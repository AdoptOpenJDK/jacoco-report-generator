<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JSlider.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JSlider.java</span></div><h1>JSlider.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing;

import javax.swing.event.*;
import javax.swing.plaf.*;
import javax.accessibility.*;

import java.io.Serializable;
import java.io.ObjectOutputStream;
import java.io.IOException;

import java.awt.*;
import java.util.*;
import java.beans.*;


/**
 * A component that lets the user graphically select a value by sliding
 * a knob within a bounded interval. The knob is always positioned
 * at the points that match integer values within the specified interval.
 * &lt;p&gt;
 * The slider can show both
 * major tick marks, and minor tick marks between the major ones.  The number of
 * values between the tick marks is controlled with
 * &lt;code&gt;setMajorTickSpacing&lt;/code&gt; and &lt;code&gt;setMinorTickSpacing&lt;/code&gt;.
 * Painting of tick marks is controlled by {@code setPaintTicks}.
 * &lt;p&gt;
 * Sliders can also print text labels at regular intervals (or at
 * arbitrary locations) along the slider track.  Painting of labels is
 * controlled by {@code setLabelTable} and {@code setPaintLabels}.
 * &lt;p&gt;
 * For further information and examples see
 * &lt;a
 href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/slider.html&quot;&gt;How to Use Sliders&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @beaninfo
 *      attribute: isContainer false
 *    description: A component that supports selecting a integer value from a range.
 *
 * @author David Kloba
 */
public class JSlider extends JComponent implements SwingConstants, Accessible {
    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;SliderUI&quot;;

<span class="nc" id="L88">    private boolean paintTicks = false;</span>
<span class="nc" id="L89">    private boolean paintTrack = true;</span>
<span class="nc" id="L90">    private boolean paintLabels = false;</span>
<span class="nc" id="L91">    private boolean isInverted = false;</span>

    /**
     * The data model that handles the numeric maximum value,
     * minimum value, and current-position value for the slider.
     */
    protected BoundedRangeModel sliderModel;

    /**
     * The number of values between the major tick marks -- the
     * larger marks that break up the minor tick marks.
     */
    protected int majorTickSpacing;

    /**
     * The number of values between the minor tick marks -- the
     * smaller marks that occur between the major tick marks.
     * @see #setMinorTickSpacing
     */
    protected int minorTickSpacing;

    /**
     * If true, the knob (and the data value it represents)
     * resolve to the closest tick mark next to where the user
     * positioned the knob.  The default is false.
     * @see #setSnapToTicks
     */
<span class="nc" id="L118">    protected boolean snapToTicks = false;</span>

    /**
     * If true, the knob (and the data value it represents)
     * resolve to the closest slider value next to where the user
     * positioned the knob.
     */
<span class="nc" id="L125">    boolean snapToValue = true;</span>

    /**
     * Whether the slider is horizontal or vertical
     * The default is horizontal.
     *
     * @see #setOrientation
     */
    protected int orientation;


    /**
     * {@code Dictionary} of what labels to draw at which values
     */
    private Dictionary labelTable;


    /**
     * The changeListener (no suffix) is the listener we add to the
     * slider's model.  This listener is initialized to the
     * {@code ChangeListener} returned from {@code createChangeListener},
     * which by default just forwards events
     * to {@code ChangeListener}s (if any) added directly to the slider.
     *
     * @see #addChangeListener
     * @see #createChangeListener
     */
<span class="nc" id="L152">    protected ChangeListener changeListener = createChangeListener();</span>


    /**
     * Only one &lt;code&gt;ChangeEvent&lt;/code&gt; is needed per slider instance since the
     * event's only (read-only) state is the source property.  The source
     * of events generated here is always &quot;this&quot;. The event is lazily
     * created the first time that an event notification is fired.
     *
     * @see #fireStateChanged
     */
<span class="nc" id="L163">    protected transient ChangeEvent changeEvent = null;</span>


    private void checkOrientation(int orientation) {
<span class="nc bnc" id="L167" title="All 2 branches missed.">        switch (orientation) {</span>
        case VERTICAL:
        case HORIZONTAL:
<span class="nc" id="L170">            break;</span>
        default:
<span class="nc" id="L172">            throw new IllegalArgumentException(&quot;orientation must be one of: VERTICAL, HORIZONTAL&quot;);</span>
        }
<span class="nc" id="L174">    }</span>


    /**
     * Creates a horizontal slider with the range 0 to 100 and
     * an initial value of 50.
     */
    public JSlider() {
<span class="nc" id="L182">        this(HORIZONTAL, 0, 100, 50);</span>
<span class="nc" id="L183">    }</span>


    /**
     * Creates a slider using the specified orientation with the
     * range {@code 0} to {@code 100} and an initial value of {@code 50}.
     * The orientation can be
     * either &lt;code&gt;SwingConstants.VERTICAL&lt;/code&gt; or
     * &lt;code&gt;SwingConstants.HORIZONTAL&lt;/code&gt;.
     *
     * @param  orientation  the orientation of the slider
     * @throws IllegalArgumentException if orientation is not one of {@code VERTICAL}, {@code HORIZONTAL}
     * @see #setOrientation
     */
    public JSlider(int orientation) {
<span class="nc" id="L198">        this(orientation, 0, 100, 50);</span>
<span class="nc" id="L199">    }</span>


    /**
     * Creates a horizontal slider using the specified min and max
     * with an initial value equal to the average of the min plus max.
     * &lt;p&gt;
     * The &lt;code&gt;BoundedRangeModel&lt;/code&gt; that holds the slider's data
     * handles any issues that may arise from improperly setting the
     * minimum and maximum values on the slider.  See the
     * {@code BoundedRangeModel} documentation for details.
     *
     * @param min  the minimum value of the slider
     * @param max  the maximum value of the slider
     *
     * @see BoundedRangeModel
     * @see #setMinimum
     * @see #setMaximum
     */
    public JSlider(int min, int max) {
<span class="nc" id="L219">        this(HORIZONTAL, min, max, (min + max) / 2);</span>
<span class="nc" id="L220">    }</span>


    /**
     * Creates a horizontal slider using the specified min, max and value.
     * &lt;p&gt;
     * The &lt;code&gt;BoundedRangeModel&lt;/code&gt; that holds the slider's data
     * handles any issues that may arise from improperly setting the
     * minimum, initial, and maximum values on the slider.  See the
     * {@code BoundedRangeModel} documentation for details.
     *
     * @param min  the minimum value of the slider
     * @param max  the maximum value of the slider
     * @param value  the initial value of the slider
     *
     * @see BoundedRangeModel
     * @see #setMinimum
     * @see #setMaximum
     * @see #setValue
     */
    public JSlider(int min, int max, int value) {
<span class="nc" id="L241">        this(HORIZONTAL, min, max, value);</span>
<span class="nc" id="L242">    }</span>


    /**
     * Creates a slider with the specified orientation and the
     * specified minimum, maximum, and initial values.
     * The orientation can be
     * either &lt;code&gt;SwingConstants.VERTICAL&lt;/code&gt; or
     * &lt;code&gt;SwingConstants.HORIZONTAL&lt;/code&gt;.
     * &lt;p&gt;
     * The &lt;code&gt;BoundedRangeModel&lt;/code&gt; that holds the slider's data
     * handles any issues that may arise from improperly setting the
     * minimum, initial, and maximum values on the slider.  See the
     * {@code BoundedRangeModel} documentation for details.
     *
     * @param orientation  the orientation of the slider
     * @param min  the minimum value of the slider
     * @param max  the maximum value of the slider
     * @param value  the initial value of the slider
     *
     * @throws IllegalArgumentException if orientation is not one of {@code VERTICAL}, {@code HORIZONTAL}
     *
     * @see BoundedRangeModel
     * @see #setOrientation
     * @see #setMinimum
     * @see #setMaximum
     * @see #setValue
     */
    public JSlider(int orientation, int min, int max, int value)
<span class="nc" id="L271">    {</span>
<span class="nc" id="L272">        checkOrientation(orientation);</span>
<span class="nc" id="L273">        this.orientation = orientation;</span>
<span class="nc" id="L274">        setModel(new DefaultBoundedRangeModel(value, 0, min, max));</span>
<span class="nc" id="L275">        updateUI();</span>
<span class="nc" id="L276">    }</span>


    /**
     * Creates a horizontal slider using the specified
     * BoundedRangeModel.
     */
    public JSlider(BoundedRangeModel brm)
<span class="nc" id="L284">    {</span>
<span class="nc" id="L285">        this.orientation = JSlider.HORIZONTAL;</span>
<span class="nc" id="L286">        setModel(brm);</span>
<span class="nc" id="L287">        updateUI();</span>
<span class="nc" id="L288">    }</span>


    /**
     * Gets the UI object which implements the L&amp;amp;F for this component.
     *
     * @return the SliderUI object that implements the Slider L&amp;amp;F
     */
    public SliderUI getUI() {
<span class="nc" id="L297">        return(SliderUI)ui;</span>
    }


    /**
     * Sets the UI object which implements the L&amp;amp;F for this component.
     *
     * @param ui the SliderUI L&amp;amp;F object
     * @see UIDefaults#getUI
     * @beaninfo
     *        bound: true
     *       hidden: true
     *    attribute: visualUpdate true
     *  description: The UI object that implements the slider's LookAndFeel.
     */
    public void setUI(SliderUI ui) {
<span class="nc" id="L313">        super.setUI(ui);</span>
<span class="nc" id="L314">    }</span>


    /**
     * Resets the UI property to a value from the current look and feel.
     *
     * @see JComponent#updateUI
     */
    public void updateUI() {
<span class="nc" id="L323">        setUI((SliderUI)UIManager.getUI(this));</span>
        // The labels preferred size may be derived from the font
        // of the slider, so we must update the UI of the slider first, then
        // that of labels.  This way when setSize is called the right
        // font is used.
<span class="nc" id="L328">        updateLabelUIs();</span>
<span class="nc" id="L329">    }</span>


    /**
     * Returns the name of the L&amp;amp;F class that renders this component.
     *
     * @return &quot;SliderUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L340">        return uiClassID;</span>
    }


    /**
     * We pass Change events along to the listeners with the
     * the slider (instead of the model itself) as the event source.
     */
<span class="nc" id="L348">    private class ModelListener implements ChangeListener, Serializable {</span>
        public void stateChanged(ChangeEvent e) {
<span class="nc" id="L350">            fireStateChanged();</span>
<span class="nc" id="L351">        }</span>
    }


    /**
     * Subclasses that want to handle {@code ChangeEvent}s
     * from the model differently
     * can override this to return
     * an instance of a custom &lt;code&gt;ChangeListener&lt;/code&gt; implementation.
     * The default {@code ChangeListener} simply calls the
     * {@code fireStateChanged} method to forward {@code ChangeEvent}s
     * to the {@code ChangeListener}s that have been added directly to the
     * slider.
     * @see #changeListener
     * @see #fireStateChanged
     * @see javax.swing.event.ChangeListener
     * @see javax.swing.BoundedRangeModel
     */
    protected ChangeListener createChangeListener() {
<span class="nc" id="L370">        return new ModelListener();</span>
    }


    /**
     * Adds a ChangeListener to the slider.
     *
     * @param l the ChangeListener to add
     * @see #fireStateChanged
     * @see #removeChangeListener
     */
    public void addChangeListener(ChangeListener l) {
<span class="nc" id="L382">        listenerList.add(ChangeListener.class, l);</span>
<span class="nc" id="L383">    }</span>


    /**
     * Removes a ChangeListener from the slider.
     *
     * @param l the ChangeListener to remove
     * @see #fireStateChanged
     * @see #addChangeListener

     */
    public void removeChangeListener(ChangeListener l) {
<span class="nc" id="L395">        listenerList.remove(ChangeListener.class, l);</span>
<span class="nc" id="L396">    }</span>


    /**
     * Returns an array of all the &lt;code&gt;ChangeListener&lt;/code&gt;s added
     * to this JSlider with addChangeListener().
     *
     * @return all of the &lt;code&gt;ChangeListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public ChangeListener[] getChangeListeners() {
<span class="nc" id="L408">        return listenerList.getListeners(ChangeListener.class);</span>
    }


    /**
     * Send a {@code ChangeEvent}, whose source is this {@code JSlider}, to
     * all {@code ChangeListener}s that have registered interest in
     * {@code ChangeEvent}s.
     * This method is called each time a {@code ChangeEvent} is received from
     * the model.
     * &lt;p&gt;
     * The event instance is created if necessary, and stored in
     * {@code changeEvent}.
     *
     * @see #addChangeListener
     * @see EventListenerList
     */
    protected void fireStateChanged() {
<span class="nc" id="L426">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        for (int i = listeners.length - 2; i &gt;= 0; i -= 2) {</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            if (listeners[i]==ChangeListener.class) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                if (changeEvent == null) {</span>
<span class="nc" id="L430">                    changeEvent = new ChangeEvent(this);</span>
                }
<span class="nc" id="L432">                ((ChangeListener)listeners[i+1]).stateChanged(changeEvent);</span>
            }
        }
<span class="nc" id="L435">    }</span>


    /**
     * Returns the {@code BoundedRangeModel} that handles the slider's three
     * fundamental properties: minimum, maximum, value.
     *
     * @return the data model for this component
     * @see #setModel
     * @see    BoundedRangeModel
     */
    public BoundedRangeModel getModel() {
<span class="nc" id="L447">        return sliderModel;</span>
    }


    /**
     * Sets the {@code BoundedRangeModel} that handles the slider's three
     * fundamental properties: minimum, maximum, value.
     *&lt;p&gt;
     * Attempts to pass a {@code null} model to this method result in
     * undefined behavior, and, most likely, exceptions.
     *
     * @param  newModel the new, {@code non-null} &lt;code&gt;BoundedRangeModel&lt;/code&gt; to use
     *
     * @see #getModel
     * @see    BoundedRangeModel
     * @beaninfo
     *       bound: true
     * description: The sliders BoundedRangeModel.
     */
    public void setModel(BoundedRangeModel newModel)
    {
<span class="nc" id="L468">        BoundedRangeModel oldModel = getModel();</span>

<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (oldModel != null) {</span>
<span class="nc" id="L471">            oldModel.removeChangeListener(changeListener);</span>
        }

<span class="nc" id="L474">        sliderModel = newModel;</span>

<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (newModel != null) {</span>
<span class="nc" id="L477">            newModel.addChangeListener(changeListener);</span>
        }

<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (accessibleContext != null) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            accessibleContext.firePropertyChange(</span>
                                                AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,
                                                (oldModel == null
<span class="nc bnc" id="L484" title="All 2 branches missed.">                                                 ? null : Integer.valueOf(oldModel.getValue())),</span>
                                                (newModel == null
<span class="nc" id="L486">                                                 ? null : Integer.valueOf(newModel.getValue())));</span>
        }

<span class="nc" id="L489">        firePropertyChange(&quot;model&quot;, oldModel, sliderModel);</span>
<span class="nc" id="L490">    }</span>


    /**
     * Returns the slider's current value
     * from the {@code BoundedRangeModel}.
     *
     * @return  the current value of the slider
     * @see     #setValue
     * @see     BoundedRangeModel#getValue
     */
    public int getValue() {
<span class="nc" id="L502">        return getModel().getValue();</span>
    }

    /**
     * Sets the slider's current value to {@code n}.  This method
     * forwards the new value to the model.
     * &lt;p&gt;
     * The data model (an instance of {@code BoundedRangeModel})
     * handles any mathematical
     * issues arising from assigning faulty values.  See the
     * {@code BoundedRangeModel} documentation for details.
     * &lt;p&gt;
     * If the new value is different from the previous value,
     * all change listeners are notified.
     *
     * @param   n       the new value
     * @see     #getValue
     * @see     #addChangeListener
     * @see     BoundedRangeModel#setValue
     * @beaninfo
     *   preferred: true
     * description: The sliders current value.
     */
    public void setValue(int n) {
<span class="nc" id="L526">        BoundedRangeModel m = getModel();</span>
<span class="nc" id="L527">        int oldValue = m.getValue();</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (oldValue == n) {</span>
<span class="nc" id="L529">            return;</span>
        }
<span class="nc" id="L531">        m.setValue(n);</span>

<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (accessibleContext != null) {</span>
<span class="nc" id="L534">            accessibleContext.firePropertyChange(</span>
                                                AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,
<span class="nc" id="L536">                                                Integer.valueOf(oldValue),</span>
<span class="nc" id="L537">                                                Integer.valueOf(m.getValue()));</span>
        }
<span class="nc" id="L539">    }</span>


    /**
     * Returns the minimum value supported by the slider
     * from the &lt;code&gt;BoundedRangeModel&lt;/code&gt;.
     *
     * @return the value of the model's minimum property
     * @see #setMinimum
     * @see     BoundedRangeModel#getMinimum
     */
    public int getMinimum() {
<span class="nc" id="L551">        return getModel().getMinimum();</span>
    }


    /**
     * Sets the slider's minimum value to {@code minimum}.  This method
     * forwards the new minimum value to the model.
     * &lt;p&gt;
     * The data model (an instance of {@code BoundedRangeModel})
     * handles any mathematical
     * issues arising from assigning faulty values.  See the
     * {@code BoundedRangeModel} documentation for details.
     * &lt;p&gt;
     * If the new minimum value is different from the previous minimum value,
     * all change listeners are notified.
     *
     * @param minimum  the new minimum
     * @see #getMinimum
     * @see    #addChangeListener
     * @see BoundedRangeModel#setMinimum
     * @beaninfo
     *       bound: true
     *   preferred: true
     * description: The sliders minimum value.
     */
    public void setMinimum(int minimum) {
<span class="nc" id="L577">        int oldMin = getModel().getMinimum();</span>
<span class="nc" id="L578">        getModel().setMinimum(minimum);</span>
<span class="nc" id="L579">        firePropertyChange( &quot;minimum&quot;, Integer.valueOf( oldMin ), Integer.valueOf( minimum ) );</span>
<span class="nc" id="L580">    }</span>


    /**
     * Returns the maximum value supported by the slider
     * from the &lt;code&gt;BoundedRangeModel&lt;/code&gt;.
     *
     * @return the value of the model's maximum property
     * @see #setMaximum
     * @see BoundedRangeModel#getMaximum
     */
    public int getMaximum() {
<span class="nc" id="L592">        return getModel().getMaximum();</span>
    }


    /**
     * Sets the slider's maximum value to {@code maximum}.  This method
     * forwards the new maximum value to the model.
     * &lt;p&gt;
     * The data model (an instance of {@code BoundedRangeModel})
     * handles any mathematical
     * issues arising from assigning faulty values.  See the
     * {@code BoundedRangeModel} documentation for details.
     * &lt;p&gt;
     * If the new maximum value is different from the previous maximum value,
     * all change listeners are notified.
     *
     * @param maximum  the new maximum
     * @see #getMaximum
     * @see #addChangeListener
     * @see BoundedRangeModel#setMaximum
     * @beaninfo
     *       bound: true
     *   preferred: true
     * description: The sliders maximum value.
     */
    public void setMaximum(int maximum) {
<span class="nc" id="L618">        int oldMax = getModel().getMaximum();</span>
<span class="nc" id="L619">        getModel().setMaximum(maximum);</span>
<span class="nc" id="L620">        firePropertyChange( &quot;maximum&quot;, Integer.valueOf( oldMax ), Integer.valueOf( maximum ) );</span>
<span class="nc" id="L621">    }</span>


    /**
     * Returns the {@code valueIsAdjusting} property from the model.  For
     * details on how this is used, see the {@code setValueIsAdjusting}
     * documentation.
     *
     * @return the value of the model's {@code valueIsAdjusting} property
     * @see #setValueIsAdjusting
     */
    public boolean getValueIsAdjusting() {
<span class="nc" id="L633">        return getModel().getValueIsAdjusting();</span>
    }


    /**
     * Sets the model's {@code valueIsAdjusting} property.  Slider look and
     * feel implementations should set this property to {@code true} when
     * a knob drag begins, and to {@code false} when the drag ends.
     *
     * @param b the new value for the {@code valueIsAdjusting} property
     * @see   #getValueIsAdjusting
     * @see   BoundedRangeModel#setValueIsAdjusting
     * @beaninfo
     *      expert: true
     * description: True if the slider knob is being dragged.
     */
    public void setValueIsAdjusting(boolean b) {
<span class="nc" id="L650">        BoundedRangeModel m = getModel();</span>
<span class="nc" id="L651">        boolean oldValue = m.getValueIsAdjusting();</span>
<span class="nc" id="L652">        m.setValueIsAdjusting(b);</span>

<span class="nc bnc" id="L654" title="All 4 branches missed.">        if ((oldValue != b) &amp;&amp; (accessibleContext != null)) {</span>
<span class="nc bnc" id="L655" title="All 4 branches missed.">            accessibleContext.firePropertyChange(</span>
                                                AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                ((oldValue) ? AccessibleState.BUSY : null),
                                                ((b) ? AccessibleState.BUSY : null));
        }
<span class="nc" id="L660">    }</span>


    /**
     * Returns the &quot;extent&quot; from the &lt;code&gt;BoundedRangeModel&lt;/code&gt;.
     * This represents the range of values &quot;covered&quot; by the knob.
     *
     * @return an int representing the extent
     * @see #setExtent
     * @see BoundedRangeModel#getExtent
     */
    public int getExtent() {
<span class="nc" id="L672">        return getModel().getExtent();</span>
    }


    /**
     * Sets the size of the range &quot;covered&quot; by the knob.  Most look
     * and feel implementations will change the value by this amount
     * if the user clicks on either side of the knob.  This method just
     * forwards the new extent value to the model.
     * &lt;p&gt;
     * The data model (an instance of {@code BoundedRangeModel})
     * handles any mathematical
     * issues arising from assigning faulty values.  See the
     * {@code BoundedRangeModel} documentation for details.
     * &lt;p&gt;
     * If the new extent value is different from the previous extent value,
     * all change listeners are notified.
     *
     * @param extent the new extent
     * @see   #getExtent
     * @see   BoundedRangeModel#setExtent
     * @beaninfo
     *      expert: true
     * description: Size of the range covered by the knob.
     */
    public void setExtent(int extent) {
<span class="nc" id="L698">        getModel().setExtent(extent);</span>
<span class="nc" id="L699">    }</span>


    /**
     * Return this slider's vertical or horizontal orientation.
     * @return {@code SwingConstants.VERTICAL} or
     *  {@code SwingConstants.HORIZONTAL}
     * @see #setOrientation
     */
    public int getOrientation() {
<span class="nc" id="L709">        return orientation;</span>
    }


    /**
     * Set the slider's orientation to either {@code SwingConstants.VERTICAL} or
     * {@code SwingConstants.HORIZONTAL}.
     *
     * @param orientation {@code HORIZONTAL} or {@code VERTICAL}
     * @throws IllegalArgumentException if orientation is not one of {@code VERTICAL}, {@code HORIZONTAL}
     * @see #getOrientation
     * @beaninfo
     *    preferred: true
     *        bound: true
     *    attribute: visualUpdate true
     *  description: Set the scrollbars orientation to either VERTICAL or HORIZONTAL.
     *         enum: VERTICAL JSlider.VERTICAL
     *               HORIZONTAL JSlider.HORIZONTAL
     *
     */
    public void setOrientation(int orientation)
    {
<span class="nc" id="L731">        checkOrientation(orientation);</span>
<span class="nc" id="L732">        int oldValue = this.orientation;</span>
<span class="nc" id="L733">        this.orientation = orientation;</span>
<span class="nc" id="L734">        firePropertyChange(&quot;orientation&quot;, oldValue, orientation);</span>

<span class="nc bnc" id="L736" title="All 4 branches missed.">        if ((oldValue != orientation) &amp;&amp; (accessibleContext != null)) {</span>
<span class="nc bnc" id="L737" title="All 4 branches missed.">            accessibleContext.firePropertyChange(</span>
                                                AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                                                ((oldValue == VERTICAL)
                                                 ? AccessibleState.VERTICAL : AccessibleState.HORIZONTAL),
                                                ((orientation == VERTICAL)
                                                 ? AccessibleState.VERTICAL : AccessibleState.HORIZONTAL));
        }
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if (orientation != oldValue) {</span>
<span class="nc" id="L745">            revalidate();</span>
        }
<span class="nc" id="L747">    }</span>


    /**
     * {@inheritDoc}
     *
     * @since 1.6
     */
    public void setFont(Font font) {
<span class="nc" id="L756">        super.setFont(font);</span>
<span class="nc" id="L757">        updateLabelSizes();</span>
<span class="nc" id="L758">    }</span>

    /**
     * {@inheritDoc}
     * @since 1.7
     */
    public boolean imageUpdate(Image img, int infoflags, int x, int y, int w, int h) {
<span class="nc bnc" id="L765" title="All 2 branches missed.">        if (!isShowing()) {</span>
<span class="nc" id="L766">            return false;</span>
        }

        // Check that there is a label with such image
<span class="nc" id="L770">        Enumeration elements = labelTable.elements();</span>

<span class="nc bnc" id="L772" title="All 2 branches missed.">        while (elements.hasMoreElements()) {</span>
<span class="nc" id="L773">            Component component = (Component) elements.nextElement();</span>

<span class="nc bnc" id="L775" title="All 2 branches missed.">            if (component instanceof JLabel) {</span>
<span class="nc" id="L776">                JLabel label = (JLabel) component;</span>

<span class="nc bnc" id="L778" title="All 2 branches missed.">                if (SwingUtilities.doesIconReferenceImage(label.getIcon(), img) ||</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                        SwingUtilities.doesIconReferenceImage(label.getDisabledIcon(), img)) {</span>
<span class="nc" id="L780">                    return super.imageUpdate(img, infoflags, x, y, w, h);</span>
                }
            }
<span class="nc" id="L783">        }</span>

<span class="nc" id="L785">        return false;</span>
    }

    /**
     * Returns the dictionary of what labels to draw at which values.
     *
     * @return the &lt;code&gt;Dictionary&lt;/code&gt; containing labels and
     *    where to draw them
     */
    public Dictionary getLabelTable() {
/*
        if ( labelTable == null &amp;&amp; getMajorTickSpacing() &gt; 0 ) {
            setLabelTable( createStandardLabels( getMajorTickSpacing() ) );
        }
*/
<span class="nc" id="L800">        return labelTable;</span>
    }


    /**
     * Used to specify what label will be drawn at any given value.
     * The key-value pairs are of this format:
     * &lt;code&gt;{ Integer value, java.swing.JComponent label }&lt;/code&gt;.
     * &lt;p&gt;
     * An easy way to generate a standard table of value labels is by using the
     * {@code createStandardLabels} method.
     * &lt;p&gt;
     * Once the labels have been set, this method calls {@link #updateLabelUIs}.
     * Note that the labels are only painted if the {@code paintLabels}
     * property is {@code true}.
     *
     * @param labels new {@code Dictionary} of labels, or {@code null} to
     *        remove all labels
     * @see #createStandardLabels(int)
     * @see #getLabelTable
     * @see #setPaintLabels
     * @beaninfo
     *       hidden: true
     *        bound: true
     *    attribute: visualUpdate true
     *  description: Specifies what labels will be drawn for any given value.
     */
    public void setLabelTable( Dictionary labels ) {
<span class="nc" id="L828">        Dictionary oldTable = labelTable;</span>
<span class="nc" id="L829">        labelTable = labels;</span>
<span class="nc" id="L830">        updateLabelUIs();</span>
<span class="nc" id="L831">        firePropertyChange(&quot;labelTable&quot;, oldTable, labelTable );</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">        if (labels != oldTable) {</span>
<span class="nc" id="L833">            revalidate();</span>
<span class="nc" id="L834">            repaint();</span>
        }
<span class="nc" id="L836">    }</span>


    /**
     * Updates the UIs for the labels in the label table by calling
     * {@code updateUI} on each label.  The UIs are updated from
     * the current look and feel.  The labels are also set to their
     * preferred size.
     *
     * @see #setLabelTable
     * @see JComponent#updateUI
     */
    protected void updateLabelUIs() {
<span class="nc" id="L849">        Dictionary labelTable = getLabelTable();</span>

<span class="nc bnc" id="L851" title="All 2 branches missed.">        if (labelTable == null) {</span>
<span class="nc" id="L852">            return;</span>
        }
<span class="nc" id="L854">        Enumeration labels = labelTable.keys();</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">        while ( labels.hasMoreElements() ) {</span>
<span class="nc" id="L856">            JComponent component = (JComponent) labelTable.get(labels.nextElement());</span>
<span class="nc" id="L857">            component.updateUI();</span>
<span class="nc" id="L858">            component.setSize(component.getPreferredSize());</span>
<span class="nc" id="L859">        }</span>
<span class="nc" id="L860">    }</span>

    private void updateLabelSizes() {
<span class="nc" id="L863">        Dictionary labelTable = getLabelTable();</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">        if (labelTable != null) {</span>
<span class="nc" id="L865">            Enumeration labels = labelTable.elements();</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">            while (labels.hasMoreElements()) {</span>
<span class="nc" id="L867">                JComponent component = (JComponent) labels.nextElement();</span>
<span class="nc" id="L868">                component.setSize(component.getPreferredSize());</span>
<span class="nc" id="L869">            }</span>
        }
<span class="nc" id="L871">    }</span>


    /**
     * Creates a {@code Hashtable} of numerical text labels, starting at the
     * slider minimum, and using the increment specified.
     * For example, if you call &lt;code&gt;createStandardLabels( 10 )&lt;/code&gt;
     * and the slider minimum is zero,
     * then labels will be created for the values 0, 10, 20, 30, and so on.
     * &lt;p&gt;
     * For the labels to be drawn on the slider, the returned {@code Hashtable}
     * must be passed into {@code setLabelTable}, and {@code setPaintLabels}
     * must be set to {@code true}.
     * &lt;p&gt;
     * For further details on the makeup of the returned {@code Hashtable}, see
     * the {@code setLabelTable} documentation.
     *
     * @param  increment  distance between labels in the generated hashtable
     * @return a new {@code Hashtable} of labels
     * @see #setLabelTable
     * @see #setPaintLabels
     * @throws IllegalArgumentException if {@code increment} is less than or
     *          equal to zero
     */
    public Hashtable createStandardLabels( int increment ) {
<span class="nc" id="L896">        return createStandardLabels( increment, getMinimum() );</span>
    }


    /**
     * Creates a {@code Hashtable} of numerical text labels, starting at the
     * starting point specified, and using the increment specified.
     * For example, if you call
     * &lt;code&gt;createStandardLabels( 10, 2 )&lt;/code&gt;,
     * then labels will be created for the values 2, 12, 22, 32, and so on.
     * &lt;p&gt;
     * For the labels to be drawn on the slider, the returned {@code Hashtable}
     * must be passed into {@code setLabelTable}, and {@code setPaintLabels}
     * must be set to {@code true}.
     * &lt;p&gt;
     * For further details on the makeup of the returned {@code Hashtable}, see
     * the {@code setLabelTable} documentation.
     *
     * @param  increment  distance between labels in the generated hashtable
     * @param  start      value at which the labels will begin
     * @return a new {@code Hashtable} of labels
     * @see #setLabelTable
     * @see #setPaintLabels
     * @exception IllegalArgumentException if {@code start} is
     *          out of range, or if {@code increment} is less than or equal
     *          to zero
     */
    public Hashtable createStandardLabels( int increment, int start ) {
<span class="nc bnc" id="L924" title="All 4 branches missed.">        if ( start &gt; getMaximum() || start &lt; getMinimum() ) {</span>
<span class="nc" id="L925">            throw new IllegalArgumentException( &quot;Slider label start point out of range.&quot; );</span>
        }

<span class="nc bnc" id="L928" title="All 2 branches missed.">        if ( increment &lt;= 0 ) {</span>
<span class="nc" id="L929">            throw new IllegalArgumentException( &quot;Label incremement must be &gt; 0&quot; );</span>
        }

        class SmartHashtable extends Hashtable&lt;Object, Object&gt; implements PropertyChangeListener {
<span class="nc" id="L933">            int increment = 0;</span>
<span class="nc" id="L934">            int start = 0;</span>
<span class="nc" id="L935">            boolean startAtMin = false;</span>

            class LabelUIResource extends JLabel implements UIResource {
<span class="nc" id="L938">                public LabelUIResource( String text, int alignment ) {</span>
<span class="nc" id="L939">                    super( text, alignment );</span>
<span class="nc" id="L940">                    setName(&quot;Slider.label&quot;);</span>
<span class="nc" id="L941">                }</span>

                public Font getFont() {
<span class="nc" id="L944">                    Font font = super.getFont();</span>
<span class="nc bnc" id="L945" title="All 4 branches missed.">                    if (font != null &amp;&amp; !(font instanceof UIResource)) {</span>
<span class="nc" id="L946">                        return font;</span>
                    }
<span class="nc" id="L948">                    return JSlider.this.getFont();</span>
                }

                public Color getForeground() {
<span class="nc" id="L952">                    Color fg = super.getForeground();</span>
<span class="nc bnc" id="L953" title="All 4 branches missed.">                    if (fg != null &amp;&amp; !(fg instanceof UIResource)) {</span>
<span class="nc" id="L954">                        return fg;</span>
                    }
<span class="nc bnc" id="L956" title="All 2 branches missed.">                    if (!(JSlider.this.getForeground() instanceof UIResource)) {</span>
<span class="nc" id="L957">                        return JSlider.this.getForeground();</span>
                    }
<span class="nc" id="L959">                    return fg;</span>
                }
            }

<span class="nc" id="L963">            public SmartHashtable( int increment, int start ) {</span>
<span class="nc" id="L964">                super();</span>
<span class="nc" id="L965">                this.increment = increment;</span>
<span class="nc" id="L966">                this.start = start;</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">                startAtMin = start == getMinimum();</span>
<span class="nc" id="L968">                createLabels();</span>
<span class="nc" id="L969">            }</span>

            public void propertyChange( PropertyChangeEvent e ) {
<span class="nc bnc" id="L972" title="All 4 branches missed.">                if ( e.getPropertyName().equals( &quot;minimum&quot; ) &amp;&amp; startAtMin ) {</span>
<span class="nc" id="L973">                    start = getMinimum();</span>
                }

<span class="nc bnc" id="L976" title="All 2 branches missed.">                if ( e.getPropertyName().equals( &quot;minimum&quot; ) ||</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">                     e.getPropertyName().equals( &quot;maximum&quot; ) ) {</span>

<span class="nc" id="L979">                    Enumeration keys = getLabelTable().keys();</span>
<span class="nc" id="L980">                    Hashtable&lt;Object, Object&gt; hashtable = new Hashtable&lt;Object, Object&gt;();</span>

                    // Save the labels that were added by the developer
<span class="nc bnc" id="L983" title="All 2 branches missed.">                    while ( keys.hasMoreElements() ) {</span>
<span class="nc" id="L984">                        Object key = keys.nextElement();</span>
<span class="nc" id="L985">                        Object value = labelTable.get(key);</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">                        if ( !(value instanceof LabelUIResource) ) {</span>
<span class="nc" id="L987">                            hashtable.put( key, value );</span>
                        }
<span class="nc" id="L989">                    }</span>

<span class="nc" id="L991">                    clear();</span>
<span class="nc" id="L992">                    createLabels();</span>

                    // Add the saved labels
<span class="nc" id="L995">                    keys = hashtable.keys();</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">                    while ( keys.hasMoreElements() ) {</span>
<span class="nc" id="L997">                        Object key = keys.nextElement();</span>
<span class="nc" id="L998">                        put( key, hashtable.get( key ) );</span>
<span class="nc" id="L999">                    }</span>

<span class="nc" id="L1001">                    ((JSlider)e.getSource()).setLabelTable( this );</span>
                }
<span class="nc" id="L1003">            }</span>

            void createLabels() {
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                for ( int labelIndex = start; labelIndex &lt;= getMaximum(); labelIndex += increment ) {</span>
<span class="nc" id="L1007">                    put( Integer.valueOf( labelIndex ), new LabelUIResource( &quot;&quot;+labelIndex, JLabel.CENTER ) );</span>
                }
<span class="nc" id="L1009">            }</span>
        }

<span class="nc" id="L1012">        SmartHashtable table = new SmartHashtable( increment, start );</span>

<span class="nc" id="L1014">        Dictionary labelTable = getLabelTable();</span>

<span class="nc bnc" id="L1016" title="All 4 branches missed.">        if (labelTable != null &amp;&amp; (labelTable instanceof PropertyChangeListener)) {</span>
<span class="nc" id="L1017">            removePropertyChangeListener((PropertyChangeListener) labelTable);</span>
        }

<span class="nc" id="L1020">        addPropertyChangeListener( table );</span>

<span class="nc" id="L1022">        return table;</span>
    }


    /**
     * Returns true if the value-range shown for the slider is reversed,
     *
     * @return true if the slider values are reversed from their normal order
     * @see #setInverted
     */
    public boolean getInverted() {
<span class="nc" id="L1033">        return isInverted;</span>
    }


    /**
     * Specify true to reverse the value-range shown for the slider and false to
     * put the value range in the normal order.  The order depends on the
     * slider's &lt;code&gt;ComponentOrientation&lt;/code&gt; property.  Normal (non-inverted)
     * horizontal sliders with a &lt;code&gt;ComponentOrientation&lt;/code&gt; value of
     * &lt;code&gt;LEFT_TO_RIGHT&lt;/code&gt; have their maximum on the right.
     * Normal horizontal sliders with a &lt;code&gt;ComponentOrientation&lt;/code&gt; value of
     * &lt;code&gt;RIGHT_TO_LEFT&lt;/code&gt; have their maximum on the left.  Normal vertical
     * sliders have their maximum on the top.  These labels are reversed when the
     * slider is inverted.
     * &lt;p&gt;
     * By default, the value of this property is {@code false}.
     *
     * @param b  true to reverse the slider values from their normal order
     * @beaninfo
     *        bound: true
     *    attribute: visualUpdate true
     *  description: If true reverses the slider values from their normal order
     *
     */
    public void setInverted( boolean b ) {
<span class="nc" id="L1058">        boolean oldValue = isInverted;</span>
<span class="nc" id="L1059">        isInverted = b;</span>
<span class="nc" id="L1060">        firePropertyChange(&quot;inverted&quot;, oldValue, isInverted);</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">        if (b != oldValue) {</span>
<span class="nc" id="L1062">            repaint();</span>
        }
<span class="nc" id="L1064">    }</span>


    /**
     * This method returns the major tick spacing.  The number that is returned
     * represents the distance, measured in values, between each major tick mark.
     * If you have a slider with a range from 0 to 50 and the major tick spacing
     * is set to 10, you will get major ticks next to the following values:
     * 0, 10, 20, 30, 40, 50.
     *
     * @return the number of values between major ticks
     * @see #setMajorTickSpacing
     */
    public int getMajorTickSpacing() {
<span class="nc" id="L1078">        return majorTickSpacing;</span>
    }


    /**
     * This method sets the major tick spacing.  The number that is passed in
     * represents the distance, measured in values, between each major tick mark.
     * If you have a slider with a range from 0 to 50 and the major tick spacing
     * is set to 10, you will get major ticks next to the following values:
     * 0, 10, 20, 30, 40, 50.
     * &lt;p&gt;
     * In order for major ticks to be painted, {@code setPaintTicks} must be
     * set to {@code true}.
     * &lt;p&gt;
     * This method will also set up a label table for you.
     * If there is not already a label table, and the major tick spacing is
     * {@code &gt; 0}, and {@code getPaintLabels} returns
     * {@code true}, a standard label table will be generated (by calling
     * {@code createStandardLabels}) with labels at the major tick marks.
     * For the example above, you would get text labels: &quot;0&quot;,
     * &quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;, &quot;50&quot;.
     * The label table is then set on the slider by calling
     * {@code setLabelTable}.
     *
     * @param  n  new value for the {@code majorTickSpacing} property
     * @see #getMajorTickSpacing
     * @see #setPaintTicks
     * @see #setLabelTable
     * @see #createStandardLabels(int)
     * @beaninfo
     *        bound: true
     *    attribute: visualUpdate true
     *  description: Sets the number of values between major tick marks.
     *
     */
    public void setMajorTickSpacing(int n) {
<span class="nc" id="L1114">        int oldValue = majorTickSpacing;</span>
<span class="nc" id="L1115">        majorTickSpacing = n;</span>
<span class="nc bnc" id="L1116" title="All 6 branches missed.">        if ( labelTable == null &amp;&amp; getMajorTickSpacing() &gt; 0 &amp;&amp; getPaintLabels() ) {</span>
<span class="nc" id="L1117">            setLabelTable( createStandardLabels( getMajorTickSpacing() ) );</span>
        }
<span class="nc" id="L1119">        firePropertyChange(&quot;majorTickSpacing&quot;, oldValue, majorTickSpacing);</span>
<span class="nc bnc" id="L1120" title="All 4 branches missed.">        if (majorTickSpacing != oldValue &amp;&amp; getPaintTicks()) {</span>
<span class="nc" id="L1121">            repaint();</span>
        }
<span class="nc" id="L1123">    }</span>



    /**
     * This method returns the minor tick spacing.  The number that is returned
     * represents the distance, measured in values, between each minor tick mark.
     * If you have a slider with a range from 0 to 50 and the minor tick spacing
     * is set to 10, you will get minor ticks next to the following values:
     * 0, 10, 20, 30, 40, 50.
     *
     * @return the number of values between minor ticks
     * @see #getMinorTickSpacing
     */
    public int getMinorTickSpacing() {
<span class="nc" id="L1138">        return minorTickSpacing;</span>
    }


    /**
     * This method sets the minor tick spacing.  The number that is passed in
     * represents the distance, measured in values, between each minor tick mark.
     * If you have a slider with a range from 0 to 50 and the minor tick spacing
     * is set to 10, you will get minor ticks next to the following values:
     * 0, 10, 20, 30, 40, 50.
     * &lt;p&gt;
     * In order for minor ticks to be painted, {@code setPaintTicks} must be
     * set to {@code true}.
     *
     * @param  n  new value for the {@code minorTickSpacing} property
     * @see #getMinorTickSpacing
     * @see #setPaintTicks
     * @beaninfo
     *        bound: true
     *    attribute: visualUpdate true
     *  description: Sets the number of values between minor tick marks.
     */
    public void setMinorTickSpacing(int n) {
<span class="nc" id="L1161">        int oldValue = minorTickSpacing;</span>
<span class="nc" id="L1162">        minorTickSpacing = n;</span>
<span class="nc" id="L1163">        firePropertyChange(&quot;minorTickSpacing&quot;, oldValue, minorTickSpacing);</span>
<span class="nc bnc" id="L1164" title="All 4 branches missed.">        if (minorTickSpacing != oldValue &amp;&amp; getPaintTicks()) {</span>
<span class="nc" id="L1165">            repaint();</span>
        }
<span class="nc" id="L1167">    }</span>


    /**
     * Returns true if the knob (and the data value it represents)
     * resolve to the closest tick mark next to where the user
     * positioned the knob.
     *
     * @return true if the value snaps to the nearest tick mark, else false
     * @see #setSnapToTicks
     */
    public boolean getSnapToTicks() {
<span class="nc" id="L1179">        return snapToTicks;</span>
    }


    /**
     * Returns true if the knob (and the data value it represents)
     * resolve to the closest slider value next to where the user
     * positioned the knob.
     *
     * @return true if the value snaps to the nearest slider value, else false
     * @see #setSnapToValue
     */
    boolean getSnapToValue() {
<span class="nc" id="L1192">        return snapToValue;</span>
    }


    /**
     * Specifying true makes the knob (and the data value it represents)
     * resolve to the closest tick mark next to where the user
     * positioned the knob.
     * By default, this property is {@code false}.
     *
     * @param b  true to snap the knob to the nearest tick mark
     * @see #getSnapToTicks
     * @beaninfo
     *       bound: true
     * description: If true snap the knob to the nearest tick mark.
     */
    public void setSnapToTicks(boolean b) {
<span class="nc" id="L1209">        boolean oldValue = snapToTicks;</span>
<span class="nc" id="L1210">        snapToTicks = b;</span>
<span class="nc" id="L1211">        firePropertyChange(&quot;snapToTicks&quot;, oldValue, snapToTicks);</span>
<span class="nc" id="L1212">    }</span>


    /**
     * Specifying true makes the knob (and the data value it represents)
     * resolve to the closest slider value next to where the user
     * positioned the knob. If the {@code snapToTicks} property has also been
     * set to {@code true}, the snap-to-ticks behavior will prevail.
     * By default, the snapToValue property is {@code true}.
     *
     * @param b  true to snap the knob to the nearest slider value
     * @see #getSnapToValue
     * @see #setSnapToTicks
     * @beaninfo
     *       bound: true
     * description: If true snap the knob to the nearest slider value.
     */
    void setSnapToValue(boolean b) {
<span class="nc" id="L1230">        boolean oldValue = snapToValue;</span>
<span class="nc" id="L1231">        snapToValue = b;</span>
<span class="nc" id="L1232">        firePropertyChange(&quot;snapToValue&quot;, oldValue, snapToValue);</span>
<span class="nc" id="L1233">    }</span>


    /**
     * Tells if tick marks are to be painted.
     * @return true if tick marks are painted, else false
     * @see #setPaintTicks
     */
    public boolean getPaintTicks() {
<span class="nc" id="L1242">        return paintTicks;</span>
    }


    /**
     * Determines whether tick marks are painted on the slider.
     * By default, this property is {@code false}.
     *
     * @param  b  whether or not tick marks should be painted
     * @see #getPaintTicks
     * @beaninfo
     *        bound: true
     *    attribute: visualUpdate true
     *  description: If true tick marks are painted on the slider.
     */
    public void setPaintTicks(boolean b) {
<span class="nc" id="L1258">        boolean oldValue = paintTicks;</span>
<span class="nc" id="L1259">        paintTicks = b;</span>
<span class="nc" id="L1260">        firePropertyChange(&quot;paintTicks&quot;, oldValue, paintTicks);</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">        if (paintTicks != oldValue) {</span>
<span class="nc" id="L1262">            revalidate();</span>
<span class="nc" id="L1263">            repaint();</span>
        }
<span class="nc" id="L1265">    }</span>

    /**
     * Tells if the track (area the slider slides in) is to be painted.
     * @return true if track is painted, else false
     * @see #setPaintTrack
     */
    public boolean getPaintTrack() {
<span class="nc" id="L1273">        return paintTrack;</span>
    }


    /**
     * Determines whether the track is painted on the slider.
     * By default, this property is {@code true}.
     *
     * @param  b  whether or not to paint the slider track
     * @see #getPaintTrack
     * @beaninfo
     *        bound: true
     *    attribute: visualUpdate true
     *  description: If true, the track is painted on the slider.
     */
    public void setPaintTrack(boolean b) {
<span class="nc" id="L1289">        boolean oldValue = paintTrack;</span>
<span class="nc" id="L1290">        paintTrack = b;</span>
<span class="nc" id="L1291">        firePropertyChange(&quot;paintTrack&quot;, oldValue, paintTrack);</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">        if (paintTrack != oldValue) {</span>
<span class="nc" id="L1293">            repaint();</span>
        }
<span class="nc" id="L1295">    }</span>


    /**
     * Tells if labels are to be painted.
     * @return true if labels are painted, else false
     * @see #setPaintLabels
     */
    public boolean getPaintLabels() {
<span class="nc" id="L1304">        return paintLabels;</span>
    }


    /**
     * Determines whether labels are painted on the slider.
     * &lt;p&gt;
     * This method will also set up a label table for you.
     * If there is not already a label table, and the major tick spacing is
     * {@code &gt; 0},
     * a standard label table will be generated (by calling
     * {@code createStandardLabels}) with labels at the major tick marks.
     * The label table is then set on the slider by calling
     * {@code setLabelTable}.
     * &lt;p&gt;
     * By default, this property is {@code false}.
     *
     * @param  b  whether or not to paint labels
     * @see #getPaintLabels
     * @see #getLabelTable
     * @see #createStandardLabels(int)
     * @beaninfo
     *        bound: true
     *    attribute: visualUpdate true
     *  description: If true labels are painted on the slider.
     */
    public void setPaintLabels(boolean b) {
<span class="nc" id="L1331">        boolean oldValue = paintLabels;</span>
<span class="nc" id="L1332">        paintLabels = b;</span>
<span class="nc bnc" id="L1333" title="All 4 branches missed.">        if ( labelTable == null &amp;&amp; getMajorTickSpacing() &gt; 0 ) {</span>
<span class="nc" id="L1334">            setLabelTable( createStandardLabels( getMajorTickSpacing() ) );</span>
        }
<span class="nc" id="L1336">        firePropertyChange(&quot;paintLabels&quot;, oldValue, paintLabels);</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">        if (paintLabels != oldValue) {</span>
<span class="nc" id="L1338">            revalidate();</span>
<span class="nc" id="L1339">            repaint();</span>
        }
<span class="nc" id="L1341">    }</span>


    /**
     * See readObject() and writeObject() in JComponent for more
     * information about serialization in Swing.
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L1349">        s.defaultWriteObject();</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">        if (getUIClassID().equals(uiClassID)) {</span>
<span class="nc" id="L1351">            byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L1352">            JComponent.setWriteObjCounter(this, --count);</span>
<span class="nc bnc" id="L1353" title="All 4 branches missed.">            if (count == 0 &amp;&amp; ui != null) {</span>
<span class="nc" id="L1354">                ui.installUI(this);</span>
            }
        }
<span class="nc" id="L1357">    }</span>


    /**
     * Returns a string representation of this JSlider. This method
     * is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this JSlider.
     */
    protected String paramString() {
<span class="nc bnc" id="L1370" title="All 2 branches missed.">        String paintTicksString = (paintTicks ?</span>
                                   &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L1372" title="All 2 branches missed.">        String paintTrackString = (paintTrack ?</span>
                                   &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L1374" title="All 2 branches missed.">        String paintLabelsString = (paintLabels ?</span>
                                    &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L1376" title="All 2 branches missed.">        String isInvertedString = (isInverted ?</span>
                                   &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L1378" title="All 2 branches missed.">        String snapToTicksString = (snapToTicks ?</span>
                                    &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        String snapToValueString = (snapToValue ?</span>
                                    &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L1382" title="All 2 branches missed.">        String orientationString = (orientation == HORIZONTAL ?</span>
                                    &quot;HORIZONTAL&quot; : &quot;VERTICAL&quot;);

<span class="nc" id="L1385">        return super.paramString() +</span>
        &quot;,isInverted=&quot; + isInvertedString +
        &quot;,majorTickSpacing=&quot; + majorTickSpacing +
        &quot;,minorTickSpacing=&quot; + minorTickSpacing +
        &quot;,orientation=&quot; + orientationString +
        &quot;,paintLabels=&quot; + paintLabelsString +
        &quot;,paintTicks=&quot; + paintTicksString +
        &quot;,paintTrack=&quot; + paintTrackString +
        &quot;,snapToTicks=&quot; + snapToTicksString +
        &quot;,snapToValue=&quot; + snapToValueString;
    }


/////////////////
// Accessibility support
////////////////

    /**
     * Gets the AccessibleContext associated with this JSlider.
     * For sliders, the AccessibleContext takes the form of an
     * AccessibleJSlider.
     * A new AccessibleJSlider instance is created if necessary.
     *
     * @return an AccessibleJSlider that serves as the
     *         AccessibleContext of this JSlider
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L1412" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L1413">            accessibleContext = new AccessibleJSlider();</span>
        }
<span class="nc" id="L1415">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JSlider&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to slider user-interface elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
<span class="nc" id="L1432">    protected class AccessibleJSlider extends AccessibleJComponent</span>
    implements AccessibleValue {

        /**
         * Get the state set of this object.
         *
         * @return an instance of AccessibleState containing the current state
         * of the object
         * @see AccessibleState
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L1443">            AccessibleStateSet states = super.getAccessibleStateSet();</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">            if (getValueIsAdjusting()) {</span>
<span class="nc" id="L1445">                states.add(AccessibleState.BUSY);</span>
            }
<span class="nc bnc" id="L1447" title="All 2 branches missed.">            if (getOrientation() == VERTICAL) {</span>
<span class="nc" id="L1448">                states.add(AccessibleState.VERTICAL);</span>
            }
            else {
<span class="nc" id="L1451">                states.add(AccessibleState.HORIZONTAL);</span>
            }
<span class="nc" id="L1453">            return states;</span>
        }

        /**
         * Get the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of the object
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L1462">            return AccessibleRole.SLIDER;</span>
        }

        /**
         * Get the AccessibleValue associated with this object.  In the
         * implementation of the Java Accessibility API for this class,
         * return this object, which is responsible for implementing the
         * AccessibleValue interface on behalf of itself.
         *
         * @return this object
         */
        public AccessibleValue getAccessibleValue() {
<span class="nc" id="L1474">            return this;</span>
        }

        /**
         * Get the accessible value of this object.
         *
         * @return The current value of this object.
         */
        public Number getCurrentAccessibleValue() {
<span class="nc" id="L1483">            return Integer.valueOf(getValue());</span>
        }

        /**
         * Set the value of this object as a Number.
         *
         * @return True if the value was set.
         */
        public boolean setCurrentAccessibleValue(Number n) {
            // TIGER - 4422535
<span class="nc bnc" id="L1493" title="All 2 branches missed.">            if (n == null) {</span>
<span class="nc" id="L1494">                return false;</span>
            }
<span class="nc" id="L1496">            setValue(n.intValue());</span>
<span class="nc" id="L1497">            return true;</span>
        }

        /**
         * Get the minimum accessible value of this object.
         *
         * @return The minimum value of this object.
         */
        public Number getMinimumAccessibleValue() {
<span class="nc" id="L1506">            return Integer.valueOf(getMinimum());</span>
        }

        /**
         * Get the maximum accessible value of this object.
         *
         * @return The maximum value of this object.
         */
        public Number getMaximumAccessibleValue() {
            // TIGER - 4422362
<span class="nc" id="L1516">            BoundedRangeModel model = JSlider.this.getModel();</span>
<span class="nc" id="L1517">            return Integer.valueOf(model.getMaximum() - model.getExtent());</span>
        }
    } // AccessibleJSlider
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>