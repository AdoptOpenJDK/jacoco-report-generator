<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>JSpinner.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JSpinner.java</span></div><h1>JSpinner.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing;

import java.awt.*;
import java.awt.event.*;

import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.plaf.SpinnerUI;

import java.util.*;
import java.beans.*;
import java.text.*;
import java.io.*;
import java.text.spi.DateFormatProvider;
import java.text.spi.NumberFormatProvider;

import javax.accessibility.*;
import sun.util.locale.provider.LocaleProviderAdapter;
import sun.util.locale.provider.LocaleResources;
import sun.util.locale.provider.LocaleServiceProviderPool;


/**
 * A single line input field that lets the user select a
 * number or an object value from an ordered sequence. Spinners typically
 * provide a pair of tiny arrow buttons for stepping through the elements
 * of the sequence. The keyboard up/down arrow keys also cycle through the
 * elements. The user may also be allowed to type a (legal) value directly
 * into the spinner. Although combo boxes provide similar functionality,
 * spinners are sometimes preferred because they don't require a drop down list
 * that can obscure important data.
 * &lt;p&gt;
 * A &lt;code&gt;JSpinner&lt;/code&gt;'s sequence value is defined by its
 * &lt;code&gt;SpinnerModel&lt;/code&gt;.
 * The &lt;code&gt;model&lt;/code&gt; can be specified as a constructor argument and
 * changed with the &lt;code&gt;model&lt;/code&gt; property.  &lt;code&gt;SpinnerModel&lt;/code&gt;
 * classes for some common types are provided: &lt;code&gt;SpinnerListModel&lt;/code&gt;,
 * &lt;code&gt;SpinnerNumberModel&lt;/code&gt;, and &lt;code&gt;SpinnerDateModel&lt;/code&gt;.
 * &lt;p&gt;
 * A &lt;code&gt;JSpinner&lt;/code&gt; has a single child component that's
 * responsible for displaying
 * and potentially changing the current element or &lt;i&gt;value&lt;/i&gt; of
 * the model, which is called the &lt;code&gt;editor&lt;/code&gt;.  The editor is created
 * by the &lt;code&gt;JSpinner&lt;/code&gt;'s constructor and can be changed with the
 * &lt;code&gt;editor&lt;/code&gt; property.  The &lt;code&gt;JSpinner&lt;/code&gt;'s editor stays
 * in sync with the model by listening for &lt;code&gt;ChangeEvent&lt;/code&gt;s. If the
 * user has changed the value displayed by the &lt;code&gt;editor&lt;/code&gt; it is
 * possible for the &lt;code&gt;model&lt;/code&gt;'s value to differ from that of
 * the &lt;code&gt;editor&lt;/code&gt;. To make sure the &lt;code&gt;model&lt;/code&gt; has the same
 * value as the editor use the &lt;code&gt;commitEdit&lt;/code&gt; method, eg:
 * &lt;pre&gt;
 *   try {
 *       spinner.commitEdit();
 *   }
 *   catch (ParseException pe) {{
 *       // Edited value is invalid, spinner.getValue() will return
 *       // the last valid value, you could revert the spinner to show that:
 *       JComponent editor = spinner.getEditor()
 *       if (editor instanceof DefaultEditor) {
 *           ((DefaultEditor)editor).getTextField().setValue(spinner.getValue();
 *       }
 *       // reset the value to some known value:
 *       spinner.setValue(fallbackValue);
 *       // or treat the last valid value as the current, in which
 *       // case you don't need to do anything.
 *   }
 *   return spinner.getValue();
 * &lt;/pre&gt;
 * &lt;p&gt;
 * For information and examples of using spinner see
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/spinner.html&quot;&gt;How to Use Spinners&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @beaninfo
 *   attribute: isContainer false
 * description: A single line input field that lets the user select a
 *     number or an object value from an ordered set.
 *
 * @see SpinnerModel
 * @see AbstractSpinnerModel
 * @see SpinnerListModel
 * @see SpinnerNumberModel
 * @see SpinnerDateModel
 * @see JFormattedTextField
 *
 * @author Hans Muller
 * @author Lynn Monsanto (accessibility)
 * @since 1.4
 */
public class JSpinner extends JComponent implements Accessible
{
    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;SpinnerUI&quot;;

<span class="nc" id="L137">    private static final Action DISABLED_ACTION = new DisabledAction();</span>

    private SpinnerModel model;
    private JComponent editor;
    private ChangeListener modelListener;
    private transient ChangeEvent changeEvent;
<span class="nc" id="L143">    private boolean editorExplicitlySet = false;</span>


    /**
     * Constructs a spinner for the given model. The spinner has
     * a set of previous/next buttons, and an editor appropriate
     * for the model.
     *
     * @throws NullPointerException if the model is {@code null}
     */
<span class="nc" id="L153">    public JSpinner(SpinnerModel model) {</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (model == null) {</span>
<span class="nc" id="L155">            throw new NullPointerException(&quot;model cannot be null&quot;);</span>
        }
<span class="nc" id="L157">        this.model = model;</span>
<span class="nc" id="L158">        this.editor = createEditor(model);</span>
<span class="nc" id="L159">        setUIProperty(&quot;opaque&quot;,true);</span>
<span class="nc" id="L160">        updateUI();</span>
<span class="nc" id="L161">    }</span>


    /**
     * Constructs a spinner with an &lt;code&gt;Integer SpinnerNumberModel&lt;/code&gt;
     * with initial value 0 and no minimum or maximum limits.
     */
    public JSpinner() {
<span class="nc" id="L169">        this(new SpinnerNumberModel());</span>
<span class="nc" id="L170">    }</span>


    /**
     * Returns the look and feel (L&amp;amp;F) object that renders this component.
     *
     * @return the &lt;code&gt;SpinnerUI&lt;/code&gt; object that renders this component
     */
    public SpinnerUI getUI() {
<span class="nc" id="L179">        return (SpinnerUI)ui;</span>
    }


    /**
     * Sets the look and feel (L&amp;amp;F) object that renders this component.
     *
     * @param ui  the &lt;code&gt;SpinnerUI&lt;/code&gt; L&amp;amp;F object
     * @see UIDefaults#getUI
     */
    public void setUI(SpinnerUI ui) {
<span class="nc" id="L190">        super.setUI(ui);</span>
<span class="nc" id="L191">    }</span>


    /**
     * Returns the suffix used to construct the name of the look and feel
     * (L&amp;amp;F) class used to render this component.
     *
     * @return the string &quot;SpinnerUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L203">        return uiClassID;</span>
    }



    /**
     * Resets the UI property with the value from the current look and feel.
     *
     * @see UIManager#getUI
     */
    public void updateUI() {
<span class="nc" id="L214">        setUI((SpinnerUI)UIManager.getUI(this));</span>
<span class="nc" id="L215">        invalidate();</span>
<span class="nc" id="L216">    }</span>


    /**
     * This method is called by the constructors to create the
     * &lt;code&gt;JComponent&lt;/code&gt;
     * that displays the current value of the sequence.  The editor may
     * also allow the user to enter an element of the sequence directly.
     * An editor must listen for &lt;code&gt;ChangeEvents&lt;/code&gt; on the
     * &lt;code&gt;model&lt;/code&gt; and keep the value it displays
     * in sync with the value of the model.
     * &lt;p&gt;
     * Subclasses may override this method to add support for new
     * &lt;code&gt;SpinnerModel&lt;/code&gt; classes.  Alternatively one can just
     * replace the editor created here with the &lt;code&gt;setEditor&lt;/code&gt;
     * method.  The default mapping from model type to editor is:
     * &lt;ul&gt;
     * &lt;li&gt; &lt;code&gt;SpinnerNumberModel =&amp;gt; JSpinner.NumberEditor&lt;/code&gt;
     * &lt;li&gt; &lt;code&gt;SpinnerDateModel =&amp;gt; JSpinner.DateEditor&lt;/code&gt;
     * &lt;li&gt; &lt;code&gt;SpinnerListModel =&amp;gt; JSpinner.ListEditor&lt;/code&gt;
     * &lt;li&gt; &lt;i&gt;all others&lt;/i&gt; =&amp;gt; &lt;code&gt;JSpinner.DefaultEditor&lt;/code&gt;
     * &lt;/ul&gt;
     *
     * @return a component that displays the current value of the sequence
     * @param model the value of getModel
     * @see #getModel
     * @see #setEditor
     */
    protected JComponent createEditor(SpinnerModel model) {
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (model instanceof SpinnerDateModel) {</span>
<span class="nc" id="L246">            return new DateEditor(this);</span>
        }
<span class="nc bnc" id="L248" title="All 2 branches missed.">        else if (model instanceof SpinnerListModel) {</span>
<span class="nc" id="L249">            return new ListEditor(this);</span>
        }
<span class="nc bnc" id="L251" title="All 2 branches missed.">        else if (model instanceof SpinnerNumberModel) {</span>
<span class="nc" id="L252">            return new NumberEditor(this);</span>
        }
        else {
<span class="nc" id="L255">            return new DefaultEditor(this);</span>
        }
    }


    /**
     * Changes the model that represents the value of this spinner.
     * If the editor property has not been explicitly set,
     * the editor property is (implicitly) set after the &lt;code&gt;&quot;model&quot;&lt;/code&gt;
     * &lt;code&gt;PropertyChangeEvent&lt;/code&gt; has been fired.  The editor
     * property is set to the value returned by &lt;code&gt;createEditor&lt;/code&gt;,
     * as in:
     * &lt;pre&gt;
     * setEditor(createEditor(model));
     * &lt;/pre&gt;
     *
     * @param model the new &lt;code&gt;SpinnerModel&lt;/code&gt;
     * @see #getModel
     * @see #getEditor
     * @see #setEditor
     * @throws IllegalArgumentException if model is &lt;code&gt;null&lt;/code&gt;
     *
     * @beaninfo
     *        bound: true
     *    attribute: visualUpdate true
     *  description: Model that represents the value of this spinner.
     */
    public void setModel(SpinnerModel model) {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (model == null) {</span>
<span class="nc" id="L284">            throw new IllegalArgumentException(&quot;null model&quot;);</span>
        }
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (!model.equals(this.model)) {</span>
<span class="nc" id="L287">            SpinnerModel oldModel = this.model;</span>
<span class="nc" id="L288">            this.model = model;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">            if (modelListener != null) {</span>
<span class="nc" id="L290">                oldModel.removeChangeListener(modelListener);</span>
<span class="nc" id="L291">                this.model.addChangeListener(modelListener);</span>
            }
<span class="nc" id="L293">            firePropertyChange(&quot;model&quot;, oldModel, model);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">            if (!editorExplicitlySet) {</span>
<span class="nc" id="L295">                setEditor(createEditor(model)); // sets editorExplicitlySet true</span>
<span class="nc" id="L296">                editorExplicitlySet = false;</span>
            }
<span class="nc" id="L298">            repaint();</span>
<span class="nc" id="L299">            revalidate();</span>
        }
<span class="nc" id="L301">    }</span>


    /**
     * Returns the &lt;code&gt;SpinnerModel&lt;/code&gt; that defines
     * this spinners sequence of values.
     *
     * @return the value of the model property
     * @see #setModel
     */
    public SpinnerModel getModel() {
<span class="nc" id="L312">        return model;</span>
    }


    /**
     * Returns the current value of the model, typically
     * this value is displayed by the &lt;code&gt;editor&lt;/code&gt;. If the
     * user has changed the value displayed by the &lt;code&gt;editor&lt;/code&gt; it is
     * possible for the &lt;code&gt;model&lt;/code&gt;'s value to differ from that of
     * the &lt;code&gt;editor&lt;/code&gt;, refer to the class level javadoc for examples
     * of how to deal with this.
     * &lt;p&gt;
     * This method simply delegates to the &lt;code&gt;model&lt;/code&gt;.
     * It is equivalent to:
     * &lt;pre&gt;
     * getModel().getValue()
     * &lt;/pre&gt;
     *
     * @see #setValue
     * @see SpinnerModel#getValue
     */
    public Object getValue() {
<span class="nc" id="L334">        return getModel().getValue();</span>
    }


    /**
     * Changes current value of the model, typically
     * this value is displayed by the &lt;code&gt;editor&lt;/code&gt;.
     * If the &lt;code&gt;SpinnerModel&lt;/code&gt; implementation
     * doesn't support the specified value then an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     * &lt;p&gt;
     * This method simply delegates to the &lt;code&gt;model&lt;/code&gt;.
     * It is equivalent to:
     * &lt;pre&gt;
     * getModel().setValue(value)
     * &lt;/pre&gt;
     *
     * @throws IllegalArgumentException if &lt;code&gt;value&lt;/code&gt; isn't allowed
     * @see #getValue
     * @see SpinnerModel#setValue
     */
    public void setValue(Object value) {
<span class="nc" id="L356">        getModel().setValue(value);</span>
<span class="nc" id="L357">    }</span>


    /**
     * Returns the object in the sequence that comes after the object returned
     * by &lt;code&gt;getValue()&lt;/code&gt;. If the end of the sequence has been reached
     * then return &lt;code&gt;null&lt;/code&gt;.
     * Calling this method does not effect &lt;code&gt;value&lt;/code&gt;.
     * &lt;p&gt;
     * This method simply delegates to the &lt;code&gt;model&lt;/code&gt;.
     * It is equivalent to:
     * &lt;pre&gt;
     * getModel().getNextValue()
     * &lt;/pre&gt;
     *
     * @return the next legal value or &lt;code&gt;null&lt;/code&gt; if one doesn't exist
     * @see #getValue
     * @see #getPreviousValue
     * @see SpinnerModel#getNextValue
     */
    public Object getNextValue() {
<span class="nc" id="L378">        return getModel().getNextValue();</span>
    }


    /**
     * We pass &lt;code&gt;Change&lt;/code&gt; events along to the listeners with the
     * the slider (instead of the model itself) as the event source.
     */
<span class="nc" id="L386">    private class ModelListener implements ChangeListener, Serializable {</span>
        public void stateChanged(ChangeEvent e) {
<span class="nc" id="L388">            fireStateChanged();</span>
<span class="nc" id="L389">        }</span>
    }


    /**
     * Adds a listener to the list that is notified each time a change
     * to the model occurs.  The source of &lt;code&gt;ChangeEvents&lt;/code&gt;
     * delivered to &lt;code&gt;ChangeListeners&lt;/code&gt; will be this
     * &lt;code&gt;JSpinner&lt;/code&gt;.  Note also that replacing the model
     * will not affect listeners added directly to JSpinner.
     * Applications can add listeners to  the model directly.  In that
     * case is that the source of the event would be the
     * &lt;code&gt;SpinnerModel&lt;/code&gt;.
     *
     * @param listener the &lt;code&gt;ChangeListener&lt;/code&gt; to add
     * @see #removeChangeListener
     * @see #getModel
     */
    public void addChangeListener(ChangeListener listener) {
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (modelListener == null) {</span>
<span class="nc" id="L409">            modelListener = new ModelListener();</span>
<span class="nc" id="L410">            getModel().addChangeListener(modelListener);</span>
        }
<span class="nc" id="L412">        listenerList.add(ChangeListener.class, listener);</span>
<span class="nc" id="L413">    }</span>



    /**
     * Removes a &lt;code&gt;ChangeListener&lt;/code&gt; from this spinner.
     *
     * @param listener the &lt;code&gt;ChangeListener&lt;/code&gt; to remove
     * @see #fireStateChanged
     * @see #addChangeListener
     */
    public void removeChangeListener(ChangeListener listener) {
<span class="nc" id="L425">        listenerList.remove(ChangeListener.class, listener);</span>
<span class="nc" id="L426">    }</span>


    /**
     * Returns an array of all the &lt;code&gt;ChangeListener&lt;/code&gt;s added
     * to this JSpinner with addChangeListener().
     *
     * @return all of the &lt;code&gt;ChangeListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public ChangeListener[] getChangeListeners() {
<span class="nc" id="L438">        return listenerList.getListeners(ChangeListener.class);</span>
    }


    /**
     * Sends a &lt;code&gt;ChangeEvent&lt;/code&gt;, whose source is this
     * &lt;code&gt;JSpinner&lt;/code&gt;, to each &lt;code&gt;ChangeListener&lt;/code&gt;.
     * When a &lt;code&gt;ChangeListener&lt;/code&gt; has been added
     * to the spinner, this method method is called each time
     * a &lt;code&gt;ChangeEvent&lt;/code&gt; is received from the model.
     *
     * @see #addChangeListener
     * @see #removeChangeListener
     * @see EventListenerList
     */
    protected void fireStateChanged() {
<span class="nc" id="L454">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        for (int i = listeners.length - 2; i &gt;= 0; i -= 2) {</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            if (listeners[i] == ChangeListener.class) {</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (changeEvent == null) {</span>
<span class="nc" id="L458">                    changeEvent = new ChangeEvent(this);</span>
                }
<span class="nc" id="L460">                ((ChangeListener)listeners[i+1]).stateChanged(changeEvent);</span>
            }
        }
<span class="nc" id="L463">    }</span>


    /**
     * Returns the object in the sequence that comes
     * before the object returned by &lt;code&gt;getValue()&lt;/code&gt;.
     * If the end of the sequence has been reached then
     * return &lt;code&gt;null&lt;/code&gt;. Calling this method does
     * not effect &lt;code&gt;value&lt;/code&gt;.
     * &lt;p&gt;
     * This method simply delegates to the &lt;code&gt;model&lt;/code&gt;.
     * It is equivalent to:
     * &lt;pre&gt;
     * getModel().getPreviousValue()
     * &lt;/pre&gt;
     *
     * @return the previous legal value or &lt;code&gt;null&lt;/code&gt;
     *   if one doesn't exist
     * @see #getValue
     * @see #getNextValue
     * @see SpinnerModel#getPreviousValue
     */
    public Object getPreviousValue() {
<span class="nc" id="L486">        return getModel().getPreviousValue();</span>
    }


    /**
     * Changes the &lt;code&gt;JComponent&lt;/code&gt; that displays the current value
     * of the &lt;code&gt;SpinnerModel&lt;/code&gt;.  It is the responsibility of this
     * method to &lt;i&gt;disconnect&lt;/i&gt; the old editor from the model and to
     * connect the new editor.  This may mean removing the
     * old editors &lt;code&gt;ChangeListener&lt;/code&gt; from the model or the
     * spinner itself and adding one for the new editor.
     *
     * @param editor the new editor
     * @see #getEditor
     * @see #createEditor
     * @see #getModel
     * @throws IllegalArgumentException if editor is &lt;code&gt;null&lt;/code&gt;
     *
     * @beaninfo
     *        bound: true
     *    attribute: visualUpdate true
     *  description: JComponent that displays the current value of the model
     */
    public void setEditor(JComponent editor) {
<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (editor == null) {</span>
<span class="nc" id="L511">            throw new IllegalArgumentException(&quot;null editor&quot;);</span>
        }
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (!editor.equals(this.editor)) {</span>
<span class="nc" id="L514">            JComponent oldEditor = this.editor;</span>
<span class="nc" id="L515">            this.editor = editor;</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (oldEditor instanceof DefaultEditor) {</span>
<span class="nc" id="L517">                ((DefaultEditor)oldEditor).dismiss(this);</span>
            }
<span class="nc" id="L519">            editorExplicitlySet = true;</span>
<span class="nc" id="L520">            firePropertyChange(&quot;editor&quot;, oldEditor, editor);</span>
<span class="nc" id="L521">            revalidate();</span>
<span class="nc" id="L522">            repaint();</span>
        }
<span class="nc" id="L524">    }</span>


    /**
     * Returns the component that displays and potentially
     * changes the model's value.
     *
     * @return the component that displays and potentially
     *    changes the model's value
     * @see #setEditor
     * @see #createEditor
     */
    public JComponent getEditor() {
<span class="nc" id="L537">        return editor;</span>
    }


    /**
     * Commits the currently edited value to the &lt;code&gt;SpinnerModel&lt;/code&gt;.
     * &lt;p&gt;
     * If the editor is an instance of &lt;code&gt;DefaultEditor&lt;/code&gt;, the
     * call if forwarded to the editor, otherwise this does nothing.
     *
     * @throws ParseException if the currently edited value couldn't
     *         be committed.
     */
    public void commitEdit() throws ParseException {
<span class="nc" id="L551">        JComponent editor = getEditor();</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (editor instanceof DefaultEditor) {</span>
<span class="nc" id="L553">            ((DefaultEditor)editor).commitEdit();</span>
        }
<span class="nc" id="L555">    }</span>


    /*
     * See readObject and writeObject in JComponent for more
     * information about serialization in Swing.
     *
     * @param s Stream to write to
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L565">        s.defaultWriteObject();</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">        if (getUIClassID().equals(uiClassID)) {</span>
<span class="nc" id="L567">            byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L568">            JComponent.setWriteObjCounter(this, --count);</span>
<span class="nc bnc" id="L569" title="All 4 branches missed.">            if (count == 0 &amp;&amp; ui != null) {</span>
<span class="nc" id="L570">                ui.installUI(this);</span>
            }
        }
<span class="nc" id="L573">    }</span>


    /**
     * A simple base class for more specialized editors
     * that displays a read-only view of the model's current
     * value with a &lt;code&gt;JFormattedTextField&lt;/code&gt;.  Subclasses
     * can configure the &lt;code&gt;JFormattedTextField&lt;/code&gt; to create
     * an editor that's appropriate for the type of model they
     * support and they may want to override
     * the &lt;code&gt;stateChanged&lt;/code&gt; and &lt;code&gt;propertyChanged&lt;/code&gt;
     * methods, which keep the model and the text field in sync.
     * &lt;p&gt;
     * This class defines a &lt;code&gt;dismiss&lt;/code&gt; method that removes the
     * editors &lt;code&gt;ChangeListener&lt;/code&gt; from the &lt;code&gt;JSpinner&lt;/code&gt;
     * that it's part of.   The &lt;code&gt;setEditor&lt;/code&gt; method knows about
     * &lt;code&gt;DefaultEditor.dismiss&lt;/code&gt;, so if the developer
     * replaces an editor that's derived from &lt;code&gt;JSpinner.DefaultEditor&lt;/code&gt;
     * its &lt;code&gt;ChangeListener&lt;/code&gt; connection back to the
     * &lt;code&gt;JSpinner&lt;/code&gt; will be removed.  However after that,
     * it's up to the developer to manage their editor listeners.
     * Similarly, if a subclass overrides &lt;code&gt;createEditor&lt;/code&gt;,
     * it's up to the subclasser to deal with their editor
     * subsequently being replaced (with &lt;code&gt;setEditor&lt;/code&gt;).
     * We expect that in most cases, and in editor installed
     * with &lt;code&gt;setEditor&lt;/code&gt; or created by a &lt;code&gt;createEditor&lt;/code&gt;
     * override, will not be replaced anyway.
     * &lt;p&gt;
     * This class is the &lt;code&gt;LayoutManager&lt;/code&gt; for it's single
     * &lt;code&gt;JFormattedTextField&lt;/code&gt; child.   By default the
     * child is just centered with the parents insets.
     * @since 1.4
     */
    public static class DefaultEditor extends JPanel
        implements ChangeListener, PropertyChangeListener, LayoutManager
    {
        /**
         * Constructs an editor component for the specified &lt;code&gt;JSpinner&lt;/code&gt;.
         * This &lt;code&gt;DefaultEditor&lt;/code&gt; is it's own layout manager and
         * it is added to the spinner's &lt;code&gt;ChangeListener&lt;/code&gt; list.
         * The constructor creates a single &lt;code&gt;JFormattedTextField&lt;/code&gt; child,
         * initializes it's value to be the spinner model's current value
         * and adds it to &lt;code&gt;this&lt;/code&gt; &lt;code&gt;DefaultEditor&lt;/code&gt;.
         *
         * @param spinner the spinner whose model &lt;code&gt;this&lt;/code&gt; editor will monitor
         * @see #getTextField
         * @see JSpinner#addChangeListener
         */
        public DefaultEditor(JSpinner spinner) {
<span class="nc" id="L622">            super(null);</span>

<span class="nc" id="L624">            JFormattedTextField ftf = new JFormattedTextField();</span>
<span class="nc" id="L625">            ftf.setName(&quot;Spinner.formattedTextField&quot;);</span>
<span class="nc" id="L626">            ftf.setValue(spinner.getValue());</span>
<span class="nc" id="L627">            ftf.addPropertyChangeListener(this);</span>
<span class="nc" id="L628">            ftf.setEditable(false);</span>
<span class="nc" id="L629">            ftf.setInheritsPopupMenu(true);</span>

<span class="nc" id="L631">            String toolTipText = spinner.getToolTipText();</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (toolTipText != null) {</span>
<span class="nc" id="L633">                ftf.setToolTipText(toolTipText);</span>
            }

<span class="nc" id="L636">            add(ftf);</span>

<span class="nc" id="L638">            setLayout(this);</span>
<span class="nc" id="L639">            spinner.addChangeListener(this);</span>

            // We want the spinner's increment/decrement actions to be
            // active vs those of the JFormattedTextField. As such we
            // put disabled actions in the JFormattedTextField's actionmap.
            // A binding to a disabled action is treated as a nonexistant
            // binding.
<span class="nc" id="L646">            ActionMap ftfMap = ftf.getActionMap();</span>

<span class="nc bnc" id="L648" title="All 2 branches missed.">            if (ftfMap != null) {</span>
<span class="nc" id="L649">                ftfMap.put(&quot;increment&quot;, DISABLED_ACTION);</span>
<span class="nc" id="L650">                ftfMap.put(&quot;decrement&quot;, DISABLED_ACTION);</span>
            }
<span class="nc" id="L652">        }</span>


        /**
         * Disconnect &lt;code&gt;this&lt;/code&gt; editor from the specified
         * &lt;code&gt;JSpinner&lt;/code&gt;.  By default, this method removes
         * itself from the spinners &lt;code&gt;ChangeListener&lt;/code&gt; list.
         *
         * @param spinner the &lt;code&gt;JSpinner&lt;/code&gt; to disconnect this
         *    editor from; the same spinner as was passed to the constructor.
         */
        public void dismiss(JSpinner spinner) {
<span class="nc" id="L664">            spinner.removeChangeListener(this);</span>
<span class="nc" id="L665">        }</span>


        /**
         * Returns the &lt;code&gt;JSpinner&lt;/code&gt; ancestor of this editor or
         * &lt;code&gt;null&lt;/code&gt; if none of the ancestors are a
         * &lt;code&gt;JSpinner&lt;/code&gt;.
         * Typically the editor's parent is a &lt;code&gt;JSpinner&lt;/code&gt; however
         * subclasses of &lt;code&gt;JSpinner&lt;/code&gt; may override the
         * the &lt;code&gt;createEditor&lt;/code&gt; method and insert one or more containers
         * between the &lt;code&gt;JSpinner&lt;/code&gt; and it's editor.
         *
         * @return &lt;code&gt;JSpinner&lt;/code&gt; ancestor; &lt;code&gt;null&lt;/code&gt;
         *         if none of the ancestors are a &lt;code&gt;JSpinner&lt;/code&gt;
         *
         * @see JSpinner#createEditor
         */
        public JSpinner getSpinner() {
<span class="nc bnc" id="L683" title="All 2 branches missed.">            for (Component c = this; c != null; c = c.getParent()) {</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                if (c instanceof JSpinner) {</span>
<span class="nc" id="L685">                    return (JSpinner)c;</span>
                }
            }
<span class="nc" id="L688">            return null;</span>
        }


        /**
         * Returns the &lt;code&gt;JFormattedTextField&lt;/code&gt; child of this
         * editor.  By default the text field is the first and only
         * child of editor.
         *
         * @return the &lt;code&gt;JFormattedTextField&lt;/code&gt; that gives the user
         *     access to the &lt;code&gt;SpinnerDateModel's&lt;/code&gt; value.
         * @see #getSpinner
         * @see #getModel
         */
        public JFormattedTextField getTextField() {
<span class="nc" id="L703">            return (JFormattedTextField)getComponent(0);</span>
        }


        /**
         * This method is called when the spinner's model's state changes.
         * It sets the &lt;code&gt;value&lt;/code&gt; of the text field to the current
         * value of the spinners model.
         *
         * @param e the &lt;code&gt;ChangeEvent&lt;/code&gt; whose source is the
         * &lt;code&gt;JSpinner&lt;/code&gt; whose model has changed.
         * @see #getTextField
         * @see JSpinner#getValue
         */
        public void stateChanged(ChangeEvent e) {
<span class="nc" id="L718">            JSpinner spinner = (JSpinner)(e.getSource());</span>
<span class="nc" id="L719">            getTextField().setValue(spinner.getValue());</span>
<span class="nc" id="L720">        }</span>


        /**
         * Called by the &lt;code&gt;JFormattedTextField&lt;/code&gt;
         * &lt;code&gt;PropertyChangeListener&lt;/code&gt;.  When the &lt;code&gt;&quot;value&quot;&lt;/code&gt;
         * property changes, which implies that the user has typed a new
         * number, we set the value of the spinners model.
         * &lt;p&gt;
         * This class ignores &lt;code&gt;PropertyChangeEvents&lt;/code&gt; whose
         * source is not the &lt;code&gt;JFormattedTextField&lt;/code&gt;, so subclasses
         * may safely make &lt;code&gt;this&lt;/code&gt; &lt;code&gt;DefaultEditor&lt;/code&gt; a
         * &lt;code&gt;PropertyChangeListener&lt;/code&gt; on other objects.
         *
         * @param e the &lt;code&gt;PropertyChangeEvent&lt;/code&gt; whose source is
         *    the &lt;code&gt;JFormattedTextField&lt;/code&gt; created by this class.
         * @see #getTextField
         */
        public void propertyChange(PropertyChangeEvent e)
        {
<span class="nc" id="L740">            JSpinner spinner = getSpinner();</span>

<span class="nc bnc" id="L742" title="All 2 branches missed.">            if (spinner == null) {</span>
                // Indicates we aren't installed anywhere.
<span class="nc" id="L744">                return;</span>
            }

<span class="nc" id="L747">            Object source = e.getSource();</span>
<span class="nc" id="L748">            String name = e.getPropertyName();</span>
<span class="nc bnc" id="L749" title="All 4 branches missed.">            if ((source instanceof JFormattedTextField) &amp;&amp; &quot;value&quot;.equals(name)) {</span>
<span class="nc" id="L750">                Object lastValue = spinner.getValue();</span>

                // Try to set the new value
                try {
<span class="nc" id="L754">                    spinner.setValue(getTextField().getValue());</span>
<span class="nc" id="L755">                } catch (IllegalArgumentException iae) {</span>
                    // SpinnerModel didn't like new value, reset
                    try {
<span class="nc" id="L758">                        ((JFormattedTextField)source).setValue(lastValue);</span>
<span class="nc" id="L759">                    } catch (IllegalArgumentException iae2) {</span>
                        // Still bogus, nothing else we can do, the
                        // SpinnerModel and JFormattedTextField are now out
                        // of sync.
<span class="nc" id="L763">                    }</span>
<span class="nc" id="L764">                }</span>
            }
<span class="nc" id="L766">        }</span>


        /**
         * This &lt;code&gt;LayoutManager&lt;/code&gt; method does nothing.  We're
         * only managing a single child and there's no support
         * for layout constraints.
         *
         * @param name ignored
         * @param child ignored
         */
        public void addLayoutComponent(String name, Component child) {
<span class="nc" id="L778">        }</span>


        /**
         * This &lt;code&gt;LayoutManager&lt;/code&gt; method does nothing.  There
         * isn't any per-child state.
         *
         * @param child ignored
         */
        public void removeLayoutComponent(Component child) {
<span class="nc" id="L788">        }</span>


        /**
         * Returns the size of the parents insets.
         */
        private Dimension insetSize(Container parent) {
<span class="nc" id="L795">            Insets insets = parent.getInsets();</span>
<span class="nc" id="L796">            int w = insets.left + insets.right;</span>
<span class="nc" id="L797">            int h = insets.top + insets.bottom;</span>
<span class="nc" id="L798">            return new Dimension(w, h);</span>
        }


        /**
         * Returns the preferred size of first (and only) child plus the
         * size of the parents insets.
         *
         * @param parent the Container that's managing the layout
         * @return the preferred dimensions to lay out the subcomponents
         *          of the specified container.
         */
        public Dimension preferredLayoutSize(Container parent) {
<span class="nc" id="L811">            Dimension preferredSize = insetSize(parent);</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">            if (parent.getComponentCount() &gt; 0) {</span>
<span class="nc" id="L813">                Dimension childSize = getComponent(0).getPreferredSize();</span>
<span class="nc" id="L814">                preferredSize.width += childSize.width;</span>
<span class="nc" id="L815">                preferredSize.height += childSize.height;</span>
            }
<span class="nc" id="L817">            return preferredSize;</span>
        }


        /**
         * Returns the minimum size of first (and only) child plus the
         * size of the parents insets.
         *
         * @param parent the Container that's managing the layout
         * @return  the minimum dimensions needed to lay out the subcomponents
         *          of the specified container.
         */
        public Dimension minimumLayoutSize(Container parent) {
<span class="nc" id="L830">            Dimension minimumSize = insetSize(parent);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">            if (parent.getComponentCount() &gt; 0) {</span>
<span class="nc" id="L832">                Dimension childSize = getComponent(0).getMinimumSize();</span>
<span class="nc" id="L833">                minimumSize.width += childSize.width;</span>
<span class="nc" id="L834">                minimumSize.height += childSize.height;</span>
            }
<span class="nc" id="L836">            return minimumSize;</span>
        }


        /**
         * Resize the one (and only) child to completely fill the area
         * within the parents insets.
         */
        public void layoutContainer(Container parent) {
<span class="nc bnc" id="L845" title="All 2 branches missed.">            if (parent.getComponentCount() &gt; 0) {</span>
<span class="nc" id="L846">                Insets insets = parent.getInsets();</span>
<span class="nc" id="L847">                int w = parent.getWidth() - (insets.left + insets.right);</span>
<span class="nc" id="L848">                int h = parent.getHeight() - (insets.top + insets.bottom);</span>
<span class="nc" id="L849">                getComponent(0).setBounds(insets.left, insets.top, w, h);</span>
            }
<span class="nc" id="L851">        }</span>

        /**
         * Pushes the currently edited value to the &lt;code&gt;SpinnerModel&lt;/code&gt;.
         * &lt;p&gt;
         * The default implementation invokes &lt;code&gt;commitEdit&lt;/code&gt; on the
         * &lt;code&gt;JFormattedTextField&lt;/code&gt;.
         *
         * @throws ParseException if the edited value is not legal
         */
        public void commitEdit()  throws ParseException {
            // If the value in the JFormattedTextField is legal, this will have
            // the result of pushing the value to the SpinnerModel
            // by way of the &lt;code&gt;propertyChange&lt;/code&gt; method.
<span class="nc" id="L865">            JFormattedTextField ftf = getTextField();</span>

<span class="nc" id="L867">            ftf.commitEdit();</span>
<span class="nc" id="L868">        }</span>

        /**
         * Returns the baseline.
         *
         * @throws IllegalArgumentException {@inheritDoc}
         * @see javax.swing.JComponent#getBaseline(int,int)
         * @see javax.swing.JComponent#getBaselineResizeBehavior()
         * @since 1.6
         */
        public int getBaseline(int width, int height) {
            // check size.
<span class="nc" id="L880">            super.getBaseline(width, height);</span>
<span class="nc" id="L881">            Insets insets = getInsets();</span>
<span class="nc" id="L882">            width = width - insets.left - insets.right;</span>
<span class="nc" id="L883">            height = height - insets.top - insets.bottom;</span>
<span class="nc" id="L884">            int baseline = getComponent(0).getBaseline(width, height);</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">            if (baseline &gt;= 0) {</span>
<span class="nc" id="L886">                return baseline + insets.top;</span>
            }
<span class="nc" id="L888">            return -1;</span>
        }

        /**
         * Returns an enum indicating how the baseline of the component
         * changes as the size changes.
         *
         * @throws NullPointerException {@inheritDoc}
         * @see javax.swing.JComponent#getBaseline(int, int)
         * @since 1.6
         */
        public BaselineResizeBehavior getBaselineResizeBehavior() {
<span class="nc" id="L900">            return getComponent(0).getBaselineResizeBehavior();</span>
        }
    }




    /**
     * This subclass of javax.swing.DateFormatter maps the minimum/maximum
     * properties to te start/end properties of a SpinnerDateModel.
     */
    private static class DateEditorFormatter extends DateFormatter {
        private final SpinnerDateModel model;

        DateEditorFormatter(SpinnerDateModel model, DateFormat format) {
<span class="nc" id="L915">            super(format);</span>
<span class="nc" id="L916">            this.model = model;</span>
<span class="nc" id="L917">        }</span>

        public void setMinimum(Comparable min) {
<span class="nc" id="L920">            model.setStart(min);</span>
<span class="nc" id="L921">        }</span>

        public Comparable getMinimum() {
<span class="nc" id="L924">            return  model.getStart();</span>
        }

        public void setMaximum(Comparable max) {
<span class="nc" id="L928">            model.setEnd(max);</span>
<span class="nc" id="L929">        }</span>

        public Comparable getMaximum() {
<span class="nc" id="L932">            return model.getEnd();</span>
        }
    }


    /**
     * An editor for a &lt;code&gt;JSpinner&lt;/code&gt; whose model is a
     * &lt;code&gt;SpinnerDateModel&lt;/code&gt;.  The value of the editor is
     * displayed with a &lt;code&gt;JFormattedTextField&lt;/code&gt; whose format
     * is defined by a &lt;code&gt;DateFormatter&lt;/code&gt; instance whose
     * &lt;code&gt;minimum&lt;/code&gt; and &lt;code&gt;maximum&lt;/code&gt; properties
     * are mapped to the &lt;code&gt;SpinnerDateModel&lt;/code&gt;.
     * @since 1.4
     */
    // PENDING(hmuller): more example javadoc
    public static class DateEditor extends DefaultEditor
    {
        // This is here until SimpleDateFormat gets a constructor that
        // takes a Locale: 4923525
        private static String getDefaultPattern(Locale loc) {
<span class="nc" id="L952">            LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DateFormatProvider.class, loc);</span>
<span class="nc" id="L953">            LocaleResources lr = adapter.getLocaleResources(loc);</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">            if (lr == null) {</span>
<span class="nc" id="L955">                lr = LocaleProviderAdapter.forJRE().getLocaleResources(loc);</span>
            }
<span class="nc" id="L957">            return lr.getDateTimePattern(DateFormat.SHORT, DateFormat.SHORT, null);</span>
        }

        /**
         * Construct a &lt;code&gt;JSpinner&lt;/code&gt; editor that supports displaying
         * and editing the value of a &lt;code&gt;SpinnerDateModel&lt;/code&gt;
         * with a &lt;code&gt;JFormattedTextField&lt;/code&gt;.  &lt;code&gt;This&lt;/code&gt;
         * &lt;code&gt;DateEditor&lt;/code&gt; becomes both a &lt;code&gt;ChangeListener&lt;/code&gt;
         * on the spinners model and a &lt;code&gt;PropertyChangeListener&lt;/code&gt;
         * on the new &lt;code&gt;JFormattedTextField&lt;/code&gt;.
         *
         * @param spinner the spinner whose model &lt;code&gt;this&lt;/code&gt; editor will monitor
         * @exception IllegalArgumentException if the spinners model is not
         *     an instance of &lt;code&gt;SpinnerDateModel&lt;/code&gt;
         *
         * @see #getModel
         * @see #getFormat
         * @see SpinnerDateModel
         */
        public DateEditor(JSpinner spinner) {
<span class="nc" id="L977">            this(spinner, getDefaultPattern(spinner.getLocale()));</span>
<span class="nc" id="L978">        }</span>


        /**
         * Construct a &lt;code&gt;JSpinner&lt;/code&gt; editor that supports displaying
         * and editing the value of a &lt;code&gt;SpinnerDateModel&lt;/code&gt;
         * with a &lt;code&gt;JFormattedTextField&lt;/code&gt;.  &lt;code&gt;This&lt;/code&gt;
         * &lt;code&gt;DateEditor&lt;/code&gt; becomes both a &lt;code&gt;ChangeListener&lt;/code&gt;
         * on the spinner and a &lt;code&gt;PropertyChangeListener&lt;/code&gt;
         * on the new &lt;code&gt;JFormattedTextField&lt;/code&gt;.
         *
         * @param spinner the spinner whose model &lt;code&gt;this&lt;/code&gt; editor will monitor
         * @param dateFormatPattern the initial pattern for the
         *     &lt;code&gt;SimpleDateFormat&lt;/code&gt; object that's used to display
         *     and parse the value of the text field.
         * @exception IllegalArgumentException if the spinners model is not
         *     an instance of &lt;code&gt;SpinnerDateModel&lt;/code&gt;
         *
         * @see #getModel
         * @see #getFormat
         * @see SpinnerDateModel
         * @see java.text.SimpleDateFormat
         */
        public DateEditor(JSpinner spinner, String dateFormatPattern) {
<span class="nc" id="L1002">            this(spinner, new SimpleDateFormat(dateFormatPattern,</span>
<span class="nc" id="L1003">                                               spinner.getLocale()));</span>
<span class="nc" id="L1004">        }</span>

        /**
         * Construct a &lt;code&gt;JSpinner&lt;/code&gt; editor that supports displaying
         * and editing the value of a &lt;code&gt;SpinnerDateModel&lt;/code&gt;
         * with a &lt;code&gt;JFormattedTextField&lt;/code&gt;.  &lt;code&gt;This&lt;/code&gt;
         * &lt;code&gt;DateEditor&lt;/code&gt; becomes both a &lt;code&gt;ChangeListener&lt;/code&gt;
         * on the spinner and a &lt;code&gt;PropertyChangeListener&lt;/code&gt;
         * on the new &lt;code&gt;JFormattedTextField&lt;/code&gt;.
         *
         * @param spinner the spinner whose model &lt;code&gt;this&lt;/code&gt; editor
         *        will monitor
         * @param format &lt;code&gt;DateFormat&lt;/code&gt; object that's used to display
         *     and parse the value of the text field.
         * @exception IllegalArgumentException if the spinners model is not
         *     an instance of &lt;code&gt;SpinnerDateModel&lt;/code&gt;
         *
         * @see #getModel
         * @see #getFormat
         * @see SpinnerDateModel
         * @see java.text.SimpleDateFormat
         */
        private DateEditor(JSpinner spinner, DateFormat format) {
<span class="nc" id="L1027">            super(spinner);</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">            if (!(spinner.getModel() instanceof SpinnerDateModel)) {</span>
<span class="nc" id="L1029">                throw new IllegalArgumentException(</span>
                                 &quot;model not a SpinnerDateModel&quot;);
            }

<span class="nc" id="L1033">            SpinnerDateModel model = (SpinnerDateModel)spinner.getModel();</span>
<span class="nc" id="L1034">            DateFormatter formatter = new DateEditorFormatter(model, format);</span>
<span class="nc" id="L1035">            DefaultFormatterFactory factory = new DefaultFormatterFactory(</span>
                                                  formatter);
<span class="nc" id="L1037">            JFormattedTextField ftf = getTextField();</span>
<span class="nc" id="L1038">            ftf.setEditable(true);</span>
<span class="nc" id="L1039">            ftf.setFormatterFactory(factory);</span>

            /* TBD - initializing the column width of the text field
             * is imprecise and doing it here is tricky because
             * the developer may configure the formatter later.
             */
            try {
<span class="nc" id="L1046">                String maxString = formatter.valueToString(model.getStart());</span>
<span class="nc" id="L1047">                String minString = formatter.valueToString(model.getEnd());</span>
<span class="nc" id="L1048">                ftf.setColumns(Math.max(maxString.length(),</span>
<span class="nc" id="L1049">                                        minString.length()));</span>
            }
<span class="nc" id="L1051">            catch (ParseException e) {</span>
                // PENDING: hmuller
<span class="nc" id="L1053">            }</span>
<span class="nc" id="L1054">        }</span>

        /**
         * Returns the &lt;code&gt;java.text.SimpleDateFormat&lt;/code&gt; object the
         * &lt;code&gt;JFormattedTextField&lt;/code&gt; uses to parse and format
         * numbers.
         *
         * @return the value of &lt;code&gt;getTextField().getFormatter().getFormat()&lt;/code&gt;.
         * @see #getTextField
         * @see java.text.SimpleDateFormat
         */
        public SimpleDateFormat getFormat() {
<span class="nc" id="L1066">            return (SimpleDateFormat)((DateFormatter)(getTextField().getFormatter())).getFormat();</span>
        }


        /**
         * Return our spinner ancestor's &lt;code&gt;SpinnerDateModel&lt;/code&gt;.
         *
         * @return &lt;code&gt;getSpinner().getModel()&lt;/code&gt;
         * @see #getSpinner
         * @see #getTextField
         */
        public SpinnerDateModel getModel() {
<span class="nc" id="L1078">            return (SpinnerDateModel)(getSpinner().getModel());</span>
        }
    }


    /**
     * This subclass of javax.swing.NumberFormatter maps the minimum/maximum
     * properties to a SpinnerNumberModel and initializes the valueClass
     * of the NumberFormatter to match the type of the initial models value.
     */
    private static class NumberEditorFormatter extends NumberFormatter {
        private final SpinnerNumberModel model;

        NumberEditorFormatter(SpinnerNumberModel model, NumberFormat format) {
<span class="nc" id="L1092">            super(format);</span>
<span class="nc" id="L1093">            this.model = model;</span>
<span class="nc" id="L1094">            setValueClass(model.getValue().getClass());</span>
<span class="nc" id="L1095">        }</span>

        public void setMinimum(Comparable min) {
<span class="nc" id="L1098">            model.setMinimum(min);</span>
<span class="nc" id="L1099">        }</span>

        public Comparable getMinimum() {
<span class="nc" id="L1102">            return  model.getMinimum();</span>
        }

        public void setMaximum(Comparable max) {
<span class="nc" id="L1106">            model.setMaximum(max);</span>
<span class="nc" id="L1107">        }</span>

        public Comparable getMaximum() {
<span class="nc" id="L1110">            return model.getMaximum();</span>
        }
    }



    /**
     * An editor for a &lt;code&gt;JSpinner&lt;/code&gt; whose model is a
     * &lt;code&gt;SpinnerNumberModel&lt;/code&gt;.  The value of the editor is
     * displayed with a &lt;code&gt;JFormattedTextField&lt;/code&gt; whose format
     * is defined by a &lt;code&gt;NumberFormatter&lt;/code&gt; instance whose
     * &lt;code&gt;minimum&lt;/code&gt; and &lt;code&gt;maximum&lt;/code&gt; properties
     * are mapped to the &lt;code&gt;SpinnerNumberModel&lt;/code&gt;.
     * @since 1.4
     */
    // PENDING(hmuller): more example javadoc
    public static class NumberEditor extends DefaultEditor
    {
        // This is here until DecimalFormat gets a constructor that
        // takes a Locale: 4923525
        private static String getDefaultPattern(Locale locale) {
            // Get the pattern for the default locale.
            LocaleProviderAdapter adapter;
<span class="nc" id="L1133">            adapter = LocaleProviderAdapter.getAdapter(NumberFormatProvider.class,</span>
                                                       locale);
<span class="nc" id="L1135">            LocaleResources lr = adapter.getLocaleResources(locale);</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">            if (lr == null) {</span>
<span class="nc" id="L1137">                lr = LocaleProviderAdapter.forJRE().getLocaleResources(locale);</span>
            }
<span class="nc" id="L1139">            String[] all = lr.getNumberPatterns();</span>
<span class="nc" id="L1140">            return all[0];</span>
        }

        /**
         * Construct a &lt;code&gt;JSpinner&lt;/code&gt; editor that supports displaying
         * and editing the value of a &lt;code&gt;SpinnerNumberModel&lt;/code&gt;
         * with a &lt;code&gt;JFormattedTextField&lt;/code&gt;.  &lt;code&gt;This&lt;/code&gt;
         * &lt;code&gt;NumberEditor&lt;/code&gt; becomes both a &lt;code&gt;ChangeListener&lt;/code&gt;
         * on the spinner and a &lt;code&gt;PropertyChangeListener&lt;/code&gt;
         * on the new &lt;code&gt;JFormattedTextField&lt;/code&gt;.
         *
         * @param spinner the spinner whose model &lt;code&gt;this&lt;/code&gt; editor will monitor
         * @exception IllegalArgumentException if the spinners model is not
         *     an instance of &lt;code&gt;SpinnerNumberModel&lt;/code&gt;
         *
         * @see #getModel
         * @see #getFormat
         * @see SpinnerNumberModel
         */
        public NumberEditor(JSpinner spinner) {
<span class="nc" id="L1160">            this(spinner, getDefaultPattern(spinner.getLocale()));</span>
<span class="nc" id="L1161">        }</span>

        /**
         * Construct a &lt;code&gt;JSpinner&lt;/code&gt; editor that supports displaying
         * and editing the value of a &lt;code&gt;SpinnerNumberModel&lt;/code&gt;
         * with a &lt;code&gt;JFormattedTextField&lt;/code&gt;.  &lt;code&gt;This&lt;/code&gt;
         * &lt;code&gt;NumberEditor&lt;/code&gt; becomes both a &lt;code&gt;ChangeListener&lt;/code&gt;
         * on the spinner and a &lt;code&gt;PropertyChangeListener&lt;/code&gt;
         * on the new &lt;code&gt;JFormattedTextField&lt;/code&gt;.
         *
         * @param spinner the spinner whose model &lt;code&gt;this&lt;/code&gt; editor will monitor
         * @param decimalFormatPattern the initial pattern for the
         *     &lt;code&gt;DecimalFormat&lt;/code&gt; object that's used to display
         *     and parse the value of the text field.
         * @exception IllegalArgumentException if the spinners model is not
         *     an instance of &lt;code&gt;SpinnerNumberModel&lt;/code&gt; or if
         *     &lt;code&gt;decimalFormatPattern&lt;/code&gt; is not a legal
         *     argument to &lt;code&gt;DecimalFormat&lt;/code&gt;
         *
         * @see #getTextField
         * @see SpinnerNumberModel
         * @see java.text.DecimalFormat
         */
        public NumberEditor(JSpinner spinner, String decimalFormatPattern) {
<span class="nc" id="L1185">            this(spinner, new DecimalFormat(decimalFormatPattern));</span>
<span class="nc" id="L1186">        }</span>


        /**
         * Construct a &lt;code&gt;JSpinner&lt;/code&gt; editor that supports displaying
         * and editing the value of a &lt;code&gt;SpinnerNumberModel&lt;/code&gt;
         * with a &lt;code&gt;JFormattedTextField&lt;/code&gt;.  &lt;code&gt;This&lt;/code&gt;
         * &lt;code&gt;NumberEditor&lt;/code&gt; becomes both a &lt;code&gt;ChangeListener&lt;/code&gt;
         * on the spinner and a &lt;code&gt;PropertyChangeListener&lt;/code&gt;
         * on the new &lt;code&gt;JFormattedTextField&lt;/code&gt;.
         *
         * @param spinner the spinner whose model &lt;code&gt;this&lt;/code&gt; editor will monitor
         * @param decimalFormatPattern the initial pattern for the
         *     &lt;code&gt;DecimalFormat&lt;/code&gt; object that's used to display
         *     and parse the value of the text field.
         * @exception IllegalArgumentException if the spinners model is not
         *     an instance of &lt;code&gt;SpinnerNumberModel&lt;/code&gt;
         *
         * @see #getTextField
         * @see SpinnerNumberModel
         * @see java.text.DecimalFormat
         */
        private NumberEditor(JSpinner spinner, DecimalFormat format) {
<span class="nc" id="L1209">            super(spinner);</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">            if (!(spinner.getModel() instanceof SpinnerNumberModel)) {</span>
<span class="nc" id="L1211">                throw new IllegalArgumentException(</span>
                          &quot;model not a SpinnerNumberModel&quot;);
            }

<span class="nc" id="L1215">            SpinnerNumberModel model = (SpinnerNumberModel)spinner.getModel();</span>
<span class="nc" id="L1216">            NumberFormatter formatter = new NumberEditorFormatter(model,</span>
                                                                  format);
<span class="nc" id="L1218">            DefaultFormatterFactory factory = new DefaultFormatterFactory(</span>
                                                  formatter);
<span class="nc" id="L1220">            JFormattedTextField ftf = getTextField();</span>
<span class="nc" id="L1221">            ftf.setEditable(true);</span>
<span class="nc" id="L1222">            ftf.setFormatterFactory(factory);</span>
<span class="nc" id="L1223">            ftf.setHorizontalAlignment(JTextField.RIGHT);</span>

            /* TBD - initializing the column width of the text field
             * is imprecise and doing it here is tricky because
             * the developer may configure the formatter later.
             */
            try {
<span class="nc" id="L1230">                String maxString = formatter.valueToString(model.getMinimum());</span>
<span class="nc" id="L1231">                String minString = formatter.valueToString(model.getMaximum());</span>
<span class="nc" id="L1232">                ftf.setColumns(Math.max(maxString.length(),</span>
<span class="nc" id="L1233">                                        minString.length()));</span>
            }
<span class="nc" id="L1235">            catch (ParseException e) {</span>
                // TBD should throw a chained error here
<span class="nc" id="L1237">            }</span>

<span class="nc" id="L1239">        }</span>


        /**
         * Returns the &lt;code&gt;java.text.DecimalFormat&lt;/code&gt; object the
         * &lt;code&gt;JFormattedTextField&lt;/code&gt; uses to parse and format
         * numbers.
         *
         * @return the value of &lt;code&gt;getTextField().getFormatter().getFormat()&lt;/code&gt;.
         * @see #getTextField
         * @see java.text.DecimalFormat
         */
        public DecimalFormat getFormat() {
<span class="nc" id="L1252">            return (DecimalFormat)((NumberFormatter)(getTextField().getFormatter())).getFormat();</span>
        }


        /**
         * Return our spinner ancestor's &lt;code&gt;SpinnerNumberModel&lt;/code&gt;.
         *
         * @return &lt;code&gt;getSpinner().getModel()&lt;/code&gt;
         * @see #getSpinner
         * @see #getTextField
         */
        public SpinnerNumberModel getModel() {
<span class="nc" id="L1264">            return (SpinnerNumberModel)(getSpinner().getModel());</span>
        }
    }


    /**
     * An editor for a &lt;code&gt;JSpinner&lt;/code&gt; whose model is a
     * &lt;code&gt;SpinnerListModel&lt;/code&gt;.
     * @since 1.4
     */
    public static class ListEditor extends DefaultEditor
    {
        /**
         * Construct a &lt;code&gt;JSpinner&lt;/code&gt; editor that supports displaying
         * and editing the value of a &lt;code&gt;SpinnerListModel&lt;/code&gt;
         * with a &lt;code&gt;JFormattedTextField&lt;/code&gt;.  &lt;code&gt;This&lt;/code&gt;
         * &lt;code&gt;ListEditor&lt;/code&gt; becomes both a &lt;code&gt;ChangeListener&lt;/code&gt;
         * on the spinner and a &lt;code&gt;PropertyChangeListener&lt;/code&gt;
         * on the new &lt;code&gt;JFormattedTextField&lt;/code&gt;.
         *
         * @param spinner the spinner whose model &lt;code&gt;this&lt;/code&gt; editor will monitor
         * @exception IllegalArgumentException if the spinners model is not
         *     an instance of &lt;code&gt;SpinnerListModel&lt;/code&gt;
         *
         * @see #getModel
         * @see SpinnerListModel
         */
        public ListEditor(JSpinner spinner) {
<span class="nc" id="L1292">            super(spinner);</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">            if (!(spinner.getModel() instanceof SpinnerListModel)) {</span>
<span class="nc" id="L1294">                throw new IllegalArgumentException(&quot;model not a SpinnerListModel&quot;);</span>
            }
<span class="nc" id="L1296">            getTextField().setEditable(true);</span>
<span class="nc" id="L1297">            getTextField().setFormatterFactory(new</span>
                              DefaultFormatterFactory(new ListFormatter()));
<span class="nc" id="L1299">        }</span>

        /**
         * Return our spinner ancestor's &lt;code&gt;SpinnerNumberModel&lt;/code&gt;.
         *
         * @return &lt;code&gt;getSpinner().getModel()&lt;/code&gt;
         * @see #getSpinner
         * @see #getTextField
         */
        public SpinnerListModel getModel() {
<span class="nc" id="L1309">            return (SpinnerListModel)(getSpinner().getModel());</span>
        }


        /**
         * ListFormatter provides completion while text is being input
         * into the JFormattedTextField. Completion is only done if the
         * user is inserting text at the end of the document. Completion
         * is done by way of the SpinnerListModel method findNextMatch.
         */
<span class="nc" id="L1319">        private class ListFormatter extends</span>
                          JFormattedTextField.AbstractFormatter {
            private DocumentFilter filter;

            public String valueToString(Object value) throws ParseException {
<span class="nc bnc" id="L1324" title="All 2 branches missed.">                if (value == null) {</span>
<span class="nc" id="L1325">                    return &quot;&quot;;</span>
                }
<span class="nc" id="L1327">                return value.toString();</span>
            }

            public Object stringToValue(String string) throws ParseException {
<span class="nc" id="L1331">                return string;</span>
            }

            protected DocumentFilter getDocumentFilter() {
<span class="nc bnc" id="L1335" title="All 2 branches missed.">                if (filter == null) {</span>
<span class="nc" id="L1336">                    filter = new Filter();</span>
                }
<span class="nc" id="L1338">                return filter;</span>
            }


<span class="nc" id="L1342">            private class Filter extends DocumentFilter {</span>
                public void replace(FilterBypass fb, int offset, int length,
                                    String string, AttributeSet attrs) throws
                                           BadLocationException {
<span class="nc bnc" id="L1346" title="All 2 branches missed.">                    if (string != null &amp;&amp; (offset + length) ==</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">                                          fb.getDocument().getLength()) {</span>
<span class="nc" id="L1348">                        Object next = getModel().findNextMatch(</span>
<span class="nc" id="L1349">                                         fb.getDocument().getText(0, offset) +</span>
                                         string);
<span class="nc bnc" id="L1351" title="All 2 branches missed.">                        String value = (next != null) ? next.toString() : null;</span>

<span class="nc bnc" id="L1353" title="All 2 branches missed.">                        if (value != null) {</span>
<span class="nc" id="L1354">                            fb.remove(0, offset + length);</span>
<span class="nc" id="L1355">                            fb.insertString(0, value, null);</span>
<span class="nc" id="L1356">                            getFormattedTextField().select(offset +</span>
<span class="nc" id="L1357">                                                           string.length(),</span>
<span class="nc" id="L1358">                                                           value.length());</span>
<span class="nc" id="L1359">                            return;</span>
                        }
                    }
<span class="nc" id="L1362">                    super.replace(fb, offset, length, string, attrs);</span>
<span class="nc" id="L1363">                }</span>

                public void insertString(FilterBypass fb, int offset,
                                     String string, AttributeSet attr)
                       throws BadLocationException {
<span class="nc" id="L1368">                    replace(fb, offset, 0, string, attr);</span>
<span class="nc" id="L1369">                }</span>
            }
        }
    }


    /**
     * An Action implementation that is always disabled.
     */
<span class="nc" id="L1378">    private static class DisabledAction implements Action {</span>
        public Object getValue(String key) {
<span class="nc" id="L1380">            return null;</span>
        }
        public void putValue(String key, Object value) {
<span class="nc" id="L1383">        }</span>
        public void setEnabled(boolean b) {
<span class="nc" id="L1385">        }</span>
        public boolean isEnabled() {
<span class="nc" id="L1387">            return false;</span>
        }
        public void addPropertyChangeListener(PropertyChangeListener l) {
<span class="nc" id="L1390">        }</span>
        public void removePropertyChangeListener(PropertyChangeListener l) {
<span class="nc" id="L1392">        }</span>
        public void actionPerformed(ActionEvent ae) {
<span class="nc" id="L1394">        }</span>
    }

    /////////////////
    // Accessibility support
    ////////////////

    /**
     * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; for the &lt;code&gt;JSpinner&lt;/code&gt;
     *
     * @return the &lt;code&gt;AccessibleContext&lt;/code&gt; for the &lt;code&gt;JSpinner&lt;/code&gt;
     * @since 1.5
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L1408" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L1409">            accessibleContext = new AccessibleJSpinner();</span>
        }
<span class="nc" id="L1411">        return accessibleContext;</span>
    }

    /**
     * &lt;code&gt;AccessibleJSpinner&lt;/code&gt; implements accessibility
     * support for the &lt;code&gt;JSpinner&lt;/code&gt; class.
     * @since 1.5
     */
    protected class AccessibleJSpinner extends AccessibleJComponent
        implements AccessibleValue, AccessibleAction, AccessibleText,
                   AccessibleEditableText, ChangeListener {

<span class="nc" id="L1423">        private Object oldModelValue = null;</span>

        /**
         * AccessibleJSpinner constructor
         */
<span class="nc" id="L1428">        protected AccessibleJSpinner() {</span>
            // model is guaranteed to be non-null
<span class="nc" id="L1430">            oldModelValue = model.getValue();</span>
<span class="nc" id="L1431">            JSpinner.this.addChangeListener(this);</span>
<span class="nc" id="L1432">        }</span>

        /**
         * Invoked when the target of the listener has changed its state.
         *
         * @param e  a &lt;code&gt;ChangeEvent&lt;/code&gt; object. Must not be null.
         * @throws NullPointerException if the parameter is null.
         */
        public void stateChanged(ChangeEvent e) {
<span class="nc bnc" id="L1441" title="All 2 branches missed.">            if (e == null) {</span>
<span class="nc" id="L1442">                throw new NullPointerException();</span>
            }
<span class="nc" id="L1444">            Object newModelValue = model.getValue();</span>
<span class="nc" id="L1445">            firePropertyChange(ACCESSIBLE_VALUE_PROPERTY,</span>
                               oldModelValue,
                               newModelValue);
<span class="nc" id="L1448">            firePropertyChange(ACCESSIBLE_TEXT_PROPERTY,</span>
                               null,
<span class="nc" id="L1450">                               0); // entire text may have changed</span>

<span class="nc" id="L1452">            oldModelValue = newModelValue;</span>
<span class="nc" id="L1453">        }</span>

        /* ===== Begin AccessibleContext methods ===== */

        /**
         * Gets the role of this object.  The role of the object is the generic
         * purpose or use of the class of this object.  For example, the role
         * of a push button is AccessibleRole.PUSH_BUTTON.  The roles in
         * AccessibleRole are provided so component developers can pick from
         * a set of predefined roles.  This enables assistive technologies to
         * provide a consistent interface to various tweaked subclasses of
         * components (e.g., use AccessibleRole.PUSH_BUTTON for all components
         * that act like a push button) as well as distinguish between subclasses
         * that behave differently (e.g., AccessibleRole.CHECK_BOX for check boxes
         * and AccessibleRole.RADIO_BUTTON for radio buttons).
         * &lt;p&gt;Note that the AccessibleRole class is also extensible, so
         * custom component developers can define their own AccessibleRole's
         * if the set of predefined roles is inadequate.
         *
         * @return an instance of AccessibleRole describing the role of the object
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L1476">            return AccessibleRole.SPIN_BOX;</span>
        }

        /**
         * Returns the number of accessible children of the object.
         *
         * @return the number of accessible children of the object.
         */
        public int getAccessibleChildrenCount() {
            // the JSpinner has one child, the editor
<span class="nc bnc" id="L1486" title="All 2 branches missed.">            if (editor.getAccessibleContext() != null) {</span>
<span class="nc" id="L1487">                return 1;</span>
            }
<span class="nc" id="L1489">            return 0;</span>
        }

        /**
         * Returns the specified Accessible child of the object.  The Accessible
         * children of an Accessible object are zero-based, so the first child
         * of an Accessible child is at index 0, the second child is at index 1,
         * and so on.
         *
         * @param i zero-based index of child
         * @return the Accessible child of the object
         * @see #getAccessibleChildrenCount
         */
        public Accessible getAccessibleChild(int i) {
            // the JSpinner has one child, the editor
<span class="nc bnc" id="L1504" title="All 2 branches missed.">            if (i != 0) {</span>
<span class="nc" id="L1505">                return null;</span>
            }
<span class="nc bnc" id="L1507" title="All 2 branches missed.">            if (editor.getAccessibleContext() != null) {</span>
<span class="nc" id="L1508">                return (Accessible)editor;</span>
            }
<span class="nc" id="L1510">            return null;</span>
        }

        /* ===== End AccessibleContext methods ===== */

        /**
         * Gets the AccessibleAction associated with this object that supports
         * one or more actions.
         *
         * @return AccessibleAction if supported by object; else return null
         * @see AccessibleAction
         */
        public AccessibleAction getAccessibleAction() {
<span class="nc" id="L1523">            return this;</span>
        }

        /**
         * Gets the AccessibleText associated with this object presenting
         * text on the display.
         *
         * @return AccessibleText if supported by object; else return null
         * @see AccessibleText
         */
        public AccessibleText getAccessibleText() {
<span class="nc" id="L1534">            return this;</span>
        }

        /*
         * Returns the AccessibleContext for the JSpinner editor
         */
        private AccessibleContext getEditorAccessibleContext() {
<span class="nc bnc" id="L1541" title="All 2 branches missed.">            if (editor instanceof DefaultEditor) {</span>
<span class="nc" id="L1542">                JTextField textField = ((DefaultEditor)editor).getTextField();</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">                if (textField != null) {</span>
<span class="nc" id="L1544">                    return textField.getAccessibleContext();</span>
                }
<span class="nc bnc" id="L1546" title="All 2 branches missed.">            } else if (editor instanceof Accessible) {</span>
<span class="nc" id="L1547">                return editor.getAccessibleContext();</span>
            }
<span class="nc" id="L1549">            return null;</span>
        }

        /*
         * Returns the AccessibleText for the JSpinner editor
         */
        private AccessibleText getEditorAccessibleText() {
<span class="nc" id="L1556">            AccessibleContext ac = getEditorAccessibleContext();</span>
<span class="nc bnc" id="L1557" title="All 2 branches missed.">            if (ac != null) {</span>
<span class="nc" id="L1558">                return ac.getAccessibleText();</span>
            }
<span class="nc" id="L1560">            return null;</span>
        }

        /*
         * Returns the AccessibleEditableText for the JSpinner editor
         */
        private AccessibleEditableText getEditorAccessibleEditableText() {
<span class="nc" id="L1567">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1568" title="All 2 branches missed.">            if (at instanceof AccessibleEditableText) {</span>
<span class="nc" id="L1569">                return (AccessibleEditableText)at;</span>
            }
<span class="nc" id="L1571">            return null;</span>
        }

        /**
         * Gets the AccessibleValue associated with this object.
         *
         * @return AccessibleValue if supported by object; else return null
         * @see AccessibleValue
         *
         */
        public AccessibleValue getAccessibleValue() {
<span class="nc" id="L1582">            return this;</span>
        }

        /* ===== Begin AccessibleValue impl ===== */

        /**
         * Get the value of this object as a Number.  If the value has not been
         * set, the return value will be null.
         *
         * @return value of the object
         * @see #setCurrentAccessibleValue
         */
        public Number getCurrentAccessibleValue() {
<span class="nc" id="L1595">            Object o = model.getValue();</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">            if (o instanceof Number) {</span>
<span class="nc" id="L1597">                return (Number)o;</span>
            }
<span class="nc" id="L1599">            return null;</span>
        }

        /**
         * Set the value of this object as a Number.
         *
         * @param n the value to set for this object
         * @return true if the value was set; else False
         * @see #getCurrentAccessibleValue
         */
        public boolean setCurrentAccessibleValue(Number n) {
            // try to set the new value
            try {
<span class="nc" id="L1612">                model.setValue(n);</span>
<span class="nc" id="L1613">                return true;</span>
<span class="nc" id="L1614">            } catch (IllegalArgumentException iae) {</span>
                // SpinnerModel didn't like new value
            }
<span class="nc" id="L1617">            return false;</span>
        }

        /**
         * Get the minimum value of this object as a Number.
         *
         * @return Minimum value of the object; null if this object does not
         * have a minimum value
         * @see #getMaximumAccessibleValue
         */
        public Number getMinimumAccessibleValue() {
<span class="nc bnc" id="L1628" title="All 2 branches missed.">            if (model instanceof SpinnerNumberModel) {</span>
<span class="nc" id="L1629">                SpinnerNumberModel numberModel = (SpinnerNumberModel)model;</span>
<span class="nc" id="L1630">                Object o = numberModel.getMinimum();</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">                if (o instanceof Number) {</span>
<span class="nc" id="L1632">                    return (Number)o;</span>
                }
            }
<span class="nc" id="L1635">            return null;</span>
        }

        /**
         * Get the maximum value of this object as a Number.
         *
         * @return Maximum value of the object; null if this object does not
         * have a maximum value
         * @see #getMinimumAccessibleValue
         */
        public Number getMaximumAccessibleValue() {
<span class="nc bnc" id="L1646" title="All 2 branches missed.">            if (model instanceof SpinnerNumberModel) {</span>
<span class="nc" id="L1647">                SpinnerNumberModel numberModel = (SpinnerNumberModel)model;</span>
<span class="nc" id="L1648">                Object o = numberModel.getMaximum();</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">                if (o instanceof Number) {</span>
<span class="nc" id="L1650">                    return (Number)o;</span>
                }
            }
<span class="nc" id="L1653">            return null;</span>
        }

        /* ===== End AccessibleValue impl ===== */

        /* ===== Begin AccessibleAction impl ===== */

        /**
         * Returns the number of accessible actions available in this object
         * If there are more than one, the first one is considered the &quot;default&quot;
         * action of the object.
         *
         * Two actions are supported: AccessibleAction.INCREMENT which
         * increments the spinner value and AccessibleAction.DECREMENT
         * which decrements the spinner value
         *
         * @return the zero-based number of Actions in this object
         */
        public int getAccessibleActionCount() {
<span class="nc" id="L1672">            return 2;</span>
        }

        /**
         * Returns a description of the specified action of the object.
         *
         * @param i zero-based index of the actions
         * @return a String description of the action
         * @see #getAccessibleActionCount
         */
        public String getAccessibleActionDescription(int i) {
<span class="nc bnc" id="L1683" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L1684">                return AccessibleAction.INCREMENT;</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">            } else if (i == 1) {</span>
<span class="nc" id="L1686">                return AccessibleAction.DECREMENT;</span>
            }
<span class="nc" id="L1688">            return null;</span>
        }

        /**
         * Performs the specified Action on the object
         *
         * @param i zero-based index of actions. The first action
         * (index 0) is AccessibleAction.INCREMENT and the second
         * action (index 1) is AccessibleAction.DECREMENT.
         * @return true if the action was performed; otherwise false.
         * @see #getAccessibleActionCount
         */
        public boolean doAccessibleAction(int i) {
<span class="nc bnc" id="L1701" title="All 4 branches missed.">            if (i &lt; 0 || i &gt; 1) {</span>
<span class="nc" id="L1702">                return false;</span>
            }
            Object o;
<span class="nc bnc" id="L1705" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L1706">                o = getNextValue(); // AccessibleAction.INCREMENT</span>
            } else {
<span class="nc" id="L1708">                o = getPreviousValue(); // AccessibleAction.DECREMENT</span>
            }
            // try to set the new value
            try {
<span class="nc" id="L1712">                model.setValue(o);</span>
<span class="nc" id="L1713">                return true;</span>
<span class="nc" id="L1714">            } catch (IllegalArgumentException iae) {</span>
                // SpinnerModel didn't like new value
            }
<span class="nc" id="L1717">            return false;</span>
        }

        /* ===== End AccessibleAction impl ===== */

        /* ===== Begin AccessibleText impl ===== */

        /*
         * Returns whether source and destination components have the
         * same window ancestor
         */
        private boolean sameWindowAncestor(Component src, Component dest) {
<span class="nc bnc" id="L1729" title="All 4 branches missed.">            if (src == null || dest == null) {</span>
<span class="nc" id="L1730">                return false;</span>
            }
<span class="nc" id="L1732">            return SwingUtilities.getWindowAncestor(src) ==</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">                SwingUtilities.getWindowAncestor(dest);</span>
        }

        /**
         * Given a point in local coordinates, return the zero-based index
         * of the character under that Point.  If the point is invalid,
         * this method returns -1.
         *
         * @param p the Point in local coordinates
         * @return the zero-based index of the character under Point p; if
         * Point is invalid return -1.
         */
        public int getIndexAtPoint(Point p) {
<span class="nc" id="L1746">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1747" title="All 4 branches missed.">            if (at != null &amp;&amp; sameWindowAncestor(JSpinner.this, editor)) {</span>
                // convert point from the JSpinner bounds (source) to
                // editor bounds (destination)
<span class="nc" id="L1750">                Point editorPoint = SwingUtilities.convertPoint(JSpinner.this,</span>
                                                                p,
<span class="nc" id="L1752">                                                                editor);</span>
<span class="nc bnc" id="L1753" title="All 2 branches missed.">                if (editorPoint != null) {</span>
<span class="nc" id="L1754">                    return at.getIndexAtPoint(editorPoint);</span>
                }
            }
<span class="nc" id="L1757">            return -1;</span>
        }

        /**
         * Determines the bounding box of the character at the given
         * index into the string.  The bounds are returned in local
         * coordinates.  If the index is invalid an empty rectangle is
         * returned.
         *
         * @param i the index into the String
         * @return the screen coordinates of the character's bounding box,
         * if index is invalid return an empty rectangle.
         */
        public Rectangle getCharacterBounds(int i) {
<span class="nc" id="L1771">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">            if (at != null ) {</span>
<span class="nc" id="L1773">                Rectangle editorRect = at.getCharacterBounds(i);</span>
<span class="nc bnc" id="L1774" title="All 2 branches missed.">                if (editorRect != null &amp;&amp;</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">                    sameWindowAncestor(JSpinner.this, editor)) {</span>
                    // return rectangle in the the JSpinner bounds
<span class="nc" id="L1777">                    return SwingUtilities.convertRectangle(editor,</span>
                                                           editorRect,
                                                           JSpinner.this);
                }
            }
<span class="nc" id="L1782">            return null;</span>
        }

        /**
         * Returns the number of characters (valid indicies)
         *
         * @return the number of characters
         */
        public int getCharCount() {
<span class="nc" id="L1791">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1793">                return at.getCharCount();</span>
            }
<span class="nc" id="L1795">            return -1;</span>
        }

        /**
         * Returns the zero-based offset of the caret.
         *
         * Note: That to the right of the caret will have the same index
         * value as the offset (the caret is between two characters).
         * @return the zero-based offset of the caret.
         */
        public int getCaretPosition() {
<span class="nc" id="L1806">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1808">                return at.getCaretPosition();</span>
            }
<span class="nc" id="L1810">            return -1;</span>
        }

        /**
         * Returns the String at a given index.
         *
         * @param part the CHARACTER, WORD, or SENTENCE to retrieve
         * @param index an index within the text
         * @return the letter, word, or sentence
         */
        public String getAtIndex(int part, int index) {
<span class="nc" id="L1821">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1823">                return at.getAtIndex(part, index);</span>
            }
<span class="nc" id="L1825">            return null;</span>
        }

        /**
         * Returns the String after a given index.
         *
         * @param part the CHARACTER, WORD, or SENTENCE to retrieve
         * @param index an index within the text
         * @return the letter, word, or sentence
         */
        public String getAfterIndex(int part, int index) {
<span class="nc" id="L1836">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1837" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1838">                return at.getAfterIndex(part, index);</span>
            }
<span class="nc" id="L1840">            return null;</span>
        }

        /**
         * Returns the String before a given index.
         *
         * @param part the CHARACTER, WORD, or SENTENCE to retrieve
         * @param index an index within the text
         * @return the letter, word, or sentence
         */
        public String getBeforeIndex(int part, int index) {
<span class="nc" id="L1851">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1852" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1853">                return at.getBeforeIndex(part, index);</span>
            }
<span class="nc" id="L1855">            return null;</span>
        }

        /**
         * Returns the AttributeSet for a given character at a given index
         *
         * @param i the zero-based index into the text
         * @return the AttributeSet of the character
         */
        public AttributeSet getCharacterAttribute(int i) {
<span class="nc" id="L1865">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1866" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1867">                return at.getCharacterAttribute(i);</span>
            }
<span class="nc" id="L1869">            return null;</span>
        }

        /**
         * Returns the start offset within the selected text.
         * If there is no selection, but there is
         * a caret, the start and end offsets will be the same.
         *
         * @return the index into the text of the start of the selection
         */
        public int getSelectionStart() {
<span class="nc" id="L1880">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1881" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1882">                return at.getSelectionStart();</span>
            }
<span class="nc" id="L1884">            return -1;</span>
        }

        /**
         * Returns the end offset within the selected text.
         * If there is no selection, but there is
         * a caret, the start and end offsets will be the same.
         *
         * @return the index into the text of the end of the selection
         */
        public int getSelectionEnd() {
<span class="nc" id="L1895">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1896" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1897">                return at.getSelectionEnd();</span>
            }
<span class="nc" id="L1899">            return -1;</span>
        }

        /**
         * Returns the portion of the text that is selected.
         *
         * @return the String portion of the text that is selected
         */
        public String getSelectedText() {
<span class="nc" id="L1908">            AccessibleText at = getEditorAccessibleText();</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1910">                return at.getSelectedText();</span>
            }
<span class="nc" id="L1912">            return null;</span>
        }

        /* ===== End AccessibleText impl ===== */


        /* ===== Begin AccessibleEditableText impl ===== */

        /**
         * Sets the text contents to the specified string.
         *
         * @param s the string to set the text contents
         */
        public void setTextContents(String s) {
<span class="nc" id="L1926">            AccessibleEditableText at = getEditorAccessibleEditableText();</span>
<span class="nc bnc" id="L1927" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1928">                at.setTextContents(s);</span>
            }
<span class="nc" id="L1930">        }</span>

        /**
         * Inserts the specified string at the given index/
         *
         * @param index the index in the text where the string will
         * be inserted
         * @param s the string to insert in the text
         */
        public void insertTextAtIndex(int index, String s) {
<span class="nc" id="L1940">            AccessibleEditableText at = getEditorAccessibleEditableText();</span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1942">                at.insertTextAtIndex(index, s);</span>
            }
<span class="nc" id="L1944">        }</span>

        /**
         * Returns the text string between two indices.
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         * @return the text string between the indices
         */
        public String getTextRange(int startIndex, int endIndex) {
<span class="nc" id="L1954">            AccessibleEditableText at = getEditorAccessibleEditableText();</span>
<span class="nc bnc" id="L1955" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1956">                return at.getTextRange(startIndex, endIndex);</span>
            }
<span class="nc" id="L1958">            return null;</span>
        }

        /**
         * Deletes the text between two indices
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         */
        public void delete(int startIndex, int endIndex) {
<span class="nc" id="L1968">            AccessibleEditableText at = getEditorAccessibleEditableText();</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1970">                at.delete(startIndex, endIndex);</span>
            }
<span class="nc" id="L1972">        }</span>

        /**
         * Cuts the text between two indices into the system clipboard.
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         */
        public void cut(int startIndex, int endIndex) {
<span class="nc" id="L1981">            AccessibleEditableText at = getEditorAccessibleEditableText();</span>
<span class="nc bnc" id="L1982" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1983">                at.cut(startIndex, endIndex);</span>
            }
<span class="nc" id="L1985">        }</span>

        /**
         * Pastes the text from the system clipboard into the text
         * starting at the specified index.
         *
         * @param startIndex the starting index in the text
         */
        public void paste(int startIndex) {
<span class="nc" id="L1994">            AccessibleEditableText at = getEditorAccessibleEditableText();</span>
<span class="nc bnc" id="L1995" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L1996">                at.paste(startIndex);</span>
            }
<span class="nc" id="L1998">        }</span>

        /**
         * Replaces the text between two indices with the specified
         * string.
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         * @param s the string to replace the text between two indices
         */
        public void replaceText(int startIndex, int endIndex, String s) {
<span class="nc" id="L2009">            AccessibleEditableText at = getEditorAccessibleEditableText();</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L2011">                at.replaceText(startIndex, endIndex, s);</span>
            }
<span class="nc" id="L2013">        }</span>

        /**
         * Selects the text between two indices.
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         */
        public void selectText(int startIndex, int endIndex) {
<span class="nc" id="L2022">            AccessibleEditableText at = getEditorAccessibleEditableText();</span>
<span class="nc bnc" id="L2023" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L2024">                at.selectText(startIndex, endIndex);</span>
            }
<span class="nc" id="L2026">        }</span>

        /**
         * Sets attributes for the text between two indices.
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         * @param as the attribute set
         * @see AttributeSet
         */
        public void setAttributes(int startIndex, int endIndex, AttributeSet as) {
<span class="nc" id="L2037">            AccessibleEditableText at = getEditorAccessibleEditableText();</span>
<span class="nc bnc" id="L2038" title="All 2 branches missed.">            if (at != null) {</span>
<span class="nc" id="L2039">                at.setAttributes(startIndex, endIndex, as);</span>
            }
<span class="nc" id="L2041">        }</span>
    }  /* End AccessibleJSpinner */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>