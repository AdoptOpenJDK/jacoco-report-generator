<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JComboBox.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JComboBox.java</span></div><h1>JComboBox.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.Transient;
import java.util.*;

import java.awt.*;
import java.awt.event.*;

import java.io.Serializable;
import java.io.ObjectOutputStream;
import java.io.IOException;

import javax.swing.event.*;
import javax.swing.plaf.*;

import javax.accessibility.*;

/**
 * A component that combines a button or editable field and a drop-down list.
 * The user can select a value from the drop-down list, which appears at the
 * user's request. If you make the combo box editable, then the combo box
 * includes an editable field into which the user can type a value.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * &lt;p&gt;
 * See &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/combobox.html&quot;&gt;How to Use Combo Boxes&lt;/a&gt;
 * in &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/&quot;&gt;&lt;em&gt;The Java Tutorial&lt;/em&gt;&lt;/a&gt;
 * for further information.
 * &lt;p&gt;
 * @see ComboBoxModel
 * @see DefaultComboBoxModel
 *
 * @param &lt;E&gt; the type of the elements of this combo box
 *
 * @beaninfo
 *   attribute: isContainer false
 * description: A combination of a text field and a drop-down list.
 *
 * @author Arnaud Weber
 * @author Mark Davidson
 */
public class JComboBox&lt;E&gt; extends JComponent
implements ItemSelectable,ListDataListener,ActionListener, Accessible {
    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;ComboBoxUI&quot;;

    /**
     * This protected field is implementation specific. Do not access directly
     * or override. Use the accessor methods instead.
     *
     * @see #getModel
     * @see #setModel
     */
    protected ComboBoxModel&lt;E&gt;    dataModel;
    /**
     * This protected field is implementation specific. Do not access directly
     * or override. Use the accessor methods instead.
     *
     * @see #getRenderer
     * @see #setRenderer
     */
    protected ListCellRenderer&lt;? super E&gt; renderer;
    /**
     * This protected field is implementation specific. Do not access directly
     * or override. Use the accessor methods instead.
     *
     * @see #getEditor
     * @see #setEditor
     */
    protected ComboBoxEditor       editor;
    /**
     * This protected field is implementation specific. Do not access directly
     * or override. Use the accessor methods instead.
     *
     * @see #getMaximumRowCount
     * @see #setMaximumRowCount
     */
<span class="nc" id="L120">    protected int maximumRowCount = 8;</span>

    /**
     * This protected field is implementation specific. Do not access directly
     * or override. Use the accessor methods instead.
     *
     * @see #isEditable
     * @see #setEditable
     */
<span class="nc" id="L129">    protected boolean isEditable  = false;</span>
    /**
     * This protected field is implementation specific. Do not access directly
     * or override. Use the accessor methods instead.
     *
     * @see #setKeySelectionManager
     * @see #getKeySelectionManager
     */
<span class="nc" id="L137">    protected KeySelectionManager keySelectionManager = null;</span>
    /**
     * This protected field is implementation specific. Do not access directly
     * or override. Use the accessor methods instead.
     *
     * @see #setActionCommand
     * @see #getActionCommand
     */
<span class="nc" id="L145">    protected String actionCommand = &quot;comboBoxChanged&quot;;</span>
    /**
     * This protected field is implementation specific. Do not access directly
     * or override. Use the accessor methods instead.
     *
     * @see #setLightWeightPopupEnabled
     * @see #isLightWeightPopupEnabled
     */
<span class="nc" id="L153">    protected boolean lightWeightPopupEnabled = JPopupMenu.getDefaultLightWeightPopupEnabled();</span>

    /**
     * This protected field is implementation specific. Do not access directly
     * or override.
     */
<span class="nc" id="L159">    protected Object selectedItemReminder = null;</span>

    private E prototypeDisplayValue;

    // Flag to ensure that infinite loops do not occur with ActionEvents.
<span class="nc" id="L164">    private boolean firingActionEvent = false;</span>

    // Flag to ensure the we don't get multiple ActionEvents on item selection.
<span class="nc" id="L167">    private boolean selectingItem = false;</span>

    /**
     * Creates a &lt;code&gt;JComboBox&lt;/code&gt; that takes its items from an
     * existing &lt;code&gt;ComboBoxModel&lt;/code&gt;.  Since the
     * &lt;code&gt;ComboBoxModel&lt;/code&gt; is provided, a combo box created using
     * this constructor does not create a default combo box model and
     * may impact how the insert, remove and add methods behave.
     *
     * @param aModel the &lt;code&gt;ComboBoxModel&lt;/code&gt; that provides the
     *          displayed list of items
     * @see DefaultComboBoxModel
     */
    public JComboBox(ComboBoxModel&lt;E&gt; aModel) {
<span class="nc" id="L181">        super();</span>
<span class="nc" id="L182">        setModel(aModel);</span>
<span class="nc" id="L183">        init();</span>
<span class="nc" id="L184">    }</span>

    /**
     * Creates a &lt;code&gt;JComboBox&lt;/code&gt; that contains the elements
     * in the specified array.  By default the first item in the array
     * (and therefore the data model) becomes selected.
     *
     * @param items  an array of objects to insert into the combo box
     * @see DefaultComboBoxModel
     */
    public JComboBox(E[] items) {
<span class="nc" id="L195">        super();</span>
<span class="nc" id="L196">        setModel(new DefaultComboBoxModel&lt;E&gt;(items));</span>
<span class="nc" id="L197">        init();</span>
<span class="nc" id="L198">    }</span>

    /**
     * Creates a &lt;code&gt;JComboBox&lt;/code&gt; that contains the elements
     * in the specified Vector.  By default the first item in the vector
     * (and therefore the data model) becomes selected.
     *
     * @param items  an array of vectors to insert into the combo box
     * @see DefaultComboBoxModel
     */
    public JComboBox(Vector&lt;E&gt; items) {
<span class="nc" id="L209">        super();</span>
<span class="nc" id="L210">        setModel(new DefaultComboBoxModel&lt;E&gt;(items));</span>
<span class="nc" id="L211">        init();</span>
<span class="nc" id="L212">    }</span>

    /**
     * Creates a &lt;code&gt;JComboBox&lt;/code&gt; with a default data model.
     * The default data model is an empty list of objects.
     * Use &lt;code&gt;addItem&lt;/code&gt; to add items.  By default the first item
     * in the data model becomes selected.
     *
     * @see DefaultComboBoxModel
     */
    public JComboBox() {
<span class="nc" id="L223">        super();</span>
<span class="nc" id="L224">        setModel(new DefaultComboBoxModel&lt;E&gt;());</span>
<span class="nc" id="L225">        init();</span>
<span class="nc" id="L226">    }</span>

    private void init() {
<span class="nc" id="L229">        installAncestorListener();</span>
<span class="nc" id="L230">        setUIProperty(&quot;opaque&quot;,true);</span>
<span class="nc" id="L231">        updateUI();</span>
<span class="nc" id="L232">    }</span>

    protected void installAncestorListener() {
<span class="nc" id="L235">        addAncestorListener(new AncestorListener(){</span>
<span class="nc" id="L236">                                public void ancestorAdded(AncestorEvent event){ hidePopup();}</span>
<span class="nc" id="L237">                                public void ancestorRemoved(AncestorEvent event){ hidePopup();}</span>
                                public void ancestorMoved(AncestorEvent event){
<span class="nc bnc" id="L239" title="All 2 branches missed.">                                    if (event.getSource() != JComboBox.this)</span>
<span class="nc" id="L240">                                        hidePopup();</span>
<span class="nc" id="L241">                                }});</span>
<span class="nc" id="L242">    }</span>

    /**
     * Sets the L&amp;amp;F object that renders this component.
     *
     * @param ui  the &lt;code&gt;ComboBoxUI&lt;/code&gt; L&amp;amp;F object
     * @see UIDefaults#getUI
     *
     * @beaninfo
     *        bound: true
     *       hidden: true
     *    attribute: visualUpdate true
     *  description: The UI object that implements the Component's LookAndFeel.
     */
    public void setUI(ComboBoxUI ui) {
<span class="nc" id="L257">        super.setUI(ui);</span>
<span class="nc" id="L258">    }</span>

    /**
     * Resets the UI property to a value from the current look and feel.
     *
     * @see JComponent#updateUI
     */
    public void updateUI() {
<span class="nc" id="L266">        setUI((ComboBoxUI)UIManager.getUI(this));</span>

<span class="nc" id="L268">        ListCellRenderer&lt;? super E&gt; renderer = getRenderer();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (renderer instanceof Component) {</span>
<span class="nc" id="L270">            SwingUtilities.updateComponentTreeUI((Component)renderer);</span>
        }
<span class="nc" id="L272">    }</span>


    /**
     * Returns the name of the L&amp;amp;F class that renders this component.
     *
     * @return the string &quot;ComboBoxUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L283">        return uiClassID;</span>
    }


    /**
     * Returns the L&amp;amp;F object that renders this component.
     *
     * @return the ComboBoxUI object that renders this component
     */
    public ComboBoxUI getUI() {
<span class="nc" id="L293">        return(ComboBoxUI)ui;</span>
    }

    /**
     * Sets the data model that the &lt;code&gt;JComboBox&lt;/code&gt; uses to obtain
     * the list of items.
     *
     * @param aModel the &lt;code&gt;ComboBoxModel&lt;/code&gt; that provides the
     *  displayed list of items
     *
     * @beaninfo
     *        bound: true
     *  description: Model that the combo box uses to get data to display.
     */
    public void setModel(ComboBoxModel&lt;E&gt; aModel) {
<span class="nc" id="L308">        ComboBoxModel&lt;E&gt; oldModel = dataModel;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (oldModel != null) {</span>
<span class="nc" id="L310">            oldModel.removeListDataListener(this);</span>
        }
<span class="nc" id="L312">        dataModel = aModel;</span>
<span class="nc" id="L313">        dataModel.addListDataListener(this);</span>

        // set the current selected item.
<span class="nc" id="L316">        selectedItemReminder = dataModel.getSelectedItem();</span>

<span class="nc" id="L318">        firePropertyChange( &quot;model&quot;, oldModel, dataModel);</span>
<span class="nc" id="L319">    }</span>

    /**
     * Returns the data model currently used by the &lt;code&gt;JComboBox&lt;/code&gt;.
     *
     * @return the &lt;code&gt;ComboBoxModel&lt;/code&gt; that provides the displayed
     *                  list of items
     */
    public ComboBoxModel&lt;E&gt; getModel() {
<span class="nc" id="L328">        return dataModel;</span>
    }

    /*
     * Properties
     */

    /**
     * Sets the &lt;code&gt;lightWeightPopupEnabled&lt;/code&gt; property, which
     * provides a hint as to whether or not a lightweight
     * &lt;code&gt;Component&lt;/code&gt; should be used to contain the
     * &lt;code&gt;JComboBox&lt;/code&gt;, versus a heavyweight
     * &lt;code&gt;Component&lt;/code&gt; such as a &lt;code&gt;Panel&lt;/code&gt;
     * or a &lt;code&gt;Window&lt;/code&gt;.  The decision of lightweight
     * versus heavyweight is ultimately up to the
     * &lt;code&gt;JComboBox&lt;/code&gt;.  Lightweight windows are more
     * efficient than heavyweight windows, but lightweight
     * and heavyweight components do not mix well in a GUI.
     * If your application mixes lightweight and heavyweight
     * components, you should disable lightweight popups.
     * The default value for the &lt;code&gt;lightWeightPopupEnabled&lt;/code&gt;
     * property is &lt;code&gt;true&lt;/code&gt;, unless otherwise specified
     * by the look and feel.  Some look and feels always use
     * heavyweight popups, no matter what the value of this property.
     * &lt;p&gt;
     * See the article &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/mixing-components-433992.html&quot;&gt;Mixing Heavy and Light Components&lt;/a&gt;
     * This method fires a property changed event.
     *
     * @param aFlag if &lt;code&gt;true&lt;/code&gt;, lightweight popups are desired
     *
     * @beaninfo
     *        bound: true
     *       expert: true
     *  description: Set to &lt;code&gt;false&lt;/code&gt; to require heavyweight popups.
     */
    public void setLightWeightPopupEnabled(boolean aFlag) {
<span class="nc" id="L364">        boolean oldFlag = lightWeightPopupEnabled;</span>
<span class="nc" id="L365">        lightWeightPopupEnabled = aFlag;</span>
<span class="nc" id="L366">        firePropertyChange(&quot;lightWeightPopupEnabled&quot;, oldFlag, lightWeightPopupEnabled);</span>
<span class="nc" id="L367">    }</span>

    /**
     * Gets the value of the &lt;code&gt;lightWeightPopupEnabled&lt;/code&gt;
     * property.
     *
     * @return the value of the &lt;code&gt;lightWeightPopupEnabled&lt;/code&gt;
     *    property
     * @see #setLightWeightPopupEnabled
     */
    public boolean isLightWeightPopupEnabled() {
<span class="nc" id="L378">        return lightWeightPopupEnabled;</span>
    }

    /**
     * Determines whether the &lt;code&gt;JComboBox&lt;/code&gt; field is editable.
     * An editable &lt;code&gt;JComboBox&lt;/code&gt; allows the user to type into the
     * field or selected an item from the list to initialize the field,
     * after which it can be edited. (The editing affects only the field,
     * the list item remains intact.) A non editable &lt;code&gt;JComboBox&lt;/code&gt;
     * displays the selected item in the field,
     * but the selection cannot be modified.
     *
     * @param aFlag a boolean value, where true indicates that the
     *                  field is editable
     *
     * @beaninfo
     *        bound: true
     *    preferred: true
     *  description: If true, the user can type a new value in the combo box.
     */
    public void setEditable(boolean aFlag) {
<span class="nc" id="L399">        boolean oldFlag = isEditable;</span>
<span class="nc" id="L400">        isEditable = aFlag;</span>
<span class="nc" id="L401">        firePropertyChange( &quot;editable&quot;, oldFlag, isEditable );</span>
<span class="nc" id="L402">    }</span>

    /**
     * Returns true if the &lt;code&gt;JComboBox&lt;/code&gt; is editable.
     * By default, a combo box is not editable.
     *
     * @return true if the &lt;code&gt;JComboBox&lt;/code&gt; is editable, else false
     */
    public boolean isEditable() {
<span class="nc" id="L411">        return isEditable;</span>
    }

    /**
     * Sets the maximum number of rows the &lt;code&gt;JComboBox&lt;/code&gt; displays.
     * If the number of objects in the model is greater than count,
     * the combo box uses a scrollbar.
     *
     * @param count an integer specifying the maximum number of items to
     *              display in the list before using a scrollbar
     * @beaninfo
     *        bound: true
     *    preferred: true
     *  description: The maximum number of rows the popup should have
     */
    public void setMaximumRowCount(int count) {
<span class="nc" id="L427">        int oldCount = maximumRowCount;</span>
<span class="nc" id="L428">        maximumRowCount = count;</span>
<span class="nc" id="L429">        firePropertyChange( &quot;maximumRowCount&quot;, oldCount, maximumRowCount );</span>
<span class="nc" id="L430">    }</span>

    /**
     * Returns the maximum number of items the combo box can display
     * without a scrollbar
     *
     * @return an integer specifying the maximum number of items that are
     *         displayed in the list before using a scrollbar
     */
    public int getMaximumRowCount() {
<span class="nc" id="L440">        return maximumRowCount;</span>
    }

    /**
     * Sets the renderer that paints the list items and the item selected from the list in
     * the JComboBox field. The renderer is used if the JComboBox is not
     * editable. If it is editable, the editor is used to render and edit
     * the selected item.
     * &lt;p&gt;
     * The default renderer displays a string or an icon.
     * Other renderers can handle graphic images and composite items.
     * &lt;p&gt;
     * To display the selected item,
     * &lt;code&gt;aRenderer.getListCellRendererComponent&lt;/code&gt;
     * is called, passing the list object and an index of -1.
     *
     * @param aRenderer  the &lt;code&gt;ListCellRenderer&lt;/code&gt; that
     *                  displays the selected item
     * @see #setEditor
     * @beaninfo
     *      bound: true
     *     expert: true
     *  description: The renderer that paints the item selected in the list.
     */
    public void setRenderer(ListCellRenderer&lt;? super E&gt; aRenderer) {
<span class="nc" id="L465">        ListCellRenderer&lt;? super E&gt; oldRenderer = renderer;</span>
<span class="nc" id="L466">        renderer = aRenderer;</span>
<span class="nc" id="L467">        firePropertyChange( &quot;renderer&quot;, oldRenderer, renderer );</span>
<span class="nc" id="L468">        invalidate();</span>
<span class="nc" id="L469">    }</span>

    /**
     * Returns the renderer used to display the selected item in the
     * &lt;code&gt;JComboBox&lt;/code&gt; field.
     *
     * @return  the &lt;code&gt;ListCellRenderer&lt;/code&gt; that displays
     *                  the selected item.
     */
    public ListCellRenderer&lt;? super E&gt; getRenderer() {
<span class="nc" id="L479">        return renderer;</span>
    }

    /**
     * Sets the editor used to paint and edit the selected item in the
     * &lt;code&gt;JComboBox&lt;/code&gt; field.  The editor is used only if the
     * receiving &lt;code&gt;JComboBox&lt;/code&gt; is editable. If not editable,
     * the combo box uses the renderer to paint the selected item.
     *
     * @param anEditor  the &lt;code&gt;ComboBoxEditor&lt;/code&gt; that
     *                  displays the selected item
     * @see #setRenderer
     * @beaninfo
     *     bound: true
     *    expert: true
     *  description: The editor that combo box uses to edit the current value
     */
    public void setEditor(ComboBoxEditor anEditor) {
<span class="nc" id="L497">        ComboBoxEditor oldEditor = editor;</span>

<span class="nc bnc" id="L499" title="All 2 branches missed.">        if ( editor != null ) {</span>
<span class="nc" id="L500">            editor.removeActionListener(this);</span>
        }
<span class="nc" id="L502">        editor = anEditor;</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if ( editor != null ) {</span>
<span class="nc" id="L504">            editor.addActionListener(this);</span>
        }
<span class="nc" id="L506">        firePropertyChange( &quot;editor&quot;, oldEditor, editor );</span>
<span class="nc" id="L507">    }</span>

    /**
     * Returns the editor used to paint and edit the selected item in the
     * &lt;code&gt;JComboBox&lt;/code&gt; field.
     *
     * @return the &lt;code&gt;ComboBoxEditor&lt;/code&gt; that displays the selected item
     */
    public ComboBoxEditor getEditor() {
<span class="nc" id="L516">        return editor;</span>
    }

    //
    // Selection
    //

    /**
     * Sets the selected item in the combo box display area to the object in
     * the argument.
     * If &lt;code&gt;anObject&lt;/code&gt; is in the list, the display area shows
     * &lt;code&gt;anObject&lt;/code&gt; selected.
     * &lt;p&gt;
     * If &lt;code&gt;anObject&lt;/code&gt; is &lt;i&gt;not&lt;/i&gt; in the list and the combo box is
     * uneditable, it will not change the current selection. For editable
     * combo boxes, the selection will change to &lt;code&gt;anObject&lt;/code&gt;.
     * &lt;p&gt;
     * If this constitutes a change in the selected item,
     * &lt;code&gt;ItemListener&lt;/code&gt;s added to the combo box will be notified with
     * one or two &lt;code&gt;ItemEvent&lt;/code&gt;s.
     * If there is a current selected item, an &lt;code&gt;ItemEvent&lt;/code&gt; will be
     * fired and the state change will be &lt;code&gt;ItemEvent.DESELECTED&lt;/code&gt;.
     * If &lt;code&gt;anObject&lt;/code&gt; is in the list and is not currently selected
     * then an &lt;code&gt;ItemEvent&lt;/code&gt; will be fired and the state change will
     * be &lt;code&gt;ItemEvent.SELECTED&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;code&gt;ActionListener&lt;/code&gt;s added to the combo box will be notified
     * with an &lt;code&gt;ActionEvent&lt;/code&gt; when this method is called.
     *
     * @param anObject  the list object to select; use &lt;code&gt;null&lt;/code&gt; to
                        clear the selection
     * @beaninfo
     *    preferred:   true
     *    description: Sets the selected item in the JComboBox.
     */
    public void setSelectedItem(Object anObject) {
<span class="nc" id="L552">        Object oldSelection = selectedItemReminder;</span>
<span class="nc" id="L553">        Object objectToSelect = anObject;</span>
<span class="nc bnc" id="L554" title="All 4 branches missed.">        if (oldSelection == null || !oldSelection.equals(anObject)) {</span>

<span class="nc bnc" id="L556" title="All 4 branches missed.">            if (anObject != null &amp;&amp; !isEditable()) {</span>
                // For non editable combo boxes, an invalid selection
                // will be rejected.
<span class="nc" id="L559">                boolean found = false;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                for (int i = 0; i &lt; dataModel.getSize(); i++) {</span>
<span class="nc" id="L561">                    E element = dataModel.getElementAt(i);</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                    if (anObject.equals(element)) {</span>
<span class="nc" id="L563">                        found = true;</span>
<span class="nc" id="L564">                        objectToSelect = element;</span>
<span class="nc" id="L565">                        break;</span>
                    }
                }
<span class="nc bnc" id="L568" title="All 2 branches missed.">                if (!found) {</span>
<span class="nc" id="L569">                    return;</span>
                }
            }

            // Must toggle the state of this flag since this method
            // call may result in ListDataEvents being fired.
<span class="nc" id="L575">            selectingItem = true;</span>
<span class="nc" id="L576">            dataModel.setSelectedItem(objectToSelect);</span>
<span class="nc" id="L577">            selectingItem = false;</span>

<span class="nc bnc" id="L579" title="All 2 branches missed.">            if (selectedItemReminder != dataModel.getSelectedItem()) {</span>
                // in case a users implementation of ComboBoxModel
                // doesn't fire a ListDataEvent when the selection
                // changes.
<span class="nc" id="L583">                selectedItemChanged();</span>
            }
        }
<span class="nc" id="L586">        fireActionEvent();</span>
<span class="nc" id="L587">    }</span>

    /**
     * Returns the current selected item.
     * &lt;p&gt;
     * If the combo box is editable, then this value may not have been added
     * to the combo box with &lt;code&gt;addItem&lt;/code&gt;, &lt;code&gt;insertItemAt&lt;/code&gt;
     * or the data constructors.
     *
     * @return the current selected Object
     * @see #setSelectedItem
     */
    public Object getSelectedItem() {
<span class="nc" id="L600">        return dataModel.getSelectedItem();</span>
    }

    /**
     * Selects the item at index &lt;code&gt;anIndex&lt;/code&gt;.
     *
     * @param anIndex an integer specifying the list item to select,
     *                  where 0 specifies the first item in the list and -1 indicates no selection
     * @exception IllegalArgumentException if &lt;code&gt;anIndex&lt;/code&gt; &amp;lt; -1 or
     *                  &lt;code&gt;anIndex&lt;/code&gt; is greater than or equal to size
     * @beaninfo
     *   preferred: true
     *  description: The item at index is selected.
     */
    public void setSelectedIndex(int anIndex) {
<span class="nc" id="L615">        int size = dataModel.getSize();</span>

<span class="nc bnc" id="L617" title="All 2 branches missed.">        if ( anIndex == -1 ) {</span>
<span class="nc" id="L618">            setSelectedItem( null );</span>
<span class="nc bnc" id="L619" title="All 4 branches missed.">        } else if ( anIndex &lt; -1 || anIndex &gt;= size ) {</span>
<span class="nc" id="L620">            throw new IllegalArgumentException(&quot;setSelectedIndex: &quot; + anIndex + &quot; out of bounds&quot;);</span>
        } else {
<span class="nc" id="L622">            setSelectedItem(dataModel.getElementAt(anIndex));</span>
        }
<span class="nc" id="L624">    }</span>

    /**
     * Returns the first item in the list that matches the given item.
     * The result is not always defined if the &lt;code&gt;JComboBox&lt;/code&gt;
     * allows selected items that are not in the list.
     * Returns -1 if there is no selected item or if the user specified
     * an item which is not in the list.

     * @return an integer specifying the currently selected list item,
     *                  where 0 specifies
     *                  the first item in the list;
     *                  or -1 if no item is selected or if
     *                  the currently selected item is not in the list
     */
    @Transient
    public int getSelectedIndex() {
<span class="nc" id="L641">        Object sObject = dataModel.getSelectedItem();</span>
        int i,c;
        E obj;

<span class="nc bnc" id="L645" title="All 2 branches missed.">        for ( i=0,c=dataModel.getSize();i&lt;c;i++ ) {</span>
<span class="nc" id="L646">            obj = dataModel.getElementAt(i);</span>
<span class="nc bnc" id="L647" title="All 4 branches missed.">            if ( obj != null &amp;&amp; obj.equals(sObject) )</span>
<span class="nc" id="L648">                return i;</span>
        }
<span class="nc" id="L650">        return -1;</span>
    }

    /**
     * Returns the &quot;prototypical display&quot; value - an Object used
     * for the calculation of the display height and width.
     *
     * @return the value of the &lt;code&gt;prototypeDisplayValue&lt;/code&gt; property
     * @see #setPrototypeDisplayValue
     * @since 1.4
     */
    public E getPrototypeDisplayValue() {
<span class="nc" id="L662">        return prototypeDisplayValue;</span>
    }

    /**
     * Sets the prototype display value used to calculate the size of the display
     * for the UI portion.
     * &lt;p&gt;
     * If a prototype display value is specified, the preferred size of
     * the combo box is calculated by configuring the renderer with the
     * prototype display value and obtaining its preferred size. Specifying
     * the preferred display value is often useful when the combo box will be
     * displaying large amounts of data. If no prototype display value has
     * been specified, the renderer must be configured for each value from
     * the model and its preferred size obtained, which can be
     * relatively expensive.
     *
     * @param prototypeDisplayValue
     * @see #getPrototypeDisplayValue
     * @since 1.4
     * @beaninfo
     *       bound: true
     *   attribute: visualUpdate true
     * description: The display prototype value, used to compute display width and height.
     */
    public void setPrototypeDisplayValue(E prototypeDisplayValue) {
<span class="nc" id="L687">        Object oldValue = this.prototypeDisplayValue;</span>
<span class="nc" id="L688">        this.prototypeDisplayValue = prototypeDisplayValue;</span>
<span class="nc" id="L689">        firePropertyChange(&quot;prototypeDisplayValue&quot;, oldValue, prototypeDisplayValue);</span>
<span class="nc" id="L690">    }</span>

    /**
     * Adds an item to the item list.
     * This method works only if the &lt;code&gt;JComboBox&lt;/code&gt; uses a
     * mutable data model.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Focus and keyboard navigation problems may arise if you add duplicate
     * String objects. A workaround is to add new objects instead of String
     * objects and make sure that the toString() method is defined.
     * For example:
     * &lt;pre&gt;
     *   comboBox.addItem(makeObj(&quot;Item 1&quot;));
     *   comboBox.addItem(makeObj(&quot;Item 1&quot;));
     *   ...
     *   private Object makeObj(final String item)  {
     *     return new Object() { public String toString() { return item; } };
     *   }
     * &lt;/pre&gt;
     *
     * @param item the item to add to the list
     * @see MutableComboBoxModel
     */
    public void addItem(E item) {
<span class="nc" id="L715">        checkMutableComboBoxModel();</span>
<span class="nc" id="L716">        ((MutableComboBoxModel&lt;E&gt;)dataModel).addElement(item);</span>
<span class="nc" id="L717">    }</span>

    /**
     * Inserts an item into the item list at a given index.
     * This method works only if the &lt;code&gt;JComboBox&lt;/code&gt; uses a
     * mutable data model.
     *
     * @param item the item to add to the list
     * @param index    an integer specifying the position at which
     *                  to add the item
     * @see MutableComboBoxModel
     */
    public void insertItemAt(E item, int index) {
<span class="nc" id="L730">        checkMutableComboBoxModel();</span>
<span class="nc" id="L731">        ((MutableComboBoxModel&lt;E&gt;)dataModel).insertElementAt(item,index);</span>
<span class="nc" id="L732">    }</span>

    /**
     * Removes an item from the item list.
     * This method works only if the &lt;code&gt;JComboBox&lt;/code&gt; uses a
     * mutable data model.
     *
     * @param anObject  the object to remove from the item list
     * @see MutableComboBoxModel
     */
    public void removeItem(Object anObject) {
<span class="nc" id="L743">        checkMutableComboBoxModel();</span>
<span class="nc" id="L744">        ((MutableComboBoxModel)dataModel).removeElement(anObject);</span>
<span class="nc" id="L745">    }</span>

    /**
     * Removes the item at &lt;code&gt;anIndex&lt;/code&gt;
     * This method works only if the &lt;code&gt;JComboBox&lt;/code&gt; uses a
     * mutable data model.
     *
     * @param anIndex  an int specifying the index of the item to remove,
     *                  where 0
     *                  indicates the first item in the list
     * @see MutableComboBoxModel
     */
    public void removeItemAt(int anIndex) {
<span class="nc" id="L758">        checkMutableComboBoxModel();</span>
<span class="nc" id="L759">        ((MutableComboBoxModel&lt;E&gt;)dataModel).removeElementAt( anIndex );</span>
<span class="nc" id="L760">    }</span>

    /**
     * Removes all items from the item list.
     */
    public void removeAllItems() {
<span class="nc" id="L766">        checkMutableComboBoxModel();</span>
<span class="nc" id="L767">        MutableComboBoxModel&lt;E&gt; model = (MutableComboBoxModel&lt;E&gt;)dataModel;</span>
<span class="nc" id="L768">        int size = model.getSize();</span>

<span class="nc bnc" id="L770" title="All 2 branches missed.">        if ( model instanceof DefaultComboBoxModel ) {</span>
<span class="nc" id="L771">            ((DefaultComboBoxModel)model).removeAllElements();</span>
        }
        else {
<span class="nc bnc" id="L774" title="All 2 branches missed.">            for ( int i = 0; i &lt; size; ++i ) {</span>
<span class="nc" id="L775">                E element = model.getElementAt( 0 );</span>
<span class="nc" id="L776">                model.removeElement( element );</span>
            }
        }
<span class="nc" id="L779">        selectedItemReminder = null;</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">        if (isEditable()) {</span>
<span class="nc" id="L781">            editor.setItem(null);</span>
        }
<span class="nc" id="L783">    }</span>

    /**
     * Checks that the &lt;code&gt;dataModel&lt;/code&gt; is an instance of
     * &lt;code&gt;MutableComboBoxModel&lt;/code&gt;.  If not, it throws an exception.
     * @exception RuntimeException if &lt;code&gt;dataModel&lt;/code&gt; is not an
     *          instance of &lt;code&gt;MutableComboBoxModel&lt;/code&gt;.
     */
    void checkMutableComboBoxModel() {
<span class="nc bnc" id="L792" title="All 2 branches missed.">        if ( !(dataModel instanceof MutableComboBoxModel) )</span>
<span class="nc" id="L793">            throw new RuntimeException(&quot;Cannot use this method with a non-Mutable data model.&quot;);</span>
<span class="nc" id="L794">    }</span>

    /**
     * Causes the combo box to display its popup window.
     * @see #setPopupVisible
     */
    public void showPopup() {
<span class="nc" id="L801">        setPopupVisible(true);</span>
<span class="nc" id="L802">    }</span>

    /**
     * Causes the combo box to close its popup window.
     * @see #setPopupVisible
     */
    public void hidePopup() {
<span class="nc" id="L809">        setPopupVisible(false);</span>
<span class="nc" id="L810">    }</span>

    /**
     * Sets the visibility of the popup.
     */
    public void setPopupVisible(boolean v) {
<span class="nc" id="L816">        getUI().setPopupVisible(this, v);</span>
<span class="nc" id="L817">    }</span>

    /**
     * Determines the visibility of the popup.
     *
     * @return true if the popup is visible, otherwise returns false
     */
    public boolean isPopupVisible() {
<span class="nc" id="L825">        return getUI().isPopupVisible(this);</span>
    }

    /** Selection **/

    /**
     * Adds an &lt;code&gt;ItemListener&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;code&gt;aListener&lt;/code&gt; will receive one or two &lt;code&gt;ItemEvent&lt;/code&gt;s when
     * the selected item changes.
     *
     * @param aListener the &lt;code&gt;ItemListener&lt;/code&gt; that is to be notified
     * @see #setSelectedItem
     */
    public void addItemListener(ItemListener aListener) {
<span class="nc" id="L840">        listenerList.add(ItemListener.class,aListener);</span>
<span class="nc" id="L841">    }</span>

    /** Removes an &lt;code&gt;ItemListener&lt;/code&gt;.
     *
     * @param aListener  the &lt;code&gt;ItemListener&lt;/code&gt; to remove
     */
    public void removeItemListener(ItemListener aListener) {
<span class="nc" id="L848">        listenerList.remove(ItemListener.class,aListener);</span>
<span class="nc" id="L849">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;ItemListener&lt;/code&gt;s added
     * to this JComboBox with addItemListener().
     *
     * @return all of the &lt;code&gt;ItemListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public ItemListener[] getItemListeners() {
<span class="nc" id="L860">        return listenerList.getListeners(ItemListener.class);</span>
    }

    /**
     * Adds an &lt;code&gt;ActionListener&lt;/code&gt;.
     * &lt;p&gt;
     * The &lt;code&gt;ActionListener&lt;/code&gt; will receive an &lt;code&gt;ActionEvent&lt;/code&gt;
     * when a selection has been made. If the combo box is editable, then
     * an &lt;code&gt;ActionEvent&lt;/code&gt; will be fired when editing has stopped.
     *
     * @param l  the &lt;code&gt;ActionListener&lt;/code&gt; that is to be notified
     * @see #setSelectedItem
     */
    public void addActionListener(ActionListener l) {
<span class="nc" id="L874">        listenerList.add(ActionListener.class,l);</span>
<span class="nc" id="L875">    }</span>

    /** Removes an &lt;code&gt;ActionListener&lt;/code&gt;.
     *
     * @param l  the &lt;code&gt;ActionListener&lt;/code&gt; to remove
     */
    public void removeActionListener(ActionListener l) {
<span class="nc bnc" id="L882" title="All 4 branches missed.">        if ((l != null) &amp;&amp; (getAction() == l)) {</span>
<span class="nc" id="L883">            setAction(null);</span>
        } else {
<span class="nc" id="L885">            listenerList.remove(ActionListener.class, l);</span>
        }
<span class="nc" id="L887">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;ActionListener&lt;/code&gt;s added
     * to this JComboBox with addActionListener().
     *
     * @return all of the &lt;code&gt;ActionListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public ActionListener[] getActionListeners() {
<span class="nc" id="L898">        return listenerList.getListeners(ActionListener.class);</span>
    }

    /**
     * Adds a &lt;code&gt;PopupMenu&lt;/code&gt; listener which will listen to notification
     * messages from the popup portion of the combo box.
     * &lt;p&gt;
     * For all standard look and feels shipped with Java, the popup list
     * portion of combo box is implemented as a &lt;code&gt;JPopupMenu&lt;/code&gt;.
     * A custom look and feel may not implement it this way and will
     * therefore not receive the notification.
     *
     * @param l  the &lt;code&gt;PopupMenuListener&lt;/code&gt; to add
     * @since 1.4
     */
    public void addPopupMenuListener(PopupMenuListener l) {
<span class="nc" id="L914">        listenerList.add(PopupMenuListener.class,l);</span>
<span class="nc" id="L915">    }</span>

    /**
     * Removes a &lt;code&gt;PopupMenuListener&lt;/code&gt;.
     *
     * @param l  the &lt;code&gt;PopupMenuListener&lt;/code&gt; to remove
     * @see #addPopupMenuListener
     * @since 1.4
     */
    public void removePopupMenuListener(PopupMenuListener l) {
<span class="nc" id="L925">        listenerList.remove(PopupMenuListener.class,l);</span>
<span class="nc" id="L926">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;PopupMenuListener&lt;/code&gt;s added
     * to this JComboBox with addPopupMenuListener().
     *
     * @return all of the &lt;code&gt;PopupMenuListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public PopupMenuListener[] getPopupMenuListeners() {
<span class="nc" id="L937">        return listenerList.getListeners(PopupMenuListener.class);</span>
    }

    /**
     * Notifies &lt;code&gt;PopupMenuListener&lt;/code&gt;s that the popup portion of the
     * combo box will become visible.
     * &lt;p&gt;
     * This method is public but should not be called by anything other than
     * the UI delegate.
     * @see #addPopupMenuListener
     * @since 1.4
     */
    public void firePopupMenuWillBecomeVisible() {
<span class="nc" id="L950">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L951">        PopupMenuEvent e=null;</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">            if (listeners[i]==PopupMenuListener.class) {</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L955">                    e = new PopupMenuEvent(this);</span>
<span class="nc" id="L956">                ((PopupMenuListener)listeners[i+1]).popupMenuWillBecomeVisible(e);</span>
            }
        }
<span class="nc" id="L959">    }</span>

    /**
     * Notifies &lt;code&gt;PopupMenuListener&lt;/code&gt;s that the popup portion of the
     * combo box has become invisible.
     * &lt;p&gt;
     * This method is public but should not be called by anything other than
     * the UI delegate.
     * @see #addPopupMenuListener
     * @since 1.4
     */
    public void firePopupMenuWillBecomeInvisible() {
<span class="nc" id="L971">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L972">        PopupMenuEvent e=null;</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">            if (listeners[i]==PopupMenuListener.class) {</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L976">                    e = new PopupMenuEvent(this);</span>
<span class="nc" id="L977">                ((PopupMenuListener)listeners[i+1]).popupMenuWillBecomeInvisible(e);</span>
            }
        }
<span class="nc" id="L980">    }</span>

    /**
     * Notifies &lt;code&gt;PopupMenuListener&lt;/code&gt;s that the popup portion of the
     * combo box has been canceled.
     * &lt;p&gt;
     * This method is public but should not be called by anything other than
     * the UI delegate.
     * @see #addPopupMenuListener
     * @since 1.4
     */
    public void firePopupMenuCanceled() {
<span class="nc" id="L992">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L993">        PopupMenuEvent e=null;</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">            if (listeners[i]==PopupMenuListener.class) {</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L997">                    e = new PopupMenuEvent(this);</span>
<span class="nc" id="L998">                ((PopupMenuListener)listeners[i+1]).popupMenuCanceled(e);</span>
            }
        }
<span class="nc" id="L1001">    }</span>

    /**
     * Sets the action command that should be included in the event
     * sent to action listeners.
     *
     * @param aCommand  a string containing the &quot;command&quot; that is sent
     *                  to action listeners; the same listener can then
     *                  do different things depending on the command it
     *                  receives
     */
    public void setActionCommand(String aCommand) {
<span class="nc" id="L1013">        actionCommand = aCommand;</span>
<span class="nc" id="L1014">    }</span>

    /**
     * Returns the action command that is included in the event sent to
     * action listeners.
     *
     * @return  the string containing the &quot;command&quot; that is sent
     *          to action listeners.
     */
    public String getActionCommand() {
<span class="nc" id="L1024">        return actionCommand;</span>
    }

    private Action action;
    private PropertyChangeListener actionPropertyChangeListener;

    /**
     * Sets the &lt;code&gt;Action&lt;/code&gt; for the &lt;code&gt;ActionEvent&lt;/code&gt; source.
     * The new &lt;code&gt;Action&lt;/code&gt; replaces any previously set
     * &lt;code&gt;Action&lt;/code&gt; but does not affect &lt;code&gt;ActionListeners&lt;/code&gt;
     * independently added with &lt;code&gt;addActionListener&lt;/code&gt;.
     * If the &lt;code&gt;Action&lt;/code&gt; is already a registered
     * &lt;code&gt;ActionListener&lt;/code&gt; for the &lt;code&gt;ActionEvent&lt;/code&gt; source,
     * it is not re-registered.
     * &lt;p&gt;
     * Setting the &lt;code&gt;Action&lt;/code&gt; results in immediately changing
     * all the properties described in &lt;a href=&quot;Action.html#buttonActions&quot;&gt;
     * Swing Components Supporting &lt;code&gt;Action&lt;/code&gt;&lt;/a&gt;.
     * Subsequently, the combobox's properties are automatically updated
     * as the &lt;code&gt;Action&lt;/code&gt;'s properties change.
     * &lt;p&gt;
     * This method uses three other methods to set
     * and help track the &lt;code&gt;Action&lt;/code&gt;'s property values.
     * It uses the &lt;code&gt;configurePropertiesFromAction&lt;/code&gt; method
     * to immediately change the combobox's properties.
     * To track changes in the &lt;code&gt;Action&lt;/code&gt;'s property values,
     * this method registers the &lt;code&gt;PropertyChangeListener&lt;/code&gt;
     * returned by &lt;code&gt;createActionPropertyChangeListener&lt;/code&gt;. The
     * default {@code PropertyChangeListener} invokes the
     * {@code actionPropertyChanged} method when a property in the
     * {@code Action} changes.
     *
     * @param a the &lt;code&gt;Action&lt;/code&gt; for the &lt;code&gt;JComboBox&lt;/code&gt;,
     *                  or &lt;code&gt;null&lt;/code&gt;.
     * @since 1.3
     * @see Action
     * @see #getAction
     * @see #configurePropertiesFromAction
     * @see #createActionPropertyChangeListener
     * @see #actionPropertyChanged
     * @beaninfo
     *        bound: true
     *    attribute: visualUpdate true
     *  description: the Action instance connected with this ActionEvent source
     */
    public void setAction(Action a) {
<span class="nc" id="L1070">        Action oldValue = getAction();</span>
<span class="nc bnc" id="L1071" title="All 4 branches missed.">        if (action==null || !action.equals(a)) {</span>
<span class="nc" id="L1072">            action = a;</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">            if (oldValue!=null) {</span>
<span class="nc" id="L1074">                removeActionListener(oldValue);</span>
<span class="nc" id="L1075">                oldValue.removePropertyChangeListener(actionPropertyChangeListener);</span>
<span class="nc" id="L1076">                actionPropertyChangeListener = null;</span>
            }
<span class="nc" id="L1078">            configurePropertiesFromAction(action);</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">            if (action!=null) {</span>
                // Don't add if it is already a listener
<span class="nc bnc" id="L1081" title="All 2 branches missed.">                if (!isListener(ActionListener.class, action)) {</span>
<span class="nc" id="L1082">                    addActionListener(action);</span>
                }
                // Reverse linkage:
<span class="nc" id="L1085">                actionPropertyChangeListener = createActionPropertyChangeListener(action);</span>
<span class="nc" id="L1086">                action.addPropertyChangeListener(actionPropertyChangeListener);</span>
            }
<span class="nc" id="L1088">            firePropertyChange(&quot;action&quot;, oldValue, action);</span>
        }
<span class="nc" id="L1090">    }</span>

    private boolean isListener(Class c, ActionListener a) {
<span class="nc" id="L1093">        boolean isListener = false;</span>
<span class="nc" id="L1094">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L1096" title="All 4 branches missed.">            if (listeners[i]==c &amp;&amp; listeners[i+1]==a) {</span>
<span class="nc" id="L1097">                    isListener=true;</span>
            }
        }
<span class="nc" id="L1100">        return isListener;</span>
    }

    /**
     * Returns the currently set &lt;code&gt;Action&lt;/code&gt; for this
     * &lt;code&gt;ActionEvent&lt;/code&gt; source, or &lt;code&gt;null&lt;/code&gt; if no
     * &lt;code&gt;Action&lt;/code&gt; is set.
     *
     * @return the &lt;code&gt;Action&lt;/code&gt; for this &lt;code&gt;ActionEvent&lt;/code&gt;
     *          source; or &lt;code&gt;null&lt;/code&gt;
     * @since 1.3
     * @see Action
     * @see #setAction
     */
    public Action getAction() {
<span class="nc" id="L1115">        return action;</span>
    }

    /**
     * Sets the properties on this combobox to match those in the specified
     * &lt;code&gt;Action&lt;/code&gt;.  Refer to &lt;a href=&quot;Action.html#buttonActions&quot;&gt;
     * Swing Components Supporting &lt;code&gt;Action&lt;/code&gt;&lt;/a&gt; for more
     * details as to which properties this sets.
     *
     * @param a the &lt;code&gt;Action&lt;/code&gt; from which to get the properties,
     *          or &lt;code&gt;null&lt;/code&gt;
     * @since 1.3
     * @see Action
     * @see #setAction
     */
    protected void configurePropertiesFromAction(Action a) {
<span class="nc" id="L1131">        AbstractAction.setEnabledFromAction(this, a);</span>
<span class="nc" id="L1132">        AbstractAction.setToolTipTextFromAction(this, a);</span>
<span class="nc" id="L1133">        setActionCommandFromAction(a);</span>
<span class="nc" id="L1134">    }</span>

    /**
     * Creates and returns a &lt;code&gt;PropertyChangeListener&lt;/code&gt; that is
     * responsible for listening for changes from the specified
     * &lt;code&gt;Action&lt;/code&gt; and updating the appropriate properties.
     * &lt;p&gt;
     * &lt;b&gt;Warning:&lt;/b&gt; If you subclass this do not create an anonymous
     * inner class.  If you do the lifetime of the combobox will be tied to
     * that of the &lt;code&gt;Action&lt;/code&gt;.
     *
     * @param a the combobox's action
     * @since 1.3
     * @see Action
     * @see #setAction
     */
    protected PropertyChangeListener createActionPropertyChangeListener(Action a) {
<span class="nc" id="L1151">        return new ComboBoxActionPropertyChangeListener(this, a);</span>
    }

    /**
     * Updates the combobox's state in response to property changes in
     * associated action. This method is invoked from the
     * {@code PropertyChangeListener} returned from
     * {@code createActionPropertyChangeListener}. Subclasses do not normally
     * need to invoke this. Subclasses that support additional {@code Action}
     * properties should override this and
     * {@code configurePropertiesFromAction}.
     * &lt;p&gt;
     * Refer to the table at &lt;a href=&quot;Action.html#buttonActions&quot;&gt;
     * Swing Components Supporting &lt;code&gt;Action&lt;/code&gt;&lt;/a&gt; for a list of
     * the properties this method sets.
     *
     * @param action the &lt;code&gt;Action&lt;/code&gt; associated with this combobox
     * @param propertyName the name of the property that changed
     * @since 1.6
     * @see Action
     * @see #configurePropertiesFromAction
     */
    protected void actionPropertyChanged(Action action, String propertyName) {
<span class="nc bnc" id="L1174" title="All 2 branches missed.">        if (propertyName == Action.ACTION_COMMAND_KEY) {</span>
<span class="nc" id="L1175">            setActionCommandFromAction(action);</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">        } else if (propertyName == &quot;enabled&quot;) {</span>
<span class="nc" id="L1177">            AbstractAction.setEnabledFromAction(this, action);</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        } else if (Action.SHORT_DESCRIPTION == propertyName) {</span>
<span class="nc" id="L1179">            AbstractAction.setToolTipTextFromAction(this, action);</span>
        }
<span class="nc" id="L1181">    }</span>

    private void setActionCommandFromAction(Action a) {
<span class="nc bnc" id="L1184" title="All 2 branches missed.">        setActionCommand((a != null) ?</span>
<span class="nc" id="L1185">                             (String)a.getValue(Action.ACTION_COMMAND_KEY) :</span>
                             null);
<span class="nc" id="L1187">    }</span>


    private static class ComboBoxActionPropertyChangeListener
                 extends ActionPropertyChangeListener&lt;JComboBox&lt;?&gt;&gt; {
        ComboBoxActionPropertyChangeListener(JComboBox&lt;?&gt; b, Action a) {
<span class="nc" id="L1193">            super(b, a);</span>
<span class="nc" id="L1194">        }</span>
        protected void actionPropertyChanged(JComboBox&lt;?&gt; cb,
                                             Action action,
                                             PropertyChangeEvent e) {
<span class="nc bnc" id="L1198" title="All 2 branches missed.">            if (AbstractAction.shouldReconfigure(e)) {</span>
<span class="nc" id="L1199">                cb.configurePropertiesFromAction(action);</span>
            } else {
<span class="nc" id="L1201">                cb.actionPropertyChanged(action, e.getPropertyName());</span>
            }
<span class="nc" id="L1203">        }</span>
    }

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.
     * @param e  the event of interest
     *
     * @see EventListenerList
     */
    protected void fireItemStateChanged(ItemEvent e) {
        // Guaranteed to return a non-null array
<span class="nc" id="L1215">        Object[] listeners = listenerList.getListenerList();</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        for ( int i = listeners.length-2; i&gt;=0; i-=2 ) {</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">            if ( listeners[i]==ItemListener.class ) {</span>
                // Lazily create the event:
                // if (changeEvent == null)
                // changeEvent = new ChangeEvent(this);
<span class="nc" id="L1223">                ((ItemListener)listeners[i+1]).itemStateChanged(e);</span>
            }
        }
<span class="nc" id="L1226">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.
     *
     * @see EventListenerList
     */
    protected void fireActionEvent() {
<span class="nc bnc" id="L1235" title="All 2 branches missed.">        if (!firingActionEvent) {</span>
            // Set flag to ensure that an infinite loop is not created
<span class="nc" id="L1237">            firingActionEvent = true;</span>
<span class="nc" id="L1238">            ActionEvent e = null;</span>
            // Guaranteed to return a non-null array
<span class="nc" id="L1240">            Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L1241">            long mostRecentEventTime = EventQueue.getMostRecentEventTime();</span>
<span class="nc" id="L1242">            int modifiers = 0;</span>
<span class="nc" id="L1243">            AWTEvent currentEvent = EventQueue.getCurrentEvent();</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">            if (currentEvent instanceof InputEvent) {</span>
<span class="nc" id="L1245">                modifiers = ((InputEvent)currentEvent).getModifiers();</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">            } else if (currentEvent instanceof ActionEvent) {</span>
<span class="nc" id="L1247">                modifiers = ((ActionEvent)currentEvent).getModifiers();</span>
            }
            // Process the listeners last to first, notifying
            // those that are interested in this event
<span class="nc bnc" id="L1251" title="All 2 branches missed.">            for ( int i = listeners.length-2; i&gt;=0; i-=2 ) {</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">                if ( listeners[i]==ActionListener.class ) {</span>
                    // Lazily create the event:
<span class="nc bnc" id="L1254" title="All 2 branches missed.">                    if ( e == null )</span>
<span class="nc" id="L1255">                        e = new ActionEvent(this,ActionEvent.ACTION_PERFORMED,</span>
<span class="nc" id="L1256">                                            getActionCommand(),</span>
                                            mostRecentEventTime, modifiers);
<span class="nc" id="L1258">                    ((ActionListener)listeners[i+1]).actionPerformed(e);</span>
                }
            }
<span class="nc" id="L1261">            firingActionEvent = false;</span>
        }
<span class="nc" id="L1263">    }</span>

    /**
     * This protected method is implementation specific. Do not access directly
     * or override.
     */
    protected void selectedItemChanged() {
<span class="nc bnc" id="L1270" title="All 2 branches missed.">        if (selectedItemReminder != null ) {</span>
<span class="nc" id="L1271">            fireItemStateChanged(new ItemEvent(this,ItemEvent.ITEM_STATE_CHANGED,</span>
                                               selectedItemReminder,
                                               ItemEvent.DESELECTED));
        }

        // set the new selected item.
<span class="nc" id="L1277">        selectedItemReminder = dataModel.getSelectedItem();</span>

<span class="nc bnc" id="L1279" title="All 2 branches missed.">        if (selectedItemReminder != null ) {</span>
<span class="nc" id="L1280">            fireItemStateChanged(new ItemEvent(this,ItemEvent.ITEM_STATE_CHANGED,</span>
                                               selectedItemReminder,
                                               ItemEvent.SELECTED));
        }
<span class="nc" id="L1284">    }</span>

    /**
     * Returns an array containing the selected item.
     * This method is implemented for compatibility with
     * &lt;code&gt;ItemSelectable&lt;/code&gt;.
     *
     * @return an array of &lt;code&gt;Objects&lt;/code&gt; containing one
     *          element -- the selected item
     */
    public Object[] getSelectedObjects() {
<span class="nc" id="L1295">        Object selectedObject = getSelectedItem();</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">        if ( selectedObject == null )</span>
<span class="nc" id="L1297">            return new Object[0];</span>
        else {
<span class="nc" id="L1299">            Object result[] = new Object[1];</span>
<span class="nc" id="L1300">            result[0] = selectedObject;</span>
<span class="nc" id="L1301">            return result;</span>
        }
    }

    /**
     * This method is public as an implementation side effect.
     * do not call or override.
     */
    public void actionPerformed(ActionEvent e) {
<span class="nc" id="L1310">        Object newItem = getEditor().getItem();</span>
<span class="nc" id="L1311">        setPopupVisible(false);</span>
<span class="nc" id="L1312">        getModel().setSelectedItem(newItem);</span>
<span class="nc" id="L1313">        String oldCommand = getActionCommand();</span>
<span class="nc" id="L1314">        setActionCommand(&quot;comboBoxEdited&quot;);</span>
<span class="nc" id="L1315">        fireActionEvent();</span>
<span class="nc" id="L1316">        setActionCommand(oldCommand);</span>
<span class="nc" id="L1317">    }</span>

    /**
     * This method is public as an implementation side effect.
     * do not call or override.
     */
    public void contentsChanged(ListDataEvent e) {
<span class="nc" id="L1324">        Object oldSelection = selectedItemReminder;</span>
<span class="nc" id="L1325">        Object newSelection = dataModel.getSelectedItem();</span>
<span class="nc bnc" id="L1326" title="All 4 branches missed.">        if (oldSelection == null || !oldSelection.equals(newSelection)) {</span>
<span class="nc" id="L1327">            selectedItemChanged();</span>
<span class="nc bnc" id="L1328" title="All 2 branches missed.">            if (!selectingItem) {</span>
<span class="nc" id="L1329">                fireActionEvent();</span>
            }
        }
<span class="nc" id="L1332">    }</span>

    /**
     * This method is public as an implementation side effect.
     * do not call or override.
     */
    public void intervalAdded(ListDataEvent e) {
<span class="nc bnc" id="L1339" title="All 2 branches missed.">        if (selectedItemReminder != dataModel.getSelectedItem()) {</span>
<span class="nc" id="L1340">            selectedItemChanged();</span>
        }
<span class="nc" id="L1342">    }</span>

    /**
     * This method is public as an implementation side effect.
     * do not call or override.
     */
    public void intervalRemoved(ListDataEvent e) {
<span class="nc" id="L1349">        contentsChanged(e);</span>
<span class="nc" id="L1350">    }</span>

    /**
     * Selects the list item that corresponds to the specified keyboard
     * character and returns true, if there is an item corresponding
     * to that character.  Otherwise, returns false.
     *
     * @param keyChar a char, typically this is a keyboard key
     *                  typed by the user
     */
    public boolean selectWithKeyChar(char keyChar) {
        int index;

<span class="nc bnc" id="L1363" title="All 2 branches missed.">        if ( keySelectionManager == null )</span>
<span class="nc" id="L1364">            keySelectionManager = createDefaultKeySelectionManager();</span>

<span class="nc" id="L1366">        index = keySelectionManager.selectionForKey(keyChar,getModel());</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">        if ( index != -1 ) {</span>
<span class="nc" id="L1368">            setSelectedIndex(index);</span>
<span class="nc" id="L1369">            return true;</span>
        }
        else
<span class="nc" id="L1372">            return false;</span>
    }

    /**
     * Enables the combo box so that items can be selected. When the
     * combo box is disabled, items cannot be selected and values
     * cannot be typed into its field (if it is editable).
     *
     * @param b a boolean value, where true enables the component and
     *          false disables it
     * @beaninfo
     *        bound: true
     *    preferred: true
     *  description: Whether the combo box is enabled.
     */
    public void setEnabled(boolean b) {
<span class="nc" id="L1388">        super.setEnabled(b);</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">        firePropertyChange( &quot;enabled&quot;, !isEnabled(), isEnabled() );</span>
<span class="nc" id="L1390">    }</span>

    /**
     * Initializes the editor with the specified item.
     *
     * @param anEditor the &lt;code&gt;ComboBoxEditor&lt;/code&gt; that displays
     *                  the list item in the
     *                  combo box field and allows it to be edited
     * @param anItem   the object to display and edit in the field
     */
    public void configureEditor(ComboBoxEditor anEditor, Object anItem) {
<span class="nc" id="L1401">        anEditor.setItem(anItem);</span>
<span class="nc" id="L1402">    }</span>

    /**
     * Handles &lt;code&gt;KeyEvent&lt;/code&gt;s, looking for the Tab key.
     * If the Tab key is found, the popup window is closed.
     *
     * @param e  the &lt;code&gt;KeyEvent&lt;/code&gt; containing the keyboard
     *          key that was pressed
     */
    public void processKeyEvent(KeyEvent e) {
<span class="nc bnc" id="L1412" title="All 2 branches missed.">        if ( e.getKeyCode() == KeyEvent.VK_TAB ) {</span>
<span class="nc" id="L1413">            hidePopup();</span>
        }
<span class="nc" id="L1415">        super.processKeyEvent(e);</span>
<span class="nc" id="L1416">    }</span>

    /**
     * Sets the object that translates a keyboard character into a list
     * selection. Typically, the first selection with a matching first
     * character becomes the selected item.
     *
     * @beaninfo
     *       expert: true
     *  description: The objects that changes the selection when a key is pressed.
     */
    public void setKeySelectionManager(KeySelectionManager aManager) {
<span class="nc" id="L1428">        keySelectionManager = aManager;</span>
<span class="nc" id="L1429">    }</span>

    /**
     * Returns the list's key-selection manager.
     *
     * @return the &lt;code&gt;KeySelectionManager&lt;/code&gt; currently in use
     */
    public KeySelectionManager getKeySelectionManager() {
<span class="nc" id="L1437">        return keySelectionManager;</span>
    }

    /* Accessing the model */
    /**
     * Returns the number of items in the list.
     *
     * @return an integer equal to the number of items in the list
     */
    public int getItemCount() {
<span class="nc" id="L1447">        return dataModel.getSize();</span>
    }

    /**
     * Returns the list item at the specified index.  If &lt;code&gt;index&lt;/code&gt;
     * is out of range (less than zero or greater than or equal to size)
     * it will return &lt;code&gt;null&lt;/code&gt;.
     *
     * @param index  an integer indicating the list position, where the first
     *               item starts at zero
     * @return the item at that list position; or
     *                  &lt;code&gt;null&lt;/code&gt; if out of range
     */
    public E getItemAt(int index) {
<span class="nc" id="L1461">        return dataModel.getElementAt(index);</span>
    }

    /**
     * Returns an instance of the default key-selection manager.
     *
     * @return the &lt;code&gt;KeySelectionManager&lt;/code&gt; currently used by the list
     * @see #setKeySelectionManager
     */
    protected KeySelectionManager createDefaultKeySelectionManager() {
<span class="nc" id="L1471">        return new DefaultKeySelectionManager();</span>
    }


    /**
     * The interface that defines a &lt;code&gt;KeySelectionManager&lt;/code&gt;.
     * To qualify as a &lt;code&gt;KeySelectionManager&lt;/code&gt;,
     * the class needs to implement the method
     * that identifies the list index given a character and the
     * combo box data model.
     */
    public interface KeySelectionManager {
        /** Given &lt;code&gt;aKey&lt;/code&gt; and the model, returns the row
         *  that should become selected. Return -1 if no match was
         *  found.
         *
         * @param  aKey  a char value, usually indicating a keyboard key that
         *               was pressed
         * @param aModel a ComboBoxModel -- the component's data model, containing
         *               the list of selectable items
         * @return an int equal to the selected row, where 0 is the
         *         first item and -1 is none.
         */
        int selectionForKey(char aKey,ComboBoxModel aModel);
    }

<span class="nc" id="L1497">    class DefaultKeySelectionManager implements KeySelectionManager, Serializable {</span>
        public int selectionForKey(char aKey,ComboBoxModel aModel) {
            int i,c;
<span class="nc" id="L1500">            int currentSelection = -1;</span>
<span class="nc" id="L1501">            Object selectedItem = aModel.getSelectedItem();</span>
            String v;
            String pattern;

<span class="nc bnc" id="L1505" title="All 2 branches missed.">            if ( selectedItem != null ) {</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">                for ( i=0,c=aModel.getSize();i&lt;c;i++ ) {</span>
<span class="nc bnc" id="L1507" title="All 2 branches missed.">                    if ( selectedItem == aModel.getElementAt(i) ) {</span>
<span class="nc" id="L1508">                        currentSelection  =  i;</span>
<span class="nc" id="L1509">                        break;</span>
                    }
                }
            }

<span class="nc" id="L1514">            pattern = (&quot;&quot; + aKey).toLowerCase();</span>
<span class="nc" id="L1515">            aKey = pattern.charAt(0);</span>

<span class="nc bnc" id="L1517" title="All 2 branches missed.">            for ( i = ++currentSelection, c = aModel.getSize() ; i &lt; c ; i++ ) {</span>
<span class="nc" id="L1518">                Object elem = aModel.getElementAt(i);</span>
<span class="nc bnc" id="L1519" title="All 4 branches missed.">                if (elem != null &amp;&amp; elem.toString() != null) {</span>
<span class="nc" id="L1520">                    v = elem.toString().toLowerCase();</span>
<span class="nc bnc" id="L1521" title="All 4 branches missed.">                    if ( v.length() &gt; 0 &amp;&amp; v.charAt(0) == aKey )</span>
<span class="nc" id="L1522">                        return i;</span>
                }
            }

<span class="nc bnc" id="L1526" title="All 2 branches missed.">            for ( i = 0 ; i &lt; currentSelection ; i ++ ) {</span>
<span class="nc" id="L1527">                Object elem = aModel.getElementAt(i);</span>
<span class="nc bnc" id="L1528" title="All 4 branches missed.">                if (elem != null &amp;&amp; elem.toString() != null) {</span>
<span class="nc" id="L1529">                    v = elem.toString().toLowerCase();</span>
<span class="nc bnc" id="L1530" title="All 4 branches missed.">                    if ( v.length() &gt; 0 &amp;&amp; v.charAt(0) == aKey )</span>
<span class="nc" id="L1531">                        return i;</span>
                }
            }
<span class="nc" id="L1534">            return -1;</span>
        }
    }


    /**
     * See &lt;code&gt;readObject&lt;/code&gt; and &lt;code&gt;writeObject&lt;/code&gt; in
     * &lt;code&gt;JComponent&lt;/code&gt; for more
     * information about serialization in Swing.
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L1545">        s.defaultWriteObject();</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">        if (getUIClassID().equals(uiClassID)) {</span>
<span class="nc" id="L1547">            byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L1548">            JComponent.setWriteObjCounter(this, --count);</span>
<span class="nc bnc" id="L1549" title="All 4 branches missed.">            if (count == 0 &amp;&amp; ui != null) {</span>
<span class="nc" id="L1550">                ui.installUI(this);</span>
            }
        }
<span class="nc" id="L1553">    }</span>


    /**
     * Returns a string representation of this &lt;code&gt;JComboBox&lt;/code&gt;.
     * This method is intended to be used only for debugging purposes,
     * and the content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this &lt;code&gt;JComboBox&lt;/code&gt;
     */
    protected String paramString() {
<span class="nc bnc" id="L1566" title="All 2 branches missed.">        String selectedItemReminderString = (selectedItemReminder != null ?</span>
<span class="nc" id="L1567">                                             selectedItemReminder.toString() :</span>
                                             &quot;&quot;);
<span class="nc bnc" id="L1569" title="All 2 branches missed.">        String isEditableString = (isEditable ? &quot;true&quot; : &quot;false&quot;);</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">        String lightWeightPopupEnabledString = (lightWeightPopupEnabled ?</span>
                                                &quot;true&quot; : &quot;false&quot;);

<span class="nc" id="L1573">        return super.paramString() +</span>
        &quot;,isEditable=&quot; + isEditableString +
        &quot;,lightWeightPopupEnabled=&quot; + lightWeightPopupEnabledString +
        &quot;,maximumRowCount=&quot; + maximumRowCount +
        &quot;,selectedItemReminder=&quot; + selectedItemReminderString;
    }


///////////////////
// Accessibility support
///////////////////

    /**
     * Gets the AccessibleContext associated with this JComboBox.
     * For combo boxes, the AccessibleContext takes the form of an
     * AccessibleJComboBox.
     * A new AccessibleJComboBox instance is created if necessary.
     *
     * @return an AccessibleJComboBox that serves as the
     *         AccessibleContext of this JComboBox
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L1595" title="All 2 branches missed.">        if ( accessibleContext == null ) {</span>
<span class="nc" id="L1596">            accessibleContext = new AccessibleJComboBox();</span>
        }
<span class="nc" id="L1598">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JComboBox&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to Combo Box user-interface elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    protected class AccessibleJComboBox extends AccessibleJComponent
    implements AccessibleAction, AccessibleSelection {


        private JList popupList; // combo box popup list
<span class="nc" id="L1620">        private Accessible previousSelectedAccessible = null;</span>

        /**
         * Returns an AccessibleJComboBox instance
         * @since 1.4
         */
<span class="nc" id="L1626">        public AccessibleJComboBox() {</span>
            // set the combo box editor's accessible name and description
<span class="nc" id="L1628">            JComboBox.this.addPropertyChangeListener(new AccessibleJComboBoxPropertyChangeListener());</span>
<span class="nc" id="L1629">            setEditorNameAndDescription();</span>

            // Get the popup list
<span class="nc" id="L1632">            Accessible a = getUI().getAccessibleChild(JComboBox.this, 0);</span>
<span class="nc bnc" id="L1633" title="All 2 branches missed.">            if (a instanceof javax.swing.plaf.basic.ComboPopup) {</span>
                // Listen for changes to the popup menu selection.
<span class="nc" id="L1635">                popupList = ((javax.swing.plaf.basic.ComboPopup)a).getList();</span>
<span class="nc" id="L1636">                popupList.addListSelectionListener(</span>
                    new AccessibleJComboBoxListSelectionListener());
            }
            // Listen for popup menu show/hide events
<span class="nc" id="L1640">            JComboBox.this.addPopupMenuListener(</span>
              new AccessibleJComboBoxPopupMenuListener());
<span class="nc" id="L1642">        }</span>

        /*
         * JComboBox PropertyChangeListener
         */
<span class="nc" id="L1647">        private class AccessibleJComboBoxPropertyChangeListener</span>
            implements PropertyChangeListener {

            public void propertyChange(PropertyChangeEvent e) {
<span class="nc bnc" id="L1651" title="All 2 branches missed.">                if (e.getPropertyName() == &quot;editor&quot;) {</span>
                    // set the combo box editor's accessible name
                    // and description
<span class="nc" id="L1654">                    setEditorNameAndDescription();</span>
                }
<span class="nc" id="L1656">            }</span>
        }

        /*
         * Sets the combo box editor's accessible name and descripton
         */
        private void setEditorNameAndDescription() {
<span class="nc" id="L1663">            ComboBoxEditor editor = JComboBox.this.getEditor();</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">            if (editor != null) {</span>
<span class="nc" id="L1665">                Component comp = editor.getEditorComponent();</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">                if (comp instanceof Accessible) {</span>
<span class="nc" id="L1667">                    AccessibleContext ac = comp.getAccessibleContext();</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">                    if (ac != null) { // may be null</span>
<span class="nc" id="L1669">                        ac.setAccessibleName(getAccessibleName());</span>
<span class="nc" id="L1670">                        ac.setAccessibleDescription(getAccessibleDescription());</span>
                    }
                }
            }
<span class="nc" id="L1674">        }</span>

        /*
         * Listener for combo box popup menu
         * TIGER - 4669379 4894434
         */
<span class="nc" id="L1680">        private class AccessibleJComboBoxPopupMenuListener</span>
            implements PopupMenuListener {

            /**
             *  This method is called before the popup menu becomes visible
             */
            public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
                // save the initial selection
<span class="nc bnc" id="L1688" title="All 2 branches missed.">                if (popupList == null) {</span>
<span class="nc" id="L1689">                    return;</span>
                }
<span class="nc" id="L1691">                int selectedIndex = popupList.getSelectedIndex();</span>
<span class="nc bnc" id="L1692" title="All 2 branches missed.">                if (selectedIndex &lt; 0) {</span>
<span class="nc" id="L1693">                    return;</span>
                }
<span class="nc" id="L1695">                previousSelectedAccessible =</span>
<span class="nc" id="L1696">                    popupList.getAccessibleContext().getAccessibleChild(selectedIndex);</span>
<span class="nc" id="L1697">            }</span>

            /**
             * This method is called before the popup menu becomes invisible
             * Note that a JPopupMenu can become invisible any time
             */
            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
                // ignore
<span class="nc" id="L1705">            }</span>

            /**
             * This method is called when the popup menu is canceled
             */
            public void popupMenuCanceled(PopupMenuEvent e) {
                // ignore
<span class="nc" id="L1712">            }</span>
        }

        /*
         * Handles changes to the popup list selection.
         * TIGER - 4669379 4894434 4933143
         */
<span class="nc" id="L1719">        private class AccessibleJComboBoxListSelectionListener</span>
            implements ListSelectionListener {

            public void valueChanged(ListSelectionEvent e) {
<span class="nc bnc" id="L1723" title="All 2 branches missed.">                if (popupList == null) {</span>
<span class="nc" id="L1724">                    return;</span>
                }

                // Get the selected popup list item.
<span class="nc" id="L1728">                int selectedIndex = popupList.getSelectedIndex();</span>
<span class="nc bnc" id="L1729" title="All 2 branches missed.">                if (selectedIndex &lt; 0) {</span>
<span class="nc" id="L1730">                    return;</span>
                }
<span class="nc" id="L1732">                Accessible selectedAccessible =</span>
<span class="nc" id="L1733">                    popupList.getAccessibleContext().getAccessibleChild(selectedIndex);</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">                if (selectedAccessible == null) {</span>
<span class="nc" id="L1735">                    return;</span>
                }

                // Fire a FOCUSED lost PropertyChangeEvent for the
                // previously selected list item.
                PropertyChangeEvent pce;

<span class="nc bnc" id="L1742" title="All 2 branches missed.">                if (previousSelectedAccessible != null) {</span>
<span class="nc" id="L1743">                    pce = new PropertyChangeEvent(previousSelectedAccessible,</span>
                        AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                        AccessibleState.FOCUSED, null);
<span class="nc" id="L1746">                    firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,</span>
                                       null, pce);
                }
                // Fire a FOCUSED gained PropertyChangeEvent for the
                // currently selected list item.
<span class="nc" id="L1751">                pce = new PropertyChangeEvent(selectedAccessible,</span>
                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                    null, AccessibleState.FOCUSED);
<span class="nc" id="L1754">                firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,</span>
                                   null, pce);

                // Fire the ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY event
                // for the combo box.
<span class="nc" id="L1759">                firePropertyChange(AccessibleContext.ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY,</span>
<span class="nc" id="L1760">                                   previousSelectedAccessible, selectedAccessible);</span>

                // Save the previous selection.
<span class="nc" id="L1763">                previousSelectedAccessible = selectedAccessible;</span>
<span class="nc" id="L1764">            }</span>
        }


        /**
         * Returns the number of accessible children in the object.  If all
         * of the children of this object implement Accessible, than this
         * method should return the number of children of this object.
         *
         * @return the number of accessible children in the object.
         */
        public int getAccessibleChildrenCount() {
            // Always delegate to the UI if it exists
<span class="nc bnc" id="L1777" title="All 2 branches missed.">            if (ui != null) {</span>
<span class="nc" id="L1778">                return ui.getAccessibleChildrenCount(JComboBox.this);</span>
            } else {
<span class="nc" id="L1780">                return super.getAccessibleChildrenCount();</span>
            }
        }

        /**
         * Returns the nth Accessible child of the object.
         * The child at index zero represents the popup.
         * If the combo box is editable, the child at index one
         * represents the editor.
         *
         * @param i zero-based index of child
         * @return the nth Accessible child of the object
         */
        public Accessible getAccessibleChild(int i) {
            // Always delegate to the UI if it exists
<span class="nc bnc" id="L1795" title="All 2 branches missed.">            if (ui != null) {</span>
<span class="nc" id="L1796">                return ui.getAccessibleChild(JComboBox.this, i);</span>
            } else {
<span class="nc" id="L1798">               return super.getAccessibleChild(i);</span>
            }
        }

        /**
         * Get the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of the
         * object
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L1810">            return AccessibleRole.COMBO_BOX;</span>
        }

        /**
         * Gets the state set of this object.  The AccessibleStateSet of
         * an object is composed of a set of unique AccessibleStates.
         * A change in the AccessibleStateSet of an object will cause a
         * PropertyChangeEvent to be fired for the ACCESSIBLE_STATE_PROPERTY
         * property.
         *
         * @return an instance of AccessibleStateSet containing the
         * current state set of the object
         * @see AccessibleStateSet
         * @see AccessibleState
         * @see #addPropertyChangeListener
         *
         */
        public AccessibleStateSet getAccessibleStateSet() {
            // TIGER - 4489748
<span class="nc" id="L1829">            AccessibleStateSet ass = super.getAccessibleStateSet();</span>
<span class="nc bnc" id="L1830" title="All 2 branches missed.">            if (ass == null) {</span>
<span class="nc" id="L1831">                ass = new AccessibleStateSet();</span>
            }
<span class="nc bnc" id="L1833" title="All 2 branches missed.">            if (JComboBox.this.isPopupVisible()) {</span>
<span class="nc" id="L1834">                ass.add(AccessibleState.EXPANDED);</span>
            } else {
<span class="nc" id="L1836">                ass.add(AccessibleState.COLLAPSED);</span>
            }
<span class="nc" id="L1838">            return ass;</span>
        }

        /**
         * Get the AccessibleAction associated with this object.  In the
         * implementation of the Java Accessibility API for this class,
         * return this object, which is responsible for implementing the
         * AccessibleAction interface on behalf of itself.
         *
         * @return this object
         */
        public AccessibleAction getAccessibleAction() {
<span class="nc" id="L1850">            return this;</span>
        }

        /**
         * Return a description of the specified action of the object.
         *
         * @param i zero-based index of the actions
         */
        public String getAccessibleActionDescription(int i) {
<span class="nc bnc" id="L1859" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L1860">                return UIManager.getString(&quot;ComboBox.togglePopupText&quot;);</span>
            }
            else {
<span class="nc" id="L1863">                return null;</span>
            }
        }

        /**
         * Returns the number of Actions available in this object.  The
         * default behavior of a combo box is to have one action.
         *
         * @return 1, the number of Actions in this object
         */
        public int getAccessibleActionCount() {
<span class="nc" id="L1874">            return 1;</span>
        }

        /**
         * Perform the specified Action on the object
         *
         * @param i zero-based index of actions
         * @return true if the the action was performed; else false.
         */
        public boolean doAccessibleAction(int i) {
<span class="nc bnc" id="L1884" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">                setPopupVisible(!isPopupVisible());</span>
<span class="nc" id="L1886">                return true;</span>
            }
            else {
<span class="nc" id="L1889">                return false;</span>
            }
        }


        /**
         * Get the AccessibleSelection associated with this object.  In the
         * implementation of the Java Accessibility API for this class,
         * return this object, which is responsible for implementing the
         * AccessibleSelection interface on behalf of itself.
         *
         * @return this object
         */
        public AccessibleSelection getAccessibleSelection() {
<span class="nc" id="L1903">            return this;</span>
        }

        /**
         * Returns the number of Accessible children currently selected.
         * If no children are selected, the return value will be 0.
         *
         * @return the number of items currently selected.
         * @since 1.3
         */
        public int getAccessibleSelectionCount() {
<span class="nc" id="L1914">            Object o = JComboBox.this.getSelectedItem();</span>
<span class="nc bnc" id="L1915" title="All 2 branches missed.">            if (o != null) {</span>
<span class="nc" id="L1916">                return 1;</span>
            } else {
<span class="nc" id="L1918">                return 0;</span>
            }
        }

        /**
         * Returns an Accessible representing the specified selected child
         * in the popup.  If there isn't a selection, or there are
         * fewer children selected than the integer passed in, the return
         * value will be null.
         * &lt;p&gt;Note that the index represents the i-th selected child, which
         * is different from the i-th child.
         *
         * @param i the zero-based index of selected children
         * @return the i-th selected child
         * @see #getAccessibleSelectionCount
         * @since 1.3
         */
        public Accessible getAccessibleSelection(int i) {
            // Get the popup
<span class="nc" id="L1937">            Accessible a =</span>
<span class="nc" id="L1938">                JComboBox.this.getUI().getAccessibleChild(JComboBox.this, 0);</span>
<span class="nc bnc" id="L1939" title="All 4 branches missed.">            if (a != null &amp;&amp;</span>
                a instanceof javax.swing.plaf.basic.ComboPopup) {

                // get the popup list
<span class="nc" id="L1943">                JList list = ((javax.swing.plaf.basic.ComboPopup)a).getList();</span>

                // return the i-th selection in the popup list
<span class="nc" id="L1946">                AccessibleContext ac = list.getAccessibleContext();</span>
<span class="nc bnc" id="L1947" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L1948">                    AccessibleSelection as = ac.getAccessibleSelection();</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">                    if (as != null) {</span>
<span class="nc" id="L1950">                        return as.getAccessibleSelection(i);</span>
                    }
                }
            }
<span class="nc" id="L1954">            return null;</span>
        }

        /**
         * Determines if the current child of this object is selected.
         *
         * @return true if the current child of this object is selected;
         *              else false
         * @param i the zero-based index of the child in this Accessible
         * object.
         * @see AccessibleContext#getAccessibleChild
         * @since 1.3
         */
        public boolean isAccessibleChildSelected(int i) {
<span class="nc bnc" id="L1968" title="All 2 branches missed.">            return JComboBox.this.getSelectedIndex() == i;</span>
        }

        /**
         * Adds the specified Accessible child of the object to the object's
         * selection.  If the object supports multiple selections,
         * the specified child is added to any existing selection, otherwise
         * it replaces any existing selection in the object.  If the
         * specified child is already selected, this method has no effect.
         *
         * @param i the zero-based index of the child
         * @see AccessibleContext#getAccessibleChild
         * @since 1.3
         */
        public void addAccessibleSelection(int i) {
            // TIGER - 4856195
<span class="nc" id="L1984">            clearAccessibleSelection();</span>
<span class="nc" id="L1985">            JComboBox.this.setSelectedIndex(i);</span>
<span class="nc" id="L1986">        }</span>

        /**
         * Removes the specified child of the object from the object's
         * selection.  If the specified item isn't currently selected, this
         * method has no effect.
         *
         * @param i the zero-based index of the child
         * @see AccessibleContext#getAccessibleChild
         * @since 1.3
         */
        public void removeAccessibleSelection(int i) {
<span class="nc bnc" id="L1998" title="All 2 branches missed.">            if (JComboBox.this.getSelectedIndex() == i) {</span>
<span class="nc" id="L1999">                clearAccessibleSelection();</span>
            }
<span class="nc" id="L2001">        }</span>

        /**
         * Clears the selection in the object, so that no children in the
         * object are selected.
         * @since 1.3
         */
        public void clearAccessibleSelection() {
<span class="nc" id="L2009">            JComboBox.this.setSelectedIndex(-1);</span>
<span class="nc" id="L2010">        }</span>

        /**
         * Causes every child of the object to be selected
         * if the object supports multiple selections.
         * @since 1.3
         */
        public void selectAllAccessibleSelection() {
            // do nothing since multiple selection is not supported
<span class="nc" id="L2019">        }</span>

//        public Accessible getAccessibleAt(Point p) {
//            Accessible a = getAccessibleChild(1);
//            if ( a != null ) {
//                return a; // the editor
//            }
//            else {
//                return getAccessibleChild(0); // the list
//            }
//        }
<span class="nc" id="L2030">        private EditorAccessibleContext editorAccessibleContext = null;</span>

<span class="nc" id="L2032">        private class AccessibleEditor implements Accessible {</span>
            public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L2034" title="All 2 branches missed.">                if (editorAccessibleContext == null) {</span>
<span class="nc" id="L2035">                    Component c = JComboBox.this.getEditor().getEditorComponent();</span>
<span class="nc bnc" id="L2036" title="All 2 branches missed.">                    if (c instanceof Accessible) {</span>
<span class="nc" id="L2037">                        editorAccessibleContext =</span>
                            new EditorAccessibleContext((Accessible)c);
                    }
                }
<span class="nc" id="L2041">                return editorAccessibleContext;</span>
            }
        }

        /*
         * Wrapper class for the AccessibleContext implemented by the
         * combo box editor.  Delegates all method calls except
         * getAccessibleIndexInParent to the editor.  The
         * getAccessibleIndexInParent method returns the selected
         * index in the combo box.
         */
        private class EditorAccessibleContext extends AccessibleContext {

            private AccessibleContext ac;

<span class="nc" id="L2056">            private EditorAccessibleContext() {</span>
<span class="nc" id="L2057">            }</span>

            /*
             * @param a the AccessibleContext implemented by the
             * combo box editor
             */
<span class="nc" id="L2063">            EditorAccessibleContext(Accessible a) {</span>
<span class="nc" id="L2064">                this.ac = a.getAccessibleContext();</span>
<span class="nc" id="L2065">            }</span>

            /**
             * Gets the accessibleName property of this object.  The accessibleName
             * property of an object is a localized String that designates the purpose
             * of the object.  For example, the accessibleName property of a label
             * or button might be the text of the label or button itself.  In the
             * case of an object that doesn't display its name, the accessibleName
             * should still be set.  For example, in the case of a text field used
             * to enter the name of a city, the accessibleName for the en_US locale
             * could be 'city.'
             *
             * @return the localized name of the object; null if this
             * object does not have a name
             *
             * @see #setAccessibleName
             */
            public String getAccessibleName() {
<span class="nc" id="L2083">                return ac.getAccessibleName();</span>
            }

            /**
             * Sets the localized accessible name of this object.  Changing the
             * name will cause a PropertyChangeEvent to be fired for the
             * ACCESSIBLE_NAME_PROPERTY property.
             *
             * @param s the new localized name of the object.
             *
             * @see #getAccessibleName
             * @see #addPropertyChangeListener
             *
             * @beaninfo
             *    preferred:   true
             *    description: Sets the accessible name for the component.
             */
            public void setAccessibleName(String s) {
<span class="nc" id="L2101">                ac.setAccessibleName(s);</span>
<span class="nc" id="L2102">            }</span>

            /**
             * Gets the accessibleDescription property of this object.  The
             * accessibleDescription property of this object is a short localized
             * phrase describing the purpose of the object.  For example, in the
             * case of a 'Cancel' button, the accessibleDescription could be
             * 'Ignore changes and close dialog box.'
             *
             * @return the localized description of the object; null if
             * this object does not have a description
             *
             * @see #setAccessibleDescription
             */
            public String getAccessibleDescription() {
<span class="nc" id="L2117">                return ac.getAccessibleDescription();</span>
            }

            /**
             * Sets the accessible description of this object.  Changing the
             * name will cause a PropertyChangeEvent to be fired for the
             * ACCESSIBLE_DESCRIPTION_PROPERTY property.
             *
             * @param s the new localized description of the object
             *
             * @see #setAccessibleName
             * @see #addPropertyChangeListener
             *
             * @beaninfo
             *    preferred:   true
             *    description: Sets the accessible description for the component.
             */
            public void setAccessibleDescription(String s) {
<span class="nc" id="L2135">                ac.setAccessibleDescription(s);</span>
<span class="nc" id="L2136">            }</span>

            /**
             * Gets the role of this object.  The role of the object is the generic
             * purpose or use of the class of this object.  For example, the role
             * of a push button is AccessibleRole.PUSH_BUTTON.  The roles in
             * AccessibleRole are provided so component developers can pick from
             * a set of predefined roles.  This enables assistive technologies to
             * provide a consistent interface to various tweaked subclasses of
             * components (e.g., use AccessibleRole.PUSH_BUTTON for all components
             * that act like a push button) as well as distinguish between subclasses
             * that behave differently (e.g., AccessibleRole.CHECK_BOX for check boxes
             * and AccessibleRole.RADIO_BUTTON for radio buttons).
             * &lt;p&gt;Note that the AccessibleRole class is also extensible, so
             * custom component developers can define their own AccessibleRole's
             * if the set of predefined roles is inadequate.
             *
             * @return an instance of AccessibleRole describing the role of the object
             * @see AccessibleRole
             */
            public AccessibleRole getAccessibleRole() {
<span class="nc" id="L2157">                return ac.getAccessibleRole();</span>
            }

            /**
             * Gets the state set of this object.  The AccessibleStateSet of an object
             * is composed of a set of unique AccessibleStates.  A change in the
             * AccessibleStateSet of an object will cause a PropertyChangeEvent to
             * be fired for the ACCESSIBLE_STATE_PROPERTY property.
             *
             * @return an instance of AccessibleStateSet containing the
             * current state set of the object
             * @see AccessibleStateSet
             * @see AccessibleState
             * @see #addPropertyChangeListener
             */
            public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L2173">                return ac.getAccessibleStateSet();</span>
            }

            /**
             * Gets the Accessible parent of this object.
             *
             * @return the Accessible parent of this object; null if this
             * object does not have an Accessible parent
             */
            public Accessible getAccessibleParent() {
<span class="nc" id="L2183">                return ac.getAccessibleParent();</span>
            }

            /**
             * Sets the Accessible parent of this object.  This is meant to be used
             * only in the situations where the actual component's parent should
             * not be treated as the component's accessible parent and is a method
             * that should only be called by the parent of the accessible child.
             *
             * @param a - Accessible to be set as the parent
             */
            public void setAccessibleParent(Accessible a) {
<span class="nc" id="L2195">                ac.setAccessibleParent(a);</span>
<span class="nc" id="L2196">            }</span>

            /**
             * Gets the 0-based index of this object in its accessible parent.
             *
             * @return the 0-based index of this object in its parent; -1 if this
             * object does not have an accessible parent.
             *
             * @see #getAccessibleParent
             * @see #getAccessibleChildrenCount
             * @see #getAccessibleChild
             */
            public int getAccessibleIndexInParent() {
<span class="nc" id="L2209">                return JComboBox.this.getSelectedIndex();</span>
            }

            /**
             * Returns the number of accessible children of the object.
             *
             * @return the number of accessible children of the object.
             */
            public int getAccessibleChildrenCount() {
<span class="nc" id="L2218">                return ac.getAccessibleChildrenCount();</span>
            }

            /**
             * Returns the specified Accessible child of the object.  The Accessible
             * children of an Accessible object are zero-based, so the first child
             * of an Accessible child is at index 0, the second child is at index 1,
             * and so on.
             *
             * @param i zero-based index of child
             * @return the Accessible child of the object
             * @see #getAccessibleChildrenCount
             */
            public Accessible getAccessibleChild(int i) {
<span class="nc" id="L2232">                return ac.getAccessibleChild(i);</span>
            }

            /**
             * Gets the locale of the component. If the component does not have a
             * locale, then the locale of its parent is returned.
             *
             * @return this component's locale.  If this component does not have
             * a locale, the locale of its parent is returned.
             *
             * @exception IllegalComponentStateException
             * If the Component does not have its own locale and has not yet been
             * added to a containment hierarchy such that the locale can be
             * determined from the containing parent.
             */
            public Locale getLocale() throws IllegalComponentStateException {
<span class="nc" id="L2248">                return ac.getLocale();</span>
            }

            /**
             * Adds a PropertyChangeListener to the listener list.
             * The listener is registered for all Accessible properties and will
             * be called when those properties change.
             *
             * @see #ACCESSIBLE_NAME_PROPERTY
             * @see #ACCESSIBLE_DESCRIPTION_PROPERTY
             * @see #ACCESSIBLE_STATE_PROPERTY
             * @see #ACCESSIBLE_VALUE_PROPERTY
             * @see #ACCESSIBLE_SELECTION_PROPERTY
             * @see #ACCESSIBLE_TEXT_PROPERTY
             * @see #ACCESSIBLE_VISIBLE_DATA_PROPERTY
             *
             * @param listener  The PropertyChangeListener to be added
             */
            public void addPropertyChangeListener(PropertyChangeListener listener) {
<span class="nc" id="L2267">                ac.addPropertyChangeListener(listener);</span>
<span class="nc" id="L2268">            }</span>

            /**
             * Removes a PropertyChangeListener from the listener list.
             * This removes a PropertyChangeListener that was registered
             * for all properties.
             *
             * @param listener  The PropertyChangeListener to be removed
             */
            public void removePropertyChangeListener(PropertyChangeListener listener) {
<span class="nc" id="L2278">                ac.removePropertyChangeListener(listener);</span>
<span class="nc" id="L2279">            }</span>

            /**
             * Gets the AccessibleAction associated with this object that supports
             * one or more actions.
             *
             * @return AccessibleAction if supported by object; else return null
             * @see AccessibleAction
             */
            public AccessibleAction getAccessibleAction() {
<span class="nc" id="L2289">                return ac.getAccessibleAction();</span>
            }

            /**
             * Gets the AccessibleComponent associated with this object that has a
             * graphical representation.
             *
             * @return AccessibleComponent if supported by object; else return null
             * @see AccessibleComponent
             */
            public AccessibleComponent getAccessibleComponent() {
<span class="nc" id="L2300">                return ac.getAccessibleComponent();</span>
            }

            /**
             * Gets the AccessibleSelection associated with this object which allows its
             * Accessible children to be selected.
             *
             * @return AccessibleSelection if supported by object; else return null
             * @see AccessibleSelection
             */
            public AccessibleSelection getAccessibleSelection() {
<span class="nc" id="L2311">                return ac.getAccessibleSelection();</span>
            }

            /**
             * Gets the AccessibleText associated with this object presenting
             * text on the display.
             *
             * @return AccessibleText if supported by object; else return null
             * @see AccessibleText
             */
            public AccessibleText getAccessibleText() {
<span class="nc" id="L2322">                return ac.getAccessibleText();</span>
            }

            /**
             * Gets the AccessibleEditableText associated with this object
             * presenting editable text on the display.
             *
             * @return AccessibleEditableText if supported by object; else return null
             * @see AccessibleEditableText
             */
            public AccessibleEditableText getAccessibleEditableText() {
<span class="nc" id="L2333">                return ac.getAccessibleEditableText();</span>
            }

            /**
             * Gets the AccessibleValue associated with this object that supports a
             * Numerical value.
             *
             * @return AccessibleValue if supported by object; else return null
             * @see AccessibleValue
             */
            public AccessibleValue getAccessibleValue() {
<span class="nc" id="L2344">                return ac.getAccessibleValue();</span>
            }

            /**
             * Gets the AccessibleIcons associated with an object that has
             * one or more associated icons
             *
             * @return an array of AccessibleIcon if supported by object;
             * otherwise return null
             * @see AccessibleIcon
             */
            public AccessibleIcon [] getAccessibleIcon() {
<span class="nc" id="L2356">                return ac.getAccessibleIcon();</span>
            }

            /**
             * Gets the AccessibleRelationSet associated with an object
             *
             * @return an AccessibleRelationSet if supported by object;
             * otherwise return null
             * @see AccessibleRelationSet
             */
            public AccessibleRelationSet getAccessibleRelationSet() {
<span class="nc" id="L2367">                return ac.getAccessibleRelationSet();</span>
            }

            /**
             * Gets the AccessibleTable associated with an object
             *
             * @return an AccessibleTable if supported by object;
             * otherwise return null
             * @see AccessibleTable
             */
            public AccessibleTable getAccessibleTable() {
<span class="nc" id="L2378">                return ac.getAccessibleTable();</span>
            }

            /**
             * Support for reporting bound property changes.  If oldValue and
             * newValue are not equal and the PropertyChangeEvent listener list
             * is not empty, then fire a PropertyChange event to each listener.
             * In general, this is for use by the Accessible objects themselves
             * and should not be called by an application program.
             * @param propertyName  The programmatic name of the property that
             * was changed.
             * @param oldValue  The old value of the property.
             * @param newValue  The new value of the property.
             * @see java.beans.PropertyChangeSupport
             * @see #addPropertyChangeListener
             * @see #removePropertyChangeListener
             * @see #ACCESSIBLE_NAME_PROPERTY
             * @see #ACCESSIBLE_DESCRIPTION_PROPERTY
             * @see #ACCESSIBLE_STATE_PROPERTY
             * @see #ACCESSIBLE_VALUE_PROPERTY
             * @see #ACCESSIBLE_SELECTION_PROPERTY
             * @see #ACCESSIBLE_TEXT_PROPERTY
             * @see #ACCESSIBLE_VISIBLE_DATA_PROPERTY
             */
            public void firePropertyChange(String propertyName,
                                           Object oldValue,
                                           Object newValue) {
<span class="nc" id="L2405">                ac.firePropertyChange(propertyName, oldValue, newValue);</span>
<span class="nc" id="L2406">            }</span>
        }

    } // innerclass AccessibleJComboBox
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>