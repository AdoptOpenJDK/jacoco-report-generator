<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JTable.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JTable.java</span></div><h1>JTable.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing;

import java.util.*;

import java.applet.Applet;
import java.awt.*;
import java.awt.event.*;
import java.awt.print.*;

import java.beans.*;

import java.io.Serializable;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;

import javax.accessibility.*;

import javax.swing.event.*;
import javax.swing.plaf.*;
import javax.swing.table.*;
import javax.swing.border.*;

import java.text.NumberFormat;
import java.text.DateFormat;
import java.text.MessageFormat;

import javax.print.attribute.*;
import javax.print.PrintService;
import sun.reflect.misc.ReflectUtil;

import sun.swing.SwingUtilities2;
import sun.swing.SwingUtilities2.Section;
import static sun.swing.SwingUtilities2.Section.*;
import sun.swing.PrintingStatus;
import sun.swing.SwingLazyValue;

/**
 * The &lt;code&gt;JTable&lt;/code&gt; is used to display and edit regular two-dimensional tables
 * of cells.
 * See &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/table.html&quot;&gt;How to Use Tables&lt;/a&gt;
 * in &lt;em&gt;The Java Tutorial&lt;/em&gt;
 * for task-oriented documentation and examples of using &lt;code&gt;JTable&lt;/code&gt;.
 *
 * &lt;p&gt;
 * The &lt;code&gt;JTable&lt;/code&gt; has many
 * facilities that make it possible to customize its rendering and editing
 * but provides defaults for these features so that simple tables can be
 * set up easily.  For example, to set up a table with 10 rows and 10
 * columns of numbers:
 * &lt;p&gt;
 * &lt;pre&gt;
 *      TableModel dataModel = new AbstractTableModel() {
 *          public int getColumnCount() { return 10; }
 *          public int getRowCount() { return 10;}
 *          public Object getValueAt(int row, int col) { return new Integer(row*col); }
 *      };
 *      JTable table = new JTable(dataModel);
 *      JScrollPane scrollpane = new JScrollPane(table);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * {@code JTable}s are typically placed inside of a {@code JScrollPane}.  By
 * default, a {@code JTable} will adjust its width such that
 * a horizontal scrollbar is unnecessary.  To allow for a horizontal scrollbar,
 * invoke {@link #setAutoResizeMode} with {@code AUTO_RESIZE_OFF}.
 * Note that if you wish to use a &lt;code&gt;JTable&lt;/code&gt; in a standalone
 * view (outside of a &lt;code&gt;JScrollPane&lt;/code&gt;) and want the header
 * displayed, you can get it using {@link #getTableHeader} and
 * display it separately.
 * &lt;p&gt;
 * To enable sorting and filtering of rows, use a
 * {@code RowSorter}.
 * You can set up a row sorter in either of two ways:
 * &lt;ul&gt;
 *   &lt;li&gt;Directly set the {@code RowSorter}. For example:
 *        {@code table.setRowSorter(new TableRowSorter(model))}.
 *   &lt;li&gt;Set the {@code autoCreateRowSorter}
 *       property to {@code true}, so that the {@code JTable}
 *       creates a {@code RowSorter} for
 *       you. For example: {@code setAutoCreateRowSorter(true)}.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * When designing applications that use the &lt;code&gt;JTable&lt;/code&gt; it is worth paying
 * close attention to the data structures that will represent the table's data.
 * The &lt;code&gt;DefaultTableModel&lt;/code&gt; is a model implementation that
 * uses a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Vector&lt;/code&gt;s of &lt;code&gt;Object&lt;/code&gt;s to
 * store the cell values. As well as copying the data from an
 * application into the &lt;code&gt;DefaultTableModel&lt;/code&gt;,
 * it is also possible to wrap the data in the methods of the
 * &lt;code&gt;TableModel&lt;/code&gt; interface so that the data can be passed to the
 * &lt;code&gt;JTable&lt;/code&gt; directly, as in the example above. This often results
 * in more efficient applications because the model is free to choose the
 * internal representation that best suits the data.
 * A good rule of thumb for deciding whether to use the &lt;code&gt;AbstractTableModel&lt;/code&gt;
 * or the &lt;code&gt;DefaultTableModel&lt;/code&gt; is to use the &lt;code&gt;AbstractTableModel&lt;/code&gt;
 * as the base class for creating subclasses and the &lt;code&gt;DefaultTableModel&lt;/code&gt;
 * when subclassing is not required.
 * &lt;p&gt;
 * The &quot;TableExample&quot; directory in the demo area of the source distribution
 * gives a number of complete examples of &lt;code&gt;JTable&lt;/code&gt; usage,
 * covering how the &lt;code&gt;JTable&lt;/code&gt; can be used to provide an
 * editable view of data taken from a database and how to modify
 * the columns in the display to use specialized renderers and editors.
 * &lt;p&gt;
 * The &lt;code&gt;JTable&lt;/code&gt; uses integers exclusively to refer to both the rows and the columns
 * of the model that it displays. The &lt;code&gt;JTable&lt;/code&gt; simply takes a tabular range of cells
 * and uses &lt;code&gt;getValueAt(int, int)&lt;/code&gt; to retrieve the
 * values from the model during painting.  It is important to remember that
 * the column and row indexes returned by various &lt;code&gt;JTable&lt;/code&gt; methods
 * are in terms of the &lt;code&gt;JTable&lt;/code&gt; (the view) and are not
 * necessarily the same indexes used by the model.
 * &lt;p&gt;
 * By default, columns may be rearranged in the &lt;code&gt;JTable&lt;/code&gt; so that the
 * view's columns appear in a different order to the columns in the model.
 * This does not affect the implementation of the model at all: when the
 * columns are reordered, the &lt;code&gt;JTable&lt;/code&gt; maintains the new order of the columns
 * internally and converts its column indices before querying the model.
 * &lt;p&gt;
 * So, when writing a &lt;code&gt;TableModel&lt;/code&gt;, it is not necessary to listen for column
 * reordering events as the model will be queried in its own coordinate
 * system regardless of what is happening in the view.
 * In the examples area there is a demonstration of a sorting algorithm making
 * use of exactly this technique to interpose yet another coordinate system
 * where the order of the rows is changed, rather than the order of the columns.
 * &lt;p&gt;
 * Similarly when using the sorting and filtering functionality
 * provided by &lt;code&gt;RowSorter&lt;/code&gt; the underlying
 * &lt;code&gt;TableModel&lt;/code&gt; does not need to know how to do sorting,
 * rather &lt;code&gt;RowSorter&lt;/code&gt; will handle it.  Coordinate
 * conversions will be necessary when using the row based methods of
 * &lt;code&gt;JTable&lt;/code&gt; with the underlying &lt;code&gt;TableModel&lt;/code&gt;.
 * All of &lt;code&gt;JTable&lt;/code&gt;s row based methods are in terms of the
 * &lt;code&gt;RowSorter&lt;/code&gt;, which is not necessarily the same as that
 * of the underlying &lt;code&gt;TableModel&lt;/code&gt;.  For example, the
 * selection is always in terms of &lt;code&gt;JTable&lt;/code&gt; so that when
 * using &lt;code&gt;RowSorter&lt;/code&gt; you will need to convert using
 * &lt;code&gt;convertRowIndexToView&lt;/code&gt; or
 * &lt;code&gt;convertRowIndexToModel&lt;/code&gt;.  The following shows how to
 * convert coordinates from &lt;code&gt;JTable&lt;/code&gt; to that of the
 * underlying model:
 * &lt;pre&gt;
 *   int[] selection = table.getSelectedRows();
 *   for (int i = 0; i &amp;lt; selection.length; i++) {
 *     selection[i] = table.convertRowIndexToModel(selection[i]);
 *   }
 *   // selection is now in terms of the underlying TableModel
 * &lt;/pre&gt;
 * &lt;p&gt;
 * By default if sorting is enabled &lt;code&gt;JTable&lt;/code&gt; will persist the
 * selection and variable row heights in terms of the model on
 * sorting.  For example if row 0, in terms of the underlying model,
 * is currently selected, after the sort row 0, in terms of the
 * underlying model will be selected.  Visually the selection may
 * change, but in terms of the underlying model it will remain the
 * same.  The one exception to that is if the model index is no longer
 * visible or was removed.  For example, if row 0 in terms of model
 * was filtered out the selection will be empty after the sort.
 * &lt;p&gt;
 * J2SE 5 adds methods to &lt;code&gt;JTable&lt;/code&gt; to provide convenient access to some
 * common printing needs. Simple new {@link #print()} methods allow for quick
 * and easy addition of printing support to your application. In addition, a new
 * {@link #getPrintable} method is available for more advanced printing needs.
 * &lt;p&gt;
 * As for all &lt;code&gt;JComponent&lt;/code&gt; classes, you can use
 * {@link InputMap} and {@link ActionMap} to associate an
 * {@link Action} object with a {@link KeyStroke} and execute the
 * action under specified conditions.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 *
 * @beaninfo
 *   attribute: isContainer false
 * description: A component which displays data in a two dimensional grid.
 *
 * @author Philip Milne
 * @author Shannon Hickey (printing support)
 * @see javax.swing.table.DefaultTableModel
 * @see javax.swing.table.TableRowSorter
 */
/* The first versions of the JTable, contained in Swing-0.1 through
 * Swing-0.4, were written by Alan Chung.
 */
<span class="nc bnc" id="L221" title="All 2 branches missed.">public class JTable extends JComponent implements TableModelListener, Scrollable,</span>
    TableColumnModelListener, ListSelectionListener, CellEditorListener,
    Accessible, RowSorterListener
{
//
// Static Constants
//

    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;TableUI&quot;;

    /** Do not adjust column widths automatically; use a horizontal scrollbar instead. */
    public static final int     AUTO_RESIZE_OFF = 0;

    /** When a column is adjusted in the UI, adjust the next column the opposite way. */
    public static final int     AUTO_RESIZE_NEXT_COLUMN = 1;

    /** During UI adjustment, change subsequent columns to preserve the total width;
      * this is the default behavior. */
    public static final int     AUTO_RESIZE_SUBSEQUENT_COLUMNS = 2;

    /** During all resize operations, apply adjustments to the last column only. */
    public static final int     AUTO_RESIZE_LAST_COLUMN = 3;

    /** During all resize operations, proportionately resize all columns. */
    public static final int     AUTO_RESIZE_ALL_COLUMNS = 4;


    /**
     * Printing modes, used in printing &lt;code&gt;JTable&lt;/code&gt;s.
     *
     * @see #print(JTable.PrintMode, MessageFormat, MessageFormat,
     *             boolean, PrintRequestAttributeSet, boolean)
     * @see #getPrintable
     * @since 1.5
     */
<span class="nc" id="L260">    public enum PrintMode {</span>

        /**
         * Printing mode that prints the table at its current size,
         * spreading both columns and rows across multiple pages if necessary.
         */
<span class="nc" id="L266">        NORMAL,</span>

        /**
         * Printing mode that scales the output smaller, if necessary,
         * to fit the table's entire width (and thereby all columns) on each page;
         * Rows are spread across multiple pages as necessary.
         */
<span class="nc" id="L273">        FIT_WIDTH</span>
    }


//
// Instance Variables
//

    /** The &lt;code&gt;TableModel&lt;/code&gt; of the table. */
    protected TableModel        dataModel;

    /** The &lt;code&gt;TableColumnModel&lt;/code&gt; of the table. */
    protected TableColumnModel  columnModel;

    /** The &lt;code&gt;ListSelectionModel&lt;/code&gt; of the table, used to keep track of row selections. */
    protected ListSelectionModel selectionModel;

    /** The &lt;code&gt;TableHeader&lt;/code&gt; working with the table. */
    protected JTableHeader      tableHeader;

    /** The height in pixels of each row in the table. */
    protected int               rowHeight;

    /** The height in pixels of the margin between the cells in each row. */
    protected int               rowMargin;

    /** The color of the grid. */
    protected Color             gridColor;

    /** The table draws horizontal lines between cells if &lt;code&gt;showHorizontalLines&lt;/code&gt; is true. */
    protected boolean           showHorizontalLines;

    /** The table draws vertical lines between cells if &lt;code&gt;showVerticalLines&lt;/code&gt; is true. */
    protected boolean           showVerticalLines;

    /**
     *  Determines if the table automatically resizes the
     *  width of the table's columns to take up the entire width of the
     *  table, and how it does the resizing.
     */
    protected int               autoResizeMode;

    /**
     *  The table will query the &lt;code&gt;TableModel&lt;/code&gt; to build the default
     *  set of columns if this is true.
     */
    protected boolean           autoCreateColumnsFromModel;

    /** Used by the &lt;code&gt;Scrollable&lt;/code&gt; interface to determine the initial visible area. */
    protected Dimension         preferredViewportSize;

    /** True if row selection is allowed in this table. */
    protected boolean           rowSelectionAllowed;

    /**
     * Obsolete as of Java 2 platform v1.3.  Please use the
     * &lt;code&gt;rowSelectionAllowed&lt;/code&gt; property and the
     * &lt;code&gt;columnSelectionAllowed&lt;/code&gt; property of the
     * &lt;code&gt;columnModel&lt;/code&gt; instead. Or use the
     * method &lt;code&gt;getCellSelectionEnabled&lt;/code&gt;.
     */
    /*
     * If true, both a row selection and a column selection
     * can be non-empty at the same time, the selected cells are the
     * the cells whose row and column are both selected.
     */
    protected boolean           cellSelectionEnabled;

    /** If editing, the &lt;code&gt;Component&lt;/code&gt; that is handling the editing. */
    transient protected Component       editorComp;

    /**
     * The active cell editor object, that overwrites the screen real estate
     * occupied by the current cell and allows the user to change its contents.
     * {@code null} if the table isn't currently editing.
     */
    transient protected TableCellEditor cellEditor;

    /** Identifies the column of the cell being edited. */
    transient protected int             editingColumn;

    /** Identifies the row of the cell being edited. */
    transient protected int             editingRow;

    /**
     * A table of objects that display the contents of a cell,
     * indexed by class as declared in &lt;code&gt;getColumnClass&lt;/code&gt;
     * in the &lt;code&gt;TableModel&lt;/code&gt; interface.
     */
    transient protected Hashtable defaultRenderersByColumnClass;

    /**
     * A table of objects that display and edit the contents of a cell,
     * indexed by class as declared in &lt;code&gt;getColumnClass&lt;/code&gt;
     * in the &lt;code&gt;TableModel&lt;/code&gt; interface.
     */
    transient protected Hashtable defaultEditorsByColumnClass;

    /** The foreground color of selected cells. */
    protected Color selectionForeground;

    /** The background color of selected cells. */
    protected Color selectionBackground;

//
// Private state
//

    // WARNING: If you directly access this field you should also change the
    // SortManager.modelRowSizes field as well.
    private SizeSequence rowModel;
    private boolean dragEnabled;
    private boolean surrendersFocusOnKeystroke;
<span class="nc" id="L386">    private PropertyChangeListener editorRemover = null;</span>
    /**
     * The last value of getValueIsAdjusting from the column selection models
     * columnSelectionChanged notification. Used to test if a repaint is
     * needed.
     */
    private boolean columnSelectionAdjusting;
    /**
     * The last value of getValueIsAdjusting from the row selection models
     * valueChanged notification. Used to test if a repaint is needed.
     */
    private boolean rowSelectionAdjusting;

    /**
     * To communicate errors between threads during printing.
     */
    private Throwable printError;

    /**
     * True when setRowHeight(int) has been invoked.
     */
    private boolean isRowHeightSet;

    /**
     * If true, on a sort the selection is reset.
     */
    private boolean updateSelectionOnSort;

    /**
     * Information used in sorting.
     */
    private transient SortManager sortManager;

    /**
     * If true, when sorterChanged is invoked it's value is ignored.
     */
    private boolean ignoreSortChange;

    /**
     * Whether or not sorterChanged has been invoked.
     */
    private boolean sorterChanged;

    /**
     * If true, any time the model changes a new RowSorter is set.
     */
    private boolean autoCreateRowSorter;

    /**
     * Whether or not the table always fills the viewport height.
     * @see #setFillsViewportHeight
     * @see #getScrollableTracksViewportHeight
     */
    private boolean fillsViewportHeight;

    /**
     * The drop mode for this component.
     */
<span class="nc" id="L444">    private DropMode dropMode = DropMode.USE_SELECTION;</span>

    /**
     * The drop location.
     */
    private transient DropLocation dropLocation;

    /**
     * A subclass of &lt;code&gt;TransferHandler.DropLocation&lt;/code&gt; representing
     * a drop location for a &lt;code&gt;JTable&lt;/code&gt;.
     *
     * @see #getDropLocation
     * @since 1.6
     */
    public static final class DropLocation extends TransferHandler.DropLocation {
        private final int row;
        private final int col;
        private final boolean isInsertRow;
        private final boolean isInsertCol;

        private DropLocation(Point p, int row, int col,
                             boolean isInsertRow, boolean isInsertCol) {

<span class="nc" id="L467">            super(p);</span>
<span class="nc" id="L468">            this.row = row;</span>
<span class="nc" id="L469">            this.col = col;</span>
<span class="nc" id="L470">            this.isInsertRow = isInsertRow;</span>
<span class="nc" id="L471">            this.isInsertCol = isInsertCol;</span>
<span class="nc" id="L472">        }</span>

        /**
         * Returns the row index where a dropped item should be placed in the
         * table. Interpretation of the value depends on the return of
         * &lt;code&gt;isInsertRow()&lt;/code&gt;. If that method returns
         * &lt;code&gt;true&lt;/code&gt; this value indicates the index where a new
         * row should be inserted. Otherwise, it represents the value
         * of an existing row on which the data was dropped. This index is
         * in terms of the view.
         * &lt;p&gt;
         * &lt;code&gt;-1&lt;/code&gt; indicates that the drop occurred over empty space,
         * and no row could be calculated.
         *
         * @return the drop row
         */
        public int getRow() {
<span class="nc" id="L489">            return row;</span>
        }

        /**
         * Returns the column index where a dropped item should be placed in the
         * table. Interpretation of the value depends on the return of
         * &lt;code&gt;isInsertColumn()&lt;/code&gt;. If that method returns
         * &lt;code&gt;true&lt;/code&gt; this value indicates the index where a new
         * column should be inserted. Otherwise, it represents the value
         * of an existing column on which the data was dropped. This index is
         * in terms of the view.
         * &lt;p&gt;
         * &lt;code&gt;-1&lt;/code&gt; indicates that the drop occurred over empty space,
         * and no column could be calculated.
         *
         * @return the drop row
         */
        public int getColumn() {
<span class="nc" id="L507">            return col;</span>
        }

        /**
         * Returns whether or not this location represents an insert
         * of a row.
         *
         * @return whether or not this is an insert row
         */
        public boolean isInsertRow() {
<span class="nc" id="L517">            return isInsertRow;</span>
        }

        /**
         * Returns whether or not this location represents an insert
         * of a column.
         *
         * @return whether or not this is an insert column
         */
        public boolean isInsertColumn() {
<span class="nc" id="L527">            return isInsertCol;</span>
        }

        /**
         * Returns a string representation of this drop location.
         * This method is intended to be used for debugging purposes,
         * and the content and format of the returned string may vary
         * between implementations.
         *
         * @return a string representation of this drop location
         */
        public String toString() {
<span class="nc" id="L539">            return getClass().getName()</span>
<span class="nc" id="L540">                   + &quot;[dropPoint=&quot; + getDropPoint() + &quot;,&quot;</span>
                   + &quot;row=&quot; + row + &quot;,&quot;
                   + &quot;column=&quot; + col + &quot;,&quot;
                   + &quot;insertRow=&quot; + isInsertRow + &quot;,&quot;
                   + &quot;insertColumn=&quot; + isInsertCol + &quot;]&quot;;
        }
    }

//
// Constructors
//

    /**
     * Constructs a default &lt;code&gt;JTable&lt;/code&gt; that is initialized with a default
     * data model, a default column model, and a default selection
     * model.
     *
     * @see #createDefaultDataModel
     * @see #createDefaultColumnModel
     * @see #createDefaultSelectionModel
     */
    public JTable() {
<span class="nc" id="L562">        this(null, null, null);</span>
<span class="nc" id="L563">    }</span>

    /**
     * Constructs a &lt;code&gt;JTable&lt;/code&gt; that is initialized with
     * &lt;code&gt;dm&lt;/code&gt; as the data model, a default column model,
     * and a default selection model.
     *
     * @param dm        the data model for the table
     * @see #createDefaultColumnModel
     * @see #createDefaultSelectionModel
     */
    public JTable(TableModel dm) {
<span class="nc" id="L575">        this(dm, null, null);</span>
<span class="nc" id="L576">    }</span>

    /**
     * Constructs a &lt;code&gt;JTable&lt;/code&gt; that is initialized with
     * &lt;code&gt;dm&lt;/code&gt; as the data model, &lt;code&gt;cm&lt;/code&gt;
     * as the column model, and a default selection model.
     *
     * @param dm        the data model for the table
     * @param cm        the column model for the table
     * @see #createDefaultSelectionModel
     */
    public JTable(TableModel dm, TableColumnModel cm) {
<span class="nc" id="L588">        this(dm, cm, null);</span>
<span class="nc" id="L589">    }</span>

    /**
     * Constructs a &lt;code&gt;JTable&lt;/code&gt; that is initialized with
     * &lt;code&gt;dm&lt;/code&gt; as the data model, &lt;code&gt;cm&lt;/code&gt; as the
     * column model, and &lt;code&gt;sm&lt;/code&gt; as the selection model.
     * If any of the parameters are &lt;code&gt;null&lt;/code&gt; this method
     * will initialize the table with the corresponding default model.
     * The &lt;code&gt;autoCreateColumnsFromModel&lt;/code&gt; flag is set to false
     * if &lt;code&gt;cm&lt;/code&gt; is non-null, otherwise it is set to true
     * and the column model is populated with suitable
     * &lt;code&gt;TableColumns&lt;/code&gt; for the columns in &lt;code&gt;dm&lt;/code&gt;.
     *
     * @param dm        the data model for the table
     * @param cm        the column model for the table
     * @param sm        the row selection model for the table
     * @see #createDefaultDataModel
     * @see #createDefaultColumnModel
     * @see #createDefaultSelectionModel
     */
    public JTable(TableModel dm, TableColumnModel cm, ListSelectionModel sm) {
<span class="nc" id="L610">        super();</span>
<span class="nc" id="L611">        setLayout(null);</span>

<span class="nc" id="L613">        setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,</span>
<span class="nc" id="L614">                           JComponent.getManagingFocusForwardTraversalKeys());</span>
<span class="nc" id="L615">        setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,</span>
<span class="nc" id="L616">                           JComponent.getManagingFocusBackwardTraversalKeys());</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (cm == null) {</span>
<span class="nc" id="L618">            cm = createDefaultColumnModel();</span>
<span class="nc" id="L619">            autoCreateColumnsFromModel = true;</span>
        }
<span class="nc" id="L621">        setColumnModel(cm);</span>

<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (sm == null) {</span>
<span class="nc" id="L624">            sm = createDefaultSelectionModel();</span>
        }
<span class="nc" id="L626">        setSelectionModel(sm);</span>

    // Set the model last, that way if the autoCreatColumnsFromModel has
    // been set above, we will automatically populate an empty columnModel
    // with suitable columns for the new model.
<span class="nc bnc" id="L631" title="All 2 branches missed.">        if (dm == null) {</span>
<span class="nc" id="L632">            dm = createDefaultDataModel();</span>
        }
<span class="nc" id="L634">        setModel(dm);</span>

<span class="nc" id="L636">        initializeLocalVars();</span>
<span class="nc" id="L637">        updateUI();</span>
<span class="nc" id="L638">    }</span>

    /**
     * Constructs a &lt;code&gt;JTable&lt;/code&gt; with &lt;code&gt;numRows&lt;/code&gt;
     * and &lt;code&gt;numColumns&lt;/code&gt; of empty cells using
     * &lt;code&gt;DefaultTableModel&lt;/code&gt;.  The columns will have
     * names of the form &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, etc.
     *
     * @param numRows           the number of rows the table holds
     * @param numColumns        the number of columns the table holds
     * @see javax.swing.table.DefaultTableModel
     */
    public JTable(int numRows, int numColumns) {
<span class="nc" id="L651">        this(new DefaultTableModel(numRows, numColumns));</span>
<span class="nc" id="L652">    }</span>

    /**
     * Constructs a &lt;code&gt;JTable&lt;/code&gt; to display the values in the
     * &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Vectors&lt;/code&gt;, &lt;code&gt;rowData&lt;/code&gt;,
     * with column names, &lt;code&gt;columnNames&lt;/code&gt;.  The
     * &lt;code&gt;Vectors&lt;/code&gt; contained in &lt;code&gt;rowData&lt;/code&gt;
     * should contain the values for that row. In other words,
     * the value of the cell at row 1, column 5 can be obtained
     * with the following code:
     * &lt;p&gt;
     * &lt;pre&gt;((Vector)rowData.elementAt(1)).elementAt(5);&lt;/pre&gt;
     * &lt;p&gt;
     * @param rowData           the data for the new table
     * @param columnNames       names of each column
     */
    public JTable(Vector rowData, Vector columnNames) {
<span class="nc" id="L669">        this(new DefaultTableModel(rowData, columnNames));</span>
<span class="nc" id="L670">    }</span>

    /**
     * Constructs a &lt;code&gt;JTable&lt;/code&gt; to display the values in the two dimensional array,
     * &lt;code&gt;rowData&lt;/code&gt;, with column names, &lt;code&gt;columnNames&lt;/code&gt;.
     * &lt;code&gt;rowData&lt;/code&gt; is an array of rows, so the value of the cell at row 1,
     * column 5 can be obtained with the following code:
     * &lt;p&gt;
     * &lt;pre&gt; rowData[1][5]; &lt;/pre&gt;
     * &lt;p&gt;
     * All rows must be of the same length as &lt;code&gt;columnNames&lt;/code&gt;.
     * &lt;p&gt;
     * @param rowData           the data for the new table
     * @param columnNames       names of each column
     */
    public JTable(final Object[][] rowData, final Object[] columnNames) {
<span class="nc" id="L686">        this(new AbstractTableModel() {</span>
<span class="nc" id="L687">            public String getColumnName(int column) { return columnNames[column].toString(); }</span>
<span class="nc" id="L688">            public int getRowCount() { return rowData.length; }</span>
<span class="nc" id="L689">            public int getColumnCount() { return columnNames.length; }</span>
<span class="nc" id="L690">            public Object getValueAt(int row, int col) { return rowData[row][col]; }</span>
<span class="nc" id="L691">            public boolean isCellEditable(int row, int column) { return true; }</span>
            public void setValueAt(Object value, int row, int col) {
<span class="nc" id="L693">                rowData[row][col] = value;</span>
<span class="nc" id="L694">                fireTableCellUpdated(row, col);</span>
<span class="nc" id="L695">            }</span>
        });
<span class="nc" id="L697">    }</span>

    /**
     * Calls the &lt;code&gt;configureEnclosingScrollPane&lt;/code&gt; method.
     *
     * @see #configureEnclosingScrollPane
     */
    public void addNotify() {
<span class="nc" id="L705">        super.addNotify();</span>
<span class="nc" id="L706">        configureEnclosingScrollPane();</span>
<span class="nc" id="L707">    }</span>

    /**
     * If this &lt;code&gt;JTable&lt;/code&gt; is the &lt;code&gt;viewportView&lt;/code&gt; of an enclosing &lt;code&gt;JScrollPane&lt;/code&gt;
     * (the usual situation), configure this &lt;code&gt;ScrollPane&lt;/code&gt; by, amongst other things,
     * installing the table's &lt;code&gt;tableHeader&lt;/code&gt; as the &lt;code&gt;columnHeaderView&lt;/code&gt; of the scroll pane.
     * When a &lt;code&gt;JTable&lt;/code&gt; is added to a &lt;code&gt;JScrollPane&lt;/code&gt; in the usual way,
     * using &lt;code&gt;new JScrollPane(myTable)&lt;/code&gt;, &lt;code&gt;addNotify&lt;/code&gt; is
     * called in the &lt;code&gt;JTable&lt;/code&gt; (when the table is added to the viewport).
     * &lt;code&gt;JTable&lt;/code&gt;'s &lt;code&gt;addNotify&lt;/code&gt; method in turn calls this method,
     * which is protected so that this default installation procedure can
     * be overridden by a subclass.
     *
     * @see #addNotify
     */
    protected void configureEnclosingScrollPane() {
<span class="nc" id="L723">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc" id="L725">            JViewport port = (JViewport) parent;</span>
<span class="nc" id="L726">            Container gp = port.getParent();</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (gp instanceof JScrollPane) {</span>
<span class="nc" id="L728">                JScrollPane scrollPane = (JScrollPane)gp;</span>
                // Make certain we are the viewPort's view and not, for
                // example, the rowHeaderView of the scrollPane -
                // an implementor of fixed columns might do this.
<span class="nc" id="L732">                JViewport viewport = scrollPane.getViewport();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                if (viewport == null ||</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">                        SwingUtilities.getUnwrappedView(viewport) != this) {</span>
<span class="nc" id="L735">                    return;</span>
                }
<span class="nc" id="L737">                scrollPane.setColumnHeaderView(getTableHeader());</span>
                // configure the scrollpane for any LAF dependent settings
<span class="nc" id="L739">                configureEnclosingScrollPaneUI();</span>
            }
        }
<span class="nc" id="L742">    }</span>

    /**
     * This is a sub-part of configureEnclosingScrollPane() that configures
     * anything on the scrollpane that may change when the look and feel
     * changes. It needed to be split out from configureEnclosingScrollPane() so
     * that it can be called from updateUI() when the LAF changes without
     * causing the regression found in bug 6687962. This was because updateUI()
     * is called from the constructor which then caused
     * configureEnclosingScrollPane() to be called by the constructor which
     * changes its contract for any subclass that overrides it. So by splitting
     * it out in this way configureEnclosingScrollPaneUI() can be called both
     * from configureEnclosingScrollPane() and updateUI() in a safe manor.
     */
    private void configureEnclosingScrollPaneUI() {
<span class="nc" id="L757">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc" id="L759">            JViewport port = (JViewport) parent;</span>
<span class="nc" id="L760">            Container gp = port.getParent();</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">            if (gp instanceof JScrollPane) {</span>
<span class="nc" id="L762">                JScrollPane scrollPane = (JScrollPane)gp;</span>
                // Make certain we are the viewPort's view and not, for
                // example, the rowHeaderView of the scrollPane -
                // an implementor of fixed columns might do this.
<span class="nc" id="L766">                JViewport viewport = scrollPane.getViewport();</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">                if (viewport == null ||</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">                        SwingUtilities.getUnwrappedView(viewport) != this) {</span>
<span class="nc" id="L769">                    return;</span>
                }
                //  scrollPane.getViewport().setBackingStoreEnabled(true);
<span class="nc" id="L772">                Border border = scrollPane.getBorder();</span>
<span class="nc bnc" id="L773" title="All 4 branches missed.">                if (border == null || border instanceof UIResource) {</span>
<span class="nc" id="L774">                    Border scrollPaneBorder =</span>
<span class="nc" id="L775">                        UIManager.getBorder(&quot;Table.scrollPaneBorder&quot;);</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">                    if (scrollPaneBorder != null) {</span>
<span class="nc" id="L777">                        scrollPane.setBorder(scrollPaneBorder);</span>
                    }
                }
                // add JScrollBar corner component if available from LAF and not already set by the user
<span class="nc" id="L781">                Component corner =</span>
<span class="nc" id="L782">                        scrollPane.getCorner(JScrollPane.UPPER_TRAILING_CORNER);</span>
<span class="nc bnc" id="L783" title="All 4 branches missed.">                if (corner == null || corner instanceof UIResource){</span>
<span class="nc" id="L784">                    corner = null;</span>
                    try {
<span class="nc" id="L786">                        corner = (Component) UIManager.get(</span>
                                &quot;Table.scrollPaneCornerComponent&quot;);
<span class="nc" id="L788">                    } catch (Exception e) {</span>
                        // just ignore and don't set corner
<span class="nc" id="L790">                    }</span>
<span class="nc" id="L791">                    scrollPane.setCorner(JScrollPane.UPPER_TRAILING_CORNER,</span>
                            corner);
                }
            }
        }
<span class="nc" id="L796">    }</span>

    /**
     * Calls the &lt;code&gt;unconfigureEnclosingScrollPane&lt;/code&gt; method.
     *
     * @see #unconfigureEnclosingScrollPane
     */
    public void removeNotify() {
<span class="nc" id="L804">        KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L805">            removePropertyChangeListener(&quot;permanentFocusOwner&quot;, editorRemover);</span>
<span class="nc" id="L806">        editorRemover = null;</span>
<span class="nc" id="L807">        unconfigureEnclosingScrollPane();</span>
<span class="nc" id="L808">        super.removeNotify();</span>
<span class="nc" id="L809">    }</span>

    /**
     * Reverses the effect of &lt;code&gt;configureEnclosingScrollPane&lt;/code&gt;
     * by replacing the &lt;code&gt;columnHeaderView&lt;/code&gt; of the enclosing
     * scroll pane with &lt;code&gt;null&lt;/code&gt;. &lt;code&gt;JTable&lt;/code&gt;'s
     * &lt;code&gt;removeNotify&lt;/code&gt; method calls
     * this method, which is protected so that this default uninstallation
     * procedure can be overridden by a subclass.
     *
     * @see #removeNotify
     * @see #configureEnclosingScrollPane
     * @since 1.3
     */
    protected void unconfigureEnclosingScrollPane() {
<span class="nc" id="L824">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc" id="L826">            JViewport port = (JViewport) parent;</span>
<span class="nc" id="L827">            Container gp = port.getParent();</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">            if (gp instanceof JScrollPane) {</span>
<span class="nc" id="L829">                JScrollPane scrollPane = (JScrollPane)gp;</span>
                // Make certain we are the viewPort's view and not, for
                // example, the rowHeaderView of the scrollPane -
                // an implementor of fixed columns might do this.
<span class="nc" id="L833">                JViewport viewport = scrollPane.getViewport();</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">                if (viewport == null ||</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">                        SwingUtilities.getUnwrappedView(viewport) != this) {</span>
<span class="nc" id="L836">                    return;</span>
                }
<span class="nc" id="L838">                scrollPane.setColumnHeaderView(null);</span>
                // remove ScrollPane corner if one was added by the LAF
<span class="nc" id="L840">                Component corner =</span>
<span class="nc" id="L841">                        scrollPane.getCorner(JScrollPane.UPPER_TRAILING_CORNER);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">                if (corner instanceof UIResource){</span>
<span class="nc" id="L843">                    scrollPane.setCorner(JScrollPane.UPPER_TRAILING_CORNER,</span>
                            null);
                }
            }
        }
<span class="nc" id="L848">    }</span>

    void setUIProperty(String propertyName, Object value) {
<span class="nc bnc" id="L851" title="All 2 branches missed.">        if (propertyName == &quot;rowHeight&quot;) {</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">            if (!isRowHeightSet) {</span>
<span class="nc" id="L853">                setRowHeight(((Number)value).intValue());</span>
<span class="nc" id="L854">                isRowHeightSet = false;</span>
            }
<span class="nc" id="L856">            return;</span>
        }
<span class="nc" id="L858">        super.setUIProperty(propertyName, value);</span>
<span class="nc" id="L859">    }</span>

//
// Static Methods
//

    /**
     * Equivalent to &lt;code&gt;new JScrollPane(aTable)&lt;/code&gt;.
     *
     * @deprecated As of Swing version 1.0.2,
     * replaced by &lt;code&gt;new JScrollPane(aTable)&lt;/code&gt;.
     */
    @Deprecated
    static public JScrollPane createScrollPaneForTable(JTable aTable) {
<span class="nc" id="L873">        return new JScrollPane(aTable);</span>
    }

//
// Table Attributes
//

    /**
     * Sets the &lt;code&gt;tableHeader&lt;/code&gt; working with this &lt;code&gt;JTable&lt;/code&gt; to &lt;code&gt;newHeader&lt;/code&gt;.
     * It is legal to have a &lt;code&gt;null&lt;/code&gt; &lt;code&gt;tableHeader&lt;/code&gt;.
     *
     * @param   tableHeader                       new tableHeader
     * @see     #getTableHeader
     * @beaninfo
     *  bound: true
     *  description: The JTableHeader instance which renders the column headers.
     */
    public void setTableHeader(JTableHeader tableHeader) {
<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (this.tableHeader != tableHeader) {</span>
<span class="nc" id="L892">            JTableHeader old = this.tableHeader;</span>
            // Release the old header
<span class="nc bnc" id="L894" title="All 2 branches missed.">            if (old != null) {</span>
<span class="nc" id="L895">                old.setTable(null);</span>
            }
<span class="nc" id="L897">            this.tableHeader = tableHeader;</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">            if (tableHeader != null) {</span>
<span class="nc" id="L899">                tableHeader.setTable(this);</span>
            }
<span class="nc" id="L901">            firePropertyChange(&quot;tableHeader&quot;, old, tableHeader);</span>
        }
<span class="nc" id="L903">    }</span>

    /**
     * Returns the &lt;code&gt;tableHeader&lt;/code&gt; used by this &lt;code&gt;JTable&lt;/code&gt;.
     *
     * @return  the &lt;code&gt;tableHeader&lt;/code&gt; used by this table
     * @see     #setTableHeader
     */
    public JTableHeader getTableHeader() {
<span class="nc" id="L912">        return tableHeader;</span>
    }

    /**
     * Sets the height, in pixels, of all cells to &lt;code&gt;rowHeight&lt;/code&gt;,
     * revalidates, and repaints.
     * The height of the cells will be equal to the row height minus
     * the row margin.
     *
     * @param   rowHeight                       new row height
     * @exception IllegalArgumentException      if &lt;code&gt;rowHeight&lt;/code&gt; is
     *                                          less than 1
     * @see     #getRowHeight
     * @beaninfo
     *  bound: true
     *  description: The height of the specified row.
     */
    public void setRowHeight(int rowHeight) {
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if (rowHeight &lt;= 0) {</span>
<span class="nc" id="L931">            throw new IllegalArgumentException(&quot;New row height less than 1&quot;);</span>
        }
<span class="nc" id="L933">        int old = this.rowHeight;</span>
<span class="nc" id="L934">        this.rowHeight = rowHeight;</span>
<span class="nc" id="L935">        rowModel = null;</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">        if (sortManager != null) {</span>
<span class="nc" id="L937">            sortManager.modelRowSizes = null;</span>
        }
<span class="nc" id="L939">        isRowHeightSet = true;</span>
<span class="nc" id="L940">        resizeAndRepaint();</span>
<span class="nc" id="L941">        firePropertyChange(&quot;rowHeight&quot;, old, rowHeight);</span>
<span class="nc" id="L942">    }</span>

    /**
     * Returns the height of a table row, in pixels.
     *
     * @return  the height in pixels of a table row
     * @see     #setRowHeight
     */
    public int getRowHeight() {
<span class="nc" id="L951">        return rowHeight;</span>
    }

    private SizeSequence getRowModel() {
<span class="nc bnc" id="L955" title="All 2 branches missed.">        if (rowModel == null) {</span>
<span class="nc" id="L956">            rowModel = new SizeSequence(getRowCount(), getRowHeight());</span>
        }
<span class="nc" id="L958">        return rowModel;</span>
    }

    /**
     * Sets the height for &lt;code&gt;row&lt;/code&gt; to &lt;code&gt;rowHeight&lt;/code&gt;,
     * revalidates, and repaints. The height of the cells in this row
     * will be equal to the row height minus the row margin.
     *
     * @param   row                             the row whose height is being
                                                changed
     * @param   rowHeight                       new row height, in pixels
     * @exception IllegalArgumentException      if &lt;code&gt;rowHeight&lt;/code&gt; is
     *                                          less than 1
     * @beaninfo
     *  bound: true
     *  description: The height in pixels of the cells in &lt;code&gt;row&lt;/code&gt;
     * @since 1.3
     */
    public void setRowHeight(int row, int rowHeight) {
<span class="nc bnc" id="L977" title="All 2 branches missed.">        if (rowHeight &lt;= 0) {</span>
<span class="nc" id="L978">            throw new IllegalArgumentException(&quot;New row height less than 1&quot;);</span>
        }
<span class="nc" id="L980">        getRowModel().setSize(row, rowHeight);</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">        if (sortManager != null) {</span>
<span class="nc" id="L982">            sortManager.setViewRowHeight(row, rowHeight);</span>
        }
<span class="nc" id="L984">        resizeAndRepaint();</span>
<span class="nc" id="L985">    }</span>

    /**
     * Returns the height, in pixels, of the cells in &lt;code&gt;row&lt;/code&gt;.
     * @param   row              the row whose height is to be returned
     * @return the height, in pixels, of the cells in the row
     * @since 1.3
     */
    public int getRowHeight(int row) {
<span class="nc bnc" id="L994" title="All 2 branches missed.">        return (rowModel == null) ? getRowHeight() : rowModel.getSize(row);</span>
    }

    /**
     * Sets the amount of empty space between cells in adjacent rows.
     *
     * @param  rowMargin  the number of pixels between cells in a row
     * @see     #getRowMargin
     * @beaninfo
     *  bound: true
     *  description: The amount of space between cells.
     */
    public void setRowMargin(int rowMargin) {
<span class="nc" id="L1007">        int old = this.rowMargin;</span>
<span class="nc" id="L1008">        this.rowMargin = rowMargin;</span>
<span class="nc" id="L1009">        resizeAndRepaint();</span>
<span class="nc" id="L1010">        firePropertyChange(&quot;rowMargin&quot;, old, rowMargin);</span>
<span class="nc" id="L1011">    }</span>

    /**
     * Gets the amount of empty space, in pixels, between cells. Equivalent to:
     * &lt;code&gt;getIntercellSpacing().height&lt;/code&gt;.
     * @return the number of pixels between cells in a row
     *
     * @see     #setRowMargin
     */
    public int getRowMargin() {
<span class="nc" id="L1021">        return rowMargin;</span>
    }

    /**
     * Sets the &lt;code&gt;rowMargin&lt;/code&gt; and the &lt;code&gt;columnMargin&lt;/code&gt; --
     * the height and width of the space between cells -- to
     * &lt;code&gt;intercellSpacing&lt;/code&gt;.
     *
     * @param   intercellSpacing        a &lt;code&gt;Dimension&lt;/code&gt;
     *                                  specifying the new width
     *                                  and height between cells
     * @see     #getIntercellSpacing
     * @beaninfo
     *  description: The spacing between the cells,
     *               drawn in the background color of the JTable.
     */
    public void setIntercellSpacing(Dimension intercellSpacing) {
        // Set the rowMargin here and columnMargin in the TableColumnModel
<span class="nc" id="L1039">        setRowMargin(intercellSpacing.height);</span>
<span class="nc" id="L1040">        getColumnModel().setColumnMargin(intercellSpacing.width);</span>

<span class="nc" id="L1042">        resizeAndRepaint();</span>
<span class="nc" id="L1043">    }</span>

    /**
     * Returns the horizontal and vertical space between cells.
     * The default spacing is look and feel dependent.
     *
     * @return  the horizontal and vertical spacing between cells
     * @see     #setIntercellSpacing
     */
    public Dimension getIntercellSpacing() {
<span class="nc" id="L1053">        return new Dimension(getColumnModel().getColumnMargin(), rowMargin);</span>
    }

    /**
     * Sets the color used to draw grid lines to &lt;code&gt;gridColor&lt;/code&gt; and redisplays.
     * The default color is look and feel dependent.
     *
     * @param   gridColor                       the new color of the grid lines
     * @exception IllegalArgumentException      if &lt;code&gt;gridColor&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @see     #getGridColor
     * @beaninfo
     *  bound: true
     *  description: The grid color.
     */
    public void setGridColor(Color gridColor) {
<span class="nc bnc" id="L1068" title="All 2 branches missed.">        if (gridColor == null) {</span>
<span class="nc" id="L1069">            throw new IllegalArgumentException(&quot;New color is null&quot;);</span>
        }
<span class="nc" id="L1071">        Color old = this.gridColor;</span>
<span class="nc" id="L1072">        this.gridColor = gridColor;</span>
<span class="nc" id="L1073">        firePropertyChange(&quot;gridColor&quot;, old, gridColor);</span>
        // Redraw
<span class="nc" id="L1075">        repaint();</span>
<span class="nc" id="L1076">    }</span>

    /**
     * Returns the color used to draw grid lines.
     * The default color is look and feel dependent.
     *
     * @return  the color used to draw grid lines
     * @see     #setGridColor
     */
    public Color getGridColor() {
<span class="nc" id="L1086">        return gridColor;</span>
    }

    /**
     *  Sets whether the table draws grid lines around cells.
     *  If &lt;code&gt;showGrid&lt;/code&gt; is true it does; if it is false it doesn't.
     *  There is no &lt;code&gt;getShowGrid&lt;/code&gt; method as this state is held
     *  in two variables -- &lt;code&gt;showHorizontalLines&lt;/code&gt; and &lt;code&gt;showVerticalLines&lt;/code&gt; --
     *  each of which can be queried independently.
     *
     * @param   showGrid                 true if table view should draw grid lines
     *
     * @see     #setShowVerticalLines
     * @see     #setShowHorizontalLines
     * @beaninfo
     *  description: The color used to draw the grid lines.
     */
    public void setShowGrid(boolean showGrid) {
<span class="nc" id="L1104">        setShowHorizontalLines(showGrid);</span>
<span class="nc" id="L1105">        setShowVerticalLines(showGrid);</span>

        // Redraw
<span class="nc" id="L1108">        repaint();</span>
<span class="nc" id="L1109">    }</span>

    /**
     *  Sets whether the table draws horizontal lines between cells.
     *  If &lt;code&gt;showHorizontalLines&lt;/code&gt; is true it does; if it is false it doesn't.
     *
     * @param   showHorizontalLines      true if table view should draw horizontal lines
     * @see     #getShowHorizontalLines
     * @see     #setShowGrid
     * @see     #setShowVerticalLines
     * @beaninfo
     *  bound: true
     *  description: Whether horizontal lines should be drawn in between the cells.
     */
    public void setShowHorizontalLines(boolean showHorizontalLines) {
<span class="nc" id="L1124">        boolean old = this.showHorizontalLines;</span>
<span class="nc" id="L1125">        this.showHorizontalLines = showHorizontalLines;</span>
<span class="nc" id="L1126">        firePropertyChange(&quot;showHorizontalLines&quot;, old, showHorizontalLines);</span>

        // Redraw
<span class="nc" id="L1129">        repaint();</span>
<span class="nc" id="L1130">    }</span>

    /**
     *  Sets whether the table draws vertical lines between cells.
     *  If &lt;code&gt;showVerticalLines&lt;/code&gt; is true it does; if it is false it doesn't.
     *
     * @param   showVerticalLines              true if table view should draw vertical lines
     * @see     #getShowVerticalLines
     * @see     #setShowGrid
     * @see     #setShowHorizontalLines
     * @beaninfo
     *  bound: true
     *  description: Whether vertical lines should be drawn in between the cells.
     */
    public void setShowVerticalLines(boolean showVerticalLines) {
<span class="nc" id="L1145">        boolean old = this.showVerticalLines;</span>
<span class="nc" id="L1146">        this.showVerticalLines = showVerticalLines;</span>
<span class="nc" id="L1147">        firePropertyChange(&quot;showVerticalLines&quot;, old, showVerticalLines);</span>
        // Redraw
<span class="nc" id="L1149">        repaint();</span>
<span class="nc" id="L1150">    }</span>

    /**
     * Returns true if the table draws horizontal lines between cells, false if it
     * doesn't. The default value is look and feel dependent.
     *
     * @return  true if the table draws horizontal lines between cells, false if it
     *          doesn't
     * @see     #setShowHorizontalLines
     */
    public boolean getShowHorizontalLines() {
<span class="nc" id="L1161">        return showHorizontalLines;</span>
    }

    /**
     * Returns true if the table draws vertical lines between cells, false if it
     * doesn't. The default value is look and feel dependent.
     *
     * @return  true if the table draws vertical lines between cells, false if it
     *          doesn't
     * @see     #setShowVerticalLines
     */
    public boolean getShowVerticalLines() {
<span class="nc" id="L1173">        return showVerticalLines;</span>
    }

    /**
     * Sets the table's auto resize mode when the table is resized.  For further
     * information on how the different resize modes work, see
     * {@link #doLayout}.
     *
     * @param   mode One of 5 legal values:
     *                   AUTO_RESIZE_OFF,
     *                   AUTO_RESIZE_NEXT_COLUMN,
     *                   AUTO_RESIZE_SUBSEQUENT_COLUMNS,
     *                   AUTO_RESIZE_LAST_COLUMN,
     *                   AUTO_RESIZE_ALL_COLUMNS
     *
     * @see     #getAutoResizeMode
     * @see     #doLayout
     * @beaninfo
     *  bound: true
     *  description: Whether the columns should adjust themselves automatically.
     *        enum: AUTO_RESIZE_OFF                JTable.AUTO_RESIZE_OFF
     *              AUTO_RESIZE_NEXT_COLUMN        JTable.AUTO_RESIZE_NEXT_COLUMN
     *              AUTO_RESIZE_SUBSEQUENT_COLUMNS JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS
     *              AUTO_RESIZE_LAST_COLUMN        JTable.AUTO_RESIZE_LAST_COLUMN
     *              AUTO_RESIZE_ALL_COLUMNS        JTable.AUTO_RESIZE_ALL_COLUMNS
     */
    public void setAutoResizeMode(int mode) {
<span class="nc bnc" id="L1200" title="All 10 branches missed.">        if ((mode == AUTO_RESIZE_OFF) ||</span>
            (mode == AUTO_RESIZE_NEXT_COLUMN) ||
            (mode == AUTO_RESIZE_SUBSEQUENT_COLUMNS) ||
            (mode == AUTO_RESIZE_LAST_COLUMN) ||
            (mode == AUTO_RESIZE_ALL_COLUMNS)) {
<span class="nc" id="L1205">            int old = autoResizeMode;</span>
<span class="nc" id="L1206">            autoResizeMode = mode;</span>
<span class="nc" id="L1207">            resizeAndRepaint();</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">            if (tableHeader != null) {</span>
<span class="nc" id="L1209">                tableHeader.resizeAndRepaint();</span>
            }
<span class="nc" id="L1211">            firePropertyChange(&quot;autoResizeMode&quot;, old, autoResizeMode);</span>
        }
<span class="nc" id="L1213">    }</span>

    /**
     * Returns the auto resize mode of the table.  The default mode
     * is AUTO_RESIZE_SUBSEQUENT_COLUMNS.
     *
     * @return  the autoResizeMode of the table
     *
     * @see     #setAutoResizeMode
     * @see     #doLayout
     */
    public int getAutoResizeMode() {
<span class="nc" id="L1225">        return autoResizeMode;</span>
    }

    /**
     * Sets this table's &lt;code&gt;autoCreateColumnsFromModel&lt;/code&gt; flag.
     * This method calls &lt;code&gt;createDefaultColumnsFromModel&lt;/code&gt; if
     * &lt;code&gt;autoCreateColumnsFromModel&lt;/code&gt; changes from false to true.
     *
     * @param   autoCreateColumnsFromModel   true if &lt;code&gt;JTable&lt;/code&gt; should automatically create columns
     * @see     #getAutoCreateColumnsFromModel
     * @see     #createDefaultColumnsFromModel
     * @beaninfo
     *  bound: true
     *  description: Automatically populates the columnModel when a new TableModel is submitted.
     */
    public void setAutoCreateColumnsFromModel(boolean autoCreateColumnsFromModel) {
<span class="nc bnc" id="L1241" title="All 2 branches missed.">        if (this.autoCreateColumnsFromModel != autoCreateColumnsFromModel) {</span>
<span class="nc" id="L1242">            boolean old = this.autoCreateColumnsFromModel;</span>
<span class="nc" id="L1243">            this.autoCreateColumnsFromModel = autoCreateColumnsFromModel;</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">            if (autoCreateColumnsFromModel) {</span>
<span class="nc" id="L1245">                createDefaultColumnsFromModel();</span>
            }
<span class="nc" id="L1247">            firePropertyChange(&quot;autoCreateColumnsFromModel&quot;, old, autoCreateColumnsFromModel);</span>
        }
<span class="nc" id="L1249">    }</span>

    /**
     * Determines whether the table will create default columns from the model.
     * If true, &lt;code&gt;setModel&lt;/code&gt; will clear any existing columns and
     * create new columns from the new model.  Also, if the event in
     * the &lt;code&gt;tableChanged&lt;/code&gt; notification specifies that the
     * entire table changed, then the columns will be rebuilt.
     * The default is true.
     *
     * @return  the autoCreateColumnsFromModel of the table
     * @see     #setAutoCreateColumnsFromModel
     * @see     #createDefaultColumnsFromModel
     */
    public boolean getAutoCreateColumnsFromModel() {
<span class="nc" id="L1264">        return autoCreateColumnsFromModel;</span>
    }

    /**
     * Creates default columns for the table from
     * the data model using the &lt;code&gt;getColumnCount&lt;/code&gt; method
     * defined in the &lt;code&gt;TableModel&lt;/code&gt; interface.
     * &lt;p&gt;
     * Clears any existing columns before creating the
     * new columns based on information from the model.
     *
     * @see     #getAutoCreateColumnsFromModel
     */
    public void createDefaultColumnsFromModel() {
<span class="nc" id="L1278">        TableModel m = getModel();</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">        if (m != null) {</span>
            // Remove any current columns
<span class="nc" id="L1281">            TableColumnModel cm = getColumnModel();</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">            while (cm.getColumnCount() &gt; 0) {</span>
<span class="nc" id="L1283">                cm.removeColumn(cm.getColumn(0));</span>
            }

            // Create new columns from the data model info
<span class="nc bnc" id="L1287" title="All 2 branches missed.">            for (int i = 0; i &lt; m.getColumnCount(); i++) {</span>
<span class="nc" id="L1288">                TableColumn newColumn = new TableColumn(i);</span>
<span class="nc" id="L1289">                addColumn(newColumn);</span>
            }
        }
<span class="nc" id="L1292">    }</span>

    /**
     * Sets a default cell renderer to be used if no renderer has been set in
     * a &lt;code&gt;TableColumn&lt;/code&gt;. If renderer is &lt;code&gt;null&lt;/code&gt;,
     * removes the default renderer for this column class.
     *
     * @param  columnClass     set the default cell renderer for this columnClass
     * @param  renderer        default cell renderer to be used for this
     *                         columnClass
     * @see     #getDefaultRenderer
     * @see     #setDefaultEditor
     */
    public void setDefaultRenderer(Class&lt;?&gt; columnClass, TableCellRenderer renderer) {
<span class="nc bnc" id="L1306" title="All 2 branches missed.">        if (renderer != null) {</span>
<span class="nc" id="L1307">            defaultRenderersByColumnClass.put(columnClass, renderer);</span>
        }
        else {
<span class="nc" id="L1310">            defaultRenderersByColumnClass.remove(columnClass);</span>
        }
<span class="nc" id="L1312">    }</span>

    /**
     * Returns the cell renderer to be used when no renderer has been set in
     * a &lt;code&gt;TableColumn&lt;/code&gt;. During the rendering of cells the renderer is fetched from
     * a &lt;code&gt;Hashtable&lt;/code&gt; of entries according to the class of the cells in the column. If
     * there is no entry for this &lt;code&gt;columnClass&lt;/code&gt; the method returns
     * the entry for the most specific superclass. The &lt;code&gt;JTable&lt;/code&gt; installs entries
     * for &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, and &lt;code&gt;Boolean&lt;/code&gt;, all of which can be modified
     * or replaced.
     *
     * @param   columnClass   return the default cell renderer
     *                        for this columnClass
     * @return  the renderer for this columnClass
     * @see     #setDefaultRenderer
     * @see     #getColumnClass
     */
    public TableCellRenderer getDefaultRenderer(Class&lt;?&gt; columnClass) {
<span class="nc bnc" id="L1330" title="All 2 branches missed.">        if (columnClass == null) {</span>
<span class="nc" id="L1331">            return null;</span>
        }
        else {
<span class="nc" id="L1334">            Object renderer = defaultRenderersByColumnClass.get(columnClass);</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">            if (renderer != null) {</span>
<span class="nc" id="L1336">                return (TableCellRenderer)renderer;</span>
            }
            else {
<span class="nc" id="L1339">                Class c = columnClass.getSuperclass();</span>
<span class="nc bnc" id="L1340" title="All 4 branches missed.">                if (c == null &amp;&amp; columnClass != Object.class) {</span>
<span class="nc" id="L1341">                    c = Object.class;</span>
                }
<span class="nc" id="L1343">                return getDefaultRenderer(c);</span>
            }
        }
    }

    /**
     * Sets a default cell editor to be used if no editor has been set in
     * a &lt;code&gt;TableColumn&lt;/code&gt;. If no editing is required in a table, or a
     * particular column in a table, uses the &lt;code&gt;isCellEditable&lt;/code&gt;
     * method in the &lt;code&gt;TableModel&lt;/code&gt; interface to ensure that this
     * &lt;code&gt;JTable&lt;/code&gt; will not start an editor in these columns.
     * If editor is &lt;code&gt;null&lt;/code&gt;, removes the default editor for this
     * column class.
     *
     * @param  columnClass  set the default cell editor for this columnClass
     * @param  editor   default cell editor to be used for this columnClass
     * @see     TableModel#isCellEditable
     * @see     #getDefaultEditor
     * @see     #setDefaultRenderer
     */
    public void setDefaultEditor(Class&lt;?&gt; columnClass, TableCellEditor editor) {
<span class="nc bnc" id="L1364" title="All 2 branches missed.">        if (editor != null) {</span>
<span class="nc" id="L1365">            defaultEditorsByColumnClass.put(columnClass, editor);</span>
        }
        else {
<span class="nc" id="L1368">            defaultEditorsByColumnClass.remove(columnClass);</span>
        }
<span class="nc" id="L1370">    }</span>

    /**
     * Returns the editor to be used when no editor has been set in
     * a &lt;code&gt;TableColumn&lt;/code&gt;. During the editing of cells the editor is fetched from
     * a &lt;code&gt;Hashtable&lt;/code&gt; of entries according to the class of the cells in the column. If
     * there is no entry for this &lt;code&gt;columnClass&lt;/code&gt; the method returns
     * the entry for the most specific superclass. The &lt;code&gt;JTable&lt;/code&gt; installs entries
     * for &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, and &lt;code&gt;Boolean&lt;/code&gt;, all of which can be modified
     * or replaced.
     *
     * @param   columnClass  return the default cell editor for this columnClass
     * @return the default cell editor to be used for this columnClass
     * @see     #setDefaultEditor
     * @see     #getColumnClass
     */
    public TableCellEditor getDefaultEditor(Class&lt;?&gt; columnClass) {
<span class="nc bnc" id="L1387" title="All 2 branches missed.">        if (columnClass == null) {</span>
<span class="nc" id="L1388">            return null;</span>
        }
        else {
<span class="nc" id="L1391">            Object editor = defaultEditorsByColumnClass.get(columnClass);</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">            if (editor != null) {</span>
<span class="nc" id="L1393">                return (TableCellEditor)editor;</span>
            }
            else {
<span class="nc" id="L1396">                return getDefaultEditor(columnClass.getSuperclass());</span>
            }
        }
    }

    /**
     * Turns on or off automatic drag handling. In order to enable automatic
     * drag handling, this property should be set to {@code true}, and the
     * table's {@code TransferHandler} needs to be {@code non-null}.
     * The default value of the {@code dragEnabled} property is {@code false}.
     * &lt;p&gt;
     * The job of honoring this property, and recognizing a user drag gesture,
     * lies with the look and feel implementation, and in particular, the table's
     * {@code TableUI}. When automatic drag handling is enabled, most look and
     * feels (including those that subclass {@code BasicLookAndFeel}) begin a
     * drag and drop operation whenever the user presses the mouse button over
     * an item (in single selection mode) or a selection (in other selection
     * modes) and then moves the mouse a few pixels. Setting this property to
     * {@code true} can therefore have a subtle effect on how selections behave.
     * &lt;p&gt;
     * If a look and feel is used that ignores this property, you can still
     * begin a drag and drop operation by calling {@code exportAsDrag} on the
     * table's {@code TransferHandler}.
     *
     * @param b whether or not to enable automatic drag handling
     * @exception HeadlessException if
     *            &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and
     *            &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt;
     *            returns &lt;code&gt;true&lt;/code&gt;
     * @see java.awt.GraphicsEnvironment#isHeadless
     * @see #getDragEnabled
     * @see #setTransferHandler
     * @see TransferHandler
     * @since 1.4
     *
     * @beaninfo
     *  description: determines whether automatic drag handling is enabled
     *        bound: false
     */
    public void setDragEnabled(boolean b) {
<span class="nc bnc" id="L1436" title="All 4 branches missed.">        if (b &amp;&amp; GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L1437">            throw new HeadlessException();</span>
        }
<span class="nc" id="L1439">        dragEnabled = b;</span>
<span class="nc" id="L1440">    }</span>

    /**
     * Returns whether or not automatic drag handling is enabled.
     *
     * @return the value of the {@code dragEnabled} property
     * @see #setDragEnabled
     * @since 1.4
     */
    public boolean getDragEnabled() {
<span class="nc" id="L1450">        return dragEnabled;</span>
    }

    /**
     * Sets the drop mode for this component. For backward compatibility,
     * the default for this property is &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;.
     * Usage of one of the other modes is recommended, however, for an
     * improved user experience. &lt;code&gt;DropMode.ON&lt;/code&gt;, for instance,
     * offers similar behavior of showing items as selected, but does so without
     * affecting the actual selection in the table.
     * &lt;p&gt;
     * &lt;code&gt;JTable&lt;/code&gt; supports the following drop modes:
     * &lt;ul&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.ON&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.INSERT&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.INSERT_ROWS&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.INSERT_COLS&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.ON_OR_INSERT_ROWS&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.ON_OR_INSERT_COLS&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The drop mode is only meaningful if this component has a
     * &lt;code&gt;TransferHandler&lt;/code&gt; that accepts drops.
     *
     * @param dropMode the drop mode to use
     * @throws IllegalArgumentException if the drop mode is unsupported
     *         or &lt;code&gt;null&lt;/code&gt;
     * @see #getDropMode
     * @see #getDropLocation
     * @see #setTransferHandler
     * @see TransferHandler
     * @since 1.6
     */
    public final void setDropMode(DropMode dropMode) {
<span class="nc bnc" id="L1486" title="All 2 branches missed.">        if (dropMode != null) {</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">            switch (dropMode) {</span>
                case USE_SELECTION:
                case ON:
                case INSERT:
                case INSERT_ROWS:
                case INSERT_COLS:
                case ON_OR_INSERT:
                case ON_OR_INSERT_ROWS:
                case ON_OR_INSERT_COLS:
<span class="nc" id="L1496">                    this.dropMode = dropMode;</span>
<span class="nc" id="L1497">                    return;</span>
            }
        }

<span class="nc" id="L1501">        throw new IllegalArgumentException(dropMode + &quot;: Unsupported drop mode for table&quot;);</span>
    }

    /**
     * Returns the drop mode for this component.
     *
     * @return the drop mode for this component
     * @see #setDropMode
     * @since 1.6
     */
    public final DropMode getDropMode() {
<span class="nc" id="L1512">        return dropMode;</span>
    }

    /**
     * Calculates a drop location in this component, representing where a
     * drop at the given point should insert data.
     *
     * @param p the point to calculate a drop location for
     * @return the drop location, or &lt;code&gt;null&lt;/code&gt;
     */
    DropLocation dropLocationForPoint(Point p) {
<span class="nc" id="L1523">        DropLocation location = null;</span>

<span class="nc" id="L1525">        int row = rowAtPoint(p);</span>
<span class="nc" id="L1526">        int col = columnAtPoint(p);</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">        boolean outside = Boolean.TRUE == getClientProperty(&quot;Table.isFileList&quot;)</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">                          &amp;&amp; SwingUtilities2.pointOutsidePrefSize(this, row, col, p);</span>

<span class="nc" id="L1530">        Rectangle rect = getCellRect(row, col, true);</span>
        Section xSection, ySection;
<span class="nc" id="L1532">        boolean between = false;</span>
<span class="nc" id="L1533">        boolean ltr = getComponentOrientation().isLeftToRight();</span>

<span class="nc bnc" id="L1535" title="All 8 branches missed.">        switch(dropMode) {</span>
            case USE_SELECTION:
            case ON:
<span class="nc bnc" id="L1538" title="All 6 branches missed.">                if (row == -1 || col == -1 || outside) {</span>
<span class="nc" id="L1539">                    location = new DropLocation(p, -1, -1, false, false);</span>
                } else {
<span class="nc" id="L1541">                    location = new DropLocation(p, row, col, false, false);</span>
                }
<span class="nc" id="L1543">                break;</span>
            case INSERT:
<span class="nc bnc" id="L1545" title="All 4 branches missed.">                if (row == -1 &amp;&amp; col == -1) {</span>
<span class="nc" id="L1546">                    location = new DropLocation(p, 0, 0, true, true);</span>
<span class="nc" id="L1547">                    break;</span>
                }

<span class="nc" id="L1550">                xSection = SwingUtilities2.liesInHorizontal(rect, p, ltr, true);</span>

<span class="nc bnc" id="L1552" title="All 2 branches missed.">                if (row == -1) {</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">                    if (xSection == LEADING) {</span>
<span class="nc" id="L1554">                        location = new DropLocation(p, getRowCount(), col, true, true);</span>
<span class="nc bnc" id="L1555" title="All 2 branches missed.">                    } else if (xSection == TRAILING) {</span>
<span class="nc" id="L1556">                        location = new DropLocation(p, getRowCount(), col + 1, true, true);</span>
                    } else {
<span class="nc" id="L1558">                        location = new DropLocation(p, getRowCount(), col, true, false);</span>
                    }
<span class="nc bnc" id="L1560" title="All 4 branches missed.">                } else if (xSection == LEADING || xSection == TRAILING) {</span>
<span class="nc" id="L1561">                    ySection = SwingUtilities2.liesInVertical(rect, p, true);</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">                    if (ySection == LEADING) {</span>
<span class="nc" id="L1563">                        between = true;</span>
<span class="nc bnc" id="L1564" title="All 2 branches missed.">                    } else if (ySection == TRAILING) {</span>
<span class="nc" id="L1565">                        row++;</span>
<span class="nc" id="L1566">                        between = true;</span>
                    }

<span class="nc bnc" id="L1569" title="All 2 branches missed.">                    location = new DropLocation(p, row,</span>
                                                xSection == TRAILING ? col + 1 : col,
                                                between, true);
                } else {
<span class="nc bnc" id="L1573" title="All 2 branches missed.">                    if (SwingUtilities2.liesInVertical(rect, p, false) == TRAILING) {</span>
<span class="nc" id="L1574">                        row++;</span>
                    }

<span class="nc" id="L1577">                    location = new DropLocation(p, row, col, true, false);</span>
                }

<span class="nc" id="L1580">                break;</span>
            case INSERT_ROWS:
<span class="nc bnc" id="L1582" title="All 4 branches missed.">                if (row == -1 &amp;&amp; col == -1) {</span>
<span class="nc" id="L1583">                    location = new DropLocation(p, -1, -1, false, false);</span>
<span class="nc" id="L1584">                    break;</span>
                }

<span class="nc bnc" id="L1587" title="All 2 branches missed.">                if (row == -1) {</span>
<span class="nc" id="L1588">                    location = new DropLocation(p, getRowCount(), col, true, false);</span>
<span class="nc" id="L1589">                    break;</span>
                }

<span class="nc bnc" id="L1592" title="All 2 branches missed.">                if (SwingUtilities2.liesInVertical(rect, p, false) == TRAILING) {</span>
<span class="nc" id="L1593">                    row++;</span>
                }

<span class="nc" id="L1596">                location = new DropLocation(p, row, col, true, false);</span>
<span class="nc" id="L1597">                break;</span>
            case ON_OR_INSERT_ROWS:
<span class="nc bnc" id="L1599" title="All 4 branches missed.">                if (row == -1 &amp;&amp; col == -1) {</span>
<span class="nc" id="L1600">                    location = new DropLocation(p, -1, -1, false, false);</span>
<span class="nc" id="L1601">                    break;</span>
                }

<span class="nc bnc" id="L1604" title="All 2 branches missed.">                if (row == -1) {</span>
<span class="nc" id="L1605">                    location = new DropLocation(p, getRowCount(), col, true, false);</span>
<span class="nc" id="L1606">                    break;</span>
                }

<span class="nc" id="L1609">                ySection = SwingUtilities2.liesInVertical(rect, p, true);</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">                if (ySection == LEADING) {</span>
<span class="nc" id="L1611">                    between = true;</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">                } else if (ySection == TRAILING) {</span>
<span class="nc" id="L1613">                    row++;</span>
<span class="nc" id="L1614">                    between = true;</span>
                }

<span class="nc" id="L1617">                location = new DropLocation(p, row, col, between, false);</span>
<span class="nc" id="L1618">                break;</span>
            case INSERT_COLS:
<span class="nc bnc" id="L1620" title="All 2 branches missed.">                if (row == -1) {</span>
<span class="nc" id="L1621">                    location = new DropLocation(p, -1, -1, false, false);</span>
<span class="nc" id="L1622">                    break;</span>
                }

<span class="nc bnc" id="L1625" title="All 2 branches missed.">                if (col == -1) {</span>
<span class="nc" id="L1626">                    location = new DropLocation(p, getColumnCount(), col, false, true);</span>
<span class="nc" id="L1627">                    break;</span>
                }

<span class="nc bnc" id="L1630" title="All 2 branches missed.">                if (SwingUtilities2.liesInHorizontal(rect, p, ltr, false) == TRAILING) {</span>
<span class="nc" id="L1631">                    col++;</span>
                }

<span class="nc" id="L1634">                location = new DropLocation(p, row, col, false, true);</span>
<span class="nc" id="L1635">                break;</span>
            case ON_OR_INSERT_COLS:
<span class="nc bnc" id="L1637" title="All 2 branches missed.">                if (row == -1) {</span>
<span class="nc" id="L1638">                    location = new DropLocation(p, -1, -1, false, false);</span>
<span class="nc" id="L1639">                    break;</span>
                }

<span class="nc bnc" id="L1642" title="All 2 branches missed.">                if (col == -1) {</span>
<span class="nc" id="L1643">                    location = new DropLocation(p, row, getColumnCount(), false, true);</span>
<span class="nc" id="L1644">                    break;</span>
                }

<span class="nc" id="L1647">                xSection = SwingUtilities2.liesInHorizontal(rect, p, ltr, true);</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">                if (xSection == LEADING) {</span>
<span class="nc" id="L1649">                    between = true;</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">                } else if (xSection == TRAILING) {</span>
<span class="nc" id="L1651">                    col++;</span>
<span class="nc" id="L1652">                    between = true;</span>
                }

<span class="nc" id="L1655">                location = new DropLocation(p, row, col, false, between);</span>
<span class="nc" id="L1656">                break;</span>
            case ON_OR_INSERT:
<span class="nc bnc" id="L1658" title="All 4 branches missed.">                if (row == -1 &amp;&amp; col == -1) {</span>
<span class="nc" id="L1659">                    location = new DropLocation(p, 0, 0, true, true);</span>
<span class="nc" id="L1660">                    break;</span>
                }

<span class="nc" id="L1663">                xSection = SwingUtilities2.liesInHorizontal(rect, p, ltr, true);</span>

<span class="nc bnc" id="L1665" title="All 2 branches missed.">                if (row == -1) {</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">                    if (xSection == LEADING) {</span>
<span class="nc" id="L1667">                        location = new DropLocation(p, getRowCount(), col, true, true);</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">                    } else if (xSection == TRAILING) {</span>
<span class="nc" id="L1669">                        location = new DropLocation(p, getRowCount(), col + 1, true, true);</span>
                    } else {
<span class="nc" id="L1671">                        location = new DropLocation(p, getRowCount(), col, true, false);</span>
                    }

<span class="nc" id="L1674">                    break;</span>
                }

<span class="nc" id="L1677">                ySection = SwingUtilities2.liesInVertical(rect, p, true);</span>
<span class="nc bnc" id="L1678" title="All 2 branches missed.">                if (ySection == LEADING) {</span>
<span class="nc" id="L1679">                    between = true;</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">                } else if (ySection == TRAILING) {</span>
<span class="nc" id="L1681">                    row++;</span>
<span class="nc" id="L1682">                    between = true;</span>
                }

<span class="nc bnc" id="L1685" title="All 4 branches missed.">                location = new DropLocation(p, row,</span>
                                            xSection == TRAILING ? col + 1 : col,
                                            between,
                                            xSection != MIDDLE);

<span class="nc" id="L1690">                break;</span>
            default:
<span class="nc bnc" id="L1692" title="All 2 branches missed.">                assert false : &quot;Unexpected drop mode&quot;;</span>
        }

<span class="nc" id="L1695">        return location;</span>
    }

    /**
     * Called to set or clear the drop location during a DnD operation.
     * In some cases, the component may need to use it's internal selection
     * temporarily to indicate the drop location. To help facilitate this,
     * this method returns and accepts as a parameter a state object.
     * This state object can be used to store, and later restore, the selection
     * state. Whatever this method returns will be passed back to it in
     * future calls, as the state parameter. If it wants the DnD system to
     * continue storing the same state, it must pass it back every time.
     * Here's how this is used:
     * &lt;p&gt;
     * Let's say that on the first call to this method the component decides
     * to save some state (because it is about to use the selection to show
     * a drop index). It can return a state object to the caller encapsulating
     * any saved selection state. On a second call, let's say the drop location
     * is being changed to something else. The component doesn't need to
     * restore anything yet, so it simply passes back the same state object
     * to have the DnD system continue storing it. Finally, let's say this
     * method is messaged with &lt;code&gt;null&lt;/code&gt;. This means DnD
     * is finished with this component for now, meaning it should restore
     * state. At this point, it can use the state parameter to restore
     * said state, and of course return &lt;code&gt;null&lt;/code&gt; since there's
     * no longer anything to store.
     *
     * @param location the drop location (as calculated by
     *        &lt;code&gt;dropLocationForPoint&lt;/code&gt;) or &lt;code&gt;null&lt;/code&gt;
     *        if there's no longer a valid drop location
     * @param state the state object saved earlier for this component,
     *        or &lt;code&gt;null&lt;/code&gt;
     * @param forDrop whether or not the method is being called because an
     *        actual drop occurred
     * @return any saved state for this component, or &lt;code&gt;null&lt;/code&gt; if none
     */
    Object setDropLocation(TransferHandler.DropLocation location,
                           Object state,
                           boolean forDrop) {

<span class="nc" id="L1735">        Object retVal = null;</span>
<span class="nc" id="L1736">        DropLocation tableLocation = (DropLocation)location;</span>

<span class="nc bnc" id="L1738" title="All 2 branches missed.">        if (dropMode == DropMode.USE_SELECTION) {</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">            if (tableLocation == null) {</span>
<span class="nc bnc" id="L1740" title="All 4 branches missed.">                if (!forDrop &amp;&amp; state != null) {</span>
<span class="nc" id="L1741">                    clearSelection();</span>

<span class="nc" id="L1743">                    int[] rows = ((int[][])state)[0];</span>
<span class="nc" id="L1744">                    int[] cols = ((int[][])state)[1];</span>
<span class="nc" id="L1745">                    int[] anchleads = ((int[][])state)[2];</span>

<span class="nc bnc" id="L1747" title="All 2 branches missed.">                    for (int row : rows) {</span>
<span class="nc" id="L1748">                        addRowSelectionInterval(row, row);</span>
                    }

<span class="nc bnc" id="L1751" title="All 2 branches missed.">                    for (int col : cols) {</span>
<span class="nc" id="L1752">                        addColumnSelectionInterval(col, col);</span>
                    }

<span class="nc" id="L1755">                    SwingUtilities2.setLeadAnchorWithoutSelection(</span>
<span class="nc" id="L1756">                            getSelectionModel(), anchleads[1], anchleads[0]);</span>

<span class="nc" id="L1758">                    SwingUtilities2.setLeadAnchorWithoutSelection(</span>
<span class="nc" id="L1759">                            getColumnModel().getSelectionModel(),</span>
                            anchleads[3], anchleads[2]);
<span class="nc" id="L1761">                }</span>
            } else {
<span class="nc bnc" id="L1763" title="All 2 branches missed.">                if (dropLocation == null) {</span>
<span class="nc" id="L1764">                    retVal = new int[][]{</span>
<span class="nc" id="L1765">                        getSelectedRows(),</span>
<span class="nc" id="L1766">                        getSelectedColumns(),</span>
<span class="nc" id="L1767">                        {getAdjustedIndex(getSelectionModel()</span>
<span class="nc" id="L1768">                             .getAnchorSelectionIndex(), true),</span>
<span class="nc" id="L1769">                         getAdjustedIndex(getSelectionModel()</span>
<span class="nc" id="L1770">                             .getLeadSelectionIndex(), true),</span>
<span class="nc" id="L1771">                         getAdjustedIndex(getColumnModel().getSelectionModel()</span>
<span class="nc" id="L1772">                             .getAnchorSelectionIndex(), false),</span>
<span class="nc" id="L1773">                         getAdjustedIndex(getColumnModel().getSelectionModel()</span>
<span class="nc" id="L1774">                             .getLeadSelectionIndex(), false)}};</span>
                } else {
<span class="nc" id="L1776">                    retVal = state;</span>
                }

<span class="nc bnc" id="L1779" title="All 2 branches missed.">                if (tableLocation.getRow() == -1) {</span>
<span class="nc" id="L1780">                    clearSelectionAndLeadAnchor();</span>
                } else {
<span class="nc" id="L1782">                    setRowSelectionInterval(tableLocation.getRow(),</span>
<span class="nc" id="L1783">                                            tableLocation.getRow());</span>
<span class="nc" id="L1784">                    setColumnSelectionInterval(tableLocation.getColumn(),</span>
<span class="nc" id="L1785">                                               tableLocation.getColumn());</span>
                }
            }
        }

<span class="nc" id="L1790">        DropLocation old = dropLocation;</span>
<span class="nc" id="L1791">        dropLocation = tableLocation;</span>
<span class="nc" id="L1792">        firePropertyChange(&quot;dropLocation&quot;, old, dropLocation);</span>

<span class="nc" id="L1794">        return retVal;</span>
    }

    /**
     * Returns the location that this component should visually indicate
     * as the drop location during a DnD operation over the component,
     * or {@code null} if no location is to currently be shown.
     * &lt;p&gt;
     * This method is not meant for querying the drop location
     * from a {@code TransferHandler}, as the drop location is only
     * set after the {@code TransferHandler}'s &lt;code&gt;canImport&lt;/code&gt;
     * has returned and has allowed for the location to be shown.
     * &lt;p&gt;
     * When this property changes, a property change event with
     * name &quot;dropLocation&quot; is fired by the component.
     *
     * @return the drop location
     * @see #setDropMode
     * @see TransferHandler#canImport(TransferHandler.TransferSupport)
     * @since 1.6
     */
    public final DropLocation getDropLocation() {
<span class="nc" id="L1816">        return dropLocation;</span>
    }

    /**
     * Specifies whether a {@code RowSorter} should be created for the
     * table whenever its model changes.
     * &lt;p&gt;
     * When {@code setAutoCreateRowSorter(true)} is invoked, a {@code
     * TableRowSorter} is immediately created and installed on the
     * table.  While the {@code autoCreateRowSorter} property remains
     * {@code true}, every time the model is changed, a new {@code
     * TableRowSorter} is created and set as the table's row sorter.
     * The default value for the {@code autoCreateRowSorter}
     * property is {@code false}.
     *
     * @param autoCreateRowSorter whether or not a {@code RowSorter}
     *        should be automatically created
     * @see javax.swing.table.TableRowSorter
     * @beaninfo
     *        bound: true
     *    preferred: true
     *  description: Whether or not to turn on sorting by default.
     * @since 1.6
     */
    public void setAutoCreateRowSorter(boolean autoCreateRowSorter) {
<span class="nc" id="L1841">        boolean oldValue = this.autoCreateRowSorter;</span>
<span class="nc" id="L1842">        this.autoCreateRowSorter = autoCreateRowSorter;</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">        if (autoCreateRowSorter) {</span>
<span class="nc" id="L1844">            setRowSorter(new TableRowSorter&lt;TableModel&gt;(getModel()));</span>
        }
<span class="nc" id="L1846">        firePropertyChange(&quot;autoCreateRowSorter&quot;, oldValue,</span>
                           autoCreateRowSorter);
<span class="nc" id="L1848">    }</span>

    /**
     * Returns {@code true} if whenever the model changes, a new
     * {@code RowSorter} should be created and installed
     * as the table's sorter; otherwise, returns {@code false}.
     *
     * @return true if a {@code RowSorter} should be created when
     *         the model changes
     * @since 1.6
     */
    public boolean getAutoCreateRowSorter() {
<span class="nc" id="L1860">        return autoCreateRowSorter;</span>
    }

    /**
     * Specifies whether the selection should be updated after sorting.
     * If true, on sorting the selection is reset such that
     * the same rows, in terms of the model, remain selected.  The default
     * is true.
     *
     * @param update whether or not to update the selection on sorting
     * @beaninfo
     *        bound: true
     *       expert: true
     *  description: Whether or not to update the selection on sorting
     * @since 1.6
     */
    public void setUpdateSelectionOnSort(boolean update) {
<span class="nc bnc" id="L1877" title="All 2 branches missed.">        if (updateSelectionOnSort != update) {</span>
<span class="nc" id="L1878">            updateSelectionOnSort = update;</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">            firePropertyChange(&quot;updateSelectionOnSort&quot;, !update, update);</span>
        }
<span class="nc" id="L1881">    }</span>

    /**
     * Returns true if the selection should be updated after sorting.
     *
     * @return whether to update the selection on a sort
     * @since 1.6
     */
    public boolean getUpdateSelectionOnSort() {
<span class="nc" id="L1890">        return updateSelectionOnSort;</span>
    }

    /**
     * Sets the &lt;code&gt;RowSorter&lt;/code&gt;.  &lt;code&gt;RowSorter&lt;/code&gt; is used
     * to provide sorting and filtering to a &lt;code&gt;JTable&lt;/code&gt;.
     * &lt;p&gt;
     * This method clears the selection and resets any variable row heights.
     * &lt;p&gt;
     * This method fires a &lt;code&gt;PropertyChangeEvent&lt;/code&gt; when appropriate,
     * with the property name &lt;code&gt;&quot;rowSorter&quot;&lt;/code&gt;.  For
     * backward-compatibility, this method fires an additional event with the
     * property name &lt;code&gt;&quot;sorter&quot;&lt;/code&gt;.
     * &lt;p&gt;
     * If the underlying model of the &lt;code&gt;RowSorter&lt;/code&gt; differs from
     * that of this &lt;code&gt;JTable&lt;/code&gt; undefined behavior will result.
     *
     * @param sorter the &lt;code&gt;RowSorter&lt;/code&gt;; &lt;code&gt;null&lt;/code&gt; turns
     *        sorting off
     * @see javax.swing.table.TableRowSorter
     * @beaninfo
     *        bound: true
     *  description: The table's RowSorter
     * @since 1.6
     */
    public void setRowSorter(RowSorter&lt;? extends TableModel&gt; sorter) {
<span class="nc" id="L1916">        RowSorter&lt;? extends TableModel&gt; oldRowSorter = null;</span>
<span class="nc bnc" id="L1917" title="All 2 branches missed.">        if (sortManager != null) {</span>
<span class="nc" id="L1918">            oldRowSorter = sortManager.sorter;</span>
<span class="nc" id="L1919">            sortManager.dispose();</span>
<span class="nc" id="L1920">            sortManager = null;</span>
        }
<span class="nc" id="L1922">        rowModel = null;</span>
<span class="nc" id="L1923">        clearSelectionAndLeadAnchor();</span>
<span class="nc bnc" id="L1924" title="All 2 branches missed.">        if (sorter != null) {</span>
<span class="nc" id="L1925">            sortManager = new SortManager(sorter);</span>
        }
<span class="nc" id="L1927">        resizeAndRepaint();</span>
<span class="nc" id="L1928">        firePropertyChange(&quot;rowSorter&quot;, oldRowSorter, sorter);</span>
<span class="nc" id="L1929">        firePropertyChange(&quot;sorter&quot;, oldRowSorter, sorter);</span>
<span class="nc" id="L1930">    }</span>

    /**
     * Returns the object responsible for sorting.
     *
     * @return the object responsible for sorting
     * @since 1.6
     */
    public RowSorter&lt;? extends TableModel&gt; getRowSorter() {
<span class="nc bnc" id="L1939" title="All 2 branches missed.">        return (sortManager != null) ? sortManager.sorter : null;</span>
    }

//
// Selection methods
//
    /**
     * Sets the table's selection mode to allow only single selections, a single
     * contiguous interval, or multiple intervals.
     * &lt;P&gt;
     * &lt;b&gt;Note:&lt;/b&gt;
     * &lt;code&gt;JTable&lt;/code&gt; provides all the methods for handling
     * column and row selection.  When setting states,
     * such as &lt;code&gt;setSelectionMode&lt;/code&gt;, it not only
     * updates the mode for the row selection model but also sets similar
     * values in the selection model of the &lt;code&gt;columnModel&lt;/code&gt;.
     * If you want to have the row and column selection models operating
     * in different modes, set them both directly.
     * &lt;p&gt;
     * Both the row and column selection models for &lt;code&gt;JTable&lt;/code&gt;
     * default to using a &lt;code&gt;DefaultListSelectionModel&lt;/code&gt;
     * so that &lt;code&gt;JTable&lt;/code&gt; works the same way as the
     * &lt;code&gt;JList&lt;/code&gt;. See the &lt;code&gt;setSelectionMode&lt;/code&gt; method
     * in &lt;code&gt;JList&lt;/code&gt; for details about the modes.
     *
     * @see JList#setSelectionMode
     * @beaninfo
     * description: The selection mode used by the row and column selection models.
     *        enum: SINGLE_SELECTION            ListSelectionModel.SINGLE_SELECTION
     *              SINGLE_INTERVAL_SELECTION   ListSelectionModel.SINGLE_INTERVAL_SELECTION
     *              MULTIPLE_INTERVAL_SELECTION ListSelectionModel.MULTIPLE_INTERVAL_SELECTION
     */
    public void setSelectionMode(int selectionMode) {
<span class="nc" id="L1972">        clearSelection();</span>
<span class="nc" id="L1973">        getSelectionModel().setSelectionMode(selectionMode);</span>
<span class="nc" id="L1974">        getColumnModel().getSelectionModel().setSelectionMode(selectionMode);</span>
<span class="nc" id="L1975">    }</span>

    /**
     * Sets whether the rows in this model can be selected.
     *
     * @param rowSelectionAllowed   true if this model will allow row selection
     * @see #getRowSelectionAllowed
     * @beaninfo
     *  bound: true
     *    attribute: visualUpdate true
     *  description: If true, an entire row is selected for each selected cell.
     */
    public void setRowSelectionAllowed(boolean rowSelectionAllowed) {
<span class="nc" id="L1988">        boolean old = this.rowSelectionAllowed;</span>
<span class="nc" id="L1989">        this.rowSelectionAllowed = rowSelectionAllowed;</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">        if (old != rowSelectionAllowed) {</span>
<span class="nc" id="L1991">            repaint();</span>
        }
<span class="nc" id="L1993">        firePropertyChange(&quot;rowSelectionAllowed&quot;, old, rowSelectionAllowed);</span>
<span class="nc" id="L1994">    }</span>

    /**
     * Returns true if rows can be selected.
     *
     * @return true if rows can be selected, otherwise false
     * @see #setRowSelectionAllowed
     */
    public boolean getRowSelectionAllowed() {
<span class="nc" id="L2003">        return rowSelectionAllowed;</span>
    }

    /**
     * Sets whether the columns in this model can be selected.
     *
     * @param columnSelectionAllowed   true if this model will allow column selection
     * @see #getColumnSelectionAllowed
     * @beaninfo
     *  bound: true
     *    attribute: visualUpdate true
     *  description: If true, an entire column is selected for each selected cell.
     */
    public void setColumnSelectionAllowed(boolean columnSelectionAllowed) {
<span class="nc" id="L2017">        boolean old = columnModel.getColumnSelectionAllowed();</span>
<span class="nc" id="L2018">        columnModel.setColumnSelectionAllowed(columnSelectionAllowed);</span>
<span class="nc bnc" id="L2019" title="All 2 branches missed.">        if (old != columnSelectionAllowed) {</span>
<span class="nc" id="L2020">            repaint();</span>
        }
<span class="nc" id="L2022">        firePropertyChange(&quot;columnSelectionAllowed&quot;, old, columnSelectionAllowed);</span>
<span class="nc" id="L2023">    }</span>

    /**
     * Returns true if columns can be selected.
     *
     * @return true if columns can be selected, otherwise false
     * @see #setColumnSelectionAllowed
     */
    public boolean getColumnSelectionAllowed() {
<span class="nc" id="L2032">        return columnModel.getColumnSelectionAllowed();</span>
    }

    /**
     * Sets whether this table allows both a column selection and a
     * row selection to exist simultaneously. When set,
     * the table treats the intersection of the row and column selection
     * models as the selected cells. Override &lt;code&gt;isCellSelected&lt;/code&gt; to
     * change this default behavior. This method is equivalent to setting
     * both the &lt;code&gt;rowSelectionAllowed&lt;/code&gt; property and
     * &lt;code&gt;columnSelectionAllowed&lt;/code&gt; property of the
     * &lt;code&gt;columnModel&lt;/code&gt; to the supplied value.
     *
     * @param  cellSelectionEnabled     true if simultaneous row and column
     *                                  selection is allowed
     * @see #getCellSelectionEnabled
     * @see #isCellSelected
     * @beaninfo
     *  bound: true
     *    attribute: visualUpdate true
     *  description: Select a rectangular region of cells rather than
     *               rows or columns.
     */
    public void setCellSelectionEnabled(boolean cellSelectionEnabled) {
<span class="nc" id="L2056">        setRowSelectionAllowed(cellSelectionEnabled);</span>
<span class="nc" id="L2057">        setColumnSelectionAllowed(cellSelectionEnabled);</span>
<span class="nc" id="L2058">        boolean old = this.cellSelectionEnabled;</span>
<span class="nc" id="L2059">        this.cellSelectionEnabled = cellSelectionEnabled;</span>
<span class="nc" id="L2060">        firePropertyChange(&quot;cellSelectionEnabled&quot;, old, cellSelectionEnabled);</span>
<span class="nc" id="L2061">    }</span>

    /**
     * Returns true if both row and column selection models are enabled.
     * Equivalent to &lt;code&gt;getRowSelectionAllowed() &amp;amp;&amp;amp;
     * getColumnSelectionAllowed()&lt;/code&gt;.
     *
     * @return true if both row and column selection models are enabled
     *
     * @see #setCellSelectionEnabled
     */
    public boolean getCellSelectionEnabled() {
<span class="nc bnc" id="L2073" title="All 4 branches missed.">        return getRowSelectionAllowed() &amp;&amp; getColumnSelectionAllowed();</span>
    }

    /**
     *  Selects all rows, columns, and cells in the table.
     */
    public void selectAll() {
        // If I'm currently editing, then I should stop editing
<span class="nc bnc" id="L2081" title="All 2 branches missed.">        if (isEditing()) {</span>
<span class="nc" id="L2082">            removeEditor();</span>
        }
<span class="nc bnc" id="L2084" title="All 4 branches missed.">        if (getRowCount() &gt; 0 &amp;&amp; getColumnCount() &gt; 0) {</span>
            int oldLead;
            int oldAnchor;
            ListSelectionModel selModel;

<span class="nc" id="L2089">            selModel = selectionModel;</span>
<span class="nc" id="L2090">            selModel.setValueIsAdjusting(true);</span>
<span class="nc" id="L2091">            oldLead = getAdjustedIndex(selModel.getLeadSelectionIndex(), true);</span>
<span class="nc" id="L2092">            oldAnchor = getAdjustedIndex(selModel.getAnchorSelectionIndex(), true);</span>

<span class="nc" id="L2094">            setRowSelectionInterval(0, getRowCount()-1);</span>

            // this is done to restore the anchor and lead
<span class="nc" id="L2097">            SwingUtilities2.setLeadAnchorWithoutSelection(selModel, oldLead, oldAnchor);</span>

<span class="nc" id="L2099">            selModel.setValueIsAdjusting(false);</span>

<span class="nc" id="L2101">            selModel = columnModel.getSelectionModel();</span>
<span class="nc" id="L2102">            selModel.setValueIsAdjusting(true);</span>
<span class="nc" id="L2103">            oldLead = getAdjustedIndex(selModel.getLeadSelectionIndex(), false);</span>
<span class="nc" id="L2104">            oldAnchor = getAdjustedIndex(selModel.getAnchorSelectionIndex(), false);</span>

<span class="nc" id="L2106">            setColumnSelectionInterval(0, getColumnCount()-1);</span>

            // this is done to restore the anchor and lead
<span class="nc" id="L2109">            SwingUtilities2.setLeadAnchorWithoutSelection(selModel, oldLead, oldAnchor);</span>

<span class="nc" id="L2111">            selModel.setValueIsAdjusting(false);</span>
        }
<span class="nc" id="L2113">    }</span>

    /**
     * Deselects all selected columns and rows.
     */
    public void clearSelection() {
<span class="nc" id="L2119">        selectionModel.clearSelection();</span>
<span class="nc" id="L2120">        columnModel.getSelectionModel().clearSelection();</span>
<span class="nc" id="L2121">    }</span>

    private void clearSelectionAndLeadAnchor() {
<span class="nc" id="L2124">        selectionModel.setValueIsAdjusting(true);</span>
<span class="nc" id="L2125">        columnModel.getSelectionModel().setValueIsAdjusting(true);</span>

<span class="nc" id="L2127">        clearSelection();</span>

<span class="nc" id="L2129">        selectionModel.setAnchorSelectionIndex(-1);</span>
<span class="nc" id="L2130">        selectionModel.setLeadSelectionIndex(-1);</span>
<span class="nc" id="L2131">        columnModel.getSelectionModel().setAnchorSelectionIndex(-1);</span>
<span class="nc" id="L2132">        columnModel.getSelectionModel().setLeadSelectionIndex(-1);</span>

<span class="nc" id="L2134">        selectionModel.setValueIsAdjusting(false);</span>
<span class="nc" id="L2135">        columnModel.getSelectionModel().setValueIsAdjusting(false);</span>
<span class="nc" id="L2136">    }</span>

    private int getAdjustedIndex(int index, boolean row) {
<span class="nc bnc" id="L2139" title="All 2 branches missed.">        int compare = row ? getRowCount() : getColumnCount();</span>
<span class="nc bnc" id="L2140" title="All 2 branches missed.">        return index &lt; compare ? index : -1;</span>
    }

    private int boundRow(int row) throws IllegalArgumentException {
<span class="nc bnc" id="L2144" title="All 4 branches missed.">        if (row &lt; 0 || row &gt;= getRowCount()) {</span>
<span class="nc" id="L2145">            throw new IllegalArgumentException(&quot;Row index out of range&quot;);</span>
        }
<span class="nc" id="L2147">        return row;</span>
    }

    private int boundColumn(int col) {
<span class="nc bnc" id="L2151" title="All 4 branches missed.">        if (col&lt; 0 || col &gt;= getColumnCount()) {</span>
<span class="nc" id="L2152">            throw new IllegalArgumentException(&quot;Column index out of range&quot;);</span>
        }
<span class="nc" id="L2154">        return col;</span>
    }

    /**
     * Selects the rows from &lt;code&gt;index0&lt;/code&gt; to &lt;code&gt;index1&lt;/code&gt;,
     * inclusive.
     *
     * @exception IllegalArgumentException      if &lt;code&gt;index0&lt;/code&gt; or
     *                                          &lt;code&gt;index1&lt;/code&gt; lie outside
     *                                          [0, &lt;code&gt;getRowCount()&lt;/code&gt;-1]
     * @param   index0 one end of the interval
     * @param   index1 the other end of the interval
     */
    public void setRowSelectionInterval(int index0, int index1) {
<span class="nc" id="L2168">        selectionModel.setSelectionInterval(boundRow(index0), boundRow(index1));</span>
<span class="nc" id="L2169">    }</span>

    /**
     * Selects the columns from &lt;code&gt;index0&lt;/code&gt; to &lt;code&gt;index1&lt;/code&gt;,
     * inclusive.
     *
     * @exception IllegalArgumentException      if &lt;code&gt;index0&lt;/code&gt; or
     *                                          &lt;code&gt;index1&lt;/code&gt; lie outside
     *                                          [0, &lt;code&gt;getColumnCount()&lt;/code&gt;-1]
     * @param   index0 one end of the interval
     * @param   index1 the other end of the interval
     */
    public void setColumnSelectionInterval(int index0, int index1) {
<span class="nc" id="L2182">        columnModel.getSelectionModel().setSelectionInterval(boundColumn(index0), boundColumn(index1));</span>
<span class="nc" id="L2183">    }</span>

    /**
     * Adds the rows from &lt;code&gt;index0&lt;/code&gt; to &lt;code&gt;index1&lt;/code&gt;, inclusive, to
     * the current selection.
     *
     * @exception IllegalArgumentException      if &lt;code&gt;index0&lt;/code&gt; or &lt;code&gt;index1&lt;/code&gt;
     *                                          lie outside [0, &lt;code&gt;getRowCount()&lt;/code&gt;-1]
     * @param   index0 one end of the interval
     * @param   index1 the other end of the interval
     */
    public void addRowSelectionInterval(int index0, int index1) {
<span class="nc" id="L2195">        selectionModel.addSelectionInterval(boundRow(index0), boundRow(index1));</span>
<span class="nc" id="L2196">    }</span>

    /**
     * Adds the columns from &lt;code&gt;index0&lt;/code&gt; to &lt;code&gt;index1&lt;/code&gt;,
     * inclusive, to the current selection.
     *
     * @exception IllegalArgumentException      if &lt;code&gt;index0&lt;/code&gt; or
     *                                          &lt;code&gt;index1&lt;/code&gt; lie outside
     *                                          [0, &lt;code&gt;getColumnCount()&lt;/code&gt;-1]
     * @param   index0 one end of the interval
     * @param   index1 the other end of the interval
     */
    public void addColumnSelectionInterval(int index0, int index1) {
<span class="nc" id="L2209">        columnModel.getSelectionModel().addSelectionInterval(boundColumn(index0), boundColumn(index1));</span>
<span class="nc" id="L2210">    }</span>

    /**
     * Deselects the rows from &lt;code&gt;index0&lt;/code&gt; to &lt;code&gt;index1&lt;/code&gt;, inclusive.
     *
     * @exception IllegalArgumentException      if &lt;code&gt;index0&lt;/code&gt; or
     *                                          &lt;code&gt;index1&lt;/code&gt; lie outside
     *                                          [0, &lt;code&gt;getRowCount()&lt;/code&gt;-1]
     * @param   index0 one end of the interval
     * @param   index1 the other end of the interval
     */
    public void removeRowSelectionInterval(int index0, int index1) {
<span class="nc" id="L2222">        selectionModel.removeSelectionInterval(boundRow(index0), boundRow(index1));</span>
<span class="nc" id="L2223">    }</span>

    /**
     * Deselects the columns from &lt;code&gt;index0&lt;/code&gt; to &lt;code&gt;index1&lt;/code&gt;, inclusive.
     *
     * @exception IllegalArgumentException      if &lt;code&gt;index0&lt;/code&gt; or
     *                                          &lt;code&gt;index1&lt;/code&gt; lie outside
     *                                          [0, &lt;code&gt;getColumnCount()&lt;/code&gt;-1]
     * @param   index0 one end of the interval
     * @param   index1 the other end of the interval
     */
    public void removeColumnSelectionInterval(int index0, int index1) {
<span class="nc" id="L2235">        columnModel.getSelectionModel().removeSelectionInterval(boundColumn(index0), boundColumn(index1));</span>
<span class="nc" id="L2236">    }</span>

    /**
     * Returns the index of the first selected row, -1 if no row is selected.
     * @return the index of the first selected row
     */
    public int getSelectedRow() {
<span class="nc" id="L2243">        return selectionModel.getMinSelectionIndex();</span>
    }

    /**
     * Returns the index of the first selected column,
     * -1 if no column is selected.
     * @return the index of the first selected column
     */
    public int getSelectedColumn() {
<span class="nc" id="L2252">        return columnModel.getSelectionModel().getMinSelectionIndex();</span>
    }

    /**
     * Returns the indices of all selected rows.
     *
     * @return an array of integers containing the indices of all selected rows,
     *         or an empty array if no row is selected
     * @see #getSelectedRow
     */
    public int[] getSelectedRows() {
<span class="nc" id="L2263">        int iMin = selectionModel.getMinSelectionIndex();</span>
<span class="nc" id="L2264">        int iMax = selectionModel.getMaxSelectionIndex();</span>

<span class="nc bnc" id="L2266" title="All 4 branches missed.">        if ((iMin == -1) || (iMax == -1)) {</span>
<span class="nc" id="L2267">            return new int[0];</span>
        }

<span class="nc" id="L2270">        int[] rvTmp = new int[1+ (iMax - iMin)];</span>
<span class="nc" id="L2271">        int n = 0;</span>
<span class="nc bnc" id="L2272" title="All 2 branches missed.">        for(int i = iMin; i &lt;= iMax; i++) {</span>
<span class="nc bnc" id="L2273" title="All 2 branches missed.">            if (selectionModel.isSelectedIndex(i)) {</span>
<span class="nc" id="L2274">                rvTmp[n++] = i;</span>
            }
        }
<span class="nc" id="L2277">        int[] rv = new int[n];</span>
<span class="nc" id="L2278">        System.arraycopy(rvTmp, 0, rv, 0, n);</span>
<span class="nc" id="L2279">        return rv;</span>
    }

    /**
     * Returns the indices of all selected columns.
     *
     * @return an array of integers containing the indices of all selected columns,
     *         or an empty array if no column is selected
     * @see #getSelectedColumn
     */
    public int[] getSelectedColumns() {
<span class="nc" id="L2290">        return columnModel.getSelectedColumns();</span>
    }

    /**
     * Returns the number of selected rows.
     *
     * @return the number of selected rows, 0 if no rows are selected
     */
    public int getSelectedRowCount() {
<span class="nc" id="L2299">        int iMin = selectionModel.getMinSelectionIndex();</span>
<span class="nc" id="L2300">        int iMax = selectionModel.getMaxSelectionIndex();</span>
<span class="nc" id="L2301">        int count = 0;</span>

<span class="nc bnc" id="L2303" title="All 2 branches missed.">        for(int i = iMin; i &lt;= iMax; i++) {</span>
<span class="nc bnc" id="L2304" title="All 2 branches missed.">            if (selectionModel.isSelectedIndex(i)) {</span>
<span class="nc" id="L2305">                count++;</span>
            }
        }
<span class="nc" id="L2308">        return count;</span>
    }

    /**
     * Returns the number of selected columns.
     *
     * @return the number of selected columns, 0 if no columns are selected
     */
    public int getSelectedColumnCount() {
<span class="nc" id="L2317">        return columnModel.getSelectedColumnCount();</span>
    }

    /**
     * Returns true if the specified index is in the valid range of rows,
     * and the row at that index is selected.
     *
     * @return true if &lt;code&gt;row&lt;/code&gt; is a valid index and the row at
     *              that index is selected (where 0 is the first row)
     */
    public boolean isRowSelected(int row) {
<span class="nc" id="L2328">        return selectionModel.isSelectedIndex(row);</span>
    }

    /**
     * Returns true if the specified index is in the valid range of columns,
     * and the column at that index is selected.
     *
     * @param   column   the column in the column model
     * @return true if &lt;code&gt;column&lt;/code&gt; is a valid index and the column at
     *              that index is selected (where 0 is the first column)
     */
    public boolean isColumnSelected(int column) {
<span class="nc" id="L2340">        return columnModel.getSelectionModel().isSelectedIndex(column);</span>
    }

    /**
     * Returns true if the specified indices are in the valid range of rows
     * and columns and the cell at the specified position is selected.
     * @param row   the row being queried
     * @param column  the column being queried
     *
     * @return true if &lt;code&gt;row&lt;/code&gt; and &lt;code&gt;column&lt;/code&gt; are valid indices
     *              and the cell at index &lt;code&gt;(row, column)&lt;/code&gt; is selected,
     *              where the first row and first column are at index 0
     */
    public boolean isCellSelected(int row, int column) {
<span class="nc bnc" id="L2354" title="All 4 branches missed.">        if (!getRowSelectionAllowed() &amp;&amp; !getColumnSelectionAllowed()) {</span>
<span class="nc" id="L2355">            return false;</span>
        }
<span class="nc bnc" id="L2357" title="All 4 branches missed.">        return (!getRowSelectionAllowed() || isRowSelected(row)) &amp;&amp;</span>
<span class="nc bnc" id="L2358" title="All 4 branches missed.">               (!getColumnSelectionAllowed() || isColumnSelected(column));</span>
    }

    private void changeSelectionModel(ListSelectionModel sm, int index,
                                      boolean toggle, boolean extend, boolean selected,
                                      int anchor, boolean anchorSelected) {
<span class="nc bnc" id="L2364" title="All 2 branches missed.">        if (extend) {</span>
<span class="nc bnc" id="L2365" title="All 2 branches missed.">            if (toggle) {</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">                if (anchorSelected) {</span>
<span class="nc" id="L2367">                    sm.addSelectionInterval(anchor, index);</span>
                } else {
<span class="nc" id="L2369">                    sm.removeSelectionInterval(anchor, index);</span>
                    // this is a Windows-only behavior that we want for file lists
<span class="nc bnc" id="L2371" title="All 2 branches missed.">                    if (Boolean.TRUE == getClientProperty(&quot;Table.isFileList&quot;)) {</span>
<span class="nc" id="L2372">                        sm.addSelectionInterval(index, index);</span>
<span class="nc" id="L2373">                        sm.setAnchorSelectionIndex(anchor);</span>
                    }
                }
            }
            else {
<span class="nc" id="L2378">                sm.setSelectionInterval(anchor, index);</span>
            }
        }
        else {
<span class="nc bnc" id="L2382" title="All 2 branches missed.">            if (toggle) {</span>
<span class="nc bnc" id="L2383" title="All 2 branches missed.">                if (selected) {</span>
<span class="nc" id="L2384">                    sm.removeSelectionInterval(index, index);</span>
                }
                else {
<span class="nc" id="L2387">                    sm.addSelectionInterval(index, index);</span>
                }
            }
            else {
<span class="nc" id="L2391">                sm.setSelectionInterval(index, index);</span>
            }
        }
<span class="nc" id="L2394">    }</span>

    /**
     * Updates the selection models of the table, depending on the state of the
     * two flags: &lt;code&gt;toggle&lt;/code&gt; and &lt;code&gt;extend&lt;/code&gt;. Most changes
     * to the selection that are the result of keyboard or mouse events received
     * by the UI are channeled through this method so that the behavior may be
     * overridden by a subclass. Some UIs may need more functionality than
     * this method provides, such as when manipulating the lead for discontiguous
     * selection, and may not call into this method for some selection changes.
     * &lt;p&gt;
     * This implementation uses the following conventions:
     * &lt;ul&gt;
     * &lt;li&gt; &lt;code&gt;toggle&lt;/code&gt;: &lt;em&gt;false&lt;/em&gt;, &lt;code&gt;extend&lt;/code&gt;: &lt;em&gt;false&lt;/em&gt;.
     *      Clear the previous selection and ensure the new cell is selected.
     * &lt;li&gt; &lt;code&gt;toggle&lt;/code&gt;: &lt;em&gt;false&lt;/em&gt;, &lt;code&gt;extend&lt;/code&gt;: &lt;em&gt;true&lt;/em&gt;.
     *      Extend the previous selection from the anchor to the specified cell,
     *      clearing all other selections.
     * &lt;li&gt; &lt;code&gt;toggle&lt;/code&gt;: &lt;em&gt;true&lt;/em&gt;, &lt;code&gt;extend&lt;/code&gt;: &lt;em&gt;false&lt;/em&gt;.
     *      If the specified cell is selected, deselect it. If it is not selected, select it.
     * &lt;li&gt; &lt;code&gt;toggle&lt;/code&gt;: &lt;em&gt;true&lt;/em&gt;, &lt;code&gt;extend&lt;/code&gt;: &lt;em&gt;true&lt;/em&gt;.
     *      Apply the selection state of the anchor to all cells between it and the
     *      specified cell.
     * &lt;/ul&gt;
     * @param  rowIndex   affects the selection at &lt;code&gt;row&lt;/code&gt;
     * @param  columnIndex  affects the selection at &lt;code&gt;column&lt;/code&gt;
     * @param  toggle  see description above
     * @param  extend  if true, extend the current selection
     *
     * @since 1.3
     */
    public void changeSelection(int rowIndex, int columnIndex, boolean toggle, boolean extend) {
<span class="nc" id="L2426">        ListSelectionModel rsm = getSelectionModel();</span>
<span class="nc" id="L2427">        ListSelectionModel csm = getColumnModel().getSelectionModel();</span>

<span class="nc" id="L2429">        int anchorRow = getAdjustedIndex(rsm.getAnchorSelectionIndex(), true);</span>
<span class="nc" id="L2430">        int anchorCol = getAdjustedIndex(csm.getAnchorSelectionIndex(), false);</span>

<span class="nc" id="L2432">        boolean anchorSelected = true;</span>

<span class="nc bnc" id="L2434" title="All 2 branches missed.">        if (anchorRow == -1) {</span>
<span class="nc bnc" id="L2435" title="All 2 branches missed.">            if (getRowCount() &gt; 0) {</span>
<span class="nc" id="L2436">                anchorRow = 0;</span>
            }
<span class="nc" id="L2438">            anchorSelected = false;</span>
        }

<span class="nc bnc" id="L2441" title="All 2 branches missed.">        if (anchorCol == -1) {</span>
<span class="nc bnc" id="L2442" title="All 2 branches missed.">            if (getColumnCount() &gt; 0) {</span>
<span class="nc" id="L2443">                anchorCol = 0;</span>
            }
<span class="nc" id="L2445">            anchorSelected = false;</span>
        }

        // Check the selection here rather than in each selection model.
        // This is significant in cell selection mode if we are supposed
        // to be toggling the selection. In this case it is better to
        // ensure that the cell's selection state will indeed be changed.
        // If this were done in the code for the selection model it
        // might leave a cell in selection state if the row was
        // selected but the column was not - as it would toggle them both.
<span class="nc" id="L2455">        boolean selected = isCellSelected(rowIndex, columnIndex);</span>
<span class="nc bnc" id="L2456" title="All 4 branches missed.">        anchorSelected = anchorSelected &amp;&amp; isCellSelected(anchorRow, anchorCol);</span>

<span class="nc" id="L2458">        changeSelectionModel(csm, columnIndex, toggle, extend, selected,</span>
                             anchorCol, anchorSelected);
<span class="nc" id="L2460">        changeSelectionModel(rsm, rowIndex, toggle, extend, selected,</span>
                             anchorRow, anchorSelected);

        // Scroll after changing the selection as blit scrolling is immediate,
        // so that if we cause the repaint after the scroll we end up painting
        // everything!
<span class="nc bnc" id="L2466" title="All 2 branches missed.">        if (getAutoscrolls()) {</span>
<span class="nc" id="L2467">            Rectangle cellRect = getCellRect(rowIndex, columnIndex, false);</span>
<span class="nc bnc" id="L2468" title="All 2 branches missed.">            if (cellRect != null) {</span>
<span class="nc" id="L2469">                scrollRectToVisible(cellRect);</span>
            }
        }
<span class="nc" id="L2472">    }</span>

    /**
     * Returns the foreground color for selected cells.
     *
     * @return the &lt;code&gt;Color&lt;/code&gt; object for the foreground property
     * @see #setSelectionForeground
     * @see #setSelectionBackground
     */
    public Color getSelectionForeground() {
<span class="nc" id="L2482">        return selectionForeground;</span>
    }

    /**
     * Sets the foreground color for selected cells.  Cell renderers
     * can use this color to render text and graphics for selected
     * cells.
     * &lt;p&gt;
     * The default value of this property is defined by the look
     * and feel implementation.
     * &lt;p&gt;
     * This is a &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html&quot;&gt;JavaBeans&lt;/a&gt; bound property.
     *
     * @param selectionForeground  the &lt;code&gt;Color&lt;/code&gt; to use in the foreground
     *                             for selected list items
     * @see #getSelectionForeground
     * @see #setSelectionBackground
     * @see #setForeground
     * @see #setBackground
     * @see #setFont
     * @beaninfo
     *       bound: true
     * description: A default foreground color for selected cells.
     */
    public void setSelectionForeground(Color selectionForeground) {
<span class="nc" id="L2507">        Color old = this.selectionForeground;</span>
<span class="nc" id="L2508">        this.selectionForeground = selectionForeground;</span>
<span class="nc" id="L2509">        firePropertyChange(&quot;selectionForeground&quot;, old, selectionForeground);</span>
<span class="nc" id="L2510">        repaint();</span>
<span class="nc" id="L2511">    }</span>

    /**
     * Returns the background color for selected cells.
     *
     * @return the &lt;code&gt;Color&lt;/code&gt; used for the background of selected list items
     * @see #setSelectionBackground
     * @see #setSelectionForeground
     */
    public Color getSelectionBackground() {
<span class="nc" id="L2521">        return selectionBackground;</span>
    }

    /**
     * Sets the background color for selected cells.  Cell renderers
     * can use this color to the fill selected cells.
     * &lt;p&gt;
     * The default value of this property is defined by the look
     * and feel implementation.
     * &lt;p&gt;
     * This is a &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html&quot;&gt;JavaBeans&lt;/a&gt; bound property.
     *
     * @param selectionBackground  the &lt;code&gt;Color&lt;/code&gt; to use for the background
     *                             of selected cells
     * @see #getSelectionBackground
     * @see #setSelectionForeground
     * @see #setForeground
     * @see #setBackground
     * @see #setFont
     * @beaninfo
     *       bound: true
     * description: A default background color for selected cells.
     */
    public void setSelectionBackground(Color selectionBackground) {
<span class="nc" id="L2545">        Color old = this.selectionBackground;</span>
<span class="nc" id="L2546">        this.selectionBackground = selectionBackground;</span>
<span class="nc" id="L2547">        firePropertyChange(&quot;selectionBackground&quot;, old, selectionBackground);</span>
<span class="nc" id="L2548">        repaint();</span>
<span class="nc" id="L2549">    }</span>

    /**
     * Returns the &lt;code&gt;TableColumn&lt;/code&gt; object for the column in the table
     * whose identifier is equal to &lt;code&gt;identifier&lt;/code&gt;, when compared using
     * &lt;code&gt;equals&lt;/code&gt;.
     *
     * @return  the &lt;code&gt;TableColumn&lt;/code&gt; object that matches the identifier
     * @exception IllegalArgumentException      if &lt;code&gt;identifier&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or no &lt;code&gt;TableColumn&lt;/code&gt; has this identifier
     *
     * @param   identifier                      the identifier object
     */
    public TableColumn getColumn(Object identifier) {
<span class="nc" id="L2562">        TableColumnModel cm = getColumnModel();</span>
<span class="nc" id="L2563">        int columnIndex = cm.getColumnIndex(identifier);</span>
<span class="nc" id="L2564">        return cm.getColumn(columnIndex);</span>
    }

//
// Informally implement the TableModel interface.
//

    /**
     * Maps the index of the column in the view at
     * &lt;code&gt;viewColumnIndex&lt;/code&gt; to the index of the column
     * in the table model.  Returns the index of the corresponding
     * column in the model.  If &lt;code&gt;viewColumnIndex&lt;/code&gt;
     * is less than zero, returns &lt;code&gt;viewColumnIndex&lt;/code&gt;.
     *
     * @param   viewColumnIndex     the index of the column in the view
     * @return  the index of the corresponding column in the model
     *
     * @see #convertColumnIndexToView
     */
    public int convertColumnIndexToModel(int viewColumnIndex) {
<span class="nc" id="L2584">        return SwingUtilities2.convertColumnIndexToModel(</span>
<span class="nc" id="L2585">                getColumnModel(), viewColumnIndex);</span>
    }

    /**
     * Maps the index of the column in the table model at
     * &lt;code&gt;modelColumnIndex&lt;/code&gt; to the index of the column
     * in the view.  Returns the index of the
     * corresponding column in the view; returns -1 if this column is not
     * being displayed.  If &lt;code&gt;modelColumnIndex&lt;/code&gt; is less than zero,
     * returns &lt;code&gt;modelColumnIndex&lt;/code&gt;.
     *
     * @param   modelColumnIndex     the index of the column in the model
     * @return   the index of the corresponding column in the view
     *
     * @see #convertColumnIndexToModel
     */
    public int convertColumnIndexToView(int modelColumnIndex) {
<span class="nc" id="L2602">        return SwingUtilities2.convertColumnIndexToView(</span>
<span class="nc" id="L2603">                getColumnModel(), modelColumnIndex);</span>
    }

    /**
     * Maps the index of the row in terms of the
     * &lt;code&gt;TableModel&lt;/code&gt; to the view.  If the contents of the
     * model are not sorted the model and view indices are the same.
     *
     * @param modelRowIndex the index of the row in terms of the model
     * @return the index of the corresponding row in the view, or -1 if
     *         the row isn't visible
     * @throws IndexOutOfBoundsException if sorting is enabled and passed an
     *         index outside the number of rows of the &lt;code&gt;TableModel&lt;/code&gt;
     * @see javax.swing.table.TableRowSorter
     * @since 1.6
     */
    public int convertRowIndexToView(int modelRowIndex) {
<span class="nc" id="L2620">        RowSorter sorter = getRowSorter();</span>
<span class="nc bnc" id="L2621" title="All 2 branches missed.">        if (sorter != null) {</span>
<span class="nc" id="L2622">            return sorter.convertRowIndexToView(modelRowIndex);</span>
        }
<span class="nc" id="L2624">        return modelRowIndex;</span>
    }

    /**
     * Maps the index of the row in terms of the view to the
     * underlying &lt;code&gt;TableModel&lt;/code&gt;.  If the contents of the
     * model are not sorted the model and view indices are the same.
     *
     * @param viewRowIndex the index of the row in the view
     * @return the index of the corresponding row in the model
     * @throws IndexOutOfBoundsException if sorting is enabled and passed an
     *         index outside the range of the &lt;code&gt;JTable&lt;/code&gt; as
     *         determined by the method &lt;code&gt;getRowCount&lt;/code&gt;
     * @see javax.swing.table.TableRowSorter
     * @see #getRowCount
     * @since 1.6
     */
    public int convertRowIndexToModel(int viewRowIndex) {
<span class="nc" id="L2642">        RowSorter sorter = getRowSorter();</span>
<span class="nc bnc" id="L2643" title="All 2 branches missed.">        if (sorter != null) {</span>
<span class="nc" id="L2644">            return sorter.convertRowIndexToModel(viewRowIndex);</span>
        }
<span class="nc" id="L2646">        return viewRowIndex;</span>
    }

    /**
     * Returns the number of rows that can be shown in the
     * &lt;code&gt;JTable&lt;/code&gt;, given unlimited space.  If a
     * &lt;code&gt;RowSorter&lt;/code&gt; with a filter has been specified, the
     * number of rows returned may differ from that of the underlying
     * &lt;code&gt;TableModel&lt;/code&gt;.
     *
     * @return the number of rows shown in the &lt;code&gt;JTable&lt;/code&gt;
     * @see #getColumnCount
     */
    public int getRowCount() {
<span class="nc" id="L2660">        RowSorter sorter = getRowSorter();</span>
<span class="nc bnc" id="L2661" title="All 2 branches missed.">        if (sorter != null) {</span>
<span class="nc" id="L2662">            return sorter.getViewRowCount();</span>
        }
<span class="nc" id="L2664">        return getModel().getRowCount();</span>
    }

    /**
     * Returns the number of columns in the column model. Note that this may
     * be different from the number of columns in the table model.
     *
     * @return  the number of columns in the table
     * @see #getRowCount
     * @see #removeColumn
     */
    public int getColumnCount() {
<span class="nc" id="L2676">        return getColumnModel().getColumnCount();</span>
    }

    /**
     * Returns the name of the column appearing in the view at
     * column position &lt;code&gt;column&lt;/code&gt;.
     *
     * @param  column    the column in the view being queried
     * @return the name of the column at position &lt;code&gt;column&lt;/code&gt;
                        in the view where the first column is column 0
     */
    public String getColumnName(int column) {
<span class="nc" id="L2688">        return getModel().getColumnName(convertColumnIndexToModel(column));</span>
    }

    /**
     * Returns the type of the column appearing in the view at
     * column position &lt;code&gt;column&lt;/code&gt;.
     *
     * @param   column   the column in the view being queried
     * @return the type of the column at position &lt;code&gt;column&lt;/code&gt;
     *          in the view where the first column is column 0
     */
    public Class&lt;?&gt; getColumnClass(int column) {
<span class="nc" id="L2700">        return getModel().getColumnClass(convertColumnIndexToModel(column));</span>
    }

    /**
     * Returns the cell value at &lt;code&gt;row&lt;/code&gt; and &lt;code&gt;column&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: The column is specified in the table view's display
     *              order, and not in the &lt;code&gt;TableModel&lt;/code&gt;'s column
     *              order.  This is an important distinction because as the
     *              user rearranges the columns in the table,
     *              the column at a given index in the view will change.
     *              Meanwhile the user's actions never affect the model's
     *              column ordering.
     *
     * @param   row             the row whose value is to be queried
     * @param   column          the column whose value is to be queried
     * @return  the Object at the specified cell
     */
    public Object getValueAt(int row, int column) {
<span class="nc" id="L2719">        return getModel().getValueAt(convertRowIndexToModel(row),</span>
<span class="nc" id="L2720">                                     convertColumnIndexToModel(column));</span>
    }

    /**
     * Sets the value for the cell in the table model at &lt;code&gt;row&lt;/code&gt;
     * and &lt;code&gt;column&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: The column is specified in the table view's display
     *              order, and not in the &lt;code&gt;TableModel&lt;/code&gt;'s column
     *              order.  This is an important distinction because as the
     *              user rearranges the columns in the table,
     *              the column at a given index in the view will change.
     *              Meanwhile the user's actions never affect the model's
     *              column ordering.
     *
     * &lt;code&gt;aValue&lt;/code&gt; is the new value.
     *
     * @param   aValue          the new value
     * @param   row             the row of the cell to be changed
     * @param   column          the column of the cell to be changed
     * @see #getValueAt
     */
    public void setValueAt(Object aValue, int row, int column) {
<span class="nc" id="L2743">        getModel().setValueAt(aValue, convertRowIndexToModel(row),</span>
<span class="nc" id="L2744">                              convertColumnIndexToModel(column));</span>
<span class="nc" id="L2745">    }</span>

    /**
     * Returns true if the cell at &lt;code&gt;row&lt;/code&gt; and &lt;code&gt;column&lt;/code&gt;
     * is editable.  Otherwise, invoking &lt;code&gt;setValueAt&lt;/code&gt; on the cell
     * will have no effect.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: The column is specified in the table view's display
     *              order, and not in the &lt;code&gt;TableModel&lt;/code&gt;'s column
     *              order.  This is an important distinction because as the
     *              user rearranges the columns in the table,
     *              the column at a given index in the view will change.
     *              Meanwhile the user's actions never affect the model's
     *              column ordering.
     *
     *
     * @param   row      the row whose value is to be queried
     * @param   column   the column whose value is to be queried
     * @return  true if the cell is editable
     * @see #setValueAt
     */
    public boolean isCellEditable(int row, int column) {
<span class="nc" id="L2767">        return getModel().isCellEditable(convertRowIndexToModel(row),</span>
<span class="nc" id="L2768">                                         convertColumnIndexToModel(column));</span>
    }
//
// Adding and removing columns in the view
//

    /**
     *  Appends &lt;code&gt;aColumn&lt;/code&gt; to the end of the array of columns held by
     *  this &lt;code&gt;JTable&lt;/code&gt;'s column model.
     *  If the column name of &lt;code&gt;aColumn&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     *  sets the column name of &lt;code&gt;aColumn&lt;/code&gt; to the name
     *  returned by &lt;code&gt;getModel().getColumnName()&lt;/code&gt;.
     *  &lt;p&gt;
     *  To add a column to this &lt;code&gt;JTable&lt;/code&gt; to display the
     *  &lt;code&gt;modelColumn&lt;/code&gt;'th column of data in the model with a
     *  given &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;cellRenderer&lt;/code&gt;,
     *  and &lt;code&gt;cellEditor&lt;/code&gt; you can use:
     *  &lt;pre&gt;
     *
     *      addColumn(new TableColumn(modelColumn, width, cellRenderer, cellEditor));
     *
     *  &lt;/pre&gt;
     *  [Any of the &lt;code&gt;TableColumn&lt;/code&gt; constructors can be used
     *  instead of this one.]
     *  The model column number is stored inside the &lt;code&gt;TableColumn&lt;/code&gt;
     *  and is used during rendering and editing to locate the appropriates
     *  data values in the model. The model column number does not change
     *  when columns are reordered in the view.
     *
     *  @param  aColumn         the &lt;code&gt;TableColumn&lt;/code&gt; to be added
     *  @see    #removeColumn
     */
    public void addColumn(TableColumn aColumn) {
<span class="nc bnc" id="L2801" title="All 2 branches missed.">        if (aColumn.getHeaderValue() == null) {</span>
<span class="nc" id="L2802">            int modelColumn = aColumn.getModelIndex();</span>
<span class="nc" id="L2803">            String columnName = getModel().getColumnName(modelColumn);</span>
<span class="nc" id="L2804">            aColumn.setHeaderValue(columnName);</span>
        }
<span class="nc" id="L2806">        getColumnModel().addColumn(aColumn);</span>
<span class="nc" id="L2807">    }</span>

    /**
     *  Removes &lt;code&gt;aColumn&lt;/code&gt; from this &lt;code&gt;JTable&lt;/code&gt;'s
     *  array of columns.  Note: this method does not remove the column
     *  of data from the model; it just removes the &lt;code&gt;TableColumn&lt;/code&gt;
     *  that was responsible for displaying it.
     *
     *  @param  aColumn         the &lt;code&gt;TableColumn&lt;/code&gt; to be removed
     *  @see    #addColumn
     */
    public void removeColumn(TableColumn aColumn) {
<span class="nc" id="L2819">        getColumnModel().removeColumn(aColumn);</span>
<span class="nc" id="L2820">    }</span>

    /**
     * Moves the column &lt;code&gt;column&lt;/code&gt; to the position currently
     * occupied by the column &lt;code&gt;targetColumn&lt;/code&gt; in the view.
     * The old column at &lt;code&gt;targetColumn&lt;/code&gt; is
     * shifted left or right to make room.
     *
     * @param   column                  the index of column to be moved
     * @param   targetColumn            the new index of the column
     */
    public void moveColumn(int column, int targetColumn) {
<span class="nc" id="L2832">        getColumnModel().moveColumn(column, targetColumn);</span>
<span class="nc" id="L2833">    }</span>

//
// Cover methods for various models and helper methods
//

    /**
     * Returns the index of the column that &lt;code&gt;point&lt;/code&gt; lies in,
     * or -1 if the result is not in the range
     * [0, &lt;code&gt;getColumnCount()&lt;/code&gt;-1].
     *
     * @param   point   the location of interest
     * @return  the index of the column that &lt;code&gt;point&lt;/code&gt; lies in,
     *          or -1 if the result is not in the range
     *          [0, &lt;code&gt;getColumnCount()&lt;/code&gt;-1]
     * @see     #rowAtPoint
     */
    public int columnAtPoint(Point point) {
<span class="nc" id="L2851">        int x = point.x;</span>
<span class="nc bnc" id="L2852" title="All 2 branches missed.">        if( !getComponentOrientation().isLeftToRight() ) {</span>
<span class="nc" id="L2853">            x = getWidth() - x - 1;</span>
        }
<span class="nc" id="L2855">        return getColumnModel().getColumnIndexAtX(x);</span>
    }

    /**
     * Returns the index of the row that &lt;code&gt;point&lt;/code&gt; lies in,
     * or -1 if the result is not in the range
     * [0, &lt;code&gt;getRowCount()&lt;/code&gt;-1].
     *
     * @param   point   the location of interest
     * @return  the index of the row that &lt;code&gt;point&lt;/code&gt; lies in,
     *          or -1 if the result is not in the range
     *          [0, &lt;code&gt;getRowCount()&lt;/code&gt;-1]
     * @see     #columnAtPoint
     */
    public int rowAtPoint(Point point) {
<span class="nc" id="L2870">        int y = point.y;</span>
<span class="nc bnc" id="L2871" title="All 2 branches missed.">        int result = (rowModel == null) ?  y/getRowHeight() : rowModel.getIndex(y);</span>
<span class="nc bnc" id="L2872" title="All 2 branches missed.">        if (result &lt; 0) {</span>
<span class="nc" id="L2873">            return -1;</span>
        }
<span class="nc bnc" id="L2875" title="All 2 branches missed.">        else if (result &gt;= getRowCount()) {</span>
<span class="nc" id="L2876">            return -1;</span>
        }
        else {
<span class="nc" id="L2879">            return result;</span>
        }
    }

    /**
     * Returns a rectangle for the cell that lies at the intersection of
     * &lt;code&gt;row&lt;/code&gt; and &lt;code&gt;column&lt;/code&gt;.
     * If &lt;code&gt;includeSpacing&lt;/code&gt; is true then the value returned
     * has the full height and width of the row and column
     * specified. If it is false, the returned rectangle is inset by the
     * intercell spacing to return the true bounds of the rendering or
     * editing component as it will be set during rendering.
     * &lt;p&gt;
     * If the column index is valid but the row index is less
     * than zero the method returns a rectangle with the
     * &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; values set appropriately
     * and the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; values both set
     * to zero. In general, when either the row or column indices indicate a
     * cell outside the appropriate range, the method returns a rectangle
     * depicting the closest edge of the closest cell that is within
     * the table's range. When both row and column indices are out
     * of range the returned rectangle covers the closest
     * point of the closest cell.
     * &lt;p&gt;
     * In all cases, calculations that use this method to calculate
     * results along one axis will not fail because of anomalies in
     * calculations along the other axis. When the cell is not valid
     * the &lt;code&gt;includeSpacing&lt;/code&gt; parameter is ignored.
     *
     * @param   row                   the row index where the desired cell
     *                                is located
     * @param   column                the column index where the desired cell
     *                                is located in the display; this is not
     *                                necessarily the same as the column index
     *                                in the data model for the table; the
     *                                {@link #convertColumnIndexToView(int)}
     *                                method may be used to convert a data
     *                                model column index to a display
     *                                column index
     * @param   includeSpacing        if false, return the true cell bounds -
     *                                computed by subtracting the intercell
     *                                spacing from the height and widths of
     *                                the column and row models
     *
     * @return  the rectangle containing the cell at location
     *          &lt;code&gt;row&lt;/code&gt;,&lt;code&gt;column&lt;/code&gt;
     * @see #getIntercellSpacing
     */
    public Rectangle getCellRect(int row, int column, boolean includeSpacing) {
<span class="nc" id="L2928">        Rectangle r = new Rectangle();</span>
<span class="nc" id="L2929">        boolean valid = true;</span>
<span class="nc bnc" id="L2930" title="All 2 branches missed.">        if (row &lt; 0) {</span>
            // y = height = 0;
<span class="nc" id="L2932">            valid = false;</span>
        }
<span class="nc bnc" id="L2934" title="All 2 branches missed.">        else if (row &gt;= getRowCount()) {</span>
<span class="nc" id="L2935">            r.y = getHeight();</span>
<span class="nc" id="L2936">            valid = false;</span>
        }
        else {
<span class="nc" id="L2939">            r.height = getRowHeight(row);</span>
<span class="nc bnc" id="L2940" title="All 2 branches missed.">            r.y = (rowModel == null) ? row * r.height : rowModel.getPosition(row);</span>
        }

<span class="nc bnc" id="L2943" title="All 2 branches missed.">        if (column &lt; 0) {</span>
<span class="nc bnc" id="L2944" title="All 2 branches missed.">            if( !getComponentOrientation().isLeftToRight() ) {</span>
<span class="nc" id="L2945">                r.x = getWidth();</span>
            }
            // otherwise, x = width = 0;
<span class="nc" id="L2948">            valid = false;</span>
        }
<span class="nc bnc" id="L2950" title="All 2 branches missed.">        else if (column &gt;= getColumnCount()) {</span>
<span class="nc bnc" id="L2951" title="All 2 branches missed.">            if( getComponentOrientation().isLeftToRight() ) {</span>
<span class="nc" id="L2952">                r.x = getWidth();</span>
            }
            // otherwise, x = width = 0;
<span class="nc" id="L2955">            valid = false;</span>
        }
        else {
<span class="nc" id="L2958">            TableColumnModel cm = getColumnModel();</span>
<span class="nc bnc" id="L2959" title="All 2 branches missed.">            if( getComponentOrientation().isLeftToRight() ) {</span>
<span class="nc bnc" id="L2960" title="All 2 branches missed.">                for(int i = 0; i &lt; column; i++) {</span>
<span class="nc" id="L2961">                    r.x += cm.getColumn(i).getWidth();</span>
                }
            } else {
<span class="nc bnc" id="L2964" title="All 2 branches missed.">                for(int i = cm.getColumnCount()-1; i &gt; column; i--) {</span>
<span class="nc" id="L2965">                    r.x += cm.getColumn(i).getWidth();</span>
                }
            }
<span class="nc" id="L2968">            r.width = cm.getColumn(column).getWidth();</span>
        }

<span class="nc bnc" id="L2971" title="All 4 branches missed.">        if (valid &amp;&amp; !includeSpacing) {</span>
            // Bound the margins by their associated dimensions to prevent
            // returning bounds with negative dimensions.
<span class="nc" id="L2974">            int rm = Math.min(getRowMargin(), r.height);</span>
<span class="nc" id="L2975">            int cm = Math.min(getColumnModel().getColumnMargin(), r.width);</span>
            // This is not the same as grow(), it rounds differently.
<span class="nc" id="L2977">            r.setBounds(r.x + cm/2, r.y + rm/2, r.width - cm, r.height - rm);</span>
        }
<span class="nc" id="L2979">        return r;</span>
    }

    private int viewIndexForColumn(TableColumn aColumn) {
<span class="nc" id="L2983">        TableColumnModel cm = getColumnModel();</span>
<span class="nc bnc" id="L2984" title="All 2 branches missed.">        for (int column = 0; column &lt; cm.getColumnCount(); column++) {</span>
<span class="nc bnc" id="L2985" title="All 2 branches missed.">            if (cm.getColumn(column) == aColumn) {</span>
<span class="nc" id="L2986">                return column;</span>
            }
        }
<span class="nc" id="L2989">        return -1;</span>
    }

    /**
     * Causes this table to lay out its rows and columns.  Overridden so
     * that columns can be resized to accommodate a change in the size of
     * a containing parent.
     * Resizes one or more of the columns in the table
     * so that the total width of all of this &lt;code&gt;JTable&lt;/code&gt;'s
     * columns is equal to the width of the table.
     * &lt;p&gt;
     * Before the layout begins the method gets the
     * &lt;code&gt;resizingColumn&lt;/code&gt; of the &lt;code&gt;tableHeader&lt;/code&gt;.
     * When the method is called as a result of the resizing of an enclosing window,
     * the &lt;code&gt;resizingColumn&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. This means that resizing
     * has taken place &quot;outside&quot; the &lt;code&gt;JTable&lt;/code&gt; and the change -
     * or &quot;delta&quot; - should be distributed to all of the columns regardless
     * of this &lt;code&gt;JTable&lt;/code&gt;'s automatic resize mode.
     * &lt;p&gt;
     * If the &lt;code&gt;resizingColumn&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it is one of
     * the columns in the table that has changed size rather than
     * the table itself. In this case the auto-resize modes govern
     * the way the extra (or deficit) space is distributed
     * amongst the available columns.
     * &lt;p&gt;
     * The modes are:
     * &lt;ul&gt;
     * &lt;li&gt;  AUTO_RESIZE_OFF: Don't automatically adjust the column's
     * widths at all. Use a horizontal scrollbar to accommodate the
     * columns when their sum exceeds the width of the
     * &lt;code&gt;Viewport&lt;/code&gt;.  If the &lt;code&gt;JTable&lt;/code&gt; is not
     * enclosed in a &lt;code&gt;JScrollPane&lt;/code&gt; this may
     * leave parts of the table invisible.
     * &lt;li&gt;  AUTO_RESIZE_NEXT_COLUMN: Use just the column after the
     * resizing column. This results in the &quot;boundary&quot; or divider
     * between adjacent cells being independently adjustable.
     * &lt;li&gt;  AUTO_RESIZE_SUBSEQUENT_COLUMNS: Use all columns after the
     * one being adjusted to absorb the changes.  This is the
     * default behavior.
     * &lt;li&gt;  AUTO_RESIZE_LAST_COLUMN: Automatically adjust the
     * size of the last column only. If the bounds of the last column
     * prevent the desired size from being allocated, set the
     * width of the last column to the appropriate limit and make
     * no further adjustments.
     * &lt;li&gt;  AUTO_RESIZE_ALL_COLUMNS: Spread the delta amongst all the columns
     * in the &lt;code&gt;JTable&lt;/code&gt;, including the one that is being
     * adjusted.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; When a &lt;code&gt;JTable&lt;/code&gt; makes adjustments
     *   to the widths of the columns it respects their minimum and
     *   maximum values absolutely.  It is therefore possible that,
     *   even after this method is called, the total width of the columns
     *   is still not equal to the width of the table. When this happens
     *   the &lt;code&gt;JTable&lt;/code&gt; does not put itself
     *   in AUTO_RESIZE_OFF mode to bring up a scroll bar, or break other
     *   commitments of its current auto-resize mode -- instead it
     *   allows its bounds to be set larger (or smaller) than the total of the
     *   column minimum or maximum, meaning, either that there
     *   will not be enough room to display all of the columns, or that the
     *   columns will not fill the &lt;code&gt;JTable&lt;/code&gt;'s bounds.
     *   These respectively, result in the clipping of some columns
     *   or an area being painted in the &lt;code&gt;JTable&lt;/code&gt;'s
     *   background color during painting.
     * &lt;p&gt;
     *   The mechanism for distributing the delta amongst the available
     *   columns is provided in a private method in the &lt;code&gt;JTable&lt;/code&gt;
     *   class:
     * &lt;pre&gt;
     *   adjustSizes(long targetSize, final Resizable3 r, boolean inverse)
     * &lt;/pre&gt;
     *   an explanation of which is provided in the following section.
     *   &lt;code&gt;Resizable3&lt;/code&gt; is a private
     *   interface that allows any data structure containing a collection
     *   of elements with a size, preferred size, maximum size and minimum size
     *   to have its elements manipulated by the algorithm.
     * &lt;p&gt;
     * &lt;H3&gt; Distributing the delta &lt;/H3&gt;
     * &lt;p&gt;
     * &lt;H4&gt; Overview &lt;/H4&gt;
     * &lt;P&gt;
     * Call &quot;DELTA&quot; the difference between the target size and the
     * sum of the preferred sizes of the elements in r. The individual
     * sizes are calculated by taking the original preferred
     * sizes and adding a share of the DELTA - that share being based on
     * how far each preferred size is from its limiting bound (minimum or
     * maximum).
     * &lt;p&gt;
     * &lt;H4&gt;Definition&lt;/H4&gt;
     * &lt;P&gt;
     * Call the individual constraints min[i], max[i], and pref[i].
     * &lt;p&gt;
     * Call their respective sums: MIN, MAX, and PREF.
     * &lt;p&gt;
     * Each new size will be calculated using:
     * &lt;p&gt;
     * &lt;pre&gt;
     *          size[i] = pref[i] + delta[i]
     * &lt;/pre&gt;
     * where each individual delta[i] is calculated according to:
     * &lt;p&gt;
     * If (DELTA &amp;lt; 0) we are in shrink mode where:
     * &lt;p&gt;
     * &lt;PRE&gt;
     *                        DELTA
     *          delta[i] = ------------ * (pref[i] - min[i])
     *                     (PREF - MIN)
     * &lt;/PRE&gt;
     * If (DELTA &amp;gt; 0) we are in expand mode where:
     * &lt;p&gt;
     * &lt;PRE&gt;
     *                        DELTA
     *          delta[i] = ------------ * (max[i] - pref[i])
     *                      (MAX - PREF)
     * &lt;/PRE&gt;
     * &lt;P&gt;
     * The overall effect is that the total size moves that same percentage,
     * k, towards the total minimum or maximum and that percentage guarantees
     * accommodation of the required space, DELTA.
     *
     * &lt;H4&gt;Details&lt;/H4&gt;
     * &lt;P&gt;
     * Naive evaluation of the formulae presented here would be subject to
     * the aggregated rounding errors caused by doing this operation in finite
     * precision (using ints). To deal with this, the multiplying factor above,
     * is constantly recalculated and this takes account of the rounding
     * errors in the previous iterations. The result is an algorithm that
     * produces a set of integers whose values exactly sum to the supplied
     * &lt;code&gt;targetSize&lt;/code&gt;, and does so by spreading the rounding
     * errors evenly over the given elements.
     *
     * &lt;H4&gt;When the MAX and MIN bounds are hit&lt;/H4&gt;
     * &lt;P&gt;
     * When &lt;code&gt;targetSize&lt;/code&gt; is outside the [MIN, MAX] range,
     * the algorithm sets all sizes to their appropriate limiting value
     * (maximum or minimum).
     *
     */
    public void doLayout() {
<span class="nc" id="L3128">        TableColumn resizingColumn = getResizingColumn();</span>
<span class="nc bnc" id="L3129" title="All 2 branches missed.">        if (resizingColumn == null) {</span>
<span class="nc" id="L3130">            setWidthsFromPreferredWidths(false);</span>
        }
        else {
            // JTable behaves like a layout manger - but one in which the
            // user can come along and dictate how big one of the children
            // (columns) is supposed to be.

            // A column has been resized and JTable may need to distribute
            // any overall delta to other columns, according to the resize mode.
<span class="nc" id="L3139">            int columnIndex = viewIndexForColumn(resizingColumn);</span>
<span class="nc" id="L3140">            int delta = getWidth() - getColumnModel().getTotalColumnWidth();</span>
<span class="nc" id="L3141">            accommodateDelta(columnIndex, delta);</span>
<span class="nc" id="L3142">            delta = getWidth() - getColumnModel().getTotalColumnWidth();</span>

            // If the delta cannot be completely accomodated, then the
            // resizing column will have to take any remainder. This means
            // that the column is not being allowed to take the requested
            // width. This happens under many circumstances: For example,
            // AUTO_RESIZE_NEXT_COLUMN specifies that any delta be distributed
            // to the column after the resizing column. If one were to attempt
            // to resize the last column of the table, there would be no
            // columns after it, and hence nowhere to distribute the delta.
            // It would then be given entirely back to the resizing column,
            // preventing it from changing size.
<span class="nc bnc" id="L3154" title="All 2 branches missed.">            if (delta != 0) {</span>
<span class="nc" id="L3155">                resizingColumn.setWidth(resizingColumn.getWidth() + delta);</span>
            }

            // At this point the JTable has to work out what preferred sizes
            // would have resulted in the layout the user has chosen.
            // Thereafter, during window resizing etc. it has to work off
            // the preferred sizes as usual - the idea being that, whatever
            // the user does, everything stays in synch and things don't jump
            // around.
<span class="nc" id="L3164">            setWidthsFromPreferredWidths(true);</span>
        }

<span class="nc" id="L3167">        super.doLayout();</span>
<span class="nc" id="L3168">    }</span>

    private TableColumn getResizingColumn() {
<span class="nc bnc" id="L3171" title="All 2 branches missed.">        return (tableHeader == null) ? null</span>
<span class="nc" id="L3172">                                     : tableHeader.getResizingColumn();</span>
    }

    /**
     * Sizes the table columns to fit the available space.
     * @deprecated As of Swing version 1.0.3,
     * replaced by &lt;code&gt;doLayout()&lt;/code&gt;.
     * @see #doLayout
     */
    @Deprecated
    public void sizeColumnsToFit(boolean lastColumnOnly) {
<span class="nc" id="L3183">        int oldAutoResizeMode = autoResizeMode;</span>
<span class="nc bnc" id="L3184" title="All 2 branches missed.">        setAutoResizeMode(lastColumnOnly ? AUTO_RESIZE_LAST_COLUMN</span>
                                         : AUTO_RESIZE_ALL_COLUMNS);
<span class="nc" id="L3186">        sizeColumnsToFit(-1);</span>
<span class="nc" id="L3187">        setAutoResizeMode(oldAutoResizeMode);</span>
<span class="nc" id="L3188">    }</span>

    /**
     * Obsolete as of Java 2 platform v1.4.  Please use the
     * &lt;code&gt;doLayout()&lt;/code&gt; method instead.
     * @param resizingColumn    the column whose resizing made this adjustment
     *                          necessary or -1 if there is no such column
     * @see  #doLayout
     */
    public void sizeColumnsToFit(int resizingColumn) {
<span class="nc bnc" id="L3198" title="All 2 branches missed.">        if (resizingColumn == -1) {</span>
<span class="nc" id="L3199">            setWidthsFromPreferredWidths(false);</span>
        }
        else {
<span class="nc bnc" id="L3202" title="All 2 branches missed.">            if (autoResizeMode == AUTO_RESIZE_OFF) {</span>
<span class="nc" id="L3203">                TableColumn aColumn = getColumnModel().getColumn(resizingColumn);</span>
<span class="nc" id="L3204">                aColumn.setPreferredWidth(aColumn.getWidth());</span>
<span class="nc" id="L3205">            }</span>
            else {
<span class="nc" id="L3207">                int delta = getWidth() - getColumnModel().getTotalColumnWidth();</span>
<span class="nc" id="L3208">                accommodateDelta(resizingColumn, delta);</span>
<span class="nc" id="L3209">                setWidthsFromPreferredWidths(true);</span>
            }
        }
<span class="nc" id="L3212">    }</span>

    private void setWidthsFromPreferredWidths(final boolean inverse) {
<span class="nc" id="L3215">        int totalWidth     = getWidth();</span>
<span class="nc" id="L3216">        int totalPreferred = getPreferredSize().width;</span>
<span class="nc bnc" id="L3217" title="All 2 branches missed.">        int target = !inverse ? totalWidth : totalPreferred;</span>

<span class="nc" id="L3219">        final TableColumnModel cm = columnModel;</span>
<span class="nc" id="L3220">        Resizable3 r = new Resizable3() {</span>
<span class="nc" id="L3221">            public int  getElementCount()      { return cm.getColumnCount(); }</span>
<span class="nc" id="L3222">            public int  getLowerBoundAt(int i) { return cm.getColumn(i).getMinWidth(); }</span>
<span class="nc" id="L3223">            public int  getUpperBoundAt(int i) { return cm.getColumn(i).getMaxWidth(); }</span>
            public int  getMidPointAt(int i)  {
<span class="nc bnc" id="L3225" title="All 2 branches missed.">                if (!inverse) {</span>
<span class="nc" id="L3226">                    return cm.getColumn(i).getPreferredWidth();</span>
                }
                else {
<span class="nc" id="L3229">                    return cm.getColumn(i).getWidth();</span>
                }
            }
            public void setSizeAt(int s, int i) {
<span class="nc bnc" id="L3233" title="All 2 branches missed.">                if (!inverse) {</span>
<span class="nc" id="L3234">                    cm.getColumn(i).setWidth(s);</span>
                }
                else {
<span class="nc" id="L3237">                    cm.getColumn(i).setPreferredWidth(s);</span>
                }
<span class="nc" id="L3239">            }</span>
        };

<span class="nc" id="L3242">        adjustSizes(target, r, inverse);</span>
<span class="nc" id="L3243">    }</span>


    // Distribute delta over columns, as indicated by the autoresize mode.
    private void accommodateDelta(int resizingColumnIndex, int delta) {
<span class="nc" id="L3248">        int columnCount = getColumnCount();</span>
<span class="nc" id="L3249">        int from = resizingColumnIndex;</span>
        int to;

        // Use the mode to determine how to absorb the changes.
<span class="nc bnc" id="L3253" title="All 5 branches missed.">        switch(autoResizeMode) {</span>
            case AUTO_RESIZE_NEXT_COLUMN:
<span class="nc" id="L3255">                from = from + 1;</span>
<span class="nc" id="L3256">                to = Math.min(from + 1, columnCount); break;</span>
            case AUTO_RESIZE_SUBSEQUENT_COLUMNS:
<span class="nc" id="L3258">                from = from + 1;</span>
<span class="nc" id="L3259">                to = columnCount; break;</span>
            case AUTO_RESIZE_LAST_COLUMN:
<span class="nc" id="L3261">                from = columnCount - 1;</span>
<span class="nc" id="L3262">                to = from + 1; break;</span>
            case AUTO_RESIZE_ALL_COLUMNS:
<span class="nc" id="L3264">                from = 0;</span>
<span class="nc" id="L3265">                to = columnCount; break;</span>
            default:
<span class="nc" id="L3267">                return;</span>
        }

<span class="nc" id="L3270">        final int start = from;</span>
<span class="nc" id="L3271">        final int end = to;</span>
<span class="nc" id="L3272">        final TableColumnModel cm = columnModel;</span>
<span class="nc" id="L3273">        Resizable3 r = new Resizable3() {</span>
<span class="nc" id="L3274">            public int  getElementCount()       { return end-start; }</span>
<span class="nc" id="L3275">            public int  getLowerBoundAt(int i)  { return cm.getColumn(i+start).getMinWidth(); }</span>
<span class="nc" id="L3276">            public int  getUpperBoundAt(int i)  { return cm.getColumn(i+start).getMaxWidth(); }</span>
<span class="nc" id="L3277">            public int  getMidPointAt(int i)    { return cm.getColumn(i+start).getWidth(); }</span>
<span class="nc" id="L3278">            public void setSizeAt(int s, int i) {        cm.getColumn(i+start).setWidth(s); }</span>
        };

<span class="nc" id="L3281">        int totalWidth = 0;</span>
<span class="nc bnc" id="L3282" title="All 2 branches missed.">        for(int i = from; i &lt; to; i++) {</span>
<span class="nc" id="L3283">            TableColumn aColumn = columnModel.getColumn(i);</span>
<span class="nc" id="L3284">            int input = aColumn.getWidth();</span>
<span class="nc" id="L3285">            totalWidth = totalWidth + input;</span>
        }

<span class="nc" id="L3288">        adjustSizes(totalWidth + delta, r, false);</span>
<span class="nc" id="L3289">    }</span>

    private interface Resizable2 {
        public int  getElementCount();
        public int  getLowerBoundAt(int i);
        public int  getUpperBoundAt(int i);
        public void setSizeAt(int newSize, int i);
    }

    private interface Resizable3 extends Resizable2 {
        public int  getMidPointAt(int i);
    }


    private void adjustSizes(long target, final Resizable3 r, boolean inverse) {
<span class="nc" id="L3304">        int N = r.getElementCount();</span>
<span class="nc" id="L3305">        long totalPreferred = 0;</span>
<span class="nc bnc" id="L3306" title="All 2 branches missed.">        for(int i = 0; i &lt; N; i++) {</span>
<span class="nc" id="L3307">            totalPreferred += r.getMidPointAt(i);</span>
        }
        Resizable2 s;
<span class="nc bnc" id="L3310" title="All 6 branches missed.">        if ((target &lt; totalPreferred) == !inverse) {</span>
<span class="nc" id="L3311">            s = new Resizable2() {</span>
<span class="nc" id="L3312">                public int  getElementCount()      { return r.getElementCount(); }</span>
<span class="nc" id="L3313">                public int  getLowerBoundAt(int i) { return r.getLowerBoundAt(i); }</span>
<span class="nc" id="L3314">                public int  getUpperBoundAt(int i) { return r.getMidPointAt(i); }</span>
<span class="nc" id="L3315">                public void setSizeAt(int newSize, int i) { r.setSizeAt(newSize, i); }</span>

            };
        }
        else {
<span class="nc" id="L3320">            s = new Resizable2() {</span>
<span class="nc" id="L3321">                public int  getElementCount()      { return r.getElementCount(); }</span>
<span class="nc" id="L3322">                public int  getLowerBoundAt(int i) { return r.getMidPointAt(i); }</span>
<span class="nc" id="L3323">                public int  getUpperBoundAt(int i) { return r.getUpperBoundAt(i); }</span>
<span class="nc" id="L3324">                public void setSizeAt(int newSize, int i) { r.setSizeAt(newSize, i); }</span>

            };
        }
<span class="nc bnc" id="L3328" title="All 2 branches missed.">        adjustSizes(target, s, !inverse);</span>
<span class="nc" id="L3329">    }</span>

    private void adjustSizes(long target, Resizable2 r, boolean limitToRange) {
<span class="nc" id="L3332">        long totalLowerBound = 0;</span>
<span class="nc" id="L3333">        long totalUpperBound = 0;</span>
<span class="nc bnc" id="L3334" title="All 2 branches missed.">        for(int i = 0; i &lt; r.getElementCount(); i++) {</span>
<span class="nc" id="L3335">            totalLowerBound += r.getLowerBoundAt(i);</span>
<span class="nc" id="L3336">            totalUpperBound += r.getUpperBoundAt(i);</span>
        }

<span class="nc bnc" id="L3339" title="All 2 branches missed.">        if (limitToRange) {</span>
<span class="nc" id="L3340">            target = Math.min(Math.max(totalLowerBound, target), totalUpperBound);</span>
        }

<span class="nc bnc" id="L3343" title="All 2 branches missed.">        for(int i = 0; i &lt; r.getElementCount(); i++) {</span>
<span class="nc" id="L3344">            int lowerBound = r.getLowerBoundAt(i);</span>
<span class="nc" id="L3345">            int upperBound = r.getUpperBoundAt(i);</span>
            // Check for zero. This happens when the distribution of the delta
            // finishes early due to a series of &quot;fixed&quot; entries at the end.
            // In this case, lowerBound == upperBound, for all subsequent terms.
            int newSize;
<span class="nc bnc" id="L3350" title="All 2 branches missed.">            if (totalLowerBound == totalUpperBound) {</span>
<span class="nc" id="L3351">                newSize = lowerBound;</span>
            }
            else {
<span class="nc" id="L3354">                double f = (double)(target - totalLowerBound)/(totalUpperBound - totalLowerBound);</span>
<span class="nc" id="L3355">                newSize = (int)Math.round(lowerBound+f*(upperBound - lowerBound));</span>
                // We'd need to round manually in an all integer version.
                // size[i] = (int)(((totalUpperBound - target) * lowerBound +
                //     (target - totalLowerBound) * upperBound)/(totalUpperBound-totalLowerBound));
            }
<span class="nc" id="L3360">            r.setSizeAt(newSize, i);</span>
<span class="nc" id="L3361">            target -= newSize;</span>
<span class="nc" id="L3362">            totalLowerBound -= lowerBound;</span>
<span class="nc" id="L3363">            totalUpperBound -= upperBound;</span>
        }
<span class="nc" id="L3365">    }</span>

    /**
     * Overrides &lt;code&gt;JComponent&lt;/code&gt;'s &lt;code&gt;getToolTipText&lt;/code&gt;
     * method in order to allow the renderer's tips to be used
     * if it has text set.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; For &lt;code&gt;JTable&lt;/code&gt; to properly display
     * tooltips of its renderers
     * &lt;code&gt;JTable&lt;/code&gt; must be a registered component with the
     * &lt;code&gt;ToolTipManager&lt;/code&gt;.
     * This is done automatically in &lt;code&gt;initializeLocalVars&lt;/code&gt;,
     * but if at a later point &lt;code&gt;JTable&lt;/code&gt; is told
     * &lt;code&gt;setToolTipText(null)&lt;/code&gt; it will unregister the table
     * component, and no tips from renderers will display anymore.
     *
     * @see JComponent#getToolTipText
     */
    public String getToolTipText(MouseEvent event) {
<span class="nc" id="L3384">        String tip = null;</span>
<span class="nc" id="L3385">        Point p = event.getPoint();</span>

        // Locate the renderer under the event location
<span class="nc" id="L3388">        int hitColumnIndex = columnAtPoint(p);</span>
<span class="nc" id="L3389">        int hitRowIndex = rowAtPoint(p);</span>

<span class="nc bnc" id="L3391" title="All 4 branches missed.">        if ((hitColumnIndex != -1) &amp;&amp; (hitRowIndex != -1)) {</span>
<span class="nc" id="L3392">            TableCellRenderer renderer = getCellRenderer(hitRowIndex, hitColumnIndex);</span>
<span class="nc" id="L3393">            Component component = prepareRenderer(renderer, hitRowIndex, hitColumnIndex);</span>

            // Now have to see if the component is a JComponent before
            // getting the tip
<span class="nc bnc" id="L3397" title="All 2 branches missed.">            if (component instanceof JComponent) {</span>
                // Convert the event to the renderer's coordinate system
<span class="nc" id="L3399">                Rectangle cellRect = getCellRect(hitRowIndex, hitColumnIndex, false);</span>
<span class="nc" id="L3400">                p.translate(-cellRect.x, -cellRect.y);</span>
<span class="nc" id="L3401">                MouseEvent newEvent = new MouseEvent(component, event.getID(),</span>
<span class="nc" id="L3402">                                          event.getWhen(), event.getModifiers(),</span>
                                          p.x, p.y,
<span class="nc" id="L3404">                                          event.getXOnScreen(),</span>
<span class="nc" id="L3405">                                          event.getYOnScreen(),</span>
<span class="nc" id="L3406">                                          event.getClickCount(),</span>
<span class="nc" id="L3407">                                          event.isPopupTrigger(),</span>
                                          MouseEvent.NOBUTTON);

<span class="nc" id="L3410">                tip = ((JComponent)component).getToolTipText(newEvent);</span>
            }
        }

        // No tip from the renderer get our own tip
<span class="nc bnc" id="L3415" title="All 2 branches missed.">        if (tip == null)</span>
<span class="nc" id="L3416">            tip = getToolTipText();</span>

<span class="nc" id="L3418">        return tip;</span>
    }

//
// Editing Support
//

    /**
     * Sets whether editors in this JTable get the keyboard focus
     * when an editor is activated as a result of the JTable
     * forwarding keyboard events for a cell.
     * By default, this property is false, and the JTable
     * retains the focus unless the cell is clicked.
     *
     * @param surrendersFocusOnKeystroke true if the editor should get the focus
     *          when keystrokes cause the editor to be
     *          activated
     *
     *
     * @see #getSurrendersFocusOnKeystroke
     * @since 1.4
     */
    public void setSurrendersFocusOnKeystroke(boolean surrendersFocusOnKeystroke) {
<span class="nc" id="L3441">        this.surrendersFocusOnKeystroke = surrendersFocusOnKeystroke;</span>
<span class="nc" id="L3442">    }</span>

    /**
     * Returns true if the editor should get the focus
     * when keystrokes cause the editor to be activated
     *
     * @return  true if the editor should get the focus
     *          when keystrokes cause the editor to be
     *          activated
     *
     * @see #setSurrendersFocusOnKeystroke
     * @since 1.4
     */
    public boolean getSurrendersFocusOnKeystroke() {
<span class="nc" id="L3456">        return surrendersFocusOnKeystroke;</span>
    }

    /**
     * Programmatically starts editing the cell at &lt;code&gt;row&lt;/code&gt; and
     * &lt;code&gt;column&lt;/code&gt;, if those indices are in the valid range, and
     * the cell at those indices is editable.
     * Note that this is a convenience method for
     * &lt;code&gt;editCellAt(int, int, null)&lt;/code&gt;.
     *
     * @param   row                             the row to be edited
     * @param   column                          the column to be edited
     * @return  false if for any reason the cell cannot be edited,
     *                or if the indices are invalid
     */
    public boolean editCellAt(int row, int column) {
<span class="nc" id="L3472">        return editCellAt(row, column, null);</span>
    }

    /**
     * Programmatically starts editing the cell at &lt;code&gt;row&lt;/code&gt; and
     * &lt;code&gt;column&lt;/code&gt;, if those indices are in the valid range, and
     * the cell at those indices is editable.
     * To prevent the &lt;code&gt;JTable&lt;/code&gt; from
     * editing a particular table, column or cell value, return false from
     * the &lt;code&gt;isCellEditable&lt;/code&gt; method in the &lt;code&gt;TableModel&lt;/code&gt;
     * interface.
     *
     * @param   row     the row to be edited
     * @param   column  the column to be edited
     * @param   e       event to pass into &lt;code&gt;shouldSelectCell&lt;/code&gt;;
     *                  note that as of Java 2 platform v1.2, the call to
     *                  &lt;code&gt;shouldSelectCell&lt;/code&gt; is no longer made
     * @return  false if for any reason the cell cannot be edited,
     *                or if the indices are invalid
     */
    public boolean editCellAt(int row, int column, EventObject e){
<span class="nc bnc" id="L3493" title="All 4 branches missed.">        if (cellEditor != null &amp;&amp; !cellEditor.stopCellEditing()) {</span>
<span class="nc" id="L3494">            return false;</span>
        }

<span class="nc bnc" id="L3497" title="All 6 branches missed.">        if (row &lt; 0 || row &gt;= getRowCount() ||</span>
<span class="nc bnc" id="L3498" title="All 2 branches missed.">            column &lt; 0 || column &gt;= getColumnCount()) {</span>
<span class="nc" id="L3499">            return false;</span>
        }

<span class="nc bnc" id="L3502" title="All 2 branches missed.">        if (!isCellEditable(row, column))</span>
<span class="nc" id="L3503">            return false;</span>

<span class="nc bnc" id="L3505" title="All 2 branches missed.">        if (editorRemover == null) {</span>
            KeyboardFocusManager fm =
<span class="nc" id="L3507">                KeyboardFocusManager.getCurrentKeyboardFocusManager();</span>
<span class="nc" id="L3508">            editorRemover = new CellEditorRemover(fm);</span>
<span class="nc" id="L3509">            fm.addPropertyChangeListener(&quot;permanentFocusOwner&quot;, editorRemover);</span>
        }

<span class="nc" id="L3512">        TableCellEditor editor = getCellEditor(row, column);</span>
<span class="nc bnc" id="L3513" title="All 4 branches missed.">        if (editor != null &amp;&amp; editor.isCellEditable(e)) {</span>
<span class="nc" id="L3514">            editorComp = prepareEditor(editor, row, column);</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">            if (editorComp == null) {</span>
<span class="nc" id="L3516">                removeEditor();</span>
<span class="nc" id="L3517">                return false;</span>
            }
<span class="nc" id="L3519">            editorComp.setBounds(getCellRect(row, column, false));</span>
<span class="nc" id="L3520">            add(editorComp);</span>
<span class="nc" id="L3521">            editorComp.validate();</span>
<span class="nc" id="L3522">            editorComp.repaint();</span>

<span class="nc" id="L3524">            setCellEditor(editor);</span>
<span class="nc" id="L3525">            setEditingRow(row);</span>
<span class="nc" id="L3526">            setEditingColumn(column);</span>
<span class="nc" id="L3527">            editor.addCellEditorListener(this);</span>

<span class="nc" id="L3529">            return true;</span>
        }
<span class="nc" id="L3531">        return false;</span>
    }

    /**
     * Returns true if a cell is being edited.
     *
     * @return  true if the table is editing a cell
     * @see     #editingColumn
     * @see     #editingRow
     */
    public boolean isEditing() {
<span class="nc bnc" id="L3542" title="All 2 branches missed.">        return cellEditor != null;</span>
    }

    /**
     * Returns the component that is handling the editing session.
     * If nothing is being edited, returns null.
     *
     * @return  Component handling editing session
     */
    public Component getEditorComponent() {
<span class="nc" id="L3552">        return editorComp;</span>
    }

    /**
     * Returns the index of the column that contains the cell currently
     * being edited.  If nothing is being edited, returns -1.
     *
     * @return  the index of the column that contains the cell currently
     *          being edited; returns -1 if nothing being edited
     * @see #editingRow
     */
    public int getEditingColumn() {
<span class="nc" id="L3564">        return editingColumn;</span>
    }

    /**
     * Returns the index of the row that contains the cell currently
     * being edited.  If nothing is being edited, returns -1.
     *
     * @return  the index of the row that contains the cell currently
     *          being edited; returns -1 if nothing being edited
     * @see #editingColumn
     */
    public int getEditingRow() {
<span class="nc" id="L3576">        return editingRow;</span>
    }

//
// Managing TableUI
//

    /**
     * Returns the L&amp;amp;F object that renders this component.
     *
     * @return the &lt;code&gt;TableUI&lt;/code&gt; object that renders this component
     */
    public TableUI getUI() {
<span class="nc" id="L3589">        return (TableUI)ui;</span>
    }

    /**
     * Sets the L&amp;amp;F object that renders this component and repaints.
     *
     * @param ui  the TableUI L&amp;amp;F object
     * @see UIDefaults#getUI
     * @beaninfo
     *        bound: true
     *       hidden: true
     *    attribute: visualUpdate true
     *  description: The UI object that implements the Component's LookAndFeel.
     */
    public void setUI(TableUI ui) {
<span class="nc bnc" id="L3604" title="All 2 branches missed.">        if (this.ui != ui) {</span>
<span class="nc" id="L3605">            super.setUI(ui);</span>
<span class="nc" id="L3606">            repaint();</span>
        }
<span class="nc" id="L3608">    }</span>

    /**
     * Notification from the &lt;code&gt;UIManager&lt;/code&gt; that the L&amp;amp;F has changed.
     * Replaces the current UI object with the latest version from the
     * &lt;code&gt;UIManager&lt;/code&gt;.
     *
     * @see JComponent#updateUI
     */
    public void updateUI() {
        // Update the UIs of the cell renderers, cell editors and header renderers.
<span class="nc" id="L3619">        TableColumnModel cm = getColumnModel();</span>
<span class="nc bnc" id="L3620" title="All 2 branches missed.">        for(int column = 0; column &lt; cm.getColumnCount(); column++) {</span>
<span class="nc" id="L3621">            TableColumn aColumn = cm.getColumn(column);</span>
<span class="nc" id="L3622">            SwingUtilities.updateRendererOrEditorUI(aColumn.getCellRenderer());</span>
<span class="nc" id="L3623">            SwingUtilities.updateRendererOrEditorUI(aColumn.getCellEditor());</span>
<span class="nc" id="L3624">            SwingUtilities.updateRendererOrEditorUI(aColumn.getHeaderRenderer());</span>
        }

        // Update the UIs of all the default renderers.
<span class="nc" id="L3628">        Enumeration defaultRenderers = defaultRenderersByColumnClass.elements();</span>
<span class="nc bnc" id="L3629" title="All 2 branches missed.">        while (defaultRenderers.hasMoreElements()) {</span>
<span class="nc" id="L3630">            SwingUtilities.updateRendererOrEditorUI(defaultRenderers.nextElement());</span>
        }

        // Update the UIs of all the default editors.
<span class="nc" id="L3634">        Enumeration defaultEditors = defaultEditorsByColumnClass.elements();</span>
<span class="nc bnc" id="L3635" title="All 2 branches missed.">        while (defaultEditors.hasMoreElements()) {</span>
<span class="nc" id="L3636">            SwingUtilities.updateRendererOrEditorUI(defaultEditors.nextElement());</span>
        }

        // Update the UI of the table header
<span class="nc bnc" id="L3640" title="All 4 branches missed.">        if (tableHeader != null &amp;&amp; tableHeader.getParent() == null) {</span>
<span class="nc" id="L3641">            tableHeader.updateUI();</span>
        }

        // Update UI applied to parent ScrollPane
<span class="nc" id="L3645">        configureEnclosingScrollPaneUI();</span>

<span class="nc" id="L3647">        setUI((TableUI)UIManager.getUI(this));</span>
<span class="nc" id="L3648">    }</span>

    /**
     * Returns the suffix used to construct the name of the L&amp;amp;F class used to
     * render this component.
     *
     * @return the string &quot;TableUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L3659">        return uiClassID;</span>
    }


//
// Managing models
//

    /**
     * Sets the data model for this table to &lt;code&gt;newModel&lt;/code&gt; and registers
     * with it for listener notifications from the new data model.
     *
     * @param   dataModel        the new data source for this table
     * @exception IllegalArgumentException      if &lt;code&gt;newModel&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @see     #getModel
     * @beaninfo
     *  bound: true
     *  description: The model that is the source of the data for this view.
     */
    public void setModel(TableModel dataModel) {
<span class="nc bnc" id="L3679" title="All 2 branches missed.">        if (dataModel == null) {</span>
<span class="nc" id="L3680">            throw new IllegalArgumentException(&quot;Cannot set a null TableModel&quot;);</span>
        }
<span class="nc bnc" id="L3682" title="All 2 branches missed.">        if (this.dataModel != dataModel) {</span>
<span class="nc" id="L3683">            TableModel old = this.dataModel;</span>
<span class="nc bnc" id="L3684" title="All 2 branches missed.">            if (old != null) {</span>
<span class="nc" id="L3685">                old.removeTableModelListener(this);</span>
            }
<span class="nc" id="L3687">            this.dataModel = dataModel;</span>
<span class="nc" id="L3688">            dataModel.addTableModelListener(this);</span>

<span class="nc" id="L3690">            tableChanged(new TableModelEvent(dataModel, TableModelEvent.HEADER_ROW));</span>

<span class="nc" id="L3692">            firePropertyChange(&quot;model&quot;, old, dataModel);</span>

<span class="nc bnc" id="L3694" title="All 2 branches missed.">            if (getAutoCreateRowSorter()) {</span>
<span class="nc" id="L3695">                setRowSorter(new TableRowSorter&lt;TableModel&gt;(dataModel));</span>
            }
        }
<span class="nc" id="L3698">    }</span>

    /**
     * Returns the &lt;code&gt;TableModel&lt;/code&gt; that provides the data displayed by this
     * &lt;code&gt;JTable&lt;/code&gt;.
     *
     * @return  the &lt;code&gt;TableModel&lt;/code&gt; that provides the data displayed by this &lt;code&gt;JTable&lt;/code&gt;
     * @see     #setModel
     */
    public TableModel getModel() {
<span class="nc" id="L3708">        return dataModel;</span>
    }

    /**
     * Sets the column model for this table to &lt;code&gt;newModel&lt;/code&gt; and registers
     * for listener notifications from the new column model. Also sets
     * the column model of the &lt;code&gt;JTableHeader&lt;/code&gt; to &lt;code&gt;columnModel&lt;/code&gt;.
     *
     * @param   columnModel        the new data source for this table
     * @exception IllegalArgumentException      if &lt;code&gt;columnModel&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @see     #getColumnModel
     * @beaninfo
     *  bound: true
     *  description: The object governing the way columns appear in the view.
     */
    public void setColumnModel(TableColumnModel columnModel) {
<span class="nc bnc" id="L3724" title="All 2 branches missed.">        if (columnModel == null) {</span>
<span class="nc" id="L3725">            throw new IllegalArgumentException(&quot;Cannot set a null ColumnModel&quot;);</span>
        }
<span class="nc" id="L3727">        TableColumnModel old = this.columnModel;</span>
<span class="nc bnc" id="L3728" title="All 2 branches missed.">        if (columnModel != old) {</span>
<span class="nc bnc" id="L3729" title="All 2 branches missed.">            if (old != null) {</span>
<span class="nc" id="L3730">                old.removeColumnModelListener(this);</span>
            }
<span class="nc" id="L3732">            this.columnModel = columnModel;</span>
<span class="nc" id="L3733">            columnModel.addColumnModelListener(this);</span>

            // Set the column model of the header as well.
<span class="nc bnc" id="L3736" title="All 2 branches missed.">            if (tableHeader != null) {</span>
<span class="nc" id="L3737">                tableHeader.setColumnModel(columnModel);</span>
            }

<span class="nc" id="L3740">            firePropertyChange(&quot;columnModel&quot;, old, columnModel);</span>
<span class="nc" id="L3741">            resizeAndRepaint();</span>
        }
<span class="nc" id="L3743">    }</span>

    /**
     * Returns the &lt;code&gt;TableColumnModel&lt;/code&gt; that contains all column information
     * of this table.
     *
     * @return  the object that provides the column state of the table
     * @see     #setColumnModel
     */
    public TableColumnModel getColumnModel() {
<span class="nc" id="L3753">        return columnModel;</span>
    }

    /**
     * Sets the row selection model for this table to &lt;code&gt;newModel&lt;/code&gt;
     * and registers for listener notifications from the new selection model.
     *
     * @param   newModel        the new selection model
     * @exception IllegalArgumentException      if &lt;code&gt;newModel&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @see     #getSelectionModel
     * @beaninfo
     *      bound: true
     *      description: The selection model for rows.
     */
    public void setSelectionModel(ListSelectionModel newModel) {
<span class="nc bnc" id="L3768" title="All 2 branches missed.">        if (newModel == null) {</span>
<span class="nc" id="L3769">            throw new IllegalArgumentException(&quot;Cannot set a null SelectionModel&quot;);</span>
        }

<span class="nc" id="L3772">        ListSelectionModel oldModel = selectionModel;</span>

<span class="nc bnc" id="L3774" title="All 2 branches missed.">        if (newModel != oldModel) {</span>
<span class="nc bnc" id="L3775" title="All 2 branches missed.">            if (oldModel != null) {</span>
<span class="nc" id="L3776">                oldModel.removeListSelectionListener(this);</span>
            }

<span class="nc" id="L3779">            selectionModel = newModel;</span>
<span class="nc" id="L3780">            newModel.addListSelectionListener(this);</span>

<span class="nc" id="L3782">            firePropertyChange(&quot;selectionModel&quot;, oldModel, newModel);</span>
<span class="nc" id="L3783">            repaint();</span>
        }
<span class="nc" id="L3785">    }</span>

    /**
     * Returns the &lt;code&gt;ListSelectionModel&lt;/code&gt; that is used to maintain row
     * selection state.
     *
     * @return  the object that provides row selection state, &lt;code&gt;null&lt;/code&gt;
     *          if row selection is not allowed
     * @see     #setSelectionModel
     */
    public ListSelectionModel getSelectionModel() {
<span class="nc" id="L3796">        return selectionModel;</span>
    }

//
// RowSorterListener
//

    /**
     * &lt;code&gt;RowSorterListener&lt;/code&gt; notification that the
     * &lt;code&gt;RowSorter&lt;/code&gt; has changed in some way.
     *
     * @param e the &lt;code&gt;RowSorterEvent&lt;/code&gt; describing the change
     * @throws NullPointerException if &lt;code&gt;e&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @since 1.6
     */
    public void sorterChanged(RowSorterEvent e) {
<span class="nc bnc" id="L3812" title="All 2 branches missed.">        if (e.getType() == RowSorterEvent.Type.SORT_ORDER_CHANGED) {</span>
<span class="nc" id="L3813">            JTableHeader header = getTableHeader();</span>
<span class="nc bnc" id="L3814" title="All 2 branches missed.">            if (header != null) {</span>
<span class="nc" id="L3815">                header.repaint();</span>
            }
<span class="nc" id="L3817">        }</span>
<span class="nc bnc" id="L3818" title="All 2 branches missed.">        else if (e.getType() == RowSorterEvent.Type.SORTED) {</span>
<span class="nc" id="L3819">            sorterChanged = true;</span>
<span class="nc bnc" id="L3820" title="All 2 branches missed.">            if (!ignoreSortChange) {</span>
<span class="nc" id="L3821">                sortedTableChanged(e, null);</span>
            }
        }
<span class="nc" id="L3824">    }</span>


    /**
     * SortManager provides support for managing the selection and variable
     * row heights when sorting is enabled. This information is encapsulated
     * into a class to avoid bulking up JTable.
     */
    private final class SortManager {
        RowSorter&lt;? extends TableModel&gt; sorter;

        // Selection, in terms of the model. This is lazily created
        // as needed.
        private ListSelectionModel modelSelection;
        private int modelLeadIndex;
        // Set to true while in the process of changing the selection.
        // If this is true the selection change is ignored.
        private boolean syncingSelection;
        // Temporary cache of selection, in terms of model. This is only used
        // if we don't need the full weight of modelSelection.
        private int[] lastModelSelection;

        // Heights of the rows in terms of the model.
        private SizeSequence modelRowSizes;


<span class="nc" id="L3850">        SortManager(RowSorter&lt;? extends TableModel&gt; sorter) {</span>
<span class="nc" id="L3851">            this.sorter = sorter;</span>
<span class="nc" id="L3852">            sorter.addRowSorterListener(JTable.this);</span>
<span class="nc" id="L3853">        }</span>

        /**
         * Disposes any resources used by this SortManager.
         */
        public void dispose() {
<span class="nc bnc" id="L3859" title="All 2 branches missed.">            if (sorter != null) {</span>
<span class="nc" id="L3860">                sorter.removeRowSorterListener(JTable.this);</span>
            }
<span class="nc" id="L3862">        }</span>

        /**
         * Sets the height for a row at a specified index.
         */
        public void setViewRowHeight(int viewIndex, int rowHeight) {
<span class="nc bnc" id="L3868" title="All 2 branches missed.">            if (modelRowSizes == null) {</span>
<span class="nc" id="L3869">                modelRowSizes = new SizeSequence(getModel().getRowCount(),</span>
<span class="nc" id="L3870">                                                 getRowHeight());</span>
            }
<span class="nc" id="L3872">            modelRowSizes.setSize(convertRowIndexToModel(viewIndex),rowHeight);</span>
<span class="nc" id="L3873">        }</span>

        /**
         * Invoked when the underlying model has completely changed.
         */
        public void allChanged() {
<span class="nc" id="L3879">            modelLeadIndex = -1;</span>
<span class="nc" id="L3880">            modelSelection = null;</span>
<span class="nc" id="L3881">            modelRowSizes = null;</span>
<span class="nc" id="L3882">        }</span>

        /**
         * Invoked when the selection, on the view, has changed.
         */
        public void viewSelectionChanged(ListSelectionEvent e) {
<span class="nc bnc" id="L3888" title="All 4 branches missed.">            if (!syncingSelection &amp;&amp; modelSelection != null) {</span>
<span class="nc" id="L3889">                modelSelection = null;</span>
            }
<span class="nc" id="L3891">        }</span>

        /**
         * Invoked when either the table model has changed, or the RowSorter
         * has changed. This is invoked prior to notifying the sorter of the
         * change.
         */
        public void prepareForChange(RowSorterEvent sortEvent,
                                     ModelChange change) {
<span class="nc bnc" id="L3900" title="All 2 branches missed.">            if (getUpdateSelectionOnSort()) {</span>
<span class="nc" id="L3901">                cacheSelection(sortEvent, change);</span>
            }
<span class="nc" id="L3903">        }</span>

        /**
         * Updates the internal cache of the selection based on the change.
         */
        private void cacheSelection(RowSorterEvent sortEvent,
                                    ModelChange change) {
<span class="nc bnc" id="L3910" title="All 2 branches missed.">            if (sortEvent != null) {</span>
                // sort order changed. If modelSelection is null and filtering
                // is enabled we need to cache the selection in terms of the
                // underlying model, this will allow us to correctly restore
                // the selection even if rows are filtered out.
<span class="nc bnc" id="L3915" title="All 2 branches missed.">                if (modelSelection == null &amp;&amp;</span>
<span class="nc bnc" id="L3916" title="All 2 branches missed.">                        sorter.getViewRowCount() != getModel().getRowCount()) {</span>
<span class="nc" id="L3917">                    modelSelection = new DefaultListSelectionModel();</span>
<span class="nc" id="L3918">                    ListSelectionModel viewSelection = getSelectionModel();</span>
<span class="nc" id="L3919">                    int min = viewSelection.getMinSelectionIndex();</span>
<span class="nc" id="L3920">                    int max = viewSelection.getMaxSelectionIndex();</span>
                    int modelIndex;
<span class="nc bnc" id="L3922" title="All 2 branches missed.">                    for (int viewIndex = min; viewIndex &lt;= max; viewIndex++) {</span>
<span class="nc bnc" id="L3923" title="All 2 branches missed.">                        if (viewSelection.isSelectedIndex(viewIndex)) {</span>
<span class="nc" id="L3924">                            modelIndex = convertRowIndexToModel(</span>
                                    sortEvent, viewIndex);
<span class="nc bnc" id="L3926" title="All 2 branches missed.">                            if (modelIndex != -1) {</span>
<span class="nc" id="L3927">                                modelSelection.addSelectionInterval(</span>
                                    modelIndex, modelIndex);
                            }
                        }
                    }
<span class="nc" id="L3932">                    modelIndex = convertRowIndexToModel(sortEvent,</span>
<span class="nc" id="L3933">                            viewSelection.getLeadSelectionIndex());</span>
<span class="nc" id="L3934">                    SwingUtilities2.setLeadAnchorWithoutSelection(</span>
                            modelSelection, modelIndex, modelIndex);
<span class="nc bnc" id="L3936" title="All 2 branches missed.">                } else if (modelSelection == null) {</span>
                    // Sorting changed, haven't cached selection in terms
                    // of model and no filtering. Temporarily cache selection.
<span class="nc" id="L3939">                    cacheModelSelection(sortEvent);</span>
                }
<span class="nc bnc" id="L3941" title="All 2 branches missed.">            } else if (change.allRowsChanged) {</span>
                // All the rows have changed, chuck any cached selection.
<span class="nc" id="L3943">                modelSelection = null;</span>
<span class="nc bnc" id="L3944" title="All 2 branches missed.">            } else if (modelSelection != null) {</span>
                // Table changed, reflect changes in cached selection model.
<span class="nc bnc" id="L3946" title="All 3 branches missed.">                switch(change.type) {</span>
                case TableModelEvent.DELETE:
<span class="nc" id="L3948">                    modelSelection.removeIndexInterval(change.startModelIndex,</span>
                                                       change.endModelIndex);
<span class="nc" id="L3950">                    break;</span>
                case TableModelEvent.INSERT:
<span class="nc" id="L3952">                    modelSelection.insertIndexInterval(change.startModelIndex,</span>
                                                       change.length,
                                                       true);
<span class="nc" id="L3955">                    break;</span>
                default:
<span class="nc" id="L3957">                    break;</span>
                }
            } else {
                // table changed, but haven't cached rows, temporarily
                // cache them.
<span class="nc" id="L3962">                cacheModelSelection(null);</span>
            }
<span class="nc" id="L3964">        }</span>

        private void cacheModelSelection(RowSorterEvent sortEvent) {
<span class="nc" id="L3967">            lastModelSelection = convertSelectionToModel(sortEvent);</span>
<span class="nc" id="L3968">            modelLeadIndex = convertRowIndexToModel(sortEvent,</span>
<span class="nc" id="L3969">                        selectionModel.getLeadSelectionIndex());</span>
<span class="nc" id="L3970">        }</span>

        /**
         * Inovked when either the table has changed or the sorter has changed
         * and after the sorter has been notified. If necessary this will
         * reapply the selection and variable row heights.
         */
        public void processChange(RowSorterEvent sortEvent,
                                  ModelChange change,
                                  boolean sorterChanged) {
<span class="nc bnc" id="L3980" title="All 2 branches missed.">            if (change != null) {</span>
<span class="nc bnc" id="L3981" title="All 2 branches missed.">                if (change.allRowsChanged) {</span>
<span class="nc" id="L3982">                    modelRowSizes = null;</span>
<span class="nc" id="L3983">                    rowModel = null;</span>
<span class="nc bnc" id="L3984" title="All 2 branches missed.">                } else if (modelRowSizes != null) {</span>
<span class="nc bnc" id="L3985" title="All 2 branches missed.">                    if (change.type == TableModelEvent.INSERT) {</span>
<span class="nc" id="L3986">                        modelRowSizes.insertEntries(change.startModelIndex,</span>
                                                    change.endModelIndex -
                                                    change.startModelIndex + 1,
<span class="nc" id="L3989">                                                    getRowHeight());</span>
<span class="nc bnc" id="L3990" title="All 2 branches missed.">                    } else if (change.type == TableModelEvent.DELETE) {</span>
<span class="nc" id="L3991">                        modelRowSizes.removeEntries(change.startModelIndex,</span>
                                                    change.endModelIndex -
                                                    change.startModelIndex +1 );
                    }
                }
            }
<span class="nc bnc" id="L3997" title="All 2 branches missed.">            if (sorterChanged) {</span>
<span class="nc" id="L3998">                setViewRowHeightsFromModel();</span>
<span class="nc" id="L3999">                restoreSelection(change);</span>
            }
<span class="nc" id="L4001">        }</span>

        /**
         * Resets the variable row heights in terms of the view from
         * that of the variable row heights in terms of the model.
         */
        private void setViewRowHeightsFromModel() {
<span class="nc bnc" id="L4008" title="All 2 branches missed.">            if (modelRowSizes != null) {</span>
<span class="nc" id="L4009">                rowModel.setSizes(getRowCount(), getRowHeight());</span>
<span class="nc bnc" id="L4010" title="All 2 branches missed.">                for (int viewIndex = getRowCount() - 1; viewIndex &gt;= 0;</span>
<span class="nc" id="L4011">                         viewIndex--) {</span>
<span class="nc" id="L4012">                    int modelIndex = convertRowIndexToModel(viewIndex);</span>
<span class="nc" id="L4013">                    rowModel.setSize(viewIndex,</span>
<span class="nc" id="L4014">                                     modelRowSizes.getSize(modelIndex));</span>
                }
            }
<span class="nc" id="L4017">        }</span>

        /**
         * Restores the selection from that in terms of the model.
         */
        private void restoreSelection(ModelChange change) {
<span class="nc" id="L4023">            syncingSelection = true;</span>
<span class="nc bnc" id="L4024" title="All 2 branches missed.">            if (lastModelSelection != null) {</span>
<span class="nc" id="L4025">                restoreSortingSelection(lastModelSelection,</span>
                                        modelLeadIndex, change);
<span class="nc" id="L4027">                lastModelSelection = null;</span>
<span class="nc bnc" id="L4028" title="All 2 branches missed.">            } else if (modelSelection != null) {</span>
<span class="nc" id="L4029">                ListSelectionModel viewSelection = getSelectionModel();</span>
<span class="nc" id="L4030">                viewSelection.setValueIsAdjusting(true);</span>
<span class="nc" id="L4031">                viewSelection.clearSelection();</span>
<span class="nc" id="L4032">                int min = modelSelection.getMinSelectionIndex();</span>
<span class="nc" id="L4033">                int max = modelSelection.getMaxSelectionIndex();</span>
                int viewIndex;
<span class="nc bnc" id="L4035" title="All 2 branches missed.">                for (int modelIndex = min; modelIndex &lt;= max; modelIndex++) {</span>
<span class="nc bnc" id="L4036" title="All 2 branches missed.">                    if (modelSelection.isSelectedIndex(modelIndex)) {</span>
<span class="nc" id="L4037">                        viewIndex = convertRowIndexToView(modelIndex);</span>
<span class="nc bnc" id="L4038" title="All 2 branches missed.">                        if (viewIndex != -1) {</span>
<span class="nc" id="L4039">                            viewSelection.addSelectionInterval(viewIndex,</span>
                                                               viewIndex);
                        }
                    }
                }
                // Restore the lead
<span class="nc" id="L4045">                int viewLeadIndex = modelSelection.getLeadSelectionIndex();</span>
<span class="nc bnc" id="L4046" title="All 2 branches missed.">                if (viewLeadIndex != -1) {</span>
<span class="nc" id="L4047">                    viewLeadIndex = convertRowIndexToView(viewLeadIndex);</span>
                }
<span class="nc" id="L4049">                SwingUtilities2.setLeadAnchorWithoutSelection(</span>
                        viewSelection, viewLeadIndex, viewLeadIndex);
<span class="nc" id="L4051">                viewSelection.setValueIsAdjusting(false);</span>
            }
<span class="nc" id="L4053">            syncingSelection = false;</span>
<span class="nc" id="L4054">        }</span>
    }


    /**
     * ModelChange is used when sorting to restore state, it corresponds
     * to data from a TableModelEvent.  The values are precalculated as
     * they are used extensively.
     */
    private final class ModelChange {
        // Starting index of the change, in terms of the model
        int startModelIndex;

        // Ending index of the change, in terms of the model
        int endModelIndex;

        // Type of change
        int type;

        // Number of rows in the model
        int modelRowCount;

        // The event that triggered this.
        TableModelEvent event;

        // Length of the change (end - start + 1)
        int length;

        // True if the event indicates all the contents have changed
        boolean allRowsChanged;

<span class="nc" id="L4085">        ModelChange(TableModelEvent e) {</span>
<span class="nc" id="L4086">            startModelIndex = Math.max(0, e.getFirstRow());</span>
<span class="nc" id="L4087">            endModelIndex = e.getLastRow();</span>
<span class="nc" id="L4088">            modelRowCount = getModel().getRowCount();</span>
<span class="nc bnc" id="L4089" title="All 2 branches missed.">            if (endModelIndex &lt; 0) {</span>
<span class="nc" id="L4090">                endModelIndex = Math.max(0, modelRowCount - 1);</span>
            }
<span class="nc" id="L4092">            length = endModelIndex - startModelIndex + 1;</span>
<span class="nc" id="L4093">            type = e.getType();</span>
<span class="nc" id="L4094">            event = e;</span>
<span class="nc bnc" id="L4095" title="All 2 branches missed.">            allRowsChanged = (e.getLastRow() == Integer.MAX_VALUE);</span>
<span class="nc" id="L4096">        }</span>
    }

    /**
     * Invoked when &lt;code&gt;sorterChanged&lt;/code&gt; is invoked, or
     * when &lt;code&gt;tableChanged&lt;/code&gt; is invoked and sorting is enabled.
     */
    private void sortedTableChanged(RowSorterEvent sortedEvent,
                                    TableModelEvent e) {
<span class="nc" id="L4105">        int editingModelIndex = -1;</span>
<span class="nc bnc" id="L4106" title="All 2 branches missed.">        ModelChange change = (e != null) ? new ModelChange(e) : null;</span>

<span class="nc bnc" id="L4108" title="All 6 branches missed.">        if ((change == null || !change.allRowsChanged) &amp;&amp;</span>
                this.editingRow != -1) {
<span class="nc" id="L4110">            editingModelIndex = convertRowIndexToModel(sortedEvent,</span>
                                                       this.editingRow);
        }

<span class="nc" id="L4114">        sortManager.prepareForChange(sortedEvent, change);</span>

<span class="nc bnc" id="L4116" title="All 2 branches missed.">        if (e != null) {</span>
<span class="nc bnc" id="L4117" title="All 2 branches missed.">            if (change.type == TableModelEvent.UPDATE) {</span>
<span class="nc" id="L4118">                repaintSortedRows(change);</span>
            }
<span class="nc" id="L4120">            notifySorter(change);</span>
<span class="nc bnc" id="L4121" title="All 2 branches missed.">            if (change.type != TableModelEvent.UPDATE) {</span>
                // If the Sorter is unsorted we will not have received
                // notification, force treating insert/delete as a change.
<span class="nc" id="L4124">                sorterChanged = true;</span>
            }
        }
        else {
<span class="nc" id="L4128">            sorterChanged = true;</span>
        }

<span class="nc" id="L4131">        sortManager.processChange(sortedEvent, change, sorterChanged);</span>

<span class="nc bnc" id="L4133" title="All 2 branches missed.">        if (sorterChanged) {</span>
            // Update the editing row
<span class="nc bnc" id="L4135" title="All 2 branches missed.">            if (this.editingRow != -1) {</span>
<span class="nc bnc" id="L4136" title="All 2 branches missed.">                int newIndex = (editingModelIndex == -1) ? -1 :</span>
<span class="nc" id="L4137">                        convertRowIndexToView(editingModelIndex,change);</span>
<span class="nc" id="L4138">                restoreSortingEditingRow(newIndex);</span>
            }

            // And handle the appropriate repainting.
<span class="nc bnc" id="L4142" title="All 4 branches missed.">            if (e == null || change.type != TableModelEvent.UPDATE) {</span>
<span class="nc" id="L4143">                resizeAndRepaint();</span>
            }
        }

        // Check if lead/anchor need to be reset.
<span class="nc bnc" id="L4148" title="All 4 branches missed.">        if (change != null &amp;&amp; change.allRowsChanged) {</span>
<span class="nc" id="L4149">            clearSelectionAndLeadAnchor();</span>
<span class="nc" id="L4150">            resizeAndRepaint();</span>
        }
<span class="nc" id="L4152">    }</span>

    /**
     * Repaints the sort of sorted rows in response to a TableModelEvent.
     */
    private void repaintSortedRows(ModelChange change) {
<span class="nc bnc" id="L4158" title="All 4 branches missed.">        if (change.startModelIndex &gt; change.endModelIndex ||</span>
                change.startModelIndex + 10 &lt; change.endModelIndex) {
            // Too much has changed, punt
<span class="nc" id="L4161">            repaint();</span>
<span class="nc" id="L4162">            return;</span>
        }
<span class="nc" id="L4164">        int eventColumn = change.event.getColumn();</span>
<span class="nc" id="L4165">        int columnViewIndex = eventColumn;</span>
<span class="nc bnc" id="L4166" title="All 2 branches missed.">        if (columnViewIndex == TableModelEvent.ALL_COLUMNS) {</span>
<span class="nc" id="L4167">            columnViewIndex = 0;</span>
        }
        else {
<span class="nc" id="L4170">            columnViewIndex = convertColumnIndexToView(columnViewIndex);</span>
<span class="nc bnc" id="L4171" title="All 2 branches missed.">            if (columnViewIndex == -1) {</span>
<span class="nc" id="L4172">                return;</span>
            }
        }
<span class="nc" id="L4175">        int modelIndex = change.startModelIndex;</span>
<span class="nc bnc" id="L4176" title="All 2 branches missed.">        while (modelIndex &lt;= change.endModelIndex) {</span>
<span class="nc" id="L4177">            int viewIndex = convertRowIndexToView(modelIndex++);</span>
<span class="nc bnc" id="L4178" title="All 2 branches missed.">            if (viewIndex != -1) {</span>
<span class="nc" id="L4179">                Rectangle dirty = getCellRect(viewIndex, columnViewIndex,</span>
                                              false);
<span class="nc" id="L4181">                int x = dirty.x;</span>
<span class="nc" id="L4182">                int w = dirty.width;</span>
<span class="nc bnc" id="L4183" title="All 2 branches missed.">                if (eventColumn == TableModelEvent.ALL_COLUMNS) {</span>
<span class="nc" id="L4184">                    x = 0;</span>
<span class="nc" id="L4185">                    w = getWidth();</span>
                }
<span class="nc" id="L4187">                repaint(x, dirty.y, w, dirty.height);</span>
            }
<span class="nc" id="L4189">        }</span>
<span class="nc" id="L4190">    }</span>

    /**
     * Restores the selection after a model event/sort order changes.
     * All coordinates are in terms of the model.
     */
    private void restoreSortingSelection(int[] selection, int lead,
            ModelChange change) {
        // Convert the selection from model to view
<span class="nc bnc" id="L4199" title="All 2 branches missed.">        for (int i = selection.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L4200">            selection[i] = convertRowIndexToView(selection[i], change);</span>
        }
<span class="nc" id="L4202">        lead = convertRowIndexToView(lead, change);</span>

        // Check for the common case of no change in selection for 1 row
<span class="nc bnc" id="L4205" title="All 4 branches missed.">        if (selection.length == 0 ||</span>
<span class="nc bnc" id="L4206" title="All 2 branches missed.">            (selection.length == 1 &amp;&amp; selection[0] == getSelectedRow())) {</span>
<span class="nc" id="L4207">            return;</span>
        }

        // And apply the new selection
<span class="nc" id="L4211">        selectionModel.setValueIsAdjusting(true);</span>
<span class="nc" id="L4212">        selectionModel.clearSelection();</span>
<span class="nc bnc" id="L4213" title="All 2 branches missed.">        for (int i = selection.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L4214" title="All 2 branches missed.">            if (selection[i] != -1) {</span>
<span class="nc" id="L4215">                selectionModel.addSelectionInterval(selection[i],</span>
                                                    selection[i]);
            }
        }
<span class="nc" id="L4219">        SwingUtilities2.setLeadAnchorWithoutSelection(</span>
                selectionModel, lead, lead);
<span class="nc" id="L4221">        selectionModel.setValueIsAdjusting(false);</span>
<span class="nc" id="L4222">    }</span>

    /**
     * Restores the editing row after a model event/sort order change.
     *
     * @param editingRow new index of the editingRow, in terms of the view
     */
    private void restoreSortingEditingRow(int editingRow) {
<span class="nc bnc" id="L4230" title="All 2 branches missed.">        if (editingRow == -1) {</span>
            // Editing row no longer being shown, cancel editing
<span class="nc" id="L4232">            TableCellEditor editor = getCellEditor();</span>
<span class="nc bnc" id="L4233" title="All 2 branches missed.">            if (editor != null) {</span>
                // First try and cancel
<span class="nc" id="L4235">                editor.cancelCellEditing();</span>
<span class="nc bnc" id="L4236" title="All 2 branches missed.">                if (getCellEditor() != null) {</span>
                    // CellEditor didn't cede control, forcefully
                    // remove it
<span class="nc" id="L4239">                    removeEditor();</span>
                }
            }
<span class="nc" id="L4242">        }</span>
        else {
            // Repositioning handled in BasicTableUI
<span class="nc" id="L4245">            this.editingRow = editingRow;</span>
<span class="nc" id="L4246">            repaint();</span>
        }
<span class="nc" id="L4248">    }</span>

    /**
     * Notifies the sorter of a change in the underlying model.
     */
    private void notifySorter(ModelChange change) {
        try {
<span class="nc" id="L4255">            ignoreSortChange = true;</span>
<span class="nc" id="L4256">            sorterChanged = false;</span>
<span class="nc bnc" id="L4257" title="All 4 branches missed.">            switch(change.type) {</span>
            case TableModelEvent.UPDATE:
<span class="nc bnc" id="L4259" title="All 2 branches missed.">                if (change.event.getLastRow() == Integer.MAX_VALUE) {</span>
<span class="nc" id="L4260">                    sortManager.sorter.allRowsChanged();</span>
<span class="nc bnc" id="L4261" title="All 2 branches missed.">                } else if (change.event.getColumn() ==</span>
                           TableModelEvent.ALL_COLUMNS) {
<span class="nc" id="L4263">                    sortManager.sorter.rowsUpdated(change.startModelIndex,</span>
                                       change.endModelIndex);
                } else {
<span class="nc" id="L4266">                    sortManager.sorter.rowsUpdated(change.startModelIndex,</span>
                                       change.endModelIndex,
<span class="nc" id="L4268">                                       change.event.getColumn());</span>
                }
<span class="nc" id="L4270">                break;</span>
            case TableModelEvent.INSERT:
<span class="nc" id="L4272">                sortManager.sorter.rowsInserted(change.startModelIndex,</span>
                                    change.endModelIndex);
<span class="nc" id="L4274">                break;</span>
            case TableModelEvent.DELETE:
<span class="nc" id="L4276">                sortManager.sorter.rowsDeleted(change.startModelIndex,</span>
                                   change.endModelIndex);
                break;
            }
        } finally {
<span class="nc" id="L4281">            ignoreSortChange = false;</span>
<span class="nc" id="L4282">        }</span>
<span class="nc" id="L4283">    }</span>

    /**
     * Converts a model index to view index.  This is called when the
     * sorter or model changes and sorting is enabled.
     *
     * @param change describes the TableModelEvent that initiated the change;
     *        will be null if called as the result of a sort
     */
    private int convertRowIndexToView(int modelIndex, ModelChange change) {
<span class="nc bnc" id="L4293" title="All 2 branches missed.">        if (modelIndex &lt; 0) {</span>
<span class="nc" id="L4294">            return -1;</span>
        }
<span class="nc bnc" id="L4296" title="All 4 branches missed.">        if (change != null &amp;&amp; modelIndex &gt;= change.startModelIndex) {</span>
<span class="nc bnc" id="L4297" title="All 2 branches missed.">            if (change.type == TableModelEvent.INSERT) {</span>
<span class="nc bnc" id="L4298" title="All 2 branches missed.">                if (modelIndex + change.length &gt;= change.modelRowCount) {</span>
<span class="nc" id="L4299">                    return -1;</span>
                }
<span class="nc" id="L4301">                return sortManager.sorter.convertRowIndexToView(</span>
                        modelIndex + change.length);
            }
<span class="nc bnc" id="L4304" title="All 2 branches missed.">            else if (change.type == TableModelEvent.DELETE) {</span>
<span class="nc bnc" id="L4305" title="All 2 branches missed.">                if (modelIndex &lt;= change.endModelIndex) {</span>
                    // deleted
<span class="nc" id="L4307">                    return -1;</span>
                }
                else {
<span class="nc bnc" id="L4310" title="All 2 branches missed.">                    if (modelIndex - change.length &gt;= change.modelRowCount) {</span>
<span class="nc" id="L4311">                        return -1;</span>
                    }
<span class="nc" id="L4313">                    return sortManager.sorter.convertRowIndexToView(</span>
                            modelIndex - change.length);
                }
            }
            // else, updated
        }
<span class="nc bnc" id="L4319" title="All 2 branches missed.">        if (modelIndex &gt;= getModel().getRowCount()) {</span>
<span class="nc" id="L4320">            return -1;</span>
        }
<span class="nc" id="L4322">        return sortManager.sorter.convertRowIndexToView(modelIndex);</span>
    }

    /**
     * Converts the selection to model coordinates.  This is used when
     * the model changes or the sorter changes.
     */
    private int[] convertSelectionToModel(RowSorterEvent e) {
<span class="nc" id="L4330">        int[] selection = getSelectedRows();</span>
<span class="nc bnc" id="L4331" title="All 2 branches missed.">        for (int i = selection.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L4332">            selection[i] = convertRowIndexToModel(e, selection[i]);</span>
        }
<span class="nc" id="L4334">        return selection;</span>
    }

    private int convertRowIndexToModel(RowSorterEvent e, int viewIndex) {
<span class="nc bnc" id="L4338" title="All 2 branches missed.">        if (e != null) {</span>
<span class="nc bnc" id="L4339" title="All 2 branches missed.">            if (e.getPreviousRowCount() == 0) {</span>
<span class="nc" id="L4340">                return viewIndex;</span>
            }
            // range checking handled by RowSorterEvent
<span class="nc" id="L4343">            return e.convertPreviousRowIndexToModel(viewIndex);</span>
        }
        // Make sure the viewIndex is valid
<span class="nc bnc" id="L4346" title="All 4 branches missed.">        if (viewIndex &lt; 0 || viewIndex &gt;= getRowCount()) {</span>
<span class="nc" id="L4347">            return -1;</span>
        }
<span class="nc" id="L4349">        return convertRowIndexToModel(viewIndex);</span>
    }

//
// Implementing TableModelListener interface
//

    /**
     * Invoked when this table's &lt;code&gt;TableModel&lt;/code&gt; generates
     * a &lt;code&gt;TableModelEvent&lt;/code&gt;.
     * The &lt;code&gt;TableModelEvent&lt;/code&gt; should be constructed in the
     * coordinate system of the model; the appropriate mapping to the
     * view coordinate system is performed by this &lt;code&gt;JTable&lt;/code&gt;
     * when it receives the event.
     * &lt;p&gt;
     * Application code will not use these methods explicitly, they
     * are used internally by &lt;code&gt;JTable&lt;/code&gt;.
     * &lt;p&gt;
     * Note that as of 1.3, this method clears the selection, if any.
     */
    public void tableChanged(TableModelEvent e) {
<span class="nc bnc" id="L4370" title="All 4 branches missed.">        if (e == null || e.getFirstRow() == TableModelEvent.HEADER_ROW) {</span>
            // The whole thing changed
<span class="nc" id="L4372">            clearSelectionAndLeadAnchor();</span>

<span class="nc" id="L4374">            rowModel = null;</span>

<span class="nc bnc" id="L4376" title="All 2 branches missed.">            if (sortManager != null) {</span>
                try {
<span class="nc" id="L4378">                    ignoreSortChange = true;</span>
<span class="nc" id="L4379">                    sortManager.sorter.modelStructureChanged();</span>
                } finally {
<span class="nc" id="L4381">                    ignoreSortChange = false;</span>
<span class="nc" id="L4382">                }</span>
<span class="nc" id="L4383">                sortManager.allChanged();</span>
            }

<span class="nc bnc" id="L4386" title="All 2 branches missed.">            if (getAutoCreateColumnsFromModel()) {</span>
                // This will effect invalidation of the JTable and JTableHeader.
<span class="nc" id="L4388">                createDefaultColumnsFromModel();</span>
<span class="nc" id="L4389">                return;</span>
            }

<span class="nc" id="L4392">            resizeAndRepaint();</span>
<span class="nc" id="L4393">            return;</span>
        }

<span class="nc bnc" id="L4396" title="All 2 branches missed.">        if (sortManager != null) {</span>
<span class="nc" id="L4397">            sortedTableChanged(null, e);</span>
<span class="nc" id="L4398">            return;</span>
        }

        // The totalRowHeight calculated below will be incorrect if
        // there are variable height rows. Repaint the visible region,
        // but don't return as a revalidate may be necessary as well.
<span class="nc bnc" id="L4404" title="All 2 branches missed.">        if (rowModel != null) {</span>
<span class="nc" id="L4405">            repaint();</span>
        }

<span class="nc bnc" id="L4408" title="All 2 branches missed.">        if (e.getType() == TableModelEvent.INSERT) {</span>
<span class="nc" id="L4409">            tableRowsInserted(e);</span>
<span class="nc" id="L4410">            return;</span>
        }

<span class="nc bnc" id="L4413" title="All 2 branches missed.">        if (e.getType() == TableModelEvent.DELETE) {</span>
<span class="nc" id="L4414">            tableRowsDeleted(e);</span>
<span class="nc" id="L4415">            return;</span>
        }

<span class="nc" id="L4418">        int modelColumn = e.getColumn();</span>
<span class="nc" id="L4419">        int start = e.getFirstRow();</span>
<span class="nc" id="L4420">        int end = e.getLastRow();</span>

        Rectangle dirtyRegion;
<span class="nc bnc" id="L4423" title="All 2 branches missed.">        if (modelColumn == TableModelEvent.ALL_COLUMNS) {</span>
            // 1 or more rows changed
<span class="nc" id="L4425">            dirtyRegion = new Rectangle(0, start * getRowHeight(),</span>
<span class="nc" id="L4426">                                        getColumnModel().getTotalColumnWidth(), 0);</span>
        }
        else {
            // A cell or column of cells has changed.
            // Unlike the rest of the methods in the JTable, the TableModelEvent
            // uses the coordinate system of the model instead of the view.
            // This is the only place in the JTable where this &quot;reverse mapping&quot;
            // is used.
<span class="nc" id="L4434">            int column = convertColumnIndexToView(modelColumn);</span>
<span class="nc" id="L4435">            dirtyRegion = getCellRect(start, column, false);</span>
        }

        // Now adjust the height of the dirty region according to the value of &quot;end&quot;.
        // Check for Integer.MAX_VALUE as this will cause an overflow.
<span class="nc bnc" id="L4440" title="All 2 branches missed.">        if (end != Integer.MAX_VALUE) {</span>
<span class="nc" id="L4441">            dirtyRegion.height = (end-start+1)*getRowHeight();</span>
<span class="nc" id="L4442">            repaint(dirtyRegion.x, dirtyRegion.y, dirtyRegion.width, dirtyRegion.height);</span>
        }
        // In fact, if the end is Integer.MAX_VALUE we need to revalidate anyway
        // because the scrollbar may need repainting.
        else {
<span class="nc" id="L4447">            clearSelectionAndLeadAnchor();</span>
<span class="nc" id="L4448">            resizeAndRepaint();</span>
<span class="nc" id="L4449">            rowModel = null;</span>
        }
<span class="nc" id="L4451">    }</span>

    /*
     * Invoked when rows have been inserted into the table.
     * &lt;p&gt;
     * Application code will not use these methods explicitly, they
     * are used internally by JTable.
     *
     * @param e the TableModelEvent encapsulating the insertion
     */
    private void tableRowsInserted(TableModelEvent e) {
<span class="nc" id="L4462">        int start = e.getFirstRow();</span>
<span class="nc" id="L4463">        int end = e.getLastRow();</span>
<span class="nc bnc" id="L4464" title="All 2 branches missed.">        if (start &lt; 0) {</span>
<span class="nc" id="L4465">            start = 0;</span>
        }
<span class="nc bnc" id="L4467" title="All 2 branches missed.">        if (end &lt; 0) {</span>
<span class="nc" id="L4468">            end = getRowCount()-1;</span>
        }

        // Adjust the selection to account for the new rows.
<span class="nc" id="L4472">        int length = end - start + 1;</span>
<span class="nc" id="L4473">        selectionModel.insertIndexInterval(start, length, true);</span>

        // If we have variable height rows, adjust the row model.
<span class="nc bnc" id="L4476" title="All 2 branches missed.">        if (rowModel != null) {</span>
<span class="nc" id="L4477">            rowModel.insertEntries(start, length, getRowHeight());</span>
        }
<span class="nc" id="L4479">        int rh = getRowHeight() ;</span>
<span class="nc" id="L4480">        Rectangle drawRect = new Rectangle(0, start * rh,</span>
<span class="nc" id="L4481">                                        getColumnModel().getTotalColumnWidth(),</span>
<span class="nc" id="L4482">                                           (getRowCount()-start) * rh);</span>

<span class="nc" id="L4484">        revalidate();</span>
        // PENDING(milne) revalidate calls repaint() if parent is a ScrollPane
        // repaint still required in the unusual case where there is no ScrollPane
<span class="nc" id="L4487">        repaint(drawRect);</span>
<span class="nc" id="L4488">    }</span>

    /*
     * Invoked when rows have been removed from the table.
     * &lt;p&gt;
     * Application code will not use these methods explicitly, they
     * are used internally by JTable.
     *
     * @param e the TableModelEvent encapsulating the deletion
     */
    private void tableRowsDeleted(TableModelEvent e) {
<span class="nc" id="L4499">        int start = e.getFirstRow();</span>
<span class="nc" id="L4500">        int end = e.getLastRow();</span>
<span class="nc bnc" id="L4501" title="All 2 branches missed.">        if (start &lt; 0) {</span>
<span class="nc" id="L4502">            start = 0;</span>
        }
<span class="nc bnc" id="L4504" title="All 2 branches missed.">        if (end &lt; 0) {</span>
<span class="nc" id="L4505">            end = getRowCount()-1;</span>
        }

<span class="nc" id="L4508">        int deletedCount = end - start + 1;</span>
<span class="nc" id="L4509">        int previousRowCount = getRowCount() + deletedCount;</span>
        // Adjust the selection to account for the new rows
<span class="nc" id="L4511">        selectionModel.removeIndexInterval(start, end);</span>

        // If we have variable height rows, adjust the row model.
<span class="nc bnc" id="L4514" title="All 2 branches missed.">        if (rowModel != null) {</span>
<span class="nc" id="L4515">            rowModel.removeEntries(start, deletedCount);</span>
        }

<span class="nc" id="L4518">        int rh = getRowHeight();</span>
<span class="nc" id="L4519">        Rectangle drawRect = new Rectangle(0, start * rh,</span>
<span class="nc" id="L4520">                                        getColumnModel().getTotalColumnWidth(),</span>
                                        (previousRowCount - start) * rh);

<span class="nc" id="L4523">        revalidate();</span>
        // PENDING(milne) revalidate calls repaint() if parent is a ScrollPane
        // repaint still required in the unusual case where there is no ScrollPane
<span class="nc" id="L4526">        repaint(drawRect);</span>
<span class="nc" id="L4527">    }</span>

//
// Implementing TableColumnModelListener interface
//

    /**
     * Invoked when a column is added to the table column model.
     * &lt;p&gt;
     * Application code will not use these methods explicitly, they
     * are used internally by JTable.
     *
     * @see TableColumnModelListener
     */
    public void columnAdded(TableColumnModelEvent e) {
        // If I'm currently editing, then I should stop editing
<span class="nc bnc" id="L4543" title="All 2 branches missed.">        if (isEditing()) {</span>
<span class="nc" id="L4544">            removeEditor();</span>
        }
<span class="nc" id="L4546">        resizeAndRepaint();</span>
<span class="nc" id="L4547">    }</span>

    /**
     * Invoked when a column is removed from the table column model.
     * &lt;p&gt;
     * Application code will not use these methods explicitly, they
     * are used internally by JTable.
     *
     * @see TableColumnModelListener
     */
    public void columnRemoved(TableColumnModelEvent e) {
        // If I'm currently editing, then I should stop editing
<span class="nc bnc" id="L4559" title="All 2 branches missed.">        if (isEditing()) {</span>
<span class="nc" id="L4560">            removeEditor();</span>
        }
<span class="nc" id="L4562">        resizeAndRepaint();</span>
<span class="nc" id="L4563">    }</span>

    /**
     * Invoked when a column is repositioned. If a cell is being
     * edited, then editing is stopped and the cell is redrawn.
     * &lt;p&gt;
     * Application code will not use these methods explicitly, they
     * are used internally by JTable.
     *
     * @param e   the event received
     * @see TableColumnModelListener
     */
    public void columnMoved(TableColumnModelEvent e) {
<span class="nc bnc" id="L4576" title="All 4 branches missed.">        if (isEditing() &amp;&amp; !getCellEditor().stopCellEditing()) {</span>
<span class="nc" id="L4577">            getCellEditor().cancelCellEditing();</span>
        }
<span class="nc" id="L4579">        repaint();</span>
<span class="nc" id="L4580">    }</span>

    /**
     * Invoked when a column is moved due to a margin change.
     * If a cell is being edited, then editing is stopped and the cell
     * is redrawn.
     * &lt;p&gt;
     * Application code will not use these methods explicitly, they
     * are used internally by JTable.
     *
     * @param  e    the event received
     * @see TableColumnModelListener
     */
    public void columnMarginChanged(ChangeEvent e) {
<span class="nc bnc" id="L4594" title="All 4 branches missed.">        if (isEditing() &amp;&amp; !getCellEditor().stopCellEditing()) {</span>
<span class="nc" id="L4595">            getCellEditor().cancelCellEditing();</span>
        }
<span class="nc" id="L4597">        TableColumn resizingColumn = getResizingColumn();</span>
        // Need to do this here, before the parent's
        // layout manager calls getPreferredSize().
<span class="nc bnc" id="L4600" title="All 4 branches missed.">        if (resizingColumn != null &amp;&amp; autoResizeMode == AUTO_RESIZE_OFF) {</span>
<span class="nc" id="L4601">            resizingColumn.setPreferredWidth(resizingColumn.getWidth());</span>
        }
<span class="nc" id="L4603">        resizeAndRepaint();</span>
<span class="nc" id="L4604">    }</span>

    private int limit(int i, int a, int b) {
<span class="nc" id="L4607">        return Math.min(b, Math.max(i, a));</span>
    }

    /**
     * Invoked when the selection model of the &lt;code&gt;TableColumnModel&lt;/code&gt;
     * is changed.
     * &lt;p&gt;
     * Application code will not use these methods explicitly, they
     * are used internally by JTable.
     *
     * @param  e  the event received
     * @see TableColumnModelListener
     */
    public void columnSelectionChanged(ListSelectionEvent e) {
<span class="nc" id="L4621">        boolean isAdjusting = e.getValueIsAdjusting();</span>
<span class="nc bnc" id="L4622" title="All 4 branches missed.">        if (columnSelectionAdjusting &amp;&amp; !isAdjusting) {</span>
            // The assumption is that when the model is no longer adjusting
            // we will have already gotten all the changes, and therefore
            // don't need to do an additional paint.
<span class="nc" id="L4626">            columnSelectionAdjusting = false;</span>
<span class="nc" id="L4627">            return;</span>
        }
<span class="nc" id="L4629">        columnSelectionAdjusting = isAdjusting;</span>
        // The getCellRect() call will fail unless there is at least one row.
<span class="nc bnc" id="L4631" title="All 4 branches missed.">        if (getRowCount() &lt;= 0 || getColumnCount() &lt;= 0) {</span>
<span class="nc" id="L4632">            return;</span>
        }
<span class="nc" id="L4634">        int firstIndex = limit(e.getFirstIndex(), 0, getColumnCount()-1);</span>
<span class="nc" id="L4635">        int lastIndex = limit(e.getLastIndex(), 0, getColumnCount()-1);</span>
<span class="nc" id="L4636">        int minRow = 0;</span>
<span class="nc" id="L4637">        int maxRow = getRowCount() - 1;</span>
<span class="nc bnc" id="L4638" title="All 2 branches missed.">        if (getRowSelectionAllowed()) {</span>
<span class="nc" id="L4639">            minRow = selectionModel.getMinSelectionIndex();</span>
<span class="nc" id="L4640">            maxRow = selectionModel.getMaxSelectionIndex();</span>
<span class="nc" id="L4641">            int leadRow = getAdjustedIndex(selectionModel.getLeadSelectionIndex(), true);</span>

<span class="nc bnc" id="L4643" title="All 4 branches missed.">            if (minRow == -1 || maxRow == -1) {</span>
<span class="nc bnc" id="L4644" title="All 2 branches missed.">                if (leadRow == -1) {</span>
                    // nothing to repaint, return
<span class="nc" id="L4646">                    return;</span>
                }

                // only thing to repaint is the lead
<span class="nc" id="L4650">                minRow = maxRow = leadRow;</span>
            } else {
                // We need to consider more than just the range between
                // the min and max selected index. The lead row, which could
                // be outside this range, should be considered also.
<span class="nc bnc" id="L4655" title="All 2 branches missed.">                if (leadRow != -1) {</span>
<span class="nc" id="L4656">                    minRow = Math.min(minRow, leadRow);</span>
<span class="nc" id="L4657">                    maxRow = Math.max(maxRow, leadRow);</span>
                }
            }
        }
<span class="nc" id="L4661">        Rectangle firstColumnRect = getCellRect(minRow, firstIndex, false);</span>
<span class="nc" id="L4662">        Rectangle lastColumnRect = getCellRect(maxRow, lastIndex, false);</span>
<span class="nc" id="L4663">        Rectangle dirtyRegion = firstColumnRect.union(lastColumnRect);</span>
<span class="nc" id="L4664">        repaint(dirtyRegion);</span>
<span class="nc" id="L4665">    }</span>

//
// Implementing ListSelectionListener interface
//

    /**
     * Invoked when the row selection changes -- repaints to show the new
     * selection.
     * &lt;p&gt;
     * Application code will not use these methods explicitly, they
     * are used internally by JTable.
     *
     * @param e   the event received
     * @see ListSelectionListener
     */
    public void valueChanged(ListSelectionEvent e) {
<span class="nc bnc" id="L4682" title="All 2 branches missed.">        if (sortManager != null) {</span>
<span class="nc" id="L4683">            sortManager.viewSelectionChanged(e);</span>
        }
<span class="nc" id="L4685">        boolean isAdjusting = e.getValueIsAdjusting();</span>
<span class="nc bnc" id="L4686" title="All 4 branches missed.">        if (rowSelectionAdjusting &amp;&amp; !isAdjusting) {</span>
            // The assumption is that when the model is no longer adjusting
            // we will have already gotten all the changes, and therefore
            // don't need to do an additional paint.
<span class="nc" id="L4690">            rowSelectionAdjusting = false;</span>
<span class="nc" id="L4691">            return;</span>
        }
<span class="nc" id="L4693">        rowSelectionAdjusting = isAdjusting;</span>
        // The getCellRect() calls will fail unless there is at least one column.
<span class="nc bnc" id="L4695" title="All 4 branches missed.">        if (getRowCount() &lt;= 0 || getColumnCount() &lt;= 0) {</span>
<span class="nc" id="L4696">            return;</span>
        }
<span class="nc" id="L4698">        int firstIndex = limit(e.getFirstIndex(), 0, getRowCount()-1);</span>
<span class="nc" id="L4699">        int lastIndex = limit(e.getLastIndex(), 0, getRowCount()-1);</span>
<span class="nc" id="L4700">        Rectangle firstRowRect = getCellRect(firstIndex, 0, false);</span>
<span class="nc" id="L4701">        Rectangle lastRowRect = getCellRect(lastIndex, getColumnCount()-1, false);</span>
<span class="nc" id="L4702">        Rectangle dirtyRegion = firstRowRect.union(lastRowRect);</span>
<span class="nc" id="L4703">        repaint(dirtyRegion);</span>
<span class="nc" id="L4704">    }</span>

//
// Implementing the CellEditorListener interface
//

    /**
     * Invoked when editing is finished. The changes are saved and the
     * editor is discarded.
     * &lt;p&gt;
     * Application code will not use these methods explicitly, they
     * are used internally by JTable.
     *
     * @param  e  the event received
     * @see CellEditorListener
     */
    public void editingStopped(ChangeEvent e) {
        // Take in the new value
<span class="nc" id="L4722">        TableCellEditor editor = getCellEditor();</span>
<span class="nc bnc" id="L4723" title="All 2 branches missed.">        if (editor != null) {</span>
<span class="nc" id="L4724">            Object value = editor.getCellEditorValue();</span>
<span class="nc" id="L4725">            setValueAt(value, editingRow, editingColumn);</span>
<span class="nc" id="L4726">            removeEditor();</span>
        }
<span class="nc" id="L4728">    }</span>

    /**
     * Invoked when editing is canceled. The editor object is discarded
     * and the cell is rendered once again.
     * &lt;p&gt;
     * Application code will not use these methods explicitly, they
     * are used internally by JTable.
     *
     * @param  e  the event received
     * @see CellEditorListener
     */
    public void editingCanceled(ChangeEvent e) {
<span class="nc" id="L4741">        removeEditor();</span>
<span class="nc" id="L4742">    }</span>

//
// Implementing the Scrollable interface
//

    /**
     * Sets the preferred size of the viewport for this table.
     *
     * @param size  a &lt;code&gt;Dimension&lt;/code&gt; object specifying the &lt;code&gt;preferredSize&lt;/code&gt; of a
     *              &lt;code&gt;JViewport&lt;/code&gt; whose view is this table
     * @see Scrollable#getPreferredScrollableViewportSize
     * @beaninfo
     * description: The preferred size of the viewport.
     */
    public void setPreferredScrollableViewportSize(Dimension size) {
<span class="nc" id="L4758">        preferredViewportSize = size;</span>
<span class="nc" id="L4759">    }</span>

    /**
     * Returns the preferred size of the viewport for this table.
     *
     * @return a &lt;code&gt;Dimension&lt;/code&gt; object containing the &lt;code&gt;preferredSize&lt;/code&gt; of the &lt;code&gt;JViewport&lt;/code&gt;
     *         which displays this table
     * @see Scrollable#getPreferredScrollableViewportSize
     */
    public Dimension getPreferredScrollableViewportSize() {
<span class="nc" id="L4769">        return preferredViewportSize;</span>
    }

    /**
     * Returns the scroll increment (in pixels) that completely exposes one new
     * row or column (depending on the orientation).
     * &lt;p&gt;
     * This method is called each time the user requests a unit scroll.
     *
     * @param visibleRect the view area visible within the viewport
     * @param orientation either &lt;code&gt;SwingConstants.VERTICAL&lt;/code&gt;
     *                  or &lt;code&gt;SwingConstants.HORIZONTAL&lt;/code&gt;
     * @param direction less than zero to scroll up/left,
     *                  greater than zero for down/right
     * @return the &quot;unit&quot; increment for scrolling in the specified direction
     * @see Scrollable#getScrollableUnitIncrement
     */
    public int getScrollableUnitIncrement(Rectangle visibleRect,
                                          int orientation,
                                          int direction) {
        int leadingRow;
        int leadingCol;
        Rectangle leadingCellRect;

        int leadingVisibleEdge;
        int leadingCellEdge;
        int leadingCellSize;

<span class="nc" id="L4797">        leadingRow = getLeadingRow(visibleRect);</span>
<span class="nc" id="L4798">        leadingCol = getLeadingCol(visibleRect);</span>
<span class="nc bnc" id="L4799" title="All 4 branches missed.">        if (orientation == SwingConstants.VERTICAL &amp;&amp; leadingRow &lt; 0) {</span>
            // Couldn't find leading row - return some default value
<span class="nc" id="L4801">            return getRowHeight();</span>
        }
<span class="nc bnc" id="L4803" title="All 4 branches missed.">        else if (orientation == SwingConstants.HORIZONTAL &amp;&amp; leadingCol &lt; 0) {</span>
            // Couldn't find leading col - return some default value
<span class="nc" id="L4805">            return 100;</span>
        }

        // Note that it's possible for one of leadingCol or leadingRow to be
        // -1, depending on the orientation.  This is okay, as getCellRect()
        // still provides enough information to calculate the unit increment.
<span class="nc" id="L4811">        leadingCellRect = getCellRect(leadingRow, leadingCol, true);</span>
<span class="nc" id="L4812">        leadingVisibleEdge = leadingEdge(visibleRect, orientation);</span>
<span class="nc" id="L4813">        leadingCellEdge = leadingEdge(leadingCellRect, orientation);</span>

<span class="nc bnc" id="L4815" title="All 2 branches missed.">        if (orientation == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L4816">            leadingCellSize = leadingCellRect.height;</span>

        }
        else {
<span class="nc" id="L4820">            leadingCellSize = leadingCellRect.width;</span>
        }

        // 4 cases:
        // #1: Leading cell fully visible, reveal next cell
        // #2: Leading cell fully visible, hide leading cell
        // #3: Leading cell partially visible, hide rest of leading cell
        // #4: Leading cell partially visible, reveal rest of leading cell

<span class="nc bnc" id="L4829" title="All 2 branches missed.">        if (leadingVisibleEdge == leadingCellEdge) { // Leading cell is fully</span>
                                                     // visible
            // Case #1: Reveal previous cell
<span class="nc bnc" id="L4832" title="All 2 branches missed.">            if (direction &lt; 0) {</span>
<span class="nc" id="L4833">                int retVal = 0;</span>

<span class="nc bnc" id="L4835" title="All 2 branches missed.">                if (orientation == SwingConstants.VERTICAL) {</span>
                    // Loop past any zero-height rows
<span class="nc bnc" id="L4837" title="All 2 branches missed.">                    while (--leadingRow &gt;= 0) {</span>
<span class="nc" id="L4838">                        retVal = getRowHeight(leadingRow);</span>
<span class="nc bnc" id="L4839" title="All 2 branches missed.">                        if (retVal != 0) {</span>
<span class="nc" id="L4840">                            break;</span>
                        }
                    }
                }
                else { // HORIZONTAL
                    // Loop past any zero-width cols
<span class="nc bnc" id="L4846" title="All 2 branches missed.">                    while (--leadingCol &gt;= 0) {</span>
<span class="nc" id="L4847">                        retVal = getCellRect(leadingRow, leadingCol, true).width;</span>
<span class="nc bnc" id="L4848" title="All 2 branches missed.">                        if (retVal != 0) {</span>
<span class="nc" id="L4849">                            break;</span>
                        }
                    }
                }
<span class="nc" id="L4853">                return retVal;</span>
            }
            else { // Case #2: hide leading cell
<span class="nc" id="L4856">                return leadingCellSize;</span>
            }
        }
        else { // Leading cell is partially hidden
            // Compute visible, hidden portions
<span class="nc" id="L4861">            int hiddenAmt = Math.abs(leadingVisibleEdge - leadingCellEdge);</span>
<span class="nc" id="L4862">            int visibleAmt = leadingCellSize - hiddenAmt;</span>

<span class="nc bnc" id="L4864" title="All 2 branches missed.">            if (direction &gt; 0) {</span>
                // Case #3: hide showing portion of leading cell
<span class="nc" id="L4866">                return visibleAmt;</span>
            }
            else { // Case #4: reveal hidden portion of leading cell
<span class="nc" id="L4869">                return hiddenAmt;</span>
            }
        }
    }

    /**
     * Returns &lt;code&gt;visibleRect.height&lt;/code&gt; or
     * &lt;code&gt;visibleRect.width&lt;/code&gt;,
     * depending on this table's orientation.  Note that as of Swing 1.1.1
     * (Java 2 v 1.2.2) the value
     * returned will ensure that the viewport is cleanly aligned on
     * a row boundary.
     *
     * @return &lt;code&gt;visibleRect.height&lt;/code&gt; or
     *                                  &lt;code&gt;visibleRect.width&lt;/code&gt;
     *                                  per the orientation
     * @see Scrollable#getScrollableBlockIncrement
     */
    public int getScrollableBlockIncrement(Rectangle visibleRect,
            int orientation, int direction) {

<span class="nc bnc" id="L4890" title="All 2 branches missed.">        if (getRowCount() == 0) {</span>
            // Short-circuit empty table model
<span class="nc bnc" id="L4892" title="All 2 branches missed.">            if (SwingConstants.VERTICAL == orientation) {</span>
<span class="nc" id="L4893">                int rh = getRowHeight();</span>
<span class="nc bnc" id="L4894" title="All 2 branches missed.">                return (rh &gt; 0) ? Math.max(rh, (visibleRect.height / rh) * rh) :</span>
                                  visibleRect.height;
            }
            else {
<span class="nc" id="L4898">                return visibleRect.width;</span>
            }
        }
        // Shortcut for vertical scrolling of a table w/ uniform row height
<span class="nc bnc" id="L4902" title="All 4 branches missed.">        if (null == rowModel &amp;&amp; SwingConstants.VERTICAL == orientation) {</span>
<span class="nc" id="L4903">            int row = rowAtPoint(visibleRect.getLocation());</span>
<span class="nc bnc" id="L4904" title="All 4 branches missed.">            assert row != -1;</span>
<span class="nc" id="L4905">            int col = columnAtPoint(visibleRect.getLocation());</span>
<span class="nc" id="L4906">            Rectangle cellRect = getCellRect(row, col, true);</span>

<span class="nc bnc" id="L4908" title="All 2 branches missed.">            if (cellRect.y == visibleRect.y) {</span>
<span class="nc" id="L4909">                int rh = getRowHeight();</span>
<span class="nc bnc" id="L4910" title="All 4 branches missed.">                assert rh &gt; 0;</span>
<span class="nc" id="L4911">                return Math.max(rh, (visibleRect.height / rh) * rh);</span>
            }
        }
<span class="nc bnc" id="L4914" title="All 2 branches missed.">        if (direction &lt; 0) {</span>
<span class="nc" id="L4915">            return getPreviousBlockIncrement(visibleRect, orientation);</span>
        }
        else {
<span class="nc" id="L4918">            return getNextBlockIncrement(visibleRect, orientation);</span>
        }
    }

    /**
     * Called to get the block increment for upward scrolling in cases of
     * horizontal scrolling, or for vertical scrolling of a table with
     * variable row heights.
     */
    private int getPreviousBlockIncrement(Rectangle visibleRect,
                                          int orientation) {
        // Measure back from visible leading edge
        // If we hit the cell on its leading edge, it becomes the leading cell.
        // Else, use following cell

        int row;
        int col;

        int   newEdge;
        Point newCellLoc;

<span class="nc" id="L4939">        int visibleLeadingEdge = leadingEdge(visibleRect, orientation);</span>
<span class="nc" id="L4940">        boolean leftToRight = getComponentOrientation().isLeftToRight();</span>
        int newLeadingEdge;

        // Roughly determine the new leading edge by measuring back from the
        // leading visible edge by the size of the visible rect, and find the
        // cell there.
<span class="nc bnc" id="L4946" title="All 2 branches missed.">        if (orientation == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L4947">            newEdge = visibleLeadingEdge - visibleRect.height;</span>
<span class="nc bnc" id="L4948" title="All 2 branches missed.">            int x = visibleRect.x + (leftToRight ? 0 : visibleRect.width);</span>
<span class="nc" id="L4949">            newCellLoc = new Point(x, newEdge);</span>
<span class="nc" id="L4950">        }</span>
<span class="nc bnc" id="L4951" title="All 2 branches missed.">        else if (leftToRight) {</span>
<span class="nc" id="L4952">            newEdge = visibleLeadingEdge - visibleRect.width;</span>
<span class="nc" id="L4953">            newCellLoc = new Point(newEdge, visibleRect.y);</span>
        }
        else { // Horizontal, right-to-left
<span class="nc" id="L4956">            newEdge = visibleLeadingEdge + visibleRect.width;</span>
<span class="nc" id="L4957">            newCellLoc = new Point(newEdge - 1, visibleRect.y);</span>
        }
<span class="nc" id="L4959">        row = rowAtPoint(newCellLoc);</span>
<span class="nc" id="L4960">        col = columnAtPoint(newCellLoc);</span>

        // If we're measuring past the beginning of the table, we get an invalid
        // cell.  Just go to the beginning of the table in this case.
<span class="nc bnc" id="L4964" title="All 6 branches missed.">        if (orientation == SwingConstants.VERTICAL &amp; row &lt; 0) {</span>
<span class="nc" id="L4965">            newLeadingEdge = 0;</span>
        }
<span class="nc bnc" id="L4967" title="All 6 branches missed.">        else if (orientation == SwingConstants.HORIZONTAL &amp; col &lt; 0) {</span>
<span class="nc bnc" id="L4968" title="All 2 branches missed.">            if (leftToRight) {</span>
<span class="nc" id="L4969">                newLeadingEdge = 0;</span>
            }
            else {
<span class="nc" id="L4972">                newLeadingEdge = getWidth();</span>
            }
        }
        else {
            // Refine our measurement
<span class="nc" id="L4977">            Rectangle newCellRect = getCellRect(row, col, true);</span>
<span class="nc" id="L4978">            int newCellLeadingEdge = leadingEdge(newCellRect, orientation);</span>
<span class="nc" id="L4979">            int newCellTrailingEdge = trailingEdge(newCellRect, orientation);</span>

            // Usually, we hit in the middle of newCell, and want to scroll to
            // the beginning of the cell after newCell.  But there are a
            // couple corner cases where we want to scroll to the beginning of
            // newCell itself.  These cases are:
            // 1) newCell is so large that it ends at or extends into the
            //    visibleRect (newCell is the leading cell, or is adjacent to
            //    the leading cell)
            // 2) newEdge happens to fall right on the beginning of a cell

            // Case 1
<span class="nc bnc" id="L4991" title="All 6 branches missed.">            if ((orientation == SwingConstants.VERTICAL || leftToRight) &amp;&amp;</span>
                (newCellTrailingEdge &gt;= visibleLeadingEdge)) {
<span class="nc" id="L4993">                newLeadingEdge = newCellLeadingEdge;</span>
            }
<span class="nc bnc" id="L4995" title="All 6 branches missed.">            else if (orientation == SwingConstants.HORIZONTAL &amp;&amp;</span>
                     !leftToRight &amp;&amp;
                     newCellTrailingEdge &lt;= visibleLeadingEdge) {
<span class="nc" id="L4998">                newLeadingEdge = newCellLeadingEdge;</span>
            }
            // Case 2:
<span class="nc bnc" id="L5001" title="All 2 branches missed.">            else if (newEdge == newCellLeadingEdge) {</span>
<span class="nc" id="L5002">                newLeadingEdge = newCellLeadingEdge;</span>
            }
            // Common case: scroll to cell after newCell
            else {
<span class="nc" id="L5006">                newLeadingEdge = newCellTrailingEdge;</span>
            }
        }
<span class="nc" id="L5009">        return Math.abs(visibleLeadingEdge - newLeadingEdge);</span>
    }

    /**
     * Called to get the block increment for downward scrolling in cases of
     * horizontal scrolling, or for vertical scrolling of a table with
     * variable row heights.
     */
    private int getNextBlockIncrement(Rectangle visibleRect,
                                      int orientation) {
        // Find the cell at the trailing edge.  Return the distance to put
        // that cell at the leading edge.
<span class="nc" id="L5021">        int trailingRow = getTrailingRow(visibleRect);</span>
<span class="nc" id="L5022">        int trailingCol = getTrailingCol(visibleRect);</span>

        Rectangle cellRect;
        boolean cellFillsVis;

        int cellLeadingEdge;
        int cellTrailingEdge;
        int newLeadingEdge;
<span class="nc" id="L5030">        int visibleLeadingEdge = leadingEdge(visibleRect, orientation);</span>

        // If we couldn't find trailing cell, just return the size of the
        // visibleRect.  Note that, for instance, we don't need the
        // trailingCol to proceed if we're scrolling vertically, because
        // cellRect will still fill in the required dimensions.  This would
        // happen if we're scrolling vertically, and the table is not wide
        // enough to fill the visibleRect.
<span class="nc bnc" id="L5038" title="All 4 branches missed.">        if (orientation == SwingConstants.VERTICAL &amp;&amp; trailingRow &lt; 0) {</span>
<span class="nc" id="L5039">            return visibleRect.height;</span>
        }
<span class="nc bnc" id="L5041" title="All 4 branches missed.">        else if (orientation == SwingConstants.HORIZONTAL &amp;&amp; trailingCol &lt; 0) {</span>
<span class="nc" id="L5042">            return visibleRect.width;</span>
        }
<span class="nc" id="L5044">        cellRect = getCellRect(trailingRow, trailingCol, true);</span>
<span class="nc" id="L5045">        cellLeadingEdge = leadingEdge(cellRect, orientation);</span>
<span class="nc" id="L5046">        cellTrailingEdge = trailingEdge(cellRect, orientation);</span>

<span class="nc bnc" id="L5048" title="All 2 branches missed.">        if (orientation == SwingConstants.VERTICAL ||</span>
<span class="nc bnc" id="L5049" title="All 2 branches missed.">            getComponentOrientation().isLeftToRight()) {</span>
<span class="nc bnc" id="L5050" title="All 2 branches missed.">            cellFillsVis = cellLeadingEdge &lt;= visibleLeadingEdge;</span>
        }
        else { // Horizontal, right-to-left
<span class="nc bnc" id="L5053" title="All 2 branches missed.">            cellFillsVis = cellLeadingEdge &gt;= visibleLeadingEdge;</span>
        }

<span class="nc bnc" id="L5056" title="All 2 branches missed.">        if (cellFillsVis) {</span>
            // The visibleRect contains a single large cell.  Scroll to the end
            // of this cell, so the following cell is the first cell.
<span class="nc" id="L5059">            newLeadingEdge = cellTrailingEdge;</span>
        }
<span class="nc bnc" id="L5061" title="All 2 branches missed.">        else if (cellTrailingEdge == trailingEdge(visibleRect, orientation)) {</span>
            // The trailing cell happens to end right at the end of the
            // visibleRect.  Again, scroll to the beginning of the next cell.
<span class="nc" id="L5064">            newLeadingEdge = cellTrailingEdge;</span>
        }
        else {
            // Common case: the trailing cell is partially visible, and isn't
            // big enough to take up the entire visibleRect.  Scroll so it
            // becomes the leading cell.
<span class="nc" id="L5070">            newLeadingEdge = cellLeadingEdge;</span>
        }
<span class="nc" id="L5072">        return Math.abs(newLeadingEdge - visibleLeadingEdge);</span>
    }

    /*
     * Return the row at the top of the visibleRect
     *
     * May return -1
     */
    private int getLeadingRow(Rectangle visibleRect) {
        Point leadingPoint;

<span class="nc bnc" id="L5083" title="All 2 branches missed.">        if (getComponentOrientation().isLeftToRight()) {</span>
<span class="nc" id="L5084">            leadingPoint = new Point(visibleRect.x, visibleRect.y);</span>
        }
        else {
<span class="nc" id="L5087">            leadingPoint = new Point(visibleRect.x + visibleRect.width - 1,</span>
                                     visibleRect.y);
        }
<span class="nc" id="L5090">        return rowAtPoint(leadingPoint);</span>
    }

    /*
     * Return the column at the leading edge of the visibleRect.
     *
     * May return -1
     */
    private int getLeadingCol(Rectangle visibleRect) {
        Point leadingPoint;

<span class="nc bnc" id="L5101" title="All 2 branches missed.">        if (getComponentOrientation().isLeftToRight()) {</span>
<span class="nc" id="L5102">            leadingPoint = new Point(visibleRect.x, visibleRect.y);</span>
        }
        else {
<span class="nc" id="L5105">            leadingPoint = new Point(visibleRect.x + visibleRect.width - 1,</span>
                                     visibleRect.y);
        }
<span class="nc" id="L5108">        return columnAtPoint(leadingPoint);</span>
    }

    /*
     * Return the row at the bottom of the visibleRect.
     *
     * May return -1
     */
    private int getTrailingRow(Rectangle visibleRect) {
        Point trailingPoint;

<span class="nc bnc" id="L5119" title="All 2 branches missed.">        if (getComponentOrientation().isLeftToRight()) {</span>
<span class="nc" id="L5120">            trailingPoint = new Point(visibleRect.x,</span>
                                      visibleRect.y + visibleRect.height - 1);
        }
        else {
<span class="nc" id="L5124">            trailingPoint = new Point(visibleRect.x + visibleRect.width - 1,</span>
                                      visibleRect.y + visibleRect.height - 1);
        }
<span class="nc" id="L5127">        return rowAtPoint(trailingPoint);</span>
    }

    /*
     * Return the column at the trailing edge of the visibleRect.
     *
     * May return -1
     */
    private int getTrailingCol(Rectangle visibleRect) {
        Point trailingPoint;

<span class="nc bnc" id="L5138" title="All 2 branches missed.">        if (getComponentOrientation().isLeftToRight()) {</span>
<span class="nc" id="L5139">            trailingPoint = new Point(visibleRect.x + visibleRect.width - 1,</span>
                                      visibleRect.y);
        }
        else {
<span class="nc" id="L5143">            trailingPoint = new Point(visibleRect.x, visibleRect.y);</span>
        }
<span class="nc" id="L5145">        return columnAtPoint(trailingPoint);</span>
    }

    /*
     * Returns the leading edge (&quot;beginning&quot;) of the given Rectangle.
     * For VERTICAL, this is the top, for left-to-right, the left side, and for
     * right-to-left, the right side.
     */
    private int leadingEdge(Rectangle rect, int orientation) {
<span class="nc bnc" id="L5154" title="All 2 branches missed.">        if (orientation == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L5155">            return rect.y;</span>
        }
<span class="nc bnc" id="L5157" title="All 2 branches missed.">        else if (getComponentOrientation().isLeftToRight()) {</span>
<span class="nc" id="L5158">            return rect.x;</span>
        }
        else { // Horizontal, right-to-left
<span class="nc" id="L5161">            return rect.x + rect.width;</span>
        }
    }

    /*
     * Returns the trailing edge (&quot;end&quot;) of the given Rectangle.
     * For VERTICAL, this is the bottom, for left-to-right, the right side, and
     * for right-to-left, the left side.
     */
    private int trailingEdge(Rectangle rect, int orientation) {
<span class="nc bnc" id="L5171" title="All 2 branches missed.">        if (orientation == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L5172">            return rect.y + rect.height;</span>
        }
<span class="nc bnc" id="L5174" title="All 2 branches missed.">        else if (getComponentOrientation().isLeftToRight()) {</span>
<span class="nc" id="L5175">            return rect.x + rect.width;</span>
        }
        else { // Horizontal, right-to-left
<span class="nc" id="L5178">            return rect.x;</span>
        }
    }

    /**
     * Returns false if &lt;code&gt;autoResizeMode&lt;/code&gt; is set to
     * &lt;code&gt;AUTO_RESIZE_OFF&lt;/code&gt;, which indicates that the
     * width of the viewport does not determine the width
     * of the table.  Otherwise returns true.
     *
     * @return false if &lt;code&gt;autoResizeMode&lt;/code&gt; is set
     *   to &lt;code&gt;AUTO_RESIZE_OFF&lt;/code&gt;, otherwise returns true
     * @see Scrollable#getScrollableTracksViewportWidth
     */
    public boolean getScrollableTracksViewportWidth() {
<span class="nc bnc" id="L5193" title="All 2 branches missed.">        return !(autoResizeMode == AUTO_RESIZE_OFF);</span>
    }

    /**
     * Returns {@code false} to indicate that the height of the viewport does
     * not determine the height of the table, unless
     * {@code getFillsViewportHeight} is {@code true} and the preferred height
     * of the table is smaller than the viewport's height.
     *
     * @return {@code false} unless {@code getFillsViewportHeight} is
     *         {@code true} and the table needs to be stretched to fill
     *         the viewport
     * @see Scrollable#getScrollableTracksViewportHeight
     * @see #setFillsViewportHeight
     * @see #getFillsViewportHeight
     */
    public boolean getScrollableTracksViewportHeight() {
<span class="nc" id="L5210">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L5211" title="All 4 branches missed.">        return getFillsViewportHeight()</span>
               &amp;&amp; parent instanceof JViewport
<span class="nc bnc" id="L5213" title="All 2 branches missed.">               &amp;&amp; parent.getHeight() &gt; getPreferredSize().height;</span>
    }

    /**
     * Sets whether or not this table is always made large enough
     * to fill the height of an enclosing viewport. If the preferred
     * height of the table is smaller than the viewport, then the table
     * will be stretched to fill the viewport. In other words, this
     * ensures the table is never smaller than the viewport.
     * The default for this property is {@code false}.
     *
     * @param fillsViewportHeight whether or not this table is always
     *        made large enough to fill the height of an enclosing
     *        viewport
     * @see #getFillsViewportHeight
     * @see #getScrollableTracksViewportHeight
     * @since 1.6
     * @beaninfo
     *      bound: true
     *      description: Whether or not this table is always made large enough
     *                   to fill the height of an enclosing viewport
     */
    public void setFillsViewportHeight(boolean fillsViewportHeight) {
<span class="nc" id="L5236">        boolean old = this.fillsViewportHeight;</span>
<span class="nc" id="L5237">        this.fillsViewportHeight = fillsViewportHeight;</span>
<span class="nc" id="L5238">        resizeAndRepaint();</span>
<span class="nc" id="L5239">        firePropertyChange(&quot;fillsViewportHeight&quot;, old, fillsViewportHeight);</span>
<span class="nc" id="L5240">    }</span>

    /**
     * Returns whether or not this table is always made large enough
     * to fill the height of an enclosing viewport.
     *
     * @return whether or not this table is always made large enough
     *         to fill the height of an enclosing viewport
     * @see #setFillsViewportHeight
     * @since 1.6
     */
    public boolean getFillsViewportHeight() {
<span class="nc" id="L5252">        return fillsViewportHeight;</span>
    }

//
// Protected Methods
//

    protected boolean processKeyBinding(KeyStroke ks, KeyEvent e,
                                        int condition, boolean pressed) {
<span class="nc" id="L5261">        boolean retValue = super.processKeyBinding(ks, e, condition, pressed);</span>

        // Start editing when a key is typed. UI classes can disable this behavior
        // by setting the client property JTable.autoStartsEdit to Boolean.FALSE.
<span class="nc bnc" id="L5265" title="All 4 branches missed.">        if (!retValue &amp;&amp; condition == WHEN_ANCESTOR_OF_FOCUSED_COMPONENT &amp;&amp;</span>
<span class="nc bnc" id="L5266" title="All 2 branches missed.">            isFocusOwner() &amp;&amp;</span>
<span class="nc bnc" id="L5267" title="All 2 branches missed.">            !Boolean.FALSE.equals(getClientProperty(&quot;JTable.autoStartsEdit&quot;))) {</span>
            // We do not have a binding for the event.
<span class="nc" id="L5269">            Component editorComponent = getEditorComponent();</span>
<span class="nc bnc" id="L5270" title="All 2 branches missed.">            if (editorComponent == null) {</span>
                // Only attempt to install the editor on a KEY_PRESSED,
<span class="nc bnc" id="L5272" title="All 4 branches missed.">                if (e == null || e.getID() != KeyEvent.KEY_PRESSED) {</span>
<span class="nc" id="L5273">                    return false;</span>
                }
                // Don't start when just a modifier is pressed
<span class="nc" id="L5276">                int code = e.getKeyCode();</span>
<span class="nc bnc" id="L5277" title="All 6 branches missed.">                if (code == KeyEvent.VK_SHIFT || code == KeyEvent.VK_CONTROL ||</span>
                    code == KeyEvent.VK_ALT) {
<span class="nc" id="L5279">                    return false;</span>
                }
                // Try to install the editor
<span class="nc" id="L5282">                int leadRow = getSelectionModel().getLeadSelectionIndex();</span>
<span class="nc" id="L5283">                int leadColumn = getColumnModel().getSelectionModel().</span>
<span class="nc" id="L5284">                                   getLeadSelectionIndex();</span>
<span class="nc bnc" id="L5285" title="All 6 branches missed.">                if (leadRow != -1 &amp;&amp; leadColumn != -1 &amp;&amp; !isEditing()) {</span>
<span class="nc bnc" id="L5286" title="All 2 branches missed.">                    if (!editCellAt(leadRow, leadColumn, e)) {</span>
<span class="nc" id="L5287">                        return false;</span>
                    }
                }
<span class="nc" id="L5290">                editorComponent = getEditorComponent();</span>
<span class="nc bnc" id="L5291" title="All 2 branches missed.">                if (editorComponent == null) {</span>
<span class="nc" id="L5292">                    return false;</span>
                }
            }
            // If the editorComponent is a JComponent, pass the event to it.
<span class="nc bnc" id="L5296" title="All 2 branches missed.">            if (editorComponent instanceof JComponent) {</span>
<span class="nc" id="L5297">                retValue = ((JComponent)editorComponent).processKeyBinding</span>
<span class="nc" id="L5298">                                        (ks, e, WHEN_FOCUSED, pressed);</span>
                // If we have started an editor as a result of the user
                // pressing a key and the surrendersFocusOnKeystroke property
                // is true, give the focus to the new editor.
<span class="nc bnc" id="L5302" title="All 2 branches missed.">                if (getSurrendersFocusOnKeystroke()) {</span>
<span class="nc" id="L5303">                    editorComponent.requestFocus();</span>
                }
            }
        }
<span class="nc" id="L5307">        return retValue;</span>
    }

    private void setLazyValue(Hashtable h, Class c, String s) {
<span class="nc" id="L5311">        h.put(c, new SwingLazyValue(s));</span>
<span class="nc" id="L5312">    }</span>

    private void setLazyRenderer(Class c, String s) {
<span class="nc" id="L5315">        setLazyValue(defaultRenderersByColumnClass, c, s);</span>
<span class="nc" id="L5316">    }</span>

    /**
     * Creates default cell renderers for objects, numbers, doubles, dates,
     * booleans, and icons.
     * @see javax.swing.table.DefaultTableCellRenderer
     *
     */
    protected void createDefaultRenderers() {
<span class="nc" id="L5325">        defaultRenderersByColumnClass = new UIDefaults(8, 0.75f);</span>

        // Objects
<span class="nc" id="L5328">        setLazyRenderer(Object.class, &quot;javax.swing.table.DefaultTableCellRenderer$UIResource&quot;);</span>

        // Numbers
<span class="nc" id="L5331">        setLazyRenderer(Number.class, &quot;javax.swing.JTable$NumberRenderer&quot;);</span>

        // Doubles and Floats
<span class="nc" id="L5334">        setLazyRenderer(Float.class, &quot;javax.swing.JTable$DoubleRenderer&quot;);</span>
<span class="nc" id="L5335">        setLazyRenderer(Double.class, &quot;javax.swing.JTable$DoubleRenderer&quot;);</span>

        // Dates
<span class="nc" id="L5338">        setLazyRenderer(Date.class, &quot;javax.swing.JTable$DateRenderer&quot;);</span>

        // Icons and ImageIcons
<span class="nc" id="L5341">        setLazyRenderer(Icon.class, &quot;javax.swing.JTable$IconRenderer&quot;);</span>
<span class="nc" id="L5342">        setLazyRenderer(ImageIcon.class, &quot;javax.swing.JTable$IconRenderer&quot;);</span>

        // Booleans
<span class="nc" id="L5345">        setLazyRenderer(Boolean.class, &quot;javax.swing.JTable$BooleanRenderer&quot;);</span>
<span class="nc" id="L5346">    }</span>

    /**
     * Default Renderers
     **/
    static class NumberRenderer extends DefaultTableCellRenderer.UIResource {
        public NumberRenderer() {
<span class="nc" id="L5353">            super();</span>
<span class="nc" id="L5354">            setHorizontalAlignment(JLabel.RIGHT);</span>
<span class="nc" id="L5355">        }</span>
    }

    static class DoubleRenderer extends NumberRenderer {
        NumberFormat formatter;
<span class="nc" id="L5360">        public DoubleRenderer() { super(); }</span>

        public void setValue(Object value) {
<span class="nc bnc" id="L5363" title="All 2 branches missed.">            if (formatter == null) {</span>
<span class="nc" id="L5364">                formatter = NumberFormat.getInstance();</span>
            }
<span class="nc bnc" id="L5366" title="All 2 branches missed.">            setText((value == null) ? &quot;&quot; : formatter.format(value));</span>
<span class="nc" id="L5367">        }</span>
    }

    static class DateRenderer extends DefaultTableCellRenderer.UIResource {
        DateFormat formatter;
<span class="nc" id="L5372">        public DateRenderer() { super(); }</span>

        public void setValue(Object value) {
<span class="nc bnc" id="L5375" title="All 2 branches missed.">            if (formatter==null) {</span>
<span class="nc" id="L5376">                formatter = DateFormat.getDateInstance();</span>
            }
<span class="nc bnc" id="L5378" title="All 2 branches missed.">            setText((value == null) ? &quot;&quot; : formatter.format(value));</span>
<span class="nc" id="L5379">        }</span>
    }

    static class IconRenderer extends DefaultTableCellRenderer.UIResource {
        public IconRenderer() {
<span class="nc" id="L5384">            super();</span>
<span class="nc" id="L5385">            setHorizontalAlignment(JLabel.CENTER);</span>
<span class="nc" id="L5386">        }</span>
<span class="nc bnc" id="L5387" title="All 2 branches missed.">        public void setValue(Object value) { setIcon((value instanceof Icon) ? (Icon)value : null); }</span>
    }


    static class BooleanRenderer extends JCheckBox implements TableCellRenderer, UIResource
    {
<span class="nc" id="L5393">        private static final Border noFocusBorder = new EmptyBorder(1, 1, 1, 1);</span>

        public BooleanRenderer() {
<span class="nc" id="L5396">            super();</span>
<span class="nc" id="L5397">            setHorizontalAlignment(JLabel.CENTER);</span>
<span class="nc" id="L5398">            setBorderPainted(true);</span>
<span class="nc" id="L5399">        }</span>

        public Component getTableCellRendererComponent(JTable table, Object value,
                                                       boolean isSelected, boolean hasFocus, int row, int column) {
<span class="nc bnc" id="L5403" title="All 2 branches missed.">            if (isSelected) {</span>
<span class="nc" id="L5404">                setForeground(table.getSelectionForeground());</span>
<span class="nc" id="L5405">                super.setBackground(table.getSelectionBackground());</span>
            }
            else {
<span class="nc" id="L5408">                setForeground(table.getForeground());</span>
<span class="nc" id="L5409">                setBackground(table.getBackground());</span>
            }
<span class="nc bnc" id="L5411" title="All 4 branches missed.">            setSelected((value != null &amp;&amp; ((Boolean)value).booleanValue()));</span>

<span class="nc bnc" id="L5413" title="All 2 branches missed.">            if (hasFocus) {</span>
<span class="nc" id="L5414">                setBorder(UIManager.getBorder(&quot;Table.focusCellHighlightBorder&quot;));</span>
            } else {
<span class="nc" id="L5416">                setBorder(noFocusBorder);</span>
            }

<span class="nc" id="L5419">            return this;</span>
        }
    }

    private void setLazyEditor(Class c, String s) {
<span class="nc" id="L5424">        setLazyValue(defaultEditorsByColumnClass, c, s);</span>
<span class="nc" id="L5425">    }</span>

    /**
     * Creates default cell editors for objects, numbers, and boolean values.
     * @see DefaultCellEditor
     */
    protected void createDefaultEditors() {
<span class="nc" id="L5432">        defaultEditorsByColumnClass = new UIDefaults(3, 0.75f);</span>

        // Objects
<span class="nc" id="L5435">        setLazyEditor(Object.class, &quot;javax.swing.JTable$GenericEditor&quot;);</span>

        // Numbers
<span class="nc" id="L5438">        setLazyEditor(Number.class, &quot;javax.swing.JTable$NumberEditor&quot;);</span>

        // Booleans
<span class="nc" id="L5441">        setLazyEditor(Boolean.class, &quot;javax.swing.JTable$BooleanEditor&quot;);</span>
<span class="nc" id="L5442">    }</span>

    /**
     * Default Editors
     */
    static class GenericEditor extends DefaultCellEditor {

<span class="nc" id="L5449">        Class[] argTypes = new Class[]{String.class};</span>
        java.lang.reflect.Constructor constructor;
        Object value;

        public GenericEditor() {
<span class="nc" id="L5454">            super(new JTextField());</span>
<span class="nc" id="L5455">            getComponent().setName(&quot;Table.editor&quot;);</span>
<span class="nc" id="L5456">        }</span>

        public boolean stopCellEditing() {
<span class="nc" id="L5459">            String s = (String)super.getCellEditorValue();</span>
            // Here we are dealing with the case where a user
            // has deleted the string value in a cell, possibly
            // after a failed validation. Return null, so that
            // they have the option to replace the value with
            // null or use escape to restore the original.
            // For Strings, return &quot;&quot; for backward compatibility.
            try {
<span class="nc bnc" id="L5467" title="All 2 branches missed.">                if (&quot;&quot;.equals(s)) {</span>
<span class="nc bnc" id="L5468" title="All 2 branches missed.">                    if (constructor.getDeclaringClass() == String.class) {</span>
<span class="nc" id="L5469">                        value = s;</span>
                    }
<span class="nc" id="L5471">                    return super.stopCellEditing();</span>
                }

<span class="nc" id="L5474">                SwingUtilities2.checkAccess(constructor.getModifiers());</span>
<span class="nc" id="L5475">                value = constructor.newInstance(new Object[]{s});</span>
            }
<span class="nc" id="L5477">            catch (Exception e) {</span>
<span class="nc" id="L5478">                ((JComponent)getComponent()).setBorder(new LineBorder(Color.red));</span>
<span class="nc" id="L5479">                return false;</span>
<span class="nc" id="L5480">            }</span>
<span class="nc" id="L5481">            return super.stopCellEditing();</span>
        }

        public Component getTableCellEditorComponent(JTable table, Object value,
                                                 boolean isSelected,
                                                 int row, int column) {
<span class="nc" id="L5487">            this.value = null;</span>
<span class="nc" id="L5488">            ((JComponent)getComponent()).setBorder(new LineBorder(Color.black));</span>
            try {
<span class="nc" id="L5490">                Class&lt;?&gt; type = table.getColumnClass(column);</span>
                // Since our obligation is to produce a value which is
                // assignable for the required type it is OK to use the
                // String constructor for columns which are declared
                // to contain Objects. A String is an Object.
<span class="nc bnc" id="L5495" title="All 2 branches missed.">                if (type == Object.class) {</span>
<span class="nc" id="L5496">                    type = String.class;</span>
                }
<span class="nc" id="L5498">                ReflectUtil.checkPackageAccess(type);</span>
<span class="nc" id="L5499">                SwingUtilities2.checkAccess(type.getModifiers());</span>
<span class="nc" id="L5500">                constructor = type.getConstructor(argTypes);</span>
            }
<span class="nc" id="L5502">            catch (Exception e) {</span>
<span class="nc" id="L5503">                return null;</span>
<span class="nc" id="L5504">            }</span>
<span class="nc" id="L5505">            return super.getTableCellEditorComponent(table, value, isSelected, row, column);</span>
        }

        public Object getCellEditorValue() {
<span class="nc" id="L5509">            return value;</span>
        }
    }

    static class NumberEditor extends GenericEditor {

<span class="nc" id="L5515">        public NumberEditor() {</span>
<span class="nc" id="L5516">            ((JTextField)getComponent()).setHorizontalAlignment(JTextField.RIGHT);</span>
<span class="nc" id="L5517">        }</span>
    }

    static class BooleanEditor extends DefaultCellEditor {
        public BooleanEditor() {
<span class="nc" id="L5522">            super(new JCheckBox());</span>
<span class="nc" id="L5523">            JCheckBox checkBox = (JCheckBox)getComponent();</span>
<span class="nc" id="L5524">            checkBox.setHorizontalAlignment(JCheckBox.CENTER);</span>
<span class="nc" id="L5525">        }</span>
    }

    /**
     * Initializes table properties to their default values.
     */
    protected void initializeLocalVars() {
<span class="nc" id="L5532">        updateSelectionOnSort = true;</span>
<span class="nc" id="L5533">        setOpaque(true);</span>
<span class="nc" id="L5534">        createDefaultRenderers();</span>
<span class="nc" id="L5535">        createDefaultEditors();</span>

<span class="nc" id="L5537">        setTableHeader(createDefaultTableHeader());</span>

<span class="nc" id="L5539">        setShowGrid(true);</span>
<span class="nc" id="L5540">        setAutoResizeMode(AUTO_RESIZE_SUBSEQUENT_COLUMNS);</span>
<span class="nc" id="L5541">        setRowHeight(16);</span>
<span class="nc" id="L5542">        isRowHeightSet = false;</span>
<span class="nc" id="L5543">        setRowMargin(1);</span>
<span class="nc" id="L5544">        setRowSelectionAllowed(true);</span>
<span class="nc" id="L5545">        setCellEditor(null);</span>
<span class="nc" id="L5546">        setEditingColumn(-1);</span>
<span class="nc" id="L5547">        setEditingRow(-1);</span>
<span class="nc" id="L5548">        setSurrendersFocusOnKeystroke(false);</span>
<span class="nc" id="L5549">        setPreferredScrollableViewportSize(new Dimension(450, 400));</span>

        // I'm registered to do tool tips so we can draw tips for the renderers
<span class="nc" id="L5552">        ToolTipManager toolTipManager = ToolTipManager.sharedInstance();</span>
<span class="nc" id="L5553">        toolTipManager.registerComponent(this);</span>

<span class="nc" id="L5555">        setAutoscrolls(true);</span>
<span class="nc" id="L5556">    }</span>

    /**
     * Returns the default table model object, which is
     * a &lt;code&gt;DefaultTableModel&lt;/code&gt;.  A subclass can override this
     * method to return a different table model object.
     *
     * @return the default table model object
     * @see javax.swing.table.DefaultTableModel
     */
    protected TableModel createDefaultDataModel() {
<span class="nc" id="L5567">        return new DefaultTableModel();</span>
    }

    /**
     * Returns the default column model object, which is
     * a &lt;code&gt;DefaultTableColumnModel&lt;/code&gt;.  A subclass can override this
     * method to return a different column model object.
     *
     * @return the default column model object
     * @see javax.swing.table.DefaultTableColumnModel
     */
    protected TableColumnModel createDefaultColumnModel() {
<span class="nc" id="L5579">        return new DefaultTableColumnModel();</span>
    }

    /**
     * Returns the default selection model object, which is
     * a &lt;code&gt;DefaultListSelectionModel&lt;/code&gt;.  A subclass can override this
     * method to return a different selection model object.
     *
     * @return the default selection model object
     * @see javax.swing.DefaultListSelectionModel
     */
    protected ListSelectionModel createDefaultSelectionModel() {
<span class="nc" id="L5591">        return new DefaultListSelectionModel();</span>
    }

    /**
     * Returns the default table header object, which is
     * a &lt;code&gt;JTableHeader&lt;/code&gt;.  A subclass can override this
     * method to return a different table header object.
     *
     * @return the default table header object
     * @see javax.swing.table.JTableHeader
     */
    protected JTableHeader createDefaultTableHeader() {
<span class="nc" id="L5603">        return new JTableHeader(columnModel);</span>
    }

    /**
     * Equivalent to &lt;code&gt;revalidate&lt;/code&gt; followed by &lt;code&gt;repaint&lt;/code&gt;.
     */
    protected void resizeAndRepaint() {
<span class="nc" id="L5610">        revalidate();</span>
<span class="nc" id="L5611">        repaint();</span>
<span class="nc" id="L5612">    }</span>

    /**
     * Returns the active cell editor, which is {@code null} if the table
     * is not currently editing.
     *
     * @return the {@code TableCellEditor} that does the editing,
     *         or {@code null} if the table is not currently editing.
     * @see #cellEditor
     * @see #getCellEditor(int, int)
     */
    public TableCellEditor getCellEditor() {
<span class="nc" id="L5624">        return cellEditor;</span>
    }

    /**
     * Sets the active cell editor.
     *
     * @param anEditor the active cell editor
     * @see #cellEditor
     * @beaninfo
     *  bound: true
     *  description: The table's active cell editor.
     */
    public void setCellEditor(TableCellEditor anEditor) {
<span class="nc" id="L5637">        TableCellEditor oldEditor = cellEditor;</span>
<span class="nc" id="L5638">        cellEditor = anEditor;</span>
<span class="nc" id="L5639">        firePropertyChange(&quot;tableCellEditor&quot;, oldEditor, anEditor);</span>
<span class="nc" id="L5640">    }</span>

    /**
     * Sets the &lt;code&gt;editingColumn&lt;/code&gt; variable.
     * @param aColumn  the column of the cell to be edited
     *
     * @see #editingColumn
     */
    public void setEditingColumn(int aColumn) {
<span class="nc" id="L5649">        editingColumn = aColumn;</span>
<span class="nc" id="L5650">    }</span>

    /**
     * Sets the &lt;code&gt;editingRow&lt;/code&gt; variable.
     * @param aRow  the row of the cell to be edited
     *
     * @see #editingRow
     */
    public void setEditingRow(int aRow) {
<span class="nc" id="L5659">        editingRow = aRow;</span>
<span class="nc" id="L5660">    }</span>

    /**
     * Returns an appropriate renderer for the cell specified by this row and
     * column. If the &lt;code&gt;TableColumn&lt;/code&gt; for this column has a non-null
     * renderer, returns that.  If not, finds the class of the data in
     * this column (using &lt;code&gt;getColumnClass&lt;/code&gt;)
     * and returns the default renderer for this type of data.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt;
     * Throughout the table package, the internal implementations always
     * use this method to provide renderers so that this default behavior
     * can be safely overridden by a subclass.
     *
     * @param row       the row of the cell to render, where 0 is the first row
     * @param column    the column of the cell to render,
     *                  where 0 is the first column
     * @return the assigned renderer; if &lt;code&gt;null&lt;/code&gt;
     *                  returns the default renderer
     *                  for this type of object
     * @see javax.swing.table.DefaultTableCellRenderer
     * @see javax.swing.table.TableColumn#setCellRenderer
     * @see #setDefaultRenderer
     */
    public TableCellRenderer getCellRenderer(int row, int column) {
<span class="nc" id="L5685">        TableColumn tableColumn = getColumnModel().getColumn(column);</span>
<span class="nc" id="L5686">        TableCellRenderer renderer = tableColumn.getCellRenderer();</span>
<span class="nc bnc" id="L5687" title="All 2 branches missed.">        if (renderer == null) {</span>
<span class="nc" id="L5688">            renderer = getDefaultRenderer(getColumnClass(column));</span>
        }
<span class="nc" id="L5690">        return renderer;</span>
    }

    /**
     * Prepares the renderer by querying the data model for the
     * value and selection state
     * of the cell at &lt;code&gt;row&lt;/code&gt;, &lt;code&gt;column&lt;/code&gt;.
     * Returns the component (may be a &lt;code&gt;Component&lt;/code&gt;
     * or a &lt;code&gt;JComponent&lt;/code&gt;) under the event location.
     * &lt;p&gt;
     * During a printing operation, this method will configure the
     * renderer without indicating selection or focus, to prevent
     * them from appearing in the printed output. To do other
     * customizations based on whether or not the table is being
     * printed, you can check the value of
     * {@link javax.swing.JComponent#isPaintingForPrint()}, either here
     * or within custom renderers.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt;
     * Throughout the table package, the internal implementations always
     * use this method to prepare renderers so that this default behavior
     * can be safely overridden by a subclass.
     *
     * @param renderer  the &lt;code&gt;TableCellRenderer&lt;/code&gt; to prepare
     * @param row       the row of the cell to render, where 0 is the first row
     * @param column    the column of the cell to render,
     *                  where 0 is the first column
     * @return          the &lt;code&gt;Component&lt;/code&gt; under the event location
     */
    public Component prepareRenderer(TableCellRenderer renderer, int row, int column) {
<span class="nc" id="L5720">        Object value = getValueAt(row, column);</span>

<span class="nc" id="L5722">        boolean isSelected = false;</span>
<span class="nc" id="L5723">        boolean hasFocus = false;</span>

        // Only indicate the selection and focused cell if not printing
<span class="nc bnc" id="L5726" title="All 2 branches missed.">        if (!isPaintingForPrint()) {</span>
<span class="nc" id="L5727">            isSelected = isCellSelected(row, column);</span>

<span class="nc" id="L5729">            boolean rowIsLead =</span>
<span class="nc bnc" id="L5730" title="All 2 branches missed.">                (selectionModel.getLeadSelectionIndex() == row);</span>
<span class="nc" id="L5731">            boolean colIsLead =</span>
<span class="nc bnc" id="L5732" title="All 2 branches missed.">                (columnModel.getSelectionModel().getLeadSelectionIndex() == column);</span>

<span class="nc bnc" id="L5734" title="All 6 branches missed.">            hasFocus = (rowIsLead &amp;&amp; colIsLead) &amp;&amp; isFocusOwner();</span>
        }

<span class="nc" id="L5737">        return renderer.getTableCellRendererComponent(this, value,</span>
                                                      isSelected, hasFocus,
                                                      row, column);
    }

    /**
     * Returns an appropriate editor for the cell specified by
     * &lt;code&gt;row&lt;/code&gt; and &lt;code&gt;column&lt;/code&gt;. If the
     * &lt;code&gt;TableColumn&lt;/code&gt; for this column has a non-null editor,
     * returns that.  If not, finds the class of the data in this
     * column (using &lt;code&gt;getColumnClass&lt;/code&gt;)
     * and returns the default editor for this type of data.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt;
     * Throughout the table package, the internal implementations always
     * use this method to provide editors so that this default behavior
     * can be safely overridden by a subclass.
     *
     * @param row       the row of the cell to edit, where 0 is the first row
     * @param column    the column of the cell to edit,
     *                  where 0 is the first column
     * @return          the editor for this cell;
     *                  if &lt;code&gt;null&lt;/code&gt; return the default editor for
     *                  this type of cell
     * @see DefaultCellEditor
     */
    public TableCellEditor getCellEditor(int row, int column) {
<span class="nc" id="L5764">        TableColumn tableColumn = getColumnModel().getColumn(column);</span>
<span class="nc" id="L5765">        TableCellEditor editor = tableColumn.getCellEditor();</span>
<span class="nc bnc" id="L5766" title="All 2 branches missed.">        if (editor == null) {</span>
<span class="nc" id="L5767">            editor = getDefaultEditor(getColumnClass(column));</span>
        }
<span class="nc" id="L5769">        return editor;</span>
    }


    /**
     * Prepares the editor by querying the data model for the value and
     * selection state of the cell at &lt;code&gt;row&lt;/code&gt;, &lt;code&gt;column&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt;
     * Throughout the table package, the internal implementations always
     * use this method to prepare editors so that this default behavior
     * can be safely overridden by a subclass.
     *
     * @param editor  the &lt;code&gt;TableCellEditor&lt;/code&gt; to set up
     * @param row     the row of the cell to edit,
     *                where 0 is the first row
     * @param column  the column of the cell to edit,
     *                where 0 is the first column
     * @return the &lt;code&gt;Component&lt;/code&gt; being edited
     */
    public Component prepareEditor(TableCellEditor editor, int row, int column) {
<span class="nc" id="L5790">        Object value = getValueAt(row, column);</span>
<span class="nc" id="L5791">        boolean isSelected = isCellSelected(row, column);</span>
<span class="nc" id="L5792">        Component comp = editor.getTableCellEditorComponent(this, value, isSelected,</span>
                                                  row, column);
<span class="nc bnc" id="L5794" title="All 2 branches missed.">        if (comp instanceof JComponent) {</span>
<span class="nc" id="L5795">            JComponent jComp = (JComponent)comp;</span>
<span class="nc bnc" id="L5796" title="All 2 branches missed.">            if (jComp.getNextFocusableComponent() == null) {</span>
<span class="nc" id="L5797">                jComp.setNextFocusableComponent(this);</span>
            }
        }
<span class="nc" id="L5800">        return comp;</span>
    }

    /**
     * Discards the editor object and frees the real estate it used for
     * cell rendering.
     */
    public void removeEditor() {
<span class="nc" id="L5808">        KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L5809">            removePropertyChangeListener(&quot;permanentFocusOwner&quot;, editorRemover);</span>
<span class="nc" id="L5810">        editorRemover = null;</span>

<span class="nc" id="L5812">        TableCellEditor editor = getCellEditor();</span>
<span class="nc bnc" id="L5813" title="All 2 branches missed.">        if(editor != null) {</span>
<span class="nc" id="L5814">            editor.removeCellEditorListener(this);</span>
<span class="nc bnc" id="L5815" title="All 2 branches missed.">            if (editorComp != null) {</span>
                Component focusOwner =
<span class="nc" id="L5817">                        KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();</span>
<span class="nc bnc" id="L5818" title="All 2 branches missed.">                boolean isFocusOwnerInTheTable = focusOwner != null?</span>
<span class="nc" id="L5819">                        SwingUtilities.isDescendingFrom(focusOwner, this):false;</span>
<span class="nc" id="L5820">                remove(editorComp);</span>
<span class="nc bnc" id="L5821" title="All 2 branches missed.">                if(isFocusOwnerInTheTable) {</span>
<span class="nc" id="L5822">                    requestFocusInWindow();</span>
                }
            }

<span class="nc" id="L5826">            Rectangle cellRect = getCellRect(editingRow, editingColumn, false);</span>

<span class="nc" id="L5828">            setCellEditor(null);</span>
<span class="nc" id="L5829">            setEditingColumn(-1);</span>
<span class="nc" id="L5830">            setEditingRow(-1);</span>
<span class="nc" id="L5831">            editorComp = null;</span>

<span class="nc" id="L5833">            repaint(cellRect);</span>
        }
<span class="nc" id="L5835">    }</span>

//
// Serialization
//

    /**
     * See readObject() and writeObject() in JComponent for more
     * information about serialization in Swing.
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L5846">        s.defaultWriteObject();</span>
<span class="nc bnc" id="L5847" title="All 2 branches missed.">        if (getUIClassID().equals(uiClassID)) {</span>
<span class="nc" id="L5848">            byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L5849">            JComponent.setWriteObjCounter(this, --count);</span>
<span class="nc bnc" id="L5850" title="All 4 branches missed.">            if (count == 0 &amp;&amp; ui != null) {</span>
<span class="nc" id="L5851">                ui.installUI(this);</span>
            }
        }
<span class="nc" id="L5854">    }</span>

    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException
    {
<span class="nc" id="L5859">        s.defaultReadObject();</span>
<span class="nc bnc" id="L5860" title="All 4 branches missed.">        if ((ui != null) &amp;&amp; (getUIClassID().equals(uiClassID))) {</span>
<span class="nc" id="L5861">            ui.installUI(this);</span>
        }
<span class="nc" id="L5863">        createDefaultRenderers();</span>
<span class="nc" id="L5864">        createDefaultEditors();</span>

        // If ToolTipText != null, then the tooltip has already been
        // registered by JComponent.readObject() and we don't want
        // to re-register here
<span class="nc bnc" id="L5869" title="All 2 branches missed.">        if (getToolTipText() == null) {</span>
<span class="nc" id="L5870">            ToolTipManager.sharedInstance().registerComponent(this);</span>
         }
<span class="nc" id="L5872">    }</span>

    /* Called from the JComponent's EnableSerializationFocusListener to
     * do any Swing-specific pre-serialization configuration.
     */
    void compWriteObjectNotify() {
<span class="nc" id="L5878">        super.compWriteObjectNotify();</span>
        // If ToolTipText != null, then the tooltip has already been
        // unregistered by JComponent.compWriteObjectNotify()
<span class="nc bnc" id="L5881" title="All 2 branches missed.">        if (getToolTipText() == null) {</span>
<span class="nc" id="L5882">            ToolTipManager.sharedInstance().unregisterComponent(this);</span>
        }
<span class="nc" id="L5884">    }</span>

    /**
     * Returns a string representation of this table. This method
     * is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this table
     */
    protected String paramString() {
<span class="nc bnc" id="L5896" title="All 2 branches missed.">        String gridColorString = (gridColor != null ?</span>
<span class="nc" id="L5897">                                  gridColor.toString() : &quot;&quot;);</span>
<span class="nc bnc" id="L5898" title="All 2 branches missed.">        String showHorizontalLinesString = (showHorizontalLines ?</span>
                                            &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L5900" title="All 2 branches missed.">        String showVerticalLinesString = (showVerticalLines ?</span>
                                          &quot;true&quot; : &quot;false&quot;);
        String autoResizeModeString;
<span class="nc bnc" id="L5903" title="All 2 branches missed.">        if (autoResizeMode == AUTO_RESIZE_OFF) {</span>
<span class="nc" id="L5904">            autoResizeModeString = &quot;AUTO_RESIZE_OFF&quot;;</span>
<span class="nc bnc" id="L5905" title="All 2 branches missed.">        } else if (autoResizeMode == AUTO_RESIZE_NEXT_COLUMN) {</span>
<span class="nc" id="L5906">            autoResizeModeString = &quot;AUTO_RESIZE_NEXT_COLUMN&quot;;</span>
<span class="nc bnc" id="L5907" title="All 2 branches missed.">        } else if (autoResizeMode == AUTO_RESIZE_SUBSEQUENT_COLUMNS) {</span>
<span class="nc" id="L5908">            autoResizeModeString = &quot;AUTO_RESIZE_SUBSEQUENT_COLUMNS&quot;;</span>
<span class="nc bnc" id="L5909" title="All 2 branches missed.">        } else if (autoResizeMode == AUTO_RESIZE_LAST_COLUMN) {</span>
<span class="nc" id="L5910">            autoResizeModeString = &quot;AUTO_RESIZE_LAST_COLUMN&quot;;</span>
<span class="nc bnc" id="L5911" title="All 2 branches missed.">        } else if (autoResizeMode == AUTO_RESIZE_ALL_COLUMNS)  {</span>
<span class="nc" id="L5912">            autoResizeModeString = &quot;AUTO_RESIZE_ALL_COLUMNS&quot;;</span>
<span class="nc" id="L5913">        } else autoResizeModeString = &quot;&quot;;</span>
<span class="nc bnc" id="L5914" title="All 2 branches missed.">        String autoCreateColumnsFromModelString = (autoCreateColumnsFromModel ?</span>
                                                   &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L5916" title="All 2 branches missed.">        String preferredViewportSizeString = (preferredViewportSize != null ?</span>
<span class="nc" id="L5917">                                              preferredViewportSize.toString()</span>
                                              : &quot;&quot;);
<span class="nc bnc" id="L5919" title="All 2 branches missed.">        String rowSelectionAllowedString = (rowSelectionAllowed ?</span>
                                            &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L5921" title="All 2 branches missed.">        String cellSelectionEnabledString = (cellSelectionEnabled ?</span>
                                            &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L5923" title="All 2 branches missed.">        String selectionForegroundString = (selectionForeground != null ?</span>
<span class="nc" id="L5924">                                            selectionForeground.toString() :</span>
                                            &quot;&quot;);
<span class="nc bnc" id="L5926" title="All 2 branches missed.">        String selectionBackgroundString = (selectionBackground != null ?</span>
<span class="nc" id="L5927">                                            selectionBackground.toString() :</span>
                                            &quot;&quot;);

<span class="nc" id="L5930">        return super.paramString() +</span>
        &quot;,autoCreateColumnsFromModel=&quot; + autoCreateColumnsFromModelString +
        &quot;,autoResizeMode=&quot; + autoResizeModeString +
        &quot;,cellSelectionEnabled=&quot; + cellSelectionEnabledString +
        &quot;,editingColumn=&quot; + editingColumn +
        &quot;,editingRow=&quot; + editingRow +
        &quot;,gridColor=&quot; + gridColorString +
        &quot;,preferredViewportSize=&quot; + preferredViewportSizeString +
        &quot;,rowHeight=&quot; + rowHeight +
        &quot;,rowMargin=&quot; + rowMargin +
        &quot;,rowSelectionAllowed=&quot; + rowSelectionAllowedString +
        &quot;,selectionBackground=&quot; + selectionBackgroundString +
        &quot;,selectionForeground=&quot; + selectionForegroundString +
        &quot;,showHorizontalLines=&quot; + showHorizontalLinesString +
        &quot;,showVerticalLines=&quot; + showVerticalLinesString;
    }

    // This class tracks changes in the keyboard focus state. It is used
    // when the JTable is editing to determine when to cancel the edit.
    // If focus switches to a component outside of the jtable, but in the
    // same window, this will cancel editing.
    class CellEditorRemover implements PropertyChangeListener {
        KeyboardFocusManager focusManager;

<span class="nc" id="L5954">        public CellEditorRemover(KeyboardFocusManager fm) {</span>
<span class="nc" id="L5955">            this.focusManager = fm;</span>
<span class="nc" id="L5956">        }</span>

        public void propertyChange(PropertyChangeEvent ev) {
<span class="nc bnc" id="L5959" title="All 4 branches missed.">            if (!isEditing() || getClientProperty(&quot;terminateEditOnFocusLost&quot;) != Boolean.TRUE) {</span>
<span class="nc" id="L5960">                return;</span>
            }

<span class="nc" id="L5963">            Component c = focusManager.getPermanentFocusOwner();</span>
<span class="nc bnc" id="L5964" title="All 2 branches missed.">            while (c != null) {</span>
<span class="nc bnc" id="L5965" title="All 2 branches missed.">                if (c == JTable.this) {</span>
                    // focus remains inside the table
<span class="nc" id="L5967">                    return;</span>
<span class="nc bnc" id="L5968" title="All 4 branches missed.">                } else if ((c instanceof Window) ||</span>
<span class="nc bnc" id="L5969" title="All 2 branches missed.">                           (c instanceof Applet &amp;&amp; c.getParent() == null)) {</span>
<span class="nc bnc" id="L5970" title="All 2 branches missed.">                    if (c == SwingUtilities.getRoot(JTable.this)) {</span>
<span class="nc bnc" id="L5971" title="All 2 branches missed.">                        if (!getCellEditor().stopCellEditing()) {</span>
<span class="nc" id="L5972">                            getCellEditor().cancelCellEditing();</span>
                        }
                    }
                    break;
                }
<span class="nc" id="L5977">                c = c.getParent();</span>
            }
<span class="nc" id="L5979">        }</span>
    }

/////////////////
// Printing Support
/////////////////

    /**
     * A convenience method that displays a printing dialog, and then prints
     * this &lt;code&gt;JTable&lt;/code&gt; in mode &lt;code&gt;PrintMode.FIT_WIDTH&lt;/code&gt;,
     * with no header or footer text. A modal progress dialog, with an abort
     * option, will be shown for the duration of printing.
     * &lt;p&gt;
     * Note: In headless mode, no dialogs are shown and printing
     * occurs on the default printer.
     *
     * @return true, unless printing is cancelled by the user
     * @throws SecurityException if this thread is not allowed to
     *                           initiate a print job request
     * @throws PrinterException if an error in the print system causes the job
     *                          to be aborted
     * @see #print(JTable.PrintMode, MessageFormat, MessageFormat,
     *             boolean, PrintRequestAttributeSet, boolean, PrintService)
     * @see #getPrintable
     *
     * @since 1.5
     */
    public boolean print() throws PrinterException {

<span class="nc" id="L6008">        return print(PrintMode.FIT_WIDTH);</span>
    }

    /**
     * A convenience method that displays a printing dialog, and then prints
     * this &lt;code&gt;JTable&lt;/code&gt; in the given printing mode,
     * with no header or footer text. A modal progress dialog, with an abort
     * option, will be shown for the duration of printing.
     * &lt;p&gt;
     * Note: In headless mode, no dialogs are shown and printing
     * occurs on the default printer.
     *
     * @param  printMode        the printing mode that the printable should use
     * @return true, unless printing is cancelled by the user
     * @throws SecurityException if this thread is not allowed to
     *                           initiate a print job request
     * @throws PrinterException if an error in the print system causes the job
     *                          to be aborted
     * @see #print(JTable.PrintMode, MessageFormat, MessageFormat,
     *             boolean, PrintRequestAttributeSet, boolean, PrintService)
     * @see #getPrintable
     *
     * @since 1.5
     */
    public boolean print(PrintMode printMode) throws PrinterException {

<span class="nc" id="L6034">        return print(printMode, null, null);</span>
    }

    /**
     * A convenience method that displays a printing dialog, and then prints
     * this &lt;code&gt;JTable&lt;/code&gt; in the given printing mode,
     * with the specified header and footer text. A modal progress dialog,
     * with an abort option, will be shown for the duration of printing.
     * &lt;p&gt;
     * Note: In headless mode, no dialogs are shown and printing
     * occurs on the default printer.
     *
     * @param  printMode        the printing mode that the printable should use
     * @param  headerFormat     a &lt;code&gt;MessageFormat&lt;/code&gt; specifying the text
     *                          to be used in printing a header,
     *                          or null for none
     * @param  footerFormat     a &lt;code&gt;MessageFormat&lt;/code&gt; specifying the text
     *                          to be used in printing a footer,
     *                          or null for none
     * @return true, unless printing is cancelled by the user
     * @throws SecurityException if this thread is not allowed to
     *                           initiate a print job request
     * @throws PrinterException if an error in the print system causes the job
     *                          to be aborted
     * @see #print(JTable.PrintMode, MessageFormat, MessageFormat,
     *             boolean, PrintRequestAttributeSet, boolean, PrintService)
     * @see #getPrintable
     *
     * @since 1.5
     */
    public boolean print(PrintMode printMode,
                         MessageFormat headerFormat,
                         MessageFormat footerFormat) throws PrinterException {

<span class="nc bnc" id="L6068" title="All 2 branches missed.">        boolean showDialogs = !GraphicsEnvironment.isHeadless();</span>
<span class="nc" id="L6069">        return print(printMode, headerFormat, footerFormat,</span>
                     showDialogs, null, showDialogs);
    }

    /**
     * Prints this table, as specified by the fully featured
     * {@link #print(JTable.PrintMode, MessageFormat, MessageFormat,
     * boolean, PrintRequestAttributeSet, boolean, PrintService) print}
     * method, with the default printer specified as the print service.
     *
     * @param  printMode        the printing mode that the printable should use
     * @param  headerFormat     a &lt;code&gt;MessageFormat&lt;/code&gt; specifying the text
     *                          to be used in printing a header,
     *                          or &lt;code&gt;null&lt;/code&gt; for none
     * @param  footerFormat     a &lt;code&gt;MessageFormat&lt;/code&gt; specifying the text
     *                          to be used in printing a footer,
     *                          or &lt;code&gt;null&lt;/code&gt; for none
     * @param  showPrintDialog  whether or not to display a print dialog
     * @param  attr             a &lt;code&gt;PrintRequestAttributeSet&lt;/code&gt;
     *                          specifying any printing attributes,
     *                          or &lt;code&gt;null&lt;/code&gt; for none
     * @param  interactive      whether or not to print in an interactive mode
     * @return true, unless printing is cancelled by the user
     * @throws HeadlessException if the method is asked to show a printing
     *                           dialog or run interactively, and
     *                           &lt;code&gt;GraphicsEnvironment.isHeadless&lt;/code&gt;
     *                           returns &lt;code&gt;true&lt;/code&gt;
     * @throws SecurityException if this thread is not allowed to
     *                           initiate a print job request
     * @throws PrinterException if an error in the print system causes the job
     *                          to be aborted
     * @see #print(JTable.PrintMode, MessageFormat, MessageFormat,
     *             boolean, PrintRequestAttributeSet, boolean, PrintService)
     * @see #getPrintable
     *
     * @since 1.5
     */
    public boolean print(PrintMode printMode,
                         MessageFormat headerFormat,
                         MessageFormat footerFormat,
                         boolean showPrintDialog,
                         PrintRequestAttributeSet attr,
                         boolean interactive) throws PrinterException,
                                                     HeadlessException {

<span class="nc" id="L6114">        return print(printMode,</span>
                     headerFormat,
                     footerFormat,
                     showPrintDialog,
                     attr,
                     interactive,
                     null);
    }

    /**
     * Prints this &lt;code&gt;JTable&lt;/code&gt;. Takes steps that the majority of
     * developers would take in order to print a &lt;code&gt;JTable&lt;/code&gt;.
     * In short, it prepares the table, calls &lt;code&gt;getPrintable&lt;/code&gt; to
     * fetch an appropriate &lt;code&gt;Printable&lt;/code&gt;, and then sends it to the
     * printer.
     * &lt;p&gt;
     * A &lt;code&gt;boolean&lt;/code&gt; parameter allows you to specify whether or not
     * a printing dialog is displayed to the user. When it is, the user may
     * use the dialog to change the destination printer or printing attributes,
     * or even to cancel the print. Another two parameters allow for a
     * &lt;code&gt;PrintService&lt;/code&gt; and printing attributes to be specified.
     * These parameters can be used either to provide initial values for the
     * print dialog, or to specify values when the dialog is not shown.
     * &lt;p&gt;
     * A second &lt;code&gt;boolean&lt;/code&gt; parameter allows you to specify whether
     * or not to perform printing in an interactive mode. If &lt;code&gt;true&lt;/code&gt;,
     * a modal progress dialog, with an abort option, is displayed for the
     * duration of printing . This dialog also prevents any user action which
     * may affect the table. However, it can not prevent the table from being
     * modified by code (for example, another thread that posts updates using
     * &lt;code&gt;SwingUtilities.invokeLater&lt;/code&gt;). It is therefore the
     * responsibility of the developer to ensure that no other code modifies
     * the table in any way during printing (invalid modifications include
     * changes in: size, renderers, or underlying data). Printing behavior is
     * undefined when the table is changed during printing.
     * &lt;p&gt;
     * If &lt;code&gt;false&lt;/code&gt; is specified for this parameter, no dialog will
     * be displayed and printing will begin immediately on the event-dispatch
     * thread. This blocks any other events, including repaints, from being
     * processed until printing is complete. Although this effectively prevents
     * the table from being changed, it doesn't provide a good user experience.
     * For this reason, specifying &lt;code&gt;false&lt;/code&gt; is only recommended when
     * printing from an application with no visible GUI.
     * &lt;p&gt;
     * Note: Attempting to show the printing dialog or run interactively, while
     * in headless mode, will result in a &lt;code&gt;HeadlessException&lt;/code&gt;.
     * &lt;p&gt;
     * Before fetching the printable, this method will gracefully terminate
     * editing, if necessary, to prevent an editor from showing in the printed
     * result. Additionally, &lt;code&gt;JTable&lt;/code&gt; will prepare its renderers
     * during printing such that selection and focus are not indicated.
     * As far as customizing further how the table looks in the printout,
     * developers can provide custom renderers or paint code that conditionalize
     * on the value of {@link javax.swing.JComponent#isPaintingForPrint()}.
     * &lt;p&gt;
     * See {@link #getPrintable} for more description on how the table is
     * printed.
     *
     * @param  printMode        the printing mode that the printable should use
     * @param  headerFormat     a &lt;code&gt;MessageFormat&lt;/code&gt; specifying the text
     *                          to be used in printing a header,
     *                          or &lt;code&gt;null&lt;/code&gt; for none
     * @param  footerFormat     a &lt;code&gt;MessageFormat&lt;/code&gt; specifying the text
     *                          to be used in printing a footer,
     *                          or &lt;code&gt;null&lt;/code&gt; for none
     * @param  showPrintDialog  whether or not to display a print dialog
     * @param  attr             a &lt;code&gt;PrintRequestAttributeSet&lt;/code&gt;
     *                          specifying any printing attributes,
     *                          or &lt;code&gt;null&lt;/code&gt; for none
     * @param  interactive      whether or not to print in an interactive mode
     * @param  service          the destination &lt;code&gt;PrintService&lt;/code&gt;,
     *                          or &lt;code&gt;null&lt;/code&gt; to use the default printer
     * @return true, unless printing is cancelled by the user
     * @throws HeadlessException if the method is asked to show a printing
     *                           dialog or run interactively, and
     *                           &lt;code&gt;GraphicsEnvironment.isHeadless&lt;/code&gt;
     *                           returns &lt;code&gt;true&lt;/code&gt;
     * @throws  SecurityException if a security manager exists and its
     *          {@link java.lang.SecurityManager#checkPrintJobAccess}
     *          method disallows this thread from creating a print job request
     * @throws PrinterException if an error in the print system causes the job
     *                          to be aborted
     * @see #getPrintable
     * @see java.awt.GraphicsEnvironment#isHeadless
     *
     * @since 1.6
     */
    public boolean print(PrintMode printMode,
                         MessageFormat headerFormat,
                         MessageFormat footerFormat,
                         boolean showPrintDialog,
                         PrintRequestAttributeSet attr,
                         boolean interactive,
                         PrintService service) throws PrinterException,
                                                      HeadlessException {

        // complain early if an invalid parameter is specified for headless mode
<span class="nc" id="L6211">        boolean isHeadless = GraphicsEnvironment.isHeadless();</span>
<span class="nc bnc" id="L6212" title="All 2 branches missed.">        if (isHeadless) {</span>
<span class="nc bnc" id="L6213" title="All 2 branches missed.">            if (showPrintDialog) {</span>
<span class="nc" id="L6214">                throw new HeadlessException(&quot;Can't show print dialog.&quot;);</span>
            }

<span class="nc bnc" id="L6217" title="All 2 branches missed.">            if (interactive) {</span>
<span class="nc" id="L6218">                throw new HeadlessException(&quot;Can't run interactively.&quot;);</span>
            }
        }

        // Get a PrinterJob.
        // Do this before anything with side-effects since it may throw a
        // security exception - in which case we don't want to do anything else.
<span class="nc" id="L6225">        final PrinterJob job = PrinterJob.getPrinterJob();</span>

<span class="nc bnc" id="L6227" title="All 2 branches missed.">        if (isEditing()) {</span>
            // try to stop cell editing, and failing that, cancel it
<span class="nc bnc" id="L6229" title="All 2 branches missed.">            if (!getCellEditor().stopCellEditing()) {</span>
<span class="nc" id="L6230">                getCellEditor().cancelCellEditing();</span>
            }
        }

<span class="nc bnc" id="L6234" title="All 2 branches missed.">        if (attr == null) {</span>
<span class="nc" id="L6235">            attr = new HashPrintRequestAttributeSet();</span>
        }

        final PrintingStatus printingStatus;

         // fetch the Printable
<span class="nc" id="L6241">        Printable printable =</span>
<span class="nc" id="L6242">             getPrintable(printMode, headerFormat, footerFormat);</span>

<span class="nc bnc" id="L6244" title="All 2 branches missed.">        if (interactive) {</span>
            // wrap the Printable so that we can print on another thread
<span class="nc" id="L6246">            printable = new ThreadSafePrintable(printable);</span>
<span class="nc" id="L6247">            printingStatus = PrintingStatus.createPrintingStatus(this, job);</span>
<span class="nc" id="L6248">            printable = printingStatus.createNotificationPrintable(printable);</span>
        } else {
            // to please compiler
<span class="nc" id="L6251">            printingStatus = null;</span>
        }

        // set the printable on the PrinterJob
<span class="nc" id="L6255">        job.setPrintable(printable);</span>

        // if specified, set the PrintService on the PrinterJob
<span class="nc bnc" id="L6258" title="All 2 branches missed.">        if (service != null) {</span>
<span class="nc" id="L6259">            job.setPrintService(service);</span>
        }

        // if requested, show the print dialog
<span class="nc bnc" id="L6263" title="All 4 branches missed.">        if (showPrintDialog &amp;&amp; !job.printDialog(attr)) {</span>
            // the user cancelled the print dialog
<span class="nc" id="L6265">            return false;</span>
        }

        // if not interactive, just print on this thread (no dialog)
<span class="nc bnc" id="L6269" title="All 2 branches missed.">        if (!interactive) {</span>
            // do the printing
<span class="nc" id="L6271">            job.print(attr);</span>

            // we're done
<span class="nc" id="L6274">            return true;</span>
        }

        // make sure this is clear since we'll check it after
<span class="nc" id="L6278">        printError = null;</span>

        // to synchronize on
<span class="nc" id="L6281">        final Object lock = new Object();</span>

        // copied so we can access from the inner class
<span class="nc" id="L6284">        final PrintRequestAttributeSet copyAttr = attr;</span>

        // this runnable will be used to do the printing
        // (and save any throwables) on another thread
<span class="nc" id="L6288">        Runnable runnable = new Runnable() {</span>
            public void run() {
                try {
                    // do the printing
<span class="nc" id="L6292">                    job.print(copyAttr);</span>
<span class="nc" id="L6293">                } catch (Throwable t) {</span>
                    // save any Throwable to be rethrown
<span class="nc" id="L6295">                    synchronized(lock) {</span>
<span class="nc" id="L6296">                        printError = t;</span>
<span class="nc" id="L6297">                    }</span>
                } finally {
                    // we're finished - hide the dialog
<span class="nc" id="L6300">                    printingStatus.dispose();</span>
<span class="nc" id="L6301">                }</span>
<span class="nc" id="L6302">            }</span>
        };

        // start printing on another thread
<span class="nc" id="L6306">        Thread th = new Thread(runnable);</span>
<span class="nc" id="L6307">        th.start();</span>

<span class="nc" id="L6309">        printingStatus.showModal(true);</span>

        // look for any error that the printing may have generated
        Throwable pe;
<span class="nc" id="L6313">        synchronized(lock) {</span>
<span class="nc" id="L6314">            pe = printError;</span>
<span class="nc" id="L6315">            printError = null;</span>
<span class="nc" id="L6316">        }</span>

        // check the type of error and handle it
<span class="nc bnc" id="L6319" title="All 2 branches missed.">        if (pe != null) {</span>
            // a subclass of PrinterException meaning the job was aborted,
            // in this case, by the user
<span class="nc bnc" id="L6322" title="All 2 branches missed.">            if (pe instanceof PrinterAbortException) {</span>
<span class="nc" id="L6323">                return false;</span>
<span class="nc bnc" id="L6324" title="All 2 branches missed.">            } else if (pe instanceof PrinterException) {</span>
<span class="nc" id="L6325">                throw (PrinterException)pe;</span>
<span class="nc bnc" id="L6326" title="All 2 branches missed.">            } else if (pe instanceof RuntimeException) {</span>
<span class="nc" id="L6327">                throw (RuntimeException)pe;</span>
<span class="nc bnc" id="L6328" title="All 2 branches missed.">            } else if (pe instanceof Error) {</span>
<span class="nc" id="L6329">                throw (Error)pe;</span>
            }

            // can not happen
<span class="nc" id="L6333">            throw new AssertionError(pe);</span>
        }

<span class="nc" id="L6336">        return true;</span>
    }

    /**
     * Return a &lt;code&gt;Printable&lt;/code&gt; for use in printing this JTable.
     * &lt;p&gt;
     * This method is meant for those wishing to customize the default
     * &lt;code&gt;Printable&lt;/code&gt; implementation used by &lt;code&gt;JTable&lt;/code&gt;'s
     * &lt;code&gt;print&lt;/code&gt; methods. Developers wanting simply to print the table
     * should use one of those methods directly.
     * &lt;p&gt;
     * The &lt;code&gt;Printable&lt;/code&gt; can be requested in one of two printing modes.
     * In both modes, it spreads table rows naturally in sequence across
     * multiple pages, fitting as many rows as possible per page.
     * &lt;code&gt;PrintMode.NORMAL&lt;/code&gt; specifies that the table be
     * printed at its current size. In this mode, there may be a need to spread
     * columns across pages in a similar manner to that of the rows. When the
     * need arises, columns are distributed in an order consistent with the
     * table's &lt;code&gt;ComponentOrientation&lt;/code&gt;.
     * &lt;code&gt;PrintMode.FIT_WIDTH&lt;/code&gt; specifies that the output be
     * scaled smaller, if necessary, to fit the table's entire width
     * (and thereby all columns) on each page. Width and height are scaled
     * equally, maintaining the aspect ratio of the output.
     * &lt;p&gt;
     * The &lt;code&gt;Printable&lt;/code&gt; heads the portion of table on each page
     * with the appropriate section from the table's &lt;code&gt;JTableHeader&lt;/code&gt;,
     * if it has one.
     * &lt;p&gt;
     * Header and footer text can be added to the output by providing
     * &lt;code&gt;MessageFormat&lt;/code&gt; arguments. The printing code requests
     * Strings from the formats, providing a single item which may be included
     * in the formatted string: an &lt;code&gt;Integer&lt;/code&gt; representing the current
     * page number.
     * &lt;p&gt;
     * You are encouraged to read the documentation for
     * &lt;code&gt;MessageFormat&lt;/code&gt; as some characters, such as single-quote,
     * are special and need to be escaped.
     * &lt;p&gt;
     * Here's an example of creating a &lt;code&gt;MessageFormat&lt;/code&gt; that can be
     * used to print &quot;Duke's Table: Page - &quot; and the current page number:
     * &lt;p&gt;
     * &lt;pre&gt;
     *     // notice the escaping of the single quote
     *     // notice how the page number is included with &quot;{0}&quot;
     *     MessageFormat format = new MessageFormat(&quot;Duke''s Table: Page - {0}&quot;);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The &lt;code&gt;Printable&lt;/code&gt; constrains what it draws to the printable
     * area of each page that it prints. Under certain circumstances, it may
     * find it impossible to fit all of a page's content into that area. In
     * these cases the output may be clipped, but the implementation
     * makes an effort to do something reasonable. Here are a few situations
     * where this is known to occur, and how they may be handled by this
     * particular implementation:
     * &lt;ul&gt;
     *   &lt;li&gt;In any mode, when the header or footer text is too wide to fit
     *       completely in the printable area -- print as much of the text as
     *       possible starting from the beginning, as determined by the table's
     *       &lt;code&gt;ComponentOrientation&lt;/code&gt;.
     *   &lt;li&gt;In any mode, when a row is too tall to fit in the
     *       printable area -- print the upper-most portion of the row
     *       and paint no lower border on the table.
     *   &lt;li&gt;In &lt;code&gt;PrintMode.NORMAL&lt;/code&gt; when a column
     *       is too wide to fit in the printable area -- print the center
     *       portion of the column and leave the left and right borders
     *       off the table.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * It is entirely valid for this &lt;code&gt;Printable&lt;/code&gt; to be wrapped
     * inside another in order to create complex reports and documents. You may
     * even request that different pages be rendered into different sized
     * printable areas. The implementation must be prepared to handle this
     * (possibly by doing its layout calculations on the fly). However,
     * providing different heights to each page will likely not work well
     * with &lt;code&gt;PrintMode.NORMAL&lt;/code&gt; when it has to spread columns
     * across pages.
     * &lt;p&gt;
     * As far as customizing how the table looks in the printed result,
     * &lt;code&gt;JTable&lt;/code&gt; itself will take care of hiding the selection
     * and focus during printing. For additional customizations, your
     * renderers or painting code can customize the look based on the value
     * of {@link javax.swing.JComponent#isPaintingForPrint()}
     * &lt;p&gt;
     * Also, &lt;i&gt;before&lt;/i&gt; calling this method you may wish to &lt;i&gt;first&lt;/i&gt;
     * modify the state of the table, such as to cancel cell editing or
     * have the user size the table appropriately. However, you must not
     * modify the state of the table &lt;i&gt;after&lt;/i&gt; this &lt;code&gt;Printable&lt;/code&gt;
     * has been fetched (invalid modifications include changes in size or
     * underlying data). The behavior of the returned &lt;code&gt;Printable&lt;/code&gt;
     * is undefined once the table has been changed.
     *
     * @param  printMode     the printing mode that the printable should use
     * @param  headerFormat  a &lt;code&gt;MessageFormat&lt;/code&gt; specifying the text to
     *                       be used in printing a header, or null for none
     * @param  footerFormat  a &lt;code&gt;MessageFormat&lt;/code&gt; specifying the text to
     *                       be used in printing a footer, or null for none
     * @return a &lt;code&gt;Printable&lt;/code&gt; for printing this JTable
     * @see #print(JTable.PrintMode, MessageFormat, MessageFormat,
     *             boolean, PrintRequestAttributeSet, boolean)
     * @see Printable
     * @see PrinterJob
     *
     * @since 1.5
     */
    public Printable getPrintable(PrintMode printMode,
                                  MessageFormat headerFormat,
                                  MessageFormat footerFormat) {

<span class="nc" id="L6444">        return new TablePrintable(this, printMode, headerFormat, footerFormat);</span>
    }


    /**
     * A &lt;code&gt;Printable&lt;/code&gt; implementation that wraps another
     * &lt;code&gt;Printable&lt;/code&gt;, making it safe for printing on another thread.
     */
    private class ThreadSafePrintable implements Printable {

        /** The delegate &lt;code&gt;Printable&lt;/code&gt;. */
        private Printable printDelegate;

        /**
         * To communicate any return value when delegating.
         */
        private int retVal;

        /**
         * To communicate any &lt;code&gt;Throwable&lt;/code&gt; when delegating.
         */
        private Throwable retThrowable;

        /**
         * Construct a &lt;code&gt;ThreadSafePrintable&lt;/code&gt; around the given
         * delegate.
         *
         * @param printDelegate the &lt;code&gt;Printable&lt;/code&gt; to delegate to
         */
<span class="nc" id="L6473">        public ThreadSafePrintable(Printable printDelegate) {</span>
<span class="nc" id="L6474">            this.printDelegate = printDelegate;</span>
<span class="nc" id="L6475">        }</span>

        /**
         * Prints the specified page into the given {@link Graphics}
         * context, in the specified format.
         * &lt;p&gt;
         * Regardless of what thread this method is called on, all calls into
         * the delegate will be done on the event-dispatch thread.
         *
         * @param   graphics    the context into which the page is drawn
         * @param   pageFormat  the size and orientation of the page being drawn
         * @param   pageIndex   the zero based index of the page to be drawn
         * @return  PAGE_EXISTS if the page is rendered successfully, or
         *          NO_SUCH_PAGE if a non-existent page index is specified
         * @throws  PrinterException if an error causes printing to be aborted
         */
        public int print(final Graphics graphics,
                         final PageFormat pageFormat,
                         final int pageIndex) throws PrinterException {

            // We'll use this Runnable
<span class="nc" id="L6496">            Runnable runnable = new Runnable() {</span>
                public synchronized void run() {
                    try {
                        // call into the delegate and save the return value
<span class="nc" id="L6500">                        retVal = printDelegate.print(graphics, pageFormat, pageIndex);</span>
<span class="nc" id="L6501">                    } catch (Throwable throwable) {</span>
                        // save any Throwable to be rethrown
<span class="nc" id="L6503">                        retThrowable = throwable;</span>
                    } finally {
                        // notify the caller that we're done
<span class="nc" id="L6506">                        notifyAll();</span>
<span class="nc" id="L6507">                    }</span>
<span class="nc" id="L6508">                }</span>
            };

<span class="nc" id="L6511">            synchronized(runnable) {</span>
                // make sure these are initialized
<span class="nc" id="L6513">                retVal = -1;</span>
<span class="nc" id="L6514">                retThrowable = null;</span>

                // call into the EDT
<span class="nc" id="L6517">                SwingUtilities.invokeLater(runnable);</span>

                // wait for the runnable to finish
<span class="nc bnc" id="L6520" title="All 4 branches missed.">                while (retVal == -1 &amp;&amp; retThrowable == null) {</span>
                    try {
<span class="nc" id="L6522">                        runnable.wait();</span>
<span class="nc" id="L6523">                    } catch (InterruptedException ie) {</span>
                        // short process, safe to ignore interrupts
<span class="nc" id="L6525">                    }</span>
                }

                // if the delegate threw a throwable, rethrow it here
<span class="nc bnc" id="L6529" title="All 2 branches missed.">                if (retThrowable != null) {</span>
<span class="nc bnc" id="L6530" title="All 2 branches missed.">                    if (retThrowable instanceof PrinterException) {</span>
<span class="nc" id="L6531">                        throw (PrinterException)retThrowable;</span>
<span class="nc bnc" id="L6532" title="All 2 branches missed.">                    } else if (retThrowable instanceof RuntimeException) {</span>
<span class="nc" id="L6533">                        throw (RuntimeException)retThrowable;</span>
<span class="nc bnc" id="L6534" title="All 2 branches missed.">                    } else if (retThrowable instanceof Error) {</span>
<span class="nc" id="L6535">                        throw (Error)retThrowable;</span>
                    }

                    // can not happen
<span class="nc" id="L6539">                    throw new AssertionError(retThrowable);</span>
                }

<span class="nc" id="L6542">                return retVal;</span>
<span class="nc" id="L6543">            }</span>
        }
    }


/////////////////
// Accessibility support
////////////////

    /**
     * Gets the AccessibleContext associated with this JTable.
     * For tables, the AccessibleContext takes the form of an
     * AccessibleJTable.
     * A new AccessibleJTable instance is created if necessary.
     *
     * @return an AccessibleJTable that serves as the
     *         AccessibleContext of this JTable
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L6562" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L6563">            accessibleContext = new AccessibleJTable();</span>
        }
<span class="nc" id="L6565">        return accessibleContext;</span>
    }

    //
    // *** should also implement AccessibleSelection?
    // *** and what's up with keyboard navigation/manipulation?
    //
    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JTable&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to table user-interface elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    protected class AccessibleJTable extends AccessibleJComponent
    implements AccessibleSelection, ListSelectionListener, TableModelListener,
    TableColumnModelListener, CellEditorListener, PropertyChangeListener,
    AccessibleExtendedTable {

        int lastSelectedRow;
        int lastSelectedCol;

        /**
         * AccessibleJTable constructor
         *
         * @since 1.5
         */
<span class="nc" id="L6599">        protected AccessibleJTable() {</span>
<span class="nc" id="L6600">            super();</span>
<span class="nc" id="L6601">            JTable.this.addPropertyChangeListener(this);</span>
<span class="nc" id="L6602">            JTable.this.getSelectionModel().addListSelectionListener(this);</span>
<span class="nc" id="L6603">            TableColumnModel tcm = JTable.this.getColumnModel();</span>
<span class="nc" id="L6604">            tcm.addColumnModelListener(this);</span>
<span class="nc" id="L6605">            tcm.getSelectionModel().addListSelectionListener(this);</span>
<span class="nc" id="L6606">            JTable.this.getModel().addTableModelListener(this);</span>
<span class="nc" id="L6607">            lastSelectedRow = JTable.this.getSelectedRow();</span>
<span class="nc" id="L6608">            lastSelectedCol = JTable.this.getSelectedColumn();</span>
<span class="nc" id="L6609">        }</span>

    // Listeners to track model, etc. changes to as to re-place the other
    // listeners

        /**
         * Track changes to selection model, column model, etc. so as to
         * be able to re-place listeners on those in order to pass on
         * information to the Accessibility PropertyChange mechanism
         */
        public void propertyChange(PropertyChangeEvent e) {
<span class="nc" id="L6620">            String name = e.getPropertyName();</span>
<span class="nc" id="L6621">            Object oldValue = e.getOldValue();</span>
<span class="nc" id="L6622">            Object newValue = e.getNewValue();</span>

                // re-set tableModel listeners
<span class="nc bnc" id="L6625" title="All 2 branches missed.">            if (name.compareTo(&quot;model&quot;) == 0) {</span>

<span class="nc bnc" id="L6627" title="All 4 branches missed.">                if (oldValue != null &amp;&amp; oldValue instanceof TableModel) {</span>
<span class="nc" id="L6628">                    ((TableModel) oldValue).removeTableModelListener(this);</span>
                }
<span class="nc bnc" id="L6630" title="All 4 branches missed.">                if (newValue != null &amp;&amp; newValue instanceof TableModel) {</span>
<span class="nc" id="L6631">                    ((TableModel) newValue).addTableModelListener(this);</span>
                }

                // re-set selectionModel listeners
<span class="nc bnc" id="L6635" title="All 2 branches missed.">            } else if (name.compareTo(&quot;selectionModel&quot;) == 0) {</span>

<span class="nc" id="L6637">                Object source = e.getSource();</span>
<span class="nc bnc" id="L6638" title="All 2 branches missed.">                if (source == JTable.this) {    // row selection model</span>

<span class="nc bnc" id="L6640" title="All 4 branches missed.">                    if (oldValue != null &amp;&amp;</span>
                        oldValue instanceof ListSelectionModel) {
<span class="nc" id="L6642">                        ((ListSelectionModel) oldValue).removeListSelectionListener(this);</span>
                    }
<span class="nc bnc" id="L6644" title="All 4 branches missed.">                    if (newValue != null &amp;&amp;</span>
                        newValue instanceof ListSelectionModel) {
<span class="nc" id="L6646">                        ((ListSelectionModel) newValue).addListSelectionListener(this);</span>
                    }

<span class="nc bnc" id="L6649" title="All 2 branches missed.">                } else if (source == JTable.this.getColumnModel()) {</span>

<span class="nc bnc" id="L6651" title="All 4 branches missed.">                    if (oldValue != null &amp;&amp;</span>
                        oldValue instanceof ListSelectionModel) {
<span class="nc" id="L6653">                        ((ListSelectionModel) oldValue).removeListSelectionListener(this);</span>
                    }
<span class="nc bnc" id="L6655" title="All 4 branches missed.">                    if (newValue != null &amp;&amp;</span>
                        newValue instanceof ListSelectionModel) {
<span class="nc" id="L6657">                        ((ListSelectionModel) newValue).addListSelectionListener(this);</span>
                    }

                } else {
                  //        System.out.println(&quot;!!! Bug in source of selectionModel propertyChangeEvent&quot;);
                }

                // re-set columnModel listeners
                // and column's selection property listener as well
<span class="nc bnc" id="L6666" title="All 2 branches missed.">            } else if (name.compareTo(&quot;columnModel&quot;) == 0) {</span>

<span class="nc bnc" id="L6668" title="All 4 branches missed.">                if (oldValue != null &amp;&amp; oldValue instanceof TableColumnModel) {</span>
<span class="nc" id="L6669">                    TableColumnModel tcm = (TableColumnModel) oldValue;</span>
<span class="nc" id="L6670">                    tcm.removeColumnModelListener(this);</span>
<span class="nc" id="L6671">                    tcm.getSelectionModel().removeListSelectionListener(this);</span>
                }
<span class="nc bnc" id="L6673" title="All 4 branches missed.">                if (newValue != null &amp;&amp; newValue instanceof TableColumnModel) {</span>
<span class="nc" id="L6674">                    TableColumnModel tcm = (TableColumnModel) newValue;</span>
<span class="nc" id="L6675">                    tcm.addColumnModelListener(this);</span>
<span class="nc" id="L6676">                    tcm.getSelectionModel().addListSelectionListener(this);</span>
<span class="nc" id="L6677">                }</span>

                // re-se cellEditor listeners
<span class="nc bnc" id="L6680" title="All 2 branches missed.">            } else if (name.compareTo(&quot;tableCellEditor&quot;) == 0) {</span>

<span class="nc bnc" id="L6682" title="All 4 branches missed.">                if (oldValue != null &amp;&amp; oldValue instanceof TableCellEditor) {</span>
<span class="nc" id="L6683">                    ((TableCellEditor) oldValue).removeCellEditorListener(this);</span>
                }
<span class="nc bnc" id="L6685" title="All 4 branches missed.">                if (newValue != null &amp;&amp; newValue instanceof TableCellEditor) {</span>
<span class="nc" id="L6686">                    ((TableCellEditor) newValue).addCellEditorListener(this);</span>
                }
            }
<span class="nc" id="L6689">        }</span>


    // Listeners to echo changes to the AccessiblePropertyChange mechanism

        /*
         * Describes a change in the accessible table model.
         */
        protected class AccessibleJTableModelChange
            implements AccessibleTableModelChange {

            protected int type;
            protected int firstRow;
            protected int lastRow;
            protected int firstColumn;
            protected int lastColumn;

            protected AccessibleJTableModelChange(int type, int firstRow,
                                                  int lastRow, int firstColumn,
<span class="nc" id="L6708">                                                  int lastColumn) {</span>
<span class="nc" id="L6709">                this.type = type;</span>
<span class="nc" id="L6710">                this.firstRow = firstRow;</span>
<span class="nc" id="L6711">                this.lastRow = lastRow;</span>
<span class="nc" id="L6712">                this.firstColumn = firstColumn;</span>
<span class="nc" id="L6713">                this.lastColumn = lastColumn;</span>
<span class="nc" id="L6714">            }</span>

            public int getType() {
<span class="nc" id="L6717">                return type;</span>
            }

            public int getFirstRow() {
<span class="nc" id="L6721">                return firstRow;</span>
            }

            public int getLastRow() {
<span class="nc" id="L6725">                return lastRow;</span>
            }

            public int getFirstColumn() {
<span class="nc" id="L6729">                return firstColumn;</span>
            }

            public int getLastColumn() {
<span class="nc" id="L6733">                return lastColumn;</span>
            }
        }

        /**
         * Track changes to the table contents
         */
        public void tableChanged(TableModelEvent e) {
<span class="nc" id="L6741">           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
                              null, null);
<span class="nc bnc" id="L6743" title="All 2 branches missed.">           if (e != null) {</span>
<span class="nc" id="L6744">               int firstColumn = e.getColumn();</span>
<span class="nc" id="L6745">               int lastColumn = e.getColumn();</span>
<span class="nc bnc" id="L6746" title="All 2 branches missed.">               if (firstColumn == TableModelEvent.ALL_COLUMNS) {</span>
<span class="nc" id="L6747">                   firstColumn = 0;</span>
<span class="nc" id="L6748">                   lastColumn = getColumnCount() - 1;</span>
               }

               // Fire a property change event indicating the table model
               // has changed.
<span class="nc" id="L6753">               AccessibleJTableModelChange change =</span>
<span class="nc" id="L6754">                   new AccessibleJTableModelChange(e.getType(),</span>
<span class="nc" id="L6755">                                                   e.getFirstRow(),</span>
<span class="nc" id="L6756">                                                   e.getLastRow(),</span>
                                                   firstColumn,
                                                   lastColumn);
<span class="nc" id="L6759">               firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,</span>
                                  null, change);
            }
<span class="nc" id="L6762">        }</span>

        /**
         * Track changes to the table contents (row insertions)
         */
        public void tableRowsInserted(TableModelEvent e) {
<span class="nc" id="L6768">           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
                              null, null);

           // Fire a property change event indicating the table model
           // has changed.
<span class="nc" id="L6773">           int firstColumn = e.getColumn();</span>
<span class="nc" id="L6774">           int lastColumn = e.getColumn();</span>
<span class="nc bnc" id="L6775" title="All 2 branches missed.">           if (firstColumn == TableModelEvent.ALL_COLUMNS) {</span>
<span class="nc" id="L6776">               firstColumn = 0;</span>
<span class="nc" id="L6777">               lastColumn = getColumnCount() - 1;</span>
           }
<span class="nc" id="L6779">           AccessibleJTableModelChange change =</span>
<span class="nc" id="L6780">               new AccessibleJTableModelChange(e.getType(),</span>
<span class="nc" id="L6781">                                               e.getFirstRow(),</span>
<span class="nc" id="L6782">                                               e.getLastRow(),</span>
                                               firstColumn,
                                               lastColumn);
<span class="nc" id="L6785">           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,</span>
                              null, change);
<span class="nc" id="L6787">        }</span>

        /**
         * Track changes to the table contents (row deletions)
         */
        public void tableRowsDeleted(TableModelEvent e) {
<span class="nc" id="L6793">           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
                              null, null);

           // Fire a property change event indicating the table model
           // has changed.
<span class="nc" id="L6798">           int firstColumn = e.getColumn();</span>
<span class="nc" id="L6799">           int lastColumn = e.getColumn();</span>
<span class="nc bnc" id="L6800" title="All 2 branches missed.">           if (firstColumn == TableModelEvent.ALL_COLUMNS) {</span>
<span class="nc" id="L6801">               firstColumn = 0;</span>
<span class="nc" id="L6802">               lastColumn = getColumnCount() - 1;</span>
           }
<span class="nc" id="L6804">           AccessibleJTableModelChange change =</span>
<span class="nc" id="L6805">               new AccessibleJTableModelChange(e.getType(),</span>
<span class="nc" id="L6806">                                               e.getFirstRow(),</span>
<span class="nc" id="L6807">                                               e.getLastRow(),</span>
                                               firstColumn,
                                               lastColumn);
<span class="nc" id="L6810">           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,</span>
                              null, change);
<span class="nc" id="L6812">        }</span>

        /**
         * Track changes to the table contents (column insertions)
         */
        public void columnAdded(TableColumnModelEvent e) {
<span class="nc" id="L6818">           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
                              null, null);

           // Fire a property change event indicating the table model
           // has changed.
<span class="nc" id="L6823">           int type = AccessibleTableModelChange.INSERT;</span>
<span class="nc" id="L6824">           AccessibleJTableModelChange change =</span>
               new AccessibleJTableModelChange(type,
                                               0,
                                               0,
<span class="nc" id="L6828">                                               e.getFromIndex(),</span>
<span class="nc" id="L6829">                                               e.getToIndex());</span>
<span class="nc" id="L6830">           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,</span>
                              null, change);
<span class="nc" id="L6832">        }</span>

        /**
         * Track changes to the table contents (column deletions)
         */
        public void columnRemoved(TableColumnModelEvent e) {
<span class="nc" id="L6838">           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
                              null, null);
           // Fire a property change event indicating the table model
           // has changed.
<span class="nc" id="L6842">           int type = AccessibleTableModelChange.DELETE;</span>
<span class="nc" id="L6843">           AccessibleJTableModelChange change =</span>
               new AccessibleJTableModelChange(type,
                                               0,
                                               0,
<span class="nc" id="L6847">                                               e.getFromIndex(),</span>
<span class="nc" id="L6848">                                               e.getToIndex());</span>
<span class="nc" id="L6849">           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,</span>
                              null, change);
<span class="nc" id="L6851">        }</span>

        /**
         * Track changes of a column repositioning.
         *
         * @see TableColumnModelListener
         */
        public void columnMoved(TableColumnModelEvent e) {
<span class="nc" id="L6859">           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
                              null, null);

           // Fire property change events indicating the table model
           // has changed.
<span class="nc" id="L6864">           int type = AccessibleTableModelChange.DELETE;</span>
<span class="nc" id="L6865">           AccessibleJTableModelChange change =</span>
               new AccessibleJTableModelChange(type,
                                               0,
                                               0,
<span class="nc" id="L6869">                                               e.getFromIndex(),</span>
<span class="nc" id="L6870">                                               e.getFromIndex());</span>
<span class="nc" id="L6871">           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,</span>
                              null, change);

<span class="nc" id="L6874">           int type2 = AccessibleTableModelChange.INSERT;</span>
<span class="nc" id="L6875">           AccessibleJTableModelChange change2 =</span>
               new AccessibleJTableModelChange(type2,
                                               0,
                                               0,
<span class="nc" id="L6879">                                               e.getToIndex(),</span>
<span class="nc" id="L6880">                                               e.getToIndex());</span>
<span class="nc" id="L6881">           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,</span>
                              null, change2);
<span class="nc" id="L6883">        }</span>

        /**
         * Track changes of a column moving due to margin changes.
         *
         * @see TableColumnModelListener
         */
        public void columnMarginChanged(ChangeEvent e) {
<span class="nc" id="L6891">           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
                              null, null);
<span class="nc" id="L6893">        }</span>

        /**
         * Track that the selection model of the TableColumnModel changed.
         *
         * @see TableColumnModelListener
         */
        public void columnSelectionChanged(ListSelectionEvent e) {
            // we should now re-place our TableColumn listener
<span class="nc" id="L6902">        }</span>

        /**
         * Track changes to a cell's contents.
         *
         * Invoked when editing is finished. The changes are saved, the
         * editor object is discarded, and the cell is rendered once again.
         *
         * @see CellEditorListener
         */
        public void editingStopped(ChangeEvent e) {
           // it'd be great if we could figure out which cell, and pass that
           // somehow as a parameter
<span class="nc" id="L6915">           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
                              null, null);
<span class="nc" id="L6917">        }</span>

        /**
         * Invoked when editing is canceled. The editor object is discarded
         * and the cell is rendered once again.
         *
         * @see CellEditorListener
         */
        public void editingCanceled(ChangeEvent e) {
            // nothing to report, 'cause nothing changed
<span class="nc" id="L6927">        }</span>

        /**
         * Track changes to table cell selections
         */
        public void valueChanged(ListSelectionEvent e) {
<span class="nc" id="L6933">            firePropertyChange(AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,</span>
<span class="nc" id="L6934">                               Boolean.valueOf(false), Boolean.valueOf(true));</span>

<span class="nc" id="L6936">            int selectedRow = JTable.this.getSelectedRow();</span>
<span class="nc" id="L6937">            int selectedCol = JTable.this.getSelectedColumn();</span>
<span class="nc bnc" id="L6938" title="All 4 branches missed.">            if (selectedRow != lastSelectedRow ||</span>
                selectedCol != lastSelectedCol) {
<span class="nc" id="L6940">                Accessible oldA = getAccessibleAt(lastSelectedRow,</span>
                                                  lastSelectedCol);
<span class="nc" id="L6942">                Accessible newA = getAccessibleAt(selectedRow, selectedCol);</span>
<span class="nc" id="L6943">                firePropertyChange(AccessibleContext.ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY,</span>
                                   oldA, newA);
<span class="nc" id="L6945">                 lastSelectedRow = selectedRow;</span>
<span class="nc" id="L6946">                 lastSelectedCol = selectedCol;</span>
             }
<span class="nc" id="L6948">        }</span>




    // AccessibleContext support

        /**
         * Get the AccessibleSelection associated with this object.  In the
         * implementation of the Java Accessibility API for this class,
         * return this object, which is responsible for implementing the
         * AccessibleSelection interface on behalf of itself.
         *
         * @return this object
         */
        public AccessibleSelection getAccessibleSelection() {
<span class="nc" id="L6964">            return this;</span>
        }

        /**
         * Gets the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of the
         * object
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L6975">            return AccessibleRole.TABLE;</span>
        }

        /**
         * Returns the &lt;code&gt;Accessible&lt;/code&gt; child, if one exists,
         * contained at the local coordinate &lt;code&gt;Point&lt;/code&gt;.
         *
         * @param p the point defining the top-left corner of the
         *    &lt;code&gt;Accessible&lt;/code&gt;, given in the coordinate space
         *    of the object's parent
         * @return the &lt;code&gt;Accessible&lt;/code&gt;, if it exists,
         *    at the specified location; else &lt;code&gt;null&lt;/code&gt;
         */
        public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L6989">            int column = columnAtPoint(p);</span>
<span class="nc" id="L6990">            int row = rowAtPoint(p);</span>

<span class="nc bnc" id="L6992" title="All 4 branches missed.">            if ((column != -1) &amp;&amp; (row != -1)) {</span>
<span class="nc" id="L6993">                TableColumn aColumn = getColumnModel().getColumn(column);</span>
<span class="nc" id="L6994">                TableCellRenderer renderer = aColumn.getCellRenderer();</span>
<span class="nc bnc" id="L6995" title="All 2 branches missed.">                if (renderer == null) {</span>
<span class="nc" id="L6996">                    Class&lt;?&gt; columnClass = getColumnClass(column);</span>
<span class="nc" id="L6997">                    renderer = getDefaultRenderer(columnClass);</span>
                }
<span class="nc" id="L6999">                Component component = renderer.getTableCellRendererComponent(</span>
                                  JTable.this, null, false, false,
                                  row, column);
<span class="nc" id="L7002">                return new AccessibleJTableCell(JTable.this, row, column,</span>
<span class="nc" id="L7003">                      getAccessibleIndexAt(row, column));</span>
            }
<span class="nc" id="L7005">            return null;</span>
        }

        /**
         * Returns the number of accessible children in the object.  If all
         * of the children of this object implement &lt;code&gt;Accessible&lt;/code&gt;,
         * then this method should return the number of children of this object.
         *
         * @return the number of accessible children in the object
         */
        public int getAccessibleChildrenCount() {
<span class="nc" id="L7016">            return (JTable.this.getColumnCount() * JTable.this.getRowCount());</span>
        }

        /**
         * Returns the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object.
         *
         * @param i zero-based index of child
         * @return the nth Accessible child of the object
         */
        public Accessible getAccessibleChild(int i) {
<span class="nc bnc" id="L7026" title="All 4 branches missed.">            if (i &lt; 0 || i &gt;= getAccessibleChildrenCount()) {</span>
<span class="nc" id="L7027">                return null;</span>
            } else {
                // children increase across, and then down, for tables
                // (arbitrary decision)
<span class="nc" id="L7031">                int column = getAccessibleColumnAtIndex(i);</span>
<span class="nc" id="L7032">                int row = getAccessibleRowAtIndex(i);</span>

<span class="nc" id="L7034">                TableColumn aColumn = getColumnModel().getColumn(column);</span>
<span class="nc" id="L7035">                TableCellRenderer renderer = aColumn.getCellRenderer();</span>
<span class="nc bnc" id="L7036" title="All 2 branches missed.">                if (renderer == null) {</span>
<span class="nc" id="L7037">                    Class&lt;?&gt; columnClass = getColumnClass(column);</span>
<span class="nc" id="L7038">                    renderer = getDefaultRenderer(columnClass);</span>
                }
<span class="nc" id="L7040">                Component component = renderer.getTableCellRendererComponent(</span>
                                  JTable.this, null, false, false,
                                  row, column);
<span class="nc" id="L7043">                return new AccessibleJTableCell(JTable.this, row, column,</span>
<span class="nc" id="L7044">                      getAccessibleIndexAt(row, column));</span>
            }
        }

    // AccessibleSelection support

        /**
         * Returns the number of &lt;code&gt;Accessible&lt;/code&gt; children
         * currently selected.
         * If no children are selected, the return value will be 0.
         *
         * @return the number of items currently selected
         */
        public int getAccessibleSelectionCount() {
<span class="nc" id="L7058">            int rowsSel = JTable.this.getSelectedRowCount();</span>
<span class="nc" id="L7059">            int colsSel = JTable.this.getSelectedColumnCount();</span>

<span class="nc bnc" id="L7061" title="All 2 branches missed.">            if (JTable.this.cellSelectionEnabled) { // a contiguous block</span>
<span class="nc" id="L7062">                return rowsSel * colsSel;</span>

            } else {
                // a column swath and a row swath, with a shared block
<span class="nc bnc" id="L7066" title="All 2 branches missed.">                if (JTable.this.getRowSelectionAllowed() &amp;&amp;</span>
<span class="nc bnc" id="L7067" title="All 2 branches missed.">                    JTable.this.getColumnSelectionAllowed()) {</span>
<span class="nc" id="L7068">                    return rowsSel * JTable.this.getColumnCount() +</span>
<span class="nc" id="L7069">                           colsSel * JTable.this.getRowCount() -</span>
                           rowsSel * colsSel;

                // just one or more rows in selection
<span class="nc bnc" id="L7073" title="All 2 branches missed.">                } else if (JTable.this.getRowSelectionAllowed()) {</span>
<span class="nc" id="L7074">                    return rowsSel * JTable.this.getColumnCount();</span>

                // just one or more rows in selection
<span class="nc bnc" id="L7077" title="All 2 branches missed.">                } else if (JTable.this.getColumnSelectionAllowed()) {</span>
<span class="nc" id="L7078">                    return colsSel * JTable.this.getRowCount();</span>

                } else {
<span class="nc" id="L7081">                    return 0;    // JTable doesn't allow selections</span>
                }
            }
        }

        /**
         * Returns an &lt;code&gt;Accessible&lt;/code&gt; representing the
         * specified selected child in the object.  If there
         * isn't a selection, or there are fewer children selected
         * than the integer passed in, the return
         * value will be &lt;code&gt;null&lt;/code&gt;.
         * &lt;p&gt;Note that the index represents the i-th selected child, which
         * is different from the i-th child.
         *
         * @param i the zero-based index of selected children
         * @return the i-th selected child
         * @see #getAccessibleSelectionCount
         */
        public Accessible getAccessibleSelection(int i) {
<span class="nc bnc" id="L7100" title="All 4 branches missed.">            if (i &lt; 0 || i &gt; getAccessibleSelectionCount()) {</span>
<span class="nc" id="L7101">                return null;</span>
            }

<span class="nc" id="L7104">            int rowsSel = JTable.this.getSelectedRowCount();</span>
<span class="nc" id="L7105">            int colsSel = JTable.this.getSelectedColumnCount();</span>
<span class="nc" id="L7106">            int rowIndicies[] = getSelectedRows();</span>
<span class="nc" id="L7107">            int colIndicies[] = getSelectedColumns();</span>
<span class="nc" id="L7108">            int ttlCols = JTable.this.getColumnCount();</span>
<span class="nc" id="L7109">            int ttlRows = JTable.this.getRowCount();</span>
            int r;
            int c;

<span class="nc bnc" id="L7113" title="All 2 branches missed.">            if (JTable.this.cellSelectionEnabled) { // a contiguous block</span>
<span class="nc" id="L7114">                r = rowIndicies[i / colsSel];</span>
<span class="nc" id="L7115">                c = colIndicies[i % colsSel];</span>
<span class="nc" id="L7116">                return getAccessibleChild((r * ttlCols) + c);</span>
            } else {

                // a column swath and a row swath, with a shared block
<span class="nc bnc" id="L7120" title="All 2 branches missed.">                if (JTable.this.getRowSelectionAllowed() &amp;&amp;</span>
<span class="nc bnc" id="L7121" title="All 2 branches missed.">                    JTable.this.getColumnSelectionAllowed()) {</span>

                    // Situation:
                    //   We have a table, like the 6x3 table below,
                    //   wherein three colums and one row selected
                    //   (selected cells marked with &quot;*&quot;, unselected &quot;0&quot;):
                    //
                    //            0 * 0 * * 0
                    //            * * * * * *
                    //            0 * 0 * * 0
                    //

                    // State machine below walks through the array of
                    // selected rows in two states: in a selected row,
                    // and not in one; continuing until we are in a row
                    // in which the ith selection exists.  Then we return
                    // the appropriate cell.  In the state machine, we
                    // always do rows above the &quot;current&quot; selected row first,
                    // then the cells in the selected row.  If we're done
                    // with the state machine before finding the requested
                    // selected child, we handle the rows below the last
                    // selected row at the end.
                    //
<span class="nc" id="L7144">                    int curIndex = i;</span>
                    final int IN_ROW = 0;
                    final int NOT_IN_ROW = 1;
<span class="nc bnc" id="L7147" title="All 2 branches missed.">                    int state = (rowIndicies[0] == 0 ? IN_ROW : NOT_IN_ROW);</span>
<span class="nc" id="L7148">                    int j = 0;</span>
<span class="nc" id="L7149">                    int prevRow = -1;</span>
<span class="nc bnc" id="L7150" title="All 2 branches missed.">                    while (j &lt; rowIndicies.length) {</span>
<span class="nc bnc" id="L7151" title="All 3 branches missed.">                        switch (state) {</span>

                        case IN_ROW:   // on individual row full of selections
<span class="nc bnc" id="L7154" title="All 2 branches missed.">                            if (curIndex &lt; ttlCols) { // it's here!</span>
<span class="nc" id="L7155">                                c = curIndex % ttlCols;</span>
<span class="nc" id="L7156">                                r = rowIndicies[j];</span>
<span class="nc" id="L7157">                                return getAccessibleChild((r * ttlCols) + c);</span>
                            } else {                               // not here
<span class="nc" id="L7159">                                curIndex -= ttlCols;</span>
                            }
                            // is the next row in table selected or not?
<span class="nc bnc" id="L7162" title="All 4 branches missed.">                            if (j + 1 == rowIndicies.length ||</span>
                                rowIndicies[j] != rowIndicies[j+1] - 1) {
<span class="nc" id="L7164">                                state = NOT_IN_ROW;</span>
<span class="nc" id="L7165">                                prevRow = rowIndicies[j];</span>
                            }
<span class="nc" id="L7167">                            j++;  // we didn't return earlier, so go to next row</span>
<span class="nc" id="L7168">                            break;</span>

                        case NOT_IN_ROW:  // sparse bunch of rows of selections
<span class="nc bnc" id="L7171" title="All 4 branches missed.">                            if (curIndex &lt;</span>
                                (colsSel * (rowIndicies[j] -
                                (prevRow == -1 ? 0 : (prevRow + 1))))) {

                                // it's here!
<span class="nc" id="L7176">                                c = colIndicies[curIndex % colsSel];</span>
<span class="nc bnc" id="L7177" title="All 2 branches missed.">                                r = (j &gt; 0 ? rowIndicies[j-1] + 1 : 0)</span>
                                    + curIndex / colsSel;
<span class="nc" id="L7179">                                return getAccessibleChild((r * ttlCols) + c);</span>
                            } else {                               // not here
<span class="nc bnc" id="L7181" title="All 2 branches missed.">                                curIndex -= colsSel * (rowIndicies[j] -</span>
                                (prevRow == -1 ? 0 : (prevRow + 1)));
                            }
<span class="nc" id="L7184">                            state = IN_ROW;</span>
<span class="nc" id="L7185">                            break;</span>
                        }
                    }
                    // we got here, so we didn't find it yet; find it in
                    // the last sparse bunch of rows
<span class="nc bnc" id="L7190" title="All 4 branches missed.">                    if (curIndex &lt;</span>
                        (colsSel * (ttlRows -
                        (prevRow == -1 ? 0 : (prevRow + 1))))) { // it's here!
<span class="nc" id="L7193">                        c = colIndicies[curIndex % colsSel];</span>
<span class="nc" id="L7194">                        r = rowIndicies[j-1] + curIndex / colsSel + 1;</span>
<span class="nc" id="L7195">                        return getAccessibleChild((r * ttlCols) + c);</span>
                    } else {                               // not here
                        // we shouldn't get to this spot in the code!
//                      System.out.println(&quot;Bug in AccessibleJTable.getAccessibleSelection()&quot;);
                    }

                // one or more rows selected
<span class="nc bnc" id="L7202" title="All 2 branches missed.">                } else if (JTable.this.getRowSelectionAllowed()) {</span>
<span class="nc" id="L7203">                    c = i % ttlCols;</span>
<span class="nc" id="L7204">                    r = rowIndicies[i / ttlCols];</span>
<span class="nc" id="L7205">                    return getAccessibleChild((r * ttlCols) + c);</span>

                // one or more columns selected
<span class="nc bnc" id="L7208" title="All 2 branches missed.">                } else if (JTable.this.getColumnSelectionAllowed()) {</span>
<span class="nc" id="L7209">                    c = colIndicies[i % colsSel];</span>
<span class="nc" id="L7210">                    r = i / colsSel;</span>
<span class="nc" id="L7211">                    return getAccessibleChild((r * ttlCols) + c);</span>
                }
            }
<span class="nc" id="L7214">            return null;</span>
        }

        /**
         * Determines if the current child of this object is selected.
         *
         * @param i the zero-based index of the child in this
         *    &lt;code&gt;Accessible&lt;/code&gt; object
         * @return true if the current child of this object is selected
         * @see AccessibleContext#getAccessibleChild
         */
        public boolean isAccessibleChildSelected(int i) {
<span class="nc" id="L7226">            int column = getAccessibleColumnAtIndex(i);</span>
<span class="nc" id="L7227">            int row = getAccessibleRowAtIndex(i);</span>
<span class="nc" id="L7228">            return JTable.this.isCellSelected(row, column);</span>
        }

        /**
         * Adds the specified &lt;code&gt;Accessible&lt;/code&gt; child of the
         * object to the object's selection.  If the object supports
         * multiple selections, the specified child is added to
         * any existing selection, otherwise
         * it replaces any existing selection in the object.  If the
         * specified child is already selected, this method has no effect.
         * &lt;p&gt;
         * This method only works on &lt;code&gt;JTable&lt;/code&gt;s which have
         * individual cell selection enabled.
         *
         * @param i the zero-based index of the child
         * @see AccessibleContext#getAccessibleChild
         */
        public void addAccessibleSelection(int i) {
            // TIGER - 4495286
<span class="nc" id="L7247">            int column = getAccessibleColumnAtIndex(i);</span>
<span class="nc" id="L7248">            int row = getAccessibleRowAtIndex(i);</span>
<span class="nc" id="L7249">            JTable.this.changeSelection(row, column, true, false);</span>
<span class="nc" id="L7250">        }</span>

        /**
         * Removes the specified child of the object from the object's
         * selection.  If the specified item isn't currently selected, this
         * method has no effect.
         * &lt;p&gt;
         * This method only works on &lt;code&gt;JTables&lt;/code&gt; which have
         * individual cell selection enabled.
         *
         * @param i the zero-based index of the child
         * @see AccessibleContext#getAccessibleChild
         */
        public void removeAccessibleSelection(int i) {
<span class="nc bnc" id="L7264" title="All 2 branches missed.">            if (JTable.this.cellSelectionEnabled) {</span>
<span class="nc" id="L7265">                int column = getAccessibleColumnAtIndex(i);</span>
<span class="nc" id="L7266">                int row = getAccessibleRowAtIndex(i);</span>
<span class="nc" id="L7267">                JTable.this.removeRowSelectionInterval(row, row);</span>
<span class="nc" id="L7268">                JTable.this.removeColumnSelectionInterval(column, column);</span>
            }
<span class="nc" id="L7270">        }</span>

        /**
         * Clears the selection in the object, so that no children in the
         * object are selected.
         */
        public void clearAccessibleSelection() {
<span class="nc" id="L7277">            JTable.this.clearSelection();</span>
<span class="nc" id="L7278">        }</span>

        /**
         * Causes every child of the object to be selected, but only
         * if the &lt;code&gt;JTable&lt;/code&gt; supports multiple selections,
         * and if individual cell selection is enabled.
         */
        public void selectAllAccessibleSelection() {
<span class="nc bnc" id="L7286" title="All 2 branches missed.">            if (JTable.this.cellSelectionEnabled) {</span>
<span class="nc" id="L7287">                JTable.this.selectAll();</span>
            }
<span class="nc" id="L7289">        }</span>

        // begin AccessibleExtendedTable implementation -------------

        /**
         * Returns the row number of an index in the table.
         *
         * @param index the zero-based index in the table
         * @return the zero-based row of the table if one exists;
         * otherwise -1.
         * @since 1.4
         */
        public int getAccessibleRow(int index) {
<span class="nc" id="L7302">            return getAccessibleRowAtIndex(index);</span>
        }

        /**
         * Returns the column number of an index in the table.
         *
         * @param index the zero-based index in the table
         * @return the zero-based column of the table if one exists;
         * otherwise -1.
         * @since 1.4
         */
        public int getAccessibleColumn(int index) {
<span class="nc" id="L7314">            return getAccessibleColumnAtIndex(index);</span>
        }

        /**
         * Returns the index at a row and column in the table.
         *
         * @param r zero-based row of the table
         * @param c zero-based column of the table
         * @return the zero-based index in the table if one exists;
         * otherwise -1.
         * @since 1.4
         */
        public int getAccessibleIndex(int r, int c) {
<span class="nc" id="L7327">            return getAccessibleIndexAt(r, c);</span>
        }

        // end of AccessibleExtendedTable implementation ------------

        // start of AccessibleTable implementation ------------------

        private Accessible caption;
        private Accessible summary;
        private Accessible [] rowDescription;
        private Accessible [] columnDescription;

        /**
         * Gets the &lt;code&gt;AccessibleTable&lt;/code&gt; associated with this
         * object.  In the implementation of the Java Accessibility
         * API for this class, return this object, which is responsible
         * for implementing the &lt;code&gt;AccessibleTables&lt;/code&gt; interface
         * on behalf of itself.
         *
         * @return this object
         * @since 1.3
         */
        public AccessibleTable getAccessibleTable() {
<span class="nc" id="L7350">            return this;</span>
        }

        /**
         * Returns the caption for the table.
         *
         * @return the caption for the table
         * @since 1.3
         */
        public Accessible getAccessibleCaption() {
<span class="nc" id="L7360">            return this.caption;</span>
        }

        /**
         * Sets the caption for the table.
         *
         * @param a the caption for the table
         * @since 1.3
         */
        public void setAccessibleCaption(Accessible a) {
<span class="nc" id="L7370">            Accessible oldCaption = caption;</span>
<span class="nc" id="L7371">            this.caption = a;</span>
<span class="nc" id="L7372">            firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_CAPTION_CHANGED,</span>
                               oldCaption, this.caption);
<span class="nc" id="L7374">        }</span>

        /**
         * Returns the summary description of the table.
         *
         * @return the summary description of the table
         * @since 1.3
         */
        public Accessible getAccessibleSummary() {
<span class="nc" id="L7383">            return this.summary;</span>
        }

        /**
         * Sets the summary description of the table.
         *
         * @param a the summary description of the table
         * @since 1.3
         */
        public void setAccessibleSummary(Accessible a) {
<span class="nc" id="L7393">            Accessible oldSummary = summary;</span>
<span class="nc" id="L7394">            this.summary = a;</span>
<span class="nc" id="L7395">            firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_SUMMARY_CHANGED,</span>
                               oldSummary, this.summary);
<span class="nc" id="L7397">        }</span>

        /*
         * Returns the total number of rows in this table.
         *
         * @return the total number of rows in this table
         */
        public int getAccessibleRowCount() {
<span class="nc" id="L7405">            return JTable.this.getRowCount();</span>
        }

        /*
         * Returns the total number of columns in the table.
         *
         * @return the total number of columns in the table
         */
        public int getAccessibleColumnCount() {
<span class="nc" id="L7414">            return JTable.this.getColumnCount();</span>
        }

        /*
         * Returns the &lt;code&gt;Accessible&lt;/code&gt; at a specified row
         * and column in the table.
         *
         * @param r zero-based row of the table
         * @param c zero-based column of the table
         * @return the &lt;code&gt;Accessible&lt;/code&gt; at the specified row and column
         * in the table
         */
        public Accessible getAccessibleAt(int r, int c) {
<span class="nc" id="L7427">            return getAccessibleChild((r * getAccessibleColumnCount()) + c);</span>
        }

        /**
         * Returns the number of rows occupied by the &lt;code&gt;Accessible&lt;/code&gt;
         * at a specified row and column in the table.
         *
         * @return the number of rows occupied by the &lt;code&gt;Accessible&lt;/code&gt;
         *     at a specified row and column in the table
         * @since 1.3
         */
        public int getAccessibleRowExtentAt(int r, int c) {
<span class="nc" id="L7439">            return 1;</span>
        }

        /**
         * Returns the number of columns occupied by the
         * &lt;code&gt;Accessible&lt;/code&gt; at a given (row, column).
         *
         * @return the number of columns occupied by the &lt;code&gt;Accessible&lt;/code&gt;
         *     at a specified row and column in the table
         * @since 1.3
         */
        public int getAccessibleColumnExtentAt(int r, int c) {
<span class="nc" id="L7451">            return 1;</span>
        }

        /**
         * Returns the row headers as an &lt;code&gt;AccessibleTable&lt;/code&gt;.
         *
         * @return an &lt;code&gt;AccessibleTable&lt;/code&gt; representing the row
         * headers
         * @since 1.3
         */
        public AccessibleTable getAccessibleRowHeader() {
            // row headers are not supported
<span class="nc" id="L7463">            return null;</span>
        }

        /**
         * Sets the row headers as an &lt;code&gt;AccessibleTable&lt;/code&gt;.
         *
         * @param a an &lt;code&gt;AccessibleTable&lt;/code&gt; representing the row
         *  headers
         * @since 1.3
         */
        public void setAccessibleRowHeader(AccessibleTable a) {
            // row headers are not supported
<span class="nc" id="L7475">        }</span>

        /**
         * Returns the column headers as an &lt;code&gt;AccessibleTable&lt;/code&gt;.
         *
         *  @return an &lt;code&gt;AccessibleTable&lt;/code&gt; representing the column
         *          headers, or &lt;code&gt;null&lt;/code&gt; if the table header is
         *          &lt;code&gt;null&lt;/code&gt;
         * @since 1.3
         */
        public AccessibleTable getAccessibleColumnHeader() {
<span class="nc" id="L7486">            JTableHeader header = JTable.this.getTableHeader();</span>
<span class="nc bnc" id="L7487" title="All 2 branches missed.">            return header == null ? null : new AccessibleTableHeader(header);</span>
        }

        /*
         * Private class representing a table column header
         */
        private class AccessibleTableHeader implements AccessibleTable {
            private JTableHeader header;
            private TableColumnModel headerModel;

<span class="nc" id="L7497">            AccessibleTableHeader(JTableHeader header) {</span>
<span class="nc" id="L7498">                this.header = header;</span>
<span class="nc" id="L7499">                this.headerModel = header.getColumnModel();</span>
<span class="nc" id="L7500">            }</span>

            /**
             * Returns the caption for the table.
             *
             * @return the caption for the table
             */
<span class="nc" id="L7507">            public Accessible getAccessibleCaption() { return null; }</span>


            /**
             * Sets the caption for the table.
             *
             * @param a the caption for the table
             */
<span class="nc" id="L7515">            public void setAccessibleCaption(Accessible a) {}</span>

            /**
             * Returns the summary description of the table.
             *
             * @return the summary description of the table
             */
<span class="nc" id="L7522">            public Accessible getAccessibleSummary() { return null; }</span>

            /**
             * Sets the summary description of the table
             *
             * @param a the summary description of the table
             */
<span class="nc" id="L7529">            public void setAccessibleSummary(Accessible a) {}</span>

            /**
             * Returns the number of rows in the table.
             *
             * @return the number of rows in the table
             */
<span class="nc" id="L7536">            public int getAccessibleRowCount() { return 1; }</span>

            /**
             * Returns the number of columns in the table.
             *
             * @return the number of columns in the table
             */
            public int getAccessibleColumnCount() {
<span class="nc" id="L7544">                return headerModel.getColumnCount();</span>
            }

            /**
             * Returns the Accessible at a specified row and column
             * in the table.
             *
             * @param row zero-based row of the table
             * @param column zero-based column of the table
             * @return the Accessible at the specified row and column
             */
            public Accessible getAccessibleAt(int row, int column) {


                // TIGER - 4715503
<span class="nc" id="L7559">                TableColumn aColumn = headerModel.getColumn(column);</span>
<span class="nc" id="L7560">                TableCellRenderer renderer = aColumn.getHeaderRenderer();</span>
<span class="nc bnc" id="L7561" title="All 2 branches missed.">                if (renderer == null) {</span>
<span class="nc" id="L7562">                    renderer = header.getDefaultRenderer();</span>
                }
<span class="nc" id="L7564">                Component component = renderer.getTableCellRendererComponent(</span>
<span class="nc" id="L7565">                                  header.getTable(),</span>
<span class="nc" id="L7566">                                  aColumn.getHeaderValue(), false, false,</span>
                                  -1, column);

<span class="nc" id="L7569">                return new AccessibleJTableHeaderCell(row, column,</span>
<span class="nc" id="L7570">                                                      JTable.this.getTableHeader(),</span>
                                                      component);
            }

            /**
             * Returns the number of rows occupied by the Accessible at
             * a specified row and column in the table.
             *
             * @return the number of rows occupied by the Accessible at a
             * given specified (row, column)
             */
<span class="nc" id="L7581">            public int getAccessibleRowExtentAt(int r, int c) { return 1; }</span>

            /**
             * Returns the number of columns occupied by the Accessible at
             * a specified row and column in the table.
             *
             * @return the number of columns occupied by the Accessible at a
             * given specified row and column
             */
<span class="nc" id="L7590">            public int getAccessibleColumnExtentAt(int r, int c) { return 1; }</span>

            /**
             * Returns the row headers as an AccessibleTable.
             *
             * @return an AccessibleTable representing the row
             * headers
             */
<span class="nc" id="L7598">            public AccessibleTable getAccessibleRowHeader() { return null; }</span>

            /**
             * Sets the row headers.
             *
             * @param table an AccessibleTable representing the
             * row headers
             */
<span class="nc" id="L7606">            public void setAccessibleRowHeader(AccessibleTable table) {}</span>

            /**
             * Returns the column headers as an AccessibleTable.
             *
             * @return an AccessibleTable representing the column
             * headers
             */
<span class="nc" id="L7614">            public AccessibleTable getAccessibleColumnHeader() { return null; }</span>

            /**
             * Sets the column headers.
             *
             * @param table an AccessibleTable representing the
             * column headers
             * @since 1.3
             */
<span class="nc" id="L7623">            public void setAccessibleColumnHeader(AccessibleTable table) {}</span>

            /**
             * Returns the description of the specified row in the table.
             *
             * @param r zero-based row of the table
             * @return the description of the row
             * @since 1.3
             */
<span class="nc" id="L7632">            public Accessible getAccessibleRowDescription(int r) { return null; }</span>

            /**
             * Sets the description text of the specified row of the table.
             *
             * @param r zero-based row of the table
             * @param a the description of the row
             * @since 1.3
             */
<span class="nc" id="L7641">            public void setAccessibleRowDescription(int r, Accessible a) {}</span>

            /**
             * Returns the description text of the specified column in the table.
             *
             * @param c zero-based column of the table
             * @return the text description of the column
             * @since 1.3
             */
<span class="nc" id="L7650">            public Accessible getAccessibleColumnDescription(int c) { return null; }</span>

            /**
             * Sets the description text of the specified column in the table.
             *
             * @param c zero-based column of the table
             * @param a the text description of the column
             * @since 1.3
             */
<span class="nc" id="L7659">            public void setAccessibleColumnDescription(int c, Accessible a) {}</span>

            /**
             * Returns a boolean value indicating whether the accessible at
             * a specified row and column is selected.
             *
             * @param r zero-based row of the table
             * @param c zero-based column of the table
             * @return the boolean value true if the accessible at the
             * row and column is selected. Otherwise, the boolean value
             * false
             * @since 1.3
             */
<span class="nc" id="L7672">            public boolean isAccessibleSelected(int r, int c) { return false; }</span>

            /**
             * Returns a boolean value indicating whether the specified row
             * is selected.
             *
             * @param r zero-based row of the table
             * @return the boolean value true if the specified row is selected.
             * Otherwise, false.
             * @since 1.3
             */
<span class="nc" id="L7683">            public boolean isAccessibleRowSelected(int r) { return false; }</span>

            /**
             * Returns a boolean value indicating whether the specified column
             * is selected.
             *
             * @param r zero-based column of the table
             * @return the boolean value true if the specified column is selected.
             * Otherwise, false.
             * @since 1.3
             */
<span class="nc" id="L7694">            public boolean isAccessibleColumnSelected(int c) { return false; }</span>

            /**
             * Returns the selected rows in a table.
             *
             * @return an array of selected rows where each element is a
             * zero-based row of the table
             * @since 1.3
             */
<span class="nc" id="L7703">            public int [] getSelectedAccessibleRows() { return new int[0]; }</span>

            /**
             * Returns the selected columns in a table.
             *
             * @return an array of selected columns where each element is a
             * zero-based column of the table
             * @since 1.3
             */
<span class="nc" id="L7712">            public int [] getSelectedAccessibleColumns() { return new int[0]; }</span>
        }


        /**
         * Sets the column headers as an &lt;code&gt;AccessibleTable&lt;/code&gt;.
         *
         * @param a an &lt;code&gt;AccessibleTable&lt;/code&gt; representing the
         * column headers
         * @since 1.3
         */
        public void setAccessibleColumnHeader(AccessibleTable a) {
            // XXX not implemented
<span class="nc" id="L7725">        }</span>

        /**
         * Returns the description of the specified row in the table.
         *
         * @param r zero-based row of the table
         * @return the description of the row
         * @since 1.3
         */
        public Accessible getAccessibleRowDescription(int r) {
<span class="nc bnc" id="L7735" title="All 4 branches missed.">            if (r &lt; 0 || r &gt;= getAccessibleRowCount()) {</span>
<span class="nc" id="L7736">                throw new IllegalArgumentException(Integer.toString(r));</span>
            }
<span class="nc bnc" id="L7738" title="All 2 branches missed.">            if (rowDescription == null) {</span>
<span class="nc" id="L7739">                return null;</span>
            } else {
<span class="nc" id="L7741">                return rowDescription[r];</span>
            }
        }

        /**
         * Sets the description text of the specified row of the table.
         *
         * @param r zero-based row of the table
         * @param a the description of the row
         * @since 1.3
         */
        public void setAccessibleRowDescription(int r, Accessible a) {
<span class="nc bnc" id="L7753" title="All 4 branches missed.">            if (r &lt; 0 || r &gt;= getAccessibleRowCount()) {</span>
<span class="nc" id="L7754">                throw new IllegalArgumentException(Integer.toString(r));</span>
            }
<span class="nc bnc" id="L7756" title="All 2 branches missed.">            if (rowDescription == null) {</span>
<span class="nc" id="L7757">                int numRows = getAccessibleRowCount();</span>
<span class="nc" id="L7758">                rowDescription = new Accessible[numRows];</span>
            }
<span class="nc" id="L7760">            rowDescription[r] = a;</span>
<span class="nc" id="L7761">        }</span>

        /**
         * Returns the description of the specified column in the table.
         *
         * @param c zero-based column of the table
         * @return the description of the column
         * @since 1.3
         */
        public Accessible getAccessibleColumnDescription(int c) {
<span class="nc bnc" id="L7771" title="All 4 branches missed.">            if (c &lt; 0 || c &gt;= getAccessibleColumnCount()) {</span>
<span class="nc" id="L7772">                throw new IllegalArgumentException(Integer.toString(c));</span>
            }
<span class="nc bnc" id="L7774" title="All 2 branches missed.">            if (columnDescription == null) {</span>
<span class="nc" id="L7775">                return null;</span>
            } else {
<span class="nc" id="L7777">                return columnDescription[c];</span>
            }
        }

        /**
         * Sets the description text of the specified column of the table.
         *
         * @param c zero-based column of the table
         * @param a the description of the column
         * @since 1.3
         */
        public void setAccessibleColumnDescription(int c, Accessible a) {
<span class="nc bnc" id="L7789" title="All 4 branches missed.">            if (c &lt; 0 || c &gt;= getAccessibleColumnCount()) {</span>
<span class="nc" id="L7790">                throw new IllegalArgumentException(Integer.toString(c));</span>
            }
<span class="nc bnc" id="L7792" title="All 2 branches missed.">            if (columnDescription == null) {</span>
<span class="nc" id="L7793">                int numColumns = getAccessibleColumnCount();</span>
<span class="nc" id="L7794">                columnDescription = new Accessible[numColumns];</span>
            }
<span class="nc" id="L7796">            columnDescription[c] = a;</span>
<span class="nc" id="L7797">        }</span>

        /**
         * Returns a boolean value indicating whether the accessible at a
         * given (row, column) is selected.
         *
         * @param r zero-based row of the table
         * @param c zero-based column of the table
         * @return the boolean value true if the accessible at (row, column)
         *     is selected; otherwise, the boolean value false
         * @since 1.3
         */
        public boolean isAccessibleSelected(int r, int c) {
<span class="nc" id="L7810">            return JTable.this.isCellSelected(r, c);</span>
        }

        /**
         * Returns a boolean value indicating whether the specified row
         * is selected.
         *
         * @param r zero-based row of the table
         * @return the boolean value true if the specified row is selected;
         *     otherwise, false
         * @since 1.3
         */
        public boolean isAccessibleRowSelected(int r) {
<span class="nc" id="L7823">            return JTable.this.isRowSelected(r);</span>
        }

        /**
         * Returns a boolean value indicating whether the specified column
         * is selected.
         *
         * @param c zero-based column of the table
         * @return the boolean value true if the specified column is selected;
         *     otherwise, false
         * @since 1.3
         */
        public boolean isAccessibleColumnSelected(int c) {
<span class="nc" id="L7836">            return JTable.this.isColumnSelected(c);</span>
        }

        /**
         * Returns the selected rows in a table.
         *
         * @return an array of selected rows where each element is a
         *     zero-based row of the table
         * @since 1.3
         */
        public int [] getSelectedAccessibleRows() {
<span class="nc" id="L7847">            return JTable.this.getSelectedRows();</span>
        }

        /**
         * Returns the selected columns in a table.
         *
         * @return an array of selected columns where each element is a
         *     zero-based column of the table
         * @since 1.3
         */
        public int [] getSelectedAccessibleColumns() {
<span class="nc" id="L7858">            return JTable.this.getSelectedColumns();</span>
        }

        /**
         * Returns the row at a given index into the table.
         *
         * @param i zero-based index into the table
         * @return the row at a given index
         * @since 1.3
         */
        public int getAccessibleRowAtIndex(int i) {
<span class="nc" id="L7869">            int columnCount = getAccessibleColumnCount();</span>
<span class="nc bnc" id="L7870" title="All 2 branches missed.">            if (columnCount == 0) {</span>
<span class="nc" id="L7871">                return -1;</span>
            } else {
<span class="nc" id="L7873">                return (i / columnCount);</span>
            }
        }

        /**
         * Returns the column at a given index into the table.
         *
         * @param i zero-based index into the table
         * @return the column at a given index
         * @since 1.3
         */
        public int getAccessibleColumnAtIndex(int i) {
<span class="nc" id="L7885">            int columnCount = getAccessibleColumnCount();</span>
<span class="nc bnc" id="L7886" title="All 2 branches missed.">            if (columnCount == 0) {</span>
<span class="nc" id="L7887">                return -1;</span>
            } else {
<span class="nc" id="L7889">                return (i % columnCount);</span>
            }
        }

        /**
         * Returns the index at a given (row, column) in the table.
         *
         * @param r zero-based row of the table
         * @param c zero-based column of the table
         * @return the index into the table
         * @since 1.3
         */
        public int getAccessibleIndexAt(int r, int c) {
<span class="nc" id="L7902">            return ((r * getAccessibleColumnCount()) + c);</span>
        }

        // end of AccessibleTable implementation --------------------

        /**
         * The class provides an implementation of the Java Accessibility
         * API appropriate to table cells.
         */
        protected class AccessibleJTableCell extends AccessibleContext
            implements Accessible, AccessibleComponent {

            private JTable parent;
            private int row;
            private int column;
            private int index;

            /**
             *  Constructs an &lt;code&gt;AccessibleJTableHeaderEntry&lt;/code&gt;.
             * @since 1.4
             */
<span class="nc" id="L7923">            public AccessibleJTableCell(JTable t, int r, int c, int i) {</span>
<span class="nc" id="L7924">                parent = t;</span>
<span class="nc" id="L7925">                row = r;</span>
<span class="nc" id="L7926">                column = c;</span>
<span class="nc" id="L7927">                index = i;</span>
<span class="nc" id="L7928">                this.setAccessibleParent(parent);</span>
<span class="nc" id="L7929">            }</span>

            /**
             * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
             * component. In the implementation of the Java Accessibility
             * API for this class, return this object, which is its own
             * &lt;code&gt;AccessibleContext&lt;/code&gt;.
             *
             * @return this object
             */
            public AccessibleContext getAccessibleContext() {
<span class="nc" id="L7940">                return this;</span>
            }

            /**
             * Gets the AccessibleContext for the table cell renderer.
             *
             * @return the &lt;code&gt;AccessibleContext&lt;/code&gt; for the table
             * cell renderer if one exists;
             * otherwise, returns &lt;code&gt;null&lt;/code&gt;.
             * @since 1.6
             */
            protected AccessibleContext getCurrentAccessibleContext() {
<span class="nc" id="L7952">                TableColumn aColumn = getColumnModel().getColumn(column);</span>
<span class="nc" id="L7953">                TableCellRenderer renderer = aColumn.getCellRenderer();</span>
<span class="nc bnc" id="L7954" title="All 2 branches missed.">                if (renderer == null) {</span>
<span class="nc" id="L7955">                    Class&lt;?&gt; columnClass = getColumnClass(column);</span>
<span class="nc" id="L7956">                    renderer = getDefaultRenderer(columnClass);</span>
                }
<span class="nc" id="L7958">                Component component = renderer.getTableCellRendererComponent(</span>
<span class="nc" id="L7959">                                  JTable.this, getValueAt(row, column),</span>
                                  false, false, row, column);
<span class="nc bnc" id="L7961" title="All 2 branches missed.">                if (component instanceof Accessible) {</span>
<span class="nc" id="L7962">                    return component.getAccessibleContext();</span>
                } else {
<span class="nc" id="L7964">                    return null;</span>
                }
            }

            /**
             * Gets the table cell renderer component.
             *
             * @return the table cell renderer component if one exists;
             * otherwise, returns &lt;code&gt;null&lt;/code&gt;.
             * @since 1.6
             */
            protected Component getCurrentComponent() {
<span class="nc" id="L7976">                TableColumn aColumn = getColumnModel().getColumn(column);</span>
<span class="nc" id="L7977">                TableCellRenderer renderer = aColumn.getCellRenderer();</span>
<span class="nc bnc" id="L7978" title="All 2 branches missed.">                if (renderer == null) {</span>
<span class="nc" id="L7979">                    Class&lt;?&gt; columnClass = getColumnClass(column);</span>
<span class="nc" id="L7980">                    renderer = getDefaultRenderer(columnClass);</span>
                }
<span class="nc" id="L7982">                return renderer.getTableCellRendererComponent(</span>
                                  JTable.this, null, false, false,
                                  row, column);
            }

        // AccessibleContext methods

            /**
             * Gets the accessible name of this object.
             *
             * @return the localized name of the object; &lt;code&gt;null&lt;/code&gt;
             *     if this object does not have a name
             */
            public String getAccessibleName() {
<span class="nc" id="L7996">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L7997" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L7998">                    String name = ac.getAccessibleName();</span>
<span class="nc bnc" id="L7999" title="All 4 branches missed.">                    if ((name != null) &amp;&amp; (name != &quot;&quot;)) {</span>
                        // return the cell renderer's AccessibleName
<span class="nc" id="L8001">                        return name;</span>
                    }
                }
<span class="nc bnc" id="L8004" title="All 4 branches missed.">                if ((accessibleName != null) &amp;&amp; (accessibleName != &quot;&quot;)) {</span>
<span class="nc" id="L8005">                    return accessibleName;</span>
                } else {
                    // fall back to the client property
<span class="nc" id="L8008">                    return (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);</span>
                }
            }

            /**
             * Sets the localized accessible name of this object.
             *
             * @param s the new localized name of the object
             */
            public void setAccessibleName(String s) {
<span class="nc" id="L8018">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8019" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8020">                    ac.setAccessibleName(s);</span>
                } else {
<span class="nc" id="L8022">                    super.setAccessibleName(s);</span>
                }
<span class="nc" id="L8024">            }</span>

            //
            // *** should check toolTip text for desc. (needs MouseEvent)
            //
            /**
             * Gets the accessible description of this object.
             *
             * @return the localized description of the object;
             *     &lt;code&gt;null&lt;/code&gt; if this object does not have
             *     a description
             */
            public String getAccessibleDescription() {
<span class="nc" id="L8037">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8038" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8039">                    return ac.getAccessibleDescription();</span>
                } else {
<span class="nc" id="L8041">                    return super.getAccessibleDescription();</span>
                }
            }

            /**
             * Sets the accessible description of this object.
             *
             * @param s the new localized description of the object
             */
            public void setAccessibleDescription(String s) {
<span class="nc" id="L8051">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8052" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8053">                    ac.setAccessibleDescription(s);</span>
                } else {
<span class="nc" id="L8055">                    super.setAccessibleDescription(s);</span>
                }
<span class="nc" id="L8057">            }</span>

            /**
             * Gets the role of this object.
             *
             * @return an instance of &lt;code&gt;AccessibleRole&lt;/code&gt;
             *      describing the role of the object
             * @see AccessibleRole
             */
            public AccessibleRole getAccessibleRole() {
<span class="nc" id="L8067">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8068" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8069">                    return ac.getAccessibleRole();</span>
                } else {
<span class="nc" id="L8071">                    return AccessibleRole.UNKNOWN;</span>
                }
            }

            /**
             * Gets the state set of this object.
             *
             * @return an instance of &lt;code&gt;AccessibleStateSet&lt;/code&gt;
             *     containing the current state set of the object
             * @see AccessibleState
             */
            public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L8083">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc" id="L8084">                AccessibleStateSet as = null;</span>

<span class="nc bnc" id="L8086" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8087">                    as = ac.getAccessibleStateSet();</span>
                }
<span class="nc bnc" id="L8089" title="All 2 branches missed.">                if (as == null) {</span>
<span class="nc" id="L8090">                    as = new AccessibleStateSet();</span>
                }
<span class="nc" id="L8092">                Rectangle rjt = JTable.this.getVisibleRect();</span>
<span class="nc" id="L8093">                Rectangle rcell = JTable.this.getCellRect(row, column, false);</span>
<span class="nc bnc" id="L8094" title="All 2 branches missed.">                if (rjt.intersects(rcell)) {</span>
<span class="nc" id="L8095">                    as.add(AccessibleState.SHOWING);</span>
                } else {
<span class="nc bnc" id="L8097" title="All 2 branches missed.">                    if (as.contains(AccessibleState.SHOWING)) {</span>
<span class="nc" id="L8098">                         as.remove(AccessibleState.SHOWING);</span>
                    }
                }
<span class="nc bnc" id="L8101" title="All 2 branches missed.">                if (parent.isCellSelected(row, column)) {</span>
<span class="nc" id="L8102">                    as.add(AccessibleState.SELECTED);</span>
<span class="nc bnc" id="L8103" title="All 2 branches missed.">                } else if (as.contains(AccessibleState.SELECTED)) {</span>
<span class="nc" id="L8104">                    as.remove(AccessibleState.SELECTED);</span>
                }
<span class="nc bnc" id="L8106" title="All 4 branches missed.">                if ((row == getSelectedRow()) &amp;&amp; (column == getSelectedColumn())) {</span>
<span class="nc" id="L8107">                    as.add(AccessibleState.ACTIVE);</span>
                }
<span class="nc" id="L8109">                as.add(AccessibleState.TRANSIENT);</span>
<span class="nc" id="L8110">                return as;</span>
            }

            /**
             * Gets the &lt;code&gt;Accessible&lt;/code&gt; parent of this object.
             *
             * @return the Accessible parent of this object;
             *     &lt;code&gt;null&lt;/code&gt; if this object does not
             *     have an &lt;code&gt;Accessible&lt;/code&gt; parent
             */
            public Accessible getAccessibleParent() {
<span class="nc" id="L8121">                return parent;</span>
            }

            /**
             * Gets the index of this object in its accessible parent.
             *
             * @return the index of this object in its parent; -1 if this
             *     object does not have an accessible parent
             * @see #getAccessibleParent
             */
            public int getAccessibleIndexInParent() {
<span class="nc" id="L8132">                return index;</span>
            }

            /**
             * Returns the number of accessible children in the object.
             *
             * @return the number of accessible children in the object
             */
            public int getAccessibleChildrenCount() {
<span class="nc" id="L8141">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8142" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8143">                    return ac.getAccessibleChildrenCount();</span>
                } else {
<span class="nc" id="L8145">                    return 0;</span>
                }
            }

            /**
             * Returns the specified &lt;code&gt;Accessible&lt;/code&gt; child of the
             * object.
             *
             * @param i zero-based index of child
             * @return the &lt;code&gt;Accessible&lt;/code&gt; child of the object
             */
            public Accessible getAccessibleChild(int i) {
<span class="nc" id="L8157">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8158" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8159">                    Accessible accessibleChild = ac.getAccessibleChild(i);</span>
<span class="nc" id="L8160">                    ac.setAccessibleParent(this);</span>
<span class="nc" id="L8161">                    return accessibleChild;</span>
                } else {
<span class="nc" id="L8163">                    return null;</span>
                }
            }

            /**
             * Gets the locale of the component. If the component
             * does not have a locale, then the locale of its parent
             * is returned.
             *
             * @return this component's locale; if this component does
             *    not have a locale, the locale of its parent is returned
             * @exception IllegalComponentStateException if the
             *    &lt;code&gt;Component&lt;/code&gt; does not have its own locale
             *    and has not yet been added to a containment hierarchy
             *    such that the locale can be determined from the
             *    containing parent
             * @see #setLocale
             */
            public Locale getLocale() {
<span class="nc" id="L8182">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8183" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8184">                    return ac.getLocale();</span>
                } else {
<span class="nc" id="L8186">                    return null;</span>
                }
            }

            /**
             * Adds a &lt;code&gt;PropertyChangeListener&lt;/code&gt; to the listener list.
             * The listener is registered for all properties.
             *
             * @param l  the &lt;code&gt;PropertyChangeListener&lt;/code&gt;
             *     to be added
             */
            public void addPropertyChangeListener(PropertyChangeListener l) {
<span class="nc" id="L8198">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8199" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8200">                    ac.addPropertyChangeListener(l);</span>
                } else {
<span class="nc" id="L8202">                    super.addPropertyChangeListener(l);</span>
                }
<span class="nc" id="L8204">            }</span>

            /**
             * Removes a &lt;code&gt;PropertyChangeListener&lt;/code&gt; from the
             * listener list. This removes a &lt;code&gt;PropertyChangeListener&lt;/code&gt;
             * that was registered for all properties.
             *
             * @param l  the &lt;code&gt;PropertyChangeListener&lt;/code&gt;
             *    to be removed
             */
            public void removePropertyChangeListener(PropertyChangeListener l) {
<span class="nc" id="L8215">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8216" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8217">                    ac.removePropertyChangeListener(l);</span>
                } else {
<span class="nc" id="L8219">                    super.removePropertyChangeListener(l);</span>
                }
<span class="nc" id="L8221">            }</span>

            /**
             * Gets the &lt;code&gt;AccessibleAction&lt;/code&gt; associated with this
             * object if one exists.  Otherwise returns &lt;code&gt;null&lt;/code&gt;.
             *
             * @return the &lt;code&gt;AccessibleAction&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
             */
            public AccessibleAction getAccessibleAction() {
<span class="nc" id="L8230">                return getCurrentAccessibleContext().getAccessibleAction();</span>
            }

            /**
             * Gets the &lt;code&gt;AccessibleComponent&lt;/code&gt; associated with
             * this object if one exists.  Otherwise returns &lt;code&gt;null&lt;/code&gt;.
             *
             * @return the &lt;code&gt;AccessibleComponent&lt;/code&gt;, or
             *    &lt;code&gt;null&lt;/code&gt;
             */
            public AccessibleComponent getAccessibleComponent() {
<span class="nc" id="L8241">                return this; // to override getBounds()</span>
            }

            /**
             * Gets the &lt;code&gt;AccessibleSelection&lt;/code&gt; associated with
             * this object if one exists.  Otherwise returns &lt;code&gt;null&lt;/code&gt;.
             *
             * @return the &lt;code&gt;AccessibleSelection&lt;/code&gt;, or
             *    &lt;code&gt;null&lt;/code&gt;
             */
            public AccessibleSelection getAccessibleSelection() {
<span class="nc" id="L8252">                return getCurrentAccessibleContext().getAccessibleSelection();</span>
            }

            /**
             * Gets the &lt;code&gt;AccessibleText&lt;/code&gt; associated with this
             * object if one exists.  Otherwise returns &lt;code&gt;null&lt;/code&gt;.
             *
             * @return the &lt;code&gt;AccessibleText&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
             */
            public AccessibleText getAccessibleText() {
<span class="nc" id="L8262">                return getCurrentAccessibleContext().getAccessibleText();</span>
            }

            /**
             * Gets the &lt;code&gt;AccessibleValue&lt;/code&gt; associated with
             * this object if one exists.  Otherwise returns &lt;code&gt;null&lt;/code&gt;.
             *
             * @return the &lt;code&gt;AccessibleValue&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
             */
            public AccessibleValue getAccessibleValue() {
<span class="nc" id="L8272">                return getCurrentAccessibleContext().getAccessibleValue();</span>
            }


        // AccessibleComponent methods

            /**
             * Gets the background color of this object.
             *
             * @return the background color, if supported, of the object;
             *     otherwise, &lt;code&gt;null&lt;/code&gt;
             */
            public Color getBackground() {
<span class="nc" id="L8285">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8286" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8287">                    return ((AccessibleComponent) ac).getBackground();</span>
                } else {
<span class="nc" id="L8289">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8290" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8291">                        return c.getBackground();</span>
                    } else {
<span class="nc" id="L8293">                        return null;</span>
                    }
                }
            }

            /**
             * Sets the background color of this object.
             *
             * @param c the new &lt;code&gt;Color&lt;/code&gt; for the background
             */
            public void setBackground(Color c) {
<span class="nc" id="L8304">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8305" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8306">                    ((AccessibleComponent) ac).setBackground(c);</span>
                } else {
<span class="nc" id="L8308">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L8309" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L8310">                        cp.setBackground(c);</span>
                    }
                }
<span class="nc" id="L8313">            }</span>

            /**
             * Gets the foreground color of this object.
             *
             * @return the foreground color, if supported, of the object;
             *     otherwise, &lt;code&gt;null&lt;/code&gt;
             */
            public Color getForeground() {
<span class="nc" id="L8322">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8323" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8324">                    return ((AccessibleComponent) ac).getForeground();</span>
                } else {
<span class="nc" id="L8326">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8327" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8328">                        return c.getForeground();</span>
                    } else {
<span class="nc" id="L8330">                        return null;</span>
                    }
                }
            }

            /**
             * Sets the foreground color of this object.
             *
             * @param c the new &lt;code&gt;Color&lt;/code&gt; for the foreground
             */
            public void setForeground(Color c) {
<span class="nc" id="L8341">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8342" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8343">                    ((AccessibleComponent) ac).setForeground(c);</span>
                } else {
<span class="nc" id="L8345">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L8346" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L8347">                        cp.setForeground(c);</span>
                    }
                }
<span class="nc" id="L8350">            }</span>

            /**
             * Gets the &lt;code&gt;Cursor&lt;/code&gt; of this object.
             *
             * @return the &lt;code&gt;Cursor&lt;/code&gt;, if supported,
             *    of the object; otherwise, &lt;code&gt;null&lt;/code&gt;
             */
            public Cursor getCursor() {
<span class="nc" id="L8359">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8360" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8361">                    return ((AccessibleComponent) ac).getCursor();</span>
                } else {
<span class="nc" id="L8363">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8364" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8365">                        return c.getCursor();</span>
                    } else {
<span class="nc" id="L8367">                        Accessible ap = getAccessibleParent();</span>
<span class="nc bnc" id="L8368" title="All 2 branches missed.">                        if (ap instanceof AccessibleComponent) {</span>
<span class="nc" id="L8369">                            return ((AccessibleComponent) ap).getCursor();</span>
                        } else {
<span class="nc" id="L8371">                            return null;</span>
                        }
                    }
                }
            }

            /**
             * Sets the &lt;code&gt;Cursor&lt;/code&gt; of this object.
             *
             * @param c the new &lt;code&gt;Cursor&lt;/code&gt; for the object
             */
            public void setCursor(Cursor c) {
<span class="nc" id="L8383">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8384" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8385">                    ((AccessibleComponent) ac).setCursor(c);</span>
                } else {
<span class="nc" id="L8387">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L8388" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L8389">                        cp.setCursor(c);</span>
                    }
                }
<span class="nc" id="L8392">            }</span>

            /**
             * Gets the &lt;code&gt;Font&lt;/code&gt; of this object.
             *
             * @return the &lt;code&gt;Font&lt;/code&gt;,if supported,
             *   for the object; otherwise, &lt;code&gt;null&lt;/code&gt;
             */
            public Font getFont() {
<span class="nc" id="L8401">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8402" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8403">                    return ((AccessibleComponent) ac).getFont();</span>
                } else {
<span class="nc" id="L8405">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8406" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8407">                        return c.getFont();</span>
                    } else {
<span class="nc" id="L8409">                        return null;</span>
                    }
                }
            }

            /**
             * Sets the &lt;code&gt;Font&lt;/code&gt; of this object.
             *
             * @param f the new &lt;code&gt;Font&lt;/code&gt; for the object
             */
            public void setFont(Font f) {
<span class="nc" id="L8420">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8421" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8422">                    ((AccessibleComponent) ac).setFont(f);</span>
                } else {
<span class="nc" id="L8424">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8425" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8426">                        c.setFont(f);</span>
                    }
                }
<span class="nc" id="L8429">            }</span>

            /**
             * Gets the &lt;code&gt;FontMetrics&lt;/code&gt; of this object.
             *
             * @param f the &lt;code&gt;Font&lt;/code&gt;
             * @return the &lt;code&gt;FontMetrics&lt;/code&gt; object, if supported;
             *    otherwise &lt;code&gt;null&lt;/code&gt;
             * @see #getFont
             */
            public FontMetrics getFontMetrics(Font f) {
<span class="nc" id="L8440">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8441" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8442">                    return ((AccessibleComponent) ac).getFontMetrics(f);</span>
                } else {
<span class="nc" id="L8444">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8445" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8446">                        return c.getFontMetrics(f);</span>
                    } else {
<span class="nc" id="L8448">                        return null;</span>
                    }
                }
            }

            /**
             * Determines if the object is enabled.
             *
             * @return true if object is enabled; otherwise, false
             */
            public boolean isEnabled() {
<span class="nc" id="L8459">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8460" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8461">                    return ((AccessibleComponent) ac).isEnabled();</span>
                } else {
<span class="nc" id="L8463">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8464" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8465">                        return c.isEnabled();</span>
                    } else {
<span class="nc" id="L8467">                        return false;</span>
                    }
                }
            }

            /**
             * Sets the enabled state of the object.
             *
             * @param b if true, enables this object; otherwise, disables it
             */
            public void setEnabled(boolean b) {
<span class="nc" id="L8478">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8479" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8480">                    ((AccessibleComponent) ac).setEnabled(b);</span>
                } else {
<span class="nc" id="L8482">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8483" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8484">                        c.setEnabled(b);</span>
                    }
                }
<span class="nc" id="L8487">            }</span>

            /**
             * Determines if this object is visible.  Note: this means that the
             * object intends to be visible; however, it may not in fact be
             * showing on the screen because one of the objects that this object
             * is contained by is not visible.  To determine if an object is
             * showing on the screen, use &lt;code&gt;isShowing&lt;/code&gt;.
             *
             * @return true if object is visible; otherwise, false
             */
            public boolean isVisible() {
<span class="nc" id="L8499">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8500" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8501">                    return ((AccessibleComponent) ac).isVisible();</span>
                } else {
<span class="nc" id="L8503">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8504" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8505">                        return c.isVisible();</span>
                    } else {
<span class="nc" id="L8507">                        return false;</span>
                    }
                }
            }

            /**
             * Sets the visible state of the object.
             *
             * @param b if true, shows this object; otherwise, hides it
             */
            public void setVisible(boolean b) {
<span class="nc" id="L8518">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8519" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8520">                    ((AccessibleComponent) ac).setVisible(b);</span>
                } else {
<span class="nc" id="L8522">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8523" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8524">                        c.setVisible(b);</span>
                    }
                }
<span class="nc" id="L8527">            }</span>

            /**
             * Determines if the object is showing.  This is determined
             * by checking the visibility of the object and ancestors
             * of the object.  Note: this will return true even if the
             * object is obscured by another (for example,
             * it happens to be underneath a menu that was pulled down).
             *
             * @return true if the object is showing; otherwise, false
             */
            public boolean isShowing() {
<span class="nc" id="L8539">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8540" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc bnc" id="L8541" title="All 2 branches missed.">                    if (ac.getAccessibleParent() != null) {</span>
<span class="nc" id="L8542">                        return ((AccessibleComponent) ac).isShowing();</span>
                    } else {
                        // Fixes 4529616 - AccessibleJTableCell.isShowing()
                        // returns false when the cell on the screen
                        // if no parent
<span class="nc" id="L8547">                        return isVisible();</span>
                    }
                } else {
<span class="nc" id="L8550">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8551" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8552">                        return c.isShowing();</span>
                    } else {
<span class="nc" id="L8554">                        return false;</span>
                    }
                }
            }

            /**
             * Checks whether the specified point is within this
             * object's bounds, where the point's x and y coordinates
             * are defined to be relative to the coordinate system of
             * the object.
             *
             * @param p the &lt;code&gt;Point&lt;/code&gt; relative to the
             *    coordinate system of the object
             * @return true if object contains &lt;code&gt;Point&lt;/code&gt;;
             *    otherwise false
             */
            public boolean contains(Point p) {
<span class="nc" id="L8571">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8572" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8573">                    Rectangle r = ((AccessibleComponent) ac).getBounds();</span>
<span class="nc" id="L8574">                    return r.contains(p);</span>
                } else {
<span class="nc" id="L8576">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8577" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8578">                        Rectangle r = c.getBounds();</span>
<span class="nc" id="L8579">                        return r.contains(p);</span>
                    } else {
<span class="nc" id="L8581">                        return getBounds().contains(p);</span>
                    }
                }
            }

            /**
             * Returns the location of the object on the screen.
             *
             * @return location of object on screen -- can be
             *    &lt;code&gt;null&lt;/code&gt; if this object is not on the screen
             */
            public Point getLocationOnScreen() {
<span class="nc bnc" id="L8593" title="All 4 branches missed.">                if (parent != null &amp;&amp; parent.isShowing()) {</span>
<span class="nc" id="L8594">                    Point parentLocation = parent.getLocationOnScreen();</span>
<span class="nc" id="L8595">                    Point componentLocation = getLocation();</span>
<span class="nc" id="L8596">                    componentLocation.translate(parentLocation.x, parentLocation.y);</span>
<span class="nc" id="L8597">                    return componentLocation;</span>
                } else {
<span class="nc" id="L8599">                    return null;</span>
                }
            }

            /**
             * Gets the location of the object relative to the parent
             * in the form of a point specifying the object's
             * top-left corner in the screen's coordinate space.
             *
             * @return an instance of &lt;code&gt;Point&lt;/code&gt; representing
             *    the top-left corner of the object's bounds in the
             *    coordinate space of the screen; &lt;code&gt;null&lt;/code&gt; if
             *    this object or its parent are not on the screen
             */
            public Point getLocation() {
<span class="nc bnc" id="L8614" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L8615">                    Rectangle r = parent.getCellRect(row, column, false);</span>
<span class="nc bnc" id="L8616" title="All 2 branches missed.">                    if (r != null) {</span>
<span class="nc" id="L8617">                        return r.getLocation();</span>
                    }
                }
<span class="nc" id="L8620">                return null;</span>
            }

            /**
             * Sets the location of the object relative to the parent.
             */
            public void setLocation(Point p) {
//              if ((parent != null)  &amp;&amp; (parent.contains(p))) {
//                  ensureIndexIsVisible(indexInParent);
//              }
<span class="nc" id="L8630">            }</span>

            public Rectangle getBounds() {
<span class="nc bnc" id="L8633" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L8634">                    return parent.getCellRect(row, column, false);</span>
                } else {
<span class="nc" id="L8636">                    return null;</span>
                }
            }

            public void setBounds(Rectangle r) {
<span class="nc" id="L8641">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8642" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8643">                    ((AccessibleComponent) ac).setBounds(r);</span>
                } else {
<span class="nc" id="L8645">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8646" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8647">                        c.setBounds(r);</span>
                    }
                }
<span class="nc" id="L8650">            }</span>

            public Dimension getSize() {
<span class="nc bnc" id="L8653" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L8654">                    Rectangle r = parent.getCellRect(row, column, false);</span>
<span class="nc bnc" id="L8655" title="All 2 branches missed.">                    if (r != null) {</span>
<span class="nc" id="L8656">                        return r.getSize();</span>
                    }
                }
<span class="nc" id="L8659">                return null;</span>
            }

            public void setSize (Dimension d) {
<span class="nc" id="L8663">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8664" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8665">                    ((AccessibleComponent) ac).setSize(d);</span>
                } else {
<span class="nc" id="L8667">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8668" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8669">                        c.setSize(d);</span>
                    }
                }
<span class="nc" id="L8672">            }</span>

            public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L8675">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8676" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8677">                    return ((AccessibleComponent) ac).getAccessibleAt(p);</span>
                } else {
<span class="nc" id="L8679">                    return null;</span>
                }
            }

            public boolean isFocusTraversable() {
<span class="nc" id="L8684">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8685" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8686">                    return ((AccessibleComponent) ac).isFocusTraversable();</span>
                } else {
<span class="nc" id="L8688">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8689" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8690">                        return c.isFocusTraversable();</span>
                    } else {
<span class="nc" id="L8692">                        return false;</span>
                    }
                }
            }

            public void requestFocus() {
<span class="nc" id="L8698">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8699" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8700">                    ((AccessibleComponent) ac).requestFocus();</span>
                } else {
<span class="nc" id="L8702">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8703" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8704">                        c.requestFocus();</span>
                    }
                }
<span class="nc" id="L8707">            }</span>

            public void addFocusListener(FocusListener l) {
<span class="nc" id="L8710">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8711" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8712">                    ((AccessibleComponent) ac).addFocusListener(l);</span>
                } else {
<span class="nc" id="L8714">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8715" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8716">                        c.addFocusListener(l);</span>
                    }
                }
<span class="nc" id="L8719">            }</span>

            public void removeFocusListener(FocusListener l) {
<span class="nc" id="L8722">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8723" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L8724">                    ((AccessibleComponent) ac).removeFocusListener(l);</span>
                } else {
<span class="nc" id="L8726">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L8727" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L8728">                        c.removeFocusListener(l);</span>
                    }
                }
<span class="nc" id="L8731">            }</span>

        } // inner class AccessibleJTableCell

        // Begin AccessibleJTableHeader ========== // TIGER - 4715503

        /**
         * This class implements accessibility for JTable header cells.
         */
        private class AccessibleJTableHeaderCell extends AccessibleContext
            implements Accessible, AccessibleComponent {

            private int row;
            private int column;
            private JTableHeader parent;
            private Component rendererComponent;

            /**
             * Constructs an &lt;code&gt;AccessibleJTableHeaderEntry&lt;/code&gt; instance.
             *
             * @param row header cell row index
             * @param column header cell column index
             * @param parent header cell parent
             * @param rendererComponent component that renders the header cell
             */
            public AccessibleJTableHeaderCell(int row, int column,
                                              JTableHeader parent,
<span class="nc" id="L8758">                                              Component rendererComponent) {</span>
<span class="nc" id="L8759">                this.row = row;</span>
<span class="nc" id="L8760">                this.column = column;</span>
<span class="nc" id="L8761">                this.parent = parent;</span>
<span class="nc" id="L8762">                this.rendererComponent = rendererComponent;</span>
<span class="nc" id="L8763">                this.setAccessibleParent(parent);</span>
<span class="nc" id="L8764">            }</span>

            /**
             * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
             * component. In the implementation of the Java Accessibility
             * API for this class, return this object, which is its own
             * &lt;code&gt;AccessibleContext&lt;/code&gt;.
             *
             * @return this object
             */
            public AccessibleContext getAccessibleContext() {
<span class="nc" id="L8775">                return this;</span>
            }

            /*
             * Returns the AccessibleContext for the header cell
             * renderer.
             */
            private AccessibleContext getCurrentAccessibleContext() {
<span class="nc" id="L8783">                return rendererComponent.getAccessibleContext();</span>
            }

            /*
             * Returns the component that renders the header cell.
             */
            private Component getCurrentComponent() {
<span class="nc" id="L8790">                return rendererComponent;</span>
            }

            // AccessibleContext methods ==========

            /**
             * Gets the accessible name of this object.
             *
             * @return the localized name of the object; &lt;code&gt;null&lt;/code&gt;
             *     if this object does not have a name
             */
            public String getAccessibleName() {
<span class="nc" id="L8802">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8803" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8804">                    String name = ac.getAccessibleName();</span>
<span class="nc bnc" id="L8805" title="All 4 branches missed.">                    if ((name != null) &amp;&amp; (name != &quot;&quot;)) {</span>
<span class="nc" id="L8806">                        return ac.getAccessibleName();</span>
                    }
                }
<span class="nc bnc" id="L8809" title="All 4 branches missed.">                if ((accessibleName != null) &amp;&amp; (accessibleName != &quot;&quot;)) {</span>
<span class="nc" id="L8810">                    return accessibleName;</span>
                } else {
<span class="nc" id="L8812">                    return null;</span>
                }
            }

            /**
             * Sets the localized accessible name of this object.
             *
             * @param s the new localized name of the object
             */
            public void setAccessibleName(String s) {
<span class="nc" id="L8822">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8823" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8824">                    ac.setAccessibleName(s);</span>
                } else {
<span class="nc" id="L8826">                    super.setAccessibleName(s);</span>
                }
<span class="nc" id="L8828">            }</span>

            /**
             * Gets the accessible description of this object.
             *
             * @return the localized description of the object;
             *     &lt;code&gt;null&lt;/code&gt; if this object does not have
             *     a description
             */
            public String getAccessibleDescription() {
<span class="nc" id="L8838">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8839" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8840">                    return ac.getAccessibleDescription();</span>
                } else {
<span class="nc" id="L8842">                    return super.getAccessibleDescription();</span>
                }
            }

            /**
             * Sets the accessible description of this object.
             *
             * @param s the new localized description of the object
             */
            public void setAccessibleDescription(String s) {
<span class="nc" id="L8852">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8853" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8854">                    ac.setAccessibleDescription(s);</span>
                } else {
<span class="nc" id="L8856">                    super.setAccessibleDescription(s);</span>
                }
<span class="nc" id="L8858">            }</span>

            /**
             * Gets the role of this object.
             *
             * @return an instance of &lt;code&gt;AccessibleRole&lt;/code&gt;
             *      describing the role of the object
             * @see AccessibleRole
             */
            public AccessibleRole getAccessibleRole() {
<span class="nc" id="L8868">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8869" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8870">                    return ac.getAccessibleRole();</span>
                } else {
<span class="nc" id="L8872">                    return AccessibleRole.UNKNOWN;</span>
                }
            }

            /**
             * Gets the state set of this object.
             *
             * @return an instance of &lt;code&gt;AccessibleStateSet&lt;/code&gt;
             *     containing the current state set of the object
             * @see AccessibleState
             */
            public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L8884">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc" id="L8885">                AccessibleStateSet as = null;</span>

<span class="nc bnc" id="L8887" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8888">                    as = ac.getAccessibleStateSet();</span>
                }
<span class="nc bnc" id="L8890" title="All 2 branches missed.">                if (as == null) {</span>
<span class="nc" id="L8891">                    as = new AccessibleStateSet();</span>
                }
<span class="nc" id="L8893">                Rectangle rjt = JTable.this.getVisibleRect();</span>
<span class="nc" id="L8894">                Rectangle rcell = JTable.this.getCellRect(row, column, false);</span>
<span class="nc bnc" id="L8895" title="All 2 branches missed.">                if (rjt.intersects(rcell)) {</span>
<span class="nc" id="L8896">                    as.add(AccessibleState.SHOWING);</span>
                } else {
<span class="nc bnc" id="L8898" title="All 2 branches missed.">                    if (as.contains(AccessibleState.SHOWING)) {</span>
<span class="nc" id="L8899">                         as.remove(AccessibleState.SHOWING);</span>
                    }
                }
<span class="nc bnc" id="L8902" title="All 2 branches missed.">                if (JTable.this.isCellSelected(row, column)) {</span>
<span class="nc" id="L8903">                    as.add(AccessibleState.SELECTED);</span>
<span class="nc bnc" id="L8904" title="All 2 branches missed.">                } else if (as.contains(AccessibleState.SELECTED)) {</span>
<span class="nc" id="L8905">                    as.remove(AccessibleState.SELECTED);</span>
                }
<span class="nc bnc" id="L8907" title="All 4 branches missed.">                if ((row == getSelectedRow()) &amp;&amp; (column == getSelectedColumn())) {</span>
<span class="nc" id="L8908">                    as.add(AccessibleState.ACTIVE);</span>
                }
<span class="nc" id="L8910">                as.add(AccessibleState.TRANSIENT);</span>
<span class="nc" id="L8911">                return as;</span>
            }

            /**
             * Gets the &lt;code&gt;Accessible&lt;/code&gt; parent of this object.
             *
             * @return the Accessible parent of this object;
             *     &lt;code&gt;null&lt;/code&gt; if this object does not
             *     have an &lt;code&gt;Accessible&lt;/code&gt; parent
             */
            public Accessible getAccessibleParent() {
<span class="nc" id="L8922">                return parent;</span>
            }

            /**
             * Gets the index of this object in its accessible parent.
             *
             * @return the index of this object in its parent; -1 if this
             *     object does not have an accessible parent
             * @see #getAccessibleParent
             */
            public int getAccessibleIndexInParent() {
<span class="nc" id="L8933">                return column;</span>
            }

            /**
             * Returns the number of accessible children in the object.
             *
             * @return the number of accessible children in the object
             */
            public int getAccessibleChildrenCount() {
<span class="nc" id="L8942">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8943" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8944">                    return ac.getAccessibleChildrenCount();</span>
                } else {
<span class="nc" id="L8946">                    return 0;</span>
                }
            }

            /**
             * Returns the specified &lt;code&gt;Accessible&lt;/code&gt; child of the
             * object.
             *
             * @param i zero-based index of child
             * @return the &lt;code&gt;Accessible&lt;/code&gt; child of the object
             */
            public Accessible getAccessibleChild(int i) {
<span class="nc" id="L8958">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8959" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8960">                    Accessible accessibleChild = ac.getAccessibleChild(i);</span>
<span class="nc" id="L8961">                    ac.setAccessibleParent(this);</span>
<span class="nc" id="L8962">                    return accessibleChild;</span>
                } else {
<span class="nc" id="L8964">                    return null;</span>
                }
            }

            /**
             * Gets the locale of the component. If the component
             * does not have a locale, then the locale of its parent
             * is returned.
             *
             * @return this component's locale; if this component does
             *    not have a locale, the locale of its parent is returned
             * @exception IllegalComponentStateException if the
             *    &lt;code&gt;Component&lt;/code&gt; does not have its own locale
             *    and has not yet been added to a containment hierarchy
             *    such that the locale can be determined from the
             *    containing parent
             * @see #setLocale
             */
            public Locale getLocale() {
<span class="nc" id="L8983">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L8984" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L8985">                    return ac.getLocale();</span>
                } else {
<span class="nc" id="L8987">                    return null;</span>
                }
            }

            /**
             * Adds a &lt;code&gt;PropertyChangeListener&lt;/code&gt; to the listener list.
             * The listener is registered for all properties.
             *
             * @param l  the &lt;code&gt;PropertyChangeListener&lt;/code&gt;
             *     to be added
             */
            public void addPropertyChangeListener(PropertyChangeListener l) {
<span class="nc" id="L8999">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9000" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L9001">                    ac.addPropertyChangeListener(l);</span>
                } else {
<span class="nc" id="L9003">                    super.addPropertyChangeListener(l);</span>
                }
<span class="nc" id="L9005">            }</span>

            /**
             * Removes a &lt;code&gt;PropertyChangeListener&lt;/code&gt; from the
             * listener list. This removes a &lt;code&gt;PropertyChangeListener&lt;/code&gt;
             * that was registered for all properties.
             *
             * @param l  the &lt;code&gt;PropertyChangeListener&lt;/code&gt;
             *    to be removed
             */
            public void removePropertyChangeListener(PropertyChangeListener l) {
<span class="nc" id="L9016">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9017" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L9018">                    ac.removePropertyChangeListener(l);</span>
                } else {
<span class="nc" id="L9020">                    super.removePropertyChangeListener(l);</span>
                }
<span class="nc" id="L9022">            }</span>

            /**
             * Gets the &lt;code&gt;AccessibleAction&lt;/code&gt; associated with this
             * object if one exists.  Otherwise returns &lt;code&gt;null&lt;/code&gt;.
             *
             * @return the &lt;code&gt;AccessibleAction&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
             */
            public AccessibleAction getAccessibleAction() {
<span class="nc" id="L9031">                return getCurrentAccessibleContext().getAccessibleAction();</span>
            }

            /**
             * Gets the &lt;code&gt;AccessibleComponent&lt;/code&gt; associated with
             * this object if one exists.  Otherwise returns &lt;code&gt;null&lt;/code&gt;.
             *
             * @return the &lt;code&gt;AccessibleComponent&lt;/code&gt;, or
             *    &lt;code&gt;null&lt;/code&gt;
             */
            public AccessibleComponent getAccessibleComponent() {
<span class="nc" id="L9042">                return this; // to override getBounds()</span>
            }

            /**
             * Gets the &lt;code&gt;AccessibleSelection&lt;/code&gt; associated with
             * this object if one exists.  Otherwise returns &lt;code&gt;null&lt;/code&gt;.
             *
             * @return the &lt;code&gt;AccessibleSelection&lt;/code&gt;, or
             *    &lt;code&gt;null&lt;/code&gt;
             */
            public AccessibleSelection getAccessibleSelection() {
<span class="nc" id="L9053">                return getCurrentAccessibleContext().getAccessibleSelection();</span>
            }

            /**
             * Gets the &lt;code&gt;AccessibleText&lt;/code&gt; associated with this
             * object if one exists.  Otherwise returns &lt;code&gt;null&lt;/code&gt;.
             *
             * @return the &lt;code&gt;AccessibleText&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
             */
            public AccessibleText getAccessibleText() {
<span class="nc" id="L9063">                return getCurrentAccessibleContext().getAccessibleText();</span>
            }

            /**
             * Gets the &lt;code&gt;AccessibleValue&lt;/code&gt; associated with
             * this object if one exists.  Otherwise returns &lt;code&gt;null&lt;/code&gt;.
             *
             * @return the &lt;code&gt;AccessibleValue&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
             */
            public AccessibleValue getAccessibleValue() {
<span class="nc" id="L9073">                return getCurrentAccessibleContext().getAccessibleValue();</span>
            }


            // AccessibleComponent methods ==========

            /**
             * Gets the background color of this object.
             *
             * @return the background color, if supported, of the object;
             *     otherwise, &lt;code&gt;null&lt;/code&gt;
             */
            public Color getBackground() {
<span class="nc" id="L9086">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9087" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9088">                    return ((AccessibleComponent) ac).getBackground();</span>
                } else {
<span class="nc" id="L9090">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9091" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9092">                        return c.getBackground();</span>
                    } else {
<span class="nc" id="L9094">                        return null;</span>
                    }
                }
            }

            /**
             * Sets the background color of this object.
             *
             * @param c the new &lt;code&gt;Color&lt;/code&gt; for the background
             */
            public void setBackground(Color c) {
<span class="nc" id="L9105">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9106" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9107">                    ((AccessibleComponent) ac).setBackground(c);</span>
                } else {
<span class="nc" id="L9109">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L9110" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L9111">                        cp.setBackground(c);</span>
                    }
                }
<span class="nc" id="L9114">            }</span>

            /**
             * Gets the foreground color of this object.
             *
             * @return the foreground color, if supported, of the object;
             *     otherwise, &lt;code&gt;null&lt;/code&gt;
             */
            public Color getForeground() {
<span class="nc" id="L9123">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9124" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9125">                    return ((AccessibleComponent) ac).getForeground();</span>
                } else {
<span class="nc" id="L9127">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9128" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9129">                        return c.getForeground();</span>
                    } else {
<span class="nc" id="L9131">                        return null;</span>
                    }
                }
            }

            /**
             * Sets the foreground color of this object.
             *
             * @param c the new &lt;code&gt;Color&lt;/code&gt; for the foreground
             */
            public void setForeground(Color c) {
<span class="nc" id="L9142">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9143" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9144">                    ((AccessibleComponent) ac).setForeground(c);</span>
                } else {
<span class="nc" id="L9146">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L9147" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L9148">                        cp.setForeground(c);</span>
                    }
                }
<span class="nc" id="L9151">            }</span>

            /**
             * Gets the &lt;code&gt;Cursor&lt;/code&gt; of this object.
             *
             * @return the &lt;code&gt;Cursor&lt;/code&gt;, if supported,
             *    of the object; otherwise, &lt;code&gt;null&lt;/code&gt;
             */
            public Cursor getCursor() {
<span class="nc" id="L9160">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9161" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9162">                    return ((AccessibleComponent) ac).getCursor();</span>
                } else {
<span class="nc" id="L9164">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9165" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9166">                        return c.getCursor();</span>
                    } else {
<span class="nc" id="L9168">                        Accessible ap = getAccessibleParent();</span>
<span class="nc bnc" id="L9169" title="All 2 branches missed.">                        if (ap instanceof AccessibleComponent) {</span>
<span class="nc" id="L9170">                            return ((AccessibleComponent) ap).getCursor();</span>
                        } else {
<span class="nc" id="L9172">                            return null;</span>
                        }
                    }
                }
            }

            /**
             * Sets the &lt;code&gt;Cursor&lt;/code&gt; of this object.
             *
             * @param c the new &lt;code&gt;Cursor&lt;/code&gt; for the object
             */
            public void setCursor(Cursor c) {
<span class="nc" id="L9184">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9185" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9186">                    ((AccessibleComponent) ac).setCursor(c);</span>
                } else {
<span class="nc" id="L9188">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L9189" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L9190">                        cp.setCursor(c);</span>
                    }
                }
<span class="nc" id="L9193">            }</span>

            /**
             * Gets the &lt;code&gt;Font&lt;/code&gt; of this object.
             *
             * @return the &lt;code&gt;Font&lt;/code&gt;,if supported,
             *   for the object; otherwise, &lt;code&gt;null&lt;/code&gt;
             */
            public Font getFont() {
<span class="nc" id="L9202">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9203" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9204">                    return ((AccessibleComponent) ac).getFont();</span>
                } else {
<span class="nc" id="L9206">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9207" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9208">                        return c.getFont();</span>
                    } else {
<span class="nc" id="L9210">                        return null;</span>
                    }
                }
            }

            /**
             * Sets the &lt;code&gt;Font&lt;/code&gt; of this object.
             *
             * @param f the new &lt;code&gt;Font&lt;/code&gt; for the object
             */
            public void setFont(Font f) {
<span class="nc" id="L9221">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9222" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9223">                    ((AccessibleComponent) ac).setFont(f);</span>
                } else {
<span class="nc" id="L9225">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9226" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9227">                        c.setFont(f);</span>
                    }
                }
<span class="nc" id="L9230">            }</span>

            /**
             * Gets the &lt;code&gt;FontMetrics&lt;/code&gt; of this object.
             *
             * @param f the &lt;code&gt;Font&lt;/code&gt;
             * @return the &lt;code&gt;FontMetrics&lt;/code&gt; object, if supported;
             *    otherwise &lt;code&gt;null&lt;/code&gt;
             * @see #getFont
             */
            public FontMetrics getFontMetrics(Font f) {
<span class="nc" id="L9241">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9242" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9243">                    return ((AccessibleComponent) ac).getFontMetrics(f);</span>
                } else {
<span class="nc" id="L9245">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9246" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9247">                        return c.getFontMetrics(f);</span>
                    } else {
<span class="nc" id="L9249">                        return null;</span>
                    }
                }
            }

            /**
             * Determines if the object is enabled.
             *
             * @return true if object is enabled; otherwise, false
             */
            public boolean isEnabled() {
<span class="nc" id="L9260">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9261" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9262">                    return ((AccessibleComponent) ac).isEnabled();</span>
                } else {
<span class="nc" id="L9264">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9265" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9266">                        return c.isEnabled();</span>
                    } else {
<span class="nc" id="L9268">                        return false;</span>
                    }
                }
            }

            /**
             * Sets the enabled state of the object.
             *
             * @param b if true, enables this object; otherwise, disables it
             */
            public void setEnabled(boolean b) {
<span class="nc" id="L9279">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9280" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9281">                    ((AccessibleComponent) ac).setEnabled(b);</span>
                } else {
<span class="nc" id="L9283">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9284" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9285">                        c.setEnabled(b);</span>
                    }
                }
<span class="nc" id="L9288">            }</span>

            /**
             * Determines if this object is visible.  Note: this means that the
             * object intends to be visible; however, it may not in fact be
             * showing on the screen because one of the objects that this object
             * is contained by is not visible.  To determine if an object is
             * showing on the screen, use &lt;code&gt;isShowing&lt;/code&gt;.
             *
             * @return true if object is visible; otherwise, false
             */
            public boolean isVisible() {
<span class="nc" id="L9300">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9301" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9302">                    return ((AccessibleComponent) ac).isVisible();</span>
                } else {
<span class="nc" id="L9304">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9305" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9306">                        return c.isVisible();</span>
                    } else {
<span class="nc" id="L9308">                        return false;</span>
                    }
                }
            }

            /**
             * Sets the visible state of the object.
             *
             * @param b if true, shows this object; otherwise, hides it
             */
            public void setVisible(boolean b) {
<span class="nc" id="L9319">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9320" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9321">                    ((AccessibleComponent) ac).setVisible(b);</span>
                } else {
<span class="nc" id="L9323">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9324" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9325">                        c.setVisible(b);</span>
                    }
                }
<span class="nc" id="L9328">            }</span>

            /**
             * Determines if the object is showing.  This is determined
             * by checking the visibility of the object and ancestors
             * of the object.  Note: this will return true even if the
             * object is obscured by another (for example,
             * it happens to be underneath a menu that was pulled down).
             *
             * @return true if the object is showing; otherwise, false
             */
            public boolean isShowing() {
<span class="nc" id="L9340">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9341" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc bnc" id="L9342" title="All 2 branches missed.">                    if (ac.getAccessibleParent() != null) {</span>
<span class="nc" id="L9343">                        return ((AccessibleComponent) ac).isShowing();</span>
                    } else {
                        // Fixes 4529616 - AccessibleJTableCell.isShowing()
                        // returns false when the cell on the screen
                        // if no parent
<span class="nc" id="L9348">                        return isVisible();</span>
                    }
                } else {
<span class="nc" id="L9351">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9352" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9353">                        return c.isShowing();</span>
                    } else {
<span class="nc" id="L9355">                        return false;</span>
                    }
                }
            }

            /**
             * Checks whether the specified point is within this
             * object's bounds, where the point's x and y coordinates
             * are defined to be relative to the coordinate system of
             * the object.
             *
             * @param p the &lt;code&gt;Point&lt;/code&gt; relative to the
             *    coordinate system of the object
             * @return true if object contains &lt;code&gt;Point&lt;/code&gt;;
             *    otherwise false
             */
            public boolean contains(Point p) {
<span class="nc" id="L9372">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9373" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9374">                    Rectangle r = ((AccessibleComponent) ac).getBounds();</span>
<span class="nc" id="L9375">                    return r.contains(p);</span>
                } else {
<span class="nc" id="L9377">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9378" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9379">                        Rectangle r = c.getBounds();</span>
<span class="nc" id="L9380">                        return r.contains(p);</span>
                    } else {
<span class="nc" id="L9382">                        return getBounds().contains(p);</span>
                    }
                }
            }

            /**
             * Returns the location of the object on the screen.
             *
             * @return location of object on screen -- can be
             *    &lt;code&gt;null&lt;/code&gt; if this object is not on the screen
             */
            public Point getLocationOnScreen() {
<span class="nc bnc" id="L9394" title="All 4 branches missed.">                if (parent != null &amp;&amp; parent.isShowing()) {</span>
<span class="nc" id="L9395">                    Point parentLocation = parent.getLocationOnScreen();</span>
<span class="nc" id="L9396">                    Point componentLocation = getLocation();</span>
<span class="nc" id="L9397">                    componentLocation.translate(parentLocation.x, parentLocation.y);</span>
<span class="nc" id="L9398">                    return componentLocation;</span>
                } else {
<span class="nc" id="L9400">                    return null;</span>
                }
            }

            /**
             * Gets the location of the object relative to the parent
             * in the form of a point specifying the object's
             * top-left corner in the screen's coordinate space.
             *
             * @return an instance of &lt;code&gt;Point&lt;/code&gt; representing
             *    the top-left corner of the object's bounds in the
             *    coordinate space of the screen; &lt;code&gt;null&lt;/code&gt; if
             *    this object or its parent are not on the screen
             */
            public Point getLocation() {
<span class="nc bnc" id="L9415" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L9416">                    Rectangle r = parent.getHeaderRect(column);</span>
<span class="nc bnc" id="L9417" title="All 2 branches missed.">                    if (r != null) {</span>
<span class="nc" id="L9418">                        return r.getLocation();</span>
                    }
                }
<span class="nc" id="L9421">                return null;</span>
            }

            /**
             * Sets the location of the object relative to the parent.
             * @param p the new position for the top-left corner
             * @see #getLocation
             */
            public void setLocation(Point p) {
<span class="nc" id="L9430">            }</span>

            /**
             * Gets the bounds of this object in the form of a Rectangle object.
             * The bounds specify this object's width, height, and location
             * relative to its parent.
             *
             * @return A rectangle indicating this component's bounds; null if
             * this object is not on the screen.
             * @see #contains
             */
            public Rectangle getBounds() {
<span class="nc bnc" id="L9442" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L9443">                    return parent.getHeaderRect(column);</span>
                } else {
<span class="nc" id="L9445">                    return null;</span>
                }
            }

            /**
             * Sets the bounds of this object in the form of a Rectangle object.
             * The bounds specify this object's width, height, and location
             * relative to its parent.
             *
             * @param r rectangle indicating this component's bounds
             * @see #getBounds
             */
            public void setBounds(Rectangle r) {
<span class="nc" id="L9458">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9459" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9460">                    ((AccessibleComponent) ac).setBounds(r);</span>
                } else {
<span class="nc" id="L9462">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9463" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9464">                        c.setBounds(r);</span>
                    }
                }
<span class="nc" id="L9467">            }</span>

            /**
             * Returns the size of this object in the form of a Dimension object.
             * The height field of the Dimension object contains this object's
             * height, and the width field of the Dimension object contains this
             * object's width.
             *
             * @return A Dimension object that indicates the size of this component;
             * null if this object is not on the screen
             * @see #setSize
             */
            public Dimension getSize() {
<span class="nc bnc" id="L9480" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L9481">                    Rectangle r = parent.getHeaderRect(column);</span>
<span class="nc bnc" id="L9482" title="All 2 branches missed.">                    if (r != null) {</span>
<span class="nc" id="L9483">                        return r.getSize();</span>
                    }
                }
<span class="nc" id="L9486">                return null;</span>
            }

            /**
             * Resizes this object so that it has width and height.
             *
             * @param d The dimension specifying the new size of the object.
             * @see #getSize
             */
            public void setSize (Dimension d) {
<span class="nc" id="L9496">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9497" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9498">                    ((AccessibleComponent) ac).setSize(d);</span>
                } else {
<span class="nc" id="L9500">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9501" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9502">                        c.setSize(d);</span>
                    }
                }
<span class="nc" id="L9505">            }</span>

            /**
             * Returns the Accessible child, if one exists, contained at the local
             * coordinate Point.
             *
             * @param p The point relative to the coordinate system of this object.
             * @return the Accessible, if it exists, at the specified location;
             * otherwise null
             */
            public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L9516">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9517" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9518">                    return ((AccessibleComponent) ac).getAccessibleAt(p);</span>
                } else {
<span class="nc" id="L9520">                    return null;</span>
                }
            }

            /**
             * Returns whether this object can accept focus or not.   Objects that
             * can accept focus will also have the AccessibleState.FOCUSABLE state
             * set in their AccessibleStateSets.
             *
             * @return true if object can accept focus; otherwise false
             * @see AccessibleContext#getAccessibleStateSet
             * @see AccessibleState#FOCUSABLE
             * @see AccessibleState#FOCUSED
             * @see AccessibleStateSet
             */
            public boolean isFocusTraversable() {
<span class="nc" id="L9536">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9537" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9538">                    return ((AccessibleComponent) ac).isFocusTraversable();</span>
                } else {
<span class="nc" id="L9540">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9541" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9542">                        return c.isFocusTraversable();</span>
                    } else {
<span class="nc" id="L9544">                        return false;</span>
                    }
                }
            }

            /**
             * Requests focus for this object.  If this object cannot accept focus,
             * nothing will happen.  Otherwise, the object will attempt to take
             * focus.
             * @see #isFocusTraversable
             */
            public void requestFocus() {
<span class="nc" id="L9556">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9557" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9558">                    ((AccessibleComponent) ac).requestFocus();</span>
                } else {
<span class="nc" id="L9560">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9561" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9562">                        c.requestFocus();</span>
                    }
                }
<span class="nc" id="L9565">            }</span>

            /**
             * Adds the specified focus listener to receive focus events from this
             * component.
             *
             * @param l the focus listener
             * @see #removeFocusListener
             */
            public void addFocusListener(FocusListener l) {
<span class="nc" id="L9575">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9576" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9577">                    ((AccessibleComponent) ac).addFocusListener(l);</span>
                } else {
<span class="nc" id="L9579">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9580" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9581">                        c.addFocusListener(l);</span>
                    }
                }
<span class="nc" id="L9584">            }</span>

            /**
             * Removes the specified focus listener so it no longer receives focus
             * events from this component.
             *
             * @param l the focus listener
             * @see #addFocusListener
             */
            public void removeFocusListener(FocusListener l) {
<span class="nc" id="L9594">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L9595" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L9596">                    ((AccessibleComponent) ac).removeFocusListener(l);</span>
                } else {
<span class="nc" id="L9598">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L9599" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L9600">                        c.removeFocusListener(l);</span>
                    }
                }
<span class="nc" id="L9603">            }</span>

        } // inner class AccessibleJTableHeaderCell

    }  // inner class AccessibleJTable

}  // End of Class JTable
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>