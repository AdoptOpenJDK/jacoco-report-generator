<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Spring.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">Spring.java</span></div><h1>Spring.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.awt.Component;

/**
 *  An instance of the &lt;code&gt;Spring&lt;/code&gt; class holds three properties that
 *  characterize its behavior: the &lt;em&gt;minimum&lt;/em&gt;, &lt;em&gt;preferred&lt;/em&gt;, and
 *  &lt;em&gt;maximum&lt;/em&gt; values. Each of these properties may be involved in
 *  defining its fourth, &lt;em&gt;value&lt;/em&gt;, property based on a series of rules.
 *  &lt;p&gt;
 *  An instance of the &lt;code&gt;Spring&lt;/code&gt; class can be visualized as a
 *  mechanical spring that provides a corrective force as the spring is compressed
 *  or stretched away from its preferred value. This force is modelled
 *  as linear function of the distance from the preferred value, but with
 *  two different constants -- one for the compressional force and one for the
 *  tensional one. Those constants are specified by the minimum and maximum
 *  values of the spring such that a spring at its minimum value produces an
 *  equal and opposite force to that which is created when it is at its
 *  maximum value. The difference between the &lt;em&gt;preferred&lt;/em&gt; and
 *  &lt;em&gt;minimum&lt;/em&gt; values, therefore, represents the ease with which the
 *  spring can be compressed and the difference between its &lt;em&gt;maximum&lt;/em&gt;
 *  and &lt;em&gt;preferred&lt;/em&gt; values, indicates the ease with which the
 *  &lt;code&gt;Spring&lt;/code&gt; can be extended.
 *  See the {@link #sum} method for details.
 *
 *  &lt;p&gt;
 *  By defining simple arithmetic operations on &lt;code&gt;Spring&lt;/code&gt;s,
 *  the behavior of a collection of &lt;code&gt;Spring&lt;/code&gt;s
 *  can be reduced to that of an ordinary (non-compound) &lt;code&gt;Spring&lt;/code&gt;. We define
 *  the &quot;+&quot;, &quot;-&quot;, &lt;em&gt;max&lt;/em&gt;, and &lt;em&gt;min&lt;/em&gt; operators on
 *  &lt;code&gt;Spring&lt;/code&gt;s so that, in each case, the result is a &lt;code&gt;Spring&lt;/code&gt;
 *  whose characteristics bear a useful mathematical relationship to its constituent
 *  springs.
 *
 *  &lt;p&gt;
 *  A &lt;code&gt;Spring&lt;/code&gt; can be treated as a pair of intervals
 *  with a single common point: the preferred value.
 *  The following rules define some of the
 *  arithmetic operators that can be applied to intervals
 *  (&lt;code&gt;[a, b]&lt;/code&gt; refers to the interval
 *  from &lt;code&gt;a&lt;/code&gt;
 *  to &lt;code&gt;b&lt;/code&gt;,
 *  where &lt;code&gt;a &amp;lt;= b&lt;/code&gt;).
 *  &lt;p&gt;
 *  &lt;pre&gt;
 *          [a1, b1] + [a2, b2] = [a1 + a2, b1 + b2]
 *
 *                      -[a, b] = [-b, -a]
 *
 *      max([a1, b1], [a2, b2]) = [max(a1, a2), max(b1, b2)]
 *  &lt;/pre&gt;
 *  &lt;p&gt;
 *
 *  If we denote &lt;code&gt;Spring&lt;/code&gt;s as &lt;code&gt;[a, b, c]&lt;/code&gt;,
 *  where &lt;code&gt;a &amp;lt;= b &amp;lt;= c&lt;/code&gt;, we can define the same
 *  arithmetic operators on &lt;code&gt;Spring&lt;/code&gt;s:
 *  &lt;p&gt;
 *  &lt;pre&gt;
 *          [a1, b1, c1] + [a2, b2, c2] = [a1 + a2, b1 + b2, c1 + c2]
 *
 *                           -[a, b, c] = [-c, -b, -a]
 *
 *      max([a1, b1, c1], [a2, b2, c2]) = [max(a1, a2), max(b1, b2), max(c1, c2)]
 *  &lt;/pre&gt;
 *  &lt;p&gt;
 *  With both intervals and &lt;code&gt;Spring&lt;/code&gt;s we can define &quot;-&quot; and &lt;em&gt;min&lt;/em&gt;
 *  in terms of negation:
 *  &lt;p&gt;
 *  &lt;pre&gt;
 *      X - Y = X + (-Y)
 *
 *      min(X, Y) = -max(-X, -Y)
 *  &lt;/pre&gt;
 *  &lt;p&gt;
 *  For the static methods in this class that embody the arithmetic
 *  operators, we do not actually perform the operation in question as
 *  that would snapshot the values of the properties of the method's arguments
 *  at the time the static method is called. Instead, the static methods
 *  create a new &lt;code&gt;Spring&lt;/code&gt; instance containing references to
 *  the method's arguments so that the characteristics of the new spring track the
 *  potentially changing characteristics of the springs from which it
 *  was made. This is a little like the idea of a &lt;em&gt;lazy value&lt;/em&gt;
 *  in a functional language.
 * &lt;p&gt;
 * If you are implementing a &lt;code&gt;SpringLayout&lt;/code&gt; you
 * can find further information and examples in
 * &lt;a
 href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/spring.html&quot;&gt;How to Use SpringLayout&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @see SpringLayout
 * @see SpringLayout.Constraints
 *
 * @author      Philip Milne
 * @since       1.4
 */
public abstract class Spring {

    /**
     * An integer value signifying that a property value has not yet been calculated.
     */
    public static final int UNSET = Integer.MIN_VALUE;

    /**
     * Used by factory methods to create a &lt;code&gt;Spring&lt;/code&gt;.
     *
     * @see #constant(int)
     * @see #constant(int, int, int)
     * @see #max
     * @see #minus
     * @see #sum
     * @see SpringLayout.Constraints
     */
<span class="nc" id="L147">    protected Spring() {}</span>

    /**
     * Returns the &lt;em&gt;minimum&lt;/em&gt; value of this &lt;code&gt;Spring&lt;/code&gt;.
     *
     * @return the &lt;code&gt;minimumValue&lt;/code&gt; property of this &lt;code&gt;Spring&lt;/code&gt;
     */
    public abstract int getMinimumValue();

    /**
     * Returns the &lt;em&gt;preferred&lt;/em&gt; value of this &lt;code&gt;Spring&lt;/code&gt;.
     *
     * @return the &lt;code&gt;preferredValue&lt;/code&gt; of this &lt;code&gt;Spring&lt;/code&gt;
     */
    public abstract int getPreferredValue();

    /**
     * Returns the &lt;em&gt;maximum&lt;/em&gt; value of this &lt;code&gt;Spring&lt;/code&gt;.
     *
     * @return the &lt;code&gt;maximumValue&lt;/code&gt; property of this &lt;code&gt;Spring&lt;/code&gt;
     */
    public abstract int getMaximumValue();

    /**
     * Returns the current &lt;em&gt;value&lt;/em&gt; of this &lt;code&gt;Spring&lt;/code&gt;.
     *
     * @return  the &lt;code&gt;value&lt;/code&gt; property of this &lt;code&gt;Spring&lt;/code&gt;
     *
     * @see #setValue
     */
    public abstract int getValue();

    /**
     * Sets the current &lt;em&gt;value&lt;/em&gt; of this &lt;code&gt;Spring&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;.
     *
     * @param   value the new setting of the &lt;code&gt;value&lt;/code&gt; property
     *
     * @see #getValue
     */
    public abstract void setValue(int value);

    private double range(boolean contract) {
<span class="nc bnc" id="L189" title="All 2 branches missed.">        return contract ? (getPreferredValue() - getMinimumValue()) :</span>
<span class="nc" id="L190">                          (getMaximumValue() - getPreferredValue());</span>
    }

    /*pp*/ double getStrain() {
<span class="nc" id="L194">        double delta = (getValue() - getPreferredValue());</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        return delta/range(getValue() &lt; getPreferredValue());</span>
    }

    /*pp*/ void setStrain(double strain) {
<span class="nc bnc" id="L199" title="All 2 branches missed.">        setValue(getPreferredValue() + (int)(strain * range(strain &lt; 0)));</span>
<span class="nc" id="L200">    }</span>

    /*pp*/ boolean isCyclic(SpringLayout l) {
<span class="nc" id="L203">        return false;</span>
    }

<span class="nc" id="L206">    /*pp*/ static abstract class AbstractSpring extends Spring {</span>
<span class="nc" id="L207">        protected int size = UNSET;</span>

        public int getValue() {
<span class="nc bnc" id="L210" title="All 2 branches missed.">            return size != UNSET ? size : getPreferredValue();</span>
        }

        public final void setValue(int size) {
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if (this.size == size) {</span>
<span class="nc" id="L215">                return;</span>
            }
<span class="nc bnc" id="L217" title="All 2 branches missed.">            if (size == UNSET) {</span>
<span class="nc" id="L218">                clear();</span>
            } else {
<span class="nc" id="L220">                setNonClearValue(size);</span>
            }
<span class="nc" id="L222">        }</span>

        protected void clear() {
<span class="nc" id="L225">            size = UNSET;</span>
<span class="nc" id="L226">        }</span>

        protected void setNonClearValue(int size) {
<span class="nc" id="L229">            this.size = size;</span>
<span class="nc" id="L230">        }</span>
    }

    private static class StaticSpring extends AbstractSpring {
        protected int min;
        protected int pref;
        protected int max;

        public StaticSpring(int pref) {
<span class="nc" id="L239">            this(pref, pref, pref);</span>
<span class="nc" id="L240">        }</span>

<span class="nc" id="L242">        public StaticSpring(int min, int pref, int max) {</span>
<span class="nc" id="L243">            this.min = min;</span>
<span class="nc" id="L244">            this.pref = pref;</span>
<span class="nc" id="L245">            this.max = max;</span>
<span class="nc" id="L246">        }</span>

         public String toString() {
<span class="nc" id="L249">             return &quot;StaticSpring [&quot; + min + &quot;, &quot; + pref + &quot;, &quot; + max + &quot;]&quot;;</span>
         }

         public int getMinimumValue() {
<span class="nc" id="L253">            return min;</span>
        }

        public int getPreferredValue() {
<span class="nc" id="L257">            return pref;</span>
        }

        public int getMaximumValue() {
<span class="nc" id="L261">            return max;</span>
        }
    }

    private static class NegativeSpring extends Spring {
        private Spring s;

<span class="nc" id="L268">        public NegativeSpring(Spring s) {</span>
<span class="nc" id="L269">            this.s = s;</span>
<span class="nc" id="L270">        }</span>

// Note the use of max value rather than minimum value here.
// See the opening preamble on arithmetic with springs.

        public int getMinimumValue() {
<span class="nc" id="L276">            return -s.getMaximumValue();</span>
        }

        public int getPreferredValue() {
<span class="nc" id="L280">            return -s.getPreferredValue();</span>
        }

        public int getMaximumValue() {
<span class="nc" id="L284">            return -s.getMinimumValue();</span>
        }

        public int getValue() {
<span class="nc" id="L288">            return -s.getValue();</span>
        }

        public void setValue(int size) {
            // No need to check for UNSET as
            // Integer.MIN_VALUE == -Integer.MIN_VALUE.
<span class="nc" id="L294">            s.setValue(-size);</span>
<span class="nc" id="L295">        }</span>

        /*pp*/ boolean isCyclic(SpringLayout l) {
<span class="nc" id="L298">            return s.isCyclic(l);</span>
        }
    }

    private static class ScaleSpring extends Spring {
        private Spring s;
        private float factor;

<span class="nc" id="L306">        private ScaleSpring(Spring s, float factor) {</span>
<span class="nc" id="L307">            this.s = s;</span>
<span class="nc" id="L308">            this.factor = factor;</span>
<span class="nc" id="L309">        }</span>

        public int getMinimumValue() {
<span class="nc bnc" id="L312" title="All 2 branches missed.">            return Math.round((factor &lt; 0 ? s.getMaximumValue() : s.getMinimumValue()) * factor);</span>
        }

        public int getPreferredValue() {
<span class="nc" id="L316">            return Math.round(s.getPreferredValue() * factor);</span>
        }

        public int getMaximumValue() {
<span class="nc bnc" id="L320" title="All 2 branches missed.">            return Math.round((factor &lt; 0 ? s.getMinimumValue() : s.getMaximumValue()) * factor);</span>
        }

        public int getValue() {
<span class="nc" id="L324">            return Math.round(s.getValue() * factor);</span>
        }

        public void setValue(int value) {
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if (value == UNSET) {</span>
<span class="nc" id="L329">                s.setValue(UNSET);</span>
            } else {
<span class="nc" id="L331">                s.setValue(Math.round(value / factor));</span>
            }
<span class="nc" id="L333">        }</span>

        /*pp*/ boolean isCyclic(SpringLayout l) {
<span class="nc" id="L336">            return s.isCyclic(l);</span>
        }
    }

    /*pp*/ static class WidthSpring extends AbstractSpring {
        /*pp*/ Component c;

<span class="nc" id="L343">        public WidthSpring(Component c) {</span>
<span class="nc" id="L344">            this.c = c;</span>
<span class="nc" id="L345">        }</span>

        public int getMinimumValue() {
<span class="nc" id="L348">            return c.getMinimumSize().width;</span>
        }

        public int getPreferredValue() {
<span class="nc" id="L352">            return c.getPreferredSize().width;</span>
        }

        public int getMaximumValue() {
            // We will be doing arithmetic with the results of this call,
            // so if a returned value is Integer.MAX_VALUE we will get
            // arithmetic overflow. Truncate such values.
<span class="nc" id="L359">            return Math.min(Short.MAX_VALUE, c.getMaximumSize().width);</span>
        }
    }

     /*pp*/  static class HeightSpring extends AbstractSpring {
        /*pp*/ Component c;

<span class="nc" id="L366">        public HeightSpring(Component c) {</span>
<span class="nc" id="L367">            this.c = c;</span>
<span class="nc" id="L368">        }</span>

        public int getMinimumValue() {
<span class="nc" id="L371">            return c.getMinimumSize().height;</span>
        }

        public int getPreferredValue() {
<span class="nc" id="L375">            return c.getPreferredSize().height;</span>
        }

        public int getMaximumValue() {
<span class="nc" id="L379">            return Math.min(Short.MAX_VALUE, c.getMaximumSize().height);</span>
        }
    }

   /*pp*/ static abstract class SpringMap extends Spring {
       private Spring s;

<span class="nc" id="L386">       public SpringMap(Spring s) {</span>
<span class="nc" id="L387">           this.s = s;</span>
<span class="nc" id="L388">       }</span>

       protected abstract int map(int i);

       protected abstract int inv(int i);

       public int getMinimumValue() {
<span class="nc" id="L395">           return map(s.getMinimumValue());</span>
       }

       public int getPreferredValue() {
<span class="nc" id="L399">           return map(s.getPreferredValue());</span>
       }

       public int getMaximumValue() {
<span class="nc" id="L403">           return Math.min(Short.MAX_VALUE, map(s.getMaximumValue()));</span>
       }

       public int getValue() {
<span class="nc" id="L407">           return map(s.getValue());</span>
       }

       public void setValue(int value) {
<span class="nc bnc" id="L411" title="All 2 branches missed.">           if (value == UNSET) {</span>
<span class="nc" id="L412">               s.setValue(UNSET);</span>
           } else {
<span class="nc" id="L414">               s.setValue(inv(value));</span>
           }
<span class="nc" id="L416">       }</span>

       /*pp*/ boolean isCyclic(SpringLayout l) {
<span class="nc" id="L419">           return s.isCyclic(l);</span>
       }
   }

// Use the instance variables of the StaticSpring superclass to
// cache values that have already been calculated.
    /*pp*/ static abstract class CompoundSpring extends StaticSpring {
        protected Spring s1;
        protected Spring s2;

        public CompoundSpring(Spring s1, Spring s2) {
<span class="nc" id="L430">            super(UNSET);</span>
<span class="nc" id="L431">            this.s1 = s1;</span>
<span class="nc" id="L432">            this.s2 = s2;</span>
<span class="nc" id="L433">        }</span>

        public String toString() {
<span class="nc" id="L436">            return &quot;CompoundSpring of &quot; + s1 + &quot; and &quot; + s2;</span>
        }

        protected void clear() {
<span class="nc" id="L440">            super.clear();</span>
<span class="nc" id="L441">            min = pref = max = UNSET;</span>
<span class="nc" id="L442">            s1.setValue(UNSET);</span>
<span class="nc" id="L443">            s2.setValue(UNSET);</span>
<span class="nc" id="L444">        }</span>

        protected abstract int op(int x, int y);

        public int getMinimumValue() {
<span class="nc bnc" id="L449" title="All 2 branches missed.">            if (min == UNSET) {</span>
<span class="nc" id="L450">                min = op(s1.getMinimumValue(), s2.getMinimumValue());</span>
            }
<span class="nc" id="L452">            return min;</span>
        }

        public int getPreferredValue() {
<span class="nc bnc" id="L456" title="All 2 branches missed.">            if (pref == UNSET) {</span>
<span class="nc" id="L457">                pref = op(s1.getPreferredValue(), s2.getPreferredValue());</span>
            }
<span class="nc" id="L459">            return pref;</span>
        }

        public int getMaximumValue() {
<span class="nc bnc" id="L463" title="All 2 branches missed.">            if (max == UNSET) {</span>
<span class="nc" id="L464">                max = op(s1.getMaximumValue(), s2.getMaximumValue());</span>
            }
<span class="nc" id="L466">            return max;</span>
        }

        public int getValue() {
<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (size == UNSET) {</span>
<span class="nc" id="L471">                size = op(s1.getValue(), s2.getValue());</span>
            }
<span class="nc" id="L473">            return size;</span>
        }

        /*pp*/ boolean isCyclic(SpringLayout l) {
<span class="nc bnc" id="L477" title="All 4 branches missed.">            return l.isCyclic(s1) || l.isCyclic(s2);</span>
        }
    };

     private static class SumSpring extends CompoundSpring {
         public SumSpring(Spring s1, Spring s2) {
<span class="nc" id="L483">             super(s1, s2);</span>
<span class="nc" id="L484">         }</span>

         protected int op(int x, int y) {
<span class="nc" id="L487">             return x + y;</span>
         }

         protected void setNonClearValue(int size) {
<span class="nc" id="L491">             super.setNonClearValue(size);</span>
<span class="nc" id="L492">             s1.setStrain(this.getStrain());</span>
<span class="nc" id="L493">             s2.setValue(size - s1.getValue());</span>
<span class="nc" id="L494">         }</span>
     }

    private static class MaxSpring extends CompoundSpring {

        public MaxSpring(Spring s1, Spring s2) {
<span class="nc" id="L500">            super(s1, s2);</span>
<span class="nc" id="L501">        }</span>

        protected int op(int x, int y) {
<span class="nc" id="L504">            return Math.max(x, y);</span>
        }

        protected void setNonClearValue(int size) {
<span class="nc" id="L508">            super.setNonClearValue(size);</span>
<span class="nc" id="L509">            s1.setValue(size);</span>
<span class="nc" id="L510">            s2.setValue(size);</span>
<span class="nc" id="L511">        }</span>
    }

    /**
     * Returns a strut -- a spring whose &lt;em&gt;minimum&lt;/em&gt;, &lt;em&gt;preferred&lt;/em&gt;, and
     * &lt;em&gt;maximum&lt;/em&gt; values each have the value &lt;code&gt;pref&lt;/code&gt;.
     *
     * @param  pref the &lt;em&gt;minimum&lt;/em&gt;, &lt;em&gt;preferred&lt;/em&gt;, and
     *         &lt;em&gt;maximum&lt;/em&gt; values of the new spring
     * @return a spring whose &lt;em&gt;minimum&lt;/em&gt;, &lt;em&gt;preferred&lt;/em&gt;, and
     *         &lt;em&gt;maximum&lt;/em&gt; values each have the value &lt;code&gt;pref&lt;/code&gt;
     *
     * @see Spring
     */
     public static Spring constant(int pref) {
<span class="nc" id="L526">         return constant(pref, pref, pref);</span>
     }

    /**
     * Returns a spring whose &lt;em&gt;minimum&lt;/em&gt;, &lt;em&gt;preferred&lt;/em&gt;, and
     * &lt;em&gt;maximum&lt;/em&gt; values have the values: &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;pref&lt;/code&gt;,
     * and &lt;code&gt;max&lt;/code&gt; respectively.
     *
     * @param  min the &lt;em&gt;minimum&lt;/em&gt; value of the new spring
     * @param  pref the &lt;em&gt;preferred&lt;/em&gt; value of the new spring
     * @param  max the &lt;em&gt;maximum&lt;/em&gt; value of the new spring
     * @return a spring whose &lt;em&gt;minimum&lt;/em&gt;, &lt;em&gt;preferred&lt;/em&gt;, and
     *         &lt;em&gt;maximum&lt;/em&gt; values have the values: &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;pref&lt;/code&gt;,
     *         and &lt;code&gt;max&lt;/code&gt; respectively
     *
     * @see Spring
     */
     public static Spring constant(int min, int pref, int max) {
<span class="nc" id="L544">         return new StaticSpring(min, pref, max);</span>
     }


    /**
     * Returns &lt;code&gt;-s&lt;/code&gt;: a spring running in the opposite direction to &lt;code&gt;s&lt;/code&gt;.
     *
     * @return &lt;code&gt;-s&lt;/code&gt;: a spring running in the opposite direction to &lt;code&gt;s&lt;/code&gt;
     *
     * @see Spring
     */
    public static Spring minus(Spring s) {
<span class="nc" id="L556">        return new NegativeSpring(s);</span>
    }

    /**
     * Returns &lt;code&gt;s1+s2&lt;/code&gt;: a spring representing &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;
     * in series. In a sum, &lt;code&gt;s3&lt;/code&gt;, of two springs, &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;,
     * the &lt;em&gt;strains&lt;/em&gt; of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, and &lt;code&gt;s3&lt;/code&gt; are maintained
     * at the same level (to within the precision implied by their integer &lt;em&gt;value&lt;/em&gt;s).
     * The strain of a spring in compression is:
     * &lt;pre&gt;
     *         value - pref
     *         ------------
     *          pref - min
     * &lt;/pre&gt;
     * and the strain of a spring in tension is:
     * &lt;pre&gt;
     *         value - pref
     *         ------------
     *          max - pref
     * &lt;/pre&gt;
     * When &lt;code&gt;setValue&lt;/code&gt; is called on the sum spring, &lt;code&gt;s3&lt;/code&gt;, the strain
     * in &lt;code&gt;s3&lt;/code&gt; is calculated using one of the formulas above. Once the strain of
     * the sum is known, the &lt;em&gt;value&lt;/em&gt;s of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; are
     * then set so that they are have a strain equal to that of the sum. The formulas are
     * evaluated so as to take rounding errors into account and ensure that the sum of
     * the &lt;em&gt;value&lt;/em&gt;s of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; is exactly equal to
     * the &lt;em&gt;value&lt;/em&gt; of &lt;code&gt;s3&lt;/code&gt;.
     *
     * @return &lt;code&gt;s1+s2&lt;/code&gt;: a spring representing &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; in series
     *
     * @see Spring
     */
     public static Spring sum(Spring s1, Spring s2) {
<span class="nc" id="L589">         return new SumSpring(s1, s2);</span>
     }

    /**
     * Returns &lt;code&gt;max(s1, s2)&lt;/code&gt;: a spring whose value is always greater than (or equal to)
     *         the values of both &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;.
     *
     * @return &lt;code&gt;max(s1, s2)&lt;/code&gt;: a spring whose value is always greater than (or equal to)
     *         the values of both &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;
     * @see Spring
     */
    public static Spring max(Spring s1, Spring s2) {
<span class="nc" id="L601">        return new MaxSpring(s1, s2);</span>
    }

    // Remove these, they're not used often and can be created using minus -
    // as per these implementations.

    /*pp*/ static Spring difference(Spring s1, Spring s2) {
<span class="nc" id="L608">        return sum(s1, minus(s2));</span>
    }

    /*
    public static Spring min(Spring s1, Spring s2) {
        return minus(max(minus(s1), minus(s2)));
    }
    */

    /**
     * Returns a spring whose &lt;em&gt;minimum&lt;/em&gt;, &lt;em&gt;preferred&lt;/em&gt;, &lt;em&gt;maximum&lt;/em&gt;
     * and &lt;em&gt;value&lt;/em&gt; properties are each multiples of the properties of the
     * argument spring, &lt;code&gt;s&lt;/code&gt;. Minimum and maximum properties are
     * swapped when &lt;code&gt;factor&lt;/code&gt; is negative (in accordance with the
     * rules of interval arithmetic).
     * &lt;p&gt;
     * When factor is, for example, 0.5f the result represents 'the mid-point'
     * of its input - an operation that is useful for centering components in
     * a container.
     *
     * @param s the spring to scale
     * @param factor amount to scale by.
     * @return  a spring whose properties are those of the input spring &lt;code&gt;s&lt;/code&gt;
     * multiplied by &lt;code&gt;factor&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;s&lt;/code&gt; is null
     * @since 1.5
     */
    public static Spring scale(Spring s, float factor) {
<span class="nc" id="L636">        checkArg(s);</span>
<span class="nc" id="L637">        return new ScaleSpring(s, factor);</span>
    }

    /**
     * Returns a spring whose &lt;em&gt;minimum&lt;/em&gt;, &lt;em&gt;preferred&lt;/em&gt;, &lt;em&gt;maximum&lt;/em&gt;
     * and &lt;em&gt;value&lt;/em&gt; properties are defined by the widths of the &lt;em&gt;minimumSize&lt;/em&gt;,
     * &lt;em&gt;preferredSize&lt;/em&gt;, &lt;em&gt;maximumSize&lt;/em&gt; and &lt;em&gt;size&lt;/em&gt; properties
     * of the supplied component. The returned spring is a 'wrapper' implementation
     * whose methods call the appropriate size methods of the supplied component.
     * The minimum, preferred, maximum and value properties of the returned spring
     * therefore report the current state of the appropriate properties in the
     * component and track them as they change.
     *
     * @param c Component used for calculating size
     * @return  a spring whose properties are defined by the horizontal component
     * of the component's size methods.
     * @throws NullPointerException if &lt;code&gt;c&lt;/code&gt; is null
     * @since 1.5
     */
    public static Spring width(Component c) {
<span class="nc" id="L657">        checkArg(c);</span>
<span class="nc" id="L658">        return new WidthSpring(c);</span>
    }

    /**
     * Returns a spring whose &lt;em&gt;minimum&lt;/em&gt;, &lt;em&gt;preferred&lt;/em&gt;, &lt;em&gt;maximum&lt;/em&gt;
     * and &lt;em&gt;value&lt;/em&gt; properties are defined by the heights of the &lt;em&gt;minimumSize&lt;/em&gt;,
     * &lt;em&gt;preferredSize&lt;/em&gt;, &lt;em&gt;maximumSize&lt;/em&gt; and &lt;em&gt;size&lt;/em&gt; properties
     * of the supplied component. The returned spring is a 'wrapper' implementation
     * whose methods call the appropriate size methods of the supplied component.
     * The minimum, preferred, maximum and value properties of the returned spring
     * therefore report the current state of the appropriate properties in the
     * component and track them as they change.
     *
     * @param c Component used for calculating size
     * @return  a spring whose properties are defined by the vertical component
     * of the component's size methods.
     * @throws NullPointerException if &lt;code&gt;c&lt;/code&gt; is null
     * @since 1.5
     */
    public static Spring height(Component c) {
<span class="nc" id="L678">        checkArg(c);</span>
<span class="nc" id="L679">        return new HeightSpring(c);</span>
    }


    /**
     * If &lt;code&gt;s&lt;/code&gt; is null, this throws an NullPointerException.
     */
    private static void checkArg(Object s) {
<span class="nc bnc" id="L687" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L688">            throw new NullPointerException(&quot;Argument must not be null&quot;);</span>
        }
<span class="nc" id="L690">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>