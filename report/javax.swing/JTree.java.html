<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JTree.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JTree.java</span></div><h1>JTree.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing;

import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.io.*;
import java.util.*;
import javax.swing.event.*;
import javax.swing.plaf.*;
import javax.swing.tree.*;
import javax.swing.text.Position;
import javax.accessibility.*;
import sun.swing.SwingUtilities2;
import sun.swing.SwingUtilities2.Section;
import static sun.swing.SwingUtilities2.Section.*;


/**
 * &lt;a name=&quot;jtree_description&quot;&gt;&lt;/a&gt;
 * A control that displays a set of hierarchical data as an outline.
 * You can find task-oriented documentation and examples of using trees in
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;How to Use Trees&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 * &lt;p&gt;
 * A specific node in a tree can be identified either by a
 * &lt;code&gt;TreePath&lt;/code&gt; (an object
 * that encapsulates a node and all of its ancestors), or by its
 * display row, where each row in the display area displays one node.
 * An &lt;i&gt;expanded&lt;/i&gt; node is a non-leaf node (as identified by
 * &lt;code&gt;TreeModel.isLeaf(node)&lt;/code&gt; returning false) that will displays
 * its children when all its ancestors are &lt;i&gt;expanded&lt;/i&gt;.
 * A &lt;i&gt;collapsed&lt;/i&gt;
 * node is one which hides them. A &lt;i&gt;hidden&lt;/i&gt; node is one which is
 * under a collapsed ancestor. All of a &lt;i&gt;viewable&lt;/i&gt; nodes parents
 * are expanded, but may or may not be displayed. A &lt;i&gt;displayed&lt;/i&gt; node
 * is both viewable and in the display area, where it can be seen.
 * &lt;/p&gt;
 * The following &lt;code&gt;JTree&lt;/code&gt; methods use &quot;visible&quot; to mean &quot;displayed&quot;:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;isRootVisible()&lt;/code&gt;
 * &lt;li&gt;&lt;code&gt;setRootVisible()&lt;/code&gt;
 * &lt;li&gt;&lt;code&gt;scrollPathToVisible()&lt;/code&gt;
 * &lt;li&gt;&lt;code&gt;scrollRowToVisible()&lt;/code&gt;
 * &lt;li&gt;&lt;code&gt;getVisibleRowCount()&lt;/code&gt;
 * &lt;li&gt;&lt;code&gt;setVisibleRowCount()&lt;/code&gt;
 * &lt;/ul&gt;
 * The next group of &lt;code&gt;JTree&lt;/code&gt; methods use &quot;visible&quot; to mean
 * &quot;viewable&quot; (under an expanded parent):
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;isVisible()&lt;/code&gt;
 * &lt;li&gt;&lt;code&gt;makeVisible()&lt;/code&gt;
 * &lt;/ul&gt;
 * If you are interested in knowing when the selection changes implement
 * the &lt;code&gt;TreeSelectionListener&lt;/code&gt; interface and add the instance
 * using the method &lt;code&gt;addTreeSelectionListener&lt;/code&gt;.
 * &lt;code&gt;valueChanged&lt;/code&gt; will be invoked when the
 * selection changes, that is if the user clicks twice on the same
 * node &lt;code&gt;valueChanged&lt;/code&gt; will only be invoked once.
 * &lt;p&gt;
 * If you are interested in detecting either double-click events or when
 * a user clicks on a node, regardless of whether or not it was selected,
 * we recommend you do the following:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * final JTree tree = ...;
 *
 * MouseListener ml = new MouseAdapter() {
 *     public void &lt;b&gt;mousePressed&lt;/b&gt;(MouseEvent e) {
 *         int selRow = tree.getRowForLocation(e.getX(), e.getY());
 *         TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());
 *         if(selRow != -1) {
 *             if(e.getClickCount() == 1) {
 *                 mySingleClick(selRow, selPath);
 *             }
 *             else if(e.getClickCount() == 2) {
 *                 myDoubleClick(selRow, selPath);
 *             }
 *         }
 *     }
 * };
 * tree.addMouseListener(ml);
 * &lt;/pre&gt;
 * NOTE: This example obtains both the path and row, but you only need to
 * get the one you're interested in.
 * &lt;p&gt;
 * To use &lt;code&gt;JTree&lt;/code&gt; to display compound nodes
 * (for example, nodes containing both
 * a graphic icon and text), subclass {@link TreeCellRenderer} and use
 * {@link #setCellRenderer} to tell the tree to use it. To edit such nodes,
 * subclass {@link TreeCellEditor} and use {@link #setCellEditor}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Like all &lt;code&gt;JComponent&lt;/code&gt; classes, you can use {@link InputMap} and
 * {@link ActionMap}
 * to associate an {@link Action} object with a {@link KeyStroke}
 * and execute the action under specified conditions.
 * &lt;/p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *&lt;/p&gt;
 * @beaninfo
 *   attribute: isContainer false
 * description: A component that displays a set of hierarchical data as an outline.
 *
 * @author Rob Davis
 * @author Ray Ryan
 * @author Scott Violet
 */
<span class="nc bnc" id="L145" title="All 2 branches missed.">@SuppressWarnings(&quot;serial&quot;)</span>
public class JTree extends JComponent implements Scrollable, Accessible
{
    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;TreeUI&quot;;

    /**
     * The model that defines the tree displayed by this object.
     */
    transient protected TreeModel        treeModel;

    /**
     * Models the set of selected nodes in this tree.
     */
    transient protected TreeSelectionModel selectionModel;

    /**
     * True if the root node is displayed, false if its children are
     * the highest visible nodes.
     */
    protected boolean                    rootVisible;

    /**
     * The cell used to draw nodes. If &lt;code&gt;null&lt;/code&gt;, the UI uses a default
     * &lt;code&gt;cellRenderer&lt;/code&gt;.
     */
    transient protected TreeCellRenderer  cellRenderer;

    /**
     * Height to use for each display row. If this is &amp;lt;= 0 the renderer
     * determines the height for each row.
     */
    protected int                         rowHeight;
<span class="nc" id="L181">    private boolean                       rowHeightSet = false;</span>

    /**
     * Maps from &lt;code&gt;TreePath&lt;/code&gt; to &lt;code&gt;Boolean&lt;/code&gt;
     * indicating whether or not the
     * particular path is expanded. This ONLY indicates whether a
     * given path is expanded, and NOT if it is visible or not. That
     * information must be determined by visiting all the parent
     * paths and seeing if they are visible.
     */
    transient private Hashtable&lt;TreePath, Boolean&gt; expandedState;


    /**
     * True if handles are displayed at the topmost level of the tree.
     * &lt;p&gt;
     * A handle is a small icon that displays adjacent to the node which
     * allows the user to click once to expand or collapse the node. A
     * common interface shows a plus sign (+) for a node which can be
     * expanded and a minus sign (-) for a node which can be collapsed.
     * Handles are always shown for nodes below the topmost level.
     * &lt;p&gt;
     * If the &lt;code&gt;rootVisible&lt;/code&gt; setting specifies that the root
     * node is to be displayed, then that is the only node at the topmost
     * level. If the root node is not displayed, then all of its
     * children are at the topmost level of the tree. Handles are
     * always displayed for nodes other than the topmost.
     * &lt;p&gt;
     * If the root node isn't visible, it is generally a good to make
     * this value true. Otherwise, the tree looks exactly like a list,
     * and users may not know that the &quot;list entries&quot; are actually
     * tree nodes.
     *
     * @see #rootVisible
     */
    protected boolean           showsRootHandles;
<span class="nc" id="L217">    private boolean             showsRootHandlesSet = false;</span>

    /**
     * Creates a new event and passed it off the
     * &lt;code&gt;selectionListeners&lt;/code&gt;.
     */
    protected transient TreeSelectionRedirector selectionRedirector;

    /**
     * Editor for the entries.  Default is &lt;code&gt;null&lt;/code&gt;
     * (tree is not editable).
     */
    transient protected TreeCellEditor          cellEditor;

    /**
     * Is the tree editable? Default is false.
     */
    protected boolean                 editable;

    /**
     * Is this tree a large model? This is a code-optimization setting.
     * A large model can be used when the cell height is the same for all
     * nodes. The UI will then cache very little information and instead
     * continually message the model. Without a large model the UI caches
     * most of the information, resulting in fewer method calls to the model.
     * &lt;p&gt;
     * This value is only a suggestion to the UI. Not all UIs will
     * take advantage of it. Default value is false.
     */
    protected boolean                 largeModel;

    /**
     * Number of rows to make visible at one time. This value is used for
     * the &lt;code&gt;Scrollable&lt;/code&gt; interface. It determines the preferred
     * size of the display area.
     */
    protected int                     visibleRowCount;

    /**
     * If true, when editing is to be stopped by way of selection changing,
     * data in tree changing or other means &lt;code&gt;stopCellEditing&lt;/code&gt;
     * is invoked, and changes are saved. If false,
     * &lt;code&gt;cancelCellEditing&lt;/code&gt; is invoked, and changes
     * are discarded. Default is false.
     */
    protected boolean                 invokesStopCellEditing;

    /**
     * If true, when a node is expanded, as many of the descendants are
     * scrolled to be visible.
     */
    protected boolean                 scrollsOnExpand;
<span class="nc" id="L269">    private boolean                   scrollsOnExpandSet = false;</span>

    /**
     * Number of mouse clicks before a node is expanded.
     */
    protected int                     toggleClickCount;

    /**
     * Updates the &lt;code&gt;expandedState&lt;/code&gt;.
     */
    transient protected TreeModelListener       treeModelListener;

    /**
     * Used when &lt;code&gt;setExpandedState&lt;/code&gt; is invoked,
     * will be a &lt;code&gt;Stack&lt;/code&gt; of &lt;code&gt;Stack&lt;/code&gt;s.
     */
    transient private Stack&lt;Stack&lt;TreePath&gt;&gt; expandedStack;

    /**
     * Lead selection path, may not be &lt;code&gt;null&lt;/code&gt;.
     */
    private TreePath                  leadPath;

    /**
     * Anchor path.
     */
    private TreePath                  anchorPath;

    /**
     * True if paths in the selection should be expanded.
     */
    private boolean                   expandsSelectedPaths;

    /**
     * This is set to true for the life of the &lt;code&gt;setUI&lt;/code&gt; call.
     */
    private boolean                   settingUI;

    /** If true, mouse presses on selections initiate a drag operation. */
    private boolean dragEnabled;

    /**
     * The drop mode for this component.
     */
<span class="nc" id="L313">    private DropMode dropMode = DropMode.USE_SELECTION;</span>

    /**
     * The drop location.
     */
    private transient DropLocation dropLocation;

    /**
     * A subclass of &lt;code&gt;TransferHandler.DropLocation&lt;/code&gt; representing
     * a drop location for a &lt;code&gt;JTree&lt;/code&gt;.
     *
     * @see #getDropLocation
     * @since 1.6
     */
    public static final class DropLocation extends TransferHandler.DropLocation {
        private final TreePath path;
        private final int index;

        private DropLocation(Point p, TreePath path, int index) {
<span class="nc" id="L332">            super(p);</span>
<span class="nc" id="L333">            this.path = path;</span>
<span class="nc" id="L334">            this.index = index;</span>
<span class="nc" id="L335">        }</span>

        /**
         * Returns the index where the dropped data should be inserted
         * with respect to the path returned by &lt;code&gt;getPath()&lt;/code&gt;.
         * &lt;p&gt;
         * For drop modes &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt; and
         * &lt;code&gt;DropMode.ON&lt;/code&gt;, this index is unimportant (and it will
         * always be &lt;code&gt;-1&lt;/code&gt;) as the only interesting data is the
         * path over which the drop operation occurred.
         * &lt;p&gt;
         * For drop mode &lt;code&gt;DropMode.INSERT&lt;/code&gt;, this index
         * indicates the index at which the data should be inserted into
         * the parent path represented by &lt;code&gt;getPath()&lt;/code&gt;.
         * &lt;code&gt;-1&lt;/code&gt; indicates that the drop occurred over the
         * parent itself, and in most cases should be treated as inserting
         * into either the beginning or the end of the parent's list of
         * children.
         * &lt;p&gt;
         * For &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;, this value will be
         * an insert index, as described above, or &lt;code&gt;-1&lt;/code&gt; if
         * the drop occurred over the path itself.
         *
         * @return the child index
         * @see #getPath
         */
        public int getChildIndex() {
<span class="nc" id="L362">            return index;</span>
        }

        /**
         * Returns the path where dropped data should be placed in the
         * tree.
         * &lt;p&gt;
         * Interpretation of this value depends on the drop mode set on the
         * component. If the drop mode is &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;
         * or &lt;code&gt;DropMode.ON&lt;/code&gt;, the return value is the path in the
         * tree over which the data has been (or will be) dropped.
         * &lt;code&gt;null&lt;/code&gt; indicates that the drop is over empty space,
         * not associated with a particular path.
         * &lt;p&gt;
         * If the drop mode is &lt;code&gt;DropMode.INSERT&lt;/code&gt;, the return value
         * refers to the path that should become the parent of the new data,
         * in which case &lt;code&gt;getChildIndex()&lt;/code&gt; indicates where the
         * new item should be inserted into this parent path. A
         * &lt;code&gt;null&lt;/code&gt; path indicates that no parent path has been
         * determined, which can happen for multiple reasons:
         * &lt;ul&gt;
         *    &lt;li&gt;The tree has no model
         *    &lt;li&gt;There is no root in the tree
         *    &lt;li&gt;The root is collapsed
         *    &lt;li&gt;The root is a leaf node
         * &lt;/ul&gt;
         * It is up to the developer to decide if and how they wish to handle
         * the &lt;code&gt;null&lt;/code&gt; case.
         * &lt;p&gt;
         * If the drop mode is &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;,
         * &lt;code&gt;getChildIndex&lt;/code&gt; can be used to determine whether the
         * drop is on top of the path itself (&lt;code&gt;-1&lt;/code&gt;) or the index
         * at which it should be inserted into the path (values other than
         * &lt;code&gt;-1&lt;/code&gt;).
         *
         * @return the drop path
         * @see #getChildIndex
         */
        public TreePath getPath() {
<span class="nc" id="L401">            return path;</span>
        }

        /**
         * Returns a string representation of this drop location.
         * This method is intended to be used for debugging purposes,
         * and the content and format of the returned string may vary
         * between implementations.
         *
         * @return a string representation of this drop location
         */
        public String toString() {
<span class="nc" id="L413">            return getClass().getName()</span>
<span class="nc" id="L414">                   + &quot;[dropPoint=&quot; + getDropPoint() + &quot;,&quot;</span>
                   + &quot;path=&quot; + path + &quot;,&quot;
                   + &quot;childIndex=&quot; + index + &quot;]&quot;;
        }
    }

    /**
     * The row to expand during DnD.
     */
<span class="nc" id="L423">    private int expandRow = -1;</span>

    @SuppressWarnings(&quot;serial&quot;)
    private class TreeTimer extends Timer {
<span class="nc" id="L427">        public TreeTimer() {</span>
<span class="nc" id="L428">            super(2000, null);</span>
<span class="nc" id="L429">            setRepeats(false);</span>
<span class="nc" id="L430">        }</span>

        public void fireActionPerformed(ActionEvent ae) {
<span class="nc" id="L433">            JTree.this.expandRow(expandRow);</span>
<span class="nc" id="L434">        }</span>
    }

    /**
     * A timer to expand nodes during drop.
     */
    private TreeTimer dropTimer;

    /**
     * When &lt;code&gt;addTreeExpansionListener&lt;/code&gt; is invoked,
     * and &lt;code&gt;settingUI&lt;/code&gt; is true, this ivar gets set to the passed in
     * &lt;code&gt;Listener&lt;/code&gt;. This listener is then notified first in
     * &lt;code&gt;fireTreeCollapsed&lt;/code&gt; and &lt;code&gt;fireTreeExpanded&lt;/code&gt;.
     * &lt;p&gt;This is an ugly workaround for a way to have the UI listener
     * get notified before other listeners.
     */
    private transient TreeExpansionListener     uiTreeExpansionListener;

    /**
     * Max number of stacks to keep around.
     */
<span class="nc" id="L455">    private static int                TEMP_STACK_SIZE = 11;</span>

    //
    // Bound property names
    //
    /** Bound property name for &lt;code&gt;cellRenderer&lt;/code&gt;. */
    public final static String        CELL_RENDERER_PROPERTY = &quot;cellRenderer&quot;;
    /** Bound property name for &lt;code&gt;treeModel&lt;/code&gt;. */
    public final static String        TREE_MODEL_PROPERTY = &quot;model&quot;;
    /** Bound property name for &lt;code&gt;rootVisible&lt;/code&gt;. */
    public final static String        ROOT_VISIBLE_PROPERTY = &quot;rootVisible&quot;;
    /** Bound property name for &lt;code&gt;showsRootHandles&lt;/code&gt;. */
    public final static String        SHOWS_ROOT_HANDLES_PROPERTY = &quot;showsRootHandles&quot;;
    /** Bound property name for &lt;code&gt;rowHeight&lt;/code&gt;. */
    public final static String        ROW_HEIGHT_PROPERTY = &quot;rowHeight&quot;;
    /** Bound property name for &lt;code&gt;cellEditor&lt;/code&gt;. */
    public final static String        CELL_EDITOR_PROPERTY = &quot;cellEditor&quot;;
    /** Bound property name for &lt;code&gt;editable&lt;/code&gt;. */
    public final static String        EDITABLE_PROPERTY = &quot;editable&quot;;
    /** Bound property name for &lt;code&gt;largeModel&lt;/code&gt;. */
    public final static String        LARGE_MODEL_PROPERTY = &quot;largeModel&quot;;
    /** Bound property name for selectionModel. */
    public final static String        SELECTION_MODEL_PROPERTY = &quot;selectionModel&quot;;
    /** Bound property name for &lt;code&gt;visibleRowCount&lt;/code&gt;. */
    public final static String        VISIBLE_ROW_COUNT_PROPERTY = &quot;visibleRowCount&quot;;
    /** Bound property name for &lt;code&gt;messagesStopCellEditing&lt;/code&gt;. */
    public final static String        INVOKES_STOP_CELL_EDITING_PROPERTY = &quot;invokesStopCellEditing&quot;;
    /** Bound property name for &lt;code&gt;scrollsOnExpand&lt;/code&gt;. */
    public final static String        SCROLLS_ON_EXPAND_PROPERTY = &quot;scrollsOnExpand&quot;;
    /** Bound property name for &lt;code&gt;toggleClickCount&lt;/code&gt;. */
    public final static String        TOGGLE_CLICK_COUNT_PROPERTY = &quot;toggleClickCount&quot;;
    /** Bound property name for &lt;code&gt;leadSelectionPath&lt;/code&gt;.
     * @since 1.3 */
    public final static String        LEAD_SELECTION_PATH_PROPERTY = &quot;leadSelectionPath&quot;;
    /** Bound property name for anchor selection path.
     * @since 1.3 */
    public final static String        ANCHOR_SELECTION_PATH_PROPERTY = &quot;anchorSelectionPath&quot;;
    /** Bound property name for expands selected paths property
     * @since 1.3 */
    public final static String        EXPANDS_SELECTED_PATHS_PROPERTY = &quot;expandsSelectedPaths&quot;;


    /**
     * Creates and returns a sample &lt;code&gt;TreeModel&lt;/code&gt;.
     * Used primarily for beanbuilders to show something interesting.
     *
     * @return the default &lt;code&gt;TreeModel&lt;/code&gt;
     */
    protected static TreeModel getDefaultTreeModel() {
<span class="nc" id="L504">        DefaultMutableTreeNode      root = new DefaultMutableTreeNode(&quot;JTree&quot;);</span>
        DefaultMutableTreeNode      parent;

<span class="nc" id="L507">        parent = new DefaultMutableTreeNode(&quot;colors&quot;);</span>
<span class="nc" id="L508">        root.add(parent);</span>
<span class="nc" id="L509">        parent.add(new DefaultMutableTreeNode(&quot;blue&quot;));</span>
<span class="nc" id="L510">        parent.add(new DefaultMutableTreeNode(&quot;violet&quot;));</span>
<span class="nc" id="L511">        parent.add(new DefaultMutableTreeNode(&quot;red&quot;));</span>
<span class="nc" id="L512">        parent.add(new DefaultMutableTreeNode(&quot;yellow&quot;));</span>

<span class="nc" id="L514">        parent = new DefaultMutableTreeNode(&quot;sports&quot;);</span>
<span class="nc" id="L515">        root.add(parent);</span>
<span class="nc" id="L516">        parent.add(new DefaultMutableTreeNode(&quot;basketball&quot;));</span>
<span class="nc" id="L517">        parent.add(new DefaultMutableTreeNode(&quot;soccer&quot;));</span>
<span class="nc" id="L518">        parent.add(new DefaultMutableTreeNode(&quot;football&quot;));</span>
<span class="nc" id="L519">        parent.add(new DefaultMutableTreeNode(&quot;hockey&quot;));</span>

<span class="nc" id="L521">        parent = new DefaultMutableTreeNode(&quot;food&quot;);</span>
<span class="nc" id="L522">        root.add(parent);</span>
<span class="nc" id="L523">        parent.add(new DefaultMutableTreeNode(&quot;hot dogs&quot;));</span>
<span class="nc" id="L524">        parent.add(new DefaultMutableTreeNode(&quot;pizza&quot;));</span>
<span class="nc" id="L525">        parent.add(new DefaultMutableTreeNode(&quot;ravioli&quot;));</span>
<span class="nc" id="L526">        parent.add(new DefaultMutableTreeNode(&quot;bananas&quot;));</span>
<span class="nc" id="L527">        return new DefaultTreeModel(root);</span>
    }

    /**
     * Returns a &lt;code&gt;TreeModel&lt;/code&gt; wrapping the specified object.
     * If the object is:&lt;ul&gt;
     * &lt;li&gt;an array of &lt;code&gt;Object&lt;/code&gt;s,
     * &lt;li&gt;a &lt;code&gt;Hashtable&lt;/code&gt;, or
     * &lt;li&gt;a &lt;code&gt;Vector&lt;/code&gt;
     * &lt;/ul&gt;then a new root node is created with each of the incoming
     * objects as children. Otherwise, a new root is created with
     * a value of {@code &quot;root&quot;}.
     *
     * @param value  the &lt;code&gt;Object&lt;/code&gt; used as the foundation for
     *          the &lt;code&gt;TreeModel&lt;/code&gt;
     * @return a &lt;code&gt;TreeModel&lt;/code&gt; wrapping the specified object
     */
    protected static TreeModel createTreeModel(Object value) {
        DefaultMutableTreeNode           root;

<span class="nc bnc" id="L547" title="All 6 branches missed.">        if((value instanceof Object[]) || (value instanceof Hashtable) ||</span>
           (value instanceof Vector)) {
<span class="nc" id="L549">            root = new DefaultMutableTreeNode(&quot;root&quot;);</span>
<span class="nc" id="L550">            DynamicUtilTreeNode.createChildren(root, value);</span>
        }
        else {
<span class="nc" id="L553">            root = new DynamicUtilTreeNode(&quot;root&quot;, value);</span>
        }
<span class="nc" id="L555">        return new DefaultTreeModel(root, false);</span>
    }

    /**
     * Returns a &lt;code&gt;JTree&lt;/code&gt; with a sample model.
     * The default model used by the tree defines a leaf node as any node
     * without children.
     *
     * @see DefaultTreeModel#asksAllowsChildren
     */
    public JTree() {
<span class="nc" id="L566">        this(getDefaultTreeModel());</span>
<span class="nc" id="L567">    }</span>

    /**
     * Returns a &lt;code&gt;JTree&lt;/code&gt; with each element of the
     * specified array as the
     * child of a new root node which is not displayed.
     * By default, the tree defines a leaf node as any node without
     * children.
     *
     * @param value  an array of &lt;code&gt;Object&lt;/code&gt;s
     * @see DefaultTreeModel#asksAllowsChildren
     */
    public JTree(Object[] value) {
<span class="nc" id="L580">        this(createTreeModel(value));</span>
<span class="nc" id="L581">        this.setRootVisible(false);</span>
<span class="nc" id="L582">        this.setShowsRootHandles(true);</span>
<span class="nc" id="L583">        expandRoot();</span>
<span class="nc" id="L584">    }</span>

    /**
     * Returns a &lt;code&gt;JTree&lt;/code&gt; with each element of the specified
     * &lt;code&gt;Vector&lt;/code&gt; as the
     * child of a new root node which is not displayed. By default, the
     * tree defines a leaf node as any node without children.
     *
     * @param value  a &lt;code&gt;Vector&lt;/code&gt;
     * @see DefaultTreeModel#asksAllowsChildren
     */
    public JTree(Vector&lt;?&gt; value) {
<span class="nc" id="L596">        this(createTreeModel(value));</span>
<span class="nc" id="L597">        this.setRootVisible(false);</span>
<span class="nc" id="L598">        this.setShowsRootHandles(true);</span>
<span class="nc" id="L599">        expandRoot();</span>
<span class="nc" id="L600">    }</span>

    /**
     * Returns a &lt;code&gt;JTree&lt;/code&gt; created from a &lt;code&gt;Hashtable&lt;/code&gt;
     * which does not display with root.
     * Each value-half of the key/value pairs in the &lt;code&gt;HashTable&lt;/code&gt;
     * becomes a child of the new root node. By default, the tree defines
     * a leaf node as any node without children.
     *
     * @param value  a &lt;code&gt;Hashtable&lt;/code&gt;
     * @see DefaultTreeModel#asksAllowsChildren
     */
    public JTree(Hashtable&lt;?,?&gt; value) {
<span class="nc" id="L613">        this(createTreeModel(value));</span>
<span class="nc" id="L614">        this.setRootVisible(false);</span>
<span class="nc" id="L615">        this.setShowsRootHandles(true);</span>
<span class="nc" id="L616">        expandRoot();</span>
<span class="nc" id="L617">    }</span>

    /**
     * Returns a &lt;code&gt;JTree&lt;/code&gt; with the specified
     * &lt;code&gt;TreeNode&lt;/code&gt; as its root,
     * which displays the root node.
     * By default, the tree defines a leaf node as any node without children.
     *
     * @param root  a &lt;code&gt;TreeNode&lt;/code&gt; object
     * @see DefaultTreeModel#asksAllowsChildren
     */
    public JTree(TreeNode root) {
<span class="nc" id="L629">        this(root, false);</span>
<span class="nc" id="L630">    }</span>

    /**
     * Returns a &lt;code&gt;JTree&lt;/code&gt; with the specified &lt;code&gt;TreeNode&lt;/code&gt;
     * as its root, which
     * displays the root node and which decides whether a node is a
     * leaf node in the specified manner.
     *
     * @param root  a &lt;code&gt;TreeNode&lt;/code&gt; object
     * @param asksAllowsChildren  if false, any node without children is a
     *              leaf node; if true, only nodes that do not allow
     *              children are leaf nodes
     * @see DefaultTreeModel#asksAllowsChildren
     */
    public JTree(TreeNode root, boolean asksAllowsChildren) {
<span class="nc" id="L645">        this(new DefaultTreeModel(root, asksAllowsChildren));</span>
<span class="nc" id="L646">    }</span>

    /**
     * Returns an instance of &lt;code&gt;JTree&lt;/code&gt; which displays the root node
     * -- the tree is created using the specified data model.
     *
     * @param newModel  the &lt;code&gt;TreeModel&lt;/code&gt; to use as the data model
     */
    @ConstructorProperties({&quot;model&quot;})
    public JTree(TreeModel newModel) {
<span class="nc" id="L656">        super();</span>
<span class="nc" id="L657">        expandedStack = new Stack&lt;Stack&lt;TreePath&gt;&gt;();</span>
<span class="nc" id="L658">        toggleClickCount = 2;</span>
<span class="nc" id="L659">        expandedState = new Hashtable&lt;TreePath, Boolean&gt;();</span>
<span class="nc" id="L660">        setLayout(null);</span>
<span class="nc" id="L661">        rowHeight = 16;</span>
<span class="nc" id="L662">        visibleRowCount = 20;</span>
<span class="nc" id="L663">        rootVisible = true;</span>
<span class="nc" id="L664">        selectionModel = new DefaultTreeSelectionModel();</span>
<span class="nc" id="L665">        cellRenderer = null;</span>
<span class="nc" id="L666">        scrollsOnExpand = true;</span>
<span class="nc" id="L667">        setOpaque(true);</span>
<span class="nc" id="L668">        expandsSelectedPaths = true;</span>
<span class="nc" id="L669">        updateUI();</span>
<span class="nc" id="L670">        setModel(newModel);</span>
<span class="nc" id="L671">    }</span>

    /**
     * Returns the L&amp;amp;F object that renders this component.
     *
     * @return the &lt;code&gt;TreeUI&lt;/code&gt; object that renders this component
     */
    public TreeUI getUI() {
<span class="nc" id="L679">        return (TreeUI)ui;</span>
    }

    /**
     * Sets the L&amp;amp;F object that renders this component.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param ui  the &lt;code&gt;TreeUI&lt;/code&gt; L&amp;amp;F object
     * @see UIDefaults#getUI
     * @beaninfo
     *        bound: true
     *       hidden: true
     *    attribute: visualUpdate true
     *  description: The UI object that implements the Component's LookAndFeel.
     */
    public void setUI(TreeUI ui) {
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (this.ui != ui) {</span>
<span class="nc" id="L697">            settingUI = true;</span>
<span class="nc" id="L698">            uiTreeExpansionListener = null;</span>
            try {
<span class="nc" id="L700">                super.setUI(ui);</span>
            }
            finally {
<span class="nc" id="L703">                settingUI = false;</span>
<span class="nc" id="L704">            }</span>
        }
<span class="nc" id="L706">    }</span>

    /**
     * Notification from the &lt;code&gt;UIManager&lt;/code&gt; that the L&amp;amp;F has changed.
     * Replaces the current UI object with the latest version from the
     * &lt;code&gt;UIManager&lt;/code&gt;.
     *
     * @see JComponent#updateUI
     */
    public void updateUI() {
<span class="nc" id="L716">        setUI((TreeUI)UIManager.getUI(this));</span>

<span class="nc" id="L718">        SwingUtilities.updateRendererOrEditorUI(getCellRenderer());</span>
<span class="nc" id="L719">        SwingUtilities.updateRendererOrEditorUI(getCellEditor());</span>
<span class="nc" id="L720">    }</span>


    /**
     * Returns the name of the L&amp;amp;F class that renders this component.
     *
     * @return the string &quot;TreeUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L731">        return uiClassID;</span>
    }


    /**
     * Returns the current &lt;code&gt;TreeCellRenderer&lt;/code&gt;
     *  that is rendering each cell.
     *
     * @return the &lt;code&gt;TreeCellRenderer&lt;/code&gt; that is rendering each cell
     */
    public TreeCellRenderer getCellRenderer() {
<span class="nc" id="L742">        return cellRenderer;</span>
    }

    /**
     * Sets the &lt;code&gt;TreeCellRenderer&lt;/code&gt; that will be used to
     * draw each cell.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param x  the &lt;code&gt;TreeCellRenderer&lt;/code&gt; that is to render each cell
     * @beaninfo
     *        bound: true
     *  description: The TreeCellRenderer that will be used to draw
     *               each cell.
     */
    public void setCellRenderer(TreeCellRenderer x) {
<span class="nc" id="L758">        TreeCellRenderer oldValue = cellRenderer;</span>

<span class="nc" id="L760">        cellRenderer = x;</span>
<span class="nc" id="L761">        firePropertyChange(CELL_RENDERER_PROPERTY, oldValue, cellRenderer);</span>
<span class="nc" id="L762">        invalidate();</span>
<span class="nc" id="L763">    }</span>

    /**
      * Determines whether the tree is editable. Fires a property
      * change event if the new setting is different from the existing
      * setting.
     * &lt;p&gt;
     * This is a bound property.
      *
      * @param flag  a boolean value, true if the tree is editable
      * @beaninfo
      *        bound: true
      *  description: Whether the tree is editable.
      */
    public void setEditable(boolean flag) {
<span class="nc" id="L778">        boolean                 oldValue = this.editable;</span>

<span class="nc" id="L780">        this.editable = flag;</span>
<span class="nc" id="L781">        firePropertyChange(EDITABLE_PROPERTY, oldValue, flag);</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (accessibleContext != null) {</span>
<span class="nc bnc" id="L783" title="All 4 branches missed.">            accessibleContext.firePropertyChange(</span>
                AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                (oldValue ? AccessibleState.EDITABLE : null),
                (flag ? AccessibleState.EDITABLE : null));
        }
<span class="nc" id="L788">    }</span>

    /**
     * Returns true if the tree is editable.
     *
     * @return true if the tree is editable
     */
    public boolean isEditable() {
<span class="nc" id="L796">        return editable;</span>
    }

    /**
     * Sets the cell editor.  A &lt;code&gt;null&lt;/code&gt; value implies that the
     * tree cannot be edited.  If this represents a change in the
     * &lt;code&gt;cellEditor&lt;/code&gt;, the &lt;code&gt;propertyChange&lt;/code&gt;
     * method is invoked on all listeners.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param cellEditor the &lt;code&gt;TreeCellEditor&lt;/code&gt; to use
     * @beaninfo
     *        bound: true
     *  description: The cell editor. A null value implies the tree
     *               cannot be edited.
     */
    public void setCellEditor(TreeCellEditor cellEditor) {
<span class="nc" id="L814">        TreeCellEditor        oldEditor = this.cellEditor;</span>

<span class="nc" id="L816">        this.cellEditor = cellEditor;</span>
<span class="nc" id="L817">        firePropertyChange(CELL_EDITOR_PROPERTY, oldEditor, cellEditor);</span>
<span class="nc" id="L818">        invalidate();</span>
<span class="nc" id="L819">    }</span>

    /**
     * Returns the editor used to edit entries in the tree.
     *
     * @return the &lt;code&gt;TreeCellEditor&lt;/code&gt; in use,
     *          or &lt;code&gt;null&lt;/code&gt; if the tree cannot be edited
     */
    public TreeCellEditor getCellEditor() {
<span class="nc" id="L828">        return cellEditor;</span>
    }

    /**
     * Returns the &lt;code&gt;TreeModel&lt;/code&gt; that is providing the data.
     *
     * @return the &lt;code&gt;TreeModel&lt;/code&gt; that is providing the data
     */
    public TreeModel getModel() {
<span class="nc" id="L837">        return treeModel;</span>
    }

    /**
     * Sets the &lt;code&gt;TreeModel&lt;/code&gt; that will provide the data.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param newModel the &lt;code&gt;TreeModel&lt;/code&gt; that is to provide the data
     * @beaninfo
     *        bound: true
     *  description: The TreeModel that will provide the data.
     */
    public void setModel(TreeModel newModel) {
<span class="nc" id="L851">        clearSelection();</span>

<span class="nc" id="L853">        TreeModel oldModel = treeModel;</span>

<span class="nc bnc" id="L855" title="All 4 branches missed.">        if(treeModel != null &amp;&amp; treeModelListener != null)</span>
<span class="nc" id="L856">            treeModel.removeTreeModelListener(treeModelListener);</span>

<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (accessibleContext != null) {</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            if (treeModel != null) {</span>
<span class="nc" id="L860">                treeModel.removeTreeModelListener((TreeModelListener)accessibleContext);</span>
            }
<span class="nc bnc" id="L862" title="All 2 branches missed.">            if (newModel != null) {</span>
<span class="nc" id="L863">                newModel.addTreeModelListener((TreeModelListener)accessibleContext);</span>
            }
        }

<span class="nc" id="L867">        treeModel = newModel;</span>
<span class="nc" id="L868">        clearToggledPaths();</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">        if(treeModel != null) {</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">            if(treeModelListener == null)</span>
<span class="nc" id="L871">                treeModelListener = createTreeModelListener();</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">            if(treeModelListener != null)</span>
<span class="nc" id="L873">                treeModel.addTreeModelListener(treeModelListener);</span>
            // Mark the root as expanded, if it isn't a leaf.
<span class="nc bnc" id="L875" title="All 2 branches missed.">            if(treeModel.getRoot() != null &amp;&amp;</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">               !treeModel.isLeaf(treeModel.getRoot())) {</span>
<span class="nc" id="L877">                expandedState.put(new TreePath(treeModel.getRoot()),</span>
                                  Boolean.TRUE);
            }
        }
<span class="nc" id="L881">        firePropertyChange(TREE_MODEL_PROPERTY, oldModel, treeModel);</span>
<span class="nc" id="L882">        invalidate();</span>
<span class="nc" id="L883">    }</span>

    /**
     * Returns true if the root node of the tree is displayed.
     *
     * @return true if the root node of the tree is displayed
     * @see #rootVisible
     */
    public boolean isRootVisible() {
<span class="nc" id="L892">        return rootVisible;</span>
    }

    /**
     * Determines whether or not the root node from
     * the &lt;code&gt;TreeModel&lt;/code&gt; is visible.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param rootVisible true if the root node of the tree is to be displayed
     * @see #rootVisible
     * @beaninfo
     *        bound: true
     *  description: Whether or not the root node
     *               from the TreeModel is visible.
     */
    public void setRootVisible(boolean rootVisible) {
<span class="nc" id="L909">        boolean                oldValue = this.rootVisible;</span>

<span class="nc" id="L911">        this.rootVisible = rootVisible;</span>
<span class="nc" id="L912">        firePropertyChange(ROOT_VISIBLE_PROPERTY, oldValue, this.rootVisible);</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">        if (accessibleContext != null) {</span>
<span class="nc" id="L914">            ((AccessibleJTree)accessibleContext).fireVisibleDataPropertyChange();</span>
        }
<span class="nc" id="L916">    }</span>

    /**
     * Sets the value of the &lt;code&gt;showsRootHandles&lt;/code&gt; property,
     * which specifies whether the node handles should be displayed.
     * The default value of this property depends on the constructor
     * used to create the &lt;code&gt;JTree&lt;/code&gt;.
     * Some look and feels might not support handles;
     * they will ignore this property.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param newValue &lt;code&gt;true&lt;/code&gt; if root handles should be displayed;
     *                 otherwise, &lt;code&gt;false&lt;/code&gt;
     * @see #showsRootHandles
     * @see #getShowsRootHandles
     * @beaninfo
     *        bound: true
     *  description: Whether the node handles are to be
     *               displayed.
     */
    public void setShowsRootHandles(boolean newValue) {
<span class="nc" id="L938">        boolean                oldValue = showsRootHandles;</span>
<span class="nc" id="L939">        TreeModel              model = getModel();</span>

<span class="nc" id="L941">        showsRootHandles = newValue;</span>
<span class="nc" id="L942">        showsRootHandlesSet = true;</span>
<span class="nc" id="L943">        firePropertyChange(SHOWS_ROOT_HANDLES_PROPERTY, oldValue,</span>
                           showsRootHandles);
<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (accessibleContext != null) {</span>
<span class="nc" id="L946">            ((AccessibleJTree)accessibleContext).fireVisibleDataPropertyChange();</span>
        }
<span class="nc" id="L948">        invalidate();</span>
<span class="nc" id="L949">    }</span>

    /**
     * Returns the value of the &lt;code&gt;showsRootHandles&lt;/code&gt; property.
     *
     * @return the value of the &lt;code&gt;showsRootHandles&lt;/code&gt; property
     * @see #showsRootHandles
     */
    public boolean getShowsRootHandles()
    {
<span class="nc" id="L959">        return showsRootHandles;</span>
    }

    /**
     * Sets the height of each cell, in pixels.  If the specified value
     * is less than or equal to zero the current cell renderer is
     * queried for each row's height.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param rowHeight the height of each cell, in pixels
     * @beaninfo
     *        bound: true
     *  description: The height of each cell.
     */
    public void setRowHeight(int rowHeight)
    {
<span class="nc" id="L976">        int                oldValue = this.rowHeight;</span>

<span class="nc" id="L978">        this.rowHeight = rowHeight;</span>
<span class="nc" id="L979">        rowHeightSet = true;</span>
<span class="nc" id="L980">        firePropertyChange(ROW_HEIGHT_PROPERTY, oldValue, this.rowHeight);</span>
<span class="nc" id="L981">        invalidate();</span>
<span class="nc" id="L982">    }</span>

    /**
     * Returns the height of each row.  If the returned value is less than
     * or equal to 0 the height for each row is determined by the
     * renderer.
     *
     */
    public int getRowHeight()
    {
<span class="nc" id="L992">        return rowHeight;</span>
    }

    /**
     * Returns true if the height of each display row is a fixed size.
     *
     * @return true if the height of each row is a fixed size
     */
    public boolean isFixedRowHeight()
    {
<span class="nc bnc" id="L1002" title="All 2 branches missed.">        return (rowHeight &gt; 0);</span>
    }

    /**
     * Specifies whether the UI should use a large model.
     * (Not all UIs will implement this.) Fires a property change
     * for the LARGE_MODEL_PROPERTY.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param newValue true to suggest a large model to the UI
     * @see #largeModel
     * @beaninfo
     *        bound: true
     *  description: Whether the UI should use a
     *               large model.
     */
    public void setLargeModel(boolean newValue) {
<span class="nc" id="L1020">        boolean                oldValue = largeModel;</span>

<span class="nc" id="L1022">        largeModel = newValue;</span>
<span class="nc" id="L1023">        firePropertyChange(LARGE_MODEL_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1024">    }</span>

    /**
     * Returns true if the tree is configured for a large model.
     *
     * @return true if a large model is suggested
     * @see #largeModel
     */
    public boolean isLargeModel() {
<span class="nc" id="L1033">        return largeModel;</span>
    }

    /**
     * Determines what happens when editing is interrupted by selecting
     * another node in the tree, a change in the tree's data, or by some
     * other means. Setting this property to &lt;code&gt;true&lt;/code&gt; causes the
     * changes to be automatically saved when editing is interrupted.
     * &lt;p&gt;
     * Fires a property change for the INVOKES_STOP_CELL_EDITING_PROPERTY.
     *
     * @param newValue true means that &lt;code&gt;stopCellEditing&lt;/code&gt; is invoked
     *        when editing is interrupted, and data is saved; false means that
     *        &lt;code&gt;cancelCellEditing&lt;/code&gt; is invoked, and changes are lost
     * @beaninfo
     *        bound: true
     *  description: Determines what happens when editing is interrupted,
     *               selecting another node in the tree, a change in the
     *               tree's data, or some other means.
     */
    public void setInvokesStopCellEditing(boolean newValue) {
<span class="nc" id="L1054">        boolean                  oldValue = invokesStopCellEditing;</span>

<span class="nc" id="L1056">        invokesStopCellEditing = newValue;</span>
<span class="nc" id="L1057">        firePropertyChange(INVOKES_STOP_CELL_EDITING_PROPERTY, oldValue,</span>
                           newValue);
<span class="nc" id="L1059">    }</span>

    /**
     * Returns the indicator that tells what happens when editing is
     * interrupted.
     *
     * @return the indicator that tells what happens when editing is
     *         interrupted
     * @see #setInvokesStopCellEditing
     */
    public boolean getInvokesStopCellEditing() {
<span class="nc" id="L1070">        return invokesStopCellEditing;</span>
    }

    /**
     * Sets the &lt;code&gt;scrollsOnExpand&lt;/code&gt; property,
     * which determines whether the
     * tree might scroll to show previously hidden children.
     * If this property is &lt;code&gt;true&lt;/code&gt; (the default),
     * when a node expands
     * the tree can use scrolling to make
     * the maximum possible number of the node's descendants visible.
     * In some look and feels, trees might not need to scroll when expanded;
     * those look and feels will ignore this property.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param newValue &lt;code&gt;false&lt;/code&gt; to disable scrolling on expansion;
     *                 &lt;code&gt;true&lt;/code&gt; to enable it
     * @see #getScrollsOnExpand
     *
     * @beaninfo
     *        bound: true
     *  description: Indicates if a node descendant should be scrolled when expanded.
     */
    public void setScrollsOnExpand(boolean newValue) {
<span class="nc" id="L1095">        boolean           oldValue = scrollsOnExpand;</span>

<span class="nc" id="L1097">        scrollsOnExpand = newValue;</span>
<span class="nc" id="L1098">        scrollsOnExpandSet = true;</span>
<span class="nc" id="L1099">        firePropertyChange(SCROLLS_ON_EXPAND_PROPERTY, oldValue,</span>
                           newValue);
<span class="nc" id="L1101">    }</span>

    /**
     * Returns the value of the &lt;code&gt;scrollsOnExpand&lt;/code&gt; property.
     *
     * @return the value of the &lt;code&gt;scrollsOnExpand&lt;/code&gt; property
     */
    public boolean getScrollsOnExpand() {
<span class="nc" id="L1109">        return scrollsOnExpand;</span>
    }

    /**
     * Sets the number of mouse clicks before a node will expand or close.
     * The default is two.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @since 1.3
     * @beaninfo
     *        bound: true
     *  description: Number of clicks before a node will expand/collapse.
     */
    public void setToggleClickCount(int clickCount) {
<span class="nc" id="L1124">        int         oldCount = toggleClickCount;</span>

<span class="nc" id="L1126">        toggleClickCount = clickCount;</span>
<span class="nc" id="L1127">        firePropertyChange(TOGGLE_CLICK_COUNT_PROPERTY, oldCount,</span>
                           clickCount);
<span class="nc" id="L1129">    }</span>

    /**
     * Returns the number of mouse clicks needed to expand or close a node.
     *
     * @return number of mouse clicks before node is expanded
     * @since 1.3
     */
    public int getToggleClickCount() {
<span class="nc" id="L1138">        return toggleClickCount;</span>
    }

    /**
     * Configures the &lt;code&gt;expandsSelectedPaths&lt;/code&gt; property. If
     * true, any time the selection is changed, either via the
     * &lt;code&gt;TreeSelectionModel&lt;/code&gt;, or the cover methods provided by
     * &lt;code&gt;JTree&lt;/code&gt;, the &lt;code&gt;TreePath&lt;/code&gt;s parents will be
     * expanded to make them visible (visible meaning the parent path is
     * expanded, not necessarily in the visible rectangle of the
     * &lt;code&gt;JTree&lt;/code&gt;). If false, when the selection
     * changes the nodes parent is not made visible (all its parents expanded).
     * This is useful if you wish to have your selection model maintain paths
     * that are not always visible (all parents expanded).
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param newValue the new value for &lt;code&gt;expandsSelectedPaths&lt;/code&gt;
     *
     * @since 1.3
     * @beaninfo
     *        bound: true
     *  description: Indicates whether changes to the selection should make
     *               the parent of the path visible.
     */
    public void setExpandsSelectedPaths(boolean newValue) {
<span class="nc" id="L1164">        boolean         oldValue = expandsSelectedPaths;</span>

<span class="nc" id="L1166">        expandsSelectedPaths = newValue;</span>
<span class="nc" id="L1167">        firePropertyChange(EXPANDS_SELECTED_PATHS_PROPERTY, oldValue,</span>
                           newValue);
<span class="nc" id="L1169">    }</span>

    /**
     * Returns the &lt;code&gt;expandsSelectedPaths&lt;/code&gt; property.
     * @return true if selection changes result in the parent path being
     *         expanded
     * @since 1.3
     * @see #setExpandsSelectedPaths
     */
    public boolean getExpandsSelectedPaths() {
<span class="nc" id="L1179">        return expandsSelectedPaths;</span>
    }

    /**
     * Turns on or off automatic drag handling. In order to enable automatic
     * drag handling, this property should be set to {@code true}, and the
     * tree's {@code TransferHandler} needs to be {@code non-null}.
     * The default value of the {@code dragEnabled} property is {@code false}.
     * &lt;p&gt;
     * The job of honoring this property, and recognizing a user drag gesture,
     * lies with the look and feel implementation, and in particular, the tree's
     * {@code TreeUI}. When automatic drag handling is enabled, most look and
     * feels (including those that subclass {@code BasicLookAndFeel}) begin a
     * drag and drop operation whenever the user presses the mouse button over
     * an item and then moves the mouse a few pixels. Setting this property to
     * {@code true} can therefore have a subtle effect on how selections behave.
     * &lt;p&gt;
     * If a look and feel is used that ignores this property, you can still
     * begin a drag and drop operation by calling {@code exportAsDrag} on the
     * tree's {@code TransferHandler}.
     *
     * @param b whether or not to enable automatic drag handling
     * @exception HeadlessException if
     *            &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and
     *            &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt;
     *            returns &lt;code&gt;true&lt;/code&gt;
     * @see java.awt.GraphicsEnvironment#isHeadless
     * @see #getDragEnabled
     * @see #setTransferHandler
     * @see TransferHandler
     * @since 1.4
     *
     * @beaninfo
     *  description: determines whether automatic drag handling is enabled
     *        bound: false
     */
    public void setDragEnabled(boolean b) {
<span class="nc bnc" id="L1216" title="All 4 branches missed.">        if (b &amp;&amp; GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L1217">            throw new HeadlessException();</span>
        }
<span class="nc" id="L1219">        dragEnabled = b;</span>
<span class="nc" id="L1220">    }</span>

    /**
     * Returns whether or not automatic drag handling is enabled.
     *
     * @return the value of the {@code dragEnabled} property
     * @see #setDragEnabled
     * @since 1.4
     */
    public boolean getDragEnabled() {
<span class="nc" id="L1230">        return dragEnabled;</span>
    }

    /**
     * Sets the drop mode for this component. For backward compatibility,
     * the default for this property is &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;.
     * Usage of one of the other modes is recommended, however, for an
     * improved user experience. &lt;code&gt;DropMode.ON&lt;/code&gt;, for instance,
     * offers similar behavior of showing items as selected, but does so without
     * affecting the actual selection in the tree.
     * &lt;p&gt;
     * &lt;code&gt;JTree&lt;/code&gt; supports the following drop modes:
     * &lt;ul&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.ON&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.INSERT&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The drop mode is only meaningful if this component has a
     * &lt;code&gt;TransferHandler&lt;/code&gt; that accepts drops.
     *
     * @param dropMode the drop mode to use
     * @throws IllegalArgumentException if the drop mode is unsupported
     *         or &lt;code&gt;null&lt;/code&gt;
     * @see #getDropMode
     * @see #getDropLocation
     * @see #setTransferHandler
     * @see TransferHandler
     * @since 1.6
     */
    public final void setDropMode(DropMode dropMode) {
<span class="nc bnc" id="L1262" title="All 2 branches missed.">        if (dropMode != null) {</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">            switch (dropMode) {</span>
                case USE_SELECTION:
                case ON:
                case INSERT:
                case ON_OR_INSERT:
<span class="nc" id="L1268">                    this.dropMode = dropMode;</span>
<span class="nc" id="L1269">                    return;</span>
            }
        }

<span class="nc" id="L1273">        throw new IllegalArgumentException(dropMode + &quot;: Unsupported drop mode for tree&quot;);</span>
    }

    /**
     * Returns the drop mode for this component.
     *
     * @return the drop mode for this component
     * @see #setDropMode
     * @since 1.6
     */
    public final DropMode getDropMode() {
<span class="nc" id="L1284">        return dropMode;</span>
    }

    /**
     * Calculates a drop location in this component, representing where a
     * drop at the given point should insert data.
     *
     * @param p the point to calculate a drop location for
     * @return the drop location, or &lt;code&gt;null&lt;/code&gt;
     */
    DropLocation dropLocationForPoint(Point p) {
<span class="nc" id="L1295">        DropLocation location = null;</span>

<span class="nc" id="L1297">        int row = getClosestRowForLocation(p.x, p.y);</span>
<span class="nc" id="L1298">        Rectangle bounds = getRowBounds(row);</span>
<span class="nc" id="L1299">        TreeModel model = getModel();</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">        Object root = (model == null) ? null : model.getRoot();</span>
<span class="nc bnc" id="L1301" title="All 2 branches missed.">        TreePath rootPath = (root == null) ? null : new TreePath(root);</span>

        TreePath child;
        TreePath parent;
<span class="nc bnc" id="L1305" title="All 6 branches missed.">        boolean outside = row == -1</span>
                          || p.y &lt; bounds.y
                          || p.y &gt;= bounds.y + bounds.height;

<span class="nc bnc" id="L1309" title="All 3 branches missed.">        switch(dropMode) {</span>
            case USE_SELECTION:
            case ON:
<span class="nc bnc" id="L1312" title="All 2 branches missed.">                if (outside) {</span>
<span class="nc" id="L1313">                    location = new DropLocation(p, null, -1);</span>
                } else {
<span class="nc" id="L1315">                    location = new DropLocation(p, getPathForRow(row), -1);</span>
                }

<span class="nc" id="L1318">                break;</span>
            case INSERT:
            case ON_OR_INSERT:
<span class="nc bnc" id="L1321" title="All 2 branches missed.">                if (row == -1) {</span>
<span class="nc bnc" id="L1322" title="All 6 branches missed.">                    if (root != null &amp;&amp; !model.isLeaf(root) &amp;&amp; isExpanded(rootPath)) {</span>
<span class="nc" id="L1323">                        location = new DropLocation(p, rootPath, 0);</span>
                    } else {
<span class="nc" id="L1325">                        location = new DropLocation(p, null, -1);</span>
                    }

<span class="nc" id="L1328">                    break;</span>
                }

<span class="nc bnc" id="L1331" title="All 2 branches missed.">                boolean checkOn = dropMode == DropMode.ON_OR_INSERT</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">                                  || !model.isLeaf(getPathForRow(row).getLastPathComponent());</span>

<span class="nc" id="L1334">                Section section = SwingUtilities2.liesInVertical(bounds, p, checkOn);</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">                if(section == LEADING) {</span>
<span class="nc" id="L1336">                    child = getPathForRow(row);</span>
<span class="nc" id="L1337">                    parent = child.getParentPath();</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">                } else if (section == TRAILING) {</span>
<span class="nc" id="L1339">                    int index = row + 1;</span>
<span class="nc bnc" id="L1340" title="All 2 branches missed.">                    if (index &gt;= getRowCount()) {</span>
<span class="nc bnc" id="L1341" title="All 4 branches missed.">                        if (model.isLeaf(root) || !isExpanded(rootPath)) {</span>
<span class="nc" id="L1342">                            location = new DropLocation(p, null, -1);</span>
                        } else {
<span class="nc" id="L1344">                            parent = rootPath;</span>
<span class="nc" id="L1345">                            index = model.getChildCount(root);</span>
<span class="nc" id="L1346">                            location = new DropLocation(p, parent, index);</span>
                        }

<span class="nc" id="L1349">                        break;</span>
                    }

<span class="nc" id="L1352">                    child = getPathForRow(index);</span>
<span class="nc" id="L1353">                    parent = child.getParentPath();</span>
<span class="nc" id="L1354">                } else {</span>
<span class="nc bnc" id="L1355" title="All 4 branches missed.">                    assert checkOn;</span>
<span class="nc" id="L1356">                    location = new DropLocation(p, getPathForRow(row), -1);</span>
<span class="nc" id="L1357">                    break;</span>
                }

<span class="nc bnc" id="L1360" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L1361">                    location = new DropLocation(p, parent,</span>
<span class="nc" id="L1362">                        model.getIndexOfChild(parent.getLastPathComponent(),</span>
<span class="nc" id="L1363">                                              child.getLastPathComponent()));</span>
<span class="nc bnc" id="L1364" title="All 4 branches missed.">                } else if (checkOn || !model.isLeaf(root)) {</span>
<span class="nc" id="L1365">                    location = new DropLocation(p, rootPath, -1);</span>
                } else {
<span class="nc" id="L1367">                    location = new DropLocation(p, null, -1);</span>
                }

<span class="nc" id="L1370">                break;</span>
            default:
<span class="nc bnc" id="L1372" title="All 2 branches missed.">                assert false : &quot;Unexpected drop mode&quot;;</span>
        }

<span class="nc bnc" id="L1375" title="All 4 branches missed.">        if (outside || row != expandRow) {</span>
<span class="nc" id="L1376">            cancelDropTimer();</span>
        }

<span class="nc bnc" id="L1379" title="All 4 branches missed.">        if (!outside &amp;&amp; row != expandRow) {</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">            if (isCollapsed(row)) {</span>
<span class="nc" id="L1381">                expandRow = row;</span>
<span class="nc" id="L1382">                startDropTimer();</span>
            }
        }

<span class="nc" id="L1386">        return location;</span>
    }

    /**
     * Called to set or clear the drop location during a DnD operation.
     * In some cases, the component may need to use it's internal selection
     * temporarily to indicate the drop location. To help facilitate this,
     * this method returns and accepts as a parameter a state object.
     * This state object can be used to store, and later restore, the selection
     * state. Whatever this method returns will be passed back to it in
     * future calls, as the state parameter. If it wants the DnD system to
     * continue storing the same state, it must pass it back every time.
     * Here's how this is used:
     * &lt;p&gt;
     * Let's say that on the first call to this method the component decides
     * to save some state (because it is about to use the selection to show
     * a drop index). It can return a state object to the caller encapsulating
     * any saved selection state. On a second call, let's say the drop location
     * is being changed to something else. The component doesn't need to
     * restore anything yet, so it simply passes back the same state object
     * to have the DnD system continue storing it. Finally, let's say this
     * method is messaged with &lt;code&gt;null&lt;/code&gt;. This means DnD
     * is finished with this component for now, meaning it should restore
     * state. At this point, it can use the state parameter to restore
     * said state, and of course return &lt;code&gt;null&lt;/code&gt; since there's
     * no longer anything to store.
     *
     * @param location the drop location (as calculated by
     *        &lt;code&gt;dropLocationForPoint&lt;/code&gt;) or &lt;code&gt;null&lt;/code&gt;
     *        if there's no longer a valid drop location
     * @param state the state object saved earlier for this component,
     *        or &lt;code&gt;null&lt;/code&gt;
     * @param forDrop whether or not the method is being called because an
     *        actual drop occurred
     * @return any saved state for this component, or &lt;code&gt;null&lt;/code&gt; if none
     */
    Object setDropLocation(TransferHandler.DropLocation location,
                           Object state,
                           boolean forDrop) {

<span class="nc" id="L1426">        Object retVal = null;</span>
<span class="nc" id="L1427">        DropLocation treeLocation = (DropLocation)location;</span>

<span class="nc bnc" id="L1429" title="All 2 branches missed.">        if (dropMode == DropMode.USE_SELECTION) {</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">            if (treeLocation == null) {</span>
<span class="nc bnc" id="L1431" title="All 4 branches missed.">                if (!forDrop &amp;&amp; state != null) {</span>
<span class="nc" id="L1432">                    setSelectionPaths(((TreePath[][])state)[0]);</span>
<span class="nc" id="L1433">                    setAnchorSelectionPath(((TreePath[][])state)[1][0]);</span>
<span class="nc" id="L1434">                    setLeadSelectionPath(((TreePath[][])state)[1][1]);</span>
                }
            } else {
<span class="nc bnc" id="L1437" title="All 2 branches missed.">                if (dropLocation == null) {</span>
<span class="nc" id="L1438">                    TreePath[] paths = getSelectionPaths();</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">                    if (paths == null) {</span>
<span class="nc" id="L1440">                        paths = new TreePath[0];</span>
                    }

<span class="nc" id="L1443">                    retVal = new TreePath[][] {paths,</span>
<span class="nc" id="L1444">                            {getAnchorSelectionPath(), getLeadSelectionPath()}};</span>
<span class="nc" id="L1445">                } else {</span>
<span class="nc" id="L1446">                    retVal = state;</span>
                }

<span class="nc" id="L1449">                setSelectionPath(treeLocation.getPath());</span>
            }
        }

<span class="nc" id="L1453">        DropLocation old = dropLocation;</span>
<span class="nc" id="L1454">        dropLocation = treeLocation;</span>
<span class="nc" id="L1455">        firePropertyChange(&quot;dropLocation&quot;, old, dropLocation);</span>

<span class="nc" id="L1457">        return retVal;</span>
    }

    /**
     * Called to indicate to this component that DnD is done.
     * Allows for us to cancel the expand timer.
     */
    void dndDone() {
<span class="nc" id="L1465">        cancelDropTimer();</span>
<span class="nc" id="L1466">        dropTimer = null;</span>
<span class="nc" id="L1467">    }</span>

    /**
     * Returns the location that this component should visually indicate
     * as the drop location during a DnD operation over the component,
     * or {@code null} if no location is to currently be shown.
     * &lt;p&gt;
     * This method is not meant for querying the drop location
     * from a {@code TransferHandler}, as the drop location is only
     * set after the {@code TransferHandler}'s &lt;code&gt;canImport&lt;/code&gt;
     * has returned and has allowed for the location to be shown.
     * &lt;p&gt;
     * When this property changes, a property change event with
     * name &quot;dropLocation&quot; is fired by the component.
     *
     * @return the drop location
     * @see #setDropMode
     * @see TransferHandler#canImport(TransferHandler.TransferSupport)
     * @since 1.6
     */
    public final DropLocation getDropLocation() {
<span class="nc" id="L1488">        return dropLocation;</span>
    }

    private void startDropTimer() {
<span class="nc bnc" id="L1492" title="All 2 branches missed.">        if (dropTimer == null) {</span>
<span class="nc" id="L1493">            dropTimer = new TreeTimer();</span>
        }
<span class="nc" id="L1495">        dropTimer.start();</span>
<span class="nc" id="L1496">    }</span>

    private void cancelDropTimer() {
<span class="nc bnc" id="L1499" title="All 4 branches missed.">        if (dropTimer != null &amp;&amp; dropTimer.isRunning()) {</span>
<span class="nc" id="L1500">            expandRow = -1;</span>
<span class="nc" id="L1501">            dropTimer.stop();</span>
        }
<span class="nc" id="L1503">    }</span>

    /**
     * Returns &lt;code&gt;isEditable&lt;/code&gt;. This is invoked from the UI before
     * editing begins to insure that the given path can be edited. This
     * is provided as an entry point for subclassers to add filtered
     * editing without having to resort to creating a new editor.
     *
     * @return true if every parent node and the node itself is editable
     * @see #isEditable
     */
    public boolean isPathEditable(TreePath path) {
<span class="nc" id="L1515">        return isEditable();</span>
    }

    /**
     * Overrides &lt;code&gt;JComponent&lt;/code&gt;'s &lt;code&gt;getToolTipText&lt;/code&gt;
     * method in order to allow
     * renderer's tips to be used if it has text set.
     * &lt;p&gt;
     * NOTE: For &lt;code&gt;JTree&lt;/code&gt; to properly display tooltips of its
     * renderers, &lt;code&gt;JTree&lt;/code&gt; must be a registered component with the
     * &lt;code&gt;ToolTipManager&lt;/code&gt;.  This can be done by invoking
     * &lt;code&gt;ToolTipManager.sharedInstance().registerComponent(tree)&lt;/code&gt;.
     * This is not done automatically!
     *
     * @param event the &lt;code&gt;MouseEvent&lt;/code&gt; that initiated the
     *          &lt;code&gt;ToolTip&lt;/code&gt; display
     * @return a string containing the  tooltip or &lt;code&gt;null&lt;/code&gt;
     *          if &lt;code&gt;event&lt;/code&gt; is null
     */
    public String getToolTipText(MouseEvent event) {
<span class="nc" id="L1535">        String tip = null;</span>

<span class="nc bnc" id="L1537" title="All 2 branches missed.">        if(event != null) {</span>
<span class="nc" id="L1538">            Point p = event.getPoint();</span>
<span class="nc" id="L1539">            int selRow = getRowForLocation(p.x, p.y);</span>
<span class="nc" id="L1540">            TreeCellRenderer       r = getCellRenderer();</span>

<span class="nc bnc" id="L1542" title="All 4 branches missed.">            if(selRow != -1 &amp;&amp; r != null) {</span>
<span class="nc" id="L1543">                TreePath     path = getPathForRow(selRow);</span>
<span class="nc" id="L1544">                Object       lastPath = path.getLastPathComponent();</span>
<span class="nc" id="L1545">                Component    rComponent = r.getTreeCellRendererComponent</span>
<span class="nc" id="L1546">                    (this, lastPath, isRowSelected(selRow),</span>
<span class="nc" id="L1547">                     isExpanded(selRow), getModel().isLeaf(lastPath), selRow,</span>
                     true);

<span class="nc bnc" id="L1550" title="All 2 branches missed.">                if(rComponent instanceof JComponent) {</span>
                    MouseEvent      newEvent;
<span class="nc" id="L1552">                    Rectangle       pathBounds = getPathBounds(path);</span>

<span class="nc" id="L1554">                    p.translate(-pathBounds.x, -pathBounds.y);</span>
<span class="nc" id="L1555">                    newEvent = new MouseEvent(rComponent, event.getID(),</span>
<span class="nc" id="L1556">                                          event.getWhen(),</span>
<span class="nc" id="L1557">                                              event.getModifiers(),</span>
                                              p.x, p.y,
<span class="nc" id="L1559">                                              event.getXOnScreen(),</span>
<span class="nc" id="L1560">                                              event.getYOnScreen(),</span>
<span class="nc" id="L1561">                                              event.getClickCount(),</span>
<span class="nc" id="L1562">                                              event.isPopupTrigger(),</span>
                                              MouseEvent.NOBUTTON);

<span class="nc" id="L1565">                    tip = ((JComponent)rComponent).getToolTipText(newEvent);</span>
                }
            }
        }
        // No tip from the renderer get our own tip
<span class="nc bnc" id="L1570" title="All 2 branches missed.">        if (tip == null) {</span>
<span class="nc" id="L1571">            tip = getToolTipText();</span>
        }
<span class="nc" id="L1573">        return tip;</span>
    }

    /**
     * Called by the renderers to convert the specified value to
     * text. This implementation returns &lt;code&gt;value.toString&lt;/code&gt;, ignoring
     * all other arguments. To control the conversion, subclass this
     * method and use any of the arguments you need.
     *
     * @param value the &lt;code&gt;Object&lt;/code&gt; to convert to text
     * @param selected true if the node is selected
     * @param expanded true if the node is expanded
     * @param leaf  true if the node is a leaf node
     * @param row  an integer specifying the node's display row, where 0 is
     *             the first row in the display
     * @param hasFocus true if the node has the focus
     * @return the &lt;code&gt;String&lt;/code&gt; representation of the node's value
     */
    public String convertValueToText(Object value, boolean selected,
                                     boolean expanded, boolean leaf, int row,
                                     boolean hasFocus) {
<span class="nc bnc" id="L1594" title="All 2 branches missed.">        if(value != null) {</span>
<span class="nc" id="L1595">            String sValue = value.toString();</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">            if (sValue != null) {</span>
<span class="nc" id="L1597">                return sValue;</span>
            }
        }
<span class="nc" id="L1600">        return &quot;&quot;;</span>
    }

    //
    // The following are convenience methods that get forwarded to the
    // current TreeUI.
    //

    /**
     * Returns the number of viewable nodes. A node is viewable if all of its
     * parents are expanded. The root is only included in this count if
     * {@code isRootVisible()} is {@code true}. This returns {@code 0} if
     * the UI has not been set.
     *
     * @return the number of viewable nodes
     */
    public int getRowCount() {
<span class="nc" id="L1617">        TreeUI            tree = getUI();</span>

<span class="nc bnc" id="L1619" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L1620">            return tree.getRowCount(this);</span>
<span class="nc" id="L1621">        return 0;</span>
    }

    /**
     * Selects the node identified by the specified path. If any
     * component of the path is hidden (under a collapsed node), and
     * &lt;code&gt;getExpandsSelectedPaths&lt;/code&gt; is true it is
     * exposed (made viewable).
     *
     * @param path the &lt;code&gt;TreePath&lt;/code&gt; specifying the node to select
     */
    public void setSelectionPath(TreePath path) {
<span class="nc" id="L1633">        getSelectionModel().setSelectionPath(path);</span>
<span class="nc" id="L1634">    }</span>

    /**
     * Selects the nodes identified by the specified array of paths.
     * If any component in any of the paths is hidden (under a collapsed
     * node), and &lt;code&gt;getExpandsSelectedPaths&lt;/code&gt; is true
     * it is exposed (made viewable).
     *
     * @param paths an array of &lt;code&gt;TreePath&lt;/code&gt; objects that specifies
     *          the nodes to select
     */
    public void setSelectionPaths(TreePath[] paths) {
<span class="nc" id="L1646">        getSelectionModel().setSelectionPaths(paths);</span>
<span class="nc" id="L1647">    }</span>

    /**
     * Sets the path identifies as the lead. The lead may not be selected.
     * The lead is not maintained by &lt;code&gt;JTree&lt;/code&gt;,
     * rather the UI will update it.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param newPath  the new lead path
     * @since 1.3
     * @beaninfo
     *        bound: true
     *  description: Lead selection path
     */
    public void setLeadSelectionPath(TreePath newPath) {
<span class="nc" id="L1663">        TreePath          oldValue = leadPath;</span>

<span class="nc" id="L1665">        leadPath = newPath;</span>
<span class="nc" id="L1666">        firePropertyChange(LEAD_SELECTION_PATH_PROPERTY, oldValue, newPath);</span>
<span class="nc" id="L1667">    }</span>

    /**
     * Sets the path identified as the anchor.
     * The anchor is not maintained by &lt;code&gt;JTree&lt;/code&gt;, rather the UI will
     * update it.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param newPath  the new anchor path
     * @since 1.3
     * @beaninfo
     *        bound: true
     *  description: Anchor selection path
     */
    public void setAnchorSelectionPath(TreePath newPath) {
<span class="nc" id="L1683">        TreePath          oldValue = anchorPath;</span>

<span class="nc" id="L1685">        anchorPath = newPath;</span>
<span class="nc" id="L1686">        firePropertyChange(ANCHOR_SELECTION_PATH_PROPERTY, oldValue, newPath);</span>
<span class="nc" id="L1687">    }</span>

    /**
     * Selects the node at the specified row in the display.
     *
     * @param row  the row to select, where 0 is the first row in
     *             the display
     */
    public void setSelectionRow(int row) {
<span class="nc" id="L1696">        int[]             rows = { row };</span>

<span class="nc" id="L1698">        setSelectionRows(rows);</span>
<span class="nc" id="L1699">    }</span>

    /**
     * Selects the nodes corresponding to each of the specified rows
     * in the display. If a particular element of &lt;code&gt;rows&lt;/code&gt; is
     * &amp;lt; 0 or &amp;gt;= &lt;code&gt;getRowCount&lt;/code&gt;, it will be ignored.
     * If none of the elements
     * in &lt;code&gt;rows&lt;/code&gt; are valid rows, the selection will
     * be cleared. That is it will be as if &lt;code&gt;clearSelection&lt;/code&gt;
     * was invoked.
     *
     * @param rows  an array of ints specifying the rows to select,
     *              where 0 indicates the first row in the display
     */
    public void setSelectionRows(int[] rows) {
<span class="nc" id="L1714">        TreeUI               ui = getUI();</span>

<span class="nc bnc" id="L1716" title="All 4 branches missed.">        if(ui != null &amp;&amp; rows != null) {</span>
<span class="nc" id="L1717">            int                  numRows = rows.length;</span>
<span class="nc" id="L1718">            TreePath[]           paths = new TreePath[numRows];</span>

<span class="nc bnc" id="L1720" title="All 2 branches missed.">            for(int counter = 0; counter &lt; numRows; counter++) {</span>
<span class="nc" id="L1721">                paths[counter] = ui.getPathForRow(this, rows[counter]);</span>
            }
<span class="nc" id="L1723">            setSelectionPaths(paths);</span>
        }
<span class="nc" id="L1725">    }</span>

    /**
     * Adds the node identified by the specified &lt;code&gt;TreePath&lt;/code&gt;
     * to the current selection. If any component of the path isn't
     * viewable, and &lt;code&gt;getExpandsSelectedPaths&lt;/code&gt; is true it is
     * made viewable.
     * &lt;p&gt;
     * Note that &lt;code&gt;JTree&lt;/code&gt; does not allow duplicate nodes to
     * exist as children under the same parent -- each sibling must be
     * a unique object.
     *
     * @param path the &lt;code&gt;TreePath&lt;/code&gt; to add
     */
    public void addSelectionPath(TreePath path) {
<span class="nc" id="L1740">        getSelectionModel().addSelectionPath(path);</span>
<span class="nc" id="L1741">    }</span>

    /**
     * Adds each path in the array of paths to the current selection. If
     * any component of any of the paths isn't viewable and
     * &lt;code&gt;getExpandsSelectedPaths&lt;/code&gt; is true, it is
     * made viewable.
     * &lt;p&gt;
     * Note that &lt;code&gt;JTree&lt;/code&gt; does not allow duplicate nodes to
     * exist as children under the same parent -- each sibling must be
     * a unique object.
     *
     * @param paths an array of &lt;code&gt;TreePath&lt;/code&gt; objects that specifies
     *          the nodes to add
     */
    public void addSelectionPaths(TreePath[] paths) {
<span class="nc" id="L1757">        getSelectionModel().addSelectionPaths(paths);</span>
<span class="nc" id="L1758">    }</span>

    /**
     * Adds the path at the specified row to the current selection.
     *
     * @param row  an integer specifying the row of the node to add,
     *             where 0 is the first row in the display
     */
    public void addSelectionRow(int row) {
<span class="nc" id="L1767">        int[]      rows = { row };</span>

<span class="nc" id="L1769">        addSelectionRows(rows);</span>
<span class="nc" id="L1770">    }</span>

    /**
     * Adds the paths at each of the specified rows to the current selection.
     *
     * @param rows  an array of ints specifying the rows to add,
     *              where 0 indicates the first row in the display
     */
    public void addSelectionRows(int[] rows) {
<span class="nc" id="L1779">        TreeUI             ui = getUI();</span>

<span class="nc bnc" id="L1781" title="All 4 branches missed.">        if(ui != null &amp;&amp; rows != null) {</span>
<span class="nc" id="L1782">            int                  numRows = rows.length;</span>
<span class="nc" id="L1783">            TreePath[]           paths = new TreePath[numRows];</span>

<span class="nc bnc" id="L1785" title="All 2 branches missed.">            for(int counter = 0; counter &lt; numRows; counter++)</span>
<span class="nc" id="L1786">                paths[counter] = ui.getPathForRow(this, rows[counter]);</span>
<span class="nc" id="L1787">            addSelectionPaths(paths);</span>
        }
<span class="nc" id="L1789">    }</span>

    /**
     * Returns the last path component of the selected path. This is
     * a convenience method for
     * {@code getSelectionModel().getSelectionPath().getLastPathComponent()}.
     * This is typically only useful if the selection has one path.
     *
     * @return the last path component of the selected path, or
     *         &lt;code&gt;null&lt;/code&gt; if nothing is selected
     * @see TreePath#getLastPathComponent
     */
    public Object getLastSelectedPathComponent() {
<span class="nc" id="L1802">        TreePath     selPath = getSelectionModel().getSelectionPath();</span>

<span class="nc bnc" id="L1804" title="All 2 branches missed.">        if(selPath != null)</span>
<span class="nc" id="L1805">            return selPath.getLastPathComponent();</span>
<span class="nc" id="L1806">        return null;</span>
    }

    /**
     * Returns the path identified as the lead.
     * @return path identified as the lead
     */
    public TreePath getLeadSelectionPath() {
<span class="nc" id="L1814">        return leadPath;</span>
    }

    /**
     * Returns the path identified as the anchor.
     * @return path identified as the anchor
     * @since 1.3
     */
    public TreePath getAnchorSelectionPath() {
<span class="nc" id="L1823">        return anchorPath;</span>
    }

    /**
     * Returns the path to the first selected node.
     *
     * @return the &lt;code&gt;TreePath&lt;/code&gt; for the first selected node,
     *          or &lt;code&gt;null&lt;/code&gt; if nothing is currently selected
     */
    public TreePath getSelectionPath() {
<span class="nc" id="L1833">        return getSelectionModel().getSelectionPath();</span>
    }

    /**
     * Returns the paths of all selected values.
     *
     * @return an array of &lt;code&gt;TreePath&lt;/code&gt; objects indicating the selected
     *         nodes, or &lt;code&gt;null&lt;/code&gt; if nothing is currently selected
     */
    public TreePath[] getSelectionPaths() {
<span class="nc" id="L1843">        TreePath[] selectionPaths = getSelectionModel().getSelectionPaths();</span>

<span class="nc bnc" id="L1845" title="All 4 branches missed.">        return (selectionPaths != null &amp;&amp; selectionPaths.length &gt; 0) ? selectionPaths : null;</span>
    }

    /**
     * Returns all of the currently selected rows. This method is simply
     * forwarded to the &lt;code&gt;TreeSelectionModel&lt;/code&gt;.
     * If nothing is selected &lt;code&gt;null&lt;/code&gt; or an empty array will
     * be returned, based on the &lt;code&gt;TreeSelectionModel&lt;/code&gt;
     * implementation.
     *
     * @return an array of integers that identifies all currently selected rows
     *         where 0 is the first row in the display
     */
    public int[] getSelectionRows() {
<span class="nc" id="L1859">        return getSelectionModel().getSelectionRows();</span>
    }

    /**
     * Returns the number of nodes selected.
     *
     * @return the number of nodes selected
     */
    public int getSelectionCount() {
<span class="nc" id="L1868">        return selectionModel.getSelectionCount();</span>
    }

    /**
     * Returns the smallest selected row. If the selection is empty, or
     * none of the selected paths are viewable, {@code -1} is returned.
     *
     * @return the smallest selected row
     */
    public int getMinSelectionRow() {
<span class="nc" id="L1878">        return getSelectionModel().getMinSelectionRow();</span>
    }

    /**
     * Returns the largest selected row. If the selection is empty, or
     * none of the selected paths are viewable, {@code -1} is returned.
     *
     * @return the largest selected row
     */
    public int getMaxSelectionRow() {
<span class="nc" id="L1888">        return getSelectionModel().getMaxSelectionRow();</span>
    }

    /**
     * Returns the row index corresponding to the lead path.
     *
     * @return an integer giving the row index of the lead path,
     *          where 0 is the first row in the display; or -1
     *          if &lt;code&gt;leadPath&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     */
    public int getLeadSelectionRow() {
<span class="nc" id="L1899">        TreePath leadPath = getLeadSelectionPath();</span>

<span class="nc bnc" id="L1901" title="All 2 branches missed.">        if (leadPath != null) {</span>
<span class="nc" id="L1902">            return getRowForPath(leadPath);</span>
        }
<span class="nc" id="L1904">        return -1;</span>
    }

    /**
     * Returns true if the item identified by the path is currently selected.
     *
     * @param path a &lt;code&gt;TreePath&lt;/code&gt; identifying a node
     * @return true if the node is selected
     */
    public boolean isPathSelected(TreePath path) {
<span class="nc" id="L1914">        return getSelectionModel().isPathSelected(path);</span>
    }

    /**
     * Returns true if the node identified by row is selected.
     *
     * @param row  an integer specifying a display row, where 0 is the first
     *             row in the display
     * @return true if the node is selected
     */
    public boolean isRowSelected(int row) {
<span class="nc" id="L1925">        return getSelectionModel().isRowSelected(row);</span>
    }

    /**
     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of the descendants of the
     * path &lt;code&gt;parent&lt;/code&gt; that
     * are currently expanded. If &lt;code&gt;parent&lt;/code&gt; is not currently
     * expanded, this will return &lt;code&gt;null&lt;/code&gt;.
     * If you expand/collapse nodes while
     * iterating over the returned &lt;code&gt;Enumeration&lt;/code&gt;
     * this may not return all
     * the expanded paths, or may return paths that are no longer expanded.
     *
     * @param parent  the path which is to be examined
     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of the descendents of
     *          &lt;code&gt;parent&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if
     *          &lt;code&gt;parent&lt;/code&gt; is not currently expanded
     */
    public Enumeration&lt;TreePath&gt; getExpandedDescendants(TreePath parent) {
<span class="nc bnc" id="L1944" title="All 2 branches missed.">        if(!isExpanded(parent))</span>
<span class="nc" id="L1945">            return null;</span>

<span class="nc" id="L1947">        Enumeration&lt;TreePath&gt; toggledPaths = expandedState.keys();</span>
<span class="nc" id="L1948">        Vector&lt;TreePath&gt; elements = null;</span>
        TreePath          path;
        Object            value;

<span class="nc bnc" id="L1952" title="All 2 branches missed.">        if(toggledPaths != null) {</span>
<span class="nc bnc" id="L1953" title="All 2 branches missed.">            while(toggledPaths.hasMoreElements()) {</span>
<span class="nc" id="L1954">                path = toggledPaths.nextElement();</span>
<span class="nc" id="L1955">                value = expandedState.get(path);</span>
                // Add the path if it is expanded, a descendant of parent,
                // and it is visible (all parents expanded). This is rather
                // expensive!
<span class="nc bnc" id="L1959" title="All 4 branches missed.">                if(path != parent &amp;&amp; value != null &amp;&amp;</span>
<span class="nc bnc" id="L1960" title="All 2 branches missed.">                   ((Boolean)value).booleanValue() &amp;&amp;</span>
<span class="nc bnc" id="L1961" title="All 4 branches missed.">                   parent.isDescendant(path) &amp;&amp; isVisible(path)) {</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">                    if (elements == null) {</span>
<span class="nc" id="L1963">                        elements = new Vector&lt;TreePath&gt;();</span>
                    }
<span class="nc" id="L1965">                    elements.addElement(path);</span>
                }
            }
        }
<span class="nc bnc" id="L1969" title="All 2 branches missed.">        if (elements == null) {</span>
<span class="nc" id="L1970">            Set&lt;TreePath&gt; empty = Collections.emptySet();</span>
<span class="nc" id="L1971">            return Collections.enumeration(empty);</span>
        }
<span class="nc" id="L1973">        return elements.elements();</span>
    }

    /**
     * Returns true if the node identified by the path has ever been
     * expanded.
     * @return true if the &lt;code&gt;path&lt;/code&gt; has ever been expanded
     */
    public boolean hasBeenExpanded(TreePath path) {
<span class="nc bnc" id="L1982" title="All 4 branches missed.">        return (path != null &amp;&amp; expandedState.get(path) != null);</span>
    }

    /**
     * Returns true if the node identified by the path is currently expanded,
     *
     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; specifying the node to check
     * @return false if any of the nodes in the node's path are collapsed,
     *               true if all nodes in the path are expanded
     */
    public boolean isExpanded(TreePath path) {

<span class="nc bnc" id="L1994" title="All 2 branches missed.">        if(path == null)</span>
<span class="nc" id="L1995">            return false;</span>
        Object  value;

        do{
<span class="nc" id="L1999">            value = expandedState.get(path);</span>
<span class="nc bnc" id="L2000" title="All 4 branches missed.">            if(value == null || !((Boolean)value).booleanValue())</span>
<span class="nc" id="L2001">                return false;</span>
<span class="nc bnc" id="L2002" title="All 2 branches missed.">        } while( (path=path.getParentPath())!=null );</span>

<span class="nc" id="L2004">        return true;</span>
    }

    /**
     * Returns true if the node at the specified display row is currently
     * expanded.
     *
     * @param row  the row to check, where 0 is the first row in the
     *             display
     * @return true if the node is currently expanded, otherwise false
     */
    public boolean isExpanded(int row) {
<span class="nc" id="L2016">        TreeUI                  tree = getUI();</span>

<span class="nc bnc" id="L2018" title="All 2 branches missed.">        if(tree != null) {</span>
<span class="nc" id="L2019">            TreePath         path = tree.getPathForRow(this, row);</span>

<span class="nc bnc" id="L2021" title="All 2 branches missed.">            if(path != null) {</span>
<span class="nc" id="L2022">                Boolean value = expandedState.get(path);</span>

<span class="nc bnc" id="L2024" title="All 4 branches missed.">                return (value != null &amp;&amp; value.booleanValue());</span>
            }
        }
<span class="nc" id="L2027">        return false;</span>
    }

    /**
     * Returns true if the value identified by path is currently collapsed,
     * this will return false if any of the values in path are currently
     * not being displayed.
     *
     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; to check
     * @return true if any of the nodes in the node's path are collapsed,
     *               false if all nodes in the path are expanded
     */
    public boolean isCollapsed(TreePath path) {
<span class="nc bnc" id="L2040" title="All 2 branches missed.">        return !isExpanded(path);</span>
    }

    /**
     * Returns true if the node at the specified display row is collapsed.
     *
     * @param row  the row to check, where 0 is the first row in the
     *             display
     * @return true if the node is currently collapsed, otherwise false
     */
    public boolean isCollapsed(int row) {
<span class="nc bnc" id="L2051" title="All 2 branches missed.">        return !isExpanded(row);</span>
    }

    /**
     * Ensures that the node identified by path is currently viewable.
     *
     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; to make visible
     */
    public void makeVisible(TreePath path) {
<span class="nc bnc" id="L2060" title="All 2 branches missed.">        if(path != null) {</span>
<span class="nc" id="L2061">            TreePath        parentPath = path.getParentPath();</span>

<span class="nc bnc" id="L2063" title="All 2 branches missed.">            if(parentPath != null) {</span>
<span class="nc" id="L2064">                expandPath(parentPath);</span>
            }
        }
<span class="nc" id="L2067">    }</span>

    /**
     * Returns true if the value identified by path is currently viewable,
     * which means it is either the root or all of its parents are expanded.
     * Otherwise, this method returns false.
     *
     * @return true if the node is viewable, otherwise false
     */
    public boolean isVisible(TreePath path) {
<span class="nc bnc" id="L2077" title="All 2 branches missed.">        if(path != null) {</span>
<span class="nc" id="L2078">            TreePath        parentPath = path.getParentPath();</span>

<span class="nc bnc" id="L2080" title="All 2 branches missed.">            if(parentPath != null)</span>
<span class="nc" id="L2081">                return isExpanded(parentPath);</span>
            // Root.
<span class="nc" id="L2083">            return true;</span>
        }
<span class="nc" id="L2085">        return false;</span>
    }

    /**
     * Returns the &lt;code&gt;Rectangle&lt;/code&gt; that the specified node will be drawn
     * into. Returns &lt;code&gt;null&lt;/code&gt; if any component in the path is hidden
     * (under a collapsed parent).
     * &lt;p&gt;
     * Note:&lt;br&gt;
     * This method returns a valid rectangle, even if the specified
     * node is not currently displayed.
     *
     * @param path the &lt;code&gt;TreePath&lt;/code&gt; identifying the node
     * @return the &lt;code&gt;Rectangle&lt;/code&gt; the node is drawn in,
     *          or &lt;code&gt;null&lt;/code&gt;
     */
    public Rectangle getPathBounds(TreePath path) {
<span class="nc" id="L2102">        TreeUI                   tree = getUI();</span>

<span class="nc bnc" id="L2104" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L2105">            return tree.getPathBounds(this, path);</span>
<span class="nc" id="L2106">        return null;</span>
    }

    /**
     * Returns the &lt;code&gt;Rectangle&lt;/code&gt; that the node at the specified row is
     * drawn in.
     *
     * @param row  the row to be drawn, where 0 is the first row in the
     *             display
     * @return the &lt;code&gt;Rectangle&lt;/code&gt; the node is drawn in
     */
    public Rectangle getRowBounds(int row) {
<span class="nc" id="L2118">        return getPathBounds(getPathForRow(row));</span>
    }

    /**
     * Makes sure all the path components in path are expanded (except
     * for the last path component) and scrolls so that the
     * node identified by the path is displayed. Only works when this
     * &lt;code&gt;JTree&lt;/code&gt; is contained in a &lt;code&gt;JScrollPane&lt;/code&gt;.
     *
     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying the node to
     *          bring into view
     */
    public void scrollPathToVisible(TreePath path) {
<span class="nc bnc" id="L2131" title="All 2 branches missed.">        if(path != null) {</span>
<span class="nc" id="L2132">            makeVisible(path);</span>

<span class="nc" id="L2134">            Rectangle          bounds = getPathBounds(path);</span>

<span class="nc bnc" id="L2136" title="All 2 branches missed.">            if(bounds != null) {</span>
<span class="nc" id="L2137">                scrollRectToVisible(bounds);</span>
<span class="nc bnc" id="L2138" title="All 2 branches missed.">                if (accessibleContext != null) {</span>
<span class="nc" id="L2139">                    ((AccessibleJTree)accessibleContext).fireVisibleDataPropertyChange();</span>
                }
            }
        }
<span class="nc" id="L2143">    }</span>

    /**
     * Scrolls the item identified by row until it is displayed. The minimum
     * of amount of scrolling necessary to bring the row into view
     * is performed. Only works when this &lt;code&gt;JTree&lt;/code&gt; is contained in a
     * &lt;code&gt;JScrollPane&lt;/code&gt;.
     *
     * @param row  an integer specifying the row to scroll, where 0 is the
     *             first row in the display
     */
    public void scrollRowToVisible(int row) {
<span class="nc" id="L2155">        scrollPathToVisible(getPathForRow(row));</span>
<span class="nc" id="L2156">    }</span>

    /**
     * Returns the path for the specified row.  If &lt;code&gt;row&lt;/code&gt; is
     * not visible, or a {@code TreeUI} has not been set, &lt;code&gt;null&lt;/code&gt;
     * is returned.
     *
     * @param row  an integer specifying a row
     * @return the &lt;code&gt;TreePath&lt;/code&gt; to the specified node,
     *          &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;row &amp;lt; 0&lt;/code&gt;
     *          or &lt;code&gt;row &amp;gt;= getRowCount()&lt;/code&gt;
     */
    public TreePath getPathForRow(int row) {
<span class="nc" id="L2169">        TreeUI                  tree = getUI();</span>

<span class="nc bnc" id="L2171" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L2172">            return tree.getPathForRow(this, row);</span>
<span class="nc" id="L2173">        return null;</span>
    }

    /**
     * Returns the row that displays the node identified by the specified
     * path.
     *
     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying a node
     * @return an integer specifying the display row, where 0 is the first
     *         row in the display, or -1 if any of the elements in path
     *         are hidden under a collapsed parent.
     */
    public int getRowForPath(TreePath path) {
<span class="nc" id="L2186">        TreeUI                  tree = getUI();</span>

<span class="nc bnc" id="L2188" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L2189">            return tree.getRowForPath(this, path);</span>
<span class="nc" id="L2190">        return -1;</span>
    }

    /**
     * Ensures that the node identified by the specified path is
     * expanded and viewable. If the last item in the path is a
     * leaf, this will have no effect.
     *
     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying a node
     */
    public void expandPath(TreePath path) {
        // Only expand if not leaf!
<span class="nc" id="L2202">        TreeModel          model = getModel();</span>

<span class="nc bnc" id="L2204" title="All 4 branches missed.">        if(path != null &amp;&amp; model != null &amp;&amp;</span>
<span class="nc bnc" id="L2205" title="All 2 branches missed.">           !model.isLeaf(path.getLastPathComponent())) {</span>
<span class="nc" id="L2206">            setExpandedState(path, true);</span>
        }
<span class="nc" id="L2208">    }</span>

    /**
     * Ensures that the node in the specified row is expanded and
     * viewable.
     * &lt;p&gt;
     * If &lt;code&gt;row&lt;/code&gt; is &amp;lt; 0 or &amp;gt;= &lt;code&gt;getRowCount&lt;/code&gt; this
     * will have no effect.
     *
     * @param row  an integer specifying a display row, where 0 is the
     *             first row in the display
     */
    public void expandRow(int row) {
<span class="nc" id="L2221">        expandPath(getPathForRow(row));</span>
<span class="nc" id="L2222">    }</span>

    /**
     * Ensures that the node identified by the specified path is
     * collapsed and viewable.
     *
     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying a node
      */
    public void collapsePath(TreePath path) {
<span class="nc" id="L2231">        setExpandedState(path, false);</span>
<span class="nc" id="L2232">    }</span>

    /**
     * Ensures that the node in the specified row is collapsed.
     * &lt;p&gt;
     * If &lt;code&gt;row&lt;/code&gt; is &amp;lt; 0 or &amp;gt;= &lt;code&gt;getRowCount&lt;/code&gt; this
     * will have no effect.
     *
     * @param row  an integer specifying a display row, where 0 is the
     *             first row in the display
      */
    public void collapseRow(int row) {
<span class="nc" id="L2244">        collapsePath(getPathForRow(row));</span>
<span class="nc" id="L2245">    }</span>

    /**
     * Returns the path for the node at the specified location.
     *
     * @param x an integer giving the number of pixels horizontally from
     *          the left edge of the display area, minus any left margin
     * @param y an integer giving the number of pixels vertically from
     *          the top of the display area, minus any top margin
     * @return  the &lt;code&gt;TreePath&lt;/code&gt; for the node at that location
     */
    public TreePath getPathForLocation(int x, int y) {
<span class="nc" id="L2257">        TreePath          closestPath = getClosestPathForLocation(x, y);</span>

<span class="nc bnc" id="L2259" title="All 2 branches missed.">        if(closestPath != null) {</span>
<span class="nc" id="L2260">            Rectangle       pathBounds = getPathBounds(closestPath);</span>

<span class="nc bnc" id="L2262" title="All 10 branches missed.">            if(pathBounds != null &amp;&amp;</span>
               x &gt;= pathBounds.x &amp;&amp; x &lt; (pathBounds.x + pathBounds.width) &amp;&amp;
               y &gt;= pathBounds.y &amp;&amp; y &lt; (pathBounds.y + pathBounds.height))
<span class="nc" id="L2265">                return closestPath;</span>
        }
<span class="nc" id="L2267">        return null;</span>
    }

    /**
     * Returns the row for the specified location.
     *
     * @param x an integer giving the number of pixels horizontally from
     *          the left edge of the display area, minus any left margin
     * @param y an integer giving the number of pixels vertically from
     *          the top of the display area, minus any top margin
     * @return the row corresponding to the location, or -1 if the
     *         location is not within the bounds of a displayed cell
     * @see #getClosestRowForLocation
     */
    public int getRowForLocation(int x, int y) {
<span class="nc" id="L2282">        return getRowForPath(getPathForLocation(x, y));</span>
    }

    /**
     * Returns the path to the node that is closest to x,y.  If
     * no nodes are currently viewable, or there is no model, returns
     * &lt;code&gt;null&lt;/code&gt;, otherwise it always returns a valid path.  To test if
     * the node is exactly at x, y, get the node's bounds and
     * test x, y against that.
     *
     * @param x an integer giving the number of pixels horizontally from
     *          the left edge of the display area, minus any left margin
     * @param y an integer giving the number of pixels vertically from
     *          the top of the display area, minus any top margin
     * @return  the &lt;code&gt;TreePath&lt;/code&gt; for the node closest to that location,
     *          &lt;code&gt;null&lt;/code&gt; if nothing is viewable or there is no model
     *
     * @see #getPathForLocation
     * @see #getPathBounds
     */
    public TreePath getClosestPathForLocation(int x, int y) {
<span class="nc" id="L2303">        TreeUI                  tree = getUI();</span>

<span class="nc bnc" id="L2305" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L2306">            return tree.getClosestPathForLocation(this, x, y);</span>
<span class="nc" id="L2307">        return null;</span>
    }

    /**
     * Returns the row to the node that is closest to x,y.  If no nodes
     * are viewable or there is no model, returns -1. Otherwise,
     * it always returns a valid row.  To test if the returned object is
     * exactly at x, y, get the bounds for the node at the returned
     * row and test x, y against that.
     *
     * @param x an integer giving the number of pixels horizontally from
     *          the left edge of the display area, minus any left margin
     * @param y an integer giving the number of pixels vertically from
     *          the top of the display area, minus any top margin
     * @return the row closest to the location, -1 if nothing is
     *         viewable or there is no model
     *
     * @see #getRowForLocation
     * @see #getRowBounds
     */
    public int getClosestRowForLocation(int x, int y) {
<span class="nc" id="L2328">        return getRowForPath(getClosestPathForLocation(x, y));</span>
    }

    /**
     * Returns true if the tree is being edited. The item that is being
     * edited can be obtained using &lt;code&gt;getSelectionPath&lt;/code&gt;.
     *
     * @return true if the user is currently editing a node
     * @see #getSelectionPath
     */
    public boolean isEditing() {
<span class="nc" id="L2339">        TreeUI                  tree = getUI();</span>

<span class="nc bnc" id="L2341" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L2342">            return tree.isEditing(this);</span>
<span class="nc" id="L2343">        return false;</span>
    }

    /**
     * Ends the current editing session.
     * (The &lt;code&gt;DefaultTreeCellEditor&lt;/code&gt;
     * object saves any edits that are currently in progress on a cell.
     * Other implementations may operate differently.)
     * Has no effect if the tree isn't being edited.
     * &lt;blockquote&gt;
     * &lt;b&gt;Note:&lt;/b&gt;&lt;br&gt;
     * To make edit-saves automatic whenever the user changes
     * their position in the tree, use {@link #setInvokesStopCellEditing}.
     * &lt;/blockquote&gt;
     *
     * @return true if editing was in progress and is now stopped,
     *              false if editing was not in progress
     */
    public boolean stopEditing() {
<span class="nc" id="L2362">        TreeUI                  tree = getUI();</span>

<span class="nc bnc" id="L2364" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L2365">            return tree.stopEditing(this);</span>
<span class="nc" id="L2366">        return false;</span>
    }

    /**
     * Cancels the current editing session. Has no effect if the
     * tree isn't being edited.
     */
    public void  cancelEditing() {
<span class="nc" id="L2374">        TreeUI                  tree = getUI();</span>

<span class="nc bnc" id="L2376" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L2377">            tree.cancelEditing(this);</span>
<span class="nc" id="L2378">    }</span>

    /**
     * Selects the node identified by the specified path and initiates
     * editing.  The edit-attempt fails if the &lt;code&gt;CellEditor&lt;/code&gt;
     * does not allow
     * editing for the specified item.
     *
     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying a node
     */
    public void startEditingAtPath(TreePath path) {
<span class="nc" id="L2389">        TreeUI                  tree = getUI();</span>

<span class="nc bnc" id="L2391" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L2392">            tree.startEditingAtPath(this, path);</span>
<span class="nc" id="L2393">    }</span>

    /**
     * Returns the path to the element that is currently being edited.
     *
     * @return  the &lt;code&gt;TreePath&lt;/code&gt; for the node being edited
     */
    public TreePath getEditingPath() {
<span class="nc" id="L2401">        TreeUI                  tree = getUI();</span>

<span class="nc bnc" id="L2403" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L2404">            return tree.getEditingPath(this);</span>
<span class="nc" id="L2405">        return null;</span>
    }

    //
    // Following are primarily convenience methods for mapping from
    // row based selections to path selections.  Sometimes it is
    // easier to deal with these than paths (mouse downs, key downs
    // usually just deal with index based selections).
    // Since row based selections require a UI many of these won't work
    // without one.
    //

    /**
     * Sets the tree's selection model. When a &lt;code&gt;null&lt;/code&gt; value is
     * specified an empty
     * &lt;code&gt;selectionModel&lt;/code&gt; is used, which does not allow selections.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param selectionModel the &lt;code&gt;TreeSelectionModel&lt;/code&gt; to use,
     *          or &lt;code&gt;null&lt;/code&gt; to disable selections
     * @see TreeSelectionModel
     * @beaninfo
     *        bound: true
     *  description: The tree's selection model.
     */
    public void setSelectionModel(TreeSelectionModel selectionModel) {
<span class="nc bnc" id="L2432" title="All 2 branches missed.">        if(selectionModel == null)</span>
<span class="nc" id="L2433">            selectionModel = EmptySelectionModel.sharedInstance();</span>

<span class="nc" id="L2435">        TreeSelectionModel         oldValue = this.selectionModel;</span>

<span class="nc bnc" id="L2437" title="All 4 branches missed.">        if (this.selectionModel != null &amp;&amp; selectionRedirector != null) {</span>
<span class="nc" id="L2438">            this.selectionModel.removeTreeSelectionListener</span>
<span class="nc" id="L2439">                                (selectionRedirector);</span>
        }
<span class="nc bnc" id="L2441" title="All 2 branches missed.">        if (accessibleContext != null) {</span>
<span class="nc" id="L2442">           this.selectionModel.removeTreeSelectionListener((TreeSelectionListener)accessibleContext);</span>
<span class="nc" id="L2443">           selectionModel.addTreeSelectionListener((TreeSelectionListener)accessibleContext);</span>
        }

<span class="nc" id="L2446">        this.selectionModel = selectionModel;</span>
<span class="nc bnc" id="L2447" title="All 2 branches missed.">        if (selectionRedirector != null) {</span>
<span class="nc" id="L2448">            this.selectionModel.addTreeSelectionListener(selectionRedirector);</span>
        }
<span class="nc" id="L2450">        firePropertyChange(SELECTION_MODEL_PROPERTY, oldValue,</span>
                           this.selectionModel);

<span class="nc bnc" id="L2453" title="All 2 branches missed.">        if (accessibleContext != null) {</span>
<span class="nc" id="L2454">            accessibleContext.firePropertyChange(</span>
                    AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,
<span class="nc" id="L2456">                    Boolean.valueOf(false), Boolean.valueOf(true));</span>
        }
<span class="nc" id="L2458">    }</span>

    /**
     * Returns the model for selections. This should always return a
     * non-&lt;code&gt;null&lt;/code&gt; value. If you don't want to allow anything
     * to be selected
     * set the selection model to &lt;code&gt;null&lt;/code&gt;, which forces an empty
     * selection model to be used.
     *
     * @see #setSelectionModel
     */
    public TreeSelectionModel getSelectionModel() {
<span class="nc" id="L2470">        return selectionModel;</span>
    }

    /**
     * Returns the paths (inclusive) between the specified rows. If
     * the specified indices are within the viewable set of rows, or
     * bound the viewable set of rows, then the indices are
     * constrained by the viewable set of rows. If the specified
     * indices are not within the viewable set of rows, or do not
     * bound the viewable set of rows, then an empty array is
     * returned. For example, if the row count is {@code 10}, and this
     * method is invoked with {@code -1, 20}, then the specified
     * indices are constrained to the viewable set of rows, and this is
     * treated as if invoked with {@code 0, 9}. On the other hand, if
     * this were invoked with {@code -10, -1}, then the specified
     * indices do not bound the viewable set of rows, and an empty
     * array is returned.
     * &lt;p&gt;
     * The parameters are not order dependent. That is, {@code
     * getPathBetweenRows(x, y)} is equivalent to
     * {@code getPathBetweenRows(y, x)}.
     * &lt;p&gt;
     * An empty array is returned if the row count is {@code 0}, or
     * the specified indices do not bound the viewable set of rows.
     *
     * @param index0 the first index in the range
     * @param index1 the last index in the range
     * @return the paths (inclusive) between the specified row indices
     */
    protected TreePath[] getPathBetweenRows(int index0, int index1) {
<span class="nc" id="L2500">        TreeUI           tree = getUI();</span>
<span class="nc bnc" id="L2501" title="All 2 branches missed.">        if (tree != null) {</span>
<span class="nc" id="L2502">            int rowCount = getRowCount();</span>
<span class="nc bnc" id="L2503" title="All 10 branches missed.">            if (rowCount &gt; 0 &amp;&amp; !((index0 &lt; 0 &amp;&amp; index1 &lt; 0) ||</span>
                                  (index0 &gt;= rowCount &amp;&amp; index1 &gt;= rowCount))){
<span class="nc" id="L2505">                index0 = Math.min(rowCount - 1, Math.max(index0, 0));</span>
<span class="nc" id="L2506">                index1 = Math.min(rowCount - 1, Math.max(index1, 0));</span>
<span class="nc" id="L2507">                int minIndex = Math.min(index0, index1);</span>
<span class="nc" id="L2508">                int maxIndex = Math.max(index0, index1);</span>
<span class="nc" id="L2509">                TreePath[] selection = new TreePath[</span>
                        maxIndex - minIndex + 1];
<span class="nc bnc" id="L2511" title="All 2 branches missed.">                for(int counter = minIndex; counter &lt;= maxIndex; counter++) {</span>
<span class="nc" id="L2512">                    selection[counter - minIndex] =</span>
<span class="nc" id="L2513">                            tree.getPathForRow(this, counter);</span>
                }
<span class="nc" id="L2515">                return selection;</span>
            }
        }
<span class="nc" id="L2518">        return new TreePath[0];</span>
    }

    /**
     * Selects the rows in the specified interval (inclusive). If
     * the specified indices are within the viewable set of rows, or bound
     * the viewable set of rows, then the specified rows are constrained by
     * the viewable set of rows. If the specified indices are not within the
     * viewable set of rows, or do not bound the viewable set of rows, then
     * the selection is cleared. For example, if the row count is {@code
     * 10}, and this method is invoked with {@code -1, 20}, then the
     * specified indices bounds the viewable range, and this is treated as
     * if invoked with {@code 0, 9}. On the other hand, if this were
     * invoked with {@code -10, -1}, then the specified indices do not
     * bound the viewable set of rows, and the selection is cleared.
     * &lt;p&gt;
     * The parameters are not order dependent. That is, {@code
     * setSelectionInterval(x, y)} is equivalent to
     * {@code setSelectionInterval(y, x)}.
     *
     * @param index0 the first index in the range to select
     * @param index1 the last index in the range to select
    */
    public void setSelectionInterval(int index0, int index1) {
<span class="nc" id="L2542">        TreePath[]         paths = getPathBetweenRows(index0, index1);</span>

<span class="nc" id="L2544">        this.getSelectionModel().setSelectionPaths(paths);</span>
<span class="nc" id="L2545">    }</span>

    /**
     * Adds the specified rows (inclusive) to the selection. If the
     * specified indices are within the viewable set of rows, or bound
     * the viewable set of rows, then the specified indices are
     * constrained by the viewable set of rows. If the indices are not
     * within the viewable set of rows, or do not bound the viewable
     * set of rows, then the selection is unchanged. For example, if
     * the row count is {@code 10}, and this method is invoked with
     * {@code -1, 20}, then the specified indices bounds the viewable
     * range, and this is treated as if invoked with {@code 0, 9}. On
     * the other hand, if this were invoked with {@code -10, -1}, then
     * the specified indices do not bound the viewable set of rows,
     * and the selection is unchanged.
     * &lt;p&gt;
     * The parameters are not order dependent. That is, {@code
     * addSelectionInterval(x, y)} is equivalent to
     * {@code addSelectionInterval(y, x)}.
     *
     * @param index0 the first index in the range to add to the selection
     * @param index1 the last index in the range to add to the selection
     */
    public void addSelectionInterval(int index0, int index1) {
<span class="nc" id="L2569">        TreePath[]         paths = getPathBetweenRows(index0, index1);</span>

<span class="nc bnc" id="L2571" title="All 4 branches missed.">        if (paths != null &amp;&amp; paths.length &gt; 0) {</span>
<span class="nc" id="L2572">            this.getSelectionModel().addSelectionPaths(paths);</span>
        }
<span class="nc" id="L2574">    }</span>

    /**
     * Removes the specified rows (inclusive) from the selection. If
     * the specified indices are within the viewable set of rows, or bound
     * the viewable set of rows, then the specified indices are constrained by
     * the viewable set of rows. If the specified indices are not within the
     * viewable set of rows, or do not bound the viewable set of rows, then
     * the selection is unchanged. For example, if the row count is {@code
     * 10}, and this method is invoked with {@code -1, 20}, then the
     * specified range bounds the viewable range, and this is treated as
     * if invoked with {@code 0, 9}. On the other hand, if this were
     * invoked with {@code -10, -1}, then the specified range does not
     * bound the viewable set of rows, and the selection is unchanged.
     * &lt;p&gt;
     * The parameters are not order dependent. That is, {@code
     * removeSelectionInterval(x, y)} is equivalent to
     * {@code removeSelectionInterval(y, x)}.
     *
     * @param index0 the first row to remove from the selection
     * @param index1 the last row to remove from the selection
     */
    public void removeSelectionInterval(int index0, int index1) {
<span class="nc" id="L2597">        TreePath[]         paths = getPathBetweenRows(index0, index1);</span>

<span class="nc bnc" id="L2599" title="All 4 branches missed.">        if (paths != null &amp;&amp; paths.length &gt; 0) {</span>
<span class="nc" id="L2600">            this.getSelectionModel().removeSelectionPaths(paths);</span>
        }
<span class="nc" id="L2602">    }</span>

    /**
     * Removes the node identified by the specified path from the current
     * selection.
     *
     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying a node
     */
    public void removeSelectionPath(TreePath path) {
<span class="nc" id="L2611">        this.getSelectionModel().removeSelectionPath(path);</span>
<span class="nc" id="L2612">    }</span>

    /**
     * Removes the nodes identified by the specified paths from the
     * current selection.
     *
     * @param paths an array of &lt;code&gt;TreePath&lt;/code&gt; objects that
     *              specifies the nodes to remove
     */
    public void removeSelectionPaths(TreePath[] paths) {
<span class="nc" id="L2622">        this.getSelectionModel().removeSelectionPaths(paths);</span>
<span class="nc" id="L2623">    }</span>

    /**
     * Removes the row at the index &lt;code&gt;row&lt;/code&gt; from the current
     * selection.
     *
     * @param row  the row to remove
     */
    public void removeSelectionRow(int row) {
<span class="nc" id="L2632">        int[]             rows = { row };</span>

<span class="nc" id="L2634">        removeSelectionRows(rows);</span>
<span class="nc" id="L2635">    }</span>

    /**
     * Removes the rows that are selected at each of the specified
     * rows.
     *
     * @param rows  an array of ints specifying display rows, where 0 is
     *             the first row in the display
     */
    public void removeSelectionRows(int[] rows) {
<span class="nc" id="L2645">        TreeUI             ui = getUI();</span>

<span class="nc bnc" id="L2647" title="All 4 branches missed.">        if(ui != null &amp;&amp; rows != null) {</span>
<span class="nc" id="L2648">            int                  numRows = rows.length;</span>
<span class="nc" id="L2649">            TreePath[]           paths = new TreePath[numRows];</span>

<span class="nc bnc" id="L2651" title="All 2 branches missed.">            for(int counter = 0; counter &lt; numRows; counter++)</span>
<span class="nc" id="L2652">                paths[counter] = ui.getPathForRow(this, rows[counter]);</span>
<span class="nc" id="L2653">            removeSelectionPaths(paths);</span>
        }
<span class="nc" id="L2655">    }</span>

    /**
     * Clears the selection.
     */
    public void clearSelection() {
<span class="nc" id="L2661">        getSelectionModel().clearSelection();</span>
<span class="nc" id="L2662">    }</span>

    /**
     * Returns true if the selection is currently empty.
     *
     * @return true if the selection is currently empty
     */
    public boolean isSelectionEmpty() {
<span class="nc" id="L2670">        return getSelectionModel().isSelectionEmpty();</span>
    }

    /**
     * Adds a listener for &lt;code&gt;TreeExpansion&lt;/code&gt; events.
     *
     * @param tel a TreeExpansionListener that will be notified when
     *            a tree node is expanded or collapsed (a &quot;negative
     *            expansion&quot;)
     */
    public void addTreeExpansionListener(TreeExpansionListener tel) {
<span class="nc bnc" id="L2681" title="All 2 branches missed.">        if (settingUI) {</span>
<span class="nc" id="L2682">            uiTreeExpansionListener = tel;</span>
        }
<span class="nc" id="L2684">        listenerList.add(TreeExpansionListener.class, tel);</span>
<span class="nc" id="L2685">    }</span>

    /**
     * Removes a listener for &lt;code&gt;TreeExpansion&lt;/code&gt; events.
     *
     * @param tel the &lt;code&gt;TreeExpansionListener&lt;/code&gt; to remove
     */
    public void removeTreeExpansionListener(TreeExpansionListener tel) {
<span class="nc" id="L2693">        listenerList.remove(TreeExpansionListener.class, tel);</span>
<span class="nc bnc" id="L2694" title="All 2 branches missed.">        if (uiTreeExpansionListener == tel) {</span>
<span class="nc" id="L2695">            uiTreeExpansionListener = null;</span>
        }
<span class="nc" id="L2697">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;TreeExpansionListener&lt;/code&gt;s added
     * to this JTree with addTreeExpansionListener().
     *
     * @return all of the &lt;code&gt;TreeExpansionListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public TreeExpansionListener[] getTreeExpansionListeners() {
<span class="nc" id="L2708">        return listenerList.getListeners(TreeExpansionListener.class);</span>
    }

    /**
     * Adds a listener for &lt;code&gt;TreeWillExpand&lt;/code&gt; events.
     *
     * @param tel a &lt;code&gt;TreeWillExpandListener&lt;/code&gt; that will be notified
     *            when a tree node will be expanded or collapsed (a &quot;negative
     *            expansion&quot;)
     */
    public void addTreeWillExpandListener(TreeWillExpandListener tel) {
<span class="nc" id="L2719">        listenerList.add(TreeWillExpandListener.class, tel);</span>
<span class="nc" id="L2720">    }</span>

    /**
     * Removes a listener for &lt;code&gt;TreeWillExpand&lt;/code&gt; events.
     *
     * @param tel the &lt;code&gt;TreeWillExpandListener&lt;/code&gt; to remove
     */
    public void removeTreeWillExpandListener(TreeWillExpandListener tel) {
<span class="nc" id="L2728">        listenerList.remove(TreeWillExpandListener.class, tel);</span>
<span class="nc" id="L2729">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;TreeWillExpandListener&lt;/code&gt;s added
     * to this JTree with addTreeWillExpandListener().
     *
     * @return all of the &lt;code&gt;TreeWillExpandListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public TreeWillExpandListener[] getTreeWillExpandListeners() {
<span class="nc" id="L2740">        return listenerList.getListeners(TreeWillExpandListener.class);</span>
    }

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the &lt;code&gt;path&lt;/code&gt; parameter.
     *
     * @param path the &lt;code&gt;TreePath&lt;/code&gt; indicating the node that was
     *          expanded
     * @see EventListenerList
     */
     public void fireTreeExpanded(TreePath path) {
        // Guaranteed to return a non-null array
<span class="nc" id="L2754">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L2755">        TreeExpansionEvent e = null;</span>
<span class="nc bnc" id="L2756" title="All 2 branches missed.">        if (uiTreeExpansionListener != null) {</span>
<span class="nc" id="L2757">            e = new TreeExpansionEvent(this, path);</span>
<span class="nc" id="L2758">            uiTreeExpansionListener.treeExpanded(e);</span>
        }
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L2762" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L2763" title="All 4 branches missed.">            if (listeners[i]==TreeExpansionListener.class &amp;&amp;</span>
                listeners[i + 1] != uiTreeExpansionListener) {
                // Lazily create the event:
<span class="nc bnc" id="L2766" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L2767">                    e = new TreeExpansionEvent(this, path);</span>
<span class="nc" id="L2768">                ((TreeExpansionListener)listeners[i+1]).</span>
<span class="nc" id="L2769">                    treeExpanded(e);</span>
            }
        }
<span class="nc" id="L2772">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the &lt;code&gt;path&lt;/code&gt; parameter.
     *
     * @param path the &lt;code&gt;TreePath&lt;/code&gt; indicating the node that was
     *          collapsed
     * @see EventListenerList
     */
    public void fireTreeCollapsed(TreePath path) {
        // Guaranteed to return a non-null array
<span class="nc" id="L2785">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L2786">        TreeExpansionEvent e = null;</span>
<span class="nc bnc" id="L2787" title="All 2 branches missed.">        if (uiTreeExpansionListener != null) {</span>
<span class="nc" id="L2788">            e = new TreeExpansionEvent(this, path);</span>
<span class="nc" id="L2789">            uiTreeExpansionListener.treeCollapsed(e);</span>
        }
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L2793" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L2794" title="All 4 branches missed.">            if (listeners[i]==TreeExpansionListener.class &amp;&amp;</span>
                listeners[i + 1] != uiTreeExpansionListener) {
                // Lazily create the event:
<span class="nc bnc" id="L2797" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L2798">                    e = new TreeExpansionEvent(this, path);</span>
<span class="nc" id="L2799">                ((TreeExpansionListener)listeners[i+1]).</span>
<span class="nc" id="L2800">                    treeCollapsed(e);</span>
            }
        }
<span class="nc" id="L2803">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the &lt;code&gt;path&lt;/code&gt; parameter.
     *
     * @param path the &lt;code&gt;TreePath&lt;/code&gt; indicating the node that was
     *          expanded
     * @see EventListenerList
     */
     public void fireTreeWillExpand(TreePath path) throws ExpandVetoException {
        // Guaranteed to return a non-null array
<span class="nc" id="L2816">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L2817">        TreeExpansionEvent e = null;</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L2820" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L2821" title="All 2 branches missed.">            if (listeners[i]==TreeWillExpandListener.class) {</span>
                // Lazily create the event:
<span class="nc bnc" id="L2823" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L2824">                    e = new TreeExpansionEvent(this, path);</span>
<span class="nc" id="L2825">                ((TreeWillExpandListener)listeners[i+1]).</span>
<span class="nc" id="L2826">                    treeWillExpand(e);</span>
            }
        }
<span class="nc" id="L2829">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the &lt;code&gt;path&lt;/code&gt; parameter.
     *
     * @param path the &lt;code&gt;TreePath&lt;/code&gt; indicating the node that was
     *          expanded
     * @see EventListenerList
     */
     public void fireTreeWillCollapse(TreePath path) throws ExpandVetoException {
        // Guaranteed to return a non-null array
<span class="nc" id="L2842">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L2843">        TreeExpansionEvent e = null;</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L2846" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L2847" title="All 2 branches missed.">            if (listeners[i]==TreeWillExpandListener.class) {</span>
                // Lazily create the event:
<span class="nc bnc" id="L2849" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L2850">                    e = new TreeExpansionEvent(this, path);</span>
<span class="nc" id="L2851">                ((TreeWillExpandListener)listeners[i+1]).</span>
<span class="nc" id="L2852">                    treeWillCollapse(e);</span>
            }
        }
<span class="nc" id="L2855">    }</span>

    /**
     * Adds a listener for &lt;code&gt;TreeSelection&lt;/code&gt; events.
     *
     * @param tsl the &lt;code&gt;TreeSelectionListener&lt;/code&gt; that will be notified
     *            when a node is selected or deselected (a &quot;negative
     *            selection&quot;)
     */
    public void addTreeSelectionListener(TreeSelectionListener tsl) {
<span class="nc" id="L2865">        listenerList.add(TreeSelectionListener.class,tsl);</span>
<span class="nc bnc" id="L2866" title="All 4 branches missed.">        if(listenerList.getListenerCount(TreeSelectionListener.class) != 0</span>
           &amp;&amp; selectionRedirector == null) {
<span class="nc" id="L2868">            selectionRedirector = new TreeSelectionRedirector();</span>
<span class="nc" id="L2869">            selectionModel.addTreeSelectionListener(selectionRedirector);</span>
        }
<span class="nc" id="L2871">    }</span>

    /**
     * Removes a &lt;code&gt;TreeSelection&lt;/code&gt; listener.
     *
     * @param tsl the &lt;code&gt;TreeSelectionListener&lt;/code&gt; to remove
     */
    public void removeTreeSelectionListener(TreeSelectionListener tsl) {
<span class="nc" id="L2879">        listenerList.remove(TreeSelectionListener.class,tsl);</span>
<span class="nc bnc" id="L2880" title="All 4 branches missed.">        if(listenerList.getListenerCount(TreeSelectionListener.class) == 0</span>
           &amp;&amp; selectionRedirector != null) {
<span class="nc" id="L2882">            selectionModel.removeTreeSelectionListener</span>
<span class="nc" id="L2883">                (selectionRedirector);</span>
<span class="nc" id="L2884">            selectionRedirector = null;</span>
        }
<span class="nc" id="L2886">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;TreeSelectionListener&lt;/code&gt;s added
     * to this JTree with addTreeSelectionListener().
     *
     * @return all of the &lt;code&gt;TreeSelectionListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public TreeSelectionListener[] getTreeSelectionListeners() {
<span class="nc" id="L2897">        return listenerList.getListeners(TreeSelectionListener.class);</span>
    }

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.
     *
     * @param e the &lt;code&gt;TreeSelectionEvent&lt;/code&gt; to be fired;
     *          generated by the
     *          &lt;code&gt;TreeSelectionModel&lt;/code&gt;
     *          when a node is selected or deselected
     * @see EventListenerList
     */
    protected void fireValueChanged(TreeSelectionEvent e) {
        // Guaranteed to return a non-null array
<span class="nc" id="L2912">        Object[] listeners = listenerList.getListenerList();</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L2915" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
            // TreeSelectionEvent e = null;
<span class="nc bnc" id="L2917" title="All 2 branches missed.">            if (listeners[i]==TreeSelectionListener.class) {</span>
                // Lazily create the event:
                // if (e == null)
                // e = new ListSelectionEvent(this, firstIndex, lastIndex);
<span class="nc" id="L2921">                ((TreeSelectionListener)listeners[i+1]).valueChanged(e);</span>
            }
        }
<span class="nc" id="L2924">    }</span>

    /**
     * Sent when the tree has changed enough that we need to resize
     * the bounds, but not enough that we need to remove the
     * expanded node set (e.g nodes were expanded or collapsed, or
     * nodes were inserted into the tree). You should never have to
     * invoke this, the UI will invoke this as it needs to.
     */
    public void treeDidChange() {
<span class="nc" id="L2934">        revalidate();</span>
<span class="nc" id="L2935">        repaint();</span>
<span class="nc" id="L2936">    }</span>

    /**
     * Sets the number of rows that are to be displayed.
     * This will only work if the tree is contained in a
     * &lt;code&gt;JScrollPane&lt;/code&gt;,
     * and will adjust the preferred size and size of that scrollpane.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param newCount the number of rows to display
     * @beaninfo
     *        bound: true
     *  description: The number of rows that are to be displayed.
     */
    public void setVisibleRowCount(int newCount) {
<span class="nc" id="L2952">        int                 oldCount = visibleRowCount;</span>

<span class="nc" id="L2954">        visibleRowCount = newCount;</span>
<span class="nc" id="L2955">        firePropertyChange(VISIBLE_ROW_COUNT_PROPERTY, oldCount,</span>
                           visibleRowCount);
<span class="nc" id="L2957">        invalidate();</span>
<span class="nc bnc" id="L2958" title="All 2 branches missed.">        if (accessibleContext != null) {</span>
<span class="nc" id="L2959">            ((AccessibleJTree)accessibleContext).fireVisibleDataPropertyChange();</span>
        }
<span class="nc" id="L2961">    }</span>

    /**
     * Returns the number of rows that are displayed in the display area.
     *
     * @return the number of rows displayed
     */
    public int getVisibleRowCount() {
<span class="nc" id="L2969">        return visibleRowCount;</span>
    }

    /**
     * Expands the root path, assuming the current TreeModel has been set.
     */
    private void expandRoot() {
<span class="nc" id="L2976">        TreeModel              model = getModel();</span>

<span class="nc bnc" id="L2978" title="All 4 branches missed.">        if(model != null &amp;&amp; model.getRoot() != null) {</span>
<span class="nc" id="L2979">            expandPath(new TreePath(model.getRoot()));</span>
        }
<span class="nc" id="L2981">    }</span>

    /**
     * Returns the TreePath to the next tree element that
     * begins with a prefix. To handle the conversion of a
     * &lt;code&gt;TreePath&lt;/code&gt; into a String, &lt;code&gt;convertValueToText&lt;/code&gt;
     * is used.
     *
     * @param prefix the string to test for a match
     * @param startingRow the row for starting the search
     * @param bias the search direction, either
     * Position.Bias.Forward or Position.Bias.Backward.
     * @return the TreePath of the next tree element that
     * starts with the prefix; otherwise null
     * @exception IllegalArgumentException if prefix is null
     * or startingRow is out of bounds
     * @since 1.4
     */
    public TreePath getNextMatch(String prefix, int startingRow,
                                 Position.Bias bias) {

<span class="nc" id="L3002">        int max = getRowCount();</span>
<span class="nc bnc" id="L3003" title="All 2 branches missed.">        if (prefix == null) {</span>
<span class="nc" id="L3004">            throw new IllegalArgumentException();</span>
        }
<span class="nc bnc" id="L3006" title="All 4 branches missed.">        if (startingRow &lt; 0 || startingRow &gt;= max) {</span>
<span class="nc" id="L3007">            throw new IllegalArgumentException();</span>
        }
<span class="nc" id="L3009">        prefix = prefix.toUpperCase();</span>

        // start search from the next/previous element froom the
        // selected element
<span class="nc bnc" id="L3013" title="All 2 branches missed.">        int increment = (bias == Position.Bias.Forward) ? 1 : -1;</span>
<span class="nc" id="L3014">        int row = startingRow;</span>
        do {
<span class="nc" id="L3016">            TreePath path = getPathForRow(row);</span>
<span class="nc" id="L3017">            String text = convertValueToText(</span>
<span class="nc" id="L3018">                path.getLastPathComponent(), isRowSelected(row),</span>
<span class="nc" id="L3019">                isExpanded(row), true, row, false);</span>

<span class="nc bnc" id="L3021" title="All 2 branches missed.">            if (text.toUpperCase().startsWith(prefix)) {</span>
<span class="nc" id="L3022">                return path;</span>
            }
<span class="nc" id="L3024">            row = (row + increment + max) % max;</span>
<span class="nc bnc" id="L3025" title="All 2 branches missed.">        } while (row != startingRow);</span>
<span class="nc" id="L3026">        return null;</span>
    }

    // Serialization support.
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L3031">        Vector&lt;Object&gt; values = new Vector&lt;Object&gt;();</span>

<span class="nc" id="L3033">        s.defaultWriteObject();</span>
        // Save the cellRenderer, if its Serializable.
<span class="nc bnc" id="L3035" title="All 4 branches missed.">        if(cellRenderer != null &amp;&amp; cellRenderer instanceof Serializable) {</span>
<span class="nc" id="L3036">            values.addElement(&quot;cellRenderer&quot;);</span>
<span class="nc" id="L3037">            values.addElement(cellRenderer);</span>
        }
        // Save the cellEditor, if its Serializable.
<span class="nc bnc" id="L3040" title="All 4 branches missed.">        if(cellEditor != null &amp;&amp; cellEditor instanceof Serializable) {</span>
<span class="nc" id="L3041">            values.addElement(&quot;cellEditor&quot;);</span>
<span class="nc" id="L3042">            values.addElement(cellEditor);</span>
        }
        // Save the treeModel, if its Serializable.
<span class="nc bnc" id="L3045" title="All 4 branches missed.">        if(treeModel != null &amp;&amp; treeModel instanceof Serializable) {</span>
<span class="nc" id="L3046">            values.addElement(&quot;treeModel&quot;);</span>
<span class="nc" id="L3047">            values.addElement(treeModel);</span>
        }
        // Save the selectionModel, if its Serializable.
<span class="nc bnc" id="L3050" title="All 4 branches missed.">        if(selectionModel != null &amp;&amp; selectionModel instanceof Serializable) {</span>
<span class="nc" id="L3051">            values.addElement(&quot;selectionModel&quot;);</span>
<span class="nc" id="L3052">            values.addElement(selectionModel);</span>
        }

<span class="nc" id="L3055">        Object      expandedData = getArchivableExpandedState();</span>

<span class="nc bnc" id="L3057" title="All 2 branches missed.">        if(expandedData != null) {</span>
<span class="nc" id="L3058">            values.addElement(&quot;expandedState&quot;);</span>
<span class="nc" id="L3059">            values.addElement(expandedData);</span>
        }

<span class="nc" id="L3062">        s.writeObject(values);</span>
<span class="nc bnc" id="L3063" title="All 2 branches missed.">        if (getUIClassID().equals(uiClassID)) {</span>
<span class="nc" id="L3064">            byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L3065">            JComponent.setWriteObjCounter(this, --count);</span>
<span class="nc bnc" id="L3066" title="All 4 branches missed.">            if (count == 0 &amp;&amp; ui != null) {</span>
<span class="nc" id="L3067">                ui.installUI(this);</span>
            }
        }
<span class="nc" id="L3070">    }</span>

    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
<span class="nc" id="L3074">        s.defaultReadObject();</span>

        // Create an instance of expanded state.

<span class="nc" id="L3078">        expandedState = new Hashtable&lt;TreePath, Boolean&gt;();</span>

<span class="nc" id="L3080">        expandedStack = new Stack&lt;Stack&lt;TreePath&gt;&gt;();</span>

<span class="nc" id="L3082">        Vector&lt;?&gt;          values = (Vector)s.readObject();</span>
<span class="nc" id="L3083">        int             indexCounter = 0;</span>
<span class="nc" id="L3084">        int             maxCounter = values.size();</span>

<span class="nc bnc" id="L3086" title="All 2 branches missed.">        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).</span>
<span class="nc bnc" id="L3087" title="All 2 branches missed.">           equals(&quot;cellRenderer&quot;)) {</span>
<span class="nc" id="L3088">            cellRenderer = (TreeCellRenderer)values.elementAt(++indexCounter);</span>
<span class="nc" id="L3089">            indexCounter++;</span>
        }
<span class="nc bnc" id="L3091" title="All 2 branches missed.">        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).</span>
<span class="nc bnc" id="L3092" title="All 2 branches missed.">           equals(&quot;cellEditor&quot;)) {</span>
<span class="nc" id="L3093">            cellEditor = (TreeCellEditor)values.elementAt(++indexCounter);</span>
<span class="nc" id="L3094">            indexCounter++;</span>
        }
<span class="nc bnc" id="L3096" title="All 2 branches missed.">        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).</span>
<span class="nc bnc" id="L3097" title="All 2 branches missed.">           equals(&quot;treeModel&quot;)) {</span>
<span class="nc" id="L3098">            treeModel = (TreeModel)values.elementAt(++indexCounter);</span>
<span class="nc" id="L3099">            indexCounter++;</span>
        }
<span class="nc bnc" id="L3101" title="All 2 branches missed.">        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).</span>
<span class="nc bnc" id="L3102" title="All 2 branches missed.">           equals(&quot;selectionModel&quot;)) {</span>
<span class="nc" id="L3103">            selectionModel = (TreeSelectionModel)values.elementAt(++indexCounter);</span>
<span class="nc" id="L3104">            indexCounter++;</span>
        }
<span class="nc bnc" id="L3106" title="All 2 branches missed.">        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).</span>
<span class="nc bnc" id="L3107" title="All 2 branches missed.">           equals(&quot;expandedState&quot;)) {</span>
<span class="nc" id="L3108">            unarchiveExpandedState(values.elementAt(++indexCounter));</span>
<span class="nc" id="L3109">            indexCounter++;</span>
        }
        // Reinstall the redirector.
<span class="nc bnc" id="L3112" title="All 2 branches missed.">        if(listenerList.getListenerCount(TreeSelectionListener.class) != 0) {</span>
<span class="nc" id="L3113">            selectionRedirector = new TreeSelectionRedirector();</span>
<span class="nc" id="L3114">            selectionModel.addTreeSelectionListener(selectionRedirector);</span>
        }
        // Listener to TreeModel.
<span class="nc bnc" id="L3117" title="All 2 branches missed.">        if(treeModel != null) {</span>
<span class="nc" id="L3118">            treeModelListener = createTreeModelListener();</span>
<span class="nc bnc" id="L3119" title="All 2 branches missed.">            if(treeModelListener != null)</span>
<span class="nc" id="L3120">                treeModel.addTreeModelListener(treeModelListener);</span>
        }
<span class="nc" id="L3122">    }</span>

    /**
     * Returns an object that can be archived indicating what nodes are
     * expanded and what aren't. The objects from the model are NOT
     * written out.
     */
    private Object getArchivableExpandedState() {
<span class="nc" id="L3130">        TreeModel       model = getModel();</span>

<span class="nc bnc" id="L3132" title="All 2 branches missed.">        if(model != null) {</span>
<span class="nc" id="L3133">            Enumeration&lt;TreePath&gt; paths = expandedState.keys();</span>

<span class="nc bnc" id="L3135" title="All 2 branches missed.">            if(paths != null) {</span>
<span class="nc" id="L3136">                Vector&lt;Object&gt; state = new Vector&lt;Object&gt;();</span>

<span class="nc bnc" id="L3138" title="All 2 branches missed.">                while(paths.hasMoreElements()) {</span>
<span class="nc" id="L3139">                    TreePath path = paths.nextElement();</span>
                    Object     archivePath;

                    try {
<span class="nc" id="L3143">                        archivePath = getModelIndexsForPath(path);</span>
<span class="nc" id="L3144">                    } catch (Error error) {</span>
<span class="nc" id="L3145">                        archivePath = null;</span>
<span class="nc" id="L3146">                    }</span>
<span class="nc bnc" id="L3147" title="All 2 branches missed.">                    if(archivePath != null) {</span>
<span class="nc" id="L3148">                        state.addElement(archivePath);</span>
<span class="nc" id="L3149">                        state.addElement(expandedState.get(path));</span>
                    }
<span class="nc" id="L3151">                }</span>
<span class="nc" id="L3152">                return state;</span>
            }
        }
<span class="nc" id="L3155">        return null;</span>
    }

    /**
     * Updates the expanded state of nodes in the tree based on the
     * previously archived state &lt;code&gt;state&lt;/code&gt;.
     */
    private void unarchiveExpandedState(Object state) {
<span class="nc bnc" id="L3163" title="All 2 branches missed.">        if(state instanceof Vector) {</span>
<span class="nc" id="L3164">            Vector&lt;?&gt;          paths = (Vector)state;</span>

<span class="nc bnc" id="L3166" title="All 2 branches missed.">            for(int counter = paths.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L3167">                Boolean        eState = (Boolean)paths.elementAt(counter--);</span>
                TreePath       path;

                try {
<span class="nc" id="L3171">                    path = getPathForIndexs((int[])paths.elementAt(counter));</span>
<span class="nc bnc" id="L3172" title="All 2 branches missed.">                    if(path != null)</span>
<span class="nc" id="L3173">                        expandedState.put(path, eState);</span>
<span class="nc" id="L3174">                } catch (Error error) {}</span>
            }
        }
<span class="nc" id="L3177">    }</span>

    /**
     * Returns an array of integers specifying the indexs of the
     * components in the &lt;code&gt;path&lt;/code&gt;. If &lt;code&gt;path&lt;/code&gt; is
     * the root, this will return an empty array.  If &lt;code&gt;path&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; will be returned.
     */
    private int[] getModelIndexsForPath(TreePath path) {
<span class="nc bnc" id="L3186" title="All 2 branches missed.">        if(path != null) {</span>
<span class="nc" id="L3187">            TreeModel   model = getModel();</span>
<span class="nc" id="L3188">            int         count = path.getPathCount();</span>
<span class="nc" id="L3189">            int[]       indexs = new int[count - 1];</span>
<span class="nc" id="L3190">            Object      parent = model.getRoot();</span>

<span class="nc bnc" id="L3192" title="All 2 branches missed.">            for(int counter = 1; counter &lt; count; counter++) {</span>
<span class="nc" id="L3193">                indexs[counter - 1] = model.getIndexOfChild</span>
<span class="nc" id="L3194">                                   (parent, path.getPathComponent(counter));</span>
<span class="nc" id="L3195">                parent = path.getPathComponent(counter);</span>
<span class="nc bnc" id="L3196" title="All 2 branches missed.">                if(indexs[counter - 1] &lt; 0)</span>
<span class="nc" id="L3197">                    return null;</span>
            }
<span class="nc" id="L3199">            return indexs;</span>
        }
<span class="nc" id="L3201">        return null;</span>
    }

    /**
     * Returns a &lt;code&gt;TreePath&lt;/code&gt; created by obtaining the children
     * for each of the indices in &lt;code&gt;indexs&lt;/code&gt;. If &lt;code&gt;indexs&lt;/code&gt;
     * or the &lt;code&gt;TreeModel&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, it will return
     * &lt;code&gt;null&lt;/code&gt;.
     */
    private TreePath getPathForIndexs(int[] indexs) {
<span class="nc bnc" id="L3211" title="All 2 branches missed.">        if(indexs == null)</span>
<span class="nc" id="L3212">            return null;</span>

<span class="nc" id="L3214">        TreeModel    model = getModel();</span>

<span class="nc bnc" id="L3216" title="All 2 branches missed.">        if(model == null)</span>
<span class="nc" id="L3217">            return null;</span>

<span class="nc" id="L3219">        int          count = indexs.length;</span>
<span class="nc" id="L3220">        Object       parent = model.getRoot();</span>
<span class="nc" id="L3221">        TreePath     parentPath = new TreePath(parent);</span>

<span class="nc bnc" id="L3223" title="All 2 branches missed.">        for(int counter = 0; counter &lt; count; counter++) {</span>
<span class="nc" id="L3224">            parent = model.getChild(parent, indexs[counter]);</span>
<span class="nc bnc" id="L3225" title="All 2 branches missed.">            if(parent == null)</span>
<span class="nc" id="L3226">                return null;</span>
<span class="nc" id="L3227">            parentPath = parentPath.pathByAddingChild(parent);</span>
        }
<span class="nc" id="L3229">        return parentPath;</span>
    }

    /**
     * &lt;code&gt;EmptySelectionModel&lt;/code&gt; is a &lt;code&gt;TreeSelectionModel&lt;/code&gt;
     * that does not allow anything to be selected.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    @SuppressWarnings(&quot;serial&quot;)
<span class="nc" id="L3246">    protected static class EmptySelectionModel extends</span>
              DefaultTreeSelectionModel
    {
        /**
         * The single instance of {@code EmptySelectionModel}.
         */
<span class="nc" id="L3252">        protected static final EmptySelectionModel sharedInstance =</span>
            new EmptySelectionModel();

        /**
         * Returns the single instance of {@code EmptySelectionModel}.
         *
         * @return single instance of {@code EmptySelectionModel}
         */
        static public EmptySelectionModel sharedInstance() {
<span class="nc" id="L3261">            return sharedInstance;</span>
        }

        /**
         * This is overriden to do nothing; {@code EmptySelectionModel}
         * does not allow a selection.
         *
         * @param paths the paths to select; this is ignored
         */
<span class="nc" id="L3270">        public void setSelectionPaths(TreePath[] paths) {}</span>

        /**
         * This is overriden to do nothing; {@code EmptySelectionModel}
         * does not allow a selection.
         *
         * @param paths the paths to add to the selection; this is ignored
         */
<span class="nc" id="L3278">        public void addSelectionPaths(TreePath[] paths) {}</span>

        /**
         * This is overriden to do nothing; {@code EmptySelectionModel}
         * does not allow a selection.
         *
         * @param paths the paths to remove; this is ignored
         */
<span class="nc" id="L3286">        public void removeSelectionPaths(TreePath[] paths) {}</span>

        /**
         * This is overriden to do nothing; {@code EmptySelectionModel}
         * does not allow a selection.
         *
         * @param mode the selection mode; this is ignored
         * @since 1.7
         */
        public void setSelectionMode(int mode) {
<span class="nc" id="L3296">        }</span>

        /**
         * This is overriden to do nothing; {@code EmptySelectionModel}
         * does not allow a selection.
         *
         * @param mapper the {@code RowMapper} instance; this is ignored
         * @since 1.7
         */
        public void setRowMapper(RowMapper mapper) {
<span class="nc" id="L3306">        }</span>

        /**
         * This is overriden to do nothing; {@code EmptySelectionModel}
         * does not allow a selection.
         *
         * @param listener the listener to add; this is ignored
         * @since 1.7
         */
        public void addTreeSelectionListener(TreeSelectionListener listener) {
<span class="nc" id="L3316">        }</span>

        /**
         * This is overriden to do nothing; {@code EmptySelectionModel}
         * does not allow a selection.
         *
         * @param listener the listener to remove; this is ignored
         * @since 1.7
         */
        public void removeTreeSelectionListener(
                TreeSelectionListener listener) {
<span class="nc" id="L3327">        }</span>

        /**
         * This is overriden to do nothing; {@code EmptySelectionModel}
         * does not allow a selection.
         *
         * @param listener the listener to add; this is ignored
         * @since 1.7
         */
        public void addPropertyChangeListener(
                                PropertyChangeListener listener) {
<span class="nc" id="L3338">        }</span>

        /**
         * This is overriden to do nothing; {@code EmptySelectionModel}
         * does not allow a selection.
         *
         * @param listener the listener to remove; this is ignored
         * @since 1.7
         */
        public void removePropertyChangeListener(
                                PropertyChangeListener listener) {
<span class="nc" id="L3349">        }</span>
    }


    /**
     * Handles creating a new &lt;code&gt;TreeSelectionEvent&lt;/code&gt; with the
     * &lt;code&gt;JTree&lt;/code&gt; as the
     * source and passing it off to all the listeners.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    @SuppressWarnings(&quot;serial&quot;)
<span class="nc" id="L3368">    protected class TreeSelectionRedirector implements Serializable,</span>
                    TreeSelectionListener
    {
        /**
         * Invoked by the &lt;code&gt;TreeSelectionModel&lt;/code&gt; when the
         * selection changes.
         *
         * @param e the &lt;code&gt;TreeSelectionEvent&lt;/code&gt; generated by the
         *              &lt;code&gt;TreeSelectionModel&lt;/code&gt;
         */
        public void valueChanged(TreeSelectionEvent e) {
            TreeSelectionEvent       newE;

<span class="nc" id="L3381">            newE = (TreeSelectionEvent)e.cloneWithSource(JTree.this);</span>
<span class="nc" id="L3382">            fireValueChanged(newE);</span>
<span class="nc" id="L3383">        }</span>
    } // End of class JTree.TreeSelectionRedirector

    //
    // Scrollable interface
    //

    /**
     * Returns the preferred display size of a &lt;code&gt;JTree&lt;/code&gt;. The height is
     * determined from &lt;code&gt;getVisibleRowCount&lt;/code&gt; and the width
     * is the current preferred width.
     *
     * @return a &lt;code&gt;Dimension&lt;/code&gt; object containing the preferred size
     */
    public Dimension getPreferredScrollableViewportSize() {
<span class="nc" id="L3398">        int                 width = getPreferredSize().width;</span>
<span class="nc" id="L3399">        int                 visRows = getVisibleRowCount();</span>
<span class="nc" id="L3400">        int                 height = -1;</span>

<span class="nc bnc" id="L3402" title="All 2 branches missed.">        if(isFixedRowHeight())</span>
<span class="nc" id="L3403">            height = visRows * getRowHeight();</span>
        else {
<span class="nc" id="L3405">            TreeUI          ui = getUI();</span>

<span class="nc bnc" id="L3407" title="All 4 branches missed.">            if (ui != null &amp;&amp; visRows &gt; 0) {</span>
<span class="nc" id="L3408">                int rc = ui.getRowCount(this);</span>

<span class="nc bnc" id="L3410" title="All 2 branches missed.">                if (rc &gt;= visRows) {</span>
<span class="nc" id="L3411">                    Rectangle bounds = getRowBounds(visRows - 1);</span>
<span class="nc bnc" id="L3412" title="All 2 branches missed.">                    if (bounds != null) {</span>
<span class="nc" id="L3413">                        height = bounds.y + bounds.height;</span>
                    }
<span class="nc" id="L3415">                }</span>
<span class="nc bnc" id="L3416" title="All 2 branches missed.">                else if (rc &gt; 0) {</span>
<span class="nc" id="L3417">                    Rectangle bounds = getRowBounds(0);</span>
<span class="nc bnc" id="L3418" title="All 2 branches missed.">                    if (bounds != null) {</span>
<span class="nc" id="L3419">                        height = bounds.height * visRows;</span>
                    }
                }
            }
<span class="nc bnc" id="L3423" title="All 2 branches missed.">            if (height == -1) {</span>
<span class="nc" id="L3424">                height = 16 * visRows;</span>
            }
        }
<span class="nc" id="L3427">        return new Dimension(width, height);</span>
    }

    /**
     * Returns the amount to increment when scrolling. The amount is
     * the height of the first displayed row that isn't completely in view
     * or, if it is totally displayed, the height of the next row in the
     * scrolling direction.
     *
     * @param visibleRect the view area visible within the viewport
     * @param orientation either &lt;code&gt;SwingConstants.VERTICAL&lt;/code&gt;
     *          or &lt;code&gt;SwingConstants.HORIZONTAL&lt;/code&gt;
     * @param direction less than zero to scroll up/left,
     *          greater than zero for down/right
     * @return the &quot;unit&quot; increment for scrolling in the specified direction
     * @see JScrollBar#setUnitIncrement(int)
     */
    public int getScrollableUnitIncrement(Rectangle visibleRect,
                                          int orientation, int direction) {
<span class="nc bnc" id="L3446" title="All 2 branches missed.">        if(orientation == SwingConstants.VERTICAL) {</span>
            Rectangle       rowBounds;
<span class="nc" id="L3448">            int             firstIndex = getClosestRowForLocation</span>
<span class="nc" id="L3449">                                         (0, visibleRect.y);</span>

<span class="nc bnc" id="L3451" title="All 2 branches missed.">            if(firstIndex != -1) {</span>
<span class="nc" id="L3452">                rowBounds = getRowBounds(firstIndex);</span>
<span class="nc bnc" id="L3453" title="All 2 branches missed.">                if(rowBounds.y != visibleRect.y) {</span>
<span class="nc bnc" id="L3454" title="All 2 branches missed.">                    if(direction &lt; 0) {</span>
                        // UP
<span class="nc" id="L3456">                        return Math.max(0, (visibleRect.y - rowBounds.y));</span>
                    }
<span class="nc" id="L3458">                    return (rowBounds.y + rowBounds.height - visibleRect.y);</span>
                }
<span class="nc bnc" id="L3460" title="All 2 branches missed.">                if(direction &lt; 0) { // UP</span>
<span class="nc bnc" id="L3461" title="All 2 branches missed.">                    if(firstIndex != 0) {</span>
<span class="nc" id="L3462">                        rowBounds = getRowBounds(firstIndex - 1);</span>
<span class="nc" id="L3463">                        return rowBounds.height;</span>
                    }
                }
                else {
<span class="nc" id="L3467">                    return rowBounds.height;</span>
                }
            }
<span class="nc" id="L3470">            return 0;</span>
        }
<span class="nc" id="L3472">        return 4;</span>
    }


    /**
     * Returns the amount for a block increment, which is the height or
     * width of &lt;code&gt;visibleRect&lt;/code&gt;, based on &lt;code&gt;orientation&lt;/code&gt;.
     *
     * @param visibleRect the view area visible within the viewport
     * @param orientation either &lt;code&gt;SwingConstants.VERTICAL&lt;/code&gt;
     *          or &lt;code&gt;SwingConstants.HORIZONTAL&lt;/code&gt;
     * @param direction less than zero to scroll up/left,
     *          greater than zero for down/right.
     * @return the &quot;block&quot; increment for scrolling in the specified direction
     * @see JScrollBar#setBlockIncrement(int)
     */
    public int getScrollableBlockIncrement(Rectangle visibleRect,
                                           int orientation, int direction) {
<span class="nc bnc" id="L3490" title="All 2 branches missed.">        return (orientation == SwingConstants.VERTICAL) ? visibleRect.height :</span>
            visibleRect.width;
    }

    /**
     * Returns false to indicate that the width of the viewport does not
     * determine the width of the table, unless the preferred width of
     * the tree is smaller than the viewports width.  In other words:
     * ensure that the tree is never smaller than its viewport.
     *
     * @return whether the tree should track the width of the viewport
     * @see Scrollable#getScrollableTracksViewportWidth
     */
    public boolean getScrollableTracksViewportWidth() {
<span class="nc" id="L3504">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L3505" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc bnc" id="L3506" title="All 2 branches missed.">            return parent.getWidth() &gt; getPreferredSize().width;</span>
        }
<span class="nc" id="L3508">        return false;</span>
    }

    /**
     * Returns false to indicate that the height of the viewport does not
     * determine the height of the table, unless the preferred height
     * of the tree is smaller than the viewports height.  In other words:
     * ensure that the tree is never smaller than its viewport.
     *
     * @return whether the tree should track the height of the viewport
     * @see Scrollable#getScrollableTracksViewportHeight
     */
    public boolean getScrollableTracksViewportHeight() {
<span class="nc" id="L3521">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L3522" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc bnc" id="L3523" title="All 2 branches missed.">            return parent.getHeight() &gt; getPreferredSize().height;</span>
        }
<span class="nc" id="L3525">        return false;</span>
    }

    /**
     * Sets the expanded state of this &lt;code&gt;JTree&lt;/code&gt;.
     * If &lt;code&gt;state&lt;/code&gt; is
     * true, all parents of &lt;code&gt;path&lt;/code&gt; and path are marked as
     * expanded. If &lt;code&gt;state&lt;/code&gt; is false, all parents of
     * &lt;code&gt;path&lt;/code&gt; are marked EXPANDED, but &lt;code&gt;path&lt;/code&gt; itself
     * is marked collapsed.&lt;p&gt;
     * This will fail if a &lt;code&gt;TreeWillExpandListener&lt;/code&gt; vetos it.
     */
    protected void setExpandedState(TreePath path, boolean state) {
<span class="nc bnc" id="L3538" title="All 2 branches missed.">        if(path != null) {</span>
            // Make sure all parents of path are expanded.
            Stack&lt;TreePath&gt; stack;
<span class="nc" id="L3541">            TreePath parentPath = path.getParentPath();</span>

<span class="nc bnc" id="L3543" title="All 2 branches missed.">            if (expandedStack.size() == 0) {</span>
<span class="nc" id="L3544">                stack = new Stack&lt;TreePath&gt;();</span>
            }
            else {
<span class="nc" id="L3547">                stack = expandedStack.pop();</span>
            }

            try {
<span class="nc bnc" id="L3551" title="All 2 branches missed.">                while(parentPath != null) {</span>
<span class="nc bnc" id="L3552" title="All 2 branches missed.">                    if(isExpanded(parentPath)) {</span>
<span class="nc" id="L3553">                        parentPath = null;</span>
                    }
                    else {
<span class="nc" id="L3556">                        stack.push(parentPath);</span>
<span class="nc" id="L3557">                        parentPath = parentPath.getParentPath();</span>
                    }
                }
<span class="nc bnc" id="L3560" title="All 2 branches missed.">                for(int counter = stack.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L3561">                    parentPath = stack.pop();</span>
<span class="nc bnc" id="L3562" title="All 2 branches missed.">                    if(!isExpanded(parentPath)) {</span>
                        try {
<span class="nc" id="L3564">                            fireTreeWillExpand(parentPath);</span>
<span class="nc" id="L3565">                        } catch (ExpandVetoException eve) {</span>
                            // Expand vetoed!
<span class="nc" id="L3567">                            return;</span>
<span class="nc" id="L3568">                        }</span>
<span class="nc" id="L3569">                        expandedState.put(parentPath, Boolean.TRUE);</span>
<span class="nc" id="L3570">                        fireTreeExpanded(parentPath);</span>
<span class="nc bnc" id="L3571" title="All 2 branches missed.">                        if (accessibleContext != null) {</span>
<span class="nc" id="L3572">                            ((AccessibleJTree)accessibleContext).</span>
<span class="nc" id="L3573">                                              fireVisibleDataPropertyChange();</span>
                        }
                    }
                }
            }
            finally {
<span class="nc bnc" id="L3579" title="All 6 branches missed.">                if (expandedStack.size() &lt; TEMP_STACK_SIZE) {</span>
<span class="nc" id="L3580">                    stack.removeAllElements();</span>
<span class="nc" id="L3581">                    expandedStack.push(stack);</span>
                }
            }
<span class="nc bnc" id="L3584" title="All 2 branches missed.">            if(!state) {</span>
                // collapse last path.
<span class="nc" id="L3586">                Object          cValue = expandedState.get(path);</span>

<span class="nc bnc" id="L3588" title="All 4 branches missed.">                if(cValue != null &amp;&amp; ((Boolean)cValue).booleanValue()) {</span>
                    try {
<span class="nc" id="L3590">                        fireTreeWillCollapse(path);</span>
                    }
<span class="nc" id="L3592">                    catch (ExpandVetoException eve) {</span>
<span class="nc" id="L3593">                        return;</span>
<span class="nc" id="L3594">                    }</span>
<span class="nc" id="L3595">                    expandedState.put(path, Boolean.FALSE);</span>
<span class="nc" id="L3596">                    fireTreeCollapsed(path);</span>
<span class="nc bnc" id="L3597" title="All 2 branches missed.">                    if (removeDescendantSelectedPaths(path, false) &amp;&amp;</span>
<span class="nc bnc" id="L3598" title="All 2 branches missed.">                        !isPathSelected(path)) {</span>
                        // A descendant was selected, select the parent.
<span class="nc" id="L3600">                        addSelectionPath(path);</span>
                    }
<span class="nc bnc" id="L3602" title="All 2 branches missed.">                    if (accessibleContext != null) {</span>
<span class="nc" id="L3603">                        ((AccessibleJTree)accessibleContext).</span>
<span class="nc" id="L3604">                                    fireVisibleDataPropertyChange();</span>
                    }
                }
<span class="nc" id="L3607">            }</span>
            else {
                // Expand last path.
<span class="nc" id="L3610">                Object          cValue = expandedState.get(path);</span>

<span class="nc bnc" id="L3612" title="All 4 branches missed.">                if(cValue == null || !((Boolean)cValue).booleanValue()) {</span>
                    try {
<span class="nc" id="L3614">                        fireTreeWillExpand(path);</span>
                    }
<span class="nc" id="L3616">                    catch (ExpandVetoException eve) {</span>
<span class="nc" id="L3617">                        return;</span>
<span class="nc" id="L3618">                    }</span>
<span class="nc" id="L3619">                    expandedState.put(path, Boolean.TRUE);</span>
<span class="nc" id="L3620">                    fireTreeExpanded(path);</span>
<span class="nc bnc" id="L3621" title="All 2 branches missed.">                    if (accessibleContext != null) {</span>
<span class="nc" id="L3622">                        ((AccessibleJTree)accessibleContext).</span>
<span class="nc" id="L3623">                                          fireVisibleDataPropertyChange();</span>
                    }
                }
            }
        }
<span class="nc" id="L3628">    }</span>

    /**
     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;TreePaths&lt;/code&gt;
     * that have been expanded that
     * are descendants of &lt;code&gt;parent&lt;/code&gt;.
     */
    protected Enumeration&lt;TreePath&gt;
        getDescendantToggledPaths(TreePath parent)
    {
<span class="nc bnc" id="L3638" title="All 2 branches missed.">        if(parent == null)</span>
<span class="nc" id="L3639">            return null;</span>

<span class="nc" id="L3641">        Vector&lt;TreePath&gt; descendants = new Vector&lt;TreePath&gt;();</span>
<span class="nc" id="L3642">        Enumeration&lt;TreePath&gt; nodes = expandedState.keys();</span>

<span class="nc bnc" id="L3644" title="All 2 branches missed.">        while(nodes.hasMoreElements()) {</span>
<span class="nc" id="L3645">            TreePath path = nodes.nextElement();</span>
<span class="nc bnc" id="L3646" title="All 2 branches missed.">            if(parent.isDescendant(path))</span>
<span class="nc" id="L3647">                descendants.addElement(path);</span>
<span class="nc" id="L3648">        }</span>
<span class="nc" id="L3649">        return descendants.elements();</span>
    }

    /**
     * Removes any descendants of the &lt;code&gt;TreePaths&lt;/code&gt; in
     * &lt;code&gt;toRemove&lt;/code&gt;
     * that have been expanded.
     *
     * @param toRemove an enumeration of the paths to remove; a value of
     *        {@code null} is ignored
     * @throws ClassCastException if {@code toRemove} contains an
     *         element that is not a {@code TreePath}; {@code null}
     *         values are ignored
     */
     protected void
         removeDescendantToggledPaths(Enumeration&lt;TreePath&gt; toRemove)
    {
<span class="nc bnc" id="L3666" title="All 2 branches missed.">         if(toRemove != null) {</span>
<span class="nc bnc" id="L3667" title="All 2 branches missed.">             while(toRemove.hasMoreElements()) {</span>
<span class="nc" id="L3668">                 Enumeration&lt;?&gt; descendants = getDescendantToggledPaths</span>
<span class="nc" id="L3669">                         (toRemove.nextElement());</span>

<span class="nc bnc" id="L3671" title="All 2 branches missed.">                 if(descendants != null) {</span>
<span class="nc bnc" id="L3672" title="All 2 branches missed.">                     while(descendants.hasMoreElements()) {</span>
<span class="nc" id="L3673">                         expandedState.remove(descendants.nextElement());</span>
                     }
                 }
<span class="nc" id="L3676">             }</span>
         }
<span class="nc" id="L3678">     }</span>

     /**
      * Clears the cache of toggled tree paths. This does NOT send out
      * any &lt;code&gt;TreeExpansionListener&lt;/code&gt; events.
      */
     protected void clearToggledPaths() {
<span class="nc" id="L3685">         expandedState.clear();</span>
<span class="nc" id="L3686">     }</span>

     /**
      * Creates and returns an instance of &lt;code&gt;TreeModelHandler&lt;/code&gt;.
      * The returned
      * object is responsible for updating the expanded state when the
      * &lt;code&gt;TreeModel&lt;/code&gt; changes.
      * &lt;p&gt;
      * For more information on what expanded state means, see the
      * &lt;a href=#jtree_description&gt;JTree description&lt;/a&gt; above.
      */
     protected TreeModelListener createTreeModelListener() {
<span class="nc" id="L3698">         return new TreeModelHandler();</span>
     }

    /**
     * Removes any paths in the selection that are descendants of
     * &lt;code&gt;path&lt;/code&gt;. If &lt;code&gt;includePath&lt;/code&gt; is true and
     * &lt;code&gt;path&lt;/code&gt; is selected, it will be removed from the selection.
     *
     * @return true if a descendant was selected
     * @since 1.3
     */
    protected boolean removeDescendantSelectedPaths(TreePath path,
                                                    boolean includePath) {
<span class="nc" id="L3711">        TreePath[]    toRemove = getDescendantSelectedPaths(path, includePath);</span>

<span class="nc bnc" id="L3713" title="All 2 branches missed.">        if (toRemove != null) {</span>
<span class="nc" id="L3714">            getSelectionModel().removeSelectionPaths(toRemove);</span>
<span class="nc" id="L3715">            return true;</span>
        }
<span class="nc" id="L3717">        return false;</span>
    }

    /**
     * Returns an array of paths in the selection that are descendants of
     * &lt;code&gt;path&lt;/code&gt;. The returned array may contain &lt;code&gt;null&lt;/code&gt;s.
     */
    private TreePath[] getDescendantSelectedPaths(TreePath path,
                                                  boolean includePath) {
<span class="nc" id="L3726">        TreeSelectionModel   sm = getSelectionModel();</span>
<span class="nc bnc" id="L3727" title="All 2 branches missed.">        TreePath[]           selPaths = (sm != null) ? sm.getSelectionPaths() :</span>
                                        null;

<span class="nc bnc" id="L3730" title="All 2 branches missed.">        if(selPaths != null) {</span>
<span class="nc" id="L3731">            boolean        shouldRemove = false;</span>

<span class="nc bnc" id="L3733" title="All 2 branches missed.">            for(int counter = selPaths.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc bnc" id="L3734" title="All 2 branches missed.">                if(selPaths[counter] != null &amp;&amp;</span>
<span class="nc bnc" id="L3735" title="All 2 branches missed.">                   path.isDescendant(selPaths[counter]) &amp;&amp;</span>
<span class="nc bnc" id="L3736" title="All 4 branches missed.">                   (!path.equals(selPaths[counter]) || includePath))</span>
<span class="nc" id="L3737">                    shouldRemove = true;</span>
                else
<span class="nc" id="L3739">                    selPaths[counter] = null;</span>
            }
<span class="nc bnc" id="L3741" title="All 2 branches missed.">            if(!shouldRemove) {</span>
<span class="nc" id="L3742">                selPaths = null;</span>
            }
<span class="nc" id="L3744">            return selPaths;</span>
        }
<span class="nc" id="L3746">        return null;</span>
    }

    /**
     * Removes any paths from the selection model that are descendants of
     * the nodes identified by in &lt;code&gt;e&lt;/code&gt;.
     */
    void removeDescendantSelectedPaths(TreeModelEvent e) {
<span class="nc" id="L3754">        TreePath            pPath = SwingUtilities2.getTreePath(e, getModel());</span>
<span class="nc" id="L3755">        Object[]            oldChildren = e.getChildren();</span>
<span class="nc" id="L3756">        TreeSelectionModel  sm = getSelectionModel();</span>

<span class="nc bnc" id="L3758" title="All 8 branches missed.">        if (sm != null &amp;&amp; pPath != null &amp;&amp; oldChildren != null &amp;&amp;</span>
            oldChildren.length &gt; 0) {
<span class="nc bnc" id="L3760" title="All 2 branches missed.">            for (int counter = oldChildren.length - 1; counter &gt;= 0;</span>
<span class="nc" id="L3761">                 counter--) {</span>
                // Might be better to call getDescendantSelectedPaths
                // numerous times, then push to the model.
<span class="nc" id="L3764">                removeDescendantSelectedPaths(pPath.pathByAddingChild</span>
<span class="nc" id="L3765">                                              (oldChildren[counter]), true);</span>
            }
        }
<span class="nc" id="L3768">    }</span>


     /**
      * Listens to the model and updates the &lt;code&gt;expandedState&lt;/code&gt;
      * accordingly when nodes are removed, or changed.
      */
<span class="nc" id="L3775">    protected class TreeModelHandler implements TreeModelListener {</span>
<span class="nc" id="L3776">        public void treeNodesChanged(TreeModelEvent e) { }</span>

<span class="nc" id="L3778">        public void treeNodesInserted(TreeModelEvent e) { }</span>

        public void treeStructureChanged(TreeModelEvent e) {
<span class="nc bnc" id="L3781" title="All 2 branches missed.">            if(e == null)</span>
<span class="nc" id="L3782">                return;</span>

            // NOTE: If I change this to NOT remove the descendants
            // and update BasicTreeUIs treeStructureChanged method
            // to update descendants in response to a treeStructureChanged
            // event, all the children of the event won't collapse!
<span class="nc" id="L3788">            TreePath            parent = SwingUtilities2.getTreePath(e, getModel());</span>

<span class="nc bnc" id="L3790" title="All 2 branches missed.">            if(parent == null)</span>
<span class="nc" id="L3791">                return;</span>

<span class="nc bnc" id="L3793" title="All 2 branches missed.">            if (parent.getPathCount() == 1) {</span>
                // New root, remove everything!
<span class="nc" id="L3795">                clearToggledPaths();</span>
<span class="nc bnc" id="L3796" title="All 2 branches missed.">                if(treeModel.getRoot() != null &amp;&amp;</span>
<span class="nc bnc" id="L3797" title="All 2 branches missed.">                   !treeModel.isLeaf(treeModel.getRoot())) {</span>
                    // Mark the root as expanded, if it isn't a leaf.
<span class="nc" id="L3799">                    expandedState.put(parent, Boolean.TRUE);</span>
                }
            }
<span class="nc bnc" id="L3802" title="All 2 branches missed.">            else if(expandedState.get(parent) != null) {</span>
<span class="nc" id="L3803">                Vector&lt;TreePath&gt;    toRemove = new Vector&lt;TreePath&gt;(1);</span>
<span class="nc" id="L3804">                boolean             isExpanded = isExpanded(parent);</span>

<span class="nc" id="L3806">                toRemove.addElement(parent);</span>
<span class="nc" id="L3807">                removeDescendantToggledPaths(toRemove.elements());</span>
<span class="nc bnc" id="L3808" title="All 2 branches missed.">                if(isExpanded) {</span>
<span class="nc" id="L3809">                    TreeModel         model = getModel();</span>

<span class="nc bnc" id="L3811" title="All 2 branches missed.">                    if(model == null || model.isLeaf</span>
<span class="nc bnc" id="L3812" title="All 2 branches missed.">                       (parent.getLastPathComponent()))</span>
<span class="nc" id="L3813">                        collapsePath(parent);</span>
                    else
<span class="nc" id="L3815">                        expandedState.put(parent, Boolean.TRUE);</span>
                }
            }
<span class="nc" id="L3818">            removeDescendantSelectedPaths(parent, false);</span>
<span class="nc" id="L3819">        }</span>

        public void treeNodesRemoved(TreeModelEvent e) {
<span class="nc bnc" id="L3822" title="All 2 branches missed.">            if(e == null)</span>
<span class="nc" id="L3823">                return;</span>

<span class="nc" id="L3825">            TreePath            parent = SwingUtilities2.getTreePath(e, getModel());</span>
<span class="nc" id="L3826">            Object[]            children = e.getChildren();</span>

<span class="nc bnc" id="L3828" title="All 2 branches missed.">            if(children == null)</span>
<span class="nc" id="L3829">                return;</span>

            TreePath            rPath;
<span class="nc" id="L3832">            Vector&lt;TreePath&gt;    toRemove</span>
<span class="nc" id="L3833">                = new Vector&lt;TreePath&gt;(Math.max(1, children.length));</span>

<span class="nc bnc" id="L3835" title="All 2 branches missed.">            for(int counter = children.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L3836">                rPath = parent.pathByAddingChild(children[counter]);</span>
<span class="nc bnc" id="L3837" title="All 2 branches missed.">                if(expandedState.get(rPath) != null)</span>
<span class="nc" id="L3838">                    toRemove.addElement(rPath);</span>
            }
<span class="nc bnc" id="L3840" title="All 2 branches missed.">            if(toRemove.size() &gt; 0)</span>
<span class="nc" id="L3841">                removeDescendantToggledPaths(toRemove.elements());</span>

<span class="nc" id="L3843">            TreeModel         model = getModel();</span>

<span class="nc bnc" id="L3845" title="All 4 branches missed.">            if(model == null || model.isLeaf(parent.getLastPathComponent()))</span>
<span class="nc" id="L3846">                expandedState.remove(parent);</span>

<span class="nc" id="L3848">            removeDescendantSelectedPaths(e);</span>
<span class="nc" id="L3849">        }</span>
    }


    /**
     * &lt;code&gt;DynamicUtilTreeNode&lt;/code&gt; can wrap
     * vectors/hashtables/arrays/strings and
     * create the appropriate children tree nodes as necessary. It is
     * dynamic in that it will only create the children as necessary.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    @SuppressWarnings(&quot;serial&quot;)
    public static class DynamicUtilTreeNode extends DefaultMutableTreeNode {
        /**
         * Does the this &lt;code&gt;JTree&lt;/code&gt; have children?
         * This property is currently not implemented.
         */
        protected boolean            hasChildren;
        /** Value to create children with. */
        protected Object             childValue;
        /** Have the children been loaded yet? */
        protected boolean            loadedChildren;

        /**
         * Adds to parent all the children in &lt;code&gt;children&lt;/code&gt;.
         * If &lt;code&gt;children&lt;/code&gt; is an array or vector all of its
         * elements are added is children, otherwise if &lt;code&gt;children&lt;/code&gt;
         * is a hashtable all the key/value pairs are added in the order
         * &lt;code&gt;Enumeration&lt;/code&gt; returns them.
         */
        public static void createChildren(DefaultMutableTreeNode parent,
                                          Object children) {
<span class="nc bnc" id="L3889" title="All 2 branches missed.">            if(children instanceof Vector) {</span>
<span class="nc" id="L3890">                Vector&lt;?&gt;          childVector = (Vector)children;</span>

<span class="nc" id="L3892">                for(int counter = 0, maxCounter = childVector.size();</span>
<span class="nc bnc" id="L3893" title="All 2 branches missed.">                    counter &lt; maxCounter; counter++)</span>
<span class="nc" id="L3894">                    parent.add(new DynamicUtilTreeNode</span>
<span class="nc" id="L3895">                               (childVector.elementAt(counter),</span>
<span class="nc" id="L3896">                                childVector.elementAt(counter)));</span>
<span class="nc" id="L3897">            }</span>
<span class="nc bnc" id="L3898" title="All 2 branches missed.">            else if(children instanceof Hashtable) {</span>
<span class="nc" id="L3899">                Hashtable&lt;?,?&gt;           childHT = (Hashtable)children;</span>
<span class="nc" id="L3900">                Enumeration&lt;?&gt;         keys = childHT.keys();</span>
                Object              aKey;

<span class="nc bnc" id="L3903" title="All 2 branches missed.">                while(keys.hasMoreElements()) {</span>
<span class="nc" id="L3904">                    aKey = keys.nextElement();</span>
<span class="nc" id="L3905">                    parent.add(new DynamicUtilTreeNode(aKey,</span>
<span class="nc" id="L3906">                                                       childHT.get(aKey)));</span>
                }
<span class="nc" id="L3908">            }</span>
<span class="nc bnc" id="L3909" title="All 2 branches missed.">            else if(children instanceof Object[]) {</span>
<span class="nc" id="L3910">                Object[]             childArray = (Object[])children;</span>

<span class="nc" id="L3912">                for(int counter = 0, maxCounter = childArray.length;</span>
<span class="nc bnc" id="L3913" title="All 2 branches missed.">                    counter &lt; maxCounter; counter++)</span>
<span class="nc" id="L3914">                    parent.add(new DynamicUtilTreeNode(childArray[counter],</span>
                                                       childArray[counter]));
            }
<span class="nc" id="L3917">        }</span>

        /**
         * Creates a node with the specified object as its value and
         * with the specified children. For the node to allow children,
         * the children-object must be an array of objects, a
         * &lt;code&gt;Vector&lt;/code&gt;, or a &lt;code&gt;Hashtable&lt;/code&gt; -- even
         * if empty. Otherwise, the node is not
         * allowed to have children.
         *
         * @param value  the &lt;code&gt;Object&lt;/code&gt; that is the value for the
         *              new node
         * @param children an array of &lt;code&gt;Object&lt;/code&gt;s, a
         *              &lt;code&gt;Vector&lt;/code&gt;, or a &lt;code&gt;Hashtable&lt;/code&gt;
         *              used to create the child nodes; if any other
         *              object is specified, or if the value is
         *              &lt;code&gt;null&lt;/code&gt;,
         *              then the node is not allowed to have children
         */
        public DynamicUtilTreeNode(Object value, Object children) {
<span class="nc" id="L3937">            super(value);</span>
<span class="nc" id="L3938">            loadedChildren = false;</span>
<span class="nc" id="L3939">            childValue = children;</span>
<span class="nc bnc" id="L3940" title="All 2 branches missed.">            if(children != null) {</span>
<span class="nc bnc" id="L3941" title="All 2 branches missed.">                if(children instanceof Vector)</span>
<span class="nc" id="L3942">                    setAllowsChildren(true);</span>
<span class="nc bnc" id="L3943" title="All 2 branches missed.">                else if(children instanceof Hashtable)</span>
<span class="nc" id="L3944">                    setAllowsChildren(true);</span>
<span class="nc bnc" id="L3945" title="All 2 branches missed.">                else if(children instanceof Object[])</span>
<span class="nc" id="L3946">                    setAllowsChildren(true);</span>
                else
<span class="nc" id="L3948">                    setAllowsChildren(false);</span>
            }
            else
<span class="nc" id="L3951">                setAllowsChildren(false);</span>
<span class="nc" id="L3952">        }</span>

        /**
         * Returns true if this node allows children. Whether the node
         * allows children depends on how it was created.
         *
         * @return true if this node allows children, false otherwise
         * @see #JTree.DynamicUtilTreeNode
         */
        public boolean isLeaf() {
<span class="nc bnc" id="L3962" title="All 2 branches missed.">            return !getAllowsChildren();</span>
        }

        /**
         * Returns the number of child nodes.
         *
         * @return the number of child nodes
         */
        public int getChildCount() {
<span class="nc bnc" id="L3971" title="All 2 branches missed.">            if(!loadedChildren)</span>
<span class="nc" id="L3972">                loadChildren();</span>
<span class="nc" id="L3973">            return super.getChildCount();</span>
        }

        /**
         * Loads the children based on &lt;code&gt;childValue&lt;/code&gt;.
         * If &lt;code&gt;childValue&lt;/code&gt; is a &lt;code&gt;Vector&lt;/code&gt;
         * or array each element is added as a child,
         * if &lt;code&gt;childValue&lt;/code&gt; is a &lt;code&gt;Hashtable&lt;/code&gt;
         * each key/value pair is added in the order that
         * &lt;code&gt;Enumeration&lt;/code&gt; returns the keys.
         */
        protected void loadChildren() {
<span class="nc" id="L3985">            loadedChildren = true;</span>
<span class="nc" id="L3986">            createChildren(this, childValue);</span>
<span class="nc" id="L3987">        }</span>

        /**
         * Subclassed to load the children, if necessary.
         */
        public TreeNode getChildAt(int index) {
<span class="nc bnc" id="L3993" title="All 2 branches missed.">            if(!loadedChildren)</span>
<span class="nc" id="L3994">                loadChildren();</span>
<span class="nc" id="L3995">            return super.getChildAt(index);</span>
        }

        /**
         * Subclassed to load the children, if necessary.
         */
        public Enumeration children() {
<span class="nc bnc" id="L4002" title="All 2 branches missed.">            if(!loadedChildren)</span>
<span class="nc" id="L4003">                loadChildren();</span>
<span class="nc" id="L4004">            return super.children();</span>
        }
    }

    void setUIProperty(String propertyName, Object value) {
<span class="nc bnc" id="L4009" title="All 2 branches missed.">        if (propertyName == &quot;rowHeight&quot;) {</span>
<span class="nc bnc" id="L4010" title="All 2 branches missed.">            if (!rowHeightSet) {</span>
<span class="nc" id="L4011">                setRowHeight(((Number)value).intValue());</span>
<span class="nc" id="L4012">                rowHeightSet = false;</span>
            }
<span class="nc bnc" id="L4014" title="All 2 branches missed.">        } else if (propertyName == &quot;scrollsOnExpand&quot;) {</span>
<span class="nc bnc" id="L4015" title="All 2 branches missed.">            if (!scrollsOnExpandSet) {</span>
<span class="nc" id="L4016">                setScrollsOnExpand(((Boolean)value).booleanValue());</span>
<span class="nc" id="L4017">                scrollsOnExpandSet = false;</span>
            }
<span class="nc bnc" id="L4019" title="All 2 branches missed.">        } else if (propertyName == &quot;showsRootHandles&quot;) {</span>
<span class="nc bnc" id="L4020" title="All 2 branches missed.">            if (!showsRootHandlesSet) {</span>
<span class="nc" id="L4021">                setShowsRootHandles(((Boolean)value).booleanValue());</span>
<span class="nc" id="L4022">                showsRootHandlesSet = false;</span>
            }
        } else {
<span class="nc" id="L4025">            super.setUIProperty(propertyName, value);</span>
        }
<span class="nc" id="L4027">    }</span>


    /**
     * Returns a string representation of this &lt;code&gt;JTree&lt;/code&gt;.
     * This method
     * is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this &lt;code&gt;JTree&lt;/code&gt;.
     */
    protected String paramString() {
<span class="nc bnc" id="L4041" title="All 2 branches missed.">        String rootVisibleString = (rootVisible ?</span>
                                    &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L4043" title="All 2 branches missed.">        String showsRootHandlesString = (showsRootHandles ?</span>
                                         &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L4045" title="All 2 branches missed.">        String editableString = (editable ?</span>
                                 &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L4047" title="All 2 branches missed.">        String largeModelString = (largeModel ?</span>
                                   &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L4049" title="All 2 branches missed.">        String invokesStopCellEditingString = (invokesStopCellEditing ?</span>
                                               &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L4051" title="All 2 branches missed.">        String scrollsOnExpandString = (scrollsOnExpand ?</span>
                                        &quot;true&quot; : &quot;false&quot;);

<span class="nc" id="L4054">        return super.paramString() +</span>
        &quot;,editable=&quot; + editableString +
        &quot;,invokesStopCellEditing=&quot; + invokesStopCellEditingString +
        &quot;,largeModel=&quot; + largeModelString +
        &quot;,rootVisible=&quot; + rootVisibleString +
        &quot;,rowHeight=&quot; + rowHeight +
        &quot;,scrollsOnExpand=&quot; + scrollsOnExpandString +
        &quot;,showsRootHandles=&quot; + showsRootHandlesString +
        &quot;,toggleClickCount=&quot; + toggleClickCount +
        &quot;,visibleRowCount=&quot; + visibleRowCount;
    }

/////////////////
// Accessibility support
////////////////

    /**
     * Gets the AccessibleContext associated with this JTree.
     * For JTrees, the AccessibleContext takes the form of an
     * AccessibleJTree.
     * A new AccessibleJTree instance is created if necessary.
     *
     * @return an AccessibleJTree that serves as the
     *         AccessibleContext of this JTree
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L4080" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L4081">            accessibleContext = new AccessibleJTree();</span>
        }
<span class="nc" id="L4083">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JTree&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to tree user-interface elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    @SuppressWarnings(&quot;serial&quot;)
    protected class AccessibleJTree extends AccessibleJComponent
            implements AccessibleSelection, TreeSelectionListener,
                       TreeModelListener, TreeExpansionListener  {

        TreePath   leadSelectionPath;
        Accessible leadSelectionAccessible;

<span class="nc" id="L4108">        public AccessibleJTree() {</span>
            // Add a tree model listener for JTree
<span class="nc" id="L4110">            TreeModel model = JTree.this.getModel();</span>
<span class="nc bnc" id="L4111" title="All 2 branches missed.">            if (model != null) {</span>
<span class="nc" id="L4112">                model.addTreeModelListener(this);</span>
            }
<span class="nc" id="L4114">            JTree.this.addTreeExpansionListener(this);</span>
<span class="nc" id="L4115">            JTree.this.addTreeSelectionListener(this);</span>
<span class="nc" id="L4116">            leadSelectionPath = JTree.this.getLeadSelectionPath();</span>
<span class="nc bnc" id="L4117" title="All 2 branches missed.">            leadSelectionAccessible = (leadSelectionPath != null)</span>
                    ? new AccessibleJTreeNode(JTree.this,
                                              leadSelectionPath,
                                              JTree.this)
                    : null;
<span class="nc" id="L4122">        }</span>

        /**
         * Tree Selection Listener value change method. Used to fire the
         * property change
         *
         * @param e ListSelectionEvent
         *
         */
        public void valueChanged(TreeSelectionEvent e) {
            // Fixes 4546503 - JTree is sending incorrect active
            // descendant events
<span class="nc" id="L4134">            TreePath oldLeadSelectionPath = e.getOldLeadSelectionPath();</span>
<span class="nc" id="L4135">            leadSelectionPath = e.getNewLeadSelectionPath();</span>

<span class="nc bnc" id="L4137" title="All 2 branches missed.">            if (oldLeadSelectionPath != leadSelectionPath) {</span>
                // Set parent to null so AccessibleJTreeNode computes
                // its parent.
<span class="nc" id="L4140">                Accessible oldLSA = leadSelectionAccessible;</span>
<span class="nc bnc" id="L4141" title="All 2 branches missed.">                leadSelectionAccessible = (leadSelectionPath != null)</span>
                        ? new AccessibleJTreeNode(JTree.this,
                                                  leadSelectionPath,
                                                  null) // parent
                        : null;
<span class="nc" id="L4146">                firePropertyChange(AccessibleContext.ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY,</span>
                                   oldLSA, leadSelectionAccessible);
            }
<span class="nc" id="L4149">            firePropertyChange(AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,</span>
<span class="nc" id="L4150">                               Boolean.valueOf(false), Boolean.valueOf(true));</span>
<span class="nc" id="L4151">        }</span>

        /**
         * Fire a visible data property change notification.
         * A 'visible' data property is one that represents
         * something about the way the component appears on the
         * display, where that appearance isn't bound to any other
         * property. It notifies screen readers  that the visual
         * appearance of the component has changed, so they can
         * notify the user.
         */
        public void fireVisibleDataPropertyChange() {
<span class="nc" id="L4163">           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
<span class="nc" id="L4164">                              Boolean.valueOf(false), Boolean.valueOf(true));</span>
<span class="nc" id="L4165">        }</span>

        // Fire the visible data changes for the model changes.

        /**
         * Tree Model Node change notification.
         *
         * @param e  a Tree Model event
         */
        public void treeNodesChanged(TreeModelEvent e) {
<span class="nc" id="L4175">           fireVisibleDataPropertyChange();</span>
<span class="nc" id="L4176">        }</span>

        /**
         * Tree Model Node change notification.
         *
         * @param e  a Tree node insertion event
         */
        public void treeNodesInserted(TreeModelEvent e) {
<span class="nc" id="L4184">           fireVisibleDataPropertyChange();</span>
<span class="nc" id="L4185">        }</span>

        /**
         * Tree Model Node change notification.
         *
         * @param e  a Tree node(s) removal event
         */
        public  void treeNodesRemoved(TreeModelEvent e) {
<span class="nc" id="L4193">           fireVisibleDataPropertyChange();</span>
<span class="nc" id="L4194">        }</span>

        /**
         * Tree Model structure change change notification.
         *
         * @param e  a Tree Model event
         */
        public  void treeStructureChanged(TreeModelEvent e) {
<span class="nc" id="L4202">           fireVisibleDataPropertyChange();</span>
<span class="nc" id="L4203">        }</span>

        /**
         * Tree Collapsed notification.
         *
         * @param e  a TreeExpansionEvent
         */
        public  void treeCollapsed(TreeExpansionEvent e) {
<span class="nc" id="L4211">            fireVisibleDataPropertyChange();</span>
<span class="nc" id="L4212">            TreePath path = e.getPath();</span>
<span class="nc bnc" id="L4213" title="All 2 branches missed.">            if (path != null) {</span>
                // Set parent to null so AccessibleJTreeNode computes
                // its parent.
<span class="nc" id="L4216">                AccessibleJTreeNode node = new AccessibleJTreeNode(JTree.this,</span>
                                                                   path,
                                                                   null);
<span class="nc" id="L4219">                PropertyChangeEvent pce = new PropertyChangeEvent(node,</span>
                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                    AccessibleState.EXPANDED,
                    AccessibleState.COLLAPSED);
<span class="nc" id="L4223">                firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,</span>
                                   null, pce);
            }
<span class="nc" id="L4226">        }</span>

        /**
         * Tree Model Expansion notification.
         *
         * @param e  a Tree node insertion event
         */
        public  void treeExpanded(TreeExpansionEvent e) {
<span class="nc" id="L4234">            fireVisibleDataPropertyChange();</span>
<span class="nc" id="L4235">            TreePath path = e.getPath();</span>
<span class="nc bnc" id="L4236" title="All 2 branches missed.">            if (path != null) {</span>
                // TIGER - 4839971
                // Set parent to null so AccessibleJTreeNode computes
                // its parent.
<span class="nc" id="L4240">                AccessibleJTreeNode node = new AccessibleJTreeNode(JTree.this,</span>
                                                                   path,
                                                                   null);
<span class="nc" id="L4243">                PropertyChangeEvent pce = new PropertyChangeEvent(node,</span>
                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                    AccessibleState.COLLAPSED,
                    AccessibleState.EXPANDED);
<span class="nc" id="L4247">                firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,</span>
                                   null, pce);
            }
<span class="nc" id="L4250">        }</span>


        private AccessibleContext getCurrentAccessibleContext() {
<span class="nc" id="L4254">            Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L4255" title="All 2 branches missed.">            if (c instanceof Accessible) {</span>
<span class="nc" id="L4256">                return c.getAccessibleContext();</span>
            } else {
<span class="nc" id="L4258">                return null;</span>
            }
        }

        private Component getCurrentComponent() {
            // is the object visible?
            // if so, get row, selected, focus &amp; leaf state,
            // and then get the renderer component and return it
<span class="nc" id="L4266">            TreeModel model = JTree.this.getModel();</span>
<span class="nc bnc" id="L4267" title="All 2 branches missed.">            if (model == null) {</span>
<span class="nc" id="L4268">                return null;</span>
            }
<span class="nc" id="L4270">            TreePath path = new TreePath(model.getRoot());</span>
<span class="nc bnc" id="L4271" title="All 2 branches missed.">            if (JTree.this.isVisible(path)) {</span>
<span class="nc" id="L4272">                TreeCellRenderer r = JTree.this.getCellRenderer();</span>
<span class="nc" id="L4273">                TreeUI ui = JTree.this.getUI();</span>
<span class="nc bnc" id="L4274" title="All 2 branches missed.">                if (ui != null) {</span>
<span class="nc" id="L4275">                    int row = ui.getRowForPath(JTree.this, path);</span>
<span class="nc" id="L4276">                    int lsr = JTree.this.getLeadSelectionRow();</span>
<span class="nc bnc" id="L4277" title="All 4 branches missed.">                    boolean hasFocus = JTree.this.isFocusOwner()</span>
                                       &amp;&amp; (lsr == row);
<span class="nc" id="L4279">                    boolean selected = JTree.this.isPathSelected(path);</span>
<span class="nc" id="L4280">                    boolean expanded = JTree.this.isExpanded(path);</span>

<span class="nc" id="L4282">                    return r.getTreeCellRendererComponent(JTree.this,</span>
<span class="nc" id="L4283">                        model.getRoot(), selected, expanded,</span>
<span class="nc" id="L4284">                        model.isLeaf(model.getRoot()), row, hasFocus);</span>
                }
            }
<span class="nc" id="L4287">            return null;</span>
        }

        // Overridden methods from AccessibleJComponent

        /**
         * Get the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of the
         * object
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L4300">            return AccessibleRole.TREE;</span>
        }

        /**
         * Returns the &lt;code&gt;Accessible&lt;/code&gt; child, if one exists,
         * contained at the local coordinate &lt;code&gt;Point&lt;/code&gt;.
         * Otherwise returns &lt;code&gt;null&lt;/code&gt;.
         *
         * @param p point in local coordinates of this &lt;code&gt;Accessible&lt;/code&gt;
         * @return the &lt;code&gt;Accessible&lt;/code&gt;, if it exists,
         *    at the specified location; else &lt;code&gt;null&lt;/code&gt;
         */
        public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L4313">            TreePath path = getClosestPathForLocation(p.x, p.y);</span>
<span class="nc bnc" id="L4314" title="All 2 branches missed.">            if (path != null) {</span>
                // JTree.this is NOT the parent; parent will get computed later
<span class="nc" id="L4316">                return new AccessibleJTreeNode(JTree.this, path, null);</span>
            } else {
<span class="nc" id="L4318">                return null;</span>
            }
        }

        /**
         * Returns the number of top-level children nodes of this
         * JTree.  Each of these nodes may in turn have children nodes.
         *
         * @return the number of accessible children nodes in the tree.
         */
        public int getAccessibleChildrenCount() {
<span class="nc" id="L4329">            TreeModel model = JTree.this.getModel();</span>
<span class="nc bnc" id="L4330" title="All 2 branches missed.">            if (model == null) {</span>
<span class="nc" id="L4331">                return 0;</span>
            }
<span class="nc bnc" id="L4333" title="All 2 branches missed.">            if (isRootVisible()) {</span>
<span class="nc" id="L4334">                return 1;    // the root node</span>
            }

            // return the root's first set of children count
<span class="nc" id="L4338">            return model.getChildCount(model.getRoot());</span>
        }

        /**
         * Return the nth Accessible child of the object.
         *
         * @param i zero-based index of child
         * @return the nth Accessible child of the object
         */
        public Accessible getAccessibleChild(int i) {
<span class="nc" id="L4348">            TreeModel model = JTree.this.getModel();</span>
<span class="nc bnc" id="L4349" title="All 2 branches missed.">            if (model == null) {</span>
<span class="nc" id="L4350">                return null;</span>
            }
<span class="nc bnc" id="L4352" title="All 2 branches missed.">            if (isRootVisible()) {</span>
<span class="nc bnc" id="L4353" title="All 2 branches missed.">                if (i == 0) {    // return the root node Accessible</span>
<span class="nc" id="L4354">                    Object[] objPath = { model.getRoot() };</span>
<span class="nc" id="L4355">                    TreePath path = new TreePath(objPath);</span>
<span class="nc" id="L4356">                    return new AccessibleJTreeNode(JTree.this, path, JTree.this);</span>
                } else {
<span class="nc" id="L4358">                    return null;</span>
                }
            }

            // return Accessible for one of root's child nodes
<span class="nc" id="L4363">            int count = model.getChildCount(model.getRoot());</span>
<span class="nc bnc" id="L4364" title="All 4 branches missed.">            if (i &lt; 0 || i &gt;= count) {</span>
<span class="nc" id="L4365">                return null;</span>
            }
<span class="nc" id="L4367">            Object obj = model.getChild(model.getRoot(), i);</span>
<span class="nc" id="L4368">            Object[] objPath = { model.getRoot(), obj };</span>
<span class="nc" id="L4369">            TreePath path = new TreePath(objPath);</span>
<span class="nc" id="L4370">            return new AccessibleJTreeNode(JTree.this, path, JTree.this);</span>
        }

        /**
         * Get the index of this object in its accessible parent.
         *
         * @return the index of this object in its parent.  Since a JTree
         * top-level object does not have an accessible parent.
         * @see #getAccessibleParent
         */
        public int getAccessibleIndexInParent() {
            // didn't ever need to override this...
<span class="nc" id="L4382">            return super.getAccessibleIndexInParent();</span>
        }

        // AccessibleSelection methods
        /**
         * Get the AccessibleSelection associated with this object.  In the
         * implementation of the Java Accessibility API for this class,
         * return this object, which is responsible for implementing the
         * AccessibleSelection interface on behalf of itself.
         *
         * @return this object
         */
        public AccessibleSelection getAccessibleSelection() {
<span class="nc" id="L4395">            return this;</span>
        }

        /**
         * Returns the number of items currently selected.
         * If no items are selected, the return value will be 0.
         *
         * @return the number of items currently selected.
         */
        public int getAccessibleSelectionCount() {
<span class="nc" id="L4405">            Object[] rootPath = new Object[1];</span>
<span class="nc" id="L4406">            rootPath[0] = treeModel.getRoot();</span>
<span class="nc" id="L4407">            TreePath childPath = new TreePath(rootPath);</span>
<span class="nc bnc" id="L4408" title="All 2 branches missed.">            if (JTree.this.isPathSelected(childPath)) {</span>
<span class="nc" id="L4409">                return 1;</span>
            } else {
<span class="nc" id="L4411">                return 0;</span>
            }
        }

        /**
         * Returns an Accessible representing the specified selected item
         * in the object.  If there isn't a selection, or there are
         * fewer items selected than the integer passed in, the return
         * value will be null.
         *
         * @param i the zero-based index of selected items
         * @return an Accessible containing the selected item
         */
        public Accessible getAccessibleSelection(int i) {
            // The JTree can have only one accessible child, the root.
<span class="nc bnc" id="L4426" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L4427">                Object[] rootPath = new Object[1];</span>
<span class="nc" id="L4428">                rootPath[0] = treeModel.getRoot();</span>
<span class="nc" id="L4429">                TreePath childPath = new TreePath(rootPath);</span>
<span class="nc bnc" id="L4430" title="All 2 branches missed.">                if (JTree.this.isPathSelected(childPath)) {</span>
<span class="nc" id="L4431">                    return new AccessibleJTreeNode(JTree.this, childPath, JTree.this);</span>
                }
            }
<span class="nc" id="L4434">            return null;</span>
        }

        /**
         * Returns true if the current child of this object is selected.
         *
         * @param i the zero-based index of the child in this Accessible object.
         * @see AccessibleContext#getAccessibleChild
         */
        public boolean isAccessibleChildSelected(int i) {
            // The JTree can have only one accessible child, the root.
<span class="nc bnc" id="L4445" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L4446">                Object[] rootPath = new Object[1];</span>
<span class="nc" id="L4447">                rootPath[0] = treeModel.getRoot();</span>
<span class="nc" id="L4448">                TreePath childPath = new TreePath(rootPath);</span>
<span class="nc" id="L4449">                return JTree.this.isPathSelected(childPath);</span>
            } else {
<span class="nc" id="L4451">                return false;</span>
            }
        }

        /**
         * Adds the specified selected item in the object to the object's
         * selection.  If the object supports multiple selections,
         * the specified item is added to any existing selection, otherwise
         * it replaces any existing selection in the object.  If the
         * specified item is already selected, this method has no effect.
         *
         * @param i the zero-based index of selectable items
         */
        public void addAccessibleSelection(int i) {
<span class="nc" id="L4465">           TreeModel model = JTree.this.getModel();</span>
<span class="nc bnc" id="L4466" title="All 2 branches missed.">           if (model != null) {</span>
<span class="nc bnc" id="L4467" title="All 2 branches missed.">               if (i == 0) {</span>
<span class="nc" id="L4468">                   Object[] objPath = {model.getRoot()};</span>
<span class="nc" id="L4469">                   TreePath path = new TreePath(objPath);</span>
<span class="nc" id="L4470">                   JTree.this.addSelectionPath(path);</span>
                }
            }
<span class="nc" id="L4473">        }</span>

        /**
         * Removes the specified selected item in the object from the object's
         * selection.  If the specified item isn't currently selected, this
         * method has no effect.
         *
         * @param i the zero-based index of selectable items
         */
        public void removeAccessibleSelection(int i) {
<span class="nc" id="L4483">            TreeModel model = JTree.this.getModel();</span>
<span class="nc bnc" id="L4484" title="All 2 branches missed.">            if (model != null) {</span>
<span class="nc bnc" id="L4485" title="All 2 branches missed.">                if (i == 0) {</span>
<span class="nc" id="L4486">                    Object[] objPath = {model.getRoot()};</span>
<span class="nc" id="L4487">                    TreePath path = new TreePath(objPath);</span>
<span class="nc" id="L4488">                    JTree.this.removeSelectionPath(path);</span>
                }
            }
<span class="nc" id="L4491">        }</span>

        /**
         * Clears the selection in the object, so that nothing in the
         * object is selected.
         */
        public void clearAccessibleSelection() {
<span class="nc" id="L4498">            int childCount = getAccessibleChildrenCount();</span>
<span class="nc bnc" id="L4499" title="All 2 branches missed.">            for (int i = 0; i &lt; childCount; i++) {</span>
<span class="nc" id="L4500">                removeAccessibleSelection(i);</span>
            }
<span class="nc" id="L4502">        }</span>

        /**
         * Causes every selected item in the object to be selected
         * if the object supports multiple selections.
         */
        public void selectAllAccessibleSelection() {
<span class="nc" id="L4509">            TreeModel model = JTree.this.getModel();</span>
<span class="nc bnc" id="L4510" title="All 2 branches missed.">            if (model != null) {</span>
<span class="nc" id="L4511">                Object[] objPath = {model.getRoot()};</span>
<span class="nc" id="L4512">                TreePath path = new TreePath(objPath);</span>
<span class="nc" id="L4513">                JTree.this.addSelectionPath(path);</span>
            }
<span class="nc" id="L4515">        }</span>

        /**
         * This class implements accessibility support for the
         * &lt;code&gt;JTree&lt;/code&gt; child.  It provides an implementation of the
         * Java Accessibility API appropriate to tree nodes.
         */
        protected class AccessibleJTreeNode extends AccessibleContext
            implements Accessible, AccessibleComponent, AccessibleSelection,
            AccessibleAction {

<span class="nc" id="L4526">            private JTree tree = null;</span>
<span class="nc" id="L4527">            private TreeModel treeModel = null;</span>
<span class="nc" id="L4528">            private Object obj = null;</span>
<span class="nc" id="L4529">            private TreePath path = null;</span>
<span class="nc" id="L4530">            private Accessible accessibleParent = null;</span>
<span class="nc" id="L4531">            private int index = 0;</span>
<span class="nc" id="L4532">            private boolean isLeaf = false;</span>

            /**
             *  Constructs an AccessibleJTreeNode
             * @since 1.4
             */
<span class="nc" id="L4538">            public AccessibleJTreeNode(JTree t, TreePath p, Accessible ap) {</span>
<span class="nc" id="L4539">                tree = t;</span>
<span class="nc" id="L4540">                path = p;</span>
<span class="nc" id="L4541">                accessibleParent = ap;</span>
<span class="nc" id="L4542">                treeModel = t.getModel();</span>
<span class="nc" id="L4543">                obj = p.getLastPathComponent();</span>
<span class="nc bnc" id="L4544" title="All 2 branches missed.">                if (treeModel != null) {</span>
<span class="nc" id="L4545">                    isLeaf = treeModel.isLeaf(obj);</span>
                }
<span class="nc" id="L4547">            }</span>

            private TreePath getChildTreePath(int i) {
                // Tree nodes can't be so complex that they have
                // two sets of children -&gt; we're ignoring that case
<span class="nc bnc" id="L4552" title="All 4 branches missed.">                if (i &lt; 0 || i &gt;= getAccessibleChildrenCount()) {</span>
<span class="nc" id="L4553">                    return null;</span>
                } else {
<span class="nc" id="L4555">                    Object childObj = treeModel.getChild(obj, i);</span>
<span class="nc" id="L4556">                    Object[] objPath = path.getPath();</span>
<span class="nc" id="L4557">                    Object[] objChildPath = new Object[objPath.length+1];</span>
<span class="nc" id="L4558">                    java.lang.System.arraycopy(objPath, 0, objChildPath, 0, objPath.length);</span>
<span class="nc" id="L4559">                    objChildPath[objChildPath.length-1] = childObj;</span>
<span class="nc" id="L4560">                    return new TreePath(objChildPath);</span>
                }
            }

            /**
             * Get the AccessibleContext associated with this tree node.
             * In the implementation of the Java Accessibility API for
             * this class, return this object, which is its own
             * AccessibleContext.
             *
             * @return this object
             */
            public AccessibleContext getAccessibleContext() {
<span class="nc" id="L4573">                return this;</span>
            }

            private AccessibleContext getCurrentAccessibleContext() {
<span class="nc" id="L4577">                Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L4578" title="All 2 branches missed.">                if (c instanceof Accessible) {</span>
<span class="nc" id="L4579">                    return c.getAccessibleContext();</span>
                } else {
<span class="nc" id="L4581">                    return null;</span>
                }
            }

            private Component getCurrentComponent() {
                // is the object visible?
                // if so, get row, selected, focus &amp; leaf state,
                // and then get the renderer component and return it
<span class="nc bnc" id="L4589" title="All 2 branches missed.">                if (tree.isVisible(path)) {</span>
<span class="nc" id="L4590">                    TreeCellRenderer r = tree.getCellRenderer();</span>
<span class="nc bnc" id="L4591" title="All 2 branches missed.">                    if (r == null) {</span>
<span class="nc" id="L4592">                        return null;</span>
                    }
<span class="nc" id="L4594">                    TreeUI ui = tree.getUI();</span>
<span class="nc bnc" id="L4595" title="All 2 branches missed.">                    if (ui != null) {</span>
<span class="nc" id="L4596">                        int row = ui.getRowForPath(JTree.this, path);</span>
<span class="nc" id="L4597">                        boolean selected = tree.isPathSelected(path);</span>
<span class="nc" id="L4598">                        boolean expanded = tree.isExpanded(path);</span>
<span class="nc" id="L4599">                        boolean hasFocus = false; // how to tell?? -PK</span>
<span class="nc" id="L4600">                        return r.getTreeCellRendererComponent(tree, obj,</span>
                            selected, expanded, isLeaf, row, hasFocus);
                    }
                }
<span class="nc" id="L4604">                return null;</span>
            }

        // AccessibleContext methods

             /**
              * Get the accessible name of this object.
              *
              * @return the localized name of the object; null if this
              * object does not have a name
              */
             public String getAccessibleName() {
<span class="nc" id="L4616">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4617" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L4618">                    String name = ac.getAccessibleName();</span>
<span class="nc bnc" id="L4619" title="All 4 branches missed.">                    if ((name != null) &amp;&amp; (name != &quot;&quot;)) {</span>
<span class="nc" id="L4620">                        return ac.getAccessibleName();</span>
                    } else {
<span class="nc" id="L4622">                        return null;</span>
                    }
                }
<span class="nc bnc" id="L4625" title="All 4 branches missed.">                if ((accessibleName != null) &amp;&amp; (accessibleName != &quot;&quot;)) {</span>
<span class="nc" id="L4626">                    return accessibleName;</span>
                } else {
                    // fall back to the client property
<span class="nc" id="L4629">                    return (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);</span>
                }
            }

            /**
             * Set the localized accessible name of this object.
             *
             * @param s the new localized name of the object.
             */
            public void setAccessibleName(String s) {
<span class="nc" id="L4639">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4640" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L4641">                    ac.setAccessibleName(s);</span>
                } else {
<span class="nc" id="L4643">                    super.setAccessibleName(s);</span>
                }
<span class="nc" id="L4645">            }</span>

            //
            // *** should check tooltip text for desc. (needs MouseEvent)
            //
            /**
             * Get the accessible description of this object.
             *
             * @return the localized description of the object; null if
             * this object does not have a description
             */
            public String getAccessibleDescription() {
<span class="nc" id="L4657">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4658" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L4659">                    return ac.getAccessibleDescription();</span>
                } else {
<span class="nc" id="L4661">                    return super.getAccessibleDescription();</span>
                }
            }

            /**
             * Set the accessible description of this object.
             *
             * @param s the new localized description of the object
             */
            public void setAccessibleDescription(String s) {
<span class="nc" id="L4671">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4672" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L4673">                    ac.setAccessibleDescription(s);</span>
                } else {
<span class="nc" id="L4675">                    super.setAccessibleDescription(s);</span>
                }
<span class="nc" id="L4677">            }</span>

            /**
             * Get the role of this object.
             *
             * @return an instance of AccessibleRole describing the role of the object
             * @see AccessibleRole
             */
            public AccessibleRole getAccessibleRole() {
<span class="nc" id="L4686">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4687" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L4688">                    return ac.getAccessibleRole();</span>
                } else {
<span class="nc" id="L4690">                    return AccessibleRole.UNKNOWN;</span>
                }
            }

            /**
             * Get the state set of this object.
             *
             * @return an instance of AccessibleStateSet containing the
             * current state set of the object
             * @see AccessibleState
             */
            public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L4702">                AccessibleContext ac = getCurrentAccessibleContext();</span>
                AccessibleStateSet states;
<span class="nc bnc" id="L4704" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L4705">                    states = ac.getAccessibleStateSet();</span>
                } else {
<span class="nc" id="L4707">                    states = new AccessibleStateSet();</span>
                }
                // need to test here, 'cause the underlying component
                // is a cellRenderer, which is never showing...
<span class="nc bnc" id="L4711" title="All 2 branches missed.">                if (isShowing()) {</span>
<span class="nc" id="L4712">                    states.add(AccessibleState.SHOWING);</span>
<span class="nc bnc" id="L4713" title="All 2 branches missed.">                } else if (states.contains(AccessibleState.SHOWING)) {</span>
<span class="nc" id="L4714">                    states.remove(AccessibleState.SHOWING);</span>
                }
<span class="nc bnc" id="L4716" title="All 2 branches missed.">                if (isVisible()) {</span>
<span class="nc" id="L4717">                    states.add(AccessibleState.VISIBLE);</span>
<span class="nc bnc" id="L4718" title="All 2 branches missed.">                } else if (states.contains(AccessibleState.VISIBLE)) {</span>
<span class="nc" id="L4719">                    states.remove(AccessibleState.VISIBLE);</span>
                }
<span class="nc bnc" id="L4721" title="All 2 branches missed.">                if (tree.isPathSelected(path)){</span>
<span class="nc" id="L4722">                    states.add(AccessibleState.SELECTED);</span>
                }
<span class="nc bnc" id="L4724" title="All 2 branches missed.">                if (path == getLeadSelectionPath()) {</span>
<span class="nc" id="L4725">                    states.add(AccessibleState.ACTIVE);</span>
                }
<span class="nc bnc" id="L4727" title="All 2 branches missed.">                if (!isLeaf) {</span>
<span class="nc" id="L4728">                    states.add(AccessibleState.EXPANDABLE);</span>
                }
<span class="nc bnc" id="L4730" title="All 2 branches missed.">                if (tree.isExpanded(path)) {</span>
<span class="nc" id="L4731">                    states.add(AccessibleState.EXPANDED);</span>
                } else {
<span class="nc" id="L4733">                    states.add(AccessibleState.COLLAPSED);</span>
                }
<span class="nc bnc" id="L4735" title="All 2 branches missed.">                if (tree.isEditable()) {</span>
<span class="nc" id="L4736">                    states.add(AccessibleState.EDITABLE);</span>
                }
<span class="nc" id="L4738">                return states;</span>
            }

            /**
             * Get the Accessible parent of this object.
             *
             * @return the Accessible parent of this object; null if this
             * object does not have an Accessible parent
             */
            public Accessible getAccessibleParent() {
                // someone wants to know, so we need to create our parent
                // if we don't have one (hey, we're a talented kid!)
<span class="nc bnc" id="L4750" title="All 2 branches missed.">                if (accessibleParent == null) {</span>
<span class="nc" id="L4751">                    Object[] objPath = path.getPath();</span>
<span class="nc bnc" id="L4752" title="All 2 branches missed.">                    if (objPath.length &gt; 1) {</span>
<span class="nc" id="L4753">                        Object objParent = objPath[objPath.length-2];</span>
<span class="nc bnc" id="L4754" title="All 2 branches missed.">                        if (treeModel != null) {</span>
<span class="nc" id="L4755">                            index = treeModel.getIndexOfChild(objParent, obj);</span>
                        }
<span class="nc" id="L4757">                        Object[] objParentPath = new Object[objPath.length-1];</span>
<span class="nc" id="L4758">                        java.lang.System.arraycopy(objPath, 0, objParentPath,</span>
                                                   0, objPath.length-1);
<span class="nc" id="L4760">                        TreePath parentPath = new TreePath(objParentPath);</span>
<span class="nc" id="L4761">                        accessibleParent = new AccessibleJTreeNode(tree,</span>
                                                                   parentPath,
                                                                   null);
<span class="nc" id="L4764">                        this.setAccessibleParent(accessibleParent);</span>
<span class="nc bnc" id="L4765" title="All 2 branches missed.">                    } else if (treeModel != null) {</span>
<span class="nc" id="L4766">                        accessibleParent = tree; // we're the top!</span>
<span class="nc" id="L4767">                        index = 0; // we're an only child!</span>
<span class="nc" id="L4768">                        this.setAccessibleParent(accessibleParent);</span>
                    }
                }
<span class="nc" id="L4771">                return accessibleParent;</span>
            }

            /**
             * Get the index of this object in its accessible parent.
             *
             * @return the index of this object in its parent; -1 if this
             * object does not have an accessible parent.
             * @see #getAccessibleParent
             */
            public int getAccessibleIndexInParent() {
                // index is invalid 'till we have an accessibleParent...
<span class="nc bnc" id="L4783" title="All 2 branches missed.">                if (accessibleParent == null) {</span>
<span class="nc" id="L4784">                    getAccessibleParent();</span>
                }
<span class="nc" id="L4786">                Object[] objPath = path.getPath();</span>
<span class="nc bnc" id="L4787" title="All 2 branches missed.">                if (objPath.length &gt; 1) {</span>
<span class="nc" id="L4788">                    Object objParent = objPath[objPath.length-2];</span>
<span class="nc bnc" id="L4789" title="All 2 branches missed.">                    if (treeModel != null) {</span>
<span class="nc" id="L4790">                        index = treeModel.getIndexOfChild(objParent, obj);</span>
                    }
                }
<span class="nc" id="L4793">                return index;</span>
            }

            /**
             * Returns the number of accessible children in the object.
             *
             * @return the number of accessible children in the object.
             */
            public int getAccessibleChildrenCount() {
                // Tree nodes can't be so complex that they have
                // two sets of children -&gt; we're ignoring that case
<span class="nc" id="L4804">                return treeModel.getChildCount(obj);</span>
            }

            /**
             * Return the specified Accessible child of the object.
             *
             * @param i zero-based index of child
             * @return the Accessible child of the object
             */
            public Accessible getAccessibleChild(int i) {
                // Tree nodes can't be so complex that they have
                // two sets of children -&gt; we're ignoring that case
<span class="nc bnc" id="L4816" title="All 4 branches missed.">                if (i &lt; 0 || i &gt;= getAccessibleChildrenCount()) {</span>
<span class="nc" id="L4817">                    return null;</span>
                } else {
<span class="nc" id="L4819">                    Object childObj = treeModel.getChild(obj, i);</span>
<span class="nc" id="L4820">                    Object[] objPath = path.getPath();</span>
<span class="nc" id="L4821">                    Object[] objChildPath = new Object[objPath.length+1];</span>
<span class="nc" id="L4822">                    java.lang.System.arraycopy(objPath, 0, objChildPath, 0, objPath.length);</span>
<span class="nc" id="L4823">                    objChildPath[objChildPath.length-1] = childObj;</span>
<span class="nc" id="L4824">                    TreePath childPath = new TreePath(objChildPath);</span>
<span class="nc" id="L4825">                    return new AccessibleJTreeNode(JTree.this, childPath, this);</span>
                }
            }

            /**
             * Gets the locale of the component. If the component does not have
             * a locale, then the locale of its parent is returned.
             *
             * @return This component's locale. If this component does not have
             * a locale, the locale of its parent is returned.
             * @exception IllegalComponentStateException
             * If the Component does not have its own locale and has not yet
             * been added to a containment hierarchy such that the locale can be
             * determined from the containing parent.
             * @see #setLocale
             */
            public Locale getLocale() {
<span class="nc" id="L4842">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4843" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L4844">                    return ac.getLocale();</span>
                } else {
<span class="nc" id="L4846">                    return tree.getLocale();</span>
                }
            }

            /**
             * Add a PropertyChangeListener to the listener list.
             * The listener is registered for all properties.
             *
             * @param l  The PropertyChangeListener to be added
             */
            public void addPropertyChangeListener(PropertyChangeListener l) {
<span class="nc" id="L4857">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4858" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L4859">                    ac.addPropertyChangeListener(l);</span>
                } else {
<span class="nc" id="L4861">                    super.addPropertyChangeListener(l);</span>
                }
<span class="nc" id="L4863">            }</span>

            /**
             * Remove a PropertyChangeListener from the listener list.
             * This removes a PropertyChangeListener that was registered
             * for all properties.
             *
             * @param l  The PropertyChangeListener to be removed
             */
            public void removePropertyChangeListener(PropertyChangeListener l) {
<span class="nc" id="L4873">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4874" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L4875">                    ac.removePropertyChangeListener(l);</span>
                } else {
<span class="nc" id="L4877">                    super.removePropertyChangeListener(l);</span>
                }
<span class="nc" id="L4879">            }</span>

            /**
             * Get the AccessibleAction associated with this object.  In the
             * implementation of the Java Accessibility API for this class,
             * return this object, which is responsible for implementing the
             * AccessibleAction interface on behalf of itself.
             *
             * @return this object
             */
            public AccessibleAction getAccessibleAction() {
<span class="nc" id="L4890">                return this;</span>
            }

            /**
             * Get the AccessibleComponent associated with this object.  In the
             * implementation of the Java Accessibility API for this class,
             * return this object, which is responsible for implementing the
             * AccessibleComponent interface on behalf of itself.
             *
             * @return this object
             */
            public AccessibleComponent getAccessibleComponent() {
<span class="nc" id="L4902">                return this; // to override getBounds()</span>
            }

            /**
             * Get the AccessibleSelection associated with this object if one
             * exists.  Otherwise return null.
             *
             * @return the AccessibleSelection, or null
             */
            public AccessibleSelection getAccessibleSelection() {
<span class="nc" id="L4912">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4913" title="All 4 branches missed.">                if (ac != null &amp;&amp; isLeaf) {</span>
<span class="nc" id="L4914">                    return getCurrentAccessibleContext().getAccessibleSelection();</span>
                } else {
<span class="nc" id="L4916">                    return this;</span>
                }
            }

            /**
             * Get the AccessibleText associated with this object if one
             * exists.  Otherwise return null.
             *
             * @return the AccessibleText, or null
             */
            public AccessibleText getAccessibleText() {
<span class="nc" id="L4927">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4928" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L4929">                    return getCurrentAccessibleContext().getAccessibleText();</span>
                } else {
<span class="nc" id="L4931">                    return null;</span>
                }
            }

            /**
             * Get the AccessibleValue associated with this object if one
             * exists.  Otherwise return null.
             *
             * @return the AccessibleValue, or null
             */
            public AccessibleValue getAccessibleValue() {
<span class="nc" id="L4942">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4943" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L4944">                    return getCurrentAccessibleContext().getAccessibleValue();</span>
                } else {
<span class="nc" id="L4946">                    return null;</span>
                }
            }


        // AccessibleComponent methods

            /**
             * Get the background color of this object.
             *
             * @return the background color, if supported, of the object;
             * otherwise, null
             */
            public Color getBackground() {
<span class="nc" id="L4960">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4961" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L4962">                    return ((AccessibleComponent) ac).getBackground();</span>
                } else {
<span class="nc" id="L4964">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L4965" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L4966">                        return c.getBackground();</span>
                    } else {
<span class="nc" id="L4968">                        return null;</span>
                    }
                }
            }

            /**
             * Set the background color of this object.
             *
             * @param c the new Color for the background
             */
            public void setBackground(Color c) {
<span class="nc" id="L4979">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4980" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L4981">                    ((AccessibleComponent) ac).setBackground(c);</span>
                } else {
<span class="nc" id="L4983">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L4984" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L4985">                        cp.setBackground(c);</span>
                    }
                }
<span class="nc" id="L4988">            }</span>


            /**
             * Get the foreground color of this object.
             *
             * @return the foreground color, if supported, of the object;
             * otherwise, null
             */
            public Color getForeground() {
<span class="nc" id="L4998">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L4999" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5000">                    return ((AccessibleComponent) ac).getForeground();</span>
                } else {
<span class="nc" id="L5002">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5003" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5004">                        return c.getForeground();</span>
                    } else {
<span class="nc" id="L5006">                        return null;</span>
                    }
                }
            }

            public void setForeground(Color c) {
<span class="nc" id="L5012">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5013" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5014">                    ((AccessibleComponent) ac).setForeground(c);</span>
                } else {
<span class="nc" id="L5016">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L5017" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L5018">                        cp.setForeground(c);</span>
                    }
                }
<span class="nc" id="L5021">            }</span>

            public Cursor getCursor() {
<span class="nc" id="L5024">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5025" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5026">                    return ((AccessibleComponent) ac).getCursor();</span>
                } else {
<span class="nc" id="L5028">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5029" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5030">                        return c.getCursor();</span>
                    } else {
<span class="nc" id="L5032">                        Accessible ap = getAccessibleParent();</span>
<span class="nc bnc" id="L5033" title="All 2 branches missed.">                        if (ap instanceof AccessibleComponent) {</span>
<span class="nc" id="L5034">                            return ((AccessibleComponent) ap).getCursor();</span>
                        } else {
<span class="nc" id="L5036">                            return null;</span>
                        }
                    }
                }
            }

            public void setCursor(Cursor c) {
<span class="nc" id="L5043">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5044" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5045">                    ((AccessibleComponent) ac).setCursor(c);</span>
                } else {
<span class="nc" id="L5047">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L5048" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L5049">                        cp.setCursor(c);</span>
                    }
                }
<span class="nc" id="L5052">            }</span>

            public Font getFont() {
<span class="nc" id="L5055">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5056" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5057">                    return ((AccessibleComponent) ac).getFont();</span>
                } else {
<span class="nc" id="L5059">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5060" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5061">                        return c.getFont();</span>
                    } else {
<span class="nc" id="L5063">                        return null;</span>
                    }
                }
            }

            public void setFont(Font f) {
<span class="nc" id="L5069">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5070" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5071">                    ((AccessibleComponent) ac).setFont(f);</span>
                } else {
<span class="nc" id="L5073">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5074" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5075">                        c.setFont(f);</span>
                    }
                }
<span class="nc" id="L5078">            }</span>

            public FontMetrics getFontMetrics(Font f) {
<span class="nc" id="L5081">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5082" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5083">                    return ((AccessibleComponent) ac).getFontMetrics(f);</span>
                } else {
<span class="nc" id="L5085">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5086" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5087">                        return c.getFontMetrics(f);</span>
                    } else {
<span class="nc" id="L5089">                        return null;</span>
                    }
                }
            }

            public boolean isEnabled() {
<span class="nc" id="L5095">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5096" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5097">                    return ((AccessibleComponent) ac).isEnabled();</span>
                } else {
<span class="nc" id="L5099">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5100" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5101">                        return c.isEnabled();</span>
                    } else {
<span class="nc" id="L5103">                        return false;</span>
                    }
                }
            }

            public void setEnabled(boolean b) {
<span class="nc" id="L5109">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5110" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5111">                    ((AccessibleComponent) ac).setEnabled(b);</span>
                } else {
<span class="nc" id="L5113">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5114" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5115">                        c.setEnabled(b);</span>
                    }
                }
<span class="nc" id="L5118">            }</span>

            public boolean isVisible() {
<span class="nc" id="L5121">                Rectangle pathBounds = tree.getPathBounds(path);</span>
<span class="nc" id="L5122">                Rectangle parentBounds = tree.getVisibleRect();</span>
<span class="nc bnc" id="L5123" title="All 4 branches missed.">                return pathBounds != null &amp;&amp; parentBounds != null &amp;&amp;</span>
<span class="nc bnc" id="L5124" title="All 2 branches missed.">                        parentBounds.intersects(pathBounds);</span>
            }

            public void setVisible(boolean b) {
<span class="nc" id="L5128">            }</span>

            public boolean isShowing() {
<span class="nc bnc" id="L5131" title="All 4 branches missed.">                return (tree.isShowing() &amp;&amp; isVisible());</span>
            }

            public boolean contains(Point p) {
<span class="nc" id="L5135">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5136" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5137">                    Rectangle r = ((AccessibleComponent) ac).getBounds();</span>
<span class="nc" id="L5138">                    return r.contains(p);</span>
                } else {
<span class="nc" id="L5140">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5141" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5142">                        Rectangle r = c.getBounds();</span>
<span class="nc" id="L5143">                        return r.contains(p);</span>
                    } else {
<span class="nc" id="L5145">                        return getBounds().contains(p);</span>
                    }
                }
            }

            public Point getLocationOnScreen() {
<span class="nc bnc" id="L5151" title="All 2 branches missed.">                if (tree != null) {</span>
<span class="nc" id="L5152">                    Point treeLocation = tree.getLocationOnScreen();</span>
<span class="nc" id="L5153">                    Rectangle pathBounds = tree.getPathBounds(path);</span>
<span class="nc bnc" id="L5154" title="All 4 branches missed.">                    if (treeLocation != null &amp;&amp; pathBounds != null) {</span>
<span class="nc" id="L5155">                        Point nodeLocation = new Point(pathBounds.x,</span>
                                                       pathBounds.y);
<span class="nc" id="L5157">                        nodeLocation.translate(treeLocation.x, treeLocation.y);</span>
<span class="nc" id="L5158">                        return nodeLocation;</span>
                    } else {
<span class="nc" id="L5160">                        return null;</span>
                    }
                } else {
<span class="nc" id="L5163">                    return null;</span>
                }
            }

            protected Point getLocationInJTree() {
<span class="nc" id="L5168">                Rectangle r = tree.getPathBounds(path);</span>
<span class="nc bnc" id="L5169" title="All 2 branches missed.">                if (r != null) {</span>
<span class="nc" id="L5170">                    return r.getLocation();</span>
                } else {
<span class="nc" id="L5172">                    return null;</span>
                }
            }

            public Point getLocation() {
<span class="nc" id="L5177">                Rectangle r = getBounds();</span>
<span class="nc bnc" id="L5178" title="All 2 branches missed.">                if (r != null) {</span>
<span class="nc" id="L5179">                    return r.getLocation();</span>
                } else {
<span class="nc" id="L5181">                    return null;</span>
                }
            }

            public void setLocation(Point p) {
<span class="nc" id="L5186">            }</span>

            public Rectangle getBounds() {
<span class="nc" id="L5189">                Rectangle r = tree.getPathBounds(path);</span>
<span class="nc" id="L5190">                Accessible parent = getAccessibleParent();</span>
<span class="nc bnc" id="L5191" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc bnc" id="L5192" title="All 2 branches missed.">                    if (parent instanceof AccessibleJTreeNode) {</span>
<span class="nc" id="L5193">                        Point parentLoc = ((AccessibleJTreeNode) parent).getLocationInJTree();</span>
<span class="nc bnc" id="L5194" title="All 4 branches missed.">                        if (parentLoc != null &amp;&amp; r != null) {</span>
<span class="nc" id="L5195">                            r.translate(-parentLoc.x, -parentLoc.y);</span>
                        } else {
<span class="nc" id="L5197">                            return null;        // not visible!</span>
                        }
                    }
                }
<span class="nc" id="L5201">                return r;</span>
            }

            public void setBounds(Rectangle r) {
<span class="nc" id="L5205">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5206" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5207">                    ((AccessibleComponent) ac).setBounds(r);</span>
                } else {
<span class="nc" id="L5209">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5210" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5211">                        c.setBounds(r);</span>
                    }
                }
<span class="nc" id="L5214">            }</span>

            public Dimension getSize() {
<span class="nc" id="L5217">                return getBounds().getSize();</span>
            }

            public void setSize (Dimension d) {
<span class="nc" id="L5221">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5222" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5223">                    ((AccessibleComponent) ac).setSize(d);</span>
                } else {
<span class="nc" id="L5225">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5226" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5227">                        c.setSize(d);</span>
                    }
                }
<span class="nc" id="L5230">            }</span>

            /**
             * Returns the &lt;code&gt;Accessible&lt;/code&gt; child, if one exists,
             * contained at the local coordinate &lt;code&gt;Point&lt;/code&gt;.
             * Otherwise returns &lt;code&gt;null&lt;/code&gt;.
             *
             * @param p point in local coordinates of this
             *    &lt;code&gt;Accessible&lt;/code&gt;
             * @return the &lt;code&gt;Accessible&lt;/code&gt;, if it exists,
             *    at the specified location; else &lt;code&gt;null&lt;/code&gt;
             */
            public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L5243">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5244" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5245">                    return ((AccessibleComponent) ac).getAccessibleAt(p);</span>
                } else {
<span class="nc" id="L5247">                    return null;</span>
                }
            }

            @SuppressWarnings(&quot;deprecation&quot;)
            public boolean isFocusTraversable() {
<span class="nc" id="L5253">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5254" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5255">                    return ((AccessibleComponent) ac).isFocusTraversable();</span>
                } else {
<span class="nc" id="L5257">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5258" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5259">                        return c.isFocusTraversable();</span>
                    } else {
<span class="nc" id="L5261">                        return false;</span>
                    }
                }
            }

            public void requestFocus() {
<span class="nc" id="L5267">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5268" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5269">                    ((AccessibleComponent) ac).requestFocus();</span>
                } else {
<span class="nc" id="L5271">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5272" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5273">                        c.requestFocus();</span>
                    }
                }
<span class="nc" id="L5276">            }</span>

            public void addFocusListener(FocusListener l) {
<span class="nc" id="L5279">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5280" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5281">                    ((AccessibleComponent) ac).addFocusListener(l);</span>
                } else {
<span class="nc" id="L5283">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5284" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5285">                        c.addFocusListener(l);</span>
                    }
                }
<span class="nc" id="L5288">            }</span>

            public void removeFocusListener(FocusListener l) {
<span class="nc" id="L5291">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5292" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L5293">                    ((AccessibleComponent) ac).removeFocusListener(l);</span>
                } else {
<span class="nc" id="L5295">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L5296" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L5297">                        c.removeFocusListener(l);</span>
                    }
                }
<span class="nc" id="L5300">            }</span>

        // AccessibleSelection methods

            /**
             * Returns the number of items currently selected.
             * If no items are selected, the return value will be 0.
             *
             * @return the number of items currently selected.
             */
            public int getAccessibleSelectionCount() {
<span class="nc" id="L5311">                int count = 0;</span>
<span class="nc" id="L5312">                int childCount = getAccessibleChildrenCount();</span>
<span class="nc bnc" id="L5313" title="All 2 branches missed.">                for (int i = 0; i &lt; childCount; i++) {</span>
<span class="nc" id="L5314">                    TreePath childPath = getChildTreePath(i);</span>
<span class="nc bnc" id="L5315" title="All 2 branches missed.">                    if (tree.isPathSelected(childPath)) {</span>
<span class="nc" id="L5316">                       count++;</span>
                    }
                }
<span class="nc" id="L5319">                return count;</span>
            }

            /**
             * Returns an Accessible representing the specified selected item
             * in the object.  If there isn't a selection, or there are
             * fewer items selected than the integer passed in, the return
             * value will be null.
             *
             * @param i the zero-based index of selected items
             * @return an Accessible containing the selected item
             */
            public Accessible getAccessibleSelection(int i) {
<span class="nc" id="L5332">                int childCount = getAccessibleChildrenCount();</span>
<span class="nc bnc" id="L5333" title="All 4 branches missed.">                if (i &lt; 0 || i &gt;= childCount) {</span>
<span class="nc" id="L5334">                    return null;        // out of range</span>
                }
<span class="nc" id="L5336">                int count = 0;</span>
<span class="nc bnc" id="L5337" title="All 4 branches missed.">                for (int j = 0; j &lt; childCount &amp;&amp; i &gt;= count; j++) {</span>
<span class="nc" id="L5338">                    TreePath childPath = getChildTreePath(j);</span>
<span class="nc bnc" id="L5339" title="All 2 branches missed.">                    if (tree.isPathSelected(childPath)) {</span>
<span class="nc bnc" id="L5340" title="All 2 branches missed.">                        if (count == i) {</span>
<span class="nc" id="L5341">                            return new AccessibleJTreeNode(tree, childPath, this);</span>
                        } else {
<span class="nc" id="L5343">                            count++;</span>
                        }
                    }
                }
<span class="nc" id="L5347">                return null;</span>
            }

            /**
             * Returns true if the current child of this object is selected.
             *
             * @param i the zero-based index of the child in this Accessible
             * object.
             * @see AccessibleContext#getAccessibleChild
             */
            public boolean isAccessibleChildSelected(int i) {
<span class="nc" id="L5358">                int childCount = getAccessibleChildrenCount();</span>
<span class="nc bnc" id="L5359" title="All 4 branches missed.">                if (i &lt; 0 || i &gt;= childCount) {</span>
<span class="nc" id="L5360">                    return false;       // out of range</span>
                } else {
<span class="nc" id="L5362">                    TreePath childPath = getChildTreePath(i);</span>
<span class="nc" id="L5363">                    return tree.isPathSelected(childPath);</span>
                }
            }

            /**
             * Adds the specified selected item in the object to the object's
             * selection.  If the object supports multiple selections,
             * the specified item is added to any existing selection, otherwise
             * it replaces any existing selection in the object.  If the
             * specified item is already selected, this method has no effect.
             *
             * @param i the zero-based index of selectable items
             */
            public void addAccessibleSelection(int i) {
<span class="nc" id="L5377">               TreeModel model = JTree.this.getModel();</span>
<span class="nc bnc" id="L5378" title="All 2 branches missed.">               if (model != null) {</span>
<span class="nc bnc" id="L5379" title="All 4 branches missed.">                   if (i &gt;= 0 &amp;&amp; i &lt; getAccessibleChildrenCount()) {</span>
<span class="nc" id="L5380">                       TreePath path = getChildTreePath(i);</span>
<span class="nc" id="L5381">                       JTree.this.addSelectionPath(path);</span>
                    }
                }
<span class="nc" id="L5384">            }</span>

            /**
             * Removes the specified selected item in the object from the
             * object's
             * selection.  If the specified item isn't currently selected, this
             * method has no effect.
             *
             * @param i the zero-based index of selectable items
             */
            public void removeAccessibleSelection(int i) {
<span class="nc" id="L5395">               TreeModel model = JTree.this.getModel();</span>
<span class="nc bnc" id="L5396" title="All 2 branches missed.">               if (model != null) {</span>
<span class="nc bnc" id="L5397" title="All 4 branches missed.">                   if (i &gt;= 0 &amp;&amp; i &lt; getAccessibleChildrenCount()) {</span>
<span class="nc" id="L5398">                       TreePath path = getChildTreePath(i);</span>
<span class="nc" id="L5399">                       JTree.this.removeSelectionPath(path);</span>
                    }
                }
<span class="nc" id="L5402">            }</span>

            /**
             * Clears the selection in the object, so that nothing in the
             * object is selected.
             */
            public void clearAccessibleSelection() {
<span class="nc" id="L5409">                int childCount = getAccessibleChildrenCount();</span>
<span class="nc bnc" id="L5410" title="All 2 branches missed.">                for (int i = 0; i &lt; childCount; i++) {</span>
<span class="nc" id="L5411">                    removeAccessibleSelection(i);</span>
                }
<span class="nc" id="L5413">            }</span>

            /**
             * Causes every selected item in the object to be selected
             * if the object supports multiple selections.
             */
            public void selectAllAccessibleSelection() {
<span class="nc" id="L5420">               TreeModel model = JTree.this.getModel();</span>
<span class="nc bnc" id="L5421" title="All 2 branches missed.">               if (model != null) {</span>
<span class="nc" id="L5422">                   int childCount = getAccessibleChildrenCount();</span>
                   TreePath path;
<span class="nc bnc" id="L5424" title="All 2 branches missed.">                   for (int i = 0; i &lt; childCount; i++) {</span>
<span class="nc" id="L5425">                       path = getChildTreePath(i);</span>
<span class="nc" id="L5426">                       JTree.this.addSelectionPath(path);</span>
                   }
                }
<span class="nc" id="L5429">            }</span>

        // AccessibleAction methods

            /**
             * Returns the number of accessible actions available in this
             * tree node.  If this node is not a leaf, there is at least
             * one action (toggle expand), in addition to any available
             * on the object behind the TreeCellRenderer.
             *
             * @return the number of Actions in this object
             */
            public int getAccessibleActionCount() {
<span class="nc" id="L5442">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5443" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L5444">                    AccessibleAction aa = ac.getAccessibleAction();</span>
<span class="nc bnc" id="L5445" title="All 2 branches missed.">                    if (aa != null) {</span>
<span class="nc bnc" id="L5446" title="All 2 branches missed.">                        return (aa.getAccessibleActionCount() + (isLeaf ? 0 : 1));</span>
                    }
                }
<span class="nc bnc" id="L5449" title="All 2 branches missed.">                return isLeaf ? 0 : 1;</span>
            }

            /**
             * Return a description of the specified action of the tree node.
             * If this node is not a leaf, there is at least one action
             * description (toggle expand), in addition to any available
             * on the object behind the TreeCellRenderer.
             *
             * @param i zero-based index of the actions
             * @return a description of the action
             */
            public String getAccessibleActionDescription(int i) {
<span class="nc bnc" id="L5462" title="All 4 branches missed.">                if (i &lt; 0 || i &gt;= getAccessibleActionCount()) {</span>
<span class="nc" id="L5463">                    return null;</span>
                }
<span class="nc" id="L5465">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5466" title="All 2 branches missed.">                if (i == 0) {</span>
                    // TIGER - 4766636
<span class="nc" id="L5468">                    return AccessibleAction.TOGGLE_EXPAND;</span>
<span class="nc bnc" id="L5469" title="All 2 branches missed.">                } else if (ac != null) {</span>
<span class="nc" id="L5470">                    AccessibleAction aa = ac.getAccessibleAction();</span>
<span class="nc bnc" id="L5471" title="All 2 branches missed.">                    if (aa != null) {</span>
<span class="nc" id="L5472">                        return aa.getAccessibleActionDescription(i - 1);</span>
                    }
                }
<span class="nc" id="L5475">                return null;</span>
            }

            /**
             * Perform the specified Action on the tree node.  If this node
             * is not a leaf, there is at least one action which can be
             * done (toggle expand), in addition to any available on the
             * object behind the TreeCellRenderer.
             *
             * @param i zero-based index of actions
             * @return true if the the action was performed; else false.
             */
            public boolean doAccessibleAction(int i) {
<span class="nc bnc" id="L5488" title="All 4 branches missed.">                if (i &lt; 0 || i &gt;= getAccessibleActionCount()) {</span>
<span class="nc" id="L5489">                    return false;</span>
                }
<span class="nc" id="L5491">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L5492" title="All 2 branches missed.">                if (i == 0) {</span>
<span class="nc bnc" id="L5493" title="All 2 branches missed.">                    if (JTree.this.isExpanded(path)) {</span>
<span class="nc" id="L5494">                        JTree.this.collapsePath(path);</span>
                    } else {
<span class="nc" id="L5496">                        JTree.this.expandPath(path);</span>
                    }
<span class="nc" id="L5498">                    return true;</span>
<span class="nc bnc" id="L5499" title="All 2 branches missed.">                } else if (ac != null) {</span>
<span class="nc" id="L5500">                    AccessibleAction aa = ac.getAccessibleAction();</span>
<span class="nc bnc" id="L5501" title="All 2 branches missed.">                    if (aa != null) {</span>
<span class="nc" id="L5502">                        return aa.doAccessibleAction(i - 1);</span>
                    }
                }
<span class="nc" id="L5505">                return false;</span>
            }

        } // inner class AccessibleJTreeNode

    }  // inner class AccessibleJTree

} // End of class JTree
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>