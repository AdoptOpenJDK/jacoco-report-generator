<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JRootPane.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JRootPane.java</span></div><h1>JRootPane.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.applet.Applet;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.security.AccessController;
import javax.accessibility.*;
import javax.swing.plaf.RootPaneUI;
import java.util.Vector;
import java.io.Serializable;
import javax.swing.border.*;
import sun.awt.AWTAccessor;
import sun.security.action.GetBooleanAction;


/**
 * A lightweight container used behind the scenes by
 * &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;, &lt;code&gt;JWindow&lt;/code&gt;,
 * &lt;code&gt;JApplet&lt;/code&gt;, and &lt;code&gt;JInternalFrame&lt;/code&gt;.
 * For task-oriented information on functionality provided by root panes
 * see &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/rootpane.html&quot;&gt;How to Use Root Panes&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
 *
 * &lt;p&gt;
 * The following image shows the relationships between
 * the classes that use root panes.
 * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/JRootPane-1.gif&quot;
 * alt=&quot;The following text describes this graphic.&quot;
 * HEIGHT=484 WIDTH=629&gt;&lt;/p&gt;
 * The &amp;quot;heavyweight&amp;quot; components (those that delegate to a peer, or native
 * component on the host system) are shown with a darker, heavier box. The four
 * heavyweight JFC/Swing containers (&lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;,
 * &lt;code&gt;JWindow&lt;/code&gt;, and &lt;code&gt;JApplet&lt;/code&gt;) are
 * shown in relation to the AWT classes they extend.
 * These four components are the
 * only heavyweight containers in the Swing library. The lightweight container
 * &lt;code&gt;JInternalFrame&lt;/code&gt; is also shown.
 * All five of these JFC/Swing containers implement the
 * &lt;code&gt;RootPaneContainer&lt;/code&gt; interface,
 * and they all delegate their operations to a
 * &lt;code&gt;JRootPane&lt;/code&gt; (shown with a little &quot;handle&quot; on top).
 * &lt;blockquote&gt;
 * &lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;JComponent&lt;/code&gt; method &lt;code&gt;getRootPane&lt;/code&gt;
 * can be used to obtain the &lt;code&gt;JRootPane&lt;/code&gt; that contains
 * a given component.
 * &lt;/blockquote&gt;
 * &lt;table style=&quot;float:right&quot; border=&quot;0&quot; summary=&quot;layout&quot;&gt;
 * &lt;tr&gt;
 * &lt;td align=&quot;center&quot;&gt;
 * &lt;img src=&quot;doc-files/JRootPane-2.gif&quot;
 * alt=&quot;The following text describes this graphic.&quot; HEIGHT=386 WIDTH=349&gt;
 * &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 * The diagram at right shows the structure of a &lt;code&gt;JRootPane&lt;/code&gt;.
 * A &lt;code&gt;JRootpane&lt;/code&gt; is made up of a &lt;code&gt;glassPane&lt;/code&gt;,
 * an optional &lt;code&gt;menuBar&lt;/code&gt;, and a &lt;code&gt;contentPane&lt;/code&gt;.
 * (The &lt;code&gt;JLayeredPane&lt;/code&gt; manages the &lt;code&gt;menuBar&lt;/code&gt;
 * and the &lt;code&gt;contentPane&lt;/code&gt;.)
 * The &lt;code&gt;glassPane&lt;/code&gt; sits over the top of everything,
 * where it is in a position to intercept mouse movements.
 * Since the &lt;code&gt;glassPane&lt;/code&gt; (like the &lt;code&gt;contentPane&lt;/code&gt;)
 * can be an arbitrary component, it is also possible to set up the
 * &lt;code&gt;glassPane&lt;/code&gt; for drawing. Lines and images on the
 * &lt;code&gt;glassPane&lt;/code&gt; can then range
 * over the frames underneath without being limited by their boundaries.
 * &lt;p&gt;
 * Although the &lt;code&gt;menuBar&lt;/code&gt; component is optional,
 * the &lt;code&gt;layeredPane&lt;/code&gt;, &lt;code&gt;contentPane&lt;/code&gt;,
 * and &lt;code&gt;glassPane&lt;/code&gt; always exist.
 * Attempting to set them to &lt;code&gt;null&lt;/code&gt; generates an exception.
 * &lt;p&gt;
 * To add components to the &lt;code&gt;JRootPane&lt;/code&gt; (other than the
 * optional menu bar), you add the object to the &lt;code&gt;contentPane&lt;/code&gt;
 * of the &lt;code&gt;JRootPane&lt;/code&gt;, like this:
 * &lt;pre&gt;
 *       rootPane.getContentPane().add(child);
 * &lt;/pre&gt;
 * The same principle holds true for setting layout managers, removing
 * components, listing children, etc. All these methods are invoked on
 * the &lt;code&gt;contentPane&lt;/code&gt; instead of on the &lt;code&gt;JRootPane&lt;/code&gt;.
 * &lt;blockquote&gt;
 * &lt;b&gt;Note:&lt;/b&gt; The default layout manager for the &lt;code&gt;contentPane&lt;/code&gt; is
 *  a &lt;code&gt;BorderLayout&lt;/code&gt; manager. However, the &lt;code&gt;JRootPane&lt;/code&gt;
 *  uses a custom &lt;code&gt;LayoutManager&lt;/code&gt;.
 *  So, when you want to change the layout manager for the components you added
 *  to a &lt;code&gt;JRootPane&lt;/code&gt;, be sure to use code like this:
 * &lt;pre&gt;
 *    rootPane.getContentPane().setLayout(new BoxLayout());
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * If a &lt;code&gt;JMenuBar&lt;/code&gt; component is set on the &lt;code&gt;JRootPane&lt;/code&gt;,
 * it is positioned along the upper edge of the frame.
 * The &lt;code&gt;contentPane&lt;/code&gt; is adjusted in location and size to
 * fill the remaining area.
 * (The &lt;code&gt;JMenuBar&lt;/code&gt; and the &lt;code&gt;contentPane&lt;/code&gt; are added to the
 * &lt;code&gt;layeredPane&lt;/code&gt; component at the
 * &lt;code&gt;JLayeredPane.FRAME_CONTENT_LAYER&lt;/code&gt; layer.)
 * &lt;p&gt;
 * The &lt;code&gt;layeredPane&lt;/code&gt; is the parent of all children in the
 * &lt;code&gt;JRootPane&lt;/code&gt; -- both as the direct parent of the menu and
 * the grandparent of all components added to the &lt;code&gt;contentPane&lt;/code&gt;.
 * It is an instance of &lt;code&gt;JLayeredPane&lt;/code&gt;,
 * which provides the ability to add components at several layers.
 * This capability is very useful when working with menu popups,
 * dialog boxes, and dragging -- situations in which you need to place
 * a component on top of all other components in the pane.
 * &lt;p&gt;
 * The &lt;code&gt;glassPane&lt;/code&gt; sits on top of all other components in the
 * &lt;code&gt;JRootPane&lt;/code&gt;.
 * That provides a convenient place to draw above all other components,
 * and makes it possible to intercept mouse events,
 * which is useful both for dragging and for drawing.
 * Developers can use &lt;code&gt;setVisible&lt;/code&gt; on the &lt;code&gt;glassPane&lt;/code&gt;
 * to control when the &lt;code&gt;glassPane&lt;/code&gt; displays over the other children.
 * By default the &lt;code&gt;glassPane&lt;/code&gt; is not visible.
 * &lt;p&gt;
 * The custom &lt;code&gt;LayoutManager&lt;/code&gt; used by &lt;code&gt;JRootPane&lt;/code&gt;
 * ensures that:
 * &lt;OL&gt;
 * &lt;LI&gt;The &lt;code&gt;glassPane&lt;/code&gt; fills the entire viewable
 *     area of the &lt;code&gt;JRootPane&lt;/code&gt; (bounds - insets).
 * &lt;LI&gt;The &lt;code&gt;layeredPane&lt;/code&gt; fills the entire viewable area of the
 *     &lt;code&gt;JRootPane&lt;/code&gt;. (bounds - insets)
 * &lt;LI&gt;The &lt;code&gt;menuBar&lt;/code&gt; is positioned at the upper edge of the
 *     &lt;code&gt;layeredPane&lt;/code&gt;.
 * &lt;LI&gt;The &lt;code&gt;contentPane&lt;/code&gt; fills the entire viewable area,
 *     minus the &lt;code&gt;menuBar&lt;/code&gt;, if present.
 * &lt;/OL&gt;
 * Any other views in the &lt;code&gt;JRootPane&lt;/code&gt; view hierarchy are ignored.
 * &lt;p&gt;
 * If you replace the &lt;code&gt;LayoutManager&lt;/code&gt; of the &lt;code&gt;JRootPane&lt;/code&gt;,
 * you are responsible for managing all of these views.
 * So ordinarily you will want to be sure that you
 * change the layout manager for the &lt;code&gt;contentPane&lt;/code&gt; rather than
 * for the &lt;code&gt;JRootPane&lt;/code&gt; itself!
 * &lt;p&gt;
 * The painting architecture of Swing requires an opaque
 * &lt;code&gt;JComponent&lt;/code&gt;
 * to exist in the containment hierarchy above all other components. This is
 * typically provided by way of the content pane. If you replace the content
 * pane, it is recommended that you make the content pane opaque
 * by way of &lt;code&gt;setOpaque(true)&lt;/code&gt;. Additionally, if the content pane
 * overrides &lt;code&gt;paintComponent&lt;/code&gt;, it
 * will need to completely fill in the background in an opaque color in
 * &lt;code&gt;paintComponent&lt;/code&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @see JLayeredPane
 * @see JMenuBar
 * @see JWindow
 * @see JFrame
 * @see JDialog
 * @see JApplet
 * @see JInternalFrame
 * @see JComponent
 * @see BoxLayout
 *
 * @see &lt;a href=&quot;http://java.sun.com/products/jfc/tsc/articles/mixing/&quot;&gt;
 * Mixing Heavy and Light Components&lt;/a&gt;
 *
 * @author David Kloba
 */
/// PENDING(klobad) Who should be opaque in this component?
@SuppressWarnings(&quot;serial&quot;)
public class JRootPane extends JComponent implements Accessible {

    private static final String uiClassID = &quot;RootPaneUI&quot;;

    /**
     * Whether or not we should dump the stack when true double buffering
     * is disabled. Default is false.
     */
    private static final boolean LOG_DISABLE_TRUE_DOUBLE_BUFFERING;

    /**
     * Whether or not we should ignore requests to disable true double
     * buffering. Default is false.
     */
    private static final boolean IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should not provide any sort of
     * Window decorations.
     *
     * @since 1.4
     */
    public static final int NONE = 0;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Frame.
     *
     * @since 1.4
     */
    public static final int FRAME = 1;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog.
     *
     * @since 1.4
     */
    public static final int PLAIN_DIALOG = 2;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to display an informational message.
     *
     * @since 1.4
     */
    public static final int INFORMATION_DIALOG = 3;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to display an error message.
     *
     * @since 1.4
     */
    public static final int ERROR_DIALOG = 4;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to display a &lt;code&gt;JColorChooser&lt;/code&gt;.
     *
     * @since 1.4
     */
    public static final int COLOR_CHOOSER_DIALOG = 5;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to display a &lt;code&gt;JFileChooser&lt;/code&gt;.
     *
     * @since 1.4
     */
    public static final int FILE_CHOOSER_DIALOG = 6;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to present a question to the user.
     *
     * @since 1.4
     */
    public static final int QUESTION_DIALOG = 7;

    /**
     * Constant used for the windowDecorationStyle property. Indicates that
     * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
     * a Dialog used to display a warning message.
     *
     * @since 1.4
     */
    public static final int WARNING_DIALOG = 8;

    private int windowDecorationStyle;

    /** The menu bar. */
    protected JMenuBar menuBar;

    /** The content pane. */
    protected Container contentPane;

    /** The layered pane that manages the menu bar and content pane. */
    protected JLayeredPane layeredPane;

    /**
     * The glass pane that overlays the menu bar and content pane,
     *  so it can intercept mouse movements and such.
     */
    protected Component glassPane;
    /**
     * The button that gets activated when the pane has the focus and
     * a UI-specific action like pressing the &lt;b&gt;Enter&lt;/b&gt; key occurs.
     */
    protected JButton defaultButton;
    /**
     * As of Java 2 platform v1.3 this unusable field is no longer used.
     * To override the default button you should replace the &lt;code&gt;Action&lt;/code&gt;
     * in the &lt;code&gt;JRootPane&lt;/code&gt;'s &lt;code&gt;ActionMap&lt;/code&gt;. Please refer to
     * the key bindings specification for further details.
     *
     * @deprecated As of Java 2 platform v1.3.
     *  @see #defaultButton
     */
    @Deprecated
    protected DefaultAction defaultPressAction;
    /**
     * As of Java 2 platform v1.3 this unusable field is no longer used.
     * To override the default button you should replace the &lt;code&gt;Action&lt;/code&gt;
     * in the &lt;code&gt;JRootPane&lt;/code&gt;'s &lt;code&gt;ActionMap&lt;/code&gt;. Please refer to
     * the key bindings specification for further details.
     *
     * @deprecated As of Java 2 platform v1.3.
     *  @see #defaultButton
     */
    @Deprecated
    protected DefaultAction defaultReleaseAction;

    /**
     * Whether or not true double buffering should be used.  This is typically
     * true, but may be set to false in special situations.  For example,
     * heavy weight popups (backed by a window) set this to false.
     */
<span class="nc" id="L349">    boolean useTrueDoubleBuffering = true;</span>

    static {
<span class="nc" id="L352">        LOG_DISABLE_TRUE_DOUBLE_BUFFERING =</span>
<span class="nc" id="L353">            AccessController.doPrivileged(new GetBooleanAction(</span>
                                   &quot;swing.logDoubleBufferingDisable&quot;));
<span class="nc" id="L355">        IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING =</span>
<span class="nc" id="L356">            AccessController.doPrivileged(new GetBooleanAction(</span>
                                   &quot;swing.ignoreDoubleBufferingDisable&quot;));
<span class="nc" id="L358">    }</span>

    /**
     * Creates a &lt;code&gt;JRootPane&lt;/code&gt;, setting up its
     * &lt;code&gt;glassPane&lt;/code&gt;, &lt;code&gt;layeredPane&lt;/code&gt;,
     * and &lt;code&gt;contentPane&lt;/code&gt;.
     */
<span class="nc" id="L365">    public JRootPane() {</span>
<span class="nc" id="L366">        setGlassPane(createGlassPane());</span>
<span class="nc" id="L367">        setLayeredPane(createLayeredPane());</span>
<span class="nc" id="L368">        setContentPane(createContentPane());</span>
<span class="nc" id="L369">        setLayout(createRootLayout());</span>
<span class="nc" id="L370">        setDoubleBuffered(true);</span>
<span class="nc" id="L371">        updateUI();</span>
<span class="nc" id="L372">    }</span>

    /**
     * {@inheritDoc}
     * @since 1.6
     */
    public void setDoubleBuffered(boolean aFlag) {
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (isDoubleBuffered() != aFlag) {</span>
<span class="nc" id="L380">            super.setDoubleBuffered(aFlag);</span>
<span class="nc" id="L381">            RepaintManager.currentManager(this).doubleBufferingChanged(this);</span>
        }
<span class="nc" id="L383">    }</span>

    /**
     * Returns a constant identifying the type of Window decorations the
     * &lt;code&gt;JRootPane&lt;/code&gt; is providing.
     *
     * @return One of &lt;code&gt;NONE&lt;/code&gt;, &lt;code&gt;FRAME&lt;/code&gt;,
     *        &lt;code&gt;PLAIN_DIALOG&lt;/code&gt;, &lt;code&gt;INFORMATION_DIALOG&lt;/code&gt;,
     *        &lt;code&gt;ERROR_DIALOG&lt;/code&gt;, &lt;code&gt;COLOR_CHOOSER_DIALOG&lt;/code&gt;,
     *        &lt;code&gt;FILE_CHOOSER_DIALOG&lt;/code&gt;, &lt;code&gt;QUESTION_DIALOG&lt;/code&gt; or
     *        &lt;code&gt;WARNING_DIALOG&lt;/code&gt;.
     * @see #setWindowDecorationStyle
     * @since 1.4
     */
    public int getWindowDecorationStyle() {
<span class="nc" id="L398">        return windowDecorationStyle;</span>
    }

    /**
     * Sets the type of Window decorations (such as borders, widgets for
     * closing a Window, title ...) the &lt;code&gt;JRootPane&lt;/code&gt; should
     * provide. The default is to provide no Window decorations
     * (&lt;code&gt;NONE&lt;/code&gt;).
     * &lt;p&gt;
     * This is only a hint, and some look and feels may not support
     * this.
     * This is a bound property.
     *
     * @param windowDecorationStyle Constant identifying Window decorations
     *        to provide.
     * @see JDialog#setDefaultLookAndFeelDecorated
     * @see JFrame#setDefaultLookAndFeelDecorated
     * @see LookAndFeel#getSupportsWindowDecorations
     * @throws IllegalArgumentException if &lt;code&gt;style&lt;/code&gt; is
     *        not one of: &lt;code&gt;NONE&lt;/code&gt;, &lt;code&gt;FRAME&lt;/code&gt;,
     *        &lt;code&gt;PLAIN_DIALOG&lt;/code&gt;, &lt;code&gt;INFORMATION_DIALOG&lt;/code&gt;,
     *        &lt;code&gt;ERROR_DIALOG&lt;/code&gt;, &lt;code&gt;COLOR_CHOOSER_DIALOG&lt;/code&gt;,
     *        &lt;code&gt;FILE_CHOOSER_DIALOG&lt;/code&gt;, &lt;code&gt;QUESTION_DIALOG&lt;/code&gt;, or
     *        &lt;code&gt;WARNING_DIALOG&lt;/code&gt;.
     * @since 1.4
     * @beaninfo
     *        bound: true
     *         enum: NONE                   JRootPane.NONE
     *               FRAME                  JRootPane.FRAME
     *               PLAIN_DIALOG           JRootPane.PLAIN_DIALOG
     *               INFORMATION_DIALOG     JRootPane.INFORMATION_DIALOG
     *               ERROR_DIALOG           JRootPane.ERROR_DIALOG
     *               COLOR_CHOOSER_DIALOG   JRootPane.COLOR_CHOOSER_DIALOG
     *               FILE_CHOOSER_DIALOG    JRootPane.FILE_CHOOSER_DIALOG
     *               QUESTION_DIALOG        JRootPane.QUESTION_DIALOG
     *               WARNING_DIALOG         JRootPane.WARNING_DIALOG
     *       expert: true
     *    attribute: visualUpdate true
     *  description: Identifies the type of Window decorations to provide
     */
    public void setWindowDecorationStyle(int windowDecorationStyle) {
<span class="nc bnc" id="L439" title="All 4 branches missed.">        if (windowDecorationStyle &lt; 0 ||</span>
                  windowDecorationStyle &gt; WARNING_DIALOG) {
<span class="nc" id="L441">            throw new IllegalArgumentException(&quot;Invalid decoration style&quot;);</span>
        }
<span class="nc" id="L443">        int oldWindowDecorationStyle = getWindowDecorationStyle();</span>
<span class="nc" id="L444">        this.windowDecorationStyle = windowDecorationStyle;</span>
<span class="nc" id="L445">        firePropertyChange(&quot;windowDecorationStyle&quot;,</span>
                            oldWindowDecorationStyle,
                            windowDecorationStyle);
<span class="nc" id="L448">    }</span>

    /**
     * Returns the L&amp;amp;F object that renders this component.
     *
     * @return &lt;code&gt;LabelUI&lt;/code&gt; object
     * @since 1.3
     */
    public RootPaneUI getUI() {
<span class="nc" id="L457">        return (RootPaneUI)ui;</span>
    }

    /**
     * Sets the L&amp;amp;F object that renders this component.
     *
     * @param ui  the &lt;code&gt;LabelUI&lt;/code&gt; L&amp;amp;F object
     * @see UIDefaults#getUI
     * @beaninfo
     *        bound: true
     *       hidden: true
     *      expert: true
     *    attribute: visualUpdate true
     *  description: The UI object that implements the Component's LookAndFeel.
     * @since 1.3
     */
    public void setUI(RootPaneUI ui) {
<span class="nc" id="L474">        super.setUI(ui);</span>
<span class="nc" id="L475">    }</span>


    /**
     * Resets the UI property to a value from the current look and feel.
     *
     * @see JComponent#updateUI
     */
    public void updateUI() {
<span class="nc" id="L484">        setUI((RootPaneUI)UIManager.getUI(this));</span>
<span class="nc" id="L485">    }</span>


    /**
     * Returns a string that specifies the name of the L&amp;amp;F class
     * that renders this component.
     *
     * @return the string &quot;RootPaneUI&quot;
     *
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L498">        return uiClassID;</span>
    }

    /**
      * Called by the constructor methods to create the default
      * &lt;code&gt;layeredPane&lt;/code&gt;.
      * Bt default it creates a new &lt;code&gt;JLayeredPane&lt;/code&gt;.
      * @return the default &lt;code&gt;layeredPane&lt;/code&gt;
      */
    protected JLayeredPane createLayeredPane() {
<span class="nc" id="L508">        JLayeredPane p = new JLayeredPane();</span>
<span class="nc" id="L509">        p.setName(this.getName()+&quot;.layeredPane&quot;);</span>
<span class="nc" id="L510">        return p;</span>
    }

    /**
     * Called by the constructor methods to create the default
     * &lt;code&gt;contentPane&lt;/code&gt;.
     * By default this method creates a new &lt;code&gt;JComponent&lt;/code&gt; add sets a
     * &lt;code&gt;BorderLayout&lt;/code&gt; as its &lt;code&gt;LayoutManager&lt;/code&gt;.
     * @return the default &lt;code&gt;contentPane&lt;/code&gt;
     */
    protected Container createContentPane() {
<span class="nc" id="L521">        JComponent c = new JPanel();</span>
<span class="nc" id="L522">        c.setName(this.getName()+&quot;.contentPane&quot;);</span>
<span class="nc" id="L523">        c.setLayout(new BorderLayout() {</span>
            /* This BorderLayout subclass maps a null constraint to CENTER.
             * Although the reference BorderLayout also does this, some VMs
             * throw an IllegalArgumentException.
             */
            public void addLayoutComponent(Component comp, Object constraints) {
<span class="nc bnc" id="L529" title="All 2 branches missed.">                if (constraints == null) {</span>
<span class="nc" id="L530">                    constraints = BorderLayout.CENTER;</span>
                }
<span class="nc" id="L532">                super.addLayoutComponent(comp, constraints);</span>
<span class="nc" id="L533">            }</span>
        });
<span class="nc" id="L535">        return c;</span>
    }

    /**
      * Called by the constructor methods to create the default
      * &lt;code&gt;glassPane&lt;/code&gt;.
      * By default this method creates a new &lt;code&gt;JComponent&lt;/code&gt;
      * with visibility set to false.
      * @return the default &lt;code&gt;glassPane&lt;/code&gt;
      */
    protected Component createGlassPane() {
<span class="nc" id="L546">        JComponent c = new JPanel();</span>
<span class="nc" id="L547">        c.setName(this.getName()+&quot;.glassPane&quot;);</span>
<span class="nc" id="L548">        c.setVisible(false);</span>
<span class="nc" id="L549">        ((JPanel)c).setOpaque(false);</span>
<span class="nc" id="L550">        return c;</span>
    }

    /**
     * Called by the constructor methods to create the default
     * &lt;code&gt;layoutManager&lt;/code&gt;.
     * @return the default &lt;code&gt;layoutManager&lt;/code&gt;.
     */
    protected LayoutManager createRootLayout() {
<span class="nc" id="L559">        return new RootLayout();</span>
    }

    /**
     * Adds or changes the menu bar used in the layered pane.
     * @param menu the &lt;code&gt;JMenuBar&lt;/code&gt; to add
     */
    public void setJMenuBar(JMenuBar menu) {
<span class="nc bnc" id="L567" title="All 4 branches missed.">        if(menuBar != null &amp;&amp; menuBar.getParent() == layeredPane)</span>
<span class="nc" id="L568">            layeredPane.remove(menuBar);</span>
<span class="nc" id="L569">        menuBar = menu;</span>

<span class="nc bnc" id="L571" title="All 2 branches missed.">        if(menuBar != null)</span>
<span class="nc" id="L572">            layeredPane.add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);</span>
<span class="nc" id="L573">    }</span>

    /**
     * Specifies the menu bar value.
     * @deprecated As of Swing version 1.0.3
     *  replaced by &lt;code&gt;setJMenuBar(JMenuBar menu)&lt;/code&gt;.
     * @param menu the &lt;code&gt;JMenuBar&lt;/code&gt; to add.
     */
    @Deprecated
    public void setMenuBar(JMenuBar menu){
<span class="nc bnc" id="L583" title="All 4 branches missed.">        if(menuBar != null &amp;&amp; menuBar.getParent() == layeredPane)</span>
<span class="nc" id="L584">            layeredPane.remove(menuBar);</span>
<span class="nc" id="L585">        menuBar = menu;</span>

<span class="nc bnc" id="L587" title="All 2 branches missed.">        if(menuBar != null)</span>
<span class="nc" id="L588">            layeredPane.add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);</span>
<span class="nc" id="L589">    }</span>

    /**
     * Returns the menu bar from the layered pane.
     * @return the &lt;code&gt;JMenuBar&lt;/code&gt; used in the pane
     */
<span class="nc" id="L595">    public JMenuBar getJMenuBar() { return menuBar; }</span>

    /**
     * Returns the menu bar value.
     * @deprecated As of Swing version 1.0.3
     *  replaced by &lt;code&gt;getJMenuBar()&lt;/code&gt;.
     * @return the &lt;code&gt;JMenuBar&lt;/code&gt; used in the pane
     */
    @Deprecated
<span class="nc" id="L604">    public JMenuBar getMenuBar() { return menuBar; }</span>

    /**
     * Sets the content pane -- the container that holds the components
     * parented by the root pane.
     * &lt;p&gt;
     * Swing's painting architecture requires an opaque &lt;code&gt;JComponent&lt;/code&gt;
     * in the containment hierarchy. This is typically provided by the
     * content pane. If you replace the content pane it is recommended you
     * replace it with an opaque &lt;code&gt;JComponent&lt;/code&gt;.
     *
     * @param content the &lt;code&gt;Container&lt;/code&gt; to use for component-contents
     * @exception java.awt.IllegalComponentStateException (a runtime
     *            exception) if the content pane parameter is &lt;code&gt;null&lt;/code&gt;
     */
    public void setContentPane(Container content) {
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if(content == null)</span>
<span class="nc" id="L621">            throw new IllegalComponentStateException(&quot;contentPane cannot be set to null.&quot;);</span>
<span class="nc bnc" id="L622" title="All 4 branches missed.">        if(contentPane != null &amp;&amp; contentPane.getParent() == layeredPane)</span>
<span class="nc" id="L623">            layeredPane.remove(contentPane);</span>
<span class="nc" id="L624">        contentPane = content;</span>

<span class="nc" id="L626">        layeredPane.add(contentPane, JLayeredPane.FRAME_CONTENT_LAYER);</span>
<span class="nc" id="L627">    }</span>

    /**
     * Returns the content pane -- the container that holds the components
     * parented by the root pane.
     *
     * @return the &lt;code&gt;Container&lt;/code&gt; that holds the component-contents
     */
<span class="nc" id="L635">    public Container getContentPane() { return contentPane; }</span>

// PENDING(klobad) Should this reparent the contentPane and MenuBar?
    /**
     * Sets the layered pane for the root pane. The layered pane
     * typically holds a content pane and an optional &lt;code&gt;JMenuBar&lt;/code&gt;.
     *
     * @param layered  the &lt;code&gt;JLayeredPane&lt;/code&gt; to use
     * @exception java.awt.IllegalComponentStateException (a runtime
     *            exception) if the layered pane parameter is &lt;code&gt;null&lt;/code&gt;
     */
    public void setLayeredPane(JLayeredPane layered) {
<span class="nc bnc" id="L647" title="All 2 branches missed.">        if(layered == null)</span>
<span class="nc" id="L648">            throw new IllegalComponentStateException(&quot;layeredPane cannot be set to null.&quot;);</span>
<span class="nc bnc" id="L649" title="All 4 branches missed.">        if(layeredPane != null &amp;&amp; layeredPane.getParent() == this)</span>
<span class="nc" id="L650">            this.remove(layeredPane);</span>
<span class="nc" id="L651">        layeredPane = layered;</span>

<span class="nc" id="L653">        this.add(layeredPane, -1);</span>
<span class="nc" id="L654">    }</span>
    /**
     * Gets the layered pane used by the root pane. The layered pane
     * typically holds a content pane and an optional &lt;code&gt;JMenuBar&lt;/code&gt;.
     *
     * @return the &lt;code&gt;JLayeredPane&lt;/code&gt; currently in use
     */
<span class="nc" id="L661">    public JLayeredPane getLayeredPane() { return layeredPane; }</span>

    /**
     * Sets a specified &lt;code&gt;Component&lt;/code&gt; to be the glass pane for this
     * root pane.  The glass pane should normally be a lightweight,
     * transparent component, because it will be made visible when
     * ever the root pane needs to grab input events.
     * &lt;p&gt;
     * The new glass pane's visibility is changed to match that of
     * the current glass pane.  An implication of this is that care
     * must be taken when you want to replace the glass pane and
     * make it visible.  Either of the following will work:
     * &lt;pre&gt;
     *   root.setGlassPane(newGlassPane);
     *   newGlassPane.setVisible(true);
     * &lt;/pre&gt;
     * or:
     * &lt;pre&gt;
     *   root.getGlassPane().setVisible(true);
     *   root.setGlassPane(newGlassPane);
     * &lt;/pre&gt;
     *
     * @param glass the &lt;code&gt;Component&lt;/code&gt; to use as the glass pane
     *              for this &lt;code&gt;JRootPane&lt;/code&gt;
     * @exception NullPointerException if the &lt;code&gt;glass&lt;/code&gt; parameter is
     *          &lt;code&gt;null&lt;/code&gt;
     */
    public void setGlassPane(Component glass) {
<span class="nc bnc" id="L689" title="All 2 branches missed.">        if (glass == null) {</span>
<span class="nc" id="L690">            throw new NullPointerException(&quot;glassPane cannot be set to null.&quot;);</span>
        }

<span class="nc" id="L693">        AWTAccessor.getComponentAccessor().setMixingCutoutShape(glass,</span>
                new Rectangle());

<span class="nc" id="L696">        boolean visible = false;</span>
<span class="nc bnc" id="L697" title="All 4 branches missed.">        if (glassPane != null &amp;&amp; glassPane.getParent() == this) {</span>
<span class="nc" id="L698">            this.remove(glassPane);</span>
<span class="nc" id="L699">            visible = glassPane.isVisible();</span>
        }

<span class="nc" id="L702">        glass.setVisible(visible);</span>
<span class="nc" id="L703">        glassPane = glass;</span>
<span class="nc" id="L704">        this.add(glassPane, 0);</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L706">            repaint();</span>
        }
<span class="nc" id="L708">    }</span>

    /**
     * Returns the current glass pane for this &lt;code&gt;JRootPane&lt;/code&gt;.
     * @return the current glass pane
     * @see #setGlassPane
     */
    public Component getGlassPane() {
<span class="nc" id="L716">        return glassPane;</span>
    }

    /**
     * If a descendant of this &lt;code&gt;JRootPane&lt;/code&gt; calls
     * &lt;code&gt;revalidate&lt;/code&gt;, validate from here on down.
     *&lt;p&gt;
     * Deferred requests to layout a component and its descendents again.
     * For example, calls to &lt;code&gt;revalidate&lt;/code&gt;, are pushed upwards to
     * either a &lt;code&gt;JRootPane&lt;/code&gt; or a &lt;code&gt;JScrollPane&lt;/code&gt;
     * because both classes override &lt;code&gt;isValidateRoot&lt;/code&gt; to return true.
     *
     * @see JComponent#isValidateRoot
     * @see java.awt.Container#isValidateRoot
     * @return true
     */
    @Override
    public boolean isValidateRoot() {
<span class="nc" id="L734">        return true;</span>
    }

    /**
     * The &lt;code&gt;glassPane&lt;/code&gt; and &lt;code&gt;contentPane&lt;/code&gt;
     * have the same bounds, which means &lt;code&gt;JRootPane&lt;/code&gt;
     * does not tiles its children and this should return false.
     * On the other hand, the &lt;code&gt;glassPane&lt;/code&gt;
     * is normally not visible, and so this can return true if the
     * &lt;code&gt;glassPane&lt;/code&gt; isn't visible. Therefore, the
     * return value here depends upon the visibility of the
     * &lt;code&gt;glassPane&lt;/code&gt;.
     *
     * @return true if this component's children don't overlap
     */
    public boolean isOptimizedDrawingEnabled() {
<span class="nc bnc" id="L750" title="All 2 branches missed.">        return !glassPane.isVisible();</span>
    }

    /**
     * {@inheritDoc}
     */
    public void addNotify() {
<span class="nc" id="L757">        super.addNotify();</span>
<span class="nc" id="L758">        enableEvents(AWTEvent.KEY_EVENT_MASK);</span>
<span class="nc" id="L759">    }</span>

    /**
     * {@inheritDoc}
     */
    public void removeNotify() {
<span class="nc" id="L765">        super.removeNotify();</span>
<span class="nc" id="L766">    }</span>


    /**
     * Sets the &lt;code&gt;defaultButton&lt;/code&gt; property,
     * which determines the current default button for this &lt;code&gt;JRootPane&lt;/code&gt;.
     * The default button is the button which will be activated
     * when a UI-defined activation event (typically the &lt;b&gt;Enter&lt;/b&gt; key)
     * occurs in the root pane regardless of whether or not the button
     * has keyboard focus (unless there is another component within
     * the root pane which consumes the activation event,
     * such as a &lt;code&gt;JTextPane&lt;/code&gt;).
     * For default activation to work, the button must be an enabled
     * descendent of the root pane when activation occurs.
     * To remove a default button from this root pane, set this
     * property to &lt;code&gt;null&lt;/code&gt;.
     *
     * @see JButton#isDefaultButton
     * @param defaultButton the &lt;code&gt;JButton&lt;/code&gt; which is to be the default button
     *
     * @beaninfo
     *  description: The button activated by default in this root pane
     */
    public void setDefaultButton(JButton defaultButton) {
<span class="nc" id="L790">        JButton oldDefault = this.defaultButton;</span>

<span class="nc bnc" id="L792" title="All 2 branches missed.">        if (oldDefault != defaultButton) {</span>
<span class="nc" id="L793">            this.defaultButton = defaultButton;</span>

<span class="nc bnc" id="L795" title="All 2 branches missed.">            if (oldDefault != null) {</span>
<span class="nc" id="L796">                oldDefault.repaint();</span>
            }
<span class="nc bnc" id="L798" title="All 2 branches missed.">            if (defaultButton != null) {</span>
<span class="nc" id="L799">                defaultButton.repaint();</span>
            }
        }

<span class="nc" id="L803">        firePropertyChange(&quot;defaultButton&quot;, oldDefault, defaultButton);</span>
<span class="nc" id="L804">    }</span>

    /**
     * Returns the value of the &lt;code&gt;defaultButton&lt;/code&gt; property.
     * @return the &lt;code&gt;JButton&lt;/code&gt; which is currently the default button
     * @see #setDefaultButton
     */
    public JButton getDefaultButton() {
<span class="nc" id="L812">        return defaultButton;</span>
    }

    final void setUseTrueDoubleBuffering(boolean useTrueDoubleBuffering) {
<span class="nc" id="L816">        this.useTrueDoubleBuffering = useTrueDoubleBuffering;</span>
<span class="nc" id="L817">    }</span>

    final boolean getUseTrueDoubleBuffering() {
<span class="nc" id="L820">        return useTrueDoubleBuffering;</span>
    }

    final void disableTrueDoubleBuffering() {
<span class="nc bnc" id="L824" title="All 2 branches missed.">        if (useTrueDoubleBuffering) {</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">            if (!IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING) {</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                if (LOG_DISABLE_TRUE_DOUBLE_BUFFERING) {</span>
<span class="nc" id="L827">                    System.out.println(&quot;Disabling true double buffering for &quot; +</span>
                                       this);
<span class="nc" id="L829">                    Thread.dumpStack();</span>
                }
<span class="nc" id="L831">                useTrueDoubleBuffering = false;</span>
<span class="nc" id="L832">                RepaintManager.currentManager(this).</span>
<span class="nc" id="L833">                        doubleBufferingChanged(this);</span>
            }
        }
<span class="nc" id="L836">    }</span>

    @SuppressWarnings(&quot;serial&quot;)
    static class DefaultAction extends AbstractAction {
        JButton owner;
        JRootPane root;
        boolean press;
<span class="nc" id="L843">        DefaultAction(JRootPane root, boolean press) {</span>
<span class="nc" id="L844">            this.root = root;</span>
<span class="nc" id="L845">            this.press = press;</span>
<span class="nc" id="L846">        }</span>
        public void setOwner(JButton owner) {
<span class="nc" id="L848">            this.owner = owner;</span>
<span class="nc" id="L849">        }</span>
        public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L851" title="All 4 branches missed.">            if (owner != null &amp;&amp; SwingUtilities.getRootPane(owner) == root) {</span>
<span class="nc" id="L852">                ButtonModel model = owner.getModel();</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">                if (press) {</span>
<span class="nc" id="L854">                    model.setArmed(true);</span>
<span class="nc" id="L855">                    model.setPressed(true);</span>
                } else {
<span class="nc" id="L857">                    model.setPressed(false);</span>
                }
            }
<span class="nc" id="L860">        }</span>
        public boolean isEnabled() {
<span class="nc" id="L862">            return owner.getModel().isEnabled();</span>
        }
    }


    /**
     * Overridden to enforce the position of the glass component as
     * the zero child.
     *
     * @param comp the component to be enhanced
     * @param constraints the constraints to be respected
     * @param index the index
     */
    protected void addImpl(Component comp, Object constraints, int index) {
<span class="nc" id="L876">        super.addImpl(comp, constraints, index);</span>

        /// We are making sure the glassPane is on top.
<span class="nc bnc" id="L879" title="All 2 branches missed.">        if(glassPane != null</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">            &amp;&amp; glassPane.getParent() == this</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">            &amp;&amp; getComponent(0) != glassPane) {</span>
<span class="nc" id="L882">            add(glassPane, 0);</span>
        }
<span class="nc" id="L884">    }</span>


///////////////////////////////////////////////////////////////////////////////
//// Begin Inner Classes
///////////////////////////////////////////////////////////////////////////////


    /**
     * A custom layout manager that is responsible for the layout of
     * layeredPane, glassPane, and menuBar.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    @SuppressWarnings(&quot;serial&quot;)
<span class="nc" id="L906">    protected class RootLayout implements LayoutManager2, Serializable</span>
    {
        /**
         * Returns the amount of space the layout would like to have.
         *
         * @param parent the Container for which this layout manager
         * is being used
         * @return a Dimension object containing the layout's preferred size
         */
        public Dimension preferredLayoutSize(Container parent) {
            Dimension rd, mbd;
<span class="nc" id="L917">            Insets i = getInsets();</span>

<span class="nc bnc" id="L919" title="All 2 branches missed.">            if(contentPane != null) {</span>
<span class="nc" id="L920">                rd = contentPane.getPreferredSize();</span>
            } else {
<span class="nc" id="L922">                rd = parent.getSize();</span>
            }
<span class="nc bnc" id="L924" title="All 4 branches missed.">            if(menuBar != null &amp;&amp; menuBar.isVisible()) {</span>
<span class="nc" id="L925">                mbd = menuBar.getPreferredSize();</span>
            } else {
<span class="nc" id="L927">                mbd = new Dimension(0, 0);</span>
            }
<span class="nc" id="L929">            return new Dimension(Math.max(rd.width, mbd.width) + i.left + i.right,</span>
                                        rd.height + mbd.height + i.top + i.bottom);
        }

        /**
         * Returns the minimum amount of space the layout needs.
         *
         * @param parent the Container for which this layout manager
         * is being used
         * @return a Dimension object containing the layout's minimum size
         */
        public Dimension minimumLayoutSize(Container parent) {
            Dimension rd, mbd;
<span class="nc" id="L942">            Insets i = getInsets();</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">            if(contentPane != null) {</span>
<span class="nc" id="L944">                rd = contentPane.getMinimumSize();</span>
            } else {
<span class="nc" id="L946">                rd = parent.getSize();</span>
            }
<span class="nc bnc" id="L948" title="All 4 branches missed.">            if(menuBar != null &amp;&amp; menuBar.isVisible()) {</span>
<span class="nc" id="L949">                mbd = menuBar.getMinimumSize();</span>
            } else {
<span class="nc" id="L951">                mbd = new Dimension(0, 0);</span>
            }
<span class="nc" id="L953">            return new Dimension(Math.max(rd.width, mbd.width) + i.left + i.right,</span>
                        rd.height + mbd.height + i.top + i.bottom);
        }

        /**
         * Returns the maximum amount of space the layout can use.
         *
         * @param target the Container for which this layout manager
         * is being used
         * @return a Dimension object containing the layout's maximum size
         */
        public Dimension maximumLayoutSize(Container target) {
            Dimension rd, mbd;
<span class="nc" id="L966">            Insets i = getInsets();</span>
<span class="nc bnc" id="L967" title="All 4 branches missed.">            if(menuBar != null &amp;&amp; menuBar.isVisible()) {</span>
<span class="nc" id="L968">                mbd = menuBar.getMaximumSize();</span>
            } else {
<span class="nc" id="L970">                mbd = new Dimension(0, 0);</span>
            }
<span class="nc bnc" id="L972" title="All 2 branches missed.">            if(contentPane != null) {</span>
<span class="nc" id="L973">                rd = contentPane.getMaximumSize();</span>
            } else {
                // This is silly, but should stop an overflow error
<span class="nc" id="L976">                rd = new Dimension(Integer.MAX_VALUE,</span>
                        Integer.MAX_VALUE - i.top - i.bottom - mbd.height - 1);
            }
<span class="nc" id="L979">            return new Dimension(Math.min(rd.width, mbd.width) + i.left + i.right,</span>
                                         rd.height + mbd.height + i.top + i.bottom);
        }

        /**
         * Instructs the layout manager to perform the layout for the specified
         * container.
         *
         * @param parent the Container for which this layout manager
         * is being used
         */
        public void layoutContainer(Container parent) {
<span class="nc" id="L991">            Rectangle b = parent.getBounds();</span>
<span class="nc" id="L992">            Insets i = getInsets();</span>
<span class="nc" id="L993">            int contentY = 0;</span>
<span class="nc" id="L994">            int w = b.width - i.right - i.left;</span>
<span class="nc" id="L995">            int h = b.height - i.top - i.bottom;</span>

<span class="nc bnc" id="L997" title="All 2 branches missed.">            if(layeredPane != null) {</span>
<span class="nc" id="L998">                layeredPane.setBounds(i.left, i.top, w, h);</span>
            }
<span class="nc bnc" id="L1000" title="All 2 branches missed.">            if(glassPane != null) {</span>
<span class="nc" id="L1001">                glassPane.setBounds(i.left, i.top, w, h);</span>
            }
            // Note: This is laying out the children in the layeredPane,
            // technically, these are not our children.
<span class="nc bnc" id="L1005" title="All 4 branches missed.">            if(menuBar != null &amp;&amp; menuBar.isVisible()) {</span>
<span class="nc" id="L1006">                Dimension mbd = menuBar.getPreferredSize();</span>
<span class="nc" id="L1007">                menuBar.setBounds(0, 0, w, mbd.height);</span>
<span class="nc" id="L1008">                contentY += mbd.height;</span>
            }
<span class="nc bnc" id="L1010" title="All 2 branches missed.">            if(contentPane != null) {</span>
<span class="nc" id="L1011">                contentPane.setBounds(0, contentY, w, h - contentY);</span>
            }
<span class="nc" id="L1013">        }</span>

<span class="nc" id="L1015">        public void addLayoutComponent(String name, Component comp) {}</span>
<span class="nc" id="L1016">        public void removeLayoutComponent(Component comp) {}</span>
<span class="nc" id="L1017">        public void addLayoutComponent(Component comp, Object constraints) {}</span>
<span class="nc" id="L1018">        public float getLayoutAlignmentX(Container target) { return 0.0f; }</span>
<span class="nc" id="L1019">        public float getLayoutAlignmentY(Container target) { return 0.0f; }</span>
<span class="nc" id="L1020">        public void invalidateLayout(Container target) {}</span>
    }

    /**
     * Returns a string representation of this &lt;code&gt;JRootPane&lt;/code&gt;.
     * This method is intended to be used only for debugging purposes,
     * and the content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this &lt;code&gt;JRootPane&lt;/code&gt;.
     */
    protected String paramString() {
<span class="nc" id="L1033">        return super.paramString();</span>
    }

/////////////////
// Accessibility support
////////////////

    /**
     * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
     * &lt;code&gt;JRootPane&lt;/code&gt;. For root panes, the
     * &lt;code&gt;AccessibleContext&lt;/code&gt; takes the form of an
     * &lt;code&gt;AccessibleJRootPane&lt;/code&gt;.
     * A new &lt;code&gt;AccessibleJRootPane&lt;/code&gt; instance is created if necessary.
     *
     * @return an &lt;code&gt;AccessibleJRootPane&lt;/code&gt; that serves as the
     *         &lt;code&gt;AccessibleContext&lt;/code&gt; of this &lt;code&gt;JRootPane&lt;/code&gt;
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L1051" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L1052">            accessibleContext = new AccessibleJRootPane();</span>
        }
<span class="nc" id="L1054">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JRootPane&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to root pane user-interface elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    @SuppressWarnings(&quot;serial&quot;)
<span class="nc" id="L1072">    protected class AccessibleJRootPane extends AccessibleJComponent {</span>
        /**
         * Get the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of
         * the object
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L1080">            return AccessibleRole.ROOT_PANE;</span>
        }

        /**
         * Returns the number of accessible children of the object.
         *
         * @return the number of accessible children of the object.
         */
        public int getAccessibleChildrenCount() {
<span class="nc" id="L1089">            return super.getAccessibleChildrenCount();</span>
        }

        /**
         * Returns the specified Accessible child of the object.  The Accessible
         * children of an Accessible object are zero-based, so the first child
         * of an Accessible child is at index 0, the second child is at index 1,
         * and so on.
         *
         * @param i zero-based index of child
         * @return the Accessible child of the object
         * @see #getAccessibleChildrenCount
         */
        public Accessible getAccessibleChild(int i) {
<span class="nc" id="L1103">            return super.getAccessibleChild(i);</span>
        }
    } // inner class AccessibleJRootPane
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>