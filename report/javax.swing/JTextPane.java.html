<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>JTextPane.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JTextPane.java</span></div><h1>JTextPane.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.awt.*;
import java.awt.event.ActionEvent;

import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;

import javax.swing.text.*;
import javax.swing.event.*;
import javax.swing.plaf.*;

/**
 * A text component that can be marked up with attributes that are
 * represented graphically.
 * You can find how-to information and examples of using text panes in
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/text.html&quot;&gt;Using Text Components&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 *
 * &lt;p&gt;
 * This component models paragraphs
 * that are composed of runs of character level attributes.  Each
 * paragraph may have a logical style attached to it which contains
 * the default attributes to use if not overridden by attributes set
 * on the paragraph or character run.  Components and images may
 * be embedded in the flow of text.
 * &lt;p&gt;
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Newlines&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * For a discussion on how newlines are handled, see
 * &lt;a href=&quot;text/DefaultEditorKit.html&quot;&gt;DefaultEditorKit&lt;/a&gt;.
 * &lt;/dl&gt;
 *
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @beaninfo
 *   attribute: isContainer true
 * description: A text component that can be marked up with attributes that are graphically represented.
 *
 * @author  Timothy Prinzing
 * @see javax.swing.text.StyledEditorKit
 */
public class JTextPane extends JEditorPane {

    /**
     * Creates a new &lt;code&gt;JTextPane&lt;/code&gt;.  A new instance of
     * &lt;code&gt;StyledEditorKit&lt;/code&gt; is
     * created and set, and the document model set to &lt;code&gt;null&lt;/code&gt;.
     */
    public JTextPane() {
<span class="nc" id="L90">        super();</span>
<span class="nc" id="L91">        EditorKit editorKit = createDefaultEditorKit();</span>
<span class="nc" id="L92">        String contentType = editorKit.getContentType();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (contentType != null</span>
<span class="nc" id="L94">            &amp;&amp; getEditorKitClassNameForContentType(contentType) ==</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">                 defaultEditorKitMap.get(contentType)) {</span>
<span class="nc" id="L96">            setEditorKitForContentType(contentType, editorKit);</span>
        }
<span class="nc" id="L98">        setEditorKit(editorKit);</span>
<span class="nc" id="L99">    }</span>

    /**
     * Creates a new &lt;code&gt;JTextPane&lt;/code&gt;, with a specified document model.
     * A new instance of &lt;code&gt;javax.swing.text.StyledEditorKit&lt;/code&gt;
     *  is created and set.
     *
     * @param doc the document model
     */
    public JTextPane(StyledDocument doc) {
<span class="nc" id="L109">        this();</span>
<span class="nc" id="L110">        setStyledDocument(doc);</span>
<span class="nc" id="L111">    }</span>

    /**
     * Returns the class ID for the UI.
     *
     * @return the string &quot;TextPaneUI&quot;
     *
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L122">        return uiClassID;</span>
    }

    /**
     * Associates the editor with a text document.  This
     * must be a &lt;code&gt;StyledDocument&lt;/code&gt;.
     *
     * @param doc  the document to display/edit
     * @exception IllegalArgumentException  if &lt;code&gt;doc&lt;/code&gt; can't
     *   be narrowed to a &lt;code&gt;StyledDocument&lt;/code&gt; which is the
     *   required type of model for this text component
     */
    public void setDocument(Document doc) {
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (doc instanceof StyledDocument) {</span>
<span class="nc" id="L136">            super.setDocument(doc);</span>
        } else {
<span class="nc" id="L138">            throw new IllegalArgumentException(&quot;Model must be StyledDocument&quot;);</span>
        }
<span class="nc" id="L140">    }</span>

    /**
     * Associates the editor with a text document.
     * The currently registered factory is used to build a view for
     * the document, which gets displayed by the editor.
     *
     * @param doc  the document to display/edit
     */
    public void setStyledDocument(StyledDocument doc) {
<span class="nc" id="L150">        super.setDocument(doc);</span>
<span class="nc" id="L151">    }</span>

    /**
     * Fetches the model associated with the editor.
     *
     * @return the model
     */
    public StyledDocument getStyledDocument() {
<span class="nc" id="L159">        return (StyledDocument) getDocument();</span>
    }

    /**
     * Replaces the currently selected content with new content
     * represented by the given string.  If there is no selection
     * this amounts to an insert of the given text.  If there
     * is no replacement text this amounts to a removal of the
     * current selection.  The replacement text will have the
     * attributes currently defined for input at the point of
     * insertion.  If the document is not editable, beep and return.
     *
     * @param content  the content to replace the selection with
     */
    @Override
    public void replaceSelection(String content) {
<span class="nc" id="L175">        replaceSelection(content, true);</span>
<span class="nc" id="L176">    }</span>

    private void replaceSelection(String content, boolean checkEditable) {
<span class="nc bnc" id="L179" title="All 4 branches missed.">        if (checkEditable &amp;&amp; !isEditable()) {</span>
<span class="nc" id="L180">            UIManager.getLookAndFeel().provideErrorFeedback(JTextPane.this);</span>
<span class="nc" id="L181">            return;</span>
        }
<span class="nc" id="L183">        Document doc = getStyledDocument();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (doc != null) {</span>
            try {
<span class="nc" id="L186">                Caret caret = getCaret();</span>
<span class="nc" id="L187">                boolean composedTextSaved = saveComposedText(caret.getDot());</span>
<span class="nc" id="L188">                int p0 = Math.min(caret.getDot(), caret.getMark());</span>
<span class="nc" id="L189">                int p1 = Math.max(caret.getDot(), caret.getMark());</span>
<span class="nc" id="L190">                AttributeSet attr = getInputAttributes().copyAttributes();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L192">                    ((AbstractDocument)doc).replace(p0, p1 - p0, content,attr);</span>
                }
                else {
<span class="nc bnc" id="L195" title="All 2 branches missed.">                    if (p0 != p1) {</span>
<span class="nc" id="L196">                        doc.remove(p0, p1 - p0);</span>
                    }
<span class="nc bnc" id="L198" title="All 4 branches missed.">                    if (content != null &amp;&amp; content.length() &gt; 0) {</span>
<span class="nc" id="L199">                        doc.insertString(p0, content, attr);</span>
                    }
                }
<span class="nc bnc" id="L202" title="All 2 branches missed.">                if (composedTextSaved) {</span>
<span class="nc" id="L203">                    restoreComposedText();</span>
                }
<span class="nc" id="L205">            } catch (BadLocationException e) {</span>
<span class="nc" id="L206">                UIManager.getLookAndFeel().provideErrorFeedback(JTextPane.this);</span>
<span class="nc" id="L207">            }</span>
        }
<span class="nc" id="L209">    }</span>

    /**
     * Inserts a component into the document as a replacement
     * for the currently selected content.  If there is no
     * selection the component is effectively inserted at the
     * current position of the caret.  This is represented in
     * the associated document as an attribute of one character
     * of content.
     * &lt;p&gt;
     * The component given is the actual component used by the
     * JTextPane.  Since components cannot be a child of more than
     * one container, this method should not be used in situations
     * where the model is shared by text components.
     * &lt;p&gt;
     * The component is placed relative to the text baseline
     * according to the value returned by
     * &lt;code&gt;Component.getAlignmentY&lt;/code&gt;.  For Swing components
     * this value can be conveniently set using the method
     * &lt;code&gt;JComponent.setAlignmentY&lt;/code&gt;.  For example, setting
     * a value of &lt;code&gt;0.75&lt;/code&gt; will cause 75 percent of the
     * component to be above the baseline, and 25 percent of the
     * component to be below the baseline.
     *
     * @param c    the component to insert
     */
    public void insertComponent(Component c) {
<span class="nc" id="L236">        MutableAttributeSet inputAttributes = getInputAttributes();</span>
<span class="nc" id="L237">        inputAttributes.removeAttributes(inputAttributes);</span>
<span class="nc" id="L238">        StyleConstants.setComponent(inputAttributes, c);</span>
<span class="nc" id="L239">        replaceSelection(&quot; &quot;, false);</span>
<span class="nc" id="L240">        inputAttributes.removeAttributes(inputAttributes);</span>
<span class="nc" id="L241">    }</span>

    /**
     * Inserts an icon into the document as a replacement
     * for the currently selected content.  If there is no
     * selection the icon is effectively inserted at the
     * current position of the caret.  This is represented in
     * the associated document as an attribute of one character
     * of content.
     *
     * @param g    the icon to insert
     * @see Icon
     */
    public void insertIcon(Icon g) {
<span class="nc" id="L255">        MutableAttributeSet inputAttributes = getInputAttributes();</span>
<span class="nc" id="L256">        inputAttributes.removeAttributes(inputAttributes);</span>
<span class="nc" id="L257">        StyleConstants.setIcon(inputAttributes, g);</span>
<span class="nc" id="L258">        replaceSelection(&quot; &quot;, false);</span>
<span class="nc" id="L259">        inputAttributes.removeAttributes(inputAttributes);</span>
<span class="nc" id="L260">    }</span>

    /**
     * Adds a new style into the logical style hierarchy.  Style attributes
     * resolve from bottom up so an attribute specified in a child
     * will override an attribute specified in the parent.
     *
     * @param nm   the name of the style (must be unique within the
     *   collection of named styles).  The name may be &lt;code&gt;null&lt;/code&gt;
     *   if the style is unnamed, but the caller is responsible
     *   for managing the reference returned as an unnamed style can't
     *   be fetched by name.  An unnamed style may be useful for things
     *   like character attribute overrides such as found in a style
     *   run.
     * @param parent the parent style.  This may be &lt;code&gt;null&lt;/code&gt;
     *   if unspecified
     *   attributes need not be resolved in some other style.
     * @return the new &lt;code&gt;Style&lt;/code&gt;
     */
    public Style addStyle(String nm, Style parent) {
<span class="nc" id="L280">        StyledDocument doc = getStyledDocument();</span>
<span class="nc" id="L281">        return doc.addStyle(nm, parent);</span>
    }

    /**
     * Removes a named non-&lt;code&gt;null&lt;/code&gt; style previously added to
     * the document.
     *
     * @param nm  the name of the style to remove
     */
    public void removeStyle(String nm) {
<span class="nc" id="L291">        StyledDocument doc = getStyledDocument();</span>
<span class="nc" id="L292">        doc.removeStyle(nm);</span>
<span class="nc" id="L293">    }</span>

    /**
     * Fetches a named non-&lt;code&gt;null&lt;/code&gt; style previously added.
     *
     * @param nm  the name of the style
     * @return the &lt;code&gt;Style&lt;/code&gt;
     */
    public Style getStyle(String nm) {
<span class="nc" id="L302">        StyledDocument doc = getStyledDocument();</span>
<span class="nc" id="L303">        return doc.getStyle(nm);</span>
    }

    /**
     * Sets the logical style to use for the paragraph at the
     * current caret position.  If attributes aren't explicitly set
     * for character and paragraph attributes they will resolve
     * through the logical style assigned to the paragraph, which
     * in term may resolve through some hierarchy completely
     * independent of the element hierarchy in the document.
     *
     * @param s  the logical style to assign to the paragraph,
     *          or &lt;code&gt;null&lt;/code&gt; for no style
     */
    public void setLogicalStyle(Style s) {
<span class="nc" id="L318">        StyledDocument doc = getStyledDocument();</span>
<span class="nc" id="L319">        doc.setLogicalStyle(getCaretPosition(), s);</span>
<span class="nc" id="L320">    }</span>

    /**
     * Fetches the logical style assigned to the paragraph represented
     * by the current position of the caret, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @return the &lt;code&gt;Style&lt;/code&gt;
     */
    public Style getLogicalStyle() {
<span class="nc" id="L329">        StyledDocument doc = getStyledDocument();</span>
<span class="nc" id="L330">        return doc.getLogicalStyle(getCaretPosition());</span>
    }

    /**
     * Fetches the character attributes in effect at the
     * current location of the caret, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @return the attributes, or &lt;code&gt;null&lt;/code&gt;
     */
    public AttributeSet getCharacterAttributes() {
<span class="nc" id="L340">        StyledDocument doc = getStyledDocument();</span>
<span class="nc" id="L341">        Element run = doc.getCharacterElement(getCaretPosition());</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (run != null) {</span>
<span class="nc" id="L343">            return run.getAttributes();</span>
        }
<span class="nc" id="L345">        return null;</span>
    }

    /**
     * Applies the given attributes to character
     * content.  If there is a selection, the attributes
     * are applied to the selection range.  If there
     * is no selection, the attributes are applied to
     * the input attribute set which defines the attributes
     * for any new text that gets inserted.
     *
     * @param attr the attributes
     * @param replace if true, then replace the existing attributes first
     */
    public void setCharacterAttributes(AttributeSet attr, boolean replace) {
<span class="nc" id="L360">        int p0 = getSelectionStart();</span>
<span class="nc" id="L361">        int p1 = getSelectionEnd();</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (p0 != p1) {</span>
<span class="nc" id="L363">            StyledDocument doc = getStyledDocument();</span>
<span class="nc" id="L364">            doc.setCharacterAttributes(p0, p1 - p0, attr, replace);</span>
<span class="nc" id="L365">        } else {</span>
<span class="nc" id="L366">            MutableAttributeSet inputAttributes = getInputAttributes();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (replace) {</span>
<span class="nc" id="L368">                inputAttributes.removeAttributes(inputAttributes);</span>
            }
<span class="nc" id="L370">            inputAttributes.addAttributes(attr);</span>
        }
<span class="nc" id="L372">    }</span>

    /**
     * Fetches the current paragraph attributes in effect
     * at the location of the caret, or &lt;code&gt;null&lt;/code&gt; if none.
     *
     * @return the attributes
     */
    public AttributeSet getParagraphAttributes() {
<span class="nc" id="L381">        StyledDocument doc = getStyledDocument();</span>
<span class="nc" id="L382">        Element paragraph = doc.getParagraphElement(getCaretPosition());</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (paragraph != null) {</span>
<span class="nc" id="L384">            return paragraph.getAttributes();</span>
        }
<span class="nc" id="L386">        return null;</span>
    }

    /**
     * Applies the given attributes to paragraphs.  If
     * there is a selection, the attributes are applied
     * to the paragraphs that intersect the selection.
     * If there is no selection, the attributes are applied
     * to the paragraph at the current caret position.
     *
     * @param attr the non-&lt;code&gt;null&lt;/code&gt; attributes
     * @param replace if true, replace the existing attributes first
     */
    public void setParagraphAttributes(AttributeSet attr, boolean replace) {
<span class="nc" id="L400">        int p0 = getSelectionStart();</span>
<span class="nc" id="L401">        int p1 = getSelectionEnd();</span>
<span class="nc" id="L402">        StyledDocument doc = getStyledDocument();</span>
<span class="nc" id="L403">        doc.setParagraphAttributes(p0, p1 - p0, attr, replace);</span>
<span class="nc" id="L404">    }</span>

    /**
     * Gets the input attributes for the pane.
     *
     * @return the attributes
     */
    public MutableAttributeSet getInputAttributes() {
<span class="nc" id="L412">        return getStyledEditorKit().getInputAttributes();</span>
    }

    /**
     * Gets the editor kit.
     *
     * @return the editor kit
     */
    protected final StyledEditorKit getStyledEditorKit() {
<span class="nc" id="L421">        return (StyledEditorKit) getEditorKit();</span>
    }

    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;TextPaneUI&quot;;


    /**
     * See &lt;code&gt;readObject&lt;/code&gt; and &lt;code&gt;writeObject&lt;/code&gt; in
     * &lt;code&gt;JComponent&lt;/code&gt; for more
     * information about serialization in Swing.
     *
     * @param s the output stream
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L439">        s.defaultWriteObject();</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (getUIClassID().equals(uiClassID)) {</span>
<span class="nc" id="L441">            byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L442">            JComponent.setWriteObjCounter(this, --count);</span>
<span class="nc bnc" id="L443" title="All 4 branches missed.">            if (count == 0 &amp;&amp; ui != null) {</span>
<span class="nc" id="L444">                ui.installUI(this);</span>
            }
        }
<span class="nc" id="L447">    }</span>


    // --- JEditorPane ------------------------------------

    /**
     * Creates the &lt;code&gt;EditorKit&lt;/code&gt; to use by default.  This
     * is implemented to return &lt;code&gt;javax.swing.text.StyledEditorKit&lt;/code&gt;.
     *
     * @return the editor kit
     */
    protected EditorKit createDefaultEditorKit() {
<span class="nc" id="L459">        return new StyledEditorKit();</span>
    }

    /**
     * Sets the currently installed kit for handling
     * content.  This is the bound property that
     * establishes the content type of the editor.
     *
     * @param kit the desired editor behavior
     * @exception IllegalArgumentException if kit is not a
     *          &lt;code&gt;StyledEditorKit&lt;/code&gt;
     */
    public final void setEditorKit(EditorKit kit) {
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (kit instanceof StyledEditorKit) {</span>
<span class="nc" id="L473">            super.setEditorKit(kit);</span>
        } else {
<span class="nc" id="L475">            throw new IllegalArgumentException(&quot;Must be StyledEditorKit&quot;);</span>
        }
<span class="nc" id="L477">    }</span>

    /**
     * Returns a string representation of this &lt;code&gt;JTextPane&lt;/code&gt;.
     * This method
     * is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this &lt;code&gt;JTextPane&lt;/code&gt;
     */
    protected String paramString() {
<span class="nc" id="L490">        return super.paramString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>