<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BufferStrategyPaintManager.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">BufferStrategyPaintManager.java</span></div><h1>BufferStrategyPaintManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.lang.reflect.*;
import java.lang.ref.WeakReference;
import java.util.*;

import com.sun.java.swing.SwingUtilities3;

import sun.awt.SubRegionShowable;
import sun.java2d.SunGraphics2D;
import sun.java2d.pipe.hw.ExtendedBufferCapabilities;
import sun.awt.SunToolkit;
import sun.util.logging.PlatformLogger;

/**
 * A PaintManager implementation that uses a BufferStrategy for
 * rendering.
 *
 * @author Scott Violet
 */
class BufferStrategyPaintManager extends RepaintManager.PaintManager {
    //
    // All drawing is done to a BufferStrategy.  At the end of painting
    // (endPaint) the region that was painted is flushed to the screen
    // (using BufferStrategy.show).
    //
    // PaintManager.show is overriden to show directly from the
    // BufferStrategy (when using blit), if successful true is
    // returned and a paint event will not be generated.  To avoid
    // showing from the buffer while painting a locking scheme is
    // implemented.  When beginPaint is invoked the field painting is
    // set to true.  If painting is true and show is invoked we
    // immediately return false.  This is done to avoid blocking the
    // toolkit thread while painting happens.  In a similar way when
    // show is invoked the field showing is set to true, beginPaint
    // will then block until showing is true.  This scheme ensures we
    // only ever have one thread using the BufferStrategy and it also
    // ensures the toolkit thread remains as responsive as possible.
    //
    // If we're using a flip strategy the contents of the backbuffer may
    // have changed and so show only attempts to show from the backbuffer
    // if we get a blit strategy.
    //

    //
    // Methods used to create BufferStrategy for Applets.
    //
    private static Method COMPONENT_CREATE_BUFFER_STRATEGY_METHOD;
    private static Method COMPONENT_GET_BUFFER_STRATEGY_METHOD;

<span class="nc" id="L78">    private static final PlatformLogger LOGGER = PlatformLogger.getLogger(</span>
                           &quot;javax.swing.BufferStrategyPaintManager&quot;);

    /**
     * List of BufferInfos.  We don't use a Map primarily because
     * there are typically only a handful of top level components making
     * a Map overkill.
     */
    private ArrayList&lt;BufferInfo&gt; bufferInfos;

    /**
     * Indicates &lt;code&gt;beginPaint&lt;/code&gt; has been invoked.  This is
     * set to true for the life of beginPaint/endPaint pair.
     */
    private boolean painting;
    /**
     * Indicates we're in the process of showing.  All painting, on the EDT,
     * is blocked while this is true.
     */
    private boolean showing;

    //
    // Region that we need to flush.  When beginPaint is called these are
    // reset and any subsequent calls to paint/copyArea then update these
    // fields accordingly.  When endPaint is called we then try and show
    // the accumulated region.
    // These fields are in the coordinate system of the root.
    //
    private int accumulatedX;
    private int accumulatedY;
    private int accumulatedMaxX;
    private int accumulatedMaxY;

    //
    // The following fields are set by prepare
    //

    /**
     * Farthest JComponent ancestor for the current paint/copyArea.
     */
    private JComponent rootJ;
    /**
     * Location of component being painted relative to root.
     */
    private int xOffset;
    /**
     * Location of component being painted relative to root.
     */
    private int yOffset;
    /**
     * Graphics from the BufferStrategy.
     */
    private Graphics bsg;
    /**
     * BufferStrategy currently being used.
     */
    private BufferStrategy bufferStrategy;
    /**
     * BufferInfo corresponding to root.
     */
    private BufferInfo bufferInfo;

    /**
     * Set to true if the bufferInfo needs to be disposed when current
     * paint loop is done.
     */
    private boolean disposeBufferOnEnd;

    private static Method getGetBufferStrategyMethod() {
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (COMPONENT_GET_BUFFER_STRATEGY_METHOD == null) {</span>
<span class="nc" id="L148">            getMethods();</span>
        }
<span class="nc" id="L150">        return COMPONENT_GET_BUFFER_STRATEGY_METHOD;</span>
    }

    private static Method getCreateBufferStrategyMethod() {
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (COMPONENT_CREATE_BUFFER_STRATEGY_METHOD == null) {</span>
<span class="nc" id="L155">            getMethods();</span>
        }
<span class="nc" id="L157">        return COMPONENT_CREATE_BUFFER_STRATEGY_METHOD;</span>
    }

    private static void getMethods() {
<span class="nc" id="L161">        java.security.AccessController.doPrivileged(</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                            new java.security.PrivilegedAction&lt;Object&gt;() {</span>
            public Object run() {
                try {
<span class="nc" id="L165">                    COMPONENT_CREATE_BUFFER_STRATEGY_METHOD = Component.class.</span>
<span class="nc" id="L166">                              getDeclaredMethod(&quot;createBufferStrategy&quot;,</span>
                                                new Class[] { int.class,
                                                BufferCapabilities.class });
<span class="nc" id="L169">                    COMPONENT_CREATE_BUFFER_STRATEGY_METHOD.</span>
<span class="nc" id="L170">                                            setAccessible(true);</span>
<span class="nc" id="L171">                    COMPONENT_GET_BUFFER_STRATEGY_METHOD = Component.class.</span>
<span class="nc" id="L172">                              getDeclaredMethod(&quot;getBufferStrategy&quot;);</span>
<span class="nc" id="L173">                    COMPONENT_GET_BUFFER_STRATEGY_METHOD.setAccessible(true);</span>
<span class="nc" id="L174">                } catch (SecurityException e) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                    assert false;</span>
<span class="nc" id="L176">                } catch (NoSuchMethodException nsme) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                    assert false;</span>
<span class="nc" id="L178">                }</span>
<span class="nc" id="L179">                return null;</span>
            }
        });
<span class="nc" id="L182">    }</span>

<span class="nc" id="L184">    BufferStrategyPaintManager() {</span>
<span class="nc" id="L185">        bufferInfos = new ArrayList&lt;BufferInfo&gt;(1);</span>
<span class="nc" id="L186">    }</span>

    //
    // PaintManager methods
    //

    /**
     * Cleans up any created BufferStrategies.
     */
    protected void dispose() {
        // dipose can be invoked at any random time. To avoid
        // threading dependancies we do the actual diposing via an
        // invokeLater.
<span class="nc" id="L199">        SwingUtilities.invokeLater(new Runnable() {</span>
            public void run() {
                java.util.List&lt;BufferInfo&gt; bufferInfos;
<span class="nc" id="L202">                synchronized(BufferStrategyPaintManager.this) {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                    while (showing) {</span>
                        try {
<span class="nc" id="L205">                            BufferStrategyPaintManager.this.wait();</span>
<span class="nc" id="L206">                        } catch (InterruptedException ie) {</span>
<span class="nc" id="L207">                        }</span>
                    }
<span class="nc" id="L209">                    bufferInfos = BufferStrategyPaintManager.this.bufferInfos;</span>
<span class="nc" id="L210">                    BufferStrategyPaintManager.this.bufferInfos = null;</span>
<span class="nc" id="L211">                }</span>
<span class="nc" id="L212">                dispose(bufferInfos);</span>
<span class="nc" id="L213">            }</span>
        });
<span class="nc" id="L215">    }</span>

    private void dispose(java.util.List&lt;BufferInfo&gt; bufferInfos) {
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L219">            LOGGER.finer(&quot;BufferStrategyPaintManager disposed&quot;,</span>
                         new RuntimeException());
        }
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (bufferInfos != null) {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            for (BufferInfo bufferInfo : bufferInfos) {</span>
<span class="nc" id="L224">                bufferInfo.dispose();</span>
<span class="nc" id="L225">            }</span>
        }
<span class="nc" id="L227">    }</span>

    /**
     * Shows the specified region of the back buffer.  This will return
     * true if successful, false otherwise.  This is invoked on the
     * toolkit thread in response to an expose event.
     */
    public boolean show(Container c, int x, int y, int w, int h) {
<span class="nc" id="L235">        synchronized(this) {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            if (painting) {</span>
                // Don't show from backbuffer while in the process of
                // painting.
<span class="nc" id="L239">                return false;</span>
            }
<span class="nc" id="L241">            showing = true;</span>
<span class="nc" id="L242">        }</span>
        try {
<span class="nc" id="L244">            BufferInfo info = getBufferInfo(c);</span>
            BufferStrategy bufferStrategy;
<span class="nc bnc" id="L246" title="All 4 branches missed.">            if (info != null &amp;&amp; info.isInSync() &amp;&amp;</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">                (bufferStrategy = info.getBufferStrategy(false)) != null) {</span>
<span class="nc" id="L248">                SubRegionShowable bsSubRegion =</span>
                        (SubRegionShowable)bufferStrategy;
<span class="nc" id="L250">                boolean paintAllOnExpose = info.getPaintAllOnExpose();</span>
<span class="nc" id="L251">                info.setPaintAllOnExpose(false);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                if (bsSubRegion.showIfNotLost(x, y, (x + w), (y + h))) {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">                    return !paintAllOnExpose;</span>
                }
                // Mark the buffer as needing to be repainted.  We don't
                // immediately do a repaint as this method will return false
                // indicating a PaintEvent should be generated which will
                // trigger a complete repaint.
<span class="nc" id="L259">                bufferInfo.setContentsLostDuringExpose(true);</span>
            }
        }
        finally {
<span class="nc" id="L263">            synchronized(this) {</span>
<span class="nc" id="L264">                showing = false;</span>
<span class="nc" id="L265">                notifyAll();</span>
<span class="nc" id="L266">            }</span>
<span class="nc" id="L267">        }</span>
<span class="nc" id="L268">        return false;</span>
    }

    public boolean paint(JComponent paintingComponent,
                         JComponent bufferComponent, Graphics g,
                         int x, int y, int w, int h) {
<span class="nc" id="L274">        Container root = fetchRoot(paintingComponent);</span>

<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (prepare(paintingComponent, root, true, x, y, w, h)) {</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if ((g instanceof SunGraphics2D) &amp;&amp;</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">                    ((SunGraphics2D)g).getDestination() == root) {</span>
                // BufferStrategy may have already constrained the Graphics. To
                // account for that we revert the constrain, then apply a
                // constrain for Swing on top of that.
<span class="nc" id="L282">                int cx = ((SunGraphics2D)bsg).constrainX;</span>
<span class="nc" id="L283">                int cy = ((SunGraphics2D)bsg).constrainY;</span>
<span class="nc bnc" id="L284" title="All 4 branches missed.">                if (cx != 0 || cy != 0) {</span>
<span class="nc" id="L285">                    bsg.translate(-cx, -cy);</span>
                }
<span class="nc" id="L287">                ((SunGraphics2D)bsg).constrain(xOffset + cx, yOffset + cy,</span>
                                               x + w, y + h);
<span class="nc" id="L289">                bsg.setClip(x, y, w, h);</span>
<span class="nc" id="L290">                paintingComponent.paintToOffscreen(bsg, x, y, w, h,</span>
                                                   x + w, y + h);
<span class="nc" id="L292">                accumulate(xOffset + x, yOffset + y, w, h);</span>
<span class="nc" id="L293">                return true;</span>
            } else {
                // Assume they are going to eventually render to the screen.
                // This disables showing from backbuffer until a complete
                // repaint occurs.
<span class="nc" id="L298">                bufferInfo.setInSync(false);</span>
                // Fall through to old rendering.
            }
        }
        // Invalid root, do what Swing has always done.
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L304">            LOGGER.finer(&quot;prepare failed&quot;);</span>
        }
<span class="nc" id="L306">        return super.paint(paintingComponent, bufferComponent, g, x, y, w, h);</span>
    }

    public void copyArea(JComponent c, Graphics g, int x, int y, int w, int h,
                         int deltaX, int deltaY, boolean clip) {
        // Note: this method is only called internally and we know that
        // g is from a heavyweight Component, so no check is necessary as
        // it is in paint() above.
        //
        // If the buffer isn't in sync there is no point in doing a copyArea,
        // it has garbage.
<span class="nc" id="L317">        Container root = fetchRoot(c);</span>

<span class="nc bnc" id="L319" title="All 4 branches missed.">        if (prepare(c, root, false, 0, 0, 0, 0) &amp;&amp; bufferInfo.isInSync()) {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (clip) {</span>
<span class="nc" id="L321">                Rectangle cBounds = c.getVisibleRect();</span>
<span class="nc" id="L322">                int relX = xOffset + x;</span>
<span class="nc" id="L323">                int relY = yOffset + y;</span>
<span class="nc" id="L324">                bsg.clipRect(xOffset + cBounds.x,</span>
                             yOffset + cBounds.y,
                             cBounds.width, cBounds.height);
<span class="nc" id="L327">                bsg.copyArea(relX, relY, w, h, deltaX, deltaY);</span>
<span class="nc" id="L328">            }</span>
            else {
<span class="nc" id="L330">                bsg.copyArea(xOffset + x, yOffset + y, w, h, deltaX,</span>
                             deltaY);
            }
<span class="nc" id="L333">            accumulate(x + xOffset + deltaX, y + yOffset + deltaY, w, h);</span>
        } else {
<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L336">                LOGGER.finer(&quot;copyArea: prepare failed or not in sync&quot;);</span>
            }
            // Prepare failed, or not in sync. By calling super.copyArea
            // we'll copy on screen. We need to flush any pending paint to
            // the screen otherwise we'll do a copyArea on the wrong thing.
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (!flushAccumulatedRegion()) {</span>
                // Flush failed, copyArea will be copying garbage,
                // force repaint of all.
<span class="nc" id="L344">                rootJ.repaint();</span>
            } else {
<span class="nc" id="L346">                super.copyArea(c, g, x, y, w, h, deltaX, deltaY, clip);</span>
            }
        }
<span class="nc" id="L349">    }</span>

    public void beginPaint() {
<span class="nc" id="L352">        synchronized(this) {</span>
<span class="nc" id="L353">            painting = true;</span>
            // Make sure another thread isn't attempting to show from
            // the back buffer.
<span class="nc bnc" id="L356" title="All 2 branches missed.">            while(showing) {</span>
                try {
<span class="nc" id="L358">                    wait();</span>
<span class="nc" id="L359">                } catch (InterruptedException ie) {</span>
<span class="nc" id="L360">                }</span>
            }
<span class="nc" id="L362">        }</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (LOGGER.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L364">            LOGGER.finest(&quot;beginPaint&quot;);</span>
        }
        // Reset the area that needs to be painted.
<span class="nc" id="L367">        resetAccumulated();</span>
<span class="nc" id="L368">    }</span>

    public void endPaint() {
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (LOGGER.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L372">            LOGGER.finest(&quot;endPaint: region &quot; + accumulatedX + &quot; &quot; +</span>
                       accumulatedY + &quot; &quot; +  accumulatedMaxX + &quot; &quot; +
                       accumulatedMaxY);
        }
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (painting) {</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (!flushAccumulatedRegion()) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                if (!isRepaintingRoot()) {</span>
<span class="nc" id="L379">                    repaintRoot(rootJ);</span>
                }
                else {
                    // Contents lost twice in a row, punt.
<span class="nc" id="L383">                    resetDoubleBufferPerWindow();</span>
                    // In case we've left junk on the screen, force a repaint.
<span class="nc" id="L385">                    rootJ.repaint();</span>
                }
            }
        }

<span class="nc" id="L390">        BufferInfo toDispose = null;</span>
<span class="nc" id="L391">        synchronized(this) {</span>
<span class="nc" id="L392">            painting = false;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            if (disposeBufferOnEnd) {</span>
<span class="nc" id="L394">                disposeBufferOnEnd = false;</span>
<span class="nc" id="L395">                toDispose = bufferInfo;</span>
<span class="nc" id="L396">                bufferInfos.remove(toDispose);</span>
            }
<span class="nc" id="L398">        }</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (toDispose != null) {</span>
<span class="nc" id="L400">            toDispose.dispose();</span>
        }
<span class="nc" id="L402">    }</span>

    /**
     * Renders the BufferStrategy to the screen.
     *
     * @return true if successful, false otherwise.
     */
    private boolean flushAccumulatedRegion() {
<span class="nc" id="L410">        boolean success = true;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (accumulatedX != Integer.MAX_VALUE) {</span>
<span class="nc" id="L412">            SubRegionShowable bsSubRegion = (SubRegionShowable)bufferStrategy;</span>
<span class="nc" id="L413">            boolean contentsLost = bufferStrategy.contentsLost();</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">            if (!contentsLost) {</span>
<span class="nc" id="L415">                bsSubRegion.show(accumulatedX, accumulatedY,</span>
                                 accumulatedMaxX, accumulatedMaxY);
<span class="nc" id="L417">                contentsLost = bufferStrategy.contentsLost();</span>
            }
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (contentsLost) {</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L421">                    LOGGER.finer(&quot;endPaint: contents lost&quot;);</span>
                }
                // Shown region was bogus, mark buffer as out of sync.
<span class="nc" id="L424">                bufferInfo.setInSync(false);</span>
<span class="nc" id="L425">                success = false;</span>
            }
        }
<span class="nc" id="L428">        resetAccumulated();</span>
<span class="nc" id="L429">        return success;</span>
    }

    private void resetAccumulated() {
<span class="nc" id="L433">        accumulatedX = Integer.MAX_VALUE;</span>
<span class="nc" id="L434">        accumulatedY = Integer.MAX_VALUE;</span>
<span class="nc" id="L435">        accumulatedMaxX = 0;</span>
<span class="nc" id="L436">        accumulatedMaxY = 0;</span>
<span class="nc" id="L437">    }</span>

    /**
     * Invoked when the double buffering or useTrueDoubleBuffering
     * changes for a JRootPane.  If the rootpane is not double
     * buffered, or true double buffering changes we throw out any
     * cache we may have.
     */
    public void doubleBufferingChanged(final JRootPane rootPane) {
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if ((!rootPane.isDoubleBuffered() ||</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                !rootPane.getUseTrueDoubleBuffering()) &amp;&amp;</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                rootPane.getParent() != null) {</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">            if (!SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L450">                Runnable updater = new Runnable() {</span>
                    public void run() {
<span class="nc" id="L452">                        doubleBufferingChanged0(rootPane);</span>
<span class="nc" id="L453">                    }</span>
                };
<span class="nc" id="L455">                SwingUtilities.invokeLater(updater);</span>
<span class="nc" id="L456">            }</span>
            else {
<span class="nc" id="L458">                doubleBufferingChanged0(rootPane);</span>
            }
        }
<span class="nc" id="L461">    }</span>

    /**
     * Does the work for doubleBufferingChanged.
     */
    private void doubleBufferingChanged0(JRootPane rootPane) {
        // This will only happen on the EDT.
        BufferInfo info;
<span class="nc" id="L469">        synchronized(this) {</span>
            // Make sure another thread isn't attempting to show from
            // the back buffer.
<span class="nc bnc" id="L472" title="All 2 branches missed.">            while(showing) {</span>
                try {
<span class="nc" id="L474">                    wait();</span>
<span class="nc" id="L475">                } catch (InterruptedException ie) {</span>
<span class="nc" id="L476">                }</span>
            }
<span class="nc" id="L478">            info = getBufferInfo(rootPane.getParent());</span>
<span class="nc bnc" id="L479" title="All 4 branches missed.">            if (painting &amp;&amp; bufferInfo == info) {</span>
                // We're in the process of painting and the user grabbed
                // the Graphics. If we dispose now, endPaint will attempt
                // to show a bogus BufferStrategy. Set a flag so that
                // endPaint knows it needs to dispose this buffer.
<span class="nc" id="L484">                disposeBufferOnEnd = true;</span>
<span class="nc" id="L485">                info = null;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            } else if (info != null) {</span>
<span class="nc" id="L487">                bufferInfos.remove(info);</span>
            }
<span class="nc" id="L489">        }</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (info != null) {</span>
<span class="nc" id="L491">            info.dispose();</span>
        }
<span class="nc" id="L493">    }</span>

    /**
     * Calculates information common to paint/copyArea.
     *
     * @return true if should use buffering per window in painting.
     */
    private boolean prepare(JComponent c, Container root, boolean isPaint, int x, int y,
                            int w, int h) {
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (bsg != null) {</span>
<span class="nc" id="L503">            bsg.dispose();</span>
<span class="nc" id="L504">            bsg = null;</span>
        }
<span class="nc" id="L506">        bufferStrategy = null;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (root != null) {</span>
<span class="nc" id="L508">            boolean contentsLost = false;</span>
<span class="nc" id="L509">            BufferInfo bufferInfo = getBufferInfo(root);</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">            if (bufferInfo == null) {</span>
<span class="nc" id="L511">                contentsLost = true;</span>
<span class="nc" id="L512">                bufferInfo = new BufferInfo(root);</span>
<span class="nc" id="L513">                bufferInfos.add(bufferInfo);</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L515">                    LOGGER.finer(&quot;prepare: new BufferInfo: &quot; + root);</span>
                }
            }
<span class="nc" id="L518">            this.bufferInfo = bufferInfo;</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            if (!bufferInfo.hasBufferStrategyChanged()) {</span>
<span class="nc" id="L520">                bufferStrategy = bufferInfo.getBufferStrategy(true);</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                if (bufferStrategy != null) {</span>
<span class="nc" id="L522">                    bsg = bufferStrategy.getDrawGraphics();</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">                    if (bufferStrategy.contentsRestored()) {</span>
<span class="nc" id="L524">                        contentsLost = true;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                        if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L526">                            LOGGER.finer(&quot;prepare: contents restored in prepare&quot;);</span>
                        }
                    }
                }
                else {
                    // Couldn't create BufferStrategy, fallback to normal
                    // painting.
<span class="nc" id="L533">                    return false;</span>
                }
<span class="nc bnc" id="L535" title="All 2 branches missed.">                if (bufferInfo.getContentsLostDuringExpose()) {</span>
<span class="nc" id="L536">                    contentsLost = true;</span>
<span class="nc" id="L537">                    bufferInfo.setContentsLostDuringExpose(false);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">                    if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L539">                        LOGGER.finer(&quot;prepare: contents lost on expose&quot;);</span>
                    }
                }
<span class="nc bnc" id="L542" title="All 8 branches missed.">                if (isPaint &amp;&amp; c == rootJ &amp;&amp; x == 0 &amp;&amp; y == 0 &amp;&amp;</span>
<span class="nc bnc" id="L543" title="All 4 branches missed.">                      c.getWidth() == w &amp;&amp; c.getHeight() == h) {</span>
<span class="nc" id="L544">                    bufferInfo.setInSync(true);</span>
                }
<span class="nc bnc" id="L546" title="All 2 branches missed.">                else if (contentsLost) {</span>
                    // We either recreated the BufferStrategy, or the contents
                    // of the buffer strategy were restored.  We need to
                    // repaint the root pane so that the back buffer is in sync
                    // again.
<span class="nc" id="L551">                    bufferInfo.setInSync(false);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                    if (!isRepaintingRoot()) {</span>
<span class="nc" id="L553">                        repaintRoot(rootJ);</span>
                    }
                    else {
                        // Contents lost twice in a row, punt
<span class="nc" id="L557">                        resetDoubleBufferPerWindow();</span>
                    }
                }
<span class="nc bnc" id="L560" title="All 2 branches missed.">                return (bufferInfos != null);</span>
            }
        }
<span class="nc" id="L563">        return false;</span>
    }

    private Container fetchRoot(JComponent c) {
<span class="nc" id="L567">        boolean encounteredHW = false;</span>
<span class="nc" id="L568">        rootJ = c;</span>
<span class="nc" id="L569">        Container root = c;</span>
<span class="nc" id="L570">        xOffset = yOffset = 0;</span>
<span class="nc bnc" id="L571" title="All 4 branches missed.">        while (root != null &amp;&amp;</span>
               (!(root instanceof Window) &amp;&amp;
<span class="nc bnc" id="L573" title="All 2 branches missed.">                !SunToolkit.isInstanceOf(root, &quot;java.applet.Applet&quot;))) {</span>
<span class="nc" id="L574">            xOffset += root.getX();</span>
<span class="nc" id="L575">            yOffset += root.getY();</span>
<span class="nc" id="L576">            root = root.getParent();</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">            if (root != null) {</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">                if (root instanceof JComponent) {</span>
<span class="nc" id="L579">                    rootJ = (JComponent)root;</span>
                }
<span class="nc bnc" id="L581" title="All 2 branches missed.">                else if (!root.isLightweight()) {</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                    if (!encounteredHW) {</span>
<span class="nc" id="L583">                        encounteredHW = true;</span>
                    }
                    else {
                        // We've encountered two hws now and may have
                        // a containment hierarchy with lightweights containing
                        // heavyweights containing other lightweights.
                        // Heavyweights poke holes in lightweight
                        // rendering so that if we call show on the BS
                        // (which is associated with the Window) you will
                        // not see the contents over any child
                        // heavyweights.  If we didn't do this when we
                        // went to show the descendants of the nested hw
                        // you would see nothing, so, we bail out here.
<span class="nc" id="L596">                        return null;</span>
                    }
                }
            }
        }
<span class="nc bnc" id="L601" title="All 4 branches missed.">        if ((root instanceof RootPaneContainer) &amp;&amp;</span>
            (rootJ instanceof JRootPane)) {
            // We're in a Swing heavyeight (JFrame/JWindow...), use double
            // buffering if double buffering enabled on the JRootPane and
            // the JRootPane wants true double buffering.
<span class="nc bnc" id="L606" title="All 2 branches missed.">            if (rootJ.isDoubleBuffered() &amp;&amp;</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">                    ((JRootPane)rootJ).getUseTrueDoubleBuffering()) {</span>
                // Whether or not a component is double buffered is a
                // bit tricky with Swing. This gives a good approximation
                // of the various ways to turn on double buffering for
                // components.
<span class="nc" id="L612">                return root;</span>
            }
        }
        // Don't do true double buffering.
<span class="nc" id="L616">        return null;</span>
    }

    /**
     * Turns off double buffering per window.
     */
    private void resetDoubleBufferPerWindow() {
<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (bufferInfos != null) {</span>
<span class="nc" id="L624">            dispose(bufferInfos);</span>
<span class="nc" id="L625">            bufferInfos = null;</span>
<span class="nc" id="L626">            repaintManager.setPaintManager(null);</span>
        }
<span class="nc" id="L628">    }</span>

    /**
     * Returns the BufferInfo for the specified root or null if one
     * hasn't been created yet.
     */
    private BufferInfo getBufferInfo(Container root) {
<span class="nc bnc" id="L635" title="All 2 branches missed.">        for (int counter = bufferInfos.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L636">            BufferInfo bufferInfo = bufferInfos.get(counter);</span>
<span class="nc" id="L637">            Container biRoot = bufferInfo.getRoot();</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (biRoot == null) {</span>
                // Window gc'ed
<span class="nc" id="L640">                bufferInfos.remove(counter);</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">                if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L642">                    LOGGER.finer(&quot;BufferInfo pruned, root null&quot;);</span>
                }
            }
<span class="nc bnc" id="L645" title="All 2 branches missed.">            else if (biRoot == root) {</span>
<span class="nc" id="L646">                return bufferInfo;</span>
            }
        }
<span class="nc" id="L649">        return null;</span>
    }

    private void accumulate(int x, int y, int w, int h) {
<span class="nc" id="L653">        accumulatedX = Math.min(x, accumulatedX);</span>
<span class="nc" id="L654">        accumulatedY = Math.min(y, accumulatedY);</span>
<span class="nc" id="L655">        accumulatedMaxX = Math.max(accumulatedMaxX, x + w);</span>
<span class="nc" id="L656">        accumulatedMaxY = Math.max(accumulatedMaxY, y + h);</span>
<span class="nc" id="L657">    }</span>



    /**
     * BufferInfo is used to track the BufferStrategy being used for
     * a particular Component.  In addition to tracking the BufferStrategy
     * it will install a WindowListener and ComponentListener.  When the
     * component is hidden/iconified the buffer is marked as needing to be
     * completely repainted.
     */
<span class="nc bnc" id="L668" title="All 2 branches missed.">    private class BufferInfo extends ComponentAdapter implements</span>
                               WindowListener {
        // NOTE: This class does NOT hold a direct reference to the root, if it
        // did there would be a cycle between the BufferPerWindowPaintManager
        // and the Window so that it could never be GC'ed
        //
        // Reference to BufferStrategy is referenced via WeakReference for
        // same reason.
        private WeakReference&lt;BufferStrategy&gt; weakBS;
        private WeakReference&lt;Container&gt; root;
        // Indicates whether or not the backbuffer and display are in sync.
        // This is set to true when a full repaint on the rootpane is done.
        private boolean inSync;
        // Indicates the contents were lost during and expose event.
        private boolean contentsLostDuringExpose;
        // Indicates we need to generate a paint event on expose.
        private boolean paintAllOnExpose;


<span class="nc" id="L687">        public BufferInfo(Container root) {</span>
<span class="nc" id="L688">            this.root = new WeakReference&lt;Container&gt;(root);</span>
<span class="nc" id="L689">            root.addComponentListener(this);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if (root instanceof Window) {</span>
<span class="nc" id="L691">                ((Window)root).addWindowListener(this);</span>
            }
<span class="nc" id="L693">        }</span>

        public void setPaintAllOnExpose(boolean paintAllOnExpose) {
<span class="nc" id="L696">            this.paintAllOnExpose = paintAllOnExpose;</span>
<span class="nc" id="L697">        }</span>

        public boolean getPaintAllOnExpose() {
<span class="nc" id="L700">            return paintAllOnExpose;</span>
        }

        public void setContentsLostDuringExpose(boolean value) {
<span class="nc" id="L704">            contentsLostDuringExpose = value;</span>
<span class="nc" id="L705">        }</span>

        public boolean getContentsLostDuringExpose() {
<span class="nc" id="L708">            return contentsLostDuringExpose;</span>
        }

        public void setInSync(boolean inSync) {
<span class="nc" id="L712">            this.inSync = inSync;</span>
<span class="nc" id="L713">        }</span>

        /**
         * Whether or not the contents of the buffer strategy
         * is in sync with the window.  This is set to true when the root
         * pane paints all, and false when contents are lost/restored.
         */
        public boolean isInSync() {
<span class="nc" id="L721">            return inSync;</span>
        }

        /**
         * Returns the Root (Window or Applet) that this BufferInfo references.
         */
        public Container getRoot() {
<span class="nc bnc" id="L728" title="All 2 branches missed.">            return (root == null) ? null : root.get();</span>
        }

        /**
         * Returns the BufferStartegy.  This will return null if
         * the BufferStartegy hasn't been created and &lt;code&gt;create&lt;/code&gt; is
         * false, or if there is a problem in creating the
         * &lt;code&gt;BufferStartegy&lt;/code&gt;.
         *
         * @param create If true, and the BufferStartegy is currently null,
         *               one will be created.
         */
        public BufferStrategy getBufferStrategy(boolean create) {
<span class="nc bnc" id="L741" title="All 2 branches missed.">            BufferStrategy bs = (weakBS == null) ? null : weakBS.get();</span>
<span class="nc bnc" id="L742" title="All 4 branches missed.">            if (bs == null &amp;&amp; create) {</span>
<span class="nc" id="L743">                bs = createBufferStrategy();</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">                if (bs != null) {</span>
<span class="nc" id="L745">                    weakBS = new WeakReference&lt;BufferStrategy&gt;(bs);</span>
                }
<span class="nc bnc" id="L747" title="All 2 branches missed.">                if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L748">                    LOGGER.finer(&quot;getBufferStrategy: created bs: &quot; + bs);</span>
                }
            }
<span class="nc" id="L751">            return bs;</span>
        }

        /**
         * Returns true if the buffer strategy of the component differs
         * from current buffer strategy.
         */
        public boolean hasBufferStrategyChanged() {
<span class="nc" id="L759">            Container root = getRoot();</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">            if (root != null) {</span>
<span class="nc" id="L761">                BufferStrategy ourBS = null;</span>
<span class="nc" id="L762">                BufferStrategy componentBS = null;</span>

<span class="nc" id="L764">                ourBS = getBufferStrategy(false);</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">                if (root instanceof Window) {</span>
<span class="nc" id="L766">                    componentBS = ((Window)root).getBufferStrategy();</span>
                }
                else {
                    try {
                        componentBS = (BufferStrategy)
<span class="nc" id="L771">                                 getGetBufferStrategyMethod().invoke(root);</span>
<span class="nc" id="L772">                    } catch (InvocationTargetException ite) {</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">                        assert false;</span>
<span class="nc" id="L774">                    } catch (IllegalArgumentException iae) {</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">                        assert false;</span>
<span class="nc" id="L776">                    } catch (IllegalAccessException iae2) {</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">                        assert false;</span>
<span class="nc" id="L778">                    }</span>
                }
<span class="nc bnc" id="L780" title="All 2 branches missed.">                if (componentBS != ourBS) {</span>
                    // Component has a different BS, dispose ours.
<span class="nc bnc" id="L782" title="All 2 branches missed.">                    if (ourBS != null) {</span>
<span class="nc" id="L783">                        ourBS.dispose();</span>
                    }
<span class="nc" id="L785">                    weakBS = null;</span>
<span class="nc" id="L786">                    return true;</span>
                }
            }
<span class="nc" id="L789">            return false;</span>
        }

        /**
         * Creates the BufferStrategy.  If the appropriate system property
         * has been set we'll try for flip first and then we'll try for
         * blit.
         */
        private BufferStrategy createBufferStrategy() {
<span class="nc" id="L798">            Container root = getRoot();</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">            if (root == null) {</span>
<span class="nc" id="L800">                return null;</span>
            }
<span class="nc" id="L802">            BufferStrategy bs = null;</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">            if (SwingUtilities3.isVsyncRequested(root)) {</span>
<span class="nc" id="L804">                bs = createBufferStrategy(root, true);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">                if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L806">                    LOGGER.finer(&quot;createBufferStrategy: using vsynced strategy&quot;);</span>
                }
            }
<span class="nc bnc" id="L809" title="All 2 branches missed.">            if (bs == null) {</span>
<span class="nc" id="L810">                bs = createBufferStrategy(root, false);</span>
            }
<span class="nc bnc" id="L812" title="All 2 branches missed.">            if (!(bs instanceof SubRegionShowable)) {</span>
                // We do this for two reasons:
                // 1. So that we know we can cast to SubRegionShowable and
                //    invoke show with the minimal region to update
                // 2. To avoid the possibility of invoking client code
                //    on the toolkit thread.
<span class="nc" id="L818">                bs = null;</span>
            }
<span class="nc" id="L820">            return bs;</span>
        }

        // Creates and returns a buffer strategy.  If
        // there is a problem creating the buffer strategy this will
        // eat the exception and return null.
        private BufferStrategy createBufferStrategy(Container root,
                boolean isVsynced) {
            BufferCapabilities caps;
<span class="nc bnc" id="L829" title="All 2 branches missed.">            if (isVsynced) {</span>
<span class="nc" id="L830">                caps = new ExtendedBufferCapabilities(</span>
                    new ImageCapabilities(true), new ImageCapabilities(true),
                    BufferCapabilities.FlipContents.COPIED,
                    ExtendedBufferCapabilities.VSyncType.VSYNC_ON);
            } else {
<span class="nc" id="L835">                caps = new BufferCapabilities(</span>
                    new ImageCapabilities(true), new ImageCapabilities(true),
                    null);
            }
<span class="nc" id="L839">            BufferStrategy bs = null;</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">            if (SunToolkit.isInstanceOf(root, &quot;java.applet.Applet&quot;)) {</span>
                try {
<span class="nc" id="L842">                    getCreateBufferStrategyMethod().invoke(root, 2, caps);</span>
<span class="nc" id="L843">                    bs = (BufferStrategy)getGetBufferStrategyMethod().</span>
<span class="nc" id="L844">                                            invoke(root);</span>
<span class="nc" id="L845">                } catch (InvocationTargetException ite) {</span>
                    // Type is not supported
<span class="nc bnc" id="L847" title="All 2 branches missed.">                    if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L848">                        LOGGER.finer(&quot;createBufferStratety failed&quot;,</span>
                                     ite);
                    }
<span class="nc" id="L851">                } catch (IllegalArgumentException iae) {</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">                    assert false;</span>
<span class="nc" id="L853">                } catch (IllegalAccessException iae2) {</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">                    assert false;</span>
<span class="nc" id="L855">                }</span>
            }
            else {
                try {
<span class="nc" id="L859">                    ((Window)root).createBufferStrategy(2, caps);</span>
<span class="nc" id="L860">                    bs = ((Window)root).getBufferStrategy();</span>
<span class="nc" id="L861">                } catch (AWTException e) {</span>
                    // Type not supported
<span class="nc bnc" id="L863" title="All 2 branches missed.">                    if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L864">                        LOGGER.finer(&quot;createBufferStratety failed&quot;,</span>
                                     e);
                    }
<span class="nc" id="L867">                }</span>
            }
<span class="nc" id="L869">            return bs;</span>
        }

        /**
         * Cleans up and removes any references.
         */
        public void dispose() {
<span class="nc" id="L876">            Container root = getRoot();</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">            if (LOGGER.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc" id="L878">                LOGGER.finer(&quot;disposed BufferInfo for: &quot; + root);</span>
            }
<span class="nc bnc" id="L880" title="All 2 branches missed.">            if (root != null) {</span>
<span class="nc" id="L881">                root.removeComponentListener(this);</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">                if (root instanceof Window) {</span>
<span class="nc" id="L883">                    ((Window)root).removeWindowListener(this);</span>
                }
<span class="nc" id="L885">                BufferStrategy bs = getBufferStrategy(false);</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">                if (bs != null) {</span>
<span class="nc" id="L887">                    bs.dispose();</span>
                }
            }
<span class="nc" id="L890">            this.root = null;</span>
<span class="nc" id="L891">            weakBS = null;</span>
<span class="nc" id="L892">        }</span>

        // We mark the buffer as needing to be painted on a hide/iconify
        // because the developer may have conditionalized painting based on
        // visibility.
        // Ideally we would also move to having the BufferStrategy being
        // a SoftReference in Component here, but that requires changes to
        // Component and the like.
        public void componentHidden(ComponentEvent e) {
<span class="nc" id="L901">            Container root = getRoot();</span>
<span class="nc bnc" id="L902" title="All 4 branches missed.">            if (root != null &amp;&amp; root.isVisible()) {</span>
                // This case will only happen if a developer calls
                // hide immediately followed by show.  In this case
                // the event is delivered after show and the window
                // will still be visible.  If a developer altered the
                // contents of the window between the hide/show
                // invocations we won't recognize we need to paint and
                // the contents would be bogus.  Calling repaint here
                // fixs everything up.
<span class="nc" id="L911">                root.repaint();</span>
            }
            else {
<span class="nc" id="L914">                setPaintAllOnExpose(true);</span>
            }
<span class="nc" id="L916">        }</span>

        public void windowIconified(WindowEvent e) {
<span class="nc" id="L919">            setPaintAllOnExpose(true);</span>
<span class="nc" id="L920">        }</span>

        // On a dispose we chuck everything.
        public void windowClosed(WindowEvent e) {
            // Make sure we're not showing.
<span class="nc" id="L925">            synchronized(BufferStrategyPaintManager.this) {</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">                while (showing) {</span>
                    try {
<span class="nc" id="L928">                        BufferStrategyPaintManager.this.wait();</span>
<span class="nc" id="L929">                    } catch (InterruptedException ie) {</span>
<span class="nc" id="L930">                    }</span>
                }
<span class="nc" id="L932">                bufferInfos.remove(this);</span>
<span class="nc" id="L933">            }</span>
<span class="nc" id="L934">            dispose();</span>
<span class="nc" id="L935">        }</span>

        public void windowOpened(WindowEvent e) {
<span class="nc" id="L938">        }</span>

        public void windowClosing(WindowEvent e) {
<span class="nc" id="L941">        }</span>

        public void windowDeiconified(WindowEvent e) {
<span class="nc" id="L944">        }</span>

        public void windowActivated(WindowEvent e) {
<span class="nc" id="L947">        }</span>

        public void windowDeactivated(WindowEvent e) {
<span class="nc" id="L950">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>