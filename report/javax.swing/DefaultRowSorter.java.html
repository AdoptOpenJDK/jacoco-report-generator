<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DefaultRowSorter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">DefaultRowSorter.java</span></div><h1>DefaultRowSorter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.text.Collator;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.SortOrder;

/**
 * An implementation of &lt;code&gt;RowSorter&lt;/code&gt; that provides sorting and
 * filtering around a grid-based data model.
 * Beyond creating and installing a &lt;code&gt;RowSorter&lt;/code&gt;, you very rarely
 * need to interact with one directly.  Refer to
 * {@link javax.swing.table.TableRowSorter TableRowSorter} for a concrete
 * implementation of &lt;code&gt;RowSorter&lt;/code&gt; for &lt;code&gt;JTable&lt;/code&gt;.
 * &lt;p&gt;
 * Sorting is done based on the current &lt;code&gt;SortKey&lt;/code&gt;s, in order.
 * If two objects are equal (the &lt;code&gt;Comparator&lt;/code&gt; for the
 * column returns 0) the next &lt;code&gt;SortKey&lt;/code&gt; is used.  If no
 * &lt;code&gt;SortKey&lt;/code&gt;s remain or the order is &lt;code&gt;UNSORTED&lt;/code&gt;, then
 * the order of the rows in the model is used.
 * &lt;p&gt;
 * Sorting of each column is done by way of a &lt;code&gt;Comparator&lt;/code&gt;
 * that you can specify using the &lt;code&gt;setComparator&lt;/code&gt; method.
 * If a &lt;code&gt;Comparator&lt;/code&gt; has not been specified, the
 * &lt;code&gt;Comparator&lt;/code&gt; returned by
 * &lt;code&gt;Collator.getInstance()&lt;/code&gt; is used on the results of
 * calling &lt;code&gt;toString&lt;/code&gt; on the underlying objects.  The
 * &lt;code&gt;Comparator&lt;/code&gt; is never passed &lt;code&gt;null&lt;/code&gt;.  A
 * &lt;code&gt;null&lt;/code&gt; value is treated as occurring before a
 * non-&lt;code&gt;null&lt;/code&gt; value, and two &lt;code&gt;null&lt;/code&gt; values are
 * considered equal.
 * &lt;p&gt;
 * If you specify a &lt;code&gt;Comparator&lt;/code&gt; that casts its argument to
 * a type other than that provided by the model, a
 * &lt;code&gt;ClassCastException&lt;/code&gt; will be thrown when the data is sorted.
 * &lt;p&gt;
 * In addition to sorting, &lt;code&gt;DefaultRowSorter&lt;/code&gt; provides the
 * ability to filter rows.  Filtering is done by way of a
 * &lt;code&gt;RowFilter&lt;/code&gt; that is specified using the
 * &lt;code&gt;setRowFilter&lt;/code&gt; method.  If no filter has been specified all
 * rows are included.
 * &lt;p&gt;
 * By default, rows are in unsorted order (the same as the model) and
 * every column is sortable. The default &lt;code&gt;Comparator&lt;/code&gt;s are
 * documented in the subclasses (for example, {@link
 * javax.swing.table.TableRowSorter TableRowSorter}).
 * &lt;p&gt;
 * If the underlying model structure changes (the
 * &lt;code&gt;modelStructureChanged&lt;/code&gt; method is invoked) the following
 * are reset to their default values: &lt;code&gt;Comparator&lt;/code&gt;s by
 * column, current sort order, and whether each column is sortable. To
 * find the default &lt;code&gt;Comparator&lt;/code&gt;s, see the concrete
 * implementation (for example, {@link
 * javax.swing.table.TableRowSorter TableRowSorter}).  The default
 * sort order is unsorted (the same as the model), and columns are
 * sortable by default.
 * &lt;p&gt;
 * If the underlying model structure changes (the
 * &lt;code&gt;modelStructureChanged&lt;/code&gt; method is invoked) the following
 * are reset to their default values: &lt;code&gt;Comparator&lt;/code&gt;s by column,
 * current sort order and whether a column is sortable.
 * &lt;p&gt;
 * &lt;code&gt;DefaultRowSorter&lt;/code&gt; is an abstract class.  Concrete
 * subclasses must provide access to the underlying data by invoking
 * {@code setModelWrapper}. The {@code setModelWrapper} method
 * &lt;b&gt;must&lt;/b&gt; be invoked soon after the constructor is
 * called, ideally from within the subclass's constructor.
 * Undefined behavior will result if you use a {@code
 * DefaultRowSorter} without specifying a {@code ModelWrapper}.
 * &lt;p&gt;
 * &lt;code&gt;DefaultRowSorter&lt;/code&gt; has two formal type parameters.  The
 * first type parameter corresponds to the class of the model, for example
 * &lt;code&gt;DefaultTableModel&lt;/code&gt;.  The second type parameter
 * corresponds to the class of the identifier passed to the
 * &lt;code&gt;RowFilter&lt;/code&gt;.  Refer to &lt;code&gt;TableRowSorter&lt;/code&gt; and
 * &lt;code&gt;RowFilter&lt;/code&gt; for more details on the type parameters.
 *
 * @param &lt;M&gt; the type of the model
 * @param &lt;I&gt; the type of the identifier passed to the &lt;code&gt;RowFilter&lt;/code&gt;
 * @see javax.swing.table.TableRowSorter
 * @see javax.swing.table.DefaultTableModel
 * @see java.text.Collator
 * @since 1.6
 */
public abstract class DefaultRowSorter&lt;M, I&gt; extends RowSorter&lt;M&gt; {
    /**
     * Whether or not we resort on TableModelEvent.UPDATEs.
     */
    private boolean sortsOnUpdates;

    /**
     * View (JTable) -&gt; model.
     */
    private Row[] viewToModel;

    /**
     * model -&gt; view (JTable)
     */
    private int[] modelToView;

    /**
     * Comparators specified by column.
     */
    private Comparator[] comparators;

    /**
     * Whether or not the specified column is sortable, by column.
     */
    private boolean[] isSortable;

    /**
     * Cached SortKeys for the current sort.
     */
    private SortKey[] cachedSortKeys;

    /**
     * Cached comparators for the current sort
     */
    private Comparator[] sortComparators;

    /**
     * Developer supplied Filter.
     */
    private RowFilter&lt;? super M,? super I&gt; filter;

    /**
     * Value passed to the filter.  The same instance is passed to the
     * filter for different rows.
     */
    private FilterEntry filterEntry;

    /**
     * The sort keys.
     */
    private List&lt;SortKey&gt; sortKeys;

    /**
     * Whether or not to use getStringValueAt.  This is indexed by column.
     */
    private boolean[] useToString;

    /**
     * Indicates the contents are sorted.  This is used if
     * getSortsOnUpdates is false and an update event is received.
     */
    private boolean sorted;

    /**
     * Maximum number of sort keys.
     */
    private int maxSortKeys;

    /**
     * Provides access to the data we're sorting/filtering.
     */
    private ModelWrapper&lt;M,I&gt; modelWrapper;

    /**
     * Size of the model. This is used to enforce error checking within
     * the table changed notification methods (such as rowsInserted).
     */
    private int modelRowCount;


    /**
     * Creates an empty &lt;code&gt;DefaultRowSorter&lt;/code&gt;.
     */
<span class="nc" id="L195">    public DefaultRowSorter() {</span>
<span class="nc" id="L196">        sortKeys = Collections.emptyList();</span>
<span class="nc" id="L197">        maxSortKeys = 3;</span>
<span class="nc" id="L198">    }</span>

    /**
     * Sets the model wrapper providing the data that is being sorted and
     * filtered.
     *
     * @param modelWrapper the model wrapper responsible for providing the
     *         data that gets sorted and filtered
     * @throws IllegalArgumentException if {@code modelWrapper} is
     *         {@code null}
     */
    protected final void setModelWrapper(ModelWrapper&lt;M,I&gt; modelWrapper) {
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (modelWrapper == null) {</span>
<span class="nc" id="L211">            throw new IllegalArgumentException(</span>
                &quot;modelWrapper most be non-null&quot;);
        }
<span class="nc" id="L214">        ModelWrapper&lt;M,I&gt; last = this.modelWrapper;</span>
<span class="nc" id="L215">        this.modelWrapper = modelWrapper;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (last != null) {</span>
<span class="nc" id="L217">            modelStructureChanged();</span>
        } else {
            // If last is null, we're in the constructor. If we're in
            // the constructor we don't want to call to overridable methods.
<span class="nc" id="L221">            modelRowCount = getModelWrapper().getRowCount();</span>
        }
<span class="nc" id="L223">    }</span>

    /**
     * Returns the model wrapper providing the data that is being sorted and
     * filtered.
     *
     * @return the model wrapper responsible for providing the data that
     *         gets sorted and filtered
     */
    protected final ModelWrapper&lt;M,I&gt; getModelWrapper() {
<span class="nc" id="L233">        return modelWrapper;</span>
    }

    /**
     * Returns the underlying model.
     *
     * @return the underlying model
     */
    public final M getModel() {
<span class="nc" id="L242">        return getModelWrapper().getModel();</span>
    }

    /**
     * Sets whether or not the specified column is sortable.  The specified
     * value is only checked when &lt;code&gt;toggleSortOrder&lt;/code&gt; is invoked.
     * It is still possible to sort on a column that has been marked as
     * unsortable by directly setting the sort keys.  The default is
     * true.
     *
     * @param column the column to enable or disable sorting on, in terms
     *        of the underlying model
     * @param sortable whether or not the specified column is sortable
     * @throws IndexOutOfBoundsException if &lt;code&gt;column&lt;/code&gt; is outside
     *         the range of the model
     * @see #toggleSortOrder
     * @see #setSortKeys
     */
    public void setSortable(int column, boolean sortable) {
<span class="nc" id="L261">        checkColumn(column);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (isSortable == null) {</span>
<span class="nc" id="L263">            isSortable = new boolean[getModelWrapper().getColumnCount()];</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            for (int i = isSortable.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L265">                isSortable[i] = true;</span>
            }
        }
<span class="nc" id="L268">        isSortable[column] = sortable;</span>
<span class="nc" id="L269">    }</span>

    /**
     * Returns true if the specified column is sortable; otherwise, false.
     *
     * @param column the column to check sorting for, in terms of the
     *        underlying model
     * @return true if the column is sortable
     * @throws IndexOutOfBoundsException if column is outside
     *         the range of the underlying model
     */
    public boolean isSortable(int column) {
<span class="nc" id="L281">        checkColumn(column);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        return (isSortable == null) ? true : isSortable[column];</span>
    }

    /**
     * Sets the sort keys. This creates a copy of the supplied
     * {@code List}; subsequent changes to the supplied
     * {@code List} do not effect this {@code DefaultRowSorter}.
     * If the sort keys have changed this triggers a sort.
     *
     * @param sortKeys the new &lt;code&gt;SortKeys&lt;/code&gt;; &lt;code&gt;null&lt;/code&gt;
     *        is a shorthand for specifying an empty list,
     *        indicating that the view should be unsorted
     * @throws IllegalArgumentException if any of the values in
     *         &lt;code&gt;sortKeys&lt;/code&gt; are null or have a column index outside
     *         the range of the model
     */
    public void setSortKeys(List&lt;? extends SortKey&gt; sortKeys) {
<span class="nc" id="L299">        List&lt;SortKey&gt; old = this.sortKeys;</span>
<span class="nc bnc" id="L300" title="All 4 branches missed.">        if (sortKeys != null &amp;&amp; sortKeys.size() &gt; 0) {</span>
<span class="nc" id="L301">            int max = getModelWrapper().getColumnCount();</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            for (SortKey key : sortKeys) {</span>
<span class="nc bnc" id="L303" title="All 4 branches missed.">                if (key == null || key.getColumn() &lt; 0 ||</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                        key.getColumn() &gt;= max) {</span>
<span class="nc" id="L305">                    throw new IllegalArgumentException(&quot;Invalid SortKey&quot;);</span>
                }
<span class="nc" id="L307">            }</span>
<span class="nc" id="L308">            this.sortKeys = Collections.unmodifiableList(</span>
                    new ArrayList&lt;SortKey&gt;(sortKeys));
<span class="nc" id="L310">        }</span>
        else {
<span class="nc" id="L312">            this.sortKeys = Collections.emptyList();</span>
        }
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (!this.sortKeys.equals(old)) {</span>
<span class="nc" id="L315">            fireSortOrderChanged();</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (viewToModel == null) {</span>
                // Currently unsorted, use sort so that internal fields
                // are correctly set.
<span class="nc" id="L319">                sort();</span>
            } else {
<span class="nc" id="L321">                sortExistingData();</span>
            }
        }
<span class="nc" id="L324">    }</span>

    /**
     * Returns the current sort keys.  This returns an unmodifiable
     * {@code non-null List}. If you need to change the sort keys,
     * make a copy of the returned {@code List}, mutate the copy
     * and invoke {@code setSortKeys} with the new list.
     *
     * @return the current sort order
     */
    public List&lt;? extends SortKey&gt; getSortKeys() {
<span class="nc" id="L335">        return sortKeys;</span>
    }

    /**
     * Sets the maximum number of sort keys.  The number of sort keys
     * determines how equal values are resolved when sorting.  For
     * example, assume a table row sorter is created and
     * &lt;code&gt;setMaxSortKeys(2)&lt;/code&gt; is invoked on it. The user
     * clicks the header for column 1, causing the table rows to be
     * sorted based on the items in column 1.  Next, the user clicks
     * the header for column 2, causing the table to be sorted based
     * on the items in column 2; if any items in column 2 are equal,
     * then those particular rows are ordered based on the items in
     * column 1. In this case, we say that the rows are primarily
     * sorted on column 2, and secondarily on column 1.  If the user
     * then clicks the header for column 3, then the items are
     * primarily sorted on column 3 and secondarily sorted on column
     * 2.  Because the maximum number of sort keys has been set to 2
     * with &lt;code&gt;setMaxSortKeys&lt;/code&gt;, column 1 no longer has an
     * effect on the order.
     * &lt;p&gt;
     * The maximum number of sort keys is enforced by
     * &lt;code&gt;toggleSortOrder&lt;/code&gt;.  You can specify more sort
     * keys by invoking &lt;code&gt;setSortKeys&lt;/code&gt; directly and they will
     * all be honored.  However if &lt;code&gt;toggleSortOrder&lt;/code&gt; is subsequently
     * invoked the maximum number of sort keys will be enforced.
     * The default value is 3.
     *
     * @param max the maximum number of sort keys
     * @throws IllegalArgumentException if &lt;code&gt;max&lt;/code&gt; &amp;lt; 1
     */
    public void setMaxSortKeys(int max) {
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (max &lt; 1) {</span>
<span class="nc" id="L368">            throw new IllegalArgumentException(&quot;Invalid max&quot;);</span>
        }
<span class="nc" id="L370">        maxSortKeys = max;</span>
<span class="nc" id="L371">    }</span>

    /**
     * Returns the maximum number of sort keys.
     *
     * @return the maximum number of sort keys
     */
    public int getMaxSortKeys() {
<span class="nc" id="L379">        return maxSortKeys;</span>
    }

    /**
     * If true, specifies that a sort should happen when the underlying
     * model is updated (&lt;code&gt;rowsUpdated&lt;/code&gt; is invoked).  For
     * example, if this is true and the user edits an entry the
     * location of that item in the view may change.  The default is
     * false.
     *
     * @param sortsOnUpdates whether or not to sort on update events
     */
    public void setSortsOnUpdates(boolean sortsOnUpdates) {
<span class="nc" id="L392">        this.sortsOnUpdates = sortsOnUpdates;</span>
<span class="nc" id="L393">    }</span>

    /**
     * Returns true if  a sort should happen when the underlying
     * model is updated; otherwise, returns false.
     *
     * @return whether or not to sort when the model is updated
     */
    public boolean getSortsOnUpdates() {
<span class="nc" id="L402">        return sortsOnUpdates;</span>
    }

    /**
     * Sets the filter that determines which rows, if any, should be
     * hidden from the view.  The filter is applied before sorting.  A value
     * of &lt;code&gt;null&lt;/code&gt; indicates all values from the model should be
     * included.
     * &lt;p&gt;
     * &lt;code&gt;RowFilter&lt;/code&gt;'s &lt;code&gt;include&lt;/code&gt; method is passed an
     * &lt;code&gt;Entry&lt;/code&gt; that wraps the underlying model.  The number
     * of columns in the &lt;code&gt;Entry&lt;/code&gt; corresponds to the
     * number of columns in the &lt;code&gt;ModelWrapper&lt;/code&gt;.  The identifier
     * comes from the &lt;code&gt;ModelWrapper&lt;/code&gt; as well.
     * &lt;p&gt;
     * This method triggers a sort.
     *
     * @param filter the filter used to determine what entries should be
     *        included
     */
    public void setRowFilter(RowFilter&lt;? super M,? super I&gt; filter) {
<span class="nc" id="L423">        this.filter = filter;</span>
<span class="nc" id="L424">        sort();</span>
<span class="nc" id="L425">    }</span>

    /**
     * Returns the filter that determines which rows, if any, should
     * be hidden from view.
     *
     * @return the filter
     */
    public RowFilter&lt;? super M,? super I&gt; getRowFilter() {
<span class="nc" id="L434">        return filter;</span>
    }

    /**
     * Reverses the sort order from ascending to descending (or
     * descending to ascending) if the specified column is already the
     * primary sorted column; otherwise, makes the specified column
     * the primary sorted column, with an ascending sort order.  If
     * the specified column is not sortable, this method has no
     * effect.
     *
     * @param column index of the column to make the primary sorted column,
     *        in terms of the underlying model
     * @throws IndexOutOfBoundsException {@inheritDoc}
     * @see #setSortable(int,boolean)
     * @see #setMaxSortKeys(int)
     */
    public void toggleSortOrder(int column) {
<span class="nc" id="L452">        checkColumn(column);</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (isSortable(column)) {</span>
<span class="nc" id="L454">            List&lt;SortKey&gt; keys = new ArrayList&lt;SortKey&gt;(getSortKeys());</span>
            SortKey sortKey;
            int sortIndex;
<span class="nc bnc" id="L457" title="All 2 branches missed.">            for (sortIndex = keys.size() - 1; sortIndex &gt;= 0; sortIndex--) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (keys.get(sortIndex).getColumn() == column) {</span>
<span class="nc" id="L459">                    break;</span>
                }
            }
<span class="nc bnc" id="L462" title="All 2 branches missed.">            if (sortIndex == -1) {</span>
                // Key doesn't exist
<span class="nc" id="L464">                sortKey = new SortKey(column, SortOrder.ASCENDING);</span>
<span class="nc" id="L465">                keys.add(0, sortKey);</span>
            }
<span class="nc bnc" id="L467" title="All 2 branches missed.">            else if (sortIndex == 0) {</span>
                // It's the primary sorting key, toggle it
<span class="nc" id="L469">                keys.set(0, toggle(keys.get(0)));</span>
            }
            else {
                // It's not the first, but was sorted on, remove old
                // entry, insert as first with ascending.
<span class="nc" id="L474">                keys.remove(sortIndex);</span>
<span class="nc" id="L475">                keys.add(0, new SortKey(column, SortOrder.ASCENDING));</span>
            }
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (keys.size() &gt; getMaxSortKeys()) {</span>
<span class="nc" id="L478">                keys = keys.subList(0, getMaxSortKeys());</span>
            }
<span class="nc" id="L480">            setSortKeys(keys);</span>
        }
<span class="nc" id="L482">    }</span>

    private SortKey toggle(SortKey key) {
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if (key.getSortOrder() == SortOrder.ASCENDING) {</span>
<span class="nc" id="L486">            return new SortKey(key.getColumn(), SortOrder.DESCENDING);</span>
        }
<span class="nc" id="L488">        return new SortKey(key.getColumn(), SortOrder.ASCENDING);</span>
    }

    /**
     * {@inheritDoc}
     *
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public int convertRowIndexToView(int index) {
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (modelToView == null) {</span>
<span class="nc bnc" id="L498" title="All 4 branches missed.">            if (index &lt; 0 || index &gt;= getModelWrapper().getRowCount()) {</span>
<span class="nc" id="L499">                throw new IndexOutOfBoundsException(&quot;Invalid index&quot;);</span>
            }
<span class="nc" id="L501">            return index;</span>
        }
<span class="nc" id="L503">        return modelToView[index];</span>
    }

    /**
     * {@inheritDoc}
     *
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public int convertRowIndexToModel(int index) {
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (viewToModel == null) {</span>
<span class="nc bnc" id="L513" title="All 4 branches missed.">            if (index &lt; 0 || index &gt;= getModelWrapper().getRowCount()) {</span>
<span class="nc" id="L514">                throw new IndexOutOfBoundsException(&quot;Invalid index&quot;);</span>
            }
<span class="nc" id="L516">            return index;</span>
        }
<span class="nc" id="L518">        return viewToModel[index].modelIndex;</span>
    }

    private boolean isUnsorted() {
<span class="nc" id="L522">        List&lt;? extends SortKey&gt; keys = getSortKeys();</span>
<span class="nc" id="L523">        int keySize = keys.size();</span>
<span class="nc bnc" id="L524" title="All 4 branches missed.">        return (keySize == 0 || keys.get(0).getSortOrder() ==</span>
                SortOrder.UNSORTED);
    }

    /**
     * Sorts the existing filtered data.  This should only be used if
     * the filter hasn't changed.
     */
    private void sortExistingData() {
<span class="nc" id="L533">        int[] lastViewToModel = getViewToModelAsInts(viewToModel);</span>

<span class="nc" id="L535">        updateUseToString();</span>
<span class="nc" id="L536">        cacheSortKeys(getSortKeys());</span>

<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (isUnsorted()) {</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">            if (getRowFilter() == null) {</span>
<span class="nc" id="L540">                viewToModel = null;</span>
<span class="nc" id="L541">                modelToView = null;</span>
            } else {
<span class="nc" id="L543">                int included = 0;</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">                for (int i = 0; i &lt; modelToView.length; i++) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">                    if (modelToView[i] != -1) {</span>
<span class="nc" id="L546">                        viewToModel[included].modelIndex = i;</span>
<span class="nc" id="L547">                        modelToView[i] = included++;</span>
                    }
                }
<span class="nc" id="L550">            }</span>
        } else {
            // sort the data
<span class="nc" id="L553">            Arrays.sort(viewToModel);</span>

            // Update the modelToView array
<span class="nc" id="L556">            setModelToViewFromViewToModel(false);</span>
        }
<span class="nc" id="L558">        fireRowSorterChanged(lastViewToModel);</span>
<span class="nc" id="L559">    }</span>

    /**
     * Sorts and filters the rows in the view based on the sort keys
     * of the columns currently being sorted and the filter, if any,
     * associated with this sorter.  An empty &lt;code&gt;sortKeys&lt;/code&gt; list
     * indicates that the view should unsorted, the same as the model.
     *
     * @see #setRowFilter
     * @see #setSortKeys
     */
    public void sort() {
<span class="nc" id="L571">        sorted = true;</span>
<span class="nc" id="L572">        int[] lastViewToModel = getViewToModelAsInts(viewToModel);</span>
<span class="nc" id="L573">        updateUseToString();</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (isUnsorted()) {</span>
            // Unsorted
<span class="nc" id="L576">            cachedSortKeys = new SortKey[0];</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">            if (getRowFilter() == null) {</span>
                // No filter &amp; unsorted
<span class="nc bnc" id="L579" title="All 2 branches missed.">                if (viewToModel != null) {</span>
                    // sorted -&gt; unsorted
<span class="nc" id="L581">                    viewToModel = null;</span>
<span class="nc" id="L582">                    modelToView = null;</span>
                }
                else {
                    // unsorted -&gt; unsorted
                    // No need to do anything.
<span class="nc" id="L587">                    return;</span>
                }
            }
            else {
                // There is filter, reset mappings
<span class="nc" id="L592">                initializeFilteredMapping();</span>
            }
        }
        else {
<span class="nc" id="L596">            cacheSortKeys(getSortKeys());</span>

<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (getRowFilter() != null) {</span>
<span class="nc" id="L599">                initializeFilteredMapping();</span>
            }
            else {
<span class="nc" id="L602">                createModelToView(getModelWrapper().getRowCount());</span>
<span class="nc" id="L603">                createViewToModel(getModelWrapper().getRowCount());</span>
            }

            // sort them
<span class="nc" id="L607">            Arrays.sort(viewToModel);</span>

            // Update the modelToView array
<span class="nc" id="L610">            setModelToViewFromViewToModel(false);</span>
        }
<span class="nc" id="L612">        fireRowSorterChanged(lastViewToModel);</span>
<span class="nc" id="L613">    }</span>

    /**
     * Updates the useToString mapping before a sort.
     */
    private void updateUseToString() {
<span class="nc" id="L619">        int i = getModelWrapper().getColumnCount();</span>
<span class="nc bnc" id="L620" title="All 4 branches missed.">        if (useToString == null || useToString.length != i) {</span>
<span class="nc" id="L621">            useToString = new boolean[i];</span>
        }
<span class="nc bnc" id="L623" title="All 2 branches missed.">        for (--i; i &gt;= 0; i--) {</span>
<span class="nc" id="L624">            useToString[i] = useToString(i);</span>
        }
<span class="nc" id="L626">    }</span>

    /**
     * Resets the viewToModel and modelToView mappings based on
     * the current Filter.
     */
    private void initializeFilteredMapping() {
<span class="nc" id="L633">        int rowCount = getModelWrapper().getRowCount();</span>
        int i, j;
<span class="nc" id="L635">        int excludedCount = 0;</span>

        // Update model -&gt; view
<span class="nc" id="L638">        createModelToView(rowCount);</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">        for (i = 0; i &lt; rowCount; i++) {</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">            if (include(i)) {</span>
<span class="nc" id="L641">                modelToView[i] = i - excludedCount;</span>
            }
            else {
<span class="nc" id="L644">                modelToView[i] = -1;</span>
<span class="nc" id="L645">                excludedCount++;</span>
            }
        }

        // Update view -&gt; model
<span class="nc" id="L650">        createViewToModel(rowCount - excludedCount);</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">        for (i = 0, j = 0; i &lt; rowCount; i++) {</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (modelToView[i] != -1) {</span>
<span class="nc" id="L653">                viewToModel[j++].modelIndex = i;</span>
            }
        }
<span class="nc" id="L656">    }</span>

    /**
     * Makes sure the modelToView array is of size rowCount.
     */
    private void createModelToView(int rowCount) {
<span class="nc bnc" id="L662" title="All 4 branches missed.">        if (modelToView == null || modelToView.length != rowCount) {</span>
<span class="nc" id="L663">            modelToView = new int[rowCount];</span>
        }
<span class="nc" id="L665">    }</span>

    /**
     * Resets the viewToModel array to be of size rowCount.
     */
    private void createViewToModel(int rowCount) {
<span class="nc" id="L671">        int recreateFrom = 0;</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (viewToModel != null) {</span>
<span class="nc" id="L673">            recreateFrom = Math.min(rowCount, viewToModel.length);</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">            if (viewToModel.length != rowCount) {</span>
<span class="nc" id="L675">                Row[] oldViewToModel = viewToModel;</span>
<span class="nc" id="L676">                viewToModel = new Row[rowCount];</span>
<span class="nc" id="L677">                System.arraycopy(oldViewToModel, 0, viewToModel,</span>
                                 0, recreateFrom);
<span class="nc" id="L679">            }</span>
        }
        else {
<span class="nc" id="L682">            viewToModel = new Row[rowCount];</span>
        }
        int i;
<span class="nc bnc" id="L685" title="All 2 branches missed.">        for (i = 0; i &lt; recreateFrom; i++) {</span>
<span class="nc" id="L686">            viewToModel[i].modelIndex = i;</span>
        }
<span class="nc bnc" id="L688" title="All 2 branches missed.">        for (i = recreateFrom; i &lt; rowCount; i++) {</span>
<span class="nc" id="L689">            viewToModel[i] = new Row(this, i);</span>
        }
<span class="nc" id="L691">    }</span>

    /**
     * Caches the sort keys before a sort.
     */
    private void cacheSortKeys(List&lt;? extends SortKey&gt; keys) {
<span class="nc" id="L697">        int keySize = keys.size();</span>
<span class="nc" id="L698">        sortComparators = new Comparator[keySize];</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">        for (int i = 0; i &lt; keySize; i++) {</span>
<span class="nc" id="L700">            sortComparators[i] = getComparator0(keys.get(i).getColumn());</span>
        }
<span class="nc" id="L702">        cachedSortKeys = keys.toArray(new SortKey[keySize]);</span>
<span class="nc" id="L703">    }</span>

    /**
     * Returns whether or not to convert the value to a string before
     * doing comparisons when sorting.  If true
     * &lt;code&gt;ModelWrapper.getStringValueAt&lt;/code&gt; will be used, otherwise
     * &lt;code&gt;ModelWrapper.getValueAt&lt;/code&gt; will be used.  It is up to
     * subclasses, such as &lt;code&gt;TableRowSorter&lt;/code&gt;, to honor this value
     * in their &lt;code&gt;ModelWrapper&lt;/code&gt; implementation.
     *
     * @param column the index of the column to test, in terms of the
     *        underlying model
     * @throws IndexOutOfBoundsException if &lt;code&gt;column&lt;/code&gt; is not valid
     */
    protected boolean useToString(int column) {
<span class="nc bnc" id="L718" title="All 2 branches missed.">        return (getComparator(column) == null);</span>
    }

    /**
     * Refreshes the modelToView mapping from that of viewToModel.
     * If &lt;code&gt;unsetFirst&lt;/code&gt; is true, all indices in modelToView are
     * first set to -1.
     */
    private void setModelToViewFromViewToModel(boolean unsetFirst) {
        int i;
<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (unsetFirst) {</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">            for (i = modelToView.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L730">                modelToView[i] = -1;</span>
            }
        }
<span class="nc bnc" id="L733" title="All 2 branches missed.">        for (i = viewToModel.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L734">            modelToView[viewToModel[i].modelIndex] = i;</span>
        }
<span class="nc" id="L736">    }</span>

    private int[] getViewToModelAsInts(Row[] viewToModel) {
<span class="nc bnc" id="L739" title="All 2 branches missed.">        if (viewToModel != null) {</span>
<span class="nc" id="L740">            int[] viewToModelI = new int[viewToModel.length];</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">            for (int i = viewToModel.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L742">                viewToModelI[i] = viewToModel[i].modelIndex;</span>
            }
<span class="nc" id="L744">            return viewToModelI;</span>
        }
<span class="nc" id="L746">        return new int[0];</span>
    }

    /**
     * Sets the &lt;code&gt;Comparator&lt;/code&gt; to use when sorting the specified
     * column.  This does not trigger a sort.  If you want to sort after
     * setting the comparator you need to explicitly invoke &lt;code&gt;sort&lt;/code&gt;.
     *
     * @param column the index of the column the &lt;code&gt;Comparator&lt;/code&gt; is
     *        to be used for, in terms of the underlying model
     * @param comparator the &lt;code&gt;Comparator&lt;/code&gt; to use
     * @throws IndexOutOfBoundsException if &lt;code&gt;column&lt;/code&gt; is outside
     *         the range of the underlying model
     */
    public void setComparator(int column, Comparator&lt;?&gt; comparator) {
<span class="nc" id="L761">        checkColumn(column);</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">        if (comparators == null) {</span>
<span class="nc" id="L763">            comparators = new Comparator[getModelWrapper().getColumnCount()];</span>
        }
<span class="nc" id="L765">        comparators[column] = comparator;</span>
<span class="nc" id="L766">    }</span>

    /**
     * Returns the &lt;code&gt;Comparator&lt;/code&gt; for the specified
     * column.  This will return &lt;code&gt;null&lt;/code&gt; if a &lt;code&gt;Comparator&lt;/code&gt;
     * has not been specified for the column.
     *
     * @param column the column to fetch the &lt;code&gt;Comparator&lt;/code&gt; for, in
     *        terms of the underlying model
     * @return the &lt;code&gt;Comparator&lt;/code&gt; for the specified column
     * @throws IndexOutOfBoundsException if column is outside
     *         the range of the underlying model
     */
    public Comparator&lt;?&gt; getComparator(int column) {
<span class="nc" id="L780">        checkColumn(column);</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">        if (comparators != null) {</span>
<span class="nc" id="L782">            return comparators[column];</span>
        }
<span class="nc" id="L784">        return null;</span>
    }

    // Returns the Comparator to use during sorting.  Where as
    // getComparator() may return null, this will never return null.
    private Comparator getComparator0(int column) {
<span class="nc" id="L790">        Comparator comparator = getComparator(column);</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">        if (comparator != null) {</span>
<span class="nc" id="L792">            return comparator;</span>
        }
        // This should be ok as useToString(column) should have returned
        // true in this case.
<span class="nc" id="L796">        return Collator.getInstance();</span>
    }

    private RowFilter.Entry&lt;M,I&gt; getFilterEntry(int modelIndex) {
<span class="nc bnc" id="L800" title="All 2 branches missed.">        if (filterEntry == null) {</span>
<span class="nc" id="L801">            filterEntry = new FilterEntry();</span>
        }
<span class="nc" id="L803">        filterEntry.modelIndex = modelIndex;</span>
<span class="nc" id="L804">        return filterEntry;</span>
    }

    /**
     * {@inheritDoc}
     */
    public int getViewRowCount() {
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (viewToModel != null) {</span>
            // When filtering this may differ from getModelWrapper().getRowCount()
<span class="nc" id="L813">            return viewToModel.length;</span>
        }
<span class="nc" id="L815">        return getModelWrapper().getRowCount();</span>
    }

    /**
     * {@inheritDoc}
     */
    public int getModelRowCount() {
<span class="nc" id="L822">        return getModelWrapper().getRowCount();</span>
    }

    private void allChanged() {
<span class="nc" id="L826">        modelToView = null;</span>
<span class="nc" id="L827">        viewToModel = null;</span>
<span class="nc" id="L828">        comparators = null;</span>
<span class="nc" id="L829">        isSortable = null;</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (isUnsorted()) {</span>
            // Keys are already empty, to force a resort we have to
            // call sort
<span class="nc" id="L833">            sort();</span>
        } else {
<span class="nc" id="L835">            setSortKeys(null);</span>
        }
<span class="nc" id="L837">    }</span>

    /**
     * {@inheritDoc}
     */
    public void modelStructureChanged() {
<span class="nc" id="L843">        allChanged();</span>
<span class="nc" id="L844">        modelRowCount = getModelWrapper().getRowCount();</span>
<span class="nc" id="L845">    }</span>

    /**
     * {@inheritDoc}
     */
    public void allRowsChanged() {
<span class="nc" id="L851">        modelRowCount = getModelWrapper().getRowCount();</span>
<span class="nc" id="L852">        sort();</span>
<span class="nc" id="L853">    }</span>

    /**
     * {@inheritDoc}
     *
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public void rowsInserted(int firstRow, int endRow) {
<span class="nc" id="L861">        checkAgainstModel(firstRow, endRow);</span>
<span class="nc" id="L862">        int newModelRowCount = getModelWrapper().getRowCount();</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">        if (endRow &gt;= newModelRowCount) {</span>
<span class="nc" id="L864">            throw new IndexOutOfBoundsException(&quot;Invalid range&quot;);</span>
        }
<span class="nc" id="L866">        modelRowCount = newModelRowCount;</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">        if (shouldOptimizeChange(firstRow, endRow)) {</span>
<span class="nc" id="L868">            rowsInserted0(firstRow, endRow);</span>
        }
<span class="nc" id="L870">    }</span>

    /**
     * {@inheritDoc}
     *
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public void rowsDeleted(int firstRow, int endRow) {
<span class="nc" id="L878">        checkAgainstModel(firstRow, endRow);</span>
<span class="nc bnc" id="L879" title="All 4 branches missed.">        if (firstRow &gt;= modelRowCount || endRow &gt;= modelRowCount) {</span>
<span class="nc" id="L880">            throw new IndexOutOfBoundsException(&quot;Invalid range&quot;);</span>
        }
<span class="nc" id="L882">        modelRowCount = getModelWrapper().getRowCount();</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">        if (shouldOptimizeChange(firstRow, endRow)) {</span>
<span class="nc" id="L884">            rowsDeleted0(firstRow, endRow);</span>
        }
<span class="nc" id="L886">    }</span>

    /**
     * {@inheritDoc}
     *
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public void rowsUpdated(int firstRow, int endRow) {
<span class="nc" id="L894">        checkAgainstModel(firstRow, endRow);</span>
<span class="nc bnc" id="L895" title="All 4 branches missed.">        if (firstRow &gt;= modelRowCount || endRow &gt;= modelRowCount) {</span>
<span class="nc" id="L896">            throw new IndexOutOfBoundsException(&quot;Invalid range&quot;);</span>
        }
<span class="nc bnc" id="L898" title="All 2 branches missed.">        if (getSortsOnUpdates()) {</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            if (shouldOptimizeChange(firstRow, endRow)) {</span>
<span class="nc" id="L900">                rowsUpdated0(firstRow, endRow);</span>
            }
        }
        else {
<span class="nc" id="L904">            sorted = false;</span>
        }
<span class="nc" id="L906">    }</span>

    /**
     * {@inheritDoc}
     *
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public void rowsUpdated(int firstRow, int endRow, int column) {
<span class="nc" id="L914">        checkColumn(column);</span>
<span class="nc" id="L915">        rowsUpdated(firstRow, endRow);</span>
<span class="nc" id="L916">    }</span>

    private void checkAgainstModel(int firstRow, int endRow) {
<span class="nc bnc" id="L919" title="All 8 branches missed.">        if (firstRow &gt; endRow || firstRow &lt; 0 || endRow &lt; 0 ||</span>
                firstRow &gt; modelRowCount) {
<span class="nc" id="L921">            throw new IndexOutOfBoundsException(&quot;Invalid range&quot;);</span>
        }
<span class="nc" id="L923">    }</span>

    /**
     * Returns true if the specified row should be included.
     */
    private boolean include(int row) {
<span class="nc" id="L929">        RowFilter&lt;? super M, ? super I&gt; filter = getRowFilter();</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if (filter != null) {</span>
<span class="nc" id="L931">            return filter.include(getFilterEntry(row));</span>
        }
        // null filter, always include the row.
<span class="nc" id="L934">        return true;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private int compare(int model1, int model2) {
        int column;
        SortOrder sortOrder;
        Object v1, v2;
        int result;

<span class="nc bnc" id="L944" title="All 2 branches missed.">        for (int counter = 0; counter &lt; cachedSortKeys.length; counter++) {</span>
<span class="nc" id="L945">            column = cachedSortKeys[counter].getColumn();</span>
<span class="nc" id="L946">            sortOrder = cachedSortKeys[counter].getSortOrder();</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">            if (sortOrder == SortOrder.UNSORTED) {</span>
<span class="nc" id="L948">                result = model1 - model2;</span>
            } else {
                // v1 != null &amp;&amp; v2 != null
<span class="nc bnc" id="L951" title="All 2 branches missed.">                if (useToString[column]) {</span>
<span class="nc" id="L952">                    v1 = getModelWrapper().getStringValueAt(model1, column);</span>
<span class="nc" id="L953">                    v2 = getModelWrapper().getStringValueAt(model2, column);</span>
                } else {
<span class="nc" id="L955">                    v1 = getModelWrapper().getValueAt(model1, column);</span>
<span class="nc" id="L956">                    v2 = getModelWrapper().getValueAt(model2, column);</span>
                }
                // Treat nulls as &lt; then non-null
<span class="nc bnc" id="L959" title="All 2 branches missed.">                if (v1 == null) {</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">                    if (v2 == null) {</span>
<span class="nc" id="L961">                        result = 0;</span>
                    } else {
<span class="nc" id="L963">                        result = -1;</span>
                    }
<span class="nc bnc" id="L965" title="All 2 branches missed.">                } else if (v2 == null) {</span>
<span class="nc" id="L966">                    result = 1;</span>
                } else {
<span class="nc" id="L968">                    result = sortComparators[counter].compare(v1, v2);</span>
                }
<span class="nc bnc" id="L970" title="All 2 branches missed.">                if (sortOrder == SortOrder.DESCENDING) {</span>
<span class="nc" id="L971">                    result *= -1;</span>
                }
            }
<span class="nc bnc" id="L974" title="All 2 branches missed.">            if (result != 0) {</span>
<span class="nc" id="L975">                return result;</span>
            }
        }
        // If we get here, they're equal. Fallback to model order.
<span class="nc" id="L979">        return model1 - model2;</span>
    }

    /**
     * Whether not we are filtering/sorting.
     */
    private boolean isTransformed() {
<span class="nc bnc" id="L986" title="All 2 branches missed.">        return (viewToModel != null);</span>
    }

    /**
     * Insets new set of entries.
     *
     * @param toAdd the Rows to add, sorted
     * @param current the array to insert the items into
     */
    private void insertInOrder(List&lt;Row&gt; toAdd, Row[] current) {
<span class="nc" id="L996">        int last = 0;</span>
        int index;
<span class="nc" id="L998">        int max = toAdd.size();</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">        for (int i = 0; i &lt; max; i++) {</span>
<span class="nc" id="L1000">            index = Arrays.binarySearch(current, toAdd.get(i));</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            if (index &lt; 0) {</span>
<span class="nc" id="L1002">                index = -1 - index;</span>
            }
<span class="nc" id="L1004">            System.arraycopy(current, last,</span>
                             viewToModel, last + i, index - last);
<span class="nc" id="L1006">            viewToModel[index + i] = toAdd.get(i);</span>
<span class="nc" id="L1007">            last = index;</span>
        }
<span class="nc" id="L1009">        System.arraycopy(current, last, viewToModel, last + max,</span>
                         current.length - last);
<span class="nc" id="L1011">    }</span>

    /**
     * Returns true if we should try and optimize the processing of the
     * &lt;code&gt;TableModelEvent&lt;/code&gt;.  If this returns false, assume the
     * event was dealt with and no further processing needs to happen.
     */
    private boolean shouldOptimizeChange(int firstRow, int lastRow) {
<span class="nc bnc" id="L1019" title="All 2 branches missed.">        if (!isTransformed()) {</span>
            // Not transformed, nothing to do.
<span class="nc" id="L1021">            return false;</span>
        }
<span class="nc bnc" id="L1023" title="All 4 branches missed.">        if (!sorted || (lastRow - firstRow) &gt; viewToModel.length / 10) {</span>
            // We either weren't sorted, or to much changed, sort it all
<span class="nc" id="L1025">            sort();</span>
<span class="nc" id="L1026">            return false;</span>
        }
<span class="nc" id="L1028">        return true;</span>
    }

    private void rowsInserted0(int firstRow, int lastRow) {
<span class="nc" id="L1032">        int[] oldViewToModel = getViewToModelAsInts(viewToModel);</span>
        int i;
<span class="nc" id="L1034">        int delta = (lastRow - firstRow) + 1;</span>
<span class="nc" id="L1035">        List&lt;Row&gt; added = new ArrayList&lt;Row&gt;(delta);</span>

        // Build the list of Rows to add into added
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        for (i = firstRow; i &lt;= lastRow; i++) {</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            if (include(i)) {</span>
<span class="nc" id="L1040">                added.add(new Row(this, i));</span>
            }
        }

        // Adjust the model index of rows after the effected region
        int viewIndex;
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        for (i = modelToView.length - 1; i &gt;= firstRow; i--) {</span>
<span class="nc" id="L1047">            viewIndex = modelToView[i];</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">            if (viewIndex != -1) {</span>
<span class="nc" id="L1049">                viewToModel[viewIndex].modelIndex += delta;</span>
            }
        }

        // Insert newly added rows into viewToModel
<span class="nc bnc" id="L1054" title="All 2 branches missed.">        if (added.size() &gt; 0) {</span>
<span class="nc" id="L1055">            Collections.sort(added);</span>
<span class="nc" id="L1056">            Row[] lastViewToModel = viewToModel;</span>
<span class="nc" id="L1057">            viewToModel = new Row[viewToModel.length + added.size()];</span>
<span class="nc" id="L1058">            insertInOrder(added, lastViewToModel);</span>
        }

        // Update modelToView
<span class="nc" id="L1062">        createModelToView(getModelWrapper().getRowCount());</span>
<span class="nc" id="L1063">        setModelToViewFromViewToModel(true);</span>

        // Notify of change
<span class="nc" id="L1066">        fireRowSorterChanged(oldViewToModel);</span>
<span class="nc" id="L1067">    }</span>

    private void rowsDeleted0(int firstRow, int lastRow) {
<span class="nc" id="L1070">        int[] oldViewToModel = getViewToModelAsInts(viewToModel);</span>
<span class="nc" id="L1071">        int removedFromView = 0;</span>
        int i;
        int viewIndex;

        // Figure out how many visible rows are going to be effected.
<span class="nc bnc" id="L1076" title="All 2 branches missed.">        for (i = firstRow; i &lt;= lastRow; i++) {</span>
<span class="nc" id="L1077">            viewIndex = modelToView[i];</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">            if (viewIndex != -1) {</span>
<span class="nc" id="L1079">                removedFromView++;</span>
<span class="nc" id="L1080">                viewToModel[viewIndex] = null;</span>
            }
        }

        // Update the model index of rows after the effected region
<span class="nc" id="L1085">        int delta = lastRow - firstRow + 1;</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">        for (i = modelToView.length - 1; i &gt; lastRow; i--) {</span>
<span class="nc" id="L1087">            viewIndex = modelToView[i];</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">            if (viewIndex != -1) {</span>
<span class="nc" id="L1089">                viewToModel[viewIndex].modelIndex -= delta;</span>
            }
        }

        // Then patch up the viewToModel array
<span class="nc bnc" id="L1094" title="All 2 branches missed.">        if (removedFromView &gt; 0) {</span>
<span class="nc" id="L1095">            Row[] newViewToModel = new Row[viewToModel.length -</span>
                                           removedFromView];
<span class="nc" id="L1097">            int newIndex = 0;</span>
<span class="nc" id="L1098">            int last = 0;</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">            for (i = 0; i &lt; viewToModel.length; i++) {</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                if (viewToModel[i] == null) {</span>
<span class="nc" id="L1101">                    System.arraycopy(viewToModel, last,</span>
                                     newViewToModel, newIndex, i - last);
<span class="nc" id="L1103">                    newIndex += (i - last);</span>
<span class="nc" id="L1104">                    last = i + 1;</span>
                }
            }
<span class="nc" id="L1107">            System.arraycopy(viewToModel, last,</span>
                    newViewToModel, newIndex, viewToModel.length - last);
<span class="nc" id="L1109">            viewToModel = newViewToModel;</span>
        }

        // Update the modelToView mapping
<span class="nc" id="L1113">        createModelToView(getModelWrapper().getRowCount());</span>
<span class="nc" id="L1114">        setModelToViewFromViewToModel(true);</span>

        // And notify of change
<span class="nc" id="L1117">        fireRowSorterChanged(oldViewToModel);</span>
<span class="nc" id="L1118">    }</span>

    private void rowsUpdated0(int firstRow, int lastRow) {
<span class="nc" id="L1121">        int[] oldViewToModel = getViewToModelAsInts(viewToModel);</span>
        int i, j;
<span class="nc" id="L1123">        int delta = lastRow - firstRow + 1;</span>
        int modelIndex;
        int last;
        int index;

<span class="nc bnc" id="L1128" title="All 2 branches missed.">        if (getRowFilter() == null) {</span>
            // Sorting only:

            // Remove the effected rows
<span class="nc" id="L1132">            Row[] updated = new Row[delta];</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">            for (j = 0, i = firstRow; i &lt;= lastRow; i++, j++) {</span>
<span class="nc" id="L1134">                updated[j] = viewToModel[modelToView[i]];</span>
            }

            // Sort the update rows
<span class="nc" id="L1138">            Arrays.sort(updated);</span>

            // Build the intermediary array: the array of
            // viewToModel without the effected rows.
<span class="nc" id="L1142">            Row[] intermediary = new Row[viewToModel.length - delta];</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">            for (i = 0, j = 0; i &lt; viewToModel.length; i++) {</span>
<span class="nc" id="L1144">                modelIndex = viewToModel[i].modelIndex;</span>
<span class="nc bnc" id="L1145" title="All 4 branches missed.">                if (modelIndex &lt; firstRow || modelIndex &gt; lastRow) {</span>
<span class="nc" id="L1146">                    intermediary[j++] = viewToModel[i];</span>
                }
            }

            // Build the new viewToModel
<span class="nc" id="L1151">            insertInOrder(Arrays.asList(updated), intermediary);</span>

            // Update modelToView
<span class="nc" id="L1154">            setModelToViewFromViewToModel(false);</span>
<span class="nc" id="L1155">        }</span>
        else {
            // Sorting &amp; filtering.

            // Remove the effected rows, adding them to updated and setting
            // modelToView to -2 for any rows that were not filtered out
<span class="nc" id="L1161">            List&lt;Row&gt; updated = new ArrayList&lt;Row&gt;(delta);</span>
<span class="nc" id="L1162">            int newlyVisible = 0;</span>
<span class="nc" id="L1163">            int newlyHidden = 0;</span>
<span class="nc" id="L1164">            int effected = 0;</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">            for (i = firstRow; i &lt;= lastRow; i++) {</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                if (modelToView[i] == -1) {</span>
                    // This row was filtered out
<span class="nc bnc" id="L1168" title="All 2 branches missed.">                    if (include(i)) {</span>
                        // No longer filtered
<span class="nc" id="L1170">                        updated.add(new Row(this, i));</span>
<span class="nc" id="L1171">                        newlyVisible++;</span>
                    }
                }
                else {
                    // This row was visible, make sure it should still be
                    // visible.
<span class="nc bnc" id="L1177" title="All 2 branches missed.">                    if (!include(i)) {</span>
<span class="nc" id="L1178">                        newlyHidden++;</span>
                    }
                    else {
<span class="nc" id="L1181">                        updated.add(viewToModel[modelToView[i]]);</span>
                    }
<span class="nc" id="L1183">                    modelToView[i] = -2;</span>
<span class="nc" id="L1184">                    effected++;</span>
                }
            }

            // Sort the updated rows
<span class="nc" id="L1189">            Collections.sort(updated);</span>

            // Build the intermediary array: the array of
            // viewToModel without the updated rows.
<span class="nc" id="L1193">            Row[] intermediary = new Row[viewToModel.length - effected];</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">            for (i = 0, j = 0; i &lt; viewToModel.length; i++) {</span>
<span class="nc" id="L1195">                modelIndex = viewToModel[i].modelIndex;</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">                if (modelToView[modelIndex] != -2) {</span>
<span class="nc" id="L1197">                    intermediary[j++] = viewToModel[i];</span>
                }
            }

            // Recreate viewToModel, if necessary
<span class="nc bnc" id="L1202" title="All 2 branches missed.">            if (newlyVisible != newlyHidden) {</span>
<span class="nc" id="L1203">                viewToModel = new Row[viewToModel.length + newlyVisible -</span>
                                      newlyHidden];
            }

            // Rebuild the new viewToModel array
<span class="nc" id="L1208">            insertInOrder(updated, intermediary);</span>

            // Update modelToView
<span class="nc" id="L1211">            setModelToViewFromViewToModel(true);</span>
        }
        // And finally fire a sort event.
<span class="nc" id="L1214">        fireRowSorterChanged(oldViewToModel);</span>
<span class="nc" id="L1215">    }</span>

    private void checkColumn(int column) {
<span class="nc bnc" id="L1218" title="All 4 branches missed.">        if (column &lt; 0 || column &gt;= getModelWrapper().getColumnCount()) {</span>
<span class="nc" id="L1219">            throw new IndexOutOfBoundsException(</span>
                    &quot;column beyond range of TableModel&quot;);
        }
<span class="nc" id="L1222">    }</span>


    /**
     * &lt;code&gt;DefaultRowSorter.ModelWrapper&lt;/code&gt; is responsible for providing
     * the data that gets sorted by &lt;code&gt;DefaultRowSorter&lt;/code&gt;.  You
     * normally do not interact directly with &lt;code&gt;ModelWrapper&lt;/code&gt;.
     * Subclasses of &lt;code&gt;DefaultRowSorter&lt;/code&gt; provide an
     * implementation of &lt;code&gt;ModelWrapper&lt;/code&gt; wrapping another model.
     * For example,
     * &lt;code&gt;TableRowSorter&lt;/code&gt; provides a &lt;code&gt;ModelWrapper&lt;/code&gt; that
     * wraps a &lt;code&gt;TableModel&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;code&gt;ModelWrapper&lt;/code&gt; makes a distinction between values as
     * &lt;code&gt;Object&lt;/code&gt;s and &lt;code&gt;String&lt;/code&gt;s.  This allows
     * implementations to provide a custom string
     * converter to be used instead of invoking &lt;code&gt;toString&lt;/code&gt; on the
     * object.
     *
     * @param &lt;M&gt; the type of the underlying model
     * @param &lt;I&gt; the identifier supplied to the filter
     * @since 1.6
     * @see RowFilter
     * @see RowFilter.Entry
     */
    protected abstract static class ModelWrapper&lt;M,I&gt; {
        /**
         * Creates a new &lt;code&gt;ModelWrapper&lt;/code&gt;.
         */
<span class="nc" id="L1251">        protected ModelWrapper() {</span>
<span class="nc" id="L1252">        }</span>

        /**
         * Returns the underlying model that this &lt;code&gt;Model&lt;/code&gt; is
         * wrapping.
         *
         * @return the underlying model
         */
        public abstract M getModel();

        /**
         * Returns the number of columns in the model.
         *
         * @return the number of columns in the model
         */
        public abstract int getColumnCount();

        /**
         * Returns the number of rows in the model.
         *
         * @return the number of rows in the model
         */
        public abstract int getRowCount();

        /**
         * Returns the value at the specified index.
         *
         * @param row the row index
         * @param column the column index
         * @return the value at the specified index
         * @throws IndexOutOfBoundsException if the indices are outside
         *         the range of the model
         */
        public abstract Object getValueAt(int row, int column);

        /**
         * Returns the value as a &lt;code&gt;String&lt;/code&gt; at the specified
         * index.  This implementation uses &lt;code&gt;toString&lt;/code&gt; on
         * the result from &lt;code&gt;getValueAt&lt;/code&gt; (making sure
         * to return an empty string for null values).  Subclasses that
         * override this method should never return null.
         *
         * @param row the row index
         * @param column the column index
         * @return the value at the specified index as a &lt;code&gt;String&lt;/code&gt;
         * @throws IndexOutOfBoundsException if the indices are outside
         *         the range of the model
         */
        public String getStringValueAt(int row, int column) {
<span class="nc" id="L1301">            Object o = getValueAt(row, column);</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">            if (o == null) {</span>
<span class="nc" id="L1303">                return &quot;&quot;;</span>
            }
<span class="nc" id="L1305">            String string = o.toString();</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">            if (string == null) {</span>
<span class="nc" id="L1307">                return &quot;&quot;;</span>
            }
<span class="nc" id="L1309">            return string;</span>
        }

        /**
         * Returns the identifier for the specified row.  The return value
         * of this is used as the identifier for the
         * &lt;code&gt;RowFilter.Entry&lt;/code&gt; that is passed to the
         * &lt;code&gt;RowFilter&lt;/code&gt;.
         *
         * @param row the row to return the identifier for, in terms of
         *            the underlying model
         * @return the identifier
         * @see RowFilter.Entry#getIdentifier
         */
        public abstract I getIdentifier(int row);
    }


    /**
     * RowFilter.Entry implementation that delegates to the ModelWrapper.
     * getFilterEntry(int) creates the single instance of this that is
     * passed to the Filter.  Only call getFilterEntry(int) to get
     * the instance.
     */
<span class="nc" id="L1333">    private class FilterEntry extends RowFilter.Entry&lt;M,I&gt; {</span>
        /**
         * The index into the model, set in getFilterEntry
         */
        int modelIndex;

        public M getModel() {
<span class="nc" id="L1340">            return getModelWrapper().getModel();</span>
        }

        public int getValueCount() {
<span class="nc" id="L1344">            return getModelWrapper().getColumnCount();</span>
        }

        public Object getValue(int index) {
<span class="nc" id="L1348">            return getModelWrapper().getValueAt(modelIndex, index);</span>
        }

        public String getStringValue(int index) {
<span class="nc" id="L1352">            return getModelWrapper().getStringValueAt(modelIndex, index);</span>
        }

        public I getIdentifier() {
<span class="nc" id="L1356">            return getModelWrapper().getIdentifier(modelIndex);</span>
        }
    }


    /**
     * Row is used to handle the actual sorting by way of Comparable.  It
     * will use the sortKeys to do the actual comparison.
     */
    // NOTE: this class is static so that it can be placed in an array
    private static class Row implements Comparable&lt;Row&gt; {
        private DefaultRowSorter sorter;
        int modelIndex;

<span class="nc" id="L1370">        public Row(DefaultRowSorter sorter, int index) {</span>
<span class="nc" id="L1371">            this.sorter = sorter;</span>
<span class="nc" id="L1372">            modelIndex = index;</span>
<span class="nc" id="L1373">        }</span>

        public int compareTo(Row o) {
<span class="nc" id="L1376">            return sorter.compare(modelIndex, o.modelIndex);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>