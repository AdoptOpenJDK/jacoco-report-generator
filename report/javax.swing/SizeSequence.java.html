<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SizeSequence.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">SizeSequence.java</span></div><h1>SizeSequence.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing;

/**
 * A &lt;code&gt;SizeSequence&lt;/code&gt; object
 * efficiently maintains an ordered list
 * of sizes and corresponding positions.
 * One situation for which &lt;code&gt;SizeSequence&lt;/code&gt;
 * might be appropriate is in a component
 * that displays multiple rows of unequal size.
 * In this case, a single &lt;code&gt;SizeSequence&lt;/code&gt;
 * object could be used to track the heights
 * and Y positions of all rows.
 * &lt;p&gt;
 * Another example would be a multi-column component,
 * such as a &lt;code&gt;JTable&lt;/code&gt;,
 * in which the column sizes are not all equal.
 * The &lt;code&gt;JTable&lt;/code&gt; might use a single
 * &lt;code&gt;SizeSequence&lt;/code&gt; object
 * to store the widths and X positions of all the columns.
 * The &lt;code&gt;JTable&lt;/code&gt; could then use the
 * &lt;code&gt;SizeSequence&lt;/code&gt; object
 * to find the column corresponding to a certain position.
 * The &lt;code&gt;JTable&lt;/code&gt; could update the
 * &lt;code&gt;SizeSequence&lt;/code&gt; object
 * whenever one or more column sizes changed.
 *
 * &lt;p&gt;
 * The following figure shows the relationship between size and position data
 * for a multi-column component.
 * &lt;p&gt;
 * &lt;center&gt;
 * &lt;img src=&quot;doc-files/SizeSequence-1.gif&quot; width=384 height = 100
 * alt=&quot;The first item begins at position 0, the second at the position equal
 to the size of the previous item, and so on.&quot;&gt;
 * &lt;/center&gt;
 * &lt;p&gt;
 * In the figure, the first index (0) corresponds to the first column,
 * the second index (1) to the second column, and so on.
 * The first column's position starts at 0,
 * and the column occupies &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; pixels,
 * where &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; is the value returned by
 * &lt;code&gt;getSize(0)&lt;/code&gt;.
 * Thus, the first column ends at &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; - 1.
 * The second column then begins at
 * the position &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt;
 * and occupies &lt;em&gt;size&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; (&lt;code&gt;getSize(1)&lt;/code&gt;) pixels.
 * &lt;p&gt;
 * Note that a &lt;code&gt;SizeSequence&lt;/code&gt; object simply represents intervals
 * along an axis.
 * In our examples, the intervals represent height or width in pixels.
 * However, any other unit of measure (for example, time in days)
 * could be just as valid.
 *
 * &lt;p&gt;
 *
 * &lt;h3&gt;Implementation Notes&lt;/h3&gt;
 *
 * Normally when storing the size and position of entries,
 * one would choose between
 * storing the sizes or storing their positions
 * instead. The two common operations that are needed during
 * rendering are: &lt;code&gt;getIndex(position)&lt;/code&gt;
 * and &lt;code&gt;setSize(index, size)&lt;/code&gt;.
 * Whichever choice of internal format is made one of these
 * operations is costly when the number of entries becomes large.
 * If sizes are stored, finding the index of the entry
 * that encloses a particular position is linear in the
 * number of entries. If positions are stored instead, setting
 * the size of an entry at a particular index requires updating
 * the positions of the affected entries, which is also a linear
 * calculation.
 * &lt;p&gt;
 * Like the above techniques this class holds an array of N integers
 * internally but uses a hybrid encoding, which is halfway
 * between the size-based and positional-based approaches.
 * The result is a data structure that takes the same space to store
 * the information but can perform most operations in Log(N) time
 * instead of O(N), where N is the number of entries in the list.
 * &lt;p&gt;
 * Two operations that remain O(N) in the number of entries are
 * the &lt;code&gt;insertEntries&lt;/code&gt;
 * and &lt;code&gt;removeEntries&lt;/code&gt; methods, both
 * of which are implemented by converting the internal array to
 * a set of integer sizes, copying it into the new array, and then
 * reforming the hybrid representation in place.
 *
 * @author Philip Milne
 * @since 1.3
 */

/*
 *   Each method is implemented by taking the minimum and
 *   maximum of the range of integers that need to be operated
 *   upon. All the algorithms work by dividing this range
 *   into two smaller ranges and recursing. The recursion
 *   is terminated when the upper and lower bounds are equal.
 */

public class SizeSequence {

<span class="nc" id="L126">    private static int[] emptyArray = new int[0];</span>
    private int a[];

    /**
     * Creates a new &lt;code&gt;SizeSequence&lt;/code&gt; object
     * that contains no entries.  To add entries, you
     * can use &lt;code&gt;insertEntries&lt;/code&gt; or &lt;code&gt;setSizes&lt;/code&gt;.
     *
     * @see #insertEntries
     * @see #setSizes(int[])
     */
<span class="nc" id="L137">    public SizeSequence() {</span>
<span class="nc" id="L138">        a = emptyArray;</span>
<span class="nc" id="L139">    }</span>

    /**
     * Creates a new &lt;code&gt;SizeSequence&lt;/code&gt; object
     * that contains the specified number of entries,
     * all initialized to have size 0.
     *
     * @param numEntries  the number of sizes to track
     * @exception NegativeArraySizeException if
     *    &lt;code&gt;numEntries &amp;lt; 0&lt;/code&gt;
     */
    public SizeSequence(int numEntries) {
<span class="nc" id="L151">        this(numEntries, 0);</span>
<span class="nc" id="L152">    }</span>

    /**
     * Creates a new &lt;code&gt;SizeSequence&lt;/code&gt; object
     * that contains the specified number of entries,
     * all initialized to have size &lt;code&gt;value&lt;/code&gt;.
     *
     * @param numEntries  the number of sizes to track
     * @param value       the initial value of each size
     */
    public SizeSequence(int numEntries, int value) {
<span class="nc" id="L163">        this();</span>
<span class="nc" id="L164">        insertEntries(0, numEntries, value);</span>
<span class="nc" id="L165">    }</span>

    /**
     * Creates a new &lt;code&gt;SizeSequence&lt;/code&gt; object
     * that contains the specified sizes.
     *
     * @param sizes  the array of sizes to be contained in
     *               the &lt;code&gt;SizeSequence&lt;/code&gt;
     */
    public SizeSequence(int[] sizes) {
<span class="nc" id="L175">        this();</span>
<span class="nc" id="L176">        setSizes(sizes);</span>
<span class="nc" id="L177">    }</span>

    /**
     * Resets the size sequence to contain &lt;code&gt;length&lt;/code&gt; items
     * all with a size of &lt;code&gt;size&lt;/code&gt;.
     */
    void setSizes(int length, int size) {
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (a.length != length) {</span>
<span class="nc" id="L185">            a = new int[length];</span>
        }
<span class="nc" id="L187">        setSizes(0, length, size);</span>
<span class="nc" id="L188">    }</span>

    private int setSizes(int from, int to, int size) {
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (to &lt;= from) {</span>
<span class="nc" id="L192">            return 0;</span>
        }
<span class="nc" id="L194">        int m = (from + to)/2;</span>
<span class="nc" id="L195">        a[m] = size + setSizes(from, m, size);</span>
<span class="nc" id="L196">        return a[m] + setSizes(m + 1, to, size);</span>
    }

    /**
     * Resets this &lt;code&gt;SizeSequence&lt;/code&gt; object,
     * using the data in the &lt;code&gt;sizes&lt;/code&gt; argument.
     * This method reinitializes this object so that it
     * contains as many entries as the &lt;code&gt;sizes&lt;/code&gt; array.
     * Each entry's size is initialized to the value of the
     * corresponding item in &lt;code&gt;sizes&lt;/code&gt;.
     *
     * @param sizes  the array of sizes to be contained in
     *               this &lt;code&gt;SizeSequence&lt;/code&gt;
     */
    public void setSizes(int[] sizes) {
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (a.length != sizes.length) {</span>
<span class="nc" id="L212">            a = new int[sizes.length];</span>
        }
<span class="nc" id="L214">        setSizes(0, a.length, sizes);</span>
<span class="nc" id="L215">    }</span>

    private int setSizes(int from, int to, int[] sizes) {
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (to &lt;= from) {</span>
<span class="nc" id="L219">            return 0;</span>
        }
<span class="nc" id="L221">        int m = (from + to)/2;</span>
<span class="nc" id="L222">        a[m] = sizes[m] + setSizes(from, m, sizes);</span>
<span class="nc" id="L223">        return a[m] + setSizes(m + 1, to, sizes);</span>
    }

    /**
     * Returns the size of all entries.
     *
     * @return  a new array containing the sizes in this object
     */
    public int[] getSizes() {
<span class="nc" id="L232">        int n = a.length;</span>
<span class="nc" id="L233">        int[] sizes = new int[n];</span>
<span class="nc" id="L234">        getSizes(0, n, sizes);</span>
<span class="nc" id="L235">        return sizes;</span>
    }

    private int getSizes(int from, int to, int[] sizes) {
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (to &lt;= from) {</span>
<span class="nc" id="L240">            return 0;</span>
        }
<span class="nc" id="L242">        int m = (from + to)/2;</span>
<span class="nc" id="L243">        sizes[m] = a[m] - getSizes(from, m, sizes);</span>
<span class="nc" id="L244">        return a[m] + getSizes(m + 1, to, sizes);</span>
    }

    /**
     * Returns the start position for the specified entry.
     * For example, &lt;code&gt;getPosition(0)&lt;/code&gt; returns 0,
     * &lt;code&gt;getPosition(1)&lt;/code&gt; is equal to
     *   &lt;code&gt;getSize(0)&lt;/code&gt;,
     * &lt;code&gt;getPosition(2)&lt;/code&gt; is equal to
     *   &lt;code&gt;getSize(0)&lt;/code&gt; + &lt;code&gt;getSize(1)&lt;/code&gt;,
     * and so on.
     * &lt;p&gt;Note that if &lt;code&gt;index&lt;/code&gt; is greater than
     * &lt;code&gt;length&lt;/code&gt; the value returned may
     * be meaningless.
     *
     * @param index  the index of the entry whose position is desired
     * @return       the starting position of the specified entry
     */
    public int getPosition(int index) {
<span class="nc" id="L263">        return getPosition(0, a.length, index);</span>
    }

    private int getPosition(int from, int to, int index) {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (to &lt;= from) {</span>
<span class="nc" id="L268">            return 0;</span>
        }
<span class="nc" id="L270">        int m = (from + to)/2;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (index &lt;= m) {</span>
<span class="nc" id="L272">            return getPosition(from, m, index);</span>
        }
        else {
<span class="nc" id="L275">            return a[m] + getPosition(m + 1, to, index);</span>
        }
    }

    /**
     * Returns the index of the entry
     * that corresponds to the specified position.
     * For example, &lt;code&gt;getIndex(0)&lt;/code&gt; is 0,
     * since the first entry always starts at position 0.
     *
     * @param position  the position of the entry
     * @return  the index of the entry that occupies the specified position
     */
    public int getIndex(int position) {
<span class="nc" id="L289">        return getIndex(0, a.length, position);</span>
    }

    private int getIndex(int from, int to, int position) {
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (to &lt;= from) {</span>
<span class="nc" id="L294">            return from;</span>
        }
<span class="nc" id="L296">        int m = (from + to)/2;</span>
<span class="nc" id="L297">        int pivot = a[m];</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (position &lt; pivot) {</span>
<span class="nc" id="L299">           return getIndex(from, m, position);</span>
        }
        else {
<span class="nc" id="L302">            return getIndex(m + 1, to, position - pivot);</span>
        }
    }

    /**
     * Returns the size of the specified entry.
     * If &lt;code&gt;index&lt;/code&gt; is out of the range
     * &lt;code&gt;(0 &amp;lt;= index &amp;lt; getSizes().length)&lt;/code&gt;
     * the behavior is unspecified.
     *
     * @param index  the index corresponding to the entry
     * @return  the size of the entry
     */
    public int getSize(int index) {
<span class="nc" id="L316">        return getPosition(index + 1) - getPosition(index);</span>
    }

    /**
     * Sets the size of the specified entry.
     * Note that if the value of &lt;code&gt;index&lt;/code&gt;
     * does not fall in the range:
     * &lt;code&gt;(0 &amp;lt;= index &amp;lt; getSizes().length)&lt;/code&gt;
     * the behavior is unspecified.
     *
     * @param index  the index corresponding to the entry
     * @param size   the size of the entry
     */
    public void setSize(int index, int size) {
<span class="nc" id="L330">        changeSize(0, a.length, index, size - getSize(index));</span>
<span class="nc" id="L331">    }</span>

    private void changeSize(int from, int to, int index, int delta) {
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (to &lt;= from) {</span>
<span class="nc" id="L335">            return;</span>
        }
<span class="nc" id="L337">        int m = (from + to)/2;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (index &lt;= m) {</span>
<span class="nc" id="L339">            a[m] += delta;</span>
<span class="nc" id="L340">            changeSize(from, m, index, delta);</span>
        }
        else {
<span class="nc" id="L343">            changeSize(m + 1, to, index, delta);</span>
        }
<span class="nc" id="L345">    }</span>

    /**
     * Adds a contiguous group of entries to this &lt;code&gt;SizeSequence&lt;/code&gt;.
     * Note that the values of &lt;code&gt;start&lt;/code&gt; and
     * &lt;code&gt;length&lt;/code&gt; must satisfy the following
     * conditions:  &lt;code&gt;(0 &amp;lt;= start &amp;lt; getSizes().length)
     * AND (length &amp;gt;= 0)&lt;/code&gt;.  If these conditions are
     * not met, the behavior is unspecified and an exception
     * may be thrown.
     *
     * @param start   the index to be assigned to the first entry
     *                in the group
     * @param length  the number of entries in the group
     * @param value   the size to be assigned to each new entry
     * @exception ArrayIndexOutOfBoundsException if the parameters
     *   are outside of the range:
     *   (&lt;code&gt;0 &amp;lt;= start &amp;lt; (getSizes().length)) AND (length &amp;gt;= 0)&lt;/code&gt;
     */
    public void insertEntries(int start, int length, int value) {
<span class="nc" id="L365">        int sizes[] = getSizes();</span>
<span class="nc" id="L366">        int end = start + length;</span>
<span class="nc" id="L367">        int n = a.length + length;</span>
<span class="nc" id="L368">        a = new int[n];</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">        for (int i = 0; i &lt; start; i++) {</span>
<span class="nc" id="L370">            a[i] = sizes[i] ;</span>
        }
<span class="nc bnc" id="L372" title="All 2 branches missed.">        for (int i = start; i &lt; end; i++) {</span>
<span class="nc" id="L373">            a[i] = value ;</span>
        }
<span class="nc bnc" id="L375" title="All 2 branches missed.">        for (int i = end; i &lt; n; i++) {</span>
<span class="nc" id="L376">            a[i] = sizes[i-length] ;</span>
        }
<span class="nc" id="L378">        setSizes(a);</span>
<span class="nc" id="L379">    }</span>

    /**
     * Removes a contiguous group of entries
     * from this &lt;code&gt;SizeSequence&lt;/code&gt;.
     * Note that the values of &lt;code&gt;start&lt;/code&gt; and
     * &lt;code&gt;length&lt;/code&gt; must satisfy the following
     * conditions:  &lt;code&gt;(0 &amp;lt;= start &amp;lt; getSizes().length)
     * AND (length &amp;gt;= 0)&lt;/code&gt;.  If these conditions are
     * not met, the behavior is unspecified and an exception
     * may be thrown.
     *
     * @param start   the index of the first entry to be removed
     * @param length  the number of entries to be removed
     */
    public void removeEntries(int start, int length) {
<span class="nc" id="L395">        int sizes[] = getSizes();</span>
<span class="nc" id="L396">        int end = start + length;</span>
<span class="nc" id="L397">        int n = a.length - length;</span>
<span class="nc" id="L398">        a = new int[n];</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        for (int i = 0; i &lt; start; i++) {</span>
<span class="nc" id="L400">            a[i] = sizes[i] ;</span>
        }
<span class="nc bnc" id="L402" title="All 2 branches missed.">        for (int i = start; i &lt; n; i++) {</span>
<span class="nc" id="L403">            a[i] = sizes[i+length] ;</span>
        }
<span class="nc" id="L405">        setSizes(a);</span>
<span class="nc" id="L406">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>