<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SwingUtilities.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">SwingUtilities.java</span></div><h1>SwingUtilities.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import sun.swing.SwingUtilities2;
import sun.swing.UIAction;

import java.applet.*;

import java.awt.*;
import java.awt.event.*;
import java.awt.dnd.DropTarget;

import java.util.Vector;
import java.util.Hashtable;

import java.lang.reflect.*;

import javax.accessibility.*;
import javax.swing.event.MenuDragMouseEvent;
import javax.swing.plaf.UIResource;
import javax.swing.text.View;
import java.security.AccessController;
import sun.security.action.GetPropertyAction;

import sun.awt.AppContext;

/**
 * A collection of utility methods for Swing.
 *
 * @author unknown
 */
public class SwingUtilities implements SwingConstants
{
    // These states are system-wide, rather than AppContext wide.
<span class="fc" id="L58">    private static boolean canAccessEventQueue = false;</span>
<span class="fc" id="L59">    private static boolean eventQueueTested = false;</span>

    /**
     * Indicates if we should change the drop target when a
     * {@code TransferHandler} is set.
     */
    private static boolean suppressDropSupport;

    /**
     * Indiciates if we've checked the system property for suppressing
     * drop support.
     */
    private static boolean checkedSuppressDropSupport;


    /**
     * Returns true if &lt;code&gt;setTransferHandler&lt;/code&gt; should change the
     * &lt;code&gt;DropTarget&lt;/code&gt;.
     */
    private static boolean getSuppressDropTarget() {
<span class="nc bnc" id="L79" title="All 2 branches missed.">        if (!checkedSuppressDropSupport) {</span>
<span class="nc" id="L80">            suppressDropSupport = Boolean.valueOf(</span>
<span class="nc" id="L81">                AccessController.doPrivileged(</span>
                    new GetPropertyAction(&quot;suppressSwingDropSupport&quot;)));
<span class="nc" id="L83">            checkedSuppressDropSupport = true;</span>
        }
<span class="nc" id="L85">        return suppressDropSupport;</span>
    }

    /**
     * Installs a {@code DropTarget} on the component as necessary for a
     * {@code TransferHandler} change.
     */
    static void installSwingDropTargetAsNecessary(Component c,
                                                         TransferHandler t) {

<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (!getSuppressDropTarget()) {</span>
<span class="nc" id="L96">            DropTarget dropHandler = c.getDropTarget();</span>
<span class="nc bnc" id="L97" title="All 4 branches missed.">            if ((dropHandler == null) || (dropHandler instanceof UIResource)) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                if (t == null) {</span>
<span class="nc" id="L99">                    c.setDropTarget(null);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">                } else if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L101">                    c.setDropTarget(new TransferHandler.SwingDropTarget(c));</span>
                }
            }
        }
<span class="nc" id="L105">    }</span>

    /**
     * Return true if &lt;code&gt;a&lt;/code&gt; contains &lt;code&gt;b&lt;/code&gt;
     */
    public static final boolean isRectangleContainingRectangle(Rectangle a,Rectangle b) {
<span class="nc bnc" id="L111" title="All 8 branches missed.">        return b.x &gt;= a.x &amp;&amp; (b.x + b.width) &lt;= (a.x + a.width) &amp;&amp;</span>
                b.y &gt;= a.y &amp;&amp; (b.y + b.height) &lt;= (a.y + a.height);
    }

    /**
     * Return the rectangle (0,0,bounds.width,bounds.height) for the component &lt;code&gt;aComponent&lt;/code&gt;
     */
    public static Rectangle getLocalBounds(Component aComponent) {
<span class="nc" id="L119">        Rectangle b = new Rectangle(aComponent.getBounds());</span>
<span class="nc" id="L120">        b.x = b.y = 0;</span>
<span class="nc" id="L121">        return b;</span>
    }


    /**
     * Returns the first &lt;code&gt;Window &lt;/code&gt; ancestor of &lt;code&gt;c&lt;/code&gt;, or
     * {@code null} if &lt;code&gt;c&lt;/code&gt; is not contained inside a &lt;code&gt;Window&lt;/code&gt;.
     *
     * @param c &lt;code&gt;Component&lt;/code&gt; to get &lt;code&gt;Window&lt;/code&gt; ancestor
     *        of.
     * @return the first &lt;code&gt;Window &lt;/code&gt; ancestor of &lt;code&gt;c&lt;/code&gt;, or
     *         {@code null} if &lt;code&gt;c&lt;/code&gt; is not contained inside a
     *         &lt;code&gt;Window&lt;/code&gt;.
     * @since 1.3
     */
    public static Window getWindowAncestor(Component c) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        for(Container p = c.getParent(); p != null; p = p.getParent()) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            if (p instanceof Window) {</span>
<span class="nc" id="L139">                return (Window)p;</span>
            }
        }
<span class="nc" id="L142">        return null;</span>
    }

    /**
     * Converts the location &lt;code&gt;x&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; to the
     * parents coordinate system, returning the location.
     */
    static Point convertScreenLocationToParent(Container parent,int x, int y) {
<span class="nc bnc" id="L150" title="All 2 branches missed.">        for (Container p = parent; p != null; p = p.getParent()) {</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if (p instanceof Window) {</span>
<span class="nc" id="L152">                Point point = new Point(x, y);</span>

<span class="nc" id="L154">                SwingUtilities.convertPointFromScreen(point, parent);</span>
<span class="nc" id="L155">                return point;</span>
            }
        }
<span class="nc" id="L158">        throw new Error(&quot;convertScreenLocationToParent: no window ancestor&quot;);</span>
    }

    /**
     * Convert a &lt;code&gt;aPoint&lt;/code&gt; in &lt;code&gt;source&lt;/code&gt; coordinate system to
     * &lt;code&gt;destination&lt;/code&gt; coordinate system.
     * If &lt;code&gt;source&lt;/code&gt; is {@code null}, &lt;code&gt;aPoint&lt;/code&gt; is assumed to be in &lt;code&gt;destination&lt;/code&gt;'s
     * root component coordinate system.
     * If &lt;code&gt;destination&lt;/code&gt; is {@code null}, &lt;code&gt;aPoint&lt;/code&gt; will be converted to &lt;code&gt;source&lt;/code&gt;'s
     * root component coordinate system.
     * If both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are {@code null}, return &lt;code&gt;aPoint&lt;/code&gt;
     * without any conversion.
     */
    public static Point convertPoint(Component source,Point aPoint,Component destination) {
        Point p;

<span class="nc bnc" id="L174" title="All 4 branches missed.">        if(source == null &amp;&amp; destination == null)</span>
<span class="nc" id="L175">            return aPoint;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if(source == null) {</span>
<span class="nc" id="L177">            source = getWindowAncestor(destination);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            if(source == null)</span>
<span class="nc" id="L179">                throw new Error(&quot;Source component not connected to component tree hierarchy&quot;);</span>
        }
<span class="nc" id="L181">        p = new Point(aPoint);</span>
<span class="nc" id="L182">        convertPointToScreen(p,source);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if(destination == null) {</span>
<span class="nc" id="L184">            destination = getWindowAncestor(source);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            if(destination == null)</span>
<span class="nc" id="L186">                throw new Error(&quot;Destination component not connected to component tree hierarchy&quot;);</span>
        }
<span class="nc" id="L188">        convertPointFromScreen(p,destination);</span>
<span class="nc" id="L189">        return p;</span>
    }

    /**
     * Convert the point &lt;code&gt;(x,y)&lt;/code&gt; in &lt;code&gt;source&lt;/code&gt; coordinate system to
     * &lt;code&gt;destination&lt;/code&gt; coordinate system.
     * If &lt;code&gt;source&lt;/code&gt; is {@code null}, &lt;code&gt;(x,y)&lt;/code&gt; is assumed to be in &lt;code&gt;destination&lt;/code&gt;'s
     * root component coordinate system.
     * If &lt;code&gt;destination&lt;/code&gt; is {@code null}, &lt;code&gt;(x,y)&lt;/code&gt; will be converted to &lt;code&gt;source&lt;/code&gt;'s
     * root component coordinate system.
     * If both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are {@code null}, return &lt;code&gt;(x,y)&lt;/code&gt;
     * without any conversion.
     */
    public static Point convertPoint(Component source,int x, int y,Component destination) {
<span class="nc" id="L203">        Point point = new Point(x,y);</span>
<span class="nc" id="L204">        return convertPoint(source,point,destination);</span>
    }

    /**
     * Convert the rectangle &lt;code&gt;aRectangle&lt;/code&gt; in &lt;code&gt;source&lt;/code&gt; coordinate system to
     * &lt;code&gt;destination&lt;/code&gt; coordinate system.
     * If &lt;code&gt;source&lt;/code&gt; is {@code null}, &lt;code&gt;aRectangle&lt;/code&gt; is assumed to be in &lt;code&gt;destination&lt;/code&gt;'s
     * root component coordinate system.
     * If &lt;code&gt;destination&lt;/code&gt; is {@code null}, &lt;code&gt;aRectangle&lt;/code&gt; will be converted to &lt;code&gt;source&lt;/code&gt;'s
     * root component coordinate system.
     * If both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are {@code null}, return &lt;code&gt;aRectangle&lt;/code&gt;
     * without any conversion.
     */
    public static Rectangle convertRectangle(Component source,Rectangle aRectangle,Component destination) {
<span class="nc" id="L218">        Point point = new Point(aRectangle.x,aRectangle.y);</span>
<span class="nc" id="L219">        point =  convertPoint(source,point,destination);</span>
<span class="nc" id="L220">        return new Rectangle(point.x,point.y,aRectangle.width,aRectangle.height);</span>
    }

    /**
     * Convenience method for searching above &lt;code&gt;comp&lt;/code&gt; in the
     * component hierarchy and returns the first object of class &lt;code&gt;c&lt;/code&gt; it
     * finds. Can return {@code null}, if a class &lt;code&gt;c&lt;/code&gt; cannot be found.
     */
    public static Container getAncestorOfClass(Class&lt;?&gt; c, Component comp)
    {
<span class="nc bnc" id="L230" title="All 4 branches missed.">        if(comp == null || c == null)</span>
<span class="nc" id="L231">            return null;</span>

<span class="nc" id="L233">        Container parent = comp.getParent();</span>
<span class="nc bnc" id="L234" title="All 4 branches missed.">        while(parent != null &amp;&amp; !(c.isInstance(parent)))</span>
<span class="nc" id="L235">            parent = parent.getParent();</span>
<span class="nc" id="L236">        return parent;</span>
    }

    /**
     * Convenience method for searching above &lt;code&gt;comp&lt;/code&gt; in the
     * component hierarchy and returns the first object of &lt;code&gt;name&lt;/code&gt; it
     * finds. Can return {@code null}, if &lt;code&gt;name&lt;/code&gt; cannot be found.
     */
    public static Container getAncestorNamed(String name, Component comp) {
<span class="nc bnc" id="L245" title="All 4 branches missed.">        if(comp == null || name == null)</span>
<span class="nc" id="L246">            return null;</span>

<span class="nc" id="L248">        Container parent = comp.getParent();</span>
<span class="nc bnc" id="L249" title="All 4 branches missed.">        while(parent != null &amp;&amp; !(name.equals(parent.getName())))</span>
<span class="nc" id="L250">            parent = parent.getParent();</span>
<span class="nc" id="L251">        return parent;</span>
    }

    /**
     * Returns the deepest visible descendent Component of &lt;code&gt;parent&lt;/code&gt;
     * that contains the location &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;.
     * If &lt;code&gt;parent&lt;/code&gt; does not contain the specified location,
     * then &lt;code&gt;null&lt;/code&gt; is returned.  If &lt;code&gt;parent&lt;/code&gt; is not a
     * container, or none of &lt;code&gt;parent&lt;/code&gt;'s visible descendents
     * contain the specified location, &lt;code&gt;parent&lt;/code&gt; is returned.
     *
     * @param parent the root component to begin the search
     * @param x the x target location
     * @param y the y target location
     */
    public static Component getDeepestComponentAt(Component parent, int x, int y) {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (!parent.contains(x, y)) {</span>
<span class="nc" id="L268">            return null;</span>
        }
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (parent instanceof Container) {</span>
<span class="nc" id="L271">            Component components[] = ((Container)parent).getComponents();</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            for (Component comp : components) {</span>
<span class="nc bnc" id="L273" title="All 4 branches missed.">                if (comp != null &amp;&amp; comp.isVisible()) {</span>
<span class="nc" id="L274">                    Point loc = comp.getLocation();</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">                    if (comp instanceof Container) {</span>
<span class="nc" id="L276">                        comp = getDeepestComponentAt(comp, x - loc.x, y - loc.y);</span>
                    } else {
<span class="nc" id="L278">                        comp = comp.getComponentAt(x - loc.x, y - loc.y);</span>
                    }
<span class="nc bnc" id="L280" title="All 4 branches missed.">                    if (comp != null &amp;&amp; comp.isVisible()) {</span>
<span class="nc" id="L281">                        return comp;</span>
                    }
                }
            }
        }
<span class="nc" id="L286">        return parent;</span>
    }


    /**
     * Returns a MouseEvent similar to &lt;code&gt;sourceEvent&lt;/code&gt; except that its x
     * and y members have been converted to &lt;code&gt;destination&lt;/code&gt;'s coordinate
     * system.  If &lt;code&gt;source&lt;/code&gt; is {@code null}, &lt;code&gt;sourceEvent&lt;/code&gt; x and y members
     * are assumed to be into &lt;code&gt;destination&lt;/code&gt;'s root component coordinate system.
     * If &lt;code&gt;destination&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the
     * returned MouseEvent will be in &lt;code&gt;source&lt;/code&gt;'s coordinate system.
     * &lt;code&gt;sourceEvent&lt;/code&gt; will not be changed. A new event is returned.
     * the &lt;code&gt;source&lt;/code&gt; field of the returned event will be set
     * to &lt;code&gt;destination&lt;/code&gt; if destination is non-{@code null}
     * use the translateMouseEvent() method to translate a mouse event from
     * one component to another without changing the source.
     */
    public static MouseEvent convertMouseEvent(Component source,
                                               MouseEvent sourceEvent,
                                               Component destination) {
<span class="nc" id="L306">        Point p = convertPoint(source,new Point(sourceEvent.getX(),</span>
<span class="nc" id="L307">                                                sourceEvent.getY()),</span>
                               destination);
        Component newSource;

<span class="nc bnc" id="L311" title="All 2 branches missed.">        if(destination != null)</span>
<span class="nc" id="L312">            newSource = destination;</span>
        else
<span class="nc" id="L314">            newSource = source;</span>

        MouseEvent newEvent;
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (sourceEvent instanceof MouseWheelEvent) {</span>
<span class="nc" id="L318">            MouseWheelEvent sourceWheelEvent = (MouseWheelEvent)sourceEvent;</span>
<span class="nc" id="L319">            newEvent = new MouseWheelEvent(newSource,</span>
<span class="nc" id="L320">                                           sourceWheelEvent.getID(),</span>
<span class="nc" id="L321">                                           sourceWheelEvent.getWhen(),</span>
<span class="nc" id="L322">                                           sourceWheelEvent.getModifiers()</span>
<span class="nc" id="L323">                                                   | sourceWheelEvent.getModifiersEx(),</span>
                                           p.x,p.y,
<span class="nc" id="L325">                                           sourceWheelEvent.getXOnScreen(),</span>
<span class="nc" id="L326">                                           sourceWheelEvent.getYOnScreen(),</span>
<span class="nc" id="L327">                                           sourceWheelEvent.getClickCount(),</span>
<span class="nc" id="L328">                                           sourceWheelEvent.isPopupTrigger(),</span>
<span class="nc" id="L329">                                           sourceWheelEvent.getScrollType(),</span>
<span class="nc" id="L330">                                           sourceWheelEvent.getScrollAmount(),</span>
<span class="nc" id="L331">                                           sourceWheelEvent.getWheelRotation());</span>
<span class="nc" id="L332">        }</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        else if (sourceEvent instanceof MenuDragMouseEvent) {</span>
<span class="nc" id="L334">            MenuDragMouseEvent sourceMenuDragEvent = (MenuDragMouseEvent)sourceEvent;</span>
<span class="nc" id="L335">            newEvent = new MenuDragMouseEvent(newSource,</span>
<span class="nc" id="L336">                                              sourceMenuDragEvent.getID(),</span>
<span class="nc" id="L337">                                              sourceMenuDragEvent.getWhen(),</span>
<span class="nc" id="L338">                                              sourceMenuDragEvent.getModifiers()</span>
<span class="nc" id="L339">                                                      | sourceMenuDragEvent.getModifiersEx(),</span>
                                              p.x,p.y,
<span class="nc" id="L341">                                              sourceMenuDragEvent.getXOnScreen(),</span>
<span class="nc" id="L342">                                              sourceMenuDragEvent.getYOnScreen(),</span>
<span class="nc" id="L343">                                              sourceMenuDragEvent.getClickCount(),</span>
<span class="nc" id="L344">                                              sourceMenuDragEvent.isPopupTrigger(),</span>
<span class="nc" id="L345">                                              sourceMenuDragEvent.getPath(),</span>
<span class="nc" id="L346">                                              sourceMenuDragEvent.getMenuSelectionManager());</span>
<span class="nc" id="L347">        }</span>
        else {
<span class="nc" id="L349">            newEvent = new MouseEvent(newSource,</span>
<span class="nc" id="L350">                                      sourceEvent.getID(),</span>
<span class="nc" id="L351">                                      sourceEvent.getWhen(),</span>
<span class="nc" id="L352">                                      sourceEvent.getModifiers()</span>
<span class="nc" id="L353">                                              | sourceEvent.getModifiersEx(),</span>
                                      p.x,p.y,
<span class="nc" id="L355">                                      sourceEvent.getXOnScreen(),</span>
<span class="nc" id="L356">                                      sourceEvent.getYOnScreen(),</span>
<span class="nc" id="L357">                                      sourceEvent.getClickCount(),</span>
<span class="nc" id="L358">                                      sourceEvent.isPopupTrigger(),</span>
<span class="nc" id="L359">                                      sourceEvent.getButton());</span>
        }
<span class="nc" id="L361">        return newEvent;</span>
    }


    /**
     * Convert a point from a component's coordinate system to
     * screen coordinates.
     *
     * @param p  a Point object (converted to the new coordinate system)
     * @param c  a Component object
     */
    public static void convertPointToScreen(Point p,Component c) {
            Rectangle b;
            int x,y;

            do {
<span class="nc bnc" id="L377" title="All 2 branches missed.">                if(c instanceof JComponent) {</span>
<span class="nc" id="L378">                    x = c.getX();</span>
<span class="nc" id="L379">                    y = c.getY();</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">                } else if(c instanceof java.applet.Applet ||</span>
                          c instanceof java.awt.Window) {
                    try {
<span class="nc" id="L383">                        Point pp = c.getLocationOnScreen();</span>
<span class="nc" id="L384">                        x = pp.x;</span>
<span class="nc" id="L385">                        y = pp.y;</span>
<span class="nc" id="L386">                    } catch (IllegalComponentStateException icse) {</span>
<span class="nc" id="L387">                        x = c.getX();</span>
<span class="nc" id="L388">                        y = c.getY();</span>
<span class="nc" id="L389">                    }</span>
                } else {
<span class="nc" id="L391">                    x = c.getX();</span>
<span class="nc" id="L392">                    y = c.getY();</span>
                }

<span class="nc" id="L395">                p.x += x;</span>
<span class="nc" id="L396">                p.y += y;</span>

<span class="nc bnc" id="L398" title="All 4 branches missed.">                if(c instanceof java.awt.Window || c instanceof java.applet.Applet)</span>
<span class="nc" id="L399">                    break;</span>
<span class="nc" id="L400">                c = c.getParent();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">            } while(c != null);</span>
<span class="nc" id="L402">        }</span>

    /**
     * Convert a point from a screen coordinates to a component's
     * coordinate system
     *
     * @param p  a Point object (converted to the new coordinate system)
     * @param c  a Component object
     */
    public static void convertPointFromScreen(Point p,Component c) {
        Rectangle b;
        int x,y;

        do {
<span class="nc bnc" id="L416" title="All 2 branches missed.">            if(c instanceof JComponent) {</span>
<span class="nc" id="L417">                x = c.getX();</span>
<span class="nc" id="L418">                y = c.getY();</span>
<span class="nc bnc" id="L419" title="All 4 branches missed.">            }  else if(c instanceof java.applet.Applet ||</span>
                       c instanceof java.awt.Window) {
                try {
<span class="nc" id="L422">                    Point pp = c.getLocationOnScreen();</span>
<span class="nc" id="L423">                    x = pp.x;</span>
<span class="nc" id="L424">                    y = pp.y;</span>
<span class="nc" id="L425">                } catch (IllegalComponentStateException icse) {</span>
<span class="nc" id="L426">                    x = c.getX();</span>
<span class="nc" id="L427">                    y = c.getY();</span>
<span class="nc" id="L428">                }</span>
            } else {
<span class="nc" id="L430">                x = c.getX();</span>
<span class="nc" id="L431">                y = c.getY();</span>
            }

<span class="nc" id="L434">            p.x -= x;</span>
<span class="nc" id="L435">            p.y -= y;</span>

<span class="nc bnc" id="L437" title="All 4 branches missed.">            if(c instanceof java.awt.Window || c instanceof java.applet.Applet)</span>
<span class="nc" id="L438">                break;</span>
<span class="nc" id="L439">            c = c.getParent();</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        } while(c != null);</span>
<span class="nc" id="L441">    }</span>

    /**
     * Returns the first &lt;code&gt;Window &lt;/code&gt; ancestor of &lt;code&gt;c&lt;/code&gt;, or
     * {@code null} if &lt;code&gt;c&lt;/code&gt; is not contained inside a &lt;code&gt;Window&lt;/code&gt;.
     * &lt;p&gt;
     * Note: This method provides the same functionality as
     * &lt;code&gt;getWindowAncestor&lt;/code&gt;.
     *
     * @param c &lt;code&gt;Component&lt;/code&gt; to get &lt;code&gt;Window&lt;/code&gt; ancestor
     *        of.
     * @return the first &lt;code&gt;Window &lt;/code&gt; ancestor of &lt;code&gt;c&lt;/code&gt;, or
     *         {@code null} if &lt;code&gt;c&lt;/code&gt; is not contained inside a
     *         &lt;code&gt;Window&lt;/code&gt;.
     */
    public static Window windowForComponent(Component c) {
<span class="nc" id="L457">        return getWindowAncestor(c);</span>
    }

    /**
     * Return &lt;code&gt;true&lt;/code&gt; if a component &lt;code&gt;a&lt;/code&gt; descends from a component &lt;code&gt;b&lt;/code&gt;
     */
    public static boolean isDescendingFrom(Component a,Component b) {
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if(a == b)</span>
<span class="nc" id="L465">            return true;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        for(Container p = a.getParent();p!=null;p=p.getParent())</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">            if(p == b)</span>
<span class="nc" id="L468">                return true;</span>
<span class="nc" id="L469">        return false;</span>
    }


    /**
     * Convenience to calculate the intersection of two rectangles
     * without allocating a new rectangle.
     * If the two rectangles don't intersect,
     * then the returned rectangle begins at (0,0)
     * and has zero width and height.
     *
     * @param x       the X coordinate of the first rectangle's top-left point
     * @param y       the Y coordinate of the first rectangle's top-left point
     * @param width   the width of the first rectangle
     * @param height  the height of the first rectangle
     * @param dest    the second rectangle
     *
     * @return &lt;code&gt;dest&lt;/code&gt;, modified to specify the intersection
     */
    public static Rectangle computeIntersection(int x,int y,int width,int height,Rectangle dest) {
<span class="nc bnc" id="L489" title="All 2 branches missed.">        int x1 = (x &gt; dest.x) ? x : dest.x;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        int x2 = ((x+width) &lt; (dest.x + dest.width)) ? (x+width) : (dest.x + dest.width);</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">        int y1 = (y &gt; dest.y) ? y : dest.y;</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        int y2 = ((y + height) &lt; (dest.y + dest.height) ? (y+height) : (dest.y + dest.height));</span>

<span class="nc" id="L494">        dest.x = x1;</span>
<span class="nc" id="L495">        dest.y = y1;</span>
<span class="nc" id="L496">        dest.width = x2 - x1;</span>
<span class="nc" id="L497">        dest.height = y2 - y1;</span>

        // If rectangles don't intersect, return zero'd intersection.
<span class="nc bnc" id="L500" title="All 4 branches missed.">        if (dest.width &lt; 0 || dest.height &lt; 0) {</span>
<span class="nc" id="L501">            dest.x = dest.y = dest.width = dest.height = 0;</span>
        }

<span class="nc" id="L504">        return dest;</span>
    }

    /**
     * Convenience method that calculates the union of two rectangles
     * without allocating a new rectangle.
     *
     * @param x the x-coordinate of the first rectangle
     * @param y the y-coordinate of the first rectangle
     * @param width the width of the first rectangle
     * @param height the height of the first rectangle
     * @param dest  the coordinates of the second rectangle; the union
     *    of the two rectangles is returned in this rectangle
     * @return the &lt;code&gt;dest&lt;/code&gt; &lt;code&gt;Rectangle&lt;/code&gt;
     */
    public static Rectangle computeUnion(int x,int y,int width,int height,Rectangle dest) {
<span class="nc bnc" id="L520" title="All 2 branches missed.">        int x1 = (x &lt; dest.x) ? x : dest.x;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        int x2 = ((x+width) &gt; (dest.x + dest.width)) ? (x+width) : (dest.x + dest.width);</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">        int y1 = (y &lt; dest.y) ? y : dest.y;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">        int y2 = ((y+height) &gt; (dest.y + dest.height)) ? (y+height) : (dest.y + dest.height);</span>

<span class="nc" id="L525">        dest.x = x1;</span>
<span class="nc" id="L526">        dest.y = y1;</span>
<span class="nc" id="L527">        dest.width = (x2 - x1);</span>
<span class="nc" id="L528">        dest.height= (y2 - y1);</span>
<span class="nc" id="L529">        return dest;</span>
    }

    /**
     * Convenience returning an array of rect representing the regions within
     * &lt;code&gt;rectA&lt;/code&gt; that do not overlap with &lt;code&gt;rectB&lt;/code&gt;. If the
     * two Rects do not overlap, returns an empty array
     */
    public static Rectangle[] computeDifference(Rectangle rectA,Rectangle rectB) {
<span class="nc bnc" id="L538" title="All 6 branches missed.">        if (rectB == null || !rectA.intersects(rectB) || isRectangleContainingRectangle(rectB,rectA)) {</span>
<span class="nc" id="L539">            return new Rectangle[0];</span>
        }

<span class="nc" id="L542">        Rectangle t = new Rectangle();</span>
<span class="nc" id="L543">        Rectangle a=null,b=null,c=null,d=null;</span>
        Rectangle result[];
<span class="nc" id="L545">        int rectCount = 0;</span>

        /* rectA contains rectB */
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (isRectangleContainingRectangle(rectA,rectB)) {</span>
<span class="nc" id="L549">            t.x = rectA.x; t.y = rectA.y; t.width = rectB.x - rectA.x; t.height = rectA.height;</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">            if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L551">                a = new Rectangle(t);</span>
<span class="nc" id="L552">                rectCount++;</span>
            }

<span class="nc" id="L555">            t.x = rectB.x; t.y = rectA.y; t.width = rectB.width; t.height = rectB.y - rectA.y;</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">            if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L557">                b = new Rectangle(t);</span>
<span class="nc" id="L558">                rectCount++;</span>
            }

<span class="nc" id="L561">            t.x = rectB.x; t.y = rectB.y + rectB.height; t.width = rectB.width;</span>
<span class="nc" id="L562">            t.height = rectA.y + rectA.height - (rectB.y + rectB.height);</span>
<span class="nc bnc" id="L563" title="All 4 branches missed.">            if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L564">                c = new Rectangle(t);</span>
<span class="nc" id="L565">                rectCount++;</span>
            }

<span class="nc" id="L568">            t.x = rectB.x + rectB.width; t.y = rectA.y; t.width = rectA.x + rectA.width - (rectB.x + rectB.width);</span>
<span class="nc" id="L569">            t.height = rectA.height;</span>
<span class="nc bnc" id="L570" title="All 4 branches missed.">            if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L571">                d = new Rectangle(t);</span>
<span class="nc" id="L572">                rectCount++;</span>
            }
        } else {
            /* 1 */
<span class="nc bnc" id="L576" title="All 4 branches missed.">            if (rectB.x &lt;= rectA.x &amp;&amp; rectB.y &lt;= rectA.y) {</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">                if ((rectB.x + rectB.width) &gt; (rectA.x + rectA.width)) {</span>

<span class="nc" id="L579">                    t.x = rectA.x; t.y = rectB.y + rectB.height;</span>
<span class="nc" id="L580">                    t.width = rectA.width; t.height = rectA.y + rectA.height - (rectB.y + rectB.height);</span>
<span class="nc bnc" id="L581" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L582">                        a = t;</span>
<span class="nc" id="L583">                        rectCount++;</span>
                    }
<span class="nc bnc" id="L585" title="All 2 branches missed.">                } else if ((rectB.y + rectB.height) &gt; (rectA.y + rectA.height)) {</span>
<span class="nc" id="L586">                    t.setBounds((rectB.x + rectB.width), rectA.y,</span>
                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
<span class="nc bnc" id="L588" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L589">                        a = t;</span>
<span class="nc" id="L590">                        rectCount++;</span>
                    }
                } else {
<span class="nc" id="L593">                    t.setBounds((rectB.x + rectB.width), rectA.y,</span>
                                (rectA.x + rectA.width) - (rectB.x + rectB.width),
                                (rectB.y + rectB.height) - rectA.y);
<span class="nc bnc" id="L596" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L597">                        a = new Rectangle(t);</span>
<span class="nc" id="L598">                        rectCount++;</span>
                    }

<span class="nc" id="L601">                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,</span>
                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
<span class="nc bnc" id="L603" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L604">                        b = new Rectangle(t);</span>
<span class="nc" id="L605">                        rectCount++;</span>
                    }
                }
<span class="nc bnc" id="L608" title="All 4 branches missed.">            } else if (rectB.x &lt;= rectA.x &amp;&amp; (rectB.y + rectB.height) &gt;= (rectA.y + rectA.height)) {</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                if ((rectB.x + rectB.width) &gt; (rectA.x + rectA.width)) {</span>
<span class="nc" id="L610">                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);</span>
<span class="nc bnc" id="L611" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L612">                        a = t;</span>
<span class="nc" id="L613">                        rectCount++;</span>
                    }
                } else {
<span class="nc" id="L616">                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);</span>
<span class="nc bnc" id="L617" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L618">                        a = new Rectangle(t);</span>
<span class="nc" id="L619">                        rectCount++;</span>
                    }
<span class="nc" id="L621">                    t.setBounds((rectB.x + rectB.width), rectB.y,</span>
                                (rectA.x + rectA.width) - (rectB.x + rectB.width),
                                (rectA.y + rectA.height) - rectB.y);
<span class="nc bnc" id="L624" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L625">                        b = new Rectangle(t);</span>
<span class="nc" id="L626">                        rectCount++;</span>
                    }
                }
<span class="nc bnc" id="L629" title="All 2 branches missed.">            } else if (rectB.x &lt;= rectA.x) {</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">                if ((rectB.x + rectB.width) &gt;= (rectA.x + rectA.width)) {</span>
<span class="nc" id="L631">                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);</span>
<span class="nc bnc" id="L632" title="All 4 branches missed.">                    if(t.width&gt;0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L633">                        a = new Rectangle(t);</span>
<span class="nc" id="L634">                        rectCount++;</span>
                    }

<span class="nc" id="L637">                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,</span>
                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
<span class="nc bnc" id="L639" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L640">                        b = new Rectangle(t);</span>
<span class="nc" id="L641">                        rectCount++;</span>
                    }
                } else {
<span class="nc" id="L644">                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);</span>
<span class="nc bnc" id="L645" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L646">                        a = new Rectangle(t);</span>
<span class="nc" id="L647">                        rectCount++;</span>
                    }

<span class="nc" id="L650">                    t.setBounds((rectB.x + rectB.width), rectB.y,</span>
                                (rectA.x + rectA.width) - (rectB.x + rectB.width),
                                rectB.height);
<span class="nc bnc" id="L653" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L654">                        b = new Rectangle(t);</span>
<span class="nc" id="L655">                        rectCount++;</span>
                    }

<span class="nc" id="L658">                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,</span>
                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
<span class="nc bnc" id="L660" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L661">                        c = new Rectangle(t);</span>
<span class="nc" id="L662">                        rectCount++;</span>
                    }
                }
<span class="nc bnc" id="L665" title="All 4 branches missed.">            } else if (rectB.x &lt;= (rectA.x + rectA.width) &amp;&amp; (rectB.x + rectB.width) &gt; (rectA.x + rectA.width)) {</span>
<span class="nc bnc" id="L666" title="All 4 branches missed.">                if (rectB.y &lt;= rectA.y &amp;&amp; (rectB.y + rectB.height) &gt; (rectA.y + rectA.height)) {</span>
<span class="nc" id="L667">                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);</span>
<span class="nc bnc" id="L668" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L669">                        a = t;</span>
<span class="nc" id="L670">                        rectCount++;</span>
                    }
<span class="nc bnc" id="L672" title="All 2 branches missed.">                } else if (rectB.y &lt;= rectA.y) {</span>
<span class="nc" id="L673">                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x,</span>
                                (rectB.y + rectB.height) - rectA.y);
<span class="nc bnc" id="L675" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L676">                        a = new Rectangle(t);</span>
<span class="nc" id="L677">                        rectCount++;</span>
                    }

<span class="nc" id="L680">                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,</span>
                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
<span class="nc bnc" id="L682" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L683">                        b = new Rectangle(t);</span>
<span class="nc" id="L684">                        rectCount++;</span>
                    }
<span class="nc bnc" id="L686" title="All 2 branches missed.">                } else if ((rectB.y + rectB.height) &gt; (rectA.y + rectA.height)) {</span>
<span class="nc" id="L687">                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);</span>
<span class="nc bnc" id="L688" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L689">                        a = new Rectangle(t);</span>
<span class="nc" id="L690">                        rectCount++;</span>
                    }

<span class="nc" id="L693">                    t.setBounds(rectA.x, rectB.y, rectB.x - rectA.x,</span>
                                (rectA.y + rectA.height) - rectB.y);
<span class="nc bnc" id="L695" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L696">                        b = new Rectangle(t);</span>
<span class="nc" id="L697">                        rectCount++;</span>
                    }
                } else {
<span class="nc" id="L700">                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);</span>
<span class="nc bnc" id="L701" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L702">                        a = new Rectangle(t);</span>
<span class="nc" id="L703">                        rectCount++;</span>
                    }

<span class="nc" id="L706">                    t.setBounds(rectA.x, rectB.y, rectB.x - rectA.x,</span>
                                rectB.height);
<span class="nc bnc" id="L708" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L709">                        b = new Rectangle(t);</span>
<span class="nc" id="L710">                        rectCount++;</span>
                    }

<span class="nc" id="L713">                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,</span>
                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
<span class="nc bnc" id="L715" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L716">                        c = new Rectangle(t);</span>
<span class="nc" id="L717">                        rectCount++;</span>
                    }
                }
<span class="nc bnc" id="L720" title="All 4 branches missed.">            } else if (rectB.x &gt;= rectA.x &amp;&amp; (rectB.x + rectB.width) &lt;= (rectA.x + rectA.width)) {</span>
<span class="nc bnc" id="L721" title="All 4 branches missed.">                if (rectB.y &lt;= rectA.y &amp;&amp; (rectB.y + rectB.height) &gt; (rectA.y + rectA.height)) {</span>
<span class="nc" id="L722">                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);</span>
<span class="nc bnc" id="L723" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L724">                        a = new Rectangle(t);</span>
<span class="nc" id="L725">                        rectCount++;</span>
                    }
<span class="nc" id="L727">                    t.setBounds((rectB.x + rectB.width), rectA.y,</span>
                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
<span class="nc bnc" id="L729" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L730">                        b = new Rectangle(t);</span>
<span class="nc" id="L731">                        rectCount++;</span>
                    }
<span class="nc bnc" id="L733" title="All 2 branches missed.">                } else if (rectB.y &lt;= rectA.y) {</span>
<span class="nc" id="L734">                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);</span>
<span class="nc bnc" id="L735" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L736">                        a = new Rectangle(t);</span>
<span class="nc" id="L737">                        rectCount++;</span>
                    }

<span class="nc" id="L740">                    t.setBounds(rectB.x, (rectB.y + rectB.height),</span>
                                rectB.width,
                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
<span class="nc bnc" id="L743" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L744">                        b = new Rectangle(t);</span>
<span class="nc" id="L745">                        rectCount++;</span>
                    }

<span class="nc" id="L748">                    t.setBounds((rectB.x + rectB.width), rectA.y,</span>
                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
<span class="nc bnc" id="L750" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L751">                        c = new Rectangle(t);</span>
<span class="nc" id="L752">                        rectCount++;</span>
                    }
                } else {
<span class="nc" id="L755">                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);</span>
<span class="nc bnc" id="L756" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L757">                        a = new Rectangle(t);</span>
<span class="nc" id="L758">                        rectCount++;</span>
                    }

<span class="nc" id="L761">                    t.setBounds(rectB.x, rectA.y, rectB.width,</span>
                                rectB.y - rectA.y);
<span class="nc bnc" id="L763" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L764">                        b = new Rectangle(t);</span>
<span class="nc" id="L765">                        rectCount++;</span>
                    }

<span class="nc" id="L768">                    t.setBounds((rectB.x + rectB.width), rectA.y,</span>
                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
<span class="nc bnc" id="L770" title="All 4 branches missed.">                    if(t.width &gt; 0 &amp;&amp; t.height &gt; 0) {</span>
<span class="nc" id="L771">                        c = new Rectangle(t);</span>
<span class="nc" id="L772">                        rectCount++;</span>
                    }
                }
            }
        }

<span class="nc" id="L778">        result = new Rectangle[rectCount];</span>
<span class="nc" id="L779">        rectCount = 0;</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">        if(a != null)</span>
<span class="nc" id="L781">            result[rectCount++] = a;</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if(b != null)</span>
<span class="nc" id="L783">            result[rectCount++] = b;</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">        if(c != null)</span>
<span class="nc" id="L785">            result[rectCount++] = c;</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">        if(d != null)</span>
<span class="nc" id="L787">            result[rectCount++] = d;</span>
<span class="nc" id="L788">        return result;</span>
    }

    /**
     * Returns true if the mouse event specifies the left mouse button.
     *
     * @param anEvent  a MouseEvent object
     * @return true if the left mouse button was active
     */
    public static boolean isLeftMouseButton(MouseEvent anEvent) {
<span class="nc bnc" id="L798" title="All 2 branches missed.">         return ((anEvent.getModifiersEx() &amp; InputEvent.BUTTON1_DOWN_MASK) != 0 ||</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">                 anEvent.getButton() == MouseEvent.BUTTON1);</span>
    }

    /**
     * Returns true if the mouse event specifies the middle mouse button.
     *
     * @param anEvent  a MouseEvent object
     * @return true if the middle mouse button was active
     */
    public static boolean isMiddleMouseButton(MouseEvent anEvent) {
<span class="nc bnc" id="L809" title="All 2 branches missed.">        return ((anEvent.getModifiersEx() &amp; InputEvent.BUTTON2_DOWN_MASK) != 0 ||</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">                anEvent.getButton() == MouseEvent.BUTTON2);</span>
    }

    /**
     * Returns true if the mouse event specifies the right mouse button.
     *
     * @param anEvent  a MouseEvent object
     * @return true if the right mouse button was active
     */
    public static boolean isRightMouseButton(MouseEvent anEvent) {
<span class="nc bnc" id="L820" title="All 2 branches missed.">        return ((anEvent.getModifiersEx() &amp; InputEvent.BUTTON3_DOWN_MASK) != 0 ||</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">                anEvent.getButton() == MouseEvent.BUTTON3);</span>
    }

    /**
     * Compute the width of the string using a font with the specified
     * &quot;metrics&quot; (sizes).
     *
     * @param fm   a FontMetrics object to compute with
     * @param str  the String to compute
     * @return an int containing the string width
     */
    public static int computeStringWidth(FontMetrics fm,String str) {
        // You can't assume that a string's width is the sum of its
        // characters' widths in Java2D -- it may be smaller due to
        // kerning, etc.
<span class="nc" id="L836">        return SwingUtilities2.stringWidth(null, fm, str);</span>
    }

    /**
     * Compute and return the location of the icons origin, the
     * location of origin of the text baseline, and a possibly clipped
     * version of the compound labels string.  Locations are computed
     * relative to the viewR rectangle.
     * The JComponents orientation (LEADING/TRAILING) will also be taken
     * into account and translated into LEFT/RIGHT values accordingly.
     */
    public static String layoutCompoundLabel(JComponent c,
                                             FontMetrics fm,
                                             String text,
                                             Icon icon,
                                             int verticalAlignment,
                                             int horizontalAlignment,
                                             int verticalTextPosition,
                                             int horizontalTextPosition,
                                             Rectangle viewR,
                                             Rectangle iconR,
                                             Rectangle textR,
                                             int textIconGap)
    {
<span class="nc" id="L860">        boolean orientationIsLeftToRight = true;</span>
<span class="nc" id="L861">        int     hAlign = horizontalAlignment;</span>
<span class="nc" id="L862">        int     hTextPos = horizontalTextPosition;</span>

<span class="nc bnc" id="L864" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">            if (!(c.getComponentOrientation().isLeftToRight())) {</span>
<span class="nc" id="L866">                orientationIsLeftToRight = false;</span>
            }
        }

        // Translate LEADING/TRAILING values in horizontalAlignment
        // to LEFT/RIGHT values depending on the components orientation
<span class="nc bnc" id="L872" title="All 3 branches missed.">        switch (horizontalAlignment) {</span>
        case LEADING:
<span class="nc bnc" id="L874" title="All 2 branches missed.">            hAlign = (orientationIsLeftToRight) ? LEFT : RIGHT;</span>
<span class="nc" id="L875">            break;</span>
        case TRAILING:
<span class="nc bnc" id="L877" title="All 2 branches missed.">            hAlign = (orientationIsLeftToRight) ? RIGHT : LEFT;</span>
            break;
        }

        // Translate LEADING/TRAILING values in horizontalTextPosition
        // to LEFT/RIGHT values depending on the components orientation
<span class="nc bnc" id="L883" title="All 3 branches missed.">        switch (horizontalTextPosition) {</span>
        case LEADING:
<span class="nc bnc" id="L885" title="All 2 branches missed.">            hTextPos = (orientationIsLeftToRight) ? LEFT : RIGHT;</span>
<span class="nc" id="L886">            break;</span>
        case TRAILING:
<span class="nc bnc" id="L888" title="All 2 branches missed.">            hTextPos = (orientationIsLeftToRight) ? RIGHT : LEFT;</span>
            break;
        }

<span class="nc" id="L892">        return layoutCompoundLabelImpl(c,</span>
                                       fm,
                                       text,
                                       icon,
                                       verticalAlignment,
                                       hAlign,
                                       verticalTextPosition,
                                       hTextPos,
                                       viewR,
                                       iconR,
                                       textR,
                                       textIconGap);
    }

    /**
     * Compute and return the location of the icons origin, the
     * location of origin of the text baseline, and a possibly clipped
     * version of the compound labels string.  Locations are computed
     * relative to the viewR rectangle.
     * This layoutCompoundLabel() does not know how to handle LEADING/TRAILING
     * values in horizontalTextPosition (they will default to RIGHT) and in
     * horizontalAlignment (they will default to CENTER).
     * Use the other version of layoutCompoundLabel() instead.
     */
    public static String layoutCompoundLabel(
        FontMetrics fm,
        String text,
        Icon icon,
        int verticalAlignment,
        int horizontalAlignment,
        int verticalTextPosition,
        int horizontalTextPosition,
        Rectangle viewR,
        Rectangle iconR,
        Rectangle textR,
        int textIconGap)
    {
<span class="nc" id="L929">        return layoutCompoundLabelImpl(null, fm, text, icon,</span>
                                       verticalAlignment,
                                       horizontalAlignment,
                                       verticalTextPosition,
                                       horizontalTextPosition,
                                       viewR, iconR, textR, textIconGap);
    }

    /**
     * Compute and return the location of the icons origin, the
     * location of origin of the text baseline, and a possibly clipped
     * version of the compound labels string.  Locations are computed
     * relative to the viewR rectangle.
     * This layoutCompoundLabel() does not know how to handle LEADING/TRAILING
     * values in horizontalTextPosition (they will default to RIGHT) and in
     * horizontalAlignment (they will default to CENTER).
     * Use the other version of layoutCompoundLabel() instead.
     */
    private static String layoutCompoundLabelImpl(
        JComponent c,
        FontMetrics fm,
        String text,
        Icon icon,
        int verticalAlignment,
        int horizontalAlignment,
        int verticalTextPosition,
        int horizontalTextPosition,
        Rectangle viewR,
        Rectangle iconR,
        Rectangle textR,
        int textIconGap)
    {
        /* Initialize the icon bounds rectangle iconR.
         */

<span class="nc bnc" id="L964" title="All 2 branches missed.">        if (icon != null) {</span>
<span class="nc" id="L965">            iconR.width = icon.getIconWidth();</span>
<span class="nc" id="L966">            iconR.height = icon.getIconHeight();</span>
        }
        else {
<span class="nc" id="L969">            iconR.width = iconR.height = 0;</span>
        }

        /* Initialize the text bounds rectangle textR.  If a null
         * or and empty String was specified we substitute &quot;&quot; here
         * and use 0,0,0,0 for textR.
         */

<span class="nc bnc" id="L977" title="All 4 branches missed.">        boolean textIsEmpty = (text == null) || text.equals(&quot;&quot;);</span>
<span class="nc" id="L978">        int lsb = 0;</span>
<span class="nc" id="L979">        int rsb = 0;</span>
        /* Unless both text and icon are non-null, we effectively ignore
         * the value of textIconGap.
         */
        int gap;

        View v;
<span class="nc bnc" id="L986" title="All 2 branches missed.">        if (textIsEmpty) {</span>
<span class="nc" id="L987">            textR.width = textR.height = 0;</span>
<span class="nc" id="L988">            text = &quot;&quot;;</span>
<span class="nc" id="L989">            gap = 0;</span>
        }
        else {
            int availTextWidth;
<span class="nc bnc" id="L993" title="All 2 branches missed.">            gap = (icon == null) ? 0 : textIconGap;</span>

<span class="nc bnc" id="L995" title="All 2 branches missed.">            if (horizontalTextPosition == CENTER) {</span>
<span class="nc" id="L996">                availTextWidth = viewR.width;</span>
            }
            else {
<span class="nc" id="L999">                availTextWidth = viewR.width - (iconR.width + gap);</span>
            }
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            v = (c != null) ? (View) c.getClientProperty(&quot;html&quot;) : null;</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">            if (v != null) {</span>
<span class="nc" id="L1003">                textR.width = Math.min(availTextWidth,</span>
<span class="nc" id="L1004">                                       (int) v.getPreferredSpan(View.X_AXIS));</span>
<span class="nc" id="L1005">                textR.height = (int) v.getPreferredSpan(View.Y_AXIS);</span>
            } else {
<span class="nc" id="L1007">                textR.width = SwingUtilities2.stringWidth(c, fm, text);</span>
<span class="nc" id="L1008">                lsb = SwingUtilities2.getLeftSideBearing(c, fm, text);</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                if (lsb &lt; 0) {</span>
                    // If lsb is negative, add it to the width and later
                    // adjust the x location. This gives more space than is
                    // actually needed.
                    // This is done like this for two reasons:
                    // 1. If we set the width to the actual bounds all
                    //    callers would have to account for negative lsb
                    //    (pref size calculations ONLY look at width of
                    //    textR)
                    // 2. You can do a drawString at the returned location
                    //    and the text won't be clipped.
<span class="nc" id="L1020">                    textR.width -= lsb;</span>
                }
<span class="nc bnc" id="L1022" title="All 2 branches missed.">                if (textR.width &gt; availTextWidth) {</span>
<span class="nc" id="L1023">                    text = SwingUtilities2.clipString(c, fm, text,</span>
                                                      availTextWidth);
<span class="nc" id="L1025">                    textR.width = SwingUtilities2.stringWidth(c, fm, text);</span>
                }
<span class="nc" id="L1027">                textR.height = fm.getHeight();</span>
            }
        }


        /* Compute textR.x,y given the verticalTextPosition and
         * horizontalTextPosition properties
         */

<span class="nc bnc" id="L1036" title="All 2 branches missed.">        if (verticalTextPosition == TOP) {</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (horizontalTextPosition != CENTER) {</span>
<span class="nc" id="L1038">                textR.y = 0;</span>
            }
            else {
<span class="nc" id="L1041">                textR.y = -(textR.height + gap);</span>
            }
        }
<span class="nc bnc" id="L1044" title="All 2 branches missed.">        else if (verticalTextPosition == CENTER) {</span>
<span class="nc" id="L1045">            textR.y = (iconR.height / 2) - (textR.height / 2);</span>
        }
        else { // (verticalTextPosition == BOTTOM)
<span class="nc bnc" id="L1048" title="All 2 branches missed.">            if (horizontalTextPosition != CENTER) {</span>
<span class="nc" id="L1049">                textR.y = iconR.height - textR.height;</span>
            }
            else {
<span class="nc" id="L1052">                textR.y = (iconR.height + gap);</span>
            }
        }

<span class="nc bnc" id="L1056" title="All 2 branches missed.">        if (horizontalTextPosition == LEFT) {</span>
<span class="nc" id="L1057">            textR.x = -(textR.width + gap);</span>
        }
<span class="nc bnc" id="L1059" title="All 2 branches missed.">        else if (horizontalTextPosition == CENTER) {</span>
<span class="nc" id="L1060">            textR.x = (iconR.width / 2) - (textR.width / 2);</span>
        }
        else { // (horizontalTextPosition == RIGHT)
<span class="nc" id="L1063">            textR.x = (iconR.width + gap);</span>
        }

        // WARNING: DefaultTreeCellEditor uses a shortened version of
        // this algorithm to position it's Icon. If you change how this
        // is calculated, be sure and update DefaultTreeCellEditor too.

        /* labelR is the rectangle that contains iconR and textR.
         * Move it to its proper position given the labelAlignment
         * properties.
         *
         * To avoid actually allocating a Rectangle, Rectangle.union
         * has been inlined below.
         */
<span class="nc" id="L1077">        int labelR_x = Math.min(iconR.x, textR.x);</span>
<span class="nc" id="L1078">        int labelR_width = Math.max(iconR.x + iconR.width,</span>
                                    textR.x + textR.width) - labelR_x;
<span class="nc" id="L1080">        int labelR_y = Math.min(iconR.y, textR.y);</span>
<span class="nc" id="L1081">        int labelR_height = Math.max(iconR.y + iconR.height,</span>
                                     textR.y + textR.height) - labelR_y;

        int dx, dy;

<span class="nc bnc" id="L1086" title="All 2 branches missed.">        if (verticalAlignment == TOP) {</span>
<span class="nc" id="L1087">            dy = viewR.y - labelR_y;</span>
        }
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        else if (verticalAlignment == CENTER) {</span>
<span class="nc" id="L1090">            dy = (viewR.y + (viewR.height / 2)) - (labelR_y + (labelR_height / 2));</span>
        }
        else { // (verticalAlignment == BOTTOM)
<span class="nc" id="L1093">            dy = (viewR.y + viewR.height) - (labelR_y + labelR_height);</span>
        }

<span class="nc bnc" id="L1096" title="All 2 branches missed.">        if (horizontalAlignment == LEFT) {</span>
<span class="nc" id="L1097">            dx = viewR.x - labelR_x;</span>
        }
<span class="nc bnc" id="L1099" title="All 2 branches missed.">        else if (horizontalAlignment == RIGHT) {</span>
<span class="nc" id="L1100">            dx = (viewR.x + viewR.width) - (labelR_x + labelR_width);</span>
        }
        else { // (horizontalAlignment == CENTER)
<span class="nc" id="L1103">            dx = (viewR.x + (viewR.width / 2)) -</span>
                 (labelR_x + (labelR_width / 2));
        }

        /* Translate textR and glypyR by dx,dy.
         */

<span class="nc" id="L1110">        textR.x += dx;</span>
<span class="nc" id="L1111">        textR.y += dy;</span>

<span class="nc" id="L1113">        iconR.x += dx;</span>
<span class="nc" id="L1114">        iconR.y += dy;</span>

<span class="nc bnc" id="L1116" title="All 2 branches missed.">        if (lsb &lt; 0) {</span>
            // lsb is negative. Shift the x location so that the text is
            // visually drawn at the right location.
<span class="nc" id="L1119">            textR.x -= lsb;</span>

<span class="nc" id="L1121">            textR.width += lsb;</span>
        }
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        if (rsb &gt; 0) {</span>
<span class="nc" id="L1124">            textR.width -= rsb;</span>
        }

<span class="nc" id="L1127">        return text;</span>
    }


    /**
     * Paints a component to the specified &lt;code&gt;Graphics&lt;/code&gt;.
     * This method is primarily useful to render
     * &lt;code&gt;Component&lt;/code&gt;s that don't exist as part of the visible
     * containment hierarchy, but are used for rendering.  For
     * example, if you are doing your own rendering and want to render
     * some text (or even HTML), you could make use of
     * &lt;code&gt;JLabel&lt;/code&gt;'s text rendering support and have it paint
     * directly by way of this method, without adding the label to the
     * visible containment hierarchy.
     * &lt;p&gt;
     * This method makes use of &lt;code&gt;CellRendererPane&lt;/code&gt; to handle
     * the actual painting, and is only recommended if you use one
     * component for rendering.  If you make use of multiple components
     * to handle the rendering, as &lt;code&gt;JTable&lt;/code&gt; does, use
     * &lt;code&gt;CellRendererPane&lt;/code&gt; directly.  Otherwise, as described
     * below, you could end up with a &lt;code&gt;CellRendererPane&lt;/code&gt;
     * per &lt;code&gt;Component&lt;/code&gt;.
     * &lt;p&gt;
     * If &lt;code&gt;c&lt;/code&gt;'s parent is not a &lt;code&gt;CellRendererPane&lt;/code&gt;,
     * a new &lt;code&gt;CellRendererPane&lt;/code&gt; is created, &lt;code&gt;c&lt;/code&gt; is
     * added to it, and the &lt;code&gt;CellRendererPane&lt;/code&gt; is added to
     * &lt;code&gt;p&lt;/code&gt;.  If &lt;code&gt;c&lt;/code&gt;'s parent is a
     * &lt;code&gt;CellRendererPane&lt;/code&gt; and the &lt;code&gt;CellRendererPane&lt;/code&gt;s
     * parent is not &lt;code&gt;p&lt;/code&gt;, it is added to &lt;code&gt;p&lt;/code&gt;.
     * &lt;p&gt;
     * The component should either descend from &lt;code&gt;JComponent&lt;/code&gt;
     * or be another kind of lightweight component.
     * A lightweight component is one whose &quot;lightweight&quot; property
     * (returned by the &lt;code&gt;Component&lt;/code&gt;
     * &lt;code&gt;isLightweight&lt;/code&gt; method)
     * is true. If the Component is not lightweight, bad things map happen:
     * crashes, exceptions, painting problems...
     *
     * @param g  the &lt;code&gt;Graphics&lt;/code&gt; object to draw on
     * @param c  the &lt;code&gt;Component&lt;/code&gt; to draw
     * @param p  the intermediate &lt;code&gt;Container&lt;/code&gt;
     * @param x  an int specifying the left side of the area draw in, in pixels,
     *           measured from the left edge of the graphics context
     * @param y  an int specifying the top of the area to draw in, in pixels
     *           measured down from the top edge of the graphics context
     * @param w  an int specifying the width of the area draw in, in pixels
     * @param h  an int specifying the height of the area draw in, in pixels
     *
     * @see CellRendererPane
     * @see java.awt.Component#isLightweight
     */
    public static void paintComponent(Graphics g, Component c, Container p, int x, int y, int w, int h) {
<span class="nc" id="L1179">        getCellRendererPane(c, p).paintComponent(g, c, p, x, y, w, h,false);</span>
<span class="nc" id="L1180">    }</span>

    /**
     * Paints a component to the specified &lt;code&gt;Graphics&lt;/code&gt;.  This
     * is a cover method for
     * {@link #paintComponent(Graphics,Component,Container,int,int,int,int)}.
     * Refer to it for more information.
     *
     * @param g  the &lt;code&gt;Graphics&lt;/code&gt; object to draw on
     * @param c  the &lt;code&gt;Component&lt;/code&gt; to draw
     * @param p  the intermediate &lt;code&gt;Container&lt;/code&gt;
     * @param r  the &lt;code&gt;Rectangle&lt;/code&gt; to draw in
     *
     * @see #paintComponent(Graphics,Component,Container,int,int,int,int)
     * @see CellRendererPane
     */
    public static void paintComponent(Graphics g, Component c, Container p, Rectangle r) {
<span class="nc" id="L1197">        paintComponent(g, c, p, r.x, r.y, r.width, r.height);</span>
<span class="nc" id="L1198">    }</span>


    /*
     * Ensures that cell renderer &lt;code&gt;c&lt;/code&gt; has a
     * &lt;code&gt;ComponentShell&lt;/code&gt; parent and that
     * the shell's parent is p.
     */
    private static CellRendererPane getCellRendererPane(Component c, Container p) {
<span class="nc" id="L1207">        Container shell = c.getParent();</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">        if (shell instanceof CellRendererPane) {</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">            if (shell.getParent() != p) {</span>
<span class="nc" id="L1210">                p.add(shell);</span>
            }
        } else {
<span class="nc" id="L1213">            shell = new CellRendererPane();</span>
<span class="nc" id="L1214">            shell.add(c);</span>
<span class="nc" id="L1215">            p.add(shell);</span>
        }
<span class="nc" id="L1217">        return (CellRendererPane)shell;</span>
    }

    /**
     * A simple minded look and feel change: ask each node in the tree
     * to &lt;code&gt;updateUI()&lt;/code&gt; -- that is, to initialize its UI property
     * with the current look and feel.
     */
    public static void updateComponentTreeUI(Component c) {
<span class="nc" id="L1226">        updateComponentTreeUI0(c);</span>
<span class="nc" id="L1227">        c.invalidate();</span>
<span class="nc" id="L1228">        c.validate();</span>
<span class="nc" id="L1229">        c.repaint();</span>
<span class="nc" id="L1230">    }</span>

    private static void updateComponentTreeUI0(Component c) {
<span class="nc bnc" id="L1233" title="All 2 branches missed.">        if (c instanceof JComponent) {</span>
<span class="nc" id="L1234">            JComponent jc = (JComponent) c;</span>
<span class="nc" id="L1235">            jc.updateUI();</span>
<span class="nc" id="L1236">            JPopupMenu jpm =jc.getComponentPopupMenu();</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">            if(jpm != null) {</span>
<span class="nc" id="L1238">                updateComponentTreeUI(jpm);</span>
            }
        }
<span class="nc" id="L1241">        Component[] children = null;</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">        if (c instanceof JMenu) {</span>
<span class="nc" id="L1243">            children = ((JMenu)c).getMenuComponents();</span>
        }
<span class="nc bnc" id="L1245" title="All 2 branches missed.">        else if (c instanceof Container) {</span>
<span class="nc" id="L1246">            children = ((Container)c).getComponents();</span>
        }
<span class="nc bnc" id="L1248" title="All 2 branches missed.">        if (children != null) {</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">            for (Component child : children) {</span>
<span class="nc" id="L1250">                updateComponentTreeUI0(child);</span>
            }
        }
<span class="nc" id="L1253">    }</span>


    /**
     * Causes &lt;i&gt;doRun.run()&lt;/i&gt; to be executed asynchronously on the
     * AWT event dispatching thread.  This will happen after all
     * pending AWT events have been processed.  This method should
     * be used when an application thread needs to update the GUI.
     * In the following example the &lt;code&gt;invokeLater&lt;/code&gt; call queues
     * the &lt;code&gt;Runnable&lt;/code&gt; object &lt;code&gt;doHelloWorld&lt;/code&gt;
     * on the event dispatching thread and
     * then prints a message.
     * &lt;pre&gt;
     * Runnable doHelloWorld = new Runnable() {
     *     public void run() {
     *         System.out.println(&quot;Hello World on &quot; + Thread.currentThread());
     *     }
     * };
     *
     * SwingUtilities.invokeLater(doHelloWorld);
     * System.out.println(&quot;This might well be displayed before the other message.&quot;);
     * &lt;/pre&gt;
     * If invokeLater is called from the event dispatching thread --
     * for example, from a JButton's ActionListener -- the &lt;i&gt;doRun.run()&lt;/i&gt; will
     * still be deferred until all pending events have been processed.
     * Note that if the &lt;i&gt;doRun.run()&lt;/i&gt; throws an uncaught exception
     * the event dispatching thread will unwind (not the current thread).
     * &lt;p&gt;
     * Additional documentation and examples for this method can be
     * found in
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency in Swing&lt;/a&gt;.
     * &lt;p&gt;
     * As of 1.3 this method is just a cover for &lt;code&gt;java.awt.EventQueue.invokeLater()&lt;/code&gt;.
     * &lt;p&gt;
     * Unlike the rest of Swing, this method can be invoked from any thread.
     *
     * @see #invokeAndWait
     */
    public static void invokeLater(Runnable doRun) {
<span class="nc" id="L1292">        EventQueue.invokeLater(doRun);</span>
<span class="nc" id="L1293">    }</span>


    /**
     * Causes &lt;code&gt;doRun.run()&lt;/code&gt; to be executed synchronously on the
     * AWT event dispatching thread.  This call blocks until
     * all pending AWT events have been processed and (then)
     * &lt;code&gt;doRun.run()&lt;/code&gt; returns. This method should
     * be used when an application thread needs to update the GUI.
     * It shouldn't be called from the event dispatching thread.
     * Here's an example that creates a new application thread
     * that uses &lt;code&gt;invokeAndWait&lt;/code&gt; to print a string from the event
     * dispatching thread and then, when that's finished, print
     * a string from the application thread.
     * &lt;pre&gt;
     * final Runnable doHelloWorld = new Runnable() {
     *     public void run() {
     *         System.out.println(&quot;Hello World on &quot; + Thread.currentThread());
     *     }
     * };
     *
     * Thread appThread = new Thread() {
     *     public void run() {
     *         try {
     *             SwingUtilities.invokeAndWait(doHelloWorld);
     *         }
     *         catch (Exception e) {
     *             e.printStackTrace();
     *         }
     *         System.out.println(&quot;Finished on &quot; + Thread.currentThread());
     *     }
     * };
     * appThread.start();
     * &lt;/pre&gt;
     * Note that if the &lt;code&gt;Runnable.run&lt;/code&gt; method throws an
     * uncaught exception
     * (on the event dispatching thread) it's caught and rethrown, as
     * an &lt;code&gt;InvocationTargetException&lt;/code&gt;, on the caller's thread.
     * &lt;p&gt;
     * Additional documentation and examples for this method can be
     * found in
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency in Swing&lt;/a&gt;.
     * &lt;p&gt;
     * As of 1.3 this method is just a cover for
     * &lt;code&gt;java.awt.EventQueue.invokeAndWait()&lt;/code&gt;.
     *
     * @exception  InterruptedException if we're interrupted while waiting for
     *             the event dispatching thread to finish executing
     *             &lt;code&gt;doRun.run()&lt;/code&gt;
     * @exception  InvocationTargetException  if an exception is thrown
     *             while running &lt;code&gt;doRun&lt;/code&gt;
     *
     * @see #invokeLater
     */
    public static void invokeAndWait(final Runnable doRun)
        throws InterruptedException, InvocationTargetException
    {
<span class="nc" id="L1350">        EventQueue.invokeAndWait(doRun);</span>
<span class="nc" id="L1351">    }</span>

    /**
     * Returns true if the current thread is an AWT event dispatching thread.
     * &lt;p&gt;
     * As of 1.3 this method is just a cover for
     * &lt;code&gt;java.awt.EventQueue.isDispatchThread()&lt;/code&gt;.
     *
     * @return true if the current thread is an AWT event dispatching thread
     */
    public static boolean isEventDispatchThread()
    {
<span class="nc" id="L1363">        return EventQueue.isDispatchThread();</span>
    }


    /*
     * --- Accessibility Support ---
     *
     */

    /**
     * Get the index of this object in its accessible parent.&lt;p&gt;
     *
     * Note: as of the Java 2 platform v1.3, it is recommended that developers call
     * Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead
     * of using this method.
     *
     * @return -1 of this object does not have an accessible parent.
     * Otherwise, the index of the child in its accessible parent.
     */
    public static int getAccessibleIndexInParent(Component c) {
<span class="nc" id="L1383">        return c.getAccessibleContext().getAccessibleIndexInParent();</span>
    }

    /**
     * Returns the &lt;code&gt;Accessible&lt;/code&gt; child contained at the
     * local coordinate &lt;code&gt;Point&lt;/code&gt;, if one exists.
     * Otherwise returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return the &lt;code&gt;Accessible&lt;/code&gt; at the specified location,
     *    if it exists; otherwise &lt;code&gt;null&lt;/code&gt;
     */
    public static Accessible getAccessibleAt(Component c, Point p) {
<span class="nc bnc" id="L1395" title="All 2 branches missed.">        if (c instanceof Container) {</span>
<span class="nc" id="L1396">            return c.getAccessibleContext().getAccessibleComponent().getAccessibleAt(p);</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">        } else if (c instanceof Accessible) {</span>
<span class="nc" id="L1398">            Accessible a = (Accessible) c;</span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">            if (a != null) {</span>
<span class="nc" id="L1400">                AccessibleContext ac = a.getAccessibleContext();</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                if (ac != null) {</span>
                    AccessibleComponent acmp;
                    Point location;
<span class="nc" id="L1404">                    int nchildren = ac.getAccessibleChildrenCount();</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">                    for (int i=0; i &lt; nchildren; i++) {</span>
<span class="nc" id="L1406">                        a = ac.getAccessibleChild(i);</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">                        if ((a != null)) {</span>
<span class="nc" id="L1408">                            ac = a.getAccessibleContext();</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">                            if (ac != null) {</span>
<span class="nc" id="L1410">                                acmp = ac.getAccessibleComponent();</span>
<span class="nc bnc" id="L1411" title="All 4 branches missed.">                                if ((acmp != null) &amp;&amp; (acmp.isShowing())) {</span>
<span class="nc" id="L1412">                                    location = acmp.getLocation();</span>
<span class="nc" id="L1413">                                    Point np = new Point(p.x-location.x,</span>
                                                         p.y-location.y);
<span class="nc bnc" id="L1415" title="All 2 branches missed.">                                    if (acmp.contains(np)){</span>
<span class="nc" id="L1416">                                        return a;</span>
                                    }
                                }
                            }
                        }
                    }
                }
            }
<span class="nc" id="L1424">            return (Accessible) c;</span>
        }
<span class="nc" id="L1426">        return null;</span>
    }

    /**
     * Get the state of this object. &lt;p&gt;
     *
     * Note: as of the Java 2 platform v1.3, it is recommended that developers call
     * Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead
     * of using this method.
     *
     * @return an instance of AccessibleStateSet containing the current state
     * set of the object
     * @see AccessibleState
     */
    public static AccessibleStateSet getAccessibleStateSet(Component c) {
<span class="nc" id="L1441">        return c.getAccessibleContext().getAccessibleStateSet();</span>
    }

    /**
     * Returns the number of accessible children in the object.  If all
     * of the children of this object implement Accessible, than this
     * method should return the number of children of this object. &lt;p&gt;
     *
     * Note: as of the Java 2 platform v1.3, it is recommended that developers call
     * Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead
     * of using this method.
     *
     * @return the number of accessible children in the object.
     */
    public static int getAccessibleChildrenCount(Component c) {
<span class="nc" id="L1456">        return c.getAccessibleContext().getAccessibleChildrenCount();</span>
    }

    /**
     * Return the nth Accessible child of the object. &lt;p&gt;
     *
     * Note: as of the Java 2 platform v1.3, it is recommended that developers call
     * Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead
     * of using this method.
     *
     * @param i zero-based index of child
     * @return the nth Accessible child of the object
     */
    public static Accessible getAccessibleChild(Component c, int i) {
<span class="nc" id="L1470">        return c.getAccessibleContext().getAccessibleChild(i);</span>
    }

    /**
     * Return the child &lt;code&gt;Component&lt;/code&gt; of the specified
     * &lt;code&gt;Component&lt;/code&gt; that is the focus owner, if any.
     *
     * @param c the root of the &lt;code&gt;Component&lt;/code&gt; hierarchy to
     *        search for the focus owner
     * @return the focus owner, or &lt;code&gt;null&lt;/code&gt; if there is no focus
     *         owner, or if the focus owner is not &lt;code&gt;comp&lt;/code&gt;, or a
     *         descendant of &lt;code&gt;comp&lt;/code&gt;
     *
     * @see java.awt.KeyboardFocusManager#getFocusOwner
     * @deprecated As of 1.4, replaced by
     *   &lt;code&gt;KeyboardFocusManager.getFocusOwner()&lt;/code&gt;.
     */
    @Deprecated
    public static Component findFocusOwner(Component c) {
        Component focusOwner = KeyboardFocusManager.
<span class="nc" id="L1490">            getCurrentKeyboardFocusManager().getFocusOwner();</span>

        // verify focusOwner is a descendant of c
<span class="nc bnc" id="L1493" title="All 2 branches missed.">        for (Component temp = focusOwner; temp != null;</span>
<span class="nc bnc" id="L1494" title="All 2 branches missed.">             temp = (temp instanceof Window) ? null : temp.getParent())</span>
        {
<span class="nc bnc" id="L1496" title="All 2 branches missed.">            if (temp == c) {</span>
<span class="nc" id="L1497">                return focusOwner;</span>
            }
        }

<span class="nc" id="L1501">        return null;</span>
    }

    /**
     * If c is a JRootPane descendant return its JRootPane ancestor.
     * If c is a RootPaneContainer then return its JRootPane.
     * @return the JRootPane for Component c or {@code null}.
     */
    public static JRootPane getRootPane(Component c) {
<span class="nc bnc" id="L1510" title="All 2 branches missed.">        if (c instanceof RootPaneContainer) {</span>
<span class="nc" id="L1511">            return ((RootPaneContainer)c).getRootPane();</span>
        }
<span class="nc bnc" id="L1513" title="All 2 branches missed.">        for( ; c != null; c = c.getParent()) {</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">            if (c instanceof JRootPane) {</span>
<span class="nc" id="L1515">                return (JRootPane)c;</span>
            }
        }
<span class="nc" id="L1518">        return null;</span>
    }


    /**
     * Returns the root component for the current component tree.
     * @return the first ancestor of c that's a Window or the last Applet ancestor
     */
    public static Component getRoot(Component c) {
<span class="nc" id="L1527">        Component applet = null;</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">        for(Component p = c; p != null; p = p.getParent()) {</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">            if (p instanceof Window) {</span>
<span class="nc" id="L1530">                return p;</span>
            }
<span class="nc bnc" id="L1532" title="All 2 branches missed.">            if (p instanceof Applet) {</span>
<span class="nc" id="L1533">                applet = p;</span>
            }
        }
<span class="nc" id="L1536">        return applet;</span>
    }

    static JComponent getPaintingOrigin(JComponent c) {
<span class="nc" id="L1540">        Container p = c;</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">        while ((p = p.getParent()) instanceof JComponent) {</span>
<span class="nc" id="L1542">            JComponent jp = (JComponent) p;</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">            if (jp.isPaintingOrigin()) {</span>
<span class="nc" id="L1544">                return jp;</span>
            }
<span class="nc" id="L1546">        }</span>
<span class="nc" id="L1547">        return null;</span>
    }

    /**
     * Process the key bindings for the &lt;code&gt;Component&lt;/code&gt; associated with
     * &lt;code&gt;event&lt;/code&gt;. This method is only useful if
     * &lt;code&gt;event.getComponent()&lt;/code&gt; does not descend from
     * &lt;code&gt;JComponent&lt;/code&gt;, or your are not invoking
     * &lt;code&gt;super.processKeyEvent&lt;/code&gt; from within your
     * &lt;code&gt;JComponent&lt;/code&gt; subclass. &lt;code&gt;JComponent&lt;/code&gt;
     * automatically processes bindings from within its
     * &lt;code&gt;processKeyEvent&lt;/code&gt; method, hence you rarely need
     * to directly invoke this method.
     *
     * @param event KeyEvent used to identify which bindings to process, as
     *              well as which Component has focus.
     * @return true if a binding has found and processed
     * @since 1.4
     */
    public static boolean processKeyBindings(KeyEvent event) {
<span class="nc bnc" id="L1567" title="All 2 branches missed.">        if (event != null) {</span>
<span class="nc bnc" id="L1568" title="All 2 branches missed.">            if (event.isConsumed()) {</span>
<span class="nc" id="L1569">                return false;</span>
            }

<span class="nc" id="L1572">            Component component = event.getComponent();</span>
<span class="nc bnc" id="L1573" title="All 2 branches missed.">            boolean pressed = (event.getID() == KeyEvent.KEY_PRESSED);</span>

<span class="nc bnc" id="L1575" title="All 2 branches missed.">            if (!isValidKeyEventForKeyBindings(event)) {</span>
<span class="nc" id="L1576">                return false;</span>
            }
            // Find the first JComponent in the ancestor hierarchy, and
            // invoke processKeyBindings on it
<span class="nc bnc" id="L1580" title="All 2 branches missed.">            while (component != null) {</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">                if (component instanceof JComponent) {</span>
<span class="nc" id="L1582">                    return ((JComponent)component).processKeyBindings(</span>
                                                   event, pressed);
                }
<span class="nc bnc" id="L1585" title="All 4 branches missed.">                if ((component instanceof Applet) ||</span>
                    (component instanceof Window)) {
                    // No JComponents, if Window or Applet parent, process
                    // WHEN_IN_FOCUSED_WINDOW bindings.
<span class="nc" id="L1589">                    return JComponent.processKeyBindingsForAllComponents(</span>
                                  event, (Container)component, pressed);
                }
<span class="nc" id="L1592">                component = component.getParent();</span>
            }
        }
<span class="nc" id="L1595">        return false;</span>
    }

    /**
     * Returns true if the &lt;code&gt;e&lt;/code&gt; is a valid KeyEvent to use in
     * processing the key bindings associated with JComponents.
     */
    static boolean isValidKeyEventForKeyBindings(KeyEvent e) {
<span class="nc" id="L1603">        return true;</span>
    }

    /**
     * Invokes &lt;code&gt;actionPerformed&lt;/code&gt; on &lt;code&gt;action&lt;/code&gt; if
     * &lt;code&gt;action&lt;/code&gt; is enabled (and non-{@code null}). The command for the
     * ActionEvent is determined by:
     * &lt;ol&gt;
     *   &lt;li&gt;If the action was registered via
     *       &lt;code&gt;registerKeyboardAction&lt;/code&gt;, then the command string
     *       passed in ({@code null} will be used if {@code null} was passed in).
     *   &lt;li&gt;Action value with name Action.ACTION_COMMAND_KEY, unless {@code null}.
     *   &lt;li&gt;String value of the KeyEvent, unless &lt;code&gt;getKeyChar&lt;/code&gt;
     *       returns KeyEvent.CHAR_UNDEFINED..
     * &lt;/ol&gt;
     * This will return true if &lt;code&gt;action&lt;/code&gt; is non-{@code null} and
     * actionPerformed is invoked on it.
     *
     * @since 1.3
     */
    public static boolean notifyAction(Action action, KeyStroke ks,
                                       KeyEvent event, Object sender,
                                       int modifiers) {
<span class="nc bnc" id="L1626" title="All 2 branches missed.">        if (action == null) {</span>
<span class="nc" id="L1627">            return false;</span>
        }
<span class="nc bnc" id="L1629" title="All 2 branches missed.">        if (action instanceof UIAction) {</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">            if (!((UIAction)action).isEnabled(sender)) {</span>
<span class="nc" id="L1631">                return false;</span>
            }
        }
<span class="nc bnc" id="L1634" title="All 2 branches missed.">        else if (!action.isEnabled()) {</span>
<span class="nc" id="L1635">            return false;</span>
        }
        Object commandO;
        boolean stayNull;

        // Get the command object.
<span class="nc" id="L1641">        commandO = action.getValue(Action.ACTION_COMMAND_KEY);</span>
<span class="nc bnc" id="L1642" title="All 4 branches missed.">        if (commandO == null &amp;&amp; (action instanceof JComponent.ActionStandin)) {</span>
            // ActionStandin is used for historical reasons to support
            // registerKeyboardAction with a null value.
<span class="nc" id="L1645">            stayNull = true;</span>
        }
        else {
<span class="nc" id="L1648">            stayNull = false;</span>
        }

        // Convert it to a string.
        String command;

<span class="nc bnc" id="L1654" title="All 2 branches missed.">        if (commandO != null) {</span>
<span class="nc" id="L1655">            command = commandO.toString();</span>
        }
<span class="nc bnc" id="L1657" title="All 4 branches missed.">        else if (!stayNull &amp;&amp; event.getKeyChar() != KeyEvent.CHAR_UNDEFINED) {</span>
<span class="nc" id="L1658">            command = String.valueOf(event.getKeyChar());</span>
        }
        else {
            // Do null for undefined chars, or if registerKeyboardAction
            // was called with a null.
<span class="nc" id="L1663">            command = null;</span>
        }
<span class="nc" id="L1665">        action.actionPerformed(new ActionEvent(sender,</span>
<span class="nc" id="L1666">                        ActionEvent.ACTION_PERFORMED, command, event.getWhen(),</span>
                        modifiers));
<span class="nc" id="L1668">        return true;</span>
    }


    /**
     * Convenience method to change the UI InputMap for &lt;code&gt;component&lt;/code&gt;
     * to &lt;code&gt;uiInputMap&lt;/code&gt;. If &lt;code&gt;uiInputMap&lt;/code&gt; is {@code null},
     * this removes any previously installed UI InputMap.
     *
     * @since 1.3
     */
    public static void replaceUIInputMap(JComponent component, int type,
                                         InputMap uiInputMap) {
<span class="nc bnc" id="L1681" title="All 2 branches missed.">        InputMap map = component.getInputMap(type, (uiInputMap != null));</span>

<span class="nc bnc" id="L1683" title="All 2 branches missed.">        while (map != null) {</span>
<span class="nc" id="L1684">            InputMap parent = map.getParent();</span>
<span class="nc bnc" id="L1685" title="All 4 branches missed.">            if (parent == null || (parent instanceof UIResource)) {</span>
<span class="nc" id="L1686">                map.setParent(uiInputMap);</span>
<span class="nc" id="L1687">                return;</span>
            }
<span class="nc" id="L1689">            map = parent;</span>
<span class="nc" id="L1690">        }</span>
<span class="nc" id="L1691">    }</span>


    /**
     * Convenience method to change the UI ActionMap for &lt;code&gt;component&lt;/code&gt;
     * to &lt;code&gt;uiActionMap&lt;/code&gt;. If &lt;code&gt;uiActionMap&lt;/code&gt; is {@code null},
     * this removes any previously installed UI ActionMap.
     *
     * @since 1.3
     */
    public static void replaceUIActionMap(JComponent component,
                                          ActionMap uiActionMap) {
<span class="nc bnc" id="L1703" title="All 2 branches missed.">        ActionMap map = component.getActionMap((uiActionMap != null));</span>

<span class="nc bnc" id="L1705" title="All 2 branches missed.">        while (map != null) {</span>
<span class="nc" id="L1706">            ActionMap parent = map.getParent();</span>
<span class="nc bnc" id="L1707" title="All 4 branches missed.">            if (parent == null || (parent instanceof UIResource)) {</span>
<span class="nc" id="L1708">                map.setParent(uiActionMap);</span>
<span class="nc" id="L1709">                return;</span>
            }
<span class="nc" id="L1711">            map = parent;</span>
<span class="nc" id="L1712">        }</span>
<span class="nc" id="L1713">    }</span>


    /**
     * Returns the InputMap provided by the UI for condition
     * &lt;code&gt;condition&lt;/code&gt; in component &lt;code&gt;component&lt;/code&gt;.
     * &lt;p&gt;This will return {@code null} if the UI has not installed a InputMap
     * of the specified type.
     *
     * @since 1.3
     */
    public static InputMap getUIInputMap(JComponent component, int condition) {
<span class="nc" id="L1725">        InputMap map = component.getInputMap(condition, false);</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">        while (map != null) {</span>
<span class="nc" id="L1727">            InputMap parent = map.getParent();</span>
<span class="nc bnc" id="L1728" title="All 2 branches missed.">            if (parent instanceof UIResource) {</span>
<span class="nc" id="L1729">                return parent;</span>
            }
<span class="nc" id="L1731">            map = parent;</span>
<span class="nc" id="L1732">        }</span>
<span class="nc" id="L1733">        return null;</span>
    }

    /**
     * Returns the ActionMap provided by the UI
     * in component &lt;code&gt;component&lt;/code&gt;.
     * &lt;p&gt;This will return {@code null} if the UI has not installed an ActionMap.
     *
     * @since 1.3
     */
    public static ActionMap getUIActionMap(JComponent component) {
<span class="nc" id="L1744">        ActionMap map = component.getActionMap(false);</span>
<span class="nc bnc" id="L1745" title="All 2 branches missed.">        while (map != null) {</span>
<span class="nc" id="L1746">            ActionMap parent = map.getParent();</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">            if (parent instanceof UIResource) {</span>
<span class="nc" id="L1748">                return parent;</span>
            }
<span class="nc" id="L1750">            map = parent;</span>
<span class="nc" id="L1751">        }</span>
<span class="nc" id="L1752">        return null;</span>
    }


    // Don't use String, as it's not guaranteed to be unique in a Hashtable.
<span class="fc" id="L1757">    private static final Object sharedOwnerFrameKey =</span>
       new StringBuffer(&quot;SwingUtilities.sharedOwnerFrame&quot;);

<span class="nc" id="L1760">    static class SharedOwnerFrame extends Frame implements WindowListener {</span>
        public void addNotify() {
<span class="nc" id="L1762">            super.addNotify();</span>
<span class="nc" id="L1763">            installListeners();</span>
<span class="nc" id="L1764">        }</span>

        /**
         * Install window listeners on owned windows to watch for displayability changes
         */
        void installListeners() {
<span class="nc" id="L1770">            Window[] windows = getOwnedWindows();</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">            for (Window window : windows) {</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">                if (window != null) {</span>
<span class="nc" id="L1773">                    window.removeWindowListener(this);</span>
<span class="nc" id="L1774">                    window.addWindowListener(this);</span>
                }
            }
<span class="nc" id="L1777">        }</span>

        /**
         * Watches for displayability changes and disposes shared instance if there are no
         * displayable children left.
         */
        public void windowClosed(WindowEvent e) {
<span class="nc" id="L1784">            synchronized(getTreeLock()) {</span>
<span class="nc" id="L1785">                Window[] windows = getOwnedWindows();</span>
<span class="nc bnc" id="L1786" title="All 2 branches missed.">                for (Window window : windows) {</span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">                    if (window != null) {</span>
<span class="nc bnc" id="L1788" title="All 2 branches missed.">                        if (window.isDisplayable()) {</span>
<span class="nc" id="L1789">                            return;</span>
                        }
<span class="nc" id="L1791">                        window.removeWindowListener(this);</span>
                    }
                }
<span class="nc" id="L1794">                dispose();</span>
<span class="nc" id="L1795">            }</span>
<span class="nc" id="L1796">        }</span>
        public void windowOpened(WindowEvent e) {
<span class="nc" id="L1798">        }</span>
        public void windowClosing(WindowEvent e) {
<span class="nc" id="L1800">        }</span>
        public void windowIconified(WindowEvent e) {
<span class="nc" id="L1802">        }</span>
        public void windowDeiconified(WindowEvent e) {
<span class="nc" id="L1804">        }</span>
        public void windowActivated(WindowEvent e) {
<span class="nc" id="L1806">        }</span>
        public void windowDeactivated(WindowEvent e) {
<span class="nc" id="L1808">        }</span>

        public void show() {
            // This frame can never be shown
<span class="nc" id="L1812">        }</span>
        public void dispose() {
            try {
<span class="nc" id="L1815">                getToolkit().getSystemEventQueue();</span>
<span class="nc" id="L1816">                super.dispose();</span>
<span class="nc" id="L1817">            } catch (Exception e) {</span>
                // untrusted code not allowed to dispose
<span class="nc" id="L1819">            }</span>
<span class="nc" id="L1820">        }</span>
    }

    /**
     * Returns a toolkit-private, shared, invisible Frame
     * to be the owner for JDialogs and JWindows created with
     * {@code null} owners.
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    static Frame getSharedOwnerFrame() throws HeadlessException {
<span class="nc" id="L1832">        Frame sharedOwnerFrame =</span>
<span class="nc" id="L1833">            (Frame)SwingUtilities.appContextGet(sharedOwnerFrameKey);</span>
<span class="nc bnc" id="L1834" title="All 2 branches missed.">        if (sharedOwnerFrame == null) {</span>
<span class="nc" id="L1835">            sharedOwnerFrame = new SharedOwnerFrame();</span>
<span class="nc" id="L1836">            SwingUtilities.appContextPut(sharedOwnerFrameKey,</span>
                                         sharedOwnerFrame);
        }
<span class="nc" id="L1839">        return sharedOwnerFrame;</span>
    }

    /**
     * Returns a SharedOwnerFrame's shutdown listener to dispose the SharedOwnerFrame
     * if it has no more displayable children.
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    static WindowListener getSharedOwnerFrameShutdownListener() throws HeadlessException {
<span class="nc" id="L1850">        Frame sharedOwnerFrame = getSharedOwnerFrame();</span>
<span class="nc" id="L1851">        return (WindowListener)sharedOwnerFrame;</span>
    }

    /* Don't make these AppContext accessors public or protected --
     * since AppContext is in sun.awt in 1.2, we shouldn't expose it
     * even indirectly with a public API.
     */
    // REMIND(aim): phase out use of 4 methods below since they
    // are just private covers for AWT methods (?)

    static Object appContextGet(Object key) {
<span class="fc" id="L1862">        return AppContext.getAppContext().get(key);</span>
    }

    static void appContextPut(Object key, Object value) {
<span class="fc" id="L1866">        AppContext.getAppContext().put(key, value);</span>
<span class="fc" id="L1867">    }</span>

    static void appContextRemove(Object key) {
<span class="nc" id="L1870">        AppContext.getAppContext().remove(key);</span>
<span class="nc" id="L1871">    }</span>


    static Class&lt;?&gt; loadSystemClass(String className) throws ClassNotFoundException {
<span class="nc" id="L1875">        return Class.forName(className, true, Thread.currentThread().</span>
<span class="nc" id="L1876">                             getContextClassLoader());</span>
    }


   /*
     * Convenience function for determining ComponentOrientation.  Helps us
     * avoid having Munge directives throughout the code.
     */
    static boolean isLeftToRight( Component c ) {
<span class="nc" id="L1885">        return c.getComponentOrientation().isLeftToRight();</span>
    }
<span class="nc" id="L1887">    private SwingUtilities() {</span>
<span class="nc" id="L1888">        throw new Error(&quot;SwingUtilities is just a container for static methods&quot;);</span>
    }

    /**
     * Returns true if the Icon &lt;code&gt;icon&lt;/code&gt; is an instance of
     * ImageIcon, and the image it contains is the same as &lt;code&gt;image&lt;/code&gt;.
     */
    static boolean doesIconReferenceImage(Icon icon, Image image) {
<span class="nc bnc" id="L1896" title="All 4 branches missed.">        Image iconImage = (icon != null &amp;&amp; (icon instanceof ImageIcon)) ?</span>
<span class="nc" id="L1897">                           ((ImageIcon)icon).getImage() : null;</span>
<span class="nc bnc" id="L1898" title="All 2 branches missed.">        return (iconImage == image);</span>
    }

    /**
     * Returns index of the first occurrence of &lt;code&gt;mnemonic&lt;/code&gt;
     * within string &lt;code&gt;text&lt;/code&gt;. Matching algorithm is not
     * case-sensitive.
     *
     * @param text The text to search through, may be {@code null}
     * @param mnemonic The mnemonic to find the character for.
     * @return index into the string if exists, otherwise -1
     */
    static int findDisplayedMnemonicIndex(String text, int mnemonic) {
<span class="nc bnc" id="L1911" title="All 4 branches missed.">        if (text == null || mnemonic == '\0') {</span>
<span class="nc" id="L1912">            return -1;</span>
        }

<span class="nc" id="L1915">        char uc = Character.toUpperCase((char)mnemonic);</span>
<span class="nc" id="L1916">        char lc = Character.toLowerCase((char)mnemonic);</span>

<span class="nc" id="L1918">        int uci = text.indexOf(uc);</span>
<span class="nc" id="L1919">        int lci = text.indexOf(lc);</span>

<span class="nc bnc" id="L1921" title="All 2 branches missed.">        if (uci == -1) {</span>
<span class="nc" id="L1922">            return lci;</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">        } else if(lci == -1) {</span>
<span class="nc" id="L1924">            return uci;</span>
        } else {
<span class="nc bnc" id="L1926" title="All 2 branches missed.">            return (lci &lt; uci) ? lci : uci;</span>
        }
    }

    /**
     * Stores the position and size of
     * the inner painting area of the specified component
     * in &lt;code&gt;r&lt;/code&gt; and returns &lt;code&gt;r&lt;/code&gt;.
     * The position and size specify the bounds of the component,
     * adjusted so as not to include the border area (the insets).
     * This method is useful for classes
     * that implement painting code.
     *
     * @param c  the JComponent in question; if {@code null}, this method returns {@code null}
     * @param r  the Rectangle instance to be modified;
     *           may be {@code null}
     * @return {@code null} if the Component is {@code null};
     *         otherwise, returns the passed-in rectangle (if non-{@code null})
     *         or a new rectangle specifying position and size information
     *
     * @since 1.4
     */
    public static Rectangle calculateInnerArea(JComponent c, Rectangle r) {
<span class="nc bnc" id="L1949" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1950">            return null;</span>
        }
<span class="nc" id="L1952">        Rectangle rect = r;</span>
<span class="nc" id="L1953">        Insets insets = c.getInsets();</span>

<span class="nc bnc" id="L1955" title="All 2 branches missed.">        if (rect == null) {</span>
<span class="nc" id="L1956">            rect = new Rectangle();</span>
        }

<span class="nc" id="L1959">        rect.x = insets.left;</span>
<span class="nc" id="L1960">        rect.y = insets.top;</span>
<span class="nc" id="L1961">        rect.width = c.getWidth() - insets.left - insets.right;</span>
<span class="nc" id="L1962">        rect.height = c.getHeight() - insets.top - insets.bottom;</span>

<span class="nc" id="L1964">        return rect;</span>
    }

    static void updateRendererOrEditorUI(Object rendererOrEditor) {
<span class="nc bnc" id="L1968" title="All 2 branches missed.">        if (rendererOrEditor == null) {</span>
<span class="nc" id="L1969">            return;</span>
        }

<span class="nc" id="L1972">        Component component = null;</span>

<span class="nc bnc" id="L1974" title="All 2 branches missed.">        if (rendererOrEditor instanceof Component) {</span>
<span class="nc" id="L1975">            component = (Component)rendererOrEditor;</span>
        }
<span class="nc bnc" id="L1977" title="All 2 branches missed.">        if (rendererOrEditor instanceof DefaultCellEditor) {</span>
<span class="nc" id="L1978">            component = ((DefaultCellEditor)rendererOrEditor).getComponent();</span>
        }

<span class="nc bnc" id="L1981" title="All 2 branches missed.">        if (component != null) {</span>
<span class="nc" id="L1982">            SwingUtilities.updateComponentTreeUI(component);</span>
        }
<span class="nc" id="L1984">    }</span>

    /**
     * Returns the first ancestor of the {@code component}
     * which is not an instance of {@link JLayer}.
     *
     * @param component {@code Component} to get
     * the first ancestor of, which is not a {@link JLayer} instance.
     *
     * @return the first ancestor of the {@code component}
     * which is not an instance of {@link JLayer}.
     * If such an ancestor can not be found, {@code null} is returned.
     *
     * @throws NullPointerException if {@code component} is {@code null}
     * @see JLayer
     *
     * @since 1.7
     */
    public static Container getUnwrappedParent(Component component) {
<span class="nc" id="L2003">        Container parent = component.getParent();</span>
<span class="nc bnc" id="L2004" title="All 2 branches missed.">        while(parent instanceof JLayer) {</span>
<span class="nc" id="L2005">            parent = parent.getParent();</span>
        }
<span class="nc" id="L2007">        return parent;</span>
    }

    /**
     * Returns the first {@code JViewport}'s descendant
     * which is not an instance of {@code JLayer}.
     * If such a descendant can not be found, {@code null} is returned.
     *
     * If the {@code viewport}'s view component is not a {@code JLayer},
     * this method is equivalent to {@link JViewport#getView()}
     * otherwise {@link JLayer#getView()} will be recursively
     * called on all descending {@code JLayer}s.
     *
     * @param viewport {@code JViewport} to get the first descendant of,
     * which in not a {@code JLayer} instance.
     *
     * @return the first {@code JViewport}'s descendant
     * which is not an instance of {@code JLayer}.
     * If such a descendant can not be found, {@code null} is returned.
     *
     * @throws NullPointerException if {@code viewport} is {@code null}
     * @see JViewport#getView()
     * @see JLayer
     *
     * @since 1.7
     */
    public static Component getUnwrappedView(JViewport viewport) {
<span class="nc" id="L2034">        Component view = viewport.getView();</span>
<span class="nc bnc" id="L2035" title="All 2 branches missed.">        while (view instanceof JLayer) {</span>
<span class="nc" id="L2036">            view = ((JLayer)view).getView();</span>
        }
<span class="nc" id="L2038">        return view;</span>
    }

   /**
     * Retrieves the validate root of a given container.
     *
     * If the container is contained within a {@code CellRendererPane}, this
     * method returns {@code null} due to the synthetic nature of the {@code
     * CellRendererPane}.
     * &lt;p&gt;
     * The component hierarchy must be displayable up to the toplevel component
     * (either a {@code Frame} or an {@code Applet} object.) Otherwise this
     * method returns {@code null}.
     * &lt;p&gt;
     * If the {@code visibleOnly} argument is {@code true}, the found validate
     * root and all its parents up to the toplevel component must also be
     * visible. Otherwise this method returns {@code null}.
     *
     * @return the validate root of the given container or null
     * @see java.awt.Component#isDisplayable()
     * @see java.awt.Component#isVisible()
     * @since 1.7
     */
    static Container getValidateRoot(Container c, boolean visibleOnly) {
<span class="nc" id="L2062">        Container root = null;</span>

<span class="nc bnc" id="L2064" title="All 2 branches missed.">        for (; c != null; c = c.getParent())</span>
        {
<span class="nc bnc" id="L2066" title="All 4 branches missed.">            if (!c.isDisplayable() || c instanceof CellRendererPane) {</span>
<span class="nc" id="L2067">                return null;</span>
            }
<span class="nc bnc" id="L2069" title="All 2 branches missed.">            if (c.isValidateRoot()) {</span>
<span class="nc" id="L2070">                root = c;</span>
<span class="nc" id="L2071">                break;</span>
            }
        }

<span class="nc bnc" id="L2075" title="All 2 branches missed.">        if (root == null) {</span>
<span class="nc" id="L2076">            return null;</span>
        }

<span class="nc bnc" id="L2079" title="All 2 branches missed.">        for (; c != null; c = c.getParent()) {</span>
<span class="nc bnc" id="L2080" title="All 6 branches missed.">            if (!c.isDisplayable() || (visibleOnly &amp;&amp; !c.isVisible())) {</span>
<span class="nc" id="L2081">                return null;</span>
            }
<span class="nc bnc" id="L2083" title="All 4 branches missed.">            if (c instanceof Window || c instanceof Applet) {</span>
<span class="nc" id="L2084">                return root;</span>
            }
        }

<span class="nc" id="L2088">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>