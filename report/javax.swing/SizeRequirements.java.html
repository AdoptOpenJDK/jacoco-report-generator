<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SizeRequirements.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">SizeRequirements.java</span></div><h1>SizeRequirements.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;


import java.awt.*;
import java.io.Serializable;

/**
 * For the convenience of layout managers,
 * calculates information about the size and position of components.
 * All size and position calculation methods are class methods
 * that take arrays of SizeRequirements as arguments.
 * The SizeRequirements class supports two types of layout:
 *
 * &lt;blockquote&gt;
 * &lt;dl&gt;
 * &lt;dt&gt; tiled
 * &lt;dd&gt; The components are placed end-to-end,
 *      starting either at coordinate 0 (the leftmost or topmost position)
 *      or at the coordinate representing the end of the allocated span
 *      (the rightmost or bottommost position).
 *
 * &lt;dt&gt; aligned
 * &lt;dd&gt; The components are aligned as specified
 *      by each component's X or Y alignment value.
 * &lt;/dl&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt;
 *
 * Each SizeRequirements object contains information
 * about either the width (and X alignment)
 * or height (and Y alignment)
 * of a single component or a group of components:
 *
 * &lt;blockquote&gt;
 * &lt;dl&gt;
 * &lt;dt&gt; &lt;code&gt;minimum&lt;/code&gt;
 * &lt;dd&gt; The smallest reasonable width/height of the component
 *      or component group, in pixels.
 *
 * &lt;dt&gt; &lt;code&gt;preferred&lt;/code&gt;
 * &lt;dd&gt; The natural width/height of the component
 *      or component group, in pixels.
 *
 * &lt;dt&gt; &lt;code&gt;maximum&lt;/code&gt;
 * &lt;dd&gt; The largest reasonable width/height of the component
 *      or component group, in pixels.
 *
 * &lt;dt&gt; &lt;code&gt;alignment&lt;/code&gt;
 * &lt;dd&gt; The X/Y alignment of the component
 *      or component group.
 * &lt;/dl&gt;
 * &lt;/blockquote&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @see Component#getMinimumSize
 * @see Component#getPreferredSize
 * @see Component#getMaximumSize
 * @see Component#getAlignmentX
 * @see Component#getAlignmentY
 *
 * @author Timothy Prinzing
 */
public class SizeRequirements implements Serializable {

    /**
     * The minimum size required.
     * For a component &lt;code&gt;comp&lt;/code&gt;, this should be equal to either
     * &lt;code&gt;comp.getMinimumSize().width&lt;/code&gt; or
     * &lt;code&gt;comp.getMinimumSize().height&lt;/code&gt;.
     */
    public int minimum;

    /**
     * The preferred (natural) size.
     * For a component &lt;code&gt;comp&lt;/code&gt;, this should be equal to either
     * &lt;code&gt;comp.getPreferredSize().width&lt;/code&gt; or
     * &lt;code&gt;comp.getPreferredSize().height&lt;/code&gt;.
     */
    public int preferred;

    /**
     * The maximum size allowed.
     * For a component &lt;code&gt;comp&lt;/code&gt;, this should be equal to either
     * &lt;code&gt;comp.getMaximumSize().width&lt;/code&gt; or
     * &lt;code&gt;comp.getMaximumSize().height&lt;/code&gt;.
     */
    public int maximum;

    /**
     * The alignment, specified as a value between 0.0 and 1.0,
     * inclusive.
     * To specify centering, the alignment should be 0.5.
     */
    public float alignment;

    /**
     * Creates a SizeRequirements object with the minimum, preferred,
     * and maximum sizes set to zero and an alignment value of 0.5
     * (centered).
     */
<span class="nc" id="L134">    public SizeRequirements() {</span>
<span class="nc" id="L135">        minimum = 0;</span>
<span class="nc" id="L136">        preferred = 0;</span>
<span class="nc" id="L137">        maximum = 0;</span>
<span class="nc" id="L138">        alignment = 0.5f;</span>
<span class="nc" id="L139">    }</span>

    /**
     * Creates a SizeRequirements object with the specified minimum, preferred,
     * and maximum sizes and the specified alignment.
     *
     * @param min the minimum size &amp;gt;= 0
     * @param pref the preferred size &amp;gt;= 0
     * @param max the maximum size &amp;gt;= 0
     * @param a the alignment &amp;gt;= 0.0f &amp;amp;&amp;amp; &amp;lt;= 1.0f
     */
<span class="nc" id="L150">    public SizeRequirements(int min, int pref, int max, float a) {</span>
<span class="nc" id="L151">        minimum = min;</span>
<span class="nc" id="L152">        preferred = pref;</span>
<span class="nc" id="L153">        maximum = max;</span>
<span class="nc bnc" id="L154" title="All 4 branches missed.">        alignment = a &gt; 1.0f ? 1.0f : a &lt; 0.0f ? 0.0f : a;</span>
<span class="nc" id="L155">    }</span>

    /**
     * Returns a string describing the minimum, preferred, and maximum
     * size requirements, along with the alignment.
     *
     * @return the string
     */
    public String toString() {
<span class="nc" id="L164">        return &quot;[&quot; + minimum + &quot;,&quot; + preferred + &quot;,&quot; + maximum + &quot;]@&quot; + alignment;</span>
    }

    /**
     * Determines the total space necessary to
     * place a set of components end-to-end.  The needs
     * of each component in the set are represented by an entry in the
     * passed-in SizeRequirements array.
     * The returned SizeRequirements object has an alignment of 0.5
     * (centered).  The space requirement is never more than
     * Integer.MAX_VALUE.
     *
     * @param children  the space requirements for a set of components.
     *   The vector may be of zero length, which will result in a
     *   default SizeRequirements object instance being passed back.
     * @return  the total space requirements.
     */
    public static SizeRequirements getTiledSizeRequirements(SizeRequirements[]
                                                            children) {
<span class="nc" id="L183">        SizeRequirements total = new SizeRequirements();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        for (int i = 0; i &lt; children.length; i++) {</span>
<span class="nc" id="L185">            SizeRequirements req = children[i];</span>
<span class="nc" id="L186">            total.minimum = (int) Math.min((long) total.minimum + (long) req.minimum, Integer.MAX_VALUE);</span>
<span class="nc" id="L187">            total.preferred = (int) Math.min((long) total.preferred + (long) req.preferred, Integer.MAX_VALUE);</span>
<span class="nc" id="L188">            total.maximum = (int) Math.min((long) total.maximum + (long) req.maximum, Integer.MAX_VALUE);</span>
        }
<span class="nc" id="L190">        return total;</span>
    }

    /**
     * Determines the total space necessary to
     * align a set of components.  The needs
     * of each component in the set are represented by an entry in the
     * passed-in SizeRequirements array.  The total space required will
     * never be more than Integer.MAX_VALUE.
     *
     * @param children  the set of child requirements.  If of zero length,
     *  the returns result will be a default instance of SizeRequirements.
     * @return  the total space requirements.
     */
    public static SizeRequirements getAlignedSizeRequirements(SizeRequirements[]
                                                              children) {
<span class="nc" id="L206">        SizeRequirements totalAscent = new SizeRequirements();</span>
<span class="nc" id="L207">        SizeRequirements totalDescent = new SizeRequirements();</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        for (int i = 0; i &lt; children.length; i++) {</span>
<span class="nc" id="L209">            SizeRequirements req = children[i];</span>

<span class="nc" id="L211">            int ascent = (int) (req.alignment * req.minimum);</span>
<span class="nc" id="L212">            int descent = req.minimum - ascent;</span>
<span class="nc" id="L213">            totalAscent.minimum = Math.max(ascent, totalAscent.minimum);</span>
<span class="nc" id="L214">            totalDescent.minimum = Math.max(descent, totalDescent.minimum);</span>

<span class="nc" id="L216">            ascent = (int) (req.alignment * req.preferred);</span>
<span class="nc" id="L217">            descent = req.preferred - ascent;</span>
<span class="nc" id="L218">            totalAscent.preferred = Math.max(ascent, totalAscent.preferred);</span>
<span class="nc" id="L219">            totalDescent.preferred = Math.max(descent, totalDescent.preferred);</span>

<span class="nc" id="L221">            ascent = (int) (req.alignment * req.maximum);</span>
<span class="nc" id="L222">            descent = req.maximum - ascent;</span>
<span class="nc" id="L223">            totalAscent.maximum = Math.max(ascent, totalAscent.maximum);</span>
<span class="nc" id="L224">            totalDescent.maximum = Math.max(descent, totalDescent.maximum);</span>
        }
<span class="nc" id="L226">        int min = (int) Math.min((long) totalAscent.minimum + (long) totalDescent.minimum, Integer.MAX_VALUE);</span>
<span class="nc" id="L227">        int pref = (int) Math.min((long) totalAscent.preferred + (long) totalDescent.preferred, Integer.MAX_VALUE);</span>
<span class="nc" id="L228">        int max = (int) Math.min((long) totalAscent.maximum + (long) totalDescent.maximum, Integer.MAX_VALUE);</span>
<span class="nc" id="L229">        float alignment = 0.0f;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (min &gt; 0) {</span>
<span class="nc" id="L231">            alignment = (float) totalAscent.minimum / min;</span>
<span class="nc bnc" id="L232" title="All 4 branches missed.">            alignment = alignment &gt; 1.0f ? 1.0f : alignment &lt; 0.0f ? 0.0f : alignment;</span>
        }
<span class="nc" id="L234">        return new SizeRequirements(min, pref, max, alignment);</span>
    }

    /**
     * Creates a set of offset/span pairs representing how to
     * lay out a set of components end-to-end.
     * This method requires that you specify
     * the total amount of space to be allocated,
     * the size requirements for each component to be placed
     * (specified as an array of SizeRequirements), and
     * the total size requirement of the set of components.
     * You can get the total size requirement
     * by invoking the getTiledSizeRequirements method.  The components
     * will be tiled in the forward direction with offsets increasing from 0.
     *
     * @param allocated the total span to be allocated &amp;gt;= 0.
     * @param total     the total of the children requests.  This argument
     *  is optional and may be null.
     * @param children  the size requirements for each component.
     * @param offsets   the offset from 0 for each child where
     *   the spans were allocated (determines placement of the span).
     * @param spans     the span allocated for each child to make the
     *   total target span.
     */
    public static void calculateTiledPositions(int allocated,
                                               SizeRequirements total,
                                               SizeRequirements[] children,
                                               int[] offsets,
                                               int[] spans) {
<span class="nc" id="L263">        calculateTiledPositions(allocated, total, children, offsets, spans, true);</span>
<span class="nc" id="L264">    }</span>

    /**
     * Creates a set of offset/span pairs representing how to
     * lay out a set of components end-to-end.
     * This method requires that you specify
     * the total amount of space to be allocated,
     * the size requirements for each component to be placed
     * (specified as an array of SizeRequirements), and
     * the total size requirement of the set of components.
     * You can get the total size requirement
     * by invoking the getTiledSizeRequirements method.
     *
     * This method also requires a flag indicating whether components
     * should be tiled in the forward direction (offsets increasing
     * from 0) or reverse direction (offsets decreasing from the end
     * of the allocated space).  The forward direction represents
     * components tiled from left to right or top to bottom.  The
     * reverse direction represents components tiled from right to left
     * or bottom to top.
     *
     * @param allocated the total span to be allocated &amp;gt;= 0.
     * @param total     the total of the children requests.  This argument
     *  is optional and may be null.
     * @param children  the size requirements for each component.
     * @param offsets   the offset from 0 for each child where
     *   the spans were allocated (determines placement of the span).
     * @param spans     the span allocated for each child to make the
     *   total target span.
     * @param forward   tile with offsets increasing from 0 if true
     *   and with offsets decreasing from the end of the allocated space
     *   if false.
     * @since 1.4
     */
    public static void calculateTiledPositions(int allocated,
                                               SizeRequirements total,
                                               SizeRequirements[] children,
                                               int[] offsets,
                                               int[] spans,
                                               boolean forward) {
        // The total argument turns out to be a bad idea since the
        // total of all the children can overflow the integer used to
        // hold the total.  The total must therefore be calculated and
        // stored in long variables.
<span class="nc" id="L308">        long min = 0;</span>
<span class="nc" id="L309">        long pref = 0;</span>
<span class="nc" id="L310">        long max = 0;</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        for (int i = 0; i &lt; children.length; i++) {</span>
<span class="nc" id="L312">            min += children[i].minimum;</span>
<span class="nc" id="L313">            pref += children[i].preferred;</span>
<span class="nc" id="L314">            max += children[i].maximum;</span>
        }
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (allocated &gt;= pref) {</span>
<span class="nc" id="L317">            expandedTile(allocated, min, pref, max, children, offsets, spans, forward);</span>
        } else {
<span class="nc" id="L319">            compressedTile(allocated, min, pref, max, children, offsets, spans, forward);</span>
        }
<span class="nc" id="L321">    }</span>

    private static void compressedTile(int allocated, long min, long pref, long max,
                                       SizeRequirements[] request,
                                       int[] offsets, int[] spans,
                                       boolean forward) {

        // ---- determine what we have to work with ----
<span class="nc" id="L329">        float totalPlay = Math.min(pref - allocated, pref - min);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        float factor = (pref - min == 0) ? 0.0f : totalPlay / (pref - min);</span>

        // ---- make the adjustments ----
        int totalOffset;
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if( forward ) {</span>
            // lay out with offsets increasing from 0
<span class="nc" id="L336">            totalOffset = 0;</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">            for (int i = 0; i &lt; spans.length; i++) {</span>
<span class="nc" id="L338">                offsets[i] = totalOffset;</span>
<span class="nc" id="L339">                SizeRequirements req = request[i];</span>
<span class="nc" id="L340">                float play = factor * (req.preferred - req.minimum);</span>
<span class="nc" id="L341">                spans[i] = (int)(req.preferred - play);</span>
<span class="nc" id="L342">                totalOffset = (int) Math.min((long) totalOffset + (long) spans[i], Integer.MAX_VALUE);</span>
            }
        } else {
            // lay out with offsets decreasing from the end of the allocation
<span class="nc" id="L346">            totalOffset = allocated;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            for (int i = 0; i &lt; spans.length; i++) {</span>
<span class="nc" id="L348">                SizeRequirements req = request[i];</span>
<span class="nc" id="L349">                float play = factor * (req.preferred - req.minimum);</span>
<span class="nc" id="L350">                spans[i] = (int)(req.preferred - play);</span>
<span class="nc" id="L351">                offsets[i] = totalOffset - spans[i];</span>
<span class="nc" id="L352">                totalOffset = (int) Math.max((long) totalOffset - (long) spans[i], 0);</span>
            }
        }
<span class="nc" id="L355">    }</span>

    private static void expandedTile(int allocated, long min, long pref, long max,
                                     SizeRequirements[] request,
                                     int[] offsets, int[] spans,
                                     boolean forward) {

        // ---- determine what we have to work with ----
<span class="nc" id="L363">        float totalPlay = Math.min(allocated - pref, max - pref);</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">        float factor = (max - pref == 0) ? 0.0f : totalPlay / (max - pref);</span>

        // ---- make the adjustments ----
        int totalOffset;
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if( forward ) {</span>
            // lay out with offsets increasing from 0
<span class="nc" id="L370">            totalOffset = 0;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">            for (int i = 0; i &lt; spans.length; i++) {</span>
<span class="nc" id="L372">                offsets[i] = totalOffset;</span>
<span class="nc" id="L373">                SizeRequirements req = request[i];</span>
<span class="nc" id="L374">                int play = (int)(factor * (req.maximum - req.preferred));</span>
<span class="nc" id="L375">                spans[i] = (int) Math.min((long) req.preferred + (long) play, Integer.MAX_VALUE);</span>
<span class="nc" id="L376">                totalOffset = (int) Math.min((long) totalOffset + (long) spans[i], Integer.MAX_VALUE);</span>
            }
        } else {
            // lay out with offsets decreasing from the end of the allocation
<span class="nc" id="L380">            totalOffset = allocated;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">            for (int i = 0; i &lt; spans.length; i++) {</span>
<span class="nc" id="L382">                SizeRequirements req = request[i];</span>
<span class="nc" id="L383">                int play = (int)(factor * (req.maximum - req.preferred));</span>
<span class="nc" id="L384">                spans[i] = (int) Math.min((long) req.preferred + (long) play, Integer.MAX_VALUE);</span>
<span class="nc" id="L385">                offsets[i] = totalOffset - spans[i];</span>
<span class="nc" id="L386">                totalOffset = (int) Math.max((long) totalOffset - (long) spans[i], 0);</span>
            }
        }
<span class="nc" id="L389">    }</span>

    /**
     * Creates a bunch of offset/span pairs specifying how to
     * lay out a set of components with the specified alignments.
     * The resulting span allocations will overlap, with each one
     * fitting as well as possible into the given total allocation.
     * This method requires that you specify
     * the total amount of space to be allocated,
     * the size requirements for each component to be placed
     * (specified as an array of SizeRequirements), and
     * the total size requirements of the set of components
     * (only the alignment field of which is actually used).
     * You can get the total size requirement by invoking
     * getAlignedSizeRequirements.
     *
     * Normal alignment will be done with an alignment value of 0.0f
     * representing the left/top edge of a component.
     *
     * @param allocated the total span to be allocated &amp;gt;= 0.
     * @param total     the total of the children requests.
     * @param children  the size requirements for each component.
     * @param offsets   the offset from 0 for each child where
     *   the spans were allocated (determines placement of the span).
     * @param spans     the span allocated for each child to make the
     *   total target span.
     */
    public static void calculateAlignedPositions(int allocated,
                                                 SizeRequirements total,
                                                 SizeRequirements[] children,
                                                 int[] offsets,
                                                 int[] spans) {
<span class="nc" id="L421">        calculateAlignedPositions( allocated, total, children, offsets, spans, true );</span>
<span class="nc" id="L422">    }</span>

    /**
     * Creates a set of offset/span pairs specifying how to
     * lay out a set of components with the specified alignments.
     * The resulting span allocations will overlap, with each one
     * fitting as well as possible into the given total allocation.
     * This method requires that you specify
     * the total amount of space to be allocated,
     * the size requirements for each component to be placed
     * (specified as an array of SizeRequirements), and
     * the total size requirements of the set of components
     * (only the alignment field of which is actually used)
     * You can get the total size requirement by invoking
     * getAlignedSizeRequirements.
     *
     * This method also requires a flag indicating whether normal or
     * reverse alignment should be performed.  With normal alignment
     * the value 0.0f represents the left/top edge of the component
     * to be aligned.  With reverse alignment, 0.0f represents the
     * right/bottom edge.
     *
     * @param allocated the total span to be allocated &amp;gt;= 0.
     * @param total     the total of the children requests.
     * @param children  the size requirements for each component.
     * @param offsets   the offset from 0 for each child where
     *   the spans were allocated (determines placement of the span).
     * @param spans     the span allocated for each child to make the
     *   total target span.
     * @param normal    when true, the alignment value 0.0f means
     *   left/top; when false, it means right/bottom.
     * @since 1.4
     */
    public static void calculateAlignedPositions(int allocated,
                                                 SizeRequirements total,
                                                 SizeRequirements[] children,
                                                 int[] offsets,
                                                 int[] spans,
                                                 boolean normal) {
<span class="nc bnc" id="L461" title="All 2 branches missed.">        float totalAlignment = normal ? total.alignment : 1.0f - total.alignment;</span>
<span class="nc" id="L462">        int totalAscent = (int)(allocated * totalAlignment);</span>
<span class="nc" id="L463">        int totalDescent = allocated - totalAscent;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        for (int i = 0; i &lt; children.length; i++) {</span>
<span class="nc" id="L465">            SizeRequirements req = children[i];</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            float alignment = normal ? req.alignment : 1.0f - req.alignment;</span>
<span class="nc" id="L467">            int maxAscent = (int)(req.maximum * alignment);</span>
<span class="nc" id="L468">            int maxDescent = req.maximum - maxAscent;</span>
<span class="nc" id="L469">            int ascent = Math.min(totalAscent, maxAscent);</span>
<span class="nc" id="L470">            int descent = Math.min(totalDescent, maxDescent);</span>

<span class="nc" id="L472">            offsets[i] = totalAscent - ascent;</span>
<span class="nc" id="L473">            spans[i] = (int) Math.min((long) ascent + (long) descent, Integer.MAX_VALUE);</span>
        }
<span class="nc" id="L475">    }</span>

    // This method was used by the JTable - which now uses a different technique.
    /**
     * Adjust a specified array of sizes by a given amount.
     *
     * @param delta     an int specifying the size difference
     * @param children  an array of SizeRequirements objects
     * @return an array of ints containing the final size for each item
     */
    public static int[] adjustSizes(int delta, SizeRequirements[] children) {
<span class="nc" id="L486">      return new int[0];</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>