<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>UIManager.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">UIManager.java</span></div><h1>UIManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.awt.Component;
import java.awt.Font;
import java.awt.Color;
import java.awt.Insets;
import java.awt.Dimension;
import java.awt.KeyboardFocusManager;
import java.awt.KeyEventPostProcessor;
import java.awt.Toolkit;

import java.awt.event.KeyEvent;

import java.security.AccessController;

import javax.swing.plaf.ComponentUI;
import javax.swing.border.Border;

import javax.swing.event.SwingPropertyChangeSupport;
import java.beans.PropertyChangeListener;

import java.io.Serializable;
import java.io.File;
import java.io.FileInputStream;

import java.util.ArrayList;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.Locale;

import sun.awt.SunToolkit;
import sun.awt.OSInfo;
import sun.security.action.GetPropertyAction;
import sun.swing.SwingUtilities2;
import java.lang.reflect.Method;
import java.util.HashMap;
import sun.awt.AppContext;
import sun.awt.AWTAccessor;


/**
 * {@code UIManager} manages the current look and feel, the set of
 * available look and feels, {@code PropertyChangeListeners} that
 * are notified when the look and feel changes, look and feel defaults, and
 * convenience methods for obtaining various default values.
 *
 * &lt;h3&gt;Specifying the look and feel&lt;/h3&gt;
 *
 * The look and feel can be specified in two distinct ways: by
 * specifying the fully qualified name of the class for the look and
 * feel, or by creating an instance of {@code LookAndFeel} and passing
 * it to {@code setLookAndFeel}. The following example illustrates
 * setting the look and feel to the system look and feel:
 * &lt;pre&gt;
 *   UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
 * &lt;/pre&gt;
 * The following example illustrates setting the look and feel based on
 * class name:
 * &lt;pre&gt;
 *   UIManager.setLookAndFeel(&quot;javax.swing.plaf.metal.MetalLookAndFeel&quot;);
 * &lt;/pre&gt;
 * Once the look and feel has been changed it is imperative to invoke
 * {@code updateUI} on all {@code JComponents}. The method {@link
 * SwingUtilities#updateComponentTreeUI} makes it easy to apply {@code
 * updateUI} to a containment hierarchy. Refer to it for
 * details. The exact behavior of not invoking {@code
 * updateUI} after changing the look and feel is
 * unspecified. It is very possible to receive unexpected exceptions,
 * painting problems, or worse.
 *
 * &lt;h3&gt;Default look and feel&lt;/h3&gt;
 *
 * The class used for the default look and feel is chosen in the following
 * manner:
 * &lt;ol&gt;
 *   &lt;li&gt;If the system property &lt;code&gt;swing.defaultlaf&lt;/code&gt; is
 *       {@code non-null}, use its value as the default look and feel class
 *       name.
 *   &lt;li&gt;If the {@link java.util.Properties} file &lt;code&gt;swing.properties&lt;/code&gt;
 *       exists and contains the key &lt;code&gt;swing.defaultlaf&lt;/code&gt;,
 *       use its value as the default look and feel class name. The location
 *       that is checked for &lt;code&gt;swing.properties&lt;/code&gt; may vary depending
 *       upon the implementation of the Java platform. Typically the
 *       &lt;code&gt;swing.properties&lt;/code&gt; file is located in the &lt;code&gt;lib&lt;/code&gt;
 *       subdirectory of the Java installation directory.
 *       Refer to the release notes of the implementation being used for
 *       further details.
 *   &lt;li&gt;Otherwise use the cross platform look and feel.
 * &lt;/ol&gt;
 *
 * &lt;h3&gt;Defaults&lt;/h3&gt;
 *
 * {@code UIManager} manages three sets of {@code UIDefaults}. In order, they
 * are:
 * &lt;ol&gt;
 *   &lt;li&gt;Developer defaults. With few exceptions Swing does not
 *       alter the developer defaults; these are intended to be modified
 *       and used by the developer.
 *   &lt;li&gt;Look and feel defaults. The look and feel defaults are
 *       supplied by the look and feel at the time it is installed as the
 *       current look and feel ({@code setLookAndFeel()} is invoked). The
 *       look and feel defaults can be obtained using the {@code
 *       getLookAndFeelDefaults()} method.
 *   &lt;li&gt;System defaults. The system defaults are provided by Swing.
 * &lt;/ol&gt;
 * Invoking any of the various {@code get} methods
 * results in checking each of the defaults, in order, returning
 * the first {@code non-null} value. For example, invoking
 * {@code UIManager.getString(&quot;Table.foreground&quot;)} results in first
 * checking developer defaults. If the developer defaults contain
 * a value for {@code &quot;Table.foreground&quot;} it is returned, otherwise
 * the look and feel defaults are checked, followed by the system defaults.
 * &lt;p&gt;
 * It's important to note that {@code getDefaults} returns a custom
 * instance of {@code UIDefaults} with this resolution logic built into it.
 * For example, {@code UIManager.getDefaults().getString(&quot;Table.foreground&quot;)}
 * is equivalent to {@code UIManager.getString(&quot;Table.foreground&quot;)}. Both
 * resolve using the algorithm just described. In many places the
 * documentation uses the word defaults to refer to the custom instance
 * of {@code UIDefaults} with the resolution logic as previously described.
 * &lt;p&gt;
 * When the look and feel is changed, {@code UIManager} alters only the
 * look and feel defaults; the developer and system defaults are not
 * altered by the {@code UIManager} in any way.
 * &lt;p&gt;
 * The set of defaults a particular look and feel supports is defined
 * and documented by that look and feel. In addition, each look and
 * feel, or {@code ComponentUI} provided by a look and feel, may
 * access the defaults at different times in their life cycle. Some
 * look and feels may aggressively look up defaults, so that changing a
 * default may not have an effect after installing the look and feel.
 * Other look and feels may lazily access defaults so that a change to
 * the defaults may effect an existing look and feel. Finally, other look
 * and feels might not configure themselves from the defaults table in
 * any way. None-the-less it is usually the case that a look and feel
 * expects certain defaults, so that in general
 * a {@code ComponentUI} provided by one look and feel will not
 * work with another look and feel.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author Thomas Ball
 * @author Hans Muller
 */
<span class="nc" id="L177">public class UIManager implements Serializable</span>
{
    /**
     * This class defines the state managed by the &lt;code&gt;UIManager&lt;/code&gt;.  For
     * Swing applications the fields in this class could just as well
     * be static members of &lt;code&gt;UIManager&lt;/code&gt; however we give them
     * &quot;AppContext&quot;
     * scope instead so that applets (and potentially multiple lightweight
     * applications running in a single VM) have their own state. For example,
     * an applet can alter its look and feel, see &lt;code&gt;setLookAndFeel&lt;/code&gt;.
     * Doing so has no affect on other applets (or the browser).
     */
<span class="fc" id="L189">    private static class LAFState</span>
    {
        Properties swingProps;
<span class="fc" id="L192">        private UIDefaults[] tables = new UIDefaults[2];</span>

<span class="fc" id="L194">        boolean initialized = false;</span>
<span class="fc" id="L195">        boolean focusPolicyInitialized = false;</span>
<span class="fc" id="L196">        MultiUIDefaults multiUIDefaults = new MultiUIDefaults(tables);</span>
        LookAndFeel lookAndFeel;
<span class="fc" id="L198">        LookAndFeel multiLookAndFeel = null;</span>
<span class="fc" id="L199">        Vector&lt;LookAndFeel&gt; auxLookAndFeels = null;</span>
        SwingPropertyChangeSupport changeSupport;

        LookAndFeelInfo[] installedLAFs;

<span class="nc" id="L204">        UIDefaults getLookAndFeelDefaults() { return tables[0]; }</span>
<span class="fc" id="L205">        void setLookAndFeelDefaults(UIDefaults x) { tables[0] = x; }</span>

<span class="nc" id="L207">        UIDefaults getSystemDefaults() { return tables[1]; }</span>
<span class="nc" id="L208">        void setSystemDefaults(UIDefaults x) { tables[1] = x; }</span>

        /**
         * Returns the SwingPropertyChangeSupport for the current
         * AppContext.  If &lt;code&gt;create&lt;/code&gt; is a true, a non-null
         * &lt;code&gt;SwingPropertyChangeSupport&lt;/code&gt; will be returned, if
         * &lt;code&gt;create&lt;/code&gt; is false and this has not been invoked
         * with true, null will be returned.
         */
        public synchronized SwingPropertyChangeSupport
                                 getPropertyChangeSupport(boolean create) {
<span class="pc bpc" id="L219" title="3 of 4 branches missed.">            if (create &amp;&amp; changeSupport == null) {</span>
<span class="nc" id="L220">                changeSupport = new SwingPropertyChangeSupport(</span>
                                         UIManager.class);
            }
<span class="fc" id="L223">            return changeSupport;</span>
        }
    }




    /* Lock object used in place of class object for synchronization. (4187686)
     */
<span class="fc" id="L232">    private static final Object classLock = new Object();</span>

    /**
     * Return the &lt;code&gt;LAFState&lt;/code&gt; object, lazily create one if necessary.
     * All access to the &lt;code&gt;LAFState&lt;/code&gt; fields is done via this method,
     * for example:
     * &lt;pre&gt;
     *     getLAFState().initialized = true;
     * &lt;/pre&gt;
     */
    private static LAFState getLAFState() {
<span class="fc" id="L243">        LAFState rv = (LAFState)SwingUtilities.appContextGet(</span>
                SwingUtilities2.LAF_STATE_KEY);
<span class="fc bfc" id="L245" title="All 2 branches covered.">        if (rv == null) {</span>
<span class="fc" id="L246">            synchronized (classLock) {</span>
<span class="fc" id="L247">                rv = (LAFState)SwingUtilities.appContextGet(</span>
                        SwingUtilities2.LAF_STATE_KEY);
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">                if (rv == null) {</span>
<span class="fc" id="L250">                    SwingUtilities.appContextPut(</span>
                            SwingUtilities2.LAF_STATE_KEY,
                            (rv = new LAFState()));
                }
<span class="pc" id="L254">            }</span>
        }
<span class="fc" id="L256">        return rv;</span>
    }


    /* Keys used in the &lt;code&gt;swing.properties&lt;/code&gt; properties file.
     * See loadUserProperties(), initialize().
     */

    private static final String defaultLAFKey = &quot;swing.defaultlaf&quot;;
    private static final String auxiliaryLAFsKey = &quot;swing.auxiliarylaf&quot;;
    private static final String multiplexingLAFKey = &quot;swing.plaf.multiplexinglaf&quot;;
    private static final String installedLAFsKey = &quot;swing.installedlafs&quot;;
    private static final String disableMnemonicKey = &quot;swing.disablenavaids&quot;;

    /**
     * Return a &lt;code&gt;swing.properties&lt;/code&gt; file key for the attribute of specified
     * look and feel.  The attr is either &quot;name&quot; or &quot;class&quot;, a typical
     * key would be: &quot;swing.installedlaf.windows.name&quot;
     */
    private static String makeInstalledLAFKey(String laf, String attr) {
<span class="nc" id="L276">        return &quot;swing.installedlaf.&quot; + laf + &quot;.&quot; + attr;</span>
    }

    /**
     * The location of the &lt;code&gt;swing.properties&lt;/code&gt; property file is
     * implementation-specific.
     * It is typically located in the &lt;code&gt;lib&lt;/code&gt; subdirectory of the Java
     * installation directory. This method returns a bogus filename
     * if &lt;code&gt;java.home&lt;/code&gt; isn't defined.
     */
    private static String makeSwingPropertiesFilename() {
<span class="fc" id="L287">        String sep = File.separator;</span>
        // No need to wrap this in a doPrivileged as it's called from
        // a doPrivileged.
<span class="fc" id="L290">        String javaHome = System.getProperty(&quot;java.home&quot;);</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (javaHome == null) {</span>
<span class="nc" id="L292">            javaHome = &quot;&lt;java.home undefined&gt;&quot;;</span>
        }
<span class="fc" id="L294">        return javaHome + sep + &quot;lib&quot; + sep + &quot;swing.properties&quot;;</span>
    }


    /**
     * Provides a little information about an installed
     * &lt;code&gt;LookAndFeel&lt;/code&gt; for the sake of configuring a menu or
     * for initial application set up.
     *
     * @see UIManager#getInstalledLookAndFeels
     * @see LookAndFeel
     */
<span class="nc" id="L306">    public static class LookAndFeelInfo {</span>
        private String name;
        private String className;

        /**
         * Constructs a &lt;code&gt;UIManager&lt;/code&gt;s
         * &lt;code&gt;LookAndFeelInfo&lt;/code&gt; object.
         *
         * @param name      a &lt;code&gt;String&lt;/code&gt; specifying the name of
         *                      the look and feel
         * @param className a &lt;code&gt;String&lt;/code&gt; specifying the name of
         *                      the class that implements the look and feel
         */
<span class="fc" id="L319">        public LookAndFeelInfo(String name, String className) {</span>
<span class="fc" id="L320">            this.name = name;</span>
<span class="fc" id="L321">            this.className = className;</span>
<span class="fc" id="L322">        }</span>

        /**
         * Returns the name of the look and feel in a form suitable
         * for a menu or other presentation
         * @return a &lt;code&gt;String&lt;/code&gt; containing the name
         * @see LookAndFeel#getName
         */
        public String getName() {
<span class="nc" id="L331">            return name;</span>
        }

        /**
         * Returns the name of the class that implements this look and feel.
         * @return the name of the class that implements this
         *              &lt;code&gt;LookAndFeel&lt;/code&gt;
         * @see LookAndFeel
         */
        public String getClassName() {
<span class="nc" id="L341">            return className;</span>
        }

        /**
         * Returns a string that displays and identifies this
         * object's properties.
         *
         * @return a &lt;code&gt;String&lt;/code&gt; representation of this object
         */
        public String toString() {
<span class="nc" id="L351">            return getClass().getName() + &quot;[&quot; + getName() + &quot; &quot; + getClassName() + &quot;]&quot;;</span>
        }
    }


    /**
     * The default value of &lt;code&gt;installedLAFS&lt;/code&gt; is used when no
     * &lt;code&gt;swing.properties&lt;/code&gt;
     * file is available or if the file doesn't contain a &quot;swing.installedlafs&quot;
     * property.
     *
     * @see #initializeInstalledLAFs
     */
    private static LookAndFeelInfo[] installedLAFs;

    static {
<span class="fc" id="L367">        ArrayList&lt;LookAndFeelInfo&gt; iLAFs = new ArrayList&lt;LookAndFeelInfo&gt;(4);</span>
<span class="fc" id="L368">        iLAFs.add(new LookAndFeelInfo(</span>
                      &quot;Metal&quot;, &quot;javax.swing.plaf.metal.MetalLookAndFeel&quot;));
<span class="fc" id="L370">        iLAFs.add(new LookAndFeelInfo(</span>
                      &quot;Nimbus&quot;, &quot;javax.swing.plaf.nimbus.NimbusLookAndFeel&quot;));
<span class="fc" id="L372">        iLAFs.add(new LookAndFeelInfo(&quot;CDE/Motif&quot;,</span>
                  &quot;com.sun.java.swing.plaf.motif.MotifLookAndFeel&quot;));

        // Only include windows on Windows boxs.
<span class="fc" id="L376">        OSInfo.OSType osType = AccessController.doPrivileged(OSInfo.getOSTypeAction());</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        if (osType == OSInfo.OSType.WINDOWS) {</span>
<span class="nc" id="L378">            iLAFs.add(new LookAndFeelInfo(&quot;Windows&quot;,</span>
                        &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot;));
<span class="nc bnc" id="L380" title="All 2 branches missed.">            if (Toolkit.getDefaultToolkit().getDesktopProperty(</span>
                    &quot;win.xpstyle.themeActive&quot;) != null) {
<span class="nc" id="L382">                iLAFs.add(new LookAndFeelInfo(&quot;Windows Classic&quot;,</span>
                 &quot;com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel&quot;));
            }
        }
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        else if (osType == OSInfo.OSType.MACOSX) {</span>
<span class="nc" id="L387">            iLAFs.add(new LookAndFeelInfo(&quot;Mac OS X&quot;, &quot;com.apple.laf.AquaLookAndFeel&quot;));</span>
        }
        else {
            // GTK is not shipped on Windows.
<span class="fc" id="L391">            iLAFs.add(new LookAndFeelInfo(&quot;GTK+&quot;,</span>
                  &quot;com.sun.java.swing.plaf.gtk.GTKLookAndFeel&quot;));
        }
<span class="fc" id="L394">        installedLAFs = iLAFs.toArray(new LookAndFeelInfo[iLAFs.size()]);</span>
<span class="fc" id="L395">    }</span>


    /**
     * Returns an array of {@code LookAndFeelInfo}s representing the
     * {@code LookAndFeel} implementations currently available. The
     * &lt;code&gt;LookAndFeelInfo&lt;/code&gt; objects can be used by an
     * application to construct a menu of look and feel options for
     * the user, or to determine which look and feel to set at startup
     * time. To avoid the penalty of creating numerous {@code
     * LookAndFeel} objects, {@code LookAndFeelInfo} maintains the
     * class name of the {@code LookAndFeel} class, not the actual
     * {@code LookAndFeel} instance.
     * &lt;p&gt;
     * The following example illustrates setting the current look and feel
     * from an instance of {@code LookAndFeelInfo}:
     * &lt;pre&gt;
     *   UIManager.setLookAndFeel(info.getClassName());
     * &lt;/pre&gt;
     *
     * @return an array of &lt;code&gt;LookAndFeelInfo&lt;/code&gt; objects
     * @see #setLookAndFeel
     */
    public static LookAndFeelInfo[] getInstalledLookAndFeels() {
<span class="nc" id="L419">        maybeInitialize();</span>
<span class="nc" id="L420">        LookAndFeelInfo[] ilafs = getLAFState().installedLAFs;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (ilafs == null) {</span>
<span class="nc" id="L422">            ilafs = installedLAFs;</span>
        }
<span class="nc" id="L424">        LookAndFeelInfo[] rv = new LookAndFeelInfo[ilafs.length];</span>
<span class="nc" id="L425">        System.arraycopy(ilafs, 0, rv, 0, ilafs.length);</span>
<span class="nc" id="L426">        return rv;</span>
    }


    /**
     * Sets the set of available look and feels. While this method does
     * not check to ensure all of the {@code LookAndFeelInfos} are
     * {@code non-null}, it is strongly recommended that only {@code non-null}
     * values are supplied in the {@code infos} array.
     *
     * @param infos set of &lt;code&gt;LookAndFeelInfo&lt;/code&gt; objects specifying
     *        the available look and feels
     *
     * @see #getInstalledLookAndFeels
     * @throws NullPointerException if {@code infos} is {@code null}
     */
    public static void setInstalledLookAndFeels(LookAndFeelInfo[] infos)
        throws SecurityException
    {
<span class="nc" id="L445">        maybeInitialize();</span>
<span class="nc" id="L446">        LookAndFeelInfo[] newInfos = new LookAndFeelInfo[infos.length];</span>
<span class="nc" id="L447">        System.arraycopy(infos, 0, newInfos, 0, infos.length);</span>
<span class="nc" id="L448">        getLAFState().installedLAFs = newInfos;</span>
<span class="nc" id="L449">    }</span>


    /**
     * Adds the specified look and feel to the set of available look
     * and feels. While this method allows a {@code null} {@code info},
     * it is strongly recommended that a {@code non-null} value be used.
     *
     * @param info a &lt;code&gt;LookAndFeelInfo&lt;/code&gt; object that names the
     *          look and feel and identifies the class that implements it
     * @see #setInstalledLookAndFeels
     */
    public static void installLookAndFeel(LookAndFeelInfo info) {
<span class="nc" id="L462">        LookAndFeelInfo[] infos = getInstalledLookAndFeels();</span>
<span class="nc" id="L463">        LookAndFeelInfo[] newInfos = new LookAndFeelInfo[infos.length + 1];</span>
<span class="nc" id="L464">        System.arraycopy(infos, 0, newInfos, 0, infos.length);</span>
<span class="nc" id="L465">        newInfos[infos.length] = info;</span>
<span class="nc" id="L466">        setInstalledLookAndFeels(newInfos);</span>
<span class="nc" id="L467">    }</span>


    /**
     * Adds the specified look and feel to the set of available look
     * and feels. While this method does not check the
     * arguments in any way, it is strongly recommended that {@code
     * non-null} values be supplied.
     *
     * @param name descriptive name of the look and feel
     * @param className name of the class that implements the look and feel
     * @see #setInstalledLookAndFeels
     */
    public static void installLookAndFeel(String name, String className) {
<span class="nc" id="L481">        installLookAndFeel(new LookAndFeelInfo(name, className));</span>
<span class="nc" id="L482">    }</span>


    /**
     * Returns the current look and feel or &lt;code&gt;null&lt;/code&gt;.
     *
     * @return current look and feel, or &lt;code&gt;null&lt;/code&gt;
     * @see #setLookAndFeel
     */
    public static LookAndFeel getLookAndFeel() {
<span class="nc" id="L492">        maybeInitialize();</span>
<span class="nc" id="L493">        return getLAFState().lookAndFeel;</span>
    }


    /**
     * Sets the current look and feel to {@code newLookAndFeel}.
     * If the current look and feel is {@code non-null} {@code
     * uninitialize} is invoked on it. If {@code newLookAndFeel} is
     * {@code non-null}, {@code initialize} is invoked on it followed
     * by {@code getDefaults}. The defaults returned from {@code
     * newLookAndFeel.getDefaults()} replace those of the defaults
     * from the previous look and feel. If the {@code newLookAndFeel} is
     * {@code null}, the look and feel defaults are set to {@code null}.
     * &lt;p&gt;
     * A value of {@code null} can be used to set the look and feel
     * to {@code null}. As the {@code LookAndFeel} is required for
     * most of Swing to function, setting the {@code LookAndFeel} to
     * {@code null} is strongly discouraged.
     * &lt;p&gt;
     * This is a JavaBeans bound property.
     *
     * @param newLookAndFeel {@code LookAndFeel} to install
     * @throws UnsupportedLookAndFeelException if
     *          {@code newLookAndFeel} is {@code non-null} and
     *          {@code newLookAndFeel.isSupportedLookAndFeel()} returns
     *          {@code false}
     * @see #getLookAndFeel
     */
    public static void setLookAndFeel(LookAndFeel newLookAndFeel)
        throws UnsupportedLookAndFeelException
    {
<span class="pc bpc" id="L524" title="2 of 4 branches missed.">        if ((newLookAndFeel != null) &amp;&amp; !newLookAndFeel.isSupportedLookAndFeel()) {</span>
<span class="nc" id="L525">            String s = newLookAndFeel.toString() + &quot; not supported on this platform&quot;;</span>
<span class="nc" id="L526">            throw new UnsupportedLookAndFeelException(s);</span>
        }

<span class="fc" id="L529">        LAFState lafState = getLAFState();</span>
<span class="fc" id="L530">        LookAndFeel oldLookAndFeel = lafState.lookAndFeel;</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (oldLookAndFeel != null) {</span>
<span class="nc" id="L532">            oldLookAndFeel.uninitialize();</span>
        }

<span class="fc" id="L535">        lafState.lookAndFeel = newLookAndFeel;</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">        if (newLookAndFeel != null) {</span>
<span class="fc" id="L537">            sun.swing.DefaultLookup.setDefaultLookup(null);</span>
<span class="fc" id="L538">            newLookAndFeel.initialize();</span>
<span class="fc" id="L539">            lafState.setLookAndFeelDefaults(newLookAndFeel.getDefaults());</span>
        }
        else {
<span class="nc" id="L542">            lafState.setLookAndFeelDefaults(null);</span>
        }

<span class="fc" id="L545">        SwingPropertyChangeSupport changeSupport = lafState.</span>
<span class="fc" id="L546">                                         getPropertyChangeSupport(false);</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        if (changeSupport != null) {</span>
<span class="nc" id="L548">            changeSupport.firePropertyChange(&quot;lookAndFeel&quot;, oldLookAndFeel,</span>
                                             newLookAndFeel);
        }
<span class="fc" id="L551">    }</span>


    /**
     * Loads the {@code LookAndFeel} specified by the given class
     * name, using the current thread's context class loader, and
     * passes it to {@code setLookAndFeel(LookAndFeel)}.
     *
     * @param className  a string specifying the name of the class that implements
     *        the look and feel
     * @exception ClassNotFoundException if the &lt;code&gt;LookAndFeel&lt;/code&gt;
     *           class could not be found
     * @exception InstantiationException if a new instance of the class
     *          couldn't be created
     * @exception IllegalAccessException if the class or initializer isn't accessible
     * @exception UnsupportedLookAndFeelException if
     *          &lt;code&gt;lnf.isSupportedLookAndFeel()&lt;/code&gt; is false
     * @throws ClassCastException if {@code className} does not identify
     *         a class that extends {@code LookAndFeel}
     */
    public static void setLookAndFeel(String className)
        throws ClassNotFoundException,
               InstantiationException,
               IllegalAccessException,
               UnsupportedLookAndFeelException
    {
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">        if (&quot;javax.swing.plaf.metal.MetalLookAndFeel&quot;.equals(className)) {</span>
            // Avoid reflection for the common case of metal.
<span class="fc" id="L579">            setLookAndFeel(new javax.swing.plaf.metal.MetalLookAndFeel());</span>
        }
        else {
<span class="nc" id="L582">            Class lnfClass = SwingUtilities.loadSystemClass(className);</span>
<span class="nc" id="L583">            setLookAndFeel((LookAndFeel)(lnfClass.newInstance()));</span>
        }
<span class="fc" id="L585">    }</span>

    /**
     * Returns the name of the &lt;code&gt;LookAndFeel&lt;/code&gt; class that implements
     * the native system look and feel if there is one, otherwise
     * the name of the default cross platform &lt;code&gt;LookAndFeel&lt;/code&gt;
     * class. This value can be overriden by setting the
     * &lt;code&gt;swing.systemlaf&lt;/code&gt; system property.
     *
     * @return the &lt;code&gt;String&lt;/code&gt; of the &lt;code&gt;LookAndFeel&lt;/code&gt;
     *          class
     *
     * @see #setLookAndFeel
     * @see #getCrossPlatformLookAndFeelClassName
     */
    public static String getSystemLookAndFeelClassName() {
<span class="nc" id="L601">        String systemLAF = AccessController.doPrivileged(</span>
                             new GetPropertyAction(&quot;swing.systemlaf&quot;));
<span class="nc bnc" id="L603" title="All 2 branches missed.">        if (systemLAF != null) {</span>
<span class="nc" id="L604">            return systemLAF;</span>
        }
<span class="nc" id="L606">        OSInfo.OSType osType = AccessController.doPrivileged(OSInfo.getOSTypeAction());</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">        if (osType == OSInfo.OSType.WINDOWS) {</span>
<span class="nc" id="L608">            return &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot;;</span>
        } else {
<span class="nc" id="L610">            String desktop = AccessController.doPrivileged(new GetPropertyAction(&quot;sun.desktop&quot;));</span>
<span class="nc" id="L611">            Toolkit toolkit = Toolkit.getDefaultToolkit();</span>
<span class="nc bnc" id="L612" title="All 4 branches missed.">            if (&quot;gnome&quot;.equals(desktop) &amp;&amp;</span>
                    toolkit instanceof SunToolkit &amp;&amp;
<span class="nc bnc" id="L614" title="All 2 branches missed.">                    ((SunToolkit) toolkit).isNativeGTKAvailable()) {</span>
                // May be set on Linux and Solaris boxs.
<span class="nc" id="L616">                return &quot;com.sun.java.swing.plaf.gtk.GTKLookAndFeel&quot;;</span>
            }
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if (osType == OSInfo.OSType.MACOSX) {</span>
<span class="nc" id="L619">                if (toolkit.getClass() .getName()</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">                                       .equals(&quot;sun.lwawt.macosx.LWCToolkit&quot;)) {</span>
<span class="nc" id="L621">                    return &quot;com.apple.laf.AquaLookAndFeel&quot;;</span>
                }
            }
<span class="nc bnc" id="L624" title="All 2 branches missed.">            if (osType == OSInfo.OSType.SOLARIS) {</span>
<span class="nc" id="L625">                return &quot;com.sun.java.swing.plaf.motif.MotifLookAndFeel&quot;;</span>
            }
        }
<span class="nc" id="L628">        return getCrossPlatformLookAndFeelClassName();</span>
    }


    /**
     * Returns the name of the &lt;code&gt;LookAndFeel&lt;/code&gt; class that implements
     * the default cross platform look and feel -- the Java
     * Look and Feel (JLF).  This value can be overriden by setting the
     * &lt;code&gt;swing.crossplatformlaf&lt;/code&gt; system property.
     *
     * @return  a string with the JLF implementation-class
     * @see #setLookAndFeel
     * @see #getSystemLookAndFeelClassName
     */
    public static String getCrossPlatformLookAndFeelClassName() {
<span class="fc" id="L643">        String laf = AccessController.doPrivileged(</span>
                             new GetPropertyAction(&quot;swing.crossplatformlaf&quot;));
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">        if (laf != null) {</span>
<span class="nc" id="L646">            return laf;</span>
        }
<span class="fc" id="L648">        return &quot;javax.swing.plaf.metal.MetalLookAndFeel&quot;;</span>
    }


    /**
     * Returns the defaults. The returned defaults resolve using the
     * logic specified in the class documentation.
     *
     * @return a &lt;code&gt;UIDefaults&lt;/code&gt; object containing the default values
     */
    public static UIDefaults getDefaults() {
<span class="fc" id="L659">        maybeInitialize();</span>
<span class="fc" id="L660">        return getLAFState().multiUIDefaults;</span>
    }

    /**
     * Returns a font from the defaults. If the value for {@code key} is
     * not a {@code Font}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the font
     * @return the &lt;code&gt;Font&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     */
    public static Font getFont(Object key) {
<span class="nc" id="L672">        return getDefaults().getFont(key);</span>
    }

    /**
     * Returns a font from the defaults that is appropriate
     * for the given locale. If the value for {@code key} is
     * not a {@code Font}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the font
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the font is desired; refer
     *        to {@code UIDefaults} for details on how a {@code null}
     *        {@code Locale} is handled
     * @return the &lt;code&gt;Font&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     * @since 1.4
     */
    public static Font getFont(Object key, Locale l) {
<span class="nc" id="L689">        return getDefaults().getFont(key,l);</span>
    }

    /**
     * Returns a color from the defaults. If the value for {@code key} is
     * not a {@code Color}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the color
     * @return the &lt;code&gt;Color&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     */
    public static Color getColor(Object key) {
<span class="nc" id="L701">        return getDefaults().getColor(key);</span>
    }

    /**
     * Returns a color from the defaults that is appropriate
     * for the given locale. If the value for {@code key} is
     * not a {@code Color}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the color
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the color is desired; refer
     *        to {@code UIDefaults} for details on how a {@code null}
     *        {@code Locale} is handled
     * @return the &lt;code&gt;Color&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     * @since 1.4
     */
    public static Color getColor(Object key, Locale l) {
<span class="nc" id="L718">        return getDefaults().getColor(key,l);</span>
    }

    /**
     * Returns an &lt;code&gt;Icon&lt;/code&gt; from the defaults. If the value for
     * {@code key} is not an {@code Icon}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the icon
     * @return the &lt;code&gt;Icon&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     */
    public static Icon getIcon(Object key) {
<span class="nc" id="L730">        return getDefaults().getIcon(key);</span>
    }

    /**
     * Returns an &lt;code&gt;Icon&lt;/code&gt; from the defaults that is appropriate
     * for the given locale. If the value for
     * {@code key} is not an {@code Icon}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the icon
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the icon is desired; refer
     *        to {@code UIDefaults} for details on how a {@code null}
     *        {@code Locale} is handled
     * @return the &lt;code&gt;Icon&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     * @since 1.4
     */
    public static Icon getIcon(Object key, Locale l) {
<span class="nc" id="L747">        return getDefaults().getIcon(key,l);</span>
    }

    /**
     * Returns a border from the defaults. If the value for
     * {@code key} is not a {@code Border}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the border
     * @return the &lt;code&gt;Border&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     */
    public static Border getBorder(Object key) {
<span class="nc" id="L759">        return getDefaults().getBorder(key);</span>
    }

    /**
     * Returns a border from the defaults that is appropriate
     * for the given locale.  If the value for
     * {@code key} is not a {@code Border}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the border
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the border is desired; refer
     *        to {@code UIDefaults} for details on how a {@code null}
     *        {@code Locale} is handled
     * @return the &lt;code&gt;Border&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     * @since 1.4
     */
    public static Border getBorder(Object key, Locale l) {
<span class="nc" id="L776">        return getDefaults().getBorder(key,l);</span>
    }

    /**
     * Returns a string from the defaults. If the value for
     * {@code key} is not a {@code String}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the string
     * @return the &lt;code&gt;String&lt;/code&gt;
     * @throws NullPointerException if {@code key} is {@code null}
     */
    public static String getString(Object key) {
<span class="nc" id="L788">        return getDefaults().getString(key);</span>
    }

    /**
     * Returns a string from the defaults that is appropriate for the
     * given locale.  If the value for
     * {@code key} is not a {@code String}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the string
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the string is desired; refer
     *        to {@code UIDefaults} for details on how a {@code null}
     *        {@code Locale} is handled
     * @return the &lt;code&gt;String&lt;/code&gt;
     * @since 1.4
     * @throws NullPointerException if {@code key} is {@code null}
     */
    public static String getString(Object key, Locale l) {
<span class="nc" id="L805">        return getDefaults().getString(key,l);</span>
    }

    /**
     * Returns a string from the defaults that is appropriate for the
     * given locale.  If the value for
     * {@code key} is not a {@code String}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the string
     * @param c {@code Component} used to determine the locale;
     *          {@code null} implies the default locale as
     *          returned by {@code Locale.getDefault()}
     * @return the &lt;code&gt;String&lt;/code&gt;
     * @throws NullPointerException if {@code key} is {@code null}
     */
    static String getString(Object key, Component c) {
<span class="nc bnc" id="L821" title="All 2 branches missed.">        Locale l = (c == null) ? Locale.getDefault() : c.getLocale();</span>
<span class="nc" id="L822">        return getString(key, l);</span>
    }

    /**
     * Returns an integer from the defaults. If the value for
     * {@code key} is not an {@code Integer}, or does not exist,
     * {@code 0} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the int
     * @return the int
     * @throws NullPointerException if {@code key} is {@code null}
     */
    public static int getInt(Object key) {
<span class="nc" id="L835">        return getDefaults().getInt(key);</span>
    }

    /**
     * Returns an integer from the defaults that is appropriate
     * for the given locale. If the value for
     * {@code key} is not an {@code Integer}, or does not exist,
     * {@code 0} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the int
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the int is desired; refer
     *        to {@code UIDefaults} for details on how a {@code null}
     *        {@code Locale} is handled
     * @return the int
     * @throws NullPointerException if {@code key} is {@code null}
     * @since 1.4
     */
    public static int getInt(Object key, Locale l) {
<span class="nc" id="L853">        return getDefaults().getInt(key,l);</span>
    }

    /**
     * Returns a boolean from the defaults which is associated with
     * the key value. If the key is not found or the key doesn't represent
     * a boolean value then {@code false} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the key for the desired boolean value
     * @return the boolean value corresponding to the key
     * @throws NullPointerException if {@code key} is {@code null}
     * @since 1.4
     */
    public static boolean getBoolean(Object key) {
<span class="nc" id="L867">        return getDefaults().getBoolean(key);</span>
    }

    /**
     * Returns a boolean from the defaults which is associated with
     * the key value and the given &lt;code&gt;Locale&lt;/code&gt;. If the key is not
     * found or the key doesn't represent
     * a boolean value then {@code false} will be returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the key for the desired
     *             boolean value
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the boolean is desired; refer
     *        to {@code UIDefaults} for details on how a {@code null}
     *        {@code Locale} is handled
     * @return the boolean value corresponding to the key
     * @throws NullPointerException if {@code key} is {@code null}
     * @since 1.4
     */
    public static boolean getBoolean(Object key, Locale l) {
<span class="nc" id="L886">        return getDefaults().getBoolean(key,l);</span>
    }

    /**
     * Returns an &lt;code&gt;Insets&lt;/code&gt; object from the defaults. If the value
     * for {@code key} is not an {@code Insets}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the &lt;code&gt;Insets&lt;/code&gt; object
     * @return the &lt;code&gt;Insets&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     */
    public static Insets getInsets(Object key) {
<span class="nc" id="L898">        return getDefaults().getInsets(key);</span>
    }

    /**
     * Returns an &lt;code&gt;Insets&lt;/code&gt; object from the defaults that is
     * appropriate for the given locale. If the value
     * for {@code key} is not an {@code Insets}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the &lt;code&gt;Insets&lt;/code&gt; object
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the object is desired; refer
     *        to {@code UIDefaults} for details on how a {@code null}
     *        {@code Locale} is handled
     * @return the &lt;code&gt;Insets&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     * @since 1.4
     */
    public static Insets getInsets(Object key, Locale l) {
<span class="nc" id="L915">        return getDefaults().getInsets(key,l);</span>
    }

    /**
     * Returns a dimension from the defaults. If the value
     * for {@code key} is not a {@code Dimension}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the dimension object
     * @return the &lt;code&gt;Dimension&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     */
    public static Dimension getDimension(Object key) {
<span class="nc" id="L927">        return getDefaults().getDimension(key);</span>
    }

    /**
     * Returns a dimension from the defaults that is appropriate
     * for the given locale. If the value
     * for {@code key} is not a {@code Dimension}, {@code null} is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the dimension object
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the object is desired; refer
     *        to {@code UIDefaults} for details on how a {@code null}
     *        {@code Locale} is handled
     * @return the &lt;code&gt;Dimension&lt;/code&gt; object
     * @throws NullPointerException if {@code key} is {@code null}
     * @since 1.4
     */
    public static Dimension getDimension(Object key, Locale l) {
<span class="nc" id="L944">        return getDefaults().getDimension(key,l);</span>
    }

    /**
     * Returns an object from the defaults.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the desired object
     * @return the &lt;code&gt;Object&lt;/code&gt;
     * @throws NullPointerException if {@code key} is {@code null}
     */
    public static Object get(Object key) {
<span class="nc" id="L955">        return getDefaults().get(key);</span>
    }

    /**
     * Returns an object from the defaults that is appropriate for
     * the given locale.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the desired object
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the object is desired; refer
     *        to {@code UIDefaults} for details on how a {@code null}
     *        {@code Locale} is handled
     * @return the &lt;code&gt;Object&lt;/code&gt;
     * @throws NullPointerException if {@code key} is {@code null}
     * @since 1.4
     */
    public static Object get(Object key, Locale l) {
<span class="nc" id="L971">        return getDefaults().get(key,l);</span>
    }

    /**
     * Stores an object in the developer defaults. This is a cover method
     * for {@code getDefaults().put(key, value)}. This only effects the
     * developer defaults, not the system or look and feel defaults.
     *
     * @param key    an &lt;code&gt;Object&lt;/code&gt; specifying the retrieval key
     * @param value  the &lt;code&gt;Object&lt;/code&gt; to store; refer to
     *               {@code UIDefaults} for details on how {@code null} is
     *               handled
     * @return the &lt;code&gt;Object&lt;/code&gt; returned by {@link UIDefaults#put}
     * @throws NullPointerException if {@code key} is {@code null}
     * @see UIDefaults#put
     */
    public static Object put(Object key, Object value) {
<span class="nc" id="L988">        return getDefaults().put(key, value);</span>
    }

    /**
     * Returns the appropriate {@code ComponentUI} implementation for
     * {@code target}. Typically, this is a cover for
     * {@code getDefaults().getUI(target)}. However, if an auxiliary
     * look and feel has been installed, this first invokes
     * {@code getUI(target)} on the multiplexing look and feel's
     * defaults, and returns that value if it is {@code non-null}.
     *
     * @param target the &lt;code&gt;JComponent&lt;/code&gt; to return the
     *        {@code ComponentUI} for
     * @return the &lt;code&gt;ComponentUI&lt;/code&gt; object for {@code target}
     * @throws NullPointerException if {@code target} is {@code null}
     * @see UIDefaults#getUI
     */
    public static ComponentUI getUI(JComponent target) {
<span class="nc" id="L1006">        maybeInitialize();</span>
<span class="nc" id="L1007">        maybeInitializeFocusPolicy(target);</span>
<span class="nc" id="L1008">        ComponentUI ui = null;</span>
<span class="nc" id="L1009">        LookAndFeel multiLAF = getLAFState().multiLookAndFeel;</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        if (multiLAF != null) {</span>
            // This can return null if the multiplexing look and feel
            // doesn't support a particular UI.
<span class="nc" id="L1013">            ui = multiLAF.getDefaults().getUI(target);</span>
        }
<span class="nc bnc" id="L1015" title="All 2 branches missed.">        if (ui == null) {</span>
<span class="nc" id="L1016">            ui = getDefaults().getUI(target);</span>
        }
<span class="nc" id="L1018">        return ui;</span>
    }


    /**
     * Returns the {@code UIDefaults} from the current look and feel,
     * that were obtained at the time the look and feel was installed.
     * &lt;p&gt;
     * In general, developers should use the {@code UIDefaults} returned from
     * {@code getDefaults()}. As the current look and feel may expect
     * certain values to exist, altering the {@code UIDefaults} returned
     * from this method could have unexpected results.
     *
     * @return &lt;code&gt;UIDefaults&lt;/code&gt; from the current look and feel
     * @see #getDefaults
     * @see #setLookAndFeel(LookAndFeel)
     * @see LookAndFeel#getDefaults
     */
    public static UIDefaults getLookAndFeelDefaults() {
<span class="nc" id="L1037">        maybeInitialize();</span>
<span class="nc" id="L1038">        return getLAFState().getLookAndFeelDefaults();</span>
    }

    /**
     * Finds the Multiplexing &lt;code&gt;LookAndFeel&lt;/code&gt;.
     */
    private static LookAndFeel getMultiLookAndFeel() {
<span class="nc" id="L1045">        LookAndFeel multiLookAndFeel = getLAFState().multiLookAndFeel;</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        if (multiLookAndFeel == null) {</span>
<span class="nc" id="L1047">            String defaultName = &quot;javax.swing.plaf.multi.MultiLookAndFeel&quot;;</span>
<span class="nc" id="L1048">            String className = getLAFState().swingProps.getProperty(multiplexingLAFKey, defaultName);</span>
            try {
<span class="nc" id="L1050">                Class lnfClass = SwingUtilities.loadSystemClass(className);</span>
<span class="nc" id="L1051">                multiLookAndFeel = (LookAndFeel)lnfClass.newInstance();</span>
<span class="nc" id="L1052">            } catch (Exception exc) {</span>
<span class="nc" id="L1053">                System.err.println(&quot;UIManager: failed loading &quot; + className);</span>
<span class="nc" id="L1054">            }</span>
        }
<span class="nc" id="L1056">        return multiLookAndFeel;</span>
    }

    /**
     * Adds a &lt;code&gt;LookAndFeel&lt;/code&gt; to the list of auxiliary look and feels.
     * The auxiliary look and feels tell the multiplexing look and feel what
     * other &lt;code&gt;LookAndFeel&lt;/code&gt; classes for a component instance are to be used
     * in addition to the default &lt;code&gt;LookAndFeel&lt;/code&gt; class when creating a
     * multiplexing UI.  The change will only take effect when a new
     * UI class is created or when the default look and feel is changed
     * on a component instance.
     * &lt;p&gt;Note these are not the same as the installed look and feels.
     *
     * @param laf the &lt;code&gt;LookAndFeel&lt;/code&gt; object
     * @see #removeAuxiliaryLookAndFeel
     * @see #setLookAndFeel
     * @see #getAuxiliaryLookAndFeels
     * @see #getInstalledLookAndFeels
     */
    static public void addAuxiliaryLookAndFeel(LookAndFeel laf) {
<span class="nc" id="L1076">        maybeInitialize();</span>

<span class="nc bnc" id="L1078" title="All 2 branches missed.">        if (!laf.isSupportedLookAndFeel()) {</span>
            // Ideally we would throw an exception here, but it's too late
            // for that.
<span class="nc" id="L1081">            return;</span>
        }
<span class="nc" id="L1083">        Vector&lt;LookAndFeel&gt; v = getLAFState().auxLookAndFeels;</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">        if (v == null) {</span>
<span class="nc" id="L1085">            v = new Vector&lt;LookAndFeel&gt;();</span>
        }

<span class="nc bnc" id="L1088" title="All 2 branches missed.">        if (!v.contains(laf)) {</span>
<span class="nc" id="L1089">            v.addElement(laf);</span>
<span class="nc" id="L1090">            laf.initialize();</span>
<span class="nc" id="L1091">            getLAFState().auxLookAndFeels = v;</span>

<span class="nc bnc" id="L1093" title="All 2 branches missed.">            if (getLAFState().multiLookAndFeel == null) {</span>
<span class="nc" id="L1094">                getLAFState().multiLookAndFeel = getMultiLookAndFeel();</span>
            }
        }
<span class="nc" id="L1097">    }</span>

    /**
     * Removes a &lt;code&gt;LookAndFeel&lt;/code&gt; from the list of auxiliary look and feels.
     * The auxiliary look and feels tell the multiplexing look and feel what
     * other &lt;code&gt;LookAndFeel&lt;/code&gt; classes for a component instance are to be used
     * in addition to the default &lt;code&gt;LookAndFeel&lt;/code&gt; class when creating a
     * multiplexing UI.  The change will only take effect when a new
     * UI class is created or when the default look and feel is changed
     * on a component instance.
     * &lt;p&gt;Note these are not the same as the installed look and feels.
     * @return true if the &lt;code&gt;LookAndFeel&lt;/code&gt; was removed from the list
     * @see #removeAuxiliaryLookAndFeel
     * @see #getAuxiliaryLookAndFeels
     * @see #setLookAndFeel
     * @see #getInstalledLookAndFeels
     */
    static public boolean removeAuxiliaryLookAndFeel(LookAndFeel laf) {
<span class="nc" id="L1115">        maybeInitialize();</span>

        boolean result;

<span class="nc" id="L1119">        Vector&lt;LookAndFeel&gt; v = getLAFState().auxLookAndFeels;</span>
<span class="nc bnc" id="L1120" title="All 4 branches missed.">        if ((v == null) || (v.size() == 0)) {</span>
<span class="nc" id="L1121">            return false;</span>
        }

<span class="nc" id="L1124">        result = v.removeElement(laf);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">        if (result) {</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">            if (v.size() == 0) {</span>
<span class="nc" id="L1127">                getLAFState().auxLookAndFeels = null;</span>
<span class="nc" id="L1128">                getLAFState().multiLookAndFeel = null;</span>
            } else {
<span class="nc" id="L1130">                getLAFState().auxLookAndFeels = v;</span>
            }
        }
<span class="nc" id="L1133">        laf.uninitialize();</span>

<span class="nc" id="L1135">        return result;</span>
    }

    /**
     * Returns the list of auxiliary look and feels (can be &lt;code&gt;null&lt;/code&gt;).
     * The auxiliary look and feels tell the multiplexing look and feel what
     * other &lt;code&gt;LookAndFeel&lt;/code&gt; classes for a component instance are
     * to be used in addition to the default LookAndFeel class when creating a
     * multiplexing UI.
     * &lt;p&gt;Note these are not the same as the installed look and feels.
     *
     * @return list of auxiliary &lt;code&gt;LookAndFeel&lt;/code&gt;s or &lt;code&gt;null&lt;/code&gt;
     * @see #addAuxiliaryLookAndFeel
     * @see #removeAuxiliaryLookAndFeel
     * @see #setLookAndFeel
     * @see #getInstalledLookAndFeels
     */
    static public LookAndFeel[] getAuxiliaryLookAndFeels() {
<span class="nc" id="L1153">        maybeInitialize();</span>

<span class="nc" id="L1155">        Vector&lt;LookAndFeel&gt; v = getLAFState().auxLookAndFeels;</span>
<span class="nc bnc" id="L1156" title="All 4 branches missed.">        if ((v == null) || (v.size() == 0)) {</span>
<span class="nc" id="L1157">            return null;</span>
        }
        else {
<span class="nc" id="L1160">            LookAndFeel[] rv = new LookAndFeel[v.size()];</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">            for (int i = 0; i &lt; rv.length; i++) {</span>
<span class="nc" id="L1162">                rv[i] = v.elementAt(i);</span>
            }
<span class="nc" id="L1164">            return rv;</span>
        }
    }


    /**
     * Adds a &lt;code&gt;PropertyChangeListener&lt;/code&gt; to the listener list.
     * The listener is registered for all properties.
     *
     * @param listener  the &lt;code&gt;PropertyChangeListener&lt;/code&gt; to be added
     * @see java.beans.PropertyChangeSupport
     */
    public static void addPropertyChangeListener(PropertyChangeListener listener)
    {
<span class="nc" id="L1178">        synchronized (classLock) {</span>
<span class="nc" id="L1179">            getLAFState().getPropertyChangeSupport(true).</span>
<span class="nc" id="L1180">                             addPropertyChangeListener(listener);</span>
<span class="nc" id="L1181">        }</span>
<span class="nc" id="L1182">    }</span>


    /**
     * Removes a &lt;code&gt;PropertyChangeListener&lt;/code&gt; from the listener list.
     * This removes a &lt;code&gt;PropertyChangeListener&lt;/code&gt; that was registered
     * for all properties.
     *
     * @param listener  the &lt;code&gt;PropertyChangeListener&lt;/code&gt; to be removed
     * @see java.beans.PropertyChangeSupport
     */
    public static void removePropertyChangeListener(PropertyChangeListener listener)
    {
<span class="nc" id="L1195">        synchronized (classLock) {</span>
<span class="nc" id="L1196">            getLAFState().getPropertyChangeSupport(true).</span>
<span class="nc" id="L1197">                          removePropertyChangeListener(listener);</span>
<span class="nc" id="L1198">        }</span>
<span class="nc" id="L1199">    }</span>


    /**
     * Returns an array of all the &lt;code&gt;PropertyChangeListener&lt;/code&gt;s added
     * to this UIManager with addPropertyChangeListener().
     *
     * @return all of the &lt;code&gt;PropertyChangeListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public static PropertyChangeListener[] getPropertyChangeListeners() {
<span class="nc" id="L1211">        synchronized(classLock) {</span>
<span class="nc" id="L1212">            return getLAFState().getPropertyChangeSupport(true).</span>
<span class="nc" id="L1213">                      getPropertyChangeListeners();</span>
<span class="nc" id="L1214">        }</span>
    }

    private static Properties loadSwingProperties()
    {
        /* Don't bother checking for Swing properties if untrusted, as
         * there's no way to look them up without triggering SecurityExceptions.
         */
<span class="pc bpc" id="L1222" title="1 of 2 branches missed.">        if (UIManager.class.getClassLoader() != null) {</span>
<span class="nc" id="L1223">            return new Properties();</span>
        }
        else {
<span class="fc" id="L1226">            final Properties props = new Properties();</span>

<span class="fc" id="L1228">            java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L1229">                new java.security.PrivilegedAction&lt;Object&gt;() {</span>
                public Object run() {
<span class="fc" id="L1231">                    OSInfo.OSType osType = AccessController.doPrivileged(OSInfo.getOSTypeAction());</span>
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">                    if (osType == OSInfo.OSType.MACOSX) {</span>
<span class="nc" id="L1233">                        props.put(defaultLAFKey, getSystemLookAndFeelClassName());</span>
                    }

                    try {
<span class="fc" id="L1237">                        File file = new File(makeSwingPropertiesFilename());</span>

<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">                        if (file.exists()) {</span>
                            // InputStream has been buffered in Properties
                            // class
<span class="nc" id="L1242">                            FileInputStream ins = new FileInputStream(file);</span>
<span class="nc" id="L1243">                            props.load(ins);</span>
<span class="nc" id="L1244">                            ins.close();</span>
                        }
                    }
<span class="nc" id="L1247">                    catch (Exception e) {</span>
                        // No such file, or file is otherwise non-readable.
<span class="fc" id="L1249">                    }</span>

                    // Check whether any properties were overridden at the
                    // command line.
<span class="fc" id="L1253">                    checkProperty(props, defaultLAFKey);</span>
<span class="fc" id="L1254">                    checkProperty(props, auxiliaryLAFsKey);</span>
<span class="fc" id="L1255">                    checkProperty(props, multiplexingLAFKey);</span>
<span class="fc" id="L1256">                    checkProperty(props, installedLAFsKey);</span>
<span class="fc" id="L1257">                    checkProperty(props, disableMnemonicKey);</span>
                    // Don't care about return value.
<span class="fc" id="L1259">                    return null;</span>
                }
            });
<span class="fc" id="L1262">            return props;</span>
        }
    }

    private static void checkProperty(Properties props, String key) {
        // No need to do catch the SecurityException here, this runs
        // in a doPrivileged.
<span class="fc" id="L1269">        String value = System.getProperty(key);</span>
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L1271">            props.put(key, value);</span>
        }
<span class="fc" id="L1273">    }</span>


    /**
     * If a &lt;code&gt;swing.properties&lt;/code&gt; file exist and it has a
     * &lt;code&gt;swing.installedlafs&lt;/code&gt; property
     * then initialize the &lt;code&gt;installedLAFs&lt;/code&gt; field.
     *
     * @see #getInstalledLookAndFeels
     */
    private static void initializeInstalledLAFs(Properties swingProps)
    {
<span class="fc" id="L1285">        String ilafsString = swingProps.getProperty(installedLAFsKey);</span>
<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">        if (ilafsString == null) {</span>
<span class="fc" id="L1287">            return;</span>
        }

        /* Create a vector that contains the value of the swing.installedlafs
         * property.  For example given &quot;swing.installedlafs=motif,windows&quot;
         * lafs = {&quot;motif&quot;, &quot;windows&quot;}.
         */
<span class="nc" id="L1294">        Vector&lt;String&gt; lafs = new Vector&lt;String&gt;();</span>
<span class="nc" id="L1295">        StringTokenizer st = new StringTokenizer(ilafsString, &quot;,&quot;, false);</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">        while (st.hasMoreTokens()) {</span>
<span class="nc" id="L1297">            lafs.addElement(st.nextToken());</span>
        }

        /* Look up the name and class for each name in the &quot;swing.installedlafs&quot;
         * list.  If they both exist then add a LookAndFeelInfo to
         * the installedLafs array.
         */
<span class="nc" id="L1304">        Vector&lt;LookAndFeelInfo&gt; ilafs = new Vector&lt;LookAndFeelInfo&gt;(lafs.size());</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">        for (String laf : lafs) {</span>
<span class="nc" id="L1306">            String name = swingProps.getProperty(makeInstalledLAFKey(laf, &quot;name&quot;), laf);</span>
<span class="nc" id="L1307">            String cls = swingProps.getProperty(makeInstalledLAFKey(laf, &quot;class&quot;));</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">            if (cls != null) {</span>
<span class="nc" id="L1309">                ilafs.addElement(new LookAndFeelInfo(name, cls));</span>
            }
<span class="nc" id="L1311">        }</span>

<span class="nc" id="L1313">        LookAndFeelInfo[] installedLAFs = new LookAndFeelInfo[ilafs.size()];</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">        for(int i = 0; i &lt; ilafs.size(); i++) {</span>
<span class="nc" id="L1315">            installedLAFs[i] = ilafs.elementAt(i);</span>
        }
<span class="nc" id="L1317">        getLAFState().installedLAFs = installedLAFs;</span>
<span class="nc" id="L1318">    }</span>


    /**
     * If the user has specified a default look and feel, use that.
     * Otherwise use the look and feel that's native to this platform.
     * If this code is called after the application has explicitly
     * set it's look and feel, do nothing.
     *
     * @see #maybeInitialize
     */
    private static void initializeDefaultLAF(Properties swingProps)
    {
<span class="pc bpc" id="L1331" title="1 of 2 branches missed.">        if (getLAFState().lookAndFeel != null) {</span>
<span class="nc" id="L1332">            return;</span>
        }

        // Try to get default LAF from system property, then from AppContext
        // (6653395), then use cross-platform one by default.
<span class="fc" id="L1337">        String lafName = null;</span>
        HashMap lafData =
<span class="fc" id="L1339">                (HashMap) AppContext.getAppContext().remove(&quot;swing.lafdata&quot;);</span>
<span class="pc bpc" id="L1340" title="1 of 2 branches missed.">        if (lafData != null) {</span>
<span class="nc" id="L1341">            lafName = (String) lafData.remove(&quot;defaultlaf&quot;);</span>
        }
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">        if (lafName == null) {</span>
<span class="fc" id="L1344">            lafName = getCrossPlatformLookAndFeelClassName();</span>
        }
<span class="fc" id="L1346">        lafName = swingProps.getProperty(defaultLAFKey, lafName);</span>

        try {
<span class="fc" id="L1349">            setLookAndFeel(lafName);</span>
<span class="nc" id="L1350">        } catch (Exception e) {</span>
<span class="nc" id="L1351">            throw new Error(&quot;Cannot load &quot; + lafName);</span>
<span class="fc" id="L1352">        }</span>

        // Set any properties passed through AppContext (6653395).
<span class="pc bpc" id="L1355" title="1 of 2 branches missed.">        if (lafData != null) {</span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">            for (Object key: lafData.keySet()) {</span>
<span class="nc" id="L1357">                UIManager.put(key, lafData.get(key));</span>
<span class="nc" id="L1358">            }</span>
        }
<span class="fc" id="L1360">    }</span>


    private static void initializeAuxiliaryLAFs(Properties swingProps)
    {
<span class="fc" id="L1365">        String auxLookAndFeelNames = swingProps.getProperty(auxiliaryLAFsKey);</span>
<span class="pc bpc" id="L1366" title="1 of 2 branches missed.">        if (auxLookAndFeelNames == null) {</span>
<span class="fc" id="L1367">            return;</span>
        }

<span class="nc" id="L1370">        Vector&lt;LookAndFeel&gt; auxLookAndFeels = new Vector&lt;LookAndFeel&gt;();</span>

<span class="nc" id="L1372">        StringTokenizer p = new StringTokenizer(auxLookAndFeelNames,&quot;,&quot;);</span>
        String factoryName;

        /* Try to load each LookAndFeel subclass in the list.
         */

<span class="nc bnc" id="L1378" title="All 2 branches missed.">        while (p.hasMoreTokens()) {</span>
<span class="nc" id="L1379">            String className = p.nextToken();</span>
            try {
<span class="nc" id="L1381">                Class lnfClass = SwingUtilities.loadSystemClass(className);</span>
<span class="nc" id="L1382">                LookAndFeel newLAF = (LookAndFeel)lnfClass.newInstance();</span>
<span class="nc" id="L1383">                newLAF.initialize();</span>
<span class="nc" id="L1384">                auxLookAndFeels.addElement(newLAF);</span>
            }
<span class="nc" id="L1386">            catch (Exception e) {</span>
<span class="nc" id="L1387">                System.err.println(&quot;UIManager: failed loading auxiliary look and feel &quot; + className);</span>
<span class="nc" id="L1388">            }</span>
<span class="nc" id="L1389">        }</span>

        /* If there were problems and no auxiliary look and feels were
         * loaded, make sure we reset auxLookAndFeels to null.
         * Otherwise, we are going to use the MultiLookAndFeel to get
         * all component UI's, so we need to load it now.
         */
<span class="nc bnc" id="L1396" title="All 2 branches missed.">        if (auxLookAndFeels.size() == 0) {</span>
<span class="nc" id="L1397">            auxLookAndFeels = null;</span>
        }
        else {
<span class="nc" id="L1400">            getLAFState().multiLookAndFeel = getMultiLookAndFeel();</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">            if (getLAFState().multiLookAndFeel == null) {</span>
<span class="nc" id="L1402">                auxLookAndFeels = null;</span>
            }
        }

<span class="nc" id="L1406">        getLAFState().auxLookAndFeels = auxLookAndFeels;</span>
<span class="nc" id="L1407">    }</span>


    private static void initializeSystemDefaults(Properties swingProps) {
<span class="fc" id="L1411">        getLAFState().swingProps = swingProps;</span>
<span class="fc" id="L1412">    }</span>


    /*
     * This method is called before any code that depends on the
     * &lt;code&gt;AppContext&lt;/code&gt; specific LAFState object runs.  When the AppContext
     * corresponds to a set of applets it's possible for this method
     * to be re-entered, which is why we grab a lock before calling
     * initialize().
     */
    private static void maybeInitialize() {
<span class="fc" id="L1423">        synchronized (classLock) {</span>
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">            if (!getLAFState().initialized) {</span>
<span class="fc" id="L1425">                getLAFState().initialized = true;</span>
<span class="fc" id="L1426">                initialize();</span>
            }
<span class="pc" id="L1428">        }</span>
<span class="fc" id="L1429">    }</span>

    /*
     * Sets default swing focus traversal policy.
     */
    private static void maybeInitializeFocusPolicy(JComponent comp) {
        // Check for JRootPane which indicates that a swing toplevel
        // is coming, in which case a swing default focus policy
        // should be instatiated. See 7125044.
<span class="nc bnc" id="L1438" title="All 2 branches missed.">        if (comp instanceof JRootPane) {</span>
<span class="nc" id="L1439">            synchronized (classLock) {</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">                if (!getLAFState().focusPolicyInitialized) {</span>
<span class="nc" id="L1441">                    getLAFState().focusPolicyInitialized = true;</span>

<span class="nc bnc" id="L1443" title="All 2 branches missed.">                    if (FocusManager.isFocusManagerEnabled()) {</span>
<span class="nc" id="L1444">                        KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L1445">                            setDefaultFocusTraversalPolicy(</span>
                                new LayoutFocusTraversalPolicy());
                    }
                }
<span class="nc" id="L1449">            }</span>
        }
<span class="nc" id="L1451">    }</span>

    /*
     * Only called by maybeInitialize().
     */
    private static void initialize() {
<span class="fc" id="L1457">        Properties swingProps = loadSwingProperties();</span>
<span class="fc" id="L1458">        initializeSystemDefaults(swingProps);</span>
<span class="fc" id="L1459">        initializeDefaultLAF(swingProps);</span>
<span class="fc" id="L1460">        initializeAuxiliaryLAFs(swingProps);</span>
<span class="fc" id="L1461">        initializeInstalledLAFs(swingProps);</span>

        // Install Swing's PaintEventDispatcher
<span class="pc bpc" id="L1464" title="1 of 2 branches missed.">        if (RepaintManager.HANDLE_TOP_LEVEL_PAINT) {</span>
<span class="fc" id="L1465">            sun.awt.PaintEventDispatcher.setPaintEventDispatcher(</span>
                                        new SwingPaintEventDispatcher());
        }
        // Install a hook that will be invoked if no one consumes the
        // KeyEvent.  If the source isn't a JComponent this will process
        // key bindings, if the source is a JComponent it implies that
        // processKeyEvent was already invoked and thus no need to process
        // the bindings again, unless the Component is disabled, in which
        // case KeyEvents will no longer be dispatched to it so that we
        // handle it here.
<span class="fc" id="L1475">        KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="fc" id="L1476">                addKeyEventPostProcessor(new KeyEventPostProcessor() {</span>
                    public boolean postProcessKeyEvent(KeyEvent e) {
<span class="nc" id="L1478">                        Component c = e.getComponent();</span>

<span class="nc bnc" id="L1480" title="All 4 branches missed.">                        if ((!(c instanceof JComponent) ||</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">                             (c != null &amp;&amp; !c.isEnabled())) &amp;&amp;</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">                                JComponent.KeyboardState.shouldProcess(e) &amp;&amp;</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">                                SwingUtilities.processKeyBindings(e)) {</span>
<span class="nc" id="L1484">                            e.consume();</span>
<span class="nc" id="L1485">                            return true;</span>
                        }
<span class="nc" id="L1487">                        return false;</span>
                    }
                });
<span class="fc" id="L1490">        AWTAccessor.getComponentAccessor().</span>
<span class="fc" id="L1491">            setRequestFocusController(JComponent.focusController);</span>
<span class="fc" id="L1492">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>