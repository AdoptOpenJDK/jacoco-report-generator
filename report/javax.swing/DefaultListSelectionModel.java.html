<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultListSelectionModel.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">DefaultListSelectionModel.java</span></div><h1>DefaultListSelectionModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing;

import java.util.EventListener;
import java.util.BitSet;
import java.io.Serializable;
import java.beans.Transient;

import javax.swing.event.*;


/**
 * Default data model for list selections.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author Philip Milne
 * @author Hans Muller
 * @see ListSelectionModel
 */

<span class="nc" id="L53">public class DefaultListSelectionModel implements ListSelectionModel, Cloneable, Serializable</span>
{
    private static final int MIN = -1;
    private static final int MAX = Integer.MAX_VALUE;
<span class="nc" id="L57">    private int selectionMode = MULTIPLE_INTERVAL_SELECTION;</span>
<span class="nc" id="L58">    private int minIndex = MAX;</span>
<span class="nc" id="L59">    private int maxIndex = MIN;</span>
<span class="nc" id="L60">    private int anchorIndex = -1;</span>
<span class="nc" id="L61">    private int leadIndex = -1;</span>
<span class="nc" id="L62">    private int firstAdjustedIndex = MAX;</span>
<span class="nc" id="L63">    private int lastAdjustedIndex = MIN;</span>
<span class="nc" id="L64">    private boolean isAdjusting = false;</span>

<span class="nc" id="L66">    private int firstChangedIndex = MAX;</span>
<span class="nc" id="L67">    private int lastChangedIndex = MIN;</span>

<span class="nc" id="L69">    private BitSet value = new BitSet(32);</span>
<span class="nc" id="L70">    protected EventListenerList listenerList = new EventListenerList();</span>

<span class="nc" id="L72">    protected boolean leadAnchorNotificationEnabled = true;</span>

    /** {@inheritDoc} */
<span class="nc bnc" id="L75" title="All 2 branches missed.">    public int getMinSelectionIndex() { return isSelectionEmpty() ? -1 : minIndex; }</span>

    /** {@inheritDoc} */
<span class="nc" id="L78">    public int getMaxSelectionIndex() { return maxIndex; }</span>

    /** {@inheritDoc} */
<span class="nc" id="L81">    public boolean getValueIsAdjusting() { return isAdjusting; }</span>

    /** {@inheritDoc} */
<span class="nc" id="L84">    public int getSelectionMode() { return selectionMode; }</span>

    /**
     * {@inheritDoc}
     * @throws IllegalArgumentException {@inheritDoc}
     */
    public void setSelectionMode(int selectionMode) {
<span class="nc bnc" id="L91" title="All 2 branches missed.">        switch (selectionMode) {</span>
        case SINGLE_SELECTION:
        case SINGLE_INTERVAL_SELECTION:
        case MULTIPLE_INTERVAL_SELECTION:
<span class="nc" id="L95">            this.selectionMode = selectionMode;</span>
<span class="nc" id="L96">            break;</span>
        default:
<span class="nc" id="L98">            throw new IllegalArgumentException(&quot;invalid selectionMode&quot;);</span>
        }
<span class="nc" id="L100">    }</span>

    /** {@inheritDoc} */
    public boolean isSelectedIndex(int index) {
<span class="nc bnc" id="L104" title="All 4 branches missed.">        return ((index &lt; minIndex) || (index &gt; maxIndex)) ? false : value.get(index);</span>
    }

    /** {@inheritDoc} */
    public boolean isSelectionEmpty() {
<span class="nc bnc" id="L109" title="All 2 branches missed.">        return (minIndex &gt; maxIndex);</span>
    }

    /** {@inheritDoc} */
    public void addListSelectionListener(ListSelectionListener l) {
<span class="nc" id="L114">        listenerList.add(ListSelectionListener.class, l);</span>
<span class="nc" id="L115">    }</span>

    /** {@inheritDoc} */
    public void removeListSelectionListener(ListSelectionListener l) {
<span class="nc" id="L119">        listenerList.remove(ListSelectionListener.class, l);</span>
<span class="nc" id="L120">    }</span>

    /**
     * Returns an array of all the list selection listeners
     * registered on this &lt;code&gt;DefaultListSelectionModel&lt;/code&gt;.
     *
     * @return all of this model's &lt;code&gt;ListSelectionListener&lt;/code&gt;s
     *         or an empty
     *         array if no list selection listeners are currently registered
     *
     * @see #addListSelectionListener
     * @see #removeListSelectionListener
     *
     * @since 1.4
     */
    public ListSelectionListener[] getListSelectionListeners() {
<span class="nc" id="L136">        return listenerList.getListeners(ListSelectionListener.class);</span>
    }

    /**
     * Notifies listeners that we have ended a series of adjustments.
     */
    protected void fireValueChanged(boolean isAdjusting) {
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (lastChangedIndex == MIN) {</span>
<span class="nc" id="L144">            return;</span>
        }
        /* Change the values before sending the event to the
         * listeners in case the event causes a listener to make
         * another change to the selection.
         */
<span class="nc" id="L150">        int oldFirstChangedIndex = firstChangedIndex;</span>
<span class="nc" id="L151">        int oldLastChangedIndex = lastChangedIndex;</span>
<span class="nc" id="L152">        firstChangedIndex = MAX;</span>
<span class="nc" id="L153">        lastChangedIndex = MIN;</span>
<span class="nc" id="L154">        fireValueChanged(oldFirstChangedIndex, oldLastChangedIndex, isAdjusting);</span>
<span class="nc" id="L155">    }</span>


    /**
     * Notifies &lt;code&gt;ListSelectionListeners&lt;/code&gt; that the value
     * of the selection, in the closed interval &lt;code&gt;firstIndex&lt;/code&gt;,
     * &lt;code&gt;lastIndex&lt;/code&gt;, has changed.
     */
    protected void fireValueChanged(int firstIndex, int lastIndex) {
<span class="nc" id="L164">        fireValueChanged(firstIndex, lastIndex, getValueIsAdjusting());</span>
<span class="nc" id="L165">    }</span>

    /**
     * @param firstIndex the first index in the interval
     * @param lastIndex the last index in the interval
     * @param isAdjusting true if this is the final change in a series of
     *          adjustments
     * @see EventListenerList
     */
    protected void fireValueChanged(int firstIndex, int lastIndex, boolean isAdjusting)
    {
<span class="nc" id="L176">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L177">        ListSelectionEvent e = null;</span>

<span class="nc bnc" id="L179" title="All 2 branches missed.">        for (int i = listeners.length - 2; i &gt;= 0; i -= 2) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (listeners[i] == ListSelectionListener.class) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                if (e == null) {</span>
<span class="nc" id="L182">                    e = new ListSelectionEvent(this, firstIndex, lastIndex, isAdjusting);</span>
                }
<span class="nc" id="L184">                ((ListSelectionListener)listeners[i+1]).valueChanged(e);</span>
            }
        }
<span class="nc" id="L187">    }</span>

    private void fireValueChanged() {
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (lastAdjustedIndex == MIN) {</span>
<span class="nc" id="L191">            return;</span>
        }
        /* If getValueAdjusting() is true, (eg. during a drag opereration)
         * record the bounds of the changes so that, when the drag finishes (and
         * setValueAdjusting(false) is called) we can post a single event
         * with bounds covering all of these individual adjustments.
         */
<span class="nc bnc" id="L198" title="All 2 branches missed.">        if (getValueIsAdjusting()) {</span>
<span class="nc" id="L199">            firstChangedIndex = Math.min(firstChangedIndex, firstAdjustedIndex);</span>
<span class="nc" id="L200">            lastChangedIndex = Math.max(lastChangedIndex, lastAdjustedIndex);</span>
        }
        /* Change the values before sending the event to the
         * listeners in case the event causes a listener to make
         * another change to the selection.
         */
<span class="nc" id="L206">        int oldFirstAdjustedIndex = firstAdjustedIndex;</span>
<span class="nc" id="L207">        int oldLastAdjustedIndex = lastAdjustedIndex;</span>
<span class="nc" id="L208">        firstAdjustedIndex = MAX;</span>
<span class="nc" id="L209">        lastAdjustedIndex = MIN;</span>

<span class="nc" id="L211">        fireValueChanged(oldFirstAdjustedIndex, oldLastAdjustedIndex);</span>
<span class="nc" id="L212">    }</span>

    /**
     * Returns an array of all the objects currently registered as
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
     * upon this model.
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
     * are registered using the &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
     * &lt;p&gt;
     * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
     * with a class literal, such as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
     * For example, you can query a &lt;code&gt;DefaultListSelectionModel&lt;/code&gt;
     * instance &lt;code&gt;m&lt;/code&gt;
     * for its list selection listeners
     * with the following code:
     *
     * &lt;pre&gt;ListSelectionListener[] lsls = (ListSelectionListener[])(m.getListeners(ListSelectionListener.class));&lt;/pre&gt;
     *
     * If no such listeners exist,
     * this method returns an empty array.
     *
     * @param listenerType  the type of listeners requested;
     *          this parameter should specify an interface
     *          that descends from &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @return an array of all objects registered as
     *          &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
     *          on this model,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt; doesn't
     *          specify a class or interface that implements
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     *
     * @see #getListSelectionListeners
     *
     * @since 1.3
     */
    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<span class="nc" id="L250">        return listenerList.getListeners(listenerType);</span>
    }

    // Updates first and last change indices
    private void markAsDirty(int r) {
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (r == -1) {</span>
<span class="nc" id="L256">            return;</span>
        }

<span class="nc" id="L259">        firstAdjustedIndex = Math.min(firstAdjustedIndex, r);</span>
<span class="nc" id="L260">        lastAdjustedIndex =  Math.max(lastAdjustedIndex, r);</span>
<span class="nc" id="L261">    }</span>

    // Sets the state at this index and update all relevant state.
    private void set(int r) {
<span class="nc bnc" id="L265" title="All 2 branches missed.">        if (value.get(r)) {</span>
<span class="nc" id="L266">            return;</span>
        }
<span class="nc" id="L268">        value.set(r);</span>
<span class="nc" id="L269">        markAsDirty(r);</span>

        // Update minimum and maximum indices
<span class="nc" id="L272">        minIndex = Math.min(minIndex, r);</span>
<span class="nc" id="L273">        maxIndex = Math.max(maxIndex, r);</span>
<span class="nc" id="L274">    }</span>

    // Clears the state at this index and update all relevant state.
    private void clear(int r) {
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (!value.get(r)) {</span>
<span class="nc" id="L279">            return;</span>
        }
<span class="nc" id="L281">        value.clear(r);</span>
<span class="nc" id="L282">        markAsDirty(r);</span>

        // Update minimum and maximum indices
        /*
           If (r &gt; minIndex) the minimum has not changed.
           The case (r &lt; minIndex) is not possible because r'th value was set.
           We only need to check for the case when lowest entry has been cleared,
           and in this case we need to search for the first value set above it.
        */
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (r == minIndex) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            for(minIndex = minIndex + 1; minIndex &lt;= maxIndex; minIndex++) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                if (value.get(minIndex)) {</span>
<span class="nc" id="L294">                    break;</span>
                }
            }
        }
        /*
           If (r &lt; maxIndex) the maximum has not changed.
           The case (r &gt; maxIndex) is not possible because r'th value was set.
           We only need to check for the case when highest entry has been cleared,
           and in this case we need to search for the first value set below it.
        */
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (r == maxIndex) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            for(maxIndex = maxIndex - 1; minIndex &lt;= maxIndex; maxIndex--) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                if (value.get(maxIndex)) {</span>
<span class="nc" id="L307">                    break;</span>
                }
            }
        }
        /* Performance note: This method is called from inside a loop in
           changeSelection() but we will only iterate in the loops
           above on the basis of one iteration per deselected cell - in total.
           Ie. the next time this method is called the work of the previous
           deselection will not be repeated.

           We also don't need to worry about the case when the min and max
           values are in their unassigned states. This cannot happen because
           this method's initial check ensures that the selection was not empty
           and therefore that the minIndex and maxIndex had 'real' values.

           If we have cleared the whole selection, set the minIndex and maxIndex
           to their cannonical values so that the next set command always works
           just by using Math.min and Math.max.
        */
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (isSelectionEmpty()) {</span>
<span class="nc" id="L327">            minIndex = MAX;</span>
<span class="nc" id="L328">            maxIndex = MIN;</span>
        }
<span class="nc" id="L330">    }</span>

    /**
     * Sets the value of the leadAnchorNotificationEnabled flag.
     * @see             #isLeadAnchorNotificationEnabled()
     */
    public void setLeadAnchorNotificationEnabled(boolean flag) {
<span class="nc" id="L337">        leadAnchorNotificationEnabled = flag;</span>
<span class="nc" id="L338">    }</span>

    /**
     * Returns the value of the &lt;code&gt;leadAnchorNotificationEnabled&lt;/code&gt; flag.
     * When &lt;code&gt;leadAnchorNotificationEnabled&lt;/code&gt; is true the model
     * generates notification events with bounds that cover all the changes to
     * the selection plus the changes to the lead and anchor indices.
     * Setting the flag to false causes a narrowing of the event's bounds to
     * include only the elements that have been selected or deselected since
     * the last change. Either way, the model continues to maintain the lead
     * and anchor variables internally. The default is true.
     * &lt;p&gt;
     * Note: It is possible for the lead or anchor to be changed without a
     * change to the selection. Notification of these changes is often
     * important, such as when the new lead or anchor needs to be updated in
     * the view. Therefore, caution is urged when changing the default value.
     *
     * @return  the value of the &lt;code&gt;leadAnchorNotificationEnabled&lt;/code&gt; flag
     * @see             #setLeadAnchorNotificationEnabled(boolean)
     */
    public boolean isLeadAnchorNotificationEnabled() {
<span class="nc" id="L359">        return leadAnchorNotificationEnabled;</span>
    }

    private void updateLeadAnchorIndices(int anchorIndex, int leadIndex) {
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (leadAnchorNotificationEnabled) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if (this.anchorIndex != anchorIndex) {</span>
<span class="nc" id="L365">                markAsDirty(this.anchorIndex);</span>
<span class="nc" id="L366">                markAsDirty(anchorIndex);</span>
            }

<span class="nc bnc" id="L369" title="All 2 branches missed.">            if (this.leadIndex != leadIndex) {</span>
<span class="nc" id="L370">                markAsDirty(this.leadIndex);</span>
<span class="nc" id="L371">                markAsDirty(leadIndex);</span>
            }
        }
<span class="nc" id="L374">        this.anchorIndex = anchorIndex;</span>
<span class="nc" id="L375">        this.leadIndex = leadIndex;</span>
<span class="nc" id="L376">    }</span>

    private boolean contains(int a, int b, int i) {
<span class="nc bnc" id="L379" title="All 4 branches missed.">        return (i &gt;= a) &amp;&amp; (i &lt;= b);</span>
    }

    private void changeSelection(int clearMin, int clearMax,
                                 int setMin, int setMax, boolean clearFirst) {
<span class="nc bnc" id="L384" title="All 2 branches missed.">        for(int i = Math.min(setMin, clearMin); i &lt;= Math.max(setMax, clearMax); i++) {</span>

<span class="nc" id="L386">            boolean shouldClear = contains(clearMin, clearMax, i);</span>
<span class="nc" id="L387">            boolean shouldSet = contains(setMin, setMax, i);</span>

<span class="nc bnc" id="L389" title="All 4 branches missed.">            if (shouldSet &amp;&amp; shouldClear) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                if (clearFirst) {</span>
<span class="nc" id="L391">                    shouldClear = false;</span>
                }
                else {
<span class="nc" id="L394">                    shouldSet = false;</span>
                }
            }

<span class="nc bnc" id="L398" title="All 2 branches missed.">            if (shouldSet) {</span>
<span class="nc" id="L399">                set(i);</span>
            }
<span class="nc bnc" id="L401" title="All 2 branches missed.">            if (shouldClear) {</span>
<span class="nc" id="L402">                clear(i);</span>
            }
        }
<span class="nc" id="L405">        fireValueChanged();</span>
<span class="nc" id="L406">    }</span>

   /**
    * Change the selection with the effect of first clearing the values
    * in the inclusive range [clearMin, clearMax] then setting the values
    * in the inclusive range [setMin, setMax]. Do this in one pass so
    * that no values are cleared if they would later be set.
    */
    private void changeSelection(int clearMin, int clearMax, int setMin, int setMax) {
<span class="nc" id="L415">        changeSelection(clearMin, clearMax, setMin, setMax, true);</span>
<span class="nc" id="L416">    }</span>

    /** {@inheritDoc} */
    public void clearSelection() {
<span class="nc" id="L420">        removeSelectionIntervalImpl(minIndex, maxIndex, false);</span>
<span class="nc" id="L421">    }</span>

    /**
     * Changes the selection to be between {@code index0} and {@code index1}
     * inclusive. {@code index0} doesn't have to be less than or equal to
     * {@code index1}.
     * &lt;p&gt;
     * In {@code SINGLE_SELECTION} selection mode, only the second index
     * is used.
     * &lt;p&gt;
     * If this represents a change to the current selection, then each
     * {@code ListSelectionListener} is notified of the change.
     * &lt;p&gt;
     * If either index is {@code -1}, this method does nothing and returns
     * without exception. Otherwise, if either index is less than {@code -1},
     * an {@code IndexOutOfBoundsException} is thrown.
     *
     * @param index0 one end of the interval.
     * @param index1 other end of the interval
     * @throws IndexOutOfBoundsException if either index is less than {@code -1}
     *         (and neither index is {@code -1})
     * @see #addListSelectionListener
     */
    public void setSelectionInterval(int index0, int index1) {
<span class="nc bnc" id="L445" title="All 4 branches missed.">        if (index0 == -1 || index1 == -1) {</span>
<span class="nc" id="L446">            return;</span>
        }

<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (getSelectionMode() == SINGLE_SELECTION) {</span>
<span class="nc" id="L450">            index0 = index1;</span>
        }

<span class="nc" id="L453">        updateLeadAnchorIndices(index0, index1);</span>

<span class="nc" id="L455">        int clearMin = minIndex;</span>
<span class="nc" id="L456">        int clearMax = maxIndex;</span>
<span class="nc" id="L457">        int setMin = Math.min(index0, index1);</span>
<span class="nc" id="L458">        int setMax = Math.max(index0, index1);</span>
<span class="nc" id="L459">        changeSelection(clearMin, clearMax, setMin, setMax);</span>
<span class="nc" id="L460">    }</span>

    /**
     * Changes the selection to be the set union of the current selection
     * and the indices between {@code index0} and {@code index1} inclusive.
     * &lt;p&gt;
     * In {@code SINGLE_SELECTION} selection mode, this is equivalent
     * to calling {@code setSelectionInterval}, and only the second index
     * is used. In {@code SINGLE_INTERVAL_SELECTION} selection mode, this
     * method behaves like {@code setSelectionInterval}, unless the given
     * interval is immediately adjacent to or overlaps the existing selection,
     * and can therefore be used to grow it.
     * &lt;p&gt;
     * If this represents a change to the current selection, then each
     * {@code ListSelectionListener} is notified of the change. Note that
     * {@code index0} doesn't have to be less than or equal to {@code index1}.
     * &lt;p&gt;
     * If either index is {@code -1}, this method does nothing and returns
     * without exception. Otherwise, if either index is less than {@code -1},
     * an {@code IndexOutOfBoundsException} is thrown.
     *
     * @param index0 one end of the interval.
     * @param index1 other end of the interval
     * @throws IndexOutOfBoundsException if either index is less than {@code -1}
     *         (and neither index is {@code -1})
     * @see #addListSelectionListener
     * @see #setSelectionInterval
     */
    public void addSelectionInterval(int index0, int index1)
    {
<span class="nc bnc" id="L490" title="All 4 branches missed.">        if (index0 == -1 || index1 == -1) {</span>
<span class="nc" id="L491">            return;</span>
        }

        // If we only allow a single selection, channel through
        // setSelectionInterval() to enforce the rule.
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (getSelectionMode() == SINGLE_SELECTION) {</span>
<span class="nc" id="L497">            setSelectionInterval(index0, index1);</span>
<span class="nc" id="L498">            return;</span>
        }

<span class="nc" id="L501">        updateLeadAnchorIndices(index0, index1);</span>

<span class="nc" id="L503">        int clearMin = MAX;</span>
<span class="nc" id="L504">        int clearMax = MIN;</span>
<span class="nc" id="L505">        int setMin = Math.min(index0, index1);</span>
<span class="nc" id="L506">        int setMax = Math.max(index0, index1);</span>

        // If we only allow a single interval and this would result
        // in multiple intervals, then set the selection to be just
        // the new range.
<span class="nc bnc" id="L511" title="All 6 branches missed.">        if (getSelectionMode() == SINGLE_INTERVAL_SELECTION &amp;&amp;</span>
                (setMax &lt; minIndex - 1 || setMin &gt; maxIndex + 1)) {

<span class="nc" id="L514">            setSelectionInterval(index0, index1);</span>
<span class="nc" id="L515">            return;</span>
        }

<span class="nc" id="L518">        changeSelection(clearMin, clearMax, setMin, setMax);</span>
<span class="nc" id="L519">    }</span>


    /**
     * Changes the selection to be the set difference of the current selection
     * and the indices between {@code index0} and {@code index1} inclusive.
     * {@code index0} doesn't have to be less than or equal to {@code index1}.
     * &lt;p&gt;
     * In {@code SINGLE_INTERVAL_SELECTION} selection mode, if the removal
     * would produce two disjoint selections, the removal is extended through
     * the greater end of the selection. For example, if the selection is
     * {@code 0-10} and you supply indices {@code 5,6} (in any order) the
     * resulting selection is {@code 0-4}.
     * &lt;p&gt;
     * If this represents a change to the current selection, then each
     * {@code ListSelectionListener} is notified of the change.
     * &lt;p&gt;
     * If either index is {@code -1}, this method does nothing and returns
     * without exception. Otherwise, if either index is less than {@code -1},
     * an {@code IndexOutOfBoundsException} is thrown.
     *
     * @param index0 one end of the interval
     * @param index1 other end of the interval
     * @throws IndexOutOfBoundsException if either index is less than {@code -1}
     *         (and neither index is {@code -1})
     * @see #addListSelectionListener
     */
    public void removeSelectionInterval(int index0, int index1)
    {
<span class="nc" id="L548">        removeSelectionIntervalImpl(index0, index1, true);</span>
<span class="nc" id="L549">    }</span>

    // private implementation allowing the selection interval
    // to be removed without affecting the lead and anchor
    private void removeSelectionIntervalImpl(int index0, int index1,
                                             boolean changeLeadAnchor) {

<span class="nc bnc" id="L556" title="All 4 branches missed.">        if (index0 == -1 || index1 == -1) {</span>
<span class="nc" id="L557">            return;</span>
        }

<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (changeLeadAnchor) {</span>
<span class="nc" id="L561">            updateLeadAnchorIndices(index0, index1);</span>
        }

<span class="nc" id="L564">        int clearMin = Math.min(index0, index1);</span>
<span class="nc" id="L565">        int clearMax = Math.max(index0, index1);</span>
<span class="nc" id="L566">        int setMin = MAX;</span>
<span class="nc" id="L567">        int setMax = MIN;</span>

        // If the removal would produce to two disjoint selections in a mode
        // that only allows one, extend the removal to the end of the selection.
<span class="nc bnc" id="L571" title="All 6 branches missed.">        if (getSelectionMode() != MULTIPLE_INTERVAL_SELECTION &amp;&amp;</span>
               clearMin &gt; minIndex &amp;&amp; clearMax &lt; maxIndex) {
<span class="nc" id="L573">            clearMax = maxIndex;</span>
        }

<span class="nc" id="L576">        changeSelection(clearMin, clearMax, setMin, setMax);</span>
<span class="nc" id="L577">    }</span>

    private void setState(int index, boolean state) {
<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (state) {</span>
<span class="nc" id="L581">            set(index);</span>
        }
        else {
<span class="nc" id="L584">            clear(index);</span>
        }
<span class="nc" id="L586">    }</span>

    /**
     * Insert length indices beginning before/after index. If the value
     * at index is itself selected and the selection mode is not
     * SINGLE_SELECTION, set all of the newly inserted items as selected.
     * Otherwise leave them unselected. This method is typically
     * called to sync the selection model with a corresponding change
     * in the data model.
     */
    public void insertIndexInterval(int index, int length, boolean before)
    {
        /* The first new index will appear at insMinIndex and the last
         * one will appear at insMaxIndex
         */
<span class="nc bnc" id="L601" title="All 2 branches missed.">        int insMinIndex = (before) ? index : index + 1;</span>
<span class="nc" id="L602">        int insMaxIndex = (insMinIndex + length) - 1;</span>

        /* Right shift the entire bitset by length, beginning with
         * index-1 if before is true, index+1 if it's false (i.e. with
         * insMinIndex).
         */
<span class="nc bnc" id="L608" title="All 2 branches missed.">        for(int i = maxIndex; i &gt;= insMinIndex; i--) {</span>
<span class="nc" id="L609">            setState(i + length, value.get(i));</span>
        }

        /* Initialize the newly inserted indices.
         */
<span class="nc bnc" id="L614" title="All 2 branches missed.">        boolean setInsertedValues = ((getSelectionMode() == SINGLE_SELECTION) ?</span>
<span class="nc" id="L615">                                        false : value.get(index));</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        for(int i = insMinIndex; i &lt;= insMaxIndex; i++) {</span>
<span class="nc" id="L617">            setState(i, setInsertedValues);</span>
        }

<span class="nc" id="L620">        int leadIndex = this.leadIndex;</span>
<span class="nc bnc" id="L621" title="All 6 branches missed.">        if (leadIndex &gt; index || (before &amp;&amp; leadIndex == index)) {</span>
<span class="nc" id="L622">            leadIndex = this.leadIndex + length;</span>
        }
<span class="nc" id="L624">        int anchorIndex = this.anchorIndex;</span>
<span class="nc bnc" id="L625" title="All 6 branches missed.">        if (anchorIndex &gt; index || (before &amp;&amp; anchorIndex == index)) {</span>
<span class="nc" id="L626">            anchorIndex = this.anchorIndex + length;</span>
        }
<span class="nc bnc" id="L628" title="All 4 branches missed.">        if (leadIndex != this.leadIndex || anchorIndex != this.anchorIndex) {</span>
<span class="nc" id="L629">            updateLeadAnchorIndices(anchorIndex, leadIndex);</span>
        }

<span class="nc" id="L632">        fireValueChanged();</span>
<span class="nc" id="L633">    }</span>


    /**
     * Remove the indices in the interval index0,index1 (inclusive) from
     * the selection model.  This is typically called to sync the selection
     * model width a corresponding change in the data model.  Note
     * that (as always) index0 need not be &amp;lt;= index1.
     */
    public void removeIndexInterval(int index0, int index1)
    {
<span class="nc" id="L644">        int rmMinIndex = Math.min(index0, index1);</span>
<span class="nc" id="L645">        int rmMaxIndex = Math.max(index0, index1);</span>
<span class="nc" id="L646">        int gapLength = (rmMaxIndex - rmMinIndex) + 1;</span>

        /* Shift the entire bitset to the left to close the index0, index1
         * gap.
         */
<span class="nc bnc" id="L651" title="All 2 branches missed.">        for(int i = rmMinIndex; i &lt;= maxIndex; i++) {</span>
<span class="nc" id="L652">            setState(i, value.get(i + gapLength));</span>
        }

<span class="nc" id="L655">        int leadIndex = this.leadIndex;</span>
<span class="nc bnc" id="L656" title="All 4 branches missed.">        if (leadIndex == 0 &amp;&amp; rmMinIndex == 0) {</span>
            // do nothing
<span class="nc bnc" id="L658" title="All 2 branches missed.">        } else if (leadIndex &gt; rmMaxIndex) {</span>
<span class="nc" id="L659">            leadIndex = this.leadIndex - gapLength;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">        } else if (leadIndex &gt;= rmMinIndex) {</span>
<span class="nc" id="L661">            leadIndex = rmMinIndex - 1;</span>
        }

<span class="nc" id="L664">        int anchorIndex = this.anchorIndex;</span>
<span class="nc bnc" id="L665" title="All 4 branches missed.">        if (anchorIndex == 0 &amp;&amp; rmMinIndex == 0) {</span>
            // do nothing
<span class="nc bnc" id="L667" title="All 2 branches missed.">        } else if (anchorIndex &gt; rmMaxIndex) {</span>
<span class="nc" id="L668">            anchorIndex = this.anchorIndex - gapLength;</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">        } else if (anchorIndex &gt;= rmMinIndex) {</span>
<span class="nc" id="L670">            anchorIndex = rmMinIndex - 1;</span>
        }

<span class="nc bnc" id="L673" title="All 4 branches missed.">        if (leadIndex != this.leadIndex || anchorIndex != this.anchorIndex) {</span>
<span class="nc" id="L674">            updateLeadAnchorIndices(anchorIndex, leadIndex);</span>
        }

<span class="nc" id="L677">        fireValueChanged();</span>
<span class="nc" id="L678">    }</span>


    /** {@inheritDoc} */
    public void setValueIsAdjusting(boolean isAdjusting) {
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if (isAdjusting != this.isAdjusting) {</span>
<span class="nc" id="L684">            this.isAdjusting = isAdjusting;</span>
<span class="nc" id="L685">            this.fireValueChanged(isAdjusting);</span>
        }
<span class="nc" id="L687">    }</span>


    /**
     * Returns a string that displays and identifies this
     * object's properties.
     *
     * @return a &lt;code&gt;String&lt;/code&gt; representation of this object
     */
    public String toString() {
<span class="nc bnc" id="L697" title="All 2 branches missed.">        String s =  ((getValueIsAdjusting()) ? &quot;~&quot; : &quot;=&quot;) + value.toString();</span>
<span class="nc" id="L698">        return getClass().getName() + &quot; &quot; + Integer.toString(hashCode()) + &quot; &quot; + s;</span>
    }

    /**
     * Returns a clone of this selection model with the same selection.
     * &lt;code&gt;listenerLists&lt;/code&gt; are not duplicated.
     *
     * @exception CloneNotSupportedException if the selection model does not
     *    both (a) implement the Cloneable interface and (b) define a
     *    &lt;code&gt;clone&lt;/code&gt; method.
     */
    public Object clone() throws CloneNotSupportedException {
<span class="nc" id="L710">        DefaultListSelectionModel clone = (DefaultListSelectionModel)super.clone();</span>
<span class="nc" id="L711">        clone.value = (BitSet)value.clone();</span>
<span class="nc" id="L712">        clone.listenerList = new EventListenerList();</span>
<span class="nc" id="L713">        return clone;</span>
    }

    /** {@inheritDoc} */
    @Transient
    public int getAnchorSelectionIndex() {
<span class="nc" id="L719">        return anchorIndex;</span>
    }

    /** {@inheritDoc} */
    @Transient
    public int getLeadSelectionIndex() {
<span class="nc" id="L725">        return leadIndex;</span>
    }

    /**
     * Set the anchor selection index, leaving all selection values unchanged.
     * If leadAnchorNotificationEnabled is true, send a notification covering
     * the old and new anchor cells.
     *
     * @see #getAnchorSelectionIndex
     * @see #setLeadSelectionIndex
     */
    public void setAnchorSelectionIndex(int anchorIndex) {
<span class="nc" id="L737">        updateLeadAnchorIndices(anchorIndex, this.leadIndex);</span>
<span class="nc" id="L738">        fireValueChanged();</span>
<span class="nc" id="L739">    }</span>

    /**
     * Set the lead selection index, leaving all selection values unchanged.
     * If leadAnchorNotificationEnabled is true, send a notification covering
     * the old and new lead cells.
     *
     * @param leadIndex the new lead selection index
     *
     * @see #setAnchorSelectionIndex
     * @see #setLeadSelectionIndex
     * @see #getLeadSelectionIndex
     *
     * @since 1.5
     */
    public void moveLeadSelectionIndex(int leadIndex) {
        // disallow a -1 lead unless the anchor is already -1
<span class="nc bnc" id="L756" title="All 2 branches missed.">        if (leadIndex == -1) {</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            if (this.anchorIndex != -1) {</span>
<span class="nc" id="L758">                return;</span>
            }

/* PENDING(shannonh) - The following check is nice, to be consistent with
                       setLeadSelectionIndex. However, it is not absolutely
                       necessary: One could work around it by setting the anchor
                       to something valid, modifying the lead, and then moving
                       the anchor back to -1. For this reason, there's no sense
                       in adding it at this time, as that would require
                       updating the spec and officially committing to it.

        // otherwise, don't do anything if the anchor is -1
        } else if (this.anchorIndex == -1) {
            return;
*/

        }

<span class="nc" id="L776">        updateLeadAnchorIndices(this.anchorIndex, leadIndex);</span>
<span class="nc" id="L777">        fireValueChanged();</span>
<span class="nc" id="L778">    }</span>

    /**
     * Sets the lead selection index, ensuring that values between the
     * anchor and the new lead are either all selected or all deselected.
     * If the value at the anchor index is selected, first clear all the
     * values in the range [anchor, oldLeadIndex], then select all the values
     * values in the range [anchor, newLeadIndex], where oldLeadIndex is the old
     * leadIndex and newLeadIndex is the new one.
     * &lt;p&gt;
     * If the value at the anchor index is not selected, do the same thing in
     * reverse selecting values in the old range and deselecting values in the
     * new one.
     * &lt;p&gt;
     * Generate a single event for this change and notify all listeners.
     * For the purposes of generating minimal bounds in this event, do the
     * operation in a single pass; that way the first and last index inside the
     * ListSelectionEvent that is broadcast will refer to cells that actually
     * changed value because of this method. If, instead, this operation were
     * done in two steps the effect on the selection state would be the same
     * but two events would be generated and the bounds around the changed
     * values would be wider, including cells that had been first cleared only
     * to later be set.
     * &lt;p&gt;
     * This method can be used in the &lt;code&gt;mouseDragged&lt;/code&gt; method
     * of a UI class to extend a selection.
     *
     * @see #getLeadSelectionIndex
     * @see #setAnchorSelectionIndex
     */
    public void setLeadSelectionIndex(int leadIndex) {
<span class="nc" id="L809">        int anchorIndex = this.anchorIndex;</span>

        // only allow a -1 lead if the anchor is already -1
<span class="nc bnc" id="L812" title="All 2 branches missed.">        if (leadIndex == -1) {</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">            if (anchorIndex == -1) {</span>
<span class="nc" id="L814">                updateLeadAnchorIndices(anchorIndex, leadIndex);</span>
<span class="nc" id="L815">                fireValueChanged();</span>
            }

<span class="nc" id="L818">            return;</span>
        // otherwise, don't do anything if the anchor is -1
<span class="nc bnc" id="L820" title="All 2 branches missed.">        } else if (anchorIndex == -1) {</span>
<span class="nc" id="L821">            return;</span>
        }

<span class="nc bnc" id="L824" title="All 2 branches missed.">        if (this.leadIndex == -1) {</span>
<span class="nc" id="L825">            this.leadIndex = leadIndex;</span>
        }

<span class="nc" id="L828">        boolean shouldSelect = value.get(this.anchorIndex);</span>

<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (getSelectionMode() == SINGLE_SELECTION) {</span>
<span class="nc" id="L831">            anchorIndex = leadIndex;</span>
<span class="nc" id="L832">            shouldSelect = true;</span>
        }

<span class="nc" id="L835">        int oldMin = Math.min(this.anchorIndex, this.leadIndex);</span>
<span class="nc" id="L836">        int oldMax = Math.max(this.anchorIndex, this.leadIndex);</span>
<span class="nc" id="L837">        int newMin = Math.min(anchorIndex, leadIndex);</span>
<span class="nc" id="L838">        int newMax = Math.max(anchorIndex, leadIndex);</span>

<span class="nc" id="L840">        updateLeadAnchorIndices(anchorIndex, leadIndex);</span>

<span class="nc bnc" id="L842" title="All 2 branches missed.">        if (shouldSelect) {</span>
<span class="nc" id="L843">            changeSelection(oldMin, oldMax, newMin, newMax);</span>
        }
        else {
<span class="nc" id="L846">            changeSelection(newMin, newMax, oldMin, oldMax, false);</span>
        }
<span class="nc" id="L848">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>