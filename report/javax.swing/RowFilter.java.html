<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RowFilter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">RowFilter.java</span></div><h1>RowFilter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.util.ArrayList;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * &lt;code&gt;RowFilter&lt;/code&gt; is used to filter out entries from the
 * model so that they are not shown in the view.  For example, a
 * &lt;code&gt;RowFilter&lt;/code&gt; associated with a &lt;code&gt;JTable&lt;/code&gt; might
 * only allow rows that contain a column with a specific string. The
 * meaning of &lt;em&gt;entry&lt;/em&gt; depends on the component type.
 * For example, when a filter is
 * associated with a &lt;code&gt;JTable&lt;/code&gt;, an entry corresponds to a
 * row; when associated with a &lt;code&gt;JTree&lt;/code&gt;, an entry corresponds
 * to a node.
 * &lt;p&gt;
 * Subclasses must override the &lt;code&gt;include&lt;/code&gt; method to
 * indicate whether the entry should be shown in the
 * view.  The &lt;code&gt;Entry&lt;/code&gt; argument can be used to obtain the values in
 * each of the columns in that entry.  The following example shows an
 * &lt;code&gt;include&lt;/code&gt; method that allows only entries containing one or
 * more values starting with the string &quot;a&quot;:
 * &lt;pre&gt;
 * RowFilter&amp;lt;Object,Object&amp;gt; startsWithAFilter = new RowFilter&amp;lt;Object,Object&amp;gt;() {
 *   public boolean include(Entry&amp;lt;? extends Object, ? extends Object&amp;gt; entry) {
 *     for (int i = entry.getValueCount() - 1; i &amp;gt;= 0; i--) {
 *       if (entry.getStringValue(i).startsWith(&quot;a&quot;)) {
 *         // The value starts with &quot;a&quot;, include it
 *         return true;
 *       }
 *     }
 *     // None of the columns start with &quot;a&quot;; return false so that this
 *     // entry is not shown
 *     return false;
 *   }
 * };
 * &lt;/pre&gt;
 * &lt;code&gt;RowFilter&lt;/code&gt; has two formal type parameters that allow
 * you to create a &lt;code&gt;RowFilter&lt;/code&gt; for a specific model. For
 * example, the following assumes a specific model that is wrapping
 * objects of type &lt;code&gt;Person&lt;/code&gt;.  Only &lt;code&gt;Person&lt;/code&gt;s
 * with an age over 20 will be shown:
 * &lt;pre&gt;
 * RowFilter&amp;lt;PersonModel,Integer&amp;gt; ageFilter = new RowFilter&amp;lt;PersonModel,Integer&amp;gt;() {
 *   public boolean include(Entry&amp;lt;? extends PersonModel, ? extends Integer&amp;gt; entry) {
 *     PersonModel personModel = entry.getModel();
 *     Person person = personModel.getPerson(entry.getIdentifier());
 *     if (person.getAge() &amp;gt; 20) {
 *       // Returning true indicates this row should be shown.
 *       return true;
 *     }
 *     // Age is &amp;lt;= 20, don't show it.
 *     return false;
 *   }
 * };
 * PersonModel model = createPersonModel();
 * TableRowSorter&amp;lt;PersonModel&amp;gt; sorter = new TableRowSorter&amp;lt;PersonModel&amp;gt;(model);
 * sorter.setRowFilter(ageFilter);
 * &lt;/pre&gt;
 *
 * @param &lt;M&gt; the type of the model; for example &lt;code&gt;PersonModel&lt;/code&gt;
 * @param &lt;I&gt; the type of the identifier; when using
 *            &lt;code&gt;TableRowSorter&lt;/code&gt; this will be &lt;code&gt;Integer&lt;/code&gt;
 * @see javax.swing.table.TableRowSorter
 * @since 1.6
 */
<span class="nc" id="L96">public abstract class RowFilter&lt;M,I&gt; {</span>
    /**
     * Enumeration of the possible comparison values supported by
     * some of the default &lt;code&gt;RowFilter&lt;/code&gt;s.
     *
     * @see RowFilter
     * @since 1.6
     */
<span class="nc" id="L104">    public enum ComparisonType {</span>
        /**
         * Indicates that entries with a value before the supplied
         * value should be included.
         */
<span class="nc" id="L109">        BEFORE,</span>

        /**
         * Indicates that entries with a value after the supplied
         * value should be included.
         */
<span class="nc" id="L115">        AFTER,</span>

        /**
         * Indicates that entries with a value equal to the supplied
         * value should be included.
         */
<span class="nc" id="L121">        EQUAL,</span>

        /**
         * Indicates that entries with a value not equal to the supplied
         * value should be included.
         */
<span class="nc" id="L127">        NOT_EQUAL</span>
    }

    /**
     * Throws an IllegalArgumentException if any of the values in
     * columns are &lt; 0.
     */
    private static void checkIndices(int[] columns) {
<span class="nc bnc" id="L135" title="All 2 branches missed.">        for (int i = columns.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">            if (columns[i] &lt; 0) {</span>
<span class="nc" id="L137">                throw new IllegalArgumentException(&quot;Index must be &gt;= 0&quot;);</span>
            }
        }
<span class="nc" id="L140">    }</span>

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that uses a regular
     * expression to determine which entries to include.  Only entries
     * with at least one matching value are included.  For
     * example, the following creates a &lt;code&gt;RowFilter&lt;/code&gt; that
     * includes entries with at least one value starting with
     * &quot;a&quot;:
     * &lt;pre&gt;
     *   RowFilter.regexFilter(&quot;^a&quot;);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The returned filter uses {@link java.util.regex.Matcher#find}
     * to test for inclusion.  To test for exact matches use the
     * characters '^' and '$' to match the beginning and end of the
     * string respectively.  For example, &quot;^foo$&quot; includes only rows whose
     * string is exactly &quot;foo&quot; and not, for example, &quot;food&quot;.  See
     * {@link java.util.regex.Pattern} for a complete description of
     * the supported regular-expression constructs.
     *
     * @param regex the regular expression to filter on
     * @param indices the indices of the values to check.  If not supplied all
     *               values are evaluated
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @throws NullPointerException if &lt;code&gt;regex&lt;/code&gt; is
     *         &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if any of the &lt;code&gt;indices&lt;/code&gt;
     *         are &amp;lt; 0
     * @throws PatternSyntaxException if &lt;code&gt;regex&lt;/code&gt; is
     *         not a valid regular expression.
     * @see java.util.regex.Pattern
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; regexFilter(String regex,
                                                       int... indices) {
<span class="nc" id="L175">        return (RowFilter&lt;M,I&gt;)new RegexFilter(Pattern.compile(regex),</span>
                                               indices);
    }

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that includes entries that
     * have at least one &lt;code&gt;Date&lt;/code&gt; value meeting the specified
     * criteria.  For example, the following &lt;code&gt;RowFilter&lt;/code&gt; includes
     * only entries with at least one date value after the current date:
     * &lt;pre&gt;
     *   RowFilter.dateFilter(ComparisonType.AFTER, new Date());
     * &lt;/pre&gt;
     *
     * @param type the type of comparison to perform
     * @param date the date to compare against
     * @param indices the indices of the values to check.  If not supplied all
     *               values are evaluated
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @throws NullPointerException if &lt;code&gt;date&lt;/code&gt; is
     *          &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if any of the &lt;code&gt;indices&lt;/code&gt;
     *         are &amp;lt; 0 or &lt;code&gt;type&lt;/code&gt; is
     *         &lt;code&gt;null&lt;/code&gt;
     * @see java.util.Calendar
     * @see java.util.Date
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; dateFilter(ComparisonType type,
                                            Date date, int... indices) {
<span class="nc" id="L203">        return (RowFilter&lt;M,I&gt;)new DateFilter(type, date.getTime(), indices);</span>
    }

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that includes entries that
     * have at least one &lt;code&gt;Number&lt;/code&gt; value meeting the
     * specified criteria.  For example, the following
     * filter will only include entries with at
     * least one number value equal to 10:
     * &lt;pre&gt;
     *   RowFilter.numberFilter(ComparisonType.EQUAL, 10);
     * &lt;/pre&gt;
     *
     * @param type the type of comparison to perform
     * @param indices the indices of the values to check.  If not supplied all
     *               values are evaluated
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @throws IllegalArgumentException if any of the &lt;code&gt;indices&lt;/code&gt;
     *         are &amp;lt; 0, &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     *         or &lt;code&gt;number&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; numberFilter(ComparisonType type,
                                            Number number, int... indices) {
<span class="nc" id="L226">        return (RowFilter&lt;M,I&gt;)new NumberFilter(type, number, indices);</span>
    }

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that includes entries if any
     * of the supplied filters includes the entry.
     * &lt;p&gt;
     * The following example creates a &lt;code&gt;RowFilter&lt;/code&gt; that will
     * include any entries containing the string &quot;foo&quot; or the string
     * &quot;bar&quot;:
     * &lt;pre&gt;
     *   List&amp;lt;RowFilter&amp;lt;Object,Object&amp;gt;&amp;gt; filters = new ArrayList&amp;lt;RowFilter&amp;lt;Object,Object&amp;gt;&amp;gt;(2);
     *   filters.add(RowFilter.regexFilter(&quot;foo&quot;));
     *   filters.add(RowFilter.regexFilter(&quot;bar&quot;));
     *   RowFilter&amp;lt;Object,Object&amp;gt; fooBarFilter = RowFilter.orFilter(filters);
     * &lt;/pre&gt;
     *
     * @param filters the &lt;code&gt;RowFilter&lt;/code&gt;s to test
     * @throws IllegalArgumentException if any of the filters
     *         are &lt;code&gt;null&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;filters&lt;/code&gt; is null
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @see java.util.Arrays#asList
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; orFilter(
            Iterable&lt;? extends RowFilter&lt;? super M, ? super I&gt;&gt; filters) {
<span class="nc" id="L252">        return new OrFilter&lt;M,I&gt;(filters);</span>
    }

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that includes entries if all
     * of the supplied filters include the entry.
     * &lt;p&gt;
     * The following example creates a &lt;code&gt;RowFilter&lt;/code&gt; that will
     * include any entries containing the string &quot;foo&quot; and the string
     * &quot;bar&quot;:
     * &lt;pre&gt;
     *   List&amp;lt;RowFilter&amp;lt;Object,Object&amp;gt;&amp;gt; filters = new ArrayList&amp;lt;RowFilter&amp;lt;Object,Object&amp;gt;&amp;gt;(2);
     *   filters.add(RowFilter.regexFilter(&quot;foo&quot;));
     *   filters.add(RowFilter.regexFilter(&quot;bar&quot;));
     *   RowFilter&amp;lt;Object,Object&amp;gt; fooBarFilter = RowFilter.andFilter(filters);
     * &lt;/pre&gt;
     *
     * @param filters the &lt;code&gt;RowFilter&lt;/code&gt;s to test
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @throws IllegalArgumentException if any of the filters
     *         are &lt;code&gt;null&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;filters&lt;/code&gt; is null
     * @see java.util.Arrays#asList
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; andFilter(
            Iterable&lt;? extends RowFilter&lt;? super M, ? super I&gt;&gt; filters) {
<span class="nc" id="L278">        return new AndFilter&lt;M,I&gt;(filters);</span>
    }

    /**
     * Returns a &lt;code&gt;RowFilter&lt;/code&gt; that includes entries if the
     * supplied filter does not include the entry.
     *
     * @param filter the &lt;code&gt;RowFilter&lt;/code&gt; to negate
     * @return a &lt;code&gt;RowFilter&lt;/code&gt; implementing the specified criteria
     * @throws IllegalArgumentException if &lt;code&gt;filter&lt;/code&gt; is
     *         &lt;code&gt;null&lt;/code&gt;
     */
    public static &lt;M,I&gt; RowFilter&lt;M,I&gt; notFilter(RowFilter&lt;M,I&gt; filter) {
<span class="nc" id="L291">        return new NotFilter&lt;M,I&gt;(filter);</span>
    }

    /**
     * Returns true if the specified entry should be shown;
     * returns false if the entry should be hidden.
     * &lt;p&gt;
     * The &lt;code&gt;entry&lt;/code&gt; argument is valid only for the duration of
     * the invocation.  Using &lt;code&gt;entry&lt;/code&gt; after the call returns
     * results in undefined behavior.
     *
     * @param entry a non-&lt;code&gt;null&lt;/code&gt; object that wraps the underlying
     *              object from the model
     * @return true if the entry should be shown
     */
    public abstract boolean include(Entry&lt;? extends M, ? extends I&gt; entry);

    //
    // WARNING:
    // Because of the method signature of dateFilter/numberFilter/regexFilter
    // we can NEVER add a method to RowFilter that returns M,I. If we were
    // to do so it would be possible to get a ClassCastException during normal
    // usage.
    //

    /**
     * An &lt;code&gt;Entry&lt;/code&gt; object is passed to instances of
     * &lt;code&gt;RowFilter&lt;/code&gt;, allowing the filter to get the value of the
     * entry's data, and thus to determine whether the entry should be shown.
     * An &lt;code&gt;Entry&lt;/code&gt; object contains information about the model
     * as well as methods for getting the underlying values from the model.
     *
     * @param &lt;M&gt; the type of the model; for example &lt;code&gt;PersonModel&lt;/code&gt;
     * @param &lt;I&gt; the type of the identifier; when using
     *            &lt;code&gt;TableRowSorter&lt;/code&gt; this will be &lt;code&gt;Integer&lt;/code&gt;
     * @see javax.swing.RowFilter
     * @see javax.swing.DefaultRowSorter#setRowFilter(javax.swing.RowFilter)
     * @since 1.6
     */
    public static abstract class Entry&lt;M, I&gt; {
        /**
         * Creates an &lt;code&gt;Entry&lt;/code&gt;.
         */
<span class="nc" id="L334">        public Entry() {</span>
<span class="nc" id="L335">        }</span>

        /**
         * Returns the underlying model.
         *
         * @return the model containing the data that this entry represents
         */
        public abstract M getModel();

        /**
         * Returns the number of values in the entry.  For
         * example, when used with a table this corresponds to the
         * number of columns.
         *
         * @return number of values in the object being filtered
         */
        public abstract int getValueCount();

        /**
         * Returns the value at the specified index.  This may return
         * &lt;code&gt;null&lt;/code&gt;.  When used with a table, index
         * corresponds to the column number in the model.
         *
         * @param index the index of the value to get
         * @return value at the specified index
         * @throws IndexOutOfBoundsException if index &amp;lt; 0 or
         *         &amp;gt;= getValueCount
         */
        public abstract Object getValue(int index);

        /**
         * Returns the string value at the specified index.  If
         * filtering is being done based on &lt;code&gt;String&lt;/code&gt; values
         * this method is preferred to that of &lt;code&gt;getValue&lt;/code&gt;
         * as &lt;code&gt;getValue(index).toString()&lt;/code&gt; may return a
         * different result than &lt;code&gt;getStringValue(index)&lt;/code&gt;.
         * &lt;p&gt;
         * This implementation calls &lt;code&gt;getValue(index).toString()&lt;/code&gt;
         * after checking for &lt;code&gt;null&lt;/code&gt;.  Subclasses that provide
         * different string conversion should override this method if
         * necessary.
         *
         * @param index the index of the value to get
         * @return {@code non-null} string at the specified index
         * @throws IndexOutOfBoundsException if index &amp;lt; 0 ||
         *         &amp;gt;= getValueCount
         */
        public String getStringValue(int index) {
<span class="nc" id="L383">            Object value = getValue(index);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">            return (value == null) ? &quot;&quot; : value.toString();</span>
        }

        /**
         * Returns the identifer (in the model) of the entry.
         * For a table this corresponds to the index of the row in the model,
         * expressed as an &lt;code&gt;Integer&lt;/code&gt;.
         *
         * @return a model-based (not view-based) identifier for
         *         this entry
         */
        public abstract I getIdentifier();
    }


    private static abstract class GeneralFilter extends RowFilter&lt;Object,Object&gt; {
        private int[] columns;

<span class="nc" id="L402">        GeneralFilter(int[] columns) {</span>
<span class="nc" id="L403">            checkIndices(columns);</span>
<span class="nc" id="L404">            this.columns = columns;</span>
<span class="nc" id="L405">        }</span>

        public boolean include(Entry&lt;? extends Object,? extends Object&gt; value){
<span class="nc" id="L408">            int count = value.getValueCount();</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (columns.length &gt; 0) {</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">                for (int i = columns.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L411">                    int index = columns[i];</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                    if (index &lt; count) {</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                        if (include(value, index)) {</span>
<span class="nc" id="L414">                            return true;</span>
                        }
                    }
                }
            }
            else {
<span class="nc bnc" id="L420" title="All 2 branches missed.">                while (--count &gt;= 0) {</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                    if (include(value, count)) {</span>
<span class="nc" id="L422">                        return true;</span>
                    }
                }
            }
<span class="nc" id="L426">            return false;</span>
        }

        protected abstract boolean include(
              Entry&lt;? extends Object,? extends Object&gt; value, int index);
    }


    private static class RegexFilter extends GeneralFilter {
        private Matcher matcher;

        RegexFilter(Pattern regex, int[] columns) {
<span class="nc" id="L438">            super(columns);</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            if (regex == null) {</span>
<span class="nc" id="L440">                throw new IllegalArgumentException(&quot;Pattern must be non-null&quot;);</span>
            }
<span class="nc" id="L442">            matcher = regex.matcher(&quot;&quot;);</span>
<span class="nc" id="L443">        }</span>

        protected boolean include(
                Entry&lt;? extends Object,? extends Object&gt; value, int index) {
<span class="nc" id="L447">            matcher.reset(value.getStringValue(index));</span>
<span class="nc" id="L448">            return matcher.find();</span>
        }
    }


    private static class DateFilter extends GeneralFilter {
        private long date;
        private ComparisonType type;

        DateFilter(ComparisonType type, long date, int[] columns) {
<span class="nc" id="L458">            super(columns);</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            if (type == null) {</span>
<span class="nc" id="L460">                throw new IllegalArgumentException(&quot;type must be non-null&quot;);</span>
            }
<span class="nc" id="L462">            this.type = type;</span>
<span class="nc" id="L463">            this.date = date;</span>
<span class="nc" id="L464">        }</span>

        protected boolean include(
                Entry&lt;? extends Object,? extends Object&gt; value, int index) {
<span class="nc" id="L468">            Object v = value.getValue(index);</span>

<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (v instanceof Date) {</span>
<span class="nc" id="L471">                long vDate = ((Date)v).getTime();</span>
<span class="nc bnc" id="L472" title="All 5 branches missed.">                switch(type) {</span>
                case BEFORE:
<span class="nc bnc" id="L474" title="All 2 branches missed.">                    return (vDate &lt; date);</span>
                case AFTER:
<span class="nc bnc" id="L476" title="All 2 branches missed.">                    return (vDate &gt; date);</span>
                case EQUAL:
<span class="nc bnc" id="L478" title="All 2 branches missed.">                    return (vDate == date);</span>
                case NOT_EQUAL:
<span class="nc bnc" id="L480" title="All 2 branches missed.">                    return (vDate != date);</span>
                default:
                    break;
                }
            }
<span class="nc" id="L485">            return false;</span>
        }
    }




    private static class NumberFilter extends GeneralFilter {
        private boolean isComparable;
        private Number number;
        private ComparisonType type;

        NumberFilter(ComparisonType type, Number number, int[] columns) {
<span class="nc" id="L498">            super(columns);</span>
<span class="nc bnc" id="L499" title="All 4 branches missed.">            if (type == null || number == null) {</span>
<span class="nc" id="L500">                throw new IllegalArgumentException(</span>
                    &quot;type and number must be non-null&quot;);
            }
<span class="nc" id="L503">            this.type = type;</span>
<span class="nc" id="L504">            this.number = number;</span>
<span class="nc" id="L505">            isComparable = (number instanceof Comparable);</span>
<span class="nc" id="L506">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        protected boolean include(
                Entry&lt;? extends Object,? extends Object&gt; value, int index) {
<span class="nc" id="L511">            Object v = value.getValue(index);</span>

<span class="nc bnc" id="L513" title="All 2 branches missed.">            if (v instanceof Number) {</span>
<span class="nc" id="L514">                boolean compared = true;</span>
                int compareResult;
<span class="nc" id="L516">                Class vClass = v.getClass();</span>
<span class="nc bnc" id="L517" title="All 4 branches missed.">                if (number.getClass() == vClass &amp;&amp; isComparable) {</span>
<span class="nc" id="L518">                    compareResult = ((Comparable)number).compareTo(v);</span>
                }
                else {
<span class="nc" id="L521">                    compareResult = longCompare((Number)v);</span>
                }
<span class="nc bnc" id="L523" title="All 5 branches missed.">                switch(type) {</span>
                case BEFORE:
<span class="nc bnc" id="L525" title="All 2 branches missed.">                    return (compareResult &gt; 0);</span>
                case AFTER:
<span class="nc bnc" id="L527" title="All 2 branches missed.">                    return (compareResult &lt; 0);</span>
                case EQUAL:
<span class="nc bnc" id="L529" title="All 2 branches missed.">                    return (compareResult == 0);</span>
                case NOT_EQUAL:
<span class="nc bnc" id="L531" title="All 2 branches missed.">                    return (compareResult != 0);</span>
                default:
                    break;
                }
            }
<span class="nc" id="L536">            return false;</span>
        }

        private int longCompare(Number o) {
<span class="nc" id="L540">            long diff = number.longValue() - o.longValue();</span>

<span class="nc bnc" id="L542" title="All 2 branches missed.">            if (diff &lt; 0) {</span>
<span class="nc" id="L543">                return -1;</span>
            }
<span class="nc bnc" id="L545" title="All 2 branches missed.">            else if (diff &gt; 0) {</span>
<span class="nc" id="L546">                return 1;</span>
            }
<span class="nc" id="L548">            return 0;</span>
        }
    }


    private static class OrFilter&lt;M,I&gt; extends RowFilter&lt;M,I&gt; {
        List&lt;RowFilter&lt;? super M,? super I&gt;&gt; filters;

<span class="nc" id="L556">        OrFilter(Iterable&lt;? extends RowFilter&lt;? super M, ? super I&gt;&gt; filters) {</span>
<span class="nc" id="L557">            this.filters = new ArrayList&lt;RowFilter&lt;? super M,? super I&gt;&gt;();</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">            for (RowFilter&lt;? super M, ? super I&gt; filter : filters) {</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                if (filter == null) {</span>
<span class="nc" id="L560">                    throw new IllegalArgumentException(</span>
                        &quot;Filter must be non-null&quot;);
                }
<span class="nc" id="L563">                this.filters.add(filter);</span>
<span class="nc" id="L564">            }</span>
<span class="nc" id="L565">        }</span>

        public boolean include(Entry&lt;? extends M, ? extends I&gt; value) {
<span class="nc bnc" id="L568" title="All 2 branches missed.">            for (RowFilter&lt;? super M,? super I&gt; filter : filters) {</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">                if (filter.include(value)) {</span>
<span class="nc" id="L570">                    return true;</span>
                }
<span class="nc" id="L572">            }</span>
<span class="nc" id="L573">            return false;</span>
        }
    }


    private static class AndFilter&lt;M,I&gt; extends OrFilter&lt;M,I&gt; {
        AndFilter(Iterable&lt;? extends RowFilter&lt;? super M,? super I&gt;&gt; filters) {
<span class="nc" id="L580">            super(filters);</span>
<span class="nc" id="L581">        }</span>

        public boolean include(Entry&lt;? extends M, ? extends I&gt; value) {
<span class="nc bnc" id="L584" title="All 2 branches missed.">            for (RowFilter&lt;? super M,? super I&gt; filter : filters) {</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">                if (!filter.include(value)) {</span>
<span class="nc" id="L586">                    return false;</span>
                }
<span class="nc" id="L588">            }</span>
<span class="nc" id="L589">            return true;</span>
        }
    }


<span class="nc" id="L594">    private static class NotFilter&lt;M,I&gt; extends RowFilter&lt;M,I&gt; {</span>
        private RowFilter&lt;M,I&gt; filter;

<span class="nc" id="L597">        NotFilter(RowFilter&lt;M,I&gt; filter) {</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (filter == null) {</span>
<span class="nc" id="L599">                throw new IllegalArgumentException(</span>
                    &quot;filter must be non-null&quot;);
            }
<span class="nc" id="L602">            this.filter = filter;</span>
<span class="nc" id="L603">        }</span>

        public boolean include(Entry&lt;? extends M, ? extends I&gt; value) {
<span class="nc bnc" id="L606" title="All 2 branches missed.">            return !filter.include(value);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>