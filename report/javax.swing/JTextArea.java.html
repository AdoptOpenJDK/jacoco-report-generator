<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>JTextArea.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JTextArea.java</span></div><h1>JTextArea.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.awt.*;
import java.awt.event.*;
import javax.swing.text.*;
import javax.swing.plaf.*;
import javax.accessibility.*;

import java.util.Collections;
import java.util.Set;
import java.util.StringTokenizer;

import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;

/**
 * A &lt;code&gt;JTextArea&lt;/code&gt; is a multi-line area that displays plain text.
 * It is intended to be a lightweight component that provides source
 * compatibility with the &lt;code&gt;java.awt.TextArea&lt;/code&gt; class where it can
 * reasonably do so.
 * You can find information and examples of using all the text components in
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/text.html&quot;&gt;Using Text Components&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 *
 * &lt;p&gt;
 * This component has capabilities not found in the
 * &lt;code&gt;java.awt.TextArea&lt;/code&gt; class.  The superclass should be
 * consulted for additional capabilities.
 * Alternative multi-line text classes with
 * more capabilities are &lt;code&gt;JTextPane&lt;/code&gt; and &lt;code&gt;JEditorPane&lt;/code&gt;.
 * &lt;p&gt;
 * The &lt;code&gt;java.awt.TextArea&lt;/code&gt; internally handles scrolling.
 * &lt;code&gt;JTextArea&lt;/code&gt; is different in that it doesn't manage scrolling,
 * but implements the swing &lt;code&gt;Scrollable&lt;/code&gt; interface.  This allows it
 * to be placed inside a &lt;code&gt;JScrollPane&lt;/code&gt; if scrolling
 * behavior is desired, and used directly if scrolling is not desired.
 * &lt;p&gt;
 * The &lt;code&gt;java.awt.TextArea&lt;/code&gt; has the ability to do line wrapping.
 * This was controlled by the horizontal scrolling policy.  Since
 * scrolling is not done by &lt;code&gt;JTextArea&lt;/code&gt; directly, backward
 * compatibility must be provided another way.  &lt;code&gt;JTextArea&lt;/code&gt; has
 * a bound property for line wrapping that controls whether or
 * not it will wrap lines.  By default, the line wrapping property
 * is set to false (not wrapped).
 * &lt;p&gt;
 * &lt;code&gt;java.awt.TextArea&lt;/code&gt; has two properties &lt;code&gt;rows&lt;/code&gt;
 * and &lt;code&gt;columns&lt;/code&gt; that are used to determine the preferred size.
 * &lt;code&gt;JTextArea&lt;/code&gt; uses these properties to indicate the
 * preferred size of the viewport when placed inside a &lt;code&gt;JScrollPane&lt;/code&gt;
 * to match the functionality provided by &lt;code&gt;java.awt.TextArea&lt;/code&gt;.
 * &lt;code&gt;JTextArea&lt;/code&gt; has a preferred size of what is needed to
 * display all of the text, so that it functions properly inside of
 * a &lt;code&gt;JScrollPane&lt;/code&gt;.  If the value for &lt;code&gt;rows&lt;/code&gt;
 * or &lt;code&gt;columns&lt;/code&gt; is equal to zero,
 * the preferred size along that axis is used for
 * the viewport preferred size along the same axis.
 * &lt;p&gt;
 * The &lt;code&gt;java.awt.TextArea&lt;/code&gt; could be monitored for changes by adding
 * a &lt;code&gt;TextListener&lt;/code&gt; for &lt;code&gt;TextEvent&lt;/code&gt;s.
 * In the &lt;code&gt;JTextComponent&lt;/code&gt; based
 * components, changes are broadcasted from the model via a
 * &lt;code&gt;DocumentEvent&lt;/code&gt; to &lt;code&gt;DocumentListeners&lt;/code&gt;.
 * The &lt;code&gt;DocumentEvent&lt;/code&gt; gives
 * the location of the change and the kind of change if desired.
 * The code fragment might look something like:
 * &lt;pre&gt;
 *    DocumentListener myListener = ??;
 *    JTextArea myArea = ??;
 *    myArea.getDocument().addDocumentListener(myListener);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Newlines&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * For a discussion on how newlines are handled, see
 * &lt;a href=&quot;text/DefaultEditorKit.html&quot;&gt;DefaultEditorKit&lt;/a&gt;.
 * &lt;/dl&gt;
 *
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @beaninfo
 *   attribute: isContainer false
 * description: A multi-line area that displays plain text.
 *
 * @author  Timothy Prinzing
 * @see JTextPane
 * @see JEditorPane
 */
public class JTextArea extends JTextComponent {

    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;TextAreaUI&quot;;

    /**
     * Constructs a new TextArea.  A default model is set, the initial string
     * is null, and rows/columns are set to 0.
     */
    public JTextArea() {
<span class="nc" id="L140">        this(null, null, 0, 0);</span>
<span class="nc" id="L141">    }</span>

    /**
     * Constructs a new TextArea with the specified text displayed.
     * A default model is created and rows/columns are set to 0.
     *
     * @param text the text to be displayed, or null
     */
    public JTextArea(String text) {
<span class="nc" id="L150">        this(null, text, 0, 0);</span>
<span class="nc" id="L151">    }</span>

    /**
     * Constructs a new empty TextArea with the specified number of
     * rows and columns.  A default model is created, and the initial
     * string is null.
     *
     * @param rows the number of rows &amp;gt;= 0
     * @param columns the number of columns &amp;gt;= 0
     * @exception IllegalArgumentException if the rows or columns
     *  arguments are negative.
     */
    public JTextArea(int rows, int columns) {
<span class="nc" id="L164">        this(null, null, rows, columns);</span>
<span class="nc" id="L165">    }</span>

    /**
     * Constructs a new TextArea with the specified text and number
     * of rows and columns.  A default model is created.
     *
     * @param text the text to be displayed, or null
     * @param rows the number of rows &amp;gt;= 0
     * @param columns the number of columns &amp;gt;= 0
     * @exception IllegalArgumentException if the rows or columns
     *  arguments are negative.
     */
    public JTextArea(String text, int rows, int columns) {
<span class="nc" id="L178">        this(null, text, rows, columns);</span>
<span class="nc" id="L179">    }</span>

    /**
     * Constructs a new JTextArea with the given document model, and defaults
     * for all of the other arguments (null, 0, 0).
     *
     * @param doc  the model to use
     */
    public JTextArea(Document doc) {
<span class="nc" id="L188">        this(doc, null, 0, 0);</span>
<span class="nc" id="L189">    }</span>

    /**
     * Constructs a new JTextArea with the specified number of rows
     * and columns, and the given model.  All of the constructors
     * feed through this constructor.
     *
     * @param doc the model to use, or create a default one if null
     * @param text the text to be displayed, null if none
     * @param rows the number of rows &amp;gt;= 0
     * @param columns the number of columns &amp;gt;= 0
     * @exception IllegalArgumentException if the rows or columns
     *  arguments are negative.
     */
    public JTextArea(Document doc, String text, int rows, int columns) {
<span class="nc" id="L204">        super();</span>
<span class="nc" id="L205">        this.rows = rows;</span>
<span class="nc" id="L206">        this.columns = columns;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (doc == null) {</span>
<span class="nc" id="L208">            doc = createDefaultModel();</span>
        }
<span class="nc" id="L210">        setDocument(doc);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (text != null) {</span>
<span class="nc" id="L212">            setText(text);</span>
<span class="nc" id="L213">            select(0, 0);</span>
        }
<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (rows &lt; 0) {</span>
<span class="nc" id="L216">            throw new IllegalArgumentException(&quot;rows: &quot; + rows);</span>
        }
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (columns &lt; 0) {</span>
<span class="nc" id="L219">            throw new IllegalArgumentException(&quot;columns: &quot; + columns);</span>
        }
<span class="nc" id="L221">        LookAndFeel.installProperty(this,</span>
                                    &quot;focusTraversalKeysForward&quot;,
                                    JComponent.
<span class="nc" id="L224">                                    getManagingFocusForwardTraversalKeys());</span>
<span class="nc" id="L225">        LookAndFeel.installProperty(this,</span>
                                    &quot;focusTraversalKeysBackward&quot;,
                                    JComponent.
<span class="nc" id="L228">                                    getManagingFocusBackwardTraversalKeys());</span>
<span class="nc" id="L229">    }</span>

    /**
     * Returns the class ID for the UI.
     *
     * @return the ID (&quot;TextAreaUI&quot;)
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L239">        return uiClassID;</span>
    }

    /**
     * Creates the default implementation of the model
     * to be used at construction if one isn't explicitly
     * given.  A new instance of PlainDocument is returned.
     *
     * @return the default document model
     */
    protected Document createDefaultModel() {
<span class="nc" id="L250">        return new PlainDocument();</span>
    }

    /**
     * Sets the number of characters to expand tabs to.
     * This will be multiplied by the maximum advance for
     * variable width fonts.  A PropertyChange event (&quot;tabSize&quot;) is fired
     * when the tab size changes.
     *
     * @param size number of characters to expand to
     * @see #getTabSize
     * @beaninfo
     *   preferred: true
     *       bound: true
     * description: the number of characters to expand tabs to
     */
    public void setTabSize(int size) {
<span class="nc" id="L267">        Document doc = getDocument();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (doc != null) {</span>
<span class="nc" id="L269">            int old = getTabSize();</span>
<span class="nc" id="L270">            doc.putProperty(PlainDocument.tabSizeAttribute, Integer.valueOf(size));</span>
<span class="nc" id="L271">            firePropertyChange(&quot;tabSize&quot;, old, size);</span>
        }
<span class="nc" id="L273">    }</span>

    /**
     * Gets the number of characters used to expand tabs.  If the document is
     * null or doesn't have a tab setting, return a default of 8.
     *
     * @return the number of characters
     */
    public int getTabSize() {
<span class="nc" id="L282">        int size = 8;</span>
<span class="nc" id="L283">        Document doc = getDocument();</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (doc != null) {</span>
<span class="nc" id="L285">            Integer i = (Integer) doc.getProperty(PlainDocument.tabSizeAttribute);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            if (i != null) {</span>
<span class="nc" id="L287">                size = i.intValue();</span>
            }
        }
<span class="nc" id="L290">        return size;</span>
    }

    /**
     * Sets the line-wrapping policy of the text area.  If set
     * to true the lines will be wrapped if they are too long
     * to fit within the allocated width.  If set to false,
     * the lines will always be unwrapped.  A &lt;code&gt;PropertyChange&lt;/code&gt;
     * event (&quot;lineWrap&quot;) is fired when the policy is changed.
     * By default this property is false.
     *
     * @param wrap indicates if lines should be wrapped
     * @see #getLineWrap
     * @beaninfo
     *   preferred: true
     *       bound: true
     * description: should lines be wrapped
     */
    public void setLineWrap(boolean wrap) {
<span class="nc" id="L309">        boolean old = this.wrap;</span>
<span class="nc" id="L310">        this.wrap = wrap;</span>
<span class="nc" id="L311">        firePropertyChange(&quot;lineWrap&quot;, old, wrap);</span>
<span class="nc" id="L312">    }</span>

    /**
     * Gets the line-wrapping policy of the text area.  If set
     * to true the lines will be wrapped if they are too long
     * to fit within the allocated width.  If set to false,
     * the lines will always be unwrapped.
     *
     * @return if lines will be wrapped
     */
    public boolean getLineWrap() {
<span class="nc" id="L323">        return wrap;</span>
    }

    /**
     * Sets the style of wrapping used if the text area is wrapping
     * lines.  If set to true the lines will be wrapped at word
     * boundaries (whitespace) if they are too long
     * to fit within the allocated width.  If set to false,
     * the lines will be wrapped at character boundaries.
     * By default this property is false.
     *
     * @param word indicates if word boundaries should be used
     *   for line wrapping
     * @see #getWrapStyleWord
     * @beaninfo
     *   preferred: false
     *       bound: true
     * description: should wrapping occur at word boundaries
     */
    public void setWrapStyleWord(boolean word) {
<span class="nc" id="L343">        boolean old = this.word;</span>
<span class="nc" id="L344">        this.word = word;</span>
<span class="nc" id="L345">        firePropertyChange(&quot;wrapStyleWord&quot;, old, word);</span>
<span class="nc" id="L346">    }</span>

    /**
     * Gets the style of wrapping used if the text area is wrapping
     * lines.  If set to true the lines will be wrapped at word
     * boundaries (ie whitespace) if they are too long
     * to fit within the allocated width.  If set to false,
     * the lines will be wrapped at character boundaries.
     *
     * @return if the wrap style should be word boundaries
     *  instead of character boundaries
     * @see #setWrapStyleWord
     */
    public boolean getWrapStyleWord() {
<span class="nc" id="L360">        return word;</span>
    }

    /**
     * Translates an offset into the components text to a
     * line number.
     *
     * @param offset the offset &amp;gt;= 0
     * @return the line number &amp;gt;= 0
     * @exception BadLocationException thrown if the offset is
     *   less than zero or greater than the document length.
     */
    public int getLineOfOffset(int offset) throws BadLocationException {
<span class="nc" id="L373">        Document doc = getDocument();</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (offset &lt; 0) {</span>
<span class="nc" id="L375">            throw new BadLocationException(&quot;Can't translate offset to line&quot;, -1);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        } else if (offset &gt; doc.getLength()) {</span>
<span class="nc" id="L377">            throw new BadLocationException(&quot;Can't translate offset to line&quot;, doc.getLength()+1);</span>
        } else {
<span class="nc" id="L379">            Element map = getDocument().getDefaultRootElement();</span>
<span class="nc" id="L380">            return map.getElementIndex(offset);</span>
        }
    }

    /**
     * Determines the number of lines contained in the area.
     *
     * @return the number of lines &amp;gt; 0
     */
    public int getLineCount() {
<span class="nc" id="L390">        Element map = getDocument().getDefaultRootElement();</span>
<span class="nc" id="L391">        return map.getElementCount();</span>
    }

    /**
     * Determines the offset of the start of the given line.
     *
     * @param line  the line number to translate &amp;gt;= 0
     * @return the offset &amp;gt;= 0
     * @exception BadLocationException thrown if the line is
     * less than zero or greater or equal to the number of
     * lines contained in the document (as reported by
     * getLineCount).
     */
    public int getLineStartOffset(int line) throws BadLocationException {
<span class="nc" id="L405">        int lineCount = getLineCount();</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (line &lt; 0) {</span>
<span class="nc" id="L407">            throw new BadLocationException(&quot;Negative line&quot;, -1);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        } else if (line &gt;= lineCount) {</span>
<span class="nc" id="L409">            throw new BadLocationException(&quot;No such line&quot;, getDocument().getLength()+1);</span>
        } else {
<span class="nc" id="L411">            Element map = getDocument().getDefaultRootElement();</span>
<span class="nc" id="L412">            Element lineElem = map.getElement(line);</span>
<span class="nc" id="L413">            return lineElem.getStartOffset();</span>
        }
    }

    /**
     * Determines the offset of the end of the given line.
     *
     * @param line  the line &amp;gt;= 0
     * @return the offset &amp;gt;= 0
     * @exception BadLocationException Thrown if the line is
     * less than zero or greater or equal to the number of
     * lines contained in the document (as reported by
     * getLineCount).
     */
    public int getLineEndOffset(int line) throws BadLocationException {
<span class="nc" id="L428">        int lineCount = getLineCount();</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (line &lt; 0) {</span>
<span class="nc" id="L430">            throw new BadLocationException(&quot;Negative line&quot;, -1);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">        } else if (line &gt;= lineCount) {</span>
<span class="nc" id="L432">            throw new BadLocationException(&quot;No such line&quot;, getDocument().getLength()+1);</span>
        } else {
<span class="nc" id="L434">            Element map = getDocument().getDefaultRootElement();</span>
<span class="nc" id="L435">            Element lineElem = map.getElement(line);</span>
<span class="nc" id="L436">            int endOffset = lineElem.getEndOffset();</span>
            // hide the implicit break at the end of the document
<span class="nc bnc" id="L438" title="All 2 branches missed.">            return ((line == lineCount - 1) ? (endOffset - 1) : endOffset);</span>
        }
    }

    // --- java.awt.TextArea methods ---------------------------------

    /**
     * Inserts the specified text at the specified position.  Does nothing
     * if the model is null or if the text is null or empty.
     *
     * @param str the text to insert
     * @param pos the position at which to insert &amp;gt;= 0
     * @exception IllegalArgumentException  if pos is an
     *  invalid position in the model
     * @see TextComponent#setText
     * @see #replaceRange
     */
    public void insert(String str, int pos) {
<span class="nc" id="L456">        Document doc = getDocument();</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">        if (doc != null) {</span>
            try {
<span class="nc" id="L459">                doc.insertString(pos, str, null);</span>
<span class="nc" id="L460">            } catch (BadLocationException e) {</span>
<span class="nc" id="L461">                throw new IllegalArgumentException(e.getMessage());</span>
<span class="nc" id="L462">            }</span>
        }
<span class="nc" id="L464">    }</span>

    /**
     * Appends the given text to the end of the document.  Does nothing if
     * the model is null or the string is null or empty.
     *
     * @param str the text to insert
     * @see #insert
     */
    public void append(String str) {
<span class="nc" id="L474">        Document doc = getDocument();</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (doc != null) {</span>
            try {
<span class="nc" id="L477">                doc.insertString(doc.getLength(), str, null);</span>
<span class="nc" id="L478">            } catch (BadLocationException e) {</span>
<span class="nc" id="L479">            }</span>
        }
<span class="nc" id="L481">    }</span>

    /**
     * Replaces text from the indicated start to end position with the
     * new text specified.  Does nothing if the model is null.  Simply
     * does a delete if the new string is null or empty.
     *
     * @param str the text to use as the replacement
     * @param start the start position &amp;gt;= 0
     * @param end the end position &amp;gt;= start
     * @exception IllegalArgumentException  if part of the range is an
     *  invalid position in the model
     * @see #insert
     * @see #replaceRange
     */
    public void replaceRange(String str, int start, int end) {
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (end &lt; start) {</span>
<span class="nc" id="L498">            throw new IllegalArgumentException(&quot;end before start&quot;);</span>
        }
<span class="nc" id="L500">        Document doc = getDocument();</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (doc != null) {</span>
            try {
<span class="nc bnc" id="L503" title="All 2 branches missed.">                if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L504">                    ((AbstractDocument)doc).replace(start, end - start, str,</span>
                                                    null);
                }
                else {
<span class="nc" id="L508">                    doc.remove(start, end - start);</span>
<span class="nc" id="L509">                    doc.insertString(start, str, null);</span>
                }
<span class="nc" id="L511">            } catch (BadLocationException e) {</span>
<span class="nc" id="L512">                throw new IllegalArgumentException(e.getMessage());</span>
<span class="nc" id="L513">            }</span>
        }
<span class="nc" id="L515">    }</span>

    /**
     * Returns the number of rows in the TextArea.
     *
     * @return the number of rows &amp;gt;= 0
     */
    public int getRows() {
<span class="nc" id="L523">        return rows;</span>
    }

    /**
     * Sets the number of rows for this TextArea.  Calls invalidate() after
     * setting the new value.
     *
     * @param rows the number of rows &amp;gt;= 0
     * @exception IllegalArgumentException if rows is less than 0
     * @see #getRows
     * @beaninfo
     * description: the number of rows preferred for display
     */
    public void setRows(int rows) {
<span class="nc" id="L537">        int oldVal = this.rows;</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (rows &lt; 0) {</span>
<span class="nc" id="L539">            throw new IllegalArgumentException(&quot;rows less than zero.&quot;);</span>
        }
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (rows != oldVal) {</span>
<span class="nc" id="L542">            this.rows = rows;</span>
<span class="nc" id="L543">            invalidate();</span>
        }
<span class="nc" id="L545">    }</span>

    /**
     * Defines the meaning of the height of a row.  This defaults to
     * the height of the font.
     *
     * @return the height &amp;gt;= 1
     */
    protected int getRowHeight() {
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (rowHeight == 0) {</span>
<span class="nc" id="L555">            FontMetrics metrics = getFontMetrics(getFont());</span>
<span class="nc" id="L556">            rowHeight = metrics.getHeight();</span>
        }
<span class="nc" id="L558">        return rowHeight;</span>
    }

    /**
     * Returns the number of columns in the TextArea.
     *
     * @return number of columns &amp;gt;= 0
     */
    public int getColumns() {
<span class="nc" id="L567">        return columns;</span>
    }

    /**
     * Sets the number of columns for this TextArea.  Does an invalidate()
     * after setting the new value.
     *
     * @param columns the number of columns &amp;gt;= 0
     * @exception IllegalArgumentException if columns is less than 0
     * @see #getColumns
     * @beaninfo
     * description: the number of columns preferred for display
     */
    public void setColumns(int columns) {
<span class="nc" id="L581">        int oldVal = this.columns;</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">        if (columns &lt; 0) {</span>
<span class="nc" id="L583">            throw new IllegalArgumentException(&quot;columns less than zero.&quot;);</span>
        }
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (columns != oldVal) {</span>
<span class="nc" id="L586">            this.columns = columns;</span>
<span class="nc" id="L587">            invalidate();</span>
        }
<span class="nc" id="L589">    }</span>

    /**
     * Gets column width.
     * The meaning of what a column is can be considered a fairly weak
     * notion for some fonts.  This method is used to define the width
     * of a column.  By default this is defined to be the width of the
     * character &lt;em&gt;m&lt;/em&gt; for the font used.  This method can be
     * redefined to be some alternative amount.
     *
     * @return the column width &amp;gt;= 1
     */
    protected int getColumnWidth() {
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (columnWidth == 0) {</span>
<span class="nc" id="L603">            FontMetrics metrics = getFontMetrics(getFont());</span>
<span class="nc" id="L604">            columnWidth = metrics.charWidth('m');</span>
        }
<span class="nc" id="L606">        return columnWidth;</span>
    }

    // --- Component methods -----------------------------------------

    /**
     * Returns the preferred size of the TextArea.  This is the
     * maximum of the size needed to display the text and the
     * size requested for the viewport.
     *
     * @return the size
     */
    public Dimension getPreferredSize() {
<span class="nc" id="L619">        Dimension d = super.getPreferredSize();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">        d = (d == null) ? new Dimension(400,400) : d;</span>
<span class="nc" id="L621">        Insets insets = getInsets();</span>

<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (columns != 0) {</span>
<span class="nc" id="L624">            d.width = Math.max(d.width, columns * getColumnWidth() +</span>
                    insets.left + insets.right);
        }
<span class="nc bnc" id="L627" title="All 2 branches missed.">        if (rows != 0) {</span>
<span class="nc" id="L628">            d.height = Math.max(d.height, rows * getRowHeight() +</span>
                                insets.top + insets.bottom);
        }
<span class="nc" id="L631">        return d;</span>
    }

    /**
     * Sets the current font.  This removes cached row height and column
     * width so the new font will be reflected, and calls revalidate().
     *
     * @param f the font to use as the current font
     */
    public void setFont(Font f) {
<span class="nc" id="L641">        super.setFont(f);</span>
<span class="nc" id="L642">        rowHeight = 0;</span>
<span class="nc" id="L643">        columnWidth = 0;</span>
<span class="nc" id="L644">    }</span>


    /**
     * Returns a string representation of this JTextArea. This method
     * is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this JTextArea.
     */
    protected String paramString() {
<span class="nc bnc" id="L657" title="All 2 branches missed.">        String wrapString = (wrap ?</span>
                             &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L659" title="All 2 branches missed.">        String wordString = (word ?</span>
                             &quot;true&quot; : &quot;false&quot;);

<span class="nc" id="L662">        return super.paramString() +</span>
        &quot;,colums=&quot; + columns +
        &quot;,columWidth=&quot; + columnWidth +
        &quot;,rows=&quot; + rows +
        &quot;,rowHeight=&quot; + rowHeight +
        &quot;,word=&quot; + wordString +
        &quot;,wrap=&quot; + wrapString;
    }

    // --- Scrollable methods ----------------------------------------

    /**
     * Returns true if a viewport should always force the width of this
     * Scrollable to match the width of the viewport.  This is implemented
     * to return true if the line wrapping policy is true, and false
     * if lines are not being wrapped.
     *
     * @return true if a viewport should force the Scrollables width
     * to match its own.
     */
    public boolean getScrollableTracksViewportWidth() {
<span class="nc bnc" id="L683" title="All 2 branches missed.">        return (wrap) ? true : super.getScrollableTracksViewportWidth();</span>
    }

    /**
     * Returns the preferred size of the viewport if this component
     * is embedded in a JScrollPane.  This uses the desired column
     * and row settings if they have been set, otherwise the superclass
     * behavior is used.
     *
     * @return The preferredSize of a JViewport whose view is this Scrollable.
     * @see JViewport#getPreferredSize
     */
    public Dimension getPreferredScrollableViewportSize() {
<span class="nc" id="L696">        Dimension size = super.getPreferredScrollableViewportSize();</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">        size = (size == null) ? new Dimension(400,400) : size;</span>
<span class="nc" id="L698">        Insets insets = getInsets();</span>

<span class="nc bnc" id="L700" title="All 2 branches missed.">        size.width = (columns == 0) ? size.width :</span>
<span class="nc" id="L701">                columns * getColumnWidth() + insets.left + insets.right;</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">        size.height = (rows == 0) ? size.height :</span>
<span class="nc" id="L703">                rows * getRowHeight() + insets.top + insets.bottom;</span>
<span class="nc" id="L704">        return size;</span>
    }

    /**
     * Components that display logical rows or columns should compute
     * the scroll increment that will completely expose one new row
     * or column, depending on the value of orientation.  This is implemented
     * to use the values returned by the &lt;code&gt;getRowHeight&lt;/code&gt; and
     * &lt;code&gt;getColumnWidth&lt;/code&gt; methods.
     * &lt;p&gt;
     * Scrolling containers, like JScrollPane, will use this method
     * each time the user requests a unit scroll.
     *
     * @param visibleRect the view area visible within the viewport
     * @param orientation Either SwingConstants.VERTICAL or
     *   SwingConstants.HORIZONTAL.
     * @param direction Less than zero to scroll up/left,
     *   greater than zero for down/right.
     * @return The &quot;unit&quot; increment for scrolling in the specified direction
     * @exception IllegalArgumentException for an invalid orientation
     * @see JScrollBar#setUnitIncrement
     * @see #getRowHeight
     * @see #getColumnWidth
     */
    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
<span class="nc bnc" id="L729" title="All 3 branches missed.">        switch (orientation) {</span>
        case SwingConstants.VERTICAL:
<span class="nc" id="L731">            return getRowHeight();</span>
        case SwingConstants.HORIZONTAL:
<span class="nc" id="L733">            return getColumnWidth();</span>
        default:
<span class="nc" id="L735">            throw new IllegalArgumentException(&quot;Invalid orientation: &quot; + orientation);</span>
        }
    }

    /**
     * See readObject() and writeObject() in JComponent for more
     * information about serialization in Swing.
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L744">        s.defaultWriteObject();</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        if (getUIClassID().equals(uiClassID)) {</span>
<span class="nc" id="L746">            byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L747">            JComponent.setWriteObjCounter(this, --count);</span>
<span class="nc bnc" id="L748" title="All 4 branches missed.">            if (count == 0 &amp;&amp; ui != null) {</span>
<span class="nc" id="L749">                ui.installUI(this);</span>
            }
        }
<span class="nc" id="L752">    }</span>

/////////////////
// Accessibility support
////////////////


    /**
     * Gets the AccessibleContext associated with this JTextArea.
     * For JTextAreas, the AccessibleContext takes the form of an
     * AccessibleJTextArea.
     * A new AccessibleJTextArea instance is created if necessary.
     *
     * @return an AccessibleJTextArea that serves as the
     *         AccessibleContext of this JTextArea
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L769" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L770">            accessibleContext = new AccessibleJTextArea();</span>
        }
<span class="nc" id="L772">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JTextArea&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to text area user-interface
     * elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
<span class="nc" id="L790">    protected class AccessibleJTextArea extends AccessibleJTextComponent {</span>

        /**
         * Gets the state set of this object.
         *
         * @return an instance of AccessibleStateSet describing the states
         * of the object
         * @see AccessibleStateSet
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L800">            AccessibleStateSet states = super.getAccessibleStateSet();</span>
<span class="nc" id="L801">            states.add(AccessibleState.MULTI_LINE);</span>
<span class="nc" id="L802">            return states;</span>
        }
    }

    // --- variables -------------------------------------------------

    private int rows;
    private int columns;
    private int columnWidth;
    private int rowHeight;
    private boolean wrap;
    private boolean word;

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>