<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SwingWorker.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">SwingWorker.java</span></div><h1>SwingWorker.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.lang.ref.WeakReference;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.PropertyChangeEvent;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

import java.awt.event.*;

import javax.swing.SwingUtilities;

import sun.awt.AppContext;
import sun.swing.AccumulativeRunnable;

/**
 * An abstract class to perform lengthy GUI-interaction tasks in a
 * background thread. Several background threads can be used to execute such
 * tasks. However, the exact strategy of choosing a thread for any particular
 * {@code SwingWorker} is unspecified and should not be relied on.
 * &lt;p&gt;
 * When writing a multi-threaded application using Swing, there are
 * two constraints to keep in mind:
 * (refer to
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;
 *   Concurrency in Swing
 * &lt;/a&gt; for more details):
 * &lt;ul&gt;
 *   &lt;li&gt; Time-consuming tasks should not be run on the &lt;i&gt;Event
 *        Dispatch Thread&lt;/i&gt;. Otherwise the application becomes unresponsive.
 *   &lt;/li&gt;
 *   &lt;li&gt; Swing components should be accessed  on the &lt;i&gt;Event
 *        Dispatch Thread&lt;/i&gt; only.
 *   &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 *
 * &lt;p&gt;
 * These constraints mean that a GUI application with time intensive
 * computing needs at least two threads:  1) a thread to perform the lengthy
 * task and 2) the &lt;i&gt;Event Dispatch Thread&lt;/i&gt; (EDT) for all GUI-related
 * activities.  This involves inter-thread communication which can be
 * tricky to implement.
 *
 * &lt;p&gt;
 * {@code SwingWorker} is designed for situations where you need to have a long
 * running task run in a background thread and provide updates to the UI
 * either when done, or while processing.
 * Subclasses of {@code SwingWorker} must implement
 * the {@link #doInBackground} method to perform the background computation.
 *
 *
 * &lt;p&gt;
 * &lt;b&gt;Workflow&lt;/b&gt;
 * &lt;p&gt;
 * There are three threads involved in the life cycle of a
 * {@code SwingWorker} :
 * &lt;ul&gt;
 * &lt;li&gt;
 * &lt;p&gt;
 * &lt;i&gt;Current&lt;/i&gt; thread: The {@link #execute} method is
 * called on this thread. It schedules {@code SwingWorker} for the execution on a
 * &lt;i&gt;worker&lt;/i&gt;
 * thread and returns immediately. One can wait for the {@code SwingWorker} to
 * complete using the {@link #get get} methods.
 * &lt;li&gt;
 * &lt;p&gt;
 * &lt;i&gt;Worker&lt;/i&gt; thread: The {@link #doInBackground}
 * method is called on this thread.
 * This is where all background activities should happen. To notify
 * {@code PropertyChangeListeners} about bound properties changes use the
 * {@link #firePropertyChange firePropertyChange} and
 * {@link #getPropertyChangeSupport} methods. By default there are two bound
 * properties available: {@code state} and {@code progress}.
 * &lt;li&gt;
 * &lt;p&gt;
 * &lt;i&gt;Event Dispatch Thread&lt;/i&gt;:  All Swing related activities occur
 * on this thread. {@code SwingWorker} invokes the
 * {@link #process process} and {@link #done} methods and notifies
 * any {@code PropertyChangeListeners} on this thread.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * Often, the &lt;i&gt;Current&lt;/i&gt; thread is the &lt;i&gt;Event Dispatch
 * Thread&lt;/i&gt;.
 *
 *
 * &lt;p&gt;
 * Before the {@code doInBackground} method is invoked on a &lt;i&gt;worker&lt;/i&gt; thread,
 * {@code SwingWorker} notifies any {@code PropertyChangeListeners} about the
 * {@code state} property change to {@code StateValue.STARTED}.  After the
 * {@code doInBackground} method is finished the {@code done} method is
 * executed.  Then {@code SwingWorker} notifies any {@code PropertyChangeListeners}
 * about the {@code state} property change to {@code StateValue.DONE}.
 *
 * &lt;p&gt;
 * {@code SwingWorker} is only designed to be executed once.  Executing a
 * {@code SwingWorker} more than once will not result in invoking the
 * {@code doInBackground} method twice.
 *
 * &lt;p&gt;
 * &lt;b&gt;Sample Usage&lt;/b&gt;
 * &lt;p&gt;
 * The following example illustrates the simplest use case.  Some
 * processing is done in the background and when done you update a Swing
 * component.
 *
 * &lt;p&gt;
 * Say we want to find the &quot;Meaning of Life&quot; and display the result in
 * a {@code JLabel}.
 *
 * &lt;pre&gt;
 *   final JLabel label;
 *   class MeaningOfLifeFinder extends SwingWorker&amp;lt;String, Object&amp;gt; {
 *       {@code @Override}
 *       public String doInBackground() {
 *           return findTheMeaningOfLife();
 *       }
 *
 *       {@code @Override}
 *       protected void done() {
 *           try {
 *               label.setText(get());
 *           } catch (Exception ignore) {
 *           }
 *       }
 *   }
 *
 *   (new MeaningOfLifeFinder()).execute();
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The next example is useful in situations where you wish to process data
 * as it is ready on the &lt;i&gt;Event Dispatch Thread&lt;/i&gt;.
 *
 * &lt;p&gt;
 * Now we want to find the first N prime numbers and display the results in a
 * {@code JTextArea}.  While this is computing, we want to update our
 * progress in a {@code JProgressBar}.  Finally, we also want to print
 * the prime numbers to {@code System.out}.
 * &lt;pre&gt;
 * class PrimeNumbersTask extends
 *         SwingWorker&amp;lt;List&amp;lt;Integer&amp;gt;, Integer&amp;gt; {
 *     PrimeNumbersTask(JTextArea textArea, int numbersToFind) {
 *         //initialize
 *     }
 *
 *     {@code @Override}
 *     public List&amp;lt;Integer&amp;gt; doInBackground() {
 *         while (! enough &amp;amp;&amp;amp; ! isCancelled()) {
 *                 number = nextPrimeNumber();
 *                 publish(number);
 *                 setProgress(100 * numbers.size() / numbersToFind);
 *             }
 *         }
 *         return numbers;
 *     }
 *
 *     {@code @Override}
 *     protected void process(List&amp;lt;Integer&amp;gt; chunks) {
 *         for (int number : chunks) {
 *             textArea.append(number + &amp;quot;\n&amp;quot;);
 *         }
 *     }
 * }
 *
 * JTextArea textArea = new JTextArea();
 * final JProgressBar progressBar = new JProgressBar(0, 100);
 * PrimeNumbersTask task = new PrimeNumbersTask(textArea, N);
 * task.addPropertyChangeListener(
 *     new PropertyChangeListener() {
 *         public  void propertyChange(PropertyChangeEvent evt) {
 *             if (&amp;quot;progress&amp;quot;.equals(evt.getPropertyName())) {
 *                 progressBar.setValue((Integer)evt.getNewValue());
 *             }
 *         }
 *     });
 *
 * task.execute();
 * System.out.println(task.get()); //prints all prime numbers we have got
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Because {@code SwingWorker} implements {@code Runnable}, a
 * {@code SwingWorker} can be submitted to an
 * {@link java.util.concurrent.Executor} for execution.
 *
 * @author Igor Kushnirskiy
 *
 * @param &lt;T&gt; the result type returned by this {@code SwingWorker's}
 *        {@code doInBackground} and {@code get} methods
 * @param &lt;V&gt; the type used for carrying out intermediate results by this
 *        {@code SwingWorker's} {@code publish} and {@code process} methods
 *
 * @since 1.6
 */
public abstract class SwingWorker&lt;T, V&gt; implements RunnableFuture&lt;T&gt; {
    /**
     * number of worker threads.
     */
    private static final int MAX_WORKER_THREADS = 10;

    /**
     * current progress.
     */
    private volatile int progress;

    /**
     * current state.
     */
    private volatile StateValue state;

    /**
     * everything is run inside this FutureTask. Also it is used as
     * a delegatee for the Future API.
     */
    private final FutureTask&lt;T&gt; future;

    /**
     * all propertyChangeSupport goes through this.
     */
    private final PropertyChangeSupport propertyChangeSupport;

    /**
     * handler for {@code process} mehtod.
     */
    private AccumulativeRunnable&lt;V&gt; doProcess;

    /**
     * handler for progress property change notifications.
     */
    private AccumulativeRunnable&lt;Integer&gt; doNotifyProgressChange;

<span class="nc" id="L263">    private final AccumulativeRunnable&lt;Runnable&gt; doSubmit = getDoSubmit();</span>

    /**
     * Values for the {@code state} bound property.
     * @since 1.6
     */
<span class="nc" id="L269">    public enum StateValue {</span>
        /**
         * Initial {@code SwingWorker} state.
         */
<span class="nc" id="L273">        PENDING,</span>
        /**
         * {@code SwingWorker} is {@code STARTED}
         * before invoking {@code doInBackground}.
         */
<span class="nc" id="L278">        STARTED,</span>

        /**
         * {@code SwingWorker} is {@code DONE}
         * after {@code doInBackground} method
         * is finished.
         */
<span class="nc" id="L285">        DONE</span>
    }

    /**
     * Constructs this {@code SwingWorker}.
     */
<span class="nc" id="L291">    public SwingWorker() {</span>
<span class="nc" id="L292">        Callable&lt;T&gt; callable =</span>
<span class="nc" id="L293">                new Callable&lt;T&gt;() {</span>
                    public T call() throws Exception {
<span class="nc" id="L295">                        setState(StateValue.STARTED);</span>
<span class="nc" id="L296">                        return doInBackground();</span>
                    }
                };

<span class="nc" id="L300">        future = new FutureTask&lt;T&gt;(callable) {</span>
                       @Override
                       protected void done() {
<span class="nc" id="L303">                           doneEDT();</span>
<span class="nc" id="L304">                           setState(StateValue.DONE);</span>
<span class="nc" id="L305">                       }</span>
                   };

<span class="nc" id="L308">       state = StateValue.PENDING;</span>
<span class="nc" id="L309">       propertyChangeSupport = new SwingWorkerPropertyChangeSupport(this);</span>
<span class="nc" id="L310">       doProcess = null;</span>
<span class="nc" id="L311">       doNotifyProgressChange = null;</span>
<span class="nc" id="L312">    }</span>

    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * &lt;p&gt;
     * Note that this method is executed only once.
     *
     * &lt;p&gt;
     * Note: this method is executed in a background thread.
     *
     *
     * @return the computed result
     * @throws Exception if unable to compute a result
     *
     */
    protected abstract T doInBackground() throws Exception ;

    /**
     * Sets this {@code Future} to the result of computation unless
     * it has been cancelled.
     */
    public final void run() {
<span class="nc" id="L335">        future.run();</span>
<span class="nc" id="L336">    }</span>

    /**
     * Sends data chunks to the {@link #process} method. This method is to be
     * used from inside the {@code doInBackground} method to deliver
     * intermediate results
     * for processing on the &lt;i&gt;Event Dispatch Thread&lt;/i&gt; inside the
     * {@code process} method.
     *
     * &lt;p&gt;
     * Because the {@code process} method is invoked asynchronously on
     * the &lt;i&gt;Event Dispatch Thread&lt;/i&gt;
     * multiple invocations to the {@code publish} method
     * might occur before the {@code process} method is executed. For
     * performance purposes all these invocations are coalesced into one
     * invocation with concatenated arguments.
     *
     * &lt;p&gt;
     * For example:
     *
     * &lt;pre&gt;
     * publish(&amp;quot;1&amp;quot;);
     * publish(&amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;);
     * publish(&amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;);
     * &lt;/pre&gt;
     *
     * might result in:
     *
     * &lt;pre&gt;
     * process(&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;)
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * &lt;b&gt;Sample Usage&lt;/b&gt;. This code snippet loads some tabular data and
     * updates {@code DefaultTableModel} with it. Note that it safe to mutate
     * the tableModel from inside the {@code process} method because it is
     * invoked on the &lt;i&gt;Event Dispatch Thread&lt;/i&gt;.
     *
     * &lt;pre&gt;
     * class TableSwingWorker extends
     *         SwingWorker&amp;lt;DefaultTableModel, Object[]&amp;gt; {
     *     private final DefaultTableModel tableModel;
     *
     *     public TableSwingWorker(DefaultTableModel tableModel) {
     *         this.tableModel = tableModel;
     *     }
     *
     *     {@code @Override}
     *     protected DefaultTableModel doInBackground() throws Exception {
     *         for (Object[] row = loadData();
     *                  ! isCancelled() &amp;amp;&amp;amp; row != null;
     *                  row = loadData()) {
     *             publish((Object[]) row);
     *         }
     *         return tableModel;
     *     }
     *
     *     {@code @Override}
     *     protected void process(List&amp;lt;Object[]&amp;gt; chunks) {
     *         for (Object[] row : chunks) {
     *             tableModel.addRow(row);
     *         }
     *     }
     * }
     * &lt;/pre&gt;
     *
     * @param chunks intermediate results to process
     *
     * @see #process
     *
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;) // Passing chunks to add is safe
    protected final void publish(V... chunks) {
<span class="nc" id="L410">        synchronized (this) {</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (doProcess == null) {</span>
<span class="nc" id="L412">                doProcess = new AccumulativeRunnable&lt;V&gt;() {</span>
                    @Override
                    public void run(List&lt;V&gt; args) {
<span class="nc" id="L415">                        process(args);</span>
<span class="nc" id="L416">                    }</span>
                    @Override
                    protected void submit() {
<span class="nc" id="L419">                        doSubmit.add(this);</span>
<span class="nc" id="L420">                    }</span>
                };
            }
<span class="nc" id="L423">        }</span>
<span class="nc" id="L424">        doProcess.add(chunks);</span>
<span class="nc" id="L425">    }</span>

    /**
     * Receives data chunks from the {@code publish} method asynchronously on the
     * &lt;i&gt;Event Dispatch Thread&lt;/i&gt;.
     *
     * &lt;p&gt;
     * Please refer to the {@link #publish} method for more details.
     *
     * @param chunks intermediate results to process
     *
     * @see #publish
     *
     */
    protected void process(List&lt;V&gt; chunks) {
<span class="nc" id="L440">    }</span>

    /**
     * Executed on the &lt;i&gt;Event Dispatch Thread&lt;/i&gt; after the {@code doInBackground}
     * method is finished. The default
     * implementation does nothing. Subclasses may override this method to
     * perform completion actions on the &lt;i&gt;Event Dispatch Thread&lt;/i&gt;. Note
     * that you can query status inside the implementation of this method to
     * determine the result of this task or whether this task has been cancelled.
     *
     * @see #doInBackground
     * @see #isCancelled()
     * @see #get
     */
    protected void done() {
<span class="nc" id="L455">    }</span>

    /**
     * Sets the {@code progress} bound property.
     * The value should be from 0 to 100.
     *
     * &lt;p&gt;
     * Because {@code PropertyChangeListener}s are notified asynchronously on
     * the &lt;i&gt;Event Dispatch Thread&lt;/i&gt; multiple invocations to the
     * {@code setProgress} method might occur before any
     * {@code PropertyChangeListeners} are invoked. For performance purposes
     * all these invocations are coalesced into one invocation with the last
     * invocation argument only.
     *
     * &lt;p&gt;
     * For example, the following invokations:
     *
     * &lt;pre&gt;
     * setProgress(1);
     * setProgress(2);
     * setProgress(3);
     * &lt;/pre&gt;
     *
     * might result in a single {@code PropertyChangeListener} notification with
     * the value {@code 3}.
     *
     * @param progress the progress value to set
     * @throws IllegalArgumentException is value not from 0 to 100
     */
    protected final void setProgress(int progress) {
<span class="nc bnc" id="L485" title="All 4 branches missed.">        if (progress &lt; 0 || progress &gt; 100) {</span>
<span class="nc" id="L486">            throw new IllegalArgumentException(&quot;the value should be from 0 to 100&quot;);</span>
        }
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (this.progress == progress) {</span>
<span class="nc" id="L489">            return;</span>
        }
<span class="nc" id="L491">        int oldProgress = this.progress;</span>
<span class="nc" id="L492">        this.progress = progress;</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (! getPropertyChangeSupport().hasListeners(&quot;progress&quot;)) {</span>
<span class="nc" id="L494">            return;</span>
        }
<span class="nc" id="L496">        synchronized (this) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">            if (doNotifyProgressChange == null) {</span>
<span class="nc" id="L498">                doNotifyProgressChange =</span>
<span class="nc" id="L499">                    new AccumulativeRunnable&lt;Integer&gt;() {</span>
                        @Override
                        public void run(List&lt;Integer&gt; args) {
<span class="nc" id="L502">                            firePropertyChange(&quot;progress&quot;,</span>
<span class="nc" id="L503">                               args.get(0),</span>
<span class="nc" id="L504">                               args.get(args.size() - 1));</span>
<span class="nc" id="L505">                        }</span>
                        @Override
                        protected void submit() {
<span class="nc" id="L508">                            doSubmit.add(this);</span>
<span class="nc" id="L509">                        }</span>
                    };
            }
<span class="nc" id="L512">        }</span>
<span class="nc" id="L513">        doNotifyProgressChange.add(oldProgress, progress);</span>
<span class="nc" id="L514">    }</span>

    /**
     * Returns the {@code progress} bound property.
     *
     * @return the progress bound property.
     */
    public final int getProgress() {
<span class="nc" id="L522">        return progress;</span>
    }

    /**
     * Schedules this {@code SwingWorker} for execution on a &lt;i&gt;worker&lt;/i&gt;
     * thread. There are a number of &lt;i&gt;worker&lt;/i&gt; threads available. In the
     * event all &lt;i&gt;worker&lt;/i&gt; threads are busy handling other
     * {@code SwingWorkers} this {@code SwingWorker} is placed in a waiting
     * queue.
     *
     * &lt;p&gt;
     * Note:
     * {@code SwingWorker} is only designed to be executed once.  Executing a
     * {@code SwingWorker} more than once will not result in invoking the
     * {@code doInBackground} method twice.
     */
    public final void execute() {
<span class="nc" id="L539">        getWorkersExecutorService().execute(this);</span>
<span class="nc" id="L540">    }</span>

    // Future methods START
    /**
     * {@inheritDoc}
     */
    public final boolean cancel(boolean mayInterruptIfRunning) {
<span class="nc" id="L547">        return future.cancel(mayInterruptIfRunning);</span>
    }

    /**
     * {@inheritDoc}
     */
    public final boolean isCancelled() {
<span class="nc" id="L554">        return future.isCancelled();</span>
    }

    /**
     * {@inheritDoc}
     */
    public final boolean isDone() {
<span class="nc" id="L561">        return future.isDone();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Note: calling {@code get} on the &lt;i&gt;Event Dispatch Thread&lt;/i&gt; blocks
     * &lt;i&gt;all&lt;/i&gt; events, including repaints, from being processed until this
     * {@code SwingWorker} is complete.
     *
     * &lt;p&gt;
     * When you want the {@code SwingWorker} to block on the &lt;i&gt;Event
     * Dispatch Thread&lt;/i&gt; we recommend that you use a &lt;i&gt;modal dialog&lt;/i&gt;.
     *
     * &lt;p&gt;
     * For example:
     *
     * &lt;pre&gt;
     * class SwingWorkerCompletionWaiter extends PropertyChangeListener {
     *     private JDialog dialog;
     *
     *     public SwingWorkerCompletionWaiter(JDialog dialog) {
     *         this.dialog = dialog;
     *     }
     *
     *     public void propertyChange(PropertyChangeEvent event) {
     *         if (&amp;quot;state&amp;quot;.equals(event.getPropertyName())
     *                 &amp;amp;&amp;amp; SwingWorker.StateValue.DONE == event.getNewValue()) {
     *             dialog.setVisible(false);
     *             dialog.dispose();
     *         }
     *     }
     * }
     * JDialog dialog = new JDialog(owner, true);
     * swingWorker.addPropertyChangeListener(
     *     new SwingWorkerCompletionWaiter(dialog));
     * swingWorker.execute();
     * //the dialog will be visible until the SwingWorker is done
     * dialog.setVisible(true);
     * &lt;/pre&gt;
     */
    public final T get() throws InterruptedException, ExecutionException {
<span class="nc" id="L603">        return future.get();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Please refer to {@link #get} for more details.
     */
    public final T get(long timeout, TimeUnit unit) throws InterruptedException,
            ExecutionException, TimeoutException {
<span class="nc" id="L613">        return future.get(timeout, unit);</span>
    }

    // Future methods END

    // PropertyChangeSupports methods START
    /**
     * Adds a {@code PropertyChangeListener} to the listener list. The listener
     * is registered for all properties. The same listener object may be added
     * more than once, and will be called as many times as it is added. If
     * {@code listener} is {@code null}, no exception is thrown and no action is taken.
     *
     * &lt;p&gt;
     * Note: This is merely a convenience wrapper. All work is delegated to
     * {@code PropertyChangeSupport} from {@link #getPropertyChangeSupport}.
     *
     * @param listener the {@code PropertyChangeListener} to be added
     */
    public final void addPropertyChangeListener(PropertyChangeListener listener) {
<span class="nc" id="L632">        getPropertyChangeSupport().addPropertyChangeListener(listener);</span>
<span class="nc" id="L633">    }</span>

    /**
     * Removes a {@code PropertyChangeListener} from the listener list. This
     * removes a {@code PropertyChangeListener} that was registered for all
     * properties. If {@code listener} was added more than once to the same
     * event source, it will be notified one less time after being removed. If
     * {@code listener} is {@code null}, or was never added, no exception is
     * thrown and no action is taken.
     *
     * &lt;p&gt;
     * Note: This is merely a convenience wrapper. All work is delegated to
     * {@code PropertyChangeSupport} from {@link #getPropertyChangeSupport}.
     *
     * @param listener the {@code PropertyChangeListener} to be removed
     */
    public final void removePropertyChangeListener(PropertyChangeListener listener) {
<span class="nc" id="L650">        getPropertyChangeSupport().removePropertyChangeListener(listener);</span>
<span class="nc" id="L651">    }</span>

    /**
     * Reports a bound property update to any registered listeners. No event is
     * fired if {@code old} and {@code new} are equal and non-null.
     *
     * &lt;p&gt;
     * This {@code SwingWorker} will be the source for
     * any generated events.
     *
     * &lt;p&gt;
     * When called off the &lt;i&gt;Event Dispatch Thread&lt;/i&gt;
     * {@code PropertyChangeListeners} are notified asynchronously on
     * the &lt;i&gt;Event Dispatch Thread&lt;/i&gt;.
     * &lt;p&gt;
     * Note: This is merely a convenience wrapper. All work is delegated to
     * {@code PropertyChangeSupport} from {@link #getPropertyChangeSupport}.
     *
     *
     * @param propertyName the programmatic name of the property that was
     *        changed
     * @param oldValue the old value of the property
     * @param newValue the new value of the property
     */
    public final void firePropertyChange(String propertyName, Object oldValue,
            Object newValue) {
<span class="nc" id="L677">        getPropertyChangeSupport().firePropertyChange(propertyName,</span>
            oldValue, newValue);
<span class="nc" id="L679">    }</span>

    /**
     * Returns the {@code PropertyChangeSupport} for this {@code SwingWorker}.
     * This method is used when flexible access to bound properties support is
     * needed.
     * &lt;p&gt;
     * This {@code SwingWorker} will be the source for
     * any generated events.
     *
     * &lt;p&gt;
     * Note: The returned {@code PropertyChangeSupport} notifies any
     * {@code PropertyChangeListener}s asynchronously on the &lt;i&gt;Event Dispatch
     * Thread&lt;/i&gt; in the event that {@code firePropertyChange} or
     * {@code fireIndexedPropertyChange} are called off the &lt;i&gt;Event Dispatch
     * Thread&lt;/i&gt;.
     *
     * @return {@code PropertyChangeSupport} for this {@code SwingWorker}
     */
    public final PropertyChangeSupport getPropertyChangeSupport() {
<span class="nc" id="L699">        return propertyChangeSupport;</span>
    }

    // PropertyChangeSupports methods END

    /**
     * Returns the {@code SwingWorker} state bound property.
     *
     * @return the current state
     */
    public final StateValue getState() {
        /*
         * DONE is a speacial case
         * to keep getState and isDone is sync
         */
<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (isDone()) {</span>
<span class="nc" id="L715">            return StateValue.DONE;</span>
        } else {
<span class="nc" id="L717">            return state;</span>
        }
    }

    /**
     * Sets this {@code SwingWorker} state bound property.
     * @param state the state to set
     */
    private void setState(StateValue state) {
<span class="nc" id="L726">        StateValue old = this.state;</span>
<span class="nc" id="L727">        this.state = state;</span>
<span class="nc" id="L728">        firePropertyChange(&quot;state&quot;, old, state);</span>
<span class="nc" id="L729">    }</span>

    /**
     * Invokes {@code done} on the EDT.
     */
    private void doneEDT() {
<span class="nc" id="L735">        Runnable doDone =</span>
<span class="nc" id="L736">            new Runnable() {</span>
                public void run() {
<span class="nc" id="L738">                    done();</span>
<span class="nc" id="L739">                }</span>
            };
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L742">            doDone.run();</span>
        } else {
<span class="nc" id="L744">            doSubmit.add(doDone);</span>
        }
<span class="nc" id="L746">    }</span>


    /**
     * returns workersExecutorService.
     *
     * returns the service stored in the appContext or creates it if
     * necessary.
     *
     * @return ExecutorService for the {@code SwingWorkers}
     */
    private static synchronized ExecutorService getWorkersExecutorService() {
<span class="nc" id="L758">        final AppContext appContext = AppContext.getAppContext();</span>
<span class="nc" id="L759">        ExecutorService executorService =</span>
<span class="nc" id="L760">            (ExecutorService) appContext.get(SwingWorker.class);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">        if (executorService == null) {</span>
            //this creates daemon threads.
<span class="nc" id="L763">            ThreadFactory threadFactory =</span>
<span class="nc" id="L764">                new ThreadFactory() {</span>
<span class="nc" id="L765">                    final ThreadFactory defaultFactory =</span>
<span class="nc" id="L766">                        Executors.defaultThreadFactory();</span>
                    public Thread newThread(final Runnable r) {
<span class="nc" id="L768">                        Thread thread =</span>
<span class="nc" id="L769">                            defaultFactory.newThread(r);</span>
<span class="nc" id="L770">                        thread.setName(&quot;SwingWorker-&quot;</span>
<span class="nc" id="L771">                            + thread.getName());</span>
<span class="nc" id="L772">                        thread.setDaemon(true);</span>
<span class="nc" id="L773">                        return thread;</span>
                    }
                };

<span class="nc" id="L777">            executorService =</span>
                new ThreadPoolExecutor(MAX_WORKER_THREADS, MAX_WORKER_THREADS,
                                       10L, TimeUnit.MINUTES,
                                       new LinkedBlockingQueue&lt;Runnable&gt;(),
                                       threadFactory);
<span class="nc" id="L782">            appContext.put(SwingWorker.class, executorService);</span>

            // Don't use ShutdownHook here as it's not enough. We should track
            // AppContext disposal instead of JVM shutdown, see 6799345 for details
<span class="nc" id="L786">            final ExecutorService es = executorService;</span>
<span class="nc" id="L787">            appContext.addPropertyChangeListener(AppContext.DISPOSED_PROPERTY_NAME,</span>
<span class="nc" id="L788">                new PropertyChangeListener() {</span>
                    @Override
                    public void propertyChange(PropertyChangeEvent pce) {
<span class="nc" id="L791">                        boolean disposed = (Boolean)pce.getNewValue();</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">                        if (disposed) {</span>
<span class="nc" id="L793">                            final WeakReference&lt;ExecutorService&gt; executorServiceRef =</span>
                                new WeakReference&lt;ExecutorService&gt;(es);
<span class="nc" id="L795">                            final ExecutorService executorService =</span>
<span class="nc" id="L796">                                executorServiceRef.get();</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">                            if (executorService != null) {</span>
<span class="nc" id="L798">                                AccessController.doPrivileged(</span>
<span class="nc" id="L799">                                    new PrivilegedAction&lt;Void&gt;() {</span>
                                        public Void run() {
<span class="nc" id="L801">                                            executorService.shutdown();</span>
<span class="nc" id="L802">                                            return null;</span>
                                        }
                                    }
                                );
                            }
                        }
<span class="nc" id="L808">                    }</span>
                }
            );
        }
<span class="nc" id="L812">        return executorService;</span>
    }

<span class="nc" id="L815">    private static final Object DO_SUBMIT_KEY = new StringBuilder(&quot;doSubmit&quot;);</span>
    private static AccumulativeRunnable&lt;Runnable&gt; getDoSubmit() {
<span class="nc" id="L817">        synchronized (DO_SUBMIT_KEY) {</span>
<span class="nc" id="L818">            final AppContext appContext = AppContext.getAppContext();</span>
<span class="nc" id="L819">            Object doSubmit = appContext.get(DO_SUBMIT_KEY);</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">            if (doSubmit == null) {</span>
<span class="nc" id="L821">                doSubmit = new DoSubmitAccumulativeRunnable();</span>
<span class="nc" id="L822">                appContext.put(DO_SUBMIT_KEY, doSubmit);</span>
            }
<span class="nc" id="L824">            return (AccumulativeRunnable&lt;Runnable&gt;) doSubmit;</span>
<span class="nc" id="L825">        }</span>
    }
<span class="nc" id="L827">    private static class DoSubmitAccumulativeRunnable</span>
          extends AccumulativeRunnable&lt;Runnable&gt; implements ActionListener {
        private final static int DELAY = 1000 / 30;
        @Override
        protected void run(List&lt;Runnable&gt; args) {
<span class="nc bnc" id="L832" title="All 2 branches missed.">            for (Runnable runnable : args) {</span>
<span class="nc" id="L833">                runnable.run();</span>
<span class="nc" id="L834">            }</span>
<span class="nc" id="L835">        }</span>
        @Override
        protected void submit() {
<span class="nc" id="L838">            Timer timer = new Timer(DELAY, this);</span>
<span class="nc" id="L839">            timer.setRepeats(false);</span>
<span class="nc" id="L840">            timer.start();</span>
<span class="nc" id="L841">        }</span>
        public void actionPerformed(ActionEvent event) {
<span class="nc" id="L843">            run();</span>
<span class="nc" id="L844">        }</span>
    }

    private class SwingWorkerPropertyChangeSupport
            extends PropertyChangeSupport {
<span class="nc" id="L849">        SwingWorkerPropertyChangeSupport(Object source) {</span>
<span class="nc" id="L850">            super(source);</span>
<span class="nc" id="L851">        }</span>
        @Override
        public void firePropertyChange(final PropertyChangeEvent evt) {
<span class="nc bnc" id="L854" title="All 2 branches missed.">            if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L855">                super.firePropertyChange(evt);</span>
            } else {
<span class="nc" id="L857">                doSubmit.add(</span>
<span class="nc" id="L858">                    new Runnable() {</span>
                        public void run() {
<span class="nc" id="L860">                            SwingWorkerPropertyChangeSupport.this</span>
<span class="nc" id="L861">                                .firePropertyChange(evt);</span>
<span class="nc" id="L862">                        }</span>
                    });
            }
<span class="nc" id="L865">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>