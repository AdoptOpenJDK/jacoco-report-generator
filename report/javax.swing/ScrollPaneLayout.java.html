<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ScrollPaneLayout.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">ScrollPaneLayout.java</span></div><h1>ScrollPaneLayout.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing;


import javax.swing.border.*;

import java.awt.LayoutManager;
import java.awt.Component;
import java.awt.Container;
import java.awt.Rectangle;
import java.awt.Dimension;
import java.awt.Insets;
import java.io.Serializable;


/**
 * The layout manager used by &lt;code&gt;JScrollPane&lt;/code&gt;.
 * &lt;code&gt;JScrollPaneLayout&lt;/code&gt; is
 * responsible for nine components: a viewport, two scrollbars,
 * a row header, a column header, and four &quot;corner&quot; components.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @see JScrollPane
 * @see JViewport
 *
 * @author Hans Muller
 */
<span class="nc" id="L60">public class ScrollPaneLayout</span>
    implements LayoutManager, ScrollPaneConstants, Serializable
{

    /**
     * The scrollpane's viewport child.
     * Default is an empty &lt;code&gt;JViewport&lt;/code&gt;.
     * @see JScrollPane#setViewport
     */
    protected JViewport viewport;


    /**
     * The scrollpane's vertical scrollbar child.
     * Default is a &lt;code&gt;JScrollBar&lt;/code&gt;.
     * @see JScrollPane#setVerticalScrollBar
     */
    protected JScrollBar vsb;


    /**
     * The scrollpane's horizontal scrollbar child.
     * Default is a &lt;code&gt;JScrollBar&lt;/code&gt;.
     * @see JScrollPane#setHorizontalScrollBar
     */
    protected JScrollBar hsb;


    /**
     * The row header child.  Default is &lt;code&gt;null&lt;/code&gt;.
     * @see JScrollPane#setRowHeader
     */
    protected JViewport rowHead;


    /**
     * The column header child.  Default is &lt;code&gt;null&lt;/code&gt;.
     * @see JScrollPane#setColumnHeader
     */
    protected JViewport colHead;


    /**
     * The component to display in the lower left corner.
     * Default is &lt;code&gt;null&lt;/code&gt;.
     * @see JScrollPane#setCorner
     */
    protected Component lowerLeft;


    /**
     * The component to display in the lower right corner.
     * Default is &lt;code&gt;null&lt;/code&gt;.
     * @see JScrollPane#setCorner
     */
    protected Component lowerRight;


    /**
     * The component to display in the upper left corner.
     * Default is &lt;code&gt;null&lt;/code&gt;.
     * @see JScrollPane#setCorner
     */
    protected Component upperLeft;


    /**
     * The component to display in the upper right corner.
     * Default is &lt;code&gt;null&lt;/code&gt;.
     * @see JScrollPane#setCorner
     */
    protected Component upperRight;


    /**
     * The display policy for the vertical scrollbar.
     * The default is &lt;code&gt;ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED&lt;/code&gt;.
     * &lt;p&gt;
     * This field is obsolete, please use the &lt;code&gt;JScrollPane&lt;/code&gt; field instead.
     *
     * @see JScrollPane#setVerticalScrollBarPolicy
     */
<span class="nc" id="L142">    protected int vsbPolicy = VERTICAL_SCROLLBAR_AS_NEEDED;</span>


    /**
     * The display policy for the horizontal scrollbar.
     * The default is &lt;code&gt;ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED&lt;/code&gt;.
     * &lt;p&gt;
     * This field is obsolete, please use the &lt;code&gt;JScrollPane&lt;/code&gt; field instead.
     *
     * @see JScrollPane#setHorizontalScrollBarPolicy
     */
<span class="nc" id="L153">    protected int hsbPolicy = HORIZONTAL_SCROLLBAR_AS_NEEDED;</span>


    /**
     * This method is invoked after the ScrollPaneLayout is set as the
     * LayoutManager of a &lt;code&gt;JScrollPane&lt;/code&gt;.
     * It initializes all of the internal fields that
     * are ordinarily set by &lt;code&gt;addLayoutComponent&lt;/code&gt;.  For example:
     * &lt;pre&gt;
     * ScrollPaneLayout mySPLayout = new ScrollPanelLayout() {
     *     public void layoutContainer(Container p) {
     *         super.layoutContainer(p);
     *         // do some extra work here ...
     *     }
     * };
     * scrollpane.setLayout(mySPLayout):
     * &lt;/pre&gt;
     */
    public void syncWithScrollPane(JScrollPane sp) {
<span class="nc" id="L172">        viewport = sp.getViewport();</span>
<span class="nc" id="L173">        vsb = sp.getVerticalScrollBar();</span>
<span class="nc" id="L174">        hsb = sp.getHorizontalScrollBar();</span>
<span class="nc" id="L175">        rowHead = sp.getRowHeader();</span>
<span class="nc" id="L176">        colHead = sp.getColumnHeader();</span>
<span class="nc" id="L177">        lowerLeft = sp.getCorner(LOWER_LEFT_CORNER);</span>
<span class="nc" id="L178">        lowerRight = sp.getCorner(LOWER_RIGHT_CORNER);</span>
<span class="nc" id="L179">        upperLeft = sp.getCorner(UPPER_LEFT_CORNER);</span>
<span class="nc" id="L180">        upperRight = sp.getCorner(UPPER_RIGHT_CORNER);</span>
<span class="nc" id="L181">        vsbPolicy = sp.getVerticalScrollBarPolicy();</span>
<span class="nc" id="L182">        hsbPolicy = sp.getHorizontalScrollBarPolicy();</span>
<span class="nc" id="L183">    }</span>


    /**
     * Removes an existing component.  When a new component, such as
     * the left corner, or vertical scrollbar, is added, the old one,
     * if it exists, must be removed.
     * &lt;p&gt;
     * This method returns &lt;code&gt;newC&lt;/code&gt;. If &lt;code&gt;oldC&lt;/code&gt; is
     * not equal to &lt;code&gt;newC&lt;/code&gt; and is non-&lt;code&gt;null&lt;/code&gt;,
     * it will be removed from its parent.
     *
     * @param oldC the &lt;code&gt;Component&lt;/code&gt; to replace
     * @param newC the &lt;code&gt;Component&lt;/code&gt; to add
     * @return the &lt;code&gt;newC&lt;/code&gt;
     */
    protected Component addSingletonComponent(Component oldC, Component newC)
    {
<span class="nc bnc" id="L201" title="All 4 branches missed.">        if ((oldC != null) &amp;&amp; (oldC != newC)) {</span>
<span class="nc" id="L202">            oldC.getParent().remove(oldC);</span>
        }
<span class="nc" id="L204">        return newC;</span>
    }


    /**
     * Adds the specified component to the layout. The layout is
     * identified using one of:
     * &lt;ul&gt;
     * &lt;li&gt;ScrollPaneConstants.VIEWPORT
     * &lt;li&gt;ScrollPaneConstants.VERTICAL_SCROLLBAR
     * &lt;li&gt;ScrollPaneConstants.HORIZONTAL_SCROLLBAR
     * &lt;li&gt;ScrollPaneConstants.ROW_HEADER
     * &lt;li&gt;ScrollPaneConstants.COLUMN_HEADER
     * &lt;li&gt;ScrollPaneConstants.LOWER_LEFT_CORNER
     * &lt;li&gt;ScrollPaneConstants.LOWER_RIGHT_CORNER
     * &lt;li&gt;ScrollPaneConstants.UPPER_LEFT_CORNER
     * &lt;li&gt;ScrollPaneConstants.UPPER_RIGHT_CORNER
     * &lt;/ul&gt;
     *
     * @param s the component identifier
     * @param c the the component to be added
     * @exception IllegalArgumentException if &lt;code&gt;s&lt;/code&gt; is an invalid key
     */
    public void addLayoutComponent(String s, Component c)
    {
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (s.equals(VIEWPORT)) {</span>
<span class="nc" id="L230">            viewport = (JViewport)addSingletonComponent(viewport, c);</span>
        }
<span class="nc bnc" id="L232" title="All 2 branches missed.">        else if (s.equals(VERTICAL_SCROLLBAR)) {</span>
<span class="nc" id="L233">            vsb = (JScrollBar)addSingletonComponent(vsb, c);</span>
        }
<span class="nc bnc" id="L235" title="All 2 branches missed.">        else if (s.equals(HORIZONTAL_SCROLLBAR)) {</span>
<span class="nc" id="L236">            hsb = (JScrollBar)addSingletonComponent(hsb, c);</span>
        }
<span class="nc bnc" id="L238" title="All 2 branches missed.">        else if (s.equals(ROW_HEADER)) {</span>
<span class="nc" id="L239">            rowHead = (JViewport)addSingletonComponent(rowHead, c);</span>
        }
<span class="nc bnc" id="L241" title="All 2 branches missed.">        else if (s.equals(COLUMN_HEADER)) {</span>
<span class="nc" id="L242">            colHead = (JViewport)addSingletonComponent(colHead, c);</span>
        }
<span class="nc bnc" id="L244" title="All 2 branches missed.">        else if (s.equals(LOWER_LEFT_CORNER)) {</span>
<span class="nc" id="L245">            lowerLeft = addSingletonComponent(lowerLeft, c);</span>
        }
<span class="nc bnc" id="L247" title="All 2 branches missed.">        else if (s.equals(LOWER_RIGHT_CORNER)) {</span>
<span class="nc" id="L248">            lowerRight = addSingletonComponent(lowerRight, c);</span>
        }
<span class="nc bnc" id="L250" title="All 2 branches missed.">        else if (s.equals(UPPER_LEFT_CORNER)) {</span>
<span class="nc" id="L251">            upperLeft = addSingletonComponent(upperLeft, c);</span>
        }
<span class="nc bnc" id="L253" title="All 2 branches missed.">        else if (s.equals(UPPER_RIGHT_CORNER)) {</span>
<span class="nc" id="L254">            upperRight = addSingletonComponent(upperRight, c);</span>
        }
        else {
<span class="nc" id="L257">            throw new IllegalArgumentException(&quot;invalid layout key &quot; + s);</span>
        }
<span class="nc" id="L259">    }</span>


    /**
     * Removes the specified component from the layout.
     *
     * @param c the component to remove
     */
    public void removeLayoutComponent(Component c)
    {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (c == viewport) {</span>
<span class="nc" id="L270">            viewport = null;</span>
        }
<span class="nc bnc" id="L272" title="All 2 branches missed.">        else if (c == vsb) {</span>
<span class="nc" id="L273">            vsb = null;</span>
        }
<span class="nc bnc" id="L275" title="All 2 branches missed.">        else if (c == hsb) {</span>
<span class="nc" id="L276">            hsb = null;</span>
        }
<span class="nc bnc" id="L278" title="All 2 branches missed.">        else if (c == rowHead) {</span>
<span class="nc" id="L279">            rowHead = null;</span>
        }
<span class="nc bnc" id="L281" title="All 2 branches missed.">        else if (c == colHead) {</span>
<span class="nc" id="L282">            colHead = null;</span>
        }
<span class="nc bnc" id="L284" title="All 2 branches missed.">        else if (c == lowerLeft) {</span>
<span class="nc" id="L285">            lowerLeft = null;</span>
        }
<span class="nc bnc" id="L287" title="All 2 branches missed.">        else if (c == lowerRight) {</span>
<span class="nc" id="L288">            lowerRight = null;</span>
        }
<span class="nc bnc" id="L290" title="All 2 branches missed.">        else if (c == upperLeft) {</span>
<span class="nc" id="L291">            upperLeft = null;</span>
        }
<span class="nc bnc" id="L293" title="All 2 branches missed.">        else if (c == upperRight) {</span>
<span class="nc" id="L294">            upperRight = null;</span>
        }
<span class="nc" id="L296">    }</span>


    /**
     * Returns the vertical scrollbar-display policy.
     *
     * @return an integer giving the display policy
     * @see #setVerticalScrollBarPolicy
     */
    public int getVerticalScrollBarPolicy() {
<span class="nc" id="L306">        return vsbPolicy;</span>
    }


    /**
     * Sets the vertical scrollbar-display policy. The options
     * are:
     * &lt;ul&gt;
     * &lt;li&gt;ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED
     * &lt;li&gt;ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER
     * &lt;li&gt;ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS
     * &lt;/ul&gt;
     * Note: Applications should use the &lt;code&gt;JScrollPane&lt;/code&gt; version
     * of this method.  It only exists for backwards compatibility
     * with the Swing 1.0.2 (and earlier) versions of this class.
     *
     * @param x an integer giving the display policy
     * @exception IllegalArgumentException if &lt;code&gt;x&lt;/code&gt; is an invalid
     *          vertical scroll bar policy, as listed above
     */
    public void setVerticalScrollBarPolicy(int x) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">        switch (x) {</span>
        case VERTICAL_SCROLLBAR_AS_NEEDED:
        case VERTICAL_SCROLLBAR_NEVER:
        case VERTICAL_SCROLLBAR_ALWAYS:
<span class="nc" id="L331">                vsbPolicy = x;</span>
<span class="nc" id="L332">                break;</span>
        default:
<span class="nc" id="L334">            throw new IllegalArgumentException(&quot;invalid verticalScrollBarPolicy&quot;);</span>
        }
<span class="nc" id="L336">    }</span>


    /**
     * Returns the horizontal scrollbar-display policy.
     *
     * @return an integer giving the display policy
     * @see #setHorizontalScrollBarPolicy
     */
    public int getHorizontalScrollBarPolicy() {
<span class="nc" id="L346">        return hsbPolicy;</span>
    }

    /**
     * Sets the horizontal scrollbar-display policy.
     * The options are:&lt;ul&gt;
     * &lt;li&gt;ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED
     * &lt;li&gt;ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER
     * &lt;li&gt;ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS
     * &lt;/ul&gt;
     * Note: Applications should use the &lt;code&gt;JScrollPane&lt;/code&gt; version
     * of this method.  It only exists for backwards compatibility
     * with the Swing 1.0.2 (and earlier) versions of this class.
     *
     * @param x an int giving the display policy
     * @exception IllegalArgumentException if &lt;code&gt;x&lt;/code&gt; is not a valid
     *          horizontal scrollbar policy, as listed above
     */
    public void setHorizontalScrollBarPolicy(int x) {
<span class="nc bnc" id="L365" title="All 2 branches missed.">        switch (x) {</span>
        case HORIZONTAL_SCROLLBAR_AS_NEEDED:
        case HORIZONTAL_SCROLLBAR_NEVER:
        case HORIZONTAL_SCROLLBAR_ALWAYS:
<span class="nc" id="L369">                hsbPolicy = x;</span>
<span class="nc" id="L370">                break;</span>
        default:
<span class="nc" id="L372">            throw new IllegalArgumentException(&quot;invalid horizontalScrollBarPolicy&quot;);</span>
        }
<span class="nc" id="L374">    }</span>


    /**
     * Returns the &lt;code&gt;JViewport&lt;/code&gt; object that displays the
     * scrollable contents.
     * @return the &lt;code&gt;JViewport&lt;/code&gt; object that displays the scrollable contents
     * @see JScrollPane#getViewport
     */
    public JViewport getViewport() {
<span class="nc" id="L384">        return viewport;</span>
    }


    /**
     * Returns the &lt;code&gt;JScrollBar&lt;/code&gt; object that handles horizontal scrolling.
     * @return the &lt;code&gt;JScrollBar&lt;/code&gt; object that handles horizontal scrolling
     * @see JScrollPane#getHorizontalScrollBar
     */
    public JScrollBar getHorizontalScrollBar() {
<span class="nc" id="L394">        return hsb;</span>
    }

    /**
     * Returns the &lt;code&gt;JScrollBar&lt;/code&gt; object that handles vertical scrolling.
     * @return the &lt;code&gt;JScrollBar&lt;/code&gt; object that handles vertical scrolling
     * @see JScrollPane#getVerticalScrollBar
     */
    public JScrollBar getVerticalScrollBar() {
<span class="nc" id="L403">        return vsb;</span>
    }


    /**
     * Returns the &lt;code&gt;JViewport&lt;/code&gt; object that is the row header.
     * @return the &lt;code&gt;JViewport&lt;/code&gt; object that is the row header
     * @see JScrollPane#getRowHeader
     */
    public JViewport getRowHeader() {
<span class="nc" id="L413">        return rowHead;</span>
    }


    /**
     * Returns the &lt;code&gt;JViewport&lt;/code&gt; object that is the column header.
     * @return the &lt;code&gt;JViewport&lt;/code&gt; object that is the column header
     * @see JScrollPane#getColumnHeader
     */
    public JViewport getColumnHeader() {
<span class="nc" id="L423">        return colHead;</span>
    }


    /**
     * Returns the &lt;code&gt;Component&lt;/code&gt; at the specified corner.
     * @param key the &lt;code&gt;String&lt;/code&gt; specifying the corner
     * @return the &lt;code&gt;Component&lt;/code&gt; at the specified corner, as defined in
     *         {@link ScrollPaneConstants}; if &lt;code&gt;key&lt;/code&gt; is not one of the
     *          four corners, &lt;code&gt;null&lt;/code&gt; is returned
     * @see JScrollPane#getCorner
     */
    public Component getCorner(String key) {
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (key.equals(LOWER_LEFT_CORNER)) {</span>
<span class="nc" id="L437">            return lowerLeft;</span>
        }
<span class="nc bnc" id="L439" title="All 2 branches missed.">        else if (key.equals(LOWER_RIGHT_CORNER)) {</span>
<span class="nc" id="L440">            return lowerRight;</span>
        }
<span class="nc bnc" id="L442" title="All 2 branches missed.">        else if (key.equals(UPPER_LEFT_CORNER)) {</span>
<span class="nc" id="L443">            return upperLeft;</span>
        }
<span class="nc bnc" id="L445" title="All 2 branches missed.">        else if (key.equals(UPPER_RIGHT_CORNER)) {</span>
<span class="nc" id="L446">            return upperRight;</span>
        }
        else {
<span class="nc" id="L449">            return null;</span>
        }
    }


    /**
     * The preferred size of a &lt;code&gt;ScrollPane&lt;/code&gt; is the size of the insets,
     * plus the preferred size of the viewport, plus the preferred size of
     * the visible headers, plus the preferred size of the scrollbars
     * that will appear given the current view and the current
     * scrollbar displayPolicies.
     * &lt;p&gt;Note that the rowHeader is calculated as part of the preferred width
     * and the colHeader is calculated as part of the preferred size.
     *
     * @param parent the &lt;code&gt;Container&lt;/code&gt; that will be laid out
     * @return a &lt;code&gt;Dimension&lt;/code&gt; object specifying the preferred size of the
     *         viewport and any scrollbars
     * @see ViewportLayout
     * @see LayoutManager
     */
    public Dimension preferredLayoutSize(Container parent)
    {
        /* Sync the (now obsolete) policy fields with the
         * JScrollPane.
         */
<span class="nc" id="L474">        JScrollPane scrollPane = (JScrollPane)parent;</span>
<span class="nc" id="L475">        vsbPolicy = scrollPane.getVerticalScrollBarPolicy();</span>
<span class="nc" id="L476">        hsbPolicy = scrollPane.getHorizontalScrollBarPolicy();</span>

<span class="nc" id="L478">        Insets insets = parent.getInsets();</span>
<span class="nc" id="L479">        int prefWidth = insets.left + insets.right;</span>
<span class="nc" id="L480">        int prefHeight = insets.top + insets.bottom;</span>

        /* Note that viewport.getViewSize() is equivalent to
         * viewport.getView().getPreferredSize() modulo a null
         * view or a view whose size was explicitly set.
         */

<span class="nc" id="L487">        Dimension extentSize = null;</span>
<span class="nc" id="L488">        Dimension viewSize = null;</span>
<span class="nc" id="L489">        Component view = null;</span>

<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (viewport != null) {</span>
<span class="nc" id="L492">            extentSize = viewport.getPreferredSize();</span>
<span class="nc" id="L493">            view = viewport.getView();</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L495">                viewSize = view.getPreferredSize();</span>
            } else {
<span class="nc" id="L497">                viewSize = new Dimension(0, 0);</span>
            }
        }

        /* If there's a viewport add its preferredSize.
         */

<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (extentSize != null) {</span>
<span class="nc" id="L505">            prefWidth += extentSize.width;</span>
<span class="nc" id="L506">            prefHeight += extentSize.height;</span>
        }

        /* If there's a JScrollPane.viewportBorder, add its insets.
         */

<span class="nc" id="L512">        Border viewportBorder = scrollPane.getViewportBorder();</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (viewportBorder != null) {</span>
<span class="nc" id="L514">            Insets vpbInsets = viewportBorder.getBorderInsets(parent);</span>
<span class="nc" id="L515">            prefWidth += vpbInsets.left + vpbInsets.right;</span>
<span class="nc" id="L516">            prefHeight += vpbInsets.top + vpbInsets.bottom;</span>
        }

        /* If a header exists and it's visible, factor its
         * preferred size in.
         */

<span class="nc bnc" id="L523" title="All 4 branches missed.">        if ((rowHead != null) &amp;&amp; rowHead.isVisible()) {</span>
<span class="nc" id="L524">            prefWidth += rowHead.getPreferredSize().width;</span>
        }

<span class="nc bnc" id="L527" title="All 4 branches missed.">        if ((colHead != null) &amp;&amp; colHead.isVisible()) {</span>
<span class="nc" id="L528">            prefHeight += colHead.getPreferredSize().height;</span>
        }

        /* If a scrollbar is going to appear, factor its preferred size in.
         * If the scrollbars policy is AS_NEEDED, this can be a little
         * tricky:
         *
         * - If the view is a Scrollable then scrollableTracksViewportWidth
         * and scrollableTracksViewportHeight can be used to effectively
         * disable scrolling (if they're true) in their respective dimensions.
         *
         * - Assuming that a scrollbar hasn't been disabled by the
         * previous constraint, we need to decide if the scrollbar is going
         * to appear to correctly compute the JScrollPanes preferred size.
         * To do this we compare the preferredSize of the viewport (the
         * extentSize) to the preferredSize of the view.  Although we're
         * not responsible for laying out the view we'll assume that the
         * JViewport will always give it its preferredSize.
         */

<span class="nc bnc" id="L548" title="All 4 branches missed.">        if ((vsb != null) &amp;&amp; (vsbPolicy != VERTICAL_SCROLLBAR_NEVER)) {</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            if (vsbPolicy == VERTICAL_SCROLLBAR_ALWAYS) {</span>
<span class="nc" id="L550">                prefWidth += vsb.getPreferredSize().width;</span>
            }
<span class="nc bnc" id="L552" title="All 4 branches missed.">            else if ((viewSize != null) &amp;&amp; (extentSize != null)) {</span>
<span class="nc" id="L553">                boolean canScroll = true;</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                if (view instanceof Scrollable) {</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">                    canScroll = !((Scrollable)view).getScrollableTracksViewportHeight();</span>
                }
<span class="nc bnc" id="L557" title="All 4 branches missed.">                if (canScroll &amp;&amp; (viewSize.height &gt; extentSize.height)) {</span>
<span class="nc" id="L558">                    prefWidth += vsb.getPreferredSize().width;</span>
                }
            }
        }

<span class="nc bnc" id="L563" title="All 4 branches missed.">        if ((hsb != null) &amp;&amp; (hsbPolicy != HORIZONTAL_SCROLLBAR_NEVER)) {</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">            if (hsbPolicy == HORIZONTAL_SCROLLBAR_ALWAYS) {</span>
<span class="nc" id="L565">                prefHeight += hsb.getPreferredSize().height;</span>
            }
<span class="nc bnc" id="L567" title="All 4 branches missed.">            else if ((viewSize != null) &amp;&amp; (extentSize != null)) {</span>
<span class="nc" id="L568">                boolean canScroll = true;</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">                if (view instanceof Scrollable) {</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">                    canScroll = !((Scrollable)view).getScrollableTracksViewportWidth();</span>
                }
<span class="nc bnc" id="L572" title="All 4 branches missed.">                if (canScroll &amp;&amp; (viewSize.width &gt; extentSize.width)) {</span>
<span class="nc" id="L573">                    prefHeight += hsb.getPreferredSize().height;</span>
                }
            }
        }

<span class="nc" id="L578">        return new Dimension(prefWidth, prefHeight);</span>
    }


    /**
     * The minimum size of a &lt;code&gt;ScrollPane&lt;/code&gt; is the size of the insets
     * plus minimum size of the viewport, plus the scrollpane's
     * viewportBorder insets, plus the minimum size
     * of the visible headers, plus the minimum size of the
     * scrollbars whose displayPolicy isn't NEVER.
     *
     * @param parent the &lt;code&gt;Container&lt;/code&gt; that will be laid out
     * @return a &lt;code&gt;Dimension&lt;/code&gt; object specifying the minimum size
     */
    public Dimension minimumLayoutSize(Container parent)
    {
        /* Sync the (now obsolete) policy fields with the
         * JScrollPane.
         */
<span class="nc" id="L597">        JScrollPane scrollPane = (JScrollPane)parent;</span>
<span class="nc" id="L598">        vsbPolicy = scrollPane.getVerticalScrollBarPolicy();</span>
<span class="nc" id="L599">        hsbPolicy = scrollPane.getHorizontalScrollBarPolicy();</span>

<span class="nc" id="L601">        Insets insets = parent.getInsets();</span>
<span class="nc" id="L602">        int minWidth = insets.left + insets.right;</span>
<span class="nc" id="L603">        int minHeight = insets.top + insets.bottom;</span>

        /* If there's a viewport add its minimumSize.
         */

<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (viewport != null) {</span>
<span class="nc" id="L609">            Dimension size = viewport.getMinimumSize();</span>
<span class="nc" id="L610">            minWidth += size.width;</span>
<span class="nc" id="L611">            minHeight += size.height;</span>
        }

        /* If there's a JScrollPane.viewportBorder, add its insets.
         */

<span class="nc" id="L617">        Border viewportBorder = scrollPane.getViewportBorder();</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">        if (viewportBorder != null) {</span>
<span class="nc" id="L619">            Insets vpbInsets = viewportBorder.getBorderInsets(parent);</span>
<span class="nc" id="L620">            minWidth += vpbInsets.left + vpbInsets.right;</span>
<span class="nc" id="L621">            minHeight += vpbInsets.top + vpbInsets.bottom;</span>
        }

        /* If a header exists and it's visible, factor its
         * minimum size in.
         */

<span class="nc bnc" id="L628" title="All 4 branches missed.">        if ((rowHead != null) &amp;&amp; rowHead.isVisible()) {</span>
<span class="nc" id="L629">            Dimension size = rowHead.getMinimumSize();</span>
<span class="nc" id="L630">            minWidth += size.width;</span>
<span class="nc" id="L631">            minHeight = Math.max(minHeight, size.height);</span>
        }

<span class="nc bnc" id="L634" title="All 4 branches missed.">        if ((colHead != null) &amp;&amp; colHead.isVisible()) {</span>
<span class="nc" id="L635">            Dimension size = colHead.getMinimumSize();</span>
<span class="nc" id="L636">            minWidth = Math.max(minWidth, size.width);</span>
<span class="nc" id="L637">            minHeight += size.height;</span>
        }

        /* If a scrollbar might appear, factor its minimum
         * size in.
         */

<span class="nc bnc" id="L644" title="All 4 branches missed.">        if ((vsb != null) &amp;&amp; (vsbPolicy != VERTICAL_SCROLLBAR_NEVER)) {</span>
<span class="nc" id="L645">            Dimension size = vsb.getMinimumSize();</span>
<span class="nc" id="L646">            minWidth += size.width;</span>
<span class="nc" id="L647">            minHeight = Math.max(minHeight, size.height);</span>
        }

<span class="nc bnc" id="L650" title="All 4 branches missed.">        if ((hsb != null) &amp;&amp; (hsbPolicy != HORIZONTAL_SCROLLBAR_NEVER)) {</span>
<span class="nc" id="L651">            Dimension size = hsb.getMinimumSize();</span>
<span class="nc" id="L652">            minWidth = Math.max(minWidth, size.width);</span>
<span class="nc" id="L653">            minHeight += size.height;</span>
        }

<span class="nc" id="L656">        return new Dimension(minWidth, minHeight);</span>
    }


    /**
     * Lays out the scrollpane. The positioning of components depends on
     * the following constraints:
     * &lt;ul&gt;
     * &lt;li&gt; The row header, if present and visible, gets its preferred
     * width and the viewport's height.
     *
     * &lt;li&gt; The column header, if present and visible, gets its preferred
     * height and the viewport's width.
     *
     * &lt;li&gt; If a vertical scrollbar is needed, i.e. if the viewport's extent
     * height is smaller than its view height or if the &lt;code&gt;displayPolicy&lt;/code&gt;
     * is ALWAYS, it's treated like the row header with respect to its
     * dimensions and is made visible.
     *
     * &lt;li&gt; If a horizontal scrollbar is needed, it is treated like the
     * column header (see the paragraph above regarding the vertical scrollbar).
     *
     * &lt;li&gt; If the scrollpane has a non-&lt;code&gt;null&lt;/code&gt;
     * &lt;code&gt;viewportBorder&lt;/code&gt;, then space is allocated for that.
     *
     * &lt;li&gt; The viewport gets the space available after accounting for
     * the previous constraints.
     *
     * &lt;li&gt; The corner components, if provided, are aligned with the
     * ends of the scrollbars and headers. If there is a vertical
     * scrollbar, the right corners appear; if there is a horizontal
     * scrollbar, the lower corners appear; a row header gets left
     * corners, and a column header gets upper corners.
     * &lt;/ul&gt;
     *
     * @param parent the &lt;code&gt;Container&lt;/code&gt; to lay out
     */
    public void layoutContainer(Container parent)
    {
        /* Sync the (now obsolete) policy fields with the
         * JScrollPane.
         */
<span class="nc" id="L698">        JScrollPane scrollPane = (JScrollPane)parent;</span>
<span class="nc" id="L699">        vsbPolicy = scrollPane.getVerticalScrollBarPolicy();</span>
<span class="nc" id="L700">        hsbPolicy = scrollPane.getHorizontalScrollBarPolicy();</span>

<span class="nc" id="L702">        Rectangle availR = scrollPane.getBounds();</span>
<span class="nc" id="L703">        availR.x = availR.y = 0;</span>

<span class="nc" id="L705">        Insets insets = parent.getInsets();</span>
<span class="nc" id="L706">        availR.x = insets.left;</span>
<span class="nc" id="L707">        availR.y = insets.top;</span>
<span class="nc" id="L708">        availR.width -= insets.left + insets.right;</span>
<span class="nc" id="L709">        availR.height -= insets.top + insets.bottom;</span>

        /* Get the scrollPane's orientation.
         */
<span class="nc" id="L713">        boolean leftToRight = SwingUtilities.isLeftToRight(scrollPane);</span>

        /* If there's a visible column header remove the space it
         * needs from the top of availR.  The column header is treated
         * as if it were fixed height, arbitrary width.
         */

<span class="nc" id="L720">        Rectangle colHeadR = new Rectangle(0, availR.y, 0, 0);</span>

<span class="nc bnc" id="L722" title="All 4 branches missed.">        if ((colHead != null) &amp;&amp; (colHead.isVisible())) {</span>
<span class="nc" id="L723">            int colHeadHeight = Math.min(availR.height,</span>
<span class="nc" id="L724">                                         colHead.getPreferredSize().height);</span>
<span class="nc" id="L725">            colHeadR.height = colHeadHeight;</span>
<span class="nc" id="L726">            availR.y += colHeadHeight;</span>
<span class="nc" id="L727">            availR.height -= colHeadHeight;</span>
        }

        /* If there's a visible row header remove the space it needs
         * from the left or right of availR.  The row header is treated
         * as if it were fixed width, arbitrary height.
         */

<span class="nc" id="L735">        Rectangle rowHeadR = new Rectangle(0, 0, 0, 0);</span>

<span class="nc bnc" id="L737" title="All 4 branches missed.">        if ((rowHead != null) &amp;&amp; (rowHead.isVisible())) {</span>
<span class="nc" id="L738">            int rowHeadWidth = Math.min(availR.width,</span>
<span class="nc" id="L739">                                        rowHead.getPreferredSize().width);</span>
<span class="nc" id="L740">            rowHeadR.width = rowHeadWidth;</span>
<span class="nc" id="L741">            availR.width -= rowHeadWidth;</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            if ( leftToRight ) {</span>
<span class="nc" id="L743">                rowHeadR.x = availR.x;</span>
<span class="nc" id="L744">                availR.x += rowHeadWidth;</span>
            } else {
<span class="nc" id="L746">                rowHeadR.x = availR.x + availR.width;</span>
            }
        }

        /* If there's a JScrollPane.viewportBorder, remove the
         * space it occupies for availR.
         */

<span class="nc" id="L754">        Border viewportBorder = scrollPane.getViewportBorder();</span>
        Insets vpbInsets;
<span class="nc bnc" id="L756" title="All 2 branches missed.">        if (viewportBorder != null) {</span>
<span class="nc" id="L757">            vpbInsets = viewportBorder.getBorderInsets(parent);</span>
<span class="nc" id="L758">            availR.x += vpbInsets.left;</span>
<span class="nc" id="L759">            availR.y += vpbInsets.top;</span>
<span class="nc" id="L760">            availR.width -= vpbInsets.left + vpbInsets.right;</span>
<span class="nc" id="L761">            availR.height -= vpbInsets.top + vpbInsets.bottom;</span>
        }
        else {
<span class="nc" id="L764">            vpbInsets = new Insets(0,0,0,0);</span>
        }


        /* At this point availR is the space available for the viewport
         * and scrollbars. rowHeadR is correct except for its height and y
         * and colHeadR is correct except for its width and x.  Once we're
         * through computing the dimensions  of these three parts we can
         * go back and set the dimensions of rowHeadR.height, rowHeadR.y,
         * colHeadR.width, colHeadR.x and the bounds for the corners.
         *
         * We'll decide about putting up scrollbars by comparing the
         * viewport views preferred size with the viewports extent
         * size (generally just its size).  Using the preferredSize is
         * reasonable because layout proceeds top down - so we expect
         * the viewport to be laid out next.  And we assume that the
         * viewports layout manager will give the view it's preferred
         * size.  One exception to this is when the view implements
         * Scrollable and Scrollable.getViewTracksViewport{Width,Height}
         * methods return true.  If the view is tracking the viewports
         * width we don't bother with a horizontal scrollbar, similarly
         * if view.getViewTracksViewport(Height) is true we don't bother
         * with a vertical scrollbar.
         */

<span class="nc bnc" id="L789" title="All 2 branches missed.">        Component view = (viewport != null) ? viewport.getView() : null;</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">        Dimension viewPrefSize =</span>
<span class="nc" id="L791">            (view != null) ? view.getPreferredSize()</span>
                           : new Dimension(0,0);

<span class="nc bnc" id="L794" title="All 2 branches missed.">        Dimension extentSize =</span>
<span class="nc" id="L795">            (viewport != null) ? viewport.toViewCoordinates(availR.getSize())</span>
                               : new Dimension(0,0);

<span class="nc" id="L798">        boolean viewTracksViewportWidth = false;</span>
<span class="nc" id="L799">        boolean viewTracksViewportHeight = false;</span>
<span class="nc bnc" id="L800" title="All 4 branches missed.">        boolean isEmpty = (availR.width &lt; 0 || availR.height &lt; 0);</span>
        Scrollable sv;
        // Don't bother checking the Scrollable methods if there is no room
        // for the viewport, we aren't going to show any scrollbars in this
        // case anyway.
<span class="nc bnc" id="L805" title="All 4 branches missed.">        if (!isEmpty &amp;&amp; view instanceof Scrollable) {</span>
<span class="nc" id="L806">            sv = (Scrollable)view;</span>
<span class="nc" id="L807">            viewTracksViewportWidth = sv.getScrollableTracksViewportWidth();</span>
<span class="nc" id="L808">            viewTracksViewportHeight = sv.getScrollableTracksViewportHeight();</span>
        }
        else {
<span class="nc" id="L811">            sv = null;</span>
        }

        /* If there's a vertical scrollbar and we need one, allocate
         * space for it (we'll make it visible later). A vertical
         * scrollbar is considered to be fixed width, arbitrary height.
         */

<span class="nc" id="L819">        Rectangle vsbR = new Rectangle(0, availR.y - vpbInsets.top, 0, 0);</span>

        boolean vsbNeeded;
<span class="nc bnc" id="L822" title="All 2 branches missed.">        if (isEmpty) {</span>
<span class="nc" id="L823">            vsbNeeded = false;</span>
        }
<span class="nc bnc" id="L825" title="All 2 branches missed.">        else if (vsbPolicy == VERTICAL_SCROLLBAR_ALWAYS) {</span>
<span class="nc" id="L826">            vsbNeeded = true;</span>
        }
<span class="nc bnc" id="L828" title="All 2 branches missed.">        else if (vsbPolicy == VERTICAL_SCROLLBAR_NEVER) {</span>
<span class="nc" id="L829">            vsbNeeded = false;</span>
        }
        else {  // vsbPolicy == VERTICAL_SCROLLBAR_AS_NEEDED
<span class="nc bnc" id="L832" title="All 4 branches missed.">            vsbNeeded = !viewTracksViewportHeight &amp;&amp; (viewPrefSize.height &gt; extentSize.height);</span>
        }


<span class="nc bnc" id="L836" title="All 4 branches missed.">        if ((vsb != null) &amp;&amp; vsbNeeded) {</span>
<span class="nc" id="L837">            adjustForVSB(true, availR, vsbR, vpbInsets, leftToRight);</span>
<span class="nc" id="L838">            extentSize = viewport.toViewCoordinates(availR.getSize());</span>
        }

        /* If there's a horizontal scrollbar and we need one, allocate
         * space for it (we'll make it visible later). A horizontal
         * scrollbar is considered to be fixed height, arbitrary width.
         */

<span class="nc" id="L846">        Rectangle hsbR = new Rectangle(availR.x - vpbInsets.left, 0, 0, 0);</span>
        boolean hsbNeeded;
<span class="nc bnc" id="L848" title="All 2 branches missed.">        if (isEmpty) {</span>
<span class="nc" id="L849">            hsbNeeded = false;</span>
        }
<span class="nc bnc" id="L851" title="All 2 branches missed.">        else if (hsbPolicy == HORIZONTAL_SCROLLBAR_ALWAYS) {</span>
<span class="nc" id="L852">            hsbNeeded = true;</span>
        }
<span class="nc bnc" id="L854" title="All 2 branches missed.">        else if (hsbPolicy == HORIZONTAL_SCROLLBAR_NEVER) {</span>
<span class="nc" id="L855">            hsbNeeded = false;</span>
        }
        else {  // hsbPolicy == HORIZONTAL_SCROLLBAR_AS_NEEDED
<span class="nc bnc" id="L858" title="All 4 branches missed.">            hsbNeeded = !viewTracksViewportWidth &amp;&amp; (viewPrefSize.width &gt; extentSize.width);</span>
        }

<span class="nc bnc" id="L861" title="All 4 branches missed.">        if ((hsb != null) &amp;&amp; hsbNeeded) {</span>
<span class="nc" id="L862">            adjustForHSB(true, availR, hsbR, vpbInsets);</span>

            /* If we added the horizontal scrollbar then we've implicitly
             * reduced  the vertical space available to the viewport.
             * As a consequence we may have to add the vertical scrollbar,
             * if that hasn't been done so already.  Of course we
             * don't bother with any of this if the vsbPolicy is NEVER.
             */
<span class="nc bnc" id="L870" title="All 6 branches missed.">            if ((vsb != null) &amp;&amp; !vsbNeeded &amp;&amp;</span>
                (vsbPolicy != VERTICAL_SCROLLBAR_NEVER)) {

<span class="nc" id="L873">                extentSize = viewport.toViewCoordinates(availR.getSize());</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">                vsbNeeded = viewPrefSize.height &gt; extentSize.height;</span>

<span class="nc bnc" id="L876" title="All 2 branches missed.">                if (vsbNeeded) {</span>
<span class="nc" id="L877">                    adjustForVSB(true, availR, vsbR, vpbInsets, leftToRight);</span>
                }
            }
        }

        /* Set the size of the viewport first, and then recheck the Scrollable
         * methods. Some components base their return values for the Scrollable
         * methods on the size of the Viewport, so that if we don't
         * ask after resetting the bounds we may have gotten the wrong
         * answer.
         */

<span class="nc bnc" id="L889" title="All 2 branches missed.">        if (viewport != null) {</span>
<span class="nc" id="L890">            viewport.setBounds(availR);</span>

<span class="nc bnc" id="L892" title="All 2 branches missed.">            if (sv != null) {</span>
<span class="nc" id="L893">                extentSize = viewport.toViewCoordinates(availR.getSize());</span>

<span class="nc" id="L895">                boolean oldHSBNeeded = hsbNeeded;</span>
<span class="nc" id="L896">                boolean oldVSBNeeded = vsbNeeded;</span>
<span class="nc" id="L897">                viewTracksViewportWidth = sv.</span>
<span class="nc" id="L898">                                          getScrollableTracksViewportWidth();</span>
<span class="nc" id="L899">                viewTracksViewportHeight = sv.</span>
<span class="nc" id="L900">                                          getScrollableTracksViewportHeight();</span>
<span class="nc bnc" id="L901" title="All 4 branches missed.">                if (vsb != null &amp;&amp; vsbPolicy == VERTICAL_SCROLLBAR_AS_NEEDED) {</span>
<span class="nc bnc" id="L902" title="All 4 branches missed.">                    boolean newVSBNeeded = !viewTracksViewportHeight &amp;&amp;</span>
                                     (viewPrefSize.height &gt; extentSize.height);
<span class="nc bnc" id="L904" title="All 2 branches missed.">                    if (newVSBNeeded != vsbNeeded) {</span>
<span class="nc" id="L905">                        vsbNeeded = newVSBNeeded;</span>
<span class="nc" id="L906">                        adjustForVSB(vsbNeeded, availR, vsbR, vpbInsets,</span>
                                     leftToRight);
<span class="nc" id="L908">                        extentSize = viewport.toViewCoordinates</span>
<span class="nc" id="L909">                                              (availR.getSize());</span>
                    }
                }
<span class="nc bnc" id="L912" title="All 4 branches missed.">                if (hsb != null &amp;&amp; hsbPolicy ==HORIZONTAL_SCROLLBAR_AS_NEEDED){</span>
<span class="nc bnc" id="L913" title="All 4 branches missed.">                    boolean newHSBbNeeded = !viewTracksViewportWidth &amp;&amp;</span>
                                       (viewPrefSize.width &gt; extentSize.width);
<span class="nc bnc" id="L915" title="All 2 branches missed.">                    if (newHSBbNeeded != hsbNeeded) {</span>
<span class="nc" id="L916">                        hsbNeeded = newHSBbNeeded;</span>
<span class="nc" id="L917">                        adjustForHSB(hsbNeeded, availR, hsbR, vpbInsets);</span>
<span class="nc bnc" id="L918" title="All 6 branches missed.">                        if ((vsb != null) &amp;&amp; !vsbNeeded &amp;&amp;</span>
                            (vsbPolicy != VERTICAL_SCROLLBAR_NEVER)) {

<span class="nc" id="L921">                            extentSize = viewport.toViewCoordinates</span>
<span class="nc" id="L922">                                         (availR.getSize());</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">                            vsbNeeded = viewPrefSize.height &gt;</span>
                                        extentSize.height;

<span class="nc bnc" id="L926" title="All 2 branches missed.">                            if (vsbNeeded) {</span>
<span class="nc" id="L927">                                adjustForVSB(true, availR, vsbR, vpbInsets,</span>
                                             leftToRight);
                            }
                        }
                    }
                }
<span class="nc bnc" id="L933" title="All 4 branches missed.">                if (oldHSBNeeded != hsbNeeded ||</span>
                    oldVSBNeeded != vsbNeeded) {
<span class="nc" id="L935">                    viewport.setBounds(availR);</span>
                    // You could argue that we should recheck the
                    // Scrollable methods again until they stop changing,
                    // but they might never stop changing, so we stop here
                    // and don't do any additional checks.
                }
            }
        }

        /* We now have the final size of the viewport: availR.
         * Now fixup the header and scrollbar widths/heights.
         */
<span class="nc" id="L947">        vsbR.height = availR.height + vpbInsets.top + vpbInsets.bottom;</span>
<span class="nc" id="L948">        hsbR.width = availR.width + vpbInsets.left + vpbInsets.right;</span>
<span class="nc" id="L949">        rowHeadR.height = availR.height + vpbInsets.top + vpbInsets.bottom;</span>
<span class="nc" id="L950">        rowHeadR.y = availR.y - vpbInsets.top;</span>
<span class="nc" id="L951">        colHeadR.width = availR.width + vpbInsets.left + vpbInsets.right;</span>
<span class="nc" id="L952">        colHeadR.x = availR.x - vpbInsets.left;</span>

        /* Set the bounds of the remaining components.  The scrollbars
         * are made invisible if they're not needed.
         */

<span class="nc bnc" id="L958" title="All 2 branches missed.">        if (rowHead != null) {</span>
<span class="nc" id="L959">            rowHead.setBounds(rowHeadR);</span>
        }

<span class="nc bnc" id="L962" title="All 2 branches missed.">        if (colHead != null) {</span>
<span class="nc" id="L963">            colHead.setBounds(colHeadR);</span>
        }

<span class="nc bnc" id="L966" title="All 2 branches missed.">        if (vsb != null) {</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">            if (vsbNeeded) {</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">                if (colHead != null &amp;&amp;</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">                    UIManager.getBoolean(&quot;ScrollPane.fillUpperCorner&quot;))</span>
                {
<span class="nc bnc" id="L971" title="All 8 branches missed.">                    if ((leftToRight &amp;&amp; upperRight == null) ||</span>
                        (!leftToRight &amp;&amp; upperLeft == null))
                    {
                        // This is used primarily for GTK L&amp;F, which needs to
                        // extend the vertical scrollbar to fill the upper
                        // corner near the column header.  Note that we skip
                        // this step (and use the default behavior) if the
                        // user has set a custom corner component.
<span class="nc" id="L979">                        vsbR.y = colHeadR.y;</span>
<span class="nc" id="L980">                        vsbR.height += colHeadR.height;</span>
                    }
                }
<span class="nc" id="L983">                vsb.setVisible(true);</span>
<span class="nc" id="L984">                vsb.setBounds(vsbR);</span>
            }
            else {
<span class="nc" id="L987">                vsb.setVisible(false);</span>
            }
        }

<span class="nc bnc" id="L991" title="All 2 branches missed.">        if (hsb != null) {</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">            if (hsbNeeded) {</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">                if (rowHead != null &amp;&amp;</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">                    UIManager.getBoolean(&quot;ScrollPane.fillLowerCorner&quot;))</span>
                {
<span class="nc bnc" id="L996" title="All 8 branches missed.">                    if ((leftToRight &amp;&amp; lowerLeft == null) ||</span>
                        (!leftToRight &amp;&amp; lowerRight == null))
                    {
                        // This is used primarily for GTK L&amp;F, which needs to
                        // extend the horizontal scrollbar to fill the lower
                        // corner near the row header.  Note that we skip
                        // this step (and use the default behavior) if the
                        // user has set a custom corner component.
<span class="nc bnc" id="L1004" title="All 2 branches missed.">                        if (leftToRight) {</span>
<span class="nc" id="L1005">                            hsbR.x = rowHeadR.x;</span>
                        }
<span class="nc" id="L1007">                        hsbR.width += rowHeadR.width;</span>
                    }
                }
<span class="nc" id="L1010">                hsb.setVisible(true);</span>
<span class="nc" id="L1011">                hsb.setBounds(hsbR);</span>
            }
            else {
<span class="nc" id="L1014">                hsb.setVisible(false);</span>
            }
        }

<span class="nc bnc" id="L1018" title="All 2 branches missed.">        if (lowerLeft != null) {</span>
<span class="nc bnc" id="L1019" title="All 4 branches missed.">            lowerLeft.setBounds(leftToRight ? rowHeadR.x : vsbR.x,</span>
                                hsbR.y,
                                leftToRight ? rowHeadR.width : vsbR.width,
                                hsbR.height);
        }

<span class="nc bnc" id="L1025" title="All 2 branches missed.">        if (lowerRight != null) {</span>
<span class="nc bnc" id="L1026" title="All 4 branches missed.">            lowerRight.setBounds(leftToRight ? vsbR.x : rowHeadR.x,</span>
                                 hsbR.y,
                                 leftToRight ? vsbR.width : rowHeadR.width,
                                 hsbR.height);
        }

<span class="nc bnc" id="L1032" title="All 2 branches missed.">        if (upperLeft != null) {</span>
<span class="nc bnc" id="L1033" title="All 4 branches missed.">            upperLeft.setBounds(leftToRight ? rowHeadR.x : vsbR.x,</span>
                                colHeadR.y,
                                leftToRight ? rowHeadR.width : vsbR.width,
                                colHeadR.height);
        }

<span class="nc bnc" id="L1039" title="All 2 branches missed.">        if (upperRight != null) {</span>
<span class="nc bnc" id="L1040" title="All 4 branches missed.">            upperRight.setBounds(leftToRight ? vsbR.x : rowHeadR.x,</span>
                                 colHeadR.y,
                                 leftToRight ? vsbR.width : rowHeadR.width,
                                 colHeadR.height);
        }
<span class="nc" id="L1045">    }</span>

    /**
     * Adjusts the &lt;code&gt;Rectangle&lt;/code&gt; &lt;code&gt;available&lt;/code&gt; based on if
     * the vertical scrollbar is needed (&lt;code&gt;wantsVSB&lt;/code&gt;).
     * The location of the vsb is updated in &lt;code&gt;vsbR&lt;/code&gt;, and
     * the viewport border insets (&lt;code&gt;vpbInsets&lt;/code&gt;) are used to offset
     * the vsb. This is only called when &lt;code&gt;wantsVSB&lt;/code&gt; has
     * changed, eg you shouldn't invoke adjustForVSB(true) twice.
     */
    private void adjustForVSB(boolean wantsVSB, Rectangle available,
                              Rectangle vsbR, Insets vpbInsets,
                              boolean leftToRight) {
<span class="nc" id="L1058">        int oldWidth = vsbR.width;</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">        if (wantsVSB) {</span>
<span class="nc" id="L1060">            int vsbWidth = Math.max(0, Math.min(vsb.getPreferredSize().width,</span>
                                                available.width));

<span class="nc" id="L1063">            available.width -= vsbWidth;</span>
<span class="nc" id="L1064">            vsbR.width = vsbWidth;</span>

<span class="nc bnc" id="L1066" title="All 2 branches missed.">            if( leftToRight ) {</span>
<span class="nc" id="L1067">                vsbR.x = available.x + available.width + vpbInsets.right;</span>
            } else {
<span class="nc" id="L1069">                vsbR.x = available.x - vpbInsets.left;</span>
<span class="nc" id="L1070">                available.x += vsbWidth;</span>
            }
<span class="nc" id="L1072">        }</span>
        else {
<span class="nc" id="L1074">            available.width += oldWidth;</span>
        }
<span class="nc" id="L1076">    }</span>

    /**
     * Adjusts the &lt;code&gt;Rectangle&lt;/code&gt; &lt;code&gt;available&lt;/code&gt; based on if
     * the horizontal scrollbar is needed (&lt;code&gt;wantsHSB&lt;/code&gt;).
     * The location of the hsb is updated in &lt;code&gt;hsbR&lt;/code&gt;, and
     * the viewport border insets (&lt;code&gt;vpbInsets&lt;/code&gt;) are used to offset
     * the hsb.  This is only called when &lt;code&gt;wantsHSB&lt;/code&gt; has
     * changed, eg you shouldn't invoked adjustForHSB(true) twice.
     */
    private void adjustForHSB(boolean wantsHSB, Rectangle available,
                              Rectangle hsbR, Insets vpbInsets) {
<span class="nc" id="L1088">        int oldHeight = hsbR.height;</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (wantsHSB) {</span>
<span class="nc" id="L1090">            int hsbHeight = Math.max(0, Math.min(available.height,</span>
<span class="nc" id="L1091">                                              hsb.getPreferredSize().height));</span>

<span class="nc" id="L1093">            available.height -= hsbHeight;</span>
<span class="nc" id="L1094">            hsbR.y = available.y + available.height + vpbInsets.bottom;</span>
<span class="nc" id="L1095">            hsbR.height = hsbHeight;</span>
<span class="nc" id="L1096">        }</span>
        else {
<span class="nc" id="L1098">            available.height += oldHeight;</span>
        }
<span class="nc" id="L1100">    }</span>



    /**
     * Returns the bounds of the border around the specified scroll pane's
     * viewport.
     *
     * @return the size and position of the viewport border
     * @deprecated As of JDK version Swing1.1
     *    replaced by &lt;code&gt;JScrollPane.getViewportBorderBounds()&lt;/code&gt;.
     */
    @Deprecated
    public Rectangle getViewportBorderBounds(JScrollPane scrollpane) {
<span class="nc" id="L1114">        return scrollpane.getViewportBorderBounds();</span>
    }

    /**
     * The UI resource version of &lt;code&gt;ScrollPaneLayout&lt;/code&gt;.
     */
<span class="nc" id="L1120">    public static class UIResource extends ScrollPaneLayout implements javax.swing.plaf.UIResource {}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>