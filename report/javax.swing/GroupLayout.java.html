<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GroupLayout.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">GroupLayout.java</span></div><h1>GroupLayout.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.LayoutManager2;
import java.util.*;
import static java.awt.Component.BaselineResizeBehavior;
import static javax.swing.LayoutStyle.ComponentPlacement;
import static javax.swing.SwingConstants.HORIZONTAL;
import static javax.swing.SwingConstants.VERTICAL;

/**
 * {@code GroupLayout} is a {@code LayoutManager} that hierarchically
 * groups components in order to position them in a {@code Container}.
 * {@code GroupLayout} is intended for use by builders, but may be
 * hand-coded as well.
 * Grouping is done by instances of the {@link Group Group} class. {@code
 * GroupLayout} supports two types of groups. A sequential group
 * positions its child elements sequentially, one after another. A
 * parallel group aligns its child elements in one of four ways.
 * &lt;p&gt;
 * Each group may contain any number of elements, where an element is
 * a {@code Group}, {@code Component}, or gap. A gap can be thought
 * of as an invisible component with a minimum, preferred and maximum
 * size. In addition {@code GroupLayout} supports a preferred gap,
 * whose value comes from {@code LayoutStyle}.
 * &lt;p&gt;
 * Elements are similar to a spring. Each element has a range as
 * specified by a minimum, preferred and maximum.  Gaps have either a
 * developer-specified range, or a range determined by {@code
 * LayoutStyle}. The range for {@code Component}s is determined from
 * the {@code Component}'s {@code getMinimumSize}, {@code
 * getPreferredSize} and {@code getMaximumSize} methods. In addition,
 * when adding {@code Component}s you may specify a particular range
 * to use instead of that from the component. The range for a {@code
 * Group} is determined by the type of group. A {@code ParallelGroup}'s
 * range is the maximum of the ranges of its elements. A {@code
 * SequentialGroup}'s range is the sum of the ranges of its elements.
 * &lt;p&gt;
 * {@code GroupLayout} treats each axis independently.  That is, there
 * is a group representing the horizontal axis, and a group
 * representing the vertical axis.  The horizontal group is
 * responsible for determining the minimum, preferred and maximum size
 * along the horizontal axis as well as setting the x and width of the
 * components contained in it. The vertical group is responsible for
 * determining the minimum, preferred and maximum size along the
 * vertical axis as well as setting the y and height of the
 * components contained in it. Each {@code Component} must exist in both
 * a horizontal and vertical group, otherwise an {@code IllegalStateException}
 * is thrown during layout, or when the minimum, preferred or
 * maximum size is requested.
 * &lt;p&gt;
 * The following diagram shows a sequential group along the horizontal
 * axis. The sequential group contains three components. A parallel group
 * was used along the vertical axis.
 * &lt;p style=&quot;text-align:center&quot;&gt;
 * &lt;img src=&quot;doc-files/groupLayout.1.gif&quot; alt=&quot;Sequential group along the horizontal axis in three components&quot;&gt;
 * &lt;p&gt;
 * To reinforce that each axis is treated independently the diagram shows
 * the range of each group and element along each axis. The
 * range of each component has been projected onto the axes,
 * and the groups are rendered in blue (horizontal) and red (vertical).
 * For readability there is a gap between each of the elements in the
 * sequential group.
 * &lt;p&gt;
 * The sequential group along the horizontal axis is rendered as a solid
 * blue line. Notice the sequential group is the sum of the children elements
 * it contains.
 * &lt;p&gt;
 * Along the vertical axis the parallel group is the maximum of the height
 * of each of the components. As all three components have the same height,
 * the parallel group has the same height.
 * &lt;p&gt;
 * The following diagram shows the same three components, but with the
 * parallel group along the horizontal axis and the sequential group along
 * the vertical axis.
 * &lt;p&gt;
 * &lt;p style=&quot;text-align:center&quot;&gt;
 * &lt;img src=&quot;doc-files/groupLayout.2.gif&quot; alt=&quot;Sequential group along the vertical axis in three components&quot;&gt;
 * &lt;p&gt;
 * As {@code c1} is the largest of the three components, the parallel
 * group is sized to {@code c1}. As {@code c2} and {@code c3} are smaller
 * than {@code c1} they are aligned based on the alignment specified
 * for the component (if specified) or the default alignment of the
 * parallel group. In the diagram {@code c2} and {@code c3} were created
 * with an alignment of {@code LEADING}. If the component orientation were
 * right-to-left then {@code c2} and {@code c3} would be positioned on
 * the opposite side.
 * &lt;p&gt;
 * The following diagram shows a sequential group along both the horizontal
 * and vertical axis.
 * &lt;p style=&quot;text-align:center&quot;&gt;
 * &lt;img src=&quot;doc-files/groupLayout.3.gif&quot; alt=&quot;Sequential group along both the horizontal and vertical axis in three components&quot;&gt;
 * &lt;p&gt;
 * {@code GroupLayout} provides the ability to insert gaps between
 * {@code Component}s. The size of the gap is determined by an
 * instance of {@code LayoutStyle}. This may be turned on using the
 * {@code setAutoCreateGaps} method.  Similarly, you may use
 * the {@code setAutoCreateContainerGaps} method to insert gaps
 * between components that touch the edge of the parent container and the
 * container.
 * &lt;p&gt;
 * The following builds a panel consisting of two labels in
 * one column, followed by two textfields in the next column:
 * &lt;pre&gt;
 *   JComponent panel = ...;
 *   GroupLayout layout = new GroupLayout(panel);
 *   panel.setLayout(layout);
 *
 *   // Turn on automatically adding gaps between components
 *   layout.setAutoCreateGaps(true);
 *
 *   // Turn on automatically creating gaps between components that touch
 *   // the edge of the container and the container.
 *   layout.setAutoCreateContainerGaps(true);
 *
 *   // Create a sequential group for the horizontal axis.
 *
 *   GroupLayout.SequentialGroup hGroup = layout.createSequentialGroup();
 *
 *   // The sequential group in turn contains two parallel groups.
 *   // One parallel group contains the labels, the other the text fields.
 *   // Putting the labels in a parallel group along the horizontal axis
 *   // positions them at the same x location.
 *   //
 *   // Variable indentation is used to reinforce the level of grouping.
 *   hGroup.addGroup(layout.createParallelGroup().
 *            addComponent(label1).addComponent(label2));
 *   hGroup.addGroup(layout.createParallelGroup().
 *            addComponent(tf1).addComponent(tf2));
 *   layout.setHorizontalGroup(hGroup);
 *
 *   // Create a sequential group for the vertical axis.
 *   GroupLayout.SequentialGroup vGroup = layout.createSequentialGroup();
 *
 *   // The sequential group contains two parallel groups that align
 *   // the contents along the baseline. The first parallel group contains
 *   // the first label and text field, and the second parallel group contains
 *   // the second label and text field. By using a sequential group
 *   // the labels and text fields are positioned vertically after one another.
 *   vGroup.addGroup(layout.createParallelGroup(Alignment.BASELINE).
 *            addComponent(label1).addComponent(tf1));
 *   vGroup.addGroup(layout.createParallelGroup(Alignment.BASELINE).
 *            addComponent(label2).addComponent(tf2));
 *   layout.setVerticalGroup(vGroup);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * When run the following is produced.
 * &lt;p style=&quot;text-align:center&quot;&gt;
 * &lt;img src=&quot;doc-files/groupLayout.example.png&quot; alt=&quot;Produced horizontal/vertical form&quot;&gt;
 * &lt;p&gt;
 * This layout consists of the following.
 * &lt;ul&gt;&lt;li&gt;The horizontal axis consists of a sequential group containing two
 *         parallel groups.  The first parallel group contains the labels,
 *         and the second parallel group contains the text fields.
 *     &lt;li&gt;The vertical axis consists of a sequential group
 *         containing two parallel groups.  The parallel groups are configured
 *         to align their components along the baseline. The first parallel
 *         group contains the first label and first text field, and
 *         the second group consists of the second label and second
 *         text field.
 * &lt;/ul&gt;
 * There are a couple of things to notice in this code:
 * &lt;ul&gt;
 *   &lt;li&gt;You need not explicitly add the components to the container; this
 *       is indirectly done by using one of the {@code add} methods of
 *       {@code Group}.
 *   &lt;li&gt;The various {@code add} methods return
 *       the caller.  This allows for easy chaining of invocations.  For
 *       example, {@code group.addComponent(label1).addComponent(label2);} is
 *       equivalent to
 *       {@code group.addComponent(label1); group.addComponent(label2);}.
 *   &lt;li&gt;There are no public constructors for {@code Group}s; instead
 *       use the create methods of {@code GroupLayout}.
 * &lt;/ul&gt;
 *
 * @author Tomas Pavek
 * @author Jan Stola
 * @author Scott Violet
 * @since 1.6
 */
public class GroupLayout implements LayoutManager2 {
    // Used in size calculations
    private static final int MIN_SIZE = 0;

    private static final int PREF_SIZE = 1;

    private static final int MAX_SIZE = 2;

    // Used by prepare, indicates min, pref or max isn't going to be used.
    private static final int SPECIFIC_SIZE = 3;

    private static final int UNSET = Integer.MIN_VALUE;

    /**
     * Indicates the size from the component or gap should be used for a
     * particular range value.
     *
     * @see Group
     */
    public static final int DEFAULT_SIZE = -1;

    /**
     * Indicates the preferred size from the component or gap should
     * be used for a particular range value.
     *
     * @see Group
     */
    public static final int PREFERRED_SIZE = -2;

    // Whether or not we automatically try and create the preferred
    // padding between components.
    private boolean autocreatePadding;

    // Whether or not we automatically try and create the preferred
    // padding between components the touch the edge of the container and
    // the container.
    private boolean autocreateContainerPadding;

    /**
     * Group responsible for layout along the horizontal axis.  This is NOT
     * the user specified group, use getHorizontalGroup to dig that out.
     */
    private Group horizontalGroup;

    /**
     * Group responsible for layout along the vertical axis.  This is NOT
     * the user specified group, use getVerticalGroup to dig that out.
     */
    private Group verticalGroup;

    // Maps from Component to ComponentInfo.  This is used for tracking
    // information specific to a Component.
    private Map&lt;Component,ComponentInfo&gt; componentInfos;

    // Container we're doing layout for.
    private Container host;

    // Used by areParallelSiblings, cached to avoid excessive garbage.
    private Set&lt;Spring&gt; tmpParallelSet;

    // Indicates Springs have changed in some way since last change.
    private boolean springsChanged;

    // Indicates invalidateLayout has been invoked.
    private boolean isValid;

    // Whether or not any preferred padding (or container padding) springs
    // exist
    private boolean hasPreferredPaddingSprings;

    /**
     * The LayoutStyle instance to use, if null the sharedInstance is used.
     */
    private LayoutStyle layoutStyle;

    /**
     * If true, components that are not visible are treated as though they
     * aren't there.
     */
    private boolean honorsVisibility;


    /**
     * Enumeration of the possible ways {@code ParallelGroup} can align
     * its children.
     *
     * @see #createParallelGroup(Alignment)
     * @since 1.6
     */
<span class="nc" id="L297">    public enum Alignment {</span>
        /**
         * Indicates the elements should be
         * aligned to the origin.  For the horizontal axis with a left to
         * right orientation this means aligned to the left edge. For the
         * vertical axis leading means aligned to the top edge.
         *
         * @see #createParallelGroup(Alignment)
         */
<span class="nc" id="L306">        LEADING,</span>

        /**
         * Indicates the elements should be aligned to the end of the
         * region.  For the horizontal axis with a left to right
         * orientation this means aligned to the right edge. For the
         * vertical axis trailing means aligned to the bottom edge.
         *
         * @see #createParallelGroup(Alignment)
         */
<span class="nc" id="L316">        TRAILING,</span>

        /**
         * Indicates the elements should be centered in
         * the region.
         *
         * @see #createParallelGroup(Alignment)
         */
<span class="nc" id="L324">        CENTER,</span>

        /**
         * Indicates the elements should be aligned along
         * their baseline.
         *
         * @see #createParallelGroup(Alignment)
         * @see #createBaselineGroup(boolean,boolean)
         */
<span class="nc" id="L333">        BASELINE</span>
    }


    private static void checkSize(int min, int pref, int max,
            boolean isComponentSpring) {
<span class="nc" id="L339">        checkResizeType(min, isComponentSpring);</span>
<span class="nc bnc" id="L340" title="All 4 branches missed.">        if (!isComponentSpring &amp;&amp; pref &lt; 0) {</span>
<span class="nc" id="L341">            throw new IllegalArgumentException(&quot;Pref must be &gt;= 0&quot;);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        } else if (isComponentSpring) {</span>
<span class="nc" id="L343">            checkResizeType(pref, true);</span>
        }
<span class="nc" id="L345">        checkResizeType(max, isComponentSpring);</span>
<span class="nc" id="L346">        checkLessThan(min, pref);</span>
<span class="nc" id="L347">        checkLessThan(pref, max);</span>
<span class="nc" id="L348">    }</span>

    private static void checkResizeType(int type, boolean isComponentSpring) {
<span class="nc bnc" id="L351" title="All 12 branches missed.">        if (type &lt; 0 &amp;&amp; ((isComponentSpring &amp;&amp; type != DEFAULT_SIZE &amp;&amp;</span>
                type != PREFERRED_SIZE) ||
                (!isComponentSpring &amp;&amp; type != PREFERRED_SIZE))) {
<span class="nc" id="L354">            throw new IllegalArgumentException(&quot;Invalid size&quot;);</span>
        }
<span class="nc" id="L356">    }</span>

    private static void checkLessThan(int min, int max) {
<span class="nc bnc" id="L359" title="All 6 branches missed.">        if (min &gt;= 0 &amp;&amp; max &gt;= 0 &amp;&amp; min &gt; max) {</span>
<span class="nc" id="L360">            throw new IllegalArgumentException(</span>
                    &quot;Following is not met: min&lt;=pref&lt;=max&quot;);
        }
<span class="nc" id="L363">    }</span>

    /**
     * Creates a {@code GroupLayout} for the specified {@code Container}.
     *
     * @param host the {@code Container} the {@code GroupLayout} is
     *        the {@code LayoutManager} for
     * @throws IllegalArgumentException if host is {@code null}
     */
<span class="nc" id="L372">    public GroupLayout(Container host) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (host == null) {</span>
<span class="nc" id="L374">            throw new IllegalArgumentException(&quot;Container must be non-null&quot;);</span>
        }
<span class="nc" id="L376">        honorsVisibility = true;</span>
<span class="nc" id="L377">        this.host = host;</span>
<span class="nc" id="L378">        setHorizontalGroup(createParallelGroup(Alignment.LEADING, true));</span>
<span class="nc" id="L379">        setVerticalGroup(createParallelGroup(Alignment.LEADING, true));</span>
<span class="nc" id="L380">        componentInfos = new HashMap&lt;Component,ComponentInfo&gt;();</span>
<span class="nc" id="L381">        tmpParallelSet = new HashSet&lt;Spring&gt;();</span>
<span class="nc" id="L382">    }</span>

    /**
     * Sets whether component visibility is considered when sizing and
     * positioning components. A value of {@code true} indicates that
     * non-visible components should not be treated as part of the
     * layout. A value of {@code false} indicates that components should be
     * positioned and sized regardless of visibility.
     * &lt;p&gt;
     * A value of {@code false} is useful when the visibility of components
     * is dynamically adjusted and you don't want surrounding components and
     * the sizing to change.
     * &lt;p&gt;
     * The specified value is used for components that do not have an
     * explicit visibility specified.
     * &lt;p&gt;
     * The default is {@code true}.
     *
     * @param honorsVisibility whether component visibility is considered when
     *                         sizing and positioning components
     * @see #setHonorsVisibility(Component,Boolean)
     */
    public void setHonorsVisibility(boolean honorsVisibility) {
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (this.honorsVisibility != honorsVisibility) {</span>
<span class="nc" id="L406">            this.honorsVisibility = honorsVisibility;</span>
<span class="nc" id="L407">            springsChanged = true;</span>
<span class="nc" id="L408">            isValid = false;</span>
<span class="nc" id="L409">            invalidateHost();</span>
        }
<span class="nc" id="L411">    }</span>

    /**
     * Returns whether component visibility is considered when sizing and
     * positioning components.
     *
     * @return whether component visibility is considered when sizing and
     *         positioning components
     */
    public boolean getHonorsVisibility() {
<span class="nc" id="L421">        return honorsVisibility;</span>
    }

    /**
     * Sets whether the component's visibility is considered for
     * sizing and positioning. A value of {@code Boolean.TRUE}
     * indicates that if {@code component} is not visible it should
     * not be treated as part of the layout. A value of {@code false}
     * indicates that {@code component} is positioned and sized
     * regardless of it's visibility.  A value of {@code null}
     * indicates the value specified by the single argument method {@code
     * setHonorsVisibility} should be used.
     * &lt;p&gt;
     * If {@code component} is not a child of the {@code Container} this
     * {@code GroupLayout} is managing, it will be added to the
     * {@code Container}.
     *
     * @param component the component
     * @param honorsVisibility whether visibility of this {@code component} should be
     *              considered for sizing and positioning
     * @throws IllegalArgumentException if {@code component} is {@code null}
     * @see #setHonorsVisibility(Component,Boolean)
     */
    public void setHonorsVisibility(Component component,
            Boolean honorsVisibility) {
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (component == null) {</span>
<span class="nc" id="L447">            throw new IllegalArgumentException(&quot;Component must be non-null&quot;);</span>
        }
<span class="nc" id="L449">        getComponentInfo(component).setHonorsVisibility(honorsVisibility);</span>
<span class="nc" id="L450">        springsChanged = true;</span>
<span class="nc" id="L451">        isValid = false;</span>
<span class="nc" id="L452">        invalidateHost();</span>
<span class="nc" id="L453">    }</span>

    /**
     * Sets whether a gap between components should automatically be
     * created.  For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.  The default is
     * {@code false}.
     *
     * @param autoCreatePadding whether a gap between components is
     *        automatically created
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (this.autocreatePadding != autoCreatePadding) {</span>
<span class="nc" id="L467">            this.autocreatePadding = autoCreatePadding;</span>
<span class="nc" id="L468">            invalidateHost();</span>
        }
<span class="nc" id="L470">    }</span>

    /**
     * Returns {@code true} if gaps between components are automatically
     * created.
     *
     * @return {@code true} if gaps between components are automatically
     *         created
     */
    public boolean getAutoCreateGaps() {
<span class="nc" id="L480">        return autocreatePadding;</span>
    }

    /**
     * Sets whether a gap between the container and components that
     * touch the border of the container should automatically be
     * created. The default is {@code false}.
     *
     * @param autoCreateContainerPadding whether a gap between the container and
     *        components that touch the border of the container should
     *        automatically be created
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerPadding){
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (this.autocreateContainerPadding != autoCreateContainerPadding) {</span>
<span class="nc" id="L494">            this.autocreateContainerPadding = autoCreateContainerPadding;</span>
<span class="nc" id="L495">            horizontalGroup = createTopLevelGroup(getHorizontalGroup());</span>
<span class="nc" id="L496">            verticalGroup = createTopLevelGroup(getVerticalGroup());</span>
<span class="nc" id="L497">            invalidateHost();</span>
        }
<span class="nc" id="L499">    }</span>

    /**
     * Returns {@code true} if gaps between the container and components that
     * border the container are automatically created.
     *
     * @return {@code true} if gaps between the container and components that
     *         border the container are automatically created
     */
    public boolean getAutoCreateContainerGaps() {
<span class="nc" id="L509">        return autocreateContainerPadding;</span>
    }

    /**
     * Sets the {@code Group} that positions and sizes
     * components along the horizontal axis.
     *
     * @param group the {@code Group} that positions and sizes
     *        components along the horizontal axis
     * @throws IllegalArgumentException if group is {@code null}
     */
    public void setHorizontalGroup(Group group) {
<span class="nc bnc" id="L521" title="All 2 branches missed.">        if (group == null) {</span>
<span class="nc" id="L522">            throw new IllegalArgumentException(&quot;Group must be non-null&quot;);</span>
        }
<span class="nc" id="L524">        horizontalGroup = createTopLevelGroup(group);</span>
<span class="nc" id="L525">        invalidateHost();</span>
<span class="nc" id="L526">    }</span>

    /**
     * Returns the {@code Group} that positions and sizes components
     * along the horizontal axis.
     *
     * @return the {@code Group} responsible for positioning and
     *         sizing component along the horizontal axis
     */
    private Group getHorizontalGroup() {
<span class="nc" id="L536">        int index = 0;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (horizontalGroup.springs.size() &gt; 1) {</span>
<span class="nc" id="L538">            index = 1;</span>
        }
<span class="nc" id="L540">        return (Group)horizontalGroup.springs.get(index);</span>
    }

    /**
     * Sets the {@code Group} that positions and sizes
     * components along the vertical axis.
     *
     * @param group the {@code Group} that positions and sizes
     *        components along the vertical axis
     * @throws IllegalArgumentException if group is {@code null}
     */
    public void setVerticalGroup(Group group) {
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (group == null) {</span>
<span class="nc" id="L553">            throw new IllegalArgumentException(&quot;Group must be non-null&quot;);</span>
        }
<span class="nc" id="L555">        verticalGroup = createTopLevelGroup(group);</span>
<span class="nc" id="L556">        invalidateHost();</span>
<span class="nc" id="L557">    }</span>

    /**
     * Returns the {@code Group} that positions and sizes components
     * along the vertical axis.
     *
     * @return the {@code Group} responsible for positioning and
     *         sizing component along the vertical axis
     */
    private Group getVerticalGroup() {
<span class="nc" id="L567">        int index = 0;</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (verticalGroup.springs.size() &gt; 1) {</span>
<span class="nc" id="L569">            index = 1;</span>
        }
<span class="nc" id="L571">        return (Group)verticalGroup.springs.get(index);</span>
    }

    /**
     * Wraps the user specified group in a sequential group.  If
     * container gaps should be generated the necessary springs are
     * added.
     */
    private Group createTopLevelGroup(Group specifiedGroup) {
<span class="nc" id="L580">        SequentialGroup group = createSequentialGroup();</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">        if (getAutoCreateContainerGaps()) {</span>
<span class="nc" id="L582">            group.addSpring(new ContainerAutoPreferredGapSpring());</span>
<span class="nc" id="L583">            group.addGroup(specifiedGroup);</span>
<span class="nc" id="L584">            group.addSpring(new ContainerAutoPreferredGapSpring());</span>
        } else {
<span class="nc" id="L586">            group.addGroup(specifiedGroup);</span>
        }
<span class="nc" id="L588">        return group;</span>
    }

    /**
     * Creates and returns a {@code SequentialGroup}.
     *
     * @return a new {@code SequentialGroup}
     */
    public SequentialGroup createSequentialGroup() {
<span class="nc" id="L597">        return new SequentialGroup();</span>
    }

    /**
     * Creates and returns a {@code ParallelGroup} with an alignment of
     * {@code Alignment.LEADING}.  This is a cover method for the more
     * general {@code createParallelGroup(Alignment)} method.
     *
     * @return a new {@code ParallelGroup}
     * @see #createParallelGroup(Alignment)
     */
    public ParallelGroup createParallelGroup() {
<span class="nc" id="L609">        return createParallelGroup(Alignment.LEADING);</span>
    }

    /**
     * Creates and returns a {@code ParallelGroup} with the specified
     * alignment.  This is a cover method for the more general {@code
     * createParallelGroup(Alignment,boolean)} method with {@code true}
     * supplied for the second argument.
     *
     * @param alignment the alignment for the elements of the group
     * @throws IllegalArgumentException if {@code alignment} is {@code null}
     * @return a new {@code ParallelGroup}
     * @see #createBaselineGroup
     * @see ParallelGroup
     */
    public ParallelGroup createParallelGroup(Alignment alignment) {
<span class="nc" id="L625">        return createParallelGroup(alignment, true);</span>
    }

    /**
     * Creates and returns a {@code ParallelGroup} with the specified
     * alignment and resize behavior. The {@code
     * alignment} argument specifies how children elements are
     * positioned that do not fill the group. For example, if a {@code
     * ParallelGroup} with an alignment of {@code TRAILING} is given
     * 100 and a child only needs 50, the child is
     * positioned at the position 50 (with a component orientation of
     * left-to-right).
     * &lt;p&gt;
     * Baseline alignment is only useful when used along the vertical
     * axis. A {@code ParallelGroup} created with a baseline alignment
     * along the horizontal axis is treated as {@code LEADING}.
     * &lt;p&gt;
     * Refer to {@link GroupLayout.ParallelGroup ParallelGroup} for details on
     * the behavior of baseline groups.
     *
     * @param alignment the alignment for the elements of the group
     * @param resizable {@code true} if the group is resizable; if the group
     *        is not resizable the preferred size is used for the
     *        minimum and maximum size of the group
     * @throws IllegalArgumentException if {@code alignment} is {@code null}
     * @return a new {@code ParallelGroup}
     * @see #createBaselineGroup
     * @see GroupLayout.ParallelGroup
     */
    public ParallelGroup createParallelGroup(Alignment alignment,
            boolean resizable){
<span class="nc bnc" id="L656" title="All 2 branches missed.">        if (alignment == null) {</span>
<span class="nc" id="L657">            throw new IllegalArgumentException(&quot;alignment must be non null&quot;);</span>
        }

<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (alignment == Alignment.BASELINE) {</span>
<span class="nc" id="L661">            return new BaselineGroup(resizable);</span>
        }
<span class="nc" id="L663">        return new ParallelGroup(alignment, resizable);</span>
    }

    /**
     * Creates and returns a {@code ParallelGroup} that aligns it's
     * elements along the baseline.
     *
     * @param resizable whether the group is resizable
     * @param anchorBaselineToTop whether the baseline is anchored to
     *        the top or bottom of the group
     * @see #createBaselineGroup
     * @see ParallelGroup
     */
    public ParallelGroup createBaselineGroup(boolean resizable,
            boolean anchorBaselineToTop) {
<span class="nc" id="L678">        return new BaselineGroup(resizable, anchorBaselineToTop);</span>
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes. Components that
     * are linked are given the maximum of the preferred size of each of
     * the linked components. For example, if you link two components with
     * a preferred width of 10 and 20, both components are given a width of 20.
     * &lt;p&gt;
     * This can be used multiple times to force any number of
     * components to share the same size.
     * &lt;p&gt;
     * Linked Components are not be resizable.
     *
     * @param components the {@code Component}s that are to have the same size
     * @throws IllegalArgumentException if {@code components} is
     *         {@code null}, or contains {@code null}
     * @see #linkSize(int,Component[])
     */
    public void linkSize(Component... components) {
<span class="nc" id="L699">        linkSize(SwingConstants.HORIZONTAL, components);</span>
<span class="nc" id="L700">        linkSize(SwingConstants.VERTICAL, components);</span>
<span class="nc" id="L701">    }</span>

    /**
     * Forces the specified components to have the same size along the
     * specified axis regardless of their preferred, minimum or
     * maximum sizes. Components that are linked are given the maximum
     * of the preferred size of each of the linked components. For
     * example, if you link two components along the horizontal axis
     * and the preferred width is 10 and 20, both components are given
     * a width of 20.
     * &lt;p&gt;
     * This can be used multiple times to force any number of
     * components to share the same size.
     * &lt;p&gt;
     * Linked {@code Component}s are not be resizable.
     *
     * @param components the {@code Component}s that are to have the same size
     * @param axis the axis to link the size along; one of
     *             {@code SwingConstants.HORIZONTAL} or
     *             {@code SwingConstans.VERTICAL}
     * @throws IllegalArgumentException if {@code components} is
     *         {@code null}, or contains {@code null}; or {@code axis}
     *          is not {@code SwingConstants.HORIZONTAL} or
     *          {@code SwingConstants.VERTICAL}
     */
    public void linkSize(int axis, Component... components) {
<span class="nc bnc" id="L727" title="All 2 branches missed.">        if (components == null) {</span>
<span class="nc" id="L728">            throw new IllegalArgumentException(&quot;Components must be non-null&quot;);</span>
        }
<span class="nc bnc" id="L730" title="All 2 branches missed.">        for (int counter = components.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L731">            Component c = components[counter];</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">            if (components[counter] == null) {</span>
<span class="nc" id="L733">                throw new IllegalArgumentException(</span>
                        &quot;Components must be non-null&quot;);
            }
            // Force the component to be added
<span class="nc" id="L737">            getComponentInfo(c);</span>
        }
        int glAxis;
<span class="nc bnc" id="L740" title="All 2 branches missed.">        if (axis == SwingConstants.HORIZONTAL) {</span>
<span class="nc" id="L741">            glAxis = HORIZONTAL;</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">        } else if (axis == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L743">            glAxis = VERTICAL;</span>
        } else {
<span class="nc" id="L745">            throw new IllegalArgumentException(&quot;Axis must be one of &quot; +</span>
                    &quot;SwingConstants.HORIZONTAL or SwingConstants.VERTICAL&quot;);
        }
<span class="nc" id="L748">        LinkInfo master = getComponentInfo(</span>
<span class="nc" id="L749">                components[components.length - 1]).getLinkInfo(glAxis);</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">        for (int counter = components.length - 2; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L751">            master.add(getComponentInfo(components[counter]));</span>
        }
<span class="nc" id="L753">        invalidateHost();</span>
<span class="nc" id="L754">    }</span>

    /**
     * Replaces an existing component with a new one.
     *
     * @param existingComponent the component that should be removed
     *        and replaced with {@code newComponent}
     * @param newComponent the component to put in
     *        {@code existingComponent}'s place
     * @throws IllegalArgumentException if either of the components are
     *         {@code null} or {@code existingComponent} is not being managed
     *         by this layout manager
     */
    public void replace(Component existingComponent, Component newComponent) {
<span class="nc bnc" id="L768" title="All 4 branches missed.">        if (existingComponent == null || newComponent == null) {</span>
<span class="nc" id="L769">            throw new IllegalArgumentException(&quot;Components must be non-null&quot;);</span>
        }
        // Make sure all the components have been registered, otherwise we may
        // not update the correct Springs.
<span class="nc bnc" id="L773" title="All 2 branches missed.">        if (springsChanged) {</span>
<span class="nc" id="L774">            registerComponents(horizontalGroup, HORIZONTAL);</span>
<span class="nc" id="L775">            registerComponents(verticalGroup, VERTICAL);</span>
        }
<span class="nc" id="L777">        ComponentInfo info = componentInfos.remove(existingComponent);</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (info == null) {</span>
<span class="nc" id="L779">            throw new IllegalArgumentException(&quot;Component must already exist&quot;);</span>
        }
<span class="nc" id="L781">        host.remove(existingComponent);</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (newComponent.getParent() != host) {</span>
<span class="nc" id="L783">            host.add(newComponent);</span>
        }
<span class="nc" id="L785">        info.setComponent(newComponent);</span>
<span class="nc" id="L786">        componentInfos.put(newComponent, info);</span>
<span class="nc" id="L787">        invalidateHost();</span>
<span class="nc" id="L788">    }</span>

    /**
     * Sets the {@code LayoutStyle} used to calculate the preferred
     * gaps between components. A value of {@code null} indicates the
     * shared instance of {@code LayoutStyle} should be used.
     *
     * @param layoutStyle the {@code LayoutStyle} to use
     * @see LayoutStyle
     */
    public void setLayoutStyle(LayoutStyle layoutStyle) {
<span class="nc" id="L799">        this.layoutStyle = layoutStyle;</span>
<span class="nc" id="L800">        invalidateHost();</span>
<span class="nc" id="L801">    }</span>

    /**
     * Returns the {@code LayoutStyle} used for calculating the preferred
     * gap between components. This returns the value specified to
     * {@code setLayoutStyle}, which may be {@code null}.
     *
     * @return the {@code LayoutStyle} used for calculating the preferred
     *         gap between components
     */
    public LayoutStyle getLayoutStyle() {
<span class="nc" id="L812">        return layoutStyle;</span>
    }

    private LayoutStyle getLayoutStyle0() {
<span class="nc" id="L816">        LayoutStyle layoutStyle = getLayoutStyle();</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">        if (layoutStyle == null) {</span>
<span class="nc" id="L818">            layoutStyle = LayoutStyle.getInstance();</span>
        }
<span class="nc" id="L820">        return layoutStyle;</span>
    }

    private void invalidateHost() {
<span class="nc bnc" id="L824" title="All 2 branches missed.">        if (host instanceof JComponent) {</span>
<span class="nc" id="L825">            ((JComponent)host).revalidate();</span>
        } else {
<span class="nc" id="L827">            host.invalidate();</span>
        }
<span class="nc" id="L829">        host.repaint();</span>
<span class="nc" id="L830">    }</span>

    //
    // LayoutManager
    //
    /**
     * Notification that a {@code Component} has been added to
     * the parent container.  You should not invoke this method
     * directly, instead you should use one of the {@code Group}
     * methods to add a {@code Component}.
     *
     * @param name the string to be associated with the component
     * @param component the {@code Component} to be added
     */
    public void addLayoutComponent(String name, Component component) {
<span class="nc" id="L845">    }</span>

    /**
     * Notification that a {@code Component} has been removed from
     * the parent container.  You should not invoke this method
     * directly, instead invoke {@code remove} on the parent
     * {@code Container}.
     *
     * @param component the component to be removed
     * @see java.awt.Component#remove
     */
    public void removeLayoutComponent(Component component) {
<span class="nc" id="L857">        ComponentInfo info = componentInfos.remove(component);</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (info != null) {</span>
<span class="nc" id="L859">            info.dispose();</span>
<span class="nc" id="L860">            springsChanged = true;</span>
<span class="nc" id="L861">            isValid = false;</span>
        }
<span class="nc" id="L863">    }</span>

    /**
     * Returns the preferred size for the specified container.
     *
     * @param parent the container to return the preferred size for
     * @return the preferred size for {@code parent}
     * @throws IllegalArgumentException if {@code parent} is not
     *         the same {@code Container} this was created with
     * @throws IllegalStateException if any of the components added to
     *         this layout are not in both a horizontal and vertical group
     * @see java.awt.Container#getPreferredSize
     */
    public Dimension preferredLayoutSize(Container parent) {
<span class="nc" id="L877">        checkParent(parent);</span>
<span class="nc" id="L878">        prepare(PREF_SIZE);</span>
<span class="nc" id="L879">        return adjustSize(horizontalGroup.getPreferredSize(HORIZONTAL),</span>
<span class="nc" id="L880">                verticalGroup.getPreferredSize(VERTICAL));</span>
    }

    /**
     * Returns the minimum size for the specified container.
     *
     * @param parent the container to return the size for
     * @return the minimum size for {@code parent}
     * @throws IllegalArgumentException if {@code parent} is not
     *         the same {@code Container} that this was created with
     * @throws IllegalStateException if any of the components added to
     *         this layout are not in both a horizontal and vertical group
     * @see java.awt.Container#getMinimumSize
     */
    public Dimension minimumLayoutSize(Container parent) {
<span class="nc" id="L895">        checkParent(parent);</span>
<span class="nc" id="L896">        prepare(MIN_SIZE);</span>
<span class="nc" id="L897">        return adjustSize(horizontalGroup.getMinimumSize(HORIZONTAL),</span>
<span class="nc" id="L898">                verticalGroup.getMinimumSize(VERTICAL));</span>
    }

    /**
     * Lays out the specified container.
     *
     * @param parent the container to be laid out
     * @throws IllegalStateException if any of the components added to
     *         this layout are not in both a horizontal and vertical group
     */
    public void layoutContainer(Container parent) {
        // Step 1: Prepare for layout.
<span class="nc" id="L910">        prepare(SPECIFIC_SIZE);</span>
<span class="nc" id="L911">        Insets insets = parent.getInsets();</span>
<span class="nc" id="L912">        int width = parent.getWidth() - insets.left - insets.right;</span>
<span class="nc" id="L913">        int height = parent.getHeight() - insets.top - insets.bottom;</span>
<span class="nc" id="L914">        boolean ltr = isLeftToRight();</span>
<span class="nc bnc" id="L915" title="All 6 branches missed.">        if (getAutoCreateGaps() || getAutoCreateContainerGaps() ||</span>
                hasPreferredPaddingSprings) {
            // Step 2: Calculate autopadding springs
<span class="nc" id="L918">            calculateAutopadding(horizontalGroup, HORIZONTAL, SPECIFIC_SIZE, 0,</span>
                    width);
<span class="nc" id="L920">            calculateAutopadding(verticalGroup, VERTICAL, SPECIFIC_SIZE, 0,</span>
                    height);
        }
        // Step 3: set the size of the groups.
<span class="nc" id="L924">        horizontalGroup.setSize(HORIZONTAL, 0, width);</span>
<span class="nc" id="L925">        verticalGroup.setSize(VERTICAL, 0, height);</span>
        // Step 4: apply the size to the components.
<span class="nc bnc" id="L927" title="All 2 branches missed.">        for (ComponentInfo info : componentInfos.values()) {</span>
<span class="nc" id="L928">            info.setBounds(insets, width, ltr);</span>
<span class="nc" id="L929">        }</span>
<span class="nc" id="L930">    }</span>

    //
    // LayoutManager2
    //
    /**
     * Notification that a {@code Component} has been added to
     * the parent container.  You should not invoke this method
     * directly, instead you should use one of the {@code Group}
     * methods to add a {@code Component}.
     *
     * @param component the component added
     * @param constraints description of where to place the component
     */
    public void addLayoutComponent(Component component, Object constraints) {
<span class="nc" id="L945">    }</span>

    /**
     * Returns the maximum size for the specified container.
     *
     * @param parent the container to return the size for
     * @return the maximum size for {@code parent}
     * @throws IllegalArgumentException if {@code parent} is not
     *         the same {@code Container} that this was created with
     * @throws IllegalStateException if any of the components added to
     *         this layout are not in both a horizontal and vertical group
     * @see java.awt.Container#getMaximumSize
     */
    public Dimension maximumLayoutSize(Container parent) {
<span class="nc" id="L959">        checkParent(parent);</span>
<span class="nc" id="L960">        prepare(MAX_SIZE);</span>
<span class="nc" id="L961">        return adjustSize(horizontalGroup.getMaximumSize(HORIZONTAL),</span>
<span class="nc" id="L962">                verticalGroup.getMaximumSize(VERTICAL));</span>
    }

    /**
     * Returns the alignment along the x axis.  This specifies how
     * the component would like to be aligned relative to other
     * components.  The value should be a number between 0 and 1
     * where 0 represents alignment along the origin, 1 is aligned
     * the furthest away from the origin, 0.5 is centered, etc.
     *
     * @param parent the {@code Container} hosting this {@code LayoutManager}
     * @throws IllegalArgumentException if {@code parent} is not
     *         the same {@code Container} that this was created with
     * @return the alignment; this implementation returns {@code .5}
     */
    public float getLayoutAlignmentX(Container parent) {
<span class="nc" id="L978">        checkParent(parent);</span>
<span class="nc" id="L979">        return .5f;</span>
    }

    /**
     * Returns the alignment along the y axis.  This specifies how
     * the component would like to be aligned relative to other
     * components.  The value should be a number between 0 and 1
     * where 0 represents alignment along the origin, 1 is aligned
     * the furthest away from the origin, 0.5 is centered, etc.
     *
     * @param parent the {@code Container} hosting this {@code LayoutManager}
     * @throws IllegalArgumentException if {@code parent} is not
     *         the same {@code Container} that this was created with
     * @return alignment; this implementation returns {@code .5}
     */
    public float getLayoutAlignmentY(Container parent) {
<span class="nc" id="L995">        checkParent(parent);</span>
<span class="nc" id="L996">        return .5f;</span>
    }

    /**
     * Invalidates the layout, indicating that if the layout manager
     * has cached information it should be discarded.
     *
     * @param parent the {@code Container} hosting this LayoutManager
     * @throws IllegalArgumentException if {@code parent} is not
     *         the same {@code Container} that this was created with
     */
    public void invalidateLayout(Container parent) {
<span class="nc" id="L1008">        checkParent(parent);</span>
        // invalidateLayout is called from Container.invalidate, which
        // does NOT grab the treelock.  All other methods do.  To make sure
        // there aren't any possible threading problems we grab the tree lock
        // here.
<span class="nc" id="L1013">        synchronized(parent.getTreeLock()) {</span>
<span class="nc" id="L1014">            isValid = false;</span>
<span class="nc" id="L1015">        }</span>
<span class="nc" id="L1016">    }</span>

    private void prepare(int sizeType) {
<span class="nc" id="L1019">        boolean visChanged = false;</span>
        // Step 1: If not-valid, clear springs and update visibility.
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (!isValid) {</span>
<span class="nc" id="L1022">            isValid = true;</span>
<span class="nc" id="L1023">            horizontalGroup.setSize(HORIZONTAL, UNSET, UNSET);</span>
<span class="nc" id="L1024">            verticalGroup.setSize(VERTICAL, UNSET, UNSET);</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">            for (ComponentInfo ci : componentInfos.values()) {</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">                if (ci.updateVisibility()) {</span>
<span class="nc" id="L1027">                    visChanged = true;</span>
                }
<span class="nc" id="L1029">                ci.clearCachedSize();</span>
<span class="nc" id="L1030">            }</span>
        }
        // Step 2: Make sure components are bound to ComponentInfos
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (springsChanged) {</span>
<span class="nc" id="L1034">            registerComponents(horizontalGroup, HORIZONTAL);</span>
<span class="nc" id="L1035">            registerComponents(verticalGroup, VERTICAL);</span>
        }
        // Step 3: Adjust the autopadding. This removes existing
        // autopadding, then recalculates where it should go.
<span class="nc bnc" id="L1039" title="All 4 branches missed.">        if (springsChanged || visChanged) {</span>
<span class="nc" id="L1040">            checkComponents();</span>
<span class="nc" id="L1041">            horizontalGroup.removeAutopadding();</span>
<span class="nc" id="L1042">            verticalGroup.removeAutopadding();</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            if (getAutoCreateGaps()) {</span>
<span class="nc" id="L1044">                insertAutopadding(true);</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">            } else if (hasPreferredPaddingSprings ||</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">                    getAutoCreateContainerGaps()) {</span>
<span class="nc" id="L1047">                insertAutopadding(false);</span>
            }
<span class="nc" id="L1049">            springsChanged = false;</span>
        }
        // Step 4: (for min/pref/max size calculations only) calculate the
        // autopadding. This invokes for unsetting the calculated values, then
        // recalculating them.
        // If sizeType == SPECIFIC_SIZE, it indicates we're doing layout, this
        // step will be done later on.
<span class="nc bnc" id="L1056" title="All 4 branches missed.">        if (sizeType != SPECIFIC_SIZE &amp;&amp; (getAutoCreateGaps() ||</span>
<span class="nc bnc" id="L1057" title="All 4 branches missed.">                getAutoCreateContainerGaps() || hasPreferredPaddingSprings)) {</span>
<span class="nc" id="L1058">            calculateAutopadding(horizontalGroup, HORIZONTAL, sizeType, 0, 0);</span>
<span class="nc" id="L1059">            calculateAutopadding(verticalGroup, VERTICAL, sizeType, 0, 0);</span>
        }
<span class="nc" id="L1061">    }</span>

    private void calculateAutopadding(Group group, int axis, int sizeType,
            int origin, int size) {
<span class="nc" id="L1065">        group.unsetAutopadding();</span>
<span class="nc bnc" id="L1066" title="All 4 branches missed.">        switch(sizeType) {</span>
            case MIN_SIZE:
<span class="nc" id="L1068">                size = group.getMinimumSize(axis);</span>
<span class="nc" id="L1069">                break;</span>
            case PREF_SIZE:
<span class="nc" id="L1071">                size = group.getPreferredSize(axis);</span>
<span class="nc" id="L1072">                break;</span>
            case MAX_SIZE:
<span class="nc" id="L1074">                size = group.getMaximumSize(axis);</span>
<span class="nc" id="L1075">                break;</span>
            default:
                break;
        }
<span class="nc" id="L1079">        group.setSize(axis, origin, size);</span>
<span class="nc" id="L1080">        group.calculateAutopadding(axis);</span>
<span class="nc" id="L1081">    }</span>

    private void checkComponents() {
<span class="nc bnc" id="L1084" title="All 2 branches missed.">        for (ComponentInfo info : componentInfos.values()) {</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">            if (info.horizontalSpring == null) {</span>
<span class="nc" id="L1086">                throw new IllegalStateException(info.component +</span>
                        &quot; is not attached to a horizontal group&quot;);
            }
<span class="nc bnc" id="L1089" title="All 2 branches missed.">            if (info.verticalSpring == null) {</span>
<span class="nc" id="L1090">                throw new IllegalStateException(info.component +</span>
                        &quot; is not attached to a vertical group&quot;);
            }
<span class="nc" id="L1093">        }</span>
<span class="nc" id="L1094">    }</span>

    private void registerComponents(Group group, int axis) {
<span class="nc" id="L1097">        List&lt;Spring&gt; springs = group.springs;</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">        for (int counter = springs.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L1099">            Spring spring = springs.get(counter);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">            if (spring instanceof ComponentSpring) {</span>
<span class="nc" id="L1101">                ((ComponentSpring)spring).installIfNecessary(axis);</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">            } else if (spring instanceof Group) {</span>
<span class="nc" id="L1103">                registerComponents((Group)spring, axis);</span>
            }
        }
<span class="nc" id="L1106">    }</span>

    private Dimension adjustSize(int width, int height) {
<span class="nc" id="L1109">        Insets insets = host.getInsets();</span>
<span class="nc" id="L1110">        return new Dimension(width + insets.left + insets.right,</span>
                height + insets.top + insets.bottom);
    }

    private void checkParent(Container parent) {
<span class="nc bnc" id="L1115" title="All 2 branches missed.">        if (parent != host) {</span>
<span class="nc" id="L1116">            throw new IllegalArgumentException(</span>
                    &quot;GroupLayout can only be used with one Container at a time&quot;);
        }
<span class="nc" id="L1119">    }</span>

    /**
     * Returns the {@code ComponentInfo} for the specified Component,
     * creating one if necessary.
     */
    private ComponentInfo getComponentInfo(Component component) {
<span class="nc" id="L1126">        ComponentInfo info = componentInfos.get(component);</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        if (info == null) {</span>
<span class="nc" id="L1128">            info = new ComponentInfo(component);</span>
<span class="nc" id="L1129">            componentInfos.put(component, info);</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">            if (component.getParent() != host) {</span>
<span class="nc" id="L1131">                host.add(component);</span>
            }
        }
<span class="nc" id="L1134">        return info;</span>
    }

    /**
     * Adjusts the autopadding springs for the horizontal and vertical
     * groups.  If {@code insert} is {@code true} this will insert auto padding
     * springs, otherwise this will only adjust the springs that
     * comprise auto preferred padding springs.
     */
    private void insertAutopadding(boolean insert) {
<span class="nc" id="L1144">        horizontalGroup.insertAutopadding(HORIZONTAL,</span>
                new ArrayList&lt;AutoPreferredGapSpring&gt;(1),
                new ArrayList&lt;AutoPreferredGapSpring&gt;(1),
                new ArrayList&lt;ComponentSpring&gt;(1),
                new ArrayList&lt;ComponentSpring&gt;(1), insert);
<span class="nc" id="L1149">        verticalGroup.insertAutopadding(VERTICAL,</span>
                new ArrayList&lt;AutoPreferredGapSpring&gt;(1),
                new ArrayList&lt;AutoPreferredGapSpring&gt;(1),
                new ArrayList&lt;ComponentSpring&gt;(1),
                new ArrayList&lt;ComponentSpring&gt;(1), insert);
<span class="nc" id="L1154">    }</span>

    /**
     * Returns {@code true} if the two Components have a common ParallelGroup
     * ancestor along the particular axis.
     */
    private boolean areParallelSiblings(Component source, Component target,
            int axis) {
<span class="nc" id="L1162">        ComponentInfo sourceInfo = getComponentInfo(source);</span>
<span class="nc" id="L1163">        ComponentInfo targetInfo = getComponentInfo(target);</span>
        Spring sourceSpring;
        Spring targetSpring;
<span class="nc bnc" id="L1166" title="All 2 branches missed.">        if (axis == HORIZONTAL) {</span>
<span class="nc" id="L1167">            sourceSpring = sourceInfo.horizontalSpring;</span>
<span class="nc" id="L1168">            targetSpring = targetInfo.horizontalSpring;</span>
        } else {
<span class="nc" id="L1170">            sourceSpring = sourceInfo.verticalSpring;</span>
<span class="nc" id="L1171">            targetSpring = targetInfo.verticalSpring;</span>
        }
<span class="nc" id="L1173">        Set&lt;Spring&gt; sourcePath = tmpParallelSet;</span>
<span class="nc" id="L1174">        sourcePath.clear();</span>
<span class="nc" id="L1175">        Spring spring = sourceSpring.getParent();</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">        while (spring != null) {</span>
<span class="nc" id="L1177">            sourcePath.add(spring);</span>
<span class="nc" id="L1178">            spring = spring.getParent();</span>
        }
<span class="nc" id="L1180">        spring = targetSpring.getParent();</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">        while (spring != null) {</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">            if (sourcePath.contains(spring)) {</span>
<span class="nc" id="L1183">                sourcePath.clear();</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">                while (spring != null) {</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">                    if (spring instanceof ParallelGroup) {</span>
<span class="nc" id="L1186">                        return true;</span>
                    }
<span class="nc" id="L1188">                    spring = spring.getParent();</span>
                }
<span class="nc" id="L1190">                return false;</span>
            }
<span class="nc" id="L1192">            spring = spring.getParent();</span>
        }
<span class="nc" id="L1194">        sourcePath.clear();</span>
<span class="nc" id="L1195">        return false;</span>
    }

    private boolean isLeftToRight() {
<span class="nc" id="L1199">        return host.getComponentOrientation().isLeftToRight();</span>
    }

    /**
     * Returns a string representation of this {@code GroupLayout}.
     * This method is intended to be used for debugging purposes,
     * and the content and format of the returned string may vary
     * between implementations.
     *
     * @return a string representation of this {@code GroupLayout}
     **/
    public String toString() {
<span class="nc bnc" id="L1211" title="All 2 branches missed.">        if (springsChanged) {</span>
<span class="nc" id="L1212">            registerComponents(horizontalGroup, HORIZONTAL);</span>
<span class="nc" id="L1213">            registerComponents(verticalGroup, VERTICAL);</span>
        }
<span class="nc" id="L1215">        StringBuffer buffer = new StringBuffer();</span>
<span class="nc" id="L1216">        buffer.append(&quot;HORIZONTAL\n&quot;);</span>
<span class="nc" id="L1217">        createSpringDescription(buffer, horizontalGroup, &quot;  &quot;, HORIZONTAL);</span>
<span class="nc" id="L1218">        buffer.append(&quot;\nVERTICAL\n&quot;);</span>
<span class="nc" id="L1219">        createSpringDescription(buffer, verticalGroup, &quot;  &quot;, VERTICAL);</span>
<span class="nc" id="L1220">        return buffer.toString();</span>
    }

    private void createSpringDescription(StringBuffer buffer, Spring spring,
            String indent, int axis) {
<span class="nc" id="L1225">        String origin = &quot;&quot;;</span>
<span class="nc" id="L1226">        String padding = &quot;&quot;;</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">        if (spring instanceof ComponentSpring) {</span>
<span class="nc" id="L1228">            ComponentSpring cSpring = (ComponentSpring)spring;</span>
<span class="nc" id="L1229">            origin = Integer.toString(cSpring.getOrigin()) + &quot; &quot;;</span>
<span class="nc" id="L1230">            String name = cSpring.getComponent().getName();</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">            if (name != null) {</span>
<span class="nc" id="L1232">                origin = &quot;name=&quot; + name + &quot;, &quot;;</span>
            }
        }
<span class="nc bnc" id="L1235" title="All 2 branches missed.">        if (spring instanceof AutoPreferredGapSpring) {</span>
<span class="nc" id="L1236">            AutoPreferredGapSpring paddingSpring =</span>
                    (AutoPreferredGapSpring)spring;
<span class="nc" id="L1238">            padding = &quot;, userCreated=&quot; + paddingSpring.getUserCreated() +</span>
<span class="nc" id="L1239">                    &quot;, matches=&quot; + paddingSpring.getMatchDescription();</span>
        }
<span class="nc" id="L1241">        buffer.append(indent + spring.getClass().getName() + &quot; &quot; +</span>
<span class="nc" id="L1242">                Integer.toHexString(spring.hashCode()) + &quot; &quot; +</span>
                origin +
<span class="nc" id="L1244">                &quot;, size=&quot; + spring.getSize() +</span>
<span class="nc" id="L1245">                &quot;, alignment=&quot; + spring.getAlignment() +</span>
<span class="nc" id="L1246">                &quot; prefs=[&quot; + spring.getMinimumSize(axis) +</span>
<span class="nc" id="L1247">                &quot; &quot; + spring.getPreferredSize(axis) +</span>
<span class="nc" id="L1248">                &quot; &quot; + spring.getMaximumSize(axis) +</span>
                padding + &quot;]\n&quot;);
<span class="nc bnc" id="L1250" title="All 2 branches missed.">        if (spring instanceof Group) {</span>
<span class="nc" id="L1251">            List&lt;Spring&gt; springs = ((Group)spring).springs;</span>
<span class="nc" id="L1252">            indent += &quot;  &quot;;</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">            for (int counter = 0; counter &lt; springs.size(); counter++) {</span>
<span class="nc" id="L1254">                createSpringDescription(buffer, springs.get(counter), indent,</span>
                        axis);
            }
        }
<span class="nc" id="L1258">    }</span>


    /**
     * Spring consists of a range: min, pref and max, a value some where in
     * the middle of that, and a location. Spring caches the
     * min/max/pref.  If the min/pref/max has internally changes, or needs
     * to be updated you must invoke clear.
     */
    private abstract class Spring {
        private int size;
        private int min;
        private int max;
        private int pref;
        private Spring parent;

        private Alignment alignment;

<span class="nc" id="L1276">        Spring() {</span>
<span class="nc" id="L1277">            min = pref = max = UNSET;</span>
<span class="nc" id="L1278">        }</span>

        /**
         * Calculates and returns the minimum size.
         *
         * @param axis the axis of layout; one of HORIZONTAL or VERTICAL
         * @return the minimum size
         */
        abstract int calculateMinimumSize(int axis);

        /**
         * Calculates and returns the preferred size.
         *
         * @param axis the axis of layout; one of HORIZONTAL or VERTICAL
         * @return the preferred size
         */
        abstract int calculatePreferredSize(int axis);

        /**
         * Calculates and returns the minimum size.
         *
         * @param axis the axis of layout; one of HORIZONTAL or VERTICAL
         * @return the minimum size
         */
        abstract int calculateMaximumSize(int axis);

        /**
         * Sets the parent of this Spring.
         */
        void setParent(Spring parent) {
<span class="nc" id="L1308">            this.parent = parent;</span>
<span class="nc" id="L1309">        }</span>

        /**
         * Returns the parent of this spring.
         */
        Spring getParent() {
<span class="nc" id="L1315">            return parent;</span>
        }

        // This is here purely as a convenience for ParallelGroup to avoid
        // having to track alignment separately.
        void setAlignment(Alignment alignment) {
<span class="nc" id="L1321">            this.alignment = alignment;</span>
<span class="nc" id="L1322">        }</span>

        /**
         * Alignment for this Spring, this may be null.
         */
        Alignment getAlignment() {
<span class="nc" id="L1328">            return alignment;</span>
        }

        /**
         * Returns the minimum size.
         */
        final int getMinimumSize(int axis) {
<span class="nc bnc" id="L1335" title="All 2 branches missed.">            if (min == UNSET) {</span>
<span class="nc" id="L1336">                min = constrain(calculateMinimumSize(axis));</span>
            }
<span class="nc" id="L1338">            return min;</span>
        }

        /**
         * Returns the preferred size.
         */
        final int getPreferredSize(int axis) {
<span class="nc bnc" id="L1345" title="All 2 branches missed.">            if (pref == UNSET) {</span>
<span class="nc" id="L1346">                pref = constrain(calculatePreferredSize(axis));</span>
            }
<span class="nc" id="L1348">            return pref;</span>
        }

        /**
         * Returns the maximum size.
         */
        final int getMaximumSize(int axis) {
<span class="nc bnc" id="L1355" title="All 2 branches missed.">            if (max == UNSET) {</span>
<span class="nc" id="L1356">                max = constrain(calculateMaximumSize(axis));</span>
            }
<span class="nc" id="L1358">            return max;</span>
        }

        /**
         * Sets the value and location of the spring.  Subclasses
         * will want to invoke super, then do any additional sizing.
         *
         * @param axis HORIZONTAL or VERTICAL
         * @param origin of this Spring
         * @param size of the Spring.  If size is UNSET, this invokes
         *        clear.
         */
        void setSize(int axis, int origin, int size) {
<span class="nc" id="L1371">            this.size = size;</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">            if (size == UNSET) {</span>
<span class="nc" id="L1373">                unset();</span>
            }
<span class="nc" id="L1375">        }</span>

        /**
         * Resets the cached min/max/pref.
         */
        void unset() {
<span class="nc" id="L1381">            size = min = pref = max = UNSET;</span>
<span class="nc" id="L1382">        }</span>

        /**
         * Returns the current size.
         */
        int getSize() {
<span class="nc" id="L1388">            return size;</span>
        }

        int constrain(int value) {
<span class="nc" id="L1392">            return Math.min(value, Short.MAX_VALUE);</span>
        }

        int getBaseline() {
<span class="nc" id="L1396">            return -1;</span>
        }

        BaselineResizeBehavior getBaselineResizeBehavior() {
<span class="nc" id="L1400">            return BaselineResizeBehavior.OTHER;</span>
        }

        final boolean isResizable(int axis) {
<span class="nc" id="L1404">            int min = getMinimumSize(axis);</span>
<span class="nc" id="L1405">            int pref = getPreferredSize(axis);</span>
<span class="nc bnc" id="L1406" title="All 4 branches missed.">            return (min != pref || pref != getMaximumSize(axis));</span>
        }

        /**
         * Returns {@code true} if this spring will ALWAYS have a zero
         * size. This should NOT check the current size, rather it's
         * meant to quickly test if this Spring will always have a
         * zero size.
         *
         * @param treatAutopaddingAsZeroSized if {@code true}, auto padding
         *        springs should be treated as having a size of {@code 0}
         * @return {@code true} if this spring will have a zero size,
         *         {@code false} otherwise
         */
        abstract boolean willHaveZeroSize(boolean treatAutopaddingAsZeroSized);
    }

    /**
     * {@code Group} provides the basis for the two types of
     * operations supported by {@code GroupLayout}: laying out
     * components one after another ({@link SequentialGroup SequentialGroup})
     * or aligned ({@link ParallelGroup ParallelGroup}). {@code Group} and
     * its subclasses have no public constructor; to create one use
     * one of {@code createSequentialGroup} or
     * {@code createParallelGroup}. Additionally, taking a {@code Group}
     * created from one {@code GroupLayout} and using it with another
     * will produce undefined results.
     * &lt;p&gt;
     * Various methods in {@code Group} and its subclasses allow you
     * to explicitly specify the range. The arguments to these methods
     * can take two forms, either a value greater than or equal to 0,
     * or one of {@code DEFAULT_SIZE} or {@code PREFERRED_SIZE}. A
     * value greater than or equal to {@code 0} indicates a specific
     * size. {@code DEFAULT_SIZE} indicates the corresponding size
     * from the component should be used.  For example, if {@code
     * DEFAULT_SIZE} is passed as the minimum size argument, the
     * minimum size is obtained from invoking {@code getMinimumSize}
     * on the component. Likewise, {@code PREFERRED_SIZE} indicates
     * the value from {@code getPreferredSize} should be used.
     * The following example adds {@code myComponent} to {@code group}
     * with specific values for the range. That is, the minimum is
     * explicitly specified as 100, preferred as 200, and maximum as
     * 300.
     * &lt;pre&gt;
     *   group.addComponent(myComponent, 100, 200, 300);
     * &lt;/pre&gt;
     * The following example adds {@code myComponent} to {@code group} using
     * a combination of the forms. The minimum size is forced to be the
     * same as the preferred size, the preferred size is determined by
     * using {@code myComponent.getPreferredSize} and the maximum is
     * determined by invoking {@code getMaximumSize} on the component.
     * &lt;pre&gt;
     *   group.addComponent(myComponent, GroupLayout.PREFERRED_SIZE,
     *             GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Unless otherwise specified all the methods of {@code Group} and
     * its subclasses that allow you to specify a range throw an
     * {@code IllegalArgumentException} if passed an invalid range. An
     * invalid range is one in which any of the values are &amp;lt; 0 and
     * not one of {@code PREFERRED_SIZE} or {@code DEFAULT_SIZE}, or
     * the following is not met (for specific values): {@code min}
     * &amp;lt;= {@code pref} &amp;lt;= {@code max}.
     * &lt;p&gt;
     * Similarly any methods that take a {@code Component} throw a
     * {@code IllegalArgumentException} if passed {@code null} and any methods
     * that take a {@code Group} throw an {@code NullPointerException} if
     * passed {@code null}.
     *
     * @see #createSequentialGroup
     * @see #createParallelGroup
     * @since 1.6
     */
<span class="nc bnc" id="L1479" title="All 2 branches missed.">    public abstract class Group extends Spring {</span>
        // private int origin;
        // private int size;
        List&lt;Spring&gt; springs;

<span class="nc" id="L1484">        Group() {</span>
<span class="nc" id="L1485">            springs = new ArrayList&lt;Spring&gt;();</span>
<span class="nc" id="L1486">        }</span>

        /**
         * Adds a {@code Group} to this {@code Group}.
         *
         * @param group the {@code Group} to add
         * @return this {@code Group}
         */
        public Group addGroup(Group group) {
<span class="nc" id="L1495">            return addSpring(group);</span>
        }

        /**
         * Adds a {@code Component} to this {@code Group}.
         *
         * @param component the {@code Component} to add
         * @return this {@code Group}
         */
        public Group addComponent(Component component) {
<span class="nc" id="L1505">            return addComponent(component, DEFAULT_SIZE, DEFAULT_SIZE,</span>
                    DEFAULT_SIZE);
        }

        /**
         * Adds a {@code Component} to this {@code Group}
         * with the specified size.
         *
         * @param component the {@code Component} to add
         * @param min the minimum size or one of {@code DEFAULT_SIZE} or
         *            {@code PREFERRED_SIZE}
         * @param pref the preferred size or one of {@code DEFAULT_SIZE} or
         *            {@code PREFERRED_SIZE}
         * @param max the maximum size or one of {@code DEFAULT_SIZE} or
         *            {@code PREFERRED_SIZE}
         * @return this {@code Group}
         */
        public Group addComponent(Component component, int min, int pref,
                int max) {
<span class="nc" id="L1524">            return addSpring(new ComponentSpring(component, min, pref, max));</span>
        }

        /**
         * Adds a rigid gap to this {@code Group}.
         *
         * @param size the size of the gap
         * @return this {@code Group}
         * @throws IllegalArgumentException if {@code size} is less than
         *         {@code 0}
         */
        public Group addGap(int size) {
<span class="nc" id="L1536">            return addGap(size, size, size);</span>
        }

        /**
         * Adds a gap to this {@code Group} with the specified size.
         *
         * @param min the minimum size of the gap
         * @param pref the preferred size of the gap
         * @param max the maximum size of the gap
         * @throws IllegalArgumentException if any of the values are
         *         less than {@code 0}
         * @return this {@code Group}
         */
        public Group addGap(int min, int pref, int max) {
<span class="nc" id="L1550">            return addSpring(new GapSpring(min, pref, max));</span>
        }

        Spring getSpring(int index) {
<span class="nc" id="L1554">            return springs.get(index);</span>
        }

        int indexOf(Spring spring) {
<span class="nc" id="L1558">            return springs.indexOf(spring);</span>
        }

        /**
         * Adds the Spring to the list of {@code Spring}s and returns
         * the receiver.
         */
        Group addSpring(Spring spring) {
<span class="nc" id="L1566">            springs.add(spring);</span>
<span class="nc" id="L1567">            spring.setParent(this);</span>
<span class="nc bnc" id="L1568" title="All 2 branches missed.">            if (!(spring instanceof AutoPreferredGapSpring) ||</span>
<span class="nc bnc" id="L1569" title="All 2 branches missed.">                    !((AutoPreferredGapSpring)spring).getUserCreated()) {</span>
<span class="nc" id="L1570">                springsChanged = true;</span>
            }
<span class="nc" id="L1572">            return this;</span>
        }

        //
        // Spring methods
        //

        void setSize(int axis, int origin, int size) {
<span class="nc" id="L1580">            super.setSize(axis, origin, size);</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">            if (size == UNSET) {</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">                for (int counter = springs.size() - 1; counter &gt;= 0;</span>
<span class="nc" id="L1583">                counter--) {</span>
<span class="nc" id="L1584">                    getSpring(counter).setSize(axis, origin, size);</span>
                }
            } else {
<span class="nc" id="L1587">                setValidSize(axis, origin, size);</span>
            }
<span class="nc" id="L1589">        }</span>

        /**
         * This is invoked from {@code setSize} if passed a value
         * other than UNSET.
         */
        abstract void setValidSize(int axis, int origin, int size);

        int calculateMinimumSize(int axis) {
<span class="nc" id="L1598">            return calculateSize(axis, MIN_SIZE);</span>
        }

        int calculatePreferredSize(int axis) {
<span class="nc" id="L1602">            return calculateSize(axis, PREF_SIZE);</span>
        }

        int calculateMaximumSize(int axis) {
<span class="nc" id="L1606">            return calculateSize(axis, MAX_SIZE);</span>
        }

        /**
         * Calculates the specified size.  This is called from
         * one of the {@code getMinimumSize0},
         * {@code getPreferredSize0} or
         * {@code getMaximumSize0} methods.  This will invoke
         * to {@code operator} to combine the values.
         */
        int calculateSize(int axis, int type) {
<span class="nc" id="L1617">            int count = springs.size();</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">            if (count == 0) {</span>
<span class="nc" id="L1619">                return 0;</span>
            }
<span class="nc bnc" id="L1621" title="All 2 branches missed.">            if (count == 1) {</span>
<span class="nc" id="L1622">                return getSpringSize(getSpring(0), axis, type);</span>
            }
<span class="nc" id="L1624">            int size = constrain(operator(getSpringSize(getSpring(0), axis,</span>
<span class="nc" id="L1625">                    type), getSpringSize(getSpring(1), axis, type)));</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">            for (int counter = 2; counter &lt; count; counter++) {</span>
<span class="nc" id="L1627">                size = constrain(operator(size, getSpringSize(</span>
<span class="nc" id="L1628">                        getSpring(counter), axis, type)));</span>
            }
<span class="nc" id="L1630">            return size;</span>
        }

        int getSpringSize(Spring spring, int axis, int type) {
<span class="nc bnc" id="L1634" title="All 4 branches missed.">            switch(type) {</span>
                case MIN_SIZE:
<span class="nc" id="L1636">                    return spring.getMinimumSize(axis);</span>
                case PREF_SIZE:
<span class="nc" id="L1638">                    return spring.getPreferredSize(axis);</span>
                case MAX_SIZE:
<span class="nc" id="L1640">                    return spring.getMaximumSize(axis);</span>
            }
<span class="nc bnc" id="L1642" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L1643">            return 0;</span>
        }

        /**
         * Used to compute how the two values representing two springs
         * will be combined.  For example, a group that layed things out
         * one after the next would return {@code a + b}.
         */
        abstract int operator(int a, int b);

        //
        // Padding
        //

        /**
         * Adjusts the autopadding springs in this group and its children.
         * If {@code insert} is true this will insert auto padding
         * springs, otherwise this will only adjust the springs that
         * comprise auto preferred padding springs.
         *
         * @param axis the axis of the springs; HORIZONTAL or VERTICAL
         * @param leadingPadding List of AutopaddingSprings that occur before
         *                       this Group
         * @param trailingPadding any trailing autopadding springs are added
         *                        to this on exit
         * @param leading List of ComponentSprings that occur before this Group
         * @param trailing any trailing ComponentSpring are added to this
         *                 List
         * @param insert Whether or not to insert AutopaddingSprings or just
         *               adjust any existing AutopaddingSprings.
         */
        abstract void insertAutopadding(int axis,
                List&lt;AutoPreferredGapSpring&gt; leadingPadding,
                List&lt;AutoPreferredGapSpring&gt; trailingPadding,
                List&lt;ComponentSpring&gt; leading, List&lt;ComponentSpring&gt; trailing,
                boolean insert);

        /**
         * Removes any AutopaddingSprings for this Group and its children.
         */
        void removeAutopadding() {
<span class="nc" id="L1684">            unset();</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">            for (int counter = springs.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L1686">                Spring spring = springs.get(counter);</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">                if (spring instanceof AutoPreferredGapSpring) {</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">                    if (((AutoPreferredGapSpring)spring).getUserCreated()) {</span>
<span class="nc" id="L1689">                        ((AutoPreferredGapSpring)spring).reset();</span>
                    } else {
<span class="nc" id="L1691">                        springs.remove(counter);</span>
                    }
<span class="nc bnc" id="L1693" title="All 2 branches missed.">                } else if (spring instanceof Group) {</span>
<span class="nc" id="L1694">                    ((Group)spring).removeAutopadding();</span>
                }
            }
<span class="nc" id="L1697">        }</span>

        void unsetAutopadding() {
            // Clear cached pref/min/max.
<span class="nc" id="L1701">            unset();</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">            for (int counter = springs.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L1703">                Spring spring = springs.get(counter);</span>
<span class="nc bnc" id="L1704" title="All 2 branches missed.">                if (spring instanceof AutoPreferredGapSpring) {</span>
<span class="nc" id="L1705">                    spring.unset();</span>
<span class="nc bnc" id="L1706" title="All 2 branches missed.">                } else if (spring instanceof Group) {</span>
<span class="nc" id="L1707">                    ((Group)spring).unsetAutopadding();</span>
                }
            }
<span class="nc" id="L1710">        }</span>

        void calculateAutopadding(int axis) {
<span class="nc bnc" id="L1713" title="All 2 branches missed.">            for (int counter = springs.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L1714">                Spring spring = springs.get(counter);</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">                if (spring instanceof AutoPreferredGapSpring) {</span>
                    // Force size to be reset.
<span class="nc" id="L1717">                    spring.unset();</span>
<span class="nc" id="L1718">                    ((AutoPreferredGapSpring)spring).calculatePadding(axis);</span>
<span class="nc bnc" id="L1719" title="All 2 branches missed.">                } else if (spring instanceof Group) {</span>
<span class="nc" id="L1720">                    ((Group)spring).calculateAutopadding(axis);</span>
                }
            }
            // Clear cached pref/min/max.
<span class="nc" id="L1724">            unset();</span>
<span class="nc" id="L1725">        }</span>

        @Override
        boolean willHaveZeroSize(boolean treatAutopaddingAsZeroSized) {
<span class="nc bnc" id="L1729" title="All 2 branches missed.">            for (int i = springs.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L1730">                Spring spring = springs.get(i);</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">                if (!spring.willHaveZeroSize(treatAutopaddingAsZeroSized)) {</span>
<span class="nc" id="L1732">                    return false;</span>
                }
            }
<span class="nc" id="L1735">            return true;</span>
        }
    }


    /**
     * A {@code Group} that positions and sizes its elements
     * sequentially, one after another.  This class has no public
     * constructor, use the {@code createSequentialGroup} method
     * to create one.
     * &lt;p&gt;
     * In order to align a {@code SequentialGroup} along the baseline
     * of a baseline aligned {@code ParallelGroup} you need to specify
     * which of the elements of the {@code SequentialGroup} is used to
     * determine the baseline.  The element used to calculate the
     * baseline is specified using one of the {@code add} methods that
     * take a {@code boolean}. The last element added with a value of
     * {@code true} for {@code useAsBaseline} is used to calculate the
     * baseline.
     *
     * @see #createSequentialGroup
     * @since 1.6
     */
<span class="nc bnc" id="L1758" title="All 2 branches missed.">    public class SequentialGroup extends Group {</span>
        private Spring baselineSpring;

<span class="nc" id="L1761">        SequentialGroup() {</span>
<span class="nc" id="L1762">        }</span>

        /**
         * {@inheritDoc}
         */
        public SequentialGroup addGroup(Group group) {
<span class="nc" id="L1768">            return (SequentialGroup)super.addGroup(group);</span>
        }

        /**
         * Adds a {@code Group} to this {@code Group}.
         *
         * @param group the {@code Group} to add
         * @param useAsBaseline whether the specified {@code Group} should
         *        be used to calculate the baseline for this {@code Group}
         * @return this {@code Group}
         */
        public SequentialGroup addGroup(boolean useAsBaseline, Group group) {
<span class="nc" id="L1780">            super.addGroup(group);</span>
<span class="nc bnc" id="L1781" title="All 2 branches missed.">            if (useAsBaseline) {</span>
<span class="nc" id="L1782">                baselineSpring = group;</span>
            }
<span class="nc" id="L1784">            return this;</span>
        }

        /**
         * {@inheritDoc}
         */
        public SequentialGroup addComponent(Component component) {
<span class="nc" id="L1791">            return (SequentialGroup)super.addComponent(component);</span>
        }

        /**
         * Adds a {@code Component} to this {@code Group}.
         *
         * @param useAsBaseline whether the specified {@code Component} should
         *        be used to calculate the baseline for this {@code Group}
         * @param component the {@code Component} to add
         * @return this {@code Group}
         */
        public SequentialGroup addComponent(boolean useAsBaseline,
                Component component) {
<span class="nc" id="L1804">            super.addComponent(component);</span>
<span class="nc bnc" id="L1805" title="All 2 branches missed.">            if (useAsBaseline) {</span>
<span class="nc" id="L1806">                baselineSpring = springs.get(springs.size() - 1);</span>
            }
<span class="nc" id="L1808">            return this;</span>
        }

        /**
         * {@inheritDoc}
         */
        public SequentialGroup addComponent(Component component, int min,
                int pref, int max) {
<span class="nc" id="L1816">            return (SequentialGroup)super.addComponent(</span>
                    component, min, pref, max);
        }

        /**
         * Adds a {@code Component} to this {@code Group}
         * with the specified size.
         *
         * @param useAsBaseline whether the specified {@code Component} should
         *        be used to calculate the baseline for this {@code Group}
         * @param component the {@code Component} to add
         * @param min the minimum size or one of {@code DEFAULT_SIZE} or
         *            {@code PREFERRED_SIZE}
         * @param pref the preferred size or one of {@code DEFAULT_SIZE} or
         *            {@code PREFERRED_SIZE}
         * @param max the maximum size or one of {@code DEFAULT_SIZE} or
         *            {@code PREFERRED_SIZE}
         * @return this {@code Group}
         */
        public SequentialGroup addComponent(boolean useAsBaseline,
                Component component, int min, int pref, int max) {
<span class="nc" id="L1837">            super.addComponent(component, min, pref, max);</span>
<span class="nc bnc" id="L1838" title="All 2 branches missed.">            if (useAsBaseline) {</span>
<span class="nc" id="L1839">                baselineSpring = springs.get(springs.size() - 1);</span>
            }
<span class="nc" id="L1841">            return this;</span>
        }

        /**
         * {@inheritDoc}
         */
        public SequentialGroup addGap(int size) {
<span class="nc" id="L1848">            return (SequentialGroup)super.addGap(size);</span>
        }

        /**
         * {@inheritDoc}
         */
        public SequentialGroup addGap(int min, int pref, int max) {
<span class="nc" id="L1855">            return (SequentialGroup)super.addGap(min, pref, max);</span>
        }

        /**
         * Adds an element representing the preferred gap between two
         * components. The element created to represent the gap is not
         * resizable.
         *
         * @param comp1 the first component
         * @param comp2 the second component
         * @param type the type of gap; one of the constants defined by
         *        {@code LayoutStyle}
         * @return this {@code SequentialGroup}
         * @throws IllegalArgumentException if {@code type}, {@code comp1} or
         *         {@code comp2} is {@code null}
         * @see LayoutStyle
         */
        public SequentialGroup addPreferredGap(JComponent comp1,
                JComponent comp2, ComponentPlacement type) {
<span class="nc" id="L1874">            return addPreferredGap(comp1, comp2, type, DEFAULT_SIZE,</span>
                    PREFERRED_SIZE);
        }

        /**
         * Adds an element representing the preferred gap between two
         * components.
         *
         * @param comp1 the first component
         * @param comp2 the second component
         * @param type the type of gap
         * @param pref the preferred size of the grap; one of
         *        {@code DEFAULT_SIZE} or a value &amp;gt;= 0
         * @param max the maximum size of the gap; one of
         *        {@code DEFAULT_SIZE}, {@code PREFERRED_SIZE}
         *        or a value &amp;gt;= 0
         * @return this {@code SequentialGroup}
         * @throws IllegalArgumentException if {@code type}, {@code comp1} or
         *         {@code comp2} is {@code null}
         * @see LayoutStyle
         */
        public SequentialGroup addPreferredGap(JComponent comp1,
                JComponent comp2, ComponentPlacement type, int pref,
                int max) {
<span class="nc bnc" id="L1898" title="All 2 branches missed.">            if (type == null) {</span>
<span class="nc" id="L1899">                throw new IllegalArgumentException(&quot;Type must be non-null&quot;);</span>
            }
<span class="nc bnc" id="L1901" title="All 4 branches missed.">            if (comp1 == null || comp2 == null) {</span>
<span class="nc" id="L1902">                throw new IllegalArgumentException(</span>
                        &quot;Components must be non-null&quot;);
            }
<span class="nc" id="L1905">            checkPreferredGapValues(pref, max);</span>
<span class="nc" id="L1906">            return (SequentialGroup)addSpring(new PreferredGapSpring(</span>
                    comp1, comp2, type, pref, max));
        }

        /**
         * Adds an element representing the preferred gap between the
         * nearest components.  During layout, neighboring
         * components are found, and the size of the added gap is set
         * based on the preferred gap between the components.  If no
         * neighboring components are found the gap has a size of {@code 0}.
         * &lt;p&gt;
         * The element created to represent the gap is not
         * resizable.
         *
         * @param type the type of gap; one of
         *        {@code LayoutStyle.ComponentPlacement.RELATED} or
         *        {@code LayoutStyle.ComponentPlacement.UNRELATED}
         * @return this {@code SequentialGroup}
         * @see LayoutStyle
         * @throws IllegalArgumentException if {@code type} is not one of
         *         {@code LayoutStyle.ComponentPlacement.RELATED} or
         *         {@code LayoutStyle.ComponentPlacement.UNRELATED}
         */
        public SequentialGroup addPreferredGap(ComponentPlacement type) {
<span class="nc" id="L1930">            return addPreferredGap(type, DEFAULT_SIZE, DEFAULT_SIZE);</span>
        }

        /**
         * Adds an element representing the preferred gap between the
         * nearest components.  During layout, neighboring
         * components are found, and the minimum of this
         * gap is set based on the size of the preferred gap between the
         * neighboring components.  If no neighboring components are found the
         * minimum size is set to 0.
         *
         * @param type the type of gap; one of
         *        {@code LayoutStyle.ComponentPlacement.RELATED} or
         *        {@code LayoutStyle.ComponentPlacement.UNRELATED}
         * @param pref the preferred size of the grap; one of
         *        {@code DEFAULT_SIZE} or a value &amp;gt;= 0
         * @param max the maximum size of the gap; one of
         *        {@code DEFAULT_SIZE}, {@code PREFERRED_SIZE}
         *        or a value &amp;gt;= 0
         * @return this {@code SequentialGroup}
         * @throws IllegalArgumentException if {@code type} is not one of
         *         {@code LayoutStyle.ComponentPlacement.RELATED} or
         *         {@code LayoutStyle.ComponentPlacement.UNRELATED}
         * @see LayoutStyle
         */
        public SequentialGroup addPreferredGap(ComponentPlacement type,
                int pref, int max) {
<span class="nc bnc" id="L1957" title="All 4 branches missed.">            if (type != ComponentPlacement.RELATED &amp;&amp;</span>
                    type != ComponentPlacement.UNRELATED) {
<span class="nc" id="L1959">                throw new IllegalArgumentException(</span>
                        &quot;Type must be one of &quot; +
                        &quot;LayoutStyle.ComponentPlacement.RELATED or &quot; +
                        &quot;LayoutStyle.ComponentPlacement.UNRELATED&quot;);
            }
<span class="nc" id="L1964">            checkPreferredGapValues(pref, max);</span>
<span class="nc" id="L1965">            hasPreferredPaddingSprings = true;</span>
<span class="nc" id="L1966">            return (SequentialGroup)addSpring(new AutoPreferredGapSpring(</span>
                    type, pref, max));
        }

        /**
         * Adds an element representing the preferred gap between an edge
         * the container and components that touch the border of the
         * container. This has no effect if the added gap does not
         * touch an edge of the parent container.
         * &lt;p&gt;
         * The element created to represent the gap is not
         * resizable.
         *
         * @return this {@code SequentialGroup}
         */
        public SequentialGroup addContainerGap() {
<span class="nc" id="L1982">            return addContainerGap(DEFAULT_SIZE, DEFAULT_SIZE);</span>
        }

        /**
         * Adds an element representing the preferred gap between one
         * edge of the container and the next or previous {@code
         * Component} with the specified size. This has no
         * effect if the next or previous element is not a {@code
         * Component} and does not touch one edge of the parent
         * container.
         *
         * @param pref the preferred size; one of {@code DEFAULT_SIZE} or a
         *              value &amp;gt;= 0
         * @param max the maximum size; one of {@code DEFAULT_SIZE},
         *        {@code PREFERRED_SIZE} or a value &amp;gt;= 0
         * @return this {@code SequentialGroup}
         */
        public SequentialGroup addContainerGap(int pref, int max) {
<span class="nc bnc" id="L2000" title="All 16 branches missed.">            if ((pref &lt; 0 &amp;&amp; pref != DEFAULT_SIZE) ||</span>
                    (max &lt; 0 &amp;&amp; max != DEFAULT_SIZE &amp;&amp; max != PREFERRED_SIZE)||
                    (pref &gt;= 0 &amp;&amp; max &gt;= 0 &amp;&amp; pref &gt; max)) {
<span class="nc" id="L2003">                throw new IllegalArgumentException(</span>
                        &quot;Pref and max must be either DEFAULT_VALUE &quot; +
                        &quot;or &gt;= 0 and pref &lt;= max&quot;);
            }
<span class="nc" id="L2007">            hasPreferredPaddingSprings = true;</span>
<span class="nc" id="L2008">            return (SequentialGroup)addSpring(</span>
                    new ContainerAutoPreferredGapSpring(pref, max));
        }

        int operator(int a, int b) {
<span class="nc" id="L2013">            return constrain(a) + constrain(b);</span>
        }

        void setValidSize(int axis, int origin, int size) {
<span class="nc" id="L2017">            int pref = getPreferredSize(axis);</span>
<span class="nc bnc" id="L2018" title="All 2 branches missed.">            if (size == pref) {</span>
                // Layout at preferred size
<span class="nc bnc" id="L2020" title="All 2 branches missed.">                for (Spring spring : springs) {</span>
<span class="nc" id="L2021">                    int springPref = spring.getPreferredSize(axis);</span>
<span class="nc" id="L2022">                    spring.setSize(axis, origin, springPref);</span>
<span class="nc" id="L2023">                    origin += springPref;</span>
<span class="nc" id="L2024">                }</span>
<span class="nc bnc" id="L2025" title="All 2 branches missed.">            } else if (springs.size() == 1) {</span>
<span class="nc" id="L2026">                Spring spring = getSpring(0);</span>
<span class="nc" id="L2027">                spring.setSize(axis, origin, Math.min(</span>
<span class="nc" id="L2028">                        Math.max(size, spring.getMinimumSize(axis)),</span>
<span class="nc" id="L2029">                        spring.getMaximumSize(axis)));</span>
<span class="nc bnc" id="L2030" title="All 2 branches missed.">            } else if (springs.size() &gt; 1) {</span>
                // Adjust between min/pref
<span class="nc" id="L2032">                setValidSizeNotPreferred(axis, origin, size);</span>
            }
<span class="nc" id="L2034">        }</span>

        private void setValidSizeNotPreferred(int axis, int origin, int size) {
<span class="nc" id="L2037">            int delta = size - getPreferredSize(axis);</span>
<span class="nc bnc" id="L2038" title="All 4 branches missed.">            assert delta != 0;</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">            boolean useMin = (delta &lt; 0);</span>
<span class="nc" id="L2040">            int springCount = springs.size();</span>
<span class="nc bnc" id="L2041" title="All 2 branches missed.">            if (useMin) {</span>
<span class="nc" id="L2042">                delta *= -1;</span>
            }

            // The following algorithm if used for resizing springs:
            // 1. Calculate the resizability of each spring (pref - min or
            //    max - pref) into a list.
            // 2. Sort the list in ascending order
            // 3. Iterate through each of the resizable Springs, attempting
            //    to give them (pref - size) / resizeCount
            // 4. For any Springs that can not accommodate that much space
            //    add the remainder back to the amount to distribute and
            //    recalculate how must space the remaining springs will get.
            // 5. Set the size of the springs.

            // First pass, sort the resizable springs into the List resizable
<span class="nc" id="L2057">            List&lt;SpringDelta&gt; resizable = buildResizableList(axis, useMin);</span>
<span class="nc" id="L2058">            int resizableCount = resizable.size();</span>

<span class="nc bnc" id="L2060" title="All 2 branches missed.">            if (resizableCount &gt; 0) {</span>
                // How much we would like to give each Spring.
<span class="nc" id="L2062">                int sDelta = delta / resizableCount;</span>
                // Remaining space.
<span class="nc" id="L2064">                int slop = delta - sDelta * resizableCount;</span>
<span class="nc" id="L2065">                int[] sizes = new int[springCount];</span>
<span class="nc bnc" id="L2066" title="All 2 branches missed.">                int sign = useMin ? -1 : 1;</span>
                // Second pass, accumulate the resulting deltas (relative to
                // preferred) into sizes.
<span class="nc bnc" id="L2069" title="All 2 branches missed.">                for (int counter = 0; counter &lt; resizableCount; counter++) {</span>
<span class="nc" id="L2070">                    SpringDelta springDelta = resizable.get(counter);</span>
<span class="nc bnc" id="L2071" title="All 2 branches missed.">                    if ((counter + 1) == resizableCount) {</span>
<span class="nc" id="L2072">                        sDelta += slop;</span>
                    }
<span class="nc" id="L2074">                    springDelta.delta = Math.min(sDelta, springDelta.delta);</span>
<span class="nc" id="L2075">                    delta -= springDelta.delta;</span>
<span class="nc bnc" id="L2076" title="All 4 branches missed.">                    if (springDelta.delta != sDelta &amp;&amp; counter + 1 &lt;</span>
                            resizableCount) {
                        // Spring didn't take all the space, reset how much
                        // each spring will get.
<span class="nc" id="L2080">                        sDelta = delta / (resizableCount - counter - 1);</span>
<span class="nc" id="L2081">                        slop = delta - sDelta * (resizableCount - counter - 1);</span>
                    }
<span class="nc" id="L2083">                    sizes[springDelta.index] = sign * springDelta.delta;</span>
                }

                // And finally set the size of each spring
<span class="nc bnc" id="L2087" title="All 2 branches missed.">                for (int counter = 0; counter &lt; springCount; counter++) {</span>
<span class="nc" id="L2088">                    Spring spring = getSpring(counter);</span>
<span class="nc" id="L2089">                    int sSize = spring.getPreferredSize(axis) + sizes[counter];</span>
<span class="nc" id="L2090">                    spring.setSize(axis, origin, sSize);</span>
<span class="nc" id="L2091">                    origin += sSize;</span>
                }
<span class="nc" id="L2093">            } else {</span>
                // Nothing resizable, use the min or max of each of the
                // springs.
<span class="nc bnc" id="L2096" title="All 2 branches missed.">                for (int counter = 0; counter &lt; springCount; counter++) {</span>
<span class="nc" id="L2097">                    Spring spring = getSpring(counter);</span>
                    int sSize;
<span class="nc bnc" id="L2099" title="All 2 branches missed.">                    if (useMin) {</span>
<span class="nc" id="L2100">                        sSize = spring.getMinimumSize(axis);</span>
                    } else {
<span class="nc" id="L2102">                        sSize = spring.getMaximumSize(axis);</span>
                    }
<span class="nc" id="L2104">                    spring.setSize(axis, origin, sSize);</span>
<span class="nc" id="L2105">                    origin += sSize;</span>
                }
            }
<span class="nc" id="L2108">        }</span>

        /**
         * Returns the sorted list of SpringDelta's for the current set of
         * Springs. The list is ordered based on the amount of flexibility of
         * the springs.
         */
        private List&lt;SpringDelta&gt; buildResizableList(int axis,
                boolean useMin) {
            // First pass, figure out what is resizable
<span class="nc" id="L2118">            int size = springs.size();</span>
<span class="nc" id="L2119">            List&lt;SpringDelta&gt; sorted = new ArrayList&lt;SpringDelta&gt;(size);</span>
<span class="nc bnc" id="L2120" title="All 2 branches missed.">            for (int counter = 0; counter &lt; size; counter++) {</span>
<span class="nc" id="L2121">                Spring spring = getSpring(counter);</span>
                int sDelta;
<span class="nc bnc" id="L2123" title="All 2 branches missed.">                if (useMin) {</span>
<span class="nc" id="L2124">                    sDelta = spring.getPreferredSize(axis) -</span>
<span class="nc" id="L2125">                            spring.getMinimumSize(axis);</span>
                } else {
<span class="nc" id="L2127">                    sDelta = spring.getMaximumSize(axis) -</span>
<span class="nc" id="L2128">                            spring.getPreferredSize(axis);</span>
                }
<span class="nc bnc" id="L2130" title="All 2 branches missed.">                if (sDelta &gt; 0) {</span>
<span class="nc" id="L2131">                    sorted.add(new SpringDelta(counter, sDelta));</span>
                }
            }
<span class="nc" id="L2134">            Collections.sort(sorted);</span>
<span class="nc" id="L2135">            return sorted;</span>
        }

        private int indexOfNextNonZeroSpring(
                int index, boolean treatAutopaddingAsZeroSized) {
<span class="nc bnc" id="L2140" title="All 2 branches missed.">            while (index &lt; springs.size()) {</span>
<span class="nc" id="L2141">                Spring spring = springs.get(index);</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">                if (!spring.willHaveZeroSize(treatAutopaddingAsZeroSized)) {</span>
<span class="nc" id="L2143">                    return index;</span>
                }
<span class="nc" id="L2145">                index++;</span>
<span class="nc" id="L2146">            }</span>
<span class="nc" id="L2147">            return index;</span>
        }

        @Override
        void insertAutopadding(int axis,
                List&lt;AutoPreferredGapSpring&gt; leadingPadding,
                List&lt;AutoPreferredGapSpring&gt; trailingPadding,
                List&lt;ComponentSpring&gt; leading, List&lt;ComponentSpring&gt; trailing,
                boolean insert) {
<span class="nc" id="L2156">            List&lt;AutoPreferredGapSpring&gt; newLeadingPadding =</span>
                    new ArrayList&lt;AutoPreferredGapSpring&gt;(leadingPadding);
<span class="nc" id="L2158">            List&lt;AutoPreferredGapSpring&gt; newTrailingPadding =</span>
                    new ArrayList&lt;AutoPreferredGapSpring&gt;(1);
<span class="nc" id="L2160">            List&lt;ComponentSpring&gt; newLeading =</span>
                    new ArrayList&lt;ComponentSpring&gt;(leading);
<span class="nc" id="L2162">            List&lt;ComponentSpring&gt; newTrailing = null;</span>
<span class="nc" id="L2163">            int counter = 0;</span>
            // Warning, this must use springs.size, as it may change during the
            // loop.
<span class="nc bnc" id="L2166" title="All 2 branches missed.">            while (counter &lt; springs.size()) {</span>
<span class="nc" id="L2167">                Spring spring = getSpring(counter);</span>
<span class="nc bnc" id="L2168" title="All 2 branches missed.">                if (spring instanceof AutoPreferredGapSpring) {</span>
<span class="nc bnc" id="L2169" title="All 2 branches missed.">                    if (newLeadingPadding.size() == 0) {</span>
                        // Autopadding spring. Set the sources of the
                        // autopadding spring based on newLeading.
<span class="nc" id="L2172">                        AutoPreferredGapSpring padding =</span>
                            (AutoPreferredGapSpring)spring;
<span class="nc" id="L2174">                        padding.setSources(newLeading);</span>
<span class="nc" id="L2175">                        newLeading.clear();</span>
<span class="nc" id="L2176">                        counter = indexOfNextNonZeroSpring(counter + 1, true);</span>
<span class="nc bnc" id="L2177" title="All 2 branches missed.">                        if (counter == springs.size()) {</span>
                            // Last spring in the list, add it to
                            // trailingPadding.
<span class="nc bnc" id="L2180" title="All 2 branches missed.">                            if (!(padding instanceof</span>
                                  ContainerAutoPreferredGapSpring)) {
<span class="nc" id="L2182">                                trailingPadding.add(padding);</span>
                            }
                        } else {
<span class="nc" id="L2185">                            newLeadingPadding.clear();</span>
<span class="nc" id="L2186">                            newLeadingPadding.add(padding);</span>
                        }
<span class="nc" id="L2188">                    } else {</span>
<span class="nc" id="L2189">                        counter = indexOfNextNonZeroSpring(counter + 1, true);</span>
                    }
                } else {
                    // Not a padding spring
<span class="nc bnc" id="L2193" title="All 4 branches missed.">                    if (newLeading.size() &gt; 0 &amp;&amp; insert) {</span>
                        // There's leading ComponentSprings, create an
                        // autopadding spring.
<span class="nc" id="L2196">                        AutoPreferredGapSpring padding =</span>
                                new AutoPreferredGapSpring();
                        // Force the newly created spring to be considered
                        // by NOT incrementing counter
<span class="nc" id="L2200">                        springs.add(counter, padding);</span>
<span class="nc" id="L2201">                        continue;</span>
                    }
<span class="nc bnc" id="L2203" title="All 2 branches missed.">                    if (spring instanceof ComponentSpring) {</span>
                        // Spring is a Component, make it the target of any
                        // leading AutopaddingSpring.
<span class="nc" id="L2206">                        ComponentSpring cSpring = (ComponentSpring)spring;</span>
<span class="nc bnc" id="L2207" title="All 2 branches missed.">                        if (!cSpring.isVisible()) {</span>
<span class="nc" id="L2208">                            counter++;</span>
<span class="nc" id="L2209">                            continue;</span>
                        }
<span class="nc bnc" id="L2211" title="All 2 branches missed.">                        for (AutoPreferredGapSpring gapSpring : newLeadingPadding) {</span>
<span class="nc" id="L2212">                            gapSpring.addTarget(cSpring, axis);</span>
<span class="nc" id="L2213">                        }</span>
<span class="nc" id="L2214">                        newLeading.clear();</span>
<span class="nc" id="L2215">                        newLeadingPadding.clear();</span>
<span class="nc" id="L2216">                        counter = indexOfNextNonZeroSpring(counter + 1, false);</span>
<span class="nc bnc" id="L2217" title="All 2 branches missed.">                        if (counter == springs.size()) {</span>
                            // Last Spring, add it to trailing
<span class="nc" id="L2219">                            trailing.add(cSpring);</span>
                        } else {
                            // Not that last Spring, add it to leading
<span class="nc" id="L2222">                            newLeading.add(cSpring);</span>
                        }
<span class="nc bnc" id="L2224" title="All 2 branches missed.">                    } else if (spring instanceof Group) {</span>
                        // Forward call to child Group
<span class="nc bnc" id="L2226" title="All 2 branches missed.">                        if (newTrailing == null) {</span>
<span class="nc" id="L2227">                            newTrailing = new ArrayList&lt;ComponentSpring&gt;(1);</span>
                        } else {
<span class="nc" id="L2229">                            newTrailing.clear();</span>
                        }
<span class="nc" id="L2231">                        newTrailingPadding.clear();</span>
<span class="nc" id="L2232">                        ((Group)spring).insertAutopadding(axis,</span>
                                newLeadingPadding, newTrailingPadding,
                                newLeading, newTrailing, insert);
<span class="nc" id="L2235">                        newLeading.clear();</span>
<span class="nc" id="L2236">                        newLeadingPadding.clear();</span>
<span class="nc" id="L2237">                        counter = indexOfNextNonZeroSpring(</span>
<span class="nc bnc" id="L2238" title="All 2 branches missed.">                                    counter + 1, (newTrailing.size() == 0));</span>
<span class="nc bnc" id="L2239" title="All 2 branches missed.">                        if (counter == springs.size()) {</span>
<span class="nc" id="L2240">                            trailing.addAll(newTrailing);</span>
<span class="nc" id="L2241">                            trailingPadding.addAll(newTrailingPadding);</span>
                        } else {
<span class="nc" id="L2243">                            newLeading.addAll(newTrailing);</span>
<span class="nc" id="L2244">                            newLeadingPadding.addAll(newTrailingPadding);</span>
                        }
                    } else {
                        // Gap
<span class="nc" id="L2248">                        newLeadingPadding.clear();</span>
<span class="nc" id="L2249">                        newLeading.clear();</span>
<span class="nc" id="L2250">                        counter++;</span>
                    }
                }
<span class="nc" id="L2253">            }</span>
<span class="nc" id="L2254">        }</span>

        int getBaseline() {
<span class="nc bnc" id="L2257" title="All 2 branches missed.">            if (baselineSpring != null) {</span>
<span class="nc" id="L2258">                int baseline = baselineSpring.getBaseline();</span>
<span class="nc bnc" id="L2259" title="All 2 branches missed.">                if (baseline &gt;= 0) {</span>
<span class="nc" id="L2260">                    int size = 0;</span>
<span class="nc bnc" id="L2261" title="All 2 branches missed.">                    for (Spring spring : springs) {</span>
<span class="nc bnc" id="L2262" title="All 2 branches missed.">                        if (spring == baselineSpring) {</span>
<span class="nc" id="L2263">                            return size + baseline;</span>
                        } else {
<span class="nc" id="L2265">                            size += spring.getPreferredSize(VERTICAL);</span>
                        }
<span class="nc" id="L2267">                    }</span>
                }
            }
<span class="nc" id="L2270">            return -1;</span>
        }

        BaselineResizeBehavior getBaselineResizeBehavior() {
<span class="nc bnc" id="L2274" title="All 2 branches missed.">            if (isResizable(VERTICAL)) {</span>
<span class="nc bnc" id="L2275" title="All 2 branches missed.">                if (!baselineSpring.isResizable(VERTICAL)) {</span>
                    // Spring to use for baseline isn't resizable. In this case
                    // baseline resize behavior can be determined based on how
                    // preceding springs resize.
<span class="nc" id="L2279">                    boolean leadingResizable = false;</span>
<span class="nc bnc" id="L2280" title="All 2 branches missed.">                    for (Spring spring : springs) {</span>
<span class="nc bnc" id="L2281" title="All 2 branches missed.">                        if (spring == baselineSpring) {</span>
<span class="nc" id="L2282">                            break;</span>
<span class="nc bnc" id="L2283" title="All 2 branches missed.">                        } else if (spring.isResizable(VERTICAL)) {</span>
<span class="nc" id="L2284">                            leadingResizable = true;</span>
<span class="nc" id="L2285">                            break;</span>
                        }
<span class="nc" id="L2287">                    }</span>
<span class="nc" id="L2288">                    boolean trailingResizable = false;</span>
<span class="nc bnc" id="L2289" title="All 2 branches missed.">                    for (int i = springs.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L2290">                        Spring spring = springs.get(i);</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">                        if (spring == baselineSpring) {</span>
<span class="nc" id="L2292">                            break;</span>
                        }
<span class="nc bnc" id="L2294" title="All 2 branches missed.">                        if (spring.isResizable(VERTICAL)) {</span>
<span class="nc" id="L2295">                            trailingResizable = true;</span>
<span class="nc" id="L2296">                            break;</span>
                        }
                    }
<span class="nc bnc" id="L2299" title="All 4 branches missed.">                    if (leadingResizable &amp;&amp; !trailingResizable) {</span>
<span class="nc" id="L2300">                        return BaselineResizeBehavior.CONSTANT_DESCENT;</span>
<span class="nc bnc" id="L2301" title="All 4 branches missed.">                    } else if (!leadingResizable &amp;&amp; trailingResizable) {</span>
<span class="nc" id="L2302">                        return BaselineResizeBehavior.CONSTANT_ASCENT;</span>
                    }
                    // If we get here, both leading and trailing springs are
                    // resizable. Fall through to OTHER.
<span class="nc" id="L2306">                } else {</span>
<span class="nc" id="L2307">                    BaselineResizeBehavior brb = baselineSpring.getBaselineResizeBehavior();</span>
<span class="nc bnc" id="L2308" title="All 2 branches missed.">                    if (brb == BaselineResizeBehavior.CONSTANT_ASCENT) {</span>
<span class="nc bnc" id="L2309" title="All 2 branches missed.">                        for (Spring spring : springs) {</span>
<span class="nc bnc" id="L2310" title="All 2 branches missed.">                            if (spring == baselineSpring) {</span>
<span class="nc" id="L2311">                                return BaselineResizeBehavior.CONSTANT_ASCENT;</span>
                            }
<span class="nc bnc" id="L2313" title="All 2 branches missed.">                            if (spring.isResizable(VERTICAL)) {</span>
<span class="nc" id="L2314">                                return BaselineResizeBehavior.OTHER;</span>
                            }
<span class="nc" id="L2316">                        }</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">                    } else if (brb == BaselineResizeBehavior.CONSTANT_DESCENT) {</span>
<span class="nc bnc" id="L2318" title="All 2 branches missed.">                        for (int i = springs.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L2319">                            Spring spring = springs.get(i);</span>
<span class="nc bnc" id="L2320" title="All 2 branches missed.">                            if (spring == baselineSpring) {</span>
<span class="nc" id="L2321">                                return BaselineResizeBehavior.CONSTANT_DESCENT;</span>
                            }
<span class="nc bnc" id="L2323" title="All 2 branches missed.">                            if (spring.isResizable(VERTICAL)) {</span>
<span class="nc" id="L2324">                                return BaselineResizeBehavior.OTHER;</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2329">                return BaselineResizeBehavior.OTHER;</span>
            }
            // Not resizable, treat as constant_ascent
<span class="nc" id="L2332">            return BaselineResizeBehavior.CONSTANT_ASCENT;</span>
        }

        private void checkPreferredGapValues(int pref, int max) {
<span class="nc bnc" id="L2336" title="All 18 branches missed.">            if ((pref &lt; 0 &amp;&amp; pref != DEFAULT_SIZE &amp;&amp; pref != PREFERRED_SIZE) ||</span>
                    (max &lt; 0 &amp;&amp; max != DEFAULT_SIZE &amp;&amp; max != PREFERRED_SIZE)||
                    (pref &gt;= 0 &amp;&amp; max &gt;= 0 &amp;&amp; pref &gt; max)) {
<span class="nc" id="L2339">                throw new IllegalArgumentException(</span>
                        &quot;Pref and max must be either DEFAULT_SIZE, &quot; +
                        &quot;PREFERRED_SIZE, or &gt;= 0 and pref &lt;= max&quot;);
            }
<span class="nc" id="L2343">        }</span>
    }


    /**
     * Used by SequentialGroup in calculating resizability of springs.
     */
    private static final class SpringDelta implements Comparable&lt;SpringDelta&gt; {
        // Original index.
        public final int index;
        // Delta, one of pref - min or max - pref.
        public int delta;

<span class="nc" id="L2356">        public SpringDelta(int index, int delta) {</span>
<span class="nc" id="L2357">            this.index = index;</span>
<span class="nc" id="L2358">            this.delta = delta;</span>
<span class="nc" id="L2359">        }</span>

        public int compareTo(SpringDelta o) {
<span class="nc" id="L2362">            return delta - o.delta;</span>
        }

        public String toString() {
<span class="nc" id="L2366">            return super.toString() + &quot;[index=&quot; + index + &quot;, delta=&quot; +</span>
                    delta + &quot;]&quot;;
        }
    }


    /**
     * A {@code Group} that aligns and sizes it's children.
     * {@code ParallelGroup} aligns it's children in
     * four possible ways: along the baseline, centered, anchored to the
     * leading edge, or anchored to the trailing edge.
     * &lt;h3&gt;Baseline&lt;/h3&gt;
     * A {@code ParallelGroup} that aligns it's children along the
     * baseline must first decide where the baseline is
     * anchored. The baseline can either be anchored to the top, or
     * anchored to the bottom of the group. That is, the distance between the
     * baseline and the beginning of the group can be a constant
     * distance, or the distance between the end of the group and the
     * baseline can be a constant distance. The possible choices
     * correspond to the {@code BaselineResizeBehavior} constants
     * {@link
     * java.awt.Component.BaselineResizeBehavior#CONSTANT_ASCENT CONSTANT_ASCENT} and
     * {@link
     * java.awt.Component.BaselineResizeBehavior#CONSTANT_DESCENT CONSTANT_DESCENT}.
     * &lt;p&gt;
     * The baseline anchor may be explicitly specified by the
     * {@code createBaselineGroup} method, or determined based on the elements.
     * If not explicitly specified, the baseline will be anchored to
     * the bottom if all the elements with a baseline, and that are
     * aligned to the baseline, have a baseline resize behavior of
     * {@code CONSTANT_DESCENT}; otherwise the baseline is anchored to the top
     * of the group.
     * &lt;p&gt;
     * Elements aligned to the baseline are resizable if they have have
     * a baseline resize behavior of {@code CONSTANT_ASCENT} or
     * {@code CONSTANT_DESCENT}. Elements with a baseline resize
     * behavior of {@code OTHER} or {@code CENTER_OFFSET} are not resizable.
     * &lt;p&gt;
     * The baseline is calculated based on the preferred height of each
     * of the elements that have a baseline. The baseline is
     * calculated using the following algorithm:
     * {@code max(maxNonBaselineHeight, maxAscent + maxDescent)}, where the
     * {@code maxNonBaselineHeight} is the maximum height of all elements
     * that do not have a baseline, or are not aligned along the baseline.
     * {@code maxAscent} is the maximum ascent (baseline) of all elements that
     * have a baseline and are aligned along the baseline.
     * {@code maxDescent} is the maximum descent (preferred height - baseline)
     * of all elements that have a baseline and are aligned along the baseline.
     * &lt;p&gt;
     * A {@code ParallelGroup} that aligns it's elements along the baseline
     * is only useful along the vertical axis. If you create a
     * baseline group and use it along the horizontal axis an
     * {@code IllegalStateException} is thrown when you ask
     * {@code GroupLayout} for the minimum, preferred or maximum size or
     * attempt to layout the components.
     * &lt;p&gt;
     * Elements that are not aligned to the baseline and smaller than the size
     * of the {@code ParallelGroup} are positioned in one of three
     * ways: centered, anchored to the leading edge, or anchored to the
     * trailing edge.
     *
     * &lt;h3&gt;Non-baseline {@code ParallelGroup}&lt;/h3&gt;
     * {@code ParallelGroup}s created with an alignment other than
     * {@code BASELINE} align elements that are smaller than the size
     * of the group in one of three ways: centered, anchored to the
     * leading edge, or anchored to the trailing edge.
     * &lt;p&gt;
     * The leading edge is based on the axis and {@code
     * ComponentOrientation}.  For the vertical axis the top edge is
     * always the leading edge, and the bottom edge is always the
     * trailing edge. When the {@code ComponentOrientation} is {@code
     * LEFT_TO_RIGHT}, the leading edge is the left edge and the
     * trailing edge the right edge. A {@code ComponentOrientation} of
     * {@code RIGHT_TO_LEFT} flips the left and right edges. Child
     * elements are aligned based on the specified alignment the
     * element was added with. If you do not specify an alignment, the
     * alignment specified for the {@code ParallelGroup} is used.
     * &lt;p&gt;
     * To align elements along the baseline you {@code createBaselineGroup},
     * or {@code createParallelGroup} with an alignment of {@code BASELINE}.
     * If the group was not created with a baseline alignment, and you attempt
     * to add an element specifying a baseline alignment, an
     * {@code IllegalArgumentException} is thrown.
     *
     * @see #createParallelGroup()
     * @see #createBaselineGroup(boolean,boolean)
     * @since 1.6
     */
    public class ParallelGroup extends Group {
        // How children are layed out.
        private final Alignment childAlignment;
        // Whether or not we're resizable.
        private final boolean resizable;

<span class="nc" id="L2460">        ParallelGroup(Alignment childAlignment, boolean resizable) {</span>
<span class="nc" id="L2461">            this.childAlignment = childAlignment;</span>
<span class="nc" id="L2462">            this.resizable = resizable;</span>
<span class="nc" id="L2463">        }</span>

        /**
         * {@inheritDoc}
         */
        public ParallelGroup addGroup(Group group) {
<span class="nc" id="L2469">            return (ParallelGroup)super.addGroup(group);</span>
        }

        /**
         * {@inheritDoc}
         */
        public ParallelGroup addComponent(Component component) {
<span class="nc" id="L2476">            return (ParallelGroup)super.addComponent(component);</span>
        }

        /**
         * {@inheritDoc}
         */
        public ParallelGroup addComponent(Component component, int min, int pref,
                int max) {
<span class="nc" id="L2484">            return (ParallelGroup)super.addComponent(component, min, pref, max);</span>
        }

        /**
         * {@inheritDoc}
         */
        public ParallelGroup addGap(int pref) {
<span class="nc" id="L2491">            return (ParallelGroup)super.addGap(pref);</span>
        }

        /**
         * {@inheritDoc}
         */
        public ParallelGroup addGap(int min, int pref, int max) {
<span class="nc" id="L2498">            return (ParallelGroup)super.addGap(min, pref, max);</span>
        }

        /**
         * Adds a {@code Group} to this {@code ParallelGroup} with the
         * specified alignment. If the child is smaller than the
         * {@code Group} it is aligned based on the specified
         * alignment.
         *
         * @param alignment the alignment
         * @param group the {@code Group} to add
         * @return this {@code ParallelGroup}
         * @throws IllegalArgumentException if {@code alignment} is
         *         {@code null}
         */
        public ParallelGroup addGroup(Alignment alignment, Group group) {
<span class="nc" id="L2514">            checkChildAlignment(alignment);</span>
<span class="nc" id="L2515">            group.setAlignment(alignment);</span>
<span class="nc" id="L2516">            return (ParallelGroup)addSpring(group);</span>
        }

        /**
         * Adds a {@code Component} to this {@code ParallelGroup} with
         * the specified alignment.
         *
         * @param alignment the alignment
         * @param component the {@code Component} to add
         * @return this {@code Group}
         * @throws IllegalArgumentException if {@code alignment} is
         *         {@code null}
         */
        public ParallelGroup addComponent(Component component,
                Alignment alignment) {
<span class="nc" id="L2531">            return addComponent(component, alignment, DEFAULT_SIZE, DEFAULT_SIZE,</span>
                    DEFAULT_SIZE);
        }

        /**
         * Adds a {@code Component} to this {@code ParallelGroup} with the
         * specified alignment and size.
         *
         * @param alignment the alignment
         * @param component the {@code Component} to add
         * @param min the minimum size
         * @param pref the preferred size
         * @param max the maximum size
         * @throws IllegalArgumentException if {@code alignment} is
         *         {@code null}
         * @return this {@code Group}
         */
        public ParallelGroup addComponent(Component component,
                Alignment alignment, int min, int pref, int max) {
<span class="nc" id="L2550">            checkChildAlignment(alignment);</span>
<span class="nc" id="L2551">            ComponentSpring spring = new ComponentSpring(component,</span>
                    min, pref, max);
<span class="nc" id="L2553">            spring.setAlignment(alignment);</span>
<span class="nc" id="L2554">            return (ParallelGroup)addSpring(spring);</span>
        }

        boolean isResizable() {
<span class="nc" id="L2558">            return resizable;</span>
        }

        int operator(int a, int b) {
<span class="nc" id="L2562">            return Math.max(a, b);</span>
        }

        int calculateMinimumSize(int axis) {
<span class="nc bnc" id="L2566" title="All 2 branches missed.">            if (!isResizable()) {</span>
<span class="nc" id="L2567">                return getPreferredSize(axis);</span>
            }
<span class="nc" id="L2569">            return super.calculateMinimumSize(axis);</span>
        }

        int calculateMaximumSize(int axis) {
<span class="nc bnc" id="L2573" title="All 2 branches missed.">            if (!isResizable()) {</span>
<span class="nc" id="L2574">                return getPreferredSize(axis);</span>
            }
<span class="nc" id="L2576">            return super.calculateMaximumSize(axis);</span>
        }

        void setValidSize(int axis, int origin, int size) {
<span class="nc bnc" id="L2580" title="All 2 branches missed.">            for (Spring spring : springs) {</span>
<span class="nc" id="L2581">                setChildSize(spring, axis, origin, size);</span>
<span class="nc" id="L2582">            }</span>
<span class="nc" id="L2583">        }</span>

        void setChildSize(Spring spring, int axis, int origin, int size) {
<span class="nc" id="L2586">            Alignment alignment = spring.getAlignment();</span>
<span class="nc" id="L2587">            int springSize = Math.min(</span>
<span class="nc" id="L2588">                    Math.max(spring.getMinimumSize(axis), size),</span>
<span class="nc" id="L2589">                    spring.getMaximumSize(axis));</span>
<span class="nc bnc" id="L2590" title="All 2 branches missed.">            if (alignment == null) {</span>
<span class="nc" id="L2591">                alignment = childAlignment;</span>
            }
<span class="nc bnc" id="L2593" title="All 3 branches missed.">            switch (alignment) {</span>
                case TRAILING:
<span class="nc" id="L2595">                    spring.setSize(axis, origin + size - springSize,</span>
                            springSize);
<span class="nc" id="L2597">                    break;</span>
                case CENTER:
<span class="nc" id="L2599">                    spring.setSize(axis, origin +</span>
                            (size - springSize) / 2,springSize);
<span class="nc" id="L2601">                    break;</span>
                default: // LEADING, or BASELINE
<span class="nc" id="L2603">                    spring.setSize(axis, origin, springSize);</span>
                    break;
            }
<span class="nc" id="L2606">        }</span>

        @Override
        void insertAutopadding(int axis,
                List&lt;AutoPreferredGapSpring&gt; leadingPadding,
                List&lt;AutoPreferredGapSpring&gt; trailingPadding,
                List&lt;ComponentSpring&gt; leading, List&lt;ComponentSpring&gt; trailing,
                boolean insert) {
<span class="nc bnc" id="L2614" title="All 2 branches missed.">            for (Spring spring : springs) {</span>
<span class="nc bnc" id="L2615" title="All 2 branches missed.">                if (spring instanceof ComponentSpring) {</span>
<span class="nc bnc" id="L2616" title="All 2 branches missed.">                    if (((ComponentSpring)spring).isVisible()) {</span>
                        for (AutoPreferredGapSpring gapSpring :
<span class="nc bnc" id="L2618" title="All 2 branches missed.">                                 leadingPadding) {</span>
<span class="nc" id="L2619">                            gapSpring.addTarget((ComponentSpring)spring, axis);</span>
<span class="nc" id="L2620">                        }</span>
<span class="nc" id="L2621">                        trailing.add((ComponentSpring)spring);</span>
                    }
<span class="nc bnc" id="L2623" title="All 2 branches missed.">                } else if (spring instanceof Group) {</span>
<span class="nc" id="L2624">                    ((Group)spring).insertAutopadding(axis, leadingPadding,</span>
                            trailingPadding, leading, trailing, insert);
<span class="nc bnc" id="L2626" title="All 2 branches missed.">                } else if (spring instanceof AutoPreferredGapSpring) {</span>
<span class="nc" id="L2627">                    ((AutoPreferredGapSpring)spring).setSources(leading);</span>
<span class="nc" id="L2628">                    trailingPadding.add((AutoPreferredGapSpring)spring);</span>
                }
<span class="nc" id="L2630">            }</span>
<span class="nc" id="L2631">        }</span>

        private void checkChildAlignment(Alignment alignment) {
<span class="nc" id="L2634">            checkChildAlignment(alignment, (this instanceof BaselineGroup));</span>
<span class="nc" id="L2635">        }</span>

        private void checkChildAlignment(Alignment alignment,
                boolean allowsBaseline) {
<span class="nc bnc" id="L2639" title="All 2 branches missed.">            if (alignment == null) {</span>
<span class="nc" id="L2640">                throw new IllegalArgumentException(&quot;Alignment must be non-null&quot;);</span>
            }
<span class="nc bnc" id="L2642" title="All 4 branches missed.">            if (!allowsBaseline &amp;&amp; alignment == Alignment.BASELINE) {</span>
<span class="nc" id="L2643">                throw new IllegalArgumentException(&quot;Alignment must be one of:&quot; +</span>
                        &quot;LEADING, TRAILING or CENTER&quot;);
            }
<span class="nc" id="L2646">        }</span>
    }


    /**
     * An extension of {@code ParallelGroup} that aligns its
     * constituent {@code Spring}s along the baseline.
     */
    private class BaselineGroup extends ParallelGroup {
        // Whether or not all child springs have a baseline
        private boolean allSpringsHaveBaseline;

        // max(spring.getBaseline()) of all springs aligned along the baseline
        // that have a baseline
        private int prefAscent;

        // max(spring.getPreferredSize().height - spring.getBaseline()) of all
        // springs aligned along the baseline that have a baseline
        private int prefDescent;

        // Whether baselineAnchoredToTop was explicitly set
        private boolean baselineAnchorSet;

        // Whether the baseline is anchored to the top or the bottom.
        // If anchored to the top the baseline is always at prefAscent,
        // otherwise the baseline is at (height - prefDescent)
        private boolean baselineAnchoredToTop;

        // Whether or not the baseline has been calculated.
        private boolean calcedBaseline;

<span class="nc" id="L2677">        BaselineGroup(boolean resizable) {</span>
<span class="nc" id="L2678">            super(Alignment.LEADING, resizable);</span>
<span class="nc" id="L2679">            prefAscent = prefDescent = -1;</span>
<span class="nc" id="L2680">            calcedBaseline = false;</span>
<span class="nc" id="L2681">        }</span>

        BaselineGroup(boolean resizable, boolean baselineAnchoredToTop) {
<span class="nc" id="L2684">            this(resizable);</span>
<span class="nc" id="L2685">            this.baselineAnchoredToTop = baselineAnchoredToTop;</span>
<span class="nc" id="L2686">            baselineAnchorSet = true;</span>
<span class="nc" id="L2687">        }</span>

        void unset() {
<span class="nc" id="L2690">            super.unset();</span>
<span class="nc" id="L2691">            prefAscent = prefDescent = -1;</span>
<span class="nc" id="L2692">            calcedBaseline = false;</span>
<span class="nc" id="L2693">        }</span>

        void setValidSize(int axis, int origin, int size) {
<span class="nc" id="L2696">            checkAxis(axis);</span>
<span class="nc bnc" id="L2697" title="All 2 branches missed.">            if (prefAscent == -1) {</span>
<span class="nc" id="L2698">                super.setValidSize(axis, origin, size);</span>
            } else {
                // do baseline layout
<span class="nc" id="L2701">                baselineLayout(origin, size);</span>
            }
<span class="nc" id="L2703">        }</span>

        int calculateSize(int axis, int type) {
<span class="nc" id="L2706">            checkAxis(axis);</span>
<span class="nc bnc" id="L2707" title="All 2 branches missed.">            if (!calcedBaseline) {</span>
<span class="nc" id="L2708">                calculateBaselineAndResizeBehavior();</span>
            }
<span class="nc bnc" id="L2710" title="All 2 branches missed.">            if (type == MIN_SIZE) {</span>
<span class="nc" id="L2711">                return calculateMinSize();</span>
            }
<span class="nc bnc" id="L2713" title="All 2 branches missed.">            if (type == MAX_SIZE) {</span>
<span class="nc" id="L2714">                return calculateMaxSize();</span>
            }
<span class="nc bnc" id="L2716" title="All 2 branches missed.">            if (allSpringsHaveBaseline) {</span>
<span class="nc" id="L2717">                return prefAscent + prefDescent;</span>
            }
<span class="nc" id="L2719">            return Math.max(prefAscent + prefDescent,</span>
<span class="nc" id="L2720">                    super.calculateSize(axis, type));</span>
        }

        private void calculateBaselineAndResizeBehavior() {
            // calculate baseline
<span class="nc" id="L2725">            prefAscent = 0;</span>
<span class="nc" id="L2726">            prefDescent = 0;</span>
<span class="nc" id="L2727">            int baselineSpringCount = 0;</span>
<span class="nc" id="L2728">            BaselineResizeBehavior resizeBehavior = null;</span>
<span class="nc bnc" id="L2729" title="All 2 branches missed.">            for (Spring spring : springs) {</span>
<span class="nc bnc" id="L2730" title="All 2 branches missed.">                if (spring.getAlignment() == null ||</span>
<span class="nc bnc" id="L2731" title="All 2 branches missed.">                        spring.getAlignment() == Alignment.BASELINE) {</span>
<span class="nc" id="L2732">                    int baseline = spring.getBaseline();</span>
<span class="nc bnc" id="L2733" title="All 2 branches missed.">                    if (baseline &gt;= 0) {</span>
<span class="nc bnc" id="L2734" title="All 2 branches missed.">                        if (spring.isResizable(VERTICAL)) {</span>
<span class="nc" id="L2735">                            BaselineResizeBehavior brb = spring.</span>
<span class="nc" id="L2736">                                    getBaselineResizeBehavior();</span>
<span class="nc bnc" id="L2737" title="All 2 branches missed.">                            if (resizeBehavior == null) {</span>
<span class="nc" id="L2738">                                resizeBehavior = brb;</span>
<span class="nc bnc" id="L2739" title="All 2 branches missed.">                            } else if (brb != resizeBehavior) {</span>
<span class="nc" id="L2740">                                resizeBehavior = BaselineResizeBehavior.</span>
                                        CONSTANT_ASCENT;
                            }
                        }
<span class="nc" id="L2744">                        prefAscent = Math.max(prefAscent, baseline);</span>
<span class="nc" id="L2745">                        prefDescent = Math.max(prefDescent, spring.</span>
<span class="nc" id="L2746">                                getPreferredSize(VERTICAL) - baseline);</span>
<span class="nc" id="L2747">                        baselineSpringCount++;</span>
                    }
                }
<span class="nc" id="L2750">            }</span>
<span class="nc bnc" id="L2751" title="All 2 branches missed.">            if (!baselineAnchorSet) {</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">                if (resizeBehavior == BaselineResizeBehavior.CONSTANT_DESCENT){</span>
<span class="nc" id="L2753">                    this.baselineAnchoredToTop = false;</span>
                } else {
<span class="nc" id="L2755">                    this.baselineAnchoredToTop = true;</span>
                }
            }
<span class="nc bnc" id="L2758" title="All 2 branches missed.">            allSpringsHaveBaseline = (baselineSpringCount == springs.size());</span>
<span class="nc" id="L2759">            calcedBaseline = true;</span>
<span class="nc" id="L2760">        }</span>

        private int calculateMaxSize() {
<span class="nc" id="L2763">            int maxAscent = prefAscent;</span>
<span class="nc" id="L2764">            int maxDescent = prefDescent;</span>
<span class="nc" id="L2765">            int nonBaselineMax = 0;</span>
<span class="nc bnc" id="L2766" title="All 2 branches missed.">            for (Spring spring : springs) {</span>
                int baseline;
<span class="nc" id="L2768">                int springMax = spring.getMaximumSize(VERTICAL);</span>
<span class="nc bnc" id="L2769" title="All 2 branches missed.">                if ((spring.getAlignment() == null ||</span>
<span class="nc bnc" id="L2770" title="All 2 branches missed.">                        spring.getAlignment() == Alignment.BASELINE) &amp;&amp;</span>
<span class="nc bnc" id="L2771" title="All 2 branches missed.">                        (baseline = spring.getBaseline()) &gt;= 0) {</span>
<span class="nc" id="L2772">                    int springPref = spring.getPreferredSize(VERTICAL);</span>
<span class="nc bnc" id="L2773" title="All 2 branches missed.">                    if (springPref != springMax) {</span>
<span class="nc bnc" id="L2774" title="All 3 branches missed.">                        switch (spring.getBaselineResizeBehavior()) {</span>
                            case CONSTANT_ASCENT:
<span class="nc bnc" id="L2776" title="All 2 branches missed.">                                if (baselineAnchoredToTop) {</span>
<span class="nc" id="L2777">                                    maxDescent = Math.max(maxDescent,</span>
                                            springMax - baseline);
                                }
                                break;
                            case CONSTANT_DESCENT:
<span class="nc bnc" id="L2782" title="All 2 branches missed.">                                if (!baselineAnchoredToTop) {</span>
<span class="nc" id="L2783">                                    maxAscent = Math.max(maxAscent,</span>
                                            springMax - springPref + baseline);
                                }
                                break;
                            default: // CENTER_OFFSET and OTHER, not resizable
                                break;
                        }
                    }
<span class="nc" id="L2791">                } else {</span>
                    // Not aligned along the baseline, or no baseline.
<span class="nc" id="L2793">                    nonBaselineMax = Math.max(nonBaselineMax, springMax);</span>
                }
<span class="nc" id="L2795">            }</span>
<span class="nc" id="L2796">            return Math.max(nonBaselineMax, maxAscent + maxDescent);</span>
        }

        private int calculateMinSize() {
<span class="nc" id="L2800">            int minAscent = 0;</span>
<span class="nc" id="L2801">            int minDescent = 0;</span>
<span class="nc" id="L2802">            int nonBaselineMin = 0;</span>
<span class="nc bnc" id="L2803" title="All 2 branches missed.">            if (baselineAnchoredToTop) {</span>
<span class="nc" id="L2804">                minAscent = prefAscent;</span>
            } else {
<span class="nc" id="L2806">                minDescent = prefDescent;</span>
            }
<span class="nc bnc" id="L2808" title="All 2 branches missed.">            for (Spring spring : springs) {</span>
<span class="nc" id="L2809">                int springMin = spring.getMinimumSize(VERTICAL);</span>
                int baseline;
<span class="nc bnc" id="L2811" title="All 2 branches missed.">                if ((spring.getAlignment() == null ||</span>
<span class="nc bnc" id="L2812" title="All 2 branches missed.">                        spring.getAlignment() == Alignment.BASELINE) &amp;&amp;</span>
<span class="nc bnc" id="L2813" title="All 2 branches missed.">                        (baseline = spring.getBaseline()) &gt;= 0) {</span>
<span class="nc" id="L2814">                    int springPref = spring.getPreferredSize(VERTICAL);</span>
<span class="nc" id="L2815">                    BaselineResizeBehavior brb = spring.</span>
<span class="nc" id="L2816">                            getBaselineResizeBehavior();</span>
<span class="nc bnc" id="L2817" title="All 3 branches missed.">                    switch (brb) {</span>
                        case CONSTANT_ASCENT:
<span class="nc bnc" id="L2819" title="All 2 branches missed.">                            if (baselineAnchoredToTop) {</span>
<span class="nc" id="L2820">                                minDescent = Math.max(springMin - baseline,</span>
                                        minDescent);
                            } else {
<span class="nc" id="L2823">                                minAscent = Math.max(baseline, minAscent);</span>
                            }
<span class="nc" id="L2825">                            break;</span>
                        case CONSTANT_DESCENT:
<span class="nc bnc" id="L2827" title="All 2 branches missed.">                            if (!baselineAnchoredToTop) {</span>
<span class="nc" id="L2828">                                minAscent = Math.max(</span>
                                        baseline - (springPref - springMin),
                                        minAscent);
                            } else {
<span class="nc" id="L2832">                                minDescent = Math.max(springPref - baseline,</span>
                                        minDescent);
                            }
<span class="nc" id="L2835">                            break;</span>
                        default:
                            // CENTER_OFFSET and OTHER are !resizable, use
                            // the preferred size.
<span class="nc" id="L2839">                            minAscent = Math.max(baseline, minAscent);</span>
<span class="nc" id="L2840">                            minDescent = Math.max(springPref - baseline,</span>
                                    minDescent);
                            break;
                    }
<span class="nc" id="L2844">                } else {</span>
                    // Not aligned along the baseline, or no baseline.
<span class="nc" id="L2846">                    nonBaselineMin = Math.max(nonBaselineMin, springMin);</span>
                }
<span class="nc" id="L2848">            }</span>
<span class="nc" id="L2849">            return Math.max(nonBaselineMin, minAscent + minDescent);</span>
        }

        /**
         * Lays out springs that have a baseline along the baseline.  All
         * others are centered.
         */
        private void baselineLayout(int origin, int size) {
            int ascent;
            int descent;
<span class="nc bnc" id="L2859" title="All 2 branches missed.">            if (baselineAnchoredToTop) {</span>
<span class="nc" id="L2860">                ascent = prefAscent;</span>
<span class="nc" id="L2861">                descent = size - ascent;</span>
            } else {
<span class="nc" id="L2863">                ascent = size - prefDescent;</span>
<span class="nc" id="L2864">                descent = prefDescent;</span>
            }
<span class="nc bnc" id="L2866" title="All 2 branches missed.">            for (Spring spring : springs) {</span>
<span class="nc" id="L2867">                Alignment alignment = spring.getAlignment();</span>
<span class="nc bnc" id="L2868" title="All 4 branches missed.">                if (alignment == null || alignment == Alignment.BASELINE) {</span>
<span class="nc" id="L2869">                    int baseline = spring.getBaseline();</span>
<span class="nc bnc" id="L2870" title="All 2 branches missed.">                    if (baseline &gt;= 0) {</span>
<span class="nc" id="L2871">                        int springMax = spring.getMaximumSize(VERTICAL);</span>
<span class="nc" id="L2872">                        int springPref = spring.getPreferredSize(VERTICAL);</span>
<span class="nc" id="L2873">                        int height = springPref;</span>
                        int y;
<span class="nc bnc" id="L2875" title="All 3 branches missed.">                        switch(spring.getBaselineResizeBehavior()) {</span>
                            case CONSTANT_ASCENT:
<span class="nc" id="L2877">                                y = origin + ascent - baseline;</span>
<span class="nc" id="L2878">                                height = Math.min(descent, springMax -</span>
                                        baseline) + baseline;
<span class="nc" id="L2880">                                break;</span>
                            case CONSTANT_DESCENT:
<span class="nc" id="L2882">                                height = Math.min(ascent, springMax -</span>
                                        springPref + baseline) +
                                        (springPref - baseline);
<span class="nc" id="L2885">                                y = origin + ascent +</span>
                                        (springPref - baseline) - height;
<span class="nc" id="L2887">                                break;</span>
                            default: // CENTER_OFFSET &amp; OTHER, not resizable
<span class="nc" id="L2889">                                y = origin + ascent - baseline;</span>
                                break;
                        }
<span class="nc" id="L2892">                        spring.setSize(VERTICAL, y, height);</span>
<span class="nc" id="L2893">                    } else {</span>
<span class="nc" id="L2894">                        setChildSize(spring, VERTICAL, origin, size);</span>
                    }
<span class="nc" id="L2896">                } else {</span>
<span class="nc" id="L2897">                    setChildSize(spring, VERTICAL, origin, size);</span>
                }
<span class="nc" id="L2899">            }</span>
<span class="nc" id="L2900">        }</span>

        int getBaseline() {
<span class="nc bnc" id="L2903" title="All 2 branches missed.">            if (springs.size() &gt; 1) {</span>
                // Force the baseline to be calculated
<span class="nc" id="L2905">                getPreferredSize(VERTICAL);</span>
<span class="nc" id="L2906">                return prefAscent;</span>
<span class="nc bnc" id="L2907" title="All 2 branches missed.">            } else if (springs.size() == 1) {</span>
<span class="nc" id="L2908">                return springs.get(0).getBaseline();</span>
            }
<span class="nc" id="L2910">            return -1;</span>
        }

        BaselineResizeBehavior getBaselineResizeBehavior() {
<span class="nc bnc" id="L2914" title="All 2 branches missed.">            if (springs.size() == 1) {</span>
<span class="nc" id="L2915">                return springs.get(0).getBaselineResizeBehavior();</span>
            }
<span class="nc bnc" id="L2917" title="All 2 branches missed.">            if (baselineAnchoredToTop) {</span>
<span class="nc" id="L2918">                return BaselineResizeBehavior.CONSTANT_ASCENT;</span>
            }
<span class="nc" id="L2920">            return BaselineResizeBehavior.CONSTANT_DESCENT;</span>
        }

        // If the axis is VERTICAL, throws an IllegalStateException
        private void checkAxis(int axis) {
<span class="nc bnc" id="L2925" title="All 2 branches missed.">            if (axis == HORIZONTAL) {</span>
<span class="nc" id="L2926">                throw new IllegalStateException(</span>
                        &quot;Baseline must be used along vertical axis&quot;);
            }
<span class="nc" id="L2929">        }</span>
    }


<span class="nc bnc" id="L2933" title="All 2 branches missed.">    private final class ComponentSpring extends Spring {</span>
        private Component component;
        private int origin;

        // min/pref/max are either a value &gt;= 0 or one of
        // DEFAULT_SIZE or PREFERRED_SIZE
        private final int min;
        private final int pref;
        private final int max;

        // Baseline for the component, computed as necessary.
<span class="nc" id="L2944">        private int baseline = -1;</span>

        // Whether or not the size has been requested yet.
        private boolean installed;

        private ComponentSpring(Component component, int min, int pref,
<span class="nc" id="L2950">                int max) {</span>
<span class="nc" id="L2951">            this.component = component;</span>
<span class="nc bnc" id="L2952" title="All 2 branches missed.">            if (component == null) {</span>
<span class="nc" id="L2953">                throw new IllegalArgumentException(</span>
                        &quot;Component must be non-null&quot;);
            }

<span class="nc" id="L2957">            checkSize(min, pref, max, true);</span>

<span class="nc" id="L2959">            this.min = min;</span>
<span class="nc" id="L2960">            this.max = max;</span>
<span class="nc" id="L2961">            this.pref = pref;</span>

            // getComponentInfo makes sure component is a child of the
            // Container GroupLayout is the LayoutManager for.
<span class="nc" id="L2965">            getComponentInfo(component);</span>
<span class="nc" id="L2966">        }</span>

        int calculateMinimumSize(int axis) {
<span class="nc bnc" id="L2969" title="All 2 branches missed.">            if (isLinked(axis)) {</span>
<span class="nc" id="L2970">                return getLinkSize(axis, MIN_SIZE);</span>
            }
<span class="nc" id="L2972">            return calculateNonlinkedMinimumSize(axis);</span>
        }

        int calculatePreferredSize(int axis) {
<span class="nc bnc" id="L2976" title="All 2 branches missed.">            if (isLinked(axis)) {</span>
<span class="nc" id="L2977">                return getLinkSize(axis, PREF_SIZE);</span>
            }
<span class="nc" id="L2979">            int min = getMinimumSize(axis);</span>
<span class="nc" id="L2980">            int pref = calculateNonlinkedPreferredSize(axis);</span>
<span class="nc" id="L2981">            int max = getMaximumSize(axis);</span>
<span class="nc" id="L2982">            return Math.min(max, Math.max(min, pref));</span>
        }

        int calculateMaximumSize(int axis) {
<span class="nc bnc" id="L2986" title="All 2 branches missed.">            if (isLinked(axis)) {</span>
<span class="nc" id="L2987">                return getLinkSize(axis, MAX_SIZE);</span>
            }
<span class="nc" id="L2989">            return Math.max(getMinimumSize(axis),</span>
<span class="nc" id="L2990">                    calculateNonlinkedMaximumSize(axis));</span>
        }

        boolean isVisible() {
<span class="nc" id="L2994">            return getComponentInfo(getComponent()).isVisible();</span>
        }

        int calculateNonlinkedMinimumSize(int axis) {
<span class="nc bnc" id="L2998" title="All 2 branches missed.">            if (!isVisible()) {</span>
<span class="nc" id="L2999">                return 0;</span>
            }
<span class="nc bnc" id="L3001" title="All 2 branches missed.">            if (min &gt;= 0) {</span>
<span class="nc" id="L3002">                return min;</span>
            }
<span class="nc bnc" id="L3004" title="All 2 branches missed.">            if (min == PREFERRED_SIZE) {</span>
<span class="nc" id="L3005">                return calculateNonlinkedPreferredSize(axis);</span>
            }
<span class="nc bnc" id="L3007" title="All 4 branches missed.">            assert (min == DEFAULT_SIZE);</span>
<span class="nc" id="L3008">            return getSizeAlongAxis(axis, component.getMinimumSize());</span>
        }

        int calculateNonlinkedPreferredSize(int axis) {
<span class="nc bnc" id="L3012" title="All 2 branches missed.">            if (!isVisible()) {</span>
<span class="nc" id="L3013">                return 0;</span>
            }
<span class="nc bnc" id="L3015" title="All 2 branches missed.">            if (pref &gt;= 0) {</span>
<span class="nc" id="L3016">                return pref;</span>
            }
<span class="nc bnc" id="L3018" title="All 6 branches missed.">            assert (pref == DEFAULT_SIZE || pref == PREFERRED_SIZE);</span>
<span class="nc" id="L3019">            return getSizeAlongAxis(axis, component.getPreferredSize());</span>
        }

        int calculateNonlinkedMaximumSize(int axis) {
<span class="nc bnc" id="L3023" title="All 2 branches missed.">            if (!isVisible()) {</span>
<span class="nc" id="L3024">                return 0;</span>
            }
<span class="nc bnc" id="L3026" title="All 2 branches missed.">            if (max &gt;= 0) {</span>
<span class="nc" id="L3027">                return max;</span>
            }
<span class="nc bnc" id="L3029" title="All 2 branches missed.">            if (max == PREFERRED_SIZE) {</span>
<span class="nc" id="L3030">                return calculateNonlinkedPreferredSize(axis);</span>
            }
<span class="nc bnc" id="L3032" title="All 4 branches missed.">            assert (max == DEFAULT_SIZE);</span>
<span class="nc" id="L3033">            return getSizeAlongAxis(axis, component.getMaximumSize());</span>
        }

        private int getSizeAlongAxis(int axis, Dimension size) {
<span class="nc bnc" id="L3037" title="All 2 branches missed.">            return (axis == HORIZONTAL) ? size.width : size.height;</span>
        }

        private int getLinkSize(int axis, int type) {
<span class="nc bnc" id="L3041" title="All 2 branches missed.">            if (!isVisible()) {</span>
<span class="nc" id="L3042">                return 0;</span>
            }
<span class="nc" id="L3044">            ComponentInfo ci = getComponentInfo(component);</span>
<span class="nc" id="L3045">            return ci.getLinkSize(axis, type);</span>
        }

        void setSize(int axis, int origin, int size) {
<span class="nc" id="L3049">            super.setSize(axis, origin, size);</span>
<span class="nc" id="L3050">            this.origin = origin;</span>
<span class="nc bnc" id="L3051" title="All 2 branches missed.">            if (size == UNSET) {</span>
<span class="nc" id="L3052">                baseline = -1;</span>
            }
<span class="nc" id="L3054">        }</span>

        int getOrigin() {
<span class="nc" id="L3057">            return origin;</span>
        }

        void setComponent(Component component) {
<span class="nc" id="L3061">            this.component = component;</span>
<span class="nc" id="L3062">        }</span>

        Component getComponent() {
<span class="nc" id="L3065">            return component;</span>
        }

        int getBaseline() {
<span class="nc bnc" id="L3069" title="All 2 branches missed.">            if (baseline == -1) {</span>
<span class="nc" id="L3070">                Spring horizontalSpring = getComponentInfo(component).</span>
                        horizontalSpring;
<span class="nc" id="L3072">                int width = horizontalSpring.getPreferredSize(HORIZONTAL);</span>
<span class="nc" id="L3073">                int height = getPreferredSize(VERTICAL);</span>
<span class="nc bnc" id="L3074" title="All 4 branches missed.">                if (width &gt; 0 &amp;&amp; height &gt; 0) {</span>
<span class="nc" id="L3075">                    baseline = component.getBaseline(width, height);</span>
                }
            }
<span class="nc" id="L3078">            return baseline;</span>
        }

        BaselineResizeBehavior getBaselineResizeBehavior() {
<span class="nc" id="L3082">            return getComponent().getBaselineResizeBehavior();</span>
        }

        private boolean isLinked(int axis) {
<span class="nc" id="L3086">            return getComponentInfo(component).isLinked(axis);</span>
        }

        void installIfNecessary(int axis) {
<span class="nc bnc" id="L3090" title="All 2 branches missed.">            if (!installed) {</span>
<span class="nc" id="L3091">                installed = true;</span>
<span class="nc bnc" id="L3092" title="All 2 branches missed.">                if (axis == HORIZONTAL) {</span>
<span class="nc" id="L3093">                    getComponentInfo(component).horizontalSpring = this;</span>
                } else {
<span class="nc" id="L3095">                    getComponentInfo(component).verticalSpring = this;</span>
                }
            }
<span class="nc" id="L3098">        }</span>

        @Override
        boolean willHaveZeroSize(boolean treatAutopaddingAsZeroSized) {
<span class="nc bnc" id="L3102" title="All 2 branches missed.">            return !isVisible();</span>
        }
    }


    /**
     * Spring representing the preferred distance between two components.
     */
    private class PreferredGapSpring extends Spring {
        private final JComponent source;
        private final JComponent target;
        private final ComponentPlacement type;
        private final int pref;
        private final int max;

        PreferredGapSpring(JComponent source, JComponent target,
<span class="nc" id="L3118">                ComponentPlacement type, int pref, int max) {</span>
<span class="nc" id="L3119">            this.source = source;</span>
<span class="nc" id="L3120">            this.target = target;</span>
<span class="nc" id="L3121">            this.type = type;</span>
<span class="nc" id="L3122">            this.pref = pref;</span>
<span class="nc" id="L3123">            this.max = max;</span>
<span class="nc" id="L3124">        }</span>

        int calculateMinimumSize(int axis) {
<span class="nc" id="L3127">            return getPadding(axis);</span>
        }

        int calculatePreferredSize(int axis) {
<span class="nc bnc" id="L3131" title="All 4 branches missed.">            if (pref == DEFAULT_SIZE || pref == PREFERRED_SIZE) {</span>
<span class="nc" id="L3132">                return getMinimumSize(axis);</span>
            }
<span class="nc" id="L3134">            int min = getMinimumSize(axis);</span>
<span class="nc" id="L3135">            int max = getMaximumSize(axis);</span>
<span class="nc" id="L3136">            return Math.min(max, Math.max(min, pref));</span>
        }

        int calculateMaximumSize(int axis) {
<span class="nc bnc" id="L3140" title="All 4 branches missed.">            if (max == PREFERRED_SIZE || max == DEFAULT_SIZE) {</span>
<span class="nc" id="L3141">                return getPadding(axis);</span>
            }
<span class="nc" id="L3143">            return Math.max(getMinimumSize(axis), max);</span>
        }

        private int getPadding(int axis) {
            int position;
<span class="nc bnc" id="L3148" title="All 2 branches missed.">            if (axis == HORIZONTAL) {</span>
<span class="nc" id="L3149">                position = SwingConstants.EAST;</span>
            } else {
<span class="nc" id="L3151">                position = SwingConstants.SOUTH;</span>
            }
<span class="nc" id="L3153">            return getLayoutStyle0().getPreferredGap(source,</span>
<span class="nc" id="L3154">                    target, type, position, host);</span>
        }

        @Override
        boolean willHaveZeroSize(boolean treatAutopaddingAsZeroSized) {
<span class="nc" id="L3159">            return false;</span>
        }
    }


    /**
     * Spring represented a certain amount of space.
     */
    private class GapSpring extends Spring {
        private final int min;
        private final int pref;
        private final int max;

<span class="nc" id="L3172">        GapSpring(int min, int pref, int max) {</span>
<span class="nc" id="L3173">            checkSize(min, pref, max, false);</span>
<span class="nc" id="L3174">            this.min = min;</span>
<span class="nc" id="L3175">            this.pref = pref;</span>
<span class="nc" id="L3176">            this.max = max;</span>
<span class="nc" id="L3177">        }</span>

        int calculateMinimumSize(int axis) {
<span class="nc bnc" id="L3180" title="All 2 branches missed.">            if (min == PREFERRED_SIZE) {</span>
<span class="nc" id="L3181">                return getPreferredSize(axis);</span>
            }
<span class="nc" id="L3183">            return min;</span>
        }

        int calculatePreferredSize(int axis) {
<span class="nc" id="L3187">            return pref;</span>
        }

        int calculateMaximumSize(int axis) {
<span class="nc bnc" id="L3191" title="All 2 branches missed.">            if (max == PREFERRED_SIZE) {</span>
<span class="nc" id="L3192">                return getPreferredSize(axis);</span>
            }
<span class="nc" id="L3194">            return max;</span>
        }

        @Override
        boolean willHaveZeroSize(boolean treatAutopaddingAsZeroSized) {
<span class="nc" id="L3199">            return false;</span>
        }
    }


    /**
     * Spring reprensenting the distance between any number of sources and
     * targets.  The targets and sources are computed during layout.  An
     * instance of this can either be dynamically created when
     * autocreatePadding is true, or explicitly created by the developer.
     */
    private class AutoPreferredGapSpring extends Spring {
        List&lt;ComponentSpring&gt; sources;
        ComponentSpring source;
        private List&lt;AutoPreferredGapMatch&gt; matches;
        int size;
        int lastSize;
        private final int pref;
        private final int max;
        // Type of gap
        private ComponentPlacement type;
        private boolean userCreated;

<span class="nc" id="L3222">        private AutoPreferredGapSpring() {</span>
<span class="nc" id="L3223">            this.pref = PREFERRED_SIZE;</span>
<span class="nc" id="L3224">            this.max = PREFERRED_SIZE;</span>
<span class="nc" id="L3225">            this.type = ComponentPlacement.RELATED;</span>
<span class="nc" id="L3226">        }</span>

<span class="nc" id="L3228">        AutoPreferredGapSpring(int pref, int max) {</span>
<span class="nc" id="L3229">            this.pref = pref;</span>
<span class="nc" id="L3230">            this.max = max;</span>
<span class="nc" id="L3231">        }</span>

<span class="nc" id="L3233">        AutoPreferredGapSpring(ComponentPlacement type, int pref, int max) {</span>
<span class="nc" id="L3234">            this.type = type;</span>
<span class="nc" id="L3235">            this.pref = pref;</span>
<span class="nc" id="L3236">            this.max = max;</span>
<span class="nc" id="L3237">            this.userCreated = true;</span>
<span class="nc" id="L3238">        }</span>

        public void setSource(ComponentSpring source) {
<span class="nc" id="L3241">            this.source = source;</span>
<span class="nc" id="L3242">        }</span>

        public void setSources(List&lt;ComponentSpring&gt; sources) {
<span class="nc" id="L3245">            this.sources = new ArrayList&lt;ComponentSpring&gt;(sources);</span>
<span class="nc" id="L3246">        }</span>

        public void setUserCreated(boolean userCreated) {
<span class="nc" id="L3249">            this.userCreated = userCreated;</span>
<span class="nc" id="L3250">        }</span>

        public boolean getUserCreated() {
<span class="nc" id="L3253">            return userCreated;</span>
        }

        void unset() {
<span class="nc" id="L3257">            lastSize = getSize();</span>
<span class="nc" id="L3258">            super.unset();</span>
<span class="nc" id="L3259">            size = 0;</span>
<span class="nc" id="L3260">        }</span>

        public void reset() {
<span class="nc" id="L3263">            size = 0;</span>
<span class="nc" id="L3264">            sources = null;</span>
<span class="nc" id="L3265">            source = null;</span>
<span class="nc" id="L3266">            matches = null;</span>
<span class="nc" id="L3267">        }</span>

        public void calculatePadding(int axis) {
<span class="nc" id="L3270">            size = UNSET;</span>
<span class="nc" id="L3271">            int maxPadding = UNSET;</span>
<span class="nc bnc" id="L3272" title="All 2 branches missed.">            if (matches != null) {</span>
<span class="nc" id="L3273">                LayoutStyle p = getLayoutStyle0();</span>
                int position;
<span class="nc bnc" id="L3275" title="All 2 branches missed.">                if (axis == HORIZONTAL) {</span>
<span class="nc bnc" id="L3276" title="All 2 branches missed.">                    if (isLeftToRight()) {</span>
<span class="nc" id="L3277">                        position = SwingConstants.EAST;</span>
                    } else {
<span class="nc" id="L3279">                        position = SwingConstants.WEST;</span>
                    }
                } else {
<span class="nc" id="L3282">                    position = SwingConstants.SOUTH;</span>
                }
<span class="nc bnc" id="L3284" title="All 2 branches missed.">                for (int i = matches.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L3285">                    AutoPreferredGapMatch match = matches.get(i);</span>
<span class="nc" id="L3286">                    maxPadding = Math.max(maxPadding,</span>
<span class="nc" id="L3287">                            calculatePadding(p, position, match.source,</span>
                            match.target));
                }
            }
<span class="nc bnc" id="L3291" title="All 2 branches missed.">            if (size == UNSET) {</span>
<span class="nc" id="L3292">                size = 0;</span>
            }
<span class="nc bnc" id="L3294" title="All 2 branches missed.">            if (maxPadding == UNSET) {</span>
<span class="nc" id="L3295">                maxPadding = 0;</span>
            }
<span class="nc bnc" id="L3297" title="All 2 branches missed.">            if (lastSize != UNSET) {</span>
<span class="nc" id="L3298">                size += Math.min(maxPadding, lastSize);</span>
            }
<span class="nc" id="L3300">        }</span>

        private int calculatePadding(LayoutStyle p, int position,
                ComponentSpring source,
                ComponentSpring target) {
<span class="nc" id="L3305">            int delta = target.getOrigin() - (source.getOrigin() +</span>
<span class="nc" id="L3306">                    source.getSize());</span>
<span class="nc bnc" id="L3307" title="All 2 branches missed.">            if (delta &gt;= 0) {</span>
                int padding;
<span class="nc bnc" id="L3309" title="All 2 branches missed.">                if ((source.getComponent() instanceof JComponent) &amp;&amp;</span>
<span class="nc bnc" id="L3310" title="All 2 branches missed.">                        (target.getComponent() instanceof JComponent)) {</span>
<span class="nc" id="L3311">                    padding = p.getPreferredGap(</span>
<span class="nc" id="L3312">                            (JComponent)source.getComponent(),</span>
<span class="nc" id="L3313">                            (JComponent)target.getComponent(), type, position,</span>
<span class="nc" id="L3314">                            host);</span>
                } else {
<span class="nc" id="L3316">                    padding = 10;</span>
                }
<span class="nc bnc" id="L3318" title="All 2 branches missed.">                if (padding &gt; delta) {</span>
<span class="nc" id="L3319">                    size = Math.max(size, padding - delta);</span>
                }
<span class="nc" id="L3321">                return padding;</span>
            }
<span class="nc" id="L3323">            return 0;</span>
        }

        public void addTarget(ComponentSpring spring, int axis) {
<span class="nc bnc" id="L3327" title="All 2 branches missed.">            int oAxis = (axis == HORIZONTAL) ? VERTICAL : HORIZONTAL;</span>
<span class="nc bnc" id="L3328" title="All 2 branches missed.">            if (source != null) {</span>
<span class="nc bnc" id="L3329" title="All 2 branches missed.">                if (areParallelSiblings(source.getComponent(),</span>
<span class="nc" id="L3330">                        spring.getComponent(), oAxis)) {</span>
<span class="nc" id="L3331">                    addValidTarget(source, spring);</span>
                }
            } else {
<span class="nc" id="L3334">                Component component = spring.getComponent();</span>
<span class="nc bnc" id="L3335" title="All 2 branches missed.">                for (int counter = sources.size() - 1; counter &gt;= 0;</span>
<span class="nc" id="L3336">                         counter--){</span>
<span class="nc" id="L3337">                    ComponentSpring source = sources.get(counter);</span>
<span class="nc bnc" id="L3338" title="All 2 branches missed.">                    if (areParallelSiblings(source.getComponent(),</span>
                            component, oAxis)) {
<span class="nc" id="L3340">                        addValidTarget(source, spring);</span>
                    }
                }
            }
<span class="nc" id="L3344">        }</span>

        private void addValidTarget(ComponentSpring source,
                ComponentSpring target) {
<span class="nc bnc" id="L3348" title="All 2 branches missed.">            if (matches == null) {</span>
<span class="nc" id="L3349">                matches = new ArrayList&lt;AutoPreferredGapMatch&gt;(1);</span>
            }
<span class="nc" id="L3351">            matches.add(new AutoPreferredGapMatch(source, target));</span>
<span class="nc" id="L3352">        }</span>

        int calculateMinimumSize(int axis) {
<span class="nc" id="L3355">            return size;</span>
        }

        int calculatePreferredSize(int axis) {
<span class="nc bnc" id="L3359" title="All 4 branches missed.">            if (pref == PREFERRED_SIZE || pref == DEFAULT_SIZE) {</span>
<span class="nc" id="L3360">                return size;</span>
            }
<span class="nc" id="L3362">            return Math.max(size, pref);</span>
        }

        int calculateMaximumSize(int axis) {
<span class="nc bnc" id="L3366" title="All 2 branches missed.">            if (max &gt;= 0) {</span>
<span class="nc" id="L3367">                return Math.max(getPreferredSize(axis), max);</span>
            }
<span class="nc" id="L3369">            return size;</span>
        }

        String getMatchDescription() {
<span class="nc bnc" id="L3373" title="All 2 branches missed.">            return (matches == null) ? &quot;&quot; : matches.toString();</span>
        }

        public String toString() {
<span class="nc" id="L3377">            return super.toString() + getMatchDescription();</span>
        }

        @Override
        boolean willHaveZeroSize(boolean treatAutopaddingAsZeroSized) {
<span class="nc" id="L3382">            return treatAutopaddingAsZeroSized;</span>
        }
    }


    /**
     * Represents two springs that should have autopadding inserted between
     * them.
     */
    private final static class AutoPreferredGapMatch {
        public final ComponentSpring source;
        public final ComponentSpring target;

<span class="nc" id="L3395">        AutoPreferredGapMatch(ComponentSpring source, ComponentSpring target) {</span>
<span class="nc" id="L3396">            this.source = source;</span>
<span class="nc" id="L3397">            this.target = target;</span>
<span class="nc" id="L3398">        }</span>

        private String toString(ComponentSpring spring) {
<span class="nc" id="L3401">            return spring.getComponent().getName();</span>
        }

        public String toString() {
<span class="nc" id="L3405">            return &quot;[&quot; + toString(source) + &quot;-&quot; + toString(target) + &quot;]&quot;;</span>
        }
    }


    /**
     * An extension of AutopaddingSpring used for container level padding.
     */
    private class ContainerAutoPreferredGapSpring extends
            AutoPreferredGapSpring {
        private List&lt;ComponentSpring&gt; targets;

<span class="nc" id="L3417">        ContainerAutoPreferredGapSpring() {</span>
<span class="nc" id="L3418">            super();</span>
<span class="nc" id="L3419">            setUserCreated(true);</span>
<span class="nc" id="L3420">        }</span>

<span class="nc" id="L3422">        ContainerAutoPreferredGapSpring(int pref, int max) {</span>
<span class="nc" id="L3423">            super(pref, max);</span>
<span class="nc" id="L3424">            setUserCreated(true);</span>
<span class="nc" id="L3425">        }</span>

        public void addTarget(ComponentSpring spring, int axis) {
<span class="nc bnc" id="L3428" title="All 2 branches missed.">            if (targets == null) {</span>
<span class="nc" id="L3429">                targets = new ArrayList&lt;ComponentSpring&gt;(1);</span>
            }
<span class="nc" id="L3431">            targets.add(spring);</span>
<span class="nc" id="L3432">        }</span>

        public void calculatePadding(int axis) {
<span class="nc" id="L3435">            LayoutStyle p = getLayoutStyle0();</span>
<span class="nc" id="L3436">            int maxPadding = 0;</span>
            int position;
<span class="nc" id="L3438">            size = 0;</span>
<span class="nc bnc" id="L3439" title="All 2 branches missed.">            if (targets != null) {</span>
                // Leading
<span class="nc bnc" id="L3441" title="All 2 branches missed.">                if (axis == HORIZONTAL) {</span>
<span class="nc bnc" id="L3442" title="All 2 branches missed.">                    if (isLeftToRight()) {</span>
<span class="nc" id="L3443">                        position = SwingConstants.WEST;</span>
                    } else {
<span class="nc" id="L3445">                        position = SwingConstants.EAST;</span>
                    }
                } else {
<span class="nc" id="L3448">                    position = SwingConstants.SOUTH;</span>
                }
<span class="nc bnc" id="L3450" title="All 2 branches missed.">                for (int i = targets.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L3451">                    ComponentSpring targetSpring = targets.get(i);</span>
<span class="nc" id="L3452">                    int padding = 10;</span>
<span class="nc bnc" id="L3453" title="All 2 branches missed.">                    if (targetSpring.getComponent() instanceof JComponent) {</span>
<span class="nc" id="L3454">                        padding = p.getContainerGap(</span>
<span class="nc" id="L3455">                                (JComponent)targetSpring.getComponent(),</span>
<span class="nc" id="L3456">                                position, host);</span>
<span class="nc" id="L3457">                        maxPadding = Math.max(padding, maxPadding);</span>
<span class="nc" id="L3458">                        padding -= targetSpring.getOrigin();</span>
                    } else {
<span class="nc" id="L3460">                        maxPadding = Math.max(padding, maxPadding);</span>
                    }
<span class="nc" id="L3462">                    size = Math.max(size, padding);</span>
                }
            } else {
                // Trailing
<span class="nc bnc" id="L3466" title="All 2 branches missed.">                if (axis == HORIZONTAL) {</span>
<span class="nc bnc" id="L3467" title="All 2 branches missed.">                    if (isLeftToRight()) {</span>
<span class="nc" id="L3468">                        position = SwingConstants.EAST;</span>
                    } else {
<span class="nc" id="L3470">                        position = SwingConstants.WEST;</span>
                    }
                } else {
<span class="nc" id="L3473">                    position = SwingConstants.SOUTH;</span>
                }
<span class="nc bnc" id="L3475" title="All 2 branches missed.">                if (sources != null) {</span>
<span class="nc bnc" id="L3476" title="All 2 branches missed.">                    for (int i = sources.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L3477">                        ComponentSpring sourceSpring = sources.get(i);</span>
<span class="nc" id="L3478">                        maxPadding = Math.max(maxPadding,</span>
<span class="nc" id="L3479">                                updateSize(p, sourceSpring, position));</span>
                    }
<span class="nc bnc" id="L3481" title="All 2 branches missed.">                } else if (source != null) {</span>
<span class="nc" id="L3482">                    maxPadding = updateSize(p, source, position);</span>
                }
            }
<span class="nc bnc" id="L3485" title="All 2 branches missed.">            if (lastSize != UNSET) {</span>
<span class="nc" id="L3486">                size += Math.min(maxPadding, lastSize);</span>
            }
<span class="nc" id="L3488">        }</span>

        private int updateSize(LayoutStyle p, ComponentSpring sourceSpring,
                int position) {
<span class="nc" id="L3492">            int padding = 10;</span>
<span class="nc bnc" id="L3493" title="All 2 branches missed.">            if (sourceSpring.getComponent() instanceof JComponent) {</span>
<span class="nc" id="L3494">                padding = p.getContainerGap(</span>
<span class="nc" id="L3495">                        (JComponent)sourceSpring.getComponent(), position,</span>
<span class="nc" id="L3496">                        host);</span>
            }
<span class="nc" id="L3498">            int delta = Math.max(0, getParent().getSize() -</span>
<span class="nc" id="L3499">                    sourceSpring.getSize() - sourceSpring.getOrigin());</span>
<span class="nc" id="L3500">            size = Math.max(size, padding - delta);</span>
<span class="nc" id="L3501">            return padding;</span>
        }

        String getMatchDescription() {
<span class="nc bnc" id="L3505" title="All 2 branches missed.">            if (targets != null) {</span>
<span class="nc" id="L3506">                return &quot;leading: &quot; + targets.toString();</span>
            }
<span class="nc bnc" id="L3508" title="All 2 branches missed.">            if (sources != null) {</span>
<span class="nc" id="L3509">                return &quot;trailing: &quot; + sources.toString();</span>
            }
<span class="nc" id="L3511">            return &quot;--&quot;;</span>
        }
    }


    // LinkInfo contains the set of ComponentInfosthat are linked along a
    // particular axis.
<span class="nc bnc" id="L3518" title="All 2 branches missed.">    private static class LinkInfo {</span>
        private final int axis;
        private final List&lt;ComponentInfo&gt; linked;
        private int size;

<span class="nc" id="L3523">        LinkInfo(int axis) {</span>
<span class="nc" id="L3524">            linked = new ArrayList&lt;ComponentInfo&gt;();</span>
<span class="nc" id="L3525">            size = UNSET;</span>
<span class="nc" id="L3526">            this.axis = axis;</span>
<span class="nc" id="L3527">        }</span>

        public void add(ComponentInfo child) {
<span class="nc" id="L3530">            LinkInfo childMaster = child.getLinkInfo(axis, false);</span>
<span class="nc bnc" id="L3531" title="All 2 branches missed.">            if (childMaster == null) {</span>
<span class="nc" id="L3532">                linked.add(child);</span>
<span class="nc" id="L3533">                child.setLinkInfo(axis, this);</span>
<span class="nc bnc" id="L3534" title="All 2 branches missed.">            } else if (childMaster != this) {</span>
<span class="nc" id="L3535">                linked.addAll(childMaster.linked);</span>
<span class="nc bnc" id="L3536" title="All 2 branches missed.">                for (ComponentInfo childInfo : childMaster.linked) {</span>
<span class="nc" id="L3537">                    childInfo.setLinkInfo(axis, this);</span>
<span class="nc" id="L3538">                }</span>
            }
<span class="nc" id="L3540">            clearCachedSize();</span>
<span class="nc" id="L3541">        }</span>

        public void remove(ComponentInfo info) {
<span class="nc" id="L3544">            linked.remove(info);</span>
<span class="nc" id="L3545">            info.setLinkInfo(axis, null);</span>
<span class="nc bnc" id="L3546" title="All 2 branches missed.">            if (linked.size() == 1) {</span>
<span class="nc" id="L3547">                linked.get(0).setLinkInfo(axis, null);</span>
            }
<span class="nc" id="L3549">            clearCachedSize();</span>
<span class="nc" id="L3550">        }</span>

        public void clearCachedSize() {
<span class="nc" id="L3553">            size = UNSET;</span>
<span class="nc" id="L3554">        }</span>

        public int getSize(int axis) {
<span class="nc bnc" id="L3557" title="All 2 branches missed.">            if (size == UNSET) {</span>
<span class="nc" id="L3558">                size = calculateLinkedSize(axis);</span>
            }
<span class="nc" id="L3560">            return size;</span>
        }

        private int calculateLinkedSize(int axis) {
<span class="nc" id="L3564">            int size = 0;</span>
<span class="nc bnc" id="L3565" title="All 2 branches missed.">            for (ComponentInfo info : linked) {</span>
                ComponentSpring spring;
<span class="nc bnc" id="L3567" title="All 2 branches missed.">                if (axis == HORIZONTAL) {</span>
<span class="nc" id="L3568">                    spring = info.horizontalSpring;</span>
                } else {
<span class="nc bnc" id="L3570" title="All 4 branches missed.">                    assert (axis == VERTICAL);</span>
<span class="nc" id="L3571">                    spring = info.verticalSpring;</span>
                }
<span class="nc" id="L3573">                size = Math.max(size,</span>
<span class="nc" id="L3574">                        spring.calculateNonlinkedPreferredSize(axis));</span>
<span class="nc" id="L3575">            }</span>
<span class="nc" id="L3576">            return size;</span>
        }
    }

    /**
     * Tracks the horizontal/vertical Springs for a Component.
     * This class is also used to handle Springs that have their sizes
     * linked.
     */
<span class="nc bnc" id="L3585" title="All 2 branches missed.">    private class ComponentInfo {</span>
        // Component being layed out
        private Component component;

        ComponentSpring horizontalSpring;
        ComponentSpring verticalSpring;

        // If the component's size is linked to other components, the
        // horizontalMaster and/or verticalMaster reference the group of
        // linked components.
        private LinkInfo horizontalMaster;
        private LinkInfo verticalMaster;

        private boolean visible;
        private Boolean honorsVisibility;

<span class="nc" id="L3601">        ComponentInfo(Component component) {</span>
<span class="nc" id="L3602">            this.component = component;</span>
<span class="nc" id="L3603">            updateVisibility();</span>
<span class="nc" id="L3604">        }</span>

        public void dispose() {
            // Remove horizontal/vertical springs
<span class="nc" id="L3608">            removeSpring(horizontalSpring);</span>
<span class="nc" id="L3609">            horizontalSpring = null;</span>
<span class="nc" id="L3610">            removeSpring(verticalSpring);</span>
<span class="nc" id="L3611">            verticalSpring = null;</span>
            // Clean up links
<span class="nc bnc" id="L3613" title="All 2 branches missed.">            if (horizontalMaster != null) {</span>
<span class="nc" id="L3614">                horizontalMaster.remove(this);</span>
            }
<span class="nc bnc" id="L3616" title="All 2 branches missed.">            if (verticalMaster != null) {</span>
<span class="nc" id="L3617">                verticalMaster.remove(this);</span>
            }
<span class="nc" id="L3619">        }</span>

        void setHonorsVisibility(Boolean honorsVisibility) {
<span class="nc" id="L3622">            this.honorsVisibility = honorsVisibility;</span>
<span class="nc" id="L3623">        }</span>

        private void removeSpring(Spring spring) {
<span class="nc bnc" id="L3626" title="All 2 branches missed.">            if (spring != null) {</span>
<span class="nc" id="L3627">                ((Group)spring.getParent()).springs.remove(spring);</span>
            }
<span class="nc" id="L3629">        }</span>

        public boolean isVisible() {
<span class="nc" id="L3632">            return visible;</span>
        }

        /**
         * Updates the cached visibility.
         *
         * @return true if the visibility changed
         */
        boolean updateVisibility() {
            boolean honorsVisibility;
<span class="nc bnc" id="L3642" title="All 2 branches missed.">            if (this.honorsVisibility == null) {</span>
<span class="nc" id="L3643">                honorsVisibility = GroupLayout.this.getHonorsVisibility();</span>
            } else {
<span class="nc" id="L3645">                honorsVisibility = this.honorsVisibility;</span>
            }
<span class="nc bnc" id="L3647" title="All 2 branches missed.">            boolean newVisible = (honorsVisibility) ?</span>
<span class="nc" id="L3648">                component.isVisible() : true;</span>
<span class="nc bnc" id="L3649" title="All 2 branches missed.">            if (visible != newVisible) {</span>
<span class="nc" id="L3650">                visible = newVisible;</span>
<span class="nc" id="L3651">                return true;</span>
            }
<span class="nc" id="L3653">            return false;</span>
        }

        public void setBounds(Insets insets, int parentWidth, boolean ltr) {
<span class="nc" id="L3657">            int x = horizontalSpring.getOrigin();</span>
<span class="nc" id="L3658">            int w = horizontalSpring.getSize();</span>
<span class="nc" id="L3659">            int y = verticalSpring.getOrigin();</span>
<span class="nc" id="L3660">            int h = verticalSpring.getSize();</span>

<span class="nc bnc" id="L3662" title="All 2 branches missed.">            if (!ltr) {</span>
<span class="nc" id="L3663">                x = parentWidth - x - w;</span>
            }
<span class="nc" id="L3665">            component.setBounds(x + insets.left, y + insets.top, w, h);</span>
<span class="nc" id="L3666">        }</span>

        public void setComponent(Component component) {
<span class="nc" id="L3669">            this.component = component;</span>
<span class="nc bnc" id="L3670" title="All 2 branches missed.">            if (horizontalSpring != null) {</span>
<span class="nc" id="L3671">                horizontalSpring.setComponent(component);</span>
            }
<span class="nc bnc" id="L3673" title="All 2 branches missed.">            if (verticalSpring != null) {</span>
<span class="nc" id="L3674">                verticalSpring.setComponent(component);</span>
            }
<span class="nc" id="L3676">        }</span>

        public Component getComponent() {
<span class="nc" id="L3679">            return component;</span>
        }

        /**
         * Returns true if this component has its size linked to
         * other components.
         */
        public boolean isLinked(int axis) {
<span class="nc bnc" id="L3687" title="All 2 branches missed.">            if (axis == HORIZONTAL) {</span>
<span class="nc bnc" id="L3688" title="All 2 branches missed.">                return horizontalMaster != null;</span>
            }
<span class="nc bnc" id="L3690" title="All 4 branches missed.">            assert (axis == VERTICAL);</span>
<span class="nc bnc" id="L3691" title="All 2 branches missed.">            return (verticalMaster != null);</span>
        }

        private void setLinkInfo(int axis, LinkInfo linkInfo) {
<span class="nc bnc" id="L3695" title="All 2 branches missed.">            if (axis == HORIZONTAL) {</span>
<span class="nc" id="L3696">                horizontalMaster = linkInfo;</span>
            } else {
<span class="nc bnc" id="L3698" title="All 4 branches missed.">                assert (axis == VERTICAL);</span>
<span class="nc" id="L3699">                verticalMaster = linkInfo;</span>
            }
<span class="nc" id="L3701">        }</span>

        public LinkInfo getLinkInfo(int axis) {
<span class="nc" id="L3704">            return getLinkInfo(axis, true);</span>
        }

        private LinkInfo getLinkInfo(int axis, boolean create) {
<span class="nc bnc" id="L3708" title="All 2 branches missed.">            if (axis == HORIZONTAL) {</span>
<span class="nc bnc" id="L3709" title="All 4 branches missed.">                if (horizontalMaster == null &amp;&amp; create) {</span>
                    // horizontalMaster field is directly set by adding
                    // us to the LinkInfo.
<span class="nc" id="L3712">                    new LinkInfo(HORIZONTAL).add(this);</span>
                }
<span class="nc" id="L3714">                return horizontalMaster;</span>
            } else {
<span class="nc bnc" id="L3716" title="All 4 branches missed.">                assert (axis == VERTICAL);</span>
<span class="nc bnc" id="L3717" title="All 4 branches missed.">                if (verticalMaster == null &amp;&amp; create) {</span>
                    // verticalMaster field is directly set by adding
                    // us to the LinkInfo.
<span class="nc" id="L3720">                    new LinkInfo(VERTICAL).add(this);</span>
                }
<span class="nc" id="L3722">                return verticalMaster;</span>
            }
        }

        public void clearCachedSize() {
<span class="nc bnc" id="L3727" title="All 2 branches missed.">            if (horizontalMaster != null) {</span>
<span class="nc" id="L3728">                horizontalMaster.clearCachedSize();</span>
            }
<span class="nc bnc" id="L3730" title="All 2 branches missed.">            if (verticalMaster != null) {</span>
<span class="nc" id="L3731">                verticalMaster.clearCachedSize();</span>
            }
<span class="nc" id="L3733">        }</span>

        int getLinkSize(int axis, int type) {
<span class="nc bnc" id="L3736" title="All 2 branches missed.">            if (axis == HORIZONTAL) {</span>
<span class="nc" id="L3737">                return horizontalMaster.getSize(axis);</span>
            } else {
<span class="nc bnc" id="L3739" title="All 4 branches missed.">                assert (axis == VERTICAL);</span>
<span class="nc" id="L3740">                return verticalMaster.getSize(axis);</span>
            }
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>