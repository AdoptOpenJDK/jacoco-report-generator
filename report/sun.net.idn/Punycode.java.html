<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Punycode.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.net.idn</a> &gt; <span class="el_source">Punycode.java</span></div><h1>Punycode.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *******************************************************************************
 * Copyright (C) 2003-2004, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
//
// CHANGELOG
//      2005-05-19 Edward Wang
//          - copy this file from icu4jsrc_3_2/src/com/ibm/icu/text/Punycode.java
//          - move from package com.ibm.icu.text to package sun.net.idn
//          - use ParseException instead of StringPrepParseException
//      2007-08-14 Martin Buchholz
//          - remove redundant casts
//
package sun.net.idn;

import java.text.ParseException;
import sun.text.normalizer.UCharacter;
import sun.text.normalizer.UTF16;

/**
 * Ported code from ICU punycode.c
 * @author ram
 */

/* Package Private class */
<span class="nc" id="L51">public final class Punycode {</span>

    /* Punycode parameters for Bootstring */
    private static final int BASE           = 36;
    private static final int TMIN           = 1;
    private static final int TMAX           = 26;
    private static final int SKEW           = 38;
    private static final int DAMP           = 700;
    private static final int INITIAL_BIAS   = 72;
    private static final int INITIAL_N      = 0x80;

    /* &quot;Basic&quot; Unicode/ASCII code points */
    private static final int HYPHEN         = 0x2d;
    private static final int DELIMITER      = HYPHEN;

    private static final int ZERO           = 0x30;
    private static final int NINE           = 0x39;

    private static final int SMALL_A        = 0x61;
    private static final int SMALL_Z        = 0x7a;

    private static final int CAPITAL_A      = 0x41;
    private static final int CAPITAL_Z      = 0x5a;

    //  TODO: eliminate the 256 limitation
    private static final int MAX_CP_COUNT   = 256;

    private static final int UINT_MAGIC     = 0x80000000;
    private static final long ULONG_MAGIC   = 0x8000000000000000L;

    private static int adaptBias(int delta, int length, boolean firstTime){
<span class="fc bfc" id="L82" title="All 2 branches covered.">        if(firstTime){</span>
<span class="fc" id="L83">            delta /=DAMP;</span>
        }else{
<span class="fc" id="L85">            delta /=  2;</span>
        }
<span class="fc" id="L87">        delta += delta/length;</span>

<span class="fc" id="L89">        int count=0;</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        for(; delta&gt;((BASE-TMIN)*TMAX)/2; count+=BASE) {</span>
<span class="fc" id="L91">            delta/=(BASE-TMIN);</span>
        }

<span class="fc" id="L94">        return count+(((BASE-TMIN+1)*delta)/(delta+SKEW));</span>
    }

    /**
     * basicToDigit[] contains the numeric value of a basic code
     * point (for use in representing integers) in the range 0 to
     * BASE-1, or -1 if b is does not represent a value.
     */
<span class="fc" id="L102">    static final int[]    basicToDigit= new int[]{</span>
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1, -1,

        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,

        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

    private static char asciiCaseMap(char b, boolean uppercase) {
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if(uppercase) {</span>
<span class="pc bpc" id="L130" title="3 of 4 branches missed.">            if(SMALL_A&lt;=b &amp;&amp; b&lt;=SMALL_Z) {</span>
<span class="nc" id="L131">                b-=(SMALL_A-CAPITAL_A);</span>
            }
        } else {
<span class="pc bpc" id="L134" title="1 of 4 branches missed.">            if(CAPITAL_A&lt;=b &amp;&amp; b&lt;=CAPITAL_Z) {</span>
<span class="nc" id="L135">                b+=(SMALL_A-CAPITAL_A);</span>
            }
        }
<span class="fc" id="L138">        return b;</span>
    }

    /**
     * digitToBasic() returns the basic code point whose value
     * (when used for representing integers) is d, which must be in the
     * range 0 to BASE-1. The lowercase form is used unless the uppercase flag is
     * nonzero, in which case the uppercase form is used.
     */
    private static char digitToBasic(int digit, boolean uppercase) {
        /*  0..25 map to ASCII a..z or A..Z */
        /* 26..35 map to ASCII 0..9         */
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if(digit&lt;26) {</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            if(uppercase) {</span>
<span class="fc" id="L152">                return (char)(CAPITAL_A+digit);</span>
            } else {
<span class="fc" id="L154">                return (char)(SMALL_A+digit);</span>
            }
        } else {
<span class="fc" id="L157">            return (char)((ZERO-26)+digit);</span>
        }
    }
    /**
     * Converts Unicode to Punycode.
     * The input string must not contain single, unpaired surrogates.
     * The output will be represented as an array of ASCII code points.
     *
     * @param src
     * @param caseFlags
     * @return
     * @throws ParseException
     */
    public static StringBuffer encode(StringBuffer src, boolean[] caseFlags) throws ParseException{

<span class="fc" id="L172">        int[] cpBuffer = new int[MAX_CP_COUNT];</span>
        int n, delta, handledCPCount, basicLength, destLength, bias, j, m, q, k, t, srcCPCount;
        char c, c2;
<span class="fc" id="L175">        int srcLength = src.length();</span>
<span class="fc" id="L176">        int destCapacity = MAX_CP_COUNT;</span>
<span class="fc" id="L177">        char[] dest = new char[destCapacity];</span>
<span class="fc" id="L178">        StringBuffer result = new StringBuffer();</span>
        /*
         * Handle the basic code points and
         * convert extended ones to UTF-32 in cpBuffer (caseFlag in sign bit):
         */
<span class="fc" id="L183">        srcCPCount=destLength=0;</span>

<span class="fc bfc" id="L185" title="All 2 branches covered.">        for(j=0; j&lt;srcLength; ++j) {</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">            if(srcCPCount==MAX_CP_COUNT) {</span>
                /* too many input code points */
<span class="nc" id="L188">                throw new IndexOutOfBoundsException();</span>
            }
<span class="fc" id="L190">            c=src.charAt(j);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if(isBasic(c)) {</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                if(destLength&lt;destCapacity) {</span>
<span class="fc" id="L193">                    cpBuffer[srcCPCount++]=0;</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">                    dest[destLength]=</span>
                        caseFlags!=null ?
<span class="pc" id="L196">                            asciiCaseMap(c, caseFlags[j]) :</span>
                            c;
                }
<span class="fc" id="L199">                ++destLength;</span>
            } else {
<span class="pc bpc" id="L201" title="1 of 4 branches missed.">                n=((caseFlags!=null &amp;&amp; caseFlags[j])? 1 : 0)&lt;&lt;31L;</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">                if(!UTF16.isSurrogate(c)) {</span>
<span class="fc" id="L203">                    n|=c;</span>
<span class="nc bnc" id="L204" title="All 6 branches missed.">                } else if(UTF16.isLeadSurrogate(c) &amp;&amp; (j+1)&lt;srcLength &amp;&amp; UTF16.isTrailSurrogate(c2=src.charAt(j+1))) {</span>
<span class="nc" id="L205">                    ++j;</span>

<span class="nc" id="L207">                    n|=UCharacter.getCodePoint(c, c2);</span>
                } else {
                    /* error: unmatched surrogate */
<span class="nc" id="L210">                    throw new ParseException(&quot;Illegal char found&quot;, -1);</span>
                }
<span class="fc" id="L212">                cpBuffer[srcCPCount++]=n;</span>
            }
        }

        /* Finish the basic string - if it is not empty - with a delimiter. */
<span class="fc" id="L217">        basicLength=destLength;</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if(basicLength&gt;0) {</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">            if(destLength&lt;destCapacity) {</span>
<span class="fc" id="L220">                dest[destLength]=DELIMITER;</span>
            }
<span class="fc" id="L222">            ++destLength;</span>
        }

        /*
         * handledCPCount is the number of code points that have been handled
         * basicLength is the number of basic code points
         * destLength is the number of chars that have been output
         */

        /* Initialize the state: */
<span class="fc" id="L232">        n=INITIAL_N;</span>
<span class="fc" id="L233">        delta=0;</span>
<span class="fc" id="L234">        bias=INITIAL_BIAS;</span>

        /* Main encoding loop: */
<span class="fc bfc" id="L237" title="All 2 branches covered.">        for(handledCPCount=basicLength; handledCPCount&lt;srcCPCount; /* no op */) {</span>
            /*
             * All non-basic code points &lt; n have been handled already.
             * Find the next larger one:
             */
<span class="fc bfc" id="L242" title="All 2 branches covered.">            for(m=0x7fffffff, j=0; j&lt;srcCPCount; ++j) {</span>
<span class="fc" id="L243">                q=cpBuffer[j]&amp;0x7fffffff; /* remove case flag from the sign bit */</span>
<span class="fc bfc" id="L244" title="All 4 branches covered.">                if(n&lt;=q &amp;&amp; q&lt;m) {</span>
<span class="fc" id="L245">                    m=q;</span>
                }
            }

            /*
             * Increase delta enough to advance the decoder's
             * &lt;n,i&gt; state to &lt;m,0&gt;, but guard against overflow:
             */
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">            if(m-n&gt;(0x7fffffff-MAX_CP_COUNT-delta)/(handledCPCount+1)) {</span>
<span class="nc" id="L254">                throw new RuntimeException(&quot;Internal program error&quot;);</span>
            }
<span class="fc" id="L256">            delta+=(m-n)*(handledCPCount+1);</span>
<span class="fc" id="L257">            n=m;</span>

            /* Encode a sequence of same code points n */
<span class="fc bfc" id="L260" title="All 2 branches covered.">            for(j=0; j&lt;srcCPCount; ++j) {</span>
<span class="fc" id="L261">                q=cpBuffer[j]&amp;0x7fffffff; /* remove case flag from the sign bit */</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">                if(q&lt;n) {</span>
<span class="fc" id="L263">                    ++delta;</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">                } else if(q==n) {</span>
                    /* Represent delta as a generalized variable-length integer: */
<span class="fc" id="L266">                    for(q=delta, k=BASE; /* no condition */; k+=BASE) {</span>

                        /** RAM: comment out the old code for conformance with draft-ietf-idn-punycode-03.txt

                        t=k-bias;
                        if(t&lt;TMIN) {
                            t=TMIN;
                        } else if(t&gt;TMAX) {
                            t=TMAX;
                        }
                        */

<span class="fc" id="L278">                        t=k-bias;</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">                        if(t&lt;TMIN) {</span>
<span class="fc" id="L280">                            t=TMIN;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">                        } else if(k&gt;=(bias+TMAX)) {</span>
<span class="fc" id="L282">                            t=TMAX;</span>
                        }

<span class="fc bfc" id="L285" title="All 2 branches covered.">                        if(q&lt;t) {</span>
<span class="fc" id="L286">                            break;</span>
                        }

<span class="pc bpc" id="L289" title="1 of 2 branches missed.">                        if(destLength&lt;destCapacity) {</span>
<span class="fc" id="L290">                            dest[destLength++]=digitToBasic(t+(q-t)%(BASE-t), false);</span>
                        }
<span class="fc" id="L292">                        q=(q-t)/(BASE-t);</span>
                    }

<span class="pc bpc" id="L295" title="1 of 2 branches missed.">                    if(destLength&lt;destCapacity) {</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">                        dest[destLength++]=digitToBasic(q, (cpBuffer[j]&lt;0));</span>
                    }
<span class="fc bfc" id="L298" title="All 2 branches covered.">                    bias=adaptBias(delta, handledCPCount+1,(handledCPCount==basicLength));</span>
<span class="fc" id="L299">                    delta=0;</span>
<span class="fc" id="L300">                    ++handledCPCount;</span>
                }
            }

<span class="fc" id="L304">            ++delta;</span>
<span class="fc" id="L305">            ++n;</span>
        }

<span class="fc" id="L308">        return result.append(dest, 0, destLength);</span>
    }

    private static boolean isBasic(int ch){
<span class="fc bfc" id="L312" title="All 2 branches covered.">        return (ch &lt; INITIAL_N);</span>
    }

    private static boolean isBasicUpperCase(int ch){
<span class="fc bfc" id="L316" title="All 4 branches covered.">        return( CAPITAL_A &lt;= ch &amp;&amp; ch &lt;= CAPITAL_Z);</span>
    }

    private static boolean isSurrogate(int ch){
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        return (((ch)&amp;0xfffff800)==0xd800);</span>
    }
    /**
     * Converts Punycode to Unicode.
     * The Unicode string will be at most as long as the Punycode string.
     *
     * @param src
     * @param caseFlags
     * @return
     * @throws ParseException
     */
    public static StringBuffer decode(StringBuffer src, boolean[] caseFlags)
                               throws ParseException{
<span class="fc" id="L333">        int srcLength = src.length();</span>
<span class="fc" id="L334">        StringBuffer result = new StringBuffer();</span>
        int n, destLength, i, bias, basicLength, j, in, oldi, w, k, digit, t,
                destCPCount, firstSupplementaryIndex, cpLength;
        char b;
<span class="fc" id="L338">        int destCapacity = MAX_CP_COUNT;</span>
<span class="fc" id="L339">        char[] dest = new char[destCapacity];</span>

        /*
         * Handle the basic code points:
         * Let basicLength be the number of input code points
         * before the last delimiter, or 0 if there is none,
         * then copy the first basicLength code points to the output.
         *
         * The two following loops iterate backward.
         */
<span class="fc bfc" id="L349" title="All 2 branches covered.">        for(j=srcLength; j&gt;0;) {</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            if(src.charAt(--j)==DELIMITER) {</span>
<span class="fc" id="L351">                break;</span>
            }
        }
<span class="fc" id="L354">        destLength=basicLength=destCPCount=j;</span>

<span class="fc bfc" id="L356" title="All 2 branches covered.">        while(j&gt;0) {</span>
<span class="fc" id="L357">            b=src.charAt(--j);</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">            if(!isBasic(b)) {</span>
<span class="nc" id="L359">                throw new ParseException(&quot;Illegal char found&quot;, -1);</span>
            }

<span class="pc bpc" id="L362" title="1 of 2 branches missed.">            if(j&lt;destCapacity) {</span>
<span class="fc" id="L363">                dest[j]= b;</span>

<span class="pc bpc" id="L365" title="1 of 2 branches missed.">                if(caseFlags!=null) {</span>
<span class="fc" id="L366">                    caseFlags[j]=isBasicUpperCase(b);</span>
                }
            }
        }

        /* Initialize the state: */
<span class="fc" id="L372">        n=INITIAL_N;</span>
<span class="fc" id="L373">        i=0;</span>
<span class="fc" id="L374">        bias=INITIAL_BIAS;</span>
<span class="fc" id="L375">        firstSupplementaryIndex=1000000000;</span>

        /*
         * Main decoding loop:
         * Start just after the last delimiter if any
         * basic code points were copied; start at the beginning otherwise.
         */
<span class="fc bfc" id="L382" title="All 4 branches covered.">        for(in=basicLength&gt;0 ? basicLength+1 : 0; in&lt;srcLength; /* no op */) {</span>
            /*
             * in is the index of the next character to be consumed, and
             * destCPCount is the number of code points in the output array.
             *
             * Decode a generalized variable-length integer into delta,
             * which gets added to i.  The overflow checking is easier
             * if we increase i as we go, then subtract off its starting
             * value at the end to obtain delta.
             */
<span class="fc" id="L392">            for(oldi=i, w=1, k=BASE; /* no condition */; k+=BASE) {</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">                if(in&gt;=srcLength) {</span>
<span class="nc" id="L394">                    throw new ParseException(&quot;Illegal char found&quot;, -1);</span>
                }

<span class="fc" id="L397">                digit=basicToDigit[(byte)src.charAt(in++)];</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">                if(digit&lt;0) {</span>
<span class="nc" id="L399">                    throw new ParseException(&quot;Invalid char found&quot;, -1);</span>
                }
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">                if(digit&gt;(0x7fffffff-i)/w) {</span>
                    /* integer overflow */
<span class="nc" id="L403">                    throw new ParseException(&quot;Illegal char found&quot;, -1);</span>
                }

<span class="fc" id="L406">                i+=digit*w;</span>
<span class="fc" id="L407">                t=k-bias;</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                if(t&lt;TMIN) {</span>
<span class="fc" id="L409">                    t=TMIN;</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">                } else if(k&gt;=(bias+TMAX)) {</span>
<span class="fc" id="L411">                    t=TMAX;</span>
                }
<span class="fc bfc" id="L413" title="All 2 branches covered.">                if(digit&lt;t) {</span>
<span class="fc" id="L414">                    break;</span>
                }

<span class="pc bpc" id="L417" title="1 of 2 branches missed.">                if(w&gt;0x7fffffff/(BASE-t)) {</span>
                    /* integer overflow */
<span class="nc" id="L419">                    throw new ParseException(&quot;Illegal char found&quot;, -1);</span>
                }
<span class="fc" id="L421">                w*=BASE-t;</span>
            }

            /*
             * Modification from sample code:
             * Increments destCPCount here,
             * where needed instead of in for() loop tail.
             */
<span class="fc" id="L429">            ++destCPCount;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">            bias=adaptBias(i-oldi, destCPCount, (oldi==0));</span>

            /*
             * i was supposed to wrap around from (incremented) destCPCount to 0,
             * incrementing n each time, so we'll fix that now:
             */
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">            if(i/destCPCount&gt;(0x7fffffff-n)) {</span>
                /* integer overflow */
<span class="nc" id="L438">                throw new ParseException(&quot;Illegal char found&quot;, -1);</span>
            }

<span class="fc" id="L441">            n+=i/destCPCount;</span>
<span class="fc" id="L442">            i%=destCPCount;</span>
            /* not needed for Punycode: */
            /* if (decode_digit(n) &lt;= BASE) return punycode_invalid_input; */

<span class="pc bpc" id="L446" title="2 of 4 branches missed.">            if(n&gt;0x10ffff || isSurrogate(n)) {</span>
                /* Unicode code point overflow */
<span class="nc" id="L448">                throw new ParseException(&quot;Illegal char found&quot;, -1);</span>
            }

            /* Insert n at position i of the output: */
<span class="fc" id="L452">            cpLength=UTF16.getCharCount(n);</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">            if((destLength+cpLength)&lt;destCapacity) {</span>
                int codeUnitIndex;

                /*
                 * Handle indexes when supplementary code points are present.
                 *
                 * In almost all cases, there will be only BMP code points before i
                 * and even in the entire string.
                 * This is handled with the same efficiency as with UTF-32.
                 *
                 * Only the rare cases with supplementary code points are handled
                 * more slowly - but not too bad since this is an insertion anyway.
                 */
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">                if(i&lt;=firstSupplementaryIndex) {</span>
<span class="fc" id="L467">                    codeUnitIndex=i;</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">                    if(cpLength&gt;1) {</span>
<span class="nc" id="L469">                        firstSupplementaryIndex=codeUnitIndex;</span>
                    } else {
<span class="fc" id="L471">                        ++firstSupplementaryIndex;</span>
                    }
                } else {
<span class="nc" id="L474">                    codeUnitIndex=firstSupplementaryIndex;</span>
<span class="nc" id="L475">                    codeUnitIndex=UTF16.moveCodePointOffset(dest, 0, destLength, codeUnitIndex, i-codeUnitIndex);</span>
                }

                /* use the UChar index codeUnitIndex instead of the code point index i */
<span class="fc bfc" id="L479" title="All 2 branches covered.">                if(codeUnitIndex&lt;destLength) {</span>
<span class="fc" id="L480">                    System.arraycopy(dest, codeUnitIndex,</span>
                                     dest, codeUnitIndex+cpLength,
                                    (destLength-codeUnitIndex));
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">                    if(caseFlags!=null) {</span>
<span class="fc" id="L484">                        System.arraycopy(caseFlags, codeUnitIndex,</span>
                                         caseFlags, codeUnitIndex+cpLength,
                                         destLength-codeUnitIndex);
                    }
                }
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">                if(cpLength==1) {</span>
                    /* BMP, insert one code unit */
<span class="fc" id="L491">                    dest[codeUnitIndex]=(char)n;</span>
                } else {
                    /* supplementary character, insert two code units */
<span class="nc" id="L494">                    dest[codeUnitIndex]=UTF16.getLeadSurrogate(n);</span>
<span class="nc" id="L495">                    dest[codeUnitIndex+1]=UTF16.getTrailSurrogate(n);</span>
                }
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">                if(caseFlags!=null) {</span>
                    /* Case of last character determines uppercase flag: */
<span class="fc" id="L499">                    caseFlags[codeUnitIndex]=isBasicUpperCase(src.charAt(in-1));</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">                    if(cpLength==2) {</span>
<span class="nc" id="L501">                        caseFlags[codeUnitIndex+1]=false;</span>
                    }
                }
            }
<span class="fc" id="L505">            destLength+=cpLength;</span>
<span class="fc" id="L506">            ++i;</span>
        }
<span class="fc" id="L508">        result.append(dest, 0, destLength);</span>
<span class="fc" id="L509">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>