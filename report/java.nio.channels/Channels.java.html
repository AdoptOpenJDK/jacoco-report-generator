<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Channels.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.nio.channels</a> &gt; <span class="el_source">Channels.java</span></div><h1>Channels.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.nio.channels;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.UnsupportedCharsetException;
import java.nio.channels.spi.AbstractInterruptibleChannel;
import java.util.concurrent.ExecutionException;
import sun.nio.ch.ChannelInputStream;
import sun.nio.cs.StreamDecoder;
import sun.nio.cs.StreamEncoder;


/**
 * Utility methods for channels and streams.
 *
 * &lt;p&gt; This class defines static methods that support the interoperation of the
 * stream classes of the &lt;tt&gt;{@link java.io}&lt;/tt&gt; package with the channel
 * classes of this package.  &lt;/p&gt;
 *
 *
 * @author Mark Reinhold
 * @author Mike McCloskey
 * @author JSR-51 Expert Group
 * @since 1.4
 */

public final class Channels {

<span class="nc" id="L63">    private Channels() { }              // No instantiation</span>

    private static void checkNotNull(Object o, String name) {
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">        if (o == null)</span>
<span class="nc" id="L67">            throw new NullPointerException(&quot;\&quot;&quot; + name + &quot;\&quot; is null!&quot;);</span>
<span class="fc" id="L68">    }</span>

    /**
     * Write all remaining bytes in buffer to the given channel.
     * If the channel is selectable then it must be configured blocking.
     */
    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)
        throws IOException
    {
<span class="fc bfc" id="L77" title="All 2 branches covered.">        while (bb.remaining() &gt; 0) {</span>
<span class="fc" id="L78">            int n = ch.write(bb);</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">            if (n &lt;= 0)</span>
<span class="nc" id="L80">                throw new RuntimeException(&quot;no bytes written&quot;);</span>
<span class="fc" id="L81">        }</span>
<span class="fc" id="L82">    }</span>

    /**
     * Write all remaining bytes in buffer to the given channel.
     *
     * @throws  IllegalBlockingModeException
     *          If the channel is selectable and configured non-blocking.
     */
    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)
        throws IOException
    {
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (ch instanceof SelectableChannel) {</span>
<span class="fc" id="L94">            SelectableChannel sc = (SelectableChannel)ch;</span>
<span class="fc" id="L95">            synchronized (sc.blockingLock()) {</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">                if (!sc.isBlocking())</span>
<span class="nc" id="L97">                    throw new IllegalBlockingModeException();</span>
<span class="fc" id="L98">                writeFullyImpl(ch, bb);</span>
<span class="pc" id="L99">            }</span>
<span class="fc" id="L100">        } else {</span>
<span class="fc" id="L101">            writeFullyImpl(ch, bb);</span>
        }
<span class="fc" id="L103">    }</span>

    // -- Byte streams from channels --

    /**
     * Constructs a stream that reads bytes from the given channel.
     *
     * &lt;p&gt; The &lt;tt&gt;read&lt;/tt&gt; methods of the resulting stream will throw an
     * {@link IllegalBlockingModeException} if invoked while the underlying
     * channel is in non-blocking mode.  The stream will not be buffered, and
     * it will not support the {@link InputStream#mark mark} or {@link
     * InputStream#reset reset} methods.  The stream will be safe for access by
     * multiple concurrent threads.  Closing the stream will in turn cause the
     * channel to be closed.  &lt;/p&gt;
     *
     * @param  ch
     *         The channel from which bytes will be read
     *
     * @return  A new input stream
     */
    public static InputStream newInputStream(ReadableByteChannel ch) {
<span class="fc" id="L124">        checkNotNull(ch, &quot;ch&quot;);</span>
<span class="fc" id="L125">        return new sun.nio.ch.ChannelInputStream(ch);</span>
    }

    /**
     * Constructs a stream that writes bytes to the given channel.
     *
     * &lt;p&gt; The &lt;tt&gt;write&lt;/tt&gt; methods of the resulting stream will throw an
     * {@link IllegalBlockingModeException} if invoked while the underlying
     * channel is in non-blocking mode.  The stream will not be buffered.  The
     * stream will be safe for access by multiple concurrent threads.  Closing
     * the stream will in turn cause the channel to be closed.  &lt;/p&gt;
     *
     * @param  ch
     *         The channel to which bytes will be written
     *
     * @return  A new output stream
     */
    public static OutputStream newOutputStream(final WritableByteChannel ch) {
<span class="fc" id="L143">        checkNotNull(ch, &quot;ch&quot;);</span>

<span class="fc" id="L145">        return new OutputStream() {</span>

<span class="fc" id="L147">                private ByteBuffer bb = null;</span>
<span class="fc" id="L148">                private byte[] bs = null;       // Invoker's previous array</span>
<span class="fc" id="L149">                private byte[] b1 = null;</span>

                public synchronized void write(int b) throws IOException {
<span class="fc bfc" id="L152" title="All 2 branches covered.">                   if (b1 == null)</span>
<span class="fc" id="L153">                        b1 = new byte[1];</span>
<span class="fc" id="L154">                    b1[0] = (byte)b;</span>
<span class="fc" id="L155">                    this.write(b1);</span>
<span class="fc" id="L156">                }</span>

                public synchronized void write(byte[] bs, int off, int len)
                    throws IOException
                {
<span class="pc bpc" id="L161" title="5 of 10 branches missed.">                    if ((off &lt; 0) || (off &gt; bs.length) || (len &lt; 0) ||</span>
                        ((off + len) &gt; bs.length) || ((off + len) &lt; 0)) {
<span class="nc" id="L163">                        throw new IndexOutOfBoundsException();</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">                    } else if (len == 0) {</span>
<span class="nc" id="L165">                        return;</span>
                    }
<span class="fc bfc" id="L167" title="All 2 branches covered.">                    ByteBuffer bb = ((this.bs == bs)</span>
                                     ? this.bb
<span class="fc" id="L169">                                     : ByteBuffer.wrap(bs));</span>
<span class="fc" id="L170">                    bb.limit(Math.min(off + len, bb.capacity()));</span>
<span class="fc" id="L171">                    bb.position(off);</span>
<span class="fc" id="L172">                    this.bb = bb;</span>
<span class="fc" id="L173">                    this.bs = bs;</span>
<span class="fc" id="L174">                    Channels.writeFully(ch, bb);</span>
<span class="fc" id="L175">                }</span>

                public void close() throws IOException {
<span class="fc" id="L178">                    ch.close();</span>
<span class="fc" id="L179">                }</span>

            };
    }

    /**
     * Constructs a stream that reads bytes from the given channel.
     *
     * &lt;p&gt; The stream will not be buffered, and it will not support the {@link
     * InputStream#mark mark} or {@link InputStream#reset reset} methods.  The
     * stream will be safe for access by multiple concurrent threads.  Closing
     * the stream will in turn cause the channel to be closed.  &lt;/p&gt;
     *
     * @param  ch
     *         The channel from which bytes will be read
     *
     * @return  A new input stream
     *
     * @since 1.7
     */
    public static InputStream newInputStream(final AsynchronousByteChannel ch) {
<span class="nc" id="L200">        checkNotNull(ch, &quot;ch&quot;);</span>
<span class="nc" id="L201">        return new InputStream() {</span>

<span class="nc" id="L203">            private ByteBuffer bb = null;</span>
<span class="nc" id="L204">            private byte[] bs = null;           // Invoker's previous array</span>
<span class="nc" id="L205">            private byte[] b1 = null;</span>

            @Override
            public synchronized int read() throws IOException {
<span class="nc bnc" id="L209" title="All 2 branches missed.">                if (b1 == null)</span>
<span class="nc" id="L210">                    b1 = new byte[1];</span>
<span class="nc" id="L211">                int n = this.read(b1);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">                if (n == 1)</span>
<span class="nc" id="L213">                    return b1[0] &amp; 0xff;</span>
<span class="nc" id="L214">                return -1;</span>
            }

            @Override
            public synchronized int read(byte[] bs, int off, int len)
                throws IOException
            {
<span class="nc bnc" id="L221" title="All 10 branches missed.">                if ((off &lt; 0) || (off &gt; bs.length) || (len &lt; 0) ||</span>
                    ((off + len) &gt; bs.length) || ((off + len) &lt; 0)) {
<span class="nc" id="L223">                    throw new IndexOutOfBoundsException();</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">                } else if (len == 0)</span>
<span class="nc" id="L225">                    return 0;</span>

<span class="nc bnc" id="L227" title="All 2 branches missed.">                ByteBuffer bb = ((this.bs == bs)</span>
                                 ? this.bb
<span class="nc" id="L229">                                 : ByteBuffer.wrap(bs));</span>
<span class="nc" id="L230">                bb.position(off);</span>
<span class="nc" id="L231">                bb.limit(Math.min(off + len, bb.capacity()));</span>
<span class="nc" id="L232">                this.bb = bb;</span>
<span class="nc" id="L233">                this.bs = bs;</span>

<span class="nc" id="L235">                boolean interrupted = false;</span>
                try {
                    for (;;) {
                        try {
<span class="nc" id="L239">                            return ch.read(bb).get();</span>
<span class="nc" id="L240">                        } catch (ExecutionException ee) {</span>
<span class="nc" id="L241">                            throw new IOException(ee.getCause());</span>
<span class="nc" id="L242">                        } catch (InterruptedException ie) {</span>
<span class="nc" id="L243">                            interrupted = true;</span>
<span class="nc" id="L244">                        }</span>
                    }
                } finally {
<span class="nc bnc" id="L247" title="All 4 branches missed.">                    if (interrupted)</span>
<span class="nc" id="L248">                        Thread.currentThread().interrupt();</span>
                }
            }

            @Override
            public void close() throws IOException {
<span class="nc" id="L254">                ch.close();</span>
<span class="nc" id="L255">            }</span>
        };
    }

    /**
     * Constructs a stream that writes bytes to the given channel.
     *
     * &lt;p&gt; The stream will not be buffered. The stream will be safe for access
     * by multiple concurrent threads.  Closing the stream will in turn cause
     * the channel to be closed.  &lt;/p&gt;
     *
     * @param  ch
     *         The channel to which bytes will be written
     *
     * @return  A new output stream
     *
     * @since 1.7
     */
    public static OutputStream newOutputStream(final AsynchronousByteChannel ch) {
<span class="nc" id="L274">        checkNotNull(ch, &quot;ch&quot;);</span>
<span class="nc" id="L275">        return new OutputStream() {</span>

<span class="nc" id="L277">            private ByteBuffer bb = null;</span>
<span class="nc" id="L278">            private byte[] bs = null;   // Invoker's previous array</span>
<span class="nc" id="L279">            private byte[] b1 = null;</span>

            @Override
            public synchronized void write(int b) throws IOException {
<span class="nc bnc" id="L283" title="All 2 branches missed.">               if (b1 == null)</span>
<span class="nc" id="L284">                    b1 = new byte[1];</span>
<span class="nc" id="L285">                b1[0] = (byte)b;</span>
<span class="nc" id="L286">                this.write(b1);</span>
<span class="nc" id="L287">            }</span>

            @Override
            public synchronized void write(byte[] bs, int off, int len)
                throws IOException
            {
<span class="nc bnc" id="L293" title="All 10 branches missed.">                if ((off &lt; 0) || (off &gt; bs.length) || (len &lt; 0) ||</span>
                    ((off + len) &gt; bs.length) || ((off + len) &lt; 0)) {
<span class="nc" id="L295">                    throw new IndexOutOfBoundsException();</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                } else if (len == 0) {</span>
<span class="nc" id="L297">                    return;</span>
                }
<span class="nc bnc" id="L299" title="All 2 branches missed.">                ByteBuffer bb = ((this.bs == bs)</span>
                                 ? this.bb
<span class="nc" id="L301">                                 : ByteBuffer.wrap(bs));</span>
<span class="nc" id="L302">                bb.limit(Math.min(off + len, bb.capacity()));</span>
<span class="nc" id="L303">                bb.position(off);</span>
<span class="nc" id="L304">                this.bb = bb;</span>
<span class="nc" id="L305">                this.bs = bs;</span>

<span class="nc" id="L307">                boolean interrupted = false;</span>
                try {
<span class="nc bnc" id="L309" title="All 2 branches missed.">                    while (bb.remaining() &gt; 0) {</span>
                        try {
<span class="nc" id="L311">                            ch.write(bb).get();</span>
<span class="nc" id="L312">                        } catch (ExecutionException ee) {</span>
<span class="nc" id="L313">                            throw new IOException(ee.getCause());</span>
<span class="nc" id="L314">                        } catch (InterruptedException ie) {</span>
<span class="nc" id="L315">                            interrupted = true;</span>
<span class="nc" id="L316">                        }</span>
                    }
                } finally {
<span class="nc bnc" id="L319" title="All 4 branches missed.">                    if (interrupted)</span>
<span class="nc" id="L320">                        Thread.currentThread().interrupt();</span>
                }
<span class="nc" id="L322">            }</span>

            @Override
            public void close() throws IOException {
<span class="nc" id="L326">                ch.close();</span>
<span class="nc" id="L327">            }</span>
        };
    }


    // -- Channels from streams --

    /**
     * Constructs a channel that reads bytes from the given stream.
     *
     * &lt;p&gt; The resulting channel will not be buffered; it will simply redirect
     * its I/O operations to the given stream.  Closing the channel will in
     * turn cause the stream to be closed.  &lt;/p&gt;
     *
     * @param  in
     *         The stream from which bytes are to be read
     *
     * @return  A new readable byte channel
     */
    public static ReadableByteChannel newChannel(final InputStream in) {
<span class="fc" id="L347">        checkNotNull(in, &quot;in&quot;);</span>

<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (in instanceof FileInputStream &amp;&amp;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            FileInputStream.class.equals(in.getClass())) {</span>
<span class="nc" id="L351">            return ((FileInputStream)in).getChannel();</span>
        }

<span class="fc" id="L354">        return new ReadableByteChannelImpl(in);</span>
    }

    private static class ReadableByteChannelImpl
        extends AbstractInterruptibleChannel    // Not really interruptible
        implements ReadableByteChannel
    {
        InputStream in;
        private static final int TRANSFER_SIZE = 8192;
<span class="fc" id="L363">        private byte buf[] = new byte[0];</span>
<span class="fc" id="L364">        private boolean open = true;</span>
<span class="fc" id="L365">        private Object readLock = new Object();</span>

<span class="fc" id="L367">        ReadableByteChannelImpl(InputStream in) {</span>
<span class="fc" id="L368">            this.in = in;</span>
<span class="fc" id="L369">        }</span>

        public int read(ByteBuffer dst) throws IOException {
<span class="fc" id="L372">            int len = dst.remaining();</span>
<span class="fc" id="L373">            int totalRead = 0;</span>
<span class="fc" id="L374">            int bytesRead = 0;</span>
<span class="fc" id="L375">            synchronized (readLock) {</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">                while (totalRead &lt; len) {</span>
<span class="fc" id="L377">                    int bytesToRead = Math.min((len - totalRead),</span>
                                               TRANSFER_SIZE);
<span class="fc bfc" id="L379" title="All 2 branches covered.">                    if (buf.length &lt; bytesToRead)</span>
<span class="fc" id="L380">                        buf = new byte[bytesToRead];</span>
<span class="fc bfc" id="L381" title="All 4 branches covered.">                    if ((totalRead &gt; 0) &amp;&amp; !(in.available() &gt; 0))</span>
<span class="fc" id="L382">                        break; // block at most once</span>
                    try {
<span class="fc" id="L384">                        begin();</span>
<span class="fc" id="L385">                        bytesRead = in.read(buf, 0, bytesToRead);</span>
                    } finally {
<span class="pc bpc" id="L387" title="2 of 4 branches missed.">                        end(bytesRead &gt; 0);</span>
<span class="fc" id="L388">                    }</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">                    if (bytesRead &lt; 0)</span>
<span class="fc" id="L390">                        break;</span>
                    else
<span class="fc" id="L392">                        totalRead += bytesRead;</span>
<span class="fc" id="L393">                    dst.put(buf, 0, bytesRead);</span>
<span class="fc" id="L394">                }</span>
<span class="pc bpc" id="L395" title="1 of 4 branches missed.">                if ((bytesRead &lt; 0) &amp;&amp; (totalRead == 0))</span>
<span class="fc" id="L396">                    return -1;</span>

<span class="fc" id="L398">                return totalRead;</span>
<span class="nc" id="L399">            }</span>
        }

        protected void implCloseChannel() throws IOException {
<span class="fc" id="L403">            in.close();</span>
<span class="fc" id="L404">            open = false;</span>
<span class="fc" id="L405">        }</span>
    }


    /**
     * Constructs a channel that writes bytes to the given stream.
     *
     * &lt;p&gt; The resulting channel will not be buffered; it will simply redirect
     * its I/O operations to the given stream.  Closing the channel will in
     * turn cause the stream to be closed.  &lt;/p&gt;
     *
     * @param  out
     *         The stream to which bytes are to be written
     *
     * @return  A new writable byte channel
     */
    public static WritableByteChannel newChannel(final OutputStream out) {
<span class="fc" id="L422">        checkNotNull(out, &quot;out&quot;);</span>

<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        if (out instanceof FileOutputStream &amp;&amp;</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">            FileOutputStream.class.equals(out.getClass())) {</span>
<span class="nc" id="L426">                return ((FileOutputStream)out).getChannel();</span>
        }

<span class="fc" id="L429">        return new WritableByteChannelImpl(out);</span>
    }

    private static class WritableByteChannelImpl
        extends AbstractInterruptibleChannel    // Not really interruptible
        implements WritableByteChannel
    {
        OutputStream out;
        private static final int TRANSFER_SIZE = 8192;
<span class="fc" id="L438">        private byte buf[] = new byte[0];</span>
<span class="fc" id="L439">        private boolean open = true;</span>
<span class="fc" id="L440">        private Object writeLock = new Object();</span>

<span class="fc" id="L442">        WritableByteChannelImpl(OutputStream out) {</span>
<span class="fc" id="L443">            this.out = out;</span>
<span class="fc" id="L444">        }</span>

        public int write(ByteBuffer src) throws IOException {
<span class="fc" id="L447">            int len = src.remaining();</span>
<span class="fc" id="L448">            int totalWritten = 0;</span>
<span class="fc" id="L449">            synchronized (writeLock) {</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">                while (totalWritten &lt; len) {</span>
<span class="fc" id="L451">                    int bytesToWrite = Math.min((len - totalWritten),</span>
                                                TRANSFER_SIZE);
<span class="fc bfc" id="L453" title="All 2 branches covered.">                    if (buf.length &lt; bytesToWrite)</span>
<span class="fc" id="L454">                        buf = new byte[bytesToWrite];</span>
<span class="fc" id="L455">                    src.get(buf, 0, bytesToWrite);</span>
                    try {
<span class="fc" id="L457">                        begin();</span>
<span class="fc" id="L458">                        out.write(buf, 0, bytesToWrite);</span>
                    } finally {
<span class="pc bpc" id="L460" title="3 of 4 branches missed.">                        end(bytesToWrite &gt; 0);</span>
<span class="fc" id="L461">                    }</span>
<span class="fc" id="L462">                    totalWritten += bytesToWrite;</span>
<span class="fc" id="L463">                }</span>
<span class="fc" id="L464">                return totalWritten;</span>
<span class="nc" id="L465">            }</span>
        }

        protected void implCloseChannel() throws IOException {
<span class="fc" id="L469">            out.close();</span>
<span class="fc" id="L470">            open = false;</span>
<span class="fc" id="L471">        }</span>
    }


    // -- Character streams from channels --

    /**
     * Constructs a reader that decodes bytes from the given channel using the
     * given decoder.
     *
     * &lt;p&gt; The resulting stream will contain an internal input buffer of at
     * least &lt;tt&gt;minBufferCap&lt;/tt&gt; bytes.  The stream's &lt;tt&gt;read&lt;/tt&gt; methods
     * will, as needed, fill the buffer by reading bytes from the underlying
     * channel; if the channel is in non-blocking mode when bytes are to be
     * read then an {@link IllegalBlockingModeException} will be thrown.  The
     * resulting stream will not otherwise be buffered, and it will not support
     * the {@link Reader#mark mark} or {@link Reader#reset reset} methods.
     * Closing the stream will in turn cause the channel to be closed.  &lt;/p&gt;
     *
     * @param  ch
     *         The channel from which bytes will be read
     *
     * @param  dec
     *         The charset decoder to be used
     *
     * @param  minBufferCap
     *         The minimum capacity of the internal byte buffer,
     *         or &lt;tt&gt;-1&lt;/tt&gt; if an implementation-dependent
     *         default capacity is to be used
     *
     * @return  A new reader
     */
    public static Reader newReader(ReadableByteChannel ch,
                                   CharsetDecoder dec,
                                   int minBufferCap)
    {
<span class="nc" id="L507">        checkNotNull(ch, &quot;ch&quot;);</span>
<span class="nc" id="L508">        return StreamDecoder.forDecoder(ch, dec.reset(), minBufferCap);</span>
    }

    /**
     * Constructs a reader that decodes bytes from the given channel according
     * to the named charset.
     *
     * &lt;p&gt; An invocation of this method of the form
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * Channels.newReader(ch, csname)&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * behaves in exactly the same way as the expression
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * Channels.newReader(ch,
     *                    Charset.forName(csName)
     *                        .newDecoder(),
     *                    -1);&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param  ch
     *         The channel from which bytes will be read
     *
     * @param  csName
     *         The name of the charset to be used
     *
     * @return  A new reader
     *
     * @throws  UnsupportedCharsetException
     *          If no support for the named charset is available
     *          in this instance of the Java virtual machine
     */
    public static Reader newReader(ReadableByteChannel ch,
                                   String csName)
    {
<span class="nc" id="L543">        checkNotNull(csName, &quot;csName&quot;);</span>
<span class="nc" id="L544">        return newReader(ch, Charset.forName(csName).newDecoder(), -1);</span>
    }

    /**
     * Constructs a writer that encodes characters using the given encoder and
     * writes the resulting bytes to the given channel.
     *
     * &lt;p&gt; The resulting stream will contain an internal output buffer of at
     * least &lt;tt&gt;minBufferCap&lt;/tt&gt; bytes.  The stream's &lt;tt&gt;write&lt;/tt&gt; methods
     * will, as needed, flush the buffer by writing bytes to the underlying
     * channel; if the channel is in non-blocking mode when bytes are to be
     * written then an {@link IllegalBlockingModeException} will be thrown.
     * The resulting stream will not otherwise be buffered.  Closing the stream
     * will in turn cause the channel to be closed.  &lt;/p&gt;
     *
     * @param  ch
     *         The channel to which bytes will be written
     *
     * @param  enc
     *         The charset encoder to be used
     *
     * @param  minBufferCap
     *         The minimum capacity of the internal byte buffer,
     *         or &lt;tt&gt;-1&lt;/tt&gt; if an implementation-dependent
     *         default capacity is to be used
     *
     * @return  A new writer
     */
    public static Writer newWriter(final WritableByteChannel ch,
                                   final CharsetEncoder enc,
                                   final int minBufferCap)
    {
<span class="nc" id="L576">        checkNotNull(ch, &quot;ch&quot;);</span>
<span class="nc" id="L577">        return StreamEncoder.forEncoder(ch, enc.reset(), minBufferCap);</span>
    }

    /**
     * Constructs a writer that encodes characters according to the named
     * charset and writes the resulting bytes to the given channel.
     *
     * &lt;p&gt; An invocation of this method of the form
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * Channels.newWriter(ch, csname)&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * behaves in exactly the same way as the expression
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * Channels.newWriter(ch,
     *                    Charset.forName(csName)
     *                        .newEncoder(),
     *                    -1);&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param  ch
     *         The channel to which bytes will be written
     *
     * @param  csName
     *         The name of the charset to be used
     *
     * @return  A new writer
     *
     * @throws  UnsupportedCharsetException
     *          If no support for the named charset is available
     *          in this instance of the Java virtual machine
     */
    public static Writer newWriter(WritableByteChannel ch,
                                   String csName)
    {
<span class="nc" id="L612">        checkNotNull(csName, &quot;csName&quot;);</span>
<span class="nc" id="L613">        return newWriter(ch, Charset.forName(csName).newEncoder(), -1);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>