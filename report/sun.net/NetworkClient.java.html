<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>NetworkClient.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.net</a> &gt; <span class="el_source">NetworkClient.java</span></div><h1>NetworkClient.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.net;

import java.io.*;
import java.net.Socket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.net.Proxy;
import java.util.Arrays;
import java.security.AccessController;
import java.security.PrivilegedAction;

/**
 * This is the base class for network clients.
 *
 * @author      Jonathan Payne
 */
public class NetworkClient {
    /* Default value of read timeout, if not specified (infinity) */
    public static final int DEFAULT_READ_TIMEOUT = -1;

    /* Default value of connect timeout, if not specified (infinity) */
    public static final int DEFAULT_CONNECT_TIMEOUT = -1;

<span class="pc" id="L49">    protected Proxy     proxy = Proxy.NO_PROXY;</span>
    /** Socket for communicating with server. */
<span class="pc" id="L51">    protected Socket    serverSocket = null;</span>

    /** Stream for printing to the server. */
    public PrintStream  serverOutput;

    /** Buffered stream for reading replies from server. */
    public InputStream  serverInput;

    protected static int defaultSoTimeout;
    protected static int defaultConnectTimeout;

<span class="pc" id="L62">    protected int readTimeout = DEFAULT_READ_TIMEOUT;</span>
<span class="pc" id="L63">    protected int connectTimeout = DEFAULT_CONNECT_TIMEOUT;</span>
    /* Name of encoding to use for output */
    protected static String encoding;

    static {
<span class="fc" id="L68">        final int vals[] = {0, 0};</span>
<span class="fc" id="L69">        final String encs[] = { null };</span>

<span class="fc" id="L71">        AccessController.doPrivileged(</span>
<span class="fc" id="L72">                new PrivilegedAction&lt;Void&gt;() {</span>
                    public Void run() {
<span class="fc" id="L74">                        vals[0] = Integer.getInteger(&quot;sun.net.client.defaultReadTimeout&quot;, 0).intValue();</span>
<span class="fc" id="L75">                        vals[1] = Integer.getInteger(&quot;sun.net.client.defaultConnectTimeout&quot;, 0).intValue();</span>
<span class="fc" id="L76">                        encs[0] = System.getProperty(&quot;file.encoding&quot;, &quot;ISO8859_1&quot;);</span>
<span class="fc" id="L77">                        return null;</span>
            }
        });
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (vals[0] != 0) {</span>
<span class="fc" id="L81">            defaultSoTimeout = vals[0];</span>
        }
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        if (vals[1] != 0) {</span>
<span class="nc" id="L84">            defaultConnectTimeout = vals[1];</span>
        }

<span class="fc" id="L87">        encoding = encs[0];</span>
        try {
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">            if (!isASCIISuperset (encoding)) {</span>
<span class="nc" id="L90">                encoding = &quot;ISO8859_1&quot;;</span>
            }
<span class="nc" id="L92">        } catch (Exception e) {</span>
<span class="nc" id="L93">            encoding = &quot;ISO8859_1&quot;;</span>
<span class="fc" id="L94">        }</span>
<span class="fc" id="L95">    }</span>


    /**
     * Test the named character encoding to verify that it converts ASCII
     * characters correctly. We have to use an ASCII based encoding, or else
     * the NetworkClients will not work correctly in EBCDIC based systems.
     * However, we cannot just use ASCII or ISO8859_1 universally, because in
     * Asian locales, non-ASCII characters may be embedded in otherwise
     * ASCII based protocols (eg. HTTP). The specifications (RFC2616, 2398)
     * are a little ambiguous in this matter. For instance, RFC2398 [part 2.1]
     * says that the HTTP request URI should be escaped using a defined
     * mechanism, but there is no way to specify in the escaped string what
     * the original character set is. It is not correct to assume that
     * UTF-8 is always used (as in URLs in HTML 4.0).  For this reason,
     * until the specifications are updated to deal with this issue more
     * comprehensively, and more importantly, HTTP servers are known to
     * support these mechanisms, we will maintain the current behavior
     * where it is possible to send non-ASCII characters in their original
     * unescaped form.
     */
    private static boolean isASCIISuperset (String encoding) throws Exception {
<span class="fc" id="L117">        String chkS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;+</span>
                        &quot;abcdefghijklmnopqrstuvwxyz-_.!~*'();/?:@&amp;=+$,&quot;;

        // Expected byte sequence for string above
<span class="fc" id="L121">        byte[] chkB = { 48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,71,72,</span>
                73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,
                100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,
                115,116,117,118,119,120,121,122,45,95,46,33,126,42,39,40,41,59,
                47,63,58,64,38,61,43,36,44};

<span class="fc" id="L127">        byte[] b = chkS.getBytes (encoding);</span>
<span class="fc" id="L128">        return Arrays.equals (b, chkB);</span>
    }

    /** Open a connection to the server. */
    public void openServer(String server, int port)
        throws IOException, UnknownHostException {
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (serverSocket != null)</span>
<span class="nc" id="L135">            closeServer();</span>
<span class="nc" id="L136">        serverSocket = doConnect (server, port);</span>
        try {
<span class="nc" id="L138">            serverOutput = new PrintStream(new BufferedOutputStream(</span>
<span class="nc" id="L139">                                        serverSocket.getOutputStream()),</span>
                                        true, encoding);
<span class="nc" id="L141">        } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L142">            throw new InternalError(encoding +&quot;encoding not found&quot;, e);</span>
<span class="nc" id="L143">        }</span>
<span class="nc" id="L144">        serverInput = new BufferedInputStream(serverSocket.getInputStream());</span>
<span class="nc" id="L145">    }</span>

    /**
     * Return a socket connected to the server, with any
     * appropriate options pre-established
     */
    protected Socket doConnect (String server, int port)
    throws IOException, UnknownHostException {
        Socket s;
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if (proxy != null) {</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">            if (proxy.type() == Proxy.Type.SOCKS) {</span>
<span class="nc" id="L156">                s = AccessController.doPrivileged(</span>
<span class="nc" id="L157">                    new PrivilegedAction&lt;Socket&gt;() {</span>
                        public Socket run() {
<span class="nc" id="L159">                                       return new Socket(proxy);</span>
                                   }});
<span class="fc bfc" id="L161" title="All 2 branches covered.">            } else if (proxy.type() == Proxy.Type.DIRECT) {</span>
<span class="fc" id="L162">                s = createSocket();</span>
            } else {
                // Still connecting through a proxy
                // server &amp; port will be the proxy address and port
<span class="fc" id="L166">                s = new Socket(Proxy.NO_PROXY);</span>
            }
        } else
<span class="nc" id="L169">            s = createSocket();</span>
        // Instance specific timeouts do have priority, that means
        // connectTimeout &amp; readTimeout (-1 means not set)
        // Then global default timeouts
        // Then no timeout.
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (connectTimeout &gt;= 0) {</span>
<span class="nc" id="L175">            s.connect(new InetSocketAddress(server, port), connectTimeout);</span>
        } else {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">            if (defaultConnectTimeout &gt; 0) {</span>
<span class="nc" id="L178">                s.connect(new InetSocketAddress(server, port), defaultConnectTimeout);</span>
            } else {
<span class="fc" id="L180">                s.connect(new InetSocketAddress(server, port));</span>
            }
        }
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (readTimeout &gt;= 0)</span>
<span class="fc" id="L184">            s.setSoTimeout(readTimeout);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        else if (defaultSoTimeout &gt; 0) {</span>
<span class="fc" id="L186">            s.setSoTimeout(defaultSoTimeout);</span>
        }
<span class="fc" id="L188">        return s;</span>
    }

    /**
     * The following method, createSocket, is provided to allow the
     * https client to override it so that it may use its socket factory
     * to create the socket.
     */
    protected Socket createSocket() throws IOException {
<span class="fc" id="L197">        return new java.net.Socket();</span>
    }

    protected InetAddress getLocalAddress() throws IOException {
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (serverSocket == null)</span>
<span class="nc" id="L202">            throw new IOException(&quot;not connected&quot;);</span>
<span class="nc" id="L203">        return  AccessController.doPrivileged(</span>
<span class="nc" id="L204">                        new PrivilegedAction&lt;InetAddress&gt;() {</span>
                            public InetAddress run() {
<span class="nc" id="L206">                                return serverSocket.getLocalAddress();</span>

                            }
                        });
    }

    /** Close an open connection to the server. */
    public void closeServer() throws IOException {
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (! serverIsOpen()) {</span>
<span class="nc" id="L215">            return;</span>
        }
<span class="nc" id="L217">        serverSocket.close();</span>
<span class="nc" id="L218">        serverSocket = null;</span>
<span class="nc" id="L219">        serverInput = null;</span>
<span class="nc" id="L220">        serverOutput = null;</span>
<span class="nc" id="L221">    }</span>

    /** Return server connection status */
    public boolean serverIsOpen() {
<span class="nc bnc" id="L225" title="All 2 branches missed.">        return serverSocket != null;</span>
    }

    /** Create connection with host &lt;i&gt;host&lt;/i&gt; on port &lt;i&gt;port&lt;/i&gt; */
<span class="nc" id="L229">    public NetworkClient(String host, int port) throws IOException {</span>
<span class="nc" id="L230">        openServer(host, port);</span>
<span class="nc" id="L231">    }</span>

<span class="fc" id="L233">    public NetworkClient() {}</span>

    public void setConnectTimeout(int timeout) {
<span class="fc" id="L236">        connectTimeout = timeout;</span>
<span class="fc" id="L237">    }</span>

    public int getConnectTimeout() {
<span class="nc" id="L240">        return connectTimeout;</span>
    }

    /**
     * Sets the read timeout.
     *
     * Note: Public URLConnection (and protocol specific implementations)
     * protect against negative timeout values being set. This implementation,
     * and protocol specific implementations, use -1 to represent the default
     * read timeout.
     *
     * This method may be invoked with the default timeout value when the
     * protocol handler is trying to reset the timeout after doing a
     * potentially blocking internal operation, e.g. cleaning up unread
     * response data, buffering error stream response data, etc
     */
    public void setReadTimeout(int timeout) {
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (timeout == DEFAULT_READ_TIMEOUT)</span>
<span class="fc" id="L258">            timeout = defaultSoTimeout;</span>

<span class="pc bpc" id="L260" title="2 of 4 branches missed.">        if (serverSocket != null &amp;&amp; timeout &gt;= 0) {</span>
            try {
<span class="fc" id="L262">                serverSocket.setSoTimeout(timeout);</span>
<span class="nc" id="L263">            } catch(IOException e) {</span>
                // We tried...
<span class="fc" id="L265">            }</span>
        }
<span class="fc" id="L267">        readTimeout = timeout;</span>
<span class="fc" id="L268">    }</span>

    public int getReadTimeout() {
<span class="fc" id="L271">        return readTimeout;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>