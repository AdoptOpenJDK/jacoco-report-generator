<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ProgressMonitor.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.net</a> &gt; <span class="el_source">ProgressMonitor.java</span></div><h1>ProgressMonitor.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.net;

import java.util.ArrayList;
import java.util.Iterator;
import java.net.URL;

/**
 * ProgressMonitor is a class for monitoring progress in network input stream.
 *
 * @author Stanley Man-Kit Ho
 */
<span class="fc" id="L37">public class ProgressMonitor</span>
{
    /**
     * Return default ProgressMonitor.
     */
    public static synchronized ProgressMonitor getDefault() {
<span class="fc" id="L43">        return pm;</span>
    }

    /**
     * Change default ProgressMonitor implementation.
     */
    public static synchronized void setDefault(ProgressMonitor m)   {
<span class="nc bnc" id="L50" title="All 2 branches missed.">        if (m != null)</span>
<span class="nc" id="L51">            pm = m;</span>
<span class="nc" id="L52">    }</span>

    /**
     * Change progress metering policy.
     */
    public static synchronized void setMeteringPolicy(ProgressMeteringPolicy policy)    {
<span class="nc bnc" id="L58" title="All 2 branches missed.">        if (policy != null)</span>
<span class="nc" id="L59">            meteringPolicy = policy;</span>
<span class="nc" id="L60">    }</span>


    /**
     * Return a snapshot of the ProgressSource list
     */
    public ArrayList&lt;ProgressSource&gt; getProgressSources()    {
<span class="nc" id="L67">        ArrayList&lt;ProgressSource&gt; snapshot = new ArrayList&lt;ProgressSource&gt;();</span>

        try {
<span class="nc" id="L70">            synchronized(progressSourceList)    {</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">                for (Iterator&lt;ProgressSource&gt; iter = progressSourceList.iterator(); iter.hasNext();)    {</span>
<span class="nc" id="L72">                    ProgressSource pi = iter.next();</span>

                    // Clone ProgressSource and add to snapshot
<span class="nc" id="L75">                    snapshot.add((ProgressSource)pi.clone());</span>
<span class="nc" id="L76">                }</span>
<span class="nc" id="L77">            }</span>
        }
<span class="nc" id="L79">        catch(CloneNotSupportedException e) {</span>
<span class="nc" id="L80">            e.printStackTrace();</span>
<span class="nc" id="L81">        }</span>

<span class="nc" id="L83">        return snapshot;</span>
    }

    /**
     * Return update notification threshold
     */
    public synchronized int getProgressUpdateThreshold()    {
<span class="nc" id="L90">        return meteringPolicy.getProgressUpdateThreshold();</span>
    }

    /**
     * Return true if metering should be turned on
     * for a particular URL input stream.
     */
    public boolean shouldMeterInput(URL url, String method) {
<span class="fc" id="L98">        return meteringPolicy.shouldMeterInput(url, method);</span>
    }

    /**
     * Register progress source when progress is began.
     */
    public void registerSource(ProgressSource pi) {

<span class="nc" id="L106">        synchronized(progressSourceList)    {</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (progressSourceList.contains(pi))</span>
<span class="nc" id="L108">                return;</span>

<span class="nc" id="L110">            progressSourceList.add(pi);</span>
<span class="nc" id="L111">        }</span>

        // Notify only if there is at least one listener
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (progressListenerList.size() &gt; 0)</span>
        {
            // Notify progress listener if there is progress change
<span class="nc" id="L117">            ArrayList&lt;ProgressListener&gt; listeners = new ArrayList&lt;ProgressListener&gt;();</span>

            // Copy progress listeners to another list to avoid holding locks
<span class="nc" id="L120">            synchronized(progressListenerList) {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">                for (Iterator&lt;ProgressListener&gt; iter = progressListenerList.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L122">                    listeners.add(iter.next());</span>
                }
<span class="nc" id="L124">            }</span>

            // Fire event on each progress listener
<span class="nc bnc" id="L127" title="All 2 branches missed.">            for (Iterator&lt;ProgressListener&gt; iter = listeners.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L128">                ProgressListener pl = iter.next();</span>
<span class="nc" id="L129">                ProgressEvent pe = new ProgressEvent(pi, pi.getURL(), pi.getMethod(), pi.getContentType(), pi.getState(), pi.getProgress(), pi.getExpected());</span>
<span class="nc" id="L130">                pl.progressStart(pe);</span>
<span class="nc" id="L131">            }</span>
        }
<span class="nc" id="L133">    }</span>

    /**
     * Unregister progress source when progress is finished.
     */
    public void unregisterSource(ProgressSource pi) {

<span class="nc" id="L140">        synchronized(progressSourceList) {</span>
            // Return if ProgressEvent does not exist
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (progressSourceList.contains(pi) == false)</span>
<span class="nc" id="L143">                return;</span>

            // Close entry and remove from map
<span class="nc" id="L146">            pi.close();</span>
<span class="nc" id="L147">            progressSourceList.remove(pi);</span>
<span class="nc" id="L148">        }</span>

        // Notify only if there is at least one listener
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (progressListenerList.size() &gt; 0)</span>
        {
            // Notify progress listener if there is progress change
<span class="nc" id="L154">            ArrayList&lt;ProgressListener&gt; listeners = new ArrayList&lt;ProgressListener&gt;();</span>

            // Copy progress listeners to another list to avoid holding locks
<span class="nc" id="L157">            synchronized(progressListenerList) {</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">                for (Iterator&lt;ProgressListener&gt; iter = progressListenerList.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L159">                    listeners.add(iter.next());</span>
                }
<span class="nc" id="L161">            }</span>

            // Fire event on each progress listener
<span class="nc bnc" id="L164" title="All 2 branches missed.">            for (Iterator&lt;ProgressListener&gt; iter = listeners.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L165">                ProgressListener pl = iter.next();</span>
<span class="nc" id="L166">                ProgressEvent pe = new ProgressEvent(pi, pi.getURL(), pi.getMethod(), pi.getContentType(), pi.getState(), pi.getProgress(), pi.getExpected());</span>
<span class="nc" id="L167">                pl.progressFinish(pe);</span>
<span class="nc" id="L168">            }</span>
        }
<span class="nc" id="L170">    }</span>

    /**
     * Progress source is updated.
     */
    public void updateProgress(ProgressSource pi)   {

<span class="nc" id="L177">        synchronized (progressSourceList)   {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            if (progressSourceList.contains(pi) == false)</span>
<span class="nc" id="L179">                return;</span>
<span class="nc" id="L180">        }</span>

        // Notify only if there is at least one listener
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (progressListenerList.size() &gt; 0)</span>
        {
            // Notify progress listener if there is progress change
<span class="nc" id="L186">            ArrayList&lt;ProgressListener&gt; listeners = new ArrayList&lt;ProgressListener&gt;();</span>

            // Copy progress listeners to another list to avoid holding locks
<span class="nc" id="L189">            synchronized(progressListenerList)  {</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                for (Iterator&lt;ProgressListener&gt; iter = progressListenerList.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L191">                    listeners.add(iter.next());</span>
                }
<span class="nc" id="L193">            }</span>

            // Fire event on each progress listener
<span class="nc bnc" id="L196" title="All 2 branches missed.">            for (Iterator&lt;ProgressListener&gt; iter = listeners.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L197">                ProgressListener pl = iter.next();</span>
<span class="nc" id="L198">                ProgressEvent pe = new ProgressEvent(pi, pi.getURL(), pi.getMethod(), pi.getContentType(), pi.getState(), pi.getProgress(), pi.getExpected());</span>
<span class="nc" id="L199">                pl.progressUpdate(pe);</span>
<span class="nc" id="L200">            }</span>
        }
<span class="nc" id="L202">    }</span>

    /**
     * Add progress listener in progress monitor.
     */
    public void addProgressListener(ProgressListener l) {
<span class="nc" id="L208">        synchronized(progressListenerList) {</span>
<span class="nc" id="L209">            progressListenerList.add(l);</span>
<span class="nc" id="L210">        }</span>
<span class="nc" id="L211">    }</span>

    /**
     * Remove progress listener from progress monitor.
     */
    public void removeProgressListener(ProgressListener l) {
<span class="nc" id="L217">        synchronized(progressListenerList) {</span>
<span class="nc" id="L218">            progressListenerList.remove(l);</span>
<span class="nc" id="L219">        }</span>
<span class="nc" id="L220">    }</span>

    // Metering policy
<span class="fc" id="L223">    private static ProgressMeteringPolicy meteringPolicy = new DefaultProgressMeteringPolicy();</span>

    // Default implementation
<span class="fc" id="L226">    private static ProgressMonitor pm = new ProgressMonitor();</span>

    // ArrayList for outstanding progress sources
<span class="fc" id="L229">    private ArrayList&lt;ProgressSource&gt; progressSourceList = new ArrayList&lt;ProgressSource&gt;();</span>

    // ArrayList for progress listeners
<span class="fc" id="L232">    private ArrayList&lt;ProgressListener&gt; progressListenerList = new ArrayList&lt;ProgressListener&gt;();</span>
}


/**
 * Default progress metering policy.
 */
<span class="fc" id="L239">class DefaultProgressMeteringPolicy implements ProgressMeteringPolicy  {</span>
    /**
     * Return true if metering should be turned on for a particular network input stream.
     */
    public boolean shouldMeterInput(URL url, String method)
    {
        // By default, no URL input stream is metered for
        // performance reason.
<span class="fc" id="L247">        return false;</span>
    }

    /**
     * Return update notification threshold.
     */
    public int getProgressUpdateThreshold() {
        // 8K - same as default I/O buffer size
<span class="nc" id="L255">        return 8192;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>