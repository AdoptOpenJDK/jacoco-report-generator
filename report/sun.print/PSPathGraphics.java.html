<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PSPathGraphics.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.print</a> &gt; <span class="el_source">PSPathGraphics.java</span></div><h1>PSPathGraphics.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.print;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Shape;
import java.awt.Transparency;

import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;

import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;

import java.awt.image.BufferedImage;
import sun.awt.image.ByteComponentRaster;

import java.awt.print.PageFormat;
import java.awt.print.Printable;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;

/**
 * This class converts paths into PostScript
 * by breaking all graphics into fills and
 * clips of paths.
 */

class PSPathGraphics extends PathGraphics {

    /**
     * For a drawing application the initial user space
     * resolution is 72dpi.
     */
    private static final int DEFAULT_USER_RES = 72;

    PSPathGraphics(Graphics2D graphics, PrinterJob printerJob,
                   Printable painter, PageFormat pageFormat, int pageIndex,
                   boolean canRedraw) {
<span class="nc" id="L71">        super(graphics, printerJob, painter, pageFormat, pageIndex, canRedraw);</span>
<span class="nc" id="L72">    }</span>

    /**
     * Creates a new &lt;code&gt;Graphics&lt;/code&gt; object that is
     * a copy of this &lt;code&gt;Graphics&lt;/code&gt; object.
     * @return     a new graphics context that is a copy of
     *                       this graphics context.
     * @since      JDK1.0
     */
    public Graphics create() {

<span class="nc" id="L83">        return new PSPathGraphics((Graphics2D) getDelegate().create(),</span>
<span class="nc" id="L84">                                  getPrinterJob(),</span>
<span class="nc" id="L85">                                  getPrintable(),</span>
<span class="nc" id="L86">                                  getPageFormat(),</span>
<span class="nc" id="L87">                                  getPageIndex(),</span>
<span class="nc" id="L88">                                  canDoRedraws());</span>
    }


    /**
     * Override the inherited implementation of fill
     * so that we can generate PostScript in user space
     * rather than device space.
     */
    public void fill(Shape s, Color color) {
<span class="nc" id="L98">        deviceFill(s.getPathIterator(new AffineTransform()), color);</span>
<span class="nc" id="L99">    }</span>

    /**
     * Draws the text given by the specified string, using this
     * graphics context's current font and color. The baseline of the
     * first character is at position (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in this
     * graphics context's coordinate system.
     * @param       str      the string to be drawn.
     * @param       x        the &lt;i&gt;x&lt;/i&gt; coordinate.
     * @param       y        the &lt;i&gt;y&lt;/i&gt; coordinate.
     * @see         java.awt.Graphics#drawBytes
     * @see         java.awt.Graphics#drawChars
     * @since       JDK1.0
     */
    public void drawString(String str, int x, int y) {
<span class="nc" id="L114">        drawString(str, (float) x, (float) y);</span>
<span class="nc" id="L115">    }</span>

    /**
     * Renders the text specified by the specified &lt;code&gt;String&lt;/code&gt;,
     * using the current &lt;code&gt;Font&lt;/code&gt; and &lt;code&gt;Paint&lt;/code&gt; attributes
     * in the &lt;code&gt;Graphics2D&lt;/code&gt; context.
     * The baseline of the first character is at position
     * (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in the User Space.
     * The rendering attributes applied include the &lt;code&gt;Clip&lt;/code&gt;,
     * &lt;code&gt;Transform&lt;/code&gt;, &lt;code&gt;Paint&lt;/code&gt;, &lt;code&gt;Font&lt;/code&gt; and
     * &lt;code&gt;Composite&lt;/code&gt; attributes. For characters in script systems
     * such as Hebrew and Arabic, the glyphs can be rendered from right to
     * left, in which case the coordinate supplied is the location of the
     * leftmost character on the baseline.
     * @param s the &lt;code&gt;String&lt;/code&gt; to be rendered
     * @param x,&amp;nbsp;y the coordinates where the &lt;code&gt;String&lt;/code&gt;
     * should be rendered
     * @see #setPaint
     * @see java.awt.Graphics#setColor
     * @see java.awt.Graphics#setFont
     * @see #setTransform
     * @see #setComposite
     * @see #setClip
     */
     public void drawString(String str, float x, float y) {
<span class="nc" id="L140">         drawString(str, x, y, getFont(), getFontRenderContext(), 0f);</span>
<span class="nc" id="L141">     }</span>


    protected boolean canDrawStringToWidth() {
<span class="nc" id="L145">        return true;</span>
    }

    protected int platformFontCount(Font font, String str) {
<span class="nc" id="L149">        PSPrinterJob psPrinterJob = (PSPrinterJob) getPrinterJob();</span>
<span class="nc" id="L150">        return psPrinterJob.platformFontCount(font,  str);</span>
    }

    protected void drawString(String str, float x, float y,
                              Font font, FontRenderContext frc, float w) {
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (str.length() == 0) {</span>
<span class="nc" id="L156">            return;</span>
        }

        /* If the Font has layout attributes we need to delegate to TextLayout.
         * TextLayout renders text as GlyphVectors. We try to print those
         * using printer fonts - ie using Postscript text operators so
         * we may be reinvoked. In that case the &quot;!printingGlyphVector&quot; test
         * prevents us recursing and instead sends us into the body of the
         * method where we can safely ignore layout attributes as those
         * are already handled by TextLayout.
         */
<span class="nc bnc" id="L167" title="All 4 branches missed.">        if (font.hasLayoutAttributes() &amp;&amp; !printingGlyphVector) {</span>
<span class="nc" id="L168">            TextLayout layout = new TextLayout(str, font, frc);</span>
<span class="nc" id="L169">            layout.draw(this, x, y);</span>
<span class="nc" id="L170">            return;</span>
        }

<span class="nc" id="L173">        Font oldFont = getFont();</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (!oldFont.equals(font)) {</span>
<span class="nc" id="L175">            setFont(font);</span>
        } else {
<span class="nc" id="L177">            oldFont = null;</span>
        }

<span class="nc" id="L180">        boolean drawnWithPS = false;</span>

<span class="nc" id="L182">        float translateX = 0f, translateY = 0f;</span>
<span class="nc" id="L183">        boolean fontisTransformed = getFont().isTransformed();</span>

<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (fontisTransformed) {</span>
<span class="nc" id="L186">            AffineTransform fontTx = getFont().getTransform();</span>
<span class="nc" id="L187">            int transformType = fontTx.getType();</span>
            /* TYPE_TRANSLATION is a flag bit but we can do &quot;==&quot; here
             * because we want to detect when its just that bit set and
             *
             */
<span class="nc bnc" id="L192" title="All 2 branches missed.">            if (transformType == AffineTransform.TYPE_TRANSLATION) {</span>
<span class="nc" id="L193">                translateX = (float)(fontTx.getTranslateX());</span>
<span class="nc" id="L194">                translateY = (float)(fontTx.getTranslateY());</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">                if (Math.abs(translateX) &lt; 0.00001) translateX = 0f;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                if (Math.abs(translateY) &lt; 0.00001) translateY = 0f;</span>
<span class="nc" id="L197">                fontisTransformed = false;</span>
            }
        }

<span class="nc bnc" id="L201" title="All 2 branches missed.">        boolean directToPS = !fontisTransformed;</span>

<span class="nc bnc" id="L203" title="All 4 branches missed.">        if (!PSPrinterJob.shapeTextProp &amp;&amp; directToPS) {</span>

<span class="nc" id="L205">            PSPrinterJob psPrinterJob = (PSPrinterJob) getPrinterJob();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (psPrinterJob.setFont(getFont())) {</span>

                /* Set the text color.
                 * We should not be in this shape printing path
                 * if the application is drawing with non-solid
                 * colors. We should be in the raster path. Because
                 * we are here in the shape path, the cast of the
                 * paint to a Color should be fine.
                 */
                try {
<span class="nc" id="L216">                    psPrinterJob.setColor((Color)getPaint());</span>
<span class="nc" id="L217">                } catch (ClassCastException e) {</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                    if (oldFont != null) {</span>
<span class="nc" id="L219">                        setFont(oldFont);</span>
                    }
<span class="nc" id="L221">                    throw new IllegalArgumentException(</span>
                                                &quot;Expected a Color instance&quot;);
<span class="nc" id="L223">                }</span>

<span class="nc" id="L225">                psPrinterJob.setTransform(getTransform());</span>
<span class="nc" id="L226">                psPrinterJob.setClip(getClip());</span>

<span class="nc" id="L228">                drawnWithPS = psPrinterJob.textOut(this, str,</span>
                                                   x+translateX, y+translateY,
                                                   font, frc, w);
            }
        }

        /* The text could not be converted directly to PS text
         * calls so decompose the text into a shape.
         */
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (drawnWithPS == false) {</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            if (oldFont != null) {</span>
<span class="nc" id="L239">                setFont(oldFont);</span>
<span class="nc" id="L240">                oldFont = null;</span>
            }
<span class="nc" id="L242">            super.drawString(str, x, y, font, frc, w);</span>
        }

<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (oldFont != null) {</span>
<span class="nc" id="L246">            setFont(oldFont);</span>
        }
<span class="nc" id="L248">    }</span>

    /**
     * The various &lt;code&gt;drawImage()&lt;/code&gt; methods for
     * &lt;code&gt;WPathGraphics&lt;/code&gt; are all decomposed
     * into an invocation of &lt;code&gt;drawImageToPlatform&lt;/code&gt;.
     * The portion of the passed in image defined by
     * &lt;code&gt;srcX, srcY, srcWidth, and srcHeight&lt;/code&gt;
     * is transformed by the supplied AffineTransform and
     * drawn using PS to the printer context.
     *
     * @param   img     The image to be drawn.
     *                  This method does nothing if &lt;code&gt;img&lt;/code&gt; is null.
     * @param   xform   Used to transform the image before drawing.
     *                  This can be null.
     * @param   bgcolor This color is drawn where the image has transparent
     *                  pixels. If this parameter is null then the
     *                  pixels already in the destination should show
     *                  through.
     * @param   srcX    With srcY this defines the upper-left corner
     *                  of the portion of the image to be drawn.
     *
     * @param   srcY    With srcX this defines the upper-left corner
     *                  of the portion of the image to be drawn.
     * @param   srcWidth    The width of the portion of the image to
     *                      be drawn.
     * @param   srcHeight   The height of the portion of the image to
     *                      be drawn.
     * @param   handlingTransparency if being recursively called to
     *                    print opaque region of transparent image
     */
    protected boolean drawImageToPlatform(Image image, AffineTransform xform,
                                          Color bgcolor,
                                          int srcX, int srcY,
                                          int srcWidth, int srcHeight,
                                          boolean handlingTransparency) {

<span class="nc" id="L285">        BufferedImage img = getBufferedImage(image);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L287">            return true;</span>
        }

<span class="nc" id="L290">        PSPrinterJob psPrinterJob = (PSPrinterJob) getPrinterJob();</span>

        /* The full transform to be applied to the image is the
         * caller's transform concatenated on to the transform
         * from user space to device space. If the caller didn't
         * supply a transform then we just act as if they passed
         * in the identify transform.
         */
<span class="nc" id="L298">        AffineTransform fullTransform = getTransform();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (xform == null) {</span>
<span class="nc" id="L300">            xform = new AffineTransform();</span>
        }
<span class="nc" id="L302">        fullTransform.concatenate(xform);</span>

        /* Split the full transform into a pair of
         * transforms. The first transform holds effects
         * such as rotation and shearing. The second transform
         * is setup to hold only the scaling effects.
         * These transforms are created such that a point,
         * p, in user space, when transformed by 'fullTransform'
         * lands in the same place as when it is transformed
         * by 'rotTransform' and then 'scaleTransform'.
         *
         * The entire image transformation is not in Java in order
         * to minimize the amount of memory needed in the VM. By
         * dividing the transform in two, we rotate and shear
         * the source image in its own space and only go to
         * the, usually, larger, device space when we ask
         * PostScript to perform the final scaling.
         */
<span class="nc" id="L320">        double[] fullMatrix = new double[6];</span>
<span class="nc" id="L321">        fullTransform.getMatrix(fullMatrix);</span>

        /* Calculate the amount of scaling in the x
         * and y directions. This scaling is computed by
         * transforming a unit vector along each axis
         * and computing the resulting magnitude.
         * The computed values 'scaleX' and 'scaleY'
         * represent the amount of scaling PS will be asked
         * to perform.
         * Clamp this to the device scale for better quality printing.
         */
<span class="nc" id="L332">        Point2D.Float unitVectorX = new Point2D.Float(1, 0);</span>
<span class="nc" id="L333">        Point2D.Float unitVectorY = new Point2D.Float(0, 1);</span>
<span class="nc" id="L334">        fullTransform.deltaTransform(unitVectorX, unitVectorX);</span>
<span class="nc" id="L335">        fullTransform.deltaTransform(unitVectorY, unitVectorY);</span>

<span class="nc" id="L337">        Point2D.Float origin = new Point2D.Float(0, 0);</span>
<span class="nc" id="L338">        double scaleX = unitVectorX.distance(origin);</span>
<span class="nc" id="L339">        double scaleY = unitVectorY.distance(origin);</span>

<span class="nc" id="L341">        double devResX = psPrinterJob.getXRes();</span>
<span class="nc" id="L342">        double devResY = psPrinterJob.getYRes();</span>
<span class="nc" id="L343">        double devScaleX = devResX / DEFAULT_USER_RES;</span>
<span class="nc" id="L344">        double devScaleY = devResY / DEFAULT_USER_RES;</span>

        /* check if rotated or sheared */
<span class="nc" id="L347">        int transformType = fullTransform.getType();</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        boolean clampScale = ((transformType &amp;</span>
                               (AffineTransform.TYPE_GENERAL_ROTATION |
                                AffineTransform.TYPE_GENERAL_TRANSFORM)) != 0);
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if (clampScale) {</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            if (scaleX &gt; devScaleX) scaleX = devScaleX;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (scaleY &gt; devScaleY) scaleY = devScaleY;</span>
        }

        /* We do not need to draw anything if either scaling
         * factor is zero.
         */
<span class="nc bnc" id="L359" title="All 4 branches missed.">        if (scaleX != 0 &amp;&amp; scaleY != 0) {</span>

            /* Here's the transformation we will do with Java2D,
            */
<span class="nc" id="L363">            AffineTransform rotTransform = new AffineTransform(</span>
                                        fullMatrix[0] / scaleX,  //m00
                                        fullMatrix[1] / scaleY,  //m10
                                        fullMatrix[2] / scaleX,  //m01
                                        fullMatrix[3] / scaleY,  //m11
                                        fullMatrix[4] / scaleX,  //m02
                                        fullMatrix[5] / scaleY); //m12

            /* The scale transform is not used directly: we instead
             * directly multiply by scaleX and scaleY.
             *
             * Conceptually here is what the scaleTransform is:
             *
             * AffineTransform scaleTransform = new AffineTransform(
             *                      scaleX,                     //m00
             *                      0,                          //m10
             *                      0,                          //m01
             *                      scaleY,                     //m11
             *                      0,                          //m02
             *                      0);                         //m12
             */

            /* Convert the image source's rectangle into the rotated
             * and sheared space. Once there, we calculate a rectangle
             * that encloses the resulting shape. It is this rectangle
             * which defines the size of the BufferedImage we need to
             * create to hold the transformed image.
             */
<span class="nc" id="L391">            Rectangle2D.Float srcRect = new Rectangle2D.Float(srcX, srcY,</span>
                                                              srcWidth,
                                                              srcHeight);

<span class="nc" id="L395">            Shape rotShape = rotTransform.createTransformedShape(srcRect);</span>
<span class="nc" id="L396">            Rectangle2D rotBounds = rotShape.getBounds2D();</span>

            /* add a fudge factor as some fp precision problems have
             * been observed which caused pixels to be rounded down and
             * out of the image.
             */
<span class="nc" id="L402">            rotBounds.setRect(rotBounds.getX(), rotBounds.getY(),</span>
<span class="nc" id="L403">                              rotBounds.getWidth()+0.001,</span>
<span class="nc" id="L404">                              rotBounds.getHeight()+0.001);</span>

<span class="nc" id="L406">            int boundsWidth = (int) rotBounds.getWidth();</span>
<span class="nc" id="L407">            int boundsHeight = (int) rotBounds.getHeight();</span>

<span class="nc bnc" id="L409" title="All 4 branches missed.">            if (boundsWidth &gt; 0 &amp;&amp; boundsHeight &gt; 0) {</span>


                /* If the image has transparent or semi-transparent
                 * pixels then we'll have the application re-render
                 * the portion of the page covered by the image.
                 * This will be done in a later call to print using the
                 * saved graphics state.
                 * However several special cases can be handled otherwise:
                 * - bitmask transparency with a solid background colour
                 * - images which have transparency color models but no
                 * transparent pixels
                 * - images with bitmask transparency and an IndexColorModel
                 * (the common transparent GIF case) can be handled by
                 * rendering just the opaque pixels.
                 */
<span class="nc" id="L425">                boolean drawOpaque = true;</span>
<span class="nc bnc" id="L426" title="All 4 branches missed.">                if (!handlingTransparency &amp;&amp; hasTransparentPixels(img)) {</span>
<span class="nc" id="L427">                    drawOpaque = false;</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                    if (isBitmaskTransparency(img)) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                        if (bgcolor == null) {</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">                            if (drawBitmaskImage(img, xform, bgcolor,</span>
                                                srcX, srcY,
                                                 srcWidth, srcHeight)) {
                                // image drawn, just return.
<span class="nc" id="L434">                                return true;</span>
                            }
<span class="nc bnc" id="L436" title="All 2 branches missed.">                        } else if (bgcolor.getTransparency()</span>
                                   == Transparency.OPAQUE) {
<span class="nc" id="L438">                            drawOpaque = true;</span>
                        }
                    }
<span class="nc bnc" id="L441" title="All 2 branches missed.">                    if (!canDoRedraws()) {</span>
<span class="nc" id="L442">                        drawOpaque = true;</span>
                    }
                } else {
                    // if there's no transparent pixels there's no need
                    // for a background colour. This can avoid edge artifacts
                    // in rotation cases.
<span class="nc" id="L448">                    bgcolor = null;</span>
                }
                // if src region extends beyond the image, the &quot;opaque&quot; path
                // may blit b/g colour (including white) where it shoudn't.
<span class="nc bnc" id="L452" title="All 2 branches missed.">                if ((srcX+srcWidth &gt; img.getWidth(null) ||</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">                     srcY+srcHeight &gt; img.getHeight(null))</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">                    &amp;&amp; canDoRedraws()) {</span>
<span class="nc" id="L455">                    drawOpaque = false;</span>
                }
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (drawOpaque == false) {</span>

<span class="nc" id="L459">                    fullTransform.getMatrix(fullMatrix);</span>
<span class="nc" id="L460">                    AffineTransform tx =</span>
                        new AffineTransform(
                                            fullMatrix[0] / devScaleX,  //m00
                                            fullMatrix[1] / devScaleY,  //m10
                                            fullMatrix[2] / devScaleX,  //m01
                                            fullMatrix[3] / devScaleY,  //m11
                                            fullMatrix[4] / devScaleX,  //m02
                                            fullMatrix[5] / devScaleY); //m12

<span class="nc" id="L469">                    Rectangle2D.Float rect =</span>
                        new Rectangle2D.Float(srcX, srcY, srcWidth, srcHeight);

<span class="nc" id="L472">                    Shape shape = fullTransform.createTransformedShape(rect);</span>
                    // Region isn't user space because its potentially
                    // been rotated for landscape.
<span class="nc" id="L475">                    Rectangle2D region = shape.getBounds2D();</span>

<span class="nc" id="L477">                    region.setRect(region.getX(), region.getY(),</span>
<span class="nc" id="L478">                                   region.getWidth()+0.001,</span>
<span class="nc" id="L479">                                   region.getHeight()+0.001);</span>

                    // Try to limit the amount of memory used to 8Mb, so
                    // if at device resolution this exceeds a certain
                    // image size then scale down the region to fit in
                    // that memory, but never to less than 72 dpi.

<span class="nc" id="L486">                    int w = (int)region.getWidth();</span>
<span class="nc" id="L487">                    int h = (int)region.getHeight();</span>
<span class="nc" id="L488">                    int nbytes = w * h * 3;</span>
<span class="nc" id="L489">                    int maxBytes = 8 * 1024 * 1024;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                    double origDpi = (devResX &lt; devResY) ? devResX : devResY;</span>
<span class="nc" id="L491">                    int dpi = (int)origDpi;</span>
<span class="nc" id="L492">                    double scaleFactor = 1;</span>

<span class="nc" id="L494">                    double maxSFX = w/(double)boundsWidth;</span>
<span class="nc" id="L495">                    double maxSFY = h/(double)boundsHeight;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">                    double maxSF = (maxSFX &gt; maxSFY) ? maxSFY : maxSFX;</span>
<span class="nc" id="L497">                    int minDpi = (int)(dpi/maxSF);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                    if (minDpi &lt; DEFAULT_USER_RES) minDpi = DEFAULT_USER_RES;</span>

<span class="nc bnc" id="L500" title="All 4 branches missed.">                    while (nbytes &gt; maxBytes &amp;&amp; dpi &gt; minDpi) {</span>
<span class="nc" id="L501">                        scaleFactor *= 2;</span>
<span class="nc" id="L502">                        dpi /= 2;</span>
<span class="nc" id="L503">                        nbytes /= 4;</span>
                    }
<span class="nc bnc" id="L505" title="All 2 branches missed.">                    if (dpi &lt; minDpi) {</span>
<span class="nc" id="L506">                        scaleFactor = (origDpi / minDpi);</span>
                    }

<span class="nc" id="L509">                    region.setRect(region.getX()/scaleFactor,</span>
<span class="nc" id="L510">                                   region.getY()/scaleFactor,</span>
<span class="nc" id="L511">                                   region.getWidth()/scaleFactor,</span>
<span class="nc" id="L512">                                   region.getHeight()/scaleFactor);</span>

                    /*
                     * We need to have the clip as part of the saved state,
                     * either directly, or all the components that are
                     * needed to reconstitute it (image source area,
                     * image transform and current graphics transform).
                     * The clip is described in user space, so we need to
                     * save the current graphics transform anyway so just
                     * save these two.
                     */
<span class="nc" id="L523">                    psPrinterJob.saveState(getTransform(), getClip(),</span>
                                           region, scaleFactor, scaleFactor);
<span class="nc" id="L525">                    return true;</span>

                /* The image can be rendered directly by PS so we
                 * copy it into a BufferedImage (this takes care of
                 * ColorSpace and BufferedImageOp issues) and then
                 * send that to PS.
                 */
                } else {

                    /* Create a buffered image big enough to hold the portion
                     * of the source image being printed.
                     */
<span class="nc" id="L537">                    BufferedImage deepImage = new BufferedImage(</span>
<span class="nc" id="L538">                                                    (int) rotBounds.getWidth(),</span>
<span class="nc" id="L539">                                                    (int) rotBounds.getHeight(),</span>
                                                    BufferedImage.TYPE_3BYTE_BGR);

                    /* Setup a Graphics2D on to the BufferedImage so that the
                     * source image when copied, lands within the image buffer.
                     */
<span class="nc" id="L545">                    Graphics2D imageGraphics = deepImage.createGraphics();</span>
<span class="nc" id="L546">                    imageGraphics.clipRect(0, 0,</span>
<span class="nc" id="L547">                                           deepImage.getWidth(),</span>
<span class="nc" id="L548">                                           deepImage.getHeight());</span>

<span class="nc" id="L550">                    imageGraphics.translate(-rotBounds.getX(),</span>
<span class="nc" id="L551">                                            -rotBounds.getY());</span>
<span class="nc" id="L552">                    imageGraphics.transform(rotTransform);</span>

                    /* Fill the BufferedImage either with the caller supplied
                     * color, 'bgColor' or, if null, with white.
                     */
<span class="nc bnc" id="L557" title="All 2 branches missed.">                    if (bgcolor == null) {</span>
<span class="nc" id="L558">                        bgcolor = Color.white;</span>
                    }

                    /* REMIND: no need to use scaling here. */
<span class="nc" id="L562">                    imageGraphics.drawImage(img,</span>
                                            srcX, srcY,
                                            srcX + srcWidth, srcY + srcHeight,
                                            srcX, srcY,
                                            srcX + srcWidth, srcY + srcHeight,
                                            bgcolor, null);

                    /* In PSPrinterJob images are printed in device space
                     * and therefore we need to set a device space clip.
                     * FIX: this is an overly tight coupling of these
                     * two classes.
                     * The temporary clip set needs to be an intersection
                     * with the previous user clip.
                     * REMIND: two xfms may lose accuracy in clip path.
                     */
<span class="nc" id="L577">                    Shape holdClip = getClip();</span>
<span class="nc" id="L578">                    Shape oldClip =</span>
<span class="nc" id="L579">                        getTransform().createTransformedShape(holdClip);</span>
<span class="nc" id="L580">                    AffineTransform sat = AffineTransform.getScaleInstance(</span>
                                                             scaleX, scaleY);
<span class="nc" id="L582">                    Shape imgClip = sat.createTransformedShape(rotShape);</span>
<span class="nc" id="L583">                    Area imgArea = new Area(imgClip);</span>
<span class="nc" id="L584">                    Area oldArea = new Area(oldClip);</span>
<span class="nc" id="L585">                    imgArea.intersect(oldArea);</span>
<span class="nc" id="L586">                    psPrinterJob.setClip(imgArea);</span>

                    /* Scale the bounding rectangle by the scale transform.
                     * Because the scaling transform has only x and y
                     * scaling components it is equivalent to multiply
                     * the x components of the bounding rectangle by
                     * the x scaling factor and to multiply the y components
                     * by the y scaling factor.
                     */
<span class="nc" id="L595">                    Rectangle2D.Float scaledBounds</span>
                            = new Rectangle2D.Float(
<span class="nc" id="L597">                                    (float) (rotBounds.getX() * scaleX),</span>
<span class="nc" id="L598">                                    (float) (rotBounds.getY() * scaleY),</span>
<span class="nc" id="L599">                                    (float) (rotBounds.getWidth() * scaleX),</span>
<span class="nc" id="L600">                                    (float) (rotBounds.getHeight() * scaleY));</span>


                    /* Pull the raster data from the buffered image
                     * and pass it along to PS.
                     */
<span class="nc" id="L606">                    ByteComponentRaster tile =</span>
<span class="nc" id="L607">                                   (ByteComponentRaster)deepImage.getRaster();</span>

<span class="nc" id="L609">                    psPrinterJob.drawImageBGR(tile.getDataStorage(),</span>
                                scaledBounds.x, scaledBounds.y,
<span class="nc" id="L611">                                (float)Math.rint(scaledBounds.width+0.5),</span>
<span class="nc" id="L612">                                (float)Math.rint(scaledBounds.height+0.5),</span>
                                0f, 0f,
<span class="nc" id="L614">                                deepImage.getWidth(), deepImage.getHeight(),</span>
<span class="nc" id="L615">                                deepImage.getWidth(), deepImage.getHeight());</span>

                    /* Reset the device clip to match user clip */
<span class="nc" id="L618">                    psPrinterJob.setClip(</span>
<span class="nc" id="L619">                               getTransform().createTransformedShape(holdClip));</span>


<span class="nc" id="L622">                    imageGraphics.dispose();</span>
                }

            }
        }

<span class="nc" id="L628">        return true;</span>
    }

    /** Redraw a rectanglular area using a proxy graphics
      * To do this we need to know the rectangular area to redraw and
      * the transform &amp; clip in effect at the time of the original drawImage
      *
      */

    public void redrawRegion(Rectangle2D region, double scaleX, double scaleY,
                             Shape savedClip, AffineTransform savedTransform)

            throws PrinterException {

<span class="nc" id="L642">        PSPrinterJob psPrinterJob = (PSPrinterJob)getPrinterJob();</span>
<span class="nc" id="L643">        Printable painter = getPrintable();</span>
<span class="nc" id="L644">        PageFormat pageFormat = getPageFormat();</span>
<span class="nc" id="L645">        int pageIndex = getPageIndex();</span>

        /* Create a buffered image big enough to hold the portion
         * of the source image being printed.
         */
<span class="nc" id="L650">        BufferedImage deepImage = new BufferedImage(</span>
<span class="nc" id="L651">                                        (int) region.getWidth(),</span>
<span class="nc" id="L652">                                        (int) region.getHeight(),</span>
                                        BufferedImage.TYPE_3BYTE_BGR);

        /* Get a graphics for the application to render into.
         * We initialize the buffer to white in order to
         * match the paper and then we shift the BufferedImage
         * so that it covers the area on the page where the
         * caller's Image will be drawn.
         */
<span class="nc" id="L661">        Graphics2D g = deepImage.createGraphics();</span>
<span class="nc" id="L662">        ProxyGraphics2D proxy = new ProxyGraphics2D(g, psPrinterJob);</span>
<span class="nc" id="L663">        proxy.setColor(Color.white);</span>
<span class="nc" id="L664">        proxy.fillRect(0, 0, deepImage.getWidth(), deepImage.getHeight());</span>
<span class="nc" id="L665">        proxy.clipRect(0, 0, deepImage.getWidth(), deepImage.getHeight());</span>

<span class="nc" id="L667">        proxy.translate(-region.getX(), -region.getY());</span>

        /* Calculate the resolution of the source image.
         */
<span class="nc" id="L671">        float sourceResX = (float)(psPrinterJob.getXRes() / scaleX);</span>
<span class="nc" id="L672">        float sourceResY = (float)(psPrinterJob.getYRes() / scaleY);</span>

        /* The application expects to see user space at 72 dpi.
         * so change user space from image source resolution to
         *  72 dpi.
         */
<span class="nc" id="L678">        proxy.scale(sourceResX / DEFAULT_USER_RES,</span>
                    sourceResY / DEFAULT_USER_RES);
<span class="nc" id="L680">       proxy.translate(</span>
<span class="nc" id="L681">            -psPrinterJob.getPhysicalPrintableX(pageFormat.getPaper())</span>
<span class="nc" id="L682">               / psPrinterJob.getXRes() * DEFAULT_USER_RES,</span>
<span class="nc" id="L683">            -psPrinterJob.getPhysicalPrintableY(pageFormat.getPaper())</span>
<span class="nc" id="L684">               / psPrinterJob.getYRes() * DEFAULT_USER_RES);</span>
       /* NB User space now has to be at 72 dpi for this calc to be correct */
<span class="nc" id="L686">        proxy.transform(new AffineTransform(getPageFormat().getMatrix()));</span>

<span class="nc" id="L688">        proxy.setPaint(Color.black);</span>

<span class="nc" id="L690">        painter.print(proxy, pageFormat, pageIndex);</span>

<span class="nc" id="L692">        g.dispose();</span>

        /* In PSPrinterJob images are printed in device space
         * and therefore we need to set a device space clip.
         */
<span class="nc" id="L697">        psPrinterJob.setClip(savedTransform.createTransformedShape(savedClip));</span>


        /* Scale the bounding rectangle by the scale transform.
         * Because the scaling transform has only x and y
         * scaling components it is equivalent to multiply
         * the x components of the bounding rectangle by
         * the x scaling factor and to multiply the y components
         * by the y scaling factor.
         */
<span class="nc" id="L707">        Rectangle2D.Float scaledBounds</span>
                = new Rectangle2D.Float(
<span class="nc" id="L709">                        (float) (region.getX() * scaleX),</span>
<span class="nc" id="L710">                        (float) (region.getY() * scaleY),</span>
<span class="nc" id="L711">                        (float) (region.getWidth() * scaleX),</span>
<span class="nc" id="L712">                        (float) (region.getHeight() * scaleY));</span>


        /* Pull the raster data from the buffered image
         * and pass it along to PS.
         */
<span class="nc" id="L718">        ByteComponentRaster tile = (ByteComponentRaster)deepImage.getRaster();</span>

<span class="nc" id="L720">        psPrinterJob.drawImageBGR(tile.getDataStorage(),</span>
                            scaledBounds.x, scaledBounds.y,
                            scaledBounds.width,
                            scaledBounds.height,
                            0f, 0f,
<span class="nc" id="L725">                            deepImage.getWidth(), deepImage.getHeight(),</span>
<span class="nc" id="L726">                            deepImage.getWidth(), deepImage.getHeight());</span>


<span class="nc" id="L729">    }</span>


    /*
     * Fill the path defined by &lt;code&gt;pathIter&lt;/code&gt;
     * with the specified color.
     * The path is provided in current user space.
     */
    protected void deviceFill(PathIterator pathIter, Color color) {

<span class="nc" id="L739">        PSPrinterJob psPrinterJob = (PSPrinterJob) getPrinterJob();</span>
<span class="nc" id="L740">        psPrinterJob.deviceFill(pathIter, color, getTransform(), getClip());</span>
<span class="nc" id="L741">    }</span>

    /*
     * Draw the bounding rectangle using path by calling draw()
     * function and passing a rectangle shape.
     */
    protected void deviceFrameRect(int x, int y, int width, int height,
                                   Color color) {

<span class="nc" id="L750">        draw(new Rectangle2D.Float(x, y, width, height));</span>
<span class="nc" id="L751">    }</span>

    /*
     * Draw a line using path by calling draw() function and passing
     * a line shape.
     */
    protected void deviceDrawLine(int xBegin, int yBegin,
                                  int xEnd, int yEnd, Color color) {

<span class="nc" id="L760">        draw(new Line2D.Float(xBegin, yBegin, xEnd, yEnd));</span>
<span class="nc" id="L761">    }</span>

    /*
     * Fill the rectangle with the specified color by calling fill().
     */
    protected void deviceFillRect(int x, int y, int width, int height,
                                  Color color) {
<span class="nc" id="L768">        fill(new Rectangle2D.Float(x, y, width, height));</span>
<span class="nc" id="L769">    }</span>


    /*
     * This method should not be invoked by PSPathGraphics.
     * FIX: Rework PathGraphics so that this method is
     * not an abstract method there.
     */
    protected void deviceClip(PathIterator pathIter) {
<span class="nc" id="L778">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>