<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PSPrinterJob.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.print</a> &gt; <span class="el_source">PSPrinterJob.java</span></div><h1>PSPrinterJob.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.print;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.GraphicsEnvironment;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.HeadlessException;
import java.awt.Rectangle;
import java.awt.Shape;

import java.awt.image.BufferedImage;

import java.awt.font.FontRenderContext;

import java.awt.geom.AffineTransform;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;

import java.awt.image.BufferedImage;

import java.awt.print.Pageable;
import java.awt.print.PageFormat;
import java.awt.print.Paper;
import java.awt.print.Printable;
import java.awt.print.PrinterException;
import java.awt.print.PrinterIOException;
import java.awt.print.PrinterJob;

import javax.print.DocFlavor;
import javax.print.PrintService;
import javax.print.StreamPrintService;
import javax.print.attribute.HashPrintRequestAttributeSet;
import javax.print.attribute.PrintRequestAttributeSet;
import javax.print.attribute.PrintServiceAttributeSet;
import javax.print.attribute.standard.PrinterName;
import javax.print.attribute.standard.Chromaticity;
import javax.print.attribute.standard.Copies;
import javax.print.attribute.standard.Destination;
import javax.print.attribute.standard.DialogTypeSelection;
import javax.print.attribute.standard.JobName;
import javax.print.attribute.standard.Sides;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.CharConversionException;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Locale;
import java.util.Properties;

import sun.awt.CharsetString;
import sun.awt.FontConfiguration;
import sun.awt.FontDescriptor;
import sun.awt.PlatformFont;
import sun.awt.SunToolkit;
import sun.font.FontManagerFactory;
import sun.font.FontUtilities;

import java.nio.charset.*;
import java.nio.CharBuffer;
import java.nio.ByteBuffer;
import java.nio.file.Files;

//REMIND: Remove use of this class when IPPPrintService is moved to share directory.
import java.lang.reflect.Method;

/**
 * A class which initiates and executes a PostScript printer job.
 *
 * @author Richard Blanchard
 */
public class PSPrinterJob extends RasterPrinterJob {

 /* Class Constants */

    /**
     * Passed to the &lt;code&gt;setFillMode&lt;/code&gt;
     * method this value forces fills to be
     * done using the even-odd fill rule.
     */
    protected static final int FILL_EVEN_ODD = 1;

    /**
     * Passed to the &lt;code&gt;setFillMode&lt;/code&gt;
     * method this value forces fills to be
     * done using the non-zero winding rule.
     */
    protected static final int FILL_WINDING = 2;

    /* PostScript has a 64K maximum on its strings.
     */
    private static final int MAX_PSSTR = (1024 * 64 - 1);

    private static final int RED_MASK = 0x00ff0000;
    private static final int GREEN_MASK = 0x0000ff00;
    private static final int BLUE_MASK = 0x000000ff;

    private static final int RED_SHIFT = 16;
    private static final int GREEN_SHIFT = 8;
    private static final int BLUE_SHIFT = 0;

    private static final int LOWNIBBLE_MASK = 0x0000000f;
    private static final int HINIBBLE_MASK =  0x000000f0;
    private static final int HINIBBLE_SHIFT = 4;
<span class="nc" id="L145">    private static final byte hexDigits[] = {</span>
        (byte)'0', (byte)'1', (byte)'2', (byte)'3',
        (byte)'4', (byte)'5', (byte)'6', (byte)'7',
        (byte)'8', (byte)'9', (byte)'A', (byte)'B',
        (byte)'C', (byte)'D', (byte)'E', (byte)'F'
    };

    private static final int PS_XRES = 300;
    private static final int PS_YRES = 300;

    private static final String ADOBE_PS_STR =  &quot;%!PS-Adobe-3.0&quot;;
    private static final String EOF_COMMENT =   &quot;%%EOF&quot;;
    private static final String PAGE_COMMENT =  &quot;%%Page: &quot;;

    private static final String READIMAGEPROC = &quot;/imStr 0 def /imageSrc &quot; +
        &quot;{currentfile /ASCII85Decode filter /RunLengthDecode filter &quot; +
        &quot; imStr readstring pop } def&quot;;

    private static final String COPIES =        &quot;/#copies exch def&quot;;
    private static final String PAGE_SAVE =     &quot;/pgSave save def&quot;;
    private static final String PAGE_RESTORE =  &quot;pgSave restore&quot;;
    private static final String SHOWPAGE =      &quot;showpage&quot;;
    private static final String IMAGE_SAVE =    &quot;/imSave save def&quot;;
    private static final String IMAGE_STR =     &quot; string /imStr exch def&quot;;
    private static final String IMAGE_RESTORE = &quot;imSave restore&quot;;

    private static final String COORD_PREP =    &quot; 0 exch translate &quot;
                                              + &quot;1 -1 scale&quot;
                                              + &quot;[72 &quot; + PS_XRES + &quot; div &quot;
                                              + &quot;0 0 &quot;
                                              + &quot;72 &quot; + PS_YRES + &quot; div &quot;
                                              + &quot;0 0]concat&quot;;

    private static final String SetFontName = &quot;F&quot;;

    private static final String DrawStringName = &quot;S&quot;;

    /**
     * The PostScript invocation to fill a path using the
     * even-odd rule. (eofill)
     */
    private static final String EVEN_ODD_FILL_STR = &quot;EF&quot;;

    /**
     * The PostScript invocation to fill a path using the
     * non-zero winding rule. (fill)
     */
    private static final String WINDING_FILL_STR = &quot;WF&quot;;

    /**
     * The PostScript to set the clip to be the current path
     * using the even odd rule. (eoclip)
     */
    private static final String EVEN_ODD_CLIP_STR = &quot;EC&quot;;

    /**
     * The PostScript to set the clip to be the current path
     * using the non-zero winding rule. (clip)
     */
    private static final String WINDING_CLIP_STR = &quot;WC&quot;;

    /**
     * Expecting two numbers on the PostScript stack, this
     * invocation moves the current pen position. (moveto)
     */
    private static final String MOVETO_STR = &quot; M&quot;;
    /**
     * Expecting two numbers on the PostScript stack, this
     * invocation draws a PS line from the current pen
     * position to the point on the stack. (lineto)
     */
    private static final String LINETO_STR = &quot; L&quot;;

    /**
     * This PostScript operator takes two control points
     * and an ending point and using the current pen
     * position as a starting point adds a bezier
     * curve to the current path. (curveto)
     */
    private static final String CURVETO_STR = &quot; C&quot;;

    /**
     * The PostScript to pop a state off of the printer's
     * gstate stack. (grestore)
     */
    private static final String GRESTORE_STR = &quot;R&quot;;
    /**
     * The PostScript to push a state on to the printer's
     * gstate stack. (gsave)
     */
    private static final String GSAVE_STR = &quot;G&quot;;

    /**
     * Make the current PostScript path an empty path. (newpath)
     */
    private static final String NEWPATH_STR = &quot;N&quot;;

    /**
     * Close the current subpath by generating a line segment
     * from the current position to the start of the subpath. (closepath)
     */
    private static final String CLOSEPATH_STR = &quot;P&quot;;

    /**
     * Use the three numbers on top of the PS operator
     * stack to set the rgb color. (setrgbcolor)
     */
    private static final String SETRGBCOLOR_STR = &quot; SC&quot;;

    /**
     * Use the top number on the stack to set the printer's
     * current gray value. (setgray)
     */
    private static final String SETGRAY_STR = &quot; SG&quot;;

 /* Instance Variables */

   private int mDestType;

<span class="nc" id="L264">   private String mDestination = &quot;lp&quot;;</span>

<span class="nc" id="L266">   private boolean mNoJobSheet = false;</span>

   private String mOptions;

   private Font mLastFont;

   private Color mLastColor;

   private Shape mLastClip;

   private AffineTransform mLastTransform;

   /* non-null if printing EPS for Java Plugin */
<span class="nc" id="L279">   private EPSPrinter epsPrinter = null;</span>

   /**
    * The metrics for the font currently set.
    */
   FontMetrics mCurMetrics;

   /**
    * The output stream to which the generated PostScript
    * is written.
    */
   PrintStream mPSStream;

   /* The temporary file to which we spool before sending to the printer  */

   File spoolFile;

   /**
    * This string holds the PostScript operator to
    * be used to fill a path. It can be changed
    * by the &lt;code&gt;setFillMode&lt;/code&gt; method.
    */
<span class="nc" id="L301">    private String mFillOpStr = WINDING_FILL_STR;</span>

   /**
    * This string holds the PostScript operator to
    * be used to clip to a path. It can be changed
    * by the &lt;code&gt;setFillMode&lt;/code&gt; method.
    */
<span class="nc" id="L308">    private String mClipOpStr = WINDING_CLIP_STR;</span>

   /**
    * A stack that represents the PostScript gstate stack.
    */
<span class="nc" id="L313">   ArrayList mGStateStack = new ArrayList();</span>

   /**
    * The x coordinate of the current pen position.
    */
   private float mPenX;

   /**
    * The y coordinate of the current pen position.
    */
   private float mPenY;

   /**
    * The x coordinate of the starting point of
    * the current subpath.
    */
   private float mStartPathX;

   /**
    * The y coordinate of the starting point of
    * the current subpath.
    */
   private float mStartPathY;

   /**
    * An optional mapping of fonts to PostScript names.
    */
<span class="nc" id="L340">   private static Properties mFontProps = null;</span>

   private static boolean isMac;

    /* Class static initialiser block */
    static {
       //enable priviledges so initProps can access system properties,
        // open the property file, etc.
<span class="nc" id="L348">        java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L349">                            new java.security.PrivilegedAction() {</span>
            public Object run() {
<span class="nc" id="L351">                mFontProps = initProps();</span>
<span class="nc" id="L352">                String osName = System.getProperty(&quot;os.name&quot;);</span>
<span class="nc" id="L353">                isMac = osName.startsWith(&quot;Mac&quot;);</span>
<span class="nc" id="L354">                return null;</span>
            }
        });
<span class="nc" id="L357">    }</span>

    /*
     * Initialize PostScript font properties.
     * Copied from PSPrintStream
     */
    private static Properties initProps() {
        // search psfont.properties for fonts
        // and create and initialize fontProps if it exist.

<span class="nc" id="L367">        String jhome = System.getProperty(&quot;java.home&quot;);</span>

<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (jhome != null){</span>
<span class="nc" id="L370">            String ulocale = SunToolkit.getStartupLocale().getLanguage();</span>
            try {

<span class="nc" id="L373">                File f = new File(jhome + File.separator +</span>
                                  &quot;lib&quot; + File.separator +
                                  &quot;psfontj2d.properties.&quot; + ulocale);

<span class="nc bnc" id="L377" title="All 2 branches missed.">                if (!f.canRead()){</span>

<span class="nc" id="L379">                    f = new File(jhome + File.separator +</span>
                                      &quot;lib&quot; + File.separator +
                                      &quot;psfont.properties.&quot; + ulocale);
<span class="nc bnc" id="L382" title="All 2 branches missed.">                    if (!f.canRead()){</span>

<span class="nc" id="L384">                        f = new File(jhome + File.separator + &quot;lib&quot; +</span>
                                     File.separator + &quot;psfontj2d.properties&quot;);

<span class="nc bnc" id="L387" title="All 2 branches missed.">                        if (!f.canRead()){</span>

<span class="nc" id="L389">                            f = new File(jhome + File.separator + &quot;lib&quot; +</span>
                                         File.separator + &quot;psfont.properties&quot;);

<span class="nc bnc" id="L392" title="All 2 branches missed.">                            if (!f.canRead()){</span>
<span class="nc" id="L393">                                return (Properties)null;</span>
                            }
                        }
                    }
                }

                // Load property file
<span class="nc" id="L400">                InputStream in =</span>
<span class="nc" id="L401">                    new BufferedInputStream(new FileInputStream(f.getPath()));</span>
<span class="nc" id="L402">                Properties props = new Properties();</span>
<span class="nc" id="L403">                props.load(in);</span>
<span class="nc" id="L404">                in.close();</span>
<span class="nc" id="L405">                return props;</span>
<span class="nc" id="L406">            } catch (Exception e){</span>
<span class="nc" id="L407">                return (Properties)null;</span>
            }
        }
<span class="nc" id="L410">        return (Properties)null;</span>
    }

 /* Constructors */

    public PSPrinterJob()
<span class="nc" id="L416">    {</span>
<span class="nc" id="L417">    }</span>

 /* Instance Methods */

   /**
     * Presents the user a dialog for changing properties of the
     * print job interactively.
     * @returns false if the user cancels the dialog and
     *          true otherwise.
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    public boolean printDialog() throws HeadlessException {

<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L433">            throw new HeadlessException();</span>
        }

<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (attributes == null) {</span>
<span class="nc" id="L437">            attributes = new HashPrintRequestAttributeSet();</span>
        }
<span class="nc" id="L439">        attributes.add(new Copies(getCopies()));</span>
<span class="nc" id="L440">        attributes.add(new JobName(getJobName(), null));</span>

<span class="nc" id="L442">        boolean doPrint = false;</span>
<span class="nc" id="L443">        DialogTypeSelection dts =</span>
<span class="nc" id="L444">            (DialogTypeSelection)attributes.get(DialogTypeSelection.class);</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">        if (dts == DialogTypeSelection.NATIVE) {</span>
            // Remove DialogTypeSelection.NATIVE to prevent infinite loop in
            // RasterPrinterJob.
<span class="nc" id="L448">            attributes.remove(DialogTypeSelection.class);</span>
<span class="nc" id="L449">            doPrint = printDialog(attributes);</span>
            // restore attribute
<span class="nc" id="L451">            attributes.add(DialogTypeSelection.NATIVE);</span>
        } else {
<span class="nc" id="L453">            doPrint = printDialog(attributes);</span>
        }

<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (doPrint) {</span>
<span class="nc" id="L457">            JobName jobName = (JobName)attributes.get(JobName.class);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">            if (jobName != null) {</span>
<span class="nc" id="L459">                setJobName(jobName.getValue());</span>
            }
<span class="nc" id="L461">            Copies copies = (Copies)attributes.get(Copies.class);</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">            if (copies != null) {</span>
<span class="nc" id="L463">                setCopies(copies.getValue());</span>
            }

<span class="nc" id="L466">            Destination dest = (Destination)attributes.get(Destination.class);</span>

<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (dest != null) {</span>
                try {
<span class="nc" id="L470">                    mDestType = RasterPrinterJob.FILE;</span>
<span class="nc" id="L471">                    mDestination = (new File(dest.getURI())).getPath();</span>
<span class="nc" id="L472">                } catch (Exception e) {</span>
<span class="nc" id="L473">                    mDestination = &quot;out.ps&quot;;</span>
<span class="nc" id="L474">                }</span>
            } else {
<span class="nc" id="L476">                mDestType = RasterPrinterJob.PRINTER;</span>
<span class="nc" id="L477">                PrintService pServ = getPrintService();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">                if (pServ != null) {</span>
<span class="nc" id="L479">                    mDestination = pServ.getName();</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">                   if (isMac) {</span>
<span class="nc" id="L481">                        PrintServiceAttributeSet psaSet = pServ.getAttributes() ;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">                        if (psaSet != null) {</span>
<span class="nc" id="L483">                            mDestination = psaSet.get(PrinterName.class).toString();</span>
                        }
                    }
                }
            }
        }

<span class="nc" id="L490">        return doPrint;</span>
    }

    /**
     * Invoked by the RasterPrinterJob super class
     * this method is called to mark the start of a
     * document.
     */
    protected void startDoc() throws PrinterException {

        // A security check has been performed in the
        // java.awt.print.printerJob.getPrinterJob method.
        // We use an inner class to execute the privilged open operations.
        // Note that we only open a file if it has been nominated by
        // the end-user in a dialog that we ouselves put up.

        OutputStream output;

<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (epsPrinter == null) {</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">            if (getPrintService() instanceof PSStreamPrintService) {</span>
<span class="nc" id="L510">                StreamPrintService sps = (StreamPrintService)getPrintService();</span>
<span class="nc" id="L511">                mDestType = RasterPrinterJob.STREAM;</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">                if (sps.isDisposed()) {</span>
<span class="nc" id="L513">                    throw new PrinterException(&quot;service is disposed&quot;);</span>
                }
<span class="nc" id="L515">                output = sps.getOutputStream();</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">                if (output == null) {</span>
<span class="nc" id="L517">                    throw new PrinterException(&quot;Null output stream&quot;);</span>
                }
<span class="nc" id="L519">            } else {</span>
                /* REMIND: This needs to be more maintainable */
<span class="nc" id="L521">                mNoJobSheet = super.noJobSheet;</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                if (super.destinationAttr != null) {</span>
<span class="nc" id="L523">                    mDestType = RasterPrinterJob.FILE;</span>
<span class="nc" id="L524">                    mDestination = super.destinationAttr;</span>
                }
<span class="nc bnc" id="L526" title="All 2 branches missed.">                if (mDestType == RasterPrinterJob.FILE) {</span>
                    try {
<span class="nc" id="L528">                        spoolFile = new File(mDestination);</span>
<span class="nc" id="L529">                        output =  new FileOutputStream(spoolFile);</span>
<span class="nc" id="L530">                    } catch (IOException ex) {</span>
<span class="nc" id="L531">                        throw new PrinterIOException(ex);</span>
<span class="nc" id="L532">                    }</span>
                } else {
<span class="nc" id="L534">                    PrinterOpener po = new PrinterOpener();</span>
<span class="nc" id="L535">                    java.security.AccessController.doPrivileged(po);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                    if (po.pex != null) {</span>
<span class="nc" id="L537">                        throw po.pex;</span>
                    }
<span class="nc" id="L539">                    output = po.result;</span>
                }
            }

<span class="nc" id="L543">            mPSStream = new PrintStream(new BufferedOutputStream(output));</span>
<span class="nc" id="L544">            mPSStream.println(ADOBE_PS_STR);</span>
        }

<span class="nc" id="L547">        mPSStream.println(&quot;%%BeginProlog&quot;);</span>
<span class="nc" id="L548">        mPSStream.println(READIMAGEPROC);</span>
<span class="nc" id="L549">        mPSStream.println(&quot;/BD {bind def} bind def&quot;);</span>
<span class="nc" id="L550">        mPSStream.println(&quot;/D {def} BD&quot;);</span>
<span class="nc" id="L551">        mPSStream.println(&quot;/C {curveto} BD&quot;);</span>
<span class="nc" id="L552">        mPSStream.println(&quot;/L {lineto} BD&quot;);</span>
<span class="nc" id="L553">        mPSStream.println(&quot;/M {moveto} BD&quot;);</span>
<span class="nc" id="L554">        mPSStream.println(&quot;/R {grestore} BD&quot;);</span>
<span class="nc" id="L555">        mPSStream.println(&quot;/G {gsave} BD&quot;);</span>
<span class="nc" id="L556">        mPSStream.println(&quot;/N {newpath} BD&quot;);</span>
<span class="nc" id="L557">        mPSStream.println(&quot;/P {closepath} BD&quot;);</span>
<span class="nc" id="L558">        mPSStream.println(&quot;/EC {eoclip} BD&quot;);</span>
<span class="nc" id="L559">        mPSStream.println(&quot;/WC {clip} BD&quot;);</span>
<span class="nc" id="L560">        mPSStream.println(&quot;/EF {eofill} BD&quot;);</span>
<span class="nc" id="L561">        mPSStream.println(&quot;/WF {fill} BD&quot;);</span>
<span class="nc" id="L562">        mPSStream.println(&quot;/SG {setgray} BD&quot;);</span>
<span class="nc" id="L563">        mPSStream.println(&quot;/SC {setrgbcolor} BD&quot;);</span>
<span class="nc" id="L564">        mPSStream.println(&quot;/ISOF {&quot;);</span>
<span class="nc" id="L565">        mPSStream.println(&quot;     dup findfont dup length 1 add dict begin {&quot;);</span>
<span class="nc" id="L566">        mPSStream.println(&quot;             1 index /FID eq {pop pop} {D} ifelse&quot;);</span>
<span class="nc" id="L567">        mPSStream.println(&quot;     } forall /Encoding ISOLatin1Encoding D&quot;);</span>
<span class="nc" id="L568">        mPSStream.println(&quot;     currentdict end definefont&quot;);</span>
<span class="nc" id="L569">        mPSStream.println(&quot;} BD&quot;);</span>
<span class="nc" id="L570">        mPSStream.println(&quot;/NZ {dup 1 lt {pop 1} if} BD&quot;);</span>
        /* The following procedure takes args: string, x, y, desiredWidth.
         * It calculates using stringwidth the width of the string in the
         * current font and subtracts it from the desiredWidth and divides
         * this by stringLen-1. This gives us a per-glyph adjustment in
         * the spacing needed (either +ve or -ve) to make the string
         * print at the desiredWidth. The ashow procedure call takes this
         * per-glyph adjustment as an argument. This is necessary for WYSIWYG
         */
<span class="nc" id="L579">        mPSStream.println(&quot;/&quot;+DrawStringName +&quot; {&quot;);</span>
<span class="nc" id="L580">        mPSStream.println(&quot;     moveto 1 index stringwidth pop NZ sub&quot;);</span>
<span class="nc" id="L581">        mPSStream.println(&quot;     1 index length 1 sub NZ div 0&quot;);</span>
<span class="nc" id="L582">        mPSStream.println(&quot;     3 2 roll ashow newpath} BD&quot;);</span>
<span class="nc" id="L583">        mPSStream.println(&quot;/FL [&quot;);</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">        if (mFontProps == null){</span>
<span class="nc" id="L585">            mPSStream.println(&quot; /Helvetica ISOF&quot;);</span>
<span class="nc" id="L586">            mPSStream.println(&quot; /Helvetica-Bold ISOF&quot;);</span>
<span class="nc" id="L587">            mPSStream.println(&quot; /Helvetica-Oblique ISOF&quot;);</span>
<span class="nc" id="L588">            mPSStream.println(&quot; /Helvetica-BoldOblique ISOF&quot;);</span>
<span class="nc" id="L589">            mPSStream.println(&quot; /Times-Roman ISOF&quot;);</span>
<span class="nc" id="L590">            mPSStream.println(&quot; /Times-Bold ISOF&quot;);</span>
<span class="nc" id="L591">            mPSStream.println(&quot; /Times-Italic ISOF&quot;);</span>
<span class="nc" id="L592">            mPSStream.println(&quot; /Times-BoldItalic ISOF&quot;);</span>
<span class="nc" id="L593">            mPSStream.println(&quot; /Courier ISOF&quot;);</span>
<span class="nc" id="L594">            mPSStream.println(&quot; /Courier-Bold ISOF&quot;);</span>
<span class="nc" id="L595">            mPSStream.println(&quot; /Courier-Oblique ISOF&quot;);</span>
<span class="nc" id="L596">            mPSStream.println(&quot; /Courier-BoldOblique ISOF&quot;);</span>
        } else {
<span class="nc" id="L598">            int cnt = Integer.parseInt(mFontProps.getProperty(&quot;font.num&quot;, &quot;9&quot;));</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">            for (int i = 0; i &lt; cnt; i++){</span>
<span class="nc" id="L600">                mPSStream.println(&quot;    /&quot; + mFontProps.getProperty</span>
<span class="nc" id="L601">                           (&quot;font.&quot; + String.valueOf(i), &quot;Courier ISOF&quot;));</span>
            }
        }
<span class="nc" id="L604">        mPSStream.println(&quot;] D&quot;);</span>

<span class="nc" id="L606">        mPSStream.println(&quot;/&quot;+SetFontName +&quot; {&quot;);</span>
<span class="nc" id="L607">        mPSStream.println(&quot;     FL exch get exch scalefont&quot;);</span>
<span class="nc" id="L608">        mPSStream.println(&quot;     [1 0 0 -1 0 0] makefont setfont} BD&quot;);</span>

<span class="nc" id="L610">        mPSStream.println(&quot;%%EndProlog&quot;);</span>

<span class="nc" id="L612">        mPSStream.println(&quot;%%BeginSetup&quot;);</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (epsPrinter == null) {</span>
            // Set Page Size using first page's format.
<span class="nc" id="L615">            PageFormat pageFormat = getPageable().getPageFormat(0);</span>
<span class="nc" id="L616">            double paperHeight = pageFormat.getPaper().getHeight();</span>
<span class="nc" id="L617">            double paperWidth = pageFormat.getPaper().getWidth();</span>

            /* PostScript printers can always generate uncollated copies.
             */
<span class="nc" id="L621">            mPSStream.print(&quot;&lt;&lt; /PageSize [&quot; +</span>
                                           paperWidth + &quot; &quot;+ paperHeight+&quot;]&quot;);

<span class="nc" id="L624">            final PrintService pservice = getPrintService();</span>
<span class="nc" id="L625">            Boolean isPS = (Boolean)java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L626">                new java.security.PrivilegedAction() {</span>
                    public Object run() {
                       try {
<span class="nc" id="L629">                           Class psClass = Class.forName(&quot;sun.print.IPPPrintService&quot;);</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">                           if (psClass.isInstance(pservice)) {</span>
<span class="nc" id="L631">                               Method isPSMethod = psClass.getMethod(&quot;isPostscript&quot;,</span>
                                                                     (Class[])null);
<span class="nc" id="L633">                               return (Boolean)isPSMethod.invoke(pservice, (Object[])null);</span>
                           }
<span class="nc" id="L635">                       } catch (Throwable t) {</span>
<span class="nc" id="L636">                       }</span>
<span class="nc" id="L637">                       return Boolean.TRUE;</span>
                    }
                }
            );
<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (isPS) {</span>
<span class="nc" id="L642">                mPSStream.print(&quot; /DeferredMediaSelection true&quot;);</span>
            }

<span class="nc" id="L645">            mPSStream.print(&quot; /ImagingBBox null /ManualFeed false&quot;);</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">            mPSStream.print(isCollated() ? &quot; /Collate true&quot;:&quot;&quot;);</span>
<span class="nc" id="L647">            mPSStream.print(&quot; /NumCopies &quot; +getCopiesInt());</span>

<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (sidesAttr != Sides.ONE_SIDED) {</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">                if (sidesAttr == Sides.TWO_SIDED_LONG_EDGE) {</span>
<span class="nc" id="L651">                    mPSStream.print(&quot; /Duplex true &quot;);</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                } else if (sidesAttr == Sides.TWO_SIDED_SHORT_EDGE) {</span>
<span class="nc" id="L653">                    mPSStream.print(&quot; /Duplex true /Tumble true &quot;);</span>
                }
            }
<span class="nc" id="L656">            mPSStream.println(&quot; &gt;&gt; setpagedevice &quot;);</span>
        }
<span class="nc" id="L658">        mPSStream.println(&quot;%%EndSetup&quot;);</span>
<span class="nc" id="L659">    }</span>

    // Inner class to run &quot;privileged&quot; to open the printer output stream.

<span class="nc" id="L663">    private class PrinterOpener implements java.security.PrivilegedAction {</span>
        PrinterException pex;
        OutputStream result;

        public Object run() {
            try {

                    /* Write to a temporary file which will be spooled to
                     * the printer then deleted. In the case that the file
                     * is not removed for some reason, request that it is
                     * removed when the VM exits.
                     */
<span class="nc" id="L675">                    spoolFile = Files.createTempFile(&quot;javaprint&quot;, &quot;.ps&quot;).toFile();</span>
<span class="nc" id="L676">                    spoolFile.deleteOnExit();</span>

<span class="nc" id="L678">                result = new FileOutputStream(spoolFile);</span>
<span class="nc" id="L679">                return result;</span>
<span class="nc" id="L680">            } catch (IOException ex) {</span>
                // If there is an IOError we subvert it to a PrinterException.
<span class="nc" id="L682">                pex = new PrinterIOException(ex);</span>
            }
<span class="nc" id="L684">            return null;</span>
        }
    }

    // Inner class to run &quot;privileged&quot; to invoke the system print command

<span class="nc" id="L690">    private class PrinterSpooler implements java.security.PrivilegedAction {</span>
        PrinterException pex;

        private void handleProcessFailure(final Process failedProcess,
                final String[] execCmd, final int result) throws IOException {
<span class="nc" id="L695">            try (StringWriter sw = new StringWriter();</span>
<span class="nc" id="L696">                    PrintWriter pw = new PrintWriter(sw)) {</span>
<span class="nc" id="L697">                pw.append(&quot;error=&quot;).append(Integer.toString(result));</span>
<span class="nc" id="L698">                pw.append(&quot; running:&quot;);</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">                for (String arg: execCmd) {</span>
<span class="nc" id="L700">                    pw.append(&quot; '&quot;).append(arg).append(&quot;'&quot;);</span>
                }
<span class="nc" id="L702">                try (InputStream is = failedProcess.getErrorStream();</span>
<span class="nc" id="L703">                        InputStreamReader isr = new InputStreamReader(is);</span>
<span class="nc" id="L704">                        BufferedReader br = new BufferedReader(isr)) {</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                    while (br.ready()) {</span>
<span class="nc" id="L706">                        pw.println();</span>
<span class="nc" id="L707">                        pw.append(&quot;\t\t&quot;).append(br.readLine());</span>
                    }
<span class="nc bnc" id="L709" title="All 24 branches missed.">                } finally {</span>
<span class="nc" id="L710">                    pw.flush();</span>
<span class="nc" id="L711">                    throw new IOException(sw.toString());</span>
                }
<span class="nc bnc" id="L713" title="All 8 branches missed.">            }</span>
        }

        public Object run() {
<span class="nc bnc" id="L717" title="All 4 branches missed.">            if (spoolFile == null || !spoolFile.exists()) {</span>
<span class="nc" id="L718">               pex = new PrinterException(&quot;No spool file&quot;);</span>
<span class="nc" id="L719">               return null;</span>
            }
            try {
                /**
                 * Spool to the printer.
                 */
<span class="nc" id="L725">                String fileName = spoolFile.getAbsolutePath();</span>
<span class="nc" id="L726">                String execCmd[] = printExecCmd(mDestination, mOptions,</span>
<span class="nc" id="L727">                               mNoJobSheet, getJobNameInt(),</span>
                                                1, fileName);

<span class="nc" id="L730">                Process process = Runtime.getRuntime().exec(execCmd);</span>
<span class="nc" id="L731">                process.waitFor();</span>
<span class="nc" id="L732">                final int result = process.exitValue();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                if (0 != result) {</span>
<span class="nc" id="L734">                    handleProcessFailure(process, execCmd, result);</span>
                }
<span class="nc" id="L736">            } catch (IOException ex) {</span>
<span class="nc" id="L737">                pex = new PrinterIOException(ex);</span>
<span class="nc" id="L738">            } catch (InterruptedException ie) {</span>
<span class="nc" id="L739">                pex = new PrinterException(ie.toString());</span>
            } finally {
<span class="nc" id="L741">                spoolFile.delete();</span>
<span class="nc" id="L742">            }</span>
<span class="nc" id="L743">            return null;</span>
        }
    }


    /**
     * Invoked if the application cancelled the printjob.
     */
    protected void abortDoc() {
<span class="nc bnc" id="L752" title="All 4 branches missed.">        if (mPSStream != null &amp;&amp; mDestType != RasterPrinterJob.STREAM) {</span>
<span class="nc" id="L753">            mPSStream.close();</span>
        }
<span class="nc" id="L755">        java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L756">            new java.security.PrivilegedAction() {</span>

            public Object run() {
<span class="nc bnc" id="L759" title="All 4 branches missed.">               if (spoolFile != null &amp;&amp; spoolFile.exists()) {</span>
<span class="nc" id="L760">                   spoolFile.delete();</span>
               }
<span class="nc" id="L762">               return null;</span>
            }
        });
<span class="nc" id="L765">    }</span>

    /**
     * Invoked by the RasterPrintJob super class
     * this method is called after that last page
     * has been imaged.
     */
    protected void endDoc() throws PrinterException {
<span class="nc bnc" id="L773" title="All 2 branches missed.">        if (mPSStream != null) {</span>
<span class="nc" id="L774">            mPSStream.println(EOF_COMMENT);</span>
<span class="nc" id="L775">            mPSStream.flush();</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (mDestType != RasterPrinterJob.STREAM) {</span>
<span class="nc" id="L777">                mPSStream.close();</span>
            }
        }
<span class="nc bnc" id="L780" title="All 2 branches missed.">        if (mDestType == RasterPrinterJob.PRINTER) {</span>
<span class="nc" id="L781">            PrintService pServ = getPrintService();</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">            if (pServ != null) {</span>
<span class="nc" id="L783">                mDestination = pServ.getName();</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">               if (isMac) {</span>
<span class="nc" id="L785">                    PrintServiceAttributeSet psaSet = pServ.getAttributes();</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">                    if (psaSet != null) {</span>
<span class="nc" id="L787">                        mDestination = psaSet.get(PrinterName.class).toString() ;</span>
                    }
                }
            }
<span class="nc" id="L791">            PrinterSpooler spooler = new PrinterSpooler();</span>
<span class="nc" id="L792">            java.security.AccessController.doPrivileged(spooler);</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">            if (spooler.pex != null) {</span>
<span class="nc" id="L794">                throw spooler.pex;</span>
            }
        }
<span class="nc" id="L797">    }</span>

    /**
     * The RasterPrintJob super class calls this method
     * at the start of each page.
     */
    protected void startPage(PageFormat pageFormat, Printable painter,
                             int index, boolean paperChanged)
        throws PrinterException
    {
<span class="nc" id="L807">        double paperHeight = pageFormat.getPaper().getHeight();</span>
<span class="nc" id="L808">        double paperWidth = pageFormat.getPaper().getWidth();</span>
<span class="nc" id="L809">        int pageNumber = index + 1;</span>

        /* Place an initial gstate on to our gstate stack.
         * It will have the default PostScript gstate
         * attributes.
         */
<span class="nc" id="L815">        mGStateStack = new ArrayList();</span>
<span class="nc" id="L816">        mGStateStack.add(new GState());</span>

<span class="nc" id="L818">        mPSStream.println(PAGE_COMMENT + pageNumber + &quot; &quot; + pageNumber);</span>

        /* Check current page's pageFormat against the previous pageFormat,
         */
<span class="nc bnc" id="L822" title="All 4 branches missed.">        if (index &gt; 0 &amp;&amp; paperChanged) {</span>

<span class="nc" id="L824">            mPSStream.print(&quot;&lt;&lt; /PageSize [&quot; +</span>
                            paperWidth + &quot; &quot; + paperHeight + &quot;]&quot;);

<span class="nc" id="L827">            final PrintService pservice = getPrintService();</span>
<span class="nc" id="L828">            Boolean isPS =</span>
<span class="nc" id="L829">                (Boolean)java.security.AccessController.doPrivileged(</span>

<span class="nc" id="L831">                new java.security.PrivilegedAction() {</span>
                    public Object run() {
                        try {
<span class="nc" id="L834">                            Class psClass =</span>
<span class="nc" id="L835">                                Class.forName(&quot;sun.print.IPPPrintService&quot;);</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">                            if (psClass.isInstance(pservice)) {</span>
<span class="nc" id="L837">                                Method isPSMethod =</span>
<span class="nc" id="L838">                                    psClass.getMethod(&quot;isPostscript&quot;,</span>
                                                      (Class[])null);
<span class="nc" id="L840">                                return (Boolean)</span>
<span class="nc" id="L841">                                    isPSMethod.invoke(pservice,</span>
                                                      (Object[])null);
                            }
<span class="nc" id="L844">                        } catch (Throwable t) {</span>
<span class="nc" id="L845">                        }</span>
<span class="nc" id="L846">                        return Boolean.TRUE;</span>
                    }
                    }
                );

<span class="nc bnc" id="L851" title="All 2 branches missed.">            if (isPS) {</span>
<span class="nc" id="L852">                mPSStream.print(&quot; /DeferredMediaSelection true&quot;);</span>
            }
<span class="nc" id="L854">            mPSStream.println(&quot; &gt;&gt; setpagedevice&quot;);</span>
        }
<span class="nc" id="L856">        mPSStream.println(PAGE_SAVE);</span>
<span class="nc" id="L857">        mPSStream.println(paperHeight + COORD_PREP);</span>
<span class="nc" id="L858">    }</span>

    /**
     * The RastePrintJob super class calls this method
     * at the end of each page.
     */
    protected void endPage(PageFormat format, Printable painter,
                           int index)
        throws PrinterException
    {
<span class="nc" id="L868">        mPSStream.println(PAGE_RESTORE);</span>
<span class="nc" id="L869">        mPSStream.println(SHOWPAGE);</span>
<span class="nc" id="L870">    }</span>

   /**
     * Convert the 24 bit BGR image buffer represented by
     * &lt;code&gt;image&lt;/code&gt; to PostScript. The image is drawn at
     * &lt;code&gt;(destX, destY)&lt;/code&gt; in device coordinates.
     * The image is scaled into a square of size
     * specified by &lt;code&gt;destWidth&lt;/code&gt; and
     * &lt;code&gt;destHeight&lt;/code&gt;. The portion of the
     * source image copied into that square is specified
     * by &lt;code&gt;srcX&lt;/code&gt;, &lt;code&gt;srcY&lt;/code&gt;,
     * &lt;code&gt;srcWidth&lt;/code&gt;, and srcHeight.
     */
    protected void drawImageBGR(byte[] bgrData,
                                   float destX, float destY,
                                   float destWidth, float destHeight,
                                   float srcX, float srcY,
                                   float srcWidth, float srcHeight,
                                   int srcBitMapWidth, int srcBitMapHeight) {

        /* We draw images at device resolution so we probably need
         * to change the current PostScript transform.
         */
<span class="nc" id="L893">        setTransform(new AffineTransform());</span>
<span class="nc" id="L894">        prepDrawing();</span>

<span class="nc" id="L896">        int intSrcWidth = (int) srcWidth;</span>
<span class="nc" id="L897">        int intSrcHeight = (int) srcHeight;</span>

<span class="nc" id="L899">        mPSStream.println(IMAGE_SAVE);</span>

        /* Create a PS string big enough to hold a row of pixels.
         */
<span class="nc" id="L903">        int psBytesPerRow = 3 * (int) intSrcWidth;</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">        while (psBytesPerRow &gt; MAX_PSSTR) {</span>
<span class="nc" id="L905">            psBytesPerRow /= 2;</span>
        }

<span class="nc" id="L908">        mPSStream.println(psBytesPerRow + IMAGE_STR);</span>

        /* Scale and translate the unit image.
         */
<span class="nc" id="L912">        mPSStream.println(&quot;[&quot; + destWidth + &quot; 0 &quot;</span>
                          + &quot;0 &quot; + destHeight
                          + &quot; &quot; + destX + &quot; &quot; + destY
                          +&quot;]concat&quot;);

        /* Color Image invocation.
         */
<span class="nc" id="L919">        mPSStream.println(intSrcWidth + &quot; &quot; + intSrcHeight + &quot; &quot; + 8 + &quot;[&quot;</span>
                          + intSrcWidth + &quot; 0 &quot;
                          + &quot;0 &quot; + intSrcHeight
                          + &quot; 0 &quot; + 0 + &quot;]&quot;
                          + &quot;/imageSrc load false 3 colorimage&quot;);

        /* Image data.
         */
<span class="nc" id="L927">        int index = 0;</span>
<span class="nc" id="L928">        byte[] rgbData = new byte[intSrcWidth * 3];</span>

        try {
            /* Skip the parts of the image that are not part
             * of the source rectangle.
             */
<span class="nc" id="L934">            index = (int) srcY * srcBitMapWidth;</span>

<span class="nc bnc" id="L936" title="All 2 branches missed.">            for(int i = 0; i &lt; intSrcHeight; i++) {</span>

                /* Skip the left part of the image that is not
                 * part of the source rectangle.
                 */
<span class="nc" id="L941">                index += (int) srcX;</span>

<span class="nc" id="L943">                index = swapBGRtoRGB(bgrData, index, rgbData);</span>
<span class="nc" id="L944">                byte[] encodedData = rlEncode(rgbData);</span>
<span class="nc" id="L945">                byte[] asciiData = ascii85Encode(encodedData);</span>
<span class="nc" id="L946">                mPSStream.write(asciiData);</span>
<span class="nc" id="L947">                mPSStream.println(&quot;&quot;);</span>
            }

            /*
             * If there is an IOError we subvert it to a PrinterException.
             * Fix: There has got to be a better way, maybe define
             * a PrinterIOException and then throw that?
             */
<span class="nc" id="L955">        } catch (IOException e) {</span>
            //throw new PrinterException(e.toString());
<span class="nc" id="L957">        }</span>

<span class="nc" id="L959">        mPSStream.println(IMAGE_RESTORE);</span>
<span class="nc" id="L960">    }</span>

    /**
     * Prints the contents of the array of ints, 'data'
     * to the current page. The band is placed at the
     * location (x, y) in device coordinates on the
     * page. The width and height of the band is
     * specified by the caller. Currently the data
     * is 24 bits per pixel in BGR format.
     */
    protected void printBand(byte[] bgrData, int x, int y,
                             int width, int height)
        throws PrinterException
    {

<span class="nc" id="L975">        mPSStream.println(IMAGE_SAVE);</span>

        /* Create a PS string big enough to hold a row of pixels.
         */
<span class="nc" id="L979">        int psBytesPerRow = 3 * width;</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">        while (psBytesPerRow &gt; MAX_PSSTR) {</span>
<span class="nc" id="L981">            psBytesPerRow /= 2;</span>
        }

<span class="nc" id="L984">        mPSStream.println(psBytesPerRow + IMAGE_STR);</span>

        /* Scale and translate the unit image.
         */
<span class="nc" id="L988">        mPSStream.println(&quot;[&quot; + width + &quot; 0 &quot;</span>
                          + &quot;0 &quot; + height
                          + &quot; &quot; + x + &quot; &quot; + y
                          +&quot;]concat&quot;);

        /* Color Image invocation.
         */
<span class="nc" id="L995">        mPSStream.println(width + &quot; &quot; + height + &quot; &quot; + 8 + &quot;[&quot;</span>
                          + width + &quot; 0 &quot;
                          + &quot;0 &quot; + -height
                          + &quot; 0 &quot; + height + &quot;]&quot;
                          + &quot;/imageSrc load false 3 colorimage&quot;);

        /* Image data.
         */
<span class="nc" id="L1003">        int index = 0;</span>
<span class="nc" id="L1004">        byte[] rgbData = new byte[width*3];</span>

        try {
<span class="nc bnc" id="L1007" title="All 2 branches missed.">            for(int i = 0; i &lt; height; i++) {</span>
<span class="nc" id="L1008">                index = swapBGRtoRGB(bgrData, index, rgbData);</span>
<span class="nc" id="L1009">                byte[] encodedData = rlEncode(rgbData);</span>
<span class="nc" id="L1010">                byte[] asciiData = ascii85Encode(encodedData);</span>
<span class="nc" id="L1011">                mPSStream.write(asciiData);</span>
<span class="nc" id="L1012">                mPSStream.println(&quot;&quot;);</span>
            }

<span class="nc" id="L1015">        } catch (IOException e) {</span>
<span class="nc" id="L1016">            throw new PrinterIOException(e);</span>
<span class="nc" id="L1017">        }</span>

<span class="nc" id="L1019">        mPSStream.println(IMAGE_RESTORE);</span>
<span class="nc" id="L1020">    }</span>

    /**
     * Examine the metrics captured by the
     * &lt;code&gt;PeekGraphics&lt;/code&gt; instance and
     * if capable of directly converting this
     * print job to the printer's control language
     * or the native OS's graphics primitives, then
     * return a &lt;code&gt;PSPathGraphics&lt;/code&gt; to perform
     * that conversion. If there is not an object
     * capable of the conversion then return
     * &lt;code&gt;null&lt;/code&gt;. Returning &lt;code&gt;null&lt;/code&gt;
     * causes the print job to be rasterized.
     */

    protected Graphics2D createPathGraphics(PeekGraphics peekGraphics,
                                            PrinterJob printerJob,
                                            Printable painter,
                                            PageFormat pageFormat,
                                            int pageIndex) {

        PSPathGraphics pathGraphics;
<span class="nc" id="L1042">        PeekMetrics metrics = peekGraphics.getMetrics();</span>

        /* If the application has drawn anything that
         * out PathGraphics class can not handle then
         * return a null PathGraphics.
         */
<span class="nc bnc" id="L1048" title="All 4 branches missed.">        if (forcePDL == false &amp;&amp; (forceRaster == true</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                        || metrics.hasNonSolidColors()</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">                        || metrics.hasCompositing())) {</span>

<span class="nc" id="L1052">            pathGraphics = null;</span>
        } else {

<span class="nc" id="L1055">            BufferedImage bufferedImage = new BufferedImage(8, 8,</span>
                                            BufferedImage.TYPE_INT_RGB);
<span class="nc" id="L1057">            Graphics2D bufferedGraphics = bufferedImage.createGraphics();</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">            boolean canRedraw = peekGraphics.getAWTDrawingOnly() == false;</span>

<span class="nc" id="L1060">            pathGraphics =  new PSPathGraphics(bufferedGraphics, printerJob,</span>
                                               painter, pageFormat, pageIndex,
                                               canRedraw);
        }

<span class="nc" id="L1065">        return pathGraphics;</span>
    }

    /**
     * Intersect the gstate's current path with the
     * current clip and make the result the new clip.
     */
    protected void selectClipPath() {

<span class="nc" id="L1074">        mPSStream.println(mClipOpStr);</span>
<span class="nc" id="L1075">    }</span>

    protected void setClip(Shape clip) {

<span class="nc" id="L1079">        mLastClip = clip;</span>
<span class="nc" id="L1080">    }</span>

    protected void setTransform(AffineTransform transform) {
<span class="nc" id="L1083">        mLastTransform = transform;</span>
<span class="nc" id="L1084">    }</span>

    /**
     * Set the current PostScript font.
     * Taken from outFont in PSPrintStream.
     */
     protected boolean setFont(Font font) {
<span class="nc" id="L1091">        mLastFont = font;</span>
<span class="nc" id="L1092">        return true;</span>
    }

    /**
     * Given an array of CharsetStrings that make up a run
     * of text, this routine converts each CharsetString to
     * an index into our PostScript font list. If one or more
     * CharsetStrings can not be represented by a PostScript
     * font, then this routine will return a null array.
     */
     private int[] getPSFontIndexArray(Font font, CharsetString[] charSet) {
<span class="nc" id="L1103">        int[] psFont = null;</span>

<span class="nc bnc" id="L1105" title="All 2 branches missed.">        if (mFontProps != null) {</span>
<span class="nc" id="L1106">            psFont = new int[charSet.length];</span>
        }

<span class="nc bnc" id="L1109" title="All 4 branches missed.">        for (int i = 0; i &lt; charSet.length &amp;&amp; psFont != null; i++){</span>

            /* Get the encoding of the run of text.
             */
<span class="nc" id="L1113">            CharsetString cs = charSet[i];</span>

<span class="nc" id="L1115">            CharsetEncoder fontCS = cs.fontDescriptor.encoder;</span>
<span class="nc" id="L1116">            String charsetName = cs.fontDescriptor.getFontCharsetName();</span>
            /*
             * sun.awt.Symbol perhaps should return &quot;symbol&quot; for encoding.
             * Similarly X11Dingbats should return &quot;dingbats&quot;
             * Forced to check for win32 &amp; x/unix names for these converters.
             */

<span class="nc bnc" id="L1123" title="All 2 branches missed.">            if (&quot;Symbol&quot;.equals(charsetName)) {</span>
<span class="nc" id="L1124">                charsetName = &quot;symbol&quot;;</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            } else if (&quot;WingDings&quot;.equals(charsetName) ||</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">                       &quot;X11Dingbats&quot;.equals(charsetName)) {</span>
<span class="nc" id="L1127">                charsetName = &quot;dingbats&quot;;</span>
            } else {
<span class="nc" id="L1129">                charsetName = makeCharsetName(charsetName, cs.charsetChars);</span>
            }

<span class="nc" id="L1132">            int styleMask = font.getStyle() |</span>
<span class="nc" id="L1133">                FontUtilities.getFont2D(font).getStyle();</span>

<span class="nc" id="L1135">            String style = FontConfiguration.getStyleString(styleMask);</span>

            /* First we map the font name through the properties file.
             * This mapping provides alias names for fonts, for example,
             * &quot;timesroman&quot; is mapped to &quot;serif&quot;.
             */
<span class="nc" id="L1141">            String fontName = font.getFamily().toLowerCase(Locale.ENGLISH);</span>
<span class="nc" id="L1142">            fontName = fontName.replace(' ', '_');</span>
<span class="nc" id="L1143">            String name = mFontProps.getProperty(fontName, &quot;&quot;);</span>

            /* Now map the alias name, character set name, and style
             * to a PostScript name.
             */
<span class="nc" id="L1148">            String psName =</span>
<span class="nc" id="L1149">                mFontProps.getProperty(name + &quot;.&quot; + charsetName + &quot;.&quot; + style,</span>
                                      null);

<span class="nc bnc" id="L1152" title="All 2 branches missed.">            if (psName != null) {</span>

                /* Get the PostScript font index for the PostScript font.
                 */
                try {
<span class="nc" id="L1157">                    psFont[i] =</span>
<span class="nc" id="L1158">                        Integer.parseInt(mFontProps.getProperty(psName));</span>

                /* If there is no PostScript font for this font name,
                 * then we want to termintate the loop and the method
                 * indicating our failure. Setting the array to null
                 * is used to indicate these failures.
                 */
<span class="nc" id="L1165">                } catch(NumberFormatException e){</span>
<span class="nc" id="L1166">                    psFont = null;</span>
<span class="nc" id="L1167">                }</span>

            /* There was no PostScript name for the font, character set,
             * and style so give up.
             */
            } else {
<span class="nc" id="L1173">                psFont = null;</span>
            }
        }

<span class="nc" id="L1177">         return psFont;</span>
     }


    private static String escapeParens(String str) {
<span class="nc bnc" id="L1182" title="All 4 branches missed.">        if (str.indexOf('(') == -1 &amp;&amp; str.indexOf(')') == -1 ) {</span>
<span class="nc" id="L1183">            return str;</span>
        } else {
<span class="nc" id="L1185">            int count = 0;</span>
<span class="nc" id="L1186">            int pos = 0;</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            while ((pos = str.indexOf('(', pos)) != -1) {</span>
<span class="nc" id="L1188">                count++;</span>
<span class="nc" id="L1189">                pos++;</span>
            }
<span class="nc" id="L1191">            pos = 0;</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">            while ((pos = str.indexOf(')', pos)) != -1) {</span>
<span class="nc" id="L1193">                count++;</span>
<span class="nc" id="L1194">                pos++;</span>
            }
<span class="nc" id="L1196">            char []inArr = str.toCharArray();</span>
<span class="nc" id="L1197">            char []outArr = new char[inArr.length+count];</span>
<span class="nc" id="L1198">            pos = 0;</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">            for (int i=0;i&lt;inArr.length;i++) {</span>
<span class="nc bnc" id="L1200" title="All 4 branches missed.">                if (inArr[i] == '(' || inArr[i] == ')') {</span>
<span class="nc" id="L1201">                    outArr[pos++] = '\\';</span>
                }
<span class="nc" id="L1203">                outArr[pos++] = inArr[i];</span>
            }
<span class="nc" id="L1205">            return new String(outArr);</span>

        }
    }

    /* return of 0 means unsupported. Other return indicates the number
     * of distinct PS fonts needed to draw this text. This saves us
     * doing this processing one extra time.
     */
    protected int platformFontCount(Font font, String str) {
<span class="nc bnc" id="L1215" title="All 2 branches missed.">        if (mFontProps == null) {</span>
<span class="nc" id="L1216">            return 0;</span>
        }
<span class="nc" id="L1218">        CharsetString[] acs =</span>
<span class="nc" id="L1219">            ((PlatformFont)(font.getPeer())).makeMultiCharsetString(str,false);</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        if (acs == null) {</span>
            /* AWT can't convert all chars so use 2D path */
<span class="nc" id="L1222">            return 0;</span>
        }
<span class="nc" id="L1224">        int[] psFonts = getPSFontIndexArray(font, acs);</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">        return (psFonts == null) ? 0 : psFonts.length;</span>
    }

     protected boolean textOut(Graphics g, String str, float x, float y,
                               Font mLastFont, FontRenderContext frc,
                               float width) {
<span class="nc" id="L1231">        boolean didText = true;</span>

<span class="nc bnc" id="L1233" title="All 2 branches missed.">        if (mFontProps == null) {</span>
<span class="nc" id="L1234">            return false;</span>
        } else {
<span class="nc" id="L1236">            prepDrawing();</span>

            /* On-screen drawString renders most control chars as the missing
             * glyph and have the non-zero advance of that glyph.
             * Exceptions are \t, \n and \r which are considered zero-width.
             * Postscript handles control chars mostly as a missing glyph.
             * But we use 'ashow' specifying a width for the string which
             * assumes zero-width for those three exceptions, and Postscript
             * tries to squeeze the extra char in, with the result that the
             * glyphs look compressed or even overlap.
             * So exclude those control chars from the string sent to PS.
             */
<span class="nc" id="L1248">            str = removeControlChars(str);</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">            if (str.length() == 0) {</span>
<span class="nc" id="L1250">                return true;</span>
            }
<span class="nc" id="L1252">            CharsetString[] acs =</span>
                ((PlatformFont)
<span class="nc" id="L1254">                 (mLastFont.getPeer())).makeMultiCharsetString(str, false);</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">            if (acs == null) {</span>
                /* AWT can't convert all chars so use 2D path */
<span class="nc" id="L1257">                return false;</span>
            }
            /* Get an array of indices into our PostScript name
             * table. If all of the runs can not be converted
             * to PostScript fonts then null is returned and
             * we'll want to fall back to printing the text
             * as shapes.
             */
<span class="nc" id="L1265">            int[] psFonts = getPSFontIndexArray(mLastFont, acs);</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">            if (psFonts != null) {</span>

<span class="nc bnc" id="L1268" title="All 2 branches missed.">                for (int i = 0; i &lt; acs.length; i++){</span>
<span class="nc" id="L1269">                    CharsetString cs = acs[i];</span>
<span class="nc" id="L1270">                    CharsetEncoder fontCS = cs.fontDescriptor.encoder;</span>

<span class="nc" id="L1272">                    StringBuffer nativeStr = new StringBuffer();</span>
<span class="nc" id="L1273">                    byte[] strSeg = new byte[cs.length * 2];</span>
<span class="nc" id="L1274">                    int len = 0;</span>
                    try {
<span class="nc" id="L1276">                        ByteBuffer bb = ByteBuffer.wrap(strSeg);</span>
<span class="nc" id="L1277">                        fontCS.encode(CharBuffer.wrap(cs.charsetChars,</span>
                                                      cs.offset,
                                                      cs.length),
                                      bb, true);
<span class="nc" id="L1281">                        bb.flip();</span>
<span class="nc" id="L1282">                        len = bb.limit();</span>
<span class="nc" id="L1283">                    } catch(IllegalStateException xx){</span>
<span class="nc" id="L1284">                        continue;</span>
<span class="nc" id="L1285">                    } catch(CoderMalfunctionError xx){</span>
<span class="nc" id="L1286">                        continue;</span>
<span class="nc" id="L1287">                    }</span>
                    /* The width to fit to may either be specified,
                     * or calculated. Specifying by the caller is only
                     * valid if the text does not need to be decomposed
                     * into multiple calls.
                     */
                    float desiredWidth;
<span class="nc bnc" id="L1294" title="All 4 branches missed.">                    if (acs.length == 1 &amp;&amp; width != 0f) {</span>
<span class="nc" id="L1295">                        desiredWidth = width;</span>
                    } else {
<span class="nc" id="L1297">                        Rectangle2D r2d =</span>
<span class="nc" id="L1298">                            mLastFont.getStringBounds(cs.charsetChars,</span>
                                                      cs.offset,
                                                      cs.offset+cs.length,
                                                      frc);
<span class="nc" id="L1302">                        desiredWidth = (float)r2d.getWidth();</span>
                    }
                    /* unprintable chars had width of 0, causing a PS error
                     */
<span class="nc bnc" id="L1306" title="All 2 branches missed.">                    if (desiredWidth == 0) {</span>
<span class="nc" id="L1307">                        return didText;</span>
                    }
<span class="nc" id="L1309">                    nativeStr.append('&lt;');</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">                    for (int j = 0; j &lt; len; j++){</span>
<span class="nc" id="L1311">                        byte b = strSeg[j];</span>
                        // to avoid encoding conversion with println()
<span class="nc" id="L1313">                        String hexS = Integer.toHexString(b);</span>
<span class="nc" id="L1314">                        int length = hexS.length();</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">                        if (length &gt; 2) {</span>
<span class="nc" id="L1316">                            hexS = hexS.substring(length - 2, length);</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">                        } else if (length == 1) {</span>
<span class="nc" id="L1318">                            hexS = &quot;0&quot; + hexS;</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">                        } else if (length == 0) {</span>
<span class="nc" id="L1320">                            hexS = &quot;00&quot;;</span>
                        }
<span class="nc" id="L1322">                        nativeStr.append(hexS);</span>
                    }
<span class="nc" id="L1324">                    nativeStr.append('&gt;');</span>
                    /* This comment costs too much in output file size */
//                  mPSStream.println(&quot;% Font[&quot; + mLastFont.getName() + &quot;, &quot; +
//                             FontConfiguration.getStyleString(mLastFont.getStyle()) + &quot;, &quot;
//                             + mLastFont.getSize2D() + &quot;]&quot;);
<span class="nc" id="L1329">                    getGState().emitPSFont(psFonts[i], mLastFont.getSize2D());</span>

                    // out String
<span class="nc" id="L1332">                    mPSStream.println(nativeStr.toString() + &quot; &quot; +</span>
                                      desiredWidth + &quot; &quot; + x + &quot; &quot; + y + &quot; &quot; +
                                      DrawStringName);
<span class="nc" id="L1335">                    x += desiredWidth;</span>
                }
            } else {
<span class="nc" id="L1338">                didText = false;</span>
            }
        }

<span class="nc" id="L1342">        return didText;</span>
     }
    /**
     * Set the current path rule to be either
     * &lt;code&gt;FILL_EVEN_ODD&lt;/code&gt; (using the
     * even-odd file rule) or &lt;code&gt;FILL_WINDING&lt;/code&gt;
     * (using the non-zero winding rule.)
     */
    protected void setFillMode(int fillRule) {

<span class="nc bnc" id="L1352" title="All 3 branches missed.">        switch (fillRule) {</span>

         case FILL_EVEN_ODD:
<span class="nc" id="L1355">            mFillOpStr = EVEN_ODD_FILL_STR;</span>
<span class="nc" id="L1356">            mClipOpStr = EVEN_ODD_CLIP_STR;</span>
<span class="nc" id="L1357">            break;</span>

         case FILL_WINDING:
<span class="nc" id="L1360">             mFillOpStr = WINDING_FILL_STR;</span>
<span class="nc" id="L1361">             mClipOpStr = WINDING_CLIP_STR;</span>
<span class="nc" id="L1362">             break;</span>

         default:
<span class="nc" id="L1365">             throw new IllegalArgumentException();</span>
        }

<span class="nc" id="L1368">    }</span>

    /**
     * Set the printer's current color to be that
     * defined by &lt;code&gt;color&lt;/code&gt;
     */
    protected void setColor(Color color) {
<span class="nc" id="L1375">        mLastColor = color;</span>
<span class="nc" id="L1376">    }</span>

    /**
     * Fill the current path using the current fill mode
     * and color.
     */
    protected void fillPath() {

<span class="nc" id="L1384">        mPSStream.println(mFillOpStr);</span>
<span class="nc" id="L1385">    }</span>

    /**
     * Called to mark the start of a new path.
     */
    protected void beginPath() {

<span class="nc" id="L1392">        prepDrawing();</span>
<span class="nc" id="L1393">        mPSStream.println(NEWPATH_STR);</span>

<span class="nc" id="L1395">        mPenX = 0;</span>
<span class="nc" id="L1396">        mPenY = 0;</span>
<span class="nc" id="L1397">    }</span>

    /**
     * Close the current subpath by appending a straight
     * line from the current point to the subpath's
     * starting point.
     */
    protected void closeSubpath() {

<span class="nc" id="L1406">        mPSStream.println(CLOSEPATH_STR);</span>

<span class="nc" id="L1408">        mPenX = mStartPathX;</span>
<span class="nc" id="L1409">        mPenY = mStartPathY;</span>
<span class="nc" id="L1410">    }</span>


    /**
     * Generate PostScript to move the current pen
     * position to &lt;code&gt;(x, y)&lt;/code&gt;.
     */
    protected void moveTo(float x, float y) {

<span class="nc" id="L1419">        mPSStream.println(trunc(x) + &quot; &quot; + trunc(y) + MOVETO_STR);</span>

        /* moveto marks the start of a new subpath
         * and we need to remember that starting
         * position so that we know where the
         * pen returns to with a close path.
         */
<span class="nc" id="L1426">        mStartPathX = x;</span>
<span class="nc" id="L1427">        mStartPathY = y;</span>

<span class="nc" id="L1429">        mPenX = x;</span>
<span class="nc" id="L1430">        mPenY = y;</span>
<span class="nc" id="L1431">    }</span>
    /**
     * Generate PostScript to draw a line from the
     * current pen position to &lt;code&gt;(x, y)&lt;/code&gt;.
     */
    protected void lineTo(float x, float y) {

<span class="nc" id="L1438">        mPSStream.println(trunc(x) + &quot; &quot; + trunc(y) + LINETO_STR);</span>

<span class="nc" id="L1440">        mPenX = x;</span>
<span class="nc" id="L1441">        mPenY = y;</span>
<span class="nc" id="L1442">    }</span>

    /**
     * Add to the current path a bezier curve formed
     * by the current pen position and the method parameters
     * which are two control points and an ending
     * point.
     */
    protected void bezierTo(float control1x, float control1y,
                                float control2x, float control2y,
                                float endX, float endY) {

//      mPSStream.println(control1x + &quot; &quot; + control1y
//                        + &quot; &quot; + control2x + &quot; &quot; + control2y
//                        + &quot; &quot; + endX + &quot; &quot; + endY
//                        + CURVETO_STR);
<span class="nc" id="L1458">        mPSStream.println(trunc(control1x) + &quot; &quot; + trunc(control1y)</span>
<span class="nc" id="L1459">                          + &quot; &quot; + trunc(control2x) + &quot; &quot; + trunc(control2y)</span>
<span class="nc" id="L1460">                          + &quot; &quot; + trunc(endX) + &quot; &quot; + trunc(endY)</span>
                          + CURVETO_STR);


<span class="nc" id="L1464">        mPenX = endX;</span>
<span class="nc" id="L1465">        mPenY = endY;</span>
<span class="nc" id="L1466">    }</span>

    String trunc(float f) {
<span class="nc" id="L1469">        float af = Math.abs(f);</span>
<span class="nc bnc" id="L1470" title="All 4 branches missed.">        if (af &gt;= 1f &amp;&amp; af &lt;=1000f) {</span>
<span class="nc" id="L1471">            f = Math.round(f*1000)/1000f;</span>
        }
<span class="nc" id="L1473">        return Float.toString(f);</span>
    }

    /**
     * Return the x coordinate of the pen in the
     * current path.
     */
    protected float getPenX() {

<span class="nc" id="L1482">        return mPenX;</span>
    }
    /**
     * Return the y coordinate of the pen in the
     * current path.
     */
    protected float getPenY() {

<span class="nc" id="L1490">        return mPenY;</span>
    }

    /**
     * Return the x resolution of the coordinates
     * to be rendered.
     */
    protected double getXRes() {
<span class="nc" id="L1498">        return PS_XRES;</span>
    }
    /**
     * Return the y resolution of the coordinates
     * to be rendered.
     */
    protected double getYRes() {
<span class="nc" id="L1505">        return PS_YRES;</span>
    }

    /**
     * For PostScript the origin is in the upper-left of the
     * paper not at the imageable area corner.
     */
    protected double getPhysicalPrintableX(Paper p) {
<span class="nc" id="L1513">        return 0;</span>

    }

    /**
     * For PostScript the origin is in the upper-left of the
     * paper not at the imageable area corner.
     */
    protected double getPhysicalPrintableY(Paper p) {
<span class="nc" id="L1522">        return 0;</span>
    }

    protected double getPhysicalPrintableWidth(Paper p) {
<span class="nc" id="L1526">        return p.getImageableWidth();</span>
    }

    protected double getPhysicalPrintableHeight(Paper p) {
<span class="nc" id="L1530">        return p.getImageableHeight();</span>
    }

    protected double getPhysicalPageWidth(Paper p) {
<span class="nc" id="L1534">        return p.getWidth();</span>
    }

    protected double getPhysicalPageHeight(Paper p) {
<span class="nc" id="L1538">        return p.getHeight();</span>
    }

   /**
     * Returns how many times each page in the book
     * should be consecutively printed by PrintJob.
     * If the printer makes copies itself then this
     * method should return 1.
     */
    protected int getNoncollatedCopies() {
<span class="nc" id="L1548">        return 1;</span>
    }

    protected int getCollatedCopies() {
<span class="nc" id="L1552">        return 1;</span>
    }

    private String[] printExecCmd(String printer, String options,
                                  boolean noJobSheet,
                                  String banner, int copies, String spoolFile) {
<span class="nc" id="L1558">        int PRINTER = 0x1;</span>
<span class="nc" id="L1559">        int OPTIONS = 0x2;</span>
<span class="nc" id="L1560">        int BANNER  = 0x4;</span>
<span class="nc" id="L1561">        int COPIES  = 0x8;</span>
<span class="nc" id="L1562">        int NOSHEET = 0x10;</span>
<span class="nc" id="L1563">        int pFlags = 0;</span>
        String execCmd[];
<span class="nc" id="L1565">        int ncomps = 2; // minimum number of print args</span>
<span class="nc" id="L1566">        int n = 0;</span>

<span class="nc bnc" id="L1568" title="All 6 branches missed.">        if (printer != null &amp;&amp; !printer.equals(&quot;&quot;) &amp;&amp; !printer.equals(&quot;lp&quot;)) {</span>
<span class="nc" id="L1569">            pFlags |= PRINTER;</span>
<span class="nc" id="L1570">            ncomps+=1;</span>
        }
<span class="nc bnc" id="L1572" title="All 4 branches missed.">        if (options != null &amp;&amp; !options.equals(&quot;&quot;)) {</span>
<span class="nc" id="L1573">            pFlags |= OPTIONS;</span>
<span class="nc" id="L1574">            ncomps+=1;</span>
        }
<span class="nc bnc" id="L1576" title="All 4 branches missed.">        if (banner != null &amp;&amp; !banner.equals(&quot;&quot;)) {</span>
<span class="nc" id="L1577">            pFlags |= BANNER;</span>
<span class="nc" id="L1578">            ncomps+=1;</span>
        }
<span class="nc bnc" id="L1580" title="All 2 branches missed.">        if (copies &gt; 1) {</span>
<span class="nc" id="L1581">            pFlags |= COPIES;</span>
<span class="nc" id="L1582">            ncomps+=1;</span>
        }
<span class="nc bnc" id="L1584" title="All 2 branches missed.">        if (noJobSheet) {</span>
<span class="nc" id="L1585">            pFlags |= NOSHEET;</span>
<span class="nc" id="L1586">            ncomps+=1;</span>
        }

<span class="nc" id="L1589">       String osname = System.getProperty(&quot;os.name&quot;);</span>
<span class="nc bnc" id="L1590" title="All 4 branches missed.">       if (osname.equals(&quot;Linux&quot;) || osname.contains(&quot;OS X&quot;)) {</span>
<span class="nc" id="L1591">            execCmd = new String[ncomps];</span>
<span class="nc" id="L1592">            execCmd[n++] = &quot;/usr/bin/lpr&quot;;</span>
<span class="nc bnc" id="L1593" title="All 2 branches missed.">            if ((pFlags &amp; PRINTER) != 0) {</span>
<span class="nc" id="L1594">                execCmd[n++] = &quot;-P&quot; + printer;</span>
            }
<span class="nc bnc" id="L1596" title="All 2 branches missed.">            if ((pFlags &amp; BANNER) != 0) {</span>
<span class="nc" id="L1597">                execCmd[n++] = &quot;-J&quot;  + banner;</span>
            }
<span class="nc bnc" id="L1599" title="All 2 branches missed.">            if ((pFlags &amp; COPIES) != 0) {</span>
<span class="nc" id="L1600">                execCmd[n++] = &quot;-#&quot; + copies;</span>
            }
<span class="nc bnc" id="L1602" title="All 2 branches missed.">            if ((pFlags &amp; NOSHEET) != 0) {</span>
<span class="nc" id="L1603">                execCmd[n++] = &quot;-h&quot;;</span>
            }
<span class="nc bnc" id="L1605" title="All 2 branches missed.">            if ((pFlags &amp; OPTIONS) != 0) {</span>
<span class="nc" id="L1606">                execCmd[n++] = new String(options);</span>
            }
        } else {
<span class="nc" id="L1609">            ncomps+=1; //add 1 arg for lp</span>
<span class="nc" id="L1610">            execCmd = new String[ncomps];</span>
<span class="nc" id="L1611">            execCmd[n++] = &quot;/usr/bin/lp&quot;;</span>
<span class="nc" id="L1612">            execCmd[n++] = &quot;-c&quot;;           // make a copy of the spool file</span>
<span class="nc bnc" id="L1613" title="All 2 branches missed.">            if ((pFlags &amp; PRINTER) != 0) {</span>
<span class="nc" id="L1614">                execCmd[n++] = &quot;-d&quot; + printer;</span>
            }
<span class="nc bnc" id="L1616" title="All 2 branches missed.">            if ((pFlags &amp; BANNER) != 0) {</span>
<span class="nc" id="L1617">                execCmd[n++] = &quot;-t&quot;  + banner;</span>
            }
<span class="nc bnc" id="L1619" title="All 2 branches missed.">            if ((pFlags &amp; COPIES) != 0) {</span>
<span class="nc" id="L1620">                execCmd[n++] = &quot;-n&quot; + copies;</span>
            }
<span class="nc bnc" id="L1622" title="All 2 branches missed.">            if ((pFlags &amp; NOSHEET) != 0) {</span>
<span class="nc" id="L1623">                execCmd[n++] = &quot;-o nobanner&quot;;</span>
            }
<span class="nc bnc" id="L1625" title="All 2 branches missed.">            if ((pFlags &amp; OPTIONS) != 0) {</span>
<span class="nc" id="L1626">                execCmd[n++] = &quot;-o&quot; + options;</span>
            }
        }
<span class="nc" id="L1629">        execCmd[n++] = spoolFile;</span>
<span class="nc" id="L1630">        return execCmd;</span>
    }

    private static int swapBGRtoRGB(byte[] image, int index, byte[] dest) {
<span class="nc" id="L1634">        int destIndex = 0;</span>
<span class="nc bnc" id="L1635" title="All 4 branches missed.">        while(index &lt; image.length-2 &amp;&amp; destIndex &lt; dest.length-2) {</span>
<span class="nc" id="L1636">            dest[destIndex++] = image[index+2];</span>
<span class="nc" id="L1637">            dest[destIndex++] = image[index+1];</span>
<span class="nc" id="L1638">            dest[destIndex++] = image[index+0];</span>
<span class="nc" id="L1639">            index+=3;</span>
        }
<span class="nc" id="L1641">        return index;</span>
    }

    /*
     * Currently CharToByteConverter.getCharacterEncoding() return values are
     * not fixed yet. These are used as the part of the key of
     * psfont.properties. When those name are fixed this routine can
     * be erased.
     */
    private String makeCharsetName(String name, char[] chs) {
<span class="nc bnc" id="L1651" title="All 4 branches missed.">        if (name.equals(&quot;Cp1252&quot;) || name.equals(&quot;ISO8859_1&quot;)) {</span>
<span class="nc" id="L1652">            return &quot;latin1&quot;;</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">        } else if (name.equals(&quot;UTF8&quot;)) {</span>
            // same as latin 1 if all chars &lt; 256
<span class="nc bnc" id="L1655" title="All 2 branches missed.">            for (int i=0; i &lt; chs.length; i++) {</span>
<span class="nc bnc" id="L1656" title="All 2 branches missed.">                if (chs[i] &gt; 255) {</span>
<span class="nc" id="L1657">                    return name.toLowerCase();</span>
                }
            }
<span class="nc" id="L1660">            return &quot;latin1&quot;;</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">        } else if (name.startsWith(&quot;ISO8859&quot;)) {</span>
            // same as latin 1 if all chars &lt; 128
<span class="nc bnc" id="L1663" title="All 2 branches missed.">            for (int i=0; i &lt; chs.length; i++) {</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">                if (chs[i] &gt; 127) {</span>
<span class="nc" id="L1665">                    return name.toLowerCase();</span>
                }
            }
<span class="nc" id="L1668">            return &quot;latin1&quot;;</span>
        } else {
<span class="nc" id="L1670">            return name.toLowerCase();</span>
        }
    }

    private void prepDrawing() {

        /* Pop gstates until we can set the needed clip
         * and transform or until we are at the outer most
         * gstate.
         */
<span class="nc bnc" id="L1680" title="All 2 branches missed.">        while (isOuterGState() == false</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">               &amp;&amp; (getGState().canSetClip(mLastClip) == false</span>
<span class="nc bnc" id="L1682" title="All 2 branches missed.">                   || getGState().mTransform.equals(mLastTransform) == false)) {</span>


<span class="nc" id="L1685">            grestore();</span>
        }

        /* Set the color. This can push the color to the
         * outer most gsave which is often a good thing.
         */
<span class="nc" id="L1691">        getGState().emitPSColor(mLastColor);</span>

        /* We do not want to change the outermost
         * transform or clip so if we are at the
         * outer clip the generate a gsave.
         */
<span class="nc bnc" id="L1697" title="All 2 branches missed.">        if (isOuterGState()) {</span>
<span class="nc" id="L1698">            gsave();</span>
<span class="nc" id="L1699">            getGState().emitTransform(mLastTransform);</span>
<span class="nc" id="L1700">            getGState().emitPSClip(mLastClip);</span>
        }

        /* Set the font if we have been asked to. It is
         * important that the font is set after the
         * transform in order to get the font size
         * correct.
         */
//      if (g != null) {
//          getGState().emitPSFont(g, mLastFont);
//      }

<span class="nc" id="L1712">    }</span>

    /**
     * Return the GState that is currently on top
     * of the GState stack. There should always be
     * a GState on top of the stack. If there isn't
     * then this method will throw an IndexOutOfBounds
     * exception.
     */
    private GState getGState() {
<span class="nc" id="L1722">        int count = mGStateStack.size();</span>
<span class="nc" id="L1723">        return (GState) mGStateStack.get(count - 1);</span>
    }

    /**
     * Emit a PostScript gsave command and add a
     * new GState on to our stack which represents
     * the printer's gstate stack.
     */
    private void gsave() {
<span class="nc" id="L1732">        GState oldGState = getGState();</span>
<span class="nc" id="L1733">        mGStateStack.add(new GState(oldGState));</span>
<span class="nc" id="L1734">        mPSStream.println(GSAVE_STR);</span>
<span class="nc" id="L1735">    }</span>

    /**
     * Emit a PostScript grestore command and remove
     * a GState from our stack which represents the
     * printer's gstate stack.
     */
    private void grestore() {
<span class="nc" id="L1743">        int count = mGStateStack.size();</span>
<span class="nc" id="L1744">        mGStateStack.remove(count - 1);</span>
<span class="nc" id="L1745">        mPSStream.println(GRESTORE_STR);</span>
<span class="nc" id="L1746">    }</span>

    /**
     * Return true if the current GState is the
     * outermost GState and therefore should not
     * be restored.
     */
    private boolean isOuterGState() {
<span class="nc bnc" id="L1754" title="All 2 branches missed.">        return mGStateStack.size() == 1;</span>
    }

    /**
     * A stack of GStates is maintained to model the printer's
     * gstate stack. Each GState holds information about
     * the current graphics attributes.
     */
    private class GState{
        Color mColor;
        Shape mClip;
        Font mFont;
        AffineTransform mTransform;

<span class="nc" id="L1768">        GState() {</span>
<span class="nc" id="L1769">            mColor = Color.black;</span>
<span class="nc" id="L1770">            mClip = null;</span>
<span class="nc" id="L1771">            mFont = null;</span>
<span class="nc" id="L1772">            mTransform = new AffineTransform();</span>
<span class="nc" id="L1773">        }</span>

<span class="nc" id="L1775">        GState(GState copyGState) {</span>
<span class="nc" id="L1776">            mColor = copyGState.mColor;</span>
<span class="nc" id="L1777">            mClip = copyGState.mClip;</span>
<span class="nc" id="L1778">            mFont = copyGState.mFont;</span>
<span class="nc" id="L1779">            mTransform = copyGState.mTransform;</span>
<span class="nc" id="L1780">        }</span>

        boolean canSetClip(Shape clip) {

<span class="nc bnc" id="L1784" title="All 4 branches missed.">            return mClip == null || mClip.equals(clip);</span>
        }


        void emitPSClip(Shape clip) {
<span class="nc bnc" id="L1789" title="All 4 branches missed.">            if (clip != null</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">                &amp;&amp; (mClip == null || mClip.equals(clip) == false)) {</span>
<span class="nc" id="L1791">                String saveFillOp = mFillOpStr;</span>
<span class="nc" id="L1792">                String saveClipOp = mClipOpStr;</span>
<span class="nc" id="L1793">                convertToPSPath(clip.getPathIterator(new AffineTransform()));</span>
<span class="nc" id="L1794">                selectClipPath();</span>
<span class="nc" id="L1795">                mClip = clip;</span>
                /* The clip is a shape and has reset the winding rule state */
<span class="nc" id="L1797">                mClipOpStr = saveFillOp;</span>
<span class="nc" id="L1798">                mFillOpStr = saveFillOp;</span>
            }
<span class="nc" id="L1800">        }</span>

        void emitTransform(AffineTransform transform) {

<span class="nc bnc" id="L1804" title="All 4 branches missed.">            if (transform != null &amp;&amp; transform.equals(mTransform) == false) {</span>
<span class="nc" id="L1805">                double[] matrix = new double[6];</span>
<span class="nc" id="L1806">                transform.getMatrix(matrix);</span>
<span class="nc" id="L1807">                mPSStream.println(&quot;[&quot; + (float)matrix[0]</span>
                                  + &quot; &quot; + (float)matrix[1]
                                  + &quot; &quot; + (float)matrix[2]
                                  + &quot; &quot; + (float)matrix[3]
                                  + &quot; &quot; + (float)matrix[4]
                                  + &quot; &quot; + (float)matrix[5]
                                  + &quot;] concat&quot;);

<span class="nc" id="L1815">                mTransform = transform;</span>
            }
<span class="nc" id="L1817">        }</span>

        void emitPSColor(Color color) {
<span class="nc bnc" id="L1820" title="All 4 branches missed.">            if (color != null &amp;&amp; color.equals(mColor) == false) {</span>
<span class="nc" id="L1821">                float[] rgb = color.getRGBColorComponents(null);</span>

                /* If the color is a gray value then use
                 * setgray.
                 */
<span class="nc bnc" id="L1826" title="All 4 branches missed.">                if (rgb[0] == rgb[1] &amp;&amp; rgb[1] == rgb[2]) {</span>
<span class="nc" id="L1827">                    mPSStream.println(rgb[0] + SETGRAY_STR);</span>

                /* It's not gray so use setrgbcolor.
                 */
                } else {
<span class="nc" id="L1832">                    mPSStream.println(rgb[0] + &quot; &quot;</span>
                                      + rgb[1] + &quot; &quot;
                                      + rgb[2] + &quot; &quot;
                                      + SETRGBCOLOR_STR);
                }

<span class="nc" id="L1838">                mColor = color;</span>

            }
<span class="nc" id="L1841">        }</span>

        void emitPSFont(int psFontIndex, float fontSize) {
<span class="nc" id="L1844">            mPSStream.println(fontSize + &quot; &quot; +</span>
                              psFontIndex + &quot; &quot; + SetFontName);
<span class="nc" id="L1846">        }</span>
    }

       /**
        * Given a Java2D &lt;code&gt;PathIterator&lt;/code&gt; instance,
        * this method translates that into a PostScript path..
        */
        void convertToPSPath(PathIterator pathIter) {

<span class="nc" id="L1855">            float[] segment = new float[6];</span>
            int segmentType;

            /* Map the PathIterator's fill rule into the PostScript
             * fill rule.
             */
            int fillRule;
<span class="nc bnc" id="L1862" title="All 2 branches missed.">            if (pathIter.getWindingRule() == PathIterator.WIND_EVEN_ODD) {</span>
<span class="nc" id="L1863">                fillRule = FILL_EVEN_ODD;</span>
            } else {
<span class="nc" id="L1865">                fillRule = FILL_WINDING;</span>
            }

<span class="nc" id="L1868">            beginPath();</span>

<span class="nc" id="L1870">            setFillMode(fillRule);</span>

<span class="nc bnc" id="L1872" title="All 2 branches missed.">            while (pathIter.isDone() == false) {</span>
<span class="nc" id="L1873">                segmentType = pathIter.currentSegment(segment);</span>

<span class="nc bnc" id="L1875" title="All 6 branches missed.">                switch (segmentType) {</span>
                 case PathIterator.SEG_MOVETO:
<span class="nc" id="L1877">                    moveTo(segment[0], segment[1]);</span>
<span class="nc" id="L1878">                    break;</span>

                 case PathIterator.SEG_LINETO:
<span class="nc" id="L1881">                    lineTo(segment[0], segment[1]);</span>
<span class="nc" id="L1882">                    break;</span>

                /* Convert the quad path to a bezier.
                 */
                 case PathIterator.SEG_QUADTO:
<span class="nc" id="L1887">                    float lastX = getPenX();</span>
<span class="nc" id="L1888">                    float lastY = getPenY();</span>
<span class="nc" id="L1889">                    float c1x = lastX + (segment[0] - lastX) * 2 / 3;</span>
<span class="nc" id="L1890">                    float c1y = lastY + (segment[1] - lastY) * 2 / 3;</span>
<span class="nc" id="L1891">                    float c2x = segment[2] - (segment[2] - segment[0]) * 2/ 3;</span>
<span class="nc" id="L1892">                    float c2y = segment[3] - (segment[3] - segment[1]) * 2/ 3;</span>
<span class="nc" id="L1893">                    bezierTo(c1x, c1y,</span>
                             c2x, c2y,
                             segment[2], segment[3]);
<span class="nc" id="L1896">                    break;</span>

                 case PathIterator.SEG_CUBICTO:
<span class="nc" id="L1899">                    bezierTo(segment[0], segment[1],</span>
                             segment[2], segment[3],
                             segment[4], segment[5]);
<span class="nc" id="L1902">                    break;</span>

                 case PathIterator.SEG_CLOSE:
<span class="nc" id="L1905">                    closeSubpath();</span>
                    break;
                }


<span class="nc" id="L1910">                pathIter.next();</span>
            }
<span class="nc" id="L1912">        }</span>

    /*
     * Fill the path defined by &lt;code&gt;pathIter&lt;/code&gt;
     * with the specified color.
     * The path is provided in current user space.
     */
    protected void deviceFill(PathIterator pathIter, Color color,
                              AffineTransform tx, Shape clip) {

<span class="nc" id="L1922">        setTransform(tx);</span>
<span class="nc" id="L1923">        setClip(clip);</span>
<span class="nc" id="L1924">        setColor(color);</span>
<span class="nc" id="L1925">        convertToPSPath(pathIter);</span>
        /* Specify the path to fill as the clip, this ensures that only
         * pixels which are inside the path will be filled, which is
         * what the Java 2D APIs specify
         */
<span class="nc" id="L1930">        mPSStream.println(GSAVE_STR);</span>
<span class="nc" id="L1931">        selectClipPath();</span>
<span class="nc" id="L1932">        fillPath();</span>
<span class="nc" id="L1933">        mPSStream.println(GRESTORE_STR + &quot; &quot; + NEWPATH_STR);</span>
<span class="nc" id="L1934">    }</span>

    /*
     * Run length encode byte array in a form suitable for decoding
     * by the PS Level 2 filter RunLengthDecode.
     * Array data to encode is inArr. Encoded data is written to outArr
     * outArr must be long enough to hold the encoded data but this
     * can't be known ahead of time.
     * A safe assumption is to use double the length of the input array.
     * This is then copied into a new array of the correct length which
     * is returned.
     * Algorithm:
     * Encoding is a lead byte followed by data bytes.
     * Lead byte of 0-&gt;127 indicates leadByte + 1 distinct bytes follow
     * Lead byte of 129-&gt;255 indicates 257 - leadByte is the number of times
     * the following byte is repeated in the source.
     * 128 is a special lead byte indicating end of data (EOD) and is
     * written as the final byte of the returned encoded data.
     */
     private byte[] rlEncode(byte[] inArr) {

<span class="nc" id="L1955">         int inIndex = 0;</span>
<span class="nc" id="L1956">         int outIndex = 0;</span>
<span class="nc" id="L1957">         int startIndex = 0;</span>
<span class="nc" id="L1958">         int runLen = 0;</span>
<span class="nc" id="L1959">         byte[] outArr = new byte[(inArr.length * 2) +2];</span>
<span class="nc bnc" id="L1960" title="All 2 branches missed.">         while (inIndex &lt; inArr.length) {</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">             if (runLen == 0) {</span>
<span class="nc" id="L1962">                 startIndex = inIndex++;</span>
<span class="nc" id="L1963">                 runLen=1;</span>
             }

<span class="nc bnc" id="L1966" title="All 6 branches missed.">             while (runLen &lt; 128 &amp;&amp; inIndex &lt; inArr.length &amp;&amp;</span>
                    inArr[inIndex] == inArr[startIndex]) {
<span class="nc" id="L1968">                 runLen++; // count run of same value</span>
<span class="nc" id="L1969">                 inIndex++;</span>
             }

<span class="nc bnc" id="L1972" title="All 2 branches missed.">             if (runLen &gt; 1) {</span>
<span class="nc" id="L1973">                 outArr[outIndex++] = (byte)(257 - runLen);</span>
<span class="nc" id="L1974">                 outArr[outIndex++] = inArr[startIndex];</span>
<span class="nc" id="L1975">                 runLen = 0;</span>
<span class="nc" id="L1976">                 continue; // back to top of while loop.</span>
             }

             // if reach here have a run of different values, or at the end.
<span class="nc bnc" id="L1980" title="All 6 branches missed.">             while (runLen &lt; 128 &amp;&amp; inIndex &lt; inArr.length &amp;&amp;</span>
                    inArr[inIndex] != inArr[inIndex-1]) {
<span class="nc" id="L1982">                 runLen++; // count run of different values</span>
<span class="nc" id="L1983">                 inIndex++;</span>
             }
<span class="nc" id="L1985">             outArr[outIndex++] = (byte)(runLen - 1);</span>
<span class="nc bnc" id="L1986" title="All 2 branches missed.">             for (int i = startIndex; i &lt; startIndex+runLen; i++) {</span>
<span class="nc" id="L1987">                 outArr[outIndex++] = inArr[i];</span>
             }
<span class="nc" id="L1989">             runLen = 0;</span>
         }
<span class="nc" id="L1991">         outArr[outIndex++] = (byte)128;</span>
<span class="nc" id="L1992">         byte[] encodedData = new byte[outIndex];</span>
<span class="nc" id="L1993">         System.arraycopy(outArr, 0, encodedData, 0, outIndex);</span>

<span class="nc" id="L1995">         return encodedData;</span>
     }

    /* written acc. to Adobe Spec. &quot;Filtered Files: ASCIIEncode Filter&quot;,
     * &quot;PS Language Reference Manual, 2nd edition: Section 3.13&quot;
     */
    private byte[] ascii85Encode(byte[] inArr) {
<span class="nc" id="L2002">        byte[]  outArr = new byte[((inArr.length+4) * 5 / 4) + 2];</span>
<span class="nc" id="L2003">        long p1 = 85;</span>
<span class="nc" id="L2004">        long p2 = p1*p1;</span>
<span class="nc" id="L2005">        long p3 = p1*p2;</span>
<span class="nc" id="L2006">        long p4 = p1*p3;</span>
<span class="nc" id="L2007">        byte pling = '!';</span>

<span class="nc" id="L2009">        int i = 0;</span>
<span class="nc" id="L2010">        int olen = 0;</span>
        long val, rem;

<span class="nc bnc" id="L2013" title="All 2 branches missed.">        while (i+3 &lt; inArr.length) {</span>
<span class="nc" id="L2014">            val = ((long)((inArr[i++]&amp;0xff))&lt;&lt;24) +</span>
                  ((long)((inArr[i++]&amp;0xff))&lt;&lt;16) +
                  ((long)((inArr[i++]&amp;0xff))&lt;&lt; 8) +
                  ((long)(inArr[i++]&amp;0xff));
<span class="nc bnc" id="L2018" title="All 2 branches missed.">            if (val == 0) {</span>
<span class="nc" id="L2019">                outArr[olen++] = 'z';</span>
            } else {
<span class="nc" id="L2021">                rem = val;</span>
<span class="nc" id="L2022">                outArr[olen++] = (byte)(rem / p4 + pling); rem = rem % p4;</span>
<span class="nc" id="L2023">                outArr[olen++] = (byte)(rem / p3 + pling); rem = rem % p3;</span>
<span class="nc" id="L2024">                outArr[olen++] = (byte)(rem / p2 + pling); rem = rem % p2;</span>
<span class="nc" id="L2025">                outArr[olen++] = (byte)(rem / p1 + pling); rem = rem % p1;</span>
<span class="nc" id="L2026">                outArr[olen++] = (byte)(rem + pling);</span>
            }
        }
        // input not a multiple of 4 bytes, write partial output.
<span class="nc bnc" id="L2030" title="All 2 branches missed.">        if (i &lt; inArr.length) {</span>
<span class="nc" id="L2031">            int n = inArr.length - i; // n bytes remain to be written</span>

<span class="nc" id="L2033">            val = 0;</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">            while (i &lt; inArr.length) {</span>
<span class="nc" id="L2035">                val = (val &lt;&lt; 8) + (inArr[i++]&amp;0xff);</span>
            }

<span class="nc" id="L2038">            int append = 4 - n;</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">            while (append-- &gt; 0) {</span>
<span class="nc" id="L2040">                val = val &lt;&lt; 8;</span>
            }
<span class="nc" id="L2042">            byte []c = new byte[5];</span>
<span class="nc" id="L2043">            rem = val;</span>
<span class="nc" id="L2044">            c[0] = (byte)(rem / p4 + pling); rem = rem % p4;</span>
<span class="nc" id="L2045">            c[1] = (byte)(rem / p3 + pling); rem = rem % p3;</span>
<span class="nc" id="L2046">            c[2] = (byte)(rem / p2 + pling); rem = rem % p2;</span>
<span class="nc" id="L2047">            c[3] = (byte)(rem / p1 + pling); rem = rem % p1;</span>
<span class="nc" id="L2048">            c[4] = (byte)(rem + pling);</span>

<span class="nc bnc" id="L2050" title="All 2 branches missed.">            for (int b = 0; b &lt; n+1 ; b++) {</span>
<span class="nc" id="L2051">                outArr[olen++] = c[b];</span>
            }
        }

        // write EOD marker.
<span class="nc" id="L2056">        outArr[olen++]='~'; outArr[olen++]='&gt;';</span>

        /* The original intention was to insert a newline after every 78 bytes.
         * This was mainly intended for legibility but I decided against this
         * partially because of the (small) amount of extra space, and
         * partially because for line breaks either would have to hardwire
         * ascii 10 (newline) or calculate space in bytes to allocate for
         * the platform's newline byte sequence. Also need to be careful
         * about where its inserted:
         * Ascii 85 decoder ignores white space except for one special case:
         * you must ensure you do not split the EOD marker across lines.
         */
<span class="nc" id="L2068">        byte[] retArr = new byte[olen];</span>
<span class="nc" id="L2069">        System.arraycopy(outArr, 0, retArr, 0, olen);</span>
<span class="nc" id="L2070">        return retArr;</span>

    }

    /**
     * PluginPrinter generates EPSF wrapped with a header and trailer
     * comment. This conforms to the new requirements of Mozilla 1.7
     * and FireFox 1.5 and later. Earlier versions of these browsers
     * did not support plugin printing in the general sense (not just Java).
     * A notable limitation of these browsers is that they handle plugins
     * which would span page boundaries by scaling plugin content to fit on a
     * single page. This means white space is left at the bottom of the
     * previous page and its impossible to print these cases as they appear on
     * the web page. This is contrast to how the same browsers behave on
     * Windows where it renders as on-screen.
     * Cases where the content fits on a single page do work fine, and they
     * are the majority of cases.
     * The scaling that the browser specifies to make the plugin content fit
     * when it is larger than a single page can hold is non-uniform. It
     * scales the axis in which the content is too large just enough to
     * ensure it fits. For content which is extremely long this could lead
     * to noticeable distortion. However that is probably rare enough that
     * its not worth compensating for that here, but we can revisit that if
     * needed, and compensate by making the scale for the other axis the
     * same.
     */
    public static class PluginPrinter implements Printable {

        private EPSPrinter epsPrinter;
        private Component applet;
        private PrintStream stream;
        private String epsTitle;
        private int bx, by, bw, bh;
        private int width, height;

        /**
         * This is called from the Java Plug-in to print an Applet's
         * contents as EPS to a postscript stream provided by the browser.
         * @param applet the applet component to print.
         * @param stream the print stream provided by the plug-in
         * @param x the x location of the applet panel in the browser window
         * @param y the y location of the applet panel in the browser window
         * @param w the width of the applet panel in the browser window
         * @param h the width of the applet panel in the browser window
         */
        public PluginPrinter(Component applet,
                             PrintStream stream,
<span class="nc" id="L2117">                             int x, int y, int w, int h) {</span>

<span class="nc" id="L2119">            this.applet = applet;</span>
<span class="nc" id="L2120">            this.epsTitle = &quot;Java Plugin Applet&quot;;</span>
<span class="nc" id="L2121">            this.stream = stream;</span>
<span class="nc" id="L2122">            bx = x;</span>
<span class="nc" id="L2123">            by = y;</span>
<span class="nc" id="L2124">            bw = w;</span>
<span class="nc" id="L2125">            bh = h;</span>
<span class="nc" id="L2126">            width = applet.size().width;</span>
<span class="nc" id="L2127">            height = applet.size().height;</span>
<span class="nc" id="L2128">            epsPrinter = new EPSPrinter(this, epsTitle, stream,</span>
                                        0, 0, width, height);
<span class="nc" id="L2130">        }</span>

        public void printPluginPSHeader() {
<span class="nc" id="L2133">            stream.println(&quot;%%BeginDocument: JavaPluginApplet&quot;);</span>
<span class="nc" id="L2134">        }</span>

        public void printPluginApplet() {
            try {
<span class="nc" id="L2138">                epsPrinter.print();</span>
<span class="nc" id="L2139">            } catch (PrinterException e) {</span>
<span class="nc" id="L2140">            }</span>
<span class="nc" id="L2141">        }</span>

        public void printPluginPSTrailer() {
<span class="nc" id="L2144">            stream.println(&quot;%%EndDocument: JavaPluginApplet&quot;);</span>
<span class="nc" id="L2145">            stream.flush();</span>
<span class="nc" id="L2146">        }</span>

        public void printAll() {
<span class="nc" id="L2149">            printPluginPSHeader();</span>
<span class="nc" id="L2150">            printPluginApplet();</span>
<span class="nc" id="L2151">            printPluginPSTrailer();</span>
<span class="nc" id="L2152">        }</span>

        public int print(Graphics g, PageFormat pf, int pgIndex) {
<span class="nc bnc" id="L2155" title="All 2 branches missed.">            if (pgIndex &gt; 0) {</span>
<span class="nc" id="L2156">                return Printable.NO_SUCH_PAGE;</span>
            } else {
                // &quot;aware&quot; client code can detect that its been passed a
                // PrinterGraphics and could theoretically print
                // differently. I think this is more likely useful than
                // a problem.
<span class="nc" id="L2162">                applet.printAll(g);</span>
<span class="nc" id="L2163">                return Printable.PAGE_EXISTS;</span>
            }
        }

    }

    /*
     * This class can take an application-client supplied printable object
     * and send the result to a stream.
     * The application does not need to send any postscript to this stream
     * unless it needs to specify a translation etc.
     * It assumes that its importing application obeys all the conventions
     * for importation of EPS. See Appendix H - Encapsulated Postscript File
     * Format - of the Adobe Postscript Language Reference Manual, 2nd edition.
     * This class could be used as the basis for exposing the ability to
     * generate EPSF from 2D graphics as a StreamPrintService.
     * In that case a MediaPrintableArea attribute could be used to
     * communicate the bounding box.
     */
    public static class EPSPrinter implements Pageable {

        private PageFormat pf;
        private PSPrinterJob job;
        private int llx, lly, urx, ury;
        private Printable printable;
        private PrintStream stream;
        private String epsTitle;

        public EPSPrinter(Printable printable, String title,
                          PrintStream stream,
<span class="nc" id="L2193">                          int x, int y, int wid, int hgt) {</span>

<span class="nc" id="L2195">            this.printable = printable;</span>
<span class="nc" id="L2196">            this.epsTitle = title;</span>
<span class="nc" id="L2197">            this.stream = stream;</span>
<span class="nc" id="L2198">            llx = x;</span>
<span class="nc" id="L2199">            lly = y;</span>
<span class="nc" id="L2200">            urx = llx+wid;</span>
<span class="nc" id="L2201">            ury = lly+hgt;</span>
            // construct a PageFormat with zero margins representing the
            // exact bounds of the applet. ie construct a theoretical
            // paper which happens to exactly match applet panel size.
<span class="nc" id="L2205">            Paper p = new Paper();</span>
<span class="nc" id="L2206">            p.setSize((double)wid, (double)hgt);</span>
<span class="nc" id="L2207">            p.setImageableArea(0.0,0.0, (double)wid, (double)hgt);</span>
<span class="nc" id="L2208">            pf = new PageFormat();</span>
<span class="nc" id="L2209">            pf.setPaper(p);</span>
<span class="nc" id="L2210">        }</span>

        public void print() throws PrinterException {
<span class="nc" id="L2213">            stream.println(&quot;%!PS-Adobe-3.0 EPSF-3.0&quot;);</span>
<span class="nc" id="L2214">            stream.println(&quot;%%BoundingBox: &quot; +</span>
                           llx + &quot; &quot; + lly + &quot; &quot; + urx + &quot; &quot; + ury);
<span class="nc" id="L2216">            stream.println(&quot;%%Title: &quot; + epsTitle);</span>
<span class="nc" id="L2217">            stream.println(&quot;%%Creator: Java Printing&quot;);</span>
<span class="nc" id="L2218">            stream.println(&quot;%%CreationDate: &quot; + new java.util.Date());</span>
<span class="nc" id="L2219">            stream.println(&quot;%%EndComments&quot;);</span>
<span class="nc" id="L2220">            stream.println(&quot;/pluginSave save def&quot;);</span>
<span class="nc" id="L2221">            stream.println(&quot;mark&quot;); // for restoring stack state on return</span>

<span class="nc" id="L2223">            job = new PSPrinterJob();</span>
<span class="nc" id="L2224">            job.epsPrinter = this; // modifies the behaviour of PSPrinterJob</span>
<span class="nc" id="L2225">            job.mPSStream = stream;</span>
<span class="nc" id="L2226">            job.mDestType = RasterPrinterJob.STREAM; // prevents closure</span>

<span class="nc" id="L2228">            job.startDoc();</span>
            try {
<span class="nc" id="L2230">                job.printPage(this, 0);</span>
<span class="nc" id="L2231">            } catch (Throwable t) {</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">                if (t instanceof PrinterException) {</span>
<span class="nc" id="L2233">                    throw (PrinterException)t;</span>
                } else {
<span class="nc" id="L2235">                    throw new PrinterException(t.toString());</span>
                }
            } finally {
<span class="nc" id="L2238">                stream.println(&quot;cleartomark&quot;); // restore stack state</span>
<span class="nc" id="L2239">                stream.println(&quot;pluginSave restore&quot;);</span>
<span class="nc" id="L2240">                job.endDoc();</span>
<span class="nc" id="L2241">            }</span>
<span class="nc" id="L2242">            stream.flush();</span>
<span class="nc" id="L2243">        }</span>

        public int getNumberOfPages() {
<span class="nc" id="L2246">            return 1;</span>
        }

        public PageFormat getPageFormat(int pgIndex) {
<span class="nc bnc" id="L2250" title="All 2 branches missed.">            if (pgIndex &gt; 0) {</span>
<span class="nc" id="L2251">                throw new IndexOutOfBoundsException(&quot;pgIndex&quot;);</span>
            } else {
<span class="nc" id="L2253">                return pf;</span>
            }
        }

        public Printable getPrintable(int pgIndex) {
<span class="nc bnc" id="L2258" title="All 2 branches missed.">            if (pgIndex &gt; 0) {</span>
<span class="nc" id="L2259">                throw new IndexOutOfBoundsException(&quot;pgIndex&quot;);</span>
            } else {
<span class="nc" id="L2261">            return printable;</span>
            }
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>