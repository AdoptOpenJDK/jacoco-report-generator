<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PNGImageReader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.imageio.plugins.png</a> &gt; <span class="el_source">PNGImageReader.java</span></div><h1>PNGImageReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.imageio.plugins.png;

import java.awt.Point;
import java.awt.Rectangle;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.image.DataBufferUShort;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.EOFException;
import java.io.InputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.zip.Inflater;
import java.util.zip.InflaterInputStream;
import javax.imageio.IIOException;
import javax.imageio.ImageReader;
import javax.imageio.ImageReadParam;
import javax.imageio.ImageTypeSpecifier;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.spi.ImageReaderSpi;
import javax.imageio.stream.ImageInputStream;
import com.sun.imageio.plugins.common.InputStreamAdapter;
import com.sun.imageio.plugins.common.ReaderUtil;
import com.sun.imageio.plugins.common.SubImageInputStream;
import java.io.ByteArrayOutputStream;
import sun.awt.image.ByteInterleavedRaster;

class PNGImageDataEnumeration implements Enumeration&lt;InputStream&gt; {

<span class="nc" id="L65">    boolean firstTime = true;</span>
    ImageInputStream stream;
    int length;

    public PNGImageDataEnumeration(ImageInputStream stream)
<span class="nc" id="L70">        throws IOException {</span>
<span class="nc" id="L71">        this.stream = stream;</span>
<span class="nc" id="L72">        this.length = stream.readInt();</span>
<span class="nc" id="L73">        int type = stream.readInt(); // skip chunk type</span>
<span class="nc" id="L74">    }</span>

    public InputStream nextElement() {
        try {
<span class="nc" id="L78">            firstTime = false;</span>
<span class="nc" id="L79">            ImageInputStream iis = new SubImageInputStream(stream, length);</span>
<span class="nc" id="L80">            return new InputStreamAdapter(iis);</span>
<span class="nc" id="L81">        } catch (IOException e) {</span>
<span class="nc" id="L82">            return null;</span>
        }
    }

    public boolean hasMoreElements() {
<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (firstTime) {</span>
<span class="nc" id="L88">            return true;</span>
        }

        try {
<span class="nc" id="L92">            int crc = stream.readInt();</span>
<span class="nc" id="L93">            this.length = stream.readInt();</span>
<span class="nc" id="L94">            int type = stream.readInt();</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (type == PNGImageReader.IDAT_TYPE) {</span>
<span class="nc" id="L96">                return true;</span>
            } else {
<span class="nc" id="L98">                return false;</span>
            }
<span class="nc" id="L100">        } catch (IOException e) {</span>
<span class="nc" id="L101">            return false;</span>
        }
    }
}

public class PNGImageReader extends ImageReader {

    /*
     * Note: The following chunk type constants are autogenerated.  Each
     * one is derived from the ASCII values of its 4-character name.  For
     * example, IHDR_TYPE is calculated as follows:
     *            ('I' &lt;&lt; 24) | ('H' &lt;&lt; 16) | ('D' &lt;&lt; 8) | 'R'
     */

    // Critical chunks
    static final int IHDR_TYPE = 0x49484452;
    static final int PLTE_TYPE = 0x504c5445;
    static final int IDAT_TYPE = 0x49444154;
    static final int IEND_TYPE = 0x49454e44;

    // Ancillary chunks
    static final int bKGD_TYPE = 0x624b4744;
    static final int cHRM_TYPE = 0x6348524d;
    static final int gAMA_TYPE = 0x67414d41;
    static final int hIST_TYPE = 0x68495354;
    static final int iCCP_TYPE = 0x69434350;
    static final int iTXt_TYPE = 0x69545874;
    static final int pHYs_TYPE = 0x70485973;
    static final int sBIT_TYPE = 0x73424954;
    static final int sPLT_TYPE = 0x73504c54;
    static final int sRGB_TYPE = 0x73524742;
    static final int tEXt_TYPE = 0x74455874;
    static final int tIME_TYPE = 0x74494d45;
    static final int tRNS_TYPE = 0x74524e53;
    static final int zTXt_TYPE = 0x7a545874;

    static final int PNG_COLOR_GRAY = 0;
    static final int PNG_COLOR_RGB = 2;
    static final int PNG_COLOR_PALETTE = 3;
    static final int PNG_COLOR_GRAY_ALPHA = 4;
    static final int PNG_COLOR_RGB_ALPHA = 6;

    // The number of bands by PNG color type
<span class="nc" id="L144">    static final int[] inputBandsForColorType = {</span>
         1, // gray
        -1, // unused
         3, // rgb
         1, // palette
         2, // gray + alpha
        -1, // unused
         4  // rgb + alpha
    };

    static final int PNG_FILTER_NONE = 0;
    static final int PNG_FILTER_SUB = 1;
    static final int PNG_FILTER_UP = 2;
    static final int PNG_FILTER_AVERAGE = 3;
    static final int PNG_FILTER_PAETH = 4;

<span class="nc" id="L160">    static final int[] adam7XOffset = { 0, 4, 0, 2, 0, 1, 0 };</span>
<span class="nc" id="L161">    static final int[] adam7YOffset = { 0, 0, 4, 0, 2, 0, 1 };</span>
<span class="nc" id="L162">    static final int[] adam7XSubsampling = { 8, 8, 4, 4, 2, 2, 1, 1 };</span>
<span class="nc" id="L163">    static final int[] adam7YSubsampling = { 8, 8, 8, 4, 4, 2, 2, 1 };</span>

    private static final boolean debug = true;

<span class="nc" id="L167">    ImageInputStream stream = null;</span>

<span class="nc" id="L169">    boolean gotHeader = false;</span>
<span class="nc" id="L170">    boolean gotMetadata = false;</span>

<span class="nc" id="L172">    ImageReadParam lastParam = null;</span>

<span class="nc" id="L174">    long imageStartPosition = -1L;</span>

<span class="nc" id="L176">    Rectangle sourceRegion = null;</span>
<span class="nc" id="L177">    int sourceXSubsampling = -1;</span>
<span class="nc" id="L178">    int sourceYSubsampling = -1;</span>
<span class="nc" id="L179">    int sourceMinProgressivePass = 0;</span>
<span class="nc" id="L180">    int sourceMaxProgressivePass = 6;</span>
<span class="nc" id="L181">    int[] sourceBands = null;</span>
<span class="nc" id="L182">    int[] destinationBands = null;</span>
<span class="nc" id="L183">    Point destinationOffset = new Point(0, 0);</span>

<span class="nc" id="L185">    PNGMetadata metadata = new PNGMetadata();</span>

<span class="nc" id="L187">    DataInputStream pixelStream = null;</span>

<span class="nc" id="L189">    BufferedImage theImage = null;</span>

    // The number of source pixels processed
<span class="nc" id="L192">    int pixelsDone = 0;</span>

    // The total number of pixels in the source image
    int totalPixels;

    public PNGImageReader(ImageReaderSpi originatingProvider) {
<span class="nc" id="L198">        super(originatingProvider);</span>
<span class="nc" id="L199">    }</span>

    public void setInput(Object input,
                         boolean seekForwardOnly,
                         boolean ignoreMetadata) {
<span class="nc" id="L204">        super.setInput(input, seekForwardOnly, ignoreMetadata);</span>
<span class="nc" id="L205">        this.stream = (ImageInputStream)input; // Always works</span>

        // Clear all values based on the previous stream contents
<span class="nc" id="L208">        resetStreamSettings();</span>
<span class="nc" id="L209">    }</span>

    private String readNullTerminatedString(String charset, int maxLen) throws IOException {
<span class="nc" id="L212">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
        int b;
<span class="nc" id="L214">        int count = 0;</span>
<span class="nc bnc" id="L215" title="All 4 branches missed.">        while ((maxLen &gt; count++) &amp;&amp; ((b = stream.read()) != 0)) {</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if (b == -1) throw new EOFException();</span>
<span class="nc" id="L217">            baos.write(b);</span>
        }
<span class="nc" id="L219">        return new String(baos.toByteArray(), charset);</span>
    }

    private void readHeader() throws IIOException {
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (gotHeader) {</span>
<span class="nc" id="L224">            return;</span>
        }
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L227">            throw new IllegalStateException(&quot;Input source not set!&quot;);</span>
        }

        try {
<span class="nc" id="L231">            byte[] signature = new byte[8];</span>
<span class="nc" id="L232">            stream.readFully(signature);</span>

<span class="nc bnc" id="L234" title="All 16 branches missed.">            if (signature[0] != (byte)137 ||</span>
                signature[1] != (byte)80 ||
                signature[2] != (byte)78 ||
                signature[3] != (byte)71 ||
                signature[4] != (byte)13 ||
                signature[5] != (byte)10 ||
                signature[6] != (byte)26 ||
                signature[7] != (byte)10) {
<span class="nc" id="L242">                throw new IIOException(&quot;Bad PNG signature!&quot;);</span>
            }

<span class="nc" id="L245">            int IHDR_length = stream.readInt();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (IHDR_length != 13) {</span>
<span class="nc" id="L247">                throw new IIOException(&quot;Bad length for IHDR chunk!&quot;);</span>
            }
<span class="nc" id="L249">            int IHDR_type = stream.readInt();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (IHDR_type != IHDR_TYPE) {</span>
<span class="nc" id="L251">                throw new IIOException(&quot;Bad type for IHDR chunk!&quot;);</span>
            }

<span class="nc" id="L254">            this.metadata = new PNGMetadata();</span>

<span class="nc" id="L256">            int width = stream.readInt();</span>
<span class="nc" id="L257">            int height = stream.readInt();</span>

            // Re-use signature array to bulk-read these unsigned byte values
<span class="nc" id="L260">            stream.readFully(signature, 0, 5);</span>
<span class="nc" id="L261">            int bitDepth          = signature[0] &amp; 0xff;</span>
<span class="nc" id="L262">            int colorType         = signature[1] &amp; 0xff;</span>
<span class="nc" id="L263">            int compressionMethod = signature[2] &amp; 0xff;</span>
<span class="nc" id="L264">            int filterMethod      = signature[3] &amp; 0xff;</span>
<span class="nc" id="L265">            int interlaceMethod   = signature[4] &amp; 0xff;</span>

            // Skip IHDR CRC
<span class="nc" id="L268">            stream.skipBytes(4);</span>

<span class="nc" id="L270">            stream.flushBefore(stream.getStreamPosition());</span>

<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (width == 0) {</span>
<span class="nc" id="L273">                throw new IIOException(&quot;Image width == 0!&quot;);</span>
            }
<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (height == 0) {</span>
<span class="nc" id="L276">                throw new IIOException(&quot;Image height == 0!&quot;);</span>
            }
<span class="nc bnc" id="L278" title="All 10 branches missed.">            if (bitDepth != 1 &amp;&amp; bitDepth != 2 &amp;&amp; bitDepth != 4 &amp;&amp;</span>
                bitDepth != 8 &amp;&amp; bitDepth != 16) {
<span class="nc" id="L280">                throw new IIOException(&quot;Bit depth must be 1, 2, 4, 8, or 16!&quot;);</span>
            }
<span class="nc bnc" id="L282" title="All 10 branches missed.">            if (colorType != 0 &amp;&amp; colorType != 2 &amp;&amp; colorType != 3 &amp;&amp;</span>
                colorType != 4 &amp;&amp; colorType != 6) {
<span class="nc" id="L284">                throw new IIOException(&quot;Color type must be 0, 2, 3, 4, or 6!&quot;);</span>
            }
<span class="nc bnc" id="L286" title="All 4 branches missed.">            if (colorType == PNG_COLOR_PALETTE &amp;&amp; bitDepth == 16) {</span>
<span class="nc" id="L287">                throw new IIOException(&quot;Bad color type/bit depth combination!&quot;);</span>
            }
<span class="nc bnc" id="L289" title="All 10 branches missed.">            if ((colorType == PNG_COLOR_RGB ||</span>
                 colorType == PNG_COLOR_RGB_ALPHA ||
                 colorType == PNG_COLOR_GRAY_ALPHA) &amp;&amp;
                (bitDepth != 8 &amp;&amp; bitDepth != 16)) {
<span class="nc" id="L293">                throw new IIOException(&quot;Bad color type/bit depth combination!&quot;);</span>
            }
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (compressionMethod != 0) {</span>
<span class="nc" id="L296">                throw new IIOException(&quot;Unknown compression method (not 0)!&quot;);</span>
            }
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (filterMethod != 0) {</span>
<span class="nc" id="L299">                throw new IIOException(&quot;Unknown filter method (not 0)!&quot;);</span>
            }
<span class="nc bnc" id="L301" title="All 4 branches missed.">            if (interlaceMethod != 0 &amp;&amp; interlaceMethod != 1) {</span>
<span class="nc" id="L302">                throw new IIOException(&quot;Unknown interlace method (not 0 or 1)!&quot;);</span>
            }

<span class="nc" id="L305">            metadata.IHDR_present = true;</span>
<span class="nc" id="L306">            metadata.IHDR_width = width;</span>
<span class="nc" id="L307">            metadata.IHDR_height = height;</span>
<span class="nc" id="L308">            metadata.IHDR_bitDepth = bitDepth;</span>
<span class="nc" id="L309">            metadata.IHDR_colorType = colorType;</span>
<span class="nc" id="L310">            metadata.IHDR_compressionMethod = compressionMethod;</span>
<span class="nc" id="L311">            metadata.IHDR_filterMethod = filterMethod;</span>
<span class="nc" id="L312">            metadata.IHDR_interlaceMethod = interlaceMethod;</span>
<span class="nc" id="L313">            gotHeader = true;</span>
<span class="nc" id="L314">        } catch (IOException e) {</span>
<span class="nc" id="L315">            throw new IIOException(&quot;I/O error reading PNG header!&quot;, e);</span>
<span class="nc" id="L316">        }</span>
<span class="nc" id="L317">    }</span>

    private void parse_PLTE_chunk(int chunkLength) throws IOException {
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (metadata.PLTE_present) {</span>
<span class="nc" id="L321">            processWarningOccurred(</span>
&quot;A PNG image may not contain more than one PLTE chunk.\n&quot; +
&quot;The chunk wil be ignored.&quot;);
<span class="nc" id="L324">            return;</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">        } else if (metadata.IHDR_colorType == PNG_COLOR_GRAY ||</span>
                   metadata.IHDR_colorType == PNG_COLOR_GRAY_ALPHA) {
<span class="nc" id="L327">            processWarningOccurred(</span>
&quot;A PNG gray or gray alpha image cannot have a PLTE chunk.\n&quot; +
&quot;The chunk wil be ignored.&quot;);
<span class="nc" id="L330">            return;</span>
        }

<span class="nc" id="L333">        byte[] palette = new byte[chunkLength];</span>
<span class="nc" id="L334">        stream.readFully(palette);</span>

<span class="nc" id="L336">        int numEntries = chunkLength/3;</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (metadata.IHDR_colorType == PNG_COLOR_PALETTE) {</span>
<span class="nc" id="L338">            int maxEntries = 1 &lt;&lt; metadata.IHDR_bitDepth;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">            if (numEntries &gt; maxEntries) {</span>
<span class="nc" id="L340">                processWarningOccurred(</span>
&quot;PLTE chunk contains too many entries for bit depth, ignoring extras.&quot;);
<span class="nc" id="L342">                numEntries = maxEntries;</span>
            }
<span class="nc" id="L344">            numEntries = Math.min(numEntries, maxEntries);</span>
        }

        // Round array sizes up to 2^2^n
        int paletteEntries;
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (numEntries &gt; 16) {</span>
<span class="nc" id="L350">            paletteEntries = 256;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">        } else if (numEntries &gt; 4) {</span>
<span class="nc" id="L352">            paletteEntries = 16;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        } else if (numEntries &gt; 2) {</span>
<span class="nc" id="L354">            paletteEntries = 4;</span>
        } else {
<span class="nc" id="L356">            paletteEntries = 2;</span>
        }

<span class="nc" id="L359">        metadata.PLTE_present = true;</span>
<span class="nc" id="L360">        metadata.PLTE_red = new byte[paletteEntries];</span>
<span class="nc" id="L361">        metadata.PLTE_green = new byte[paletteEntries];</span>
<span class="nc" id="L362">        metadata.PLTE_blue = new byte[paletteEntries];</span>

<span class="nc" id="L364">        int index = 0;</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc" id="L366">            metadata.PLTE_red[i] = palette[index++];</span>
<span class="nc" id="L367">            metadata.PLTE_green[i] = palette[index++];</span>
<span class="nc" id="L368">            metadata.PLTE_blue[i] = palette[index++];</span>
        }
<span class="nc" id="L370">    }</span>

    private void parse_bKGD_chunk() throws IOException {
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (metadata.IHDR_colorType == PNG_COLOR_PALETTE) {</span>
<span class="nc" id="L374">            metadata.bKGD_colorType = PNG_COLOR_PALETTE;</span>
<span class="nc" id="L375">            metadata.bKGD_index = stream.readUnsignedByte();</span>
<span class="nc bnc" id="L376" title="All 4 branches missed.">        } else if (metadata.IHDR_colorType == PNG_COLOR_GRAY ||</span>
                   metadata.IHDR_colorType == PNG_COLOR_GRAY_ALPHA) {
<span class="nc" id="L378">            metadata.bKGD_colorType = PNG_COLOR_GRAY;</span>
<span class="nc" id="L379">            metadata.bKGD_gray = stream.readUnsignedShort();</span>
        } else { // RGB or RGB_ALPHA
<span class="nc" id="L381">            metadata.bKGD_colorType = PNG_COLOR_RGB;</span>
<span class="nc" id="L382">            metadata.bKGD_red = stream.readUnsignedShort();</span>
<span class="nc" id="L383">            metadata.bKGD_green = stream.readUnsignedShort();</span>
<span class="nc" id="L384">            metadata.bKGD_blue = stream.readUnsignedShort();</span>
        }

<span class="nc" id="L387">        metadata.bKGD_present = true;</span>
<span class="nc" id="L388">    }</span>

    private void parse_cHRM_chunk() throws IOException {
<span class="nc" id="L391">        metadata.cHRM_whitePointX = stream.readInt();</span>
<span class="nc" id="L392">        metadata.cHRM_whitePointY = stream.readInt();</span>
<span class="nc" id="L393">        metadata.cHRM_redX = stream.readInt();</span>
<span class="nc" id="L394">        metadata.cHRM_redY = stream.readInt();</span>
<span class="nc" id="L395">        metadata.cHRM_greenX = stream.readInt();</span>
<span class="nc" id="L396">        metadata.cHRM_greenY = stream.readInt();</span>
<span class="nc" id="L397">        metadata.cHRM_blueX = stream.readInt();</span>
<span class="nc" id="L398">        metadata.cHRM_blueY = stream.readInt();</span>

<span class="nc" id="L400">        metadata.cHRM_present = true;</span>
<span class="nc" id="L401">    }</span>

    private void parse_gAMA_chunk() throws IOException {
<span class="nc" id="L404">        int gamma = stream.readInt();</span>
<span class="nc" id="L405">        metadata.gAMA_gamma = gamma;</span>

<span class="nc" id="L407">        metadata.gAMA_present = true;</span>
<span class="nc" id="L408">    }</span>

    private void parse_hIST_chunk(int chunkLength) throws IOException,
        IIOException
    {
<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (!metadata.PLTE_present) {</span>
<span class="nc" id="L414">            throw new IIOException(&quot;hIST chunk without prior PLTE chunk!&quot;);</span>
        }

        /* According to PNG specification length of
         * hIST chunk is specified in bytes and
         * hIST chunk consists of 2 byte elements
         * (so we expect length is even).
         */
<span class="nc" id="L422">        metadata.hIST_histogram = new char[chunkLength/2];</span>
<span class="nc" id="L423">        stream.readFully(metadata.hIST_histogram,</span>
                         0, metadata.hIST_histogram.length);

<span class="nc" id="L426">        metadata.hIST_present = true;</span>
<span class="nc" id="L427">    }</span>

    private void parse_iCCP_chunk(int chunkLength) throws IOException {
<span class="nc" id="L430">        String keyword = readNullTerminatedString(&quot;ISO-8859-1&quot;, 80);</span>
<span class="nc" id="L431">        metadata.iCCP_profileName = keyword;</span>

<span class="nc" id="L433">        metadata.iCCP_compressionMethod = stream.readUnsignedByte();</span>

<span class="nc" id="L435">        byte[] compressedProfile =</span>
<span class="nc" id="L436">          new byte[chunkLength - keyword.length() - 2];</span>
<span class="nc" id="L437">        stream.readFully(compressedProfile);</span>
<span class="nc" id="L438">        metadata.iCCP_compressedProfile = compressedProfile;</span>

<span class="nc" id="L440">        metadata.iCCP_present = true;</span>
<span class="nc" id="L441">    }</span>

    private void parse_iTXt_chunk(int chunkLength) throws IOException {
<span class="nc" id="L444">        long chunkStart = stream.getStreamPosition();</span>

<span class="nc" id="L446">        String keyword = readNullTerminatedString(&quot;ISO-8859-1&quot;, 80);</span>
<span class="nc" id="L447">        metadata.iTXt_keyword.add(keyword);</span>

<span class="nc" id="L449">        int compressionFlag = stream.readUnsignedByte();</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">        metadata.iTXt_compressionFlag.add(Boolean.valueOf(compressionFlag == 1));</span>

<span class="nc" id="L452">        int compressionMethod = stream.readUnsignedByte();</span>
<span class="nc" id="L453">        metadata.iTXt_compressionMethod.add(Integer.valueOf(compressionMethod));</span>

<span class="nc" id="L455">        String languageTag = readNullTerminatedString(&quot;UTF8&quot;, 80);</span>
<span class="nc" id="L456">        metadata.iTXt_languageTag.add(languageTag);</span>

<span class="nc" id="L458">        long pos = stream.getStreamPosition();</span>
<span class="nc" id="L459">        int maxLen = (int)(chunkStart + chunkLength - pos);</span>
<span class="nc" id="L460">        String translatedKeyword =</span>
<span class="nc" id="L461">            readNullTerminatedString(&quot;UTF8&quot;, maxLen);</span>
<span class="nc" id="L462">        metadata.iTXt_translatedKeyword.add(translatedKeyword);</span>

        String text;
<span class="nc" id="L465">        pos = stream.getStreamPosition();</span>
<span class="nc" id="L466">        byte[] b = new byte[(int)(chunkStart + chunkLength - pos)];</span>
<span class="nc" id="L467">        stream.readFully(b);</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (compressionFlag == 1) { // Decompress the text</span>
<span class="nc" id="L470">            text = new String(inflate(b), &quot;UTF8&quot;);</span>
        } else {
<span class="nc" id="L472">            text = new String(b, &quot;UTF8&quot;);</span>
        }
<span class="nc" id="L474">        metadata.iTXt_text.add(text);</span>
<span class="nc" id="L475">    }</span>

    private void parse_pHYs_chunk() throws IOException {
<span class="nc" id="L478">        metadata.pHYs_pixelsPerUnitXAxis = stream.readInt();</span>
<span class="nc" id="L479">        metadata.pHYs_pixelsPerUnitYAxis = stream.readInt();</span>
<span class="nc" id="L480">        metadata.pHYs_unitSpecifier = stream.readUnsignedByte();</span>

<span class="nc" id="L482">        metadata.pHYs_present = true;</span>
<span class="nc" id="L483">    }</span>

    private void parse_sBIT_chunk() throws IOException {
<span class="nc" id="L486">        int colorType = metadata.IHDR_colorType;</span>
<span class="nc bnc" id="L487" title="All 4 branches missed.">        if (colorType == PNG_COLOR_GRAY ||</span>
            colorType == PNG_COLOR_GRAY_ALPHA) {
<span class="nc" id="L489">            metadata.sBIT_grayBits = stream.readUnsignedByte();</span>
<span class="nc bnc" id="L490" title="All 6 branches missed.">        } else if (colorType == PNG_COLOR_RGB ||</span>
                   colorType == PNG_COLOR_PALETTE ||
                   colorType == PNG_COLOR_RGB_ALPHA) {
<span class="nc" id="L493">            metadata.sBIT_redBits = stream.readUnsignedByte();</span>
<span class="nc" id="L494">            metadata.sBIT_greenBits = stream.readUnsignedByte();</span>
<span class="nc" id="L495">            metadata.sBIT_blueBits = stream.readUnsignedByte();</span>
        }

<span class="nc bnc" id="L498" title="All 4 branches missed.">        if (colorType == PNG_COLOR_GRAY_ALPHA ||</span>
            colorType == PNG_COLOR_RGB_ALPHA) {
<span class="nc" id="L500">            metadata.sBIT_alphaBits = stream.readUnsignedByte();</span>
        }

<span class="nc" id="L503">        metadata.sBIT_colorType = colorType;</span>
<span class="nc" id="L504">        metadata.sBIT_present = true;</span>
<span class="nc" id="L505">    }</span>

    private void parse_sPLT_chunk(int chunkLength)
        throws IOException, IIOException {
<span class="nc" id="L509">        metadata.sPLT_paletteName = readNullTerminatedString(&quot;ISO-8859-1&quot;, 80);</span>
<span class="nc" id="L510">        chunkLength -= metadata.sPLT_paletteName.length() + 1;</span>

<span class="nc" id="L512">        int sampleDepth = stream.readUnsignedByte();</span>
<span class="nc" id="L513">        metadata.sPLT_sampleDepth = sampleDepth;</span>

<span class="nc" id="L515">        int numEntries = chunkLength/(4*(sampleDepth/8) + 2);</span>
<span class="nc" id="L516">        metadata.sPLT_red = new int[numEntries];</span>
<span class="nc" id="L517">        metadata.sPLT_green = new int[numEntries];</span>
<span class="nc" id="L518">        metadata.sPLT_blue = new int[numEntries];</span>
<span class="nc" id="L519">        metadata.sPLT_alpha = new int[numEntries];</span>
<span class="nc" id="L520">        metadata.sPLT_frequency = new int[numEntries];</span>

<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (sampleDepth == 8) {</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">            for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc" id="L524">                metadata.sPLT_red[i] = stream.readUnsignedByte();</span>
<span class="nc" id="L525">                metadata.sPLT_green[i] = stream.readUnsignedByte();</span>
<span class="nc" id="L526">                metadata.sPLT_blue[i] = stream.readUnsignedByte();</span>
<span class="nc" id="L527">                metadata.sPLT_alpha[i] = stream.readUnsignedByte();</span>
<span class="nc" id="L528">                metadata.sPLT_frequency[i] = stream.readUnsignedShort();</span>
            }
<span class="nc bnc" id="L530" title="All 2 branches missed.">        } else if (sampleDepth == 16) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">            for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc" id="L532">                metadata.sPLT_red[i] = stream.readUnsignedShort();</span>
<span class="nc" id="L533">                metadata.sPLT_green[i] = stream.readUnsignedShort();</span>
<span class="nc" id="L534">                metadata.sPLT_blue[i] = stream.readUnsignedShort();</span>
<span class="nc" id="L535">                metadata.sPLT_alpha[i] = stream.readUnsignedShort();</span>
<span class="nc" id="L536">                metadata.sPLT_frequency[i] = stream.readUnsignedShort();</span>
            }
        } else {
<span class="nc" id="L539">            throw new IIOException(&quot;sPLT sample depth not 8 or 16!&quot;);</span>
        }

<span class="nc" id="L542">        metadata.sPLT_present = true;</span>
<span class="nc" id="L543">    }</span>

    private void parse_sRGB_chunk() throws IOException {
<span class="nc" id="L546">        metadata.sRGB_renderingIntent = stream.readUnsignedByte();</span>

<span class="nc" id="L548">        metadata.sRGB_present = true;</span>
<span class="nc" id="L549">    }</span>

    private void parse_tEXt_chunk(int chunkLength) throws IOException {
<span class="nc" id="L552">        String keyword = readNullTerminatedString(&quot;ISO-8859-1&quot;, 80);</span>
<span class="nc" id="L553">        metadata.tEXt_keyword.add(keyword);</span>

<span class="nc" id="L555">        byte[] b = new byte[chunkLength - keyword.length() - 1];</span>
<span class="nc" id="L556">        stream.readFully(b);</span>
<span class="nc" id="L557">        metadata.tEXt_text.add(new String(b, &quot;ISO-8859-1&quot;));</span>
<span class="nc" id="L558">    }</span>

    private void parse_tIME_chunk() throws IOException {
<span class="nc" id="L561">        metadata.tIME_year = stream.readUnsignedShort();</span>
<span class="nc" id="L562">        metadata.tIME_month = stream.readUnsignedByte();</span>
<span class="nc" id="L563">        metadata.tIME_day = stream.readUnsignedByte();</span>
<span class="nc" id="L564">        metadata.tIME_hour = stream.readUnsignedByte();</span>
<span class="nc" id="L565">        metadata.tIME_minute = stream.readUnsignedByte();</span>
<span class="nc" id="L566">        metadata.tIME_second = stream.readUnsignedByte();</span>

<span class="nc" id="L568">        metadata.tIME_present = true;</span>
<span class="nc" id="L569">    }</span>

    private void parse_tRNS_chunk(int chunkLength) throws IOException {
<span class="nc" id="L572">        int colorType = metadata.IHDR_colorType;</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">        if (colorType == PNG_COLOR_PALETTE) {</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (!metadata.PLTE_present) {</span>
<span class="nc" id="L575">                processWarningOccurred(</span>
&quot;tRNS chunk without prior PLTE chunk, ignoring it.&quot;);
<span class="nc" id="L577">                return;</span>
            }

            // Alpha table may have fewer entries than RGB palette
<span class="nc" id="L581">            int maxEntries = metadata.PLTE_red.length;</span>
<span class="nc" id="L582">            int numEntries = chunkLength;</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (numEntries &gt; maxEntries) {</span>
<span class="nc" id="L584">                processWarningOccurred(</span>
&quot;tRNS chunk has more entries than prior PLTE chunk, ignoring extras.&quot;);
<span class="nc" id="L586">                numEntries = maxEntries;</span>
            }
<span class="nc" id="L588">            metadata.tRNS_alpha = new byte[numEntries];</span>
<span class="nc" id="L589">            metadata.tRNS_colorType = PNG_COLOR_PALETTE;</span>
<span class="nc" id="L590">            stream.read(metadata.tRNS_alpha, 0, numEntries);</span>
<span class="nc" id="L591">            stream.skipBytes(chunkLength - numEntries);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">        } else if (colorType == PNG_COLOR_GRAY) {</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">            if (chunkLength != 2) {</span>
<span class="nc" id="L594">                processWarningOccurred(</span>
&quot;tRNS chunk for gray image must have length 2, ignoring chunk.&quot;);
<span class="nc" id="L596">                stream.skipBytes(chunkLength);</span>
<span class="nc" id="L597">                return;</span>
            }
<span class="nc" id="L599">            metadata.tRNS_gray = stream.readUnsignedShort();</span>
<span class="nc" id="L600">            metadata.tRNS_colorType = PNG_COLOR_GRAY;</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">        } else if (colorType == PNG_COLOR_RGB) {</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">            if (chunkLength != 6) {</span>
<span class="nc" id="L603">                processWarningOccurred(</span>
&quot;tRNS chunk for RGB image must have length 6, ignoring chunk.&quot;);
<span class="nc" id="L605">                stream.skipBytes(chunkLength);</span>
<span class="nc" id="L606">                return;</span>
            }
<span class="nc" id="L608">            metadata.tRNS_red = stream.readUnsignedShort();</span>
<span class="nc" id="L609">            metadata.tRNS_green = stream.readUnsignedShort();</span>
<span class="nc" id="L610">            metadata.tRNS_blue = stream.readUnsignedShort();</span>
<span class="nc" id="L611">            metadata.tRNS_colorType = PNG_COLOR_RGB;</span>
        } else {
<span class="nc" id="L613">            processWarningOccurred(</span>
&quot;Gray+Alpha and RGBS images may not have a tRNS chunk, ignoring it.&quot;);
<span class="nc" id="L615">            return;</span>
        }

<span class="nc" id="L618">        metadata.tRNS_present = true;</span>
<span class="nc" id="L619">    }</span>

    private static byte[] inflate(byte[] b) throws IOException {
<span class="nc" id="L622">        InputStream bais = new ByteArrayInputStream(b);</span>
<span class="nc" id="L623">        InputStream iis = new InflaterInputStream(bais);</span>
<span class="nc" id="L624">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>

        int c;
        try {
<span class="nc bnc" id="L628" title="All 2 branches missed.">            while ((c = iis.read()) != -1) {</span>
<span class="nc" id="L629">                baos.write(c);</span>
            }
        } finally {
<span class="nc" id="L632">            iis.close();</span>
<span class="nc" id="L633">        }</span>
<span class="nc" id="L634">        return baos.toByteArray();</span>
    }

    private void parse_zTXt_chunk(int chunkLength) throws IOException {
<span class="nc" id="L638">        String keyword = readNullTerminatedString(&quot;ISO-8859-1&quot;, 80);</span>
<span class="nc" id="L639">        metadata.zTXt_keyword.add(keyword);</span>

<span class="nc" id="L641">        int method = stream.readUnsignedByte();</span>
<span class="nc" id="L642">        metadata.zTXt_compressionMethod.add(new Integer(method));</span>

<span class="nc" id="L644">        byte[] b = new byte[chunkLength - keyword.length() - 2];</span>
<span class="nc" id="L645">        stream.readFully(b);</span>
<span class="nc" id="L646">        metadata.zTXt_text.add(new String(inflate(b), &quot;ISO-8859-1&quot;));</span>
<span class="nc" id="L647">    }</span>

    private void readMetadata() throws IIOException {
<span class="nc bnc" id="L650" title="All 2 branches missed.">        if (gotMetadata) {</span>
<span class="nc" id="L651">            return;</span>
        }

<span class="nc" id="L654">        readHeader();</span>

        /*
         * Optimization: We can skip the remaining metadata if the
         * ignoreMetadata flag is set, and only if this is not a palette
         * image (in that case, we need to read the metadata to get the
         * tRNS chunk, which is needed for the getImageTypes() method).
         */
<span class="nc" id="L662">        int colorType = metadata.IHDR_colorType;</span>
<span class="nc bnc" id="L663" title="All 4 branches missed.">        if (ignoreMetadata &amp;&amp; colorType != PNG_COLOR_PALETTE) {</span>
            try {
                while (true) {
<span class="nc" id="L666">                    int chunkLength = stream.readInt();</span>
<span class="nc" id="L667">                    int chunkType = stream.readInt();</span>

<span class="nc bnc" id="L669" title="All 2 branches missed.">                    if (chunkType == IDAT_TYPE) {</span>
                        // We've reached the image data
<span class="nc" id="L671">                        stream.skipBytes(-8);</span>
<span class="nc" id="L672">                        imageStartPosition = stream.getStreamPosition();</span>
<span class="nc" id="L673">                        break;</span>
                    } else {
                        // Skip the chunk plus the 4 CRC bytes that follow
<span class="nc" id="L676">                        stream.skipBytes(chunkLength + 4);</span>
                    }
<span class="nc" id="L678">                }</span>
<span class="nc" id="L679">            } catch (IOException e) {</span>
<span class="nc" id="L680">                throw new IIOException(&quot;Error skipping PNG metadata&quot;, e);</span>
<span class="nc" id="L681">            }</span>

<span class="nc" id="L683">            gotMetadata = true;</span>
<span class="nc" id="L684">            return;</span>
        }

        try {
            loop: while (true) {
<span class="nc" id="L689">                int chunkLength = stream.readInt();</span>
<span class="nc" id="L690">                int chunkType = stream.readInt();</span>
                int chunkCRC;

                // verify the chunk length
<span class="nc bnc" id="L694" title="All 2 branches missed.">                if (chunkLength &lt; 0) {</span>
<span class="nc" id="L695">                    throw new IIOException(&quot;Invalid chunk lenght &quot; + chunkLength);</span>
                };

                try {
<span class="nc" id="L699">                    stream.mark();</span>
<span class="nc" id="L700">                    stream.seek(stream.getStreamPosition() + chunkLength);</span>
<span class="nc" id="L701">                    chunkCRC = stream.readInt();</span>
<span class="nc" id="L702">                    stream.reset();</span>
<span class="nc" id="L703">                } catch (IOException e) {</span>
<span class="nc" id="L704">                    throw new IIOException(&quot;Invalid chunk length &quot; + chunkLength);</span>
<span class="nc" id="L705">                }</span>

<span class="nc bnc" id="L707" title="All 17 branches missed.">                switch (chunkType) {</span>
                case IDAT_TYPE:
                    // If chunk type is 'IDAT', we've reached the image data.
<span class="nc" id="L710">                    stream.skipBytes(-8);</span>
<span class="nc" id="L711">                    imageStartPosition = stream.getStreamPosition();</span>
<span class="nc" id="L712">                    break loop;</span>
                case PLTE_TYPE:
<span class="nc" id="L714">                    parse_PLTE_chunk(chunkLength);</span>
<span class="nc" id="L715">                    break;</span>
                case bKGD_TYPE:
<span class="nc" id="L717">                    parse_bKGD_chunk();</span>
<span class="nc" id="L718">                    break;</span>
                case cHRM_TYPE:
<span class="nc" id="L720">                    parse_cHRM_chunk();</span>
<span class="nc" id="L721">                    break;</span>
                case gAMA_TYPE:
<span class="nc" id="L723">                    parse_gAMA_chunk();</span>
<span class="nc" id="L724">                    break;</span>
                case hIST_TYPE:
<span class="nc" id="L726">                    parse_hIST_chunk(chunkLength);</span>
<span class="nc" id="L727">                    break;</span>
                case iCCP_TYPE:
<span class="nc" id="L729">                    parse_iCCP_chunk(chunkLength);</span>
<span class="nc" id="L730">                    break;</span>
                case iTXt_TYPE:
<span class="nc" id="L732">                    parse_iTXt_chunk(chunkLength);</span>
<span class="nc" id="L733">                    break;</span>
                case pHYs_TYPE:
<span class="nc" id="L735">                    parse_pHYs_chunk();</span>
<span class="nc" id="L736">                    break;</span>
                case sBIT_TYPE:
<span class="nc" id="L738">                    parse_sBIT_chunk();</span>
<span class="nc" id="L739">                    break;</span>
                case sPLT_TYPE:
<span class="nc" id="L741">                    parse_sPLT_chunk(chunkLength);</span>
<span class="nc" id="L742">                    break;</span>
                case sRGB_TYPE:
<span class="nc" id="L744">                    parse_sRGB_chunk();</span>
<span class="nc" id="L745">                    break;</span>
                case tEXt_TYPE:
<span class="nc" id="L747">                    parse_tEXt_chunk(chunkLength);</span>
<span class="nc" id="L748">                    break;</span>
                case tIME_TYPE:
<span class="nc" id="L750">                    parse_tIME_chunk();</span>
<span class="nc" id="L751">                    break;</span>
                case tRNS_TYPE:
<span class="nc" id="L753">                    parse_tRNS_chunk(chunkLength);</span>
<span class="nc" id="L754">                    break;</span>
                case zTXt_TYPE:
<span class="nc" id="L756">                    parse_zTXt_chunk(chunkLength);</span>
<span class="nc" id="L757">                    break;</span>
                default:
                    // Read an unknown chunk
<span class="nc" id="L760">                    byte[] b = new byte[chunkLength];</span>
<span class="nc" id="L761">                    stream.readFully(b);</span>

<span class="nc" id="L763">                    StringBuilder chunkName = new StringBuilder(4);</span>
<span class="nc" id="L764">                    chunkName.append((char)(chunkType &gt;&gt;&gt; 24));</span>
<span class="nc" id="L765">                    chunkName.append((char)((chunkType &gt;&gt; 16) &amp; 0xff));</span>
<span class="nc" id="L766">                    chunkName.append((char)((chunkType &gt;&gt; 8) &amp; 0xff));</span>
<span class="nc" id="L767">                    chunkName.append((char)(chunkType &amp; 0xff));</span>

<span class="nc" id="L769">                    int ancillaryBit = chunkType &gt;&gt;&gt; 28;</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">                    if (ancillaryBit == 0) {</span>
<span class="nc" id="L771">                        processWarningOccurred(</span>
&quot;Encountered unknown chunk with critical bit set!&quot;);
                    }

<span class="nc" id="L775">                    metadata.unknownChunkType.add(chunkName.toString());</span>
<span class="nc" id="L776">                    metadata.unknownChunkData.add(b);</span>
                    break;
                }

                // double check whether all chunk data were consumed
<span class="nc bnc" id="L781" title="All 2 branches missed.">                if (chunkCRC != stream.readInt()) {</span>
<span class="nc" id="L782">                    throw new IIOException(&quot;Failed to read a chunk of type &quot; +</span>
                            chunkType);
                }
<span class="nc" id="L785">                stream.flushBefore(stream.getStreamPosition());</span>
<span class="nc" id="L786">            }</span>
<span class="nc" id="L787">        } catch (IOException e) {</span>
<span class="nc" id="L788">            throw new IIOException(&quot;Error reading PNG metadata&quot;, e);</span>
<span class="nc" id="L789">        }</span>

<span class="nc" id="L791">        gotMetadata = true;</span>
<span class="nc" id="L792">    }</span>

    // Data filtering methods

    private static void decodeSubFilter(byte[] curr, int coff, int count,
                                        int bpp) {
<span class="nc bnc" id="L798" title="All 2 branches missed.">        for (int i = bpp; i &lt; count; i++) {</span>
            int val;

<span class="nc" id="L801">            val = curr[i + coff] &amp; 0xff;</span>
<span class="nc" id="L802">            val += curr[i + coff - bpp] &amp; 0xff;</span>

<span class="nc" id="L804">            curr[i + coff] = (byte)val;</span>
        }
<span class="nc" id="L806">    }</span>

    private static void decodeUpFilter(byte[] curr, int coff,
                                       byte[] prev, int poff,
                                       int count) {
<span class="nc bnc" id="L811" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L812">            int raw = curr[i + coff] &amp; 0xff;</span>
<span class="nc" id="L813">            int prior = prev[i + poff] &amp; 0xff;</span>

<span class="nc" id="L815">            curr[i + coff] = (byte)(raw + prior);</span>
        }
<span class="nc" id="L817">    }</span>

    private static void decodeAverageFilter(byte[] curr, int coff,
                                            byte[] prev, int poff,
                                            int count, int bpp) {
        int raw, priorPixel, priorRow;

<span class="nc bnc" id="L824" title="All 2 branches missed.">        for (int i = 0; i &lt; bpp; i++) {</span>
<span class="nc" id="L825">            raw = curr[i + coff] &amp; 0xff;</span>
<span class="nc" id="L826">            priorRow = prev[i + poff] &amp; 0xff;</span>

<span class="nc" id="L828">            curr[i + coff] = (byte)(raw + priorRow/2);</span>
        }

<span class="nc bnc" id="L831" title="All 2 branches missed.">        for (int i = bpp; i &lt; count; i++) {</span>
<span class="nc" id="L832">            raw = curr[i + coff] &amp; 0xff;</span>
<span class="nc" id="L833">            priorPixel = curr[i + coff - bpp] &amp; 0xff;</span>
<span class="nc" id="L834">            priorRow = prev[i + poff] &amp; 0xff;</span>

<span class="nc" id="L836">            curr[i + coff] = (byte)(raw + (priorPixel + priorRow)/2);</span>
        }
<span class="nc" id="L838">    }</span>

    private static int paethPredictor(int a, int b, int c) {
<span class="nc" id="L841">        int p = a + b - c;</span>
<span class="nc" id="L842">        int pa = Math.abs(p - a);</span>
<span class="nc" id="L843">        int pb = Math.abs(p - b);</span>
<span class="nc" id="L844">        int pc = Math.abs(p - c);</span>

<span class="nc bnc" id="L846" title="All 4 branches missed.">        if ((pa &lt;= pb) &amp;&amp; (pa &lt;= pc)) {</span>
<span class="nc" id="L847">            return a;</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">        } else if (pb &lt;= pc) {</span>
<span class="nc" id="L849">            return b;</span>
        } else {
<span class="nc" id="L851">            return c;</span>
        }
    }

    private static void decodePaethFilter(byte[] curr, int coff,
                                          byte[] prev, int poff,
                                          int count, int bpp) {
        int raw, priorPixel, priorRow, priorRowPixel;

<span class="nc bnc" id="L860" title="All 2 branches missed.">        for (int i = 0; i &lt; bpp; i++) {</span>
<span class="nc" id="L861">            raw = curr[i + coff] &amp; 0xff;</span>
<span class="nc" id="L862">            priorRow = prev[i + poff] &amp; 0xff;</span>

<span class="nc" id="L864">            curr[i + coff] = (byte)(raw + priorRow);</span>
        }

<span class="nc bnc" id="L867" title="All 2 branches missed.">        for (int i = bpp; i &lt; count; i++) {</span>
<span class="nc" id="L868">            raw = curr[i + coff] &amp; 0xff;</span>
<span class="nc" id="L869">            priorPixel = curr[i + coff - bpp] &amp; 0xff;</span>
<span class="nc" id="L870">            priorRow = prev[i + poff] &amp; 0xff;</span>
<span class="nc" id="L871">            priorRowPixel = prev[i + poff - bpp] &amp; 0xff;</span>

<span class="nc" id="L873">            curr[i + coff] = (byte)(raw + paethPredictor(priorPixel,</span>
                                                         priorRow,
                                                         priorRowPixel));
        }
<span class="nc" id="L877">    }</span>

<span class="nc" id="L879">    private static final int[][] bandOffsets = {</span>
        null,
        { 0 }, // G
        { 0, 1 }, // GA in GA order
        { 0, 1, 2 }, // RGB in RGB order
        { 0, 1, 2, 3 } // RGBA in RGBA order
    };

    private WritableRaster createRaster(int width, int height, int bands,
                                        int scanlineStride,
                                        int bitDepth) {

        DataBuffer dataBuffer;
<span class="nc" id="L892">        WritableRaster ras = null;</span>
<span class="nc" id="L893">        Point origin = new Point(0, 0);</span>
<span class="nc bnc" id="L894" title="All 4 branches missed.">        if ((bitDepth &lt; 8) &amp;&amp; (bands == 1)) {</span>
<span class="nc" id="L895">            dataBuffer = new DataBufferByte(height*scanlineStride);</span>
<span class="nc" id="L896">            ras = Raster.createPackedRaster(dataBuffer,</span>
                                            width, height,
                                            bitDepth,
                                            origin);
<span class="nc bnc" id="L900" title="All 2 branches missed.">        } else if (bitDepth &lt;= 8) {</span>
<span class="nc" id="L901">            dataBuffer = new DataBufferByte(height*scanlineStride);</span>
<span class="nc" id="L902">            ras = Raster.createInterleavedRaster(dataBuffer,</span>
                                                 width, height,
                                                 scanlineStride,
                                                 bands,
                                                 bandOffsets[bands],
                                                 origin);
        } else {
<span class="nc" id="L909">            dataBuffer = new DataBufferUShort(height*scanlineStride);</span>
<span class="nc" id="L910">            ras = Raster.createInterleavedRaster(dataBuffer,</span>
                                                 width, height,
                                                 scanlineStride,
                                                 bands,
                                                 bandOffsets[bands],
                                                 origin);
        }

<span class="nc" id="L918">        return ras;</span>
    }

    private void skipPass(int passWidth, int passHeight)
        throws IOException, IIOException  {
<span class="nc bnc" id="L923" title="All 4 branches missed.">        if ((passWidth == 0) || (passHeight == 0)) {</span>
<span class="nc" id="L924">            return;</span>
        }

<span class="nc" id="L927">        int inputBands = inputBandsForColorType[metadata.IHDR_colorType];</span>
<span class="nc" id="L928">        int bytesPerRow = (inputBands*passWidth*metadata.IHDR_bitDepth + 7)/8;</span>

        // Read the image row-by-row
<span class="nc bnc" id="L931" title="All 2 branches missed.">        for (int srcY = 0; srcY &lt; passHeight; srcY++) {</span>
            // Skip filter byte and the remaining row bytes
<span class="nc" id="L933">            pixelStream.skipBytes(1 + bytesPerRow);</span>

            // If read has been aborted, just return
            // processReadAborted will be called later
<span class="nc bnc" id="L937" title="All 2 branches missed.">            if (abortRequested()) {</span>
<span class="nc" id="L938">                return;</span>
            }
        }
<span class="nc" id="L941">    }</span>

    private void updateImageProgress(int newPixels) {
<span class="nc" id="L944">        pixelsDone += newPixels;</span>
<span class="nc" id="L945">        processImageProgress(100.0F*pixelsDone/totalPixels);</span>
<span class="nc" id="L946">    }</span>

    private void decodePass(int passNum,
                            int xStart, int yStart,
                            int xStep, int yStep,
                            int passWidth, int passHeight) throws IOException {

<span class="nc bnc" id="L953" title="All 4 branches missed.">        if ((passWidth == 0) || (passHeight == 0)) {</span>
<span class="nc" id="L954">            return;</span>
        }

<span class="nc" id="L957">        WritableRaster imRas = theImage.getWritableTile(0, 0);</span>
<span class="nc" id="L958">        int dstMinX = imRas.getMinX();</span>
<span class="nc" id="L959">        int dstMaxX = dstMinX + imRas.getWidth() - 1;</span>
<span class="nc" id="L960">        int dstMinY = imRas.getMinY();</span>
<span class="nc" id="L961">        int dstMaxY = dstMinY + imRas.getHeight() - 1;</span>

        // Determine which pixels will be updated in this pass
<span class="nc" id="L964">        int[] vals =</span>
<span class="nc" id="L965">          ReaderUtil.computeUpdatedPixels(sourceRegion,</span>
                                          destinationOffset,
                                          dstMinX, dstMinY,
                                          dstMaxX, dstMaxY,
                                          sourceXSubsampling,
                                          sourceYSubsampling,
                                          xStart, yStart,
                                          passWidth, passHeight,
                                          xStep, yStep);
<span class="nc" id="L974">        int updateMinX = vals[0];</span>
<span class="nc" id="L975">        int updateMinY = vals[1];</span>
<span class="nc" id="L976">        int updateWidth = vals[2];</span>
<span class="nc" id="L977">        int updateXStep = vals[4];</span>
<span class="nc" id="L978">        int updateYStep = vals[5];</span>

<span class="nc" id="L980">        int bitDepth = metadata.IHDR_bitDepth;</span>
<span class="nc" id="L981">        int inputBands = inputBandsForColorType[metadata.IHDR_colorType];</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">        int bytesPerPixel = (bitDepth == 16) ? 2 : 1;</span>
<span class="nc" id="L983">        bytesPerPixel *= inputBands;</span>

<span class="nc" id="L985">        int bytesPerRow = (inputBands*passWidth*bitDepth + 7)/8;</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">        int eltsPerRow = (bitDepth == 16) ? bytesPerRow/2 : bytesPerRow;</span>

        // If no pixels need updating, just skip the input data
<span class="nc bnc" id="L989" title="All 2 branches missed.">        if (updateWidth == 0) {</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">            for (int srcY = 0; srcY &lt; passHeight; srcY++) {</span>
                // Update count of pixels read
<span class="nc" id="L992">                updateImageProgress(passWidth);</span>
                // Skip filter byte and the remaining row bytes
<span class="nc" id="L994">                pixelStream.skipBytes(1 + bytesPerRow);</span>
            }
<span class="nc" id="L996">            return;</span>
        }

        // Backwards map from destination pixels
        // (dstX = updateMinX + k*updateXStep)
        // to source pixels (sourceX), and then
        // to offset and skip in passRow (srcX and srcXStep)
<span class="nc" id="L1003">        int sourceX =</span>
            (updateMinX - destinationOffset.x)*sourceXSubsampling +
            sourceRegion.x;
<span class="nc" id="L1006">        int srcX = (sourceX - xStart)/xStep;</span>

        // Compute the step factor in the source
<span class="nc" id="L1009">        int srcXStep = updateXStep*sourceXSubsampling/xStep;</span>

<span class="nc" id="L1011">        byte[] byteData = null;</span>
<span class="nc" id="L1012">        short[] shortData = null;</span>
<span class="nc" id="L1013">        byte[] curr = new byte[bytesPerRow];</span>
<span class="nc" id="L1014">        byte[] prior = new byte[bytesPerRow];</span>

        // Create a 1-row tall Raster to hold the data
<span class="nc" id="L1017">        WritableRaster passRow = createRaster(passWidth, 1, inputBands,</span>
                                              eltsPerRow,
                                              bitDepth);

        // Create an array suitable for holding one pixel
<span class="nc" id="L1022">        int[] ps = passRow.getPixel(0, 0, (int[])null);</span>

<span class="nc" id="L1024">        DataBuffer dataBuffer = passRow.getDataBuffer();</span>
<span class="nc" id="L1025">        int type = dataBuffer.getDataType();</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">        if (type == DataBuffer.TYPE_BYTE) {</span>
<span class="nc" id="L1027">            byteData = ((DataBufferByte)dataBuffer).getData();</span>
        } else {
<span class="nc" id="L1029">            shortData = ((DataBufferUShort)dataBuffer).getData();</span>
        }

<span class="nc" id="L1032">        processPassStarted(theImage,</span>
                           passNum,
                           sourceMinProgressivePass,
                           sourceMaxProgressivePass,
                           updateMinX, updateMinY,
                           updateXStep, updateYStep,
                           destinationBands);

        // Handle source and destination bands
<span class="nc bnc" id="L1041" title="All 2 branches missed.">        if (sourceBands != null) {</span>
<span class="nc" id="L1042">            passRow = passRow.createWritableChild(0, 0,</span>
<span class="nc" id="L1043">                                                  passRow.getWidth(), 1,</span>
                                                  0, 0,
                                                  sourceBands);
        }
<span class="nc bnc" id="L1047" title="All 2 branches missed.">        if (destinationBands != null) {</span>
<span class="nc" id="L1048">            imRas = imRas.createWritableChild(0, 0,</span>
<span class="nc" id="L1049">                                              imRas.getWidth(),</span>
<span class="nc" id="L1050">                                              imRas.getHeight(),</span>
                                              0, 0,
                                              destinationBands);
        }

        // Determine if all of the relevant output bands have the
        // same bit depth as the source data
<span class="nc" id="L1057">        boolean adjustBitDepths = false;</span>
<span class="nc" id="L1058">        int[] outputSampleSize = imRas.getSampleModel().getSampleSize();</span>
<span class="nc" id="L1059">        int numBands = outputSampleSize.length;</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">        for (int b = 0; b &lt; numBands; b++) {</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">            if (outputSampleSize[b] != bitDepth) {</span>
<span class="nc" id="L1062">                adjustBitDepths = true;</span>
<span class="nc" id="L1063">                break;</span>
            }
        }

        // If the bit depths differ, create a lookup table per band to perform
        // the conversion
<span class="nc" id="L1069">        int[][] scale = null;</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">        if (adjustBitDepths) {</span>
<span class="nc" id="L1071">            int maxInSample = (1 &lt;&lt; bitDepth) - 1;</span>
<span class="nc" id="L1072">            int halfMaxInSample = maxInSample/2;</span>
<span class="nc" id="L1073">            scale = new int[numBands][];</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">            for (int b = 0; b &lt; numBands; b++) {</span>
<span class="nc" id="L1075">                int maxOutSample = (1 &lt;&lt; outputSampleSize[b]) - 1;</span>
<span class="nc" id="L1076">                scale[b] = new int[maxInSample + 1];</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">                for (int s = 0; s &lt;= maxInSample; s++) {</span>
<span class="nc" id="L1078">                    scale[b][s] =</span>
                        (s*maxOutSample + halfMaxInSample)/maxInSample;
                }
            }
        }

        // Limit passRow to relevant area for the case where we
        // will can setRect to copy a contiguous span
<span class="nc bnc" id="L1086" title="All 8 branches missed.">        boolean useSetRect = srcXStep == 1 &amp;&amp;</span>
            updateXStep == 1 &amp;&amp;
            !adjustBitDepths &amp;&amp;
            (imRas instanceof ByteInterleavedRaster);

<span class="nc bnc" id="L1091" title="All 2 branches missed.">        if (useSetRect) {</span>
<span class="nc" id="L1092">            passRow = passRow.createWritableChild(srcX, 0,</span>
                                                  updateWidth, 1,
                                                  0, 0,
                                                  null);
        }

        // Decode the (sub)image row-by-row
<span class="nc bnc" id="L1099" title="All 2 branches missed.">        for (int srcY = 0; srcY &lt; passHeight; srcY++) {</span>
            // Update count of pixels read
<span class="nc" id="L1101">            updateImageProgress(passWidth);</span>

            // Read the filter type byte and a row of data
<span class="nc" id="L1104">            int filter = pixelStream.read();</span>
            try {
                // Swap curr and prior
<span class="nc" id="L1107">                byte[] tmp = prior;</span>
<span class="nc" id="L1108">                prior = curr;</span>
<span class="nc" id="L1109">                curr = tmp;</span>

<span class="nc" id="L1111">                pixelStream.readFully(curr, 0, bytesPerRow);</span>
<span class="nc" id="L1112">            } catch (java.util.zip.ZipException ze) {</span>
                // TODO - throw a more meaningful exception
<span class="nc" id="L1114">                throw ze;</span>
<span class="nc" id="L1115">            }</span>

<span class="nc bnc" id="L1117" title="All 6 branches missed.">            switch (filter) {</span>
            case PNG_FILTER_NONE:
<span class="nc" id="L1119">                break;</span>
            case PNG_FILTER_SUB:
<span class="nc" id="L1121">                decodeSubFilter(curr, 0, bytesPerRow, bytesPerPixel);</span>
<span class="nc" id="L1122">                break;</span>
            case PNG_FILTER_UP:
<span class="nc" id="L1124">                decodeUpFilter(curr, 0, prior, 0, bytesPerRow);</span>
<span class="nc" id="L1125">                break;</span>
            case PNG_FILTER_AVERAGE:
<span class="nc" id="L1127">                decodeAverageFilter(curr, 0, prior, 0, bytesPerRow,</span>
                                    bytesPerPixel);
<span class="nc" id="L1129">                break;</span>
            case PNG_FILTER_PAETH:
<span class="nc" id="L1131">                decodePaethFilter(curr, 0, prior, 0, bytesPerRow,</span>
                                  bytesPerPixel);
<span class="nc" id="L1133">                break;</span>
            default:
<span class="nc" id="L1135">                throw new IIOException(&quot;Unknown row filter type (= &quot; +</span>
                                       filter + &quot;)!&quot;);
            }

            // Copy data into passRow byte by byte
<span class="nc bnc" id="L1140" title="All 2 branches missed.">            if (bitDepth &lt; 16) {</span>
<span class="nc" id="L1141">                System.arraycopy(curr, 0, byteData, 0, bytesPerRow);</span>
            } else {
<span class="nc" id="L1143">                int idx = 0;</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">                for (int j = 0; j &lt; eltsPerRow; j++) {</span>
<span class="nc" id="L1145">                    shortData[j] =</span>
                        (short)((curr[idx] &lt;&lt; 8) | (curr[idx + 1] &amp; 0xff));
<span class="nc" id="L1147">                    idx += 2;</span>
                }
            }

            // True Y position in source
<span class="nc" id="L1152">            int sourceY = srcY*yStep + yStart;</span>
<span class="nc bnc" id="L1153" title="All 6 branches missed.">            if ((sourceY &gt;= sourceRegion.y) &amp;&amp;</span>
                (sourceY &lt; sourceRegion.y + sourceRegion.height) &amp;&amp;
                (((sourceY - sourceRegion.y) %
                  sourceYSubsampling) == 0)) {

<span class="nc" id="L1158">                int dstY = destinationOffset.y +</span>
                    (sourceY - sourceRegion.y)/sourceYSubsampling;
<span class="nc bnc" id="L1160" title="All 2 branches missed.">                if (dstY &lt; dstMinY) {</span>
<span class="nc" id="L1161">                    continue;</span>
                }
<span class="nc bnc" id="L1163" title="All 2 branches missed.">                if (dstY &gt; dstMaxY) {</span>
<span class="nc" id="L1164">                    break;</span>
                }

<span class="nc bnc" id="L1167" title="All 2 branches missed.">                if (useSetRect) {</span>
<span class="nc" id="L1168">                    imRas.setRect(updateMinX, dstY, passRow);</span>
                } else {
<span class="nc" id="L1170">                    int newSrcX = srcX;</span>

<span class="nc" id="L1172">                    for (int dstX = updateMinX;</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">                         dstX &lt; updateMinX + updateWidth;</span>
<span class="nc" id="L1174">                         dstX += updateXStep) {</span>

<span class="nc" id="L1176">                        passRow.getPixel(newSrcX, 0, ps);</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">                        if (adjustBitDepths) {</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">                            for (int b = 0; b &lt; numBands; b++) {</span>
<span class="nc" id="L1179">                                ps[b] = scale[b][ps[b]];</span>
                            }
                        }
<span class="nc" id="L1182">                        imRas.setPixel(dstX, dstY, ps);</span>
<span class="nc" id="L1183">                        newSrcX += srcXStep;</span>
                    }
                }

<span class="nc" id="L1187">                processImageUpdate(theImage,</span>
                                   updateMinX, dstY,
                                   updateWidth, 1,
                                   updateXStep, updateYStep,
                                   destinationBands);

                // If read has been aborted, just return
                // processReadAborted will be called later
<span class="nc bnc" id="L1195" title="All 2 branches missed.">                if (abortRequested()) {</span>
<span class="nc" id="L1196">                    return;</span>
                }
            }
        }

<span class="nc" id="L1201">        processPassComplete(theImage);</span>
<span class="nc" id="L1202">    }</span>

    private void decodeImage()
        throws IOException, IIOException  {
<span class="nc" id="L1206">        int width = metadata.IHDR_width;</span>
<span class="nc" id="L1207">        int height = metadata.IHDR_height;</span>

<span class="nc" id="L1209">        this.pixelsDone = 0;</span>
<span class="nc" id="L1210">        this.totalPixels = width*height;</span>

<span class="nc" id="L1212">        clearAbortRequest();</span>

<span class="nc bnc" id="L1214" title="All 2 branches missed.">        if (metadata.IHDR_interlaceMethod == 0) {</span>
<span class="nc" id="L1215">            decodePass(0, 0, 0, 1, 1, width, height);</span>
        } else {
<span class="nc bnc" id="L1217" title="All 2 branches missed.">            for (int i = 0; i &lt;= sourceMaxProgressivePass; i++) {</span>
<span class="nc" id="L1218">                int XOffset = adam7XOffset[i];</span>
<span class="nc" id="L1219">                int YOffset = adam7YOffset[i];</span>
<span class="nc" id="L1220">                int XSubsampling = adam7XSubsampling[i];</span>
<span class="nc" id="L1221">                int YSubsampling = adam7YSubsampling[i];</span>
<span class="nc" id="L1222">                int xbump = adam7XSubsampling[i + 1] - 1;</span>
<span class="nc" id="L1223">                int ybump = adam7YSubsampling[i + 1] - 1;</span>

<span class="nc bnc" id="L1225" title="All 2 branches missed.">                if (i &gt;= sourceMinProgressivePass) {</span>
<span class="nc" id="L1226">                    decodePass(i,</span>
                               XOffset,
                               YOffset,
                               XSubsampling,
                               YSubsampling,
                               (width + xbump)/XSubsampling,
                               (height + ybump)/YSubsampling);
                } else {
<span class="nc" id="L1234">                    skipPass((width + xbump)/XSubsampling,</span>
                             (height + ybump)/YSubsampling);
                }

                // If read has been aborted, just return
                // processReadAborted will be called later
<span class="nc bnc" id="L1240" title="All 2 branches missed.">                if (abortRequested()) {</span>
<span class="nc" id="L1241">                    return;</span>
                }
            }
        }
<span class="nc" id="L1245">    }</span>

    private void readImage(ImageReadParam param) throws IIOException {
<span class="nc" id="L1248">        readMetadata();</span>

<span class="nc" id="L1250">        int width = metadata.IHDR_width;</span>
<span class="nc" id="L1251">        int height = metadata.IHDR_height;</span>

        // Init default values
<span class="nc" id="L1254">        sourceXSubsampling = 1;</span>
<span class="nc" id="L1255">        sourceYSubsampling = 1;</span>
<span class="nc" id="L1256">        sourceMinProgressivePass = 0;</span>
<span class="nc" id="L1257">        sourceMaxProgressivePass = 6;</span>
<span class="nc" id="L1258">        sourceBands = null;</span>
<span class="nc" id="L1259">        destinationBands = null;</span>
<span class="nc" id="L1260">        destinationOffset = new Point(0, 0);</span>

        // If an ImageReadParam is available, get values from it
<span class="nc bnc" id="L1263" title="All 2 branches missed.">        if (param != null) {</span>
<span class="nc" id="L1264">            sourceXSubsampling = param.getSourceXSubsampling();</span>
<span class="nc" id="L1265">            sourceYSubsampling = param.getSourceYSubsampling();</span>

<span class="nc" id="L1267">            sourceMinProgressivePass =</span>
<span class="nc" id="L1268">                Math.max(param.getSourceMinProgressivePass(), 0);</span>
<span class="nc" id="L1269">            sourceMaxProgressivePass =</span>
<span class="nc" id="L1270">                Math.min(param.getSourceMaxProgressivePass(), 6);</span>

<span class="nc" id="L1272">            sourceBands = param.getSourceBands();</span>
<span class="nc" id="L1273">            destinationBands = param.getDestinationBands();</span>
<span class="nc" id="L1274">            destinationOffset = param.getDestinationOffset();</span>
        }
<span class="nc" id="L1276">        Inflater inf = null;</span>
        try {
<span class="nc" id="L1278">            stream.seek(imageStartPosition);</span>

<span class="nc" id="L1280">            Enumeration&lt;InputStream&gt; e = new PNGImageDataEnumeration(stream);</span>
<span class="nc" id="L1281">            InputStream is = new SequenceInputStream(e);</span>

           /* InflaterInputStream uses an Inflater instance which consumes
            * native (non-GC visible) resources. This is normally implicitly
            * freed when the stream is closed. However since the
            * InflaterInputStream wraps a client-supplied input stream,
            * we cannot close it.
            * But the app may depend on GC finalization to close the stream.
            * Therefore to ensure timely freeing of native resources we
            * explicitly create the Inflater instance and free its resources
            * when we are done with the InflaterInputStream by calling
            * inf.end();
            */
<span class="nc" id="L1294">            inf = new Inflater();</span>
<span class="nc" id="L1295">            is = new InflaterInputStream(is, inf);</span>
<span class="nc" id="L1296">            is = new BufferedInputStream(is);</span>
<span class="nc" id="L1297">            this.pixelStream = new DataInputStream(is);</span>

            /*
             * NB: the PNG spec declares that valid range for width
             * and height is [1, 2^31-1], so here we may fail to allocate
             * a buffer for destination image due to memory limitation.
             *
             * However, the recovery strategy for this case should be
             * defined on the level of application, so we will not
             * try to estimate the required amount of the memory and/or
             * handle OOM in any way.
             */
<span class="nc" id="L1309">            theImage = getDestination(param,</span>
<span class="nc" id="L1310">                                      getImageTypes(0),</span>
                                      width,
                                      height);

<span class="nc" id="L1314">            Rectangle destRegion = new Rectangle(0, 0, 0, 0);</span>
<span class="nc" id="L1315">            sourceRegion = new Rectangle(0, 0, 0, 0);</span>
<span class="nc" id="L1316">            computeRegions(param, width, height,</span>
                           theImage,
                           sourceRegion, destRegion);
<span class="nc" id="L1319">            destinationOffset.setLocation(destRegion.getLocation());</span>

            // At this point the header has been read and we know
            // how many bands are in the image, so perform checking
            // of the read param.
<span class="nc" id="L1324">            int colorType = metadata.IHDR_colorType;</span>
<span class="nc" id="L1325">            checkReadParamBandSettings(param,</span>
                                       inputBandsForColorType[colorType],
<span class="nc" id="L1327">                                      theImage.getSampleModel().getNumBands());</span>

<span class="nc" id="L1329">            processImageStarted(0);</span>
<span class="nc" id="L1330">            decodeImage();</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">            if (abortRequested()) {</span>
<span class="nc" id="L1332">                processReadAborted();</span>
            } else {
<span class="nc" id="L1334">                processImageComplete();</span>
            }
<span class="nc" id="L1336">        } catch (IOException e) {</span>
<span class="nc" id="L1337">            throw new IIOException(&quot;Error reading PNG image data&quot;, e);</span>
        } finally {
<span class="nc bnc" id="L1339" title="All 4 branches missed.">            if (inf != null) {</span>
<span class="nc" id="L1340">                inf.end();</span>
            }
        }
<span class="nc" id="L1343">    }</span>

    public int getNumImages(boolean allowSearch) throws IIOException {
<span class="nc bnc" id="L1346" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L1347">            throw new IllegalStateException(&quot;No input source set!&quot;);</span>
        }
<span class="nc bnc" id="L1349" title="All 4 branches missed.">        if (seekForwardOnly &amp;&amp; allowSearch) {</span>
<span class="nc" id="L1350">            throw new IllegalStateException</span>
                (&quot;seekForwardOnly and allowSearch can't both be true!&quot;);
        }
<span class="nc" id="L1353">        return 1;</span>
    }

    public int getWidth(int imageIndex) throws IIOException {
<span class="nc bnc" id="L1357" title="All 2 branches missed.">        if (imageIndex != 0) {</span>
<span class="nc" id="L1358">            throw new IndexOutOfBoundsException(&quot;imageIndex != 0!&quot;);</span>
        }

<span class="nc" id="L1361">        readHeader();</span>

<span class="nc" id="L1363">        return metadata.IHDR_width;</span>
    }

    public int getHeight(int imageIndex) throws IIOException {
<span class="nc bnc" id="L1367" title="All 2 branches missed.">        if (imageIndex != 0) {</span>
<span class="nc" id="L1368">            throw new IndexOutOfBoundsException(&quot;imageIndex != 0!&quot;);</span>
        }

<span class="nc" id="L1371">        readHeader();</span>

<span class="nc" id="L1373">        return metadata.IHDR_height;</span>
    }

    public Iterator&lt;ImageTypeSpecifier&gt; getImageTypes(int imageIndex)
      throws IIOException
    {
<span class="nc bnc" id="L1379" title="All 2 branches missed.">        if (imageIndex != 0) {</span>
<span class="nc" id="L1380">            throw new IndexOutOfBoundsException(&quot;imageIndex != 0!&quot;);</span>
        }

<span class="nc" id="L1383">        readHeader();</span>

<span class="nc" id="L1385">        ArrayList&lt;ImageTypeSpecifier&gt; l =</span>
            new ArrayList&lt;ImageTypeSpecifier&gt;(1);

        ColorSpace rgb;
        ColorSpace gray;
        int[] bandOffsets;

<span class="nc" id="L1392">        int bitDepth = metadata.IHDR_bitDepth;</span>
<span class="nc" id="L1393">        int colorType = metadata.IHDR_colorType;</span>

        int dataType;
<span class="nc bnc" id="L1396" title="All 2 branches missed.">        if (bitDepth &lt;= 8) {</span>
<span class="nc" id="L1397">            dataType = DataBuffer.TYPE_BYTE;</span>
        } else {
<span class="nc" id="L1399">            dataType = DataBuffer.TYPE_USHORT;</span>
        }

<span class="nc bnc" id="L1402" title="All 6 branches missed.">        switch (colorType) {</span>
        case PNG_COLOR_GRAY:
            // Packed grayscale
<span class="nc" id="L1405">            l.add(ImageTypeSpecifier.createGrayscale(bitDepth,</span>
                                                     dataType,
                                                     false));
<span class="nc" id="L1408">            break;</span>

        case PNG_COLOR_RGB:
<span class="nc bnc" id="L1411" title="All 2 branches missed.">            if (bitDepth == 8) {</span>
                // some standard types of buffered images
                // which can be used as destination
<span class="nc" id="L1414">                l.add(ImageTypeSpecifier.createFromBufferedImageType(</span>
                          BufferedImage.TYPE_3BYTE_BGR));

<span class="nc" id="L1417">                l.add(ImageTypeSpecifier.createFromBufferedImageType(</span>
                          BufferedImage.TYPE_INT_RGB));

<span class="nc" id="L1420">                l.add(ImageTypeSpecifier.createFromBufferedImageType(</span>
                          BufferedImage.TYPE_INT_BGR));

            }
            // Component R, G, B
<span class="nc" id="L1425">            rgb = ColorSpace.getInstance(ColorSpace.CS_sRGB);</span>
<span class="nc" id="L1426">            bandOffsets = new int[3];</span>
<span class="nc" id="L1427">            bandOffsets[0] = 0;</span>
<span class="nc" id="L1428">            bandOffsets[1] = 1;</span>
<span class="nc" id="L1429">            bandOffsets[2] = 2;</span>
<span class="nc" id="L1430">            l.add(ImageTypeSpecifier.createInterleaved(rgb,</span>
                                                       bandOffsets,
                                                       dataType,
                                                       false,
                                                       false));
<span class="nc" id="L1435">            break;</span>

        case PNG_COLOR_PALETTE:
<span class="nc" id="L1438">            readMetadata(); // Need tRNS chunk</span>

            /*
             * The PLTE chunk spec says:
             *
             * The number of palette entries must not exceed the range that
             * can be represented in the image bit depth (for example, 2^4 = 16
             * for a bit depth of 4). It is permissible to have fewer entries
             * than the bit depth would allow. In that case, any out-of-range
             * pixel value found in the image data is an error.
             *
             * http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.PLTE
             *
             * Consequently, the case when the palette length is smaller than
             * 2^bitDepth is legal in the view of PNG spec.
             *
             * However the spec of createIndexed() method demands the exact
             * equality of the palette lengh and number of possible palette
             * entries (2^bitDepth).
             *
             * {@link javax.imageio.ImageTypeSpecifier.html#createIndexed}
             *
             * In order to avoid this contradiction we need to extend the
             * palette arrays to the limit defined by the bitDepth.
             */

<span class="nc" id="L1464">            int plength = 1 &lt;&lt; bitDepth;</span>

<span class="nc" id="L1466">            byte[] red = metadata.PLTE_red;</span>
<span class="nc" id="L1467">            byte[] green = metadata.PLTE_green;</span>
<span class="nc" id="L1468">            byte[] blue = metadata.PLTE_blue;</span>

<span class="nc bnc" id="L1470" title="All 2 branches missed.">            if (metadata.PLTE_red.length &lt; plength) {</span>
<span class="nc" id="L1471">                red = Arrays.copyOf(metadata.PLTE_red, plength);</span>
<span class="nc" id="L1472">                Arrays.fill(red, metadata.PLTE_red.length, plength,</span>
                            metadata.PLTE_red[metadata.PLTE_red.length - 1]);

<span class="nc" id="L1475">                green = Arrays.copyOf(metadata.PLTE_green, plength);</span>
<span class="nc" id="L1476">                Arrays.fill(green, metadata.PLTE_green.length, plength,</span>
                            metadata.PLTE_green[metadata.PLTE_green.length - 1]);

<span class="nc" id="L1479">                blue = Arrays.copyOf(metadata.PLTE_blue, plength);</span>
<span class="nc" id="L1480">                Arrays.fill(blue, metadata.PLTE_blue.length, plength,</span>
                            metadata.PLTE_blue[metadata.PLTE_blue.length - 1]);

            }

            // Alpha from tRNS chunk may have fewer entries than
            // the RGB LUTs from the PLTE chunk; if so, pad with
            // 255.
<span class="nc" id="L1488">            byte[] alpha = null;</span>
<span class="nc bnc" id="L1489" title="All 4 branches missed.">            if (metadata.tRNS_present &amp;&amp; (metadata.tRNS_alpha != null)) {</span>
<span class="nc bnc" id="L1490" title="All 2 branches missed.">                if (metadata.tRNS_alpha.length == red.length) {</span>
<span class="nc" id="L1491">                    alpha = metadata.tRNS_alpha;</span>
                } else {
<span class="nc" id="L1493">                    alpha = Arrays.copyOf(metadata.tRNS_alpha, red.length);</span>
<span class="nc" id="L1494">                    Arrays.fill(alpha,</span>
                                metadata.tRNS_alpha.length,
                                red.length, (byte)255);
                }
            }

<span class="nc" id="L1500">            l.add(ImageTypeSpecifier.createIndexed(red, green,</span>
                                                   blue, alpha,
                                                   bitDepth,
                                                   DataBuffer.TYPE_BYTE));
<span class="nc" id="L1504">            break;</span>

        case PNG_COLOR_GRAY_ALPHA:
            // Component G, A
<span class="nc" id="L1508">            gray = ColorSpace.getInstance(ColorSpace.CS_GRAY);</span>
<span class="nc" id="L1509">            bandOffsets = new int[2];</span>
<span class="nc" id="L1510">            bandOffsets[0] = 0;</span>
<span class="nc" id="L1511">            bandOffsets[1] = 1;</span>
<span class="nc" id="L1512">            l.add(ImageTypeSpecifier.createInterleaved(gray,</span>
                                                       bandOffsets,
                                                       dataType,
                                                       true,
                                                       false));
<span class="nc" id="L1517">            break;</span>

        case PNG_COLOR_RGB_ALPHA:
<span class="nc bnc" id="L1520" title="All 2 branches missed.">            if (bitDepth == 8) {</span>
                // some standard types of buffered images
                // wich can be used as destination
<span class="nc" id="L1523">                l.add(ImageTypeSpecifier.createFromBufferedImageType(</span>
                          BufferedImage.TYPE_4BYTE_ABGR));

<span class="nc" id="L1526">                l.add(ImageTypeSpecifier.createFromBufferedImageType(</span>
                          BufferedImage.TYPE_INT_ARGB));
            }

            // Component R, G, B, A (non-premultiplied)
<span class="nc" id="L1531">            rgb = ColorSpace.getInstance(ColorSpace.CS_sRGB);</span>
<span class="nc" id="L1532">            bandOffsets = new int[4];</span>
<span class="nc" id="L1533">            bandOffsets[0] = 0;</span>
<span class="nc" id="L1534">            bandOffsets[1] = 1;</span>
<span class="nc" id="L1535">            bandOffsets[2] = 2;</span>
<span class="nc" id="L1536">            bandOffsets[3] = 3;</span>

<span class="nc" id="L1538">            l.add(ImageTypeSpecifier.createInterleaved(rgb,</span>
                                                       bandOffsets,
                                                       dataType,
                                                       true,
                                                       false));
<span class="nc" id="L1543">            break;</span>

        default:
            break;
        }

<span class="nc" id="L1549">        return l.iterator();</span>
    }

    /*
     * Super class implementation uses first element
     * of image types list as raw image type.
     *
     * Also, super implementation uses first element of this list
     * as default destination type image read param does not specify
     * anything other.
     *
     * However, in case of RGB and RGBA color types, raw image type
     * produces buffered image of custom type. It causes some
     * performance degradation of subsequent rendering operations.
     *
     * To resolve this contradiction we put standard image types
     * at the first positions of image types list (to produce standard
     * images by default) and put raw image type (which is custom)
     * at the last position of this list.
     *
     * After this changes we should override getRawImageType()
     * to return last element of image types list.
     */
    public ImageTypeSpecifier getRawImageType(int imageIndex)
      throws IOException {

<span class="nc" id="L1575">        Iterator&lt;ImageTypeSpecifier&gt; types = getImageTypes(imageIndex);</span>
<span class="nc" id="L1576">        ImageTypeSpecifier raw = null;</span>
        do {
<span class="nc" id="L1578">            raw = types.next();</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">        } while (types.hasNext());</span>
<span class="nc" id="L1580">        return raw;</span>
    }

    public ImageReadParam getDefaultReadParam() {
<span class="nc" id="L1584">        return new ImageReadParam();</span>
    }

    public IIOMetadata getStreamMetadata()
        throws IIOException {
<span class="nc" id="L1589">        return null;</span>
    }

    public IIOMetadata getImageMetadata(int imageIndex) throws IIOException {
<span class="nc bnc" id="L1593" title="All 2 branches missed.">        if (imageIndex != 0) {</span>
<span class="nc" id="L1594">            throw new IndexOutOfBoundsException(&quot;imageIndex != 0!&quot;);</span>
        }
<span class="nc" id="L1596">        readMetadata();</span>
<span class="nc" id="L1597">        return metadata;</span>
    }

    public BufferedImage read(int imageIndex, ImageReadParam param)
        throws IIOException {
<span class="nc bnc" id="L1602" title="All 2 branches missed.">        if (imageIndex != 0) {</span>
<span class="nc" id="L1603">            throw new IndexOutOfBoundsException(&quot;imageIndex != 0!&quot;);</span>
        }

<span class="nc" id="L1606">        readImage(param);</span>
<span class="nc" id="L1607">        return theImage;</span>
    }

    public void reset() {
<span class="nc" id="L1611">        super.reset();</span>
<span class="nc" id="L1612">        resetStreamSettings();</span>
<span class="nc" id="L1613">    }</span>

    private void resetStreamSettings() {
<span class="nc" id="L1616">        gotHeader = false;</span>
<span class="nc" id="L1617">        gotMetadata = false;</span>
<span class="nc" id="L1618">        metadata = null;</span>
<span class="nc" id="L1619">        pixelStream = null;</span>
<span class="nc" id="L1620">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>