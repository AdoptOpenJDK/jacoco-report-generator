<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PNGImageWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.imageio.plugins.png</a> &gt; <span class="el_source">PNGImageWriter.java</span></div><h1>PNGImageWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.imageio.plugins.png;

import java.awt.Rectangle;
import java.awt.image.ColorModel;
import java.awt.image.IndexColorModel;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.awt.image.RenderedImage;
import java.awt.image.SampleModel;
import java.io.ByteArrayOutputStream;
import java.io.DataOutput;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Iterator;
import java.util.Locale;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;
import javax.imageio.IIOException;
import javax.imageio.IIOImage;
import javax.imageio.ImageTypeSpecifier;
import javax.imageio.ImageWriteParam;
import javax.imageio.ImageWriter;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.spi.ImageWriterSpi;
import javax.imageio.stream.ImageOutputStream;
import javax.imageio.stream.ImageOutputStreamImpl;

class CRC {

<span class="nc" id="L56">    private static int[] crcTable = new int[256];</span>
<span class="nc" id="L57">    private int crc = 0xffffffff;</span>

    static {
        // Initialize CRC table
<span class="nc bnc" id="L61" title="All 2 branches missed.">        for (int n = 0; n &lt; 256; n++) {</span>
<span class="nc" id="L62">            int c = n;</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">            for (int k = 0; k &lt; 8; k++) {</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">                if ((c &amp; 1) == 1) {</span>
<span class="nc" id="L65">                    c = 0xedb88320 ^ (c &gt;&gt;&gt; 1);</span>
                } else {
<span class="nc" id="L67">                    c &gt;&gt;&gt;= 1;</span>
                }

<span class="nc" id="L70">                crcTable[n] = c;</span>
            }
        }
<span class="nc" id="L73">    }</span>

<span class="nc" id="L75">    public CRC() {}</span>

    public void reset() {
<span class="nc" id="L78">        crc = 0xffffffff;</span>
<span class="nc" id="L79">    }</span>

    public void update(byte[] data, int off, int len) {
<span class="nc bnc" id="L82" title="All 2 branches missed.">        for (int n = 0; n &lt; len; n++) {</span>
<span class="nc" id="L83">            crc = crcTable[(crc ^ data[off + n]) &amp; 0xff] ^ (crc &gt;&gt;&gt; 8);</span>
        }
<span class="nc" id="L85">    }</span>

    public void update(int data) {
<span class="nc" id="L88">        crc = crcTable[(crc ^ data) &amp; 0xff] ^ (crc &gt;&gt;&gt; 8);</span>
<span class="nc" id="L89">    }</span>

    public int getValue() {
<span class="nc" id="L92">        return crc ^ 0xffffffff;</span>
    }
}


final class ChunkStream extends ImageOutputStreamImpl {

    private ImageOutputStream stream;
    private long startPos;
<span class="nc" id="L101">    private CRC crc = new CRC();</span>

<span class="nc" id="L103">    public ChunkStream(int type, ImageOutputStream stream) throws IOException {</span>
<span class="nc" id="L104">        this.stream = stream;</span>
<span class="nc" id="L105">        this.startPos = stream.getStreamPosition();</span>

<span class="nc" id="L107">        stream.writeInt(-1); // length, will backpatch</span>
<span class="nc" id="L108">        writeInt(type);</span>
<span class="nc" id="L109">    }</span>

    public int read() throws IOException {
<span class="nc" id="L112">        throw new RuntimeException(&quot;Method not available&quot;);</span>
    }

    public int read(byte[] b, int off, int len) throws IOException {
<span class="nc" id="L116">        throw new RuntimeException(&quot;Method not available&quot;);</span>
    }

    public void write(byte[] b, int off, int len) throws IOException {
<span class="nc" id="L120">        crc.update(b, off, len);</span>
<span class="nc" id="L121">        stream.write(b, off, len);</span>
<span class="nc" id="L122">    }</span>

    public void write(int b) throws IOException {
<span class="nc" id="L125">        crc.update(b);</span>
<span class="nc" id="L126">        stream.write(b);</span>
<span class="nc" id="L127">    }</span>

    public void finish() throws IOException {
        // Write CRC
<span class="nc" id="L131">        stream.writeInt(crc.getValue());</span>

        // Write length
<span class="nc" id="L134">        long pos = stream.getStreamPosition();</span>
<span class="nc" id="L135">        stream.seek(startPos);</span>
<span class="nc" id="L136">        stream.writeInt((int)(pos - startPos) - 12);</span>

        // Return to end of chunk and flush to minimize buffering
<span class="nc" id="L139">        stream.seek(pos);</span>
<span class="nc" id="L140">        stream.flushBefore(pos);</span>
<span class="nc" id="L141">    }</span>

    protected void finalize() throws Throwable {
        // Empty finalizer (for improved performance; no need to call
        // super.finalize() in this case)
<span class="nc" id="L146">    }</span>
}

// Compress output and write as a series of 'IDAT' chunks of
// fixed length.
final class IDATOutputStream extends ImageOutputStreamImpl {

<span class="nc" id="L153">    private static byte[] chunkType = {</span>
        (byte)'I', (byte)'D', (byte)'A', (byte)'T'
    };

    private ImageOutputStream stream;
    private int chunkLength;
    private long startPos;
<span class="nc" id="L160">    private CRC crc = new CRC();</span>

<span class="nc" id="L162">    Deflater def = new Deflater(Deflater.BEST_COMPRESSION);</span>
<span class="nc" id="L163">    byte[] buf = new byte[512];</span>

    private int bytesRemaining;

    public IDATOutputStream(ImageOutputStream stream, int chunkLength)
<span class="nc" id="L168">        throws IOException {</span>
<span class="nc" id="L169">        this.stream = stream;</span>
<span class="nc" id="L170">        this.chunkLength = chunkLength;</span>
<span class="nc" id="L171">        startChunk();</span>
<span class="nc" id="L172">    }</span>

    private void startChunk() throws IOException {
<span class="nc" id="L175">        crc.reset();</span>
<span class="nc" id="L176">        this.startPos = stream.getStreamPosition();</span>
<span class="nc" id="L177">        stream.writeInt(-1); // length, will backpatch</span>

<span class="nc" id="L179">        crc.update(chunkType, 0, 4);</span>
<span class="nc" id="L180">        stream.write(chunkType, 0, 4);</span>

<span class="nc" id="L182">        this.bytesRemaining = chunkLength;</span>
<span class="nc" id="L183">    }</span>

    private void finishChunk() throws IOException {
        // Write CRC
<span class="nc" id="L187">        stream.writeInt(crc.getValue());</span>

        // Write length
<span class="nc" id="L190">        long pos = stream.getStreamPosition();</span>
<span class="nc" id="L191">        stream.seek(startPos);</span>
<span class="nc" id="L192">        stream.writeInt((int)(pos - startPos) - 12);</span>

        // Return to end of chunk and flush to minimize buffering
<span class="nc" id="L195">        stream.seek(pos);</span>
<span class="nc" id="L196">        stream.flushBefore(pos);</span>
<span class="nc" id="L197">    }</span>

    public int read() throws IOException {
<span class="nc" id="L200">        throw new RuntimeException(&quot;Method not available&quot;);</span>
    }

    public int read(byte[] b, int off, int len) throws IOException {
<span class="nc" id="L204">        throw new RuntimeException(&quot;Method not available&quot;);</span>
    }

    public void write(byte[] b, int off, int len) throws IOException {
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (len == 0) {</span>
<span class="nc" id="L209">            return;</span>
        }

<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (!def.finished()) {</span>
<span class="nc" id="L213">            def.setInput(b, off, len);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            while (!def.needsInput()) {</span>
<span class="nc" id="L215">                deflate();</span>
            }
        }
<span class="nc" id="L218">    }</span>

    public void deflate() throws IOException {
<span class="nc" id="L221">        int len = def.deflate(buf, 0, buf.length);</span>
<span class="nc" id="L222">        int off = 0;</span>

<span class="nc bnc" id="L224" title="All 2 branches missed.">        while (len &gt; 0) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (bytesRemaining == 0) {</span>
<span class="nc" id="L226">                finishChunk();</span>
<span class="nc" id="L227">                startChunk();</span>
            }

<span class="nc" id="L230">            int nbytes = Math.min(len, bytesRemaining);</span>
<span class="nc" id="L231">            crc.update(buf, off, nbytes);</span>
<span class="nc" id="L232">            stream.write(buf, off, nbytes);</span>

<span class="nc" id="L234">            off += nbytes;</span>
<span class="nc" id="L235">            len -= nbytes;</span>
<span class="nc" id="L236">            bytesRemaining -= nbytes;</span>
<span class="nc" id="L237">        }</span>
<span class="nc" id="L238">    }</span>

    public void write(int b) throws IOException {
<span class="nc" id="L241">        byte[] wbuf = new byte[1];</span>
<span class="nc" id="L242">        wbuf[0] = (byte)b;</span>
<span class="nc" id="L243">        write(wbuf, 0, 1);</span>
<span class="nc" id="L244">    }</span>

    public void finish() throws IOException {
        try {
<span class="nc bnc" id="L248" title="All 2 branches missed.">            if (!def.finished()) {</span>
<span class="nc" id="L249">                def.finish();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                while (!def.finished()) {</span>
<span class="nc" id="L251">                    deflate();</span>
                }
            }
<span class="nc" id="L254">            finishChunk();</span>
        } finally {
<span class="nc" id="L256">            def.end();</span>
<span class="nc" id="L257">        }</span>
<span class="nc" id="L258">    }</span>

    protected void finalize() throws Throwable {
        // Empty finalizer (for improved performance; no need to call
        // super.finalize() in this case)
<span class="nc" id="L263">    }</span>
}


class PNGImageWriteParam extends ImageWriteParam {

    public PNGImageWriteParam(Locale locale) {
<span class="nc" id="L270">        super();</span>
<span class="nc" id="L271">        this.canWriteProgressive = true;</span>
<span class="nc" id="L272">        this.locale = locale;</span>
<span class="nc" id="L273">    }</span>
}

/**
 */
public class PNGImageWriter extends ImageWriter {

<span class="nc" id="L280">    ImageOutputStream stream = null;</span>

<span class="nc" id="L282">    PNGMetadata metadata = null;</span>

    // Factors from the ImageWriteParam
<span class="nc" id="L285">    int sourceXOffset = 0;</span>
<span class="nc" id="L286">    int sourceYOffset = 0;</span>
<span class="nc" id="L287">    int sourceWidth = 0;</span>
<span class="nc" id="L288">    int sourceHeight = 0;</span>
<span class="nc" id="L289">    int[] sourceBands = null;</span>
<span class="nc" id="L290">    int periodX = 1;</span>
<span class="nc" id="L291">    int periodY = 1;</span>

    int numBands;
    int bpp;

<span class="nc" id="L296">    RowFilter rowFilter = new RowFilter();</span>
<span class="nc" id="L297">    byte[] prevRow = null;</span>
<span class="nc" id="L298">    byte[] currRow = null;</span>
<span class="nc" id="L299">    byte[][] filteredRows = null;</span>

    // Per-band scaling tables
    //
    // After the first call to initializeScaleTables, either scale and scale0
    // will be valid, or scaleh and scalel will be valid, but not both.
    //
    // The tables will be designed for use with a set of input but depths
    // given by sampleSize, and an output bit depth given by scalingBitDepth.
    //
<span class="nc" id="L309">    int[] sampleSize = null; // Sample size per band, in bits</span>
<span class="nc" id="L310">    int scalingBitDepth = -1; // Output bit depth of the scaling tables</span>

    // Tables for 1, 2, 4, or 8 bit output
<span class="nc" id="L313">    byte[][] scale = null; // 8 bit table</span>
<span class="nc" id="L314">    byte[] scale0 = null; // equivalent to scale[0]</span>

    // Tables for 16 bit output
<span class="nc" id="L317">    byte[][] scaleh = null; // High bytes of output</span>
<span class="nc" id="L318">    byte[][] scalel = null; // Low bytes of output</span>

    int totalPixels; // Total number of pixels to be written by write_IDAT
    int pixelsDone; // Running count of pixels written by write_IDAT

    public PNGImageWriter(ImageWriterSpi originatingProvider) {
<span class="nc" id="L324">        super(originatingProvider);</span>
<span class="nc" id="L325">    }</span>

    public void setOutput(Object output) {
<span class="nc" id="L328">        super.setOutput(output);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (output != null) {</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            if (!(output instanceof ImageOutputStream)) {</span>
<span class="nc" id="L331">                throw new IllegalArgumentException(&quot;output not an ImageOutputStream!&quot;);</span>
            }
<span class="nc" id="L333">            this.stream = (ImageOutputStream)output;</span>
        } else {
<span class="nc" id="L335">            this.stream = null;</span>
        }
<span class="nc" id="L337">    }</span>

<span class="nc" id="L339">    private static int[] allowedProgressivePasses = { 1, 7 };</span>

    public ImageWriteParam getDefaultWriteParam() {
<span class="nc" id="L342">        return new PNGImageWriteParam(getLocale());</span>
    }

    public IIOMetadata getDefaultStreamMetadata(ImageWriteParam param) {
<span class="nc" id="L346">        return null;</span>
    }

    public IIOMetadata getDefaultImageMetadata(ImageTypeSpecifier imageType,
                                               ImageWriteParam param) {
<span class="nc" id="L351">        PNGMetadata m = new PNGMetadata();</span>
<span class="nc" id="L352">        m.initialize(imageType, imageType.getSampleModel().getNumBands());</span>
<span class="nc" id="L353">        return m;</span>
    }

    public IIOMetadata convertStreamMetadata(IIOMetadata inData,
                                             ImageWriteParam param) {
<span class="nc" id="L358">        return null;</span>
    }

    public IIOMetadata convertImageMetadata(IIOMetadata inData,
                                            ImageTypeSpecifier imageType,
                                            ImageWriteParam param) {
        // TODO - deal with imageType
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (inData instanceof PNGMetadata) {</span>
<span class="nc" id="L366">            return (PNGMetadata)((PNGMetadata)inData).clone();</span>
        } else {
<span class="nc" id="L368">            return new PNGMetadata(inData);</span>
        }
    }

    private void write_magic() throws IOException {
        // Write signature
<span class="nc" id="L374">        byte[] magic = { (byte)137, 80, 78, 71, 13, 10, 26, 10 };</span>
<span class="nc" id="L375">        stream.write(magic);</span>
<span class="nc" id="L376">    }</span>

    private void write_IHDR() throws IOException {
        // Write IHDR chunk
<span class="nc" id="L380">        ChunkStream cs = new ChunkStream(PNGImageReader.IHDR_TYPE, stream);</span>
<span class="nc" id="L381">        cs.writeInt(metadata.IHDR_width);</span>
<span class="nc" id="L382">        cs.writeInt(metadata.IHDR_height);</span>
<span class="nc" id="L383">        cs.writeByte(metadata.IHDR_bitDepth);</span>
<span class="nc" id="L384">        cs.writeByte(metadata.IHDR_colorType);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (metadata.IHDR_compressionMethod != 0) {</span>
<span class="nc" id="L386">            throw new IIOException(</span>
&quot;Only compression method 0 is defined in PNG 1.1&quot;);
        }
<span class="nc" id="L389">        cs.writeByte(metadata.IHDR_compressionMethod);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (metadata.IHDR_filterMethod != 0) {</span>
<span class="nc" id="L391">            throw new IIOException(</span>
&quot;Only filter method 0 is defined in PNG 1.1&quot;);
        }
<span class="nc" id="L394">        cs.writeByte(metadata.IHDR_filterMethod);</span>
<span class="nc bnc" id="L395" title="All 4 branches missed.">        if (metadata.IHDR_interlaceMethod &lt; 0 ||</span>
            metadata.IHDR_interlaceMethod &gt; 1) {
<span class="nc" id="L397">            throw new IIOException(</span>
&quot;Only interlace methods 0 (node) and 1 (adam7) are defined in PNG 1.1&quot;);
        }
<span class="nc" id="L400">        cs.writeByte(metadata.IHDR_interlaceMethod);</span>
<span class="nc" id="L401">        cs.finish();</span>
<span class="nc" id="L402">    }</span>

    private void write_cHRM() throws IOException {
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (metadata.cHRM_present) {</span>
<span class="nc" id="L406">            ChunkStream cs = new ChunkStream(PNGImageReader.cHRM_TYPE, stream);</span>
<span class="nc" id="L407">            cs.writeInt(metadata.cHRM_whitePointX);</span>
<span class="nc" id="L408">            cs.writeInt(metadata.cHRM_whitePointY);</span>
<span class="nc" id="L409">            cs.writeInt(metadata.cHRM_redX);</span>
<span class="nc" id="L410">            cs.writeInt(metadata.cHRM_redY);</span>
<span class="nc" id="L411">            cs.writeInt(metadata.cHRM_greenX);</span>
<span class="nc" id="L412">            cs.writeInt(metadata.cHRM_greenY);</span>
<span class="nc" id="L413">            cs.writeInt(metadata.cHRM_blueX);</span>
<span class="nc" id="L414">            cs.writeInt(metadata.cHRM_blueY);</span>
<span class="nc" id="L415">            cs.finish();</span>
        }
<span class="nc" id="L417">    }</span>

    private void write_gAMA() throws IOException {
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (metadata.gAMA_present) {</span>
<span class="nc" id="L421">            ChunkStream cs = new ChunkStream(PNGImageReader.gAMA_TYPE, stream);</span>
<span class="nc" id="L422">            cs.writeInt(metadata.gAMA_gamma);</span>
<span class="nc" id="L423">            cs.finish();</span>
        }
<span class="nc" id="L425">    }</span>

    private void write_iCCP() throws IOException {
<span class="nc bnc" id="L428" title="All 2 branches missed.">        if (metadata.iCCP_present) {</span>
<span class="nc" id="L429">            ChunkStream cs = new ChunkStream(PNGImageReader.iCCP_TYPE, stream);</span>
<span class="nc" id="L430">            cs.writeBytes(metadata.iCCP_profileName);</span>
<span class="nc" id="L431">            cs.writeByte(0); // null terminator</span>

<span class="nc" id="L433">            cs.writeByte(metadata.iCCP_compressionMethod);</span>
<span class="nc" id="L434">            cs.write(metadata.iCCP_compressedProfile);</span>
<span class="nc" id="L435">            cs.finish();</span>
        }
<span class="nc" id="L437">    }</span>

    private void write_sBIT() throws IOException {
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (metadata.sBIT_present) {</span>
<span class="nc" id="L441">            ChunkStream cs = new ChunkStream(PNGImageReader.sBIT_TYPE, stream);</span>
<span class="nc" id="L442">            int colorType = metadata.IHDR_colorType;</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">            if (metadata.sBIT_colorType != colorType) {</span>
<span class="nc" id="L444">                processWarningOccurred(0,</span>
&quot;sBIT metadata has wrong color type.\n&quot; +
&quot;The chunk will not be written.&quot;);
<span class="nc" id="L447">                return;</span>
            }

<span class="nc bnc" id="L450" title="All 4 branches missed.">            if (colorType == PNGImageReader.PNG_COLOR_GRAY ||</span>
                colorType == PNGImageReader.PNG_COLOR_GRAY_ALPHA) {
<span class="nc" id="L452">                cs.writeByte(metadata.sBIT_grayBits);</span>
<span class="nc bnc" id="L453" title="All 6 branches missed.">            } else if (colorType == PNGImageReader.PNG_COLOR_RGB ||</span>
                       colorType == PNGImageReader.PNG_COLOR_PALETTE ||
                       colorType == PNGImageReader.PNG_COLOR_RGB_ALPHA) {
<span class="nc" id="L456">                cs.writeByte(metadata.sBIT_redBits);</span>
<span class="nc" id="L457">                cs.writeByte(metadata.sBIT_greenBits);</span>
<span class="nc" id="L458">                cs.writeByte(metadata.sBIT_blueBits);</span>
            }

<span class="nc bnc" id="L461" title="All 4 branches missed.">            if (colorType == PNGImageReader.PNG_COLOR_GRAY_ALPHA ||</span>
                colorType == PNGImageReader.PNG_COLOR_RGB_ALPHA) {
<span class="nc" id="L463">                cs.writeByte(metadata.sBIT_alphaBits);</span>
            }
<span class="nc" id="L465">            cs.finish();</span>
        }
<span class="nc" id="L467">    }</span>

    private void write_sRGB() throws IOException {
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (metadata.sRGB_present) {</span>
<span class="nc" id="L471">            ChunkStream cs = new ChunkStream(PNGImageReader.sRGB_TYPE, stream);</span>
<span class="nc" id="L472">            cs.writeByte(metadata.sRGB_renderingIntent);</span>
<span class="nc" id="L473">            cs.finish();</span>
        }
<span class="nc" id="L475">    }</span>

    private void write_PLTE() throws IOException {
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (metadata.PLTE_present) {</span>
<span class="nc bnc" id="L479" title="All 4 branches missed.">            if (metadata.IHDR_colorType == PNGImageReader.PNG_COLOR_GRAY ||</span>
              metadata.IHDR_colorType == PNGImageReader.PNG_COLOR_GRAY_ALPHA) {
                // PLTE cannot occur in a gray image

<span class="nc" id="L483">                processWarningOccurred(0,</span>
&quot;A PLTE chunk may not appear in a gray or gray alpha image.\n&quot; +
&quot;The chunk will not be written&quot;);
<span class="nc" id="L486">                return;</span>
            }

<span class="nc" id="L489">            ChunkStream cs = new ChunkStream(PNGImageReader.PLTE_TYPE, stream);</span>

<span class="nc" id="L491">            int numEntries = metadata.PLTE_red.length;</span>
<span class="nc" id="L492">            byte[] palette = new byte[numEntries*3];</span>
<span class="nc" id="L493">            int index = 0;</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">            for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc" id="L495">                palette[index++] = metadata.PLTE_red[i];</span>
<span class="nc" id="L496">                palette[index++] = metadata.PLTE_green[i];</span>
<span class="nc" id="L497">                palette[index++] = metadata.PLTE_blue[i];</span>
            }

<span class="nc" id="L500">            cs.write(palette);</span>
<span class="nc" id="L501">            cs.finish();</span>
        }
<span class="nc" id="L503">    }</span>

    private void write_hIST() throws IOException, IIOException {
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (metadata.hIST_present) {</span>
<span class="nc" id="L507">            ChunkStream cs = new ChunkStream(PNGImageReader.hIST_TYPE, stream);</span>

<span class="nc bnc" id="L509" title="All 2 branches missed.">            if (!metadata.PLTE_present) {</span>
<span class="nc" id="L510">                throw new IIOException(&quot;hIST chunk without PLTE chunk!&quot;);</span>
            }

<span class="nc" id="L513">            cs.writeChars(metadata.hIST_histogram,</span>
                          0, metadata.hIST_histogram.length);
<span class="nc" id="L515">            cs.finish();</span>
        }
<span class="nc" id="L517">    }</span>

    private void write_tRNS() throws IOException, IIOException {
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (metadata.tRNS_present) {</span>
<span class="nc" id="L521">            ChunkStream cs = new ChunkStream(PNGImageReader.tRNS_TYPE, stream);</span>
<span class="nc" id="L522">            int colorType = metadata.IHDR_colorType;</span>
<span class="nc" id="L523">            int chunkType = metadata.tRNS_colorType;</span>

            // Special case: image is RGB and chunk is Gray
            // Promote chunk contents to RGB
<span class="nc" id="L527">            int chunkRed = metadata.tRNS_red;</span>
<span class="nc" id="L528">            int chunkGreen = metadata.tRNS_green;</span>
<span class="nc" id="L529">            int chunkBlue = metadata.tRNS_blue;</span>
<span class="nc bnc" id="L530" title="All 4 branches missed.">            if (colorType == PNGImageReader.PNG_COLOR_RGB &amp;&amp;</span>
                chunkType == PNGImageReader.PNG_COLOR_GRAY) {
<span class="nc" id="L532">                chunkType = colorType;</span>
<span class="nc" id="L533">                chunkRed = chunkGreen = chunkBlue =</span>
                    metadata.tRNS_gray;
            }

<span class="nc bnc" id="L537" title="All 2 branches missed.">            if (chunkType != colorType) {</span>
<span class="nc" id="L538">                processWarningOccurred(0,</span>
&quot;tRNS metadata has incompatible color type.\n&quot; +
&quot;The chunk will not be written.&quot;);
<span class="nc" id="L541">                return;</span>
            }

<span class="nc bnc" id="L544" title="All 2 branches missed.">            if (colorType == PNGImageReader.PNG_COLOR_PALETTE) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">                if (!metadata.PLTE_present) {</span>
<span class="nc" id="L546">                    throw new IIOException(&quot;tRNS chunk without PLTE chunk!&quot;);</span>
                }
<span class="nc" id="L548">                cs.write(metadata.tRNS_alpha);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            } else if (colorType == PNGImageReader.PNG_COLOR_GRAY) {</span>
<span class="nc" id="L550">                cs.writeShort(metadata.tRNS_gray);</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">            } else if (colorType == PNGImageReader.PNG_COLOR_RGB) {</span>
<span class="nc" id="L552">                cs.writeShort(chunkRed);</span>
<span class="nc" id="L553">                cs.writeShort(chunkGreen);</span>
<span class="nc" id="L554">                cs.writeShort(chunkBlue);</span>
            } else {
<span class="nc" id="L556">                throw new IIOException(&quot;tRNS chunk for color type 4 or 6!&quot;);</span>
            }
<span class="nc" id="L558">            cs.finish();</span>
        }
<span class="nc" id="L560">    }</span>

    private void write_bKGD() throws IOException {
<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (metadata.bKGD_present) {</span>
<span class="nc" id="L564">            ChunkStream cs = new ChunkStream(PNGImageReader.bKGD_TYPE, stream);</span>
<span class="nc" id="L565">            int colorType = metadata.IHDR_colorType &amp; 0x3;</span>
<span class="nc" id="L566">            int chunkType = metadata.bKGD_colorType;</span>

            // Special case: image is RGB(A) and chunk is Gray
            // Promote chunk contents to RGB
<span class="nc" id="L570">            int chunkRed = metadata.bKGD_red;</span>
<span class="nc" id="L571">            int chunkGreen = metadata.bKGD_red;</span>
<span class="nc" id="L572">            int chunkBlue = metadata.bKGD_red;</span>
<span class="nc bnc" id="L573" title="All 4 branches missed.">            if (colorType == PNGImageReader.PNG_COLOR_RGB &amp;&amp;</span>
                chunkType == PNGImageReader.PNG_COLOR_GRAY) {
                // Make a gray bKGD chunk look like RGB
<span class="nc" id="L576">                chunkType = colorType;</span>
<span class="nc" id="L577">                chunkRed = chunkGreen = chunkBlue =</span>
                    metadata.bKGD_gray;
            }

            // Ignore status of alpha in colorType
<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (chunkType != colorType) {</span>
<span class="nc" id="L583">                processWarningOccurred(0,</span>
&quot;bKGD metadata has incompatible color type.\n&quot; +
&quot;The chunk will not be written.&quot;);
<span class="nc" id="L586">                return;</span>
            }

<span class="nc bnc" id="L589" title="All 2 branches missed.">            if (colorType == PNGImageReader.PNG_COLOR_PALETTE) {</span>
<span class="nc" id="L590">                cs.writeByte(metadata.bKGD_index);</span>
<span class="nc bnc" id="L591" title="All 4 branches missed.">            } else if (colorType == PNGImageReader.PNG_COLOR_GRAY ||</span>
                       colorType == PNGImageReader.PNG_COLOR_GRAY_ALPHA) {
<span class="nc" id="L593">                cs.writeShort(metadata.bKGD_gray);</span>
            } else { // colorType == PNGImageReader.PNG_COLOR_RGB ||
                     // colorType == PNGImageReader.PNG_COLOR_RGB_ALPHA
<span class="nc" id="L596">                cs.writeShort(chunkRed);</span>
<span class="nc" id="L597">                cs.writeShort(chunkGreen);</span>
<span class="nc" id="L598">                cs.writeShort(chunkBlue);</span>
            }
<span class="nc" id="L600">            cs.finish();</span>
        }
<span class="nc" id="L602">    }</span>

    private void write_pHYs() throws IOException {
<span class="nc bnc" id="L605" title="All 2 branches missed.">        if (metadata.pHYs_present) {</span>
<span class="nc" id="L606">            ChunkStream cs = new ChunkStream(PNGImageReader.pHYs_TYPE, stream);</span>
<span class="nc" id="L607">            cs.writeInt(metadata.pHYs_pixelsPerUnitXAxis);</span>
<span class="nc" id="L608">            cs.writeInt(metadata.pHYs_pixelsPerUnitYAxis);</span>
<span class="nc" id="L609">            cs.writeByte(metadata.pHYs_unitSpecifier);</span>
<span class="nc" id="L610">            cs.finish();</span>
        }
<span class="nc" id="L612">    }</span>

    private void write_sPLT() throws IOException {
<span class="nc bnc" id="L615" title="All 2 branches missed.">        if (metadata.sPLT_present) {</span>
<span class="nc" id="L616">            ChunkStream cs = new ChunkStream(PNGImageReader.sPLT_TYPE, stream);</span>

<span class="nc" id="L618">            cs.writeBytes(metadata.sPLT_paletteName);</span>
<span class="nc" id="L619">            cs.writeByte(0); // null terminator</span>

<span class="nc" id="L621">            cs.writeByte(metadata.sPLT_sampleDepth);</span>
<span class="nc" id="L622">            int numEntries = metadata.sPLT_red.length;</span>

<span class="nc bnc" id="L624" title="All 2 branches missed.">            if (metadata.sPLT_sampleDepth == 8) {</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">                for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc" id="L626">                    cs.writeByte(metadata.sPLT_red[i]);</span>
<span class="nc" id="L627">                    cs.writeByte(metadata.sPLT_green[i]);</span>
<span class="nc" id="L628">                    cs.writeByte(metadata.sPLT_blue[i]);</span>
<span class="nc" id="L629">                    cs.writeByte(metadata.sPLT_alpha[i]);</span>
<span class="nc" id="L630">                    cs.writeShort(metadata.sPLT_frequency[i]);</span>
                }
            } else { // sampleDepth == 16
<span class="nc bnc" id="L633" title="All 2 branches missed.">                for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc" id="L634">                    cs.writeShort(metadata.sPLT_red[i]);</span>
<span class="nc" id="L635">                    cs.writeShort(metadata.sPLT_green[i]);</span>
<span class="nc" id="L636">                    cs.writeShort(metadata.sPLT_blue[i]);</span>
<span class="nc" id="L637">                    cs.writeShort(metadata.sPLT_alpha[i]);</span>
<span class="nc" id="L638">                    cs.writeShort(metadata.sPLT_frequency[i]);</span>
                }
            }
<span class="nc" id="L641">            cs.finish();</span>
        }
<span class="nc" id="L643">    }</span>

    private void write_tIME() throws IOException {
<span class="nc bnc" id="L646" title="All 2 branches missed.">        if (metadata.tIME_present) {</span>
<span class="nc" id="L647">            ChunkStream cs = new ChunkStream(PNGImageReader.tIME_TYPE, stream);</span>
<span class="nc" id="L648">            cs.writeShort(metadata.tIME_year);</span>
<span class="nc" id="L649">            cs.writeByte(metadata.tIME_month);</span>
<span class="nc" id="L650">            cs.writeByte(metadata.tIME_day);</span>
<span class="nc" id="L651">            cs.writeByte(metadata.tIME_hour);</span>
<span class="nc" id="L652">            cs.writeByte(metadata.tIME_minute);</span>
<span class="nc" id="L653">            cs.writeByte(metadata.tIME_second);</span>
<span class="nc" id="L654">            cs.finish();</span>
        }
<span class="nc" id="L656">    }</span>

    private void write_tEXt() throws IOException {
<span class="nc" id="L659">        Iterator keywordIter = metadata.tEXt_keyword.iterator();</span>
<span class="nc" id="L660">        Iterator textIter = metadata.tEXt_text.iterator();</span>

<span class="nc bnc" id="L662" title="All 2 branches missed.">        while (keywordIter.hasNext()) {</span>
<span class="nc" id="L663">            ChunkStream cs = new ChunkStream(PNGImageReader.tEXt_TYPE, stream);</span>
<span class="nc" id="L664">            String keyword = (String)keywordIter.next();</span>
<span class="nc" id="L665">            cs.writeBytes(keyword);</span>
<span class="nc" id="L666">            cs.writeByte(0);</span>

<span class="nc" id="L668">            String text = (String)textIter.next();</span>
<span class="nc" id="L669">            cs.writeBytes(text);</span>
<span class="nc" id="L670">            cs.finish();</span>
<span class="nc" id="L671">        }</span>
<span class="nc" id="L672">    }</span>

    private byte[] deflate(byte[] b) throws IOException {
<span class="nc" id="L675">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L676">        DeflaterOutputStream dos = new DeflaterOutputStream(baos);</span>
<span class="nc" id="L677">        dos.write(b);</span>
<span class="nc" id="L678">        dos.close();</span>
<span class="nc" id="L679">        return baos.toByteArray();</span>
    }

    private void write_iTXt() throws IOException {
<span class="nc" id="L683">        Iterator&lt;String&gt; keywordIter = metadata.iTXt_keyword.iterator();</span>
<span class="nc" id="L684">        Iterator&lt;Boolean&gt; flagIter = metadata.iTXt_compressionFlag.iterator();</span>
<span class="nc" id="L685">        Iterator&lt;Integer&gt; methodIter = metadata.iTXt_compressionMethod.iterator();</span>
<span class="nc" id="L686">        Iterator&lt;String&gt; languageIter = metadata.iTXt_languageTag.iterator();</span>
<span class="nc" id="L687">        Iterator&lt;String&gt; translatedKeywordIter =</span>
<span class="nc" id="L688">            metadata.iTXt_translatedKeyword.iterator();</span>
<span class="nc" id="L689">        Iterator&lt;String&gt; textIter = metadata.iTXt_text.iterator();</span>

<span class="nc bnc" id="L691" title="All 2 branches missed.">        while (keywordIter.hasNext()) {</span>
<span class="nc" id="L692">            ChunkStream cs = new ChunkStream(PNGImageReader.iTXt_TYPE, stream);</span>

<span class="nc" id="L694">            cs.writeBytes(keywordIter.next());</span>
<span class="nc" id="L695">            cs.writeByte(0);</span>

<span class="nc" id="L697">            Boolean compressed = flagIter.next();</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">            cs.writeByte(compressed ? 1 : 0);</span>

<span class="nc" id="L700">            cs.writeByte(methodIter.next().intValue());</span>

<span class="nc" id="L702">            cs.writeBytes(languageIter.next());</span>
<span class="nc" id="L703">            cs.writeByte(0);</span>


<span class="nc" id="L706">            cs.write(translatedKeywordIter.next().getBytes(&quot;UTF8&quot;));</span>
<span class="nc" id="L707">            cs.writeByte(0);</span>

<span class="nc" id="L709">            String text = textIter.next();</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">            if (compressed) {</span>
<span class="nc" id="L711">                cs.write(deflate(text.getBytes(&quot;UTF8&quot;)));</span>
            } else {
<span class="nc" id="L713">                cs.write(text.getBytes(&quot;UTF8&quot;));</span>
            }
<span class="nc" id="L715">            cs.finish();</span>
<span class="nc" id="L716">        }</span>
<span class="nc" id="L717">    }</span>

    private void write_zTXt() throws IOException {
<span class="nc" id="L720">        Iterator keywordIter = metadata.zTXt_keyword.iterator();</span>
<span class="nc" id="L721">        Iterator methodIter = metadata.zTXt_compressionMethod.iterator();</span>
<span class="nc" id="L722">        Iterator textIter = metadata.zTXt_text.iterator();</span>

<span class="nc bnc" id="L724" title="All 2 branches missed.">        while (keywordIter.hasNext()) {</span>
<span class="nc" id="L725">            ChunkStream cs = new ChunkStream(PNGImageReader.zTXt_TYPE, stream);</span>
<span class="nc" id="L726">            String keyword = (String)keywordIter.next();</span>
<span class="nc" id="L727">            cs.writeBytes(keyword);</span>
<span class="nc" id="L728">            cs.writeByte(0);</span>

<span class="nc" id="L730">            int compressionMethod = ((Integer)methodIter.next()).intValue();</span>
<span class="nc" id="L731">            cs.writeByte(compressionMethod);</span>

<span class="nc" id="L733">            String text = (String)textIter.next();</span>
<span class="nc" id="L734">            cs.write(deflate(text.getBytes(&quot;ISO-8859-1&quot;)));</span>
<span class="nc" id="L735">            cs.finish();</span>
<span class="nc" id="L736">        }</span>
<span class="nc" id="L737">    }</span>

    private void writeUnknownChunks() throws IOException {
<span class="nc" id="L740">        Iterator typeIter = metadata.unknownChunkType.iterator();</span>
<span class="nc" id="L741">        Iterator dataIter = metadata.unknownChunkData.iterator();</span>

<span class="nc bnc" id="L743" title="All 4 branches missed.">        while (typeIter.hasNext() &amp;&amp; dataIter.hasNext()) {</span>
<span class="nc" id="L744">            String type = (String)typeIter.next();</span>
<span class="nc" id="L745">            ChunkStream cs = new ChunkStream(chunkType(type), stream);</span>
<span class="nc" id="L746">            byte[] data = (byte[])dataIter.next();</span>
<span class="nc" id="L747">            cs.write(data);</span>
<span class="nc" id="L748">            cs.finish();</span>
<span class="nc" id="L749">        }</span>
<span class="nc" id="L750">    }</span>

    private static int chunkType(String typeString) {
<span class="nc" id="L753">        char c0 = typeString.charAt(0);</span>
<span class="nc" id="L754">        char c1 = typeString.charAt(1);</span>
<span class="nc" id="L755">        char c2 = typeString.charAt(2);</span>
<span class="nc" id="L756">        char c3 = typeString.charAt(3);</span>

<span class="nc" id="L758">        int type = (c0 &lt;&lt; 24) | (c1 &lt;&lt; 16) | (c2 &lt;&lt; 8) | c3;</span>
<span class="nc" id="L759">        return type;</span>
    }

    private void encodePass(ImageOutputStream os,
                            RenderedImage image,
                            int xOffset, int yOffset,
                            int xSkip, int ySkip) throws IOException {
<span class="nc" id="L766">        int minX = sourceXOffset;</span>
<span class="nc" id="L767">        int minY = sourceYOffset;</span>
<span class="nc" id="L768">        int width = sourceWidth;</span>
<span class="nc" id="L769">        int height = sourceHeight;</span>

        // Adjust offsets and skips based on source subsampling factors
<span class="nc" id="L772">        xOffset *= periodX;</span>
<span class="nc" id="L773">        xSkip *= periodX;</span>
<span class="nc" id="L774">        yOffset *= periodY;</span>
<span class="nc" id="L775">        ySkip *= periodY;</span>

        // Early exit if no data for this pass
<span class="nc" id="L778">        int hpixels = (width - xOffset + xSkip - 1)/xSkip;</span>
<span class="nc" id="L779">        int vpixels = (height - yOffset + ySkip - 1)/ySkip;</span>
<span class="nc bnc" id="L780" title="All 4 branches missed.">        if (hpixels == 0 || vpixels == 0) {</span>
<span class="nc" id="L781">            return;</span>
        }

        // Convert X offset and skip from pixels to samples
<span class="nc" id="L785">        xOffset *= numBands;</span>
<span class="nc" id="L786">        xSkip *= numBands;</span>

        // Create row buffers
<span class="nc" id="L789">        int samplesPerByte = 8/metadata.IHDR_bitDepth;</span>
<span class="nc" id="L790">        int numSamples = width*numBands;</span>
<span class="nc" id="L791">        int[] samples = new int[numSamples];</span>

<span class="nc" id="L793">        int bytesPerRow = hpixels*numBands;</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (metadata.IHDR_bitDepth &lt; 8) {</span>
<span class="nc" id="L795">            bytesPerRow = (bytesPerRow + samplesPerByte - 1)/samplesPerByte;</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">        } else if (metadata.IHDR_bitDepth == 16) {</span>
<span class="nc" id="L797">            bytesPerRow *= 2;</span>
        }

<span class="nc" id="L800">        IndexColorModel icm_gray_alpha = null;</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">        if (metadata.IHDR_colorType == PNGImageReader.PNG_COLOR_GRAY_ALPHA &amp;&amp;</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">            image.getColorModel() instanceof IndexColorModel)</span>
        {
            // reserve space for alpha samples
<span class="nc" id="L805">            bytesPerRow *= 2;</span>

            // will be used to calculate alpha value for the pixel
<span class="nc" id="L808">            icm_gray_alpha = (IndexColorModel)image.getColorModel();</span>
        }

<span class="nc" id="L811">        currRow = new byte[bytesPerRow + bpp];</span>
<span class="nc" id="L812">        prevRow = new byte[bytesPerRow + bpp];</span>
<span class="nc" id="L813">        filteredRows = new byte[5][bytesPerRow + bpp];</span>

<span class="nc" id="L815">        int bitDepth = metadata.IHDR_bitDepth;</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">        for (int row = minY + yOffset; row &lt; minY + height; row += ySkip) {</span>
<span class="nc" id="L817">            Rectangle rect = new Rectangle(minX, row, width, 1);</span>
<span class="nc" id="L818">            Raster ras = image.getData(rect);</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">            if (sourceBands != null) {</span>
<span class="nc" id="L820">                ras = ras.createChild(minX, row, width, 1, minX, row,</span>
                                      sourceBands);
            }

<span class="nc" id="L824">            ras.getPixels(minX, row, width, 1, samples);</span>

<span class="nc bnc" id="L826" title="All 2 branches missed.">            if (image.getColorModel().isAlphaPremultiplied()) {</span>
<span class="nc" id="L827">                WritableRaster wr = ras.createCompatibleWritableRaster();</span>
<span class="nc" id="L828">                wr.setPixels(wr.getMinX(), wr.getMinY(),</span>
<span class="nc" id="L829">                             wr.getWidth(), wr.getHeight(),</span>
                             samples);

<span class="nc" id="L832">                image.getColorModel().coerceData(wr, false);</span>
<span class="nc" id="L833">                wr.getPixels(wr.getMinX(), wr.getMinY(),</span>
<span class="nc" id="L834">                             wr.getWidth(), wr.getHeight(),</span>
                             samples);
            }

            // Reorder palette data if necessary
<span class="nc" id="L839">            int[] paletteOrder = metadata.PLTE_order;</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">            if (paletteOrder != null) {</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">                for (int i = 0; i &lt; numSamples; i++) {</span>
<span class="nc" id="L842">                    samples[i] = paletteOrder[samples[i]];</span>
                }
            }

<span class="nc" id="L846">            int count = bpp; // leave first 'bpp' bytes zero</span>
<span class="nc" id="L847">            int pos = 0;</span>
<span class="nc" id="L848">            int tmp = 0;</span>

<span class="nc bnc" id="L850" title="All 4 branches missed.">            switch (bitDepth) {</span>
            case 1: case 2: case 4:
                // Image can only have a single band

<span class="nc" id="L854">                int mask = samplesPerByte - 1;</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">                for (int s = xOffset; s &lt; numSamples; s += xSkip) {</span>
<span class="nc" id="L856">                    byte val = scale0[samples[s]];</span>
<span class="nc" id="L857">                    tmp = (tmp &lt;&lt; bitDepth) | val;</span>

<span class="nc bnc" id="L859" title="All 2 branches missed.">                    if ((pos++ &amp; mask) == mask) {</span>
<span class="nc" id="L860">                        currRow[count++] = (byte)tmp;</span>
<span class="nc" id="L861">                        tmp = 0;</span>
<span class="nc" id="L862">                        pos = 0;</span>
                    }
                }

                // Left shift the last byte
<span class="nc bnc" id="L867" title="All 2 branches missed.">                if ((pos &amp; mask) != 0) {</span>
<span class="nc" id="L868">                    tmp &lt;&lt;= ((8/bitDepth) - pos)*bitDepth;</span>
<span class="nc" id="L869">                    currRow[count++] = (byte)tmp;</span>
                }
                break;

            case 8:
<span class="nc bnc" id="L874" title="All 2 branches missed.">                if (numBands == 1) {</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">                    for (int s = xOffset; s &lt; numSamples; s += xSkip) {</span>
<span class="nc" id="L876">                        currRow[count++] = scale0[samples[s]];</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">                        if (icm_gray_alpha != null) {</span>
<span class="nc" id="L878">                            currRow[count++] =</span>
<span class="nc" id="L879">                                scale0[icm_gray_alpha.getAlpha(0xff &amp; samples[s])];</span>
                        }
                    }
                } else {
<span class="nc bnc" id="L883" title="All 2 branches missed.">                    for (int s = xOffset; s &lt; numSamples; s += xSkip) {</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                        for (int b = 0; b &lt; numBands; b++) {</span>
<span class="nc" id="L885">                            currRow[count++] = scale[b][samples[s + b]];</span>
                        }
                    }
                }
<span class="nc" id="L889">                break;</span>

            case 16:
<span class="nc bnc" id="L892" title="All 2 branches missed.">                for (int s = xOffset; s &lt; numSamples; s += xSkip) {</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">                    for (int b = 0; b &lt; numBands; b++) {</span>
<span class="nc" id="L894">                        currRow[count++] = scaleh[b][samples[s + b]];</span>
<span class="nc" id="L895">                        currRow[count++] = scalel[b][samples[s + b]];</span>
                    }
                }
                break;
            }

            // Perform filtering
<span class="nc" id="L902">            int filterType = rowFilter.filterRow(metadata.IHDR_colorType,</span>
                                                 currRow, prevRow,
                                                 filteredRows,
                                                 bytesPerRow, bpp);

<span class="nc" id="L907">            os.write(filterType);</span>
<span class="nc" id="L908">            os.write(filteredRows[filterType], bpp, bytesPerRow);</span>

            // Swap current and previous rows
<span class="nc" id="L911">            byte[] swap = currRow;</span>
<span class="nc" id="L912">            currRow = prevRow;</span>
<span class="nc" id="L913">            prevRow = swap;</span>

<span class="nc" id="L915">            pixelsDone += hpixels;</span>
<span class="nc" id="L916">            processImageProgress(100.0F*pixelsDone/totalPixels);</span>

            // If write has been aborted, just return;
            // processWriteAborted will be called later
<span class="nc bnc" id="L920" title="All 2 branches missed.">            if (abortRequested()) {</span>
<span class="nc" id="L921">                return;</span>
            }
        }
<span class="nc" id="L924">    }</span>

    // Use sourceXOffset, etc.
    private void write_IDAT(RenderedImage image) throws IOException {
<span class="nc" id="L928">        IDATOutputStream ios = new IDATOutputStream(stream, 32768);</span>
        try {
<span class="nc bnc" id="L930" title="All 2 branches missed.">            if (metadata.IHDR_interlaceMethod == 1) {</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">                for (int i = 0; i &lt; 7; i++) {</span>
<span class="nc" id="L932">                    encodePass(ios, image,</span>
                               PNGImageReader.adam7XOffset[i],
                               PNGImageReader.adam7YOffset[i],
                               PNGImageReader.adam7XSubsampling[i],
                               PNGImageReader.adam7YSubsampling[i]);
<span class="nc bnc" id="L937" title="All 2 branches missed.">                    if (abortRequested()) {</span>
<span class="nc" id="L938">                        break;</span>
                    }
                }
            } else {
<span class="nc" id="L942">                encodePass(ios, image, 0, 0, 1, 1);</span>
            }
        } finally {
<span class="nc" id="L945">            ios.finish();</span>
<span class="nc" id="L946">        }</span>
<span class="nc" id="L947">    }</span>

    private void writeIEND() throws IOException {
<span class="nc" id="L950">        ChunkStream cs = new ChunkStream(PNGImageReader.IEND_TYPE, stream);</span>
<span class="nc" id="L951">        cs.finish();</span>
<span class="nc" id="L952">    }</span>

    // Check two int arrays for value equality, always returns false
    // if either array is null
    private boolean equals(int[] s0, int[] s1) {
<span class="nc bnc" id="L957" title="All 4 branches missed.">        if (s0 == null || s1 == null) {</span>
<span class="nc" id="L958">            return false;</span>
        }
<span class="nc bnc" id="L960" title="All 2 branches missed.">        if (s0.length != s1.length) {</span>
<span class="nc" id="L961">            return false;</span>
        }
<span class="nc bnc" id="L963" title="All 2 branches missed.">        for (int i = 0; i &lt; s0.length; i++) {</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">            if (s0[i] != s1[i]) {</span>
<span class="nc" id="L965">                return false;</span>
            }
        }
<span class="nc" id="L968">        return true;</span>
    }

    // Initialize the scale/scale0 or scaleh/scalel arrays to
    // hold the results of scaling an input value to the desired
    // output bit depth
    private void initializeScaleTables(int[] sampleSize) {
<span class="nc" id="L975">        int bitDepth = metadata.IHDR_bitDepth;</span>

        // If the existing tables are still valid, just return
<span class="nc bnc" id="L978" title="All 2 branches missed.">        if (bitDepth == scalingBitDepth &amp;&amp;</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">            equals(sampleSize, this.sampleSize)) {</span>
<span class="nc" id="L980">            return;</span>
        }

        // Compute new tables
<span class="nc" id="L984">        this.sampleSize = sampleSize;</span>
<span class="nc" id="L985">        this.scalingBitDepth = bitDepth;</span>
<span class="nc" id="L986">        int maxOutSample = (1 &lt;&lt; bitDepth) - 1;</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">        if (bitDepth &lt;= 8) {</span>
<span class="nc" id="L988">            scale = new byte[numBands][];</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">            for (int b = 0; b &lt; numBands; b++) {</span>
<span class="nc" id="L990">                int maxInSample = (1 &lt;&lt; sampleSize[b]) - 1;</span>
<span class="nc" id="L991">                int halfMaxInSample = maxInSample/2;</span>
<span class="nc" id="L992">                scale[b] = new byte[maxInSample + 1];</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">                for (int s = 0; s &lt;= maxInSample; s++) {</span>
<span class="nc" id="L994">                    scale[b][s] =</span>
                        (byte)((s*maxOutSample + halfMaxInSample)/maxInSample);
                }
            }
<span class="nc" id="L998">            scale0 = scale[0];</span>
<span class="nc" id="L999">            scaleh = scalel = null;</span>
        } else { // bitDepth == 16
            // Divide scaling table into high and low bytes
<span class="nc" id="L1002">            scaleh = new byte[numBands][];</span>
<span class="nc" id="L1003">            scalel = new byte[numBands][];</span>

<span class="nc bnc" id="L1005" title="All 2 branches missed.">            for (int b = 0; b &lt; numBands; b++) {</span>
<span class="nc" id="L1006">                int maxInSample = (1 &lt;&lt; sampleSize[b]) - 1;</span>
<span class="nc" id="L1007">                int halfMaxInSample = maxInSample/2;</span>
<span class="nc" id="L1008">                scaleh[b] = new byte[maxInSample + 1];</span>
<span class="nc" id="L1009">                scalel[b] = new byte[maxInSample + 1];</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">                for (int s = 0; s &lt;= maxInSample; s++) {</span>
<span class="nc" id="L1011">                    int val = (s*maxOutSample + halfMaxInSample)/maxInSample;</span>
<span class="nc" id="L1012">                    scaleh[b][s] = (byte)(val &gt;&gt; 8);</span>
<span class="nc" id="L1013">                    scalel[b][s] = (byte)(val &amp; 0xff);</span>
                }
            }
<span class="nc" id="L1016">            scale = null;</span>
<span class="nc" id="L1017">            scale0 = null;</span>
        }
<span class="nc" id="L1019">    }</span>

    public void write(IIOMetadata streamMetadata,
                      IIOImage image,
                      ImageWriteParam param) throws IIOException {
<span class="nc bnc" id="L1024" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L1025">            throw new IllegalStateException(&quot;output == null!&quot;);</span>
        }
<span class="nc bnc" id="L1027" title="All 2 branches missed.">        if (image == null) {</span>
<span class="nc" id="L1028">            throw new IllegalArgumentException(&quot;image == null!&quot;);</span>
        }
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (image.hasRaster()) {</span>
<span class="nc" id="L1031">            throw new UnsupportedOperationException(&quot;image has a Raster!&quot;);</span>
        }

<span class="nc" id="L1034">        RenderedImage im = image.getRenderedImage();</span>
<span class="nc" id="L1035">        SampleModel sampleModel = im.getSampleModel();</span>
<span class="nc" id="L1036">        this.numBands = sampleModel.getNumBands();</span>

        // Set source region and subsampling to default values
<span class="nc" id="L1039">        this.sourceXOffset = im.getMinX();</span>
<span class="nc" id="L1040">        this.sourceYOffset = im.getMinY();</span>
<span class="nc" id="L1041">        this.sourceWidth = im.getWidth();</span>
<span class="nc" id="L1042">        this.sourceHeight = im.getHeight();</span>
<span class="nc" id="L1043">        this.sourceBands = null;</span>
<span class="nc" id="L1044">        this.periodX = 1;</span>
<span class="nc" id="L1045">        this.periodY = 1;</span>

<span class="nc bnc" id="L1047" title="All 2 branches missed.">        if (param != null) {</span>
            // Get source region and subsampling factors
<span class="nc" id="L1049">            Rectangle sourceRegion = param.getSourceRegion();</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            if (sourceRegion != null) {</span>
<span class="nc" id="L1051">                Rectangle imageBounds = new Rectangle(im.getMinX(),</span>
<span class="nc" id="L1052">                                                      im.getMinY(),</span>
<span class="nc" id="L1053">                                                      im.getWidth(),</span>
<span class="nc" id="L1054">                                                      im.getHeight());</span>
                // Clip to actual image bounds
<span class="nc" id="L1056">                sourceRegion = sourceRegion.intersection(imageBounds);</span>
<span class="nc" id="L1057">                sourceXOffset = sourceRegion.x;</span>
<span class="nc" id="L1058">                sourceYOffset = sourceRegion.y;</span>
<span class="nc" id="L1059">                sourceWidth = sourceRegion.width;</span>
<span class="nc" id="L1060">                sourceHeight = sourceRegion.height;</span>
            }

            // Adjust for subsampling offsets
<span class="nc" id="L1064">            int gridX = param.getSubsamplingXOffset();</span>
<span class="nc" id="L1065">            int gridY = param.getSubsamplingYOffset();</span>
<span class="nc" id="L1066">            sourceXOffset += gridX;</span>
<span class="nc" id="L1067">            sourceYOffset += gridY;</span>
<span class="nc" id="L1068">            sourceWidth -= gridX;</span>
<span class="nc" id="L1069">            sourceHeight -= gridY;</span>

            // Get subsampling factors
<span class="nc" id="L1072">            periodX = param.getSourceXSubsampling();</span>
<span class="nc" id="L1073">            periodY = param.getSourceYSubsampling();</span>

<span class="nc" id="L1075">            int[] sBands = param.getSourceBands();</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">            if (sBands != null) {</span>
<span class="nc" id="L1077">                sourceBands = sBands;</span>
<span class="nc" id="L1078">                numBands = sourceBands.length;</span>
            }
        }

        // Compute output dimensions
<span class="nc" id="L1083">        int destWidth = (sourceWidth + periodX - 1)/periodX;</span>
<span class="nc" id="L1084">        int destHeight = (sourceHeight + periodY - 1)/periodY;</span>
<span class="nc bnc" id="L1085" title="All 4 branches missed.">        if (destWidth &lt;= 0 || destHeight &lt;= 0) {</span>
<span class="nc" id="L1086">            throw new IllegalArgumentException(&quot;Empty source region!&quot;);</span>
        }

        // Compute total number of pixels for progress notification
<span class="nc" id="L1090">        this.totalPixels = destWidth*destHeight;</span>
<span class="nc" id="L1091">        this.pixelsDone = 0;</span>

        // Create metadata
<span class="nc" id="L1094">        IIOMetadata imd = image.getMetadata();</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">        if (imd != null) {</span>
<span class="nc" id="L1096">            metadata = (PNGMetadata)convertImageMetadata(imd,</span>
<span class="nc" id="L1097">                               ImageTypeSpecifier.createFromRenderedImage(im),</span>
                                                         null);
        } else {
<span class="nc" id="L1100">            metadata = new PNGMetadata();</span>
        }

<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (param != null) {</span>
            // Use Adam7 interlacing if set in write param
<span class="nc bnc" id="L1105" title="All 3 branches missed.">            switch (param.getProgressiveMode()) {</span>
            case ImageWriteParam.MODE_DEFAULT:
<span class="nc" id="L1107">                metadata.IHDR_interlaceMethod = 1;</span>
<span class="nc" id="L1108">                break;</span>
            case ImageWriteParam.MODE_DISABLED:
<span class="nc" id="L1110">                metadata.IHDR_interlaceMethod = 0;</span>
                break;
                // MODE_COPY_FROM_METADATA should alreay be taken care of
                // MODE_EXPLICIT is not allowed
            }
        }

        // Initialize bitDepth and colorType
<span class="nc" id="L1118">        metadata.initialize(new ImageTypeSpecifier(im), numBands);</span>

        // Overwrite IHDR width and height values with values from image
<span class="nc" id="L1121">        metadata.IHDR_width = destWidth;</span>
<span class="nc" id="L1122">        metadata.IHDR_height = destHeight;</span>

<span class="nc bnc" id="L1124" title="All 2 branches missed.">        this.bpp = numBands*((metadata.IHDR_bitDepth == 16) ? 2 : 1);</span>

        // Initialize scaling tables for this image
<span class="nc" id="L1127">        initializeScaleTables(sampleModel.getSampleSize());</span>

<span class="nc" id="L1129">        clearAbortRequest();</span>

<span class="nc" id="L1131">        processImageStarted(0);</span>

        try {
<span class="nc" id="L1134">            write_magic();</span>
<span class="nc" id="L1135">            write_IHDR();</span>

<span class="nc" id="L1137">            write_cHRM();</span>
<span class="nc" id="L1138">            write_gAMA();</span>
<span class="nc" id="L1139">            write_iCCP();</span>
<span class="nc" id="L1140">            write_sBIT();</span>
<span class="nc" id="L1141">            write_sRGB();</span>

<span class="nc" id="L1143">            write_PLTE();</span>

<span class="nc" id="L1145">            write_hIST();</span>
<span class="nc" id="L1146">            write_tRNS();</span>
<span class="nc" id="L1147">            write_bKGD();</span>

<span class="nc" id="L1149">            write_pHYs();</span>
<span class="nc" id="L1150">            write_sPLT();</span>
<span class="nc" id="L1151">            write_tIME();</span>
<span class="nc" id="L1152">            write_tEXt();</span>
<span class="nc" id="L1153">            write_iTXt();</span>
<span class="nc" id="L1154">            write_zTXt();</span>

<span class="nc" id="L1156">            writeUnknownChunks();</span>

<span class="nc" id="L1158">            write_IDAT(im);</span>

<span class="nc bnc" id="L1160" title="All 2 branches missed.">            if (abortRequested()) {</span>
<span class="nc" id="L1161">                processWriteAborted();</span>
            } else {
                // Finish up and inform the listeners we are done
<span class="nc" id="L1164">                writeIEND();</span>
<span class="nc" id="L1165">                processImageComplete();</span>
            }
<span class="nc" id="L1167">        } catch (IOException e) {</span>
<span class="nc" id="L1168">            throw new IIOException(&quot;I/O error writing PNG file!&quot;, e);</span>
<span class="nc" id="L1169">        }</span>
<span class="nc" id="L1170">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>