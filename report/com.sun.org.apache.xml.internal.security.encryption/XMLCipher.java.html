<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>XMLCipher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.org.apache.xml.internal.security.encryption</a> &gt; <span class="el_source">XMLCipher.java</span></div><h1>XMLCipher.java</h1><pre class="source lang-java linenums">/*
 * reserved comment block
 * DO NOT REMOVE OR ALTER!
 */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.sun.org.apache.xml.internal.security.encryption;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SecureRandom;
import java.security.spec.MGF1ParameterSpec;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.OAEPParameterSpec;
import javax.crypto.spec.PSource;

import com.sun.org.apache.xml.internal.security.algorithms.JCEMapper;
import com.sun.org.apache.xml.internal.security.algorithms.MessageDigestAlgorithm;
import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException;
import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
import com.sun.org.apache.xml.internal.security.keys.KeyInfo;
import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolverException;
import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolverSpi;
import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.EncryptedKeyResolver;
import com.sun.org.apache.xml.internal.security.signature.XMLSignatureException;
import com.sun.org.apache.xml.internal.security.transforms.InvalidTransformException;
import com.sun.org.apache.xml.internal.security.transforms.TransformationException;
import com.sun.org.apache.xml.internal.security.utils.Base64;
import com.sun.org.apache.xml.internal.security.utils.Constants;
import com.sun.org.apache.xml.internal.security.utils.ElementProxy;
import com.sun.org.apache.xml.internal.security.utils.EncryptionConstants;
import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * &lt;code&gt;XMLCipher&lt;/code&gt; encrypts and decrypts the contents of
 * &lt;code&gt;Document&lt;/code&gt;s, &lt;code&gt;Element&lt;/code&gt;s and &lt;code&gt;Element&lt;/code&gt;
 * contents. It was designed to resemble &lt;code&gt;javax.crypto.Cipher&lt;/code&gt; in
 * order to facilitate understanding of its functioning.
 *
 * @author Axl Mattheus (Sun Microsystems)
 * @author Christian Geuer-Pollmann
 */
public class XMLCipher {

<span class="nc" id="L87">    private static java.util.logging.Logger log =</span>
<span class="nc" id="L88">        java.util.logging.Logger.getLogger(XMLCipher.class.getName());</span>

    /** Triple DES EDE (192 bit key) in CBC mode */
    public static final String TRIPLEDES =
        EncryptionConstants.ALGO_ID_BLOCKCIPHER_TRIPLEDES;

    /** AES 128 Cipher */
    public static final String AES_128 =
        EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES128;

    /** AES 256 Cipher */
    public static final String AES_256 =
        EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES256;

    /** AES 192 Cipher */
    public static final String AES_192 =
        EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES192;

    /** AES 128 GCM Cipher */
    public static final String AES_128_GCM =
        EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES128_GCM;

    /** AES 192 GCM Cipher */
    public static final String AES_192_GCM =
        EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES192_GCM;

    /** AES 256 GCM Cipher */
    public static final String AES_256_GCM =
        EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES256_GCM;

    /** RSA 1.5 Cipher */
    public static final String RSA_v1dot5 =
        EncryptionConstants.ALGO_ID_KEYTRANSPORT_RSA15;

    /** RSA OAEP Cipher */
    public static final String RSA_OAEP =
        EncryptionConstants.ALGO_ID_KEYTRANSPORT_RSAOAEP;

    /** RSA OAEP Cipher */
    public static final String RSA_OAEP_11 =
        EncryptionConstants.ALGO_ID_KEYTRANSPORT_RSAOAEP_11;

    /** DIFFIE_HELLMAN Cipher */
    public static final String DIFFIE_HELLMAN =
        EncryptionConstants.ALGO_ID_KEYAGREEMENT_DH;

    /** Triple DES EDE (192 bit key) in CBC mode KEYWRAP*/
    public static final String TRIPLEDES_KeyWrap =
        EncryptionConstants.ALGO_ID_KEYWRAP_TRIPLEDES;

    /** AES 128 Cipher KeyWrap */
    public static final String AES_128_KeyWrap =
        EncryptionConstants.ALGO_ID_KEYWRAP_AES128;

    /** AES 256 Cipher KeyWrap */
    public static final String AES_256_KeyWrap =
        EncryptionConstants.ALGO_ID_KEYWRAP_AES256;

    /** AES 192 Cipher KeyWrap */
    public static final String AES_192_KeyWrap =
        EncryptionConstants.ALGO_ID_KEYWRAP_AES192;

    /** SHA1 Cipher */
    public static final String SHA1 =
        Constants.ALGO_ID_DIGEST_SHA1;

    /** SHA256 Cipher */
    public static final String SHA256 =
        MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA256;

    /** SHA512 Cipher */
    public static final String SHA512 =
        MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA512;

    /** RIPEMD Cipher */
    public static final String RIPEMD_160 =
        MessageDigestAlgorithm.ALGO_ID_DIGEST_RIPEMD160;

    /** XML Signature NS */
    public static final String XML_DSIG =
        Constants.SignatureSpecNS;

    /** N14C_XML */
    public static final String N14C_XML =
        Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS;

    /** N14C_XML with comments*/
    public static final String N14C_XML_WITH_COMMENTS =
        Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS;

    /** N14C_XML exclusive */
    public static final String EXCL_XML_N14C =
        Canonicalizer.ALGO_ID_C14N_EXCL_OMIT_COMMENTS;

    /** N14C_XML exclusive with comments*/
    public static final String EXCL_XML_N14C_WITH_COMMENTS =
        Canonicalizer.ALGO_ID_C14N_EXCL_WITH_COMMENTS;

    /** N14C_PHYSICAL preserve the physical representation*/
    public static final String PHYSICAL_XML_N14C =
        Canonicalizer.ALGO_ID_C14N_PHYSICAL;

    /** Base64 encoding */
    public static final String BASE64_ENCODING =
        com.sun.org.apache.xml.internal.security.transforms.Transforms.TRANSFORM_BASE64_DECODE;

    /** ENCRYPT Mode */
    public static final int ENCRYPT_MODE = Cipher.ENCRYPT_MODE;

    /** DECRYPT Mode */
    public static final int DECRYPT_MODE = Cipher.DECRYPT_MODE;

    /** UNWRAP Mode */
    public static final int UNWRAP_MODE  = Cipher.UNWRAP_MODE;

    /** WRAP Mode */
    public static final int WRAP_MODE    = Cipher.WRAP_MODE;

    private static final String ENC_ALGORITHMS = TRIPLEDES + &quot;\n&quot; +
    AES_128 + &quot;\n&quot; + AES_256 + &quot;\n&quot; + AES_192 + &quot;\n&quot; + RSA_v1dot5 + &quot;\n&quot; +
    RSA_OAEP + &quot;\n&quot; + RSA_OAEP_11 + &quot;\n&quot; + TRIPLEDES_KeyWrap + &quot;\n&quot; +
    AES_128_KeyWrap + &quot;\n&quot; + AES_256_KeyWrap + &quot;\n&quot; + AES_192_KeyWrap + &quot;\n&quot; +
    AES_128_GCM + &quot;\n&quot; + AES_192_GCM + &quot;\n&quot; + AES_256_GCM + &quot;\n&quot;;

    /** Cipher created during initialisation that is used for encryption */
    private Cipher contextCipher;

    /** Mode that the XMLCipher object is operating in */
<span class="nc" id="L216">    private int cipherMode = Integer.MIN_VALUE;</span>

    /** URI of algorithm that is being used for cryptographic operation */
<span class="nc" id="L219">    private String algorithm = null;</span>

    /** Cryptographic provider requested by caller */
<span class="nc" id="L222">    private String requestedJCEProvider = null;</span>

    /** Holds c14n to serialize, if initialized then _always_ use this c14n to serialize */
    private Canonicalizer canon;

    /** Used for creation of DOM nodes in WRAP and ENCRYPT modes */
    private Document contextDocument;

    /** Instance of factory used to create XML Encryption objects */
    private Factory factory;

    /** Serializer class for going to/from UTF-8 */
    private Serializer serializer;

    /** Local copy of user's key */
    private Key key;

    /** Local copy of the kek (used to decrypt EncryptedKeys during a
     *  DECRYPT_MODE operation */
    private Key kek;

    // The EncryptedKey being built (part of a WRAP operation) or read
    // (part of an UNWRAP operation)
    private EncryptedKey ek;

    // The EncryptedData being built (part of a WRAP operation) or read
    // (part of an UNWRAP operation)
    private EncryptedData ed;

    private SecureRandom random;

    private boolean secureValidation;

    private String digestAlg;

    /** List of internal KeyResolvers for DECRYPT and UNWRAP modes. */
    private List&lt;KeyResolverSpi&gt; internalKeyResolvers;

    /**
     * Set the Serializer algorithm to use
     */
    public void setSerializer(Serializer serializer) {
<span class="nc" id="L264">        this.serializer = serializer;</span>
<span class="nc" id="L265">        serializer.setCanonicalizer(this.canon);</span>
<span class="nc" id="L266">    }</span>

    /**
     * Get the Serializer algorithm to use
     */
    public Serializer getSerializer() {
<span class="nc" id="L272">        return serializer;</span>
    }

    /**
     * Creates a new &lt;code&gt;XMLCipher&lt;/code&gt;.
     *
     * @param transformation    the name of the transformation, e.g.,
     *                          &lt;code&gt;XMLCipher.TRIPLEDES&lt;/code&gt;. If null the XMLCipher can only
     *                          be used for decrypt or unwrap operations where the encryption method
     *                          is defined in the &lt;code&gt;EncryptionMethod&lt;/code&gt; element.
     * @param provider          the JCE provider that supplies the transformation,
     *                          if null use the default provider.
     * @param canon             the name of the c14n algorithm, if
     *                          &lt;code&gt;null&lt;/code&gt; use standard serializer
     * @param digestMethod      An optional digestMethod to use.
     */
    private XMLCipher(
        String transformation,
        String provider,
        String canonAlg,
        String digestMethod
<span class="nc" id="L293">    ) throws XMLEncryptionException {</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L295">            log.log(java.util.logging.Level.FINE, &quot;Constructing XMLCipher...&quot;);</span>
        }

<span class="nc" id="L298">        factory = new Factory();</span>

<span class="nc" id="L300">        algorithm = transformation;</span>
<span class="nc" id="L301">        requestedJCEProvider = provider;</span>
<span class="nc" id="L302">        digestAlg = digestMethod;</span>

        // Create a canonicalizer - used when serializing DOM to octets
        // prior to encryption (and for the reverse)

        try {
<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (canonAlg == null) {</span>
                // The default is to preserve the physical representation.
<span class="nc" id="L310">                this.canon = Canonicalizer.getInstance(Canonicalizer.ALGO_ID_C14N_PHYSICAL);</span>
            } else {
<span class="nc" id="L312">                this.canon = Canonicalizer.getInstance(canonAlg);</span>
            }
<span class="nc" id="L314">        } catch (InvalidCanonicalizerException ice) {</span>
<span class="nc" id="L315">            throw new XMLEncryptionException(&quot;empty&quot;, ice);</span>
<span class="nc" id="L316">        }</span>

<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (serializer == null) {</span>
<span class="nc" id="L319">            serializer = new DocumentSerializer();</span>
        }
<span class="nc" id="L321">        serializer.setCanonicalizer(this.canon);</span>

<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (transformation != null) {</span>
<span class="nc" id="L324">            contextCipher = constructCipher(transformation, digestMethod);</span>
        }
<span class="nc" id="L326">    }</span>

    /**
     * Checks to ensure that the supplied algorithm is valid.
     *
     * @param algorithm the algorithm to check.
     * @return true if the algorithm is valid, otherwise false.
     * @since 1.0.
     */
    private static boolean isValidEncryptionAlgorithm(String algorithm) {
<span class="nc" id="L336">        return (</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">            algorithm.equals(TRIPLEDES) ||</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            algorithm.equals(AES_128) ||</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">            algorithm.equals(AES_256) ||</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            algorithm.equals(AES_192) ||</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">            algorithm.equals(AES_128_GCM) ||</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">            algorithm.equals(AES_192_GCM) ||</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            algorithm.equals(AES_256_GCM) ||</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            algorithm.equals(RSA_v1dot5) ||</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            algorithm.equals(RSA_OAEP) ||</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            algorithm.equals(RSA_OAEP_11) ||</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            algorithm.equals(TRIPLEDES_KeyWrap) ||</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">            algorithm.equals(AES_128_KeyWrap) ||</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">            algorithm.equals(AES_256_KeyWrap) ||</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            algorithm.equals(AES_192_KeyWrap)</span>
        );
    }

    /**
     * Validate the transformation argument of getInstance or getProviderInstance
     *
     * @param transformation the name of the transformation, e.g.,
     *   &lt;code&gt;XMLCipher.TRIPLEDES&lt;/code&gt; which is shorthand for
     *   &amp;quot;http://www.w3.org/2001/04/xmlenc#tripledes-cbc&amp;quot;
     */
    private static void validateTransformation(String transformation) {
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (null == transformation) {</span>
<span class="nc" id="L363">            throw new NullPointerException(&quot;Transformation unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (!isValidEncryptionAlgorithm(transformation)) {</span>
<span class="nc" id="L366">            log.log(java.util.logging.Level.WARNING, &quot;Algorithm non-standard, expected one of &quot; + ENC_ALGORITHMS);</span>
        }
<span class="nc" id="L368">    }</span>

    /**
     * Returns an &lt;code&gt;XMLCipher&lt;/code&gt; that implements the specified
     * transformation and operates on the specified context document.
     * &lt;p&gt;
     * If the default provider package supplies an implementation of the
     * requested transformation, an instance of Cipher containing that
     * implementation is returned. If the transformation is not available in
     * the default provider package, other provider packages are searched.
     * &lt;p&gt;
     * &lt;b&gt;NOTE&lt;sub&gt;1&lt;/sub&gt;:&lt;/b&gt; The transformation name does not follow the same
     * pattern as that outlined in the Java Cryptography Extension Reference
     * Guide but rather that specified by the XML Encryption Syntax and
     * Processing document. The rational behind this is to make it easier for a
     * novice at writing Java Encryption software to use the library.
     * &lt;p&gt;
     * &lt;b&gt;NOTE&lt;sub&gt;2&lt;/sub&gt;:&lt;/b&gt; &lt;code&gt;getInstance()&lt;/code&gt; does not follow the
     * same pattern regarding exceptional conditions as that used in
     * &lt;code&gt;javax.crypto.Cipher&lt;/code&gt;. Instead, it only throws an
     * &lt;code&gt;XMLEncryptionException&lt;/code&gt; which wraps an underlying exception.
     * The stack trace from the exception should be self explanatory.
     *
     * @param transformation the name of the transformation, e.g.,
     *   &lt;code&gt;XMLCipher.TRIPLEDES&lt;/code&gt; which is shorthand for
     *   &amp;quot;http://www.w3.org/2001/04/xmlenc#tripledes-cbc&amp;quot;
     * @throws XMLEncryptionException
     * @return the XMLCipher
     * @see javax.crypto.Cipher#getInstance(java.lang.String)
     */
    public static XMLCipher getInstance(String transformation) throws XMLEncryptionException {
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L400">            log.log(java.util.logging.Level.FINE, &quot;Getting XMLCipher with transformation&quot;);</span>
        }
<span class="nc" id="L402">        validateTransformation(transformation);</span>
<span class="nc" id="L403">        return new XMLCipher(transformation, null, null, null);</span>
    }

    /**
     * Returns an &lt;code&gt;XMLCipher&lt;/code&gt; that implements the specified
     * transformation, operates on the specified context document and serializes
     * the document with the specified canonicalization algorithm before it
     * encrypts the document.
     * &lt;p&gt;
     *
     * @param transformation    the name of the transformation
     * @param canon             the name of the c14n algorithm, if &lt;code&gt;null&lt;/code&gt; use
     *                          standard serializer
     * @return the XMLCipher
     * @throws XMLEncryptionException
     */
    public static XMLCipher getInstance(String transformation, String canon)
        throws XMLEncryptionException {
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L422">            log.log(java.util.logging.Level.FINE, &quot;Getting XMLCipher with transformation and c14n algorithm&quot;);</span>
        }
<span class="nc" id="L424">        validateTransformation(transformation);</span>
<span class="nc" id="L425">        return new XMLCipher(transformation, null, canon, null);</span>
    }

    /**
     * Returns an &lt;code&gt;XMLCipher&lt;/code&gt; that implements the specified
     * transformation, operates on the specified context document and serializes
     * the document with the specified canonicalization algorithm before it
     * encrypts the document.
     * &lt;p&gt;
     *
     * @param transformation    the name of the transformation
     * @param canon             the name of the c14n algorithm, if &lt;code&gt;null&lt;/code&gt; use
     *                          standard serializer
     * @param digestMethod      An optional digestMethod to use
     * @return the XMLCipher
     * @throws XMLEncryptionException
     */
    public static XMLCipher getInstance(String transformation, String canon, String digestMethod)
        throws XMLEncryptionException {
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L445">            log.log(java.util.logging.Level.FINE, &quot;Getting XMLCipher with transformation and c14n algorithm&quot;);</span>
        }
<span class="nc" id="L447">        validateTransformation(transformation);</span>
<span class="nc" id="L448">        return new XMLCipher(transformation, null, canon, digestMethod);</span>
    }

    /**
     * Returns an &lt;code&gt;XMLCipher&lt;/code&gt; that implements the specified
     * transformation and operates on the specified context document.
     *
     * @param transformation    the name of the transformation
     * @param provider          the JCE provider that supplies the transformation
     * @return the XMLCipher
     * @throws XMLEncryptionException
     */
    public static XMLCipher getProviderInstance(String transformation, String provider)
        throws XMLEncryptionException {
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L463">            log.log(java.util.logging.Level.FINE, &quot;Getting XMLCipher with transformation and provider&quot;);</span>
        }
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (null == provider) {</span>
<span class="nc" id="L466">            throw new NullPointerException(&quot;Provider unexpectedly null..&quot;);</span>
        }
<span class="nc" id="L468">        validateTransformation(transformation);</span>
<span class="nc" id="L469">        return new XMLCipher(transformation, provider, null, null);</span>
    }

    /**
     * Returns an &lt;code&gt;XMLCipher&lt;/code&gt; that implements the specified
     * transformation, operates on the specified context document and serializes
     * the document with the specified canonicalization algorithm before it
     * encrypts the document.
     * &lt;p&gt;
     *
     * @param transformation    the name of the transformation
     * @param provider          the JCE provider that supplies the transformation
     * @param canon             the name of the c14n algorithm, if &lt;code&gt;null&lt;/code&gt; use standard
     *                          serializer
     * @return the XMLCipher
     * @throws XMLEncryptionException
     */
    public static XMLCipher getProviderInstance(
        String transformation, String provider, String canon
    ) throws XMLEncryptionException {
<span class="nc bnc" id="L489" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L490">            log.log(java.util.logging.Level.FINE, &quot;Getting XMLCipher with transformation, provider and c14n algorithm&quot;);</span>
        }
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (null == provider) {</span>
<span class="nc" id="L493">            throw new NullPointerException(&quot;Provider unexpectedly null..&quot;);</span>
        }
<span class="nc" id="L495">        validateTransformation(transformation);</span>
<span class="nc" id="L496">        return new XMLCipher(transformation, provider, canon, null);</span>
    }

    /**
     * Returns an &lt;code&gt;XMLCipher&lt;/code&gt; that implements the specified
     * transformation, operates on the specified context document and serializes
     * the document with the specified canonicalization algorithm before it
     * encrypts the document.
     * &lt;p&gt;
     *
     * @param transformation    the name of the transformation
     * @param provider          the JCE provider that supplies the transformation
     * @param canon             the name of the c14n algorithm, if &lt;code&gt;null&lt;/code&gt; use standard
     *                          serializer
     * @param digestMethod      An optional digestMethod to use
     * @return the XMLCipher
     * @throws XMLEncryptionException
     */
    public static XMLCipher getProviderInstance(
        String transformation, String provider, String canon, String digestMethod
    ) throws XMLEncryptionException {
<span class="nc bnc" id="L517" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L518">            log.log(java.util.logging.Level.FINE, &quot;Getting XMLCipher with transformation, provider and c14n algorithm&quot;);</span>
        }
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (null == provider) {</span>
<span class="nc" id="L521">            throw new NullPointerException(&quot;Provider unexpectedly null..&quot;);</span>
        }
<span class="nc" id="L523">        validateTransformation(transformation);</span>
<span class="nc" id="L524">        return new XMLCipher(transformation, provider, canon, digestMethod);</span>
    }

    /**
     * Returns an &lt;code&gt;XMLCipher&lt;/code&gt; that implements no specific
     * transformation, and can therefore only be used for decrypt or
     * unwrap operations where the encryption method is defined in the
     * &lt;code&gt;EncryptionMethod&lt;/code&gt; element.
     *
     * @return The XMLCipher
     * @throws XMLEncryptionException
     */
    public static XMLCipher getInstance() throws XMLEncryptionException {
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L538">            log.log(java.util.logging.Level.FINE, &quot;Getting XMLCipher with no arguments&quot;);</span>
        }
<span class="nc" id="L540">        return new XMLCipher(null, null, null, null);</span>
    }

    /**
     * Returns an &lt;code&gt;XMLCipher&lt;/code&gt; that implements no specific
     * transformation, and can therefore only be used for decrypt or
     * unwrap operations where the encryption method is defined in the
     * &lt;code&gt;EncryptionMethod&lt;/code&gt; element.
     *
     * Allows the caller to specify a provider that will be used for
     * cryptographic operations.
     *
     * @param provider          the JCE provider that supplies the transformation
     * @return the XMLCipher
     * @throws XMLEncryptionException
     */
    public static XMLCipher getProviderInstance(String provider) throws XMLEncryptionException {
<span class="nc bnc" id="L557" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L558">            log.log(java.util.logging.Level.FINE, &quot;Getting XMLCipher with provider&quot;);</span>
        }
<span class="nc" id="L560">        return new XMLCipher(null, provider, null, null);</span>
    }

    /**
     * Initializes this cipher with a key.
     * &lt;p&gt;
     * The cipher is initialized for one of the following four operations:
     * encryption, decryption, key wrapping or key unwrapping, depending on the
     * value of opmode.
     *
     * For WRAP and ENCRYPT modes, this also initialises the internal
     * EncryptedKey or EncryptedData (with a CipherValue)
     * structure that will be used during the ensuing operations.  This
     * can be obtained (in order to modify KeyInfo elements etc. prior to
     * finalising the encryption) by calling
     * {@link #getEncryptedData} or {@link #getEncryptedKey}.
     *
     * @param opmode the operation mode of this cipher (this is one of the
     *   following: ENCRYPT_MODE, DECRYPT_MODE, WRAP_MODE or UNWRAP_MODE)
     * @param key
     * @see javax.crypto.Cipher#init(int, java.security.Key)
     * @throws XMLEncryptionException
     */
    public void init(int opmode, Key key) throws XMLEncryptionException {
        // sanity checks
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L586">            log.log(java.util.logging.Level.FINE, &quot;Initializing XMLCipher...&quot;);</span>
        }

<span class="nc" id="L589">        ek = null;</span>
<span class="nc" id="L590">        ed = null;</span>

<span class="nc bnc" id="L592" title="All 5 branches missed.">        switch (opmode) {</span>

        case ENCRYPT_MODE :
<span class="nc bnc" id="L595" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L596">                log.log(java.util.logging.Level.FINE, &quot;opmode = ENCRYPT_MODE&quot;);</span>
            }
<span class="nc" id="L598">            ed = createEncryptedData(CipherData.VALUE_TYPE, &quot;NO VALUE YET&quot;);</span>
<span class="nc" id="L599">            break;</span>
        case DECRYPT_MODE :
<span class="nc bnc" id="L601" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L602">                log.log(java.util.logging.Level.FINE, &quot;opmode = DECRYPT_MODE&quot;);</span>
            }
            break;
        case WRAP_MODE :
<span class="nc bnc" id="L606" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L607">                log.log(java.util.logging.Level.FINE, &quot;opmode = WRAP_MODE&quot;);</span>
            }
<span class="nc" id="L609">            ek = createEncryptedKey(CipherData.VALUE_TYPE, &quot;NO VALUE YET&quot;);</span>
<span class="nc" id="L610">            break;</span>
        case UNWRAP_MODE :
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L613">                log.log(java.util.logging.Level.FINE, &quot;opmode = UNWRAP_MODE&quot;);</span>
            }
            break;
        default :
<span class="nc" id="L617">            log.log(java.util.logging.Level.SEVERE, &quot;Mode unexpectedly invalid&quot;);</span>
<span class="nc" id="L618">            throw new XMLEncryptionException(&quot;Invalid mode in init&quot;);</span>
        }

<span class="nc" id="L621">        cipherMode = opmode;</span>
<span class="nc" id="L622">        this.key = key;</span>
<span class="nc" id="L623">    }</span>

    /**
     * Set whether secure validation is enabled or not. The default is false.
     */
    public void setSecureValidation(boolean secureValidation) {
<span class="nc" id="L629">        this.secureValidation = secureValidation;</span>
<span class="nc" id="L630">    }</span>

    /**
     * This method is used to add a custom {@link KeyResolverSpi} to an XMLCipher.
     * These KeyResolvers are used in KeyInfo objects in DECRYPT and
     * UNWRAP modes.
     *
     * @param keyResolver
     */
    public void registerInternalKeyResolver(KeyResolverSpi keyResolver) {
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (internalKeyResolvers == null) {</span>
<span class="nc" id="L641">            internalKeyResolvers = new ArrayList&lt;KeyResolverSpi&gt;();</span>
        }
<span class="nc" id="L643">        internalKeyResolvers.add(keyResolver);</span>
<span class="nc" id="L644">    }</span>

    /**
     * Get the EncryptedData being built
     * &lt;p&gt;
     * Returns the EncryptedData being built during an ENCRYPT operation.
     * This can then be used by applications to add KeyInfo elements and
     * set other parameters.
     *
     * @return The EncryptedData being built
     */
    public EncryptedData getEncryptedData() {
        // Sanity checks
<span class="nc bnc" id="L657" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L658">            log.log(java.util.logging.Level.FINE, &quot;Returning EncryptedData&quot;);</span>
        }
<span class="nc" id="L660">        return ed;</span>
    }

    /**
     * Get the EncryptedData being build
     *
     * Returns the EncryptedData being built during an ENCRYPT operation.
     * This can then be used by applications to add KeyInfo elements and
     * set other parameters.
     *
     * @return The EncryptedData being built
     */
    public EncryptedKey getEncryptedKey() {
        // Sanity checks
<span class="nc bnc" id="L674" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L675">            log.log(java.util.logging.Level.FINE, &quot;Returning EncryptedKey&quot;);</span>
        }
<span class="nc" id="L677">        return ek;</span>
    }

    /**
     * Set a Key Encryption Key.
     * &lt;p&gt;
     * The Key Encryption Key (KEK) is used for encrypting/decrypting
     * EncryptedKey elements.  By setting this separately, the XMLCipher
     * class can know whether a key applies to the data part or wrapped key
     * part of an encrypted object.
     *
     * @param kek The key to use for de/encrypting key data
     */

    public void setKEK(Key kek) {
<span class="nc" id="L692">        this.kek = kek;</span>
<span class="nc" id="L693">    }</span>

    /**
     * Martial an EncryptedData
     *
     * Takes an EncryptedData object and returns a DOM Element that
     * represents the appropriate &lt;code&gt;EncryptedData&lt;/code&gt;
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; This should only be used in cases where the context
     * document has been passed in via a call to doFinal.
     *
     * @param encryptedData EncryptedData object to martial
     * @return the DOM &lt;code&gt;Element&lt;/code&gt; representing the passed in
     * object
     */
    public Element martial(EncryptedData encryptedData) {
<span class="nc" id="L709">        return factory.toElement(encryptedData);</span>
    }

    /**
     * Martial an EncryptedData
     *
     * Takes an EncryptedData object and returns a DOM Element that
     * represents the appropriate &lt;code&gt;EncryptedData&lt;/code&gt;
     *
     * @param context The document that will own the returned nodes
     * @param encryptedData EncryptedData object to martial
     * @return the DOM &lt;code&gt;Element&lt;/code&gt; representing the passed in
     * object
     */
    public Element martial(Document context, EncryptedData encryptedData) {
<span class="nc" id="L724">        contextDocument = context;</span>
<span class="nc" id="L725">        return factory.toElement(encryptedData);</span>
    }

    /**
     * Martial an EncryptedKey
     *
     * Takes an EncryptedKey object and returns a DOM Element that
     * represents the appropriate &lt;code&gt;EncryptedKey&lt;/code&gt;
     *
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; This should only be used in cases where the context
     * document has been passed in via a call to doFinal.
     *
     * @param encryptedKey EncryptedKey object to martial
     * @return the DOM &lt;code&gt;Element&lt;/code&gt; representing the passed in
     * object
     */
    public Element martial(EncryptedKey encryptedKey) {
<span class="nc" id="L743">        return factory.toElement(encryptedKey);</span>
    }

    /**
     * Martial an EncryptedKey
     *
     * Takes an EncryptedKey object and returns a DOM Element that
     * represents the appropriate &lt;code&gt;EncryptedKey&lt;/code&gt;
     *
     * @param context The document that will own the created nodes
     * @param encryptedKey EncryptedKey object to martial
     * @return the DOM &lt;code&gt;Element&lt;/code&gt; representing the passed in
     * object
     */
    public Element martial(Document context, EncryptedKey encryptedKey) {
<span class="nc" id="L758">        contextDocument = context;</span>
<span class="nc" id="L759">        return factory.toElement(encryptedKey);</span>
    }

    /**
     * Martial a ReferenceList
     *
     * Takes a ReferenceList object and returns a DOM Element that
     * represents the appropriate &lt;code&gt;ReferenceList&lt;/code&gt;
     *
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; This should only be used in cases where the context
     * document has been passed in via a call to doFinal.
     *
     * @param referenceList ReferenceList object to martial
     * @return the DOM &lt;code&gt;Element&lt;/code&gt; representing the passed in
     * object
     */
    public Element martial(ReferenceList referenceList) {
<span class="nc" id="L777">        return factory.toElement(referenceList);</span>
    }

    /**
     * Martial a ReferenceList
     *
     * Takes a ReferenceList object and returns a DOM Element that
     * represents the appropriate &lt;code&gt;ReferenceList&lt;/code&gt;
     *
     * @param context The document that will own the created nodes
     * @param referenceList ReferenceList object to martial
     * @return the DOM &lt;code&gt;Element&lt;/code&gt; representing the passed in
     * object
     */
    public Element martial(Document context, ReferenceList referenceList) {
<span class="nc" id="L792">        contextDocument = context;</span>
<span class="nc" id="L793">        return factory.toElement(referenceList);</span>
    }

    /**
     * Encrypts an &lt;code&gt;Element&lt;/code&gt; and replaces it with its encrypted
     * counterpart in the context &lt;code&gt;Document&lt;/code&gt;, that is, the
     * &lt;code&gt;Document&lt;/code&gt; specified when one calls
     * {@link #getInstance(String) getInstance}.
     *
     * @param element the &lt;code&gt;Element&lt;/code&gt; to encrypt.
     * @return the context &lt;code&gt;Document&lt;/code&gt; with the encrypted
     *   &lt;code&gt;Element&lt;/code&gt; having replaced the source &lt;code&gt;Element&lt;/code&gt;.
     *  @throws Exception
     */
    private Document encryptElement(Element element) throws Exception{
<span class="nc bnc" id="L808" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L809">            log.log(java.util.logging.Level.FINE, &quot;Encrypting element...&quot;);</span>
        }
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (null == element) {</span>
<span class="nc" id="L812">            log.log(java.util.logging.Level.SEVERE, &quot;Element unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L814" title="All 4 branches missed.">        if (cipherMode != ENCRYPT_MODE &amp;&amp; log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L815">            log.log(java.util.logging.Level.FINE, &quot;XMLCipher unexpectedly not in ENCRYPT_MODE...&quot;);</span>
        }

<span class="nc bnc" id="L818" title="All 2 branches missed.">        if (algorithm == null) {</span>
<span class="nc" id="L819">            throw new XMLEncryptionException(&quot;XMLCipher instance without transformation specified&quot;);</span>
        }
<span class="nc" id="L821">        encryptData(contextDocument, element, false);</span>

<span class="nc" id="L823">        Element encryptedElement = factory.toElement(ed);</span>

<span class="nc" id="L825">        Node sourceParent = element.getParentNode();</span>
<span class="nc" id="L826">        sourceParent.replaceChild(encryptedElement, element);</span>

<span class="nc" id="L828">        return contextDocument;</span>
    }

    /**
     * Encrypts a &lt;code&gt;NodeList&lt;/code&gt; (the contents of an
     * &lt;code&gt;Element&lt;/code&gt;) and replaces its parent &lt;code&gt;Element&lt;/code&gt;'s
     * content with this the resulting &lt;code&gt;EncryptedType&lt;/code&gt; within the
     * context &lt;code&gt;Document&lt;/code&gt;, that is, the &lt;code&gt;Document&lt;/code&gt;
     * specified when one calls
     * {@link #getInstance(String) getInstance}.
     *
     * @param element the &lt;code&gt;NodeList&lt;/code&gt; to encrypt.
     * @return the context &lt;code&gt;Document&lt;/code&gt; with the encrypted
     *   &lt;code&gt;NodeList&lt;/code&gt; having replaced the content of the source
     *   &lt;code&gt;Element&lt;/code&gt;.
     * @throws Exception
     */
    private Document encryptElementContent(Element element) throws /* XMLEncryption */Exception {
<span class="nc bnc" id="L846" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L847">            log.log(java.util.logging.Level.FINE, &quot;Encrypting element content...&quot;);</span>
        }
<span class="nc bnc" id="L849" title="All 2 branches missed.">        if (null == element) {</span>
<span class="nc" id="L850">            log.log(java.util.logging.Level.SEVERE, &quot;Element unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L852" title="All 4 branches missed.">        if (cipherMode != ENCRYPT_MODE &amp;&amp; log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L853">            log.log(java.util.logging.Level.FINE, &quot;XMLCipher unexpectedly not in ENCRYPT_MODE...&quot;);</span>
        }

<span class="nc bnc" id="L856" title="All 2 branches missed.">        if (algorithm == null) {</span>
<span class="nc" id="L857">            throw new XMLEncryptionException(&quot;XMLCipher instance without transformation specified&quot;);</span>
        }
<span class="nc" id="L859">        encryptData(contextDocument, element, true);</span>

<span class="nc" id="L861">        Element encryptedElement = factory.toElement(ed);</span>

<span class="nc" id="L863">        removeContent(element);</span>
<span class="nc" id="L864">        element.appendChild(encryptedElement);</span>

<span class="nc" id="L866">        return contextDocument;</span>
    }

    /**
     * Process a DOM &lt;code&gt;Document&lt;/code&gt; node. The processing depends on the
     * initialization parameters of {@link #init(int, Key) init()}.
     *
     * @param context the context &lt;code&gt;Document&lt;/code&gt;.
     * @param source the &lt;code&gt;Document&lt;/code&gt; to be encrypted or decrypted.
     * @return the processed &lt;code&gt;Document&lt;/code&gt;.
     * @throws Exception to indicate any exceptional conditions.
     */
    public Document doFinal(Document context, Document source) throws /* XMLEncryption */Exception {
<span class="nc bnc" id="L879" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L880">            log.log(java.util.logging.Level.FINE, &quot;Processing source document...&quot;);</span>
        }
<span class="nc bnc" id="L882" title="All 2 branches missed.">        if (null == context) {</span>
<span class="nc" id="L883">            log.log(java.util.logging.Level.SEVERE, &quot;Context document unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L885" title="All 2 branches missed.">        if (null == source) {</span>
<span class="nc" id="L886">            log.log(java.util.logging.Level.SEVERE, &quot;Source document unexpectedly null...&quot;);</span>
        }

<span class="nc" id="L889">        contextDocument = context;</span>

<span class="nc" id="L891">        Document result = null;</span>

<span class="nc bnc" id="L893" title="All 4 branches missed.">        switch (cipherMode) {</span>
        case DECRYPT_MODE:
<span class="nc" id="L895">            result = decryptElement(source.getDocumentElement());</span>
<span class="nc" id="L896">            break;</span>
        case ENCRYPT_MODE:
<span class="nc" id="L898">            result = encryptElement(source.getDocumentElement());</span>
<span class="nc" id="L899">            break;</span>
        case UNWRAP_MODE:
        case WRAP_MODE:
<span class="nc" id="L902">            break;</span>
        default:
<span class="nc" id="L904">            throw new XMLEncryptionException(&quot;empty&quot;, new IllegalStateException());</span>
        }

<span class="nc" id="L907">        return result;</span>
    }

    /**
     * Process a DOM &lt;code&gt;Element&lt;/code&gt; node. The processing depends on the
     * initialization parameters of {@link #init(int, Key) init()}.
     *
     * @param context the context &lt;code&gt;Document&lt;/code&gt;.
     * @param element the &lt;code&gt;Element&lt;/code&gt; to be encrypted.
     * @return the processed &lt;code&gt;Document&lt;/code&gt;.
     * @throws Exception to indicate any exceptional conditions.
     */
    public Document doFinal(Document context, Element element) throws /* XMLEncryption */Exception {
<span class="nc bnc" id="L920" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L921">            log.log(java.util.logging.Level.FINE, &quot;Processing source element...&quot;);</span>
        }
<span class="nc bnc" id="L923" title="All 2 branches missed.">        if (null == context) {</span>
<span class="nc" id="L924">            log.log(java.util.logging.Level.SEVERE, &quot;Context document unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L926" title="All 2 branches missed.">        if (null == element) {</span>
<span class="nc" id="L927">            log.log(java.util.logging.Level.SEVERE, &quot;Source element unexpectedly null...&quot;);</span>
        }

<span class="nc" id="L930">        contextDocument = context;</span>

<span class="nc" id="L932">        Document result = null;</span>

<span class="nc bnc" id="L934" title="All 4 branches missed.">        switch (cipherMode) {</span>
        case DECRYPT_MODE:
<span class="nc" id="L936">            result = decryptElement(element);</span>
<span class="nc" id="L937">            break;</span>
        case ENCRYPT_MODE:
<span class="nc" id="L939">            result = encryptElement(element);</span>
<span class="nc" id="L940">            break;</span>
        case UNWRAP_MODE:
        case WRAP_MODE:
<span class="nc" id="L943">            break;</span>
        default:
<span class="nc" id="L945">            throw new XMLEncryptionException(&quot;empty&quot;, new IllegalStateException());</span>
        }

<span class="nc" id="L948">        return result;</span>
    }

    /**
     * Process the contents of a DOM &lt;code&gt;Element&lt;/code&gt; node. The processing
     * depends on the initialization parameters of
     * {@link #init(int, Key) init()}.
     *
     * @param context the context &lt;code&gt;Document&lt;/code&gt;.
     * @param element the &lt;code&gt;Element&lt;/code&gt; which contents is to be
     *   encrypted.
     * @param content
     * @return the processed &lt;code&gt;Document&lt;/code&gt;.
     * @throws Exception to indicate any exceptional conditions.
     */
    public Document doFinal(Document context, Element element, boolean content)
        throws /* XMLEncryption*/ Exception {
<span class="nc bnc" id="L965" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L966">            log.log(java.util.logging.Level.FINE, &quot;Processing source element...&quot;);</span>
        }
<span class="nc bnc" id="L968" title="All 2 branches missed.">        if (null == context) {</span>
<span class="nc" id="L969">            log.log(java.util.logging.Level.SEVERE, &quot;Context document unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (null == element) {</span>
<span class="nc" id="L972">            log.log(java.util.logging.Level.SEVERE, &quot;Source element unexpectedly null...&quot;);</span>
        }

<span class="nc" id="L975">        contextDocument = context;</span>

<span class="nc" id="L977">        Document result = null;</span>

<span class="nc bnc" id="L979" title="All 4 branches missed.">        switch (cipherMode) {</span>
        case DECRYPT_MODE:
<span class="nc bnc" id="L981" title="All 2 branches missed.">            if (content) {</span>
<span class="nc" id="L982">                result = decryptElementContent(element);</span>
            } else {
<span class="nc" id="L984">                result = decryptElement(element);</span>
            }
<span class="nc" id="L986">            break;</span>
        case ENCRYPT_MODE:
<span class="nc bnc" id="L988" title="All 2 branches missed.">            if (content) {</span>
<span class="nc" id="L989">                result = encryptElementContent(element);</span>
            } else {
<span class="nc" id="L991">                result = encryptElement(element);</span>
            }
<span class="nc" id="L993">            break;</span>
        case UNWRAP_MODE:
        case WRAP_MODE:
<span class="nc" id="L996">            break;</span>
        default:
<span class="nc" id="L998">            throw new XMLEncryptionException(&quot;empty&quot;, new IllegalStateException());</span>
        }

<span class="nc" id="L1001">        return result;</span>
    }

    /**
     * Returns an &lt;code&gt;EncryptedData&lt;/code&gt; interface. Use this operation if
     * you want to have full control over the contents of the
     * &lt;code&gt;EncryptedData&lt;/code&gt; structure.
     *
     * This does not change the source document in any way.
     *
     * @param context the context &lt;code&gt;Document&lt;/code&gt;.
     * @param element the &lt;code&gt;Element&lt;/code&gt; that will be encrypted.
     * @return the &lt;code&gt;EncryptedData&lt;/code&gt;
     * @throws Exception
     */
    public EncryptedData encryptData(Document context, Element element) throws
        /* XMLEncryption */Exception {
<span class="nc" id="L1018">        return encryptData(context, element, false);</span>
    }

    /**
     * Returns an &lt;code&gt;EncryptedData&lt;/code&gt; interface. Use this operation if
     * you want to have full control over the serialization of the element
     * or element content.
     *
     * This does not change the source document in any way.
     *
     * @param context the context &lt;code&gt;Document&lt;/code&gt;.
     * @param type a URI identifying type information about the plaintext form
     *    of the encrypted content (may be &lt;code&gt;null&lt;/code&gt;)
     * @param serializedData the serialized data
     * @return the &lt;code&gt;EncryptedData&lt;/code&gt;
     * @throws Exception
     */
    public EncryptedData encryptData(
        Document context, String type, InputStream serializedData
    ) throws Exception {
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1039">            log.log(java.util.logging.Level.FINE, &quot;Encrypting element...&quot;);</span>
        }
<span class="nc bnc" id="L1041" title="All 2 branches missed.">        if (null == context) {</span>
<span class="nc" id="L1042">            log.log(java.util.logging.Level.SEVERE, &quot;Context document unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L1044" title="All 2 branches missed.">        if (null == serializedData) {</span>
<span class="nc" id="L1045">            log.log(java.util.logging.Level.SEVERE, &quot;Serialized data unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L1047" title="All 4 branches missed.">        if (cipherMode != ENCRYPT_MODE &amp;&amp; log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1048">            log.log(java.util.logging.Level.FINE, &quot;XMLCipher unexpectedly not in ENCRYPT_MODE...&quot;);</span>
        }

<span class="nc" id="L1051">        return encryptData(context, null, type, serializedData);</span>
    }

    /**
     * Returns an &lt;code&gt;EncryptedData&lt;/code&gt; interface. Use this operation if
     * you want to have full control over the contents of the
     * &lt;code&gt;EncryptedData&lt;/code&gt; structure.
     *
     * This does not change the source document in any way.
     *
     * @param context the context &lt;code&gt;Document&lt;/code&gt;.
     * @param element the &lt;code&gt;Element&lt;/code&gt; that will be encrypted.
     * @param contentMode &lt;code&gt;true&lt;/code&gt; to encrypt element's content only,
     *    &lt;code&gt;false&lt;/code&gt; otherwise
     * @return the &lt;code&gt;EncryptedData&lt;/code&gt;
     * @throws Exception
     */
    public EncryptedData encryptData(
        Document context, Element element, boolean contentMode
    ) throws /* XMLEncryption */ Exception {
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1072">            log.log(java.util.logging.Level.FINE, &quot;Encrypting element...&quot;);</span>
        }
<span class="nc bnc" id="L1074" title="All 2 branches missed.">        if (null == context) {</span>
<span class="nc" id="L1075">            log.log(java.util.logging.Level.SEVERE, &quot;Context document unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        if (null == element) {</span>
<span class="nc" id="L1078">            log.log(java.util.logging.Level.SEVERE, &quot;Element unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L1080" title="All 4 branches missed.">        if (cipherMode != ENCRYPT_MODE &amp;&amp; log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1081">            log.log(java.util.logging.Level.FINE, &quot;XMLCipher unexpectedly not in ENCRYPT_MODE...&quot;);</span>
        }

<span class="nc bnc" id="L1084" title="All 2 branches missed.">        if (contentMode) {</span>
<span class="nc" id="L1085">            return encryptData(context, element, EncryptionConstants.TYPE_CONTENT, null);</span>
        } else {
<span class="nc" id="L1087">            return encryptData(context, element, EncryptionConstants.TYPE_ELEMENT, null);</span>
        }
    }

    private EncryptedData encryptData(
        Document context, Element element, String type, InputStream serializedData
    ) throws /* XMLEncryption */ Exception {
<span class="nc" id="L1094">        contextDocument = context;</span>

<span class="nc bnc" id="L1096" title="All 2 branches missed.">        if (algorithm == null) {</span>
<span class="nc" id="L1097">            throw new XMLEncryptionException(&quot;XMLCipher instance without transformation specified&quot;);</span>
        }

<span class="nc" id="L1100">        byte[] serializedOctets = null;</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        if (serializedData == null) {</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">            if (type.equals(EncryptionConstants.TYPE_CONTENT)) {</span>
<span class="nc" id="L1103">                NodeList children = element.getChildNodes();</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                if (null != children) {</span>
<span class="nc" id="L1105">                    serializedOctets = serializer.serializeToByteArray(children);</span>
                } else {
<span class="nc" id="L1107">                    Object exArgs[] = { &quot;Element has no content.&quot; };</span>
<span class="nc" id="L1108">                    throw new XMLEncryptionException(&quot;empty&quot;, exArgs);</span>
                }
<span class="nc" id="L1110">            } else {</span>
<span class="nc" id="L1111">                serializedOctets = serializer.serializeToByteArray(element);</span>
            }
<span class="nc bnc" id="L1113" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1114">                log.log(java.util.logging.Level.FINE, &quot;Serialized octets:\n&quot; + new String(serializedOctets, &quot;UTF-8&quot;));</span>
            }
        }

<span class="nc" id="L1118">        byte[] encryptedBytes = null;</span>

        // Now create the working cipher if none was created already
        Cipher c;
<span class="nc bnc" id="L1122" title="All 2 branches missed.">        if (contextCipher == null) {</span>
<span class="nc" id="L1123">            c = constructCipher(algorithm, null);</span>
        } else {
<span class="nc" id="L1125">            c = contextCipher;</span>
        }
        // Now perform the encryption

        try {
            // The Spec mandates a 96-bit IV for GCM algorithms
<span class="nc bnc" id="L1131" title="All 4 branches missed.">            if (AES_128_GCM.equals(algorithm) || AES_192_GCM.equals(algorithm)</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">                || AES_256_GCM.equals(algorithm)) {</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                if (random == null) {</span>
<span class="nc" id="L1134">                    random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span>
                }
<span class="nc" id="L1136">                byte[] temp = new byte[12];</span>
<span class="nc" id="L1137">                random.nextBytes(temp);</span>
<span class="nc" id="L1138">                IvParameterSpec paramSpec = new IvParameterSpec(temp);</span>
<span class="nc" id="L1139">                c.init(cipherMode, key, paramSpec);</span>
<span class="nc" id="L1140">            } else {</span>
<span class="nc" id="L1141">                c.init(cipherMode, key);</span>
            }
<span class="nc" id="L1143">        } catch (InvalidKeyException ike) {</span>
<span class="nc" id="L1144">            throw new XMLEncryptionException(&quot;empty&quot;, ike);</span>
<span class="nc" id="L1145">        } catch (NoSuchAlgorithmException ex) {</span>
<span class="nc" id="L1146">            throw new XMLEncryptionException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L1147">        }</span>

        try {
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            if (serializedData != null) {</span>
                int numBytes;
<span class="nc" id="L1152">                byte[] buf = new byte[8192];</span>
<span class="nc" id="L1153">                ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">                while ((numBytes = serializedData.read(buf)) != -1) {</span>
<span class="nc" id="L1155">                    byte[] data = c.update(buf, 0, numBytes);</span>
<span class="nc" id="L1156">                    baos.write(data);</span>
<span class="nc" id="L1157">                }</span>
<span class="nc" id="L1158">                baos.write(c.doFinal());</span>
<span class="nc" id="L1159">                encryptedBytes = baos.toByteArray();</span>
<span class="nc" id="L1160">            } else {</span>
<span class="nc" id="L1161">                encryptedBytes = c.doFinal(serializedOctets);</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">                if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1163">                    log.log(java.util.logging.Level.FINE, &quot;Expected cipher.outputSize = &quot; +</span>
<span class="nc" id="L1164">                        Integer.toString(c.getOutputSize(serializedOctets.length)));</span>
                }
            }
<span class="nc bnc" id="L1167" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1168">                log.log(java.util.logging.Level.FINE, &quot;Actual cipher.outputSize = &quot;</span>
<span class="nc" id="L1169">                             + Integer.toString(encryptedBytes.length));</span>
            }
<span class="nc" id="L1171">        } catch (IllegalStateException ise) {</span>
<span class="nc" id="L1172">            throw new XMLEncryptionException(&quot;empty&quot;, ise);</span>
<span class="nc" id="L1173">        } catch (IllegalBlockSizeException ibse) {</span>
<span class="nc" id="L1174">            throw new XMLEncryptionException(&quot;empty&quot;, ibse);</span>
<span class="nc" id="L1175">        } catch (BadPaddingException bpe) {</span>
<span class="nc" id="L1176">            throw new XMLEncryptionException(&quot;empty&quot;, bpe);</span>
<span class="nc" id="L1177">        } catch (UnsupportedEncodingException uee) {</span>
<span class="nc" id="L1178">            throw new XMLEncryptionException(&quot;empty&quot;, uee);</span>
<span class="nc" id="L1179">        }</span>

        // Now build up to a properly XML Encryption encoded octet stream
        // IvParameterSpec iv;
<span class="nc" id="L1183">        byte[] iv = c.getIV();</span>
<span class="nc" id="L1184">        byte[] finalEncryptedBytes = new byte[iv.length + encryptedBytes.length];</span>
<span class="nc" id="L1185">        System.arraycopy(iv, 0, finalEncryptedBytes, 0, iv.length);</span>
<span class="nc" id="L1186">        System.arraycopy(encryptedBytes, 0, finalEncryptedBytes, iv.length, encryptedBytes.length);</span>
<span class="nc" id="L1187">        String base64EncodedEncryptedOctets = Base64.encode(finalEncryptedBytes);</span>

<span class="nc bnc" id="L1189" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1190">            log.log(java.util.logging.Level.FINE, &quot;Encrypted octets:\n&quot; + base64EncodedEncryptedOctets);</span>
<span class="nc" id="L1191">            log.log(java.util.logging.Level.FINE, &quot;Encrypted octets length = &quot; + base64EncodedEncryptedOctets.length());</span>
        }

        try {
<span class="nc" id="L1195">            CipherData cd = ed.getCipherData();</span>
<span class="nc" id="L1196">            CipherValue cv = cd.getCipherValue();</span>
            // cv.setValue(base64EncodedEncryptedOctets.getBytes());
<span class="nc" id="L1198">            cv.setValue(base64EncodedEncryptedOctets);</span>

<span class="nc bnc" id="L1200" title="All 2 branches missed.">            if (type != null) {</span>
<span class="nc" id="L1201">                ed.setType(new URI(type).toString());</span>
            }
<span class="nc" id="L1203">            EncryptionMethod method =</span>
<span class="nc" id="L1204">                factory.newEncryptionMethod(new URI(algorithm).toString());</span>
<span class="nc" id="L1205">            method.setDigestAlgorithm(digestAlg);</span>
<span class="nc" id="L1206">            ed.setEncryptionMethod(method);</span>
<span class="nc" id="L1207">        } catch (URISyntaxException ex) {</span>
<span class="nc" id="L1208">            throw new XMLEncryptionException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L1209">        }</span>
<span class="nc" id="L1210">        return ed;</span>
    }

    /**
     * Returns an &lt;code&gt;EncryptedData&lt;/code&gt; interface. Use this operation if
     * you want to load an &lt;code&gt;EncryptedData&lt;/code&gt; structure from a DOM
     * structure and manipulate the contents.
     *
     * @param context the context &lt;code&gt;Document&lt;/code&gt;.
     * @param element the &lt;code&gt;Element&lt;/code&gt; that will be loaded
     * @throws XMLEncryptionException
     * @return the &lt;code&gt;EncryptedData&lt;/code&gt;
     */
    public EncryptedData loadEncryptedData(Document context, Element element)
        throws XMLEncryptionException {
<span class="nc bnc" id="L1225" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1226">            log.log(java.util.logging.Level.FINE, &quot;Loading encrypted element...&quot;);</span>
        }
<span class="nc bnc" id="L1228" title="All 2 branches missed.">        if (null == context) {</span>
<span class="nc" id="L1229">            throw new NullPointerException(&quot;Context document unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L1231" title="All 2 branches missed.">        if (null == element) {</span>
<span class="nc" id="L1232">            throw new NullPointerException(&quot;Element unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L1234" title="All 2 branches missed.">        if (cipherMode != DECRYPT_MODE) {</span>
<span class="nc" id="L1235">            throw new XMLEncryptionException(&quot;XMLCipher unexpectedly not in DECRYPT_MODE...&quot;);</span>
        }

<span class="nc" id="L1238">        contextDocument = context;</span>
<span class="nc" id="L1239">        ed = factory.newEncryptedData(element);</span>

<span class="nc" id="L1241">        return ed;</span>
    }

    /**
     * Returns an &lt;code&gt;EncryptedKey&lt;/code&gt; interface. Use this operation if
     * you want to load an &lt;code&gt;EncryptedKey&lt;/code&gt; structure from a DOM
     * structure and manipulate the contents.
     *
     * @param context the context &lt;code&gt;Document&lt;/code&gt;.
     * @param element the &lt;code&gt;Element&lt;/code&gt; that will be loaded
     * @return the &lt;code&gt;EncryptedKey&lt;/code&gt;
     * @throws XMLEncryptionException
     */
    public EncryptedKey loadEncryptedKey(Document context, Element element)
        throws XMLEncryptionException {
<span class="nc bnc" id="L1256" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1257">            log.log(java.util.logging.Level.FINE, &quot;Loading encrypted key...&quot;);</span>
        }
<span class="nc bnc" id="L1259" title="All 2 branches missed.">        if (null == context) {</span>
<span class="nc" id="L1260">            throw new NullPointerException(&quot;Context document unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L1262" title="All 2 branches missed.">        if (null == element) {</span>
<span class="nc" id="L1263">            throw new NullPointerException(&quot;Element unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L1265" title="All 4 branches missed.">        if (cipherMode != UNWRAP_MODE &amp;&amp; cipherMode != DECRYPT_MODE) {</span>
<span class="nc" id="L1266">            throw new XMLEncryptionException(</span>
                &quot;XMLCipher unexpectedly not in UNWRAP_MODE or DECRYPT_MODE...&quot;
            );
        }

<span class="nc" id="L1271">        contextDocument = context;</span>
<span class="nc" id="L1272">        ek = factory.newEncryptedKey(element);</span>
<span class="nc" id="L1273">        return ek;</span>
    }

    /**
     * Returns an &lt;code&gt;EncryptedKey&lt;/code&gt; interface. Use this operation if
     * you want to load an &lt;code&gt;EncryptedKey&lt;/code&gt; structure from a DOM
     * structure and manipulate the contents.
     *
     * Assumes that the context document is the document that owns the element
     *
     * @param element the &lt;code&gt;Element&lt;/code&gt; that will be loaded
     * @return the &lt;code&gt;EncryptedKey&lt;/code&gt;
     * @throws XMLEncryptionException
     */
    public EncryptedKey loadEncryptedKey(Element element) throws XMLEncryptionException {
<span class="nc" id="L1288">        return loadEncryptedKey(element.getOwnerDocument(), element);</span>
    }

    /**
     * Encrypts a key to an EncryptedKey structure
     *
     * @param doc the Context document that will be used to general DOM
     * @param key Key to encrypt (will use previously set KEK to
     * perform encryption
     * @return the &lt;code&gt;EncryptedKey&lt;/code&gt;
     * @throws XMLEncryptionException
     */
    public EncryptedKey encryptKey(Document doc, Key key) throws XMLEncryptionException {
<span class="nc" id="L1301">        return encryptKey(doc, key, null, null);</span>
    }

    /**
     * Encrypts a key to an EncryptedKey structure
     *
     * @param doc the Context document that will be used to general DOM
     * @param key Key to encrypt (will use previously set KEK to
     * perform encryption
     * @param mgfAlgorithm The xenc11 MGF Algorithm to use
     * @param oaepParams The OAEPParams to use
     * @return the &lt;code&gt;EncryptedKey&lt;/code&gt;
     * @throws XMLEncryptionException
     */
    public EncryptedKey encryptKey(
        Document doc,
        Key key,
        String mgfAlgorithm,
        byte[] oaepParams
    ) throws XMLEncryptionException {
<span class="nc bnc" id="L1321" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1322">            log.log(java.util.logging.Level.FINE, &quot;Encrypting key ...&quot;);</span>
        }

<span class="nc bnc" id="L1325" title="All 2 branches missed.">        if (null == key) {</span>
<span class="nc" id="L1326">            log.log(java.util.logging.Level.SEVERE, &quot;Key unexpectedly null...&quot;);</span>
        }
<span class="nc bnc" id="L1328" title="All 2 branches missed.">        if (cipherMode != WRAP_MODE) {</span>
<span class="nc" id="L1329">            log.log(java.util.logging.Level.FINE, &quot;XMLCipher unexpectedly not in WRAP_MODE...&quot;);</span>
        }
<span class="nc bnc" id="L1331" title="All 2 branches missed.">        if (algorithm == null) {</span>
<span class="nc" id="L1332">            throw new XMLEncryptionException(&quot;XMLCipher instance without transformation specified&quot;);</span>
        }

<span class="nc" id="L1335">        contextDocument = doc;</span>

<span class="nc" id="L1337">        byte[] encryptedBytes = null;</span>
        Cipher c;

<span class="nc bnc" id="L1340" title="All 2 branches missed.">        if (contextCipher == null) {</span>
            // Now create the working cipher
<span class="nc" id="L1342">            c = constructCipher(algorithm, null);</span>
        } else {
<span class="nc" id="L1344">            c = contextCipher;</span>
        }
        // Now perform the encryption

        try {
            // Should internally generate an IV
            // todo - allow user to set an IV
<span class="nc" id="L1351">            OAEPParameterSpec oaepParameters =</span>
<span class="nc" id="L1352">                constructOAEPParameters(</span>
                    algorithm, digestAlg, mgfAlgorithm, oaepParams
                );
<span class="nc bnc" id="L1355" title="All 2 branches missed.">            if (oaepParameters == null) {</span>
<span class="nc" id="L1356">                c.init(Cipher.WRAP_MODE, this.key);</span>
            } else {
<span class="nc" id="L1358">                c.init(Cipher.WRAP_MODE, this.key, oaepParameters);</span>
            }
<span class="nc" id="L1360">            encryptedBytes = c.wrap(key);</span>
<span class="nc" id="L1361">        } catch (InvalidKeyException ike) {</span>
<span class="nc" id="L1362">            throw new XMLEncryptionException(&quot;empty&quot;, ike);</span>
<span class="nc" id="L1363">        } catch (IllegalBlockSizeException ibse) {</span>
<span class="nc" id="L1364">            throw new XMLEncryptionException(&quot;empty&quot;, ibse);</span>
<span class="nc" id="L1365">        } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L1366">            throw new XMLEncryptionException(&quot;empty&quot;, e);</span>
<span class="nc" id="L1367">        }</span>

<span class="nc" id="L1369">        String base64EncodedEncryptedOctets = Base64.encode(encryptedBytes);</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1371">            log.log(java.util.logging.Level.FINE, &quot;Encrypted key octets:\n&quot; + base64EncodedEncryptedOctets);</span>
<span class="nc" id="L1372">            log.log(java.util.logging.Level.FINE, &quot;Encrypted key octets length = &quot; + base64EncodedEncryptedOctets.length());</span>
        }

<span class="nc" id="L1375">        CipherValue cv = ek.getCipherData().getCipherValue();</span>
<span class="nc" id="L1376">        cv.setValue(base64EncodedEncryptedOctets);</span>

        try {
<span class="nc" id="L1379">            EncryptionMethod method = factory.newEncryptionMethod(new URI(algorithm).toString());</span>
<span class="nc" id="L1380">            method.setDigestAlgorithm(digestAlg);</span>
<span class="nc" id="L1381">            method.setMGFAlgorithm(mgfAlgorithm);</span>
<span class="nc" id="L1382">            method.setOAEPparams(oaepParams);</span>
<span class="nc" id="L1383">            ek.setEncryptionMethod(method);</span>
<span class="nc" id="L1384">        } catch (URISyntaxException ex) {</span>
<span class="nc" id="L1385">            throw new XMLEncryptionException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L1386">        }</span>
<span class="nc" id="L1387">        return ek;</span>
    }

    /**
     * Decrypt a key from a passed in EncryptedKey structure
     *
     * @param encryptedKey Previously loaded EncryptedKey that needs
     * to be decrypted.
     * @param algorithm Algorithm for the decryption
     * @return a key corresponding to the given type
     * @throws XMLEncryptionException
     */
    public Key decryptKey(EncryptedKey encryptedKey, String algorithm)
        throws XMLEncryptionException {
<span class="nc bnc" id="L1401" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1402">            log.log(java.util.logging.Level.FINE, &quot;Decrypting key from previously loaded EncryptedKey...&quot;);</span>
        }

<span class="nc bnc" id="L1405" title="All 4 branches missed.">        if (cipherMode != UNWRAP_MODE &amp;&amp; log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1406">            log.log(java.util.logging.Level.FINE, &quot;XMLCipher unexpectedly not in UNWRAP_MODE...&quot;);</span>
        }

<span class="nc bnc" id="L1409" title="All 2 branches missed.">        if (algorithm == null) {</span>
<span class="nc" id="L1410">            throw new XMLEncryptionException(&quot;Cannot decrypt a key without knowing the algorithm&quot;);</span>
        }

<span class="nc bnc" id="L1413" title="All 2 branches missed.">        if (key == null) {</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1415">                log.log(java.util.logging.Level.FINE, &quot;Trying to find a KEK via key resolvers&quot;);</span>
            }

<span class="nc" id="L1418">            KeyInfo ki = encryptedKey.getKeyInfo();</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">            if (ki != null) {</span>
<span class="nc" id="L1420">                ki.setSecureValidation(secureValidation);</span>
                try {
<span class="nc" id="L1422">                    String keyWrapAlg = encryptedKey.getEncryptionMethod().getAlgorithm();</span>
<span class="nc" id="L1423">                    String keyType = JCEMapper.getJCEKeyAlgorithmFromURI(keyWrapAlg);</span>
<span class="nc bnc" id="L1424" title="All 2 branches missed.">                    if (&quot;RSA&quot;.equals(keyType)) {</span>
<span class="nc" id="L1425">                        key = ki.getPrivateKey();</span>
                    } else {
<span class="nc" id="L1427">                        key = ki.getSecretKey();</span>
                    }
                }
<span class="nc" id="L1430">                catch (Exception e) {</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">                    if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1432">                        log.log(java.util.logging.Level.FINE, e.getMessage(), e);</span>
                    }
<span class="nc" id="L1434">                }</span>
            }
<span class="nc bnc" id="L1436" title="All 2 branches missed.">            if (key == null) {</span>
<span class="nc" id="L1437">                log.log(java.util.logging.Level.SEVERE, &quot;XMLCipher::decryptKey called without a KEK and cannot resolve&quot;);</span>
<span class="nc" id="L1438">                throw new XMLEncryptionException(&quot;Unable to decrypt without a KEK&quot;);</span>
            }
        }

        // Obtain the encrypted octets
<span class="nc" id="L1443">        XMLCipherInput cipherInput = new XMLCipherInput(encryptedKey);</span>
<span class="nc" id="L1444">        cipherInput.setSecureValidation(secureValidation);</span>
<span class="nc" id="L1445">        byte[] encryptedBytes = cipherInput.getBytes();</span>

<span class="nc" id="L1447">        String jceKeyAlgorithm = JCEMapper.getJCEKeyAlgorithmFromURI(algorithm);</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1449">            log.log(java.util.logging.Level.FINE, &quot;JCE Key Algorithm: &quot; + jceKeyAlgorithm);</span>
        }

        Cipher c;
<span class="nc bnc" id="L1453" title="All 2 branches missed.">        if (contextCipher == null) {</span>
            // Now create the working cipher
<span class="nc" id="L1455">            c =</span>
<span class="nc" id="L1456">                constructCipher(</span>
<span class="nc" id="L1457">                    encryptedKey.getEncryptionMethod().getAlgorithm(),</span>
<span class="nc" id="L1458">                    encryptedKey.getEncryptionMethod().getDigestAlgorithm()</span>
                );
        } else {
<span class="nc" id="L1461">            c = contextCipher;</span>
        }

        Key ret;

        try {
<span class="nc" id="L1467">            EncryptionMethod encMethod = encryptedKey.getEncryptionMethod();</span>
<span class="nc" id="L1468">            OAEPParameterSpec oaepParameters =</span>
<span class="nc" id="L1469">                constructOAEPParameters(</span>
<span class="nc" id="L1470">                    encMethod.getAlgorithm(), encMethod.getDigestAlgorithm(),</span>
<span class="nc" id="L1471">                    encMethod.getMGFAlgorithm(), encMethod.getOAEPparams()</span>
                );
<span class="nc bnc" id="L1473" title="All 2 branches missed.">            if (oaepParameters == null) {</span>
<span class="nc" id="L1474">                c.init(Cipher.UNWRAP_MODE, key);</span>
            } else {
<span class="nc" id="L1476">                c.init(Cipher.UNWRAP_MODE, key, oaepParameters);</span>
            }
<span class="nc" id="L1478">            ret = c.unwrap(encryptedBytes, jceKeyAlgorithm, Cipher.SECRET_KEY);</span>
<span class="nc" id="L1479">        } catch (InvalidKeyException ike) {</span>
<span class="nc" id="L1480">            throw new XMLEncryptionException(&quot;empty&quot;, ike);</span>
<span class="nc" id="L1481">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L1482">            throw new XMLEncryptionException(&quot;empty&quot;, nsae);</span>
<span class="nc" id="L1483">        } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L1484">            throw new XMLEncryptionException(&quot;empty&quot;, e);</span>
<span class="nc" id="L1485">        }</span>
<span class="nc bnc" id="L1486" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1487">            log.log(java.util.logging.Level.FINE, &quot;Decryption of key type &quot; + algorithm + &quot; OK&quot;);</span>
        }

<span class="nc" id="L1490">        return ret;</span>
    }

    /**
     * Construct an OAEPParameterSpec object from the given parameters
     */
    private OAEPParameterSpec constructOAEPParameters(
        String encryptionAlgorithm,
        String digestAlgorithm,
        String mgfAlgorithm,
        byte[] oaepParams
    ) {
<span class="nc bnc" id="L1502" title="All 2 branches missed.">        if (XMLCipher.RSA_OAEP.equals(encryptionAlgorithm)</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">            || XMLCipher.RSA_OAEP_11.equals(encryptionAlgorithm)) {</span>

<span class="nc" id="L1505">            String jceDigestAlgorithm = &quot;SHA-1&quot;;</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">            if (digestAlgorithm != null) {</span>
<span class="nc" id="L1507">                jceDigestAlgorithm = JCEMapper.translateURItoJCEID(digestAlgorithm);</span>
            }

<span class="nc" id="L1510">            PSource.PSpecified pSource = PSource.PSpecified.DEFAULT;</span>
<span class="nc bnc" id="L1511" title="All 2 branches missed.">            if (oaepParams != null) {</span>
<span class="nc" id="L1512">                pSource = new PSource.PSpecified(oaepParams);</span>
            }

<span class="nc" id="L1515">            MGF1ParameterSpec mgfParameterSpec = new MGF1ParameterSpec(&quot;SHA-1&quot;);</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">            if (XMLCipher.RSA_OAEP_11.equals(encryptionAlgorithm)) {</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">                if (EncryptionConstants.MGF1_SHA256.equals(mgfAlgorithm)) {</span>
<span class="nc" id="L1518">                    mgfParameterSpec = new MGF1ParameterSpec(&quot;SHA-256&quot;);</span>
<span class="nc bnc" id="L1519" title="All 2 branches missed.">                } else if (EncryptionConstants.MGF1_SHA384.equals(mgfAlgorithm)) {</span>
<span class="nc" id="L1520">                    mgfParameterSpec = new MGF1ParameterSpec(&quot;SHA-384&quot;);</span>
<span class="nc bnc" id="L1521" title="All 2 branches missed.">                } else if (EncryptionConstants.MGF1_SHA512.equals(mgfAlgorithm)) {</span>
<span class="nc" id="L1522">                    mgfParameterSpec = new MGF1ParameterSpec(&quot;SHA-512&quot;);</span>
                }
            }
<span class="nc" id="L1525">            return new OAEPParameterSpec(jceDigestAlgorithm, &quot;MGF1&quot;, mgfParameterSpec, pSource);</span>
        }

<span class="nc" id="L1528">        return null;</span>
    }

    /**
     * Construct a Cipher object
     */
    private Cipher constructCipher(String algorithm, String digestAlgorithm) throws XMLEncryptionException {
<span class="nc" id="L1535">        String jceAlgorithm = JCEMapper.translateURItoJCEID(algorithm);</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1537">            log.log(java.util.logging.Level.FINE, &quot;JCE Algorithm = &quot; + jceAlgorithm);</span>
        }

        Cipher c;
        try {
<span class="nc bnc" id="L1542" title="All 2 branches missed.">            if (requestedJCEProvider == null) {</span>
<span class="nc" id="L1543">                c = Cipher.getInstance(jceAlgorithm);</span>
            } else {
<span class="nc" id="L1545">                c = Cipher.getInstance(jceAlgorithm, requestedJCEProvider);</span>
            }
<span class="nc" id="L1547">        } catch (NoSuchAlgorithmException nsae) {</span>
            // Check to see if an RSA OAEP MGF-1 with SHA-1 algorithm was requested
            // Some JDKs don't support RSA/ECB/OAEPPadding
<span class="nc bnc" id="L1550" title="All 4 branches missed.">            if (XMLCipher.RSA_OAEP.equals(algorithm)</span>
                &amp;&amp; (digestAlgorithm == null
<span class="nc bnc" id="L1552" title="All 2 branches missed.">                    || MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA1.equals(digestAlgorithm))) {</span>
                try {
<span class="nc bnc" id="L1554" title="All 2 branches missed.">                    if (requestedJCEProvider == null) {</span>
<span class="nc" id="L1555">                        c = Cipher.getInstance(&quot;RSA/ECB/OAEPWithSHA1AndMGF1Padding&quot;);</span>
                    } else {
<span class="nc" id="L1557">                        c = Cipher.getInstance(&quot;RSA/ECB/OAEPWithSHA1AndMGF1Padding&quot;, requestedJCEProvider);</span>
                    }
<span class="nc" id="L1559">                } catch (Exception ex) {</span>
<span class="nc" id="L1560">                    throw new XMLEncryptionException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L1561">                }</span>
            } else {
<span class="nc" id="L1563">                throw new XMLEncryptionException(&quot;empty&quot;, nsae);</span>
            }
<span class="nc" id="L1565">        } catch (NoSuchProviderException nspre) {</span>
<span class="nc" id="L1566">            throw new XMLEncryptionException(&quot;empty&quot;, nspre);</span>
<span class="nc" id="L1567">        } catch (NoSuchPaddingException nspae) {</span>
<span class="nc" id="L1568">            throw new XMLEncryptionException(&quot;empty&quot;, nspae);</span>
<span class="nc" id="L1569">        }</span>

<span class="nc" id="L1571">        return c;</span>
    }

    /**
     * Decrypt a key from a passed in EncryptedKey structure.  This version
     * is used mainly internally, when  the cipher already has an
     * EncryptedData loaded.  The algorithm URI will be read from the
     * EncryptedData
     *
     * @param encryptedKey Previously loaded EncryptedKey that needs
     * to be decrypted.
     * @return a key corresponding to the given type
     * @throws XMLEncryptionException
     */
    public Key decryptKey(EncryptedKey encryptedKey) throws XMLEncryptionException {
<span class="nc" id="L1586">        return decryptKey(encryptedKey, ed.getEncryptionMethod().getAlgorithm());</span>
    }

    /**
     * Removes the contents of a &lt;code&gt;Node&lt;/code&gt;.
     *
     * @param node the &lt;code&gt;Node&lt;/code&gt; to clear.
     */
    private static void removeContent(Node node) {
<span class="nc bnc" id="L1595" title="All 2 branches missed.">        while (node.hasChildNodes()) {</span>
<span class="nc" id="L1596">            node.removeChild(node.getFirstChild());</span>
        }
<span class="nc" id="L1598">    }</span>

    /**
     * Decrypts &lt;code&gt;EncryptedData&lt;/code&gt; in a single-part operation.
     *
     * @param element the &lt;code&gt;EncryptedData&lt;/code&gt; to decrypt.
     * @return the &lt;code&gt;Node&lt;/code&gt; as a result of the decrypt operation.
     * @throws XMLEncryptionException
     */
    private Document decryptElement(Element element) throws XMLEncryptionException {
<span class="nc bnc" id="L1608" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1609">            log.log(java.util.logging.Level.FINE, &quot;Decrypting element...&quot;);</span>
        }

<span class="nc bnc" id="L1612" title="All 2 branches missed.">        if (cipherMode != DECRYPT_MODE) {</span>
<span class="nc" id="L1613">            log.log(java.util.logging.Level.SEVERE, &quot;XMLCipher unexpectedly not in DECRYPT_MODE...&quot;);</span>
        }

<span class="nc" id="L1616">        byte[] octets = decryptToByteArray(element);</span>

<span class="nc bnc" id="L1618" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1619">            log.log(java.util.logging.Level.FINE, &quot;Decrypted octets:\n&quot; + new String(octets));</span>
        }

<span class="nc" id="L1622">        Node sourceParent = element.getParentNode();</span>
<span class="nc" id="L1623">        Node decryptedNode = serializer.deserialize(octets, sourceParent);</span>

        // The de-serialiser returns a node whose children we need to take on.
<span class="nc bnc" id="L1626" title="All 4 branches missed.">        if (sourceParent != null &amp;&amp; Node.DOCUMENT_NODE == sourceParent.getNodeType()) {</span>
            // If this is a content decryption, this may have problems
<span class="nc" id="L1628">            contextDocument.removeChild(contextDocument.getDocumentElement());</span>
<span class="nc" id="L1629">            contextDocument.appendChild(decryptedNode);</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">        } else if (sourceParent != null) {</span>
<span class="nc" id="L1631">            sourceParent.replaceChild(decryptedNode, element);</span>
        }

<span class="nc" id="L1634">        return contextDocument;</span>
    }

    /**
     *
     * @param element
     * @return the &lt;code&gt;Node&lt;/code&gt; as a result of the decrypt operation.
     * @throws XMLEncryptionException
     */
    private Document decryptElementContent(Element element) throws XMLEncryptionException {
<span class="nc" id="L1644">        Element e =</span>
<span class="nc" id="L1645">            (Element) element.getElementsByTagNameNS(</span>
                EncryptionConstants.EncryptionSpecNS,
                EncryptionConstants._TAG_ENCRYPTEDDATA
<span class="nc" id="L1648">            ).item(0);</span>

<span class="nc bnc" id="L1650" title="All 2 branches missed.">        if (null == e) {</span>
<span class="nc" id="L1651">            throw new XMLEncryptionException(&quot;No EncryptedData child element.&quot;);</span>
        }

<span class="nc" id="L1654">        return decryptElement(e);</span>
    }

    /**
     * Decrypt an EncryptedData element to a byte array.
     *
     * When passed in an EncryptedData node, returns the decryption
     * as a byte array.
     *
     * Does not modify the source document.
     * @param element
     * @return the bytes resulting from the decryption
     * @throws XMLEncryptionException
     */
    public byte[] decryptToByteArray(Element element) throws XMLEncryptionException {
<span class="nc bnc" id="L1669" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1670">            log.log(java.util.logging.Level.FINE, &quot;Decrypting to ByteArray...&quot;);</span>
        }

<span class="nc bnc" id="L1673" title="All 2 branches missed.">        if (cipherMode != DECRYPT_MODE) {</span>
<span class="nc" id="L1674">            log.log(java.util.logging.Level.SEVERE, &quot;XMLCipher unexpectedly not in DECRYPT_MODE...&quot;);</span>
        }

<span class="nc" id="L1677">        EncryptedData encryptedData = factory.newEncryptedData(element);</span>

<span class="nc bnc" id="L1679" title="All 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L1680">            KeyInfo ki = encryptedData.getKeyInfo();</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">            if (ki != null) {</span>
                try {
                    // Add an EncryptedKey resolver
<span class="nc" id="L1684">                    String encMethodAlgorithm = encryptedData.getEncryptionMethod().getAlgorithm();</span>
<span class="nc" id="L1685">                    EncryptedKeyResolver resolver = new EncryptedKeyResolver(encMethodAlgorithm, kek);</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">                    if (internalKeyResolvers != null) {</span>
<span class="nc" id="L1687">                        int size = internalKeyResolvers.size();</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">                        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1689">                            resolver.registerInternalKeyResolver(internalKeyResolvers.get(i));</span>
                        }
                    }
<span class="nc" id="L1692">                    ki.registerInternalKeyResolver(resolver);</span>
<span class="nc" id="L1693">                    ki.setSecureValidation(secureValidation);</span>
<span class="nc" id="L1694">                    key = ki.getSecretKey();</span>
<span class="nc" id="L1695">                } catch (KeyResolverException kre) {</span>
<span class="nc bnc" id="L1696" title="All 2 branches missed.">                    if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1697">                        log.log(java.util.logging.Level.FINE, kre.getMessage(), kre);</span>
                    }
<span class="nc" id="L1699">                }</span>
            }

<span class="nc bnc" id="L1702" title="All 2 branches missed.">            if (key == null) {</span>
<span class="nc" id="L1703">                log.log(java.util.logging.Level.SEVERE,</span>
                    &quot;XMLCipher::decryptElement called without a key and unable to resolve&quot;
                );
<span class="nc" id="L1706">                throw new XMLEncryptionException(&quot;encryption.nokey&quot;);</span>
            }
        }

        // Obtain the encrypted octets
<span class="nc" id="L1711">        XMLCipherInput cipherInput = new XMLCipherInput(encryptedData);</span>
<span class="nc" id="L1712">        cipherInput.setSecureValidation(secureValidation);</span>
<span class="nc" id="L1713">        byte[] encryptedBytes = cipherInput.getBytes();</span>

        // Now create the working cipher
<span class="nc" id="L1716">        String jceAlgorithm =</span>
<span class="nc" id="L1717">            JCEMapper.translateURItoJCEID(encryptedData.getEncryptionMethod().getAlgorithm());</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L1719">            log.log(java.util.logging.Level.FINE, &quot;JCE Algorithm = &quot; + jceAlgorithm);</span>
        }

        Cipher c;
        try {
<span class="nc bnc" id="L1724" title="All 2 branches missed.">            if (requestedJCEProvider == null) {</span>
<span class="nc" id="L1725">                c = Cipher.getInstance(jceAlgorithm);</span>
            } else {
<span class="nc" id="L1727">                c = Cipher.getInstance(jceAlgorithm, requestedJCEProvider);</span>
            }
<span class="nc" id="L1729">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L1730">            throw new XMLEncryptionException(&quot;empty&quot;, nsae);</span>
<span class="nc" id="L1731">        } catch (NoSuchProviderException nspre) {</span>
<span class="nc" id="L1732">            throw new XMLEncryptionException(&quot;empty&quot;, nspre);</span>
<span class="nc" id="L1733">        } catch (NoSuchPaddingException nspae) {</span>
<span class="nc" id="L1734">            throw new XMLEncryptionException(&quot;empty&quot;, nspae);</span>
<span class="nc" id="L1735">        }</span>

        // Calculate the IV length and copy out

        // For now, we only work with Block ciphers, so this will work.
        // This should probably be put into the JCE mapper.

<span class="nc" id="L1742">        int ivLen = c.getBlockSize();</span>
<span class="nc" id="L1743">        String alg = encryptedData.getEncryptionMethod().getAlgorithm();</span>
<span class="nc bnc" id="L1744" title="All 6 branches missed.">        if (AES_128_GCM.equals(alg) || AES_192_GCM.equals(alg) || AES_256_GCM.equals(alg)) {</span>
<span class="nc" id="L1745">            ivLen = 12;</span>
        }
<span class="nc" id="L1747">        byte[] ivBytes = new byte[ivLen];</span>

        // You may be able to pass the entire piece in to IvParameterSpec
        // and it will only take the first x bytes, but no way to be certain
        // that this will work for every JCE provider, so lets copy the
        // necessary bytes into a dedicated array.

<span class="nc" id="L1754">        System.arraycopy(encryptedBytes, 0, ivBytes, 0, ivLen);</span>
<span class="nc" id="L1755">        IvParameterSpec iv = new IvParameterSpec(ivBytes);</span>

        try {
<span class="nc" id="L1758">            c.init(cipherMode, key, iv);</span>
<span class="nc" id="L1759">        } catch (InvalidKeyException ike) {</span>
<span class="nc" id="L1760">            throw new XMLEncryptionException(&quot;empty&quot;, ike);</span>
<span class="nc" id="L1761">        } catch (InvalidAlgorithmParameterException iape) {</span>
<span class="nc" id="L1762">            throw new XMLEncryptionException(&quot;empty&quot;, iape);</span>
<span class="nc" id="L1763">        }</span>

        try {
<span class="nc" id="L1766">            return c.doFinal(encryptedBytes, ivLen, encryptedBytes.length - ivLen);</span>
<span class="nc" id="L1767">        } catch (IllegalBlockSizeException ibse) {</span>
<span class="nc" id="L1768">            throw new XMLEncryptionException(&quot;empty&quot;, ibse);</span>
<span class="nc" id="L1769">        } catch (BadPaddingException bpe) {</span>
<span class="nc" id="L1770">            throw new XMLEncryptionException(&quot;empty&quot;, bpe);</span>
        }
    }

    /*
     * Expose the interface for creating XML Encryption objects
     */

    /**
     * Creates an &lt;code&gt;EncryptedData&lt;/code&gt; &lt;code&gt;Element&lt;/code&gt;.
     *
     * The newEncryptedData and newEncryptedKey methods create fairly complete
     * elements that are immediately useable.  All the other create* methods
     * return bare elements that still need to be built upon.
     *&lt;p&gt;
     * An EncryptionMethod will still need to be added however
     *
     * @param type Either REFERENCE_TYPE or VALUE_TYPE - defines what kind of
     * CipherData this EncryptedData will contain.
     * @param value the Base 64 encoded, encrypted text to wrap in the
     *   &lt;code&gt;EncryptedData&lt;/code&gt; or the URI to set in the CipherReference
     * (usage will depend on the &lt;code&gt;type&lt;/code&gt;
     * @return the &lt;code&gt;EncryptedData&lt;/code&gt; &lt;code&gt;Element&lt;/code&gt;.
     *
     * &lt;!--
     * &lt;EncryptedData Id[OPT] Type[OPT] MimeType[OPT] Encoding[OPT]&gt;
     *     &lt;EncryptionMethod/&gt;[OPT]
     *     &lt;ds:KeyInfo&gt;[OPT]
     *         &lt;EncryptedKey/&gt;[OPT]
     *         &lt;AgreementMethod/&gt;[OPT]
     *         &lt;ds:KeyName/&gt;[OPT]
     *         &lt;ds:RetrievalMethod/&gt;[OPT]
     *         &lt;ds:[MUL]/&gt;[OPT]
     *     &lt;/ds:KeyInfo&gt;
     *     &lt;CipherData&gt;[MAN]
     *         &lt;CipherValue/&gt; XOR &lt;CipherReference/&gt;
     *     &lt;/CipherData&gt;
     *     &lt;EncryptionProperties/&gt;[OPT]
     * &lt;/EncryptedData&gt;
     * --&gt;
     * @throws XMLEncryptionException
     */
    public EncryptedData createEncryptedData(int type, String value) throws XMLEncryptionException {
<span class="nc" id="L1813">        EncryptedData result = null;</span>
<span class="nc" id="L1814">        CipherData data = null;</span>

<span class="nc bnc" id="L1816" title="All 3 branches missed.">        switch (type) {</span>
        case CipherData.REFERENCE_TYPE:
<span class="nc" id="L1818">            CipherReference cipherReference = factory.newCipherReference(value);</span>
<span class="nc" id="L1819">            data = factory.newCipherData(type);</span>
<span class="nc" id="L1820">            data.setCipherReference(cipherReference);</span>
<span class="nc" id="L1821">            result = factory.newEncryptedData(data);</span>
<span class="nc" id="L1822">            break;</span>
        case CipherData.VALUE_TYPE:
<span class="nc" id="L1824">            CipherValue cipherValue = factory.newCipherValue(value);</span>
<span class="nc" id="L1825">            data = factory.newCipherData(type);</span>
<span class="nc" id="L1826">            data.setCipherValue(cipherValue);</span>
<span class="nc" id="L1827">            result = factory.newEncryptedData(data);</span>
        }

<span class="nc" id="L1830">        return result;</span>
    }

    /**
     * Creates an &lt;code&gt;EncryptedKey&lt;/code&gt; &lt;code&gt;Element&lt;/code&gt;.
     *
     * The newEncryptedData and newEncryptedKey methods create fairly complete
     * elements that are immediately useable.  All the other create* methods
     * return bare elements that still need to be built upon.
     *&lt;p&gt;
     * An EncryptionMethod will still need to be added however
     *
     * @param type Either REFERENCE_TYPE or VALUE_TYPE - defines what kind of
     * CipherData this EncryptedData will contain.
     * @param value the Base 64 encoded, encrypted text to wrap in the
     *   &lt;code&gt;EncryptedKey&lt;/code&gt; or the URI to set in the CipherReference
     * (usage will depend on the &lt;code&gt;type&lt;/code&gt;
     * @return the &lt;code&gt;EncryptedKey&lt;/code&gt; &lt;code&gt;Element&lt;/code&gt;.
     *
     * &lt;!--
     * &lt;EncryptedKey Id[OPT] Type[OPT] MimeType[OPT] Encoding[OPT]&gt;
     *     &lt;EncryptionMethod/&gt;[OPT]
     *     &lt;ds:KeyInfo&gt;[OPT]
     *         &lt;EncryptedKey/&gt;[OPT]
     *         &lt;AgreementMethod/&gt;[OPT]
     *         &lt;ds:KeyName/&gt;[OPT]
     *         &lt;ds:RetrievalMethod/&gt;[OPT]
     *         &lt;ds:[MUL]/&gt;[OPT]
     *     &lt;/ds:KeyInfo&gt;
     *     &lt;CipherData&gt;[MAN]
     *         &lt;CipherValue/&gt; XOR &lt;CipherReference/&gt;
     *     &lt;/CipherData&gt;
     *     &lt;EncryptionProperties/&gt;[OPT]
     * &lt;/EncryptedData&gt;
     * --&gt;
     * @throws XMLEncryptionException
     */
    public EncryptedKey createEncryptedKey(int type, String value) throws XMLEncryptionException {
<span class="nc" id="L1868">        EncryptedKey result = null;</span>
<span class="nc" id="L1869">        CipherData data = null;</span>

<span class="nc bnc" id="L1871" title="All 3 branches missed.">        switch (type) {</span>
        case CipherData.REFERENCE_TYPE:
<span class="nc" id="L1873">            CipherReference cipherReference = factory.newCipherReference(value);</span>
<span class="nc" id="L1874">            data = factory.newCipherData(type);</span>
<span class="nc" id="L1875">            data.setCipherReference(cipherReference);</span>
<span class="nc" id="L1876">            result = factory.newEncryptedKey(data);</span>
<span class="nc" id="L1877">            break;</span>
        case CipherData.VALUE_TYPE:
<span class="nc" id="L1879">            CipherValue cipherValue = factory.newCipherValue(value);</span>
<span class="nc" id="L1880">            data = factory.newCipherData(type);</span>
<span class="nc" id="L1881">            data.setCipherValue(cipherValue);</span>
<span class="nc" id="L1882">            result = factory.newEncryptedKey(data);</span>
        }

<span class="nc" id="L1885">        return result;</span>
    }

    /**
     * Create an AgreementMethod object
     *
     * @param algorithm Algorithm of the agreement method
     * @return a new &lt;code&gt;AgreementMethod&lt;/code&gt;
     */
    public AgreementMethod createAgreementMethod(String algorithm) {
<span class="nc" id="L1895">        return factory.newAgreementMethod(algorithm);</span>
    }

    /**
     * Create a CipherData object
     *
     * @param type Type of this CipherData (either VALUE_TUPE or
     * REFERENCE_TYPE)
     * @return a new &lt;code&gt;CipherData&lt;/code&gt;
     */
    public CipherData createCipherData(int type) {
<span class="nc" id="L1906">        return factory.newCipherData(type);</span>
    }

    /**
     * Create a CipherReference object
     *
     * @param uri The URI that the reference will refer
     * @return a new &lt;code&gt;CipherReference&lt;/code&gt;
     */
    public CipherReference createCipherReference(String uri) {
<span class="nc" id="L1916">        return factory.newCipherReference(uri);</span>
    }

    /**
     * Create a CipherValue element
     *
     * @param value The value to set the ciphertext to
     * @return a new &lt;code&gt;CipherValue&lt;/code&gt;
     */
    public CipherValue createCipherValue(String value) {
<span class="nc" id="L1926">        return factory.newCipherValue(value);</span>
    }

    /**
     * Create an EncryptionMethod object
     *
     * @param algorithm Algorithm for the encryption
     * @return a new &lt;code&gt;EncryptionMethod&lt;/code&gt;
     */
    public EncryptionMethod createEncryptionMethod(String algorithm) {
<span class="nc" id="L1936">        return factory.newEncryptionMethod(algorithm);</span>
    }

    /**
     * Create an EncryptionProperties element
     * @return a new &lt;code&gt;EncryptionProperties&lt;/code&gt;
     */
    public EncryptionProperties createEncryptionProperties() {
<span class="nc" id="L1944">        return factory.newEncryptionProperties();</span>
    }

    /**
     * Create a new EncryptionProperty element
     * @return a new &lt;code&gt;EncryptionProperty&lt;/code&gt;
     */
    public EncryptionProperty createEncryptionProperty() {
<span class="nc" id="L1952">        return factory.newEncryptionProperty();</span>
    }

    /**
     * Create a new ReferenceList object
     * @param type ReferenceList.DATA_REFERENCE or ReferenceList.KEY_REFERENCE
     * @return a new &lt;code&gt;ReferenceList&lt;/code&gt;
     */
    public ReferenceList createReferenceList(int type) {
<span class="nc" id="L1961">        return factory.newReferenceList(type);</span>
    }

    /**
     * Create a new Transforms object
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt;: A context document &lt;i&gt;must&lt;/i&gt; have been set
     * elsewhere (possibly via a call to doFinal).  If not, use the
     * createTransforms(Document) method.
     * @return a new &lt;code&gt;Transforms&lt;/code&gt;
     */
    public Transforms createTransforms() {
<span class="nc" id="L1973">        return factory.newTransforms();</span>
    }

    /**
     * Create a new Transforms object
     *
     * Because the handling of Transforms is currently done in the signature
     * code, the creation of a Transforms object &lt;b&gt;requires&lt;/b&gt; a
     * context document.
     *
     * @param doc Document that will own the created Transforms node
     * @return a new &lt;code&gt;Transforms&lt;/code&gt;
     */
    public Transforms createTransforms(Document doc) {
<span class="nc" id="L1987">        return factory.newTransforms(doc);</span>
    }

    /**
     *
     * @author Axl Mattheus
     */
<span class="nc" id="L1994">    private class Factory {</span>
        /**
         * @param algorithm
         * @return a new AgreementMethod
         */
        AgreementMethod newAgreementMethod(String algorithm)  {
<span class="nc" id="L2000">            return new AgreementMethodImpl(algorithm);</span>
        }

        /**
         * @param type
         * @return a new CipherData
         *
         */
        CipherData newCipherData(int type) {
<span class="nc" id="L2009">            return new CipherDataImpl(type);</span>
        }

        /**
         * @param uri
         * @return a new CipherReference
         */
        CipherReference newCipherReference(String uri)  {
<span class="nc" id="L2017">            return new CipherReferenceImpl(uri);</span>
        }

        /**
         * @param value
         * @return a new CipherValue
         */
        CipherValue newCipherValue(String value) {
<span class="nc" id="L2025">            return new CipherValueImpl(value);</span>
        }

        /*
        CipherValue newCipherValue(byte[] value) {
            return new CipherValueImpl(value);
        }
         */

        /**
         * @param data
         * @return a new EncryptedData
         */
        EncryptedData newEncryptedData(CipherData data) {
<span class="nc" id="L2039">            return new EncryptedDataImpl(data);</span>
        }

        /**
         * @param data
         * @return a new EncryptedKey
         */
        EncryptedKey newEncryptedKey(CipherData data) {
<span class="nc" id="L2047">            return new EncryptedKeyImpl(data);</span>
        }

        /**
         * @param algorithm
         * @return a new EncryptionMethod
         */
        EncryptionMethod newEncryptionMethod(String algorithm) {
<span class="nc" id="L2055">            return new EncryptionMethodImpl(algorithm);</span>
        }

        /**
         * @return a new EncryptionProperties
         */
        EncryptionProperties newEncryptionProperties() {
<span class="nc" id="L2062">            return new EncryptionPropertiesImpl();</span>
        }

        /**
         * @return a new EncryptionProperty
         */
        EncryptionProperty newEncryptionProperty() {
<span class="nc" id="L2069">            return new EncryptionPropertyImpl();</span>
        }

        /**
         * @param type ReferenceList.DATA_REFERENCE or ReferenceList.KEY_REFERENCE
         * @return a new ReferenceList
         */
        ReferenceList newReferenceList(int type) {
<span class="nc" id="L2077">            return new ReferenceListImpl(type);</span>
        }

        /**
         * @return a new Transforms
         */
        Transforms newTransforms() {
<span class="nc" id="L2084">            return new TransformsImpl();</span>
        }

        /**
         * @param doc
         * @return a new Transforms
         */
        Transforms newTransforms(Document doc) {
<span class="nc" id="L2092">            return new TransformsImpl(doc);</span>
        }

        /**
         * @param element
         * @return a new CipherData
         * @throws XMLEncryptionException
         */
        CipherData newCipherData(Element element) throws XMLEncryptionException {
<span class="nc bnc" id="L2101" title="All 2 branches missed.">            if (null == element) {</span>
<span class="nc" id="L2102">                throw new NullPointerException(&quot;element is null&quot;);</span>
            }

<span class="nc" id="L2105">            int type = 0;</span>
<span class="nc" id="L2106">            Element e = null;</span>
<span class="nc" id="L2107">            if (element.getElementsByTagNameNS(</span>
                EncryptionConstants.EncryptionSpecNS,
<span class="nc bnc" id="L2109" title="All 2 branches missed.">                EncryptionConstants._TAG_CIPHERVALUE).getLength() &gt; 0</span>
            ) {
<span class="nc" id="L2111">                type = CipherData.VALUE_TYPE;</span>
<span class="nc" id="L2112">                e = (Element) element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS,
<span class="nc" id="L2114">                    EncryptionConstants._TAG_CIPHERVALUE).item(0);</span>
<span class="nc" id="L2115">            } else if (element.getElementsByTagNameNS(</span>
                EncryptionConstants.EncryptionSpecNS,
<span class="nc bnc" id="L2117" title="All 2 branches missed.">                EncryptionConstants._TAG_CIPHERREFERENCE).getLength() &gt; 0) {</span>
<span class="nc" id="L2118">                type = CipherData.REFERENCE_TYPE;</span>
<span class="nc" id="L2119">                e = (Element) element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS,
<span class="nc" id="L2121">                    EncryptionConstants._TAG_CIPHERREFERENCE).item(0);</span>
            }

<span class="nc" id="L2124">            CipherData result = newCipherData(type);</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">            if (type == CipherData.VALUE_TYPE) {</span>
<span class="nc" id="L2126">                result.setCipherValue(newCipherValue(e));</span>
<span class="nc bnc" id="L2127" title="All 2 branches missed.">            } else if (type == CipherData.REFERENCE_TYPE) {</span>
<span class="nc" id="L2128">                result.setCipherReference(newCipherReference(e));</span>
            }

<span class="nc" id="L2131">            return result;</span>
        }

        /**
         * @param element
         * @return a new CipherReference
         * @throws XMLEncryptionException
         *
         */
        CipherReference newCipherReference(Element element) throws XMLEncryptionException {

<span class="nc" id="L2142">            Attr uriAttr =</span>
<span class="nc" id="L2143">                element.getAttributeNodeNS(null, EncryptionConstants._ATT_URI);</span>
<span class="nc" id="L2144">            CipherReference result = new CipherReferenceImpl(uriAttr);</span>

            // Find any Transforms
<span class="nc" id="L2147">            NodeList transformsElements =</span>
<span class="nc" id="L2148">                element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS, EncryptionConstants._TAG_TRANSFORMS);
<span class="nc" id="L2150">            Element transformsElement = (Element) transformsElements.item(0);</span>

<span class="nc bnc" id="L2152" title="All 2 branches missed.">            if (transformsElement != null) {</span>
<span class="nc bnc" id="L2153" title="All 2 branches missed.">                if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L2154">                    log.log(java.util.logging.Level.FINE, &quot;Creating a DSIG based Transforms element&quot;);</span>
                }
                try {
<span class="nc" id="L2157">                    result.setTransforms(new TransformsImpl(transformsElement));</span>
<span class="nc" id="L2158">                } catch (XMLSignatureException xse) {</span>
<span class="nc" id="L2159">                    throw new XMLEncryptionException(&quot;empty&quot;, xse);</span>
<span class="nc" id="L2160">                } catch (InvalidTransformException ite) {</span>
<span class="nc" id="L2161">                    throw new XMLEncryptionException(&quot;empty&quot;, ite);</span>
<span class="nc" id="L2162">                } catch (XMLSecurityException xse) {</span>
<span class="nc" id="L2163">                    throw new XMLEncryptionException(&quot;empty&quot;, xse);</span>
<span class="nc" id="L2164">                }</span>
            }

<span class="nc" id="L2167">            return result;</span>
        }

        /**
         * @param element
         * @return a new CipherValue
         */
        CipherValue newCipherValue(Element element) {
<span class="nc" id="L2175">            String value = XMLUtils.getFullTextChildrenFromElement(element);</span>

<span class="nc" id="L2177">            return newCipherValue(value);</span>
        }

        /**
         * @param element
         * @return a new EncryptedData
         * @throws XMLEncryptionException
         *
         */
        EncryptedData newEncryptedData(Element element) throws XMLEncryptionException {
<span class="nc" id="L2187">            EncryptedData result = null;</span>

<span class="nc" id="L2189">            NodeList dataElements =</span>
<span class="nc" id="L2190">                element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS, EncryptionConstants._TAG_CIPHERDATA);

            // Need to get the last CipherData found, as earlier ones will
            // be for elements in the KeyInfo lists

<span class="nc" id="L2196">            Element dataElement =</span>
<span class="nc" id="L2197">                (Element) dataElements.item(dataElements.getLength() - 1);</span>

<span class="nc" id="L2199">            CipherData data = newCipherData(dataElement);</span>

<span class="nc" id="L2201">            result = newEncryptedData(data);</span>

<span class="nc" id="L2203">            result.setId(element.getAttributeNS(null, EncryptionConstants._ATT_ID));</span>
<span class="nc" id="L2204">            result.setType(element.getAttributeNS(null, EncryptionConstants._ATT_TYPE));</span>
<span class="nc" id="L2205">            result.setMimeType(element.getAttributeNS(null, EncryptionConstants._ATT_MIMETYPE));</span>
<span class="nc" id="L2206">            result.setEncoding( element.getAttributeNS(null, Constants._ATT_ENCODING));</span>

<span class="nc" id="L2208">            Element encryptionMethodElement =</span>
<span class="nc" id="L2209">                (Element) element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS,
<span class="nc" id="L2211">                    EncryptionConstants._TAG_ENCRYPTIONMETHOD).item(0);</span>
<span class="nc bnc" id="L2212" title="All 2 branches missed.">            if (null != encryptionMethodElement) {</span>
<span class="nc" id="L2213">                result.setEncryptionMethod(newEncryptionMethod(encryptionMethodElement));</span>
            }

            // BFL 16/7/03 - simple implementation
            // TODO: Work out how to handle relative URI

<span class="nc" id="L2219">            Element keyInfoElement =</span>
<span class="nc" id="L2220">                (Element) element.getElementsByTagNameNS(</span>
<span class="nc" id="L2221">                    Constants.SignatureSpecNS, Constants._TAG_KEYINFO).item(0);</span>
<span class="nc bnc" id="L2222" title="All 2 branches missed.">            if (null != keyInfoElement) {</span>
<span class="nc" id="L2223">                KeyInfo ki = newKeyInfo(keyInfoElement);</span>
<span class="nc" id="L2224">                result.setKeyInfo(ki);</span>
            }

            // TODO: Implement
<span class="nc" id="L2228">            Element encryptionPropertiesElement =</span>
<span class="nc" id="L2229">                (Element) element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS,
<span class="nc" id="L2231">                    EncryptionConstants._TAG_ENCRYPTIONPROPERTIES).item(0);</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">            if (null != encryptionPropertiesElement) {</span>
<span class="nc" id="L2233">                result.setEncryptionProperties(</span>
<span class="nc" id="L2234">                    newEncryptionProperties(encryptionPropertiesElement)</span>
                );
            }

<span class="nc" id="L2238">            return result;</span>
        }

        /**
         * @param element
         * @return a new EncryptedKey
         * @throws XMLEncryptionException
         */
        EncryptedKey newEncryptedKey(Element element) throws XMLEncryptionException {
<span class="nc" id="L2247">            EncryptedKey result = null;</span>
<span class="nc" id="L2248">            NodeList dataElements =</span>
<span class="nc" id="L2249">                element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS, EncryptionConstants._TAG_CIPHERDATA);
<span class="nc" id="L2251">            Element dataElement =</span>
<span class="nc" id="L2252">                (Element) dataElements.item(dataElements.getLength() - 1);</span>

<span class="nc" id="L2254">            CipherData data = newCipherData(dataElement);</span>
<span class="nc" id="L2255">            result = newEncryptedKey(data);</span>

<span class="nc" id="L2257">            result.setId(element.getAttributeNS(null, EncryptionConstants._ATT_ID));</span>
<span class="nc" id="L2258">            result.setType(element.getAttributeNS(null, EncryptionConstants._ATT_TYPE));</span>
<span class="nc" id="L2259">            result.setMimeType(element.getAttributeNS(null, EncryptionConstants._ATT_MIMETYPE));</span>
<span class="nc" id="L2260">            result.setEncoding(element.getAttributeNS(null, Constants._ATT_ENCODING));</span>
<span class="nc" id="L2261">            result.setRecipient(element.getAttributeNS(null, EncryptionConstants._ATT_RECIPIENT));</span>

<span class="nc" id="L2263">            Element encryptionMethodElement =</span>
<span class="nc" id="L2264">                (Element) element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS,
<span class="nc" id="L2266">                    EncryptionConstants._TAG_ENCRYPTIONMETHOD).item(0);</span>
<span class="nc bnc" id="L2267" title="All 2 branches missed.">            if (null != encryptionMethodElement) {</span>
<span class="nc" id="L2268">                result.setEncryptionMethod(newEncryptionMethod(encryptionMethodElement));</span>
            }

<span class="nc" id="L2271">            Element keyInfoElement =</span>
<span class="nc" id="L2272">                (Element) element.getElementsByTagNameNS(</span>
<span class="nc" id="L2273">                    Constants.SignatureSpecNS, Constants._TAG_KEYINFO).item(0);</span>
<span class="nc bnc" id="L2274" title="All 2 branches missed.">            if (null != keyInfoElement) {</span>
<span class="nc" id="L2275">                KeyInfo ki = newKeyInfo(keyInfoElement);</span>
<span class="nc" id="L2276">                result.setKeyInfo(ki);</span>
            }

            // TODO: Implement
<span class="nc" id="L2280">            Element encryptionPropertiesElement =</span>
<span class="nc" id="L2281">                (Element) element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS,
<span class="nc" id="L2283">                    EncryptionConstants._TAG_ENCRYPTIONPROPERTIES).item(0);</span>
<span class="nc bnc" id="L2284" title="All 2 branches missed.">            if (null != encryptionPropertiesElement) {</span>
<span class="nc" id="L2285">                result.setEncryptionProperties(</span>
<span class="nc" id="L2286">                    newEncryptionProperties(encryptionPropertiesElement)</span>
                );
            }

<span class="nc" id="L2290">            Element referenceListElement =</span>
<span class="nc" id="L2291">                (Element) element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS,
<span class="nc" id="L2293">                    EncryptionConstants._TAG_REFERENCELIST).item(0);</span>
<span class="nc bnc" id="L2294" title="All 2 branches missed.">            if (null != referenceListElement) {</span>
<span class="nc" id="L2295">                result.setReferenceList(newReferenceList(referenceListElement));</span>
            }

<span class="nc" id="L2298">            Element carriedNameElement =</span>
<span class="nc" id="L2299">                (Element) element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS,
<span class="nc" id="L2301">                    EncryptionConstants._TAG_CARRIEDKEYNAME).item(0);</span>
<span class="nc bnc" id="L2302" title="All 2 branches missed.">            if (null != carriedNameElement) {</span>
<span class="nc" id="L2303">                result.setCarriedName(carriedNameElement.getFirstChild().getNodeValue());</span>
            }

<span class="nc" id="L2306">            return result;</span>
        }

        /**
         * @param element
         * @return a new KeyInfo
         * @throws XMLEncryptionException
         */
        KeyInfo newKeyInfo(Element element) throws XMLEncryptionException {
            try {
<span class="nc" id="L2316">                KeyInfo ki = new KeyInfo(element, null);</span>
<span class="nc" id="L2317">                ki.setSecureValidation(secureValidation);</span>
<span class="nc bnc" id="L2318" title="All 2 branches missed.">                if (internalKeyResolvers != null) {</span>
<span class="nc" id="L2319">                    int size = internalKeyResolvers.size();</span>
<span class="nc bnc" id="L2320" title="All 2 branches missed.">                    for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L2321">                        ki.registerInternalKeyResolver(internalKeyResolvers.get(i));</span>
                    }
                }
<span class="nc" id="L2324">                return ki;</span>
<span class="nc" id="L2325">            } catch (XMLSecurityException xse) {</span>
<span class="nc" id="L2326">                throw new XMLEncryptionException(&quot;Error loading Key Info&quot;, xse);</span>
            }
        }

        /**
         * @param element
         * @return a new EncryptionMethod
         */
        EncryptionMethod newEncryptionMethod(Element element) {
<span class="nc" id="L2335">            String encAlgorithm = element.getAttributeNS(null, EncryptionConstants._ATT_ALGORITHM);</span>
<span class="nc" id="L2336">            EncryptionMethod result = newEncryptionMethod(encAlgorithm);</span>

<span class="nc" id="L2338">            Element keySizeElement =</span>
<span class="nc" id="L2339">                (Element) element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS,
<span class="nc" id="L2341">                    EncryptionConstants._TAG_KEYSIZE).item(0);</span>
<span class="nc bnc" id="L2342" title="All 2 branches missed.">            if (null != keySizeElement) {</span>
<span class="nc" id="L2343">                result.setKeySize(</span>
<span class="nc" id="L2344">                    Integer.valueOf(</span>
<span class="nc" id="L2345">                        keySizeElement.getFirstChild().getNodeValue()).intValue());</span>
            }

<span class="nc" id="L2348">            Element oaepParamsElement =</span>
<span class="nc" id="L2349">                (Element) element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS,
<span class="nc" id="L2351">                    EncryptionConstants._TAG_OAEPPARAMS).item(0);</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">            if (null != oaepParamsElement) {</span>
                try {
<span class="nc" id="L2354">                    String oaepParams = oaepParamsElement.getFirstChild().getNodeValue();</span>
<span class="nc" id="L2355">                    result.setOAEPparams(Base64.decode(oaepParams.getBytes(&quot;UTF-8&quot;)));</span>
<span class="nc" id="L2356">                } catch(UnsupportedEncodingException e) {</span>
<span class="nc" id="L2357">                    throw new RuntimeException(&quot;UTF-8 not supported&quot;, e);</span>
<span class="nc" id="L2358">                } catch (Base64DecodingException e) {</span>
<span class="nc" id="L2359">                    throw new RuntimeException(&quot;BASE-64 decoding error&quot;, e);</span>
<span class="nc" id="L2360">                }</span>
            }

<span class="nc" id="L2363">            Element digestElement =</span>
<span class="nc" id="L2364">                (Element) element.getElementsByTagNameNS(</span>
<span class="nc" id="L2365">                    Constants.SignatureSpecNS, Constants._TAG_DIGESTMETHOD).item(0);</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">            if (digestElement != null) {</span>
<span class="nc" id="L2367">                String digestAlgorithm = digestElement.getAttributeNS(null, &quot;Algorithm&quot;);</span>
<span class="nc" id="L2368">                result.setDigestAlgorithm(digestAlgorithm);</span>
            }

<span class="nc" id="L2371">            Element mgfElement =</span>
<span class="nc" id="L2372">                (Element) element.getElementsByTagNameNS(</span>
<span class="nc" id="L2373">                    EncryptionConstants.EncryptionSpec11NS, EncryptionConstants._TAG_MGF).item(0);</span>
<span class="nc bnc" id="L2374" title="All 4 branches missed.">            if (mgfElement != null &amp;&amp; !XMLCipher.RSA_OAEP.equals(algorithm)) {</span>
<span class="nc" id="L2375">                String mgfAlgorithm = mgfElement.getAttributeNS(null, &quot;Algorithm&quot;);</span>
<span class="nc" id="L2376">                result.setMGFAlgorithm(mgfAlgorithm);</span>
            }

            // TODO: Make this mess work
            // &lt;any namespace='##other' minOccurs='0' maxOccurs='unbounded'/&gt;

<span class="nc" id="L2382">            return result;</span>
        }

        /**
         * @param element
         * @return a new EncryptionProperties
         */
        EncryptionProperties newEncryptionProperties(Element element) {
<span class="nc" id="L2390">            EncryptionProperties result = newEncryptionProperties();</span>

<span class="nc" id="L2392">            result.setId(element.getAttributeNS(null, EncryptionConstants._ATT_ID));</span>

<span class="nc" id="L2394">            NodeList encryptionPropertyList =</span>
<span class="nc" id="L2395">                element.getElementsByTagNameNS(</span>
                    EncryptionConstants.EncryptionSpecNS,
                    EncryptionConstants._TAG_ENCRYPTIONPROPERTY);
<span class="nc bnc" id="L2398" title="All 2 branches missed.">            for (int i = 0; i &lt; encryptionPropertyList.getLength(); i++) {</span>
<span class="nc" id="L2399">                Node n = encryptionPropertyList.item(i);</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">                if (null != n) {</span>
<span class="nc" id="L2401">                    result.addEncryptionProperty(newEncryptionProperty((Element) n));</span>
                }
            }

<span class="nc" id="L2405">            return result;</span>
        }

        /**
         * @param element
         * @return a new EncryptionProperty
         */
        EncryptionProperty newEncryptionProperty(Element element) {
<span class="nc" id="L2413">            EncryptionProperty result = newEncryptionProperty();</span>

<span class="nc" id="L2415">            result.setTarget(element.getAttributeNS(null, EncryptionConstants._ATT_TARGET));</span>
<span class="nc" id="L2416">            result.setId(element.getAttributeNS(null, EncryptionConstants._ATT_ID));</span>
            // TODO: Make this lot work...
            // &lt;anyAttribute namespace=&quot;http://www.w3.org/XML/1998/namespace&quot;/&gt;

            // TODO: Make this work...
            // &lt;any namespace='##other' processContents='lax'/&gt;

<span class="nc" id="L2423">            return result;</span>
        }

        /**
         * @param element
         * @return a new ReferenceList
         */
        ReferenceList newReferenceList(Element element) {
<span class="nc" id="L2431">            int type = 0;</span>
<span class="nc" id="L2432">            if (null != element.getElementsByTagNameNS(</span>
                EncryptionConstants.EncryptionSpecNS,
<span class="nc bnc" id="L2434" title="All 2 branches missed.">                EncryptionConstants._TAG_DATAREFERENCE).item(0)) {</span>
<span class="nc" id="L2435">                type = ReferenceList.DATA_REFERENCE;</span>
<span class="nc" id="L2436">            } else if (null != element.getElementsByTagNameNS(</span>
                EncryptionConstants.EncryptionSpecNS,
<span class="nc bnc" id="L2438" title="All 2 branches missed.">                EncryptionConstants._TAG_KEYREFERENCE).item(0)) {</span>
<span class="nc" id="L2439">                type = ReferenceList.KEY_REFERENCE;</span>
            }

<span class="nc" id="L2442">            ReferenceList result = new ReferenceListImpl(type);</span>
<span class="nc" id="L2443">            NodeList list = null;</span>
<span class="nc bnc" id="L2444" title="All 3 branches missed.">            switch (type) {</span>
            case ReferenceList.DATA_REFERENCE:
<span class="nc" id="L2446">                list =</span>
<span class="nc" id="L2447">                    element.getElementsByTagNameNS(</span>
                        EncryptionConstants.EncryptionSpecNS,
                        EncryptionConstants._TAG_DATAREFERENCE);
<span class="nc bnc" id="L2450" title="All 2 branches missed.">                for (int i = 0; i &lt; list.getLength() ; i++) {</span>
<span class="nc" id="L2451">                    String uri = ((Element) list.item(i)).getAttribute(&quot;URI&quot;);</span>
<span class="nc" id="L2452">                    result.add(result.newDataReference(uri));</span>
                }
<span class="nc" id="L2454">                break;</span>
            case ReferenceList.KEY_REFERENCE:
<span class="nc" id="L2456">                list =</span>
<span class="nc" id="L2457">                    element.getElementsByTagNameNS(</span>
                        EncryptionConstants.EncryptionSpecNS,
                        EncryptionConstants._TAG_KEYREFERENCE);
<span class="nc bnc" id="L2460" title="All 2 branches missed.">                for (int i = 0; i &lt; list.getLength() ; i++) {</span>
<span class="nc" id="L2461">                    String uri = ((Element) list.item(i)).getAttribute(&quot;URI&quot;);</span>
<span class="nc" id="L2462">                    result.add(result.newKeyReference(uri));</span>
                }
            }

<span class="nc" id="L2466">            return result;</span>
        }

        /**
         * @param encryptedData
         * @return the XML Element form of that EncryptedData
         */
        Element toElement(EncryptedData encryptedData) {
<span class="nc" id="L2474">            return ((EncryptedDataImpl) encryptedData).toElement();</span>
        }

        /**
         * @param encryptedKey
         * @return the XML Element form of that EncryptedKey
         */
        Element toElement(EncryptedKey encryptedKey) {
<span class="nc" id="L2482">            return ((EncryptedKeyImpl) encryptedKey).toElement();</span>
        }

        /**
         * @param referenceList
         * @return the XML Element form of that ReferenceList
         */
        Element toElement(ReferenceList referenceList) {
<span class="nc" id="L2490">            return ((ReferenceListImpl) referenceList).toElement();</span>
        }

        private class AgreementMethodImpl implements AgreementMethod {
<span class="nc" id="L2494">            private byte[] kaNonce = null;</span>
<span class="nc" id="L2495">            private List&lt;Element&gt; agreementMethodInformation = null;</span>
<span class="nc" id="L2496">            private KeyInfo originatorKeyInfo = null;</span>
<span class="nc" id="L2497">            private KeyInfo recipientKeyInfo = null;</span>
<span class="nc" id="L2498">            private String algorithmURI = null;</span>

            /**
             * @param algorithm
             */
<span class="nc" id="L2503">            public AgreementMethodImpl(String algorithm) {</span>
<span class="nc" id="L2504">                agreementMethodInformation = new LinkedList&lt;Element&gt;();</span>
<span class="nc" id="L2505">                URI tmpAlgorithm = null;</span>
                try {
<span class="nc" id="L2507">                    tmpAlgorithm = new URI(algorithm);</span>
<span class="nc" id="L2508">                } catch (URISyntaxException ex) {</span>
<span class="nc" id="L2509">                    throw (IllegalArgumentException)</span>
<span class="nc" id="L2510">                    new IllegalArgumentException().initCause(ex);</span>
<span class="nc" id="L2511">                }</span>
<span class="nc" id="L2512">                algorithmURI = tmpAlgorithm.toString();</span>
<span class="nc" id="L2513">            }</span>

            /** @inheritDoc */
            public byte[] getKANonce() {
<span class="nc" id="L2517">                return kaNonce;</span>
            }

            /** @inheritDoc */
            public void setKANonce(byte[] kanonce) {
<span class="nc" id="L2522">                kaNonce = kanonce;</span>
<span class="nc" id="L2523">            }</span>

            /** @inheritDoc */
            public Iterator&lt;Element&gt; getAgreementMethodInformation() {
<span class="nc" id="L2527">                return agreementMethodInformation.iterator();</span>
            }

            /** @inheritDoc */
            public void addAgreementMethodInformation(Element info) {
<span class="nc" id="L2532">                agreementMethodInformation.add(info);</span>
<span class="nc" id="L2533">            }</span>

            /** @inheritDoc */
            public void revoveAgreementMethodInformation(Element info) {
<span class="nc" id="L2537">                agreementMethodInformation.remove(info);</span>
<span class="nc" id="L2538">            }</span>

            /** @inheritDoc */
            public KeyInfo getOriginatorKeyInfo() {
<span class="nc" id="L2542">                return originatorKeyInfo;</span>
            }

            /** @inheritDoc */
            public void setOriginatorKeyInfo(KeyInfo keyInfo) {
<span class="nc" id="L2547">                originatorKeyInfo = keyInfo;</span>
<span class="nc" id="L2548">            }</span>

            /** @inheritDoc */
            public KeyInfo getRecipientKeyInfo() {
<span class="nc" id="L2552">                return recipientKeyInfo;</span>
            }

            /** @inheritDoc */
            public void setRecipientKeyInfo(KeyInfo keyInfo) {
<span class="nc" id="L2557">                recipientKeyInfo = keyInfo;</span>
<span class="nc" id="L2558">            }</span>

            /** @inheritDoc */
            public String getAlgorithm() {
<span class="nc" id="L2562">                return algorithmURI;</span>
            }
        }

        private class CipherDataImpl implements CipherData {
            private static final String valueMessage =
                &quot;Data type is reference type.&quot;;
            private static final String referenceMessage =
                &quot;Data type is value type.&quot;;
<span class="nc" id="L2571">            private CipherValue cipherValue = null;</span>
<span class="nc" id="L2572">            private CipherReference cipherReference = null;</span>
<span class="nc" id="L2573">            private int cipherType = Integer.MIN_VALUE;</span>

            /**
             * @param type
             */
<span class="nc" id="L2578">            public CipherDataImpl(int type) {</span>
<span class="nc" id="L2579">                cipherType = type;</span>
<span class="nc" id="L2580">            }</span>

            /** @inheritDoc */
            public CipherValue getCipherValue() {
<span class="nc" id="L2584">                return cipherValue;</span>
            }

            /** @inheritDoc */
            public void setCipherValue(CipherValue value) throws XMLEncryptionException {

<span class="nc bnc" id="L2590" title="All 2 branches missed.">                if (cipherType == REFERENCE_TYPE) {</span>
<span class="nc" id="L2591">                    throw new XMLEncryptionException(</span>
                        &quot;empty&quot;, new UnsupportedOperationException(valueMessage)
                    );
                }

<span class="nc" id="L2596">                cipherValue = value;</span>
<span class="nc" id="L2597">            }</span>

            /** @inheritDoc */
            public CipherReference getCipherReference() {
<span class="nc" id="L2601">                return cipherReference;</span>
            }

            /** @inheritDoc */
            public void setCipherReference(CipherReference reference) throws
            XMLEncryptionException {
<span class="nc bnc" id="L2607" title="All 2 branches missed.">                if (cipherType == VALUE_TYPE) {</span>
<span class="nc" id="L2608">                    throw new XMLEncryptionException(</span>
                        &quot;empty&quot;, new UnsupportedOperationException(referenceMessage)
                    );
                }

<span class="nc" id="L2613">                cipherReference = reference;</span>
<span class="nc" id="L2614">            }</span>

            /** @inheritDoc */
            public int getDataType() {
<span class="nc" id="L2618">                return cipherType;</span>
            }

            Element toElement() {
<span class="nc" id="L2622">                Element result =</span>
<span class="nc" id="L2623">                    XMLUtils.createElementInEncryptionSpace(</span>
<span class="nc" id="L2624">                        contextDocument, EncryptionConstants._TAG_CIPHERDATA</span>
                    );
<span class="nc bnc" id="L2626" title="All 2 branches missed.">                if (cipherType == VALUE_TYPE) {</span>
<span class="nc" id="L2627">                    result.appendChild(((CipherValueImpl) cipherValue).toElement());</span>
<span class="nc bnc" id="L2628" title="All 2 branches missed.">                } else if (cipherType == REFERENCE_TYPE) {</span>
<span class="nc" id="L2629">                    result.appendChild(((CipherReferenceImpl) cipherReference).toElement());</span>
                }

<span class="nc" id="L2632">                return result;</span>
            }
        }

        private class CipherReferenceImpl implements CipherReference {
<span class="nc" id="L2637">            private String referenceURI = null;</span>
<span class="nc" id="L2638">            private Transforms referenceTransforms = null;</span>
<span class="nc" id="L2639">            private Attr referenceNode = null;</span>

            /**
             * @param uri
             */
<span class="nc" id="L2644">            public CipherReferenceImpl(String uri) {</span>
                /* Don't check validity of URI as may be &quot;&quot; */
<span class="nc" id="L2646">                referenceURI = uri;</span>
<span class="nc" id="L2647">                referenceNode = null;</span>
<span class="nc" id="L2648">            }</span>

            /**
             * @param uri
             */
<span class="nc" id="L2653">            public CipherReferenceImpl(Attr uri) {</span>
<span class="nc" id="L2654">                referenceURI = uri.getNodeValue();</span>
<span class="nc" id="L2655">                referenceNode = uri;</span>
<span class="nc" id="L2656">            }</span>

            /** @inheritDoc */
            public String getURI() {
<span class="nc" id="L2660">                return referenceURI;</span>
            }

            /** @inheritDoc */
            public Attr getURIAsAttr() {
<span class="nc" id="L2665">                return referenceNode;</span>
            }

            /** @inheritDoc */
            public Transforms getTransforms() {
<span class="nc" id="L2670">                return referenceTransforms;</span>
            }

            /** @inheritDoc */
            public void setTransforms(Transforms transforms) {
<span class="nc" id="L2675">                referenceTransforms = transforms;</span>
<span class="nc" id="L2676">            }</span>

            Element toElement() {
<span class="nc" id="L2679">                Element result =</span>
<span class="nc" id="L2680">                    XMLUtils.createElementInEncryptionSpace(</span>
<span class="nc" id="L2681">                        contextDocument, EncryptionConstants._TAG_CIPHERREFERENCE</span>
                    );
<span class="nc" id="L2683">                result.setAttributeNS(null, EncryptionConstants._ATT_URI, referenceURI);</span>
<span class="nc bnc" id="L2684" title="All 2 branches missed.">                if (null != referenceTransforms) {</span>
<span class="nc" id="L2685">                    result.appendChild(((TransformsImpl) referenceTransforms).toElement());</span>
                }

<span class="nc" id="L2688">                return result;</span>
            }
        }

        private class CipherValueImpl implements CipherValue {
<span class="nc" id="L2693">            private String cipherValue = null;</span>

            /**
             * @param value
             */
<span class="nc" id="L2698">            public CipherValueImpl(String value) {</span>
<span class="nc" id="L2699">                cipherValue = value;</span>
<span class="nc" id="L2700">            }</span>

            /** @inheritDoc */
            public String getValue() {
<span class="nc" id="L2704">                return cipherValue;</span>
            }

            /** @inheritDoc */
            public void setValue(String value) {
<span class="nc" id="L2709">                cipherValue = value;</span>
<span class="nc" id="L2710">            }</span>

            Element toElement() {
<span class="nc" id="L2713">                Element result =</span>
<span class="nc" id="L2714">                    XMLUtils.createElementInEncryptionSpace(</span>
<span class="nc" id="L2715">                        contextDocument, EncryptionConstants._TAG_CIPHERVALUE</span>
                    );
<span class="nc" id="L2717">                result.appendChild(contextDocument.createTextNode(cipherValue));</span>

<span class="nc" id="L2719">                return result;</span>
            }
        }

        private class EncryptedDataImpl extends EncryptedTypeImpl implements EncryptedData {

            /**
             * @param data
             */
<span class="nc" id="L2728">            public EncryptedDataImpl(CipherData data) {</span>
<span class="nc" id="L2729">                super(data);</span>
<span class="nc" id="L2730">            }</span>

            Element toElement() {
<span class="nc" id="L2733">                Element result =</span>
<span class="nc" id="L2734">                    ElementProxy.createElementForFamily(</span>
<span class="nc" id="L2735">                        contextDocument, EncryptionConstants.EncryptionSpecNS,</span>
                        EncryptionConstants._TAG_ENCRYPTEDDATA
                    );

<span class="nc bnc" id="L2739" title="All 2 branches missed.">                if (null != super.getId()) {</span>
<span class="nc" id="L2740">                    result.setAttributeNS(null, EncryptionConstants._ATT_ID, super.getId());</span>
                }
<span class="nc bnc" id="L2742" title="All 2 branches missed.">                if (null != super.getType()) {</span>
<span class="nc" id="L2743">                    result.setAttributeNS(null, EncryptionConstants._ATT_TYPE, super.getType());</span>
                }
<span class="nc bnc" id="L2745" title="All 2 branches missed.">                if (null != super.getMimeType()) {</span>
<span class="nc" id="L2746">                    result.setAttributeNS(</span>
<span class="nc" id="L2747">                        null, EncryptionConstants._ATT_MIMETYPE, super.getMimeType()</span>
                    );
                }
<span class="nc bnc" id="L2750" title="All 2 branches missed.">                if (null != super.getEncoding()) {</span>
<span class="nc" id="L2751">                    result.setAttributeNS(</span>
<span class="nc" id="L2752">                        null, EncryptionConstants._ATT_ENCODING, super.getEncoding()</span>
                    );
                }
<span class="nc bnc" id="L2755" title="All 2 branches missed.">                if (null != super.getEncryptionMethod()) {</span>
<span class="nc" id="L2756">                    result.appendChild(</span>
<span class="nc" id="L2757">                        ((EncryptionMethodImpl)super.getEncryptionMethod()).toElement()</span>
                    );
                }
<span class="nc bnc" id="L2760" title="All 2 branches missed.">                if (null != super.getKeyInfo()) {</span>
<span class="nc" id="L2761">                    result.appendChild(super.getKeyInfo().getElement().cloneNode(true));</span>
                }

<span class="nc" id="L2764">                result.appendChild(((CipherDataImpl) super.getCipherData()).toElement());</span>
<span class="nc bnc" id="L2765" title="All 2 branches missed.">                if (null != super.getEncryptionProperties()) {</span>
<span class="nc" id="L2766">                    result.appendChild(((EncryptionPropertiesImpl)</span>
<span class="nc" id="L2767">                        super.getEncryptionProperties()).toElement());</span>
                }

<span class="nc" id="L2770">                return result;</span>
            }
        }

        private class EncryptedKeyImpl extends EncryptedTypeImpl implements EncryptedKey {
<span class="nc" id="L2775">            private String keyRecipient = null;</span>
<span class="nc" id="L2776">            private ReferenceList referenceList = null;</span>
<span class="nc" id="L2777">            private String carriedName = null;</span>

            /**
             * @param data
             */
<span class="nc" id="L2782">            public EncryptedKeyImpl(CipherData data) {</span>
<span class="nc" id="L2783">                super(data);</span>
<span class="nc" id="L2784">            }</span>

            /** @inheritDoc */
            public String getRecipient() {
<span class="nc" id="L2788">                return keyRecipient;</span>
            }

            /** @inheritDoc */
            public void setRecipient(String recipient) {
<span class="nc" id="L2793">                keyRecipient = recipient;</span>
<span class="nc" id="L2794">            }</span>

            /** @inheritDoc */
            public ReferenceList getReferenceList() {
<span class="nc" id="L2798">                return referenceList;</span>
            }

            /** @inheritDoc */
            public void setReferenceList(ReferenceList list) {
<span class="nc" id="L2803">                referenceList = list;</span>
<span class="nc" id="L2804">            }</span>

            /** @inheritDoc */
            public String getCarriedName() {
<span class="nc" id="L2808">                return carriedName;</span>
            }

            /** @inheritDoc */
            public void setCarriedName(String name) {
<span class="nc" id="L2813">                carriedName = name;</span>
<span class="nc" id="L2814">            }</span>

            Element toElement() {
<span class="nc" id="L2817">                Element result =</span>
<span class="nc" id="L2818">                    ElementProxy.createElementForFamily(</span>
<span class="nc" id="L2819">                        contextDocument, EncryptionConstants.EncryptionSpecNS,</span>
                        EncryptionConstants._TAG_ENCRYPTEDKEY
                    );

<span class="nc bnc" id="L2823" title="All 2 branches missed.">                if (null != super.getId()) {</span>
<span class="nc" id="L2824">                    result.setAttributeNS(null, EncryptionConstants._ATT_ID, super.getId());</span>
                }
<span class="nc bnc" id="L2826" title="All 2 branches missed.">                if (null != super.getType()) {</span>
<span class="nc" id="L2827">                    result.setAttributeNS(null, EncryptionConstants._ATT_TYPE, super.getType());</span>
                }
<span class="nc bnc" id="L2829" title="All 2 branches missed.">                if (null != super.getMimeType()) {</span>
<span class="nc" id="L2830">                    result.setAttributeNS(</span>
<span class="nc" id="L2831">                        null, EncryptionConstants._ATT_MIMETYPE, super.getMimeType()</span>
                    );
                }
<span class="nc bnc" id="L2834" title="All 2 branches missed.">                if (null != super.getEncoding()) {</span>
<span class="nc" id="L2835">                    result.setAttributeNS(null, Constants._ATT_ENCODING, super.getEncoding());</span>
                }
<span class="nc bnc" id="L2837" title="All 2 branches missed.">                if (null != getRecipient()) {</span>
<span class="nc" id="L2838">                    result.setAttributeNS(</span>
<span class="nc" id="L2839">                        null, EncryptionConstants._ATT_RECIPIENT, getRecipient()</span>
                    );
                }
<span class="nc bnc" id="L2842" title="All 2 branches missed.">                if (null != super.getEncryptionMethod()) {</span>
<span class="nc" id="L2843">                    result.appendChild(((EncryptionMethodImpl)</span>
<span class="nc" id="L2844">                        super.getEncryptionMethod()).toElement());</span>
                }
<span class="nc bnc" id="L2846" title="All 2 branches missed.">                if (null != super.getKeyInfo()) {</span>
<span class="nc" id="L2847">                    result.appendChild(super.getKeyInfo().getElement().cloneNode(true));</span>
                }
<span class="nc" id="L2849">                result.appendChild(((CipherDataImpl) super.getCipherData()).toElement());</span>
<span class="nc bnc" id="L2850" title="All 2 branches missed.">                if (null != super.getEncryptionProperties()) {</span>
<span class="nc" id="L2851">                    result.appendChild(((EncryptionPropertiesImpl)</span>
<span class="nc" id="L2852">                        super.getEncryptionProperties()).toElement());</span>
                }
<span class="nc bnc" id="L2854" title="All 4 branches missed.">                if (referenceList != null &amp;&amp; !referenceList.isEmpty()) {</span>
<span class="nc" id="L2855">                    result.appendChild(((ReferenceListImpl)getReferenceList()).toElement());</span>
                }
<span class="nc bnc" id="L2857" title="All 2 branches missed.">                if (null != carriedName) {</span>
<span class="nc" id="L2858">                    Element element =</span>
<span class="nc" id="L2859">                        ElementProxy.createElementForFamily(</span>
<span class="nc" id="L2860">                            contextDocument,</span>
                            EncryptionConstants.EncryptionSpecNS,
                            EncryptionConstants._TAG_CARRIEDKEYNAME
                        );
<span class="nc" id="L2864">                    Node node = contextDocument.createTextNode(carriedName);</span>
<span class="nc" id="L2865">                    element.appendChild(node);</span>
<span class="nc" id="L2866">                    result.appendChild(element);</span>
                }

<span class="nc" id="L2869">                return result;</span>
            }
        }

        private abstract class EncryptedTypeImpl {
<span class="nc" id="L2874">            private String id =  null;</span>
<span class="nc" id="L2875">            private String type = null;</span>
<span class="nc" id="L2876">            private String mimeType = null;</span>
<span class="nc" id="L2877">            private String encoding = null;</span>
<span class="nc" id="L2878">            private EncryptionMethod encryptionMethod = null;</span>
<span class="nc" id="L2879">            private KeyInfo keyInfo = null;</span>
<span class="nc" id="L2880">            private CipherData cipherData = null;</span>
<span class="nc" id="L2881">            private EncryptionProperties encryptionProperties = null;</span>

            /**
             * Constructor.
             * @param data
             */
<span class="nc" id="L2887">            protected EncryptedTypeImpl(CipherData data) {</span>
<span class="nc" id="L2888">                cipherData = data;</span>
<span class="nc" id="L2889">            }</span>

            /**
             *
             * @return the Id
             */
            public String getId() {
<span class="nc" id="L2896">                return id;</span>
            }

            /**
             *
             * @param id
             */
            public void setId(String id) {
<span class="nc" id="L2904">                this.id = id;</span>
<span class="nc" id="L2905">            }</span>

            /**
             *
             * @return the type
             */
            public String getType() {
<span class="nc" id="L2912">                return type;</span>
            }

            /**
             *
             * @param type
             */
            public void setType(String type) {
<span class="nc bnc" id="L2920" title="All 4 branches missed.">                if (type == null || type.length() == 0) {</span>
<span class="nc" id="L2921">                    this.type = null;</span>
                } else {
<span class="nc" id="L2923">                    URI tmpType = null;</span>
                    try {
<span class="nc" id="L2925">                        tmpType = new URI(type);</span>
<span class="nc" id="L2926">                    } catch (URISyntaxException ex) {</span>
<span class="nc" id="L2927">                        throw (IllegalArgumentException)</span>
<span class="nc" id="L2928">                        new IllegalArgumentException().initCause(ex);</span>
<span class="nc" id="L2929">                    }</span>
<span class="nc" id="L2930">                    this.type = tmpType.toString();</span>
                }
<span class="nc" id="L2932">            }</span>

            /**
             *
             * @return the MimeType
             */
            public String getMimeType() {
<span class="nc" id="L2939">                return mimeType;</span>
            }
            /**
             *
             * @param type
             */
            public void setMimeType(String type) {
<span class="nc" id="L2946">                mimeType = type;</span>
<span class="nc" id="L2947">            }</span>

            /**
             *
             * @return the encoding
             */
            public String getEncoding() {
<span class="nc" id="L2954">                return encoding;</span>
            }

            /**
             *
             * @param encoding
             */
            public void setEncoding(String encoding) {
<span class="nc bnc" id="L2962" title="All 4 branches missed.">                if (encoding == null || encoding.length() == 0) {</span>
<span class="nc" id="L2963">                    this.encoding = null;</span>
                } else {
<span class="nc" id="L2965">                    URI tmpEncoding = null;</span>
                    try {
<span class="nc" id="L2967">                        tmpEncoding = new URI(encoding);</span>
<span class="nc" id="L2968">                    } catch (URISyntaxException ex) {</span>
<span class="nc" id="L2969">                        throw (IllegalArgumentException)</span>
<span class="nc" id="L2970">                        new IllegalArgumentException().initCause(ex);</span>
<span class="nc" id="L2971">                    }</span>
<span class="nc" id="L2972">                    this.encoding = tmpEncoding.toString();</span>
                }
<span class="nc" id="L2974">            }</span>

            /**
             *
             * @return the EncryptionMethod
             */
            public EncryptionMethod getEncryptionMethod() {
<span class="nc" id="L2981">                return encryptionMethod;</span>
            }

            /**
             *
             * @param method
             */
            public void setEncryptionMethod(EncryptionMethod method) {
<span class="nc" id="L2989">                encryptionMethod = method;</span>
<span class="nc" id="L2990">            }</span>

            /**
             *
             * @return the KeyInfo
             */
            public KeyInfo getKeyInfo() {
<span class="nc" id="L2997">                return keyInfo;</span>
            }

            /**
             *
             * @param info
             */
            public void setKeyInfo(KeyInfo info) {
<span class="nc" id="L3005">                keyInfo = info;</span>
<span class="nc" id="L3006">            }</span>

            /**
             *
             * @return the CipherData
             */
            public CipherData getCipherData() {
<span class="nc" id="L3013">                return cipherData;</span>
            }

            /**
             *
             * @return the EncryptionProperties
             */
            public EncryptionProperties getEncryptionProperties() {
<span class="nc" id="L3021">                return encryptionProperties;</span>
            }

            /**
             *
             * @param properties
             */
            public void setEncryptionProperties(EncryptionProperties properties) {
<span class="nc" id="L3029">                encryptionProperties = properties;</span>
<span class="nc" id="L3030">            }</span>
        }

        private class EncryptionMethodImpl implements EncryptionMethod {
<span class="nc" id="L3034">            private String algorithm = null;</span>
<span class="nc" id="L3035">            private int keySize = Integer.MIN_VALUE;</span>
<span class="nc" id="L3036">            private byte[] oaepParams = null;</span>
<span class="nc" id="L3037">            private List&lt;Element&gt; encryptionMethodInformation = null;</span>
<span class="nc" id="L3038">            private String digestAlgorithm = null;</span>
<span class="nc" id="L3039">            private String mgfAlgorithm = null;</span>

            /**
             * Constructor.
             * @param algorithm
             */
<span class="nc" id="L3045">            public EncryptionMethodImpl(String algorithm) {</span>
<span class="nc" id="L3046">                URI tmpAlgorithm = null;</span>
                try {
<span class="nc" id="L3048">                    tmpAlgorithm = new URI(algorithm);</span>
<span class="nc" id="L3049">                } catch (URISyntaxException ex) {</span>
<span class="nc" id="L3050">                    throw (IllegalArgumentException)</span>
<span class="nc" id="L3051">                    new IllegalArgumentException().initCause(ex);</span>
<span class="nc" id="L3052">                }</span>
<span class="nc" id="L3053">                this.algorithm = tmpAlgorithm.toString();</span>
<span class="nc" id="L3054">                encryptionMethodInformation = new LinkedList&lt;Element&gt;();</span>
<span class="nc" id="L3055">            }</span>

            /** @inheritDoc */
            public String getAlgorithm() {
<span class="nc" id="L3059">                return algorithm;</span>
            }

            /** @inheritDoc */
            public int getKeySize() {
<span class="nc" id="L3064">                return keySize;</span>
            }

            /** @inheritDoc */
            public void setKeySize(int size) {
<span class="nc" id="L3069">                keySize = size;</span>
<span class="nc" id="L3070">            }</span>

            /** @inheritDoc */
            public byte[] getOAEPparams() {
<span class="nc" id="L3074">                return oaepParams;</span>
            }

            /** @inheritDoc */
            public void setOAEPparams(byte[] params) {
<span class="nc" id="L3079">                oaepParams = params;</span>
<span class="nc" id="L3080">            }</span>

            /** @inheritDoc */
            public void setDigestAlgorithm(String digestAlgorithm) {
<span class="nc" id="L3084">                this.digestAlgorithm = digestAlgorithm;</span>
<span class="nc" id="L3085">            }</span>

            /** @inheritDoc */
            public String getDigestAlgorithm() {
<span class="nc" id="L3089">                return digestAlgorithm;</span>
            }

            /** @inheritDoc */
            public void setMGFAlgorithm(String mgfAlgorithm) {
<span class="nc" id="L3094">                this.mgfAlgorithm = mgfAlgorithm;</span>
<span class="nc" id="L3095">            }</span>

            /** @inheritDoc */
            public String getMGFAlgorithm() {
<span class="nc" id="L3099">                return mgfAlgorithm;</span>
            }

            /** @inheritDoc */
            public Iterator&lt;Element&gt; getEncryptionMethodInformation() {
<span class="nc" id="L3104">                return encryptionMethodInformation.iterator();</span>
            }

            /** @inheritDoc */
            public void addEncryptionMethodInformation(Element info) {
<span class="nc" id="L3109">                encryptionMethodInformation.add(info);</span>
<span class="nc" id="L3110">            }</span>

            /** @inheritDoc */
            public void removeEncryptionMethodInformation(Element info) {
<span class="nc" id="L3114">                encryptionMethodInformation.remove(info);</span>
<span class="nc" id="L3115">            }</span>

            Element toElement() {
<span class="nc" id="L3118">                Element result =</span>
<span class="nc" id="L3119">                    XMLUtils.createElementInEncryptionSpace(</span>
<span class="nc" id="L3120">                        contextDocument, EncryptionConstants._TAG_ENCRYPTIONMETHOD</span>
                    );
<span class="nc" id="L3122">                result.setAttributeNS(null, EncryptionConstants._ATT_ALGORITHM, algorithm);</span>
<span class="nc bnc" id="L3123" title="All 2 branches missed.">                if (keySize &gt; 0) {</span>
<span class="nc" id="L3124">                    result.appendChild(</span>
<span class="nc" id="L3125">                        XMLUtils.createElementInEncryptionSpace(</span>
<span class="nc" id="L3126">                            contextDocument, EncryptionConstants._TAG_KEYSIZE</span>
<span class="nc" id="L3127">                    ).appendChild(contextDocument.createTextNode(String.valueOf(keySize))));</span>
                }
<span class="nc bnc" id="L3129" title="All 2 branches missed.">                if (null != oaepParams) {</span>
<span class="nc" id="L3130">                    Element oaepElement =</span>
<span class="nc" id="L3131">                        XMLUtils.createElementInEncryptionSpace(</span>
<span class="nc" id="L3132">                            contextDocument, EncryptionConstants._TAG_OAEPPARAMS</span>
                        );
<span class="nc" id="L3134">                    oaepElement.appendChild(contextDocument.createTextNode(Base64.encode(oaepParams)));</span>
<span class="nc" id="L3135">                    result.appendChild(oaepElement);</span>
                }
<span class="nc bnc" id="L3137" title="All 2 branches missed.">                if (digestAlgorithm != null) {</span>
<span class="nc" id="L3138">                    Element digestElement =</span>
<span class="nc" id="L3139">                        XMLUtils.createElementInSignatureSpace(contextDocument, Constants._TAG_DIGESTMETHOD);</span>
<span class="nc" id="L3140">                    digestElement.setAttributeNS(null, &quot;Algorithm&quot;, digestAlgorithm);</span>
<span class="nc" id="L3141">                    result.appendChild(digestElement);</span>
                }
<span class="nc bnc" id="L3143" title="All 2 branches missed.">                if (mgfAlgorithm != null) {</span>
<span class="nc" id="L3144">                    Element mgfElement =</span>
<span class="nc" id="L3145">                        XMLUtils.createElementInEncryption11Space(</span>
<span class="nc" id="L3146">                            contextDocument, EncryptionConstants._TAG_MGF</span>
                        );
<span class="nc" id="L3148">                    mgfElement.setAttributeNS(null, &quot;Algorithm&quot;, mgfAlgorithm);</span>
<span class="nc" id="L3149">                    mgfElement.setAttributeNS(</span>
                        Constants.NamespaceSpecNS,
<span class="nc" id="L3151">                        &quot;xmlns:&quot; + ElementProxy.getDefaultPrefix(EncryptionConstants.EncryptionSpec11NS),</span>
                        EncryptionConstants.EncryptionSpec11NS
                    );
<span class="nc" id="L3154">                    result.appendChild(mgfElement);</span>
                }
<span class="nc" id="L3156">                Iterator&lt;Element&gt; itr = encryptionMethodInformation.iterator();</span>
<span class="nc bnc" id="L3157" title="All 2 branches missed.">                while (itr.hasNext()) {</span>
<span class="nc" id="L3158">                    result.appendChild(itr.next());</span>
                }

<span class="nc" id="L3161">                return result;</span>
            }
        }

        private class EncryptionPropertiesImpl implements EncryptionProperties {
<span class="nc" id="L3166">            private String id = null;</span>
<span class="nc" id="L3167">            private List&lt;EncryptionProperty&gt; encryptionProperties = null;</span>

            /**
             * Constructor.
             */
<span class="nc" id="L3172">            public EncryptionPropertiesImpl() {</span>
<span class="nc" id="L3173">                encryptionProperties = new LinkedList&lt;EncryptionProperty&gt;();</span>
<span class="nc" id="L3174">            }</span>

            /** @inheritDoc */
            public String getId() {
<span class="nc" id="L3178">                return id;</span>
            }

            /** @inheritDoc */
            public void setId(String id) {
<span class="nc" id="L3183">                this.id = id;</span>
<span class="nc" id="L3184">            }</span>

            /** @inheritDoc */
            public Iterator&lt;EncryptionProperty&gt; getEncryptionProperties() {
<span class="nc" id="L3188">                return encryptionProperties.iterator();</span>
            }

            /** @inheritDoc */
            public void addEncryptionProperty(EncryptionProperty property) {
<span class="nc" id="L3193">                encryptionProperties.add(property);</span>
<span class="nc" id="L3194">            }</span>

            /** @inheritDoc */
            public void removeEncryptionProperty(EncryptionProperty property) {
<span class="nc" id="L3198">                encryptionProperties.remove(property);</span>
<span class="nc" id="L3199">            }</span>

            Element toElement() {
<span class="nc" id="L3202">                Element result =</span>
<span class="nc" id="L3203">                    XMLUtils.createElementInEncryptionSpace(</span>
<span class="nc" id="L3204">                        contextDocument, EncryptionConstants._TAG_ENCRYPTIONPROPERTIES</span>
                    );
<span class="nc bnc" id="L3206" title="All 2 branches missed.">                if (null != id) {</span>
<span class="nc" id="L3207">                    result.setAttributeNS(null, EncryptionConstants._ATT_ID, id);</span>
                }
<span class="nc" id="L3209">                Iterator&lt;EncryptionProperty&gt; itr = getEncryptionProperties();</span>
<span class="nc bnc" id="L3210" title="All 2 branches missed.">                while (itr.hasNext()) {</span>
<span class="nc" id="L3211">                    result.appendChild(((EncryptionPropertyImpl)itr.next()).toElement());</span>
                }

<span class="nc" id="L3214">                return result;</span>
            }
        }

        private class EncryptionPropertyImpl implements EncryptionProperty {
<span class="nc" id="L3219">            private String target = null;</span>
<span class="nc" id="L3220">            private String id = null;</span>
<span class="nc" id="L3221">            private Map&lt;String, String&gt; attributeMap = new HashMap&lt;String, String&gt;();</span>
<span class="nc" id="L3222">            private List&lt;Element&gt; encryptionInformation = null;</span>

            /**
             * Constructor.
             */
<span class="nc" id="L3227">            public EncryptionPropertyImpl() {</span>
<span class="nc" id="L3228">                encryptionInformation = new LinkedList&lt;Element&gt;();</span>
<span class="nc" id="L3229">            }</span>

            /** @inheritDoc */
            public String getTarget() {
<span class="nc" id="L3233">                return target;</span>
            }

            /** @inheritDoc */
            public void setTarget(String target) {
<span class="nc bnc" id="L3238" title="All 4 branches missed.">                if (target == null || target.length() == 0) {</span>
<span class="nc" id="L3239">                    this.target = null;</span>
<span class="nc bnc" id="L3240" title="All 2 branches missed.">                } else if (target.startsWith(&quot;#&quot;)) {</span>
                    /*
                     * This is a same document URI reference. Do not parse,
                     * because it has no scheme.
                     */
<span class="nc" id="L3245">                    this.target = target;</span>
                } else {
<span class="nc" id="L3247">                    URI tmpTarget = null;</span>
                    try {
<span class="nc" id="L3249">                        tmpTarget = new URI(target);</span>
<span class="nc" id="L3250">                    } catch (URISyntaxException ex) {</span>
<span class="nc" id="L3251">                        throw (IllegalArgumentException)</span>
<span class="nc" id="L3252">                        new IllegalArgumentException().initCause(ex);</span>
<span class="nc" id="L3253">                    }</span>
<span class="nc" id="L3254">                    this.target = tmpTarget.toString();</span>
                }
<span class="nc" id="L3256">            }</span>

            /** @inheritDoc */
            public String getId() {
<span class="nc" id="L3260">                return id;</span>
            }

            /** @inheritDoc */
            public void setId(String id) {
<span class="nc" id="L3265">                this.id = id;</span>
<span class="nc" id="L3266">            }</span>

            /** @inheritDoc */
            public String getAttribute(String attribute) {
<span class="nc" id="L3270">                return attributeMap.get(attribute);</span>
            }

            /** @inheritDoc */
            public void setAttribute(String attribute, String value) {
<span class="nc" id="L3275">                attributeMap.put(attribute, value);</span>
<span class="nc" id="L3276">            }</span>

            /** @inheritDoc */
            public Iterator&lt;Element&gt; getEncryptionInformation() {
<span class="nc" id="L3280">                return encryptionInformation.iterator();</span>
            }

            /** @inheritDoc */
            public void addEncryptionInformation(Element info) {
<span class="nc" id="L3285">                encryptionInformation.add(info);</span>
<span class="nc" id="L3286">            }</span>

            /** @inheritDoc */
            public void removeEncryptionInformation(Element info) {
<span class="nc" id="L3290">                encryptionInformation.remove(info);</span>
<span class="nc" id="L3291">            }</span>

            Element toElement() {
<span class="nc" id="L3294">                Element result =</span>
<span class="nc" id="L3295">                    XMLUtils.createElementInEncryptionSpace(</span>
<span class="nc" id="L3296">                        contextDocument, EncryptionConstants._TAG_ENCRYPTIONPROPERTY</span>
                    );
<span class="nc bnc" id="L3298" title="All 2 branches missed.">                if (null != target) {</span>
<span class="nc" id="L3299">                    result.setAttributeNS(null, EncryptionConstants._ATT_TARGET, target);</span>
                }
<span class="nc bnc" id="L3301" title="All 2 branches missed.">                if (null != id) {</span>
<span class="nc" id="L3302">                    result.setAttributeNS(null, EncryptionConstants._ATT_ID, id);</span>
                }
                // TODO: figure out the anyAttribyte stuff...
                // TODO: figure out the any stuff...

<span class="nc" id="L3307">                return result;</span>
            }
        }

        private class TransformsImpl extends com.sun.org.apache.xml.internal.security.transforms.Transforms
            implements Transforms {

            /**
             * Construct Transforms
             */
<span class="nc" id="L3317">            public TransformsImpl() {</span>
<span class="nc" id="L3318">                super(contextDocument);</span>
<span class="nc" id="L3319">            }</span>

            /**
             *
             * @param doc
             */
<span class="nc" id="L3325">            public TransformsImpl(Document doc) {</span>
<span class="nc bnc" id="L3326" title="All 2 branches missed.">                if (doc == null) {</span>
<span class="nc" id="L3327">                    throw new RuntimeException(&quot;Document is null&quot;);</span>
                }

<span class="nc" id="L3330">                this.doc = doc;</span>
<span class="nc" id="L3331">                this.constructionElement =</span>
<span class="nc" id="L3332">                    createElementForFamilyLocal(</span>
<span class="nc" id="L3333">                        this.doc, this.getBaseNamespace(), this.getBaseLocalName()</span>
                    );
<span class="nc" id="L3335">            }</span>

            /**
             *
             * @param element
             * @throws XMLSignatureException
             * @throws InvalidTransformException
             * @throws XMLSecurityException
             * @throws TransformationException
             */
            public TransformsImpl(Element element)
                throws XMLSignatureException, InvalidTransformException,
<span class="nc" id="L3347">                    XMLSecurityException, TransformationException {</span>
<span class="nc" id="L3348">                super(element, &quot;&quot;);</span>
<span class="nc" id="L3349">            }</span>

            /**
             *
             * @return the XML Element form of that Transforms
             */
            public Element toElement() {
<span class="nc bnc" id="L3356" title="All 2 branches missed.">                if (doc == null) {</span>
<span class="nc" id="L3357">                    doc = contextDocument;</span>
                }

<span class="nc" id="L3360">                return getElement();</span>
            }

            /** @inheritDoc */
            public com.sun.org.apache.xml.internal.security.transforms.Transforms getDSTransforms() {
<span class="nc" id="L3365">                return this;</span>
            }

            // Over-ride the namespace
            /** @inheritDoc */
            public String getBaseNamespace() {
<span class="nc" id="L3371">                return EncryptionConstants.EncryptionSpecNS;</span>
            }
        }

<span class="nc" id="L3375">        private class ReferenceListImpl implements ReferenceList {</span>
            private Class&lt;?&gt; sentry;
            private List&lt;Reference&gt; references;

            /**
             * Constructor.
             * @param type
             */
<span class="nc" id="L3383">            public ReferenceListImpl(int type) {</span>
<span class="nc bnc" id="L3384" title="All 2 branches missed.">                if (type == ReferenceList.DATA_REFERENCE) {</span>
<span class="nc" id="L3385">                    sentry = DataReference.class;</span>
<span class="nc bnc" id="L3386" title="All 2 branches missed.">                } else if (type == ReferenceList.KEY_REFERENCE) {</span>
<span class="nc" id="L3387">                    sentry = KeyReference.class;</span>
                } else {
<span class="nc" id="L3389">                    throw new IllegalArgumentException();</span>
                }
<span class="nc" id="L3391">                references = new LinkedList&lt;Reference&gt;();</span>
<span class="nc" id="L3392">            }</span>

            /** @inheritDoc */
            public void add(Reference reference) {
<span class="nc bnc" id="L3396" title="All 2 branches missed.">                if (!reference.getClass().equals(sentry)) {</span>
<span class="nc" id="L3397">                    throw new IllegalArgumentException();</span>
                }
<span class="nc" id="L3399">                references.add(reference);</span>
<span class="nc" id="L3400">            }</span>

            /** @inheritDoc */
            public void remove(Reference reference) {
<span class="nc bnc" id="L3404" title="All 2 branches missed.">                if (!reference.getClass().equals(sentry)) {</span>
<span class="nc" id="L3405">                    throw new IllegalArgumentException();</span>
                }
<span class="nc" id="L3407">                references.remove(reference);</span>
<span class="nc" id="L3408">            }</span>

            /** @inheritDoc */
            public int size() {
<span class="nc" id="L3412">                return references.size();</span>
            }

            /** @inheritDoc */
            public boolean isEmpty() {
<span class="nc" id="L3417">                return references.isEmpty();</span>
            }

            /** @inheritDoc */
            public Iterator&lt;Reference&gt; getReferences() {
<span class="nc" id="L3422">                return references.iterator();</span>
            }

            Element toElement() {
<span class="nc" id="L3426">                Element result =</span>
<span class="nc" id="L3427">                    ElementProxy.createElementForFamily(</span>
<span class="nc" id="L3428">                        contextDocument,</span>
                        EncryptionConstants.EncryptionSpecNS,
                        EncryptionConstants._TAG_REFERENCELIST
                    );
<span class="nc" id="L3432">                Iterator&lt;Reference&gt; eachReference = references.iterator();</span>
<span class="nc bnc" id="L3433" title="All 2 branches missed.">                while (eachReference.hasNext()) {</span>
<span class="nc" id="L3434">                    Reference reference = eachReference.next();</span>
<span class="nc" id="L3435">                    result.appendChild(((ReferenceImpl) reference).toElement());</span>
<span class="nc" id="L3436">                }</span>
<span class="nc" id="L3437">                return result;</span>
            }

            /** @inheritDoc */
            public Reference newDataReference(String uri) {
<span class="nc" id="L3442">                return new DataReference(uri);</span>
            }

            /** @inheritDoc */
            public Reference newKeyReference(String uri) {
<span class="nc" id="L3447">                return new KeyReference(uri);</span>
            }

            /**
             * &lt;code&gt;ReferenceImpl&lt;/code&gt; is an implementation of
             * &lt;code&gt;Reference&lt;/code&gt;.
             *
             * @see Reference
             */
            private abstract class ReferenceImpl implements Reference {
                private String uri;
                private List&lt;Element&gt; referenceInformation;

<span class="nc" id="L3460">                ReferenceImpl(String uri) {</span>
<span class="nc" id="L3461">                    this.uri = uri;</span>
<span class="nc" id="L3462">                    referenceInformation = new LinkedList&lt;Element&gt;();</span>
<span class="nc" id="L3463">                }</span>

                /** @inheritDoc */
                public abstract String getType();

                /** @inheritDoc */
                public String getURI() {
<span class="nc" id="L3470">                    return uri;</span>
                }

                /** @inheritDoc */
                public Iterator&lt;Element&gt; getElementRetrievalInformation() {
<span class="nc" id="L3475">                    return referenceInformation.iterator();</span>
                }

                /** @inheritDoc */
                public void setURI(String uri) {
<span class="nc" id="L3480">                    this.uri = uri;</span>
<span class="nc" id="L3481">                }</span>

                /** @inheritDoc */
                public void removeElementRetrievalInformation(Element node) {
<span class="nc" id="L3485">                    referenceInformation.remove(node);</span>
<span class="nc" id="L3486">                }</span>

                /** @inheritDoc */
                public void addElementRetrievalInformation(Element node) {
<span class="nc" id="L3490">                    referenceInformation.add(node);</span>
<span class="nc" id="L3491">                }</span>

                /**
                 * @return the XML Element form of that Reference
                 */
                public Element toElement() {
<span class="nc" id="L3497">                    String tagName = getType();</span>
<span class="nc" id="L3498">                    Element result =</span>
<span class="nc" id="L3499">                        ElementProxy.createElementForFamily(</span>
<span class="nc" id="L3500">                            contextDocument,</span>
                            EncryptionConstants.EncryptionSpecNS,
                            tagName
                        );
<span class="nc" id="L3504">                    result.setAttribute(EncryptionConstants._ATT_URI, uri);</span>

                    // TODO: Need to martial referenceInformation
                    // Figure out how to make this work..
                    // &lt;any namespace=&quot;##other&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;

<span class="nc" id="L3510">                    return result;</span>
                }
            }

            private class DataReference extends ReferenceImpl {

<span class="nc" id="L3516">                DataReference(String uri) {</span>
<span class="nc" id="L3517">                    super(uri);</span>
<span class="nc" id="L3518">                }</span>

                /** @inheritDoc */
                public String getType() {
<span class="nc" id="L3522">                    return EncryptionConstants._TAG_DATAREFERENCE;</span>
                }
            }

            private class KeyReference extends ReferenceImpl {

<span class="nc" id="L3528">                KeyReference(String uri) {</span>
<span class="nc" id="L3529">                    super(uri);</span>
<span class="nc" id="L3530">                }</span>

                /** @inheritDoc */
                public String getType() {
<span class="nc" id="L3534">                    return EncryptionConstants._TAG_KEYREFERENCE;</span>
                }
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>