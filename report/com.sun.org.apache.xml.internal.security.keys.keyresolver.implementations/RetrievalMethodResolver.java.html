<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RetrievalMethodResolver.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations</a> &gt; <span class="el_source">RetrievalMethodResolver.java</span></div><h1>RetrievalMethodResolver.java</h1><pre class="source lang-java linenums">/*
 * reserved comment block
 * DO NOT REMOVE OR ALTER!
 */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.security.PublicKey;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
import com.sun.org.apache.xml.internal.security.keys.content.RetrievalMethod;
import com.sun.org.apache.xml.internal.security.keys.content.x509.XMLX509Certificate;
import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolver;
import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolverException;
import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolverSpi;
import com.sun.org.apache.xml.internal.security.keys.storage.StorageResolver;
import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
import com.sun.org.apache.xml.internal.security.transforms.Transforms;
import com.sun.org.apache.xml.internal.security.utils.Constants;
import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

/**
 * The RetrievalMethodResolver can retrieve public keys and certificates from
 * other locations. The location is specified using the ds:RetrievalMethod
 * element which points to the location. This includes the handling of raw
 * (binary) X.509 certificate which are not encapsulated in an XML structure.
 * If the retrieval process encounters an element which the
 * RetrievalMethodResolver cannot handle itself, resolving of the extracted
 * element is delegated back to the KeyResolver mechanism.
 *
 * @author $Author: raul $ modified by Dave Garcia
 */
<span class="nc" id="L72">public class RetrievalMethodResolver extends KeyResolverSpi {</span>

    /** {@link org.apache.commons.logging} logging facility */
<span class="nc" id="L75">    private static java.util.logging.Logger log =</span>
<span class="nc" id="L76">        java.util.logging.Logger.getLogger(RetrievalMethodResolver.class.getName());</span>

    /**
     * Method engineResolvePublicKey
     * @inheritDoc
     * @param element
     * @param baseURI
     * @param storage
     */
    public PublicKey engineLookupAndResolvePublicKey(
           Element element, String baseURI, StorageResolver storage
    ) {
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (!XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_RETRIEVALMETHOD)) {</span>
<span class="nc" id="L89">            return null;</span>
        }

        try {
            // Create a retrieval method over the given element
<span class="nc" id="L94">            RetrievalMethod rm = new RetrievalMethod(element, baseURI);</span>
<span class="nc" id="L95">            String type = rm.getType();</span>
<span class="nc" id="L96">            XMLSignatureInput resource = resolveInput(rm, baseURI, secureValidation);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            if (RetrievalMethod.TYPE_RAWX509.equals(type)) {</span>
                // a raw certificate, direct parsing is done!
<span class="nc" id="L99">                X509Certificate cert = getRawCertificate(resource);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">                if (cert != null) {</span>
<span class="nc" id="L101">                    return cert.getPublicKey();</span>
                }
<span class="nc" id="L103">                return null;</span>
             }
<span class="nc" id="L105">             Element e = obtainReferenceElement(resource);</span>

             // Check to make sure that the reference is not to another RetrievalMethod
             // which points to this element
<span class="nc bnc" id="L109" title="All 2 branches missed.">             if (XMLUtils.elementIsInSignatureSpace(e, Constants._TAG_RETRIEVALMETHOD)) {</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">                 if (secureValidation) {</span>
<span class="nc" id="L111">                     String error = &quot;Error: It is forbidden to have one RetrievalMethod &quot;</span>
                         + &quot;point to another with secure validation&quot;;
<span class="nc bnc" id="L113" title="All 2 branches missed.">                     if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L114">                         log.log(java.util.logging.Level.FINE, error);</span>
                     }
<span class="nc" id="L116">                     return null;</span>
                 }
<span class="nc" id="L118">                 RetrievalMethod rm2 = new RetrievalMethod(e, baseURI);</span>
<span class="nc" id="L119">                 XMLSignatureInput resource2 = resolveInput(rm2, baseURI, secureValidation);</span>
<span class="nc" id="L120">                 Element e2 = obtainReferenceElement(resource2);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">                 if (e2 == element) {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">                     if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L123">                         log.log(java.util.logging.Level.FINE, &quot;Error: Can't have RetrievalMethods pointing to each other&quot;);</span>
                     }
<span class="nc" id="L125">                     return null;</span>
                 }
             }

<span class="nc" id="L129">             return resolveKey(e, baseURI, storage);</span>
<span class="nc" id="L130">         } catch (XMLSecurityException ex) {</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">             if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L132">                 log.log(java.util.logging.Level.FINE, &quot;XMLSecurityException&quot;, ex);</span>
             }
<span class="nc" id="L134">         } catch (CertificateException ex) {</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">             if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L136">                 log.log(java.util.logging.Level.FINE, &quot;CertificateException&quot;, ex);</span>
             }
<span class="nc" id="L138">         } catch (IOException ex) {</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">             if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L140">                 log.log(java.util.logging.Level.FINE, &quot;IOException&quot;, ex);</span>
             }
<span class="nc" id="L142">         } catch (ParserConfigurationException e) {</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">             if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L144">                 log.log(java.util.logging.Level.FINE, &quot;ParserConfigurationException&quot;, e);</span>
             }
<span class="nc" id="L146">         } catch (SAXException e) {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">             if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L148">                 log.log(java.util.logging.Level.FINE, &quot;SAXException&quot;, e);</span>
             }
<span class="nc" id="L150">         }</span>
<span class="nc" id="L151">         return null;</span>
    }

    /**
     * Method engineResolveX509Certificate
     * @inheritDoc
     * @param element
     * @param baseURI
     * @param storage
     */
    public X509Certificate engineLookupResolveX509Certificate(
        Element element, String baseURI, StorageResolver storage) {
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (!XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_RETRIEVALMETHOD)) {</span>
<span class="nc" id="L164">             return null;</span>
        }

        try {
<span class="nc" id="L168">            RetrievalMethod rm = new RetrievalMethod(element, baseURI);</span>
<span class="nc" id="L169">            String type = rm.getType();</span>
<span class="nc" id="L170">            XMLSignatureInput resource = resolveInput(rm, baseURI, secureValidation);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (RetrievalMethod.TYPE_RAWX509.equals(type)) {</span>
<span class="nc" id="L172">                return getRawCertificate(resource);</span>
            }

<span class="nc" id="L175">            Element e = obtainReferenceElement(resource);</span>

            // Check to make sure that the reference is not to another RetrievalMethod
            // which points to this element
<span class="nc bnc" id="L179" title="All 2 branches missed.">            if (XMLUtils.elementIsInSignatureSpace(e, Constants._TAG_RETRIEVALMETHOD)) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                if (secureValidation) {</span>
<span class="nc" id="L181">                    String error = &quot;Error: It is forbidden to have one RetrievalMethod &quot;</span>
                        + &quot;point to another with secure validation&quot;;
<span class="nc bnc" id="L183" title="All 2 branches missed.">                    if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L184">                        log.log(java.util.logging.Level.FINE, error);</span>
                    }
<span class="nc" id="L186">                    return null;</span>
                }
<span class="nc" id="L188">                RetrievalMethod rm2 = new RetrievalMethod(e, baseURI);</span>
<span class="nc" id="L189">                XMLSignatureInput resource2 = resolveInput(rm2, baseURI, secureValidation);</span>
<span class="nc" id="L190">                Element e2 = obtainReferenceElement(resource2);</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                if (e2 == element) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                    if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L193">                        log.log(java.util.logging.Level.FINE, &quot;Error: Can't have RetrievalMethods pointing to each other&quot;);</span>
                    }
<span class="nc" id="L195">                    return null;</span>
                }
            }

<span class="nc" id="L199">            return resolveCertificate(e, baseURI, storage);</span>
<span class="nc" id="L200">        } catch (XMLSecurityException ex) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L202">                log.log(java.util.logging.Level.FINE, &quot;XMLSecurityException&quot;, ex);</span>
            }
<span class="nc" id="L204">        } catch (CertificateException ex) {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L206">                log.log(java.util.logging.Level.FINE, &quot;CertificateException&quot;, ex);</span>
            }
<span class="nc" id="L208">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L210">                log.log(java.util.logging.Level.FINE, &quot;IOException&quot;, ex);</span>
            }
<span class="nc" id="L212">        } catch (ParserConfigurationException e) {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L214">                log.log(java.util.logging.Level.FINE, &quot;ParserConfigurationException&quot;, e);</span>
            }
<span class="nc" id="L216">        } catch (SAXException e) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L218">                log.log(java.util.logging.Level.FINE, &quot;SAXException&quot;, e);</span>
            }
<span class="nc" id="L220">        }</span>
<span class="nc" id="L221">        return null;</span>
    }

    /**
     * Retrieves a x509Certificate from the given information
     * @param e
     * @param baseURI
     * @param storage
     * @return
     * @throws KeyResolverException
     */
    private static X509Certificate resolveCertificate(
        Element e, String baseURI, StorageResolver storage
    ) throws KeyResolverException {
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L236">            log.log(java.util.logging.Level.FINE, &quot;Now we have a {&quot; + e.getNamespaceURI() + &quot;}&quot;</span>
<span class="nc" id="L237">                + e.getLocalName() + &quot; Element&quot;);</span>
        }
        // An element has been provided
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (e != null) {</span>
<span class="nc" id="L241">            return KeyResolver.getX509Certificate(e, baseURI, storage);</span>
        }
<span class="nc" id="L243">        return null;</span>
    }

    /**
     * Retrieves a PublicKey from the given information
     * @param e
     * @param baseURI
     * @param storage
     * @return
     * @throws KeyResolverException
     */
    private static PublicKey resolveKey(
        Element e, String baseURI, StorageResolver storage
    ) throws KeyResolverException {
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L258">            log.log(java.util.logging.Level.FINE, &quot;Now we have a {&quot; + e.getNamespaceURI() + &quot;}&quot;</span>
<span class="nc" id="L259">                + e.getLocalName() + &quot; Element&quot;);</span>
        }
        // An element has been provided
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (e != null) {</span>
<span class="nc" id="L263">            return KeyResolver.getPublicKey(e, baseURI, storage);</span>
        }
<span class="nc" id="L265">        return null;</span>
    }

    private static Element obtainReferenceElement(XMLSignatureInput resource)
        throws CanonicalizationException, ParserConfigurationException,
        IOException, SAXException, KeyResolverException {
        Element e;
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (resource.isElement()){</span>
<span class="nc" id="L273">            e = (Element) resource.getSubNode();</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        } else if (resource.isNodeSet()) {</span>
            // Retrieved resource is a nodeSet
<span class="nc" id="L276">            e = getDocumentElement(resource.getNodeSet());</span>
        } else {
            // Retrieved resource is an inputStream
<span class="nc" id="L279">            byte inputBytes[] = resource.getBytes();</span>
<span class="nc" id="L280">            e = getDocFromBytes(inputBytes);</span>
            // otherwise, we parse the resource, create an Element and delegate
<span class="nc bnc" id="L282" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L283">                log.log(java.util.logging.Level.FINE, &quot;we have to parse &quot; + inputBytes.length + &quot; bytes&quot;);</span>
            }
        }
<span class="nc" id="L286">        return e;</span>
    }

    private static X509Certificate getRawCertificate(XMLSignatureInput resource)
        throws CanonicalizationException, IOException, CertificateException {
<span class="nc" id="L291">        byte inputBytes[] = resource.getBytes();</span>
        // if the resource stores a raw certificate, we have to handle it
<span class="nc" id="L293">        CertificateFactory certFact =</span>
<span class="nc" id="L294">            CertificateFactory.getInstance(XMLX509Certificate.JCA_CERT_ID);</span>
<span class="nc" id="L295">        X509Certificate cert = (X509Certificate)</span>
<span class="nc" id="L296">            certFact.generateCertificate(new ByteArrayInputStream(inputBytes));</span>
<span class="nc" id="L297">        return cert;</span>
    }

    /**
     * Resolves the input from the given retrieval method
     * @return
     * @throws XMLSecurityException
     */
    private static XMLSignatureInput resolveInput(
        RetrievalMethod rm, String baseURI, boolean secureValidation
    ) throws XMLSecurityException {
<span class="nc" id="L308">        Attr uri = rm.getURIAttr();</span>
        // Apply the transforms
<span class="nc" id="L310">        Transforms transforms = rm.getTransforms();</span>
<span class="nc" id="L311">        ResourceResolver resRes = ResourceResolver.getInstance(uri, baseURI, secureValidation);</span>
<span class="nc" id="L312">        XMLSignatureInput resource = resRes.resolve(uri, baseURI, secureValidation);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (transforms != null) {</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L315">                log.log(java.util.logging.Level.FINE, &quot;We have Transforms&quot;);</span>
            }
<span class="nc" id="L317">            resource = transforms.performTransforms(resource);</span>
        }
<span class="nc" id="L319">        return resource;</span>
    }

    /**
     * Parses a byte array and returns the parsed Element.
     *
     * @param bytes
     * @return the Document Element after parsing bytes
     * @throws KeyResolverException if something goes wrong
     */
    private static Element getDocFromBytes(byte[] bytes) throws KeyResolverException {
        try {
<span class="nc" id="L331">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L332">            dbf.setNamespaceAware(true);</span>
<span class="nc" id="L333">            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);</span>
<span class="nc" id="L334">            DocumentBuilder db = dbf.newDocumentBuilder();</span>
<span class="nc" id="L335">            Document doc = db.parse(new ByteArrayInputStream(bytes));</span>
<span class="nc" id="L336">            return doc.getDocumentElement();</span>
<span class="nc" id="L337">        } catch (SAXException ex) {</span>
<span class="nc" id="L338">            throw new KeyResolverException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L339">        } catch (IOException ex) {</span>
<span class="nc" id="L340">            throw new KeyResolverException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L341">        } catch (ParserConfigurationException ex) {</span>
<span class="nc" id="L342">            throw new KeyResolverException(&quot;empty&quot;, ex);</span>
        }
    }

    /**
     * Method engineResolveSecretKey
     * @inheritDoc
     * @param element
     * @param baseURI
     * @param storage
     */
    public javax.crypto.SecretKey engineLookupAndResolveSecretKey(
        Element element, String baseURI, StorageResolver storage
    ) {
<span class="nc" id="L356">        return null;</span>
    }

    private static Element getDocumentElement(Set&lt;Node&gt; set) {
<span class="nc" id="L360">        Iterator&lt;Node&gt; it = set.iterator();</span>
<span class="nc" id="L361">        Element e = null;</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L363">            Node currentNode = it.next();</span>
<span class="nc bnc" id="L364" title="All 4 branches missed.">            if (currentNode != null &amp;&amp; Node.ELEMENT_NODE == currentNode.getNodeType()) {</span>
<span class="nc" id="L365">                e = (Element) currentNode;</span>
<span class="nc" id="L366">                break;</span>
            }
<span class="nc" id="L368">        }</span>
<span class="nc" id="L369">        List&lt;Node&gt; parents = new ArrayList&lt;Node&gt;();</span>

        // Obtain all the parents of the elemnt
<span class="nc bnc" id="L372" title="All 2 branches missed.">        while (e != null) {</span>
<span class="nc" id="L373">            parents.add(e);</span>
<span class="nc" id="L374">            Node n = e.getParentNode();</span>
<span class="nc bnc" id="L375" title="All 4 branches missed.">            if (n == null || Node.ELEMENT_NODE != n.getNodeType()) {</span>
<span class="nc" id="L376">                break;</span>
            }
<span class="nc" id="L378">            e = (Element) n;</span>
<span class="nc" id="L379">        }</span>
        // Visit them in reverse order.
<span class="nc" id="L381">        ListIterator&lt;Node&gt; it2 = parents.listIterator(parents.size()-1);</span>
<span class="nc" id="L382">        Element ele = null;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        while (it2.hasPrevious()) {</span>
<span class="nc" id="L384">            ele = (Element) it2.previous();</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">            if (set.contains(ele)) {</span>
<span class="nc" id="L386">                return ele;</span>
            }
        }
<span class="nc" id="L389">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>