<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractCalendar.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.util.calendar</a> &gt; <span class="el_source">AbstractCalendar.java</span></div><h1>AbstractCalendar.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.util.calendar;

import java.util.Locale;
import java.util.TimeZone;

/**
 * The &lt;code&gt;AbstractCalendar&lt;/code&gt; class provides a framework for
 * implementing a concrete calendar system.
 *
 * &lt;p&gt;&lt;a name=&quot;fixed_date&quot;&gt;&lt;/a&gt;&lt;B&gt;Fixed Date&lt;/B&gt;&lt;br&gt;
 *
 * For implementing a concrete calendar system, each calendar must
 * have the common date numbering, starting from midnight the onset of
 * Monday, January 1, 1 (Gregorian). It is called a &lt;I&gt;fixed date&lt;/I&gt;
 * in this class. January 1, 1 (Gregorian) is fixed date 1. (See
 * Nachum Dershowitz and Edward M. Reingold, &lt;I&gt;CALENDRICAL
 * CALCULATION The Millennium Edition&lt;/I&gt;, Section 1.2 for details.)
 *
 * @author Masayoshi Okutsu
 * @since 1.5
 */

public abstract class AbstractCalendar extends CalendarSystem {

    // The constants assume no leap seconds support.
    static final int SECOND_IN_MILLIS = 1000;
    static final int MINUTE_IN_MILLIS = SECOND_IN_MILLIS * 60;
    static final int HOUR_IN_MILLIS = MINUTE_IN_MILLIS * 60;
    static final int DAY_IN_MILLIS = HOUR_IN_MILLIS * 24;

    // The number of days between January 1, 1 and January 1, 1970 (Gregorian)
    static final int EPOCH_OFFSET = 719163;

    private Era[] eras;

<span class="fc" id="L61">    protected AbstractCalendar() {</span>
<span class="fc" id="L62">    }</span>

    public Era getEra(String eraName) {
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (eras != null) {</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">            for (int i = 0; i &lt; eras.length; i++) {</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">                if (eras[i].equals(eraName)) {</span>
<span class="nc" id="L68">                    return eras[i];</span>
                }
            }
        }
<span class="nc" id="L72">        return null;</span>
    }

    public Era[] getEras() {
<span class="fc" id="L76">        Era[] e = null;</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        if (eras != null) {</span>
<span class="fc" id="L78">            e = new Era[eras.length];</span>
<span class="fc" id="L79">            System.arraycopy(eras, 0, e, 0, eras.length);</span>
        }
<span class="fc" id="L81">        return e;</span>
    }

    public void setEra(CalendarDate date, String eraName) {
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (eras == null) {</span>
<span class="nc" id="L86">            return; // should report an error???</span>
        }
<span class="nc bnc" id="L88" title="All 2 branches missed.">        for (int i = 0; i &lt; eras.length; i++) {</span>
<span class="nc" id="L89">            Era e = eras[i];</span>
<span class="nc bnc" id="L90" title="All 4 branches missed.">            if (e != null &amp;&amp; e.getName().equals(eraName)) {</span>
<span class="nc" id="L91">                date.setEra(e);</span>
<span class="nc" id="L92">                return;</span>
            }
        }
<span class="nc" id="L95">        throw new IllegalArgumentException(&quot;unknown era name: &quot; + eraName);</span>
    }

    protected void setEras(Era[] eras) {
<span class="fc" id="L99">        this.eras = eras;</span>
<span class="fc" id="L100">    }</span>

    public CalendarDate getCalendarDate() {
<span class="nc" id="L103">        return getCalendarDate(System.currentTimeMillis(), newCalendarDate());</span>
    }

    public CalendarDate getCalendarDate(long millis) {
<span class="nc" id="L107">        return getCalendarDate(millis, newCalendarDate());</span>
    }

    public CalendarDate getCalendarDate(long millis, TimeZone zone) {
<span class="nc" id="L111">        CalendarDate date = newCalendarDate(zone);</span>
<span class="nc" id="L112">        return getCalendarDate(millis, date);</span>
    }

    public CalendarDate getCalendarDate(long millis, CalendarDate date) {
<span class="fc" id="L116">        int ms = 0;             // time of day</span>
<span class="fc" id="L117">        int zoneOffset = 0;</span>
<span class="fc" id="L118">        int saving = 0;</span>
<span class="fc" id="L119">        long days = 0;          // fixed date</span>

        // adjust to local time if `date' has time zone.
<span class="fc" id="L122">        TimeZone zi = date.getZone();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (zi != null) {</span>
<span class="fc" id="L124">            int[] offsets = new int[2];</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">            if (zi instanceof ZoneInfo) {</span>
<span class="fc" id="L126">                zoneOffset = ((ZoneInfo)zi).getOffsets(millis, offsets);</span>
            } else {
<span class="nc" id="L128">                zoneOffset = zi.getOffset(millis);</span>
<span class="nc" id="L129">                offsets[0] = zi.getRawOffset();</span>
<span class="nc" id="L130">                offsets[1] = zoneOffset - offsets[0];</span>
            }

            // We need to calculate the given millis and time zone
            // offset separately for java.util.GregorianCalendar
            // compatibility. (i.e., millis + zoneOffset could cause
            // overflow or underflow, which must be avoided.) Usually
            // days should be 0 and ms is in the range of -13:00 to
            // +14:00. However, we need to deal with extreme cases.
<span class="fc" id="L139">            days = zoneOffset / DAY_IN_MILLIS;</span>
<span class="fc" id="L140">            ms = zoneOffset % DAY_IN_MILLIS;</span>
<span class="fc" id="L141">            saving = offsets[1];</span>
        }
<span class="fc" id="L143">        date.setZoneOffset(zoneOffset);</span>
<span class="fc" id="L144">        date.setDaylightSaving(saving);</span>

<span class="fc" id="L146">        days += millis / DAY_IN_MILLIS;</span>
<span class="fc" id="L147">        ms += (int) (millis % DAY_IN_MILLIS);</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (ms &gt;= DAY_IN_MILLIS) {</span>
            // at most ms is (DAY_IN_MILLIS - 1) * 2.
<span class="nc" id="L150">            ms -= DAY_IN_MILLIS;</span>
<span class="nc" id="L151">            ++days;</span>
        } else {
            // at most ms is (1 - DAY_IN_MILLIS) * 2. Adding one
            // DAY_IN_MILLIS results in still negative.
<span class="fc bfc" id="L155" title="All 2 branches covered.">            while (ms &lt; 0) {</span>
<span class="fc" id="L156">                ms += DAY_IN_MILLIS;</span>
<span class="fc" id="L157">                --days;</span>
            }
        }

        // convert to fixed date (offset from Jan. 1, 1 (Gregorian))
<span class="fc" id="L162">        days += EPOCH_OFFSET;</span>

        // calculate date fields from the fixed date
<span class="fc" id="L165">        getCalendarDateFromFixedDate(date, days);</span>

        // calculate time fields from the time of day
<span class="fc" id="L168">        setTimeOfDay(date, ms);</span>
<span class="fc" id="L169">        date.setLeapYear(isLeapYear(date));</span>
<span class="fc" id="L170">        date.setNormalized(true);</span>
<span class="fc" id="L171">        return date;</span>
    }

    public long getTime(CalendarDate date) {
<span class="fc" id="L175">        long gd = getFixedDate(date);</span>
<span class="fc" id="L176">        long ms = (gd - EPOCH_OFFSET) * DAY_IN_MILLIS + getTimeOfDay(date);</span>
<span class="fc" id="L177">        int zoneOffset = 0;</span>
<span class="fc" id="L178">        TimeZone zi = date.getZone();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (zi != null) {</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">            if (date.isNormalized()) {</span>
<span class="nc" id="L181">                return ms - date.getZoneOffset();</span>
            }
            // adjust time zone and daylight saving
<span class="fc" id="L184">            int[] offsets = new int[2];</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (date.isStandardTime()) {</span>
                // 1) 2:30am during starting-DST transition is
                //    intrepreted as 2:30am ST
                // 2) 5:00pm during DST is still interpreted as 5:00pm ST
                // 3) 1:30am during ending-DST transition is interpreted
                //    as 1:30am ST (after transition)
<span class="nc bnc" id="L191" title="All 2 branches missed.">                if (zi instanceof ZoneInfo) {</span>
<span class="nc" id="L192">                    ((ZoneInfo)zi).getOffsetsByStandard(ms, offsets);</span>
<span class="nc" id="L193">                    zoneOffset = offsets[0];</span>
                } else {
<span class="nc" id="L195">                    zoneOffset = zi.getOffset(ms - zi.getRawOffset());</span>
                }
            } else {
                // 1) 2:30am during starting-DST transition is
                //    intrepreted as 3:30am DT
                // 2) 5:00pm during DST is intrepreted as 5:00pm DT
                // 3) 1:30am during ending-DST transition is interpreted
                //    as 1:30am DT/0:30am ST (before transition)
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">                if (zi instanceof ZoneInfo) {</span>
<span class="fc" id="L204">                    zoneOffset = ((ZoneInfo)zi).getOffsetsByWall(ms, offsets);</span>
                } else {
<span class="nc" id="L206">                    zoneOffset = zi.getOffset(ms - zi.getRawOffset());</span>
                }
            }
        }
<span class="fc" id="L210">        ms -= zoneOffset;</span>
<span class="fc" id="L211">        getCalendarDate(ms, date);</span>
<span class="fc" id="L212">        return ms;</span>
    }

    protected long getTimeOfDay(CalendarDate date) {
<span class="fc" id="L216">        long fraction = date.getTimeOfDay();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (fraction != CalendarDate.TIME_UNDEFINED) {</span>
<span class="fc" id="L218">            return fraction;</span>
        }
<span class="fc" id="L220">        fraction = getTimeOfDayValue(date);</span>
<span class="fc" id="L221">        date.setTimeOfDay(fraction);</span>
<span class="fc" id="L222">        return fraction;</span>
    }

    public long getTimeOfDayValue(CalendarDate date) {
<span class="fc" id="L226">        long fraction = date.getHours();</span>
<span class="fc" id="L227">        fraction *= 60;</span>
<span class="fc" id="L228">        fraction += date.getMinutes();</span>
<span class="fc" id="L229">        fraction *= 60;</span>
<span class="fc" id="L230">        fraction += date.getSeconds();</span>
<span class="fc" id="L231">        fraction *= 1000;</span>
<span class="fc" id="L232">        fraction += date.getMillis();</span>
<span class="fc" id="L233">        return fraction;</span>
    }

    public CalendarDate setTimeOfDay(CalendarDate cdate, int fraction) {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (fraction &lt; 0) {</span>
<span class="nc" id="L238">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L240">        boolean normalizedState = cdate.isNormalized();</span>
<span class="fc" id="L241">        int time = fraction;</span>
<span class="fc" id="L242">        int hours = time / HOUR_IN_MILLIS;</span>
<span class="fc" id="L243">        time %= HOUR_IN_MILLIS;</span>
<span class="fc" id="L244">        int minutes = time / MINUTE_IN_MILLIS;</span>
<span class="fc" id="L245">        time %= MINUTE_IN_MILLIS;</span>
<span class="fc" id="L246">        int seconds = time / SECOND_IN_MILLIS;</span>
<span class="fc" id="L247">        time %= SECOND_IN_MILLIS;</span>
<span class="fc" id="L248">        cdate.setHours(hours);</span>
<span class="fc" id="L249">        cdate.setMinutes(minutes);</span>
<span class="fc" id="L250">        cdate.setSeconds(seconds);</span>
<span class="fc" id="L251">        cdate.setMillis(time);</span>
<span class="fc" id="L252">        cdate.setTimeOfDay(fraction);</span>
<span class="pc bpc" id="L253" title="2 of 4 branches missed.">        if (hours &lt; 24 &amp;&amp; normalizedState) {</span>
            // If this time of day setting doesn't affect the date,
            // then restore the normalized state.
<span class="fc" id="L256">            cdate.setNormalized(normalizedState);</span>
        }
<span class="fc" id="L258">        return cdate;</span>
    }

    /**
     * Returns 7 in this default implementation.
     *
     * @return 7
     */
    public int getWeekLength() {
<span class="nc" id="L267">        return 7;</span>
    }

    protected abstract boolean isLeapYear(CalendarDate date);

    public CalendarDate getNthDayOfWeek(int nth, int dayOfWeek, CalendarDate date) {
<span class="fc" id="L273">        CalendarDate ndate = (CalendarDate) date.clone();</span>
<span class="fc" id="L274">        normalize(ndate);</span>
<span class="fc" id="L275">        long fd = getFixedDate(ndate);</span>
        long nfd;
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (nth &gt; 0) {</span>
<span class="fc" id="L278">            nfd = 7 * nth + getDayOfWeekDateBefore(fd, dayOfWeek);</span>
        } else {
<span class="fc" id="L280">            nfd = 7 * nth + getDayOfWeekDateAfter(fd, dayOfWeek);</span>
        }
<span class="fc" id="L282">        getCalendarDateFromFixedDate(ndate, nfd);</span>
<span class="fc" id="L283">        return ndate;</span>
    }

    /**
     * Returns a date of the given day of week before the given fixed
     * date.
     *
     * @param fixedDate the fixed date
     * @param dayOfWeek the day of week
     * @return the calculated date
     */
    static long getDayOfWeekDateBefore(long fixedDate, int dayOfWeek) {
<span class="fc" id="L295">        return getDayOfWeekDateOnOrBefore(fixedDate - 1, dayOfWeek);</span>
    }

    /**
     * Returns a date of the given day of week that is closest to and
     * after the given fixed date.
     *
     * @param fixedDate the fixed date
     * @param dayOfWeek the day of week
     * @return the calculated date
     */
    static long getDayOfWeekDateAfter(long fixedDate, int dayOfWeek) {
<span class="fc" id="L307">        return getDayOfWeekDateOnOrBefore(fixedDate + 7, dayOfWeek);</span>
    }

    /**
     * Returns a date of the given day of week on or before the given fixed
     * date.
     *
     * @param fixedDate the fixed date
     * @param dayOfWeek the day of week
     * @return the calculated date
     */
    // public for java.util.GregorianCalendar
    public static long getDayOfWeekDateOnOrBefore(long fixedDate, int dayOfWeek) {
<span class="fc" id="L320">        long fd = fixedDate - (dayOfWeek - 1);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">        if (fd &gt;= 0) {</span>
<span class="fc" id="L322">            return fixedDate - (fd % 7);</span>
        }
<span class="fc" id="L324">        return fixedDate - CalendarUtils.mod(fd, 7);</span>
    }

    /**
     * Returns the fixed date calculated with the specified calendar
     * date. If the specified date is not normalized, its date fields
     * are normalized.
     *
     * @param date a &lt;code&gt;CalendarDate&lt;/code&gt; with which the fixed
     * date is calculated
     * @return the calculated fixed date
     * @see AbstractCalendar.html#fixed_date
     */
    protected abstract long getFixedDate(CalendarDate date);

    /**
     * Calculates calendar fields from the specified fixed date. This
     * method stores the calculated calendar field values in the specified
     * &lt;code&gt;CalendarDate&lt;/code&gt;.
     *
     * @param date a &lt;code&gt;CalendarDate&lt;/code&gt; to stored the
     * calculated calendar fields.
     * @param fixedDate a fixed date to calculate calendar fields
     * @see AbstractCalendar.html#fixed_date
     */
    protected abstract void getCalendarDateFromFixedDate(CalendarDate date,
                                                         long fixedDate);

    public boolean validateTime(CalendarDate date) {
<span class="nc" id="L353">        int t = date.getHours();</span>
<span class="nc bnc" id="L354" title="All 4 branches missed.">        if (t &lt; 0 || t &gt;= 24) {</span>
<span class="nc" id="L355">            return false;</span>
        }
<span class="nc" id="L357">        t = date.getMinutes();</span>
<span class="nc bnc" id="L358" title="All 4 branches missed.">        if (t &lt; 0 || t &gt;= 60) {</span>
<span class="nc" id="L359">            return false;</span>
        }
<span class="nc" id="L361">        t = date.getSeconds();</span>
        // TODO: Leap second support.
<span class="nc bnc" id="L363" title="All 4 branches missed.">        if (t &lt; 0 || t &gt;= 60) {</span>
<span class="nc" id="L364">            return false;</span>
        }
<span class="nc" id="L366">        t = date.getMillis();</span>
<span class="nc bnc" id="L367" title="All 4 branches missed.">        if (t &lt; 0 || t &gt;= 1000) {</span>
<span class="nc" id="L368">            return false;</span>
        }
<span class="nc" id="L370">        return true;</span>
    }


    int normalizeTime(CalendarDate date) {
<span class="fc" id="L375">        long fraction = getTimeOfDay(date);</span>
<span class="fc" id="L376">        long days = 0;</span>

<span class="pc bpc" id="L378" title="1 of 2 branches missed.">        if (fraction &gt;= DAY_IN_MILLIS) {</span>
<span class="nc" id="L379">            days = fraction / DAY_IN_MILLIS;</span>
<span class="nc" id="L380">            fraction %= DAY_IN_MILLIS;</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        } else if (fraction &lt; 0) {</span>
<span class="nc" id="L382">            days = CalendarUtils.floorDivide(fraction, DAY_IN_MILLIS);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">            if (days != 0) {</span>
<span class="nc" id="L384">                fraction -= DAY_IN_MILLIS * days; // mod(fraction, DAY_IN_MILLIS)</span>
            }
        }
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (days != 0) {</span>
<span class="nc" id="L388">            date.setTimeOfDay(fraction);</span>
        }
<span class="fc" id="L390">        date.setMillis((int)(fraction % 1000));</span>
<span class="fc" id="L391">        fraction /= 1000;</span>
<span class="fc" id="L392">        date.setSeconds((int)(fraction % 60));</span>
<span class="fc" id="L393">        fraction /= 60;</span>
<span class="fc" id="L394">        date.setMinutes((int)(fraction % 60));</span>
<span class="fc" id="L395">        date.setHours((int)(fraction / 60));</span>
<span class="fc" id="L396">        return (int)days;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>