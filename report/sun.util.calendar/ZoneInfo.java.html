<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ZoneInfo.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.util.calendar</a> &gt; <span class="el_source">ZoneInfo.java</span></div><h1>ZoneInfo.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.util.calendar;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.lang.ref.SoftReference;
import java.security.AccessController;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.SimpleTimeZone;
import java.util.TimeZone;

/**
 * &lt;code&gt;ZoneInfo&lt;/code&gt; is an implementation subclass of {@link
 * java.util.TimeZone TimeZone} that represents GMT offsets and
 * daylight saving time transitions of a time zone.
 * &lt;p&gt;
 * The daylight saving time transitions are described in the {@link
 * #transitions transitions} table consisting of a chronological
 * sequence of transitions of GMT offset and/or daylight saving time
 * changes. Since all transitions are represented in UTC, in theory,
 * &lt;code&gt;ZoneInfo&lt;/code&gt; can be used with any calendar systems except
 * for the {@link #getOffset(int,int,int,int,int,int) getOffset}
 * method that takes Gregorian calendar date fields.
 * &lt;p&gt;
 * This table covers transitions from 1900 until 2037 (as of version
 * 1.4), Before 1900, it assumes that there was no daylight saving
 * time and the &lt;code&gt;getOffset&lt;/code&gt; methods always return the
 * {@link #getRawOffset} value. No Local Mean Time is supported. If a
 * specified date is beyond the transition table and this time zone is
 * supposed to observe daylight saving time in 2037, it delegates
 * operations to a {@link java.util.SimpleTimeZone SimpleTimeZone}
 * object created using the daylight saving time schedule as of 2037.
 * &lt;p&gt;
 * The date items, transitions, GMT offset(s), etc. are read from a database
 * file. See {@link ZoneInfoFile} for details.
 * @see java.util.SimpleTimeZone
 * @since 1.4
 */

public class ZoneInfo extends TimeZone {

    private static final int UTC_TIME = 0;
    private static final int STANDARD_TIME = 1;
    private static final int WALL_TIME = 2;

    private static final long OFFSET_MASK = 0x0fL;
    private static final long DST_MASK = 0xf0L;
    private static final int DST_NSHIFT = 4;
    // this bit field is reserved for abbreviation support
    private static final long ABBR_MASK = 0xf00L;
    private static final int TRANSITION_NSHIFT = 12;

<span class="fc" id="L83">    private static final CalendarSystem gcal = CalendarSystem.getGregorianCalendar();</span>

    /**
     * The raw GMT offset in milliseconds between this zone and GMT.
     * Negative offsets are to the west of Greenwich.  To obtain local
     * &lt;em&gt;standard&lt;/em&gt; time, add the offset to GMT time.
     * @serial
     */
    private int rawOffset;

    /**
     * Difference in milliseconds from the original GMT offset in case
     * the raw offset value has been modified by calling {@link
     * #setRawOffset}. The initial value is 0.
     * @serial
     */
<span class="pc" id="L99">    private int rawOffsetDiff = 0;</span>

    /**
     * A CRC32 value of all pairs of transition time (in milliseconds
     * in &lt;code&gt;long&lt;/code&gt;) in local time and its GMT offset (in
     * seconds in &lt;code&gt;int&lt;/code&gt;) in the chronological order. Byte
     * values of each &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; are taken
     * in the big endian order (i.e., MSB to LSB).
     * @serial
     */
    private int checksum;

    /**
     * The amount of time in milliseconds saved during daylight saving
     * time. If &lt;code&gt;useDaylight&lt;/code&gt; is false, this value is 0.
     * @serial
     */
    private int dstSavings;

    /**
     * This array describes transitions of GMT offsets of this time
     * zone, including both raw offset changes and daylight saving
     * time changes.
     * A long integer consists of four bit fields.
     * &lt;ul&gt;
     * &lt;li&gt;The most significant 52-bit field represents transition
     * time in milliseconds from Gregorian January 1 1970, 00:00:00
     * GMT.&lt;/li&gt;
     * &lt;li&gt;The next 4-bit field is reserved and must be 0.&lt;/li&gt;
     * &lt;li&gt;The next 4-bit field is an index value to {@link #offsets
     * offsets[]} for the amount of daylight saving at the
     * transition. If this value is zero, it means that no daylight
     * saving, not the index value zero.&lt;/li&gt;
     * &lt;li&gt;The least significant 4-bit field is an index value to
     * {@link #offsets offsets[]} for &lt;em&gt;total&lt;/em&gt; GMT offset at the
     * transition.&lt;/li&gt;
     * &lt;/ul&gt;
     * If this time zone doesn't observe daylight saving time and has
     * never changed any GMT offsets in the past, this value is null.
     * @serial
     */
    private long[] transitions;

    /**
     * This array holds all unique offset values in
     * milliseconds. Index values to this array are stored in the
     * transitions array elements.
     * @serial
     */
    private int[] offsets;

    /**
     * SimpleTimeZone parameter values. It has to have either 8 for
     * {@link java.util.SimpleTimeZone#SimpleTimeZone(int, String,
     * int, int , int , int , int , int , int , int , int) the
     * 11-argument SimpleTimeZone constructor} or 10 for {@link
     * java.util.SimpleTimeZone#SimpleTimeZone(int, String, int, int,
     * int , int , int , int , int , int , int, int, int) the
     * 13-argument SimpleTimeZone constructor} parameters.
     * @serial
     */
    private int[] simpleTimeZoneParams;

    /**
     * True if the raw GMT offset value would change after the time
     * zone data has been generated; false, otherwise. The default
     * value is false.
     * @serial
     */
<span class="pc" id="L168">    private boolean willGMTOffsetChange = false;</span>

    /**
     * True if the object has been modified after its instantiation.
     */
<span class="pc" id="L173">    transient private boolean dirty = false;</span>

    private static final long serialVersionUID = 2653134537216586139L;

    /**
     * A constructor.
     */
<span class="nc" id="L180">    public ZoneInfo() {</span>
<span class="nc" id="L181">    }</span>

    /**
     * A Constructor for CustomID.
     */
    public ZoneInfo(String ID, int rawOffset) {
<span class="fc" id="L187">        this(ID, rawOffset, 0, 0, null, null, null, false);</span>
<span class="fc" id="L188">    }</span>

    /**
     * Constructs a ZoneInfo instance.
     *
     * @param ID time zone name
     * @param rawOffset GMT offset in milliseconds
     * @param dstSavings daylight saving value in milliseconds or 0
     * (zero) if this time zone doesn't observe Daylight Saving Time.
     * @param checksum CRC32 value with all transitions table entry
     * values
     * @param transitions transition table
     * @param offsets offset value table
     * @param simpleTimeZoneParams parameter values for constructing
     * SimpleTimeZone
     * @param willGMTOffsetChange the value of willGMTOffsetChange
     */
    ZoneInfo(String ID,
             int rawOffset,
             int dstSavings,
             int checksum,
             long[] transitions,
             int[] offsets,
             int[] simpleTimeZoneParams,
<span class="fc" id="L212">             boolean willGMTOffsetChange) {</span>
<span class="fc" id="L213">        setID(ID);</span>
<span class="fc" id="L214">        this.rawOffset = rawOffset;</span>
<span class="fc" id="L215">        this.dstSavings = dstSavings;</span>
<span class="fc" id="L216">        this.checksum = checksum;</span>
<span class="fc" id="L217">        this.transitions = transitions;</span>
<span class="fc" id="L218">        this.offsets = offsets;</span>
<span class="fc" id="L219">        this.simpleTimeZoneParams = simpleTimeZoneParams;</span>
<span class="fc" id="L220">        this.willGMTOffsetChange = willGMTOffsetChange;</span>
<span class="fc" id="L221">    }</span>

    /**
     * Returns the difference in milliseconds between local time and UTC
     * of given time, taking into account both the raw offset and the
     * effect of daylight savings.
     *
     * @param date the milliseconds in UTC
     * @return the milliseconds to add to UTC to get local wall time
     */
    public int getOffset(long date) {
<span class="fc" id="L232">        return getOffsets(date, null, UTC_TIME);</span>
    }

    public int getOffsets(long utc, int[] offsets) {
<span class="fc" id="L236">        return getOffsets(utc, offsets, UTC_TIME);</span>
    }

    public int getOffsetsByStandard(long standard, int[] offsets) {
<span class="nc" id="L240">        return getOffsets(standard, offsets, STANDARD_TIME);</span>
    }

    public int getOffsetsByWall(long wall, int[] offsets) {
<span class="fc" id="L244">        return getOffsets(wall, offsets, WALL_TIME);</span>
    }

    private int getOffsets(long date, int[] offsets, int type) {
        // if dst is never observed, there is no transition.
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (transitions == null) {</span>
<span class="fc" id="L250">            int offset = getLastRawOffset();</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (offsets != null) {</span>
<span class="fc" id="L252">                offsets[0] = offset;</span>
<span class="fc" id="L253">                offsets[1] = 0;</span>
            }
<span class="fc" id="L255">            return offset;</span>
        }

<span class="fc" id="L258">        date -= rawOffsetDiff;</span>
<span class="fc" id="L259">        int index = getTransitionIndex(date, type);</span>

        // prior to the transition table, returns the raw offset.
        // FIXME: should support LMT.
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L264">            int offset = getLastRawOffset();</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">            if (offsets != null) {</span>
<span class="fc" id="L266">                offsets[0] = offset;</span>
<span class="fc" id="L267">                offsets[1] = 0;</span>
            }
<span class="fc" id="L269">            return offset;</span>
        }

<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (index &lt; transitions.length) {</span>
<span class="fc" id="L273">            long val = transitions[index];</span>
<span class="fc" id="L274">            int offset = this.offsets[(int)(val &amp; OFFSET_MASK)] + rawOffsetDiff;</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">            if (offsets != null) {</span>
<span class="fc" id="L276">                int dst = (int)((val &gt;&gt;&gt; DST_NSHIFT) &amp; 0xfL);</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                int save = (dst == 0) ? 0 : this.offsets[dst];</span>
<span class="fc" id="L278">                offsets[0] = offset - save;</span>
<span class="fc" id="L279">                offsets[1] = save;</span>
            }
<span class="fc" id="L281">            return offset;</span>
        }

        // beyond the transitions, delegate to SimpleTimeZone if there
        // is a rule; otherwise, return rawOffset.
<span class="fc" id="L286">        SimpleTimeZone tz = getLastRule();</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (tz != null) {</span>
<span class="fc" id="L288">            int rawoffset = tz.getRawOffset();</span>
<span class="fc" id="L289">            long msec = date;</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">            if (type != UTC_TIME) {</span>
<span class="fc" id="L291">                msec -= rawOffset;</span>
            }
<span class="fc" id="L293">            int dstoffset = tz.getOffset(msec) - rawOffset;</span>

            // Check if it's in a standard-to-daylight transition.
<span class="pc bpc" id="L296" title="1 of 4 branches missed.">            if (dstoffset &gt; 0 &amp;&amp; tz.getOffset(msec - dstoffset) == rawoffset) {</span>
<span class="nc" id="L297">                dstoffset = 0;</span>
            }

<span class="pc bpc" id="L300" title="1 of 2 branches missed.">            if (offsets != null) {</span>
<span class="fc" id="L301">                offsets[0] = rawoffset;</span>
<span class="fc" id="L302">                offsets[1] = dstoffset;</span>
            }
<span class="fc" id="L304">            return rawoffset + dstoffset;</span>
        }
<span class="fc" id="L306">        int offset = getLastRawOffset();</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (offsets != null) {</span>
<span class="fc" id="L308">            offsets[0] = offset;</span>
<span class="fc" id="L309">            offsets[1] = 0;</span>
        }
<span class="fc" id="L311">        return offset;</span>
    }

    private int getTransitionIndex(long date, int type) {
<span class="fc" id="L315">        int low = 0;</span>
<span class="fc" id="L316">        int high = transitions.length - 1;</span>

<span class="fc bfc" id="L318" title="All 2 branches covered.">        while (low &lt;= high) {</span>
<span class="fc" id="L319">            int mid = (low + high) / 2;</span>
<span class="fc" id="L320">            long val = transitions[mid];</span>
<span class="fc" id="L321">            long midVal = val &gt;&gt; TRANSITION_NSHIFT; // sign extended</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">            if (type != UTC_TIME) {</span>
<span class="fc" id="L323">                midVal += offsets[(int)(val &amp; OFFSET_MASK)]; // wall time</span>
            }
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">            if (type == STANDARD_TIME) {</span>
<span class="nc" id="L326">                int dstIndex = (int)((val &gt;&gt;&gt; DST_NSHIFT) &amp; 0xfL);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                if (dstIndex != 0) {</span>
<span class="nc" id="L328">                    midVal -= offsets[dstIndex]; // make it standard time</span>
                }
            }

<span class="fc bfc" id="L332" title="All 2 branches covered.">            if (midVal &lt; date) {</span>
<span class="fc" id="L333">                low = mid + 1;</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">            } else if (midVal &gt; date) {</span>
<span class="fc" id="L335">                high = mid - 1;</span>
            } else {
<span class="nc" id="L337">                return mid;</span>
            }
<span class="fc" id="L339">        }</span>

        // if beyond the transitions, returns that index.
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (low &gt;= transitions.length) {</span>
<span class="fc" id="L343">            return low;</span>
        }
<span class="fc" id="L345">        return low - 1;</span>
    }

   /**
     * Returns the difference in milliseconds between local time and
     * UTC, taking into account both the raw offset and the effect of
     * daylight savings, for the specified date and time.  This method
     * assumes that the start and end month are distinct.  This method
     * assumes a Gregorian calendar for calculations.
     * &lt;p&gt;
     * &lt;em&gt;Note: In general, clients should use
     * {@link Calendar#ZONE_OFFSET Calendar.get(ZONE_OFFSET)} +
     * {@link Calendar#DST_OFFSET Calendar.get(DST_OFFSET)}
     * instead of calling this method.&lt;/em&gt;
     *
     * @param era       The era of the given date. The value must be either
     *                  GregorianCalendar.AD or GregorianCalendar.BC.
     * @param year      The year in the given date.
     * @param month     The month in the given date. Month is 0-based. e.g.,
     *                  0 for January.
     * @param day       The day-in-month of the given date.
     * @param dayOfWeek The day-of-week of the given date.
     * @param millis    The milliseconds in day in &lt;em&gt;standard&lt;/em&gt; local time.
     * @return The milliseconds to add to UTC to get local time.
     */
    public int getOffset(int era, int year, int month, int day,
                         int dayOfWeek, int milliseconds) {
<span class="nc bnc" id="L372" title="All 4 branches missed.">        if (milliseconds &lt; 0 || milliseconds &gt;= AbstractCalendar.DAY_IN_MILLIS) {</span>
<span class="nc" id="L373">            throw new IllegalArgumentException();</span>
        }

<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (era == java.util.GregorianCalendar.BC) { // BC</span>
<span class="nc" id="L377">            year = 1 - year;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        } else if (era != java.util.GregorianCalendar.AD) {</span>
<span class="nc" id="L379">            throw new IllegalArgumentException();</span>
        }

<span class="nc" id="L382">        CalendarDate date = gcal.newCalendarDate(null);</span>
<span class="nc" id="L383">        date.setDate(year, month + 1, day);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (gcal.validate(date) == false) {</span>
<span class="nc" id="L385">            throw new IllegalArgumentException();</span>
        }

        // bug-for-bug compatible argument checking
<span class="nc bnc" id="L389" title="All 4 branches missed.">        if (dayOfWeek &lt; java.util.GregorianCalendar.SUNDAY</span>
            || dayOfWeek &gt; java.util.GregorianCalendar.SATURDAY) {
<span class="nc" id="L391">            throw new IllegalArgumentException();</span>
        }

<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (transitions == null) {</span>
<span class="nc" id="L395">            return getLastRawOffset();</span>
        }

<span class="nc" id="L398">        long dateInMillis = gcal.getTime(date) + milliseconds;</span>
<span class="nc" id="L399">        dateInMillis -= (long) rawOffset; // make it UTC</span>
<span class="nc" id="L400">        return getOffsets(dateInMillis, null, UTC_TIME);</span>
    }

    /**
     * Sets the base time zone offset from GMT. This operation
     * modifies all the transitions of this ZoneInfo object, including
     * historical ones, if applicable.
     *
     * @param offsetMillis the base time zone offset to GMT.
     * @see getRawOffset
     */
    public synchronized void setRawOffset(int offsetMillis) {
<span class="fc bfc" id="L412" title="All 2 branches covered.">        if (offsetMillis == rawOffset + rawOffsetDiff) {</span>
<span class="fc" id="L413">            return;</span>
        }
<span class="fc" id="L415">        rawOffsetDiff = offsetMillis - rawOffset;</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        if (lastRule != null) {</span>
<span class="nc" id="L417">            lastRule.setRawOffset(offsetMillis);</span>
        }
<span class="fc" id="L419">        dirty = true;</span>
<span class="fc" id="L420">    }</span>

    /**
     * Returns the GMT offset of the current date. This GMT offset
     * value is not modified during Daylight Saving Time.
     *
     * @return the GMT offset value in milliseconds to add to UTC time
     * to get local standard time
     */
    public int getRawOffset() {
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">        if (!willGMTOffsetChange) {</span>
<span class="fc" id="L431">            return rawOffset + rawOffsetDiff;</span>
        }

<span class="nc" id="L434">        int[] offsets = new int[2];</span>
<span class="nc" id="L435">        getOffsets(System.currentTimeMillis(), offsets, UTC_TIME);</span>
<span class="nc" id="L436">        return offsets[0];</span>
    }

    public boolean isDirty() {
<span class="fc" id="L440">        return dirty;</span>
    }

    private int getLastRawOffset() {
<span class="fc" id="L444">        return rawOffset + rawOffsetDiff;</span>
    }

    /**
     * Queries if this time zone uses Daylight Saving Time in the last known rule.
     */
    public boolean useDaylightTime() {
<span class="fc bfc" id="L451" title="All 2 branches covered.">        return (simpleTimeZoneParams != null);</span>
    }

    @Override
    public boolean observesDaylightTime() {
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (simpleTimeZoneParams != null) {</span>
<span class="fc" id="L457">            return true;</span>
        }
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (transitions == null) {</span>
<span class="fc" id="L460">            return false;</span>
        }

        // Look up the transition table to see if it's in DST right
        // now or if there's any standard-to-daylight transition at
        // any future.
<span class="fc" id="L466">        long utc = System.currentTimeMillis() - rawOffsetDiff;</span>
<span class="fc" id="L467">        int index = getTransitionIndex(utc, UTC_TIME);</span>

        // before transitions in the transition table
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L471">            return false;</span>
        }

        // the time is in the table range.
<span class="fc bfc" id="L475" title="All 2 branches covered.">        for (int i = index; i &lt; transitions.length; i++) {</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">            if ((transitions[i] &amp; DST_MASK) != 0) {</span>
<span class="nc" id="L477">                return true;</span>
            }
        }
        // No further DST is observed.
<span class="fc" id="L481">        return false;</span>
    }

    /**
     * Queries if the specified date is in Daylight Saving Time.
     */
    public boolean inDaylightTime(Date date) {
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (date == null) {</span>
<span class="nc" id="L489">            throw new NullPointerException();</span>
        }

<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (transitions == null) {</span>
<span class="nc" id="L493">            return false;</span>
        }

<span class="nc" id="L496">        long utc = date.getTime() - rawOffsetDiff;</span>
<span class="nc" id="L497">        int index = getTransitionIndex(utc, UTC_TIME);</span>

        // before transitions in the transition table
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L501">            return false;</span>
        }

        // the time is in the table range.
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (index &lt; transitions.length) {</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">            return (transitions[index] &amp; DST_MASK) != 0;</span>
        }

        // beyond the transition table
<span class="nc" id="L510">        SimpleTimeZone tz = getLastRule();</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (tz != null) {</span>
<span class="nc" id="L512">            return tz.inDaylightTime(date);</span>
       }
<span class="nc" id="L514">        return false;</span>
    }

    /**
     * Returns the amount of time in milliseconds that the clock is advanced
     * during daylight saving time is in effect in its last daylight saving time rule.
     *
     * @return the number of milliseconds the time is advanced with respect to
     * standard time when daylight saving time is in effect.
     */
    public int getDSTSavings() {
<span class="nc" id="L525">        return dstSavings;</span>
    }

//    /**
//     * @return the last year in the transition table or -1 if this
//     * time zone doesn't observe any daylight saving time.
//     */
//    public int getMaxTransitionYear() {
//      if (transitions == null) {
//          return -1;
//      }
//      long val = transitions[transitions.length - 1];
//      int offset = this.offsets[(int)(val &amp; OFFSET_MASK)] + rawOffsetDiff;
//      val = (val &gt;&gt; TRANSITION_NSHIFT) + offset;
//      CalendarDate lastDate = Gregorian.getCalendarDate(val);
//      return lastDate.getYear();
//    }

    /**
     * Returns a string representation of this time zone.
     * @return the string
     */
    public String toString() {
<span class="nc" id="L548">        return getClass().getName() +</span>
<span class="nc" id="L549">            &quot;[id=\&quot;&quot; + getID() + &quot;\&quot;&quot; +</span>
<span class="nc" id="L550">            &quot;,offset=&quot; + getLastRawOffset() +</span>
            &quot;,dstSavings=&quot; + dstSavings +
<span class="nc bnc" id="L552" title="All 4 branches missed.">            &quot;,useDaylight=&quot; + useDaylightTime() +</span>
            &quot;,transitions=&quot; + ((transitions != null) ? transitions.length : 0) +
<span class="nc" id="L554">            &quot;,lastRule=&quot; + (lastRule == null ? getLastRuleInstance() : lastRule) +</span>
            &quot;]&quot;;
    }

    /**
     * Gets all available IDs supported in the Java run-time.
     *
     * @return an array of time zone IDs.
     */
    public static String[] getAvailableIDs() {
<span class="fc" id="L564">        return ZoneInfoFile.getZoneIds();</span>
    }

    /**
     * Gets all available IDs that have the same value as the
     * specified raw GMT offset.
     *
     * @param rawOffset the GMT offset in milliseconds. This
     * value should not include any daylight saving time.
     *
     * @return an array of time zone IDs.
     */
    public static String[] getAvailableIDs(int rawOffset) {
<span class="fc" id="L577">        return ZoneInfoFile.getZoneIds(rawOffset);</span>
    }

    /**
     * Gets the ZoneInfo for the given ID.
     *
     * @param ID the ID for a ZoneInfo. See TimeZone for detail.
     *
     * @return the specified ZoneInfo object, or null if there is no
     * time zone of the ID.
     */
    public static TimeZone getTimeZone(String ID) {
<span class="fc" id="L589">        return ZoneInfoFile.getZoneInfo(ID);</span>
    }

    private transient SimpleTimeZone lastRule;

    /**
     * Returns a SimpleTimeZone object representing the last GMT
     * offset and DST schedule or null if this time zone doesn't
     * observe DST.
     */
    private synchronized SimpleTimeZone getLastRule() {
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if (lastRule == null) {</span>
<span class="fc" id="L601">            lastRule = getLastRuleInstance();</span>
        }
<span class="fc" id="L603">        return lastRule;</span>
    }

    /**
     * Returns a SimpleTimeZone object that represents the last
     * known daylight saving time rules.
     *
     * @return a SimpleTimeZone object or null if this time zone
     * doesn't observe DST.
     */
    public SimpleTimeZone getLastRuleInstance() {
<span class="fc bfc" id="L614" title="All 2 branches covered.">        if (simpleTimeZoneParams == null) {</span>
<span class="fc" id="L615">            return null;</span>
        }
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">        if (simpleTimeZoneParams.length == 10) {</span>
<span class="fc" id="L618">            return new SimpleTimeZone(getLastRawOffset(), getID(),</span>
                                      simpleTimeZoneParams[0],
                                      simpleTimeZoneParams[1],
                                      simpleTimeZoneParams[2],
                                      simpleTimeZoneParams[3],
                                      simpleTimeZoneParams[4],
                                      simpleTimeZoneParams[5],
                                      simpleTimeZoneParams[6],
                                      simpleTimeZoneParams[7],
                                      simpleTimeZoneParams[8],
                                      simpleTimeZoneParams[9],
                                      dstSavings);
        }
<span class="nc" id="L631">        return new SimpleTimeZone(getLastRawOffset(), getID(),</span>
                                  simpleTimeZoneParams[0],
                                  simpleTimeZoneParams[1],
                                  simpleTimeZoneParams[2],
                                  simpleTimeZoneParams[3],
                                  simpleTimeZoneParams[4],
                                  simpleTimeZoneParams[5],
                                  simpleTimeZoneParams[6],
                                  simpleTimeZoneParams[7],
                                  dstSavings);
    }

    /**
     * Returns a copy of this &lt;code&gt;ZoneInfo&lt;/code&gt;.
     */
    public Object clone() {
<span class="fc" id="L647">        ZoneInfo zi = (ZoneInfo) super.clone();</span>
<span class="fc" id="L648">        zi.lastRule = null;</span>
<span class="fc" id="L649">        return zi;</span>
    }

    /**
     * Returns a hash code value calculated from the GMT offset and
     * transitions.
     * @return a hash code of this time zone
     */
    public int hashCode() {
<span class="nc" id="L658">        return getLastRawOffset() ^ checksum;</span>
    }

    /**
     * Compares the equity of two ZoneInfo objects.
     *
     * @param obj the object to be compared with
     * @return true if given object is same as this ZoneInfo object,
     * false otherwise.
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L670">            return true;</span>
        }
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">        if (!(obj instanceof ZoneInfo)) {</span>
<span class="nc" id="L673">            return false;</span>
        }
<span class="fc" id="L675">        ZoneInfo that = (ZoneInfo) obj;</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">        return (getID().equals(that.getID())</span>
<span class="pc bpc" id="L677" title="2 of 4 branches missed.">                &amp;&amp; (getLastRawOffset() == that.getLastRawOffset())</span>
                &amp;&amp; (checksum == that.checksum));
    }

    /**
     * Returns true if this zone has the same raw GMT offset value and
     * transition table as another zone info. If the specified
     * TimeZone object is not a ZoneInfo instance, this method returns
     * true if the specified TimeZone object has the same raw GMT
     * offset value with no daylight saving time.
     *
     * @param other the ZoneInfo object to be compared with
     * @return true if the given &lt;code&gt;TimeZone&lt;/code&gt; has the same
     * GMT offset and transition information; false, otherwise.
     */
    public boolean hasSameRules(TimeZone other) {
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">        if (this == other) {</span>
<span class="nc" id="L694">            return true;</span>
        }
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">        if (other == null) {</span>
<span class="nc" id="L697">            return false;</span>
        }
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">        if (!(other instanceof ZoneInfo)) {</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">            if (getRawOffset() != other.getRawOffset()) {</span>
<span class="nc" id="L701">                return false;</span>
            }
            // if both have the same raw offset and neither observes
            // DST, they have the same rule.
<span class="nc bnc" id="L705" title="All 2 branches missed.">            if ((transitions == null)</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                &amp;&amp; (useDaylightTime() == false)</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">                &amp;&amp; (other.useDaylightTime() == false)) {</span>
<span class="nc" id="L708">                return true;</span>
            }
<span class="nc" id="L710">            return false;</span>
        }
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">        if (getLastRawOffset() != ((ZoneInfo)other).getLastRawOffset()) {</span>
<span class="nc" id="L713">            return false;</span>
        }
<span class="fc bfc" id="L715" title="All 2 branches covered.">        return (checksum == ((ZoneInfo)other).checksum);</span>
    }

    /**
     * Returns a Map from alias time zone IDs to their standard
     * time zone IDs.
     *
     * @return the Map that holds the mappings from alias time zone IDs
     *    to their standard time zone IDs, or null if
     *    &lt;code&gt;ZoneInfoMappings&lt;/code&gt; file is not available.
     */
    public static Map&lt;String, String&gt; getAliasTable() {
<span class="fc" id="L727">         return ZoneInfoFile.getAliasMap();</span>
    }

    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
<span class="nc" id="L732">        stream.defaultReadObject();</span>
        // We don't know how this object from 1.4.x or earlier has
        // been mutated. So it should always be marked as `dirty'.
<span class="nc" id="L735">        dirty = true;</span>
<span class="nc" id="L736">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>