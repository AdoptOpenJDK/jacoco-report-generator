<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ZoneInfoFile.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.util.calendar</a> &gt; <span class="el_source">ZoneInfoFile.java</span></div><h1>ZoneInfoFile.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.util.calendar;

import java.io.ByteArrayInputStream;
import java.io.BufferedInputStream;
import java.io.DataInput;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.StreamCorruptedException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.SimpleTimeZone;
import java.util.concurrent.ConcurrentHashMap;
import java.util.zip.CRC32;
import sun.security.action.GetPropertyAction;

/**
 * Loads TZDB time-zone rules for j.u.TimeZone
 * &lt;p&gt;
 * @since 1.8
 */
public final class ZoneInfoFile {

    /**
     * Gets all available IDs supported in the Java run-time.
     *
     * @return a set of time zone IDs.
     */
    public static String[] getZoneIds() {
<span class="fc" id="L69">        int len = regions.length + oldMappings.length;</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        if (!USE_OLDMAPPING) {</span>
<span class="fc" id="L71">            len += 3;    // EST/HST/MST not in tzdb.dat</span>
        }
<span class="fc" id="L73">        String[] ids = Arrays.copyOf(regions, len);</span>
<span class="fc" id="L74">        int i = regions.length;</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        if (!USE_OLDMAPPING) {</span>
<span class="fc" id="L76">            ids[i++] = &quot;EST&quot;;</span>
<span class="fc" id="L77">            ids[i++] = &quot;HST&quot;;</span>
<span class="fc" id="L78">            ids[i++] = &quot;MST&quot;;</span>
        }
<span class="fc bfc" id="L80" title="All 2 branches covered.">        for (int j = 0; j &lt; oldMappings.length; j++) {</span>
<span class="fc" id="L81">            ids[i++] = oldMappings[j][0];</span>
        }
<span class="fc" id="L83">        return ids;</span>
    }

    /**
     * Gets all available IDs that have the same value as the
     * specified raw GMT offset.
     *
     * @param rawOffset  the GMT offset in milliseconds. This
     *                   value should not include any daylight saving time.
     * @return an array of time zone IDs.
     */
    public static String[] getZoneIds(int rawOffset) {
<span class="fc" id="L95">        List&lt;String&gt; ids = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        for (String id : getZoneIds()) {</span>
<span class="fc" id="L97">            ZoneInfo zi = getZoneInfo(id);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">            if (zi.getRawOffset() == rawOffset) {</span>
<span class="fc" id="L99">                ids.add(id);</span>
            }
        }
        // It appears the &quot;zi&quot; implementation returns the
        // sorted list, though the specification does not
        // specify it. Keep the same behavior for better
        // compatibility.
<span class="fc" id="L106">        String[] list = ids.toArray(new String[ids.size()]);</span>
<span class="fc" id="L107">        Arrays.sort(list);</span>
<span class="fc" id="L108">        return list;</span>
    }

    public static ZoneInfo getZoneInfo(String zoneId) {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (zoneId == null) {</span>
<span class="nc" id="L113">            return null;</span>
        }
<span class="fc" id="L115">        ZoneInfo zi = getZoneInfo0(zoneId);</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (zi != null) {</span>
<span class="fc" id="L117">            zi = (ZoneInfo)zi.clone();</span>
<span class="fc" id="L118">            zi.setID(zoneId);</span>
        }
<span class="fc" id="L120">        return zi;</span>
    }

    private static ZoneInfo getZoneInfo0(String zoneId) {
        try {
<span class="fc" id="L125">            ZoneInfo zi = zones.get(zoneId);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            if (zi != null) {</span>
<span class="fc" id="L127">                return zi;</span>
            }
<span class="fc" id="L129">            String zid = zoneId;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (aliases.containsKey(zoneId)) {</span>
<span class="fc" id="L131">                zid = aliases.get(zoneId);</span>
            }
<span class="fc" id="L133">            int index = Arrays.binarySearch(regions, zid);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">            if (index &lt; 0) {</span>
<span class="fc" id="L135">                return null;</span>
            }
<span class="fc" id="L137">            byte[] bytes = ruleArray[indices[index]];</span>
<span class="fc" id="L138">            DataInputStream dis = new DataInputStream(new ByteArrayInputStream(bytes));</span>
<span class="fc" id="L139">            zi = getZoneInfo(dis, zid);</span>
<span class="fc" id="L140">            zones.put(zoneId, zi);</span>
<span class="fc" id="L141">            return zi;</span>
<span class="nc" id="L142">        } catch (Exception ex) {</span>
<span class="nc" id="L143">            throw new RuntimeException(&quot;Invalid binary time-zone data: TZDB:&quot; +</span>
                zoneId + &quot;, version: &quot; + versionId, ex);
        }
    }

    /**
     * Returns a Map from alias time zone IDs to their standard
     * time zone IDs.
     *
     * @return an unmodified alias mapping
     */
    public static Map&lt;String, String&gt; getAliasMap() {
<span class="fc" id="L155">        return Collections.unmodifiableMap(aliases);</span>
    }

    /**
     * Gets the version of this tz data.
     *
     * @return the tzdb version
     */
    public static String getVersion() {
<span class="nc" id="L164">        return versionId;</span>
    }

    /**
     * Gets a ZoneInfo with the given GMT offset. The object
     * has its ID in the format of GMT{+|-}hh:mm.
     *
     * @param originalId  the given custom id (before normalized such as &quot;GMT+9&quot;)
     * @param gmtOffset   GMT offset &lt;em&gt;in milliseconds&lt;/em&gt;
     * @return a ZoneInfo constructed with the given GMT offset
     */
    public static ZoneInfo getCustomTimeZone(String originalId, int gmtOffset) {
<span class="fc" id="L176">        String id = toCustomID(gmtOffset);</span>
<span class="fc" id="L177">        return new ZoneInfo(id, gmtOffset);</span>
    }

    public static String toCustomID(int gmtOffset) {
        char sign;
<span class="fc" id="L182">        int offset = gmtOffset / 60000;</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (offset &gt;= 0) {</span>
<span class="fc" id="L184">            sign = '+';</span>
        } else {
<span class="fc" id="L186">            sign = '-';</span>
<span class="fc" id="L187">            offset = -offset;</span>
        }
<span class="fc" id="L189">        int hh = offset / 60;</span>
<span class="fc" id="L190">        int mm = offset % 60;</span>

<span class="fc" id="L192">        char[] buf = new char[] { 'G', 'M', 'T', sign, '0', '0', ':', '0', '0' };</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (hh &gt;= 10) {</span>
<span class="fc" id="L194">            buf[4] += hh / 10;</span>
        }
<span class="fc" id="L196">        buf[5] += hh % 10;</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (mm != 0) {</span>
<span class="nc" id="L198">            buf[7] += mm / 10;</span>
<span class="nc" id="L199">            buf[8] += mm % 10;</span>
        }
<span class="fc" id="L201">        return new String(buf);</span>
    }

    ///////////////////////////////////////////////////////////
<span class="nc" id="L205">    private ZoneInfoFile() {</span>
<span class="nc" id="L206">    }</span>

    private static String versionId;
<span class="fc" id="L209">    private final static Map&lt;String, ZoneInfo&gt; zones = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L210">    private static Map&lt;String, String&gt; aliases = new HashMap&lt;&gt;();</span>

    private static byte[][] ruleArray;
    private static String[] regions;
    private static int[] indices;

    // Flag for supporting JDK backward compatible IDs, such as &quot;EST&quot;.
    private static final boolean USE_OLDMAPPING;

<span class="fc" id="L219">    private static String[][] oldMappings = new String[][] {</span>
        { &quot;ACT&quot;, &quot;Australia/Darwin&quot; },
        { &quot;AET&quot;, &quot;Australia/Sydney&quot; },
        { &quot;AGT&quot;, &quot;America/Argentina/Buenos_Aires&quot; },
        { &quot;ART&quot;, &quot;Africa/Cairo&quot; },
        { &quot;AST&quot;, &quot;America/Anchorage&quot; },
        { &quot;BET&quot;, &quot;America/Sao_Paulo&quot; },
        { &quot;BST&quot;, &quot;Asia/Dhaka&quot; },
        { &quot;CAT&quot;, &quot;Africa/Harare&quot; },
        { &quot;CNT&quot;, &quot;America/St_Johns&quot; },
        { &quot;CST&quot;, &quot;America/Chicago&quot; },
        { &quot;CTT&quot;, &quot;Asia/Shanghai&quot; },
        { &quot;EAT&quot;, &quot;Africa/Addis_Ababa&quot; },
        { &quot;ECT&quot;, &quot;Europe/Paris&quot; },
        { &quot;IET&quot;, &quot;America/Indiana/Indianapolis&quot; },
        { &quot;IST&quot;, &quot;Asia/Kolkata&quot; },
        { &quot;JST&quot;, &quot;Asia/Tokyo&quot; },
        { &quot;MIT&quot;, &quot;Pacific/Apia&quot; },
        { &quot;NET&quot;, &quot;Asia/Yerevan&quot; },
        { &quot;NST&quot;, &quot;Pacific/Auckland&quot; },
        { &quot;PLT&quot;, &quot;Asia/Karachi&quot; },
        { &quot;PNT&quot;, &quot;America/Phoenix&quot; },
        { &quot;PRT&quot;, &quot;America/Puerto_Rico&quot; },
        { &quot;PST&quot;, &quot;America/Los_Angeles&quot; },
        { &quot;SST&quot;, &quot;Pacific/Guadalcanal&quot; },
        { &quot;VST&quot;, &quot;Asia/Ho_Chi_Minh&quot; },
    };

    static {
<span class="fc" id="L248">        String oldmapping = AccessController.doPrivileged(</span>
<span class="fc" id="L249">            new GetPropertyAction(&quot;sun.timezone.ids.oldmapping&quot;, &quot;false&quot;)).toLowerCase(Locale.ROOT);</span>
<span class="fc bfc" id="L250" title="All 4 branches covered.">        USE_OLDMAPPING = (oldmapping.equals(&quot;yes&quot;) || oldmapping.equals(&quot;true&quot;));</span>
<span class="fc" id="L251">        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {</span>
            public Object run() {
                try {
<span class="fc" id="L254">                    String libDir = System.getProperty(&quot;java.home&quot;) + File.separator + &quot;lib&quot;;</span>
<span class="pc" id="L255">                    try (DataInputStream dis = new DataInputStream(</span>
                             new BufferedInputStream(new FileInputStream(
                                 new File(libDir, &quot;tzdb.dat&quot;))))) {
<span class="fc" id="L258">                        load(dis);</span>
<span class="pc bpc" id="L259" title="6 of 8 branches missed.">                    }</span>
<span class="nc" id="L260">                } catch (Exception x) {</span>
<span class="nc" id="L261">                    throw new Error(x);</span>
<span class="fc" id="L262">                }</span>
<span class="fc" id="L263">                return null;</span>
            }
        });
    }

    private static void addOldMapping() {
<span class="fc bfc" id="L269" title="All 2 branches covered.">        for (String[] alias : oldMappings) {</span>
<span class="fc" id="L270">            aliases.put(alias[0], alias[1]);</span>
        }
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (USE_OLDMAPPING) {</span>
<span class="fc" id="L273">            aliases.put(&quot;EST&quot;, &quot;America/New_York&quot;);</span>
<span class="fc" id="L274">            aliases.put(&quot;MST&quot;, &quot;America/Denver&quot;);</span>
<span class="fc" id="L275">            aliases.put(&quot;HST&quot;, &quot;Pacific/Honolulu&quot;);</span>
        } else {
<span class="fc" id="L277">            zones.put(&quot;EST&quot;, new ZoneInfo(&quot;EST&quot;, -18000000));</span>
<span class="fc" id="L278">            zones.put(&quot;MST&quot;, new ZoneInfo(&quot;MST&quot;, -25200000));</span>
<span class="fc" id="L279">            zones.put(&quot;HST&quot;, new ZoneInfo(&quot;HST&quot;, -36000000));</span>
        }
<span class="fc" id="L281">    }</span>

    public static boolean useOldMapping() {
<span class="nc" id="L284">       return USE_OLDMAPPING;</span>
    }

    /**
     * Loads the rules from a DateInputStream
     *
     * @param dis  the DateInputStream to load, not null
     * @throws Exception if an error occurs
     */
    private static void load(DataInputStream dis) throws ClassNotFoundException, IOException {
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (dis.readByte() != 1) {</span>
<span class="nc" id="L295">            throw new StreamCorruptedException(&quot;File format not recognised&quot;);</span>
        }
        // group
<span class="fc" id="L298">        String groupId = dis.readUTF();</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (&quot;TZDB&quot;.equals(groupId) == false) {</span>
<span class="nc" id="L300">            throw new StreamCorruptedException(&quot;File format not recognised&quot;);</span>
        }
        // versions, only keep the last one
<span class="fc" id="L303">        int versionCount = dis.readShort();</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">        for (int i = 0; i &lt; versionCount; i++) {</span>
<span class="fc" id="L305">            versionId = dis.readUTF();</span>

        }
        // regions
<span class="fc" id="L309">        int regionCount = dis.readShort();</span>
<span class="fc" id="L310">        String[] regionArray = new String[regionCount];</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        for (int i = 0; i &lt; regionCount; i++) {</span>
<span class="fc" id="L312">            regionArray[i] = dis.readUTF();</span>
        }
        // rules
<span class="fc" id="L315">        int ruleCount = dis.readShort();</span>
<span class="fc" id="L316">        ruleArray = new byte[ruleCount][];</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        for (int i = 0; i &lt; ruleCount; i++) {</span>
<span class="fc" id="L318">            byte[] bytes = new byte[dis.readShort()];</span>
<span class="fc" id="L319">            dis.readFully(bytes);</span>
<span class="fc" id="L320">            ruleArray[i] = bytes;</span>
        }
        // link version-region-rules, only keep the last version, if more than one
<span class="fc bfc" id="L323" title="All 2 branches covered.">        for (int i = 0; i &lt; versionCount; i++) {</span>
<span class="fc" id="L324">            regionCount = dis.readShort();</span>
<span class="fc" id="L325">            regions = new String[regionCount];</span>
<span class="fc" id="L326">            indices = new int[regionCount];</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">            for (int j = 0; j &lt; regionCount; j++) {</span>
<span class="fc" id="L328">                regions[j] = regionArray[dis.readShort()];</span>
<span class="fc" id="L329">                indices[j] = dis.readShort();</span>
            }
        }
        // remove the following ids from the map, they
        // are exclued from the &quot;old&quot; ZoneInfo
<span class="fc" id="L334">        zones.remove(&quot;ROC&quot;);</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">        for (int i = 0; i &lt; versionCount; i++) {</span>
<span class="fc" id="L336">            int aliasCount = dis.readShort();</span>
<span class="fc" id="L337">            aliases.clear();</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">            for (int j = 0; j &lt; aliasCount; j++) {</span>
<span class="fc" id="L339">                String alias = regionArray[dis.readShort()];</span>
<span class="fc" id="L340">                String region = regionArray[dis.readShort()];</span>
<span class="fc" id="L341">                aliases.put(alias, region);</span>
            }
        }
        // old us time-zone names
<span class="fc" id="L345">        addOldMapping();</span>
<span class="fc" id="L346">    }</span>

    /////////////////////////Ser/////////////////////////////////
    public static ZoneInfo getZoneInfo(DataInput in, String zoneId) throws Exception {
<span class="fc" id="L350">        byte type = in.readByte();</span>
        // TBD: assert ZRULES:
<span class="fc" id="L352">        int stdSize = in.readInt();</span>
<span class="fc" id="L353">        long[] stdTrans = new long[stdSize];</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        for (int i = 0; i &lt; stdSize; i++) {</span>
<span class="fc" id="L355">            stdTrans[i] = readEpochSec(in);</span>
        }
<span class="fc" id="L357">        int [] stdOffsets = new int[stdSize + 1];</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">        for (int i = 0; i &lt; stdOffsets.length; i++) {</span>
<span class="fc" id="L359">            stdOffsets[i] = readOffset(in);</span>
        }
<span class="fc" id="L361">        int savSize = in.readInt();</span>
<span class="fc" id="L362">        long[] savTrans = new long[savSize];</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        for (int i = 0; i &lt; savSize; i++) {</span>
<span class="fc" id="L364">            savTrans[i] = readEpochSec(in);</span>
        }
<span class="fc" id="L366">        int[] savOffsets = new int[savSize + 1];</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        for (int i = 0; i &lt; savOffsets.length; i++) {</span>
<span class="fc" id="L368">            savOffsets[i] = readOffset(in);</span>
        }
<span class="fc" id="L370">        int ruleSize = in.readByte();</span>
<span class="fc" id="L371">        ZoneOffsetTransitionRule[] rules = new ZoneOffsetTransitionRule[ruleSize];</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        for (int i = 0; i &lt; ruleSize; i++) {</span>
<span class="fc" id="L373">            rules[i] = new ZoneOffsetTransitionRule(in);</span>
        }
<span class="fc" id="L375">        return getZoneInfo(zoneId, stdTrans, stdOffsets, savTrans, savOffsets, rules);</span>
    }

    public static int readOffset(DataInput in) throws IOException {
<span class="fc" id="L379">        int offsetByte = in.readByte();</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        return offsetByte == 127 ? in.readInt() : offsetByte * 900;</span>
    }

    static long readEpochSec(DataInput in) throws IOException {
<span class="fc" id="L384">        int hiByte = in.readByte() &amp; 255;</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (hiByte == 255) {</span>
<span class="fc" id="L386">            return in.readLong();</span>
        } else {
<span class="fc" id="L388">            int midByte = in.readByte() &amp; 255;</span>
<span class="fc" id="L389">            int loByte = in.readByte() &amp; 255;</span>
<span class="fc" id="L390">            long tot = ((hiByte &lt;&lt; 16) + (midByte &lt;&lt; 8) + loByte);</span>
<span class="fc" id="L391">            return (tot * 900) - 4575744000L;</span>
        }
    }

    /////////////////////////ZoneRules --&gt; ZoneInfo/////////////////////////////////

    // ZoneInfo starts with UTC1900
    private static final long UTC1900 = -2208988800L;

    // ZoneInfo ends with   UTC2037
    // LocalDateTime.of(2038, 1, 1, 0, 0, 0).toEpochSecond(ZoneOffset.UTC) - 1;
    private static final long UTC2037 = 2145916799L;

    // ZoneInfo has an ending entry for 2037, this need to be offset by
    // a &quot;rawOffset&quot;
    // LocalDateTime.of(2037, 1, 1, 0, 0, 0).toEpochSecond(ZoneOffset.UTC));
    private static final long LDT2037 = 2114380800L;

    /* Get a ZoneInfo instance.
     *
     * @param standardTransitions  the standard transitions, not null
     * @param standardOffsets  the standard offsets, not null
     * @param savingsInstantTransitions  the standard transitions, not null
     * @param wallOffsets  the wall offsets, not null
     * @param lastRules  the recurring last rules, size 15 or less, not null
     */
    private static ZoneInfo getZoneInfo(String zoneId,
                                        long[] standardTransitions,
                                        int[] standardOffsets,
                                        long[] savingsInstantTransitions,
                                        int[] wallOffsets,
                                        ZoneOffsetTransitionRule[] lastRules) {
<span class="fc" id="L423">        int rawOffset = 0;</span>
<span class="fc" id="L424">        int dstSavings = 0;</span>
<span class="fc" id="L425">        int checksum = 0;</span>
<span class="fc" id="L426">        int[] params = null;</span>
<span class="fc" id="L427">        boolean willGMTOffsetChange = false;</span>

        // rawOffset, pick the last one
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (standardTransitions.length &gt; 0)</span>
<span class="fc" id="L431">            rawOffset = standardOffsets[standardOffsets.length - 1] * 1000;</span>
        else
<span class="fc" id="L433">            rawOffset = standardOffsets[0] * 1000;</span>

        // transitions, offsets;
<span class="fc" id="L436">        long[] transitions = null;</span>
<span class="fc" id="L437">        int[]  offsets = null;</span>
<span class="fc" id="L438">        int    nOffsets = 0;</span>
<span class="fc" id="L439">        int    nTrans = 0;</span>

<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (savingsInstantTransitions.length != 0) {</span>
<span class="fc" id="L442">            transitions = new long[250];</span>
<span class="fc" id="L443">            offsets = new int[100];    // TBD: ZoneInfo actually can't handle</span>
                                       // offsets.length &gt; 16 (4-bit index limit)
            // last year in trans table
            // It should not matter to use before or after offset for year
<span class="fc" id="L447">            int lastyear = getYear(savingsInstantTransitions[savingsInstantTransitions.length - 1],</span>
                                   wallOffsets[savingsInstantTransitions.length - 1]);
<span class="fc" id="L449">            int i = 0, k = 1;</span>
<span class="fc bfc" id="L450" title="All 4 branches covered.">            while (i &lt; savingsInstantTransitions.length &amp;&amp;</span>
                   savingsInstantTransitions[i] &lt; UTC1900) {
<span class="fc" id="L452">                i++;     // skip any date before UTC1900</span>
            }
<span class="fc bfc" id="L454" title="All 2 branches covered.">            if (i &lt; savingsInstantTransitions.length) {</span>
                // javazic writes the last GMT offset into index 0!
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">                if (i &lt; savingsInstantTransitions.length) {</span>
<span class="fc" id="L457">                    offsets[0] = standardOffsets[standardOffsets.length - 1] * 1000;</span>
<span class="fc" id="L458">                    nOffsets = 1;</span>
                }
                // ZoneInfo has a beginning entry for 1900.
                // Only add it if this is not the only one in table
<span class="fc" id="L462">                nOffsets = addTrans(transitions, nTrans++,</span>
                                    offsets, nOffsets,
                                    UTC1900,
                                    wallOffsets[i],
<span class="fc" id="L466">                                    getStandardOffset(standardTransitions, standardOffsets, UTC1900));</span>
            }

<span class="fc bfc" id="L469" title="All 2 branches covered.">            for (; i &lt; savingsInstantTransitions.length; i++) {</span>
<span class="fc" id="L470">                long trans = savingsInstantTransitions[i];</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">                if (trans &gt; UTC2037) {</span>
                    // no trans beyond LASTYEAR
<span class="fc" id="L473">                    lastyear = LASTYEAR;</span>
<span class="fc" id="L474">                    break;</span>
                }
<span class="fc bfc" id="L476" title="All 2 branches covered.">                while (k &lt; standardTransitions.length) {</span>
                    // some standard offset transitions don't exist in
                    // savingInstantTrans, if the offset &quot;change&quot; doesn't
                    // really change the &quot;effectiveWallOffset&quot;. For example
                    // the 1999/2000 pair in Zone Arg/Buenos_Aires, in which
                    // the daylightsaving &quot;happened&quot; but it actually does
                    // not result in the timezone switch. ZoneInfo however
                    // needs them in its transitions table
<span class="fc" id="L484">                    long trans_s = standardTransitions[k];</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">                    if (trans_s &gt;= UTC1900) {</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">                        if (trans_s &gt; trans)</span>
<span class="fc" id="L487">                            break;</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">                        if (trans_s &lt; trans) {</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">                            if (nOffsets + 2 &gt;= offsets.length) {</span>
<span class="nc" id="L490">                                offsets = Arrays.copyOf(offsets, offsets.length + 100);</span>
                            }
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">                            if (nTrans + 1 &gt;= transitions.length) {</span>
<span class="nc" id="L493">                                transitions = Arrays.copyOf(transitions, transitions.length + 100);</span>
                            }
<span class="fc" id="L495">                            nOffsets = addTrans(transitions, nTrans++, offsets, nOffsets,</span>
                                                trans_s,
                                                wallOffsets[i],
                                                standardOffsets[k+1]);

                        }
                    }
<span class="fc" id="L502">                    k++;</span>
<span class="fc" id="L503">                }</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">                if (nOffsets + 2 &gt;= offsets.length) {</span>
<span class="nc" id="L505">                    offsets = Arrays.copyOf(offsets, offsets.length + 100);</span>
                }
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">                if (nTrans + 1 &gt;= transitions.length) {</span>
<span class="nc" id="L508">                    transitions = Arrays.copyOf(transitions, transitions.length + 100);</span>
                }
<span class="fc" id="L510">                nOffsets = addTrans(transitions, nTrans++, offsets, nOffsets,</span>
                                    trans,
                                    wallOffsets[i + 1],
<span class="fc" id="L513">                                    getStandardOffset(standardTransitions, standardOffsets, trans));</span>

            }
            // append any leftover standard trans
<span class="fc bfc" id="L517" title="All 2 branches covered.">            while (k &lt; standardTransitions.length) {</span>
<span class="fc" id="L518">                long trans = standardTransitions[k];</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">                if (trans &gt;= UTC1900) {</span>
<span class="fc" id="L520">                    int offset = wallOffsets[i];</span>
<span class="fc" id="L521">                    int offsetIndex = indexOf(offsets, 0, nOffsets, offset);</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">                    if (offsetIndex == nOffsets)</span>
<span class="nc" id="L523">                        nOffsets++;</span>
<span class="fc" id="L524">                    transitions[nTrans++] = ((trans * 1000) &lt;&lt; TRANSITION_NSHIFT) |</span>
                                            (offsetIndex &amp; OFFSET_MASK);
                }
<span class="fc" id="L527">                k++;</span>
<span class="fc" id="L528">            }</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">            if (lastRules.length &gt; 1) {</span>
                // fill the gap between the last trans until LASTYEAR
<span class="fc bfc" id="L531" title="All 2 branches covered.">                while (lastyear++ &lt; LASTYEAR) {</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">                    for (ZoneOffsetTransitionRule zotr : lastRules) {</span>
<span class="fc" id="L533">                        long trans = zotr.getTransitionEpochSecond(lastyear);</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">                        if (nOffsets + 2 &gt;= offsets.length) {</span>
<span class="nc" id="L535">                            offsets = Arrays.copyOf(offsets, offsets.length + 100);</span>
                        }
<span class="fc bfc" id="L537" title="All 2 branches covered.">                        if (nTrans + 1 &gt;= transitions.length) {</span>
<span class="fc" id="L538">                            transitions = Arrays.copyOf(transitions, transitions.length + 100);</span>
                        }
<span class="fc" id="L540">                        nOffsets = addTrans(transitions, nTrans++,</span>
                                            offsets, nOffsets,
                                            trans,
<span class="fc" id="L543">                                            zotr.offsetAfter,</span>
<span class="fc" id="L544">                                            zotr.standardOffset);</span>
                    }
                }
<span class="fc" id="L547">                ZoneOffsetTransitionRule startRule =  lastRules[lastRules.length - 2];</span>
<span class="fc" id="L548">                ZoneOffsetTransitionRule endRule =  lastRules[lastRules.length - 1];</span>
<span class="fc" id="L549">                params = new int[10];</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">                if (startRule.offsetAfter - startRule.offsetBefore &lt; 0 &amp;&amp;</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                    endRule.offsetAfter - endRule.offsetBefore &gt; 0) {</span>
                    ZoneOffsetTransitionRule tmp;
<span class="fc" id="L553">                    tmp = startRule;</span>
<span class="fc" id="L554">                    startRule = endRule;</span>
<span class="fc" id="L555">                    endRule = tmp;</span>
                }
<span class="fc" id="L557">                params[0] = startRule.month - 1;</span>
<span class="fc" id="L558">                int dom = startRule.dom;</span>
<span class="fc" id="L559">                int dow = startRule.dow;</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">                if (dow == -1) {</span>
<span class="nc" id="L561">                    params[1] = dom;</span>
<span class="nc" id="L562">                    params[2] = 0;</span>
                } else {
                    // ZoneRulesBuilder adjusts &lt; 0 case (-1, for last, don't have
                    // &quot;&lt;=&quot; case yet) to positive value if not February (it appears
                    // we don't have February cutoff in tzdata table yet)
                    // Ideally, if JSR310 can just pass in the nagative and
                    // we can then pass in the dom = -1, dow &gt; 0 into ZoneInfo
                    //
                    // hacking, assume the &gt;=24 is the result of ZRB optimization for
                    // &quot;last&quot;, it works for now.
<span class="pc bpc" id="L572" title="1 of 4 branches missed.">                    if (dom &lt; 0 || dom &gt;= 24) {</span>
<span class="fc" id="L573">                        params[1] = -1;</span>
<span class="fc" id="L574">                        params[2] = toCalendarDOW[dow];</span>
                    } else {
<span class="fc" id="L576">                        params[1] = dom;</span>
                        // To specify a day of week on or after an exact day of month,
                        // set the month to an exact month value, day-of-month to the
                        // day on or after which the rule is applied, and day-of-week
                        // to a negative Calendar.DAY_OF_WEEK DAY_OF_WEEK field value.
<span class="fc" id="L581">                        params[2] = -toCalendarDOW[dow];</span>
                    }
                }
<span class="fc" id="L584">                params[3] = startRule.secondOfDay * 1000;</span>
<span class="fc" id="L585">                params[4] = toSTZTime[startRule.timeDefinition];</span>
<span class="fc" id="L586">                params[5] = endRule.month - 1;</span>
<span class="fc" id="L587">                dom = endRule.dom;</span>
<span class="fc" id="L588">                dow = endRule.dow;</span>
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">                if (dow == -1) {</span>
<span class="nc" id="L590">                    params[6] = dom;</span>
<span class="nc" id="L591">                    params[7] = 0;</span>
                } else {
                    // hacking: see comment above
<span class="pc bpc" id="L594" title="1 of 4 branches missed.">                    if (dom &lt; 0 || dom &gt;= 24) {</span>
<span class="fc" id="L595">                        params[6] = -1;</span>
<span class="fc" id="L596">                        params[7] = toCalendarDOW[dow];</span>
                    } else {
<span class="fc" id="L598">                        params[6] = dom;</span>
<span class="fc" id="L599">                        params[7] = -toCalendarDOW[dow];</span>
                    }
                }
<span class="fc" id="L602">                params[8] = endRule.secondOfDay * 1000;</span>
<span class="fc" id="L603">                params[9] = toSTZTime[endRule.timeDefinition];</span>
<span class="fc" id="L604">                dstSavings = (startRule.offsetAfter - startRule.offsetBefore) * 1000;</span>

                // Note: known mismatching -&gt; Asia/Amman
                //                            Asia/Gaza
                //                            Asia/Hebron
                // ZoneInfo :      startDayOfWeek=5     &lt;= Thursday
                //                 startTime=86400000   &lt;= 24 hours
                // This:           startDayOfWeek=6
                //                 startTime=0
                // Below is the workaround, it probably slows down everyone a little
<span class="fc bfc" id="L614" title="All 4 branches covered.">                if (params[2] == 6 &amp;&amp; params[3] == 0 &amp;&amp;</span>
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">                    (zoneId.equals(&quot;Asia/Amman&quot;) ||</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">                     zoneId.equals(&quot;Asia/Gaza&quot;) ||</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">                     zoneId.equals(&quot;Asia/Hebron&quot;))) {</span>
<span class="fc" id="L618">                    params[2] = 5;</span>
<span class="fc" id="L619">                    params[3] = 86400000;</span>
                }
<span class="fc bfc" id="L621" title="All 2 branches covered.">            } else if (nTrans &gt; 0) {  // only do this if there is something in table already</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">                if (lastyear &lt; LASTYEAR) {</span>
                    // ZoneInfo has an ending entry for 2037
                    //long trans = OffsetDateTime.of(LASTYEAR, 1, 1, 0, 0, 0, 0,
                    //                               ZoneOffset.ofTotalSeconds(rawOffset/1000))
                    //                           .toEpochSecond();
<span class="fc" id="L627">                    long trans = LDT2037 - rawOffset/1000;</span>

<span class="fc" id="L629">                    int offsetIndex = indexOf(offsets, 0, nOffsets, rawOffset/1000);</span>
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">                    if (offsetIndex == nOffsets)</span>
<span class="nc" id="L631">                        nOffsets++;</span>
<span class="fc" id="L632">                    transitions[nTrans++] = (trans * 1000) &lt;&lt; TRANSITION_NSHIFT |</span>
                                       (offsetIndex &amp; OFFSET_MASK);

<span class="pc bpc" id="L635" title="1 of 2 branches missed.">                } else if (savingsInstantTransitions.length &gt; 2) {</span>
                    // Workaround: create the params based on the last pair for
                    // zones like Israel and Iran which have trans defined
                    // up until 2037, but no &quot;transition rule&quot; defined
                    //
                    // Note: Known mismatching for Israel, Asia/Jerusalem/Tel Aviv
                    // ZoneInfo:        startMode=3
                    //                  startMonth=2
                    //                  startDay=26
                    //                  startDayOfWeek=6
                    //
                    // This:            startMode=1
                    //                  startMonth=2
                    //                  startDay=27
                    //                  startDayOfWeek=0
                    // these two are actually the same for 2037, the SimpleTimeZone
                    // for the last &quot;known&quot; year
<span class="fc" id="L652">                    int m = savingsInstantTransitions.length;</span>
<span class="fc" id="L653">                    long startTrans = savingsInstantTransitions[m - 2];</span>
<span class="fc" id="L654">                    int startOffset = wallOffsets[m - 2 + 1];</span>
<span class="fc" id="L655">                    int startStd = getStandardOffset(standardTransitions, standardOffsets, startTrans);</span>
<span class="fc" id="L656">                    long endTrans =  savingsInstantTransitions[m - 1];</span>
<span class="fc" id="L657">                    int endOffset = wallOffsets[m - 1 + 1];</span>
<span class="fc" id="L658">                    int endStd = getStandardOffset(standardTransitions, standardOffsets, endTrans);</span>
<span class="pc bpc" id="L659" title="2 of 4 branches missed.">                    if (startOffset &gt; startStd &amp;&amp; endOffset == endStd) {</span>
                        // last - 1 trans
<span class="fc" id="L661">                        m = savingsInstantTransitions.length - 2;</span>
<span class="fc" id="L662">                        ZoneOffset before = ZoneOffset.ofTotalSeconds(wallOffsets[m]);</span>
<span class="fc" id="L663">                        ZoneOffset after = ZoneOffset.ofTotalSeconds(wallOffsets[m + 1]);</span>
<span class="fc" id="L664">                        LocalDateTime ldt = LocalDateTime.ofEpochSecond(savingsInstantTransitions[m], 0, before);</span>
                        LocalDateTime startLDT;
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">                        if (after.getTotalSeconds() &gt; before.getTotalSeconds()) {  // isGap()</span>
<span class="fc" id="L667">                            startLDT = ldt;</span>
                        } else {
<span class="nc" id="L669">                            startLDT = ldt.plusSeconds(wallOffsets[m + 1] - wallOffsets[m]);</span>
                        }
                        // last trans
<span class="fc" id="L672">                        m = savingsInstantTransitions.length - 1;</span>
<span class="fc" id="L673">                        before = ZoneOffset.ofTotalSeconds(wallOffsets[m]);</span>
<span class="fc" id="L674">                        after = ZoneOffset.ofTotalSeconds(wallOffsets[m + 1]);</span>
<span class="fc" id="L675">                        ldt = LocalDateTime.ofEpochSecond(savingsInstantTransitions[m], 0, before);</span>
                        LocalDateTime endLDT;
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">                        if (after.getTotalSeconds() &gt; before.getTotalSeconds()) {  // isGap()</span>
<span class="nc" id="L678">                            endLDT = ldt.plusSeconds(wallOffsets[m + 1] - wallOffsets[m]);</span>
                        } else {
<span class="fc" id="L680">                            endLDT = ldt;</span>
                        }
<span class="fc" id="L682">                        params = new int[10];</span>
<span class="fc" id="L683">                        params[0] = startLDT.getMonthValue() - 1;</span>
<span class="fc" id="L684">                        params[1] = startLDT.getDayOfMonth();</span>
<span class="fc" id="L685">                        params[2] = 0;</span>
<span class="fc" id="L686">                        params[3] = startLDT.toLocalTime().toSecondOfDay() * 1000;</span>
<span class="fc" id="L687">                        params[4] = SimpleTimeZone.WALL_TIME;</span>
<span class="fc" id="L688">                        params[5] = endLDT.getMonthValue() - 1;</span>
<span class="fc" id="L689">                        params[6] = endLDT.getDayOfMonth();</span>
<span class="fc" id="L690">                        params[7] = 0;</span>
<span class="fc" id="L691">                        params[8] = endLDT.toLocalTime().toSecondOfDay() * 1000;</span>
<span class="fc" id="L692">                        params[9] = SimpleTimeZone.WALL_TIME;</span>
<span class="fc" id="L693">                        dstSavings = (startOffset - startStd) * 1000;</span>
                    }
                }
            }
<span class="pc bpc" id="L697" title="2 of 4 branches missed.">            if (transitions != null &amp;&amp; transitions.length != nTrans) {</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">                if (nTrans == 0) {</span>
<span class="fc" id="L699">                    transitions = null;</span>
                } else {
<span class="fc" id="L701">                    transitions = Arrays.copyOf(transitions, nTrans);</span>
                }
            }
<span class="pc bpc" id="L704" title="2 of 4 branches missed.">            if (offsets != null &amp;&amp; offsets.length != nOffsets) {</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">                if (nOffsets == 0) {</span>
<span class="fc" id="L706">                    offsets = null;</span>
                } else {
<span class="fc" id="L708">                    offsets = Arrays.copyOf(offsets, nOffsets);</span>
                }
            }
<span class="fc bfc" id="L711" title="All 2 branches covered.">            if (transitions != null) {</span>
<span class="fc" id="L712">                Checksum sum = new Checksum();</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">                for (i = 0; i &lt; transitions.length; i++) {</span>
<span class="fc" id="L714">                    long val = transitions[i];</span>
<span class="fc" id="L715">                    int dst = (int)((val &gt;&gt;&gt; DST_NSHIFT) &amp; 0xfL);</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">                    int saving = (dst == 0) ? 0 : offsets[dst];</span>
<span class="fc" id="L717">                    int index = (int)(val &amp; OFFSET_MASK);</span>
<span class="fc" id="L718">                    int offset = offsets[index];</span>
<span class="fc" id="L719">                    long second = (val &gt;&gt; TRANSITION_NSHIFT);</span>
                    // javazic uses &quot;index of the offset in offsets&quot;,
                    // instead of the real offset value itself to
                    // calculate the checksum. Have to keep doing
                    // the same thing, checksum is part of the
                    // ZoneInfo serialization form.
<span class="fc" id="L725">                    sum.update(second + index);</span>
<span class="fc" id="L726">                    sum.update(index);</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">                    sum.update(dst == 0 ? -1 : dst);</span>
                }
<span class="fc" id="L729">                checksum = (int)sum.getValue();</span>
            }
        }
<span class="fc" id="L732">        return new ZoneInfo(zoneId, rawOffset, dstSavings, checksum, transitions,</span>
                            offsets, params, willGMTOffsetChange);
    }

    private static int getStandardOffset(long[] standardTransitions,
                                         int[] standardOffsets,
                                         long epochSec) {
        // The size of stdOffsets is [0..9], with most are
        // [1..4] entries , simple loop search is faster
        //
        // int index  = Arrays.binarySearch(standardTransitions, epochSec);
        // if (index &lt; 0) {
        //    // switch negative insert position to start of matched range
        //    index = -index - 2;
        // }
        // return standardOffsets[index + 1];
<span class="fc" id="L748">        int index = 0;</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">        for (; index &lt; standardTransitions.length; index++) {</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">            if (epochSec &lt; standardTransitions[index]) {</span>
<span class="fc" id="L751">                break;</span>
            }
        }
<span class="fc" id="L754">        return standardOffsets[index];</span>
    }

    static final int SECONDS_PER_DAY = 86400;
    static final int DAYS_PER_CYCLE = 146097;
    static final long DAYS_0000_TO_1970 = (DAYS_PER_CYCLE * 5L) - (30L * 365L + 7L);

    private static int getYear(long epochSecond, int offset) {
<span class="fc" id="L762">        long second = epochSecond + offset;  // overflow caught later</span>
<span class="fc" id="L763">        long epochDay = Math.floorDiv(second, SECONDS_PER_DAY);</span>
<span class="fc" id="L764">        long zeroDay = epochDay + DAYS_0000_TO_1970;</span>
        // find the march-based year
<span class="fc" id="L766">        zeroDay -= 60;  // adjust to 0000-03-01 so leap day is at end of four year cycle</span>
<span class="fc" id="L767">        long adjust = 0;</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">        if (zeroDay &lt; 0) {</span>
            // adjust negative years to positive for calculation
<span class="nc" id="L770">            long adjustCycles = (zeroDay + 1) / DAYS_PER_CYCLE - 1;</span>
<span class="nc" id="L771">            adjust = adjustCycles * 400;</span>
<span class="nc" id="L772">            zeroDay += -adjustCycles * DAYS_PER_CYCLE;</span>
        }
<span class="fc" id="L774">        long yearEst = (400 * zeroDay + 591) / DAYS_PER_CYCLE;</span>
<span class="fc" id="L775">        long doyEst = zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);</span>
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">        if (doyEst &lt; 0) {</span>
            // fix estimate
<span class="nc" id="L778">            yearEst--;</span>
<span class="nc" id="L779">            doyEst = zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);</span>
        }
<span class="fc" id="L781">        yearEst += adjust;  // reset any negative year</span>
<span class="fc" id="L782">        int marchDoy0 = (int) doyEst;</span>
        // convert march-based values back to january-based
<span class="fc" id="L784">        int marchMonth0 = (marchDoy0 * 5 + 2) / 153;</span>
<span class="fc" id="L785">        int month = (marchMonth0 + 2) % 12 + 1;</span>
<span class="fc" id="L786">        int dom = marchDoy0 - (marchMonth0 * 306 + 5) / 10 + 1;</span>
<span class="fc" id="L787">        yearEst += marchMonth0 / 10;</span>
<span class="fc" id="L788">        return (int)yearEst;</span>
    }

<span class="fc" id="L791">    private static final int toCalendarDOW[] = new int[] {</span>
        -1,
        Calendar.MONDAY,
        Calendar.TUESDAY,
        Calendar.WEDNESDAY,
        Calendar.THURSDAY,
        Calendar.FRIDAY,
        Calendar.SATURDAY,
        Calendar.SUNDAY
    };

<span class="fc" id="L802">    private static final int toSTZTime[] = new int[] {</span>
        SimpleTimeZone.UTC_TIME,
        SimpleTimeZone.WALL_TIME,
        SimpleTimeZone.STANDARD_TIME,
    };

    private static final long OFFSET_MASK = 0x0fL;
    private static final long DST_MASK = 0xf0L;
    private static final int  DST_NSHIFT = 4;
    private static final int  TRANSITION_NSHIFT = 12;
    private static final int  LASTYEAR = 2037;

    // from: 0 for offset lookup, 1 for dstsvings lookup
    private static int indexOf(int[] offsets, int from, int nOffsets, int offset) {
<span class="fc" id="L816">        offset *= 1000;</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">        for (; from &lt; nOffsets; from++) {</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">            if (offsets[from] == offset)</span>
<span class="fc" id="L819">                return from;</span>
        }
<span class="fc" id="L821">        offsets[from] = offset;</span>
<span class="fc" id="L822">        return from;</span>
    }

    // return updated nOffsets
    private static int addTrans(long transitions[], int nTrans,
                                int offsets[], int nOffsets,
                                long trans, int offset, int stdOffset) {
<span class="fc" id="L829">        int offsetIndex = indexOf(offsets, 0, nOffsets, offset);</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">        if (offsetIndex == nOffsets)</span>
<span class="fc" id="L831">            nOffsets++;</span>
<span class="fc" id="L832">        int dstIndex = 0;</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">        if (offset != stdOffset) {</span>
<span class="fc" id="L834">            dstIndex = indexOf(offsets, 1, nOffsets, offset - stdOffset);</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">            if (dstIndex == nOffsets)</span>
<span class="fc" id="L836">                nOffsets++;</span>
        }
<span class="fc" id="L838">        transitions[nTrans] = ((trans * 1000) &lt;&lt; TRANSITION_NSHIFT) |</span>
                              ((dstIndex &lt;&lt; DST_NSHIFT) &amp; DST_MASK) |
                              (offsetIndex &amp; OFFSET_MASK);
<span class="fc" id="L841">        return nOffsets;</span>
    }

    // ZoneInfo checksum, copy/pasted from javazic
<span class="fc" id="L845">    private static class Checksum extends CRC32 {</span>
        public void update(int val) {
<span class="fc" id="L847">            byte[] b = new byte[4];</span>
<span class="fc" id="L848">            b[0] = (byte)(val &gt;&gt;&gt; 24);</span>
<span class="fc" id="L849">            b[1] = (byte)(val &gt;&gt;&gt; 16);</span>
<span class="fc" id="L850">            b[2] = (byte)(val &gt;&gt;&gt; 8);</span>
<span class="fc" id="L851">            b[3] = (byte)(val);</span>
<span class="fc" id="L852">            update(b);</span>
<span class="fc" id="L853">        }</span>
        void update(long val) {
<span class="fc" id="L855">            byte[] b = new byte[8];</span>
<span class="fc" id="L856">            b[0] = (byte)(val &gt;&gt;&gt; 56);</span>
<span class="fc" id="L857">            b[1] = (byte)(val &gt;&gt;&gt; 48);</span>
<span class="fc" id="L858">            b[2] = (byte)(val &gt;&gt;&gt; 40);</span>
<span class="fc" id="L859">            b[3] = (byte)(val &gt;&gt;&gt; 32);</span>
<span class="fc" id="L860">            b[4] = (byte)(val &gt;&gt;&gt; 24);</span>
<span class="fc" id="L861">            b[5] = (byte)(val &gt;&gt;&gt; 16);</span>
<span class="fc" id="L862">            b[6] = (byte)(val &gt;&gt;&gt; 8);</span>
<span class="fc" id="L863">            b[7] = (byte)(val);</span>
<span class="fc" id="L864">            update(b);</span>
<span class="fc" id="L865">        }</span>
    }

    // A simple/raw version of j.t.ZoneOffsetTransitionRule
    private static class ZoneOffsetTransitionRule {
        private final int month;
        private final byte dom;
        private final int dow;
        private final int secondOfDay;
        private final boolean timeEndOfDay;
        private final int timeDefinition;
        private final int standardOffset;
        private final int offsetBefore;
        private final int offsetAfter;

<span class="fc" id="L880">        ZoneOffsetTransitionRule(DataInput in) throws IOException {</span>
<span class="fc" id="L881">            int data = in.readInt();</span>
<span class="fc" id="L882">            int dowByte = (data &amp; (7 &lt;&lt; 19)) &gt;&gt;&gt; 19;</span>
<span class="fc" id="L883">            int timeByte = (data &amp; (31 &lt;&lt; 14)) &gt;&gt;&gt; 14;</span>
<span class="fc" id="L884">            int stdByte = (data &amp; (255 &lt;&lt; 4)) &gt;&gt;&gt; 4;</span>
<span class="fc" id="L885">            int beforeByte = (data &amp; (3 &lt;&lt; 2)) &gt;&gt;&gt; 2;</span>
<span class="fc" id="L886">            int afterByte = (data &amp; 3);</span>

<span class="fc" id="L888">            this.month = data &gt;&gt;&gt; 28;</span>
<span class="fc" id="L889">            this.dom = (byte)(((data &amp; (63 &lt;&lt; 22)) &gt;&gt;&gt; 22) - 32);</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">            this.dow = dowByte == 0 ? -1 : dowByte;</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">            this.secondOfDay = timeByte == 31 ? in.readInt() : timeByte * 3600;</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">            this.timeEndOfDay = timeByte == 24;</span>
<span class="fc" id="L893">            this.timeDefinition = (data &amp; (3 &lt;&lt; 12)) &gt;&gt;&gt; 12;</span>

<span class="pc bpc" id="L895" title="1 of 2 branches missed.">            this.standardOffset = stdByte == 255 ? in.readInt() : (stdByte - 128) * 900;</span>
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">            this.offsetBefore = beforeByte == 3 ? in.readInt() : standardOffset + beforeByte * 1800;</span>
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">            this.offsetAfter = afterByte == 3 ? in.readInt() : standardOffset + afterByte * 1800;</span>
<span class="fc" id="L898">        }</span>

        long getTransitionEpochSecond(int year) {
<span class="fc" id="L901">            long epochDay = 0;</span>
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">            if (dom &lt; 0) {</span>
<span class="nc" id="L903">                epochDay = toEpochDay(year, month, lengthOfMonth(year, month) + 1 + dom);</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                if (dow != -1) {</span>
<span class="nc" id="L905">                    epochDay = previousOrSame(epochDay, dow);</span>
                }
            } else {
<span class="fc" id="L908">                epochDay = toEpochDay(year, month, dom);</span>
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">                if (dow != -1) {</span>
<span class="fc" id="L910">                    epochDay = nextOrSame(epochDay, dow);</span>
                }
            }
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">            if (timeEndOfDay) {</span>
<span class="nc" id="L914">                epochDay += 1;</span>
            }
<span class="fc" id="L916">            int difference = 0;</span>
<span class="pc bpc" id="L917" title="1 of 4 branches missed.">            switch (timeDefinition) {</span>
                case 0:    // UTC
<span class="fc" id="L919">                    difference = 0;</span>
<span class="fc" id="L920">                    break;</span>
                case 1:    // WALL
<span class="fc" id="L922">                    difference = -offsetBefore;</span>
<span class="fc" id="L923">                    break;</span>
                case 2:    //STANDARD
<span class="fc" id="L925">                    difference = -standardOffset;</span>
                    break;
            }
<span class="fc" id="L928">            return epochDay * 86400 + secondOfDay + difference;</span>
        }

        static final boolean isLeapYear(int year) {
<span class="pc bpc" id="L932" title="1 of 6 branches missed.">            return ((year &amp; 3) == 0) &amp;&amp; ((year % 100) != 0 || (year % 400) == 0);</span>
        }

        static final int lengthOfMonth(int year, int month) {
<span class="nc bnc" id="L936" title="All 3 branches missed.">            switch (month) {</span>
                case 2:        //FEBRUARY:
<span class="nc bnc" id="L938" title="All 2 branches missed.">                    return isLeapYear(year)? 29 : 28;</span>
                case 4:        //APRIL:
                case 6:        //JUNE:
                case 9:        //SEPTEMBER:
                case 11:       //NOVEMBER:
<span class="nc" id="L943">                    return 30;</span>
                default:
<span class="nc" id="L945">                    return 31;</span>
            }
        }

        static final long toEpochDay(int year, int month, int day) {
<span class="fc" id="L950">            long y = year;</span>
<span class="fc" id="L951">            long m = month;</span>
<span class="fc" id="L952">            long total = 0;</span>
<span class="fc" id="L953">            total += 365 * y;</span>
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">            if (y &gt;= 0) {</span>
<span class="fc" id="L955">                total += (y + 3) / 4 - (y + 99) / 100 + (y + 399) / 400;</span>
            } else {
<span class="nc" id="L957">                total -= y / -4 - y / -100 + y / -400;</span>
            }
<span class="fc" id="L959">            total += ((367 * m - 362) / 12);</span>
<span class="fc" id="L960">            total += day - 1;</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">            if (m &gt; 2) {</span>
<span class="fc" id="L962">                total--;</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">                if (!isLeapYear(year)) {</span>
<span class="fc" id="L964">                    total--;</span>
                }
            }
<span class="fc" id="L967">            return total - DAYS_0000_TO_1970;</span>
        }

        static final long previousOrSame(long epochDay, int dayOfWeek) {
<span class="nc" id="L971">            return adjust(epochDay, dayOfWeek, 1);</span>
        }

        static final long nextOrSame(long epochDay, int dayOfWeek) {
<span class="fc" id="L975">           return adjust(epochDay, dayOfWeek, 0);</span>
        }

        static final long adjust(long epochDay, int dow, int relative) {
<span class="fc" id="L979">            int calDow = (int)Math.floorMod(epochDay + 3, 7L) + 1;</span>
<span class="pc bpc" id="L980" title="1 of 4 branches missed.">            if (relative &lt; 2 &amp;&amp; calDow == dow) {</span>
<span class="fc" id="L981">                return epochDay;</span>
            }
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">            if ((relative &amp; 1) == 0) {</span>
<span class="fc" id="L984">                int daysDiff = calDow - dow;</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">                return epochDay + (daysDiff &gt;= 0 ? 7 - daysDiff : -daysDiff);</span>
            } else {
<span class="nc" id="L987">                int daysDiff = dow - calDow;</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">                return epochDay - (daysDiff &gt;= 0 ? 7 - daysDiff : -daysDiff);</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>