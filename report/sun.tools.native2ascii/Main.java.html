<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Main.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.native2ascii</a> &gt; <span class="el_source">Main.java</span></div><h1>Main.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 */

/*
        Currently javac and load() method in java.util.Properties
        supports only Latin1 encoding input.
        But in Asian platforms programmer or message translator
        uses the editor which support othere than latin1 encoding
        to specify their native language string.
        So if programmer or message translator wants to use other than
        Latin1 character in his/her program source or properties file
        they must convert the file to ASCII plus \udddd notation.
        (javac/load() modification is not appropriate due to
         time constraints for JDK1.1)
        This utility is for the purpose of that conversion.

    NAME
        native2ascii - convert native encoding file to ascii file
                       include \udddd Unicode notation

    SYNOPSIS
        native2ascii [options] [inputfile [outputfile]]

    DESCRIPTION
        If outputfile is not described standard output is used as
        output file, and if inputfile is not also described
        stardard input is used as input file.

        Options

        -reverse
           convert ascii with \udddd notation to native encoding

        -encoding encoding_name
           Specify the encoding name which is used by conversion.
           8859_[1 - 9], JIS, EUCJIS, SJIS is currently supported.
           Default encoding is taken from System property &quot;file.encoding&quot;.

*/

package sun.tools.native2ascii;

import java.io.*;
import java.util.*;
import java.text.MessageFormat;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;
import java.nio.file.Files;
import java.io.UnsupportedEncodingException;
import java.nio.charset.UnsupportedCharsetException;
import sun.tools.native2ascii.A2NFilter;
import sun.tools.native2ascii.N2AFilter;

/**
 * Main program of the native2ascii
 */

<span class="nc" id="L84">public class Main {</span>

<span class="nc" id="L86">    String inputFileName = null;</span>
<span class="nc" id="L87">    String outputFileName = null;</span>
<span class="nc" id="L88">    File tempFile = null;</span>
<span class="nc" id="L89">    boolean reverse = false;</span>
<span class="nc" id="L90">    static String encodingString = null;</span>
<span class="nc" id="L91">    static String defaultEncoding = null;</span>
<span class="nc" id="L92">    static CharsetEncoder encoder = null;</span>

    /**
     * Run the converter
     */
    public synchronized boolean convert(String argv[]){
<span class="nc" id="L98">        List&lt;String&gt; v = new ArrayList&lt;&gt;(2);</span>
<span class="nc" id="L99">        File outputFile = null;</span>
<span class="nc" id="L100">        boolean createOutputFile = false;</span>

        // Parse arguments
<span class="nc bnc" id="L103" title="All 2 branches missed.">        for (int i = 0; i &lt; argv.length; i++) {</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">            if (argv[i].equals(&quot;-encoding&quot;)) {</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">                if ((i + 1) &lt; argv.length){</span>
<span class="nc" id="L106">                    encodingString = argv[++i];</span>
                } else {
<span class="nc" id="L108">                    error(getMsg(&quot;err.bad.arg&quot;));</span>
<span class="nc" id="L109">                    usage();</span>
<span class="nc" id="L110">                    return false;</span>
                }
<span class="nc bnc" id="L112" title="All 2 branches missed.">            } else if (argv[i].equals(&quot;-reverse&quot;)){</span>
<span class="nc" id="L113">                reverse = true;</span>
            } else {
<span class="nc bnc" id="L115" title="All 2 branches missed.">                if (v.size() &gt; 1) {</span>
<span class="nc" id="L116">                    usage();</span>
<span class="nc" id="L117">                    return false;</span>
                }
<span class="nc" id="L119">                v.add(argv[i]);</span>
            }
        }
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (encodingString == null)</span>
<span class="nc" id="L123">           defaultEncoding = Charset.defaultCharset().name();</span>

<span class="nc" id="L125">        char[] lineBreak = System.getProperty(&quot;line.separator&quot;).toCharArray();</span>
        try {
<span class="nc" id="L127">            initializeConverter();</span>

<span class="nc bnc" id="L129" title="All 2 branches missed.">            if (v.size() == 1)</span>
<span class="nc" id="L130">                inputFileName = v.get(0);</span>

<span class="nc bnc" id="L132" title="All 2 branches missed.">            if (v.size() == 2) {</span>
<span class="nc" id="L133">                inputFileName = v.get(0);</span>
<span class="nc" id="L134">                outputFileName = v.get(1);</span>
<span class="nc" id="L135">                createOutputFile = true;</span>
            }

<span class="nc bnc" id="L138" title="All 2 branches missed.">            if (createOutputFile) {</span>
<span class="nc" id="L139">                outputFile = new File(outputFileName);</span>
<span class="nc bnc" id="L140" title="All 4 branches missed.">                    if (outputFile.exists() &amp;&amp; !outputFile.canWrite()) {</span>
<span class="nc" id="L141">                        throw new Exception(formatMsg(&quot;err.cannot.write&quot;, outputFileName));</span>
                    }
            }

<span class="nc bnc" id="L145" title="All 2 branches missed.">            if (reverse){</span>
<span class="nc" id="L146">                BufferedReader reader = getA2NInput(inputFileName);</span>
<span class="nc" id="L147">                Writer osw = getA2NOutput(outputFileName);</span>
                String line;

<span class="nc bnc" id="L150" title="All 2 branches missed.">                while ((line = reader.readLine()) != null) {</span>
<span class="nc" id="L151">                    osw.write(line.toCharArray());</span>
<span class="nc" id="L152">                    osw.write(lineBreak);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                    if (outputFileName == null) { // flush stdout</span>
<span class="nc" id="L154">                        osw.flush();</span>
                    }
                }
<span class="nc" id="L157">                reader.close();  // Close the stream.</span>
<span class="nc" id="L158">                osw.close();</span>
<span class="nc" id="L159">            } else {</span>
             //N2A
                String inLine;
<span class="nc" id="L162">                BufferedReader in = getN2AInput(inputFileName);</span>
<span class="nc" id="L163">                BufferedWriter out = getN2AOutput(outputFileName);</span>

<span class="nc bnc" id="L165" title="All 2 branches missed.">                while ((inLine = in.readLine()) != null) {</span>
<span class="nc" id="L166">                    out.write(inLine.toCharArray());</span>
<span class="nc" id="L167">                    out.write(lineBreak);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                    if (outputFileName == null) { // flush stdout</span>
<span class="nc" id="L169">                        out.flush();</span>
                    }
                }
<span class="nc" id="L172">                out.close();</span>
            }
            // Since we are done rename temporary file to desired output file
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (createOutputFile) {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">                if (outputFile.exists()) {</span>
                    // Some win32 platforms can't handle atomic
                    // rename if source and target file paths are
                    // identical. To make things simple we just unconditionally
                    // delete the target file before calling renameTo()
<span class="nc" id="L181">                    outputFile.delete();</span>
                }
<span class="nc" id="L183">                tempFile.renameTo(outputFile);</span>
            }

<span class="nc" id="L186">        } catch(Exception e){</span>
<span class="nc" id="L187">            error(e.toString());</span>
<span class="nc" id="L188">            return false;</span>
<span class="nc" id="L189">        }</span>

<span class="nc" id="L191">        return true;</span>
    }

    private void error(String msg){
<span class="nc" id="L195">        System.out.println(msg);</span>
<span class="nc" id="L196">    }</span>

    private void usage(){
<span class="nc" id="L199">        System.out.println(getMsg(&quot;usage&quot;));</span>
<span class="nc" id="L200">    }</span>


    private BufferedReader getN2AInput(String inFile) throws Exception {

        InputStream forwardIn;
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (inFile == null)</span>
<span class="nc" id="L207">            forwardIn = System.in;</span>
        else {
<span class="nc" id="L209">            File f = new File(inFile);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (!f.canRead()){</span>
<span class="nc" id="L211">                throw new Exception(formatMsg(&quot;err.cannot.read&quot;, f.getName()));</span>
            }

            try {
<span class="nc" id="L215">                 forwardIn = new FileInputStream(inFile);</span>
<span class="nc" id="L216">            } catch (IOException e) {</span>
<span class="nc" id="L217">               throw new Exception(formatMsg(&quot;err.cannot.read&quot;, f.getName()));</span>
<span class="nc" id="L218">            }</span>
        }

<span class="nc bnc" id="L221" title="All 2 branches missed.">        BufferedReader r = (encodingString != null) ?</span>
            new BufferedReader(new InputStreamReader(forwardIn,
                                                     encodingString)) :
            new BufferedReader(new InputStreamReader(forwardIn));
<span class="nc" id="L225">        return r;</span>
    }


    private BufferedWriter getN2AOutput(String outFile) throws Exception {
        Writer output;
        BufferedWriter n2aOut;

<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (outFile == null)</span>
<span class="nc" id="L234">            output = new OutputStreamWriter(System.out,&quot;US-ASCII&quot;);</span>

        else {
<span class="nc" id="L237">            File f = new File(outFile);</span>

<span class="nc" id="L239">            File tempDir = f.getParentFile();</span>

<span class="nc bnc" id="L241" title="All 2 branches missed.">            if (tempDir == null)</span>
<span class="nc" id="L242">                tempDir = new File(System.getProperty(&quot;user.dir&quot;));</span>

<span class="nc" id="L244">            tempFile = File.createTempFile(&quot;_N2A&quot;,</span>
                                           &quot;.TMP&quot;,
                                            tempDir);
<span class="nc" id="L247">            tempFile.deleteOnExit();</span>

            try {
<span class="nc" id="L250">                output = new FileWriter(tempFile);</span>
<span class="nc" id="L251">            } catch (IOException e){</span>
<span class="nc" id="L252">                throw new Exception(formatMsg(&quot;err.cannot.write&quot;, tempFile.getName()));</span>
<span class="nc" id="L253">            }</span>
        }

<span class="nc" id="L256">        n2aOut = new BufferedWriter(new N2AFilter(output));</span>
<span class="nc" id="L257">        return n2aOut;</span>
    }

    private BufferedReader getA2NInput(String inFile) throws Exception {
        Reader in;
        BufferedReader reader;

<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (inFile == null)</span>
<span class="nc" id="L265">            in = new InputStreamReader(System.in, &quot;US-ASCII&quot;);</span>
        else {
<span class="nc" id="L267">            File f = new File(inFile);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (!f.canRead()){</span>
<span class="nc" id="L269">                throw new Exception(formatMsg(&quot;err.cannot.read&quot;, f.getName()));</span>
            }

            try {
<span class="nc" id="L273">                 in = new FileReader(inFile);</span>
<span class="nc" id="L274">            } catch (Exception e) {</span>
<span class="nc" id="L275">               throw new Exception(formatMsg(&quot;err.cannot.read&quot;, f.getName()));</span>
<span class="nc" id="L276">            }</span>
        }

<span class="nc" id="L279">        reader = new BufferedReader(new A2NFilter(in));</span>
<span class="nc" id="L280">        return reader;</span>
    }

    private Writer getA2NOutput(String outFile) throws Exception {

<span class="nc" id="L285">        OutputStreamWriter w = null;</span>
<span class="nc" id="L286">        OutputStream output = null;</span>

<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (outFile == null)</span>
<span class="nc" id="L289">            output = System.out;</span>
        else {
<span class="nc" id="L291">            File f = new File(outFile);</span>

<span class="nc" id="L293">            File tempDir = f.getParentFile();</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">            if (tempDir == null)</span>
<span class="nc" id="L295">                tempDir = new File(System.getProperty(&quot;user.dir&quot;));</span>
<span class="nc" id="L296">            tempFile =  File.createTempFile(&quot;_N2A&quot;,</span>
                                            &quot;.TMP&quot;,
                                            tempDir);
<span class="nc" id="L299">            tempFile.deleteOnExit();</span>

            try {
<span class="nc" id="L302">                output = new FileOutputStream(tempFile);</span>
<span class="nc" id="L303">            } catch (IOException e){</span>
<span class="nc" id="L304">                throw new Exception(formatMsg(&quot;err.cannot.write&quot;, tempFile.getName()));</span>
<span class="nc" id="L305">            }</span>
        }

<span class="nc bnc" id="L308" title="All 2 branches missed.">        w = (encodingString != null) ?</span>
            new OutputStreamWriter(output, encodingString) :
            new OutputStreamWriter(output);

<span class="nc" id="L312">        return (w);</span>
    }

    private static Charset lookupCharset(String csName) {
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (Charset.isSupported(csName)) {</span>
           try {
<span class="nc" id="L318">                return Charset.forName(csName);</span>
<span class="nc" id="L319">           } catch (UnsupportedCharsetException x) {</span>
<span class="nc" id="L320">                throw new Error(x);</span>
           }
        }
<span class="nc" id="L323">        return null;</span>
    }

    public static boolean canConvert(char ch) {
<span class="nc bnc" id="L327" title="All 4 branches missed.">        return (encoder != null &amp;&amp; encoder.canEncode(ch));</span>
    }

    private static void initializeConverter() throws UnsupportedEncodingException {
<span class="nc" id="L331">        Charset cs = null;</span>

        try {
<span class="nc bnc" id="L334" title="All 2 branches missed.">            cs = (encodingString == null) ?</span>
<span class="nc" id="L335">                lookupCharset(defaultEncoding):</span>
<span class="nc" id="L336">                lookupCharset(encodingString);</span>

<span class="nc bnc" id="L338" title="All 2 branches missed.">            encoder =  (cs != null) ?</span>
<span class="nc" id="L339">                cs.newEncoder() :</span>
                null;
<span class="nc" id="L341">        } catch (IllegalCharsetNameException e) {</span>
<span class="nc" id="L342">            throw new Error(e);</span>
<span class="nc" id="L343">        }</span>
<span class="nc" id="L344">    }</span>

    private static ResourceBundle rsrc;

    static {
        try {
<span class="nc" id="L350">            rsrc = ResourceBundle.getBundle(</span>
                     &quot;sun.tools.native2ascii.resources.MsgNative2ascii&quot;);
<span class="nc" id="L352">        } catch (MissingResourceException e) {</span>
<span class="nc" id="L353">            throw new Error(&quot;Missing message file.&quot;);</span>
<span class="nc" id="L354">        }</span>
<span class="nc" id="L355">    }</span>

    private String getMsg(String key) {
        try {
<span class="nc" id="L359">            return (rsrc.getString(key));</span>
<span class="nc" id="L360">        } catch (MissingResourceException e) {</span>
<span class="nc" id="L361">            throw new Error(&quot;Error in  message file format.&quot;);</span>
        }
    }

    private String formatMsg(String key, String arg) {
<span class="nc" id="L366">        String msg = getMsg(key);</span>
<span class="nc" id="L367">        return MessageFormat.format(msg, arg);</span>
    }


    /**
     * Main program
     */
    public static void main(String argv[]){
<span class="nc" id="L375">        Main converter = new Main();</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        System.exit(converter.convert(argv) ? 0 : 1);</span>
<span class="nc" id="L377">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>