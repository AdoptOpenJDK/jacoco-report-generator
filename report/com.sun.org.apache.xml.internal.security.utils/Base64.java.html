<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Base64.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.org.apache.xml.internal.security.utils</a> &gt; <span class="el_source">Base64.java</span></div><h1>Base64.java</h1><pre class="source lang-java linenums">/*
 * reserved comment block
 * DO NOT REMOVE OR ALTER!
 */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.sun.org.apache.xml.internal.security.utils;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;

import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;

/**
 * Implementation of MIME's Base64 encoding and decoding conversions.
 * Optimized code. (raw version taken from oreilly.jonathan.util,
 * and currently org.apache.xerces.ds.util.Base64)
 *
 * @author Raul Benito(Of the xerces copy, and little adaptations).
 * @author Anli Shundi
 * @author Christian Geuer-Pollmann
 * @see &lt;A HREF=&quot;ftp://ftp.isi.edu/in-notes/rfc2045.txt&quot;&gt;RFC 2045&lt;/A&gt;
 * @see com.sun.org.apache.xml.internal.security.transforms.implementations.TransformBase64Decode
 */
public class Base64 {

    /** Field BASE64DEFAULTLENGTH */
    public static final int BASE64DEFAULTLENGTH = 76;

    private static final int BASELENGTH = 255;
    private static final int LOOKUPLENGTH = 64;
    private static final int TWENTYFOURBITGROUP = 24;
    private static final int EIGHTBIT = 8;
    private static final int SIXTEENBIT = 16;
    private static final int FOURBYTE = 4;
    private static final int SIGN = -128;
    private static final char PAD = '=';
<span class="nc" id="L61">    private static final byte [] base64Alphabet = new byte[BASELENGTH];</span>
<span class="nc" id="L62">    private static final char [] lookUpBase64Alphabet = new char[LOOKUPLENGTH];</span>

    static {
<span class="nc bnc" id="L65" title="All 2 branches missed.">        for (int i = 0; i &lt; BASELENGTH; i++) {</span>
<span class="nc" id="L66">            base64Alphabet[i] = -1;</span>
        }
<span class="nc bnc" id="L68" title="All 2 branches missed.">        for (int i = 'Z'; i &gt;= 'A'; i--) {</span>
<span class="nc" id="L69">            base64Alphabet[i] = (byte) (i - 'A');</span>
        }
<span class="nc bnc" id="L71" title="All 2 branches missed.">        for (int i = 'z'; i&gt;= 'a'; i--) {</span>
<span class="nc" id="L72">            base64Alphabet[i] = (byte) (i - 'a' + 26);</span>
        }

<span class="nc bnc" id="L75" title="All 2 branches missed.">        for (int i = '9'; i &gt;= '0'; i--) {</span>
<span class="nc" id="L76">            base64Alphabet[i] = (byte) (i - '0' + 52);</span>
        }

<span class="nc" id="L79">        base64Alphabet['+'] = 62;</span>
<span class="nc" id="L80">        base64Alphabet['/'] = 63;</span>

<span class="nc bnc" id="L82" title="All 2 branches missed.">        for (int i = 0; i &lt;= 25; i++) {</span>
<span class="nc" id="L83">            lookUpBase64Alphabet[i] = (char)('A' + i);</span>
        }

<span class="nc bnc" id="L86" title="All 2 branches missed.">        for (int i = 26,  j = 0; i &lt;= 51; i++, j++) {</span>
<span class="nc" id="L87">            lookUpBase64Alphabet[i] = (char)('a' + j);</span>
        }

<span class="nc bnc" id="L90" title="All 2 branches missed.">        for (int i = 52,  j = 0; i &lt;= 61; i++, j++) {</span>
<span class="nc" id="L91">            lookUpBase64Alphabet[i] = (char)('0' + j);</span>
        }
<span class="nc" id="L93">        lookUpBase64Alphabet[62] = '+';</span>
<span class="nc" id="L94">        lookUpBase64Alphabet[63] = '/';</span>
<span class="nc" id="L95">    }</span>

<span class="nc" id="L97">    private Base64() {</span>
        // we don't allow instantiation
<span class="nc" id="L99">    }</span>

    /**
     * Returns a byte-array representation of a &lt;code&gt;{@link BigInteger}&lt;code&gt;.
     * No sign-bit is output.
     *
     * &lt;b&gt;N.B.:&lt;/B&gt; &lt;code&gt;{@link BigInteger}&lt;code&gt;'s toByteArray
     * returns eventually longer arrays because of the leading sign-bit.
     *
     * @param big &lt;code&gt;BigInteger&lt;code&gt; to be converted
     * @param bitlen &lt;code&gt;int&lt;code&gt; the desired length in bits of the representation
     * @return a byte array with &lt;code&gt;bitlen&lt;/code&gt; bits of &lt;code&gt;big&lt;/code&gt;
     */
    static final byte[] getBytes(BigInteger big, int bitlen) {

        //round bitlen
<span class="nc" id="L115">        bitlen = ((bitlen + 7) &gt;&gt; 3) &lt;&lt; 3;</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (bitlen &lt; big.bitLength()) {</span>
<span class="nc" id="L118">            throw new IllegalArgumentException(I18n.translate(&quot;utils.Base64.IllegalBitlength&quot;));</span>
        }

<span class="nc" id="L121">        byte[] bigBytes = big.toByteArray();</span>

<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (((big.bitLength() % 8) != 0)</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">            &amp;&amp; (((big.bitLength() / 8) + 1) == (bitlen / 8))) {</span>
<span class="nc" id="L125">            return bigBytes;</span>
        }

        // some copying needed
<span class="nc" id="L129">        int startSrc = 0;    // no need to skip anything</span>
<span class="nc" id="L130">        int bigLen = bigBytes.length;    //valid length of the string</span>

<span class="nc bnc" id="L132" title="All 2 branches missed.">        if ((big.bitLength() % 8) == 0) {    // correct values</span>
<span class="nc" id="L133">            startSrc = 1;    // skip sign bit</span>

<span class="nc" id="L135">            bigLen--;    // valid length of the string</span>
        }

<span class="nc" id="L138">        int startDst = bitlen / 8 - bigLen;    //pad with leading nulls</span>
<span class="nc" id="L139">        byte[] resizedBytes = new byte[bitlen / 8];</span>

<span class="nc" id="L141">        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, bigLen);</span>

<span class="nc" id="L143">        return resizedBytes;</span>
    }

    /**
     * Encode in Base64 the given &lt;code&gt;{@link BigInteger}&lt;code&gt;.
     *
     * @param big
     * @return String with Base64 encoding
     */
    public static final String encode(BigInteger big) {
<span class="nc" id="L153">        return encode(getBytes(big, big.bitLength()));</span>
    }

    /**
     * Returns a byte-array representation of a &lt;code&gt;{@link BigInteger}&lt;code&gt;.
     * No sign-bit is output.
     *
     * &lt;b&gt;N.B.:&lt;/B&gt; &lt;code&gt;{@link BigInteger}&lt;code&gt;'s toByteArray
     * returns eventually longer arrays because of the leading sign-bit.
     *
     * @param big &lt;code&gt;BigInteger&lt;code&gt; to be converted
     * @param bitlen &lt;code&gt;int&lt;code&gt; the desired length in bits of the representation
     * @return a byte array with &lt;code&gt;bitlen&lt;/code&gt; bits of &lt;code&gt;big&lt;/code&gt;
     */
    public static final  byte[] encode(BigInteger big, int bitlen) {

        //round bitlen
<span class="nc" id="L170">        bitlen = ((bitlen + 7) &gt;&gt; 3) &lt;&lt; 3;</span>

<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (bitlen &lt; big.bitLength()) {</span>
<span class="nc" id="L173">            throw new IllegalArgumentException(I18n.translate(&quot;utils.Base64.IllegalBitlength&quot;));</span>
        }

<span class="nc" id="L176">        byte[] bigBytes = big.toByteArray();</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (((big.bitLength() % 8) != 0)</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">            &amp;&amp; (((big.bitLength() / 8) + 1) == (bitlen / 8))) {</span>
<span class="nc" id="L180">            return bigBytes;</span>
        }

        // some copying needed
<span class="nc" id="L184">        int startSrc = 0;    // no need to skip anything</span>
<span class="nc" id="L185">        int bigLen = bigBytes.length;    //valid length of the string</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">        if ((big.bitLength() % 8) == 0) {    // correct values</span>
<span class="nc" id="L188">            startSrc = 1;    // skip sign bit</span>

<span class="nc" id="L190">            bigLen--;    // valid length of the string</span>
        }

<span class="nc" id="L193">        int startDst = bitlen / 8 - bigLen;    //pad with leading nulls</span>
<span class="nc" id="L194">        byte[] resizedBytes = new byte[bitlen / 8];</span>

<span class="nc" id="L196">        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, bigLen);</span>

<span class="nc" id="L198">        return resizedBytes;</span>
    }

    /**
     * Method decodeBigIntegerFromElement
     *
     * @param element
     * @return the biginteger obtained from the node
     * @throws Base64DecodingException
     */
    public static final BigInteger decodeBigIntegerFromElement(Element element)
        throws Base64DecodingException {
<span class="nc" id="L210">        return new BigInteger(1, Base64.decode(element));</span>
    }

    /**
     * Method decodeBigIntegerFromText
     *
     * @param text
     * @return the biginter obtained from the text node
     * @throws Base64DecodingException
     */
    public static final BigInteger decodeBigIntegerFromText(Text text)
        throws Base64DecodingException {
<span class="nc" id="L222">        return new BigInteger(1, Base64.decode(text.getData()));</span>
    }

    /**
     * This method takes an (empty) Element and a BigInteger and adds the
     * base64 encoded BigInteger to the Element.
     *
     * @param element
     * @param biginteger
     */
    public static final void fillElementWithBigInteger(Element element, BigInteger biginteger) {

<span class="nc" id="L234">        String encodedInt = encode(biginteger);</span>

<span class="nc bnc" id="L236" title="All 4 branches missed.">        if (!XMLUtils.ignoreLineBreaks() &amp;&amp; encodedInt.length() &gt; BASE64DEFAULTLENGTH) {</span>
<span class="nc" id="L237">            encodedInt = &quot;\n&quot; + encodedInt + &quot;\n&quot;;</span>
        }

<span class="nc" id="L240">        Document doc = element.getOwnerDocument();</span>
<span class="nc" id="L241">        Text text = doc.createTextNode(encodedInt);</span>

<span class="nc" id="L243">        element.appendChild(text);</span>
<span class="nc" id="L244">    }</span>

    /**
     * Method decode
     *
     * Takes the &lt;CODE&gt;Text&lt;/CODE&gt; children of the Element and interprets
     * them as input for the &lt;CODE&gt;Base64.decode()&lt;/CODE&gt; function.
     *
     * @param element
     * @return the byte obtained of the decoding the element
     * $todo$ not tested yet
     * @throws Base64DecodingException
     */
    public static final byte[] decode(Element element) throws Base64DecodingException {

<span class="nc" id="L259">        Node sibling = element.getFirstChild();</span>
<span class="nc" id="L260">        StringBuffer sb = new StringBuffer();</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">        while (sibling != null) {</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">            if (sibling.getNodeType() == Node.TEXT_NODE) {</span>
<span class="nc" id="L264">                Text t = (Text) sibling;</span>

<span class="nc" id="L266">                sb.append(t.getData());</span>
            }
<span class="nc" id="L268">            sibling = sibling.getNextSibling();</span>
        }

<span class="nc" id="L271">        return decode(sb.toString());</span>
    }

    /**
     * Method encodeToElement
     *
     * @param doc
     * @param localName
     * @param bytes
     * @return an Element with the base64 encoded in the text.
     *
     */
    public static final Element encodeToElement(Document doc, String localName, byte[] bytes) {
<span class="nc" id="L284">        Element el = XMLUtils.createElementInSignatureSpace(doc, localName);</span>
<span class="nc" id="L285">        Text text = doc.createTextNode(encode(bytes));</span>

<span class="nc" id="L287">        el.appendChild(text);</span>

<span class="nc" id="L289">        return el;</span>
    }

    /**
     * Method decode
     *
     * @param base64
     * @return the UTF bytes of the base64
     * @throws Base64DecodingException
     *
     */
    public static final byte[] decode(byte[] base64) throws Base64DecodingException  {
<span class="nc" id="L301">        return decodeInternal(base64, -1);</span>
    }

    /**
     * Encode a byte array and fold lines at the standard 76th character unless
     * ignore line breaks property is set.
     *
     * @param binaryData &lt;code&gt;byte[]&lt;code&gt; to be base64 encoded
     * @return the &lt;code&gt;String&lt;code&gt; with encoded data
     */
    public static final String encode(byte[] binaryData) {
<span class="nc bnc" id="L312" title="All 2 branches missed.">        return XMLUtils.ignoreLineBreaks()</span>
<span class="nc" id="L313">            ? encode(binaryData, Integer.MAX_VALUE)</span>
<span class="nc" id="L314">            : encode(binaryData, BASE64DEFAULTLENGTH);</span>
    }

    /**
     * Base64 decode the lines from the reader and return an InputStream
     * with the bytes.
     *
     * @param reader
     * @return InputStream with the decoded bytes
     * @exception IOException passes what the reader throws
     * @throws IOException
     * @throws Base64DecodingException
     */
    public static final byte[] decode(BufferedReader reader)
        throws IOException, Base64DecodingException {

<span class="nc" id="L330">        byte[] retBytes = null;</span>
<span class="nc" id="L331">        UnsyncByteArrayOutputStream baos = null;</span>
        try {
<span class="nc" id="L333">            baos = new UnsyncByteArrayOutputStream();</span>
            String line;

<span class="nc bnc" id="L336" title="All 2 branches missed.">            while (null != (line = reader.readLine())) {</span>
<span class="nc" id="L337">                byte[] bytes = decode(line);</span>
<span class="nc" id="L338">                baos.write(bytes);</span>
<span class="nc" id="L339">            }</span>
<span class="nc" id="L340">            retBytes = baos.toByteArray();</span>
        } finally {
<span class="nc" id="L342">            baos.close();</span>
<span class="nc" id="L343">        }</span>

<span class="nc" id="L345">        return retBytes;</span>
    }

    protected static final boolean isWhiteSpace(byte octect) {
<span class="nc bnc" id="L349" title="All 8 branches missed.">        return (octect == 0x20 || octect == 0xd || octect == 0xa || octect == 0x9);</span>
    }

    protected static final boolean isPad(byte octect) {
<span class="nc bnc" id="L353" title="All 2 branches missed.">        return (octect == PAD);</span>
    }

    /**
     * Encodes hex octets into Base64
     *
     * @param binaryData Array containing binaryData
     * @return Encoded Base64 array
     */
    /**
     * Encode a byte array in Base64 format and return an optionally
     * wrapped line.
     *
     * @param binaryData &lt;code&gt;byte[]&lt;/code&gt; data to be encoded
     * @param length &lt;code&gt;int&lt;code&gt; length of wrapped lines; No wrapping if less than 4.
     * @return a &lt;code&gt;String&lt;/code&gt; with encoded data
     */
    public static final String  encode(byte[] binaryData,int length) {
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (length &lt; 4) {</span>
<span class="nc" id="L372">            length = Integer.MAX_VALUE;</span>
        }

<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (binaryData == null) {</span>
<span class="nc" id="L376">            return null;</span>
        }

<span class="nc" id="L379">        int lengthDataBits = binaryData.length * EIGHTBIT;</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (lengthDataBits == 0) {</span>
<span class="nc" id="L381">            return &quot;&quot;;</span>
        }

<span class="nc" id="L384">        int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;</span>
<span class="nc" id="L385">        int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        int numberQuartet = fewerThan24bits != 0 ? numberTriplets + 1 : numberTriplets;</span>
<span class="nc" id="L387">        int quartesPerLine = length / 4;</span>
<span class="nc" id="L388">        int numberLines = (numberQuartet - 1) / quartesPerLine;</span>
<span class="nc" id="L389">        char encodedData[] = null;</span>

<span class="nc" id="L391">        encodedData = new char[numberQuartet * 4 + numberLines];</span>

<span class="nc" id="L393">        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;</span>
<span class="nc" id="L394">        int encodedIndex = 0;</span>
<span class="nc" id="L395">        int dataIndex = 0;</span>
<span class="nc" id="L396">        int i = 0;</span>

<span class="nc bnc" id="L398" title="All 2 branches missed.">        for (int line = 0; line &lt; numberLines; line++) {</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            for (int quartet = 0; quartet &lt; 19; quartet++) {</span>
<span class="nc" id="L400">                b1 = binaryData[dataIndex++];</span>
<span class="nc" id="L401">                b2 = binaryData[dataIndex++];</span>
<span class="nc" id="L402">                b3 = binaryData[dataIndex++];</span>

<span class="nc" id="L404">                l  = (byte)(b2 &amp; 0x0f);</span>
<span class="nc" id="L405">                k  = (byte)(b1 &amp; 0x03);</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">                byte val1 = ((b1 &amp; SIGN) == 0) ? (byte)(b1 &gt;&gt; 2): (byte)((b1) &gt;&gt; 2 ^ 0xc0);</span>

<span class="nc bnc" id="L409" title="All 2 branches missed.">                byte val2 = ((b2 &amp; SIGN) == 0) ? (byte)(b2 &gt;&gt; 4) : (byte)((b2) &gt;&gt; 4 ^ 0xf0);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">                byte val3 = ((b3 &amp; SIGN) == 0) ? (byte)(b3 &gt;&gt; 6) : (byte)((b3) &gt;&gt; 6 ^ 0xfc);</span>


<span class="nc" id="L413">                encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];</span>
<span class="nc" id="L414">                encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k &lt;&lt; 4)];</span>
<span class="nc" id="L415">                encodedData[encodedIndex++] = lookUpBase64Alphabet[(l &lt;&lt; 2) | val3];</span>
<span class="nc" id="L416">                encodedData[encodedIndex++] = lookUpBase64Alphabet[b3 &amp; 0x3f];</span>

<span class="nc" id="L418">                i++;</span>
            }
<span class="nc" id="L420">            encodedData[encodedIndex++] = 0xa;</span>
        }

<span class="nc bnc" id="L423" title="All 2 branches missed.">        for (; i &lt; numberTriplets; i++) {</span>
<span class="nc" id="L424">            b1 = binaryData[dataIndex++];</span>
<span class="nc" id="L425">            b2 = binaryData[dataIndex++];</span>
<span class="nc" id="L426">            b3 = binaryData[dataIndex++];</span>

<span class="nc" id="L428">            l  = (byte)(b2 &amp; 0x0f);</span>
<span class="nc" id="L429">            k  = (byte)(b1 &amp; 0x03);</span>

<span class="nc bnc" id="L431" title="All 2 branches missed.">            byte val1 = ((b1 &amp; SIGN) == 0) ? (byte)(b1 &gt;&gt; 2) : (byte)((b1) &gt;&gt; 2 ^ 0xc0);</span>

<span class="nc bnc" id="L433" title="All 2 branches missed.">            byte val2 = ((b2 &amp; SIGN) == 0) ? (byte)(b2 &gt;&gt; 4) : (byte)((b2) &gt;&gt; 4 ^ 0xf0);</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            byte val3 = ((b3 &amp; SIGN) == 0) ? (byte)(b3 &gt;&gt; 6) : (byte)((b3) &gt;&gt; 6 ^ 0xfc);</span>


<span class="nc" id="L437">            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];</span>
<span class="nc" id="L438">            encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k &lt;&lt; 4)];</span>
<span class="nc" id="L439">            encodedData[encodedIndex++] = lookUpBase64Alphabet[(l &lt;&lt; 2) | val3];</span>
<span class="nc" id="L440">            encodedData[encodedIndex++] = lookUpBase64Alphabet[b3 &amp; 0x3f];</span>
        }

        // form integral number of 6-bit groups
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (fewerThan24bits == EIGHTBIT) {</span>
<span class="nc" id="L445">            b1 = binaryData[dataIndex];</span>
<span class="nc" id="L446">            k = (byte) (b1 &amp;0x03);</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            byte val1 = ((b1 &amp; SIGN) == 0) ? (byte)(b1 &gt;&gt; 2):(byte)((b1) &gt;&gt; 2 ^ 0xc0);</span>
<span class="nc" id="L448">            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];</span>
<span class="nc" id="L449">            encodedData[encodedIndex++] = lookUpBase64Alphabet[k &lt;&lt; 4];</span>
<span class="nc" id="L450">            encodedData[encodedIndex++] = PAD;</span>
<span class="nc" id="L451">            encodedData[encodedIndex++] = PAD;</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        } else if (fewerThan24bits == SIXTEENBIT) {</span>
<span class="nc" id="L453">            b1 = binaryData[dataIndex];</span>
<span class="nc" id="L454">            b2 = binaryData[dataIndex +1 ];</span>
<span class="nc" id="L455">            l = ( byte ) (b2 &amp; 0x0f);</span>
<span class="nc" id="L456">            k = ( byte ) (b1 &amp; 0x03);</span>

<span class="nc bnc" id="L458" title="All 2 branches missed.">            byte val1 = ((b1 &amp; SIGN) == 0) ? (byte)(b1 &gt;&gt; 2) : (byte)((b1) &gt;&gt; 2 ^ 0xc0);</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            byte val2 = ((b2 &amp; SIGN) == 0) ? (byte)(b2 &gt;&gt; 4) : (byte)((b2) &gt;&gt; 4 ^ 0xf0);</span>

<span class="nc" id="L461">            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];</span>
<span class="nc" id="L462">            encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k &lt;&lt; 4)];</span>
<span class="nc" id="L463">            encodedData[encodedIndex++] = lookUpBase64Alphabet[l &lt;&lt; 2];</span>
<span class="nc" id="L464">            encodedData[encodedIndex++] = PAD;</span>
        }

        //encodedData[encodedIndex] = 0xa;

<span class="nc" id="L469">        return new String(encodedData);</span>
    }

    /**
     * Decodes Base64 data into octets
     *
     * @param encoded String containing base64 encoded data
     * @return byte array containing the decoded data
     * @throws Base64DecodingException if there is a problem decoding the data
     */
    public static final byte[] decode(String encoded) throws Base64DecodingException {
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (encoded == null) {</span>
<span class="nc" id="L481">            return null;</span>
        }
<span class="nc" id="L483">        byte[] bytes = new byte[encoded.length()];</span>
<span class="nc" id="L484">        int len = getBytesInternal(encoded, bytes);</span>
<span class="nc" id="L485">        return decodeInternal(bytes, len);</span>
    }

    protected static final int getBytesInternal(String s, byte[] result) {
<span class="nc" id="L489">        int length = s.length();</span>

<span class="nc" id="L491">        int newSize = 0;</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L493">            byte dataS = (byte)s.charAt(i);</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">            if (!isWhiteSpace(dataS)) {</span>
<span class="nc" id="L495">                result[newSize++] = dataS;</span>
            }
        }
<span class="nc" id="L498">        return newSize;</span>
    }

    protected static final byte[] decodeInternal(byte[] base64Data, int len)
        throws Base64DecodingException {
        // remove white spaces
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (len == -1) {</span>
<span class="nc" id="L505">            len = removeWhiteSpace(base64Data);</span>
        }

<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (len % FOURBYTE != 0) {</span>
<span class="nc" id="L509">            throw new Base64DecodingException(&quot;decoding.divisible.four&quot;);</span>
            //should be divisible by four
        }

<span class="nc" id="L513">        int numberQuadruple = (len / FOURBYTE);</span>

<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (numberQuadruple == 0) {</span>
<span class="nc" id="L516">            return new byte[0];</span>
        }

<span class="nc" id="L519">        byte decodedData[] = null;</span>
<span class="nc" id="L520">        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;</span>

<span class="nc" id="L522">        int i = 0;</span>
<span class="nc" id="L523">        int encodedIndex = 0;</span>
<span class="nc" id="L524">        int dataIndex = 0;</span>

        //decodedData = new byte[ (numberQuadruple)*3];
<span class="nc" id="L527">        dataIndex = (numberQuadruple - 1) * 4;</span>
<span class="nc" id="L528">        encodedIndex = (numberQuadruple - 1) * 3;</span>
        //first last bits.
<span class="nc" id="L530">        b1 = base64Alphabet[base64Data[dataIndex++]];</span>
<span class="nc" id="L531">        b2 = base64Alphabet[base64Data[dataIndex++]];</span>
<span class="nc bnc" id="L532" title="All 4 branches missed.">        if ((b1==-1) || (b2==-1)) {</span>
             //if found &quot;no data&quot; just return null
<span class="nc" id="L534">            throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
        }


        byte d3, d4;
<span class="nc" id="L539">        b3 = base64Alphabet[d3 = base64Data[dataIndex++]];</span>
<span class="nc" id="L540">        b4 = base64Alphabet[d4 = base64Data[dataIndex++]];</span>
<span class="nc bnc" id="L541" title="All 4 branches missed.">        if ((b3 == -1) || (b4 == -1) ) {</span>
            //Check if they are PAD characters
<span class="nc bnc" id="L543" title="All 4 branches missed.">            if (isPad(d3) &amp;&amp; isPad(d4)) {               //Two PAD e.g. 3c[Pad][Pad]</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">                if ((b2 &amp; 0xf) != 0) { //last 4 bits should be zero</span>
<span class="nc" id="L545">                    throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
                }
<span class="nc" id="L547">                decodedData = new byte[encodedIndex + 1];</span>
<span class="nc" id="L548">                decodedData[encodedIndex]   = (byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4) ;</span>
<span class="nc bnc" id="L549" title="All 4 branches missed.">            } else if (!isPad(d3) &amp;&amp; isPad(d4)) {               //One PAD  e.g. 3cQ[Pad]</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">                if ((b3 &amp; 0x3) != 0) { //last 2 bits should be zero</span>
<span class="nc" id="L551">                    throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
                }
<span class="nc" id="L553">                decodedData = new byte[encodedIndex + 2];</span>
<span class="nc" id="L554">                decodedData[encodedIndex++] = (byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4);</span>
<span class="nc" id="L555">                decodedData[encodedIndex] = (byte)(((b2 &amp; 0xf) &lt;&lt; 4) |((b3 &gt;&gt; 2) &amp; 0xf));</span>
            } else {
                //an error  like &quot;3c[Pad]r&quot;, &quot;3cdX&quot;, &quot;3cXd&quot;, &quot;3cXX&quot; where X is non data
<span class="nc" id="L558">                throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
            }
        } else {
            //No PAD e.g 3cQl
<span class="nc" id="L562">            decodedData = new byte[encodedIndex+3];</span>
<span class="nc" id="L563">            decodedData[encodedIndex++] = (byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4) ;</span>
<span class="nc" id="L564">            decodedData[encodedIndex++] = (byte)(((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf));</span>
<span class="nc" id="L565">            decodedData[encodedIndex++] = (byte)(b3 &lt;&lt; 6 | b4);</span>
        }
<span class="nc" id="L567">        encodedIndex = 0;</span>
<span class="nc" id="L568">        dataIndex = 0;</span>
        //the begin
<span class="nc bnc" id="L570" title="All 2 branches missed.">        for (i = numberQuadruple - 1; i &gt; 0; i--) {</span>
<span class="nc" id="L571">            b1 = base64Alphabet[base64Data[dataIndex++]];</span>
<span class="nc" id="L572">            b2 = base64Alphabet[base64Data[dataIndex++]];</span>
<span class="nc" id="L573">            b3 = base64Alphabet[base64Data[dataIndex++]];</span>
<span class="nc" id="L574">            b4 = base64Alphabet[base64Data[dataIndex++]];</span>

<span class="nc bnc" id="L576" title="All 8 branches missed.">            if ((b1 == -1) ||</span>
                (b2 == -1) ||
                (b3 == -1) ||
                (b4 == -1)) {
                //if found &quot;no data&quot; just return null
<span class="nc" id="L581">                throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
            }

<span class="nc" id="L584">            decodedData[encodedIndex++] = (byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4) ;</span>
<span class="nc" id="L585">            decodedData[encodedIndex++] = (byte)(((b2 &amp; 0xf) &lt;&lt; 4) |((b3 &gt;&gt; 2) &amp; 0xf));</span>
<span class="nc" id="L586">            decodedData[encodedIndex++] = (byte)(b3 &lt;&lt; 6 | b4 );</span>
        }
<span class="nc" id="L588">        return decodedData;</span>
    }

    /**
     * Decodes Base64 data into outputstream
     *
     * @param base64Data String containing Base64 data
     * @param os the outputstream
     * @throws IOException
     * @throws Base64DecodingException
     */
    public static final void decode(String base64Data, OutputStream os)
        throws Base64DecodingException, IOException {
<span class="nc" id="L601">        byte[] bytes = new byte[base64Data.length()];</span>
<span class="nc" id="L602">        int len = getBytesInternal(base64Data, bytes);</span>
<span class="nc" id="L603">        decode(bytes,os,len);</span>
<span class="nc" id="L604">    }</span>

    /**
     * Decodes Base64 data into outputstream
     *
     * @param base64Data Byte array containing Base64 data
     * @param os the outputstream
     * @throws IOException
     * @throws Base64DecodingException
     */
    public static final void decode(byte[] base64Data, OutputStream os)
        throws Base64DecodingException, IOException {
<span class="nc" id="L616">        decode(base64Data,os,-1);</span>
<span class="nc" id="L617">    }</span>

    protected static final void decode(byte[] base64Data, OutputStream os, int len)
        throws Base64DecodingException, IOException {
        // remove white spaces
<span class="nc bnc" id="L622" title="All 2 branches missed.">        if (len == -1) {</span>
<span class="nc" id="L623">            len = removeWhiteSpace(base64Data);</span>
        }

<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (len % FOURBYTE != 0) {</span>
<span class="nc" id="L627">            throw new Base64DecodingException(&quot;decoding.divisible.four&quot;);</span>
            //should be divisible by four
        }

<span class="nc" id="L631">        int numberQuadruple = (len / FOURBYTE);</span>

<span class="nc bnc" id="L633" title="All 2 branches missed.">        if (numberQuadruple == 0) {</span>
<span class="nc" id="L634">            return;</span>
        }

        //byte decodedData[] = null;
<span class="nc" id="L638">        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;</span>

<span class="nc" id="L640">        int i = 0;</span>
<span class="nc" id="L641">        int dataIndex = 0;</span>

        //the begin
<span class="nc bnc" id="L644" title="All 2 branches missed.">        for (i=numberQuadruple - 1; i &gt; 0; i--) {</span>
<span class="nc" id="L645">            b1 = base64Alphabet[base64Data[dataIndex++]];</span>
<span class="nc" id="L646">            b2 = base64Alphabet[base64Data[dataIndex++]];</span>
<span class="nc" id="L647">            b3 = base64Alphabet[base64Data[dataIndex++]];</span>
<span class="nc" id="L648">            b4 = base64Alphabet[base64Data[dataIndex++]];</span>
<span class="nc bnc" id="L649" title="All 8 branches missed.">            if ((b1 == -1) ||</span>
                (b2 == -1) ||
                (b3 == -1) ||
                (b4 == -1) ) {
                //if found &quot;no data&quot; just return null
<span class="nc" id="L654">                throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
            }

<span class="nc" id="L657">            os.write((byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4));</span>
<span class="nc" id="L658">            os.write((byte)(((b2 &amp; 0xf) &lt;&lt; 4 ) | ((b3 &gt;&gt; 2) &amp; 0xf)));</span>
<span class="nc" id="L659">            os.write( (byte)(b3 &lt;&lt; 6 | b4));</span>
        }
<span class="nc" id="L661">        b1 = base64Alphabet[base64Data[dataIndex++]];</span>
<span class="nc" id="L662">        b2 = base64Alphabet[base64Data[dataIndex++]];</span>

        //  first last bits.
<span class="nc bnc" id="L665" title="All 4 branches missed.">        if ((b1 == -1) || (b2 == -1) ) {</span>
            //if found &quot;no data&quot; just return null
<span class="nc" id="L667">            throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
        }

        byte d3, d4;
<span class="nc" id="L671">        b3 = base64Alphabet[d3 = base64Data[dataIndex++]];</span>
<span class="nc" id="L672">        b4 = base64Alphabet[d4 = base64Data[dataIndex++]];</span>
<span class="nc bnc" id="L673" title="All 4 branches missed.">        if ((b3 == -1 ) || (b4 == -1) ) { //Check if they are PAD characters</span>
<span class="nc bnc" id="L674" title="All 4 branches missed.">            if (isPad(d3) &amp;&amp; isPad(d4)) {               //Two PAD e.g. 3c[Pad][Pad]</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">                if ((b2 &amp; 0xf) != 0) { //last 4 bits should be zero</span>
<span class="nc" id="L676">                    throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
                }
<span class="nc" id="L678">                os.write((byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4));</span>
<span class="nc bnc" id="L679" title="All 4 branches missed.">            } else if (!isPad(d3) &amp;&amp; isPad(d4)) {               //One PAD  e.g. 3cQ[Pad]</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                if ((b3 &amp; 0x3 ) != 0) { //last 2 bits should be zero</span>
<span class="nc" id="L681">                    throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
                }
<span class="nc" id="L683">                os.write((byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4));</span>
<span class="nc" id="L684">                os.write((byte)(((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf)));</span>
            } else {
                //an error  like &quot;3c[Pad]r&quot;, &quot;3cdX&quot;, &quot;3cXd&quot;, &quot;3cXX&quot; where X is non data
<span class="nc" id="L687">                throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
            }
        } else {
            //No PAD e.g 3cQl
<span class="nc" id="L691">            os.write((byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4));</span>
<span class="nc" id="L692">            os.write( (byte)(((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf)));</span>
<span class="nc" id="L693">            os.write((byte)(b3 &lt;&lt; 6 | b4));</span>
        }
<span class="nc" id="L695">    }</span>

    /**
     * Decodes Base64 data into  outputstream
     *
     * @param is containing Base64 data
     * @param os the outputstream
     * @throws IOException
     * @throws Base64DecodingException
     */
    public static final void decode(InputStream is, OutputStream os)
        throws Base64DecodingException, IOException {
        //byte decodedData[] = null;
<span class="nc" id="L708">        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;</span>

<span class="nc" id="L710">        int index=0;</span>
<span class="nc" id="L711">        byte[] data = new byte[4];</span>
        int read;
        //the begin
<span class="nc bnc" id="L714" title="All 2 branches missed.">        while ((read = is.read()) &gt; 0) {</span>
<span class="nc" id="L715">            byte readed = (byte)read;</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">            if (isWhiteSpace(readed)) {</span>
<span class="nc" id="L717">                continue;</span>
            }
<span class="nc bnc" id="L719" title="All 2 branches missed.">            if (isPad(readed)) {</span>
<span class="nc" id="L720">                data[index++] = readed;</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                if (index == 3) {</span>
<span class="nc" id="L722">                    data[index++] = (byte)is.read();</span>
                }
                break;
            }

<span class="nc bnc" id="L727" title="All 2 branches missed.">            if ((data[index++] = readed) == -1) {</span>
                //if found &quot;no data&quot; just return null
<span class="nc" id="L729">                throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
            }

<span class="nc bnc" id="L732" title="All 2 branches missed.">            if (index != 4) {</span>
<span class="nc" id="L733">                continue;</span>
            }
<span class="nc" id="L735">            index = 0;</span>
<span class="nc" id="L736">            b1 = base64Alphabet[data[0]];</span>
<span class="nc" id="L737">            b2 = base64Alphabet[data[1]];</span>
<span class="nc" id="L738">            b3 = base64Alphabet[data[2]];</span>
<span class="nc" id="L739">            b4 = base64Alphabet[data[3]];</span>

<span class="nc" id="L741">            os.write((byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4));</span>
<span class="nc" id="L742">            os.write((byte)(((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf)));</span>
<span class="nc" id="L743">            os.write((byte)(b3 &lt;&lt; 6 | b4));</span>
<span class="nc" id="L744">        }</span>

<span class="nc" id="L746">        byte d1 = data[0], d2 = data[1], d3 = data[2], d4 = data[3];</span>
<span class="nc" id="L747">        b1 = base64Alphabet[d1];</span>
<span class="nc" id="L748">        b2 = base64Alphabet[d2];</span>
<span class="nc" id="L749">        b3 = base64Alphabet[d3];</span>
<span class="nc" id="L750">        b4 = base64Alphabet[d4];</span>
<span class="nc bnc" id="L751" title="All 4 branches missed.">        if ((b3 == -1) || (b4 == -1)) { //Check if they are PAD characters</span>
<span class="nc bnc" id="L752" title="All 4 branches missed.">            if (isPad(d3) &amp;&amp; isPad(d4)) {               //Two PAD e.g. 3c[Pad][Pad]</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                if ((b2 &amp; 0xf) != 0) { //last 4 bits should be zero</span>
<span class="nc" id="L754">                    throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
                }
<span class="nc" id="L756">                os.write((byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4));</span>
<span class="nc bnc" id="L757" title="All 4 branches missed.">            } else if (!isPad(d3) &amp;&amp; isPad(d4)) {               //One PAD  e.g. 3cQ[Pad]</span>
<span class="nc" id="L758">                b3 = base64Alphabet[d3];</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">                if ((b3 &amp; 0x3) != 0) { //last 2 bits should be zero</span>
<span class="nc" id="L760">                    throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
                }
<span class="nc" id="L762">                os.write((byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4));</span>
<span class="nc" id="L763">                os.write((byte)(((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf)));</span>
            } else {
                //an error  like &quot;3c[Pad]r&quot;, &quot;3cdX&quot;, &quot;3cXd&quot;, &quot;3cXX&quot; where X is non data
<span class="nc" id="L766">                throw new Base64DecodingException(&quot;decoding.general&quot;);</span>
            }
        } else {
            //No PAD e.g 3cQl
<span class="nc" id="L770">            os.write((byte)(b1 &lt;&lt; 2 | b2 &gt;&gt; 4));</span>
<span class="nc" id="L771">            os.write((byte)(((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf)));</span>
<span class="nc" id="L772">            os.write((byte)(b3 &lt;&lt; 6 | b4));</span>
        }
<span class="nc" id="L774">    }</span>

    /**
     * remove WhiteSpace from MIME containing encoded Base64 data.
     *
     * @param data  the byte array of base64 data (with WS)
     * @return      the new length
     */
    protected static final int removeWhiteSpace(byte[] data) {
<span class="nc bnc" id="L783" title="All 2 branches missed.">        if (data == null) {</span>
<span class="nc" id="L784">            return 0;</span>
        }

        // count characters that's not whitespace
<span class="nc" id="L788">        int newSize = 0;</span>
<span class="nc" id="L789">        int len = data.length;</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L791">            byte dataS = data[i];</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">            if (!isWhiteSpace(dataS)) {</span>
<span class="nc" id="L793">                data[newSize++] = dataS;</span>
            }
        }
<span class="nc" id="L796">        return newSize;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>