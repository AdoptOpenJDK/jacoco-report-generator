<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>IsoFields.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.time.temporal</a> &gt; <span class="el_source">IsoFields.java</span></div><h1>IsoFields.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * Copyright (c) 2011-2012, Stephen Colebourne &amp; Michael Nascimento Santos
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of JSR-310 nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package java.time.temporal;

import static java.time.DayOfWeek.THURSDAY;
import static java.time.DayOfWeek.WEDNESDAY;
import static java.time.temporal.ChronoField.DAY_OF_WEEK;
import static java.time.temporal.ChronoField.DAY_OF_YEAR;
import static java.time.temporal.ChronoField.EPOCH_DAY;
import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
import static java.time.temporal.ChronoField.YEAR;
import static java.time.temporal.ChronoUnit.DAYS;
import static java.time.temporal.ChronoUnit.FOREVER;
import static java.time.temporal.ChronoUnit.MONTHS;
import static java.time.temporal.ChronoUnit.WEEKS;
import static java.time.temporal.ChronoUnit.YEARS;

import java.time.DateTimeException;
import java.time.Duration;
import java.time.LocalDate;
import java.time.chrono.ChronoLocalDate;
import java.time.chrono.Chronology;
import java.time.chrono.IsoChronology;
import java.time.format.ResolverStyle;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.ResourceBundle;

import sun.util.locale.provider.LocaleProviderAdapter;
import sun.util.locale.provider.LocaleResources;

/**
 * Fields and units specific to the ISO-8601 calendar system,
 * including quarter-of-year and week-based-year.
 * &lt;p&gt;
 * This class defines fields and units that are specific to the ISO calendar system.
 *
 * &lt;h3&gt;Quarter of year&lt;/h3&gt;
 * The ISO-8601 standard is based on the standard civic 12 month year.
 * This is commonly divided into four quarters, often abbreviated as Q1, Q2, Q3 and Q4.
 * &lt;p&gt;
 * January, February and March are in Q1.
 * April, May and June are in Q2.
 * July, August and September are in Q3.
 * October, November and December are in Q4.
 * &lt;p&gt;
 * The complete date is expressed using three fields:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #DAY_OF_QUARTER DAY_OF_QUARTER} - the day within the quarter, from 1 to 90, 91 or 92
 * &lt;li&gt;{@link #QUARTER_OF_YEAR QUARTER_OF_YEAR} - the week within the week-based-year
 * &lt;li&gt;{@link ChronoField#YEAR YEAR} - the standard ISO year
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Week based years&lt;/h3&gt;
 * The ISO-8601 standard was originally intended as a data interchange format,
 * defining a string format for dates and times. However, it also defines an
 * alternate way of expressing the date, based on the concept of week-based-year.
 * &lt;p&gt;
 * The date is expressed using three fields:
 * &lt;ul&gt;
 * &lt;li&gt;{@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} - the standard field defining the
 *  day-of-week from Monday (1) to Sunday (7)
 * &lt;li&gt;{@link #WEEK_OF_WEEK_BASED_YEAR} - the week within the week-based-year
 * &lt;li&gt;{@link #WEEK_BASED_YEAR WEEK_BASED_YEAR} - the week-based-year
 * &lt;/ul&gt;
 * The week-based-year itself is defined relative to the standard ISO proleptic year.
 * It differs from the standard year in that it always starts on a Monday.
 * &lt;p&gt;
 * The first week of a week-based-year is the first Monday-based week of the standard
 * ISO year that has at least 4 days in the new year.
 * &lt;ul&gt;
 * &lt;li&gt;If January 1st is Monday then week 1 starts on January 1st
 * &lt;li&gt;If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year
 * &lt;li&gt;If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year
 * &lt;li&gt;If January 1st is Thursday then week 1 starts on December 29th of the previous standard year
 * &lt;li&gt;If January 1st is Friday then week 1 starts on January 4th
 * &lt;li&gt;If January 1st is Saturday then week 1 starts on January 3rd
 * &lt;li&gt;If January 1st is Sunday then week 1 starts on January 2nd
 * &lt;/ul&gt;
 * There are 52 weeks in most week-based years, however on occasion there are 53 weeks.
 * &lt;p&gt;
 * For example:
 *
 * &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;3&quot; border=&quot;0&quot; style=&quot;text-align: left; width: 50%;&quot;&gt;
 * &lt;caption&gt;Examples of Week based Years&lt;/caption&gt;
 * &lt;tr&gt;&lt;th&gt;Date&lt;/th&gt;&lt;th&gt;Day-of-week&lt;/th&gt;&lt;th&gt;Field values&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2008-12-28&lt;/th&gt;&lt;td&gt;Sunday&lt;/td&gt;&lt;td&gt;Week 52 of week-based-year 2008&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2008-12-29&lt;/th&gt;&lt;td&gt;Monday&lt;/td&gt;&lt;td&gt;Week 1 of week-based-year 2009&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2008-12-31&lt;/th&gt;&lt;td&gt;Wednesday&lt;/td&gt;&lt;td&gt;Week 1 of week-based-year 2009&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2009-01-01&lt;/th&gt;&lt;td&gt;Thursday&lt;/td&gt;&lt;td&gt;Week 1 of week-based-year 2009&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2009-01-04&lt;/th&gt;&lt;td&gt;Sunday&lt;/td&gt;&lt;td&gt;Week 1 of week-based-year 2009&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2009-01-05&lt;/th&gt;&lt;td&gt;Monday&lt;/td&gt;&lt;td&gt;Week 2 of week-based-year 2009&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * @implSpec
 * &lt;p&gt;
 * This class is immutable and thread-safe.
 *
 * @since 1.8
 */
public final class IsoFields {

    /**
     * The field that represents the day-of-quarter.
     * &lt;p&gt;
     * This field allows the day-of-quarter value to be queried and set.
     * The day-of-quarter has values from 1 to 90 in Q1 of a standard year, from 1 to 91
     * in Q1 of a leap year, from 1 to 91 in Q2 and from 1 to 92 in Q3 and Q4.
     * &lt;p&gt;
     * The day-of-quarter can only be calculated if the day-of-year, month-of-year and year
     * are available.
     * &lt;p&gt;
     * When setting this field, the value is allowed to be partially lenient, taking any
     * value from 1 to 92. If the quarter has less than 92 days, then day 92, and
     * potentially day 91, is in the following quarter.
     * &lt;p&gt;
     * In the resolving phase of parsing, a date can be created from a year,
     * quarter-of-year and day-of-quarter.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
     * validated against their range of valid values. The day-of-quarter field
     * is validated from 1 to 90, 91 or 92 depending on the year and quarter.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
     * validated against their range of valid values. The day-of-quarter field is
     * validated between 1 and 92, ignoring the actual range based on the year and quarter.
     * If the day-of-quarter exceeds the actual range by one day, then the resulting date
     * is one day later. If the day-of-quarter exceeds the actual range by two days,
     * then the resulting date is two days later.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#LENIENT lenient mode}, only the year is validated
     * against the range of valid values. The resulting date is calculated equivalent to
     * the following three stage approach. First, create a date on the first of January
     * in the requested year. Then take the quarter-of-year, subtract one, and add the
     * amount in quarters to the date. Finally, take the day-of-quarter, subtract one,
     * and add the amount in days to the date.
     * &lt;p&gt;
     * This unit is an immutable and thread-safe singleton.
     */
<span class="nc" id="L195">    public static final TemporalField DAY_OF_QUARTER = Field.DAY_OF_QUARTER;</span>
    /**
     * The field that represents the quarter-of-year.
     * &lt;p&gt;
     * This field allows the quarter-of-year value to be queried and set.
     * The quarter-of-year has values from 1 to 4.
     * &lt;p&gt;
     * The quarter-of-year can only be calculated if the month-of-year is available.
     * &lt;p&gt;
     * In the resolving phase of parsing, a date can be created from a year,
     * quarter-of-year and day-of-quarter.
     * See {@link #DAY_OF_QUARTER} for details.
     * &lt;p&gt;
     * This unit is an immutable and thread-safe singleton.
     */
<span class="nc" id="L210">    public static final TemporalField QUARTER_OF_YEAR = Field.QUARTER_OF_YEAR;</span>
    /**
     * The field that represents the week-of-week-based-year.
     * &lt;p&gt;
     * This field allows the week of the week-based-year value to be queried and set.
     * The week-of-week-based-year has values from 1 to 52, or 53 if the
     * week-based-year has 53 weeks.
     * &lt;p&gt;
     * In the resolving phase of parsing, a date can be created from a
     * week-based-year, week-of-week-based-year and day-of-week.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
     * validated against their range of valid values. The week-of-week-based-year
     * field is validated from 1 to 52 or 53 depending on the week-based-year.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
     * validated against their range of valid values. The week-of-week-based-year
     * field is validated between 1 and 53, ignoring the week-based-year.
     * If the week-of-week-based-year is 53, but the week-based-year only has
     * 52 weeks, then the resulting date is in week 1 of the following week-based-year.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#LENIENT lenient mode}, only the week-based-year
     * is validated against the range of valid values. If the day-of-week is outside
     * the range 1 to 7, then the resulting date is adjusted by a suitable number of
     * weeks to reduce the day-of-week to the range 1 to 7. If the week-of-week-based-year
     * value is outside the range 1 to 52, then any excess weeks are added or subtracted
     * from the resulting date.
     * &lt;p&gt;
     * This unit is an immutable and thread-safe singleton.
     */
<span class="nc" id="L240">    public static final TemporalField WEEK_OF_WEEK_BASED_YEAR = Field.WEEK_OF_WEEK_BASED_YEAR;</span>
    /**
     * The field that represents the week-based-year.
     * &lt;p&gt;
     * This field allows the week-based-year value to be queried and set.
     * &lt;p&gt;
     * The field has a range that matches {@link LocalDate#MAX} and {@link LocalDate#MIN}.
     * &lt;p&gt;
     * In the resolving phase of parsing, a date can be created from a
     * week-based-year, week-of-week-based-year and day-of-week.
     * See {@link #WEEK_OF_WEEK_BASED_YEAR} for details.
     * &lt;p&gt;
     * This unit is an immutable and thread-safe singleton.
     */
<span class="nc" id="L254">    public static final TemporalField WEEK_BASED_YEAR = Field.WEEK_BASED_YEAR;</span>
    /**
     * The unit that represents week-based-years for the purpose of addition and subtraction.
     * &lt;p&gt;
     * This allows a number of week-based-years to be added to, or subtracted from, a date.
     * The unit is equal to either 52 or 53 weeks.
     * The estimated duration of a week-based-year is the same as that of a standard ISO
     * year at {@code 365.2425 Days}.
     * &lt;p&gt;
     * The rules for addition add the number of week-based-years to the existing value
     * for the week-based-year field. If the resulting week-based-year only has 52 weeks,
     * then the date will be in week 1 of the following week-based-year.
     * &lt;p&gt;
     * This unit is an immutable and thread-safe singleton.
     */
<span class="nc" id="L269">    public static final TemporalUnit WEEK_BASED_YEARS = Unit.WEEK_BASED_YEARS;</span>
    /**
     * Unit that represents the concept of a quarter-year.
     * For the ISO calendar system, it is equal to 3 months.
     * The estimated duration of a quarter-year is one quarter of {@code 365.2425 Days}.
     * &lt;p&gt;
     * This unit is an immutable and thread-safe singleton.
     */
<span class="nc" id="L277">    public static final TemporalUnit QUARTER_YEARS = Unit.QUARTER_YEARS;</span>

    /**
     * Restricted constructor.
     */
<span class="nc" id="L282">    private IsoFields() {</span>
<span class="nc" id="L283">        throw new AssertionError(&quot;Not instantiable&quot;);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Implementation of the field.
     */
<span class="nc" id="L290">    private static enum Field implements TemporalField {</span>
<span class="nc" id="L291">        DAY_OF_QUARTER {</span>
            @Override
            public TemporalUnit getBaseUnit() {
<span class="nc" id="L294">                return DAYS;</span>
            }
            @Override
            public TemporalUnit getRangeUnit() {
<span class="nc" id="L298">                return QUARTER_YEARS;</span>
            }
            @Override
            public ValueRange range() {
<span class="nc" id="L302">                return ValueRange.of(1, 90, 92);</span>
            }
            @Override
            public boolean isSupportedBy(TemporalAccessor temporal) {
<span class="nc bnc" id="L306" title="All 4 branches missed.">                return temporal.isSupported(DAY_OF_YEAR) &amp;&amp; temporal.isSupported(MONTH_OF_YEAR) &amp;&amp;</span>
<span class="nc bnc" id="L307" title="All 4 branches missed.">                        temporal.isSupported(YEAR) &amp;&amp; isIso(temporal);</span>
            }
            @Override
            public ValueRange rangeRefinedBy(TemporalAccessor temporal) {
<span class="nc bnc" id="L311" title="All 2 branches missed.">                if (isSupportedBy(temporal) == false) {</span>
<span class="nc" id="L312">                    throw new UnsupportedTemporalTypeException(&quot;Unsupported field: DayOfQuarter&quot;);</span>
                }
<span class="nc" id="L314">                long qoy = temporal.getLong(QUARTER_OF_YEAR);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">                if (qoy == 1) {</span>
<span class="nc" id="L316">                    long year = temporal.getLong(YEAR);</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                    return (IsoChronology.INSTANCE.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90));</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                } else if (qoy == 2) {</span>
<span class="nc" id="L319">                    return ValueRange.of(1, 91);</span>
<span class="nc bnc" id="L320" title="All 4 branches missed.">                } else if (qoy == 3 || qoy == 4) {</span>
<span class="nc" id="L321">                    return ValueRange.of(1, 92);</span>
                } // else value not from 1 to 4, so drop through
<span class="nc" id="L323">                return range();</span>
            }
            @Override
            public long getFrom(TemporalAccessor temporal) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">                if (isSupportedBy(temporal) == false) {</span>
<span class="nc" id="L328">                    throw new UnsupportedTemporalTypeException(&quot;Unsupported field: DayOfQuarter&quot;);</span>
                }
<span class="nc" id="L330">                int doy = temporal.get(DAY_OF_YEAR);</span>
<span class="nc" id="L331">                int moy = temporal.get(MONTH_OF_YEAR);</span>
<span class="nc" id="L332">                long year = temporal.getLong(YEAR);</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                return doy - QUARTER_DAYS[((moy - 1) / 3) + (IsoChronology.INSTANCE.isLeapYear(year) ? 4 : 0)];</span>
            }
            @SuppressWarnings(&quot;unchecked&quot;)
            @Override
            public &lt;R extends Temporal&gt; R adjustInto(R temporal, long newValue) {
                // calls getFrom() to check if supported
<span class="nc" id="L339">                long curValue = getFrom(temporal);</span>
<span class="nc" id="L340">                range().checkValidValue(newValue, this);  // leniently check from 1 to 92 TODO: check</span>
<span class="nc" id="L341">                return (R) temporal.with(DAY_OF_YEAR, temporal.getLong(DAY_OF_YEAR) + (newValue - curValue));</span>
            }
            @Override
            public ChronoLocalDate resolve(
                    Map&lt;TemporalField, Long&gt; fieldValues, TemporalAccessor partialTemporal, ResolverStyle resolverStyle) {
<span class="nc" id="L346">                Long yearLong = fieldValues.get(YEAR);</span>
<span class="nc" id="L347">                Long qoyLong = fieldValues.get(QUARTER_OF_YEAR);</span>
<span class="nc bnc" id="L348" title="All 4 branches missed.">                if (yearLong == null || qoyLong == null) {</span>
<span class="nc" id="L349">                    return null;</span>
                }
<span class="nc" id="L351">                int y = YEAR.checkValidIntValue(yearLong);  // always validate</span>
<span class="nc" id="L352">                long doq = fieldValues.get(DAY_OF_QUARTER);</span>
<span class="nc" id="L353">                ensureIso(partialTemporal);</span>
                LocalDate date;
<span class="nc bnc" id="L355" title="All 2 branches missed.">                if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L356">                    date = LocalDate.of(y, 1, 1).plusMonths(Math.multiplyExact(Math.subtractExact(qoyLong, 1), 3));</span>
<span class="nc" id="L357">                    doq = Math.subtractExact(doq, 1);</span>
                } else {
<span class="nc" id="L359">                    int qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);  // validated</span>
<span class="nc" id="L360">                    date = LocalDate.of(y, ((qoy - 1) * 3) + 1, 1);</span>
<span class="nc bnc" id="L361" title="All 4 branches missed.">                    if (doq &lt; 1 || doq &gt; 90) {</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">                        if (resolverStyle == ResolverStyle.STRICT) {</span>
<span class="nc" id="L363">                            rangeRefinedBy(date).checkValidValue(doq, this);  // only allow exact range</span>
                        } else {  // SMART
<span class="nc" id="L365">                            range().checkValidValue(doq, this);  // allow 1-92 rolling into next quarter</span>
                        }
                    }
<span class="nc" id="L368">                    doq--;</span>
                }
<span class="nc" id="L370">                fieldValues.remove(this);</span>
<span class="nc" id="L371">                fieldValues.remove(YEAR);</span>
<span class="nc" id="L372">                fieldValues.remove(QUARTER_OF_YEAR);</span>
<span class="nc" id="L373">                return date.plusDays(doq);</span>
            }
            @Override
            public String toString() {
<span class="nc" id="L377">                return &quot;DayOfQuarter&quot;;</span>
            }
        },
<span class="nc" id="L380">        QUARTER_OF_YEAR {</span>
            @Override
            public TemporalUnit getBaseUnit() {
<span class="nc" id="L383">                return QUARTER_YEARS;</span>
            }
            @Override
            public TemporalUnit getRangeUnit() {
<span class="nc" id="L387">                return YEARS;</span>
            }
            @Override
            public ValueRange range() {
<span class="nc" id="L391">                return ValueRange.of(1, 4);</span>
            }
            @Override
            public boolean isSupportedBy(TemporalAccessor temporal) {
<span class="nc bnc" id="L395" title="All 4 branches missed.">                return temporal.isSupported(MONTH_OF_YEAR) &amp;&amp; isIso(temporal);</span>
            }
            @Override
            public long getFrom(TemporalAccessor temporal) {
<span class="nc bnc" id="L399" title="All 2 branches missed.">                if (isSupportedBy(temporal) == false) {</span>
<span class="nc" id="L400">                    throw new UnsupportedTemporalTypeException(&quot;Unsupported field: QuarterOfYear&quot;);</span>
                }
<span class="nc" id="L402">                long moy = temporal.getLong(MONTH_OF_YEAR);</span>
<span class="nc" id="L403">                return ((moy + 2) / 3);</span>
            }
            @SuppressWarnings(&quot;unchecked&quot;)
            @Override
            public &lt;R extends Temporal&gt; R adjustInto(R temporal, long newValue) {
                // calls getFrom() to check if supported
<span class="nc" id="L409">                long curValue = getFrom(temporal);</span>
<span class="nc" id="L410">                range().checkValidValue(newValue, this);  // strictly check from 1 to 4</span>
<span class="nc" id="L411">                return (R) temporal.with(MONTH_OF_YEAR, temporal.getLong(MONTH_OF_YEAR) + (newValue - curValue) * 3);</span>
            }
            @Override
            public String toString() {
<span class="nc" id="L415">                return &quot;QuarterOfYear&quot;;</span>
            }
        },
<span class="nc" id="L418">        WEEK_OF_WEEK_BASED_YEAR {</span>
            @Override
            public String getDisplayName(Locale locale) {
<span class="nc" id="L421">                Objects.requireNonNull(locale, &quot;locale&quot;);</span>
<span class="nc" id="L422">                LocaleResources lr = LocaleProviderAdapter.getResourceBundleBased()</span>
<span class="nc" id="L423">                                            .getLocaleResources(locale);</span>
<span class="nc" id="L424">                ResourceBundle rb = lr.getJavaTimeFormatData();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">                return rb.containsKey(&quot;field.week&quot;) ? rb.getString(&quot;field.week&quot;) : toString();</span>
            }

            @Override
            public TemporalUnit getBaseUnit() {
<span class="nc" id="L430">                return WEEKS;</span>
            }
            @Override
            public TemporalUnit getRangeUnit() {
<span class="nc" id="L434">                return WEEK_BASED_YEARS;</span>
            }
            @Override
            public ValueRange range() {
<span class="nc" id="L438">                return ValueRange.of(1, 52, 53);</span>
            }
            @Override
            public boolean isSupportedBy(TemporalAccessor temporal) {
<span class="nc bnc" id="L442" title="All 4 branches missed.">                return temporal.isSupported(EPOCH_DAY) &amp;&amp; isIso(temporal);</span>
            }
            @Override
            public ValueRange rangeRefinedBy(TemporalAccessor temporal) {
<span class="nc bnc" id="L446" title="All 2 branches missed.">                if (isSupportedBy(temporal) == false) {</span>
<span class="nc" id="L447">                    throw new UnsupportedTemporalTypeException(&quot;Unsupported field: WeekOfWeekBasedYear&quot;);</span>
                }
<span class="nc" id="L449">                return getWeekRange(LocalDate.from(temporal));</span>
            }
            @Override
            public long getFrom(TemporalAccessor temporal) {
<span class="nc bnc" id="L453" title="All 2 branches missed.">                if (isSupportedBy(temporal) == false) {</span>
<span class="nc" id="L454">                    throw new UnsupportedTemporalTypeException(&quot;Unsupported field: WeekOfWeekBasedYear&quot;);</span>
                }
<span class="nc" id="L456">                return getWeek(LocalDate.from(temporal));</span>
            }
            @SuppressWarnings(&quot;unchecked&quot;)
            @Override
            public &lt;R extends Temporal&gt; R adjustInto(R temporal, long newValue) {
                // calls getFrom() to check if supported
<span class="nc" id="L462">                range().checkValidValue(newValue, this);  // lenient range</span>
<span class="nc" id="L463">                return (R) temporal.plus(Math.subtractExact(newValue, getFrom(temporal)), WEEKS);</span>
            }
            @Override
            public ChronoLocalDate resolve(
                    Map&lt;TemporalField, Long&gt; fieldValues, TemporalAccessor partialTemporal, ResolverStyle resolverStyle) {
<span class="nc" id="L468">                Long wbyLong = fieldValues.get(WEEK_BASED_YEAR);</span>
<span class="nc" id="L469">                Long dowLong = fieldValues.get(DAY_OF_WEEK);</span>
<span class="nc bnc" id="L470" title="All 4 branches missed.">                if (wbyLong == null || dowLong == null) {</span>
<span class="nc" id="L471">                    return null;</span>
                }
<span class="nc" id="L473">                int wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);  // always validate</span>
<span class="nc" id="L474">                long wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);</span>
<span class="nc" id="L475">                ensureIso(partialTemporal);</span>
<span class="nc" id="L476">                LocalDate date = LocalDate.of(wby, 1, 4);</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">                if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L478">                    long dow = dowLong;  // unvalidated</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">                    if (dow &gt; 7) {</span>
<span class="nc" id="L480">                        date = date.plusWeeks((dow - 1) / 7);</span>
<span class="nc" id="L481">                        dow = ((dow - 1) % 7) + 1;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">                    } else if (dow &lt; 1) {</span>
<span class="nc" id="L483">                        date = date.plusWeeks(Math.subtractExact(dow,  7) / 7);</span>
<span class="nc" id="L484">                        dow = ((dow + 6) % 7) + 1;</span>
                    }
<span class="nc" id="L486">                    date = date.plusWeeks(Math.subtractExact(wowby, 1)).with(DAY_OF_WEEK, dow);</span>
<span class="nc" id="L487">                } else {</span>
<span class="nc" id="L488">                    int dow = DAY_OF_WEEK.checkValidIntValue(dowLong);  // validated</span>
<span class="nc bnc" id="L489" title="All 4 branches missed.">                    if (wowby &lt; 1 || wowby &gt; 52) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                        if (resolverStyle == ResolverStyle.STRICT) {</span>
<span class="nc" id="L491">                            getWeekRange(date).checkValidValue(wowby, this);  // only allow exact range</span>
                        } else {  // SMART
<span class="nc" id="L493">                            range().checkValidValue(wowby, this);  // allow 1-53 rolling into next year</span>
                        }
                    }
<span class="nc" id="L496">                    date = date.plusWeeks(wowby - 1).with(DAY_OF_WEEK, dow);</span>
                }
<span class="nc" id="L498">                fieldValues.remove(this);</span>
<span class="nc" id="L499">                fieldValues.remove(WEEK_BASED_YEAR);</span>
<span class="nc" id="L500">                fieldValues.remove(DAY_OF_WEEK);</span>
<span class="nc" id="L501">                return date;</span>
            }
            @Override
            public String toString() {
<span class="nc" id="L505">                return &quot;WeekOfWeekBasedYear&quot;;</span>
            }
        },
<span class="nc" id="L508">        WEEK_BASED_YEAR {</span>
            @Override
            public TemporalUnit getBaseUnit() {
<span class="nc" id="L511">                return WEEK_BASED_YEARS;</span>
            }
            @Override
            public TemporalUnit getRangeUnit() {
<span class="nc" id="L515">                return FOREVER;</span>
            }
            @Override
            public ValueRange range() {
<span class="nc" id="L519">                return YEAR.range();</span>
            }
            @Override
            public boolean isSupportedBy(TemporalAccessor temporal) {
<span class="nc bnc" id="L523" title="All 4 branches missed.">                return temporal.isSupported(EPOCH_DAY) &amp;&amp; isIso(temporal);</span>
            }
            @Override
            public long getFrom(TemporalAccessor temporal) {
<span class="nc bnc" id="L527" title="All 2 branches missed.">                if (isSupportedBy(temporal) == false) {</span>
<span class="nc" id="L528">                    throw new UnsupportedTemporalTypeException(&quot;Unsupported field: WeekBasedYear&quot;);</span>
                }
<span class="nc" id="L530">                return getWeekBasedYear(LocalDate.from(temporal));</span>
            }
            @SuppressWarnings(&quot;unchecked&quot;)
            @Override
            public &lt;R extends Temporal&gt; R adjustInto(R temporal, long newValue) {
<span class="nc bnc" id="L535" title="All 2 branches missed.">                if (isSupportedBy(temporal) == false) {</span>
<span class="nc" id="L536">                    throw new UnsupportedTemporalTypeException(&quot;Unsupported field: WeekBasedYear&quot;);</span>
                }
<span class="nc" id="L538">                int newVal = range().checkValidIntValue(newValue, WEEK_BASED_YEAR);  // strict check</span>
<span class="nc" id="L539">                LocalDate date = LocalDate.from(temporal);</span>
<span class="nc" id="L540">                int week = getWeek(date);</span>
<span class="nc" id="L541">                date = date.withDayOfYear(180).withYear(newVal).with(WEEK_OF_WEEK_BASED_YEAR, week);</span>
<span class="nc" id="L542">                return (R) date.with(date);</span>
            }
            @Override
            public String toString() {
<span class="nc" id="L546">                return &quot;WeekBasedYear&quot;;</span>
            }
        };

        @Override
        public boolean isDateBased() {
<span class="nc" id="L552">            return true;</span>
        }

        @Override
        public boolean isTimeBased() {
<span class="nc" id="L557">            return false;</span>
        }

        @Override
        public ValueRange rangeRefinedBy(TemporalAccessor temporal) {
<span class="nc" id="L562">            return range();</span>
        }

        //-------------------------------------------------------------------------
<span class="nc" id="L566">        private static final int[] QUARTER_DAYS = {0, 90, 181, 273, 0, 91, 182, 274};</span>

        private static boolean isIso(TemporalAccessor temporal) {
<span class="nc" id="L569">            return Chronology.from(temporal).equals(IsoChronology.INSTANCE);</span>
        }

        private static void ensureIso(TemporalAccessor temporal) {
<span class="nc bnc" id="L573" title="All 2 branches missed.">            if (isIso(temporal) == false) {</span>
<span class="nc" id="L574">                throw new DateTimeException(&quot;Resolve requires IsoChronology&quot;);</span>
            }
<span class="nc" id="L576">        }</span>

        private static ValueRange getWeekRange(LocalDate date) {
<span class="nc" id="L579">            int wby = getWeekBasedYear(date);</span>
<span class="nc" id="L580">            date = date.withDayOfYear(1).withYear(wby);</span>
            // 53 weeks if standard year starts on Thursday, or Wed in a leap year
<span class="nc bnc" id="L582" title="All 6 branches missed.">            if (date.getDayOfWeek() == THURSDAY || (date.getDayOfWeek() == WEDNESDAY &amp;&amp; date.isLeapYear())) {</span>
<span class="nc" id="L583">                return ValueRange.of(1, 53);</span>
            }
<span class="nc" id="L585">            return ValueRange.of(1, 52);</span>
        }

        private static int getWeek(LocalDate date) {
<span class="nc" id="L589">            int dow0 = date.getDayOfWeek().ordinal();</span>
<span class="nc" id="L590">            int doy0 = date.getDayOfYear() - 1;</span>
<span class="nc" id="L591">            int doyThu0 = doy0 + (3 - dow0);  // adjust to mid-week Thursday (which is 3 indexed from zero)</span>
<span class="nc" id="L592">            int alignedWeek = doyThu0 / 7;</span>
<span class="nc" id="L593">            int firstThuDoy0 = doyThu0 - (alignedWeek * 7);</span>
<span class="nc" id="L594">            int firstMonDoy0 = firstThuDoy0 - 3;</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">            if (firstMonDoy0 &lt; -3) {</span>
<span class="nc" id="L596">                firstMonDoy0 += 7;</span>
            }
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (doy0 &lt; firstMonDoy0) {</span>
<span class="nc" id="L599">                return (int) getWeekRange(date.withDayOfYear(180).minusYears(1)).getMaximum();</span>
            }
<span class="nc" id="L601">            int week = ((doy0 - firstMonDoy0) / 7) + 1;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">            if (week == 53) {</span>
<span class="nc bnc" id="L603" title="All 8 branches missed.">                if ((firstMonDoy0 == -3 || (firstMonDoy0 == -2 &amp;&amp; date.isLeapYear())) == false) {</span>
<span class="nc" id="L604">                    week = 1;</span>
                }
            }
<span class="nc" id="L607">            return week;</span>
        }

        private static int getWeekBasedYear(LocalDate date) {
<span class="nc" id="L611">            int year = date.getYear();</span>
<span class="nc" id="L612">            int doy = date.getDayOfYear();</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">            if (doy &lt;= 3) {</span>
<span class="nc" id="L614">                int dow = date.getDayOfWeek().ordinal();</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">                if (doy - dow &lt; -2) {</span>
<span class="nc" id="L616">                    year--;</span>
                }
<span class="nc bnc" id="L618" title="All 2 branches missed.">            } else if (doy &gt;= 363) {</span>
<span class="nc" id="L619">                int dow = date.getDayOfWeek().ordinal();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">                doy = doy - 363 - (date.isLeapYear() ? 1 : 0);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                if (doy - dow &gt;= 0) {</span>
<span class="nc" id="L622">                    year++;</span>
                }
            }
<span class="nc" id="L625">            return year;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Implementation of the period unit.
     */
<span class="nc" id="L633">    private static enum Unit implements TemporalUnit {</span>

        /**
         * Unit that represents the concept of a week-based-year.
         */
<span class="nc" id="L638">        WEEK_BASED_YEARS(&quot;WeekBasedYears&quot;, Duration.ofSeconds(31556952L)),</span>
        /**
         * Unit that represents the concept of a quarter-year.
         */
<span class="nc" id="L642">        QUARTER_YEARS(&quot;QuarterYears&quot;, Duration.ofSeconds(31556952L / 4));</span>

        private final String name;
        private final Duration duration;

<span class="nc" id="L647">        private Unit(String name, Duration estimatedDuration) {</span>
<span class="nc" id="L648">            this.name = name;</span>
<span class="nc" id="L649">            this.duration = estimatedDuration;</span>
<span class="nc" id="L650">        }</span>

        @Override
        public Duration getDuration() {
<span class="nc" id="L654">            return duration;</span>
        }

        @Override
        public boolean isDurationEstimated() {
<span class="nc" id="L659">            return true;</span>
        }

        @Override
        public boolean isDateBased() {
<span class="nc" id="L664">            return true;</span>
        }

        @Override
        public boolean isTimeBased() {
<span class="nc" id="L669">            return false;</span>
        }

        @Override
        public boolean isSupportedBy(Temporal temporal) {
<span class="nc" id="L674">            return temporal.isSupported(EPOCH_DAY);</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public &lt;R extends Temporal&gt; R addTo(R temporal, long amount) {
<span class="nc bnc" id="L680" title="All 3 branches missed.">            switch (this) {</span>
                case WEEK_BASED_YEARS:
<span class="nc" id="L682">                    return (R) temporal.with(WEEK_BASED_YEAR,</span>
<span class="nc" id="L683">                            Math.addExact(temporal.get(WEEK_BASED_YEAR), amount));</span>
                case QUARTER_YEARS:
                    // no overflow (256 is multiple of 4)
<span class="nc" id="L686">                    return (R) temporal.plus(amount / 256, YEARS)</span>
<span class="nc" id="L687">                            .plus((amount % 256) * 3, MONTHS);</span>
                default:
<span class="nc" id="L689">                    throw new IllegalStateException(&quot;Unreachable&quot;);</span>
            }
        }

        @Override
        public long between(Temporal temporal1Inclusive, Temporal temporal2Exclusive) {
<span class="nc bnc" id="L695" title="All 2 branches missed.">            if (temporal1Inclusive.getClass() != temporal2Exclusive.getClass()) {</span>
<span class="nc" id="L696">                return temporal1Inclusive.until(temporal2Exclusive, this);</span>
            }
<span class="nc bnc" id="L698" title="All 3 branches missed.">            switch(this) {</span>
                case WEEK_BASED_YEARS:
<span class="nc" id="L700">                    return Math.subtractExact(temporal2Exclusive.getLong(WEEK_BASED_YEAR),</span>
<span class="nc" id="L701">                            temporal1Inclusive.getLong(WEEK_BASED_YEAR));</span>
                case QUARTER_YEARS:
<span class="nc" id="L703">                    return temporal1Inclusive.until(temporal2Exclusive, MONTHS) / 3;</span>
                default:
<span class="nc" id="L705">                    throw new IllegalStateException(&quot;Unreachable&quot;);</span>
            }
        }

        @Override
        public String toString() {
<span class="nc" id="L711">            return name;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>