<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WeekFields.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.time.temporal</a> &gt; <span class="el_source">WeekFields.java</span></div><h1>WeekFields.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Copyright (c) 2011-2012, Stephen Colebourne &amp; Michael Nascimento Santos
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of JSR-310 nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package java.time.temporal;

import static java.time.temporal.ChronoField.DAY_OF_MONTH;
import static java.time.temporal.ChronoField.DAY_OF_WEEK;
import static java.time.temporal.ChronoField.DAY_OF_YEAR;
import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
import static java.time.temporal.ChronoField.YEAR;
import static java.time.temporal.ChronoUnit.DAYS;
import static java.time.temporal.ChronoUnit.FOREVER;
import static java.time.temporal.ChronoUnit.MONTHS;
import static java.time.temporal.ChronoUnit.WEEKS;
import static java.time.temporal.ChronoUnit.YEARS;

import java.io.InvalidObjectException;
import java.io.Serializable;
import java.time.DateTimeException;
import java.time.DayOfWeek;
import java.time.chrono.ChronoLocalDate;
import java.time.chrono.Chronology;
import java.time.format.ResolverStyle;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.ResourceBundle;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import sun.util.locale.provider.CalendarDataUtility;
import sun.util.locale.provider.LocaleProviderAdapter;
import sun.util.locale.provider.LocaleResources;

/**
 * Localized definitions of the day-of-week, week-of-month and week-of-year fields.
 * &lt;p&gt;
 * A standard week is seven days long, but cultures have different definitions for some
 * other aspects of a week. This class represents the definition of the week, for the
 * purpose of providing {@link TemporalField} instances.
 * &lt;p&gt;
 * WeekFields provides five fields,
 * {@link #dayOfWeek()}, {@link #weekOfMonth()}, {@link #weekOfYear()},
 * {@link #weekOfWeekBasedYear()}, and {@link #weekBasedYear()}
 * that provide access to the values from any {@linkplain Temporal temporal object}.
 * &lt;p&gt;
 * The computations for day-of-week, week-of-month, and week-of-year are based
 * on the  {@linkplain ChronoField#YEAR proleptic-year},
 * {@linkplain ChronoField#MONTH_OF_YEAR month-of-year},
 * {@linkplain ChronoField#DAY_OF_MONTH day-of-month}, and
 * {@linkplain ChronoField#DAY_OF_WEEK ISO day-of-week} which are based on the
 * {@linkplain ChronoField#EPOCH_DAY epoch-day} and the chronology.
 * The values may not be aligned with the {@linkplain ChronoField#YEAR_OF_ERA year-of-Era}
 * depending on the Chronology.
 * &lt;p&gt;A week is defined by:
 * &lt;ul&gt;
 * &lt;li&gt;The first day-of-week.
 * For example, the ISO-8601 standard considers Monday to be the first day-of-week.
 * &lt;li&gt;The minimal number of days in the first week.
 * For example, the ISO-8601 standard counts the first week as needing at least 4 days.
 * &lt;/ul&gt;
 * Together these two values allow a year or month to be divided into weeks.
 *
 * &lt;h3&gt;Week of Month&lt;/h3&gt;
 * One field is used: week-of-month.
 * The calculation ensures that weeks never overlap a month boundary.
 * The month is divided into periods where each period starts on the defined first day-of-week.
 * The earliest period is referred to as week 0 if it has less than the minimal number of days
 * and week 1 if it has at least the minimal number of days.
 *
 * &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;3&quot; border=&quot;0&quot; style=&quot;text-align: left; width: 50%;&quot;&gt;
 * &lt;caption&gt;Examples of WeekFields&lt;/caption&gt;
 * &lt;tr&gt;&lt;th&gt;Date&lt;/th&gt;&lt;td&gt;Day-of-week&lt;/td&gt;
 *  &lt;td&gt;First day: Monday&lt;br&gt;Minimal days: 4&lt;/td&gt;&lt;td&gt;First day: Monday&lt;br&gt;Minimal days: 5&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2008-12-31&lt;/th&gt;&lt;td&gt;Wednesday&lt;/td&gt;
 *  &lt;td&gt;Week 5 of December 2008&lt;/td&gt;&lt;td&gt;Week 5 of December 2008&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2009-01-01&lt;/th&gt;&lt;td&gt;Thursday&lt;/td&gt;
 *  &lt;td&gt;Week 1 of January 2009&lt;/td&gt;&lt;td&gt;Week 0 of January 2009&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2009-01-04&lt;/th&gt;&lt;td&gt;Sunday&lt;/td&gt;
 *  &lt;td&gt;Week 1 of January 2009&lt;/td&gt;&lt;td&gt;Week 0 of January 2009&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2009-01-05&lt;/th&gt;&lt;td&gt;Monday&lt;/td&gt;
 *  &lt;td&gt;Week 2 of January 2009&lt;/td&gt;&lt;td&gt;Week 1 of January 2009&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;h3&gt;Week of Year&lt;/h3&gt;
 * One field is used: week-of-year.
 * The calculation ensures that weeks never overlap a year boundary.
 * The year is divided into periods where each period starts on the defined first day-of-week.
 * The earliest period is referred to as week 0 if it has less than the minimal number of days
 * and week 1 if it has at least the minimal number of days.
 *
 * &lt;h3&gt;Week Based Year&lt;/h3&gt;
 * Two fields are used for week-based-year, one for the
 * {@link #weekOfWeekBasedYear() week-of-week-based-year} and one for
 * {@link #weekBasedYear() week-based-year}.  In a week-based-year, each week
 * belongs to only a single year.  Week 1 of a year is the first week that
 * starts on the first day-of-week and has at least the minimum number of days.
 * The first and last weeks of a year may contain days from the
 * previous calendar year or next calendar year respectively.
 *
 * &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;3&quot; border=&quot;0&quot; style=&quot;text-align: left; width: 50%;&quot;&gt;
 * &lt;caption&gt;Examples of WeekFields for week-based-year&lt;/caption&gt;
 * &lt;tr&gt;&lt;th&gt;Date&lt;/th&gt;&lt;td&gt;Day-of-week&lt;/td&gt;
 *  &lt;td&gt;First day: Monday&lt;br&gt;Minimal days: 4&lt;/td&gt;&lt;td&gt;First day: Monday&lt;br&gt;Minimal days: 5&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2008-12-31&lt;/th&gt;&lt;td&gt;Wednesday&lt;/td&gt;
 *  &lt;td&gt;Week 1 of 2009&lt;/td&gt;&lt;td&gt;Week 53 of 2008&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2009-01-01&lt;/th&gt;&lt;td&gt;Thursday&lt;/td&gt;
 *  &lt;td&gt;Week 1 of 2009&lt;/td&gt;&lt;td&gt;Week 53 of 2008&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2009-01-04&lt;/th&gt;&lt;td&gt;Sunday&lt;/td&gt;
 *  &lt;td&gt;Week 1 of 2009&lt;/td&gt;&lt;td&gt;Week 53 of 2008&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2009-01-05&lt;/th&gt;&lt;td&gt;Monday&lt;/td&gt;
 *  &lt;td&gt;Week 2 of 2009&lt;/td&gt;&lt;td&gt;Week 1 of 2009&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
 */
public final class WeekFields implements Serializable {
    // implementation notes
    // querying week-of-month or week-of-year should return the week value bound within the month/year
    // however, setting the week value should be lenient (use plus/minus weeks)
    // allow week-of-month outer range [0 to 6]
    // allow week-of-year outer range [0 to 54]
    // this is because callers shouldn't be expected to know the details of validity

    /**
     * The cache of rules by firstDayOfWeek plus minimalDays.
     * Initialized first to be available for definition of ISO, etc.
     */
<span class="nc" id="L189">    private static final ConcurrentMap&lt;String, WeekFields&gt; CACHE = new ConcurrentHashMap&lt;&gt;(4, 0.75f, 2);</span>

    /**
     * The ISO-8601 definition, where a week starts on Monday and the first week
     * has a minimum of 4 days.
     * &lt;p&gt;
     * The ISO-8601 standard defines a calendar system based on weeks.
     * It uses the week-based-year and week-of-week-based-year concepts to split
     * up the passage of days instead of the standard year/month/day.
     * &lt;p&gt;
     * Note that the first week may start in the previous calendar year.
     * Note also that the first few days of a calendar year may be in the
     * week-based-year corresponding to the previous calendar year.
     */
<span class="nc" id="L203">    public static final WeekFields ISO = new WeekFields(DayOfWeek.MONDAY, 4);</span>

    /**
     * The common definition of a week that starts on Sunday and the first week
     * has a minimum of 1 day.
     * &lt;p&gt;
     * Defined as starting on Sunday and with a minimum of 1 day in the month.
     * This week definition is in use in the US and other European countries.
     */
<span class="nc" id="L212">    public static final WeekFields SUNDAY_START = WeekFields.of(DayOfWeek.SUNDAY, 1);</span>

    /**
     * The unit that represents week-based-years for the purpose of addition and subtraction.
     * &lt;p&gt;
     * This allows a number of week-based-years to be added to, or subtracted from, a date.
     * The unit is equal to either 52 or 53 weeks.
     * The estimated duration of a week-based-year is the same as that of a standard ISO
     * year at {@code 365.2425 Days}.
     * &lt;p&gt;
     * The rules for addition add the number of week-based-years to the existing value
     * for the week-based-year field retaining the week-of-week-based-year
     * and day-of-week, unless the week number it too large for the target year.
     * In that case, the week is set to the last week of the year
     * with the same day-of-week.
     * &lt;p&gt;
     * This unit is an immutable and thread-safe singleton.
     */
<span class="nc" id="L230">    public static final TemporalUnit WEEK_BASED_YEARS = IsoFields.WEEK_BASED_YEARS;</span>

    /**
     * Serialization version.
     */
    private static final long serialVersionUID = -1177360819670808121L;

    /**
     * The first day-of-week.
     */
    private final DayOfWeek firstDayOfWeek;
    /**
     * The minimal number of days in the first week.
     */
    private final int minimalDays;
    /**
     * The field used to access the computed DayOfWeek.
     */
<span class="nc" id="L248">    private final transient TemporalField dayOfWeek = ComputedDayOfField.ofDayOfWeekField(this);</span>
    /**
     * The field used to access the computed WeekOfMonth.
     */
<span class="nc" id="L252">    private final transient TemporalField weekOfMonth = ComputedDayOfField.ofWeekOfMonthField(this);</span>
    /**
     * The field used to access the computed WeekOfYear.
     */
<span class="nc" id="L256">    private final transient TemporalField weekOfYear = ComputedDayOfField.ofWeekOfYearField(this);</span>
    /**
     * The field that represents the week-of-week-based-year.
     * &lt;p&gt;
     * This field allows the week of the week-based-year value to be queried and set.
     * &lt;p&gt;
     * This unit is an immutable and thread-safe singleton.
     */
<span class="nc" id="L264">    private final transient TemporalField weekOfWeekBasedYear = ComputedDayOfField.ofWeekOfWeekBasedYearField(this);</span>
    /**
     * The field that represents the week-based-year.
     * &lt;p&gt;
     * This field allows the week-based-year value to be queried and set.
     * &lt;p&gt;
     * This unit is an immutable and thread-safe singleton.
     */
<span class="nc" id="L272">    private final transient TemporalField weekBasedYear = ComputedDayOfField.ofWeekBasedYearField(this);</span>

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code WeekFields} appropriate for a locale.
     * &lt;p&gt;
     * This will look up appropriate values from the provider of localization data.
     *
     * @param locale  the locale to use, not null
     * @return the week-definition, not null
     */
    public static WeekFields of(Locale locale) {
<span class="nc" id="L284">        Objects.requireNonNull(locale, &quot;locale&quot;);</span>
<span class="nc" id="L285">        locale = new Locale(locale.getLanguage(), locale.getCountry());  // elminate variants</span>

<span class="nc" id="L287">        int calDow = CalendarDataUtility.retrieveFirstDayOfWeek(locale);</span>
<span class="nc" id="L288">        DayOfWeek dow = DayOfWeek.SUNDAY.plus(calDow - 1);</span>
<span class="nc" id="L289">        int minDays = CalendarDataUtility.retrieveMinimalDaysInFirstWeek(locale);</span>
<span class="nc" id="L290">        return WeekFields.of(dow, minDays);</span>
    }

    /**
     * Obtains an instance of {@code WeekFields} from the first day-of-week and minimal days.
     * &lt;p&gt;
     * The first day-of-week defines the ISO {@code DayOfWeek} that is day 1 of the week.
     * The minimal number of days in the first week defines how many days must be present
     * in a month or year, starting from the first day-of-week, before the week is counted
     * as the first week. A value of 1 will count the first day of the month or year as part
     * of the first week, whereas a value of 7 will require the whole seven days to be in
     * the new month or year.
     * &lt;p&gt;
     * WeekFields instances are singletons; for each unique combination
     * of {@code firstDayOfWeek} and {@code minimalDaysInFirstWeek} the
     * the same instance will be returned.
     *
     * @param firstDayOfWeek  the first day of the week, not null
     * @param minimalDaysInFirstWeek  the minimal number of days in the first week, from 1 to 7
     * @return the week-definition, not null
     * @throws IllegalArgumentException if the minimal days value is less than one
     *      or greater than 7
     */
    public static WeekFields of(DayOfWeek firstDayOfWeek, int minimalDaysInFirstWeek) {
<span class="nc" id="L314">        String key = firstDayOfWeek.toString() + minimalDaysInFirstWeek;</span>
<span class="nc" id="L315">        WeekFields rules = CACHE.get(key);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (rules == null) {</span>
<span class="nc" id="L317">            rules = new WeekFields(firstDayOfWeek, minimalDaysInFirstWeek);</span>
<span class="nc" id="L318">            CACHE.putIfAbsent(key, rules);</span>
<span class="nc" id="L319">            rules = CACHE.get(key);</span>
        }
<span class="nc" id="L321">        return rules;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Creates an instance of the definition.
     *
     * @param firstDayOfWeek  the first day of the week, not null
     * @param minimalDaysInFirstWeek  the minimal number of days in the first week, from 1 to 7
     * @throws IllegalArgumentException if the minimal days value is invalid
     */
<span class="nc" id="L332">    private WeekFields(DayOfWeek firstDayOfWeek, int minimalDaysInFirstWeek) {</span>
<span class="nc" id="L333">        Objects.requireNonNull(firstDayOfWeek, &quot;firstDayOfWeek&quot;);</span>
<span class="nc bnc" id="L334" title="All 4 branches missed.">        if (minimalDaysInFirstWeek &lt; 1 || minimalDaysInFirstWeek &gt; 7) {</span>
<span class="nc" id="L335">            throw new IllegalArgumentException(&quot;Minimal number of days is invalid&quot;);</span>
        }
<span class="nc" id="L337">        this.firstDayOfWeek = firstDayOfWeek;</span>
<span class="nc" id="L338">        this.minimalDays = minimalDaysInFirstWeek;</span>
<span class="nc" id="L339">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Return the singleton WeekFields associated with the
     * {@code firstDayOfWeek} and {@code minimalDays}.
     * @return the singleton WeekFields for the firstDayOfWeek and minimalDays.
     * @throws InvalidObjectException if the serialized object has invalid
     *     values for firstDayOfWeek or minimalDays.
     */
    private Object readResolve() throws InvalidObjectException {
        try {
<span class="nc" id="L351">            return WeekFields.of(firstDayOfWeek, minimalDays);</span>
<span class="nc" id="L352">        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L353">            throw new InvalidObjectException(&quot;Invalid serialized WeekFields: &quot; + iae.getMessage());</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the first day-of-week.
     * &lt;p&gt;
     * The first day-of-week varies by culture.
     * For example, the US uses Sunday, while France and the ISO-8601 standard use Monday.
     * This method returns the first day using the standard {@code DayOfWeek} enum.
     *
     * @return the first day-of-week, not null
     */
    public DayOfWeek getFirstDayOfWeek() {
<span class="nc" id="L368">        return firstDayOfWeek;</span>
    }

    /**
     * Gets the minimal number of days in the first week.
     * &lt;p&gt;
     * The number of days considered to define the first week of a month or year
     * varies by culture.
     * For example, the ISO-8601 requires 4 days (more than half a week) to
     * be present before counting the first week.
     *
     * @return the minimal number of days in the first week of a month or year, from 1 to 7
     */
    public int getMinimalDaysInFirstWeek() {
<span class="nc" id="L382">        return minimalDays;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a field to access the day of week based on this {@code WeekFields}.
     * &lt;p&gt;
     * This is similar to {@link ChronoField#DAY_OF_WEEK} but uses values for
     * the day-of-week based on this {@code WeekFields}.
     * The days are numbered from 1 to 7 where the
     * {@link #getFirstDayOfWeek() first day-of-week} is assigned the value 1.
     * &lt;p&gt;
     * For example, if the first day-of-week is Sunday, then that will have the
     * value 1, with other days ranging from Monday as 2 to Saturday as 7.
     * &lt;p&gt;
     * In the resolving phase of parsing, a localized day-of-week will be converted
     * to a standardized {@code ChronoField} day-of-week.
     * The day-of-week must be in the valid range 1 to 7.
     * Other fields in this class build dates using the standardized day-of-week.
     *
     * @return a field providing access to the day-of-week with localized numbering, not null
     */
    public TemporalField dayOfWeek() {
<span class="nc" id="L405">        return dayOfWeek;</span>
    }

    /**
     * Returns a field to access the week of month based on this {@code WeekFields}.
     * &lt;p&gt;
     * This represents the concept of the count of weeks within the month where weeks
     * start on a fixed day-of-week, such as Monday.
     * This field is typically used with {@link WeekFields#dayOfWeek()}.
     * &lt;p&gt;
     * Week one (1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
     * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the month.
     * Thus, week one may start up to {@code minDays} days before the start of the month.
     * If the first week starts after the start of the month then the period before is week zero (0).
     * &lt;p&gt;
     * For example:&lt;br&gt;
     * - if the 1st day of the month is a Monday, week one starts on the 1st and there is no week zero&lt;br&gt;
     * - if the 2nd day of the month is a Monday, week one starts on the 2nd and the 1st is in week zero&lt;br&gt;
     * - if the 4th day of the month is a Monday, week one starts on the 4th and the 1st to 3rd is in week zero&lt;br&gt;
     * - if the 5th day of the month is a Monday, week two starts on the 5th and the 1st to 4th is in week one&lt;br&gt;
     * &lt;p&gt;
     * This field can be used with any calendar system.
     * &lt;p&gt;
     * In the resolving phase of parsing, a date can be created from a year,
     * week-of-month, month-of-year and day-of-week.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#STRICT strict mode}, all four fields are
     * validated against their range of valid values. The week-of-month field
     * is validated to ensure that the resulting month is the month requested.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#SMART smart mode}, all four fields are
     * validated against their range of valid values. The week-of-month field
     * is validated from 0 to 6, meaning that the resulting date can be in a
     * different month to that specified.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
     * are validated against the range of valid values. The resulting date is calculated
     * equivalent to the following four stage approach.
     * First, create a date on the first day of the first week of January in the requested year.
     * Then take the month-of-year, subtract one, and add the amount in months to the date.
     * Then take the week-of-month, subtract one, and add the amount in weeks to the date.
     * Finally, adjust to the correct day-of-week within the localized week.
     *
     * @return a field providing access to the week-of-month, not null
     */
    public TemporalField weekOfMonth() {
<span class="nc" id="L451">        return weekOfMonth;</span>
    }

    /**
     * Returns a field to access the week of year based on this {@code WeekFields}.
     * &lt;p&gt;
     * This represents the concept of the count of weeks within the year where weeks
     * start on a fixed day-of-week, such as Monday.
     * This field is typically used with {@link WeekFields#dayOfWeek()}.
     * &lt;p&gt;
     * Week one(1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
     * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.
     * Thus, week one may start up to {@code minDays} days before the start of the year.
     * If the first week starts after the start of the year then the period before is week zero (0).
     * &lt;p&gt;
     * For example:&lt;br&gt;
     * - if the 1st day of the year is a Monday, week one starts on the 1st and there is no week zero&lt;br&gt;
     * - if the 2nd day of the year is a Monday, week one starts on the 2nd and the 1st is in week zero&lt;br&gt;
     * - if the 4th day of the year is a Monday, week one starts on the 4th and the 1st to 3rd is in week zero&lt;br&gt;
     * - if the 5th day of the year is a Monday, week two starts on the 5th and the 1st to 4th is in week one&lt;br&gt;
     * &lt;p&gt;
     * This field can be used with any calendar system.
     * &lt;p&gt;
     * In the resolving phase of parsing, a date can be created from a year,
     * week-of-year and day-of-week.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
     * validated against their range of valid values. The week-of-year field
     * is validated to ensure that the resulting year is the year requested.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
     * validated against their range of valid values. The week-of-year field
     * is validated from 0 to 54, meaning that the resulting date can be in a
     * different year to that specified.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
     * are validated against the range of valid values. The resulting date is calculated
     * equivalent to the following three stage approach.
     * First, create a date on the first day of the first week in the requested year.
     * Then take the week-of-year, subtract one, and add the amount in weeks to the date.
     * Finally, adjust to the correct day-of-week within the localized week.
     *
     * @return a field providing access to the week-of-year, not null
     */
    public TemporalField weekOfYear() {
<span class="nc" id="L496">        return weekOfYear;</span>
    }

    /**
     * Returns a field to access the week of a week-based-year based on this {@code WeekFields}.
     * &lt;p&gt;
     * This represents the concept of the count of weeks within the year where weeks
     * start on a fixed day-of-week, such as Monday and each week belongs to exactly one year.
     * This field is typically used with {@link WeekFields#dayOfWeek()} and
     * {@link WeekFields#weekBasedYear()}.
     * &lt;p&gt;
     * Week one(1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
     * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.
     * If the first week starts after the start of the year then the period before
     * is in the last week of the previous year.
     * &lt;p&gt;
     * For example:&lt;br&gt;
     * - if the 1st day of the year is a Monday, week one starts on the 1st&lt;br&gt;
     * - if the 2nd day of the year is a Monday, week one starts on the 2nd and
     *   the 1st is in the last week of the previous year&lt;br&gt;
     * - if the 4th day of the year is a Monday, week one starts on the 4th and
     *   the 1st to 3rd is in the last week of the previous year&lt;br&gt;
     * - if the 5th day of the year is a Monday, week two starts on the 5th and
     *   the 1st to 4th is in week one&lt;br&gt;
     * &lt;p&gt;
     * This field can be used with any calendar system.
     * &lt;p&gt;
     * In the resolving phase of parsing, a date can be created from a week-based-year,
     * week-of-year and day-of-week.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
     * validated against their range of valid values. The week-of-year field
     * is validated to ensure that the resulting week-based-year is the
     * week-based-year requested.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
     * validated against their range of valid values. The week-of-week-based-year field
     * is validated from 1 to 53, meaning that the resulting date can be in the
     * following week-based-year to that specified.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
     * are validated against the range of valid values. The resulting date is calculated
     * equivalent to the following three stage approach.
     * First, create a date on the first day of the first week in the requested week-based-year.
     * Then take the week-of-week-based-year, subtract one, and add the amount in weeks to the date.
     * Finally, adjust to the correct day-of-week within the localized week.
     *
     * @return a field providing access to the week-of-week-based-year, not null
     */
    public TemporalField weekOfWeekBasedYear() {
<span class="nc" id="L546">        return weekOfWeekBasedYear;</span>
    }

    /**
     * Returns a field to access the year of a week-based-year based on this {@code WeekFields}.
     * &lt;p&gt;
     * This represents the concept of the year where weeks start on a fixed day-of-week,
     * such as Monday and each week belongs to exactly one year.
     * This field is typically used with {@link WeekFields#dayOfWeek()} and
     * {@link WeekFields#weekOfWeekBasedYear()}.
     * &lt;p&gt;
     * Week one(1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
     * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.
     * Thus, week one may start before the start of the year.
     * If the first week starts after the start of the year then the period before
     * is in the last week of the previous year.
     * &lt;p&gt;
     * This field can be used with any calendar system.
     * &lt;p&gt;
     * In the resolving phase of parsing, a date can be created from a week-based-year,
     * week-of-year and day-of-week.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
     * validated against their range of valid values. The week-of-year field
     * is validated to ensure that the resulting week-based-year is the
     * week-based-year requested.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
     * validated against their range of valid values. The week-of-week-based-year field
     * is validated from 1 to 53, meaning that the resulting date can be in the
     * following week-based-year to that specified.
     * &lt;p&gt;
     * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
     * are validated against the range of valid values. The resulting date is calculated
     * equivalent to the following three stage approach.
     * First, create a date on the first day of the first week in the requested week-based-year.
     * Then take the week-of-week-based-year, subtract one, and add the amount in weeks to the date.
     * Finally, adjust to the correct day-of-week within the localized week.
     *
     * @return a field providing access to the week-based-year, not null
     */
    public TemporalField weekBasedYear() {
<span class="nc" id="L588">        return weekBasedYear;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this {@code WeekFields} is equal to the specified object.
     * &lt;p&gt;
     * The comparison is based on the entire state of the rules, which is
     * the first day-of-week and minimal days.
     *
     * @param object  the other rules to compare to, null returns false
     * @return true if this is equal to the specified rules
     */
    @Override
    public boolean equals(Object object) {
<span class="nc bnc" id="L603" title="All 2 branches missed.">        if (this == object) {</span>
<span class="nc" id="L604">            return true;</span>
        }
<span class="nc bnc" id="L606" title="All 2 branches missed.">        if (object instanceof WeekFields) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">            return hashCode() == object.hashCode();</span>
        }
<span class="nc" id="L609">        return false;</span>
    }

    /**
     * A hash code for this {@code WeekFields}.
     *
     * @return a suitable hash code
     */
    @Override
    public int hashCode() {
<span class="nc" id="L619">        return firstDayOfWeek.ordinal() * 7 + minimalDays;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * A string representation of this {@code WeekFields} instance.
     *
     * @return the string representation, not null
     */
    @Override
    public String toString() {
<span class="nc" id="L630">        return &quot;WeekFields[&quot; + firstDayOfWeek + ',' + minimalDays + ']';</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Field type that computes DayOfWeek, WeekOfMonth, and WeekOfYear
     * based on a WeekFields.
     * A separate Field instance is required for each different WeekFields;
     * combination of start of week and minimum number of days.
     * Constructors are provided to create fields for DayOfWeek, WeekOfMonth,
     * and WeekOfYear.
     */
    static class ComputedDayOfField implements TemporalField {

        /**
         * Returns a field to access the day of week,
         * computed based on a WeekFields.
         * &lt;p&gt;
         * The WeekDefintion of the first day of the week is used with
         * the ISO DAY_OF_WEEK field to compute week boundaries.
         */
        static ComputedDayOfField ofDayOfWeekField(WeekFields weekDef) {
<span class="nc" id="L652">            return new ComputedDayOfField(&quot;DayOfWeek&quot;, weekDef, DAYS, WEEKS, DAY_OF_WEEK_RANGE);</span>
        }

        /**
         * Returns a field to access the week of month,
         * computed based on a WeekFields.
         * @see WeekFields#weekOfMonth()
         */
        static ComputedDayOfField ofWeekOfMonthField(WeekFields weekDef) {
<span class="nc" id="L661">            return new ComputedDayOfField(&quot;WeekOfMonth&quot;, weekDef, WEEKS, MONTHS, WEEK_OF_MONTH_RANGE);</span>
        }

        /**
         * Returns a field to access the week of year,
         * computed based on a WeekFields.
         * @see WeekFields#weekOfYear()
         */
        static ComputedDayOfField ofWeekOfYearField(WeekFields weekDef) {
<span class="nc" id="L670">            return new ComputedDayOfField(&quot;WeekOfYear&quot;, weekDef, WEEKS, YEARS, WEEK_OF_YEAR_RANGE);</span>
        }

        /**
         * Returns a field to access the week of week-based-year,
         * computed based on a WeekFields.
         * @see WeekFields#weekOfWeekBasedYear()
         */
        static ComputedDayOfField ofWeekOfWeekBasedYearField(WeekFields weekDef) {
<span class="nc" id="L679">            return new ComputedDayOfField(&quot;WeekOfWeekBasedYear&quot;, weekDef, WEEKS, IsoFields.WEEK_BASED_YEARS, WEEK_OF_YEAR_RANGE);</span>
        }

        /**
         * Returns a field to access the week of week-based-year,
         * computed based on a WeekFields.
         * @see WeekFields#weekBasedYear()
         */
        static ComputedDayOfField ofWeekBasedYearField(WeekFields weekDef) {
<span class="nc" id="L688">            return new ComputedDayOfField(&quot;WeekBasedYear&quot;, weekDef, IsoFields.WEEK_BASED_YEARS, FOREVER, ChronoField.YEAR.range());</span>
        }

        /**
         * Return a new week-based-year date of the Chronology, year, week-of-year,
         * and dow of week.
         * @param chrono The chronology of the new date
         * @param yowby the year of the week-based-year
         * @param wowby the week of the week-based-year
         * @param dow the day of the week
         * @return a ChronoLocalDate for the requested year, week of year, and day of week
         */
        private ChronoLocalDate ofWeekBasedYear(Chronology chrono,
                int yowby, int wowby, int dow) {
<span class="nc" id="L702">            ChronoLocalDate date = chrono.date(yowby, 1, 1);</span>
<span class="nc" id="L703">            int ldow = localizedDayOfWeek(date);</span>
<span class="nc" id="L704">            int offset = startOfWeekOffset(1, ldow);</span>

            // Clamp the week of year to keep it in the same year
<span class="nc" id="L707">            int yearLen = date.lengthOfYear();</span>
<span class="nc" id="L708">            int newYearWeek = computeWeek(offset, yearLen + weekDef.getMinimalDaysInFirstWeek());</span>
<span class="nc" id="L709">            wowby = Math.min(wowby, newYearWeek - 1);</span>

<span class="nc" id="L711">            int days = -offset + (dow - 1) + (wowby - 1) * 7;</span>
<span class="nc" id="L712">            return date.plus(days, DAYS);</span>
        }

        private final String name;
        private final WeekFields weekDef;
        private final TemporalUnit baseUnit;
        private final TemporalUnit rangeUnit;
        private final ValueRange range;

<span class="nc" id="L721">        private ComputedDayOfField(String name, WeekFields weekDef, TemporalUnit baseUnit, TemporalUnit rangeUnit, ValueRange range) {</span>
<span class="nc" id="L722">            this.name = name;</span>
<span class="nc" id="L723">            this.weekDef = weekDef;</span>
<span class="nc" id="L724">            this.baseUnit = baseUnit;</span>
<span class="nc" id="L725">            this.rangeUnit = rangeUnit;</span>
<span class="nc" id="L726">            this.range = range;</span>
<span class="nc" id="L727">        }</span>

<span class="nc" id="L729">        private static final ValueRange DAY_OF_WEEK_RANGE = ValueRange.of(1, 7);</span>
<span class="nc" id="L730">        private static final ValueRange WEEK_OF_MONTH_RANGE = ValueRange.of(0, 1, 4, 6);</span>
<span class="nc" id="L731">        private static final ValueRange WEEK_OF_YEAR_RANGE = ValueRange.of(0, 1, 52, 54);</span>

        @Override
        public long getFrom(TemporalAccessor temporal) {
<span class="nc bnc" id="L735" title="All 2 branches missed.">            if (rangeUnit == WEEKS) {  // day-of-week</span>
<span class="nc" id="L736">                return localizedDayOfWeek(temporal);</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">            } else if (rangeUnit == MONTHS) {  // week-of-month</span>
<span class="nc" id="L738">                return localizedWeekOfMonth(temporal);</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">            } else if (rangeUnit == YEARS) {  // week-of-year</span>
<span class="nc" id="L740">                return localizedWeekOfYear(temporal);</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">            } else if (rangeUnit == WEEK_BASED_YEARS) {</span>
<span class="nc" id="L742">                return localizedWeekOfWeekBasedYear(temporal);</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">            } else if (rangeUnit == FOREVER) {</span>
<span class="nc" id="L744">                return localizedWeekBasedYear(temporal);</span>
            } else {
<span class="nc" id="L746">                throw new IllegalStateException(&quot;unreachable, rangeUnit: &quot; + rangeUnit + &quot;, this: &quot; + this);</span>
            }
        }

        private int localizedDayOfWeek(TemporalAccessor temporal) {
<span class="nc" id="L751">            int sow = weekDef.getFirstDayOfWeek().getValue();</span>
<span class="nc" id="L752">            int isoDow = temporal.get(DAY_OF_WEEK);</span>
<span class="nc" id="L753">            return Math.floorMod(isoDow - sow, 7) + 1;</span>
        }

        private int localizedDayOfWeek(int isoDow) {
<span class="nc" id="L757">            int sow = weekDef.getFirstDayOfWeek().getValue();</span>
<span class="nc" id="L758">            return Math.floorMod(isoDow - sow, 7) + 1;</span>
        }

        private long localizedWeekOfMonth(TemporalAccessor temporal) {
<span class="nc" id="L762">            int dow = localizedDayOfWeek(temporal);</span>
<span class="nc" id="L763">            int dom = temporal.get(DAY_OF_MONTH);</span>
<span class="nc" id="L764">            int offset = startOfWeekOffset(dom, dow);</span>
<span class="nc" id="L765">            return computeWeek(offset, dom);</span>
        }

        private long localizedWeekOfYear(TemporalAccessor temporal) {
<span class="nc" id="L769">            int dow = localizedDayOfWeek(temporal);</span>
<span class="nc" id="L770">            int doy = temporal.get(DAY_OF_YEAR);</span>
<span class="nc" id="L771">            int offset = startOfWeekOffset(doy, dow);</span>
<span class="nc" id="L772">            return computeWeek(offset, doy);</span>
        }

        /**
         * Returns the year of week-based-year for the temporal.
         * The year can be the previous year, the current year, or the next year.
         * @param temporal a date of any chronology, not null
         * @return the year of week-based-year for the date
         */
        private int localizedWeekBasedYear(TemporalAccessor temporal) {
<span class="nc" id="L782">            int dow = localizedDayOfWeek(temporal);</span>
<span class="nc" id="L783">            int year = temporal.get(YEAR);</span>
<span class="nc" id="L784">            int doy = temporal.get(DAY_OF_YEAR);</span>
<span class="nc" id="L785">            int offset = startOfWeekOffset(doy, dow);</span>
<span class="nc" id="L786">            int week = computeWeek(offset, doy);</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (week == 0) {</span>
                // Day is in end of week of previous year; return the previous year
<span class="nc" id="L789">                return year - 1;</span>
            } else {
                // If getting close to end of year, use higher precision logic
                // Check if date of year is in partial week associated with next year
<span class="nc" id="L793">                ValueRange dayRange = temporal.range(DAY_OF_YEAR);</span>
<span class="nc" id="L794">                int yearLen = (int)dayRange.getMaximum();</span>
<span class="nc" id="L795">                int newYearWeek = computeWeek(offset, yearLen + weekDef.getMinimalDaysInFirstWeek());</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">                if (week &gt;= newYearWeek) {</span>
<span class="nc" id="L797">                    return year + 1;</span>
                }
            }
<span class="nc" id="L800">            return year;</span>
        }

        /**
         * Returns the week of week-based-year for the temporal.
         * The week can be part of the previous year, the current year,
         * or the next year depending on the week start and minimum number
         * of days.
         * @param temporal  a date of any chronology
         * @return the week of the year
         * @see #localizedWeekBasedYear(java.time.temporal.TemporalAccessor)
         */
        private int localizedWeekOfWeekBasedYear(TemporalAccessor temporal) {
<span class="nc" id="L813">            int dow = localizedDayOfWeek(temporal);</span>
<span class="nc" id="L814">            int doy = temporal.get(DAY_OF_YEAR);</span>
<span class="nc" id="L815">            int offset = startOfWeekOffset(doy, dow);</span>
<span class="nc" id="L816">            int week = computeWeek(offset, doy);</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">            if (week == 0) {</span>
                // Day is in end of week of previous year
                // Recompute from the last day of the previous year
<span class="nc" id="L820">                ChronoLocalDate date = Chronology.from(temporal).date(temporal);</span>
<span class="nc" id="L821">                date = date.minus(doy, DAYS);   // Back down into previous year</span>
<span class="nc" id="L822">                return localizedWeekOfWeekBasedYear(date);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">            } else if (week &gt; 50) {</span>
                // If getting close to end of year, use higher precision logic
                // Check if date of year is in partial week associated with next year
<span class="nc" id="L826">                ValueRange dayRange = temporal.range(DAY_OF_YEAR);</span>
<span class="nc" id="L827">                int yearLen = (int)dayRange.getMaximum();</span>
<span class="nc" id="L828">                int newYearWeek = computeWeek(offset, yearLen + weekDef.getMinimalDaysInFirstWeek());</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">                if (week &gt;= newYearWeek) {</span>
                    // Overlaps with week of following year; reduce to week in following year
<span class="nc" id="L831">                    week = week - newYearWeek + 1;</span>
                }
            }
<span class="nc" id="L834">            return week;</span>
        }

        /**
         * Returns an offset to align week start with a day of month or day of year.
         *
         * @param day  the day; 1 through infinity
         * @param dow  the day of the week of that day; 1 through 7
         * @return  an offset in days to align a day with the start of the first 'full' week
         */
        private int startOfWeekOffset(int day, int dow) {
            // offset of first day corresponding to the day of week in first 7 days (zero origin)
<span class="nc" id="L846">            int weekStart = Math.floorMod(day - dow, 7);</span>
<span class="nc" id="L847">            int offset = -weekStart;</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">            if (weekStart + 1 &gt; weekDef.getMinimalDaysInFirstWeek()) {</span>
                // The previous week has the minimum days in the current month to be a 'week'
<span class="nc" id="L850">                offset = 7 - weekStart;</span>
            }
<span class="nc" id="L852">            return offset;</span>
        }

        /**
         * Returns the week number computed from the reference day and reference dayOfWeek.
         *
         * @param offset the offset to align a date with the start of week
         *     from {@link #startOfWeekOffset}.
         * @param day  the day for which to compute the week number
         * @return the week number where zero is used for a partial week and 1 for the first full week
         */
        private int computeWeek(int offset, int day) {
<span class="nc" id="L864">            return ((7 + offset + (day - 1)) / 7);</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public &lt;R extends Temporal&gt; R adjustInto(R temporal, long newValue) {
            // Check the new value and get the old value of the field
<span class="nc" id="L871">            int newVal = range.checkValidIntValue(newValue, this);  // lenient check range</span>
<span class="nc" id="L872">            int currentVal = temporal.get(this);</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">            if (newVal == currentVal) {</span>
<span class="nc" id="L874">                return temporal;</span>
            }

<span class="nc bnc" id="L877" title="All 2 branches missed.">            if (rangeUnit == FOREVER) {     // replace year of WeekBasedYear</span>
                // Create a new date object with the same chronology,
                // the desired year and the same week and dow.
<span class="nc" id="L880">                int idow = temporal.get(weekDef.dayOfWeek);</span>
<span class="nc" id="L881">                int wowby = temporal.get(weekDef.weekOfWeekBasedYear);</span>
<span class="nc" id="L882">                return (R) ofWeekBasedYear(Chronology.from(temporal), (int)newValue, wowby, idow);</span>
            } else {
                // Compute the difference and add that using the base unit of the field
<span class="nc" id="L885">                return (R) temporal.plus(newVal - currentVal, baseUnit);</span>
            }
        }

        @Override
        public ChronoLocalDate resolve(
                Map&lt;TemporalField, Long&gt; fieldValues, TemporalAccessor partialTemporal, ResolverStyle resolverStyle) {
<span class="nc" id="L892">            final long value = fieldValues.get(this);</span>
<span class="nc" id="L893">            final int newValue = Math.toIntExact(value);  // broad limit makes overflow checking lighter</span>
            // first convert localized day-of-week to ISO day-of-week
            // doing this first handles case where both ISO and localized were parsed and might mismatch
            // day-of-week is always strict as two different day-of-week values makes lenient complex
<span class="nc bnc" id="L897" title="All 2 branches missed.">            if (rangeUnit == WEEKS) {  // day-of-week</span>
<span class="nc" id="L898">                final int checkedValue = range.checkValidIntValue(value, this);  // no leniency as too complex</span>
<span class="nc" id="L899">                final int startDow = weekDef.getFirstDayOfWeek().getValue();</span>
<span class="nc" id="L900">                long isoDow = Math.floorMod((startDow - 1) + (checkedValue - 1), 7) + 1;</span>
<span class="nc" id="L901">                fieldValues.remove(this);</span>
<span class="nc" id="L902">                fieldValues.put(DAY_OF_WEEK, isoDow);</span>
<span class="nc" id="L903">                return null;</span>
            }

            // can only build date if ISO day-of-week is present
<span class="nc bnc" id="L907" title="All 2 branches missed.">            if (fieldValues.containsKey(DAY_OF_WEEK) == false) {</span>
<span class="nc" id="L908">                return null;</span>
            }
<span class="nc" id="L910">            int isoDow = DAY_OF_WEEK.checkValidIntValue(fieldValues.get(DAY_OF_WEEK));</span>
<span class="nc" id="L911">            int dow = localizedDayOfWeek(isoDow);</span>

            // build date
<span class="nc" id="L914">            Chronology chrono = Chronology.from(partialTemporal);</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">            if (fieldValues.containsKey(YEAR)) {</span>
<span class="nc" id="L916">                int year = YEAR.checkValidIntValue(fieldValues.get(YEAR));  // validate</span>
<span class="nc bnc" id="L917" title="All 4 branches missed.">                if (rangeUnit == MONTHS &amp;&amp; fieldValues.containsKey(MONTH_OF_YEAR)) {  // week-of-month</span>
<span class="nc" id="L918">                    long month = fieldValues.get(MONTH_OF_YEAR);  // not validated yet</span>
<span class="nc" id="L919">                    return resolveWoM(fieldValues, chrono, year, month, newValue, dow, resolverStyle);</span>
                }
<span class="nc bnc" id="L921" title="All 2 branches missed.">                if (rangeUnit == YEARS) {  // week-of-year</span>
<span class="nc" id="L922">                    return resolveWoY(fieldValues, chrono, year, newValue, dow, resolverStyle);</span>
                }
<span class="nc bnc" id="L924" title="All 4 branches missed.">            } else if ((rangeUnit == WEEK_BASED_YEARS || rangeUnit == FOREVER) &amp;&amp;</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                    fieldValues.containsKey(weekDef.weekBasedYear) &amp;&amp;</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">                    fieldValues.containsKey(weekDef.weekOfWeekBasedYear)) { // week-of-week-based-year and year-of-week-based-year</span>
<span class="nc" id="L927">                return resolveWBY(fieldValues, chrono, dow, resolverStyle);</span>
            }
<span class="nc" id="L929">            return null;</span>
        }

        private ChronoLocalDate resolveWoM(
                Map&lt;TemporalField, Long&gt; fieldValues, Chronology chrono, int year, long month, long wom, int localDow, ResolverStyle resolverStyle) {
            ChronoLocalDate date;
<span class="nc bnc" id="L935" title="All 2 branches missed.">            if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L936">                date = chrono.date(year, 1, 1).plus(Math.subtractExact(month, 1), MONTHS);</span>
<span class="nc" id="L937">                long weeks = Math.subtractExact(wom, localizedWeekOfMonth(date));</span>
<span class="nc" id="L938">                int days = localDow - localizedDayOfWeek(date);  // safe from overflow</span>
<span class="nc" id="L939">                date = date.plus(Math.addExact(Math.multiplyExact(weeks, 7), days), DAYS);</span>
<span class="nc" id="L940">            } else {</span>
<span class="nc" id="L941">                int monthValid = MONTH_OF_YEAR.checkValidIntValue(month);  // validate</span>
<span class="nc" id="L942">                date = chrono.date(year, monthValid, 1);</span>
<span class="nc" id="L943">                int womInt = range.checkValidIntValue(wom, this);  // validate</span>
<span class="nc" id="L944">                int weeks = (int) (womInt - localizedWeekOfMonth(date));  // safe from overflow</span>
<span class="nc" id="L945">                int days = localDow - localizedDayOfWeek(date);  // safe from overflow</span>
<span class="nc" id="L946">                date = date.plus(weeks * 7 + days, DAYS);</span>
<span class="nc bnc" id="L947" title="All 4 branches missed.">                if (resolverStyle == ResolverStyle.STRICT &amp;&amp; date.getLong(MONTH_OF_YEAR) != month) {</span>
<span class="nc" id="L948">                    throw new DateTimeException(&quot;Strict mode rejected resolved date as it is in a different month&quot;);</span>
                }
            }
<span class="nc" id="L951">            fieldValues.remove(this);</span>
<span class="nc" id="L952">            fieldValues.remove(YEAR);</span>
<span class="nc" id="L953">            fieldValues.remove(MONTH_OF_YEAR);</span>
<span class="nc" id="L954">            fieldValues.remove(DAY_OF_WEEK);</span>
<span class="nc" id="L955">            return date;</span>
        }

        private ChronoLocalDate resolveWoY(
                Map&lt;TemporalField, Long&gt; fieldValues, Chronology chrono, int year, long woy, int localDow, ResolverStyle resolverStyle) {
<span class="nc" id="L960">            ChronoLocalDate date = chrono.date(year, 1, 1);</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">            if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L962">                long weeks = Math.subtractExact(woy, localizedWeekOfYear(date));</span>
<span class="nc" id="L963">                int days = localDow - localizedDayOfWeek(date);  // safe from overflow</span>
<span class="nc" id="L964">                date = date.plus(Math.addExact(Math.multiplyExact(weeks, 7), days), DAYS);</span>
<span class="nc" id="L965">            } else {</span>
<span class="nc" id="L966">                int womInt = range.checkValidIntValue(woy, this);  // validate</span>
<span class="nc" id="L967">                int weeks = (int) (womInt - localizedWeekOfYear(date));  // safe from overflow</span>
<span class="nc" id="L968">                int days = localDow - localizedDayOfWeek(date);  // safe from overflow</span>
<span class="nc" id="L969">                date = date.plus(weeks * 7 + days, DAYS);</span>
<span class="nc bnc" id="L970" title="All 4 branches missed.">                if (resolverStyle == ResolverStyle.STRICT &amp;&amp; date.getLong(YEAR) != year) {</span>
<span class="nc" id="L971">                    throw new DateTimeException(&quot;Strict mode rejected resolved date as it is in a different year&quot;);</span>
                }
            }
<span class="nc" id="L974">            fieldValues.remove(this);</span>
<span class="nc" id="L975">            fieldValues.remove(YEAR);</span>
<span class="nc" id="L976">            fieldValues.remove(DAY_OF_WEEK);</span>
<span class="nc" id="L977">            return date;</span>
        }

        private ChronoLocalDate resolveWBY(
                Map&lt;TemporalField, Long&gt; fieldValues, Chronology chrono, int localDow, ResolverStyle resolverStyle) {
<span class="nc" id="L982">            int yowby = weekDef.weekBasedYear.range().checkValidIntValue(</span>
<span class="nc" id="L983">                    fieldValues.get(weekDef.weekBasedYear), weekDef.weekBasedYear);</span>
            ChronoLocalDate date;
<span class="nc bnc" id="L985" title="All 2 branches missed.">            if (resolverStyle == ResolverStyle.LENIENT) {</span>
<span class="nc" id="L986">                date = ofWeekBasedYear(chrono, yowby, 1, localDow);</span>
<span class="nc" id="L987">                long wowby = fieldValues.get(weekDef.weekOfWeekBasedYear);</span>
<span class="nc" id="L988">                long weeks = Math.subtractExact(wowby, 1);</span>
<span class="nc" id="L989">                date = date.plus(weeks, WEEKS);</span>
<span class="nc" id="L990">            } else {</span>
<span class="nc" id="L991">                int wowby = weekDef.weekOfWeekBasedYear.range().checkValidIntValue(</span>
<span class="nc" id="L992">                        fieldValues.get(weekDef.weekOfWeekBasedYear), weekDef.weekOfWeekBasedYear);  // validate</span>
<span class="nc" id="L993">                date = ofWeekBasedYear(chrono, yowby, wowby, localDow);</span>
<span class="nc bnc" id="L994" title="All 4 branches missed.">                if (resolverStyle == ResolverStyle.STRICT &amp;&amp; localizedWeekBasedYear(date) != yowby) {</span>
<span class="nc" id="L995">                    throw new DateTimeException(&quot;Strict mode rejected resolved date as it is in a different week-based-year&quot;);</span>
                }
            }
<span class="nc" id="L998">            fieldValues.remove(this);</span>
<span class="nc" id="L999">            fieldValues.remove(weekDef.weekBasedYear);</span>
<span class="nc" id="L1000">            fieldValues.remove(weekDef.weekOfWeekBasedYear);</span>
<span class="nc" id="L1001">            fieldValues.remove(DAY_OF_WEEK);</span>
<span class="nc" id="L1002">            return date;</span>
        }

        //-----------------------------------------------------------------------
        @Override
        public String getDisplayName(Locale locale) {
<span class="nc" id="L1008">            Objects.requireNonNull(locale, &quot;locale&quot;);</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            if (rangeUnit == YEARS) {  // only have values for week-of-year</span>
<span class="nc" id="L1010">                LocaleResources lr = LocaleProviderAdapter.getResourceBundleBased()</span>
<span class="nc" id="L1011">                        .getLocaleResources(locale);</span>
<span class="nc" id="L1012">                ResourceBundle rb = lr.getJavaTimeFormatData();</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">                return rb.containsKey(&quot;field.week&quot;) ? rb.getString(&quot;field.week&quot;) : name;</span>
            }
<span class="nc" id="L1015">            return name;</span>
        }

        @Override
        public TemporalUnit getBaseUnit() {
<span class="nc" id="L1020">            return baseUnit;</span>
        }

        @Override
        public TemporalUnit getRangeUnit() {
<span class="nc" id="L1025">            return rangeUnit;</span>
        }

        @Override
        public boolean isDateBased() {
<span class="nc" id="L1030">            return true;</span>
        }

        @Override
        public boolean isTimeBased() {
<span class="nc" id="L1035">            return false;</span>
        }

        @Override
        public ValueRange range() {
<span class="nc" id="L1040">            return range;</span>
        }

        //-----------------------------------------------------------------------
        @Override
        public boolean isSupportedBy(TemporalAccessor temporal) {
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            if (temporal.isSupported(DAY_OF_WEEK)) {</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                if (rangeUnit == WEEKS) {  // day-of-week</span>
<span class="nc" id="L1048">                    return true;</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                } else if (rangeUnit == MONTHS) {  // week-of-month</span>
<span class="nc" id="L1050">                    return temporal.isSupported(DAY_OF_MONTH);</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">                } else if (rangeUnit == YEARS) {  // week-of-year</span>
<span class="nc" id="L1052">                    return temporal.isSupported(DAY_OF_YEAR);</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                } else if (rangeUnit == WEEK_BASED_YEARS) {</span>
<span class="nc" id="L1054">                    return temporal.isSupported(DAY_OF_YEAR);</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">                } else if (rangeUnit == FOREVER) {</span>
<span class="nc" id="L1056">                    return temporal.isSupported(YEAR);</span>
                }
            }
<span class="nc" id="L1059">            return false;</span>
        }

        @Override
        public ValueRange rangeRefinedBy(TemporalAccessor temporal) {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">            if (rangeUnit == ChronoUnit.WEEKS) {  // day-of-week</span>
<span class="nc" id="L1065">                return range;</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">            } else if (rangeUnit == MONTHS) {  // week-of-month</span>
<span class="nc" id="L1067">                return rangeByWeek(temporal, DAY_OF_MONTH);</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">            } else if (rangeUnit == YEARS) {  // week-of-year</span>
<span class="nc" id="L1069">                return rangeByWeek(temporal, DAY_OF_YEAR);</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">            } else if (rangeUnit == WEEK_BASED_YEARS) {</span>
<span class="nc" id="L1071">                return rangeWeekOfWeekBasedYear(temporal);</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            } else if (rangeUnit == FOREVER) {</span>
<span class="nc" id="L1073">                return YEAR.range();</span>
            } else {
<span class="nc" id="L1075">                throw new IllegalStateException(&quot;unreachable, rangeUnit: &quot; + rangeUnit + &quot;, this: &quot; + this);</span>
            }
        }

        /**
         * Map the field range to a week range
         * @param temporal the temporal
         * @param field the field to get the range of
         * @return the ValueRange with the range adjusted to weeks.
         */
        private ValueRange rangeByWeek(TemporalAccessor temporal, TemporalField field) {
<span class="nc" id="L1086">            int dow = localizedDayOfWeek(temporal);</span>
<span class="nc" id="L1087">            int offset = startOfWeekOffset(temporal.get(field), dow);</span>
<span class="nc" id="L1088">            ValueRange fieldRange = temporal.range(field);</span>
<span class="nc" id="L1089">            return ValueRange.of(computeWeek(offset, (int) fieldRange.getMinimum()),</span>
<span class="nc" id="L1090">                    computeWeek(offset, (int) fieldRange.getMaximum()));</span>
        }

        /**
         * Map the field range to a week range of a week year.
         * @param temporal  the temporal
         * @return the ValueRange with the range adjusted to weeks.
         */
        private ValueRange rangeWeekOfWeekBasedYear(TemporalAccessor temporal) {
<span class="nc bnc" id="L1099" title="All 2 branches missed.">            if (!temporal.isSupported(DAY_OF_YEAR)) {</span>
<span class="nc" id="L1100">                return WEEK_OF_YEAR_RANGE;</span>
            }
<span class="nc" id="L1102">            int dow = localizedDayOfWeek(temporal);</span>
<span class="nc" id="L1103">            int doy = temporal.get(DAY_OF_YEAR);</span>
<span class="nc" id="L1104">            int offset = startOfWeekOffset(doy, dow);</span>
<span class="nc" id="L1105">            int week = computeWeek(offset, doy);</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            if (week == 0) {</span>
                // Day is in end of week of previous year
                // Recompute from the last day of the previous year
<span class="nc" id="L1109">                ChronoLocalDate date = Chronology.from(temporal).date(temporal);</span>
<span class="nc" id="L1110">                date = date.minus(doy + 7, DAYS);   // Back down into previous year</span>
<span class="nc" id="L1111">                return rangeWeekOfWeekBasedYear(date);</span>
            }
            // Check if day of year is in partial week associated with next year
<span class="nc" id="L1114">            ValueRange dayRange = temporal.range(DAY_OF_YEAR);</span>
<span class="nc" id="L1115">            int yearLen = (int)dayRange.getMaximum();</span>
<span class="nc" id="L1116">            int newYearWeek = computeWeek(offset, yearLen + weekDef.getMinimalDaysInFirstWeek());</span>

<span class="nc bnc" id="L1118" title="All 2 branches missed.">            if (week &gt;= newYearWeek) {</span>
                // Overlaps with weeks of following year; recompute from a week in following year
<span class="nc" id="L1120">                ChronoLocalDate date = Chronology.from(temporal).date(temporal);</span>
<span class="nc" id="L1121">                date = date.plus(yearLen - doy + 1 + 7, ChronoUnit.DAYS);</span>
<span class="nc" id="L1122">                return rangeWeekOfWeekBasedYear(date);</span>
            }
<span class="nc" id="L1124">            return ValueRange.of(1, newYearWeek-1);</span>
        }

        //-----------------------------------------------------------------------
        @Override
        public String toString() {
<span class="nc" id="L1130">            return name + &quot;[&quot; + weekDef.toString() + &quot;]&quot;;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>