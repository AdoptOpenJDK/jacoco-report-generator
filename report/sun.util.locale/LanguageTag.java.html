<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>LanguageTag.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.util.locale</a> &gt; <span class="el_source">LanguageTag.java</span></div><h1>LanguageTag.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 *******************************************************************************
 * Copyright (C) 2010, International Business Machines Corporation and         *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
package sun.util.locale;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class LanguageTag {
    //
    // static fields
    //
    public static final String SEP = &quot;-&quot;;
    public static final String PRIVATEUSE = &quot;x&quot;;
    public static final String UNDETERMINED = &quot;und&quot;;
    public static final String PRIVUSE_VARIANT_PREFIX = &quot;lvariant&quot;;

    //
    // Language subtag fields
    //
<span class="fc" id="L53">    private String language = &quot;&quot;;      // language subtag</span>
<span class="fc" id="L54">    private String script = &quot;&quot;;        // script subtag</span>
<span class="fc" id="L55">    private String region = &quot;&quot;;        // region subtag</span>
<span class="fc" id="L56">    private String privateuse = &quot;&quot;;    // privateuse</span>

<span class="fc" id="L58">    private List&lt;String&gt; extlangs = Collections.emptyList();   // extlang subtags</span>
<span class="fc" id="L59">    private List&lt;String&gt; variants = Collections.emptyList();   // variant subtags</span>
<span class="fc" id="L60">    private List&lt;String&gt; extensions = Collections.emptyList(); // extensions</span>

    // Map contains grandfathered tags and its preferred mappings from
    // http://www.ietf.org/rfc/rfc5646.txt
    // Keys are lower-case strings.
<span class="fc" id="L65">    private static final Map&lt;String, String[]&gt; GRANDFATHERED = new HashMap&lt;&gt;();</span>

    static {
        // grandfathered = irregular           ; non-redundant tags registered
        //               / regular             ; during the RFC 3066 era
        //
        // irregular     = &quot;en-GB-oed&quot;         ; irregular tags do not match
        //               / &quot;i-ami&quot;             ; the 'langtag' production and
        //               / &quot;i-bnn&quot;             ; would not otherwise be
        //               / &quot;i-default&quot;         ; considered 'well-formed'
        //               / &quot;i-enochian&quot;        ; These tags are all valid,
        //               / &quot;i-hak&quot;             ; but most are deprecated
        //               / &quot;i-klingon&quot;         ; in favor of more modern
        //               / &quot;i-lux&quot;             ; subtags or subtag
        //               / &quot;i-mingo&quot;           ; combination
        //               / &quot;i-navajo&quot;
        //               / &quot;i-pwn&quot;
        //               / &quot;i-tao&quot;
        //               / &quot;i-tay&quot;
        //               / &quot;i-tsu&quot;
        //               / &quot;sgn-BE-FR&quot;
        //               / &quot;sgn-BE-NL&quot;
        //               / &quot;sgn-CH-DE&quot;
        //
        // regular       = &quot;art-lojban&quot;        ; these tags match the 'langtag'
        //               / &quot;cel-gaulish&quot;       ; production, but their subtags
        //               / &quot;no-bok&quot;            ; are not extended language
        //               / &quot;no-nyn&quot;            ; or variant subtags: their meaning
        //               / &quot;zh-guoyu&quot;          ; is defined by their registration
        //               / &quot;zh-hakka&quot;          ; and all of these are deprecated
        //               / &quot;zh-min&quot;            ; in favor of a more modern
        //               / &quot;zh-min-nan&quot;        ; subtag or sequence of subtags
        //               / &quot;zh-xiang&quot;

<span class="fc" id="L99">        final String[][] entries = {</span>
          //{&quot;tag&quot;,         &quot;preferred&quot;},
            {&quot;art-lojban&quot;,  &quot;jbo&quot;},
            {&quot;cel-gaulish&quot;, &quot;xtg-x-cel-gaulish&quot;},   // fallback
            {&quot;en-GB-oed&quot;,   &quot;en-GB-x-oed&quot;},         // fallback
            {&quot;i-ami&quot;,       &quot;ami&quot;},
            {&quot;i-bnn&quot;,       &quot;bnn&quot;},
            {&quot;i-default&quot;,   &quot;en-x-i-default&quot;},      // fallback
            {&quot;i-enochian&quot;,  &quot;und-x-i-enochian&quot;},    // fallback
            {&quot;i-hak&quot;,       &quot;hak&quot;},
            {&quot;i-klingon&quot;,   &quot;tlh&quot;},
            {&quot;i-lux&quot;,       &quot;lb&quot;},
            {&quot;i-mingo&quot;,     &quot;see-x-i-mingo&quot;},       // fallback
            {&quot;i-navajo&quot;,    &quot;nv&quot;},
            {&quot;i-pwn&quot;,       &quot;pwn&quot;},
            {&quot;i-tao&quot;,       &quot;tao&quot;},
            {&quot;i-tay&quot;,       &quot;tay&quot;},
            {&quot;i-tsu&quot;,       &quot;tsu&quot;},
            {&quot;no-bok&quot;,      &quot;nb&quot;},
            {&quot;no-nyn&quot;,      &quot;nn&quot;},
            {&quot;sgn-BE-FR&quot;,   &quot;sfb&quot;},
            {&quot;sgn-BE-NL&quot;,   &quot;vgt&quot;},
            {&quot;sgn-CH-DE&quot;,   &quot;sgg&quot;},
            {&quot;zh-guoyu&quot;,    &quot;cmn&quot;},
            {&quot;zh-hakka&quot;,    &quot;hak&quot;},
            {&quot;zh-min&quot;,      &quot;nan-x-zh-min&quot;},        // fallback
            {&quot;zh-min-nan&quot;,  &quot;nan&quot;},
            {&quot;zh-xiang&quot;,    &quot;hsn&quot;},
        };
<span class="fc bfc" id="L128" title="All 2 branches covered.">        for (String[] e : entries) {</span>
<span class="fc" id="L129">            GRANDFATHERED.put(LocaleUtils.toLowerString(e[0]), e);</span>
        }
<span class="fc" id="L131">    }</span>

<span class="fc" id="L133">    private LanguageTag() {</span>
<span class="fc" id="L134">    }</span>

    /*
     * BNF in RFC5646
     *
     * Language-Tag  = langtag             ; normal language tags
     *               / privateuse          ; private use tag
     *               / grandfathered       ; grandfathered tags
     *
     *
     * langtag       = language
     *                 [&quot;-&quot; script]
     *                 [&quot;-&quot; region]
     *                 *(&quot;-&quot; variant)
     *                 *(&quot;-&quot; extension)
     *                 [&quot;-&quot; privateuse]
     *
     * language      = 2*3ALPHA            ; shortest ISO 639 code
     *                 [&quot;-&quot; extlang]       ; sometimes followed by
     *                                     ; extended language subtags
     *               / 4ALPHA              ; or reserved for future use
     *               / 5*8ALPHA            ; or registered language subtag
     *
     * extlang       = 3ALPHA              ; selected ISO 639 codes
     *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
     *
     * script        = 4ALPHA              ; ISO 15924 code
     *
     * region        = 2ALPHA              ; ISO 3166-1 code
     *               / 3DIGIT              ; UN M.49 code
     *
     * variant       = 5*8alphanum         ; registered variants
     *               / (DIGIT 3alphanum)
     *
     * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
     *
     *                                     ; Single alphanumerics
     *                                     ; &quot;x&quot; reserved for private use
     * singleton     = DIGIT               ; 0 - 9
     *               / %x41-57             ; A - W
     *               / %x59-5A             ; Y - Z
     *               / %x61-77             ; a - w
     *               / %x79-7A             ; y - z
     *
     * privateuse    = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))
     *
     */
    public static LanguageTag parse(String languageTag, ParseStatus sts) {
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (sts == null) {</span>
<span class="fc" id="L183">            sts = new ParseStatus();</span>
        } else {
<span class="fc" id="L185">            sts.reset();</span>
        }

        StringTokenIterator itr;

        // Check if the tag is grandfathered
<span class="fc" id="L191">        String[] gfmap = GRANDFATHERED.get(LocaleUtils.toLowerString(languageTag));</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (gfmap != null) {</span>
            // use preferred mapping
<span class="fc" id="L194">            itr = new StringTokenIterator(gfmap[1], SEP);</span>
        } else {
<span class="fc" id="L196">            itr = new StringTokenIterator(languageTag, SEP);</span>
        }

<span class="fc" id="L199">        LanguageTag tag = new LanguageTag();</span>

        // langtag must start with either language or privateuse
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (tag.parseLanguage(itr, sts)) {</span>
<span class="fc" id="L203">            tag.parseExtlangs(itr, sts);</span>
<span class="fc" id="L204">            tag.parseScript(itr, sts);</span>
<span class="fc" id="L205">            tag.parseRegion(itr, sts);</span>
<span class="fc" id="L206">            tag.parseVariants(itr, sts);</span>
<span class="fc" id="L207">            tag.parseExtensions(itr, sts);</span>
        }
<span class="fc" id="L209">        tag.parsePrivateuse(itr, sts);</span>

<span class="fc bfc" id="L211" title="All 4 branches covered.">        if (!itr.isDone() &amp;&amp; !sts.isError()) {</span>
<span class="fc" id="L212">            String s = itr.current();</span>
<span class="fc" id="L213">            sts.errorIndex = itr.currentStart();</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">            if (s.length() == 0) {</span>
<span class="fc" id="L215">                sts.errorMsg = &quot;Empty subtag&quot;;</span>
            } else {
<span class="fc" id="L217">                sts.errorMsg = &quot;Invalid subtag: &quot; + s;</span>
            }
        }

<span class="fc" id="L221">        return tag;</span>
    }

    //
    // Language subtag parsers
    //

    private boolean parseLanguage(StringTokenIterator itr, ParseStatus sts) {
<span class="pc bpc" id="L229" title="2 of 4 branches missed.">        if (itr.isDone() || sts.isError()) {</span>
<span class="nc" id="L230">            return false;</span>
        }

<span class="fc" id="L233">        boolean found = false;</span>

<span class="fc" id="L235">        String s = itr.current();</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (isLanguage(s)) {</span>
<span class="fc" id="L237">            found = true;</span>
<span class="fc" id="L238">            language = s;</span>
<span class="fc" id="L239">            sts.parseLength = itr.currentEnd();</span>
<span class="fc" id="L240">            itr.next();</span>
        }

<span class="fc" id="L243">        return found;</span>
    }

    private boolean parseExtlangs(StringTokenIterator itr, ParseStatus sts) {
<span class="pc bpc" id="L247" title="1 of 4 branches missed.">        if (itr.isDone() || sts.isError()) {</span>
<span class="fc" id="L248">            return false;</span>
        }

<span class="fc" id="L251">        boolean found = false;</span>

<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        while (!itr.isDone()) {</span>
<span class="fc" id="L254">            String s = itr.current();</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">            if (!isExtlang(s)) {</span>
<span class="fc" id="L256">                break;</span>
            }
<span class="nc" id="L258">            found = true;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (extlangs.isEmpty()) {</span>
<span class="nc" id="L260">                extlangs = new ArrayList&lt;&gt;(3);</span>
            }
<span class="nc" id="L262">            extlangs.add(s);</span>
<span class="nc" id="L263">            sts.parseLength = itr.currentEnd();</span>
<span class="nc" id="L264">            itr.next();</span>

<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (extlangs.size() == 3) {</span>
                // Maximum 3 extlangs
<span class="nc" id="L268">                break;</span>
            }
<span class="nc" id="L270">        }</span>

<span class="fc" id="L272">        return found;</span>
    }

    private boolean parseScript(StringTokenIterator itr, ParseStatus sts) {
<span class="pc bpc" id="L276" title="1 of 4 branches missed.">        if (itr.isDone() || sts.isError()) {</span>
<span class="fc" id="L277">            return false;</span>
        }

<span class="fc" id="L280">        boolean found = false;</span>

<span class="fc" id="L282">        String s = itr.current();</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (isScript(s)) {</span>
<span class="fc" id="L284">            found = true;</span>
<span class="fc" id="L285">            script = s;</span>
<span class="fc" id="L286">            sts.parseLength = itr.currentEnd();</span>
<span class="fc" id="L287">            itr.next();</span>
        }

<span class="fc" id="L290">        return found;</span>
    }

    private boolean parseRegion(StringTokenIterator itr, ParseStatus sts) {
<span class="pc bpc" id="L294" title="1 of 4 branches missed.">        if (itr.isDone() || sts.isError()) {</span>
<span class="fc" id="L295">            return false;</span>
        }

<span class="fc" id="L298">        boolean found = false;</span>

<span class="fc" id="L300">        String s = itr.current();</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (isRegion(s)) {</span>
<span class="fc" id="L302">            found = true;</span>
<span class="fc" id="L303">            region = s;</span>
<span class="fc" id="L304">            sts.parseLength = itr.currentEnd();</span>
<span class="fc" id="L305">            itr.next();</span>
        }

<span class="fc" id="L308">        return found;</span>
    }

    private boolean parseVariants(StringTokenIterator itr, ParseStatus sts) {
<span class="pc bpc" id="L312" title="1 of 4 branches missed.">        if (itr.isDone() || sts.isError()) {</span>
<span class="fc" id="L313">            return false;</span>
        }

<span class="fc" id="L316">        boolean found = false;</span>

<span class="fc bfc" id="L318" title="All 2 branches covered.">        while (!itr.isDone()) {</span>
<span class="fc" id="L319">            String s = itr.current();</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">            if (!isVariant(s)) {</span>
<span class="fc" id="L321">                break;</span>
            }
<span class="fc" id="L323">            found = true;</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">            if (variants.isEmpty()) {</span>
<span class="fc" id="L325">                variants = new ArrayList&lt;&gt;(3);</span>
            }
<span class="fc" id="L327">            variants.add(s);</span>
<span class="fc" id="L328">            sts.parseLength = itr.currentEnd();</span>
<span class="fc" id="L329">            itr.next();</span>
<span class="fc" id="L330">        }</span>

<span class="fc" id="L332">        return found;</span>
    }

    private boolean parseExtensions(StringTokenIterator itr, ParseStatus sts) {
<span class="pc bpc" id="L336" title="1 of 4 branches missed.">        if (itr.isDone() || sts.isError()) {</span>
<span class="fc" id="L337">            return false;</span>
        }

<span class="fc" id="L340">        boolean found = false;</span>

<span class="fc bfc" id="L342" title="All 2 branches covered.">        while (!itr.isDone()) {</span>
<span class="fc" id="L343">            String s = itr.current();</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">            if (isExtensionSingleton(s)) {</span>
<span class="fc" id="L345">                int start = itr.currentStart();</span>
<span class="fc" id="L346">                String singleton = s;</span>
<span class="fc" id="L347">                StringBuilder sb = new StringBuilder(singleton);</span>

<span class="fc" id="L349">                itr.next();</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">                while (!itr.isDone()) {</span>
<span class="fc" id="L351">                    s = itr.current();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">                    if (isExtensionSubtag(s)) {</span>
<span class="fc" id="L353">                        sb.append(SEP).append(s);</span>
<span class="fc" id="L354">                        sts.parseLength = itr.currentEnd();</span>
                    } else {
                        break;
                    }
<span class="fc" id="L358">                    itr.next();</span>
                }

<span class="fc bfc" id="L361" title="All 2 branches covered.">                if (sts.parseLength &lt;= start) {</span>
<span class="fc" id="L362">                    sts.errorIndex = start;</span>
<span class="fc" id="L363">                    sts.errorMsg = &quot;Incomplete extension '&quot; + singleton + &quot;'&quot;;</span>
<span class="fc" id="L364">                    break;</span>
                }

<span class="fc bfc" id="L367" title="All 2 branches covered.">                if (extensions.isEmpty()) {</span>
<span class="fc" id="L368">                    extensions = new ArrayList&lt;&gt;(4);</span>
                }
<span class="fc" id="L370">                extensions.add(sb.toString());</span>
<span class="fc" id="L371">                found = true;</span>
            } else {
                break;
            }
<span class="fc" id="L375">        }</span>
<span class="fc" id="L376">        return found;</span>
    }

    private boolean parsePrivateuse(StringTokenIterator itr, ParseStatus sts) {
<span class="fc bfc" id="L380" title="All 4 branches covered.">        if (itr.isDone() || sts.isError()) {</span>
<span class="fc" id="L381">            return false;</span>
        }

<span class="fc" id="L384">        boolean found = false;</span>

<span class="fc" id="L386">        String s = itr.current();</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (isPrivateusePrefix(s)) {</span>
<span class="fc" id="L388">            int start = itr.currentStart();</span>
<span class="fc" id="L389">            StringBuilder sb = new StringBuilder(s);</span>

<span class="fc" id="L391">            itr.next();</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">            while (!itr.isDone()) {</span>
<span class="fc" id="L393">                s = itr.current();</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                if (!isPrivateuseSubtag(s)) {</span>
<span class="fc" id="L395">                    break;</span>
                }
<span class="fc" id="L397">                sb.append(SEP).append(s);</span>
<span class="fc" id="L398">                sts.parseLength = itr.currentEnd();</span>

<span class="fc" id="L400">                itr.next();</span>
            }

<span class="fc bfc" id="L403" title="All 2 branches covered.">            if (sts.parseLength &lt;= start) {</span>
                // need at least 1 private subtag
<span class="fc" id="L405">                sts.errorIndex = start;</span>
<span class="fc" id="L406">                sts.errorMsg = &quot;Incomplete privateuse&quot;;</span>
            } else {
<span class="fc" id="L408">                privateuse = sb.toString();</span>
<span class="fc" id="L409">                found = true;</span>
            }
        }

<span class="fc" id="L413">        return found;</span>
    }

    public static LanguageTag parseLocale(BaseLocale baseLocale, LocaleExtensions localeExtensions) {
<span class="fc" id="L417">        LanguageTag tag = new LanguageTag();</span>

<span class="fc" id="L419">        String language = baseLocale.getLanguage();</span>
<span class="fc" id="L420">        String script = baseLocale.getScript();</span>
<span class="fc" id="L421">        String region = baseLocale.getRegion();</span>
<span class="fc" id="L422">        String variant = baseLocale.getVariant();</span>

<span class="fc" id="L424">        boolean hasSubtag = false;</span>

<span class="fc" id="L426">        String privuseVar = null;   // store ill-formed variant subtags</span>

<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (isLanguage(language)) {</span>
            // Convert a deprecated language code to its new code
<span class="fc bfc" id="L430" title="All 2 branches covered.">            if (language.equals(&quot;iw&quot;)) {</span>
<span class="fc" id="L431">                language = &quot;he&quot;;</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">            } else if (language.equals(&quot;ji&quot;)) {</span>
<span class="fc" id="L433">                language = &quot;yi&quot;;</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">            } else if (language.equals(&quot;in&quot;)) {</span>
<span class="fc" id="L435">                language = &quot;id&quot;;</span>
            }
<span class="fc" id="L437">            tag.language = language;</span>
        }

<span class="fc bfc" id="L440" title="All 2 branches covered.">        if (isScript(script)) {</span>
<span class="fc" id="L441">            tag.script = canonicalizeScript(script);</span>
<span class="fc" id="L442">            hasSubtag = true;</span>
        }

<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (isRegion(region)) {</span>
<span class="fc" id="L446">            tag.region = canonicalizeRegion(region);</span>
<span class="fc" id="L447">            hasSubtag = true;</span>
        }

        // Special handling for no_NO_NY - use nn_NO for language tag
<span class="fc bfc" id="L451" title="All 6 branches covered.">        if (tag.language.equals(&quot;no&quot;) &amp;&amp; tag.region.equals(&quot;NO&quot;) &amp;&amp; variant.equals(&quot;NY&quot;)) {</span>
<span class="fc" id="L452">            tag.language = &quot;nn&quot;;</span>
<span class="fc" id="L453">            variant = &quot;&quot;;</span>
        }

<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (variant.length() &gt; 0) {</span>
<span class="fc" id="L457">            List&lt;String&gt; variants = null;</span>
<span class="fc" id="L458">            StringTokenIterator varitr = new StringTokenIterator(variant, BaseLocale.SEP);</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">            while (!varitr.isDone()) {</span>
<span class="fc" id="L460">                String var = varitr.current();</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">                if (!isVariant(var)) {</span>
<span class="fc" id="L462">                    break;</span>
                }
<span class="fc bfc" id="L464" title="All 2 branches covered.">                if (variants == null) {</span>
<span class="fc" id="L465">                    variants = new ArrayList&lt;&gt;();</span>
                }
<span class="fc" id="L467">                variants.add(var);  // Do not canonicalize!</span>
<span class="fc" id="L468">                varitr.next();</span>
<span class="fc" id="L469">            }</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">            if (variants != null) {</span>
<span class="fc" id="L471">                tag.variants = variants;</span>
<span class="fc" id="L472">                hasSubtag = true;</span>
            }
<span class="fc bfc" id="L474" title="All 2 branches covered.">            if (!varitr.isDone()) {</span>
                // ill-formed variant subtags
<span class="fc" id="L476">                StringBuilder buf = new StringBuilder();</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">                while (!varitr.isDone()) {</span>
<span class="fc" id="L478">                    String prvv = varitr.current();</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">                    if (!isPrivateuseSubtag(prvv)) {</span>
                        // cannot use private use subtag - truncated
<span class="fc" id="L481">                        break;</span>
                    }
<span class="fc bfc" id="L483" title="All 2 branches covered.">                    if (buf.length() &gt; 0) {</span>
<span class="fc" id="L484">                        buf.append(SEP);</span>
                    }
<span class="fc" id="L486">                    buf.append(prvv);</span>
<span class="fc" id="L487">                    varitr.next();</span>
<span class="fc" id="L488">                }</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">                if (buf.length() &gt; 0) {</span>
<span class="fc" id="L490">                    privuseVar = buf.toString();</span>
                }
            }
        }

<span class="fc" id="L495">        List&lt;String&gt; extensions = null;</span>
<span class="fc" id="L496">        String privateuse = null;</span>

<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (localeExtensions != null) {</span>
<span class="fc" id="L499">            Set&lt;Character&gt; locextKeys = localeExtensions.getKeys();</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">            for (Character locextKey : locextKeys) {</span>
<span class="fc" id="L501">                Extension ext = localeExtensions.getExtension(locextKey);</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">                if (isPrivateusePrefixChar(locextKey)) {</span>
<span class="fc" id="L503">                    privateuse = ext.getValue();</span>
                } else {
<span class="fc bfc" id="L505" title="All 2 branches covered.">                    if (extensions == null) {</span>
<span class="fc" id="L506">                        extensions = new ArrayList&lt;&gt;();</span>
                    }
<span class="fc" id="L508">                    extensions.add(locextKey.toString() + SEP + ext.getValue());</span>
                }
<span class="fc" id="L510">            }</span>
        }

<span class="fc bfc" id="L513" title="All 2 branches covered.">        if (extensions != null) {</span>
<span class="fc" id="L514">            tag.extensions = extensions;</span>
<span class="fc" id="L515">            hasSubtag = true;</span>
        }

        // append ill-formed variant subtags to private use
<span class="fc bfc" id="L519" title="All 2 branches covered.">        if (privuseVar != null) {</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">            if (privateuse == null) {</span>
<span class="fc" id="L521">                privateuse = PRIVUSE_VARIANT_PREFIX + SEP + privuseVar;</span>
            } else {
<span class="nc" id="L523">                privateuse = privateuse + SEP + PRIVUSE_VARIANT_PREFIX</span>
<span class="nc" id="L524">                             + SEP + privuseVar.replace(BaseLocale.SEP, SEP);</span>
            }
        }

<span class="fc bfc" id="L528" title="All 2 branches covered.">        if (privateuse != null) {</span>
<span class="fc" id="L529">            tag.privateuse = privateuse;</span>
        }

<span class="fc bfc" id="L532" title="All 6 branches covered.">        if (tag.language.length() == 0 &amp;&amp; (hasSubtag || privateuse == null)) {</span>
            // use lang &quot;und&quot; when 1) no language is available AND
            // 2) any of other subtags other than private use are available or
            // no private use tag is available
<span class="fc" id="L536">            tag.language = UNDETERMINED;</span>
        }

<span class="fc" id="L539">        return tag;</span>
    }

    //
    // Getter methods for language subtag fields
    //

    public String getLanguage() {
<span class="fc" id="L547">        return language;</span>
    }

    public List&lt;String&gt; getExtlangs() {
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">        if (extlangs.isEmpty()) {</span>
<span class="fc" id="L552">            return Collections.emptyList();</span>
        }
<span class="nc" id="L554">        return Collections.unmodifiableList(extlangs);</span>
    }

    public String getScript() {
<span class="fc" id="L558">        return script;</span>
    }

    public String getRegion() {
<span class="fc" id="L562">        return region;</span>
    }

    public List&lt;String&gt; getVariants() {
<span class="fc bfc" id="L566" title="All 2 branches covered.">        if (variants.isEmpty()) {</span>
<span class="fc" id="L567">            return Collections.emptyList();</span>
        }
<span class="fc" id="L569">        return Collections.unmodifiableList(variants);</span>
    }

    public List&lt;String&gt; getExtensions() {
<span class="fc bfc" id="L573" title="All 2 branches covered.">        if (extensions.isEmpty()) {</span>
<span class="fc" id="L574">            return Collections.emptyList();</span>
        }
<span class="fc" id="L576">        return Collections.unmodifiableList(extensions);</span>
    }

    public String getPrivateuse() {
<span class="fc" id="L580">        return privateuse;</span>
    }

    //
    // Language subtag syntax checking methods
    //

    public static boolean isLanguage(String s) {
        // language      = 2*3ALPHA            ; shortest ISO 639 code
        //                 [&quot;-&quot; extlang]       ; sometimes followed by
        //                                     ;   extended language subtags
        //               / 4ALPHA              ; or reserved for future use
        //               / 5*8ALPHA            ; or registered language subtag
<span class="fc" id="L593">        int len = s.length();</span>
<span class="fc bfc" id="L594" title="All 6 branches covered.">        return (len &gt;= 2) &amp;&amp; (len &lt;= 8) &amp;&amp; LocaleUtils.isAlphaString(s);</span>
    }

    public static boolean isExtlang(String s) {
        // extlang       = 3ALPHA              ; selected ISO 639 codes
        //                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
<span class="pc bpc" id="L600" title="1 of 4 branches missed.">        return (s.length() == 3) &amp;&amp; LocaleUtils.isAlphaString(s);</span>
    }

    public static boolean isScript(String s) {
        // script        = 4ALPHA              ; ISO 15924 code
<span class="fc bfc" id="L605" title="All 4 branches covered.">        return (s.length() == 4) &amp;&amp; LocaleUtils.isAlphaString(s);</span>
    }

    public static boolean isRegion(String s) {
        // region        = 2ALPHA              ; ISO 3166-1 code
        //               / 3DIGIT              ; UN M.49 code
<span class="fc bfc" id="L611" title="All 4 branches covered.">        return ((s.length() == 2) &amp;&amp; LocaleUtils.isAlphaString(s))</span>
<span class="fc bfc" id="L612" title="All 4 branches covered.">                || ((s.length() == 3) &amp;&amp; LocaleUtils.isNumericString(s));</span>
    }

    public static boolean isVariant(String s) {
        // variant       = 5*8alphanum         ; registered variants
        //               / (DIGIT 3alphanum)
<span class="fc" id="L618">        int len = s.length();</span>
<span class="fc bfc" id="L619" title="All 4 branches covered.">        if (len &gt;= 5 &amp;&amp; len &lt;= 8) {</span>
<span class="fc" id="L620">            return LocaleUtils.isAlphaNumericString(s);</span>
        }
<span class="fc bfc" id="L622" title="All 2 branches covered.">        if (len == 4) {</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">            return LocaleUtils.isNumeric(s.charAt(0))</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">                    &amp;&amp; LocaleUtils.isAlphaNumeric(s.charAt(1))</span>
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">                    &amp;&amp; LocaleUtils.isAlphaNumeric(s.charAt(2))</span>
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">                    &amp;&amp; LocaleUtils.isAlphaNumeric(s.charAt(3));</span>
        }
<span class="fc" id="L628">        return false;</span>
    }

    public static boolean isExtensionSingleton(String s) {
        // singleton     = DIGIT               ; 0 - 9
        //               / %x41-57             ; A - W
        //               / %x59-5A             ; Y - Z
        //               / %x61-77             ; a - w
        //               / %x79-7A             ; y - z

<span class="fc bfc" id="L638" title="All 2 branches covered.">        return (s.length() == 1)</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">                &amp;&amp; LocaleUtils.isAlphaString(s)</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                &amp;&amp; !LocaleUtils.caseIgnoreMatch(PRIVATEUSE, s);</span>
    }

    public static boolean isExtensionSingletonChar(char c) {
<span class="fc" id="L644">        return isExtensionSingleton(String.valueOf(c));</span>
    }

    public static boolean isExtensionSubtag(String s) {
        // extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
<span class="fc" id="L649">        int len = s.length();</span>
<span class="fc bfc" id="L650" title="All 6 branches covered.">        return (len &gt;= 2) &amp;&amp; (len &lt;= 8) &amp;&amp; LocaleUtils.isAlphaNumericString(s);</span>
    }

    public static boolean isPrivateusePrefix(String s) {
        // privateuse    = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))
<span class="fc bfc" id="L655" title="All 2 branches covered.">        return (s.length() == 1)</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">                &amp;&amp; LocaleUtils.caseIgnoreMatch(PRIVATEUSE, s);</span>
    }

    public static boolean isPrivateusePrefixChar(char c) {
<span class="fc" id="L660">        return (LocaleUtils.caseIgnoreMatch(PRIVATEUSE, String.valueOf(c)));</span>
    }

    public static boolean isPrivateuseSubtag(String s) {
        // privateuse    = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))
<span class="fc" id="L665">        int len = s.length();</span>
<span class="pc bpc" id="L666" title="1 of 6 branches missed.">        return (len &gt;= 1) &amp;&amp; (len &lt;= 8) &amp;&amp; LocaleUtils.isAlphaNumericString(s);</span>
    }

    //
    // Language subtag canonicalization methods
    //

    public static String canonicalizeLanguage(String s) {
<span class="fc" id="L674">        return LocaleUtils.toLowerString(s);</span>
    }

    public static String canonicalizeExtlang(String s) {
<span class="nc" id="L678">        return LocaleUtils.toLowerString(s);</span>
    }

    public static String canonicalizeScript(String s) {
<span class="fc" id="L682">        return LocaleUtils.toTitleString(s);</span>
    }

    public static String canonicalizeRegion(String s) {
<span class="fc" id="L686">        return LocaleUtils.toUpperString(s);</span>
    }

    public static String canonicalizeVariant(String s) {
<span class="nc" id="L690">        return LocaleUtils.toLowerString(s);</span>
    }

    public static String canonicalizeExtension(String s) {
<span class="fc" id="L694">        return LocaleUtils.toLowerString(s);</span>
    }

    public static String canonicalizeExtensionSingleton(String s) {
<span class="nc" id="L698">        return LocaleUtils.toLowerString(s);</span>
    }

    public static String canonicalizeExtensionSubtag(String s) {
<span class="nc" id="L702">        return LocaleUtils.toLowerString(s);</span>
    }

    public static String canonicalizePrivateuse(String s) {
<span class="nc" id="L706">        return LocaleUtils.toLowerString(s);</span>
    }

    public static String canonicalizePrivateuseSubtag(String s) {
<span class="nc" id="L710">        return LocaleUtils.toLowerString(s);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L715">        StringBuilder sb = new StringBuilder();</span>

<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (language.length() &gt; 0) {</span>
<span class="nc" id="L718">            sb.append(language);</span>

<span class="nc bnc" id="L720" title="All 2 branches missed.">            for (String extlang : extlangs) {</span>
<span class="nc" id="L721">                sb.append(SEP).append(extlang);</span>
<span class="nc" id="L722">            }</span>

<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (script.length() &gt; 0) {</span>
<span class="nc" id="L725">                sb.append(SEP).append(script);</span>
            }

<span class="nc bnc" id="L728" title="All 2 branches missed.">            if (region.length() &gt; 0) {</span>
<span class="nc" id="L729">                sb.append(SEP).append(region);</span>
            }

<span class="nc bnc" id="L732" title="All 2 branches missed.">            for (String variant : variants) {</span>
<span class="nc" id="L733">                sb.append(SEP).append(variant);</span>
<span class="nc" id="L734">            }</span>

<span class="nc bnc" id="L736" title="All 2 branches missed.">            for (String extension : extensions) {</span>
<span class="nc" id="L737">                sb.append(SEP).append(extension);</span>
<span class="nc" id="L738">            }</span>
        }
<span class="nc bnc" id="L740" title="All 2 branches missed.">        if (privateuse.length() &gt; 0) {</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">            if (sb.length() &gt; 0) {</span>
<span class="nc" id="L742">                sb.append(SEP);</span>
            }
<span class="nc" id="L744">            sb.append(privateuse);</span>
        }

<span class="nc" id="L747">        return sb.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>