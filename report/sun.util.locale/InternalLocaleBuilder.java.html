<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InternalLocaleBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.util.locale</a> &gt; <span class="el_source">InternalLocaleBuilder.java</span></div><h1>InternalLocaleBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 *******************************************************************************
 * Copyright (C) 2009-2010, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
package sun.util.locale;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

<span class="fc bfc" id="L41" title="All 2 branches covered.">public final class InternalLocaleBuilder {</span>

<span class="fc" id="L43">    private static final CaseInsensitiveChar PRIVATEUSE_KEY</span>
        = new CaseInsensitiveChar(LanguageTag.PRIVATEUSE);

<span class="fc" id="L46">    private String language = &quot;&quot;;</span>
<span class="fc" id="L47">    private String script = &quot;&quot;;</span>
<span class="fc" id="L48">    private String region = &quot;&quot;;</span>
<span class="fc" id="L49">    private String variant = &quot;&quot;;</span>

    private Map&lt;CaseInsensitiveChar, String&gt; extensions;
    private Set&lt;CaseInsensitiveString&gt; uattributes;
    private Map&lt;CaseInsensitiveString, String&gt; ukeywords;


<span class="fc" id="L56">    public InternalLocaleBuilder() {</span>
<span class="fc" id="L57">    }</span>

    public InternalLocaleBuilder setLanguage(String language) throws LocaleSyntaxException {
<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (LocaleUtils.isEmpty(language)) {</span>
<span class="fc" id="L61">            this.language = &quot;&quot;;</span>
        } else {
<span class="fc bfc" id="L63" title="All 2 branches covered.">            if (!LanguageTag.isLanguage(language)) {</span>
<span class="fc" id="L64">                throw new LocaleSyntaxException(&quot;Ill-formed language: &quot; + language, 0);</span>
            }
<span class="fc" id="L66">            this.language = language;</span>
        }
<span class="fc" id="L68">        return this;</span>
    }

    public InternalLocaleBuilder setScript(String script) throws LocaleSyntaxException {
<span class="fc bfc" id="L72" title="All 2 branches covered.">        if (LocaleUtils.isEmpty(script)) {</span>
<span class="fc" id="L73">            this.script = &quot;&quot;;</span>
        } else {
<span class="fc bfc" id="L75" title="All 2 branches covered.">            if (!LanguageTag.isScript(script)) {</span>
<span class="fc" id="L76">                throw new LocaleSyntaxException(&quot;Ill-formed script: &quot; + script, 0);</span>
            }
<span class="fc" id="L78">            this.script = script;</span>
        }
<span class="fc" id="L80">        return this;</span>
    }

    public InternalLocaleBuilder setRegion(String region) throws LocaleSyntaxException {
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (LocaleUtils.isEmpty(region)) {</span>
<span class="fc" id="L85">            this.region = &quot;&quot;;</span>
        } else {
<span class="fc bfc" id="L87" title="All 2 branches covered.">            if (!LanguageTag.isRegion(region)) {</span>
<span class="fc" id="L88">                throw new LocaleSyntaxException(&quot;Ill-formed region: &quot; + region, 0);</span>
            }
<span class="fc" id="L90">            this.region = region;</span>
        }
<span class="fc" id="L92">        return this;</span>
    }

    public InternalLocaleBuilder setVariant(String variant) throws LocaleSyntaxException {
<span class="fc bfc" id="L96" title="All 2 branches covered.">        if (LocaleUtils.isEmpty(variant)) {</span>
<span class="fc" id="L97">            this.variant = &quot;&quot;;</span>
        } else {
            // normalize separators to &quot;_&quot;
<span class="fc" id="L100">            String var = variant.replaceAll(LanguageTag.SEP, BaseLocale.SEP);</span>
<span class="fc" id="L101">            int errIdx = checkVariants(var, BaseLocale.SEP);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">            if (errIdx != -1) {</span>
<span class="fc" id="L103">                throw new LocaleSyntaxException(&quot;Ill-formed variant: &quot; + variant, errIdx);</span>
            }
<span class="fc" id="L105">            this.variant = var;</span>
        }
<span class="fc" id="L107">        return this;</span>
    }

    public InternalLocaleBuilder addUnicodeLocaleAttribute(String attribute) throws LocaleSyntaxException {
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (!UnicodeLocaleExtension.isAttribute(attribute)) {</span>
<span class="fc" id="L112">            throw new LocaleSyntaxException(&quot;Ill-formed Unicode locale attribute: &quot; + attribute);</span>
        }
        // Use case insensitive string to prevent duplication
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (uattributes == null) {</span>
<span class="fc" id="L116">            uattributes = new HashSet&lt;&gt;(4);</span>
        }
<span class="fc" id="L118">        uattributes.add(new CaseInsensitiveString(attribute));</span>
<span class="fc" id="L119">        return this;</span>
    }

    public InternalLocaleBuilder removeUnicodeLocaleAttribute(String attribute) throws LocaleSyntaxException {
<span class="pc bpc" id="L123" title="2 of 4 branches missed.">        if (attribute == null || !UnicodeLocaleExtension.isAttribute(attribute)) {</span>
<span class="nc" id="L124">            throw new LocaleSyntaxException(&quot;Ill-formed Unicode locale attribute: &quot; + attribute);</span>
        }
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if (uattributes != null) {</span>
<span class="fc" id="L127">            uattributes.remove(new CaseInsensitiveString(attribute));</span>
        }
<span class="fc" id="L129">        return this;</span>
    }

    public InternalLocaleBuilder setUnicodeLocaleKeyword(String key, String type) throws LocaleSyntaxException {
<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (!UnicodeLocaleExtension.isKey(key)) {</span>
<span class="fc" id="L134">            throw new LocaleSyntaxException(&quot;Ill-formed Unicode locale keyword key: &quot; + key);</span>
        }

<span class="fc" id="L137">        CaseInsensitiveString cikey = new CaseInsensitiveString(key);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (type == null) {</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">            if (ukeywords != null) {</span>
                // null type is used for remove the key
<span class="fc" id="L141">                ukeywords.remove(cikey);</span>
            }
        } else {
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">            if (type.length() != 0) {</span>
                // normalize separator to &quot;-&quot;
<span class="fc" id="L146">                String tp = type.replaceAll(BaseLocale.SEP, LanguageTag.SEP);</span>
                // validate
<span class="fc" id="L148">                StringTokenIterator itr = new StringTokenIterator(tp, LanguageTag.SEP);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">                while (!itr.isDone()) {</span>
<span class="fc" id="L150">                    String s = itr.current();</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">                    if (!UnicodeLocaleExtension.isTypeSubtag(s)) {</span>
<span class="fc" id="L152">                        throw new LocaleSyntaxException(&quot;Ill-formed Unicode locale keyword type: &quot;</span>
                                                        + type,
<span class="fc" id="L154">                                                        itr.currentStart());</span>
                    }
<span class="fc" id="L156">                    itr.next();</span>
<span class="fc" id="L157">                }</span>
            }
<span class="fc bfc" id="L159" title="All 2 branches covered.">            if (ukeywords == null) {</span>
<span class="fc" id="L160">                ukeywords = new HashMap&lt;&gt;(4);</span>
            }
<span class="fc" id="L162">            ukeywords.put(cikey, type);</span>
        }
<span class="fc" id="L164">        return this;</span>
    }

    public InternalLocaleBuilder setExtension(char singleton, String value) throws LocaleSyntaxException {
        // validate key
<span class="fc" id="L169">        boolean isBcpPrivateuse = LanguageTag.isPrivateusePrefixChar(singleton);</span>
<span class="fc bfc" id="L170" title="All 4 branches covered.">        if (!isBcpPrivateuse &amp;&amp; !LanguageTag.isExtensionSingletonChar(singleton)) {</span>
<span class="fc" id="L171">            throw new LocaleSyntaxException(&quot;Ill-formed extension key: &quot; + singleton);</span>
        }

<span class="fc" id="L174">        boolean remove = LocaleUtils.isEmpty(value);</span>
<span class="fc" id="L175">        CaseInsensitiveChar key = new CaseInsensitiveChar(singleton);</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (remove) {</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">            if (UnicodeLocaleExtension.isSingletonChar(key.value())) {</span>
                // clear entire Unicode locale extension
<span class="nc bnc" id="L180" title="All 2 branches missed.">                if (uattributes != null) {</span>
<span class="nc" id="L181">                    uattributes.clear();</span>
                }
<span class="nc bnc" id="L183" title="All 2 branches missed.">                if (ukeywords != null) {</span>
<span class="nc" id="L184">                    ukeywords.clear();</span>
                }
            } else {
<span class="pc bpc" id="L187" title="2 of 4 branches missed.">                if (extensions != null &amp;&amp; extensions.containsKey(key)) {</span>
<span class="fc" id="L188">                    extensions.remove(key);</span>
                }
            }
        } else {
            // validate value
<span class="fc" id="L193">            String val = value.replaceAll(BaseLocale.SEP, LanguageTag.SEP);</span>
<span class="fc" id="L194">            StringTokenIterator itr = new StringTokenIterator(val, LanguageTag.SEP);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            while (!itr.isDone()) {</span>
<span class="fc" id="L196">                String s = itr.current();</span>
                boolean validSubtag;
<span class="fc bfc" id="L198" title="All 2 branches covered.">                if (isBcpPrivateuse) {</span>
<span class="fc" id="L199">                    validSubtag = LanguageTag.isPrivateuseSubtag(s);</span>
                } else {
<span class="fc" id="L201">                    validSubtag = LanguageTag.isExtensionSubtag(s);</span>
                }
<span class="fc bfc" id="L203" title="All 2 branches covered.">                if (!validSubtag) {</span>
<span class="fc" id="L204">                    throw new LocaleSyntaxException(&quot;Ill-formed extension value: &quot; + s,</span>
<span class="fc" id="L205">                                                    itr.currentStart());</span>
                }
<span class="fc" id="L207">                itr.next();</span>
<span class="fc" id="L208">            }</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">            if (UnicodeLocaleExtension.isSingletonChar(key.value())) {</span>
<span class="fc" id="L211">                setUnicodeLocaleExtension(val);</span>
            } else {
<span class="fc bfc" id="L213" title="All 2 branches covered.">                if (extensions == null) {</span>
<span class="fc" id="L214">                    extensions = new HashMap&lt;&gt;(4);</span>
                }
<span class="fc" id="L216">                extensions.put(key, val);</span>
            }
        }
<span class="fc" id="L219">        return this;</span>
    }

    /*
     * Set extension/private subtags in a single string representation
     */
    public InternalLocaleBuilder setExtensions(String subtags) throws LocaleSyntaxException {
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (LocaleUtils.isEmpty(subtags)) {</span>
<span class="nc" id="L227">            clearExtensions();</span>
<span class="nc" id="L228">            return this;</span>
        }
<span class="fc" id="L230">        subtags = subtags.replaceAll(BaseLocale.SEP, LanguageTag.SEP);</span>
<span class="fc" id="L231">        StringTokenIterator itr = new StringTokenIterator(subtags, LanguageTag.SEP);</span>

<span class="fc" id="L233">        List&lt;String&gt; extensions = null;</span>
<span class="fc" id="L234">        String privateuse = null;</span>

<span class="fc" id="L236">        int parsed = 0;</span>
        int start;

        // Make a list of extension subtags
<span class="fc bfc" id="L240" title="All 2 branches covered.">        while (!itr.isDone()) {</span>
<span class="fc" id="L241">            String s = itr.current();</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (LanguageTag.isExtensionSingleton(s)) {</span>
<span class="fc" id="L243">                start = itr.currentStart();</span>
<span class="fc" id="L244">                String singleton = s;</span>
<span class="fc" id="L245">                StringBuilder sb = new StringBuilder(singleton);</span>

<span class="fc" id="L247">                itr.next();</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">                while (!itr.isDone()) {</span>
<span class="fc" id="L249">                    s = itr.current();</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">                    if (LanguageTag.isExtensionSubtag(s)) {</span>
<span class="fc" id="L251">                        sb.append(LanguageTag.SEP).append(s);</span>
<span class="fc" id="L252">                        parsed = itr.currentEnd();</span>
                    } else {
                        break;
                    }
<span class="fc" id="L256">                    itr.next();</span>
                }

<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                if (parsed &lt; start) {</span>
<span class="nc" id="L260">                    throw new LocaleSyntaxException(&quot;Incomplete extension '&quot; + singleton + &quot;'&quot;,</span>
                                                    start);
                }

<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                if (extensions == null) {</span>
<span class="fc" id="L265">                    extensions = new ArrayList&lt;&gt;(4);</span>
                }
<span class="fc" id="L267">                extensions.add(sb.toString());</span>
            } else {
                break;
            }
<span class="fc" id="L271">        }</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (!itr.isDone()) {</span>
<span class="fc" id="L273">            String s = itr.current();</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">            if (LanguageTag.isPrivateusePrefix(s)) {</span>
<span class="fc" id="L275">                start = itr.currentStart();</span>
<span class="fc" id="L276">                StringBuilder sb = new StringBuilder(s);</span>

<span class="fc" id="L278">                itr.next();</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">                while (!itr.isDone()) {</span>
<span class="fc" id="L280">                    s = itr.current();</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">                    if (!LanguageTag.isPrivateuseSubtag(s)) {</span>
<span class="nc" id="L282">                        break;</span>
                    }
<span class="fc" id="L284">                    sb.append(LanguageTag.SEP).append(s);</span>
<span class="fc" id="L285">                    parsed = itr.currentEnd();</span>

<span class="fc" id="L287">                    itr.next();</span>
                }
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">                if (parsed &lt;= start) {</span>
<span class="nc" id="L290">                    throw new LocaleSyntaxException(&quot;Incomplete privateuse:&quot;</span>
<span class="nc" id="L291">                                                    + subtags.substring(start),</span>
                                                    start);
                } else {
<span class="fc" id="L294">                    privateuse = sb.toString();</span>
                }
            }
        }

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (!itr.isDone()) {</span>
<span class="nc" id="L300">            throw new LocaleSyntaxException(&quot;Ill-formed extension subtags:&quot;</span>
<span class="nc" id="L301">                                            + subtags.substring(itr.currentStart()),</span>
<span class="nc" id="L302">                                            itr.currentStart());</span>
        }

<span class="fc" id="L305">        return setExtensions(extensions, privateuse);</span>
    }

    /*
     * Set a list of BCP47 extensions and private use subtags
     * BCP47 extensions are already validated and well-formed, but may contain duplicates
     */
    private InternalLocaleBuilder setExtensions(List&lt;String&gt; bcpExtensions, String privateuse) {
<span class="fc" id="L313">        clearExtensions();</span>

<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (!LocaleUtils.isEmpty(bcpExtensions)) {</span>
<span class="fc" id="L316">            Set&lt;CaseInsensitiveChar&gt; done = new HashSet&lt;&gt;(bcpExtensions.size());</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">            for (String bcpExt : bcpExtensions) {</span>
<span class="fc" id="L318">                CaseInsensitiveChar key = new CaseInsensitiveChar(bcpExt);</span>
                // ignore duplicates
<span class="fc bfc" id="L320" title="All 2 branches covered.">                if (!done.contains(key)) {</span>
                    // each extension string contains singleton, e.g. &quot;a-abc-def&quot;
<span class="fc bfc" id="L322" title="All 2 branches covered.">                    if (UnicodeLocaleExtension.isSingletonChar(key.value())) {</span>
<span class="fc" id="L323">                        setUnicodeLocaleExtension(bcpExt.substring(2));</span>
                    } else {
<span class="fc bfc" id="L325" title="All 2 branches covered.">                        if (extensions == null) {</span>
<span class="fc" id="L326">                            extensions = new HashMap&lt;&gt;(4);</span>
                        }
<span class="fc" id="L328">                        extensions.put(key, bcpExt.substring(2));</span>
                    }
                }
<span class="fc" id="L331">                done.add(key);</span>
<span class="fc" id="L332">            }</span>
        }
<span class="fc bfc" id="L334" title="All 4 branches covered.">        if (privateuse != null &amp;&amp; privateuse.length() &gt; 0) {</span>
            // privateuse string contains prefix, e.g. &quot;x-abc-def&quot;
<span class="fc bfc" id="L336" title="All 2 branches covered.">            if (extensions == null) {</span>
<span class="fc" id="L337">                extensions = new HashMap&lt;&gt;(1);</span>
            }
<span class="fc" id="L339">            extensions.put(new CaseInsensitiveChar(privateuse), privateuse.substring(2));</span>
        }

<span class="fc" id="L342">        return this;</span>
    }

    /*
     * Reset Builder's internal state with the given language tag
     */
    public InternalLocaleBuilder setLanguageTag(LanguageTag langtag) {
<span class="fc" id="L349">        clear();</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (!langtag.getExtlangs().isEmpty()) {</span>
<span class="nc" id="L351">            language = langtag.getExtlangs().get(0);</span>
        } else {
<span class="fc" id="L353">            String lang = langtag.getLanguage();</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">            if (!lang.equals(LanguageTag.UNDETERMINED)) {</span>
<span class="fc" id="L355">                language = lang;</span>
            }
        }
<span class="fc" id="L358">        script = langtag.getScript();</span>
<span class="fc" id="L359">        region = langtag.getRegion();</span>

<span class="fc" id="L361">        List&lt;String&gt; bcpVariants = langtag.getVariants();</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (!bcpVariants.isEmpty()) {</span>
<span class="fc" id="L363">            StringBuilder var = new StringBuilder(bcpVariants.get(0));</span>
<span class="fc" id="L364">            int size = bcpVariants.size();</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">            for (int i = 1; i &lt; size; i++) {</span>
<span class="fc" id="L366">                var.append(BaseLocale.SEP).append(bcpVariants.get(i));</span>
            }
<span class="fc" id="L368">            variant = var.toString();</span>
        }

<span class="fc" id="L371">        setExtensions(langtag.getExtensions(), langtag.getPrivateuse());</span>

<span class="fc" id="L373">        return this;</span>
    }

    public InternalLocaleBuilder setLocale(BaseLocale base, LocaleExtensions localeExtensions) throws LocaleSyntaxException {
<span class="fc" id="L377">        String language = base.getLanguage();</span>
<span class="fc" id="L378">        String script = base.getScript();</span>
<span class="fc" id="L379">        String region = base.getRegion();</span>
<span class="fc" id="L380">        String variant = base.getVariant();</span>

        // Special backward compatibility support

        // Exception 1 - ja_JP_JP
<span class="fc bfc" id="L385" title="All 6 branches covered.">        if (language.equals(&quot;ja&quot;) &amp;&amp; region.equals(&quot;JP&quot;) &amp;&amp; variant.equals(&quot;JP&quot;)) {</span>
            // When locale ja_JP_JP is created, ca-japanese is always there.
            // The builder ignores the variant &quot;JP&quot;
<span class="pc bpc" id="L388" title="2 of 4 branches missed.">            assert(&quot;japanese&quot;.equals(localeExtensions.getUnicodeLocaleType(&quot;ca&quot;)));</span>
<span class="fc" id="L389">            variant = &quot;&quot;;</span>
        }
        // Exception 2 - th_TH_TH
<span class="fc bfc" id="L392" title="All 6 branches covered.">        else if (language.equals(&quot;th&quot;) &amp;&amp; region.equals(&quot;TH&quot;) &amp;&amp; variant.equals(&quot;TH&quot;)) {</span>
            // When locale th_TH_TH is created, nu-thai is always there.
            // The builder ignores the variant &quot;TH&quot;
<span class="pc bpc" id="L395" title="2 of 4 branches missed.">            assert(&quot;thai&quot;.equals(localeExtensions.getUnicodeLocaleType(&quot;nu&quot;)));</span>
<span class="fc" id="L396">            variant = &quot;&quot;;</span>
        }
        // Exception 3 - no_NO_NY
<span class="fc bfc" id="L399" title="All 6 branches covered.">        else if (language.equals(&quot;no&quot;) &amp;&amp; region.equals(&quot;NO&quot;) &amp;&amp; variant.equals(&quot;NY&quot;)) {</span>
            // no_NO_NY is a valid locale and used by Java 6 or older versions.
            // The build ignores the variant &quot;NY&quot; and change the language to &quot;nn&quot;.
<span class="fc" id="L402">            language = &quot;nn&quot;;</span>
<span class="fc" id="L403">            variant = &quot;&quot;;</span>
        }

        // Validate base locale fields before updating internal state.
        // LocaleExtensions always store validated/canonicalized values,
        // so no checks are necessary.
<span class="fc bfc" id="L409" title="All 4 branches covered.">        if (language.length() &gt; 0 &amp;&amp; !LanguageTag.isLanguage(language)) {</span>
<span class="fc" id="L410">            throw new LocaleSyntaxException(&quot;Ill-formed language: &quot; + language);</span>
        }

<span class="pc bpc" id="L413" title="1 of 4 branches missed.">        if (script.length() &gt; 0 &amp;&amp; !LanguageTag.isScript(script)) {</span>
<span class="nc" id="L414">            throw new LocaleSyntaxException(&quot;Ill-formed script: &quot; + script);</span>
        }

<span class="pc bpc" id="L417" title="1 of 4 branches missed.">        if (region.length() &gt; 0 &amp;&amp; !LanguageTag.isRegion(region)) {</span>
<span class="nc" id="L418">            throw new LocaleSyntaxException(&quot;Ill-formed region: &quot; + region);</span>
        }

<span class="fc bfc" id="L421" title="All 2 branches covered.">        if (variant.length() &gt; 0) {</span>
<span class="fc" id="L422">            int errIdx = checkVariants(variant, BaseLocale.SEP);</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            if (errIdx != -1) {</span>
<span class="nc" id="L424">                throw new LocaleSyntaxException(&quot;Ill-formed variant: &quot; + variant, errIdx);</span>
            }
        }

        // The input locale is validated at this point.
        // Now, updating builder's internal fields.
<span class="fc" id="L430">        this.language = language;</span>
<span class="fc" id="L431">        this.script = script;</span>
<span class="fc" id="L432">        this.region = region;</span>
<span class="fc" id="L433">        this.variant = variant;</span>
<span class="fc" id="L434">        clearExtensions();</span>

<span class="fc bfc" id="L436" title="All 2 branches covered.">        Set&lt;Character&gt; extKeys = (localeExtensions == null) ? null : localeExtensions.getKeys();</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (extKeys != null) {</span>
            // map localeExtensions back to builder's internal format
<span class="fc bfc" id="L439" title="All 2 branches covered.">            for (Character key : extKeys) {</span>
<span class="fc" id="L440">                Extension e = localeExtensions.getExtension(key);</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">                if (e instanceof UnicodeLocaleExtension) {</span>
<span class="fc" id="L442">                    UnicodeLocaleExtension ue = (UnicodeLocaleExtension)e;</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">                    for (String uatr : ue.getUnicodeLocaleAttributes()) {</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                        if (uattributes == null) {</span>
<span class="nc" id="L445">                            uattributes = new HashSet&lt;&gt;(4);</span>
                        }
<span class="nc" id="L447">                        uattributes.add(new CaseInsensitiveString(uatr));</span>
<span class="nc" id="L448">                    }</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">                    for (String ukey : ue.getUnicodeLocaleKeys()) {</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">                        if (ukeywords == null) {</span>
<span class="fc" id="L451">                            ukeywords = new HashMap&lt;&gt;(4);</span>
                        }
<span class="fc" id="L453">                        ukeywords.put(new CaseInsensitiveString(ukey), ue.getUnicodeLocaleType(ukey));</span>
<span class="fc" id="L454">                    }</span>
<span class="fc" id="L455">                } else {</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">                    if (extensions == null) {</span>
<span class="fc" id="L457">                        extensions = new HashMap&lt;&gt;(4);</span>
                    }
<span class="fc" id="L459">                    extensions.put(new CaseInsensitiveChar(key), e.getValue());</span>
                }
<span class="fc" id="L461">            }</span>
        }
<span class="fc" id="L463">        return this;</span>
    }

    public InternalLocaleBuilder clear() {
<span class="fc" id="L467">        language = &quot;&quot;;</span>
<span class="fc" id="L468">        script = &quot;&quot;;</span>
<span class="fc" id="L469">        region = &quot;&quot;;</span>
<span class="fc" id="L470">        variant = &quot;&quot;;</span>
<span class="fc" id="L471">        clearExtensions();</span>
<span class="fc" id="L472">        return this;</span>
    }

    public InternalLocaleBuilder clearExtensions() {
<span class="fc bfc" id="L476" title="All 2 branches covered.">        if (extensions != null) {</span>
<span class="fc" id="L477">            extensions.clear();</span>
        }
<span class="fc bfc" id="L479" title="All 2 branches covered.">        if (uattributes != null) {</span>
<span class="fc" id="L480">            uattributes.clear();</span>
        }
<span class="fc bfc" id="L482" title="All 2 branches covered.">        if (ukeywords != null) {</span>
<span class="fc" id="L483">            ukeywords.clear();</span>
        }
<span class="fc" id="L485">        return this;</span>
    }

    public BaseLocale getBaseLocale() {
<span class="fc" id="L489">        String language = this.language;</span>
<span class="fc" id="L490">        String script = this.script;</span>
<span class="fc" id="L491">        String region = this.region;</span>
<span class="fc" id="L492">        String variant = this.variant;</span>

        // Special private use subtag sequence identified by &quot;lvariant&quot; will be
        // interpreted as Java variant.
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (extensions != null) {</span>
<span class="fc" id="L497">            String privuse = extensions.get(PRIVATEUSE_KEY);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">            if (privuse != null) {</span>
<span class="fc" id="L499">                StringTokenIterator itr = new StringTokenIterator(privuse, LanguageTag.SEP);</span>
<span class="fc" id="L500">                boolean sawPrefix = false;</span>
<span class="fc" id="L501">                int privVarStart = -1;</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">                while (!itr.isDone()) {</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">                    if (sawPrefix) {</span>
<span class="fc" id="L504">                        privVarStart = itr.currentStart();</span>
<span class="fc" id="L505">                        break;</span>
                    }
<span class="fc bfc" id="L507" title="All 2 branches covered.">                    if (LocaleUtils.caseIgnoreMatch(itr.current(), LanguageTag.PRIVUSE_VARIANT_PREFIX)) {</span>
<span class="fc" id="L508">                        sawPrefix = true;</span>
                    }
<span class="fc" id="L510">                    itr.next();</span>
                }
<span class="fc bfc" id="L512" title="All 2 branches covered.">                if (privVarStart != -1) {</span>
<span class="fc" id="L513">                    StringBuilder sb = new StringBuilder(variant);</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">                    if (sb.length() != 0) {</span>
<span class="nc" id="L515">                        sb.append(BaseLocale.SEP);</span>
                    }
<span class="fc" id="L517">                    sb.append(privuse.substring(privVarStart).replaceAll(LanguageTag.SEP,</span>
                                                                         BaseLocale.SEP));
<span class="fc" id="L519">                    variant = sb.toString();</span>
                }
            }
        }

<span class="fc" id="L524">        return BaseLocale.getInstance(language, script, region, variant);</span>
    }

    public LocaleExtensions getLocaleExtensions() {
<span class="fc bfc" id="L528" title="All 4 branches covered.">        if (LocaleUtils.isEmpty(extensions) &amp;&amp; LocaleUtils.isEmpty(uattributes)</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">            &amp;&amp; LocaleUtils.isEmpty(ukeywords)) {</span>
<span class="fc" id="L530">            return null;</span>
        }

<span class="fc" id="L533">        LocaleExtensions lext = new LocaleExtensions(extensions, uattributes, ukeywords);</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">        return lext.isEmpty() ? null : lext;</span>
    }

    /*
     * Remove special private use subtag sequence identified by &quot;lvariant&quot;
     * and return the rest. Only used by LocaleExtensions
     */
    static String removePrivateuseVariant(String privuseVal) {
<span class="fc" id="L542">        StringTokenIterator itr = new StringTokenIterator(privuseVal, LanguageTag.SEP);</span>

        // Note: privateuse value &quot;abc-lvariant&quot; is unchanged
        // because no subtags after &quot;lvariant&quot;.

<span class="fc" id="L547">        int prefixStart = -1;</span>
<span class="fc" id="L548">        boolean sawPrivuseVar = false;</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">        while (!itr.isDone()) {</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (prefixStart != -1) {</span>
                // Note: privateuse value &quot;abc-lvariant&quot; is unchanged
                // because no subtags after &quot;lvariant&quot;.
<span class="fc" id="L553">                sawPrivuseVar = true;</span>
<span class="fc" id="L554">                break;</span>
            }
<span class="fc bfc" id="L556" title="All 2 branches covered.">            if (LocaleUtils.caseIgnoreMatch(itr.current(), LanguageTag.PRIVUSE_VARIANT_PREFIX)) {</span>
<span class="fc" id="L557">                prefixStart = itr.currentStart();</span>
            }
<span class="fc" id="L559">            itr.next();</span>
        }
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (!sawPrivuseVar) {</span>
<span class="fc" id="L562">            return privuseVal;</span>
        }

<span class="pc bpc" id="L565" title="4 of 6 branches missed.">        assert(prefixStart == 0 || prefixStart &gt; 1);</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        return (prefixStart == 0) ? null : privuseVal.substring(0, prefixStart -1);</span>
    }

    /*
     * Check if the given variant subtags separated by the given
     * separator(s) are valid
     */
    private int checkVariants(String variants, String sep) {
<span class="fc" id="L574">        StringTokenIterator itr = new StringTokenIterator(variants, sep);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">        while (!itr.isDone()) {</span>
<span class="fc" id="L576">            String s = itr.current();</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (!LanguageTag.isVariant(s)) {</span>
<span class="fc" id="L578">                return itr.currentStart();</span>
            }
<span class="fc" id="L580">            itr.next();</span>
<span class="fc" id="L581">        }</span>
<span class="fc" id="L582">        return -1;</span>
    }

    /*
     * Private methods parsing Unicode Locale Extension subtags.
     * Duplicated attributes/keywords will be ignored.
     * The input must be a valid extension subtags (excluding singleton).
     */
    private void setUnicodeLocaleExtension(String subtags) {
        // wipe out existing attributes/keywords
<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (uattributes != null) {</span>
<span class="fc" id="L593">            uattributes.clear();</span>
        }
<span class="fc bfc" id="L595" title="All 2 branches covered.">        if (ukeywords != null) {</span>
<span class="fc" id="L596">            ukeywords.clear();</span>
        }

<span class="fc" id="L599">        StringTokenIterator itr = new StringTokenIterator(subtags, LanguageTag.SEP);</span>

        // parse attributes
<span class="fc bfc" id="L602" title="All 2 branches covered.">        while (!itr.isDone()) {</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">            if (!UnicodeLocaleExtension.isAttribute(itr.current())) {</span>
<span class="fc" id="L604">                break;</span>
            }
<span class="fc bfc" id="L606" title="All 2 branches covered.">            if (uattributes == null) {</span>
<span class="fc" id="L607">                uattributes = new HashSet&lt;&gt;(4);</span>
            }
<span class="fc" id="L609">            uattributes.add(new CaseInsensitiveString(itr.current()));</span>
<span class="fc" id="L610">            itr.next();</span>
        }

        // parse keywords
<span class="fc" id="L614">        CaseInsensitiveString key = null;</span>
        String type;
<span class="fc" id="L616">        int typeStart = -1;</span>
<span class="fc" id="L617">        int typeEnd = -1;</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">        while (!itr.isDone()) {</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">            if (key != null) {</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">                if (UnicodeLocaleExtension.isKey(itr.current())) {</span>
                    // next keyword - emit previous one
<span class="pc bpc" id="L622" title="3 of 6 branches missed.">                    assert(typeStart == -1 || typeEnd != -1);</span>
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">                    type = (typeStart == -1) ? &quot;&quot; : subtags.substring(typeStart, typeEnd);</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">                    if (ukeywords == null) {</span>
<span class="fc" id="L625">                        ukeywords = new HashMap&lt;&gt;(4);</span>
                    }
<span class="fc" id="L627">                    ukeywords.put(key, type);</span>

                    // reset keyword info
<span class="fc" id="L630">                    CaseInsensitiveString tmpKey = new CaseInsensitiveString(itr.current());</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">                    key = ukeywords.containsKey(tmpKey) ? null : tmpKey;</span>
<span class="fc" id="L632">                    typeStart = typeEnd = -1;</span>
<span class="fc" id="L633">                } else {</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">                    if (typeStart == -1) {</span>
<span class="fc" id="L635">                        typeStart = itr.currentStart();</span>
                    }
<span class="fc" id="L637">                    typeEnd = itr.currentEnd();</span>
                }
<span class="fc bfc" id="L639" title="All 2 branches covered.">            } else if (UnicodeLocaleExtension.isKey(itr.current())) {</span>
                // 1. first keyword or
                // 2. next keyword, but previous one was duplicate
<span class="fc" id="L642">                key = new CaseInsensitiveString(itr.current());</span>
<span class="pc bpc" id="L643" title="1 of 4 branches missed.">                if (ukeywords != null &amp;&amp; ukeywords.containsKey(key)) {</span>
                    // duplicate
<span class="nc" id="L645">                    key = null;</span>
                }
            }

<span class="fc bfc" id="L649" title="All 2 branches covered.">            if (!itr.hasNext()) {</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                if (key != null) {</span>
                    // last keyword
<span class="pc bpc" id="L652" title="2 of 6 branches missed.">                    assert(typeStart == -1 || typeEnd != -1);</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">                    type = (typeStart == -1) ? &quot;&quot; : subtags.substring(typeStart, typeEnd);</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">                    if (ukeywords == null) {</span>
<span class="fc" id="L655">                        ukeywords = new HashMap&lt;&gt;(4);</span>
                    }
<span class="fc" id="L657">                    ukeywords.put(key, type);</span>
                }
                break;
            }

<span class="fc" id="L662">            itr.next();</span>
        }
<span class="fc" id="L664">    }</span>

    static final class CaseInsensitiveString {
        private final String str, lowerStr;

<span class="fc" id="L669">        CaseInsensitiveString(String s) {</span>
<span class="fc" id="L670">            str = s;</span>
<span class="fc" id="L671">            lowerStr = LocaleUtils.toLowerString(s);</span>
<span class="fc" id="L672">        }</span>

        public String value() {
<span class="fc" id="L675">            return str;</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L680">            return lowerStr.hashCode();</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L686">                return true;</span>
            }
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">            if (!(obj instanceof CaseInsensitiveString)) {</span>
<span class="nc" id="L689">                return false;</span>
            }
<span class="fc" id="L691">            return lowerStr.equals(((CaseInsensitiveString)obj).lowerStr);</span>
        }
    }

    static final class CaseInsensitiveChar {
        private final char ch, lowerCh;

        /**
         * Constructs a CaseInsensitiveChar with the first char of the
         * given s.
         */
        private CaseInsensitiveChar(String s) {
<span class="fc" id="L703">            this(s.charAt(0));</span>
<span class="fc" id="L704">        }</span>

<span class="fc" id="L706">        CaseInsensitiveChar(char c) {</span>
<span class="fc" id="L707">            ch = c;</span>
<span class="fc" id="L708">            lowerCh = LocaleUtils.toLower(ch);</span>
<span class="fc" id="L709">        }</span>

        public char value() {
<span class="fc" id="L712">            return ch;</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L717">            return lowerCh;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L723">                return true;</span>
            }
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">            if (!(obj instanceof CaseInsensitiveChar)) {</span>
<span class="nc" id="L726">                return false;</span>
            }
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">            return lowerCh == ((CaseInsensitiveChar)obj).lowerCh;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>