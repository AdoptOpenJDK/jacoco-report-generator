<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DTraceProvider.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tracing.dtrace</a> &gt; <span class="el_source">DTraceProvider.java</span></div><h1>DTraceProvider.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tracing.dtrace;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.annotation.Annotation;

import sun.tracing.ProviderSkeleton;
import sun.tracing.ProbeSkeleton;
import com.sun.tracing.Provider;
import com.sun.tracing.ProbeName;
import com.sun.tracing.dtrace.Attributes;
import com.sun.tracing.dtrace.ModuleName;
import com.sun.tracing.dtrace.FunctionName;
import com.sun.tracing.dtrace.StabilityLevel;
import com.sun.tracing.dtrace.DependencyClass;

import sun.misc.ProxyGenerator;

<span class="nc bnc" id="L47" title="All 2 branches missed.">class DTraceProvider extends ProviderSkeleton {</span>

    private Activation activation;
    private Object proxy;

    // For proxy generation
<span class="nc" id="L53">    private final static Class[] constructorParams = { InvocationHandler.class };</span>
<span class="nc" id="L54">    private final String proxyClassNamePrefix = &quot;$DTraceTracingProxy&quot;;</span>

    static final String DEFAULT_MODULE = &quot;java_tracing&quot;;
    static final String DEFAULT_FUNCTION = &quot;unspecified&quot;;

<span class="nc" id="L59">    private static long nextUniqueNumber = 0;</span>
    private static synchronized long getUniqueNumber() {
<span class="nc" id="L61">        return nextUniqueNumber++;</span>
    }

    protected ProbeSkeleton createProbe(Method m) {
<span class="nc" id="L65">        return new DTraceProbe(proxy, m);</span>
    }

    DTraceProvider(Class&lt;? extends Provider&gt; type) {
<span class="nc" id="L69">        super(type);</span>
<span class="nc" id="L70">    }</span>

    void setProxy(Object p) {
<span class="nc" id="L73">        proxy = p;</span>
<span class="nc" id="L74">    }</span>

    void setActivation(Activation a) {
<span class="nc" id="L77">        this.activation = a;</span>
<span class="nc" id="L78">    }</span>

    public void dispose() {
<span class="nc bnc" id="L81" title="All 2 branches missed.">        if (activation != null) {</span>
<span class="nc" id="L82">            activation.disposeProvider(this);</span>
<span class="nc" id="L83">            activation = null;</span>
        }
<span class="nc" id="L85">        super.dispose();</span>
<span class="nc" id="L86">    }</span>

    /**
     * Magic routine which creates an implementation of the user's interface.
     *
     * This method uses the ProxyGenerator directly to bypass the
     * java.lang.reflect.proxy cache so that we get a unique class each
     * time it's called and can't accidently reuse a $Proxy class.
     *
     * @return an implementation of the user's interface
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T extends Provider&gt; T newProxyInstance() {
        /*
         * Choose a name for the proxy class to generate.
         */
<span class="nc" id="L102">        long num = getUniqueNumber();</span>

<span class="nc" id="L104">        String proxyPkg = &quot;&quot;;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (!Modifier.isPublic(providerType.getModifiers())) {</span>
<span class="nc" id="L106">            String name = providerType.getName();</span>
<span class="nc" id="L107">            int n = name.lastIndexOf('.');</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            proxyPkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span>
        }

<span class="nc" id="L111">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span>

        /*
         * Generate the specified proxy class.
         */
<span class="nc" id="L116">        Class&lt;?&gt; proxyClass = null;</span>
<span class="nc" id="L117">        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span>
                proxyName, new Class&lt;?&gt;[] { providerType });
        try {
<span class="nc" id="L120">            proxyClass = JVM.defineClass(</span>
<span class="nc" id="L121">                providerType.getClassLoader(), proxyName,</span>
                proxyClassFile, 0, proxyClassFile.length);
<span class="nc" id="L123">        } catch (ClassFormatError e) {</span>
            /*
             * A ClassFormatError here means that (barring bugs in the
             * proxy class generation code) there was some other
             * invalid aspect of the arguments supplied to the proxy
             * class creation (such as virtual machine limitations
             * exceeded).
             */
<span class="nc" id="L131">            throw new IllegalArgumentException(e.toString());</span>
<span class="nc" id="L132">        }</span>

        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
<span class="nc" id="L138">            Constructor cons = proxyClass.getConstructor(constructorParams);</span>
<span class="nc" id="L139">            return (T)cons.newInstance(new Object[] { this });</span>
<span class="nc" id="L140">        } catch (ReflectiveOperationException e) {</span>
<span class="nc" id="L141">            throw new InternalError(e.toString(), e);</span>
        }
    }

    // In the normal case, the proxy object's method implementations will call
    // this method (it usually calls the ProviderSkeleton's version).  That
    // method uses the passed 'method' object to lookup the associated
    // 'ProbeSkeleton' and calls uncheckedTrigger() on that probe to cause the
    // probe to fire.  DTrace probes are different in that the proxy class's
    // methods are immediately overridden with native code to fire the probe
    // directly.  So this method should never get invoked.  We also wire up the
    // DTraceProbe.uncheckedTrigger() method to call the proxy method instead
    // of doing the work itself.
    protected void triggerProbe(Method method, Object[] args) {
<span class="nc bnc" id="L155" title="All 2 branches missed.">        assert false : &quot;This method should have been overridden by the JVM&quot;;</span>
<span class="nc" id="L156">    }</span>

    public String getProviderName() {
<span class="nc" id="L159">        return super.getProviderName();</span>
    }

    String getModuleName() {
<span class="nc" id="L163">        return getAnnotationString(</span>
            providerType, ModuleName.class, DEFAULT_MODULE);
    }

    static String getProbeName(Method method) {
<span class="nc" id="L168">        return getAnnotationString(</span>
<span class="nc" id="L169">            method, ProbeName.class, method.getName());</span>
    }

    static String getFunctionName(Method method) {
<span class="nc" id="L173">        return getAnnotationString(</span>
            method, FunctionName.class, DEFAULT_FUNCTION);
    }

    DTraceProbe[] getProbes() {
<span class="nc" id="L178">        return probes.values().toArray(new DTraceProbe[0]);</span>
    }

    StabilityLevel getNameStabilityFor(Class&lt;? extends Annotation&gt; type) {
<span class="nc" id="L182">        Attributes attrs = (Attributes)getAnnotationValue(</span>
            providerType, type, &quot;value&quot;, null);
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (attrs == null) {</span>
<span class="nc" id="L185">            return StabilityLevel.PRIVATE;</span>
        } else {
<span class="nc" id="L187">            return attrs.name();</span>
        }
    }

    StabilityLevel getDataStabilityFor(Class&lt;? extends Annotation&gt; type) {
<span class="nc" id="L192">        Attributes attrs = (Attributes)getAnnotationValue(</span>
            providerType, type, &quot;value&quot;, null);
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (attrs == null) {</span>
<span class="nc" id="L195">            return StabilityLevel.PRIVATE;</span>
        } else {
<span class="nc" id="L197">            return attrs.data();</span>
        }
    }

    DependencyClass getDependencyClassFor(Class&lt;? extends Annotation&gt; type) {
<span class="nc" id="L202">        Attributes attrs = (Attributes)getAnnotationValue(</span>
            providerType, type, &quot;value&quot;, null);
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (attrs == null) {</span>
<span class="nc" id="L205">            return DependencyClass.UNKNOWN;</span>
        } else {
<span class="nc" id="L207">            return attrs.dependency();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>