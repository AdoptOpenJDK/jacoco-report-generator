<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PerfDataBuffer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.jvmstat.perfdata.monitor.v2_0</a> &gt; <span class="el_source">PerfDataBuffer.java</span></div><h1>PerfDataBuffer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.jvmstat.perfdata.monitor.v2_0;

import sun.jvmstat.monitor.*;
import sun.jvmstat.perfdata.monitor.*;
import java.util.*;
import java.util.regex.*;
import java.nio.*;

/**
 * The concrete implementation of version 2.0 of the HotSpot PerfData
 * Instrumentation buffer. This class is responsible for parsing the
 * instrumentation memory and constructing the necessary objects to
 * represent and access the instrumentation objects contained in the
 * memory buffer.
 * &lt;p&gt;
 * The structure of the 2.0 entry is defined in struct PerfDataEnry
 * as decsribed in perfMemory.hpp. This structure looks like:
 * &lt;pre&gt;
 * typedef struct {
 *   jint entry_length;         // entry length in bytes
 *   jint name_offset;          // offset to entry name, relative to start
 *                              // of entry
 *   jint vector_length;        // length of the vector. If 0, then scalar.
 *   jbyte data_type;           // JNI field descriptor type
 *   jbyte flags;               // miscellaneous attribute flags
 *                              // 0x01 - supported
 *   jbyte data_units;          // unit of measure attribute
 *   jbyte data_variability;    // variability attribute
 *   jbyte data_offset;         // offset to data item, relative to start
 *                              // of entry.
 * } PerfDataEntry;
 * &lt;/pre&gt;
 *
 * @author Brian Doherty
 * @since 1.5
 * @see AbstractPerfDataBuffer
 */
<span class="nc bnc" id="L63" title="All 2 branches missed.">public class PerfDataBuffer extends PerfDataBufferImpl {</span>

    private static final boolean DEBUG = false;
<span class="nc" id="L66">    private static final int syncWaitMs =</span>
<span class="nc" id="L67">            Integer.getInteger(&quot;sun.jvmstat.perdata.syncWaitMs&quot;, 5000);</span>
<span class="nc" id="L68">    private static final ArrayList EMPTY_LIST = new ArrayList(0);</span>

    /*
     * These are primarily for documentary purposes and the match up
     * with the PerfDataEntry structure in perfMemory.hpp. They are
     * generally unused in this code, but they are kept consistent with
     * the data structure just in case some unforseen need arrises.
     */
    private final static int PERFDATA_ENTRYLENGTH_OFFSET=0;
    private final static int PERFDATA_ENTRYLENGTH_SIZE=4;   // sizeof(int)
    private final static int PERFDATA_NAMEOFFSET_OFFSET=4;
    private final static int PERFDATA_NAMEOFFSET_SIZE=4;    // sizeof(int)
    private final static int PERFDATA_VECTORLENGTH_OFFSET=8;
    private final static int PERFDATA_VECTORLENGTH_SIZE=4;  // sizeof(int)
    private final static int PERFDATA_DATATYPE_OFFSET=12;
    private final static int PERFDATA_DATATYPE_SIZE=1;      // sizeof(byte)
    private final static int PERFDATA_FLAGS_OFFSET=13;
    private final static int PERFDATA_FLAGS_SIZE=1;       // sizeof(byte)
    private final static int PERFDATA_DATAUNITS_OFFSET=14;
    private final static int PERFDATA_DATAUNITS_SIZE=1;     // sizeof(byte)
    private final static int PERFDATA_DATAVAR_OFFSET=15;
    private final static int PERFDATA_DATAVAR_SIZE=1;       // sizeof(byte)
    private final static int PERFDATA_DATAOFFSET_OFFSET=16;
    private final static int PERFDATA_DATAOFFSET_SIZE=4;    // sizeof(int)

    PerfDataBufferPrologue prologue;
    int nextEntry;
    long lastNumEntries;
    IntegerMonitor overflow;
    ArrayList&lt;Monitor&gt; insertedMonitors;

    /**
     * Construct a PerfDataBuffer instance.
     * &lt;p&gt;
     * This class is dynamically loaded by
     * {@link AbstractPerfDataBuffer#createPerfDataBuffer}, and this
     * constructor is called to instantiate the instance.
     *
     * @param buffer the buffer containing the instrumentation data
     * @param lvmid the Local Java Virtual Machine Identifier for this
     *              instrumentation buffer.
     */
    public PerfDataBuffer(ByteBuffer buffer, int lvmid)
           throws MonitorException {
<span class="nc" id="L112">        super(buffer, lvmid);</span>
<span class="nc" id="L113">        prologue = new PerfDataBufferPrologue(buffer);</span>
<span class="nc" id="L114">        this.buffer.order(prologue.getByteOrder());</span>
<span class="nc" id="L115">    }</span>

    /**
     * {@inheritDoc}
     */
    protected void buildMonitorMap(Map&lt;String, Monitor&gt;  map) throws MonitorException {
<span class="nc bnc" id="L121" title="All 4 branches missed.">        assert Thread.holdsLock(this);</span>

        // start at the beginning of the buffer
<span class="nc" id="L124">        buffer.rewind();</span>

        // create pseudo monitors
<span class="nc" id="L127">        buildPseudoMonitors(map);</span>

        // wait for the target JVM to indicate that it's intrumentation
        // buffer is safely accessible
<span class="nc" id="L131">        synchWithTarget();</span>

        // parse the currently defined entries starting at the first entry.
<span class="nc" id="L134">        nextEntry = prologue.getEntryOffset();</span>

        // record the number of entries before parsing the structure
<span class="nc" id="L137">        int numEntries = prologue.getNumEntries();</span>

        // start parsing
<span class="nc" id="L140">        Monitor monitor = getNextMonitorEntry();</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        while (monitor != null) {</span>
<span class="nc" id="L142">            map.put(monitor.getName(), monitor);</span>
<span class="nc" id="L143">            monitor = getNextMonitorEntry();</span>
        }

        /*
         * keep track of the current number of entries in the shared
         * memory for new entry detection purposes. It's possible for
         * the data structure to be modified while the Map is being
         * built and the entry count in the header might change while
         * we are parsing it. The map will contain all the counters
         * found, but the number recorded in numEntries might be small
         * than what than the number we actually parsed (due to asynchronous
         * updates). This discrepency is handled by ignoring any re-parsed
         * entries when updating the Map in getNewMonitors().
         */
<span class="nc" id="L157">        lastNumEntries = numEntries;</span>

        // keep track of the monitors just added.
<span class="nc" id="L160">        insertedMonitors = new ArrayList&lt;Monitor&gt;(map.values());</span>
<span class="nc" id="L161">    }</span>

    /**
     * {@inheritDoc}
     */
    protected void getNewMonitors(Map&lt;String, Monitor&gt; map) throws MonitorException {
<span class="nc bnc" id="L167" title="All 4 branches missed.">        assert Thread.holdsLock(this);</span>

<span class="nc" id="L169">        int numEntries = prologue.getNumEntries();</span>

<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (numEntries &gt; lastNumEntries) {</span>
<span class="nc" id="L172">            lastNumEntries = numEntries;</span>
<span class="nc" id="L173">            Monitor monitor = getNextMonitorEntry();</span>

<span class="nc bnc" id="L175" title="All 2 branches missed.">            while (monitor != null) {</span>
<span class="nc" id="L176">                String name = monitor.getName();</span>

                // guard against re-parsed entries
<span class="nc bnc" id="L179" title="All 2 branches missed.">                if (!map.containsKey(name)) {</span>
<span class="nc" id="L180">                    map.put(name, monitor);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                    if (insertedMonitors != null) {</span>
<span class="nc" id="L182">                        insertedMonitors.add(monitor);</span>
                    }
                }
<span class="nc" id="L185">                monitor = getNextMonitorEntry();</span>
<span class="nc" id="L186">            }</span>
        }
<span class="nc" id="L188">    }</span>

    /**
     * {@inheritDoc}
     */
    protected MonitorStatus getMonitorStatus(Map&lt;String, Monitor&gt; map) throws MonitorException {
<span class="nc bnc" id="L194" title="All 4 branches missed.">        assert Thread.holdsLock(this);</span>
<span class="nc bnc" id="L195" title="All 4 branches missed.">        assert insertedMonitors != null;</span>

        // load any new monitors
<span class="nc" id="L198">        getNewMonitors(map);</span>

        // current implementation doesn't support deletion of reuse of entries
<span class="nc" id="L201">        ArrayList removed = EMPTY_LIST;</span>
<span class="nc" id="L202">        ArrayList inserted = insertedMonitors;</span>

<span class="nc" id="L204">        insertedMonitors = new ArrayList&lt;Monitor&gt;();</span>
<span class="nc" id="L205">        return new MonitorStatus(inserted, removed);</span>
    }

    /**
     * Build the pseudo monitors used to map the prolog data into counters.
     */
    protected void buildPseudoMonitors(Map&lt;String, Monitor&gt; map) {
<span class="nc" id="L212">        Monitor monitor = null;</span>
<span class="nc" id="L213">        String name = null;</span>
<span class="nc" id="L214">        IntBuffer ib = null;</span>

<span class="nc" id="L216">        name = PerfDataBufferPrologue.PERFDATA_MAJOR_NAME;</span>
<span class="nc" id="L217">        ib = prologue.majorVersionBuffer();</span>
<span class="nc" id="L218">        monitor = new PerfIntegerMonitor(name, Units.NONE,</span>
                                         Variability.CONSTANT, false, ib);
<span class="nc" id="L220">        map.put(name, monitor);</span>

<span class="nc" id="L222">        name = PerfDataBufferPrologue.PERFDATA_MINOR_NAME;</span>
<span class="nc" id="L223">        ib = prologue.minorVersionBuffer();</span>
<span class="nc" id="L224">        monitor = new PerfIntegerMonitor(name, Units.NONE,</span>
                                         Variability.CONSTANT, false, ib);
<span class="nc" id="L226">        map.put(name, monitor);</span>

<span class="nc" id="L228">        name = PerfDataBufferPrologue.PERFDATA_BUFFER_SIZE_NAME;</span>
<span class="nc" id="L229">        ib = prologue.sizeBuffer();</span>
<span class="nc" id="L230">        monitor = new PerfIntegerMonitor(name, Units.BYTES,</span>
                                         Variability.MONOTONIC, false, ib);
<span class="nc" id="L232">        map.put(name, monitor);</span>

<span class="nc" id="L234">        name = PerfDataBufferPrologue.PERFDATA_BUFFER_USED_NAME;</span>
<span class="nc" id="L235">        ib = prologue.usedBuffer();</span>
<span class="nc" id="L236">        monitor = new PerfIntegerMonitor(name, Units.BYTES,</span>
                                         Variability.MONOTONIC, false, ib);
<span class="nc" id="L238">        map.put(name, monitor);</span>

<span class="nc" id="L240">        name = PerfDataBufferPrologue.PERFDATA_OVERFLOW_NAME;</span>
<span class="nc" id="L241">        ib = prologue.overflowBuffer();</span>
<span class="nc" id="L242">        monitor = new PerfIntegerMonitor(name, Units.BYTES,</span>
                                         Variability.MONOTONIC, false, ib);
<span class="nc" id="L244">        map.put(name, monitor);</span>
<span class="nc" id="L245">        this.overflow = (IntegerMonitor)monitor;</span>

<span class="nc" id="L247">        name = PerfDataBufferPrologue.PERFDATA_MODTIMESTAMP_NAME;</span>
<span class="nc" id="L248">        LongBuffer lb = prologue.modificationTimeStampBuffer();</span>
<span class="nc" id="L249">        monitor = new PerfLongMonitor(name, Units.TICKS,</span>
                                      Variability.MONOTONIC, false, lb);
<span class="nc" id="L251">        map.put(name, monitor);</span>
<span class="nc" id="L252">    }</span>

    /**
     * Method that waits until the target jvm indicates that
     * its shared memory is safe to access.
     */
    protected void synchWithTarget() throws MonitorException {
        /*
         * synch must happen with syncWaitMs from now. Default is 5 seconds,
         * which is reasonabally generous and should provide for extreme
         * situations like startup delays due to allocation of large ISM heaps.
         */
<span class="nc" id="L264">        long timeLimit = System.currentTimeMillis() + syncWaitMs;</span>

        // loop waiting for the accessible indicater to be non-zero
<span class="nc" id="L267">        log(&quot;synchWithTarget: &quot; + lvmid + &quot; &quot;);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        while (!prologue.isAccessible()) {</span>

<span class="nc" id="L270">            log(&quot;.&quot;);</span>

            // give the target jvm a chance to complete initializatoin
<span class="nc" id="L273">            try { Thread.sleep(20); } catch (InterruptedException e) { }</span>

<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (System.currentTimeMillis() &gt; timeLimit) {</span>
<span class="nc" id="L276">                logln(&quot;failed: &quot; + lvmid);</span>
<span class="nc" id="L277">                throw new MonitorException(&quot;Could not synchronize with target&quot;);</span>
            }
        }
<span class="nc" id="L280">        logln(&quot;success: &quot; + lvmid);</span>
<span class="nc" id="L281">    }</span>

    /**
     * method to extract the next monitor entry from the instrumentation memory.
     * assumes that nextEntry is the offset into the byte array
     * at which to start the search for the next entry. method leaves
     * next entry pointing to the next entry or to the end of data.
     */
    protected Monitor getNextMonitorEntry() throws MonitorException {
<span class="nc" id="L290">        Monitor monitor = null;</span>

        // entries are always 4 byte aligned.
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if ((nextEntry % 4) != 0) {</span>
<span class="nc" id="L294">            throw new MonitorStructureException(</span>
                    &quot;Misaligned entry index: &quot;
<span class="nc" id="L296">                    + Integer.toHexString(nextEntry));</span>
        }

        // protect againt a corrupted shard memory region.
<span class="nc bnc" id="L300" title="All 4 branches missed.">        if ((nextEntry &lt; 0)  || (nextEntry &gt; buffer.limit())) {</span>
<span class="nc" id="L301">            throw new MonitorStructureException(</span>
                    &quot;Entry index out of bounds: &quot;
<span class="nc" id="L303">                    + Integer.toHexString(nextEntry)</span>
<span class="nc" id="L304">                    + &quot;, limit = &quot; + Integer.toHexString(buffer.limit()));</span>
        }

        // check for end of the buffer
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (nextEntry == buffer.limit()) {</span>
<span class="nc" id="L309">            logln(&quot;getNextMonitorEntry():&quot;</span>
                  + &quot; nextEntry == buffer.limit(): returning&quot;);
<span class="nc" id="L311">            return null;</span>
        }

<span class="nc" id="L314">        buffer.position(nextEntry);</span>

<span class="nc" id="L316">        int entryStart = buffer.position();</span>
<span class="nc" id="L317">        int entryLength = buffer.getInt();</span>

        // check for valid entry length
<span class="nc bnc" id="L320" title="All 4 branches missed.">        if ((entryLength &lt; 0) || (entryLength &gt; buffer.limit())) {</span>
<span class="nc" id="L321">            throw new MonitorStructureException(</span>
                    &quot;Invalid entry length: entryLength = &quot; + entryLength
<span class="nc" id="L323">                    + &quot; (0x&quot; + Integer.toHexString(entryLength) + &quot;)&quot;);</span>
        }

        // check if last entry occurs before the eof.
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if ((entryStart + entryLength) &gt; buffer.limit()) {</span>
<span class="nc" id="L328">            throw new MonitorStructureException(</span>
                    &quot;Entry extends beyond end of buffer: &quot;
<span class="nc" id="L330">                    + &quot; entryStart = 0x&quot; + Integer.toHexString(entryStart)</span>
<span class="nc" id="L331">                    + &quot; entryLength = 0x&quot; + Integer.toHexString(entryLength)</span>
<span class="nc" id="L332">                    + &quot; buffer limit = 0x&quot; + Integer.toHexString(buffer.limit()));</span>
        }

<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (entryLength == 0) {</span>
            // end of data
<span class="nc" id="L337">            return null;</span>
        }

        // we can safely read this entry
<span class="nc" id="L341">        int nameOffset = buffer.getInt();</span>
<span class="nc" id="L342">        int vectorLength = buffer.getInt();</span>
<span class="nc" id="L343">        byte typeCodeByte = buffer.get();</span>
<span class="nc" id="L344">        byte flags = buffer.get();</span>
<span class="nc" id="L345">        byte unitsByte = buffer.get();</span>
<span class="nc" id="L346">        byte varByte = buffer.get();</span>
<span class="nc" id="L347">        int dataOffset = buffer.getInt();</span>

<span class="nc" id="L349">        dump_entry_fixed(entryStart, nameOffset, vectorLength, typeCodeByte,</span>
                         flags, unitsByte, varByte, dataOffset);

        // convert common attributes to their object types
<span class="nc" id="L353">        Units units = Units.toUnits(unitsByte);</span>
<span class="nc" id="L354">        Variability variability = Variability.toVariability(varByte);</span>
<span class="nc" id="L355">        TypeCode typeCode = null;</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">        boolean supported = (flags &amp; 0x01) != 0;</span>

        try {
<span class="nc" id="L359">            typeCode = TypeCode.toTypeCode(typeCodeByte);</span>

<span class="nc" id="L361">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L362">            throw new MonitorStructureException(</span>
                    &quot;Illegal type code encountered:&quot;
<span class="nc" id="L364">                    + &quot; entry_offset = 0x&quot; + Integer.toHexString(nextEntry)</span>
<span class="nc" id="L365">                    + &quot;, type_code = &quot; + Integer.toHexString(typeCodeByte));</span>
<span class="nc" id="L366">        }</span>

        // verify that the name_offset is contained within the entry bounds
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (nameOffset &gt; entryLength) {</span>
<span class="nc" id="L370">            throw new MonitorStructureException(</span>
                    &quot;Field extends beyond entry bounds&quot;
<span class="nc" id="L372">                    + &quot; entry_offset = 0x&quot; + Integer.toHexString(nextEntry)</span>
<span class="nc" id="L373">                    + &quot;, name_offset = 0x&quot; + Integer.toHexString(nameOffset));</span>
        }

        // verify that the data_offset is contained within the entry bounds
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (dataOffset &gt; entryLength) {</span>
<span class="nc" id="L378">            throw new MonitorStructureException(</span>
                    &quot;Field extends beyond entry bounds:&quot;
<span class="nc" id="L380">                    + &quot; entry_offset = 0x&quot; + Integer.toHexString(nextEntry)</span>
<span class="nc" id="L381">                    + &quot;, data_offset = 0x&quot; + Integer.toHexString(dataOffset));</span>
        }

        // validate the variability and units fields
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (variability == Variability.INVALID) {</span>
<span class="nc" id="L386">            throw new MonitorDataException(</span>
                    &quot;Invalid variability attribute:&quot;
<span class="nc" id="L388">                    + &quot; entry_offset = 0x&quot; + Integer.toHexString(nextEntry)</span>
<span class="nc" id="L389">                    + &quot;, variability = 0x&quot; + Integer.toHexString(varByte));</span>
        }

<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (units == Units.INVALID) {</span>
<span class="nc" id="L393">            throw new MonitorDataException(</span>
                    &quot;Invalid units attribute: entry_offset = 0x&quot;
<span class="nc" id="L395">                    + Integer.toHexString(nextEntry)</span>
<span class="nc" id="L396">                    + &quot;, units = 0x&quot; + Integer.toHexString(unitsByte));</span>
        }

        // the entry looks good - parse the variable length components

        /*
         * The name starts at nameOffset and continues up to the first null
         * byte. however, we don't know the length, but we can approximate it
         * without searching for the null by using the offset for the data
         * field, which follows the name field.
         */
<span class="nc bnc" id="L407" title="All 4 branches missed.">        assert (buffer.position() == (entryStart + nameOffset));</span>
<span class="nc bnc" id="L408" title="All 4 branches missed.">        assert (dataOffset &gt; nameOffset);</span>

        // include possible pad space
<span class="nc" id="L411">        int maxNameLength = dataOffset-nameOffset;</span>

        // maxNameLength better be less than the total entry length
<span class="nc bnc" id="L414" title="All 4 branches missed.">        assert (maxNameLength &lt; entryLength);</span>

        // collect the characters, but do not collect the null byte,
        // as the String(byte[]) constructor does not ignore it!
<span class="nc" id="L418">        byte[] nameBytes = new byte[maxNameLength];</span>
<span class="nc" id="L419">        int nameLength = 0;</span>
        byte b;
<span class="nc bnc" id="L421" title="All 4 branches missed.">        while (((b = buffer.get()) != 0) &amp;&amp; (nameLength &lt; maxNameLength)) {</span>
<span class="nc" id="L422">             nameBytes[nameLength++] = b;</span>
        }

<span class="nc bnc" id="L425" title="All 4 branches missed.">        assert (nameLength &lt; maxNameLength);</span>

        // we should before or at the start of the data field
<span class="nc bnc" id="L428" title="All 4 branches missed.">        assert (buffer.position() &lt;= (entryStart + dataOffset));</span>

        // convert the name bytes into a String
<span class="nc" id="L431">        String name = new String(nameBytes, 0, nameLength);</span>

        /*
         * compute the size of the data item - this includes pad
         * characters used to align the next entry.
         */
<span class="nc" id="L437">        int dataSize = entryLength - dataOffset;</span>

        // set the position to the start of the data item
<span class="nc" id="L440">        buffer.position(entryStart + dataOffset);</span>

<span class="nc" id="L442">        dump_entry_variable(name, buffer, dataSize);</span>

<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (vectorLength == 0) {</span>
            // create a scalar Monitor object
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (typeCode == TypeCode.LONG) {</span>
<span class="nc" id="L447">                LongBuffer lb = buffer.asLongBuffer();</span>
<span class="nc" id="L448">                lb.limit(1);  // limit buffer size to one long value.</span>
<span class="nc" id="L449">                monitor = new PerfLongMonitor(name, units, variability,</span>
                                              supported, lb);
<span class="nc" id="L451">            } else {</span>
                /*
                 * unexpected type code - coding error or uncoordinated
                 * JVM change
                 */
<span class="nc" id="L456">                throw new MonitorTypeException(</span>
                        &quot;Unexpected type code encountered:&quot;
<span class="nc" id="L458">                        + &quot; entry_offset = 0x&quot; + Integer.toHexString(nextEntry)</span>
                        + &quot;, name = &quot; + name
                        + &quot;, type_code = &quot; + typeCode
<span class="nc" id="L461">                        + &quot; (0x&quot; + Integer.toHexString(typeCodeByte) + &quot;)&quot;);</span>
            }
        } else {
            // create a vector Monitor object
<span class="nc bnc" id="L465" title="All 2 branches missed.">            if (typeCode == TypeCode.BYTE) {</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if (units != Units.STRING) {</span>
                    // only byte arrays of type STRING are currently supported
<span class="nc" id="L468">                    throw new MonitorTypeException(</span>
                            &quot;Unexpected vector type encounterd:&quot;
                            + &quot; entry_offset = &quot;
<span class="nc" id="L471">                            + Integer.toHexString(nextEntry)</span>
                            + &quot;, name = &quot; + name
                            + &quot;, type_code = &quot; + typeCode + &quot; (0x&quot;
<span class="nc" id="L474">                            + Integer.toHexString(typeCodeByte) + &quot;)&quot;</span>
                            + &quot;, units = &quot; + units + &quot; (0x&quot;
<span class="nc" id="L476">                            + Integer.toHexString(unitsByte) + &quot;)&quot;);</span>
                }

<span class="nc" id="L479">                ByteBuffer bb = buffer.slice();</span>
<span class="nc" id="L480">                bb.limit(vectorLength); // limit buffer length to # of chars</span>

<span class="nc bnc" id="L482" title="All 2 branches missed.">                if (variability == Variability.CONSTANT) {</span>
<span class="nc" id="L483">                    monitor = new PerfStringConstantMonitor(name, supported,</span>
                                                            bb);
<span class="nc bnc" id="L485" title="All 2 branches missed.">                } else if (variability == Variability.VARIABLE) {</span>
<span class="nc" id="L486">                    monitor = new PerfStringVariableMonitor(name, supported,</span>
                                                            bb, vectorLength-1);
<span class="nc bnc" id="L488" title="All 2 branches missed.">                } else if (variability == Variability.MONOTONIC) {</span>
                    // Monotonically increasing byte arrays are not supported
<span class="nc" id="L490">                    throw new MonitorDataException(</span>
                            &quot;Unexpected variability attribute:&quot;
                            + &quot; entry_offset = 0x&quot;
<span class="nc" id="L493">                            + Integer.toHexString(nextEntry)</span>
                            + &quot; name = &quot; + name
                            + &quot;, variability = &quot; + variability + &quot; (0x&quot;
<span class="nc" id="L496">                            + Integer.toHexString(varByte) + &quot;)&quot;);</span>
                } else {
                    // variability was validated above, so this unexpected
<span class="nc bnc" id="L499" title="All 2 branches missed.">                    assert false;</span>
                }
<span class="nc" id="L501">            } else {</span>
                // coding error or uncoordinated JVM change
<span class="nc" id="L503">                throw new MonitorTypeException(</span>
                        &quot;Unexpected type code encountered:&quot;
                        + &quot; entry_offset = 0x&quot;
<span class="nc" id="L506">                        + Integer.toHexString(nextEntry)</span>
                        + &quot;, name = &quot; + name
                        + &quot;, type_code = &quot; + typeCode + &quot; (0x&quot;
<span class="nc" id="L509">                        + Integer.toHexString(typeCodeByte) + &quot;)&quot;);</span>
            }
        }

        // setup index to next entry for next iteration of the loop.
<span class="nc" id="L514">        nextEntry = entryStart + entryLength;</span>
<span class="nc" id="L515">        return monitor;</span>
    }

    /**
     * Method to dump debugging information
     */
    private void dumpAll(Map&lt;String, Monitor&gt; map, int lvmid) {
        if (DEBUG) {
            Set&lt;String&gt; keys = map.keySet();

            System.err.println(&quot;Dump for &quot; + lvmid);
            int j = 0;
            for (Iterator i = keys.iterator(); i.hasNext(); j++) {
                Monitor monitor = map.get(i.next());
                System.err.println(j + &quot;\t&quot; + monitor.getName()
                                   + &quot;=&quot; + monitor.getValue());
            }
            System.err.println(&quot;nextEntry = &quot; + nextEntry);
            System.err.println(&quot;Buffer info:&quot;);
            System.err.println(&quot;buffer = &quot; + buffer);
        }
<span class="nc" id="L536">    }</span>

    /**
     * Method to dump the fixed portion of an entry.
     */
    private void dump_entry_fixed(int entry_start, int nameOffset,
                                  int vectorLength, byte typeCodeByte,
                                  byte flags, byte unitsByte, byte varByte,
                                  int dataOffset) {
        if (DEBUG) {
            System.err.println(&quot;Entry at offset: 0x&quot;
                               + Integer.toHexString(entry_start));
            System.err.println(&quot;\tname_offset = 0x&quot;
                               + Integer.toHexString(nameOffset));
            System.err.println(&quot;\tvector_length = 0x&quot;
                               + Integer.toHexString(vectorLength));
            System.err.println(&quot;\tdata_type = 0x&quot;
                               + Integer.toHexString(typeCodeByte));
            System.err.println(&quot;\tflags = 0x&quot;
                               + Integer.toHexString(flags));
            System.err.println(&quot;\tdata_units = 0x&quot;
                               + Integer.toHexString(unitsByte));
            System.err.println(&quot;\tdata_variability = 0x&quot;
                               + Integer.toHexString(varByte));
            System.err.println(&quot;\tdata_offset = 0x&quot;
                               + Integer.toHexString(dataOffset));
        }
<span class="nc" id="L563">    }</span>

    private void dump_entry_variable(String name, ByteBuffer bb, int size) {
        if (DEBUG) {
            char[] toHex = new char[] { '0', '1', '2', '3',
                                        '4', '5', '6', '7',
                                        '8', '9', 'a', 'b',
                                        'c', 'd', 'e', 'f' };

            ByteBuffer data = bb.slice();
            data.limit(size);

            System.err.println(&quot;\tname = &quot; + name);
            System.err.println(&quot;\tdata = &quot;);

            int count=0;
            while (data.hasRemaining()) {
                byte b = data.get();
                byte high = (byte)((b &gt;&gt; 8) &amp; 0x0f);
                byte low = (byte)(b &amp; 0x0f);

                if (count % 16 == 0) {
                    System.err.print(&quot;\t\t&quot; + Integer.toHexString(count / 16)
                                     + &quot;: &quot;);
                }

                System.err.print(String.valueOf(toHex[high])
                                 + String.valueOf(toHex[low]));

                count++;
                if (count % 16 == 0) {
                    System.err.println();
                } else {
                    System.err.print(&quot; &quot;);
                }
            }
            if (count % 16 != 0) {
                System.err.println();
            }
        }
<span class="nc" id="L603">    }</span>

    private void logln(String s) {
        if (DEBUG) {
            System.err.println(s);
        }
<span class="nc" id="L609">    }</span>

    private void log(String s) {
        if (DEBUG) {
            System.err.print(s);
        }
<span class="nc" id="L615">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>