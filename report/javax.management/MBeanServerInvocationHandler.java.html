<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MBeanServerInvocationHandler.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.management</a> &gt; <span class="el_source">MBeanServerInvocationHandler.java</span></div><h1>MBeanServerInvocationHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management;

import com.sun.jmx.mbeanserver.MXBeanProxy;

import java.lang.ref.WeakReference;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Arrays;
import java.util.WeakHashMap;

/**
 * &lt;p&gt;{@link InvocationHandler} that forwards methods in an MBean's
 * management interface through the MBean server to the MBean.&lt;/p&gt;
 *
 * &lt;p&gt;Given an {@link MBeanServerConnection}, the {@link ObjectName}
 * of an MBean within that MBean server, and a Java interface
 * &lt;code&gt;Intf&lt;/code&gt; that describes the management interface of the
 * MBean using the patterns for a Standard MBean or an MXBean, this
 * class can be used to construct a proxy for the MBean.  The proxy
 * implements the interface &lt;code&gt;Intf&lt;/code&gt; such that all of its
 * methods are forwarded through the MBean server to the MBean.&lt;/p&gt;
 *
 * &lt;p&gt;If the {@code InvocationHandler} is for an MXBean, then the parameters of
 * a method are converted from the type declared in the MXBean
 * interface into the corresponding mapped type, and the return value
 * is converted from the mapped type into the declared type.  For
 * example, with the method&lt;br&gt;

 * {@code public List&lt;String&gt; reverse(List&lt;String&gt; list);}&lt;br&gt;

 * and given that the mapped type for {@code List&lt;String&gt;} is {@code
 * String[]}, a call to {@code proxy.reverse(someList)} will convert
 * {@code someList} from a {@code List&lt;String&gt;} to a {@code String[]},
 * call the MBean operation {@code reverse}, then convert the returned
 * {@code String[]} into a {@code List&lt;String&gt;}.&lt;/p&gt;
 *
 * &lt;p&gt;The method Object.toString(), Object.hashCode(), or
 * Object.equals(Object), when invoked on a proxy using this
 * invocation handler, is forwarded to the MBean server as a method on
 * the proxied MBean only if it appears in one of the proxy's
 * interfaces.  For a proxy created with {@link
 * JMX#newMBeanProxy(MBeanServerConnection, ObjectName, Class)
 * JMX.newMBeanProxy} or {@link
 * JMX#newMXBeanProxy(MBeanServerConnection, ObjectName, Class)
 * JMX.newMXBeanProxy}, this means that the method must appear in the
 * Standard MBean or MXBean interface.  Otherwise these methods have
 * the following behavior:
 * &lt;ul&gt;
 * &lt;li&gt;toString() returns a string representation of the proxy
 * &lt;li&gt;hashCode() returns a hash code for the proxy such
 * that two equal proxies have the same hash code
 * &lt;li&gt;equals(Object)
 * returns true if and only if the Object argument is of the same
 * proxy class as this proxy, with an MBeanServerInvocationHandler
 * that has the same MBeanServerConnection and ObjectName; if one
 * of the {@code MBeanServerInvocationHandler}s was constructed with
 * a {@code Class} argument then the other must have been constructed
 * with the same {@code Class} for {@code equals} to return true.
 * &lt;/ul&gt;
 *
 * @since 1.5
 */
public class MBeanServerInvocationHandler implements InvocationHandler {
    /**
     * &lt;p&gt;Invocation handler that forwards methods through an MBean
     * server to a Standard MBean.  This constructor may be called
     * instead of relying on {@link
     * JMX#newMBeanProxy(MBeanServerConnection, ObjectName, Class)
     * JMX.newMBeanProxy}, for instance if you need to supply a
     * different {@link ClassLoader} to {@link Proxy#newProxyInstance
     * Proxy.newProxyInstance}.&lt;/p&gt;
     *
     * &lt;p&gt;This constructor is not appropriate for an MXBean.  Use
     * {@link #MBeanServerInvocationHandler(MBeanServerConnection,
     * ObjectName, boolean)} for that.  This constructor is equivalent
     * to {@code new MBeanServerInvocationHandler(connection,
     * objectName, false)}.&lt;/p&gt;
     *
     * @param connection the MBean server connection through which all
     * methods of a proxy using this handler will be forwarded.
     *
     * @param objectName the name of the MBean within the MBean server
     * to which methods will be forwarded.
     */
    public MBeanServerInvocationHandler(MBeanServerConnection connection,
                                        ObjectName objectName) {

<span class="nc" id="L114">        this(connection, objectName, false);</span>
<span class="nc" id="L115">    }</span>

    /**
     * &lt;p&gt;Invocation handler that can forward methods through an MBean
     * server to a Standard MBean or MXBean.  This constructor may be called
     * instead of relying on {@link
     * JMX#newMXBeanProxy(MBeanServerConnection, ObjectName, Class)
     * JMX.newMXBeanProxy}, for instance if you need to supply a
     * different {@link ClassLoader} to {@link Proxy#newProxyInstance
     * Proxy.newProxyInstance}.&lt;/p&gt;
     *
     * @param connection the MBean server connection through which all
     * methods of a proxy using this handler will be forwarded.
     *
     * @param objectName the name of the MBean within the MBean server
     * to which methods will be forwarded.
     *
     * @param isMXBean if true, the proxy is for an {@link MXBean}, and
     * appropriate mappings will be applied to method parameters and return
     * values.
     *
     * @since 1.6
     */
    public MBeanServerInvocationHandler(MBeanServerConnection connection,
                                        ObjectName objectName,
<span class="nc" id="L140">                                        boolean isMXBean) {</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if (connection == null) {</span>
<span class="nc" id="L142">            throw new IllegalArgumentException(&quot;Null connection&quot;);</span>
        }
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (objectName == null) {</span>
<span class="nc" id="L145">            throw new IllegalArgumentException(&quot;Null object name&quot;);</span>
        }
<span class="nc" id="L147">        this.connection = connection;</span>
<span class="nc" id="L148">        this.objectName = objectName;</span>
<span class="nc" id="L149">        this.isMXBean = isMXBean;</span>
<span class="nc" id="L150">    }</span>

    /**
     * &lt;p&gt;The MBean server connection through which the methods of
     * a proxy using this handler are forwarded.&lt;/p&gt;
     *
     * @return the MBean server connection.
     *
     * @since 1.6
     */
    public MBeanServerConnection getMBeanServerConnection() {
<span class="nc" id="L161">        return connection;</span>
    }

    /**
     * &lt;p&gt;The name of the MBean within the MBean server to which methods
     * are forwarded.
     *
     * @return the object name.
     *
     * @since 1.6
     */
    public ObjectName getObjectName() {
<span class="nc" id="L173">        return objectName;</span>
    }

    /**
     * &lt;p&gt;If true, the proxy is for an MXBean, and appropriate mappings
     * are applied to method parameters and return values.
     *
     * @return whether the proxy is for an MXBean.
     *
     * @since 1.6
     */
    public boolean isMXBean() {
<span class="nc" id="L185">        return isMXBean;</span>
    }

    /**
     * &lt;p&gt;Return a proxy that implements the given interface by
     * forwarding its methods through the given MBean server to the
     * named MBean.  As of 1.6, the methods {@link
     * JMX#newMBeanProxy(MBeanServerConnection, ObjectName, Class)} and
     * {@link JMX#newMBeanProxy(MBeanServerConnection, ObjectName, Class,
     * boolean)} are preferred to this method.&lt;/p&gt;
     *
     * &lt;p&gt;This method is equivalent to {@link Proxy#newProxyInstance
     * Proxy.newProxyInstance}&lt;code&gt;(interfaceClass.getClassLoader(),
     * interfaces, handler)&lt;/code&gt;.  Here &lt;code&gt;handler&lt;/code&gt; is the
     * result of {@link #MBeanServerInvocationHandler new
     * MBeanServerInvocationHandler(connection, objectName)}, and
     * &lt;code&gt;interfaces&lt;/code&gt; is an array that has one element if
     * &lt;code&gt;notificationBroadcaster&lt;/code&gt; is false and two if it is
     * true.  The first element of &lt;code&gt;interfaces&lt;/code&gt; is
     * &lt;code&gt;interfaceClass&lt;/code&gt; and the second, if present, is
     * &lt;code&gt;NotificationEmitter.class&lt;/code&gt;.
     *
     * @param connection the MBean server to forward to.
     * @param objectName the name of the MBean within
     * &lt;code&gt;connection&lt;/code&gt; to forward to.
     * @param interfaceClass the management interface that the MBean
     * exports, which will also be implemented by the returned proxy.
     * @param notificationBroadcaster make the returned proxy
     * implement {@link NotificationEmitter} by forwarding its methods
     * via &lt;code&gt;connection&lt;/code&gt;. A call to {@link
     * NotificationBroadcaster#addNotificationListener} on the proxy will
     * result in a call to {@link
     * MBeanServerConnection#addNotificationListener(ObjectName,
     * NotificationListener, NotificationFilter, Object)}, and likewise
     * for the other methods of {@link NotificationBroadcaster} and {@link
     * NotificationEmitter}.
     *
     * @param &lt;T&gt; allows the compiler to know that if the {@code
     * interfaceClass} parameter is {@code MyMBean.class}, for example,
     * then the return type is {@code MyMBean}.
     *
     * @return the new proxy instance.
     *
     * @see JMX#newMBeanProxy(MBeanServerConnection, ObjectName, Class, boolean)
     */
    public static &lt;T&gt; T newProxyInstance(MBeanServerConnection connection,
                                         ObjectName objectName,
                                         Class&lt;T&gt; interfaceClass,
                                         boolean notificationBroadcaster) {
<span class="nc" id="L234">        return JMX.newMBeanProxy(connection, objectName, interfaceClass, notificationBroadcaster);</span>
    }

    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
<span class="nc" id="L239">        final Class&lt;?&gt; methodClass = method.getDeclaringClass();</span>

<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (methodClass.equals(NotificationBroadcaster.class)</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            || methodClass.equals(NotificationEmitter.class))</span>
<span class="nc" id="L243">            return invokeBroadcasterMethod(proxy, method, args);</span>

        // local or not: equals, toString, hashCode
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (shouldDoLocally(proxy, method))</span>
<span class="nc" id="L247">            return doLocally(proxy, method, args);</span>

        try {
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (isMXBean()) {</span>
<span class="nc" id="L251">                MXBeanProxy p = findMXBeanProxy(methodClass);</span>
<span class="nc" id="L252">                return p.invoke(connection, objectName, method, args);</span>
            } else {
<span class="nc" id="L254">                final String methodName = method.getName();</span>
<span class="nc" id="L255">                final Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span>
<span class="nc" id="L256">                final Class&lt;?&gt; returnType = method.getReturnType();</span>

                /* Inexplicably, InvocationHandler specifies that args is null
                   when the method takes no arguments rather than a
                   zero-length array.  */
<span class="nc bnc" id="L261" title="All 2 branches missed.">                final int nargs = (args == null) ? 0 : args.length;</span>

<span class="nc bnc" id="L263" title="All 2 branches missed.">                if (methodName.startsWith(&quot;get&quot;)</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">                    &amp;&amp; methodName.length() &gt; 3</span>
                    &amp;&amp; nargs == 0
<span class="nc bnc" id="L266" title="All 2 branches missed.">                    &amp;&amp; !returnType.equals(Void.TYPE)) {</span>
<span class="nc" id="L267">                    return connection.getAttribute(objectName,</span>
<span class="nc" id="L268">                        methodName.substring(3));</span>
                }

<span class="nc bnc" id="L271" title="All 2 branches missed.">                if (methodName.startsWith(&quot;is&quot;)</span>
<span class="nc bnc" id="L272" title="All 4 branches missed.">                    &amp;&amp; methodName.length() &gt; 2</span>
                    &amp;&amp; nargs == 0
<span class="nc bnc" id="L274" title="All 2 branches missed.">                    &amp;&amp; (returnType.equals(Boolean.TYPE)</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">                    || returnType.equals(Boolean.class))) {</span>
<span class="nc" id="L276">                    return connection.getAttribute(objectName,</span>
<span class="nc" id="L277">                        methodName.substring(2));</span>
                }

<span class="nc bnc" id="L280" title="All 2 branches missed.">                if (methodName.startsWith(&quot;set&quot;)</span>
<span class="nc bnc" id="L281" title="All 4 branches missed.">                    &amp;&amp; methodName.length() &gt; 3</span>
                    &amp;&amp; nargs == 1
<span class="nc bnc" id="L283" title="All 2 branches missed.">                    &amp;&amp; returnType.equals(Void.TYPE)) {</span>
<span class="nc" id="L284">                    Attribute attr = new Attribute(methodName.substring(3), args[0]);</span>
<span class="nc" id="L285">                    connection.setAttribute(objectName, attr);</span>
<span class="nc" id="L286">                    return null;</span>
                }

<span class="nc" id="L289">                final String[] signature = new String[paramTypes.length];</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                for (int i = 0; i &lt; paramTypes.length; i++)</span>
<span class="nc" id="L291">                    signature[i] = paramTypes[i].getName();</span>
<span class="nc" id="L292">                return connection.invoke(objectName, methodName,</span>
                                         args, signature);
            }
<span class="nc" id="L295">        } catch (MBeanException e) {</span>
<span class="nc" id="L296">            throw e.getTargetException();</span>
<span class="nc" id="L297">        } catch (RuntimeMBeanException re) {</span>
<span class="nc" id="L298">            throw re.getTargetException();</span>
<span class="nc" id="L299">        } catch (RuntimeErrorException rre) {</span>
<span class="nc" id="L300">            throw rre.getTargetError();</span>
        }
        /* The invoke may fail because it can't get to the MBean, with
           one of the these exceptions declared by
           MBeanServerConnection.invoke:
           - RemoteException: can't talk to MBeanServer;
           - InstanceNotFoundException: objectName is not registered;
           - ReflectionException: objectName is registered but does not
             have the method being invoked.
           In all of these cases, the exception will be wrapped by the
           proxy mechanism in an UndeclaredThrowableException unless
           it happens to be declared in the &quot;throws&quot; clause of the
           method being invoked on the proxy.
         */
    }

    private static MXBeanProxy findMXBeanProxy(Class&lt;?&gt; mxbeanInterface) {
<span class="nc" id="L317">        synchronized (mxbeanProxies) {</span>
<span class="nc" id="L318">            WeakReference&lt;MXBeanProxy&gt; proxyRef =</span>
<span class="nc" id="L319">                    mxbeanProxies.get(mxbeanInterface);</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            MXBeanProxy p = (proxyRef == null) ? null : proxyRef.get();</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            if (p == null) {</span>
                try {
<span class="nc" id="L323">                    p = new MXBeanProxy(mxbeanInterface);</span>
<span class="nc" id="L324">                } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L325">                    String msg = &quot;Cannot make MXBean proxy for &quot; +</span>
<span class="nc" id="L326">                            mxbeanInterface.getName() + &quot;: &quot; + e.getMessage();</span>
<span class="nc" id="L327">                    IllegalArgumentException iae =</span>
<span class="nc" id="L328">                            new IllegalArgumentException(msg, e.getCause());</span>
<span class="nc" id="L329">                    iae.setStackTrace(e.getStackTrace());</span>
<span class="nc" id="L330">                    throw iae;</span>
<span class="nc" id="L331">                }</span>
<span class="nc" id="L332">                mxbeanProxies.put(mxbeanInterface,</span>
                                  new WeakReference&lt;MXBeanProxy&gt;(p));
            }
<span class="nc" id="L335">            return p;</span>
<span class="nc" id="L336">        }</span>
    }
    private static final WeakHashMap&lt;Class&lt;?&gt;, WeakReference&lt;MXBeanProxy&gt;&gt;
<span class="nc" id="L339">            mxbeanProxies = new WeakHashMap&lt;Class&lt;?&gt;, WeakReference&lt;MXBeanProxy&gt;&gt;();</span>

    private Object invokeBroadcasterMethod(Object proxy, Method method,
                                           Object[] args) throws Exception {
<span class="nc" id="L343">        final String methodName = method.getName();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        final int nargs = (args == null) ? 0 : args.length;</span>

<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (methodName.equals(&quot;addNotificationListener&quot;)) {</span>
            /* The various throws of IllegalArgumentException here
               should not happen, since we know what the methods in
               NotificationBroadcaster and NotificationEmitter
               are.  */
<span class="nc bnc" id="L351" title="All 2 branches missed.">            if (nargs != 3) {</span>
<span class="nc" id="L352">                final String msg =</span>
                    &quot;Bad arg count to addNotificationListener: &quot; + nargs;
<span class="nc" id="L354">                throw new IllegalArgumentException(msg);</span>
            }
            /* Other inconsistencies will produce ClassCastException
               below.  */

<span class="nc" id="L359">            NotificationListener listener = (NotificationListener) args[0];</span>
<span class="nc" id="L360">            NotificationFilter filter = (NotificationFilter) args[1];</span>
<span class="nc" id="L361">            Object handback = args[2];</span>
<span class="nc" id="L362">            connection.addNotificationListener(objectName,</span>
                                               listener,
                                               filter,
                                               handback);
<span class="nc" id="L366">            return null;</span>

<span class="nc bnc" id="L368" title="All 2 branches missed.">        } else if (methodName.equals(&quot;removeNotificationListener&quot;)) {</span>

            /* NullPointerException if method with no args, but that
               shouldn't happen because removeNL does have args.  */
<span class="nc" id="L372">            NotificationListener listener = (NotificationListener) args[0];</span>

<span class="nc bnc" id="L374" title="All 3 branches missed.">            switch (nargs) {</span>
            case 1:
<span class="nc" id="L376">                connection.removeNotificationListener(objectName, listener);</span>
<span class="nc" id="L377">                return null;</span>

            case 3:
<span class="nc" id="L380">                NotificationFilter filter = (NotificationFilter) args[1];</span>
<span class="nc" id="L381">                Object handback = args[2];</span>
<span class="nc" id="L382">                connection.removeNotificationListener(objectName,</span>
                                                      listener,
                                                      filter,
                                                      handback);
<span class="nc" id="L386">                return null;</span>

            default:
<span class="nc" id="L389">                final String msg =</span>
                    &quot;Bad arg count to removeNotificationListener: &quot; + nargs;
<span class="nc" id="L391">                throw new IllegalArgumentException(msg);</span>
            }

<span class="nc bnc" id="L394" title="All 2 branches missed.">        } else if (methodName.equals(&quot;getNotificationInfo&quot;)) {</span>

<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (args != null) {</span>
<span class="nc" id="L397">                throw new IllegalArgumentException(&quot;getNotificationInfo has &quot; +</span>
                                                   &quot;args&quot;);
            }

<span class="nc" id="L401">            MBeanInfo info = connection.getMBeanInfo(objectName);</span>
<span class="nc" id="L402">            return info.getNotifications();</span>

        } else {
<span class="nc" id="L405">            throw new IllegalArgumentException(&quot;Bad method name: &quot; +</span>
                                               methodName);
        }
    }

    private boolean shouldDoLocally(Object proxy, Method method) {
<span class="nc" id="L411">        final String methodName = method.getName();</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">        if ((methodName.equals(&quot;hashCode&quot;) || methodName.equals(&quot;toString&quot;))</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            &amp;&amp; method.getParameterTypes().length == 0</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">            &amp;&amp; isLocal(proxy, method))</span>
<span class="nc" id="L415">            return true;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (methodName.equals(&quot;equals&quot;)</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            &amp;&amp; Arrays.equals(method.getParameterTypes(),</span>
                             new Class&lt;?&gt;[] {Object.class})
<span class="nc bnc" id="L419" title="All 2 branches missed.">            &amp;&amp; isLocal(proxy, method))</span>
<span class="nc" id="L420">            return true;</span>
<span class="nc" id="L421">        return false;</span>
    }

    private Object doLocally(Object proxy, Method method, Object[] args) {
<span class="nc" id="L425">        final String methodName = method.getName();</span>

<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (methodName.equals(&quot;equals&quot;)) {</span>

<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (this == args[0]) {</span>
<span class="nc" id="L430">                return true;</span>
            }

<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (!(args[0] instanceof Proxy)) {</span>
<span class="nc" id="L434">                return false;</span>
            }

<span class="nc" id="L437">            final InvocationHandler ihandler =</span>
<span class="nc" id="L438">                Proxy.getInvocationHandler(args[0]);</span>

<span class="nc bnc" id="L440" title="All 4 branches missed.">            if (ihandler == null ||</span>
                !(ihandler instanceof MBeanServerInvocationHandler)) {
<span class="nc" id="L442">                return false;</span>
            }

<span class="nc" id="L445">            final MBeanServerInvocationHandler handler =</span>
                (MBeanServerInvocationHandler)ihandler;

<span class="nc bnc" id="L448" title="All 2 branches missed.">            return connection.equals(handler.connection) &amp;&amp;</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">                objectName.equals(handler.objectName) &amp;&amp;</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">                proxy.getClass().equals(args[0].getClass());</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">        } else if (methodName.equals(&quot;toString&quot;)) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            return (isMXBean() ? &quot;MX&quot; : &quot;M&quot;) + &quot;BeanProxy(&quot; +</span>
                connection + &quot;[&quot; + objectName + &quot;])&quot;;
<span class="nc bnc" id="L454" title="All 2 branches missed.">        } else if (methodName.equals(&quot;hashCode&quot;)) {</span>
<span class="nc" id="L455">            return objectName.hashCode()+connection.hashCode();</span>
        }

<span class="nc" id="L458">        throw new RuntimeException(&quot;Unexpected method name: &quot; + methodName);</span>
    }

    private static boolean isLocal(Object proxy, Method method) {
<span class="nc" id="L462">        final Class&lt;?&gt;[] interfaces = proxy.getClass().getInterfaces();</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if(interfaces == null) {</span>
<span class="nc" id="L464">            return true;</span>
        }

<span class="nc" id="L467">        final String methodName = method.getName();</span>
<span class="nc" id="L468">        final Class&lt;?&gt;[] params = method.getParameterTypes();</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">        for (Class&lt;?&gt; intf : interfaces) {</span>
            try {
<span class="nc" id="L471">                intf.getMethod(methodName, params);</span>
<span class="nc" id="L472">                return false; // found method in one of our interfaces</span>
<span class="nc" id="L473">            } catch (NoSuchMethodException nsme) {</span>
                // OK.
            }
        }

<span class="nc" id="L478">        return true;  // did not find in any interface</span>
    }

    private final MBeanServerConnection connection;
    private final ObjectName objectName;
    private final boolean isMXBean;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>