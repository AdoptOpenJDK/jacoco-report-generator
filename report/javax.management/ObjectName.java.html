<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ObjectName.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.management</a> &gt; <span class="el_source">ObjectName.java</span></div><h1>ObjectName.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management;

import com.sun.jmx.mbeanserver.GetPropertyAction;
import com.sun.jmx.mbeanserver.Util;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamField;
import java.security.AccessController;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

/**
 * &lt;p&gt;Represents the object name of an MBean, or a pattern that can
 * match the names of several MBeans.  Instances of this class are
 * immutable.&lt;/p&gt;
 *
 * &lt;p&gt;An instance of this class can be used to represent:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;An object name&lt;/li&gt;
 * &lt;li&gt;An object name pattern, within the context of a query&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;An object name consists of two parts, the domain and the key
 * properties.&lt;/p&gt;
 *
 * &lt;p&gt;The &lt;em&gt;domain&lt;/em&gt; is a string of characters not including
 * the character colon (&lt;code&gt;:&lt;/code&gt;).  It is recommended that the domain
 * should not contain the string &quot;{@code //}&quot;, which is reserved for future use.
 *
 * &lt;p&gt;If the domain includes at least one occurrence of the wildcard
 * characters asterisk (&lt;code&gt;*&lt;/code&gt;) or question mark
 * (&lt;code&gt;?&lt;/code&gt;), then the object name is a pattern.  The asterisk
 * matches any sequence of zero or more characters, while the question
 * mark matches any single character.&lt;/p&gt;
 *
 * &lt;p&gt;If the domain is empty, it will be replaced in certain contexts
 * by the &lt;em&gt;default domain&lt;/em&gt; of the MBean server in which the
 * ObjectName is used.&lt;/p&gt;
 *
 * &lt;p&gt;The &lt;em&gt;key properties&lt;/em&gt; are an unordered set of keys and
 * associated values.&lt;/p&gt;
 *
 * &lt;p&gt;Each &lt;em&gt;key&lt;/em&gt; is a nonempty string of characters which may
 * not contain any of the characters comma (&lt;code&gt;,&lt;/code&gt;), equals
 * (&lt;code&gt;=&lt;/code&gt;), colon, asterisk, or question mark.  The same key
 * may not occur twice in a given ObjectName.&lt;/p&gt;
 *
 * &lt;p&gt;Each &lt;em&gt;value&lt;/em&gt; associated with a key is a string of
 * characters that is either unquoted or quoted.&lt;/p&gt;
 *
 * &lt;p&gt;An &lt;em&gt;unquoted value&lt;/em&gt; is a possibly empty string of
 * characters which may not contain any of the characters comma,
 * equals, colon, or quote.&lt;/p&gt;
 *
 * &lt;p&gt;If the &lt;em&gt;unquoted value&lt;/em&gt; contains at least one occurrence
 * of the wildcard characters asterisk or question mark, then the object
 * name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any
 * sequence of zero or more characters, while the question mark matches
 * any single character.&lt;/p&gt;
 *
 * &lt;p&gt;A &lt;em&gt;quoted value&lt;/em&gt; consists of a quote (&lt;code&gt;&quot;&lt;/code&gt;),
 * followed by a possibly empty string of characters, followed by
 * another quote.  Within the string of characters, the backslash
 * (&lt;code&gt;\&lt;/code&gt;) has a special meaning.  It must be followed by
 * one of the following characters:&lt;/p&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;Another backslash.  The second backslash has no special
 * meaning and the two characters represent a single backslash.&lt;/li&gt;
 *
 * &lt;li&gt;The character 'n'.  The two characters represent a newline
 * ('\n' in Java).&lt;/li&gt;
 *
 * &lt;li&gt;A quote.  The two characters represent a quote, and that quote
 * is not considered to terminate the quoted value. An ending closing
 * quote must be present for the quoted value to be valid.&lt;/li&gt;
 *
 * &lt;li&gt;A question mark (?) or asterisk (*).  The two characters represent
 * a question mark or asterisk respectively.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;A quote may not appear inside a quoted value except immediately
 * after an odd number of consecutive backslashes.&lt;/p&gt;
 *
 * &lt;p&gt;The quotes surrounding a quoted value, and any backslashes
 * within that value, are considered to be part of the value.&lt;/p&gt;
 *
 * &lt;p&gt;If the &lt;em&gt;quoted value&lt;/em&gt; contains at least one occurrence of
 * the characters asterisk or question mark and they are not preceded
 * by a backslash, then they are considered as wildcard characters and
 * the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk
 * matches any sequence of zero or more characters, while the question
 * mark matches any single character.&lt;/p&gt;
 *
 * &lt;p&gt;An ObjectName may be a &lt;em&gt;property list pattern&lt;/em&gt;. In this
 * case it may have zero or more keys and associated values. It matches
 * a nonpattern ObjectName whose domain matches and that contains the
 * same keys and associated values, as well as possibly other keys and
 * values.&lt;/p&gt;
 *
 * &lt;p&gt;An ObjectName is a &lt;em&gt;property value pattern&lt;/em&gt; when at least
 * one of its &lt;em&gt;quoted&lt;/em&gt; or &lt;em&gt;unquoted&lt;/em&gt; key property values
 * contains the wildcard characters asterisk or question mark as described
 * above. In this case it has one or more keys and associated values, with
 * at least one of the values containing wildcard characters. It matches a
 * nonpattern ObjectName whose domain matches and that contains the same
 * keys whose values match; if the property value pattern is also a
 * property list pattern then the nonpattern ObjectName can contain
 * other keys and values.&lt;/p&gt;
 *
 * &lt;p&gt;An ObjectName is a &lt;em&gt;property pattern&lt;/em&gt; if it is either a
 * &lt;em&gt;property list pattern&lt;/em&gt; or a &lt;em&gt;property value pattern&lt;/em&gt;
 * or both.&lt;/p&gt;
 *
 * &lt;p&gt;An ObjectName is a pattern if its domain contains a wildcard or
 * if the ObjectName is a property pattern.&lt;/p&gt;
 *
 * &lt;p&gt;If an ObjectName is not a pattern, it must contain at least one
 * key with its associated value.&lt;/p&gt;
 *
 * &lt;p&gt;Examples of ObjectName patterns are:&lt;/p&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@code *:type=Foo,name=Bar} to match names in any domain whose
 *     exact set of keys is {@code type=Foo,name=Bar}.&lt;/li&gt;
 * &lt;li&gt;{@code d:type=Foo,name=Bar,*} to match names in the domain
 *     {@code d} that have the keys {@code type=Foo,name=Bar} plus
 *     zero or more other keys.&lt;/li&gt;
 * &lt;li&gt;{@code *:type=Foo,name=Bar,*} to match names in any domain
 *     that has the keys {@code type=Foo,name=Bar} plus zero or
 *     more other keys.&lt;/li&gt;
 * &lt;li&gt;{@code d:type=F?o,name=Bar} will match e.g.
 *     {@code d:type=Foo,name=Bar} and {@code d:type=Fro,name=Bar}.&lt;/li&gt;
 * &lt;li&gt;{@code d:type=F*o,name=Bar} will match e.g.
 *     {@code d:type=Fo,name=Bar} and {@code d:type=Frodo,name=Bar}.&lt;/li&gt;
 * &lt;li&gt;{@code d:type=Foo,name=&quot;B*&quot;} will match e.g.
 *     {@code d:type=Foo,name=&quot;Bling&quot;}. Wildcards are recognized even
 *     inside quotes, and like other special characters can be escaped
 *     with {@code \}.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;An ObjectName can be written as a String with the following
 * elements in order:&lt;/p&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;The domain.
 * &lt;li&gt;A colon (&lt;code&gt;:&lt;/code&gt;).
 * &lt;li&gt;A key property list as defined below.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;A key property list written as a String is a comma-separated
 * list of elements.  Each element is either an asterisk or a key
 * property.  A key property consists of a key, an equals
 * (&lt;code&gt;=&lt;/code&gt;), and the associated value.&lt;/p&gt;
 *
 * &lt;p&gt;At most one element of a key property list may be an asterisk.
 * If the key property list contains an asterisk element, the
 * ObjectName is a property list pattern.&lt;/p&gt;
 *
 * &lt;p&gt;Spaces have no special significance in a String representing an
 * ObjectName.  For example, the String:
 * &lt;pre&gt;
 * domain: key1 = value1 , key2 = value2
 * &lt;/pre&gt;
 * represents an ObjectName with two keys.  The name of each key
 * contains six characters, of which the first and last are spaces.
 * The value associated with the key &lt;code&gt;&quot;&amp;nbsp;key1&amp;nbsp;&quot;&lt;/code&gt;
 * also begins and ends with a space.
 *
 * &lt;p&gt;In addition to the restrictions on characters spelt out above,
 * no part of an ObjectName may contain a newline character
 * (&lt;code&gt;'\n'&lt;/code&gt;), whether the domain, a key, or a value, whether
 * quoted or unquoted.  The newline character can be represented in a
 * quoted value with the sequence &lt;code&gt;\n&lt;/code&gt;.
 *
 * &lt;p&gt;The rules on special characters and quoting apply regardless of
 * which constructor is used to make an ObjectName.&lt;/p&gt;
 *
 * &lt;p&gt;To avoid collisions between MBeans supplied by different
 * vendors, a useful convention is to begin the domain name with the
 * reverse DNS name of the organization that specifies the MBeans,
 * followed by a period and a string whose interpretation is
 * determined by that organization.  For example, MBeans specified by
 * &lt;code&gt;example.com&lt;/code&gt;  would have
 * domains such as &lt;code&gt;com.example.MyDomain&lt;/code&gt;.  This is essentially
 * the same convention as for Java-language package names.&lt;/p&gt;
 *
 * &lt;p&gt;The &lt;b&gt;serialVersionUID&lt;/b&gt; of this class is &lt;code&gt;1081892073854801359L&lt;/code&gt;.
 *
 * @since 1.5
 */
@SuppressWarnings(&quot;serial&quot;) // don't complain serialVersionUID not constant
public class ObjectName implements Comparable&lt;ObjectName&gt;, QueryExp {

    /**
     * A structure recording property structure and
     * proposing minimal services
     */
    private static class Property {

        int _key_index;
        int _key_length;
        int _value_length;

        /**
         * Constructor.
         */
<span class="nc" id="L238">        Property(int key_index, int key_length, int value_length) {</span>
<span class="nc" id="L239">            _key_index = key_index;</span>
<span class="nc" id="L240">            _key_length = key_length;</span>
<span class="nc" id="L241">            _value_length = value_length;</span>
<span class="nc" id="L242">        }</span>

        /**
         * Assigns the key index of property
         */
        void setKeyIndex(int key_index) {
<span class="nc" id="L248">            _key_index = key_index;</span>
<span class="nc" id="L249">        }</span>

        /**
         * Returns a key string for receiver key
         */
        String getKeyString(String name) {
<span class="nc" id="L255">            return name.substring(_key_index, _key_index + _key_length);</span>
        }

        /**
         * Returns a value string for receiver key
         */
        String getValueString(String name) {
<span class="nc" id="L262">            int in_begin = _key_index + _key_length + 1;</span>
<span class="nc" id="L263">            int out_end = in_begin + _value_length;</span>
<span class="nc" id="L264">            return name.substring(in_begin, out_end);</span>
        }
    }

    /**
     * Marker class for value pattern property.
     */
    private static class PatternProperty extends Property {
        /**
         * Constructor.
         */
        PatternProperty(int key_index, int key_length, int value_length) {
<span class="nc" id="L276">            super(key_index, key_length, value_length);</span>
<span class="nc" id="L277">        }</span>
    }

    // Inner classes &lt;========================================



    // Private fields ----------------------------------------&gt;


    // Serialization compatibility stuff --------------------&gt;

    // Two serial forms are supported in this class. The selected form depends
    // on system property &quot;jmx.serial.form&quot;:
    //  - &quot;1.0&quot; for JMX 1.0
    //  - any other value for JMX 1.1 and higher
    //
    // Serial version for old serial form
    private static final long oldSerialVersionUID = -5467795090068647408L;
    //
    // Serial version for new serial form
    private static final long newSerialVersionUID = 1081892073854801359L;
    //
    // Serializable fields in old serial form
<span class="nc" id="L301">    private static final ObjectStreamField[] oldSerialPersistentFields =</span>
    {
        new ObjectStreamField(&quot;domain&quot;, String.class),
        new ObjectStreamField(&quot;propertyList&quot;, Hashtable.class),
        new ObjectStreamField(&quot;propertyListString&quot;, String.class),
        new ObjectStreamField(&quot;canonicalName&quot;, String.class),
        new ObjectStreamField(&quot;pattern&quot;, Boolean.TYPE),
        new ObjectStreamField(&quot;propertyPattern&quot;, Boolean.TYPE)
    };
    //
    // Serializable fields in new serial form
<span class="nc" id="L312">    private static final ObjectStreamField[] newSerialPersistentFields = { };</span>
    //
    // Actual serial version and serial form
    private static final long serialVersionUID;
    private static final ObjectStreamField[] serialPersistentFields;
<span class="nc" id="L317">    private static boolean compat = false;</span>
    static {
        try {
<span class="nc" id="L320">            GetPropertyAction act = new GetPropertyAction(&quot;jmx.serial.form&quot;);</span>
<span class="nc" id="L321">            String form = AccessController.doPrivileged(act);</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">            compat = (form != null &amp;&amp; form.equals(&quot;1.0&quot;));</span>
<span class="nc" id="L323">        } catch (Exception e) {</span>
            // OK: exception means no compat with 1.0, too bad
<span class="nc" id="L325">        }</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (compat) {</span>
<span class="nc" id="L327">            serialPersistentFields = oldSerialPersistentFields;</span>
<span class="nc" id="L328">            serialVersionUID = oldSerialVersionUID;</span>
        } else {
<span class="nc" id="L330">            serialPersistentFields = newSerialPersistentFields;</span>
<span class="nc" id="L331">            serialVersionUID = newSerialVersionUID;</span>
        }
    }

    //
    // Serialization compatibility stuff &lt;==============================

    // Class private fields -----------------------------------&gt;

    /**
     * a shared empty array for empty property lists
     */
<span class="nc" id="L343">    static final private Property[] _Empty_property_array = new Property[0];</span>


    // Class private fields &lt;==============================

    // Instance private fields -----------------------------------&gt;

    /**
     * a String containing the canonical name
     */
    private transient String _canonicalName;


    /**
     * An array of properties in the same seq order as time creation
     */
    private transient Property[] _kp_array;

    /**
     * An array of properties in the same seq order as canonical order
     */
    private transient Property[] _ca_array;


    /**
     * The length of the domain part of built objectname
     */
<span class="nc" id="L370">    private transient int _domain_length = 0;</span>


    /**
     * The propertyList of built object name. Initialized lazily.
     * Table that contains all the pairs (key,value) for this ObjectName.
     */
    private transient Map&lt;String,String&gt; _propertyList;

    /**
     * boolean that declares if this ObjectName domain part is a pattern
     */
<span class="nc" id="L382">    private transient boolean _domain_pattern = false;</span>

    /**
     * boolean that declares if this ObjectName contains a pattern on the
     * key property list
     */
<span class="nc" id="L388">    private transient boolean _property_list_pattern = false;</span>

    /**
     * boolean that declares if this ObjectName contains a pattern on the
     * value of at least one key property
     */
<span class="nc" id="L394">    private transient boolean _property_value_pattern = false;</span>

    // Instance private fields &lt;=======================================

    // Private fields &lt;========================================


    //  Private methods ----------------------------------------&gt;

    // Category : Instance construction -------------------------&gt;

    /**
     * Initializes this {@link ObjectName} from the given string
     * representation.
     *
     * @param name A string representation of the {@link ObjectName}
     *
     * @exception MalformedObjectNameException The string passed as a
     * parameter does not have the right format.
     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; parameter
     * is null.
     */
    private void construct(String name)
        throws MalformedObjectNameException {

        // The name cannot be null
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (name == null)</span>
<span class="nc" id="L421">            throw new NullPointerException(&quot;name cannot be null&quot;);</span>

        // Test if the name is empty
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (name.length() == 0) {</span>
            // this is equivalent to the whole word query object name.
<span class="nc" id="L426">            _canonicalName = &quot;*:*&quot;;</span>
<span class="nc" id="L427">            _kp_array = _Empty_property_array;</span>
<span class="nc" id="L428">            _ca_array = _Empty_property_array;</span>
<span class="nc" id="L429">            _domain_length = 1;</span>
<span class="nc" id="L430">            _propertyList = null;</span>
<span class="nc" id="L431">            _domain_pattern = true;</span>
<span class="nc" id="L432">            _property_list_pattern = true;</span>
<span class="nc" id="L433">            _property_value_pattern = false;</span>
<span class="nc" id="L434">            return;</span>
        }

        // initialize parsing of the string
<span class="nc" id="L438">        final char[] name_chars = name.toCharArray();</span>
<span class="nc" id="L439">        final int len = name_chars.length;</span>
<span class="nc" id="L440">        final char[] canonical_chars = new char[len]; // canonical form will</span>
                                                      // be same length at most
<span class="nc" id="L442">        int cname_index = 0;</span>
<span class="nc" id="L443">        int index = 0;</span>
        char c, c1;

        // parses domain part
    domain_parsing:
<span class="nc bnc" id="L448" title="All 2 branches missed.">        while (index &lt; len) {</span>
<span class="nc bnc" id="L449" title="All 5 branches missed.">            switch (name_chars[index]) {</span>
                case ':' :
<span class="nc" id="L451">                    _domain_length = index++;</span>
<span class="nc" id="L452">                    break domain_parsing;</span>
                case '=' :
                    // &quot;:&quot; omission check.
                    //
                    // Although &quot;=&quot; is a valid character in the domain part
                    // it is true that it is rarely used in the real world.
                    // So check straight away if the &quot;:&quot; has been omitted
                    // from the ObjectName. This allows us to provide a more
                    // accurate exception message.
<span class="nc" id="L461">                    int i = ++index;</span>
<span class="nc bnc" id="L462" title="All 4 branches missed.">                    while ((i &lt; len) &amp;&amp; (name_chars[i++] != ':'))</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                        if (i == len)</span>
<span class="nc" id="L464">                            throw new MalformedObjectNameException(</span>
                                &quot;Domain part must be specified&quot;);
                    break;
                case '\n' :
<span class="nc" id="L468">                    throw new MalformedObjectNameException(</span>
                              &quot;Invalid character '\\n' in domain name&quot;);
                case '*' :
                case '?' :
<span class="nc" id="L472">                    _domain_pattern = true;</span>
<span class="nc" id="L473">                    index++;</span>
<span class="nc" id="L474">                    break;</span>
                default :
<span class="nc" id="L476">                    index++;</span>
<span class="nc" id="L477">                    break;</span>
            }
        }

        // check for non-empty properties
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (index == len)</span>
<span class="nc" id="L483">            throw new MalformedObjectNameException(</span>
                                         &quot;Key properties cannot be empty&quot;);

        // we have got the domain part, begins building of _canonicalName
<span class="nc" id="L487">        System.arraycopy(name_chars, 0, canonical_chars, 0, _domain_length);</span>
<span class="nc" id="L488">        canonical_chars[_domain_length] = ':';</span>
<span class="nc" id="L489">        cname_index = _domain_length + 1;</span>

        // parses property list
        Property prop;
<span class="nc" id="L493">        Map&lt;String,Property&gt; keys_map = new HashMap&lt;String,Property&gt;();</span>
        String[] keys;
        String key_name;
        boolean quoted_value;
<span class="nc" id="L497">        int property_index = 0;</span>
        int in_index;
        int key_index, key_length, value_index, value_length;

<span class="nc" id="L501">        keys = new String[10];</span>
<span class="nc" id="L502">        _kp_array = new Property[10];</span>
<span class="nc" id="L503">        _property_list_pattern = false;</span>
<span class="nc" id="L504">        _property_value_pattern = false;</span>

<span class="nc bnc" id="L506" title="All 2 branches missed.">        while (index &lt; len) {</span>
<span class="nc" id="L507">            c = name_chars[index];</span>

            // case of pattern properties
<span class="nc bnc" id="L510" title="All 2 branches missed.">            if (c == '*') {</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">                if (_property_list_pattern)</span>
<span class="nc" id="L512">                    throw new MalformedObjectNameException(</span>
                              &quot;Cannot have several '*' characters in pattern &quot; +
                              &quot;property list&quot;);
                else {
<span class="nc" id="L516">                    _property_list_pattern = true;</span>
<span class="nc bnc" id="L517" title="All 4 branches missed.">                    if ((++index &lt; len ) &amp;&amp; (name_chars[index] != ','))</span>
<span class="nc" id="L518">                        throw new MalformedObjectNameException(</span>
                                  &quot;Invalid character found after '*': end of &quot; +
                                  &quot;name or ',' expected&quot;);
<span class="nc bnc" id="L521" title="All 2 branches missed.">                    else if (index == len) {</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                        if (property_index == 0) {</span>
                            // empty properties case
<span class="nc" id="L524">                            _kp_array = _Empty_property_array;</span>
<span class="nc" id="L525">                            _ca_array = _Empty_property_array;</span>
<span class="nc" id="L526">                            _propertyList = Collections.emptyMap();</span>
                        }
                        break;
                    } else {
                        // correct pattern spec in props, continue
<span class="nc" id="L531">                        index++;</span>
<span class="nc" id="L532">                        continue;</span>
                    }
                }
            }

            // standard property case, key part
<span class="nc" id="L538">            in_index = index;</span>
<span class="nc" id="L539">            key_index = in_index;</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            if (name_chars[in_index] == '=')</span>
<span class="nc" id="L541">                throw new MalformedObjectNameException(&quot;Invalid key (empty)&quot;);</span>
<span class="nc bnc" id="L542" title="All 4 branches missed.">            while ((in_index &lt; len) &amp;&amp; ((c1 = name_chars[in_index++]) != '='))</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">                switch (c1) {</span>
                    // '=' considered to introduce value part
                    case  '*' :
                    case  '?' :
                    case  ',' :
                    case  ':' :
                    case  '\n' :
<span class="nc bnc" id="L550" title="All 2 branches missed.">                        final String ichar = ((c1=='\n')?&quot;\\n&quot;:&quot;&quot;+c1);</span>
<span class="nc" id="L551">                        throw new MalformedObjectNameException(</span>
                                  &quot;Invalid character '&quot; + ichar +
                                  &quot;' in key part of property&quot;);
                }
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (name_chars[in_index - 1] != '=')</span>
<span class="nc" id="L556">                throw new MalformedObjectNameException(</span>
                                             &quot;Unterminated key property part&quot;);
<span class="nc" id="L558">            value_index = in_index; // in_index pointing after '=' char</span>
<span class="nc" id="L559">            key_length = value_index - key_index - 1; // found end of key</span>

            // standard property case, value part
<span class="nc" id="L562">            boolean value_pattern = false;</span>
<span class="nc bnc" id="L563" title="All 4 branches missed.">            if (in_index &lt; len &amp;&amp; name_chars[in_index] == '\&quot;') {</span>
<span class="nc" id="L564">                quoted_value = true;</span>
                // the case of quoted value part
            quoted_value_parsing:
<span class="nc bnc" id="L567" title="All 4 branches missed.">                while ((++in_index &lt; len) &amp;&amp;</span>
                       ((c1 = name_chars[in_index]) != '\&quot;')) {
                    // the case of an escaped character
<span class="nc bnc" id="L570" title="All 2 branches missed.">                    if (c1 == '\\') {</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">                        if (++in_index == len)</span>
<span class="nc" id="L572">                            throw new MalformedObjectNameException(</span>
                                               &quot;Unterminated quoted value&quot;);
<span class="nc bnc" id="L574" title="All 2 branches missed.">                        switch (c1 = name_chars[in_index]) {</span>
                            case '\\' :
                            case '\&quot;' :
                            case '?' :
                            case '*' :
                            case 'n' :
<span class="nc" id="L580">                                break; // valid character</span>
                            default :
<span class="nc" id="L582">                                throw new MalformedObjectNameException(</span>
                                          &quot;Invalid escape sequence '\\&quot; +
                                          c1 + &quot;' in quoted value&quot;);
                        }
<span class="nc bnc" id="L586" title="All 2 branches missed.">                    } else if (c1 == '\n') {</span>
<span class="nc" id="L587">                        throw new MalformedObjectNameException(</span>
                                                     &quot;Newline in quoted value&quot;);
                    } else {
<span class="nc bnc" id="L590" title="All 2 branches missed.">                        switch (c1) {</span>
                            case '?' :
                            case '*' :
<span class="nc" id="L593">                                value_pattern = true;</span>
<span class="nc" id="L594">                                break;</span>
                        }
                    }
                }
<span class="nc bnc" id="L598" title="All 2 branches missed.">                if (in_index == len)</span>
<span class="nc" id="L599">                    throw new MalformedObjectNameException(</span>
                                                 &quot;Unterminated quoted value&quot;);
<span class="nc" id="L601">                else value_length = ++in_index - value_index;</span>
            } else {
                // the case of standard value part
<span class="nc" id="L604">                quoted_value = false;</span>
<span class="nc bnc" id="L605" title="All 4 branches missed.">                while ((in_index &lt; len) &amp;&amp; ((c1 = name_chars[in_index]) != ','))</span>
<span class="nc bnc" id="L606" title="All 3 branches missed.">                switch (c1) {</span>
                    // ',' considered to be the value separator
                    case '*' :
                    case '?' :
<span class="nc" id="L610">                        value_pattern = true;</span>
<span class="nc" id="L611">                        in_index++;</span>
<span class="nc" id="L612">                        break;</span>
                    case '=' :
                    case ':' :
                    case '&quot;' :
                    case '\n' :
<span class="nc bnc" id="L617" title="All 2 branches missed.">                        final String ichar = ((c1=='\n')?&quot;\\n&quot;:&quot;&quot;+c1);</span>
<span class="nc" id="L618">                        throw new MalformedObjectNameException(</span>
                                                 &quot;Invalid character '&quot; + ichar +
                                                 &quot;' in value part of property&quot;);
                    default :
<span class="nc" id="L622">                        in_index++;</span>
<span class="nc" id="L623">                        break;</span>
                }
<span class="nc" id="L625">                value_length = in_index - value_index;</span>
            }

            // Parsed property, checks the end of name
<span class="nc bnc" id="L629" title="All 2 branches missed.">            if (in_index == len - 1) {</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">                if (quoted_value)</span>
<span class="nc" id="L631">                    throw new MalformedObjectNameException(</span>
                                             &quot;Invalid ending character `&quot; +
                                             name_chars[in_index] + &quot;'&quot;);
<span class="nc" id="L634">                else throw new MalformedObjectNameException(</span>
                                                  &quot;Invalid ending comma&quot;);
<span class="nc" id="L636">            } else in_index++;</span>

            // we got the key and value part, prepare a property for this
<span class="nc bnc" id="L639" title="All 2 branches missed.">            if (!value_pattern) {</span>
<span class="nc" id="L640">                prop = new Property(key_index, key_length, value_length);</span>
            } else {
<span class="nc" id="L642">                _property_value_pattern = true;</span>
<span class="nc" id="L643">                prop = new PatternProperty(key_index, key_length, value_length);</span>
            }
<span class="nc" id="L645">            key_name = name.substring(key_index, key_index + key_length);</span>

<span class="nc bnc" id="L647" title="All 2 branches missed.">            if (property_index == keys.length) {</span>
<span class="nc" id="L648">                String[] tmp_string_array = new String[property_index + 10];</span>
<span class="nc" id="L649">                System.arraycopy(keys, 0, tmp_string_array, 0, property_index);</span>
<span class="nc" id="L650">                keys = tmp_string_array;</span>
            }
<span class="nc" id="L652">            keys[property_index] = key_name;</span>

<span class="nc" id="L654">            addProperty(prop, property_index, keys_map, key_name);</span>
<span class="nc" id="L655">            property_index++;</span>
<span class="nc" id="L656">            index = in_index;</span>
<span class="nc" id="L657">        }</span>

        // computes and set canonical name
<span class="nc" id="L660">        setCanonicalName(name_chars, canonical_chars, keys,</span>
                         keys_map, cname_index, property_index);
<span class="nc" id="L662">    }</span>

    /**
     * Construct an ObjectName from a domain and a Hashtable.
     *
     * @param domain Domain of the ObjectName.
     * @param props  Map containing couples &lt;i&gt;key&lt;/i&gt; {@literal -&gt;} &lt;i&gt;value&lt;/i&gt;.
     *
     * @exception MalformedObjectNameException The &lt;code&gt;domain&lt;/code&gt;
     * contains an illegal character, or one of the keys or values in
     * &lt;code&gt;table&lt;/code&gt; contains an illegal character, or one of the
     * values in &lt;code&gt;table&lt;/code&gt; does not follow the rules for quoting.
     * @exception NullPointerException One of the parameters is null.
     */
    private void construct(String domain, Map&lt;String,String&gt; props)
        throws MalformedObjectNameException {

        // The domain cannot be null
<span class="nc bnc" id="L680" title="All 2 branches missed.">        if (domain == null)</span>
<span class="nc" id="L681">            throw new NullPointerException(&quot;domain cannot be null&quot;);</span>

        // The key property list cannot be null
<span class="nc bnc" id="L684" title="All 2 branches missed.">        if (props == null)</span>
<span class="nc" id="L685">            throw new NullPointerException(&quot;key property list cannot be null&quot;);</span>

        // The key property list cannot be empty
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (props.isEmpty())</span>
<span class="nc" id="L689">            throw new MalformedObjectNameException(</span>
                                         &quot;key property list cannot be empty&quot;);

        // checks domain validity
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (!isDomain(domain))</span>
<span class="nc" id="L694">            throw new MalformedObjectNameException(&quot;Invalid domain: &quot; + domain);</span>

        // init canonicalname
<span class="nc" id="L697">        final StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L698">        sb.append(domain).append(':');</span>
<span class="nc" id="L699">        _domain_length = domain.length();</span>

        // allocates the property array
<span class="nc" id="L702">        int nb_props = props.size();</span>
<span class="nc" id="L703">        _kp_array = new Property[nb_props];</span>

<span class="nc" id="L705">        String[] keys = new String[nb_props];</span>
<span class="nc" id="L706">        final Map&lt;String,Property&gt; keys_map = new HashMap&lt;String,Property&gt;();</span>
        Property prop;
        int key_index;
<span class="nc" id="L709">        int i = 0;</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        for (Map.Entry&lt;String,String&gt; entry : props.entrySet()) {</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">            if (sb.length() &gt; 0)</span>
<span class="nc" id="L712">                sb.append(&quot;,&quot;);</span>
<span class="nc" id="L713">            String key = entry.getKey();</span>
            String value;
            try {
<span class="nc" id="L716">                value = entry.getValue();</span>
<span class="nc" id="L717">            } catch (ClassCastException e) {</span>
<span class="nc" id="L718">                throw new MalformedObjectNameException(e.getMessage());</span>
<span class="nc" id="L719">            }</span>
<span class="nc" id="L720">            key_index = sb.length();</span>
<span class="nc" id="L721">            checkKey(key);</span>
<span class="nc" id="L722">            sb.append(key);</span>
<span class="nc" id="L723">            keys[i] = key;</span>
<span class="nc" id="L724">            sb.append(&quot;=&quot;);</span>
<span class="nc" id="L725">            boolean value_pattern = checkValue(value);</span>
<span class="nc" id="L726">            sb.append(value);</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (!value_pattern) {</span>
<span class="nc" id="L728">                prop = new Property(key_index,</span>
<span class="nc" id="L729">                                    key.length(),</span>
<span class="nc" id="L730">                                    value.length());</span>
            } else {
<span class="nc" id="L732">                _property_value_pattern = true;</span>
<span class="nc" id="L733">                prop = new PatternProperty(key_index,</span>
<span class="nc" id="L734">                                           key.length(),</span>
<span class="nc" id="L735">                                           value.length());</span>
            }
<span class="nc" id="L737">            addProperty(prop, i, keys_map, key);</span>
<span class="nc" id="L738">            i++;</span>
<span class="nc" id="L739">        }</span>

        // initialize canonical name and data structure
<span class="nc" id="L742">        int len = sb.length();</span>
<span class="nc" id="L743">        char[] initial_chars = new char[len];</span>
<span class="nc" id="L744">        sb.getChars(0, len, initial_chars, 0);</span>
<span class="nc" id="L745">        char[] canonical_chars = new char[len];</span>
<span class="nc" id="L746">        System.arraycopy(initial_chars, 0, canonical_chars, 0,</span>
                         _domain_length + 1);
<span class="nc" id="L748">        setCanonicalName(initial_chars, canonical_chars, keys, keys_map,</span>
                         _domain_length + 1, _kp_array.length);
<span class="nc" id="L750">    }</span>
    // Category : Instance construction &lt;==============================

    // Category : Internal utilities ------------------------------&gt;

    /**
     * Add passed property to the list at the given index
     * for the passed key name
     */
    private void addProperty(Property prop, int index,
                             Map&lt;String,Property&gt; keys_map, String key_name)
        throws MalformedObjectNameException {

<span class="nc bnc" id="L763" title="All 2 branches missed.">        if (keys_map.containsKey(key_name)) throw new</span>
                MalformedObjectNameException(&quot;key `&quot; +
                                         key_name +&quot;' already defined&quot;);

        // if no more space for property arrays, have to increase it
<span class="nc bnc" id="L768" title="All 2 branches missed.">        if (index == _kp_array.length) {</span>
<span class="nc" id="L769">            Property[] tmp_prop_array = new Property[index + 10];</span>
<span class="nc" id="L770">            System.arraycopy(_kp_array, 0, tmp_prop_array, 0, index);</span>
<span class="nc" id="L771">            _kp_array = tmp_prop_array;</span>
        }
<span class="nc" id="L773">        _kp_array[index] = prop;</span>
<span class="nc" id="L774">        keys_map.put(key_name, prop);</span>
<span class="nc" id="L775">    }</span>

    /**
     * Sets the canonical name of receiver from input 'specified_chars'
     * array, by filling 'canonical_chars' array with found 'nb-props'
     * properties starting at position 'prop_index'.
     */
    private void setCanonicalName(char[] specified_chars,
                                  char[] canonical_chars,
                                  String[] keys, Map&lt;String,Property&gt; keys_map,
                                  int prop_index, int nb_props) {

        // Sort the list of found properties
<span class="nc bnc" id="L788" title="All 2 branches missed.">        if (_kp_array != _Empty_property_array) {</span>
<span class="nc" id="L789">            String[] tmp_keys = new String[nb_props];</span>
<span class="nc" id="L790">            Property[] tmp_props = new Property[nb_props];</span>

<span class="nc" id="L792">            System.arraycopy(keys, 0, tmp_keys, 0, nb_props);</span>
<span class="nc" id="L793">            Arrays.sort(tmp_keys);</span>
<span class="nc" id="L794">            keys = tmp_keys;</span>
<span class="nc" id="L795">            System.arraycopy(_kp_array, 0, tmp_props, 0 , nb_props);</span>
<span class="nc" id="L796">            _kp_array = tmp_props;</span>
<span class="nc" id="L797">            _ca_array = new Property[nb_props];</span>

            // now assigns _ca_array to the sorted list of keys
            // (there cannot be two identical keys in an objectname.
<span class="nc bnc" id="L801" title="All 2 branches missed.">            for (int i = 0; i &lt; nb_props; i++)</span>
<span class="nc" id="L802">                _ca_array[i] = keys_map.get(keys[i]);</span>

            // now we build the canonical name and set begin indexes of
            // properties to reflect canonical form
<span class="nc" id="L806">            int last_index = nb_props - 1;</span>
            int prop_len;
            Property prop;
<span class="nc bnc" id="L809" title="All 2 branches missed.">            for (int i = 0; i &lt;= last_index; i++) {</span>
<span class="nc" id="L810">                prop = _ca_array[i];</span>
                // length of prop including '=' char
<span class="nc" id="L812">                prop_len = prop._key_length + prop._value_length + 1;</span>
<span class="nc" id="L813">                System.arraycopy(specified_chars, prop._key_index,</span>
                                 canonical_chars, prop_index, prop_len);
<span class="nc" id="L815">                prop.setKeyIndex(prop_index);</span>
<span class="nc" id="L816">                prop_index += prop_len;</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">                if (i != last_index) {</span>
<span class="nc" id="L818">                    canonical_chars[prop_index] = ',';</span>
<span class="nc" id="L819">                    prop_index++;</span>
                }
            }
        }

        // terminate canonicalname with '*' in case of pattern
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (_property_list_pattern) {</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">            if (_kp_array != _Empty_property_array)</span>
<span class="nc" id="L827">                canonical_chars[prop_index++] = ',';</span>
<span class="nc" id="L828">            canonical_chars[prop_index++] = '*';</span>
        }

        // we now build the canonicalname string
<span class="nc" id="L832">        _canonicalName = (new String(canonical_chars, 0, prop_index)).intern();</span>
<span class="nc" id="L833">    }</span>

    /**
     * Parse a key.
     * &lt;pre&gt;final int endKey=parseKey(s,startKey);&lt;/pre&gt;
     * &lt;p&gt;key starts at startKey (included), and ends at endKey (excluded).
     * If (startKey == endKey), then the key is empty.
     *
     * @param s The char array of the original string.
     * @param startKey index at which to begin parsing.
     * @return The index following the last character of the key.
     **/
    private static int parseKey(final char[] s, final int startKey)
        throws MalformedObjectNameException {
<span class="nc" id="L847">        int next   = startKey;</span>
<span class="nc" id="L848">        int endKey = startKey;</span>
<span class="nc" id="L849">        final int len = s.length;</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">        while (next &lt; len) {</span>
<span class="nc" id="L851">            final char k = s[next++];</span>
<span class="nc bnc" id="L852" title="All 3 branches missed.">            switch (k) {</span>
            case '*':
            case '?':
            case ',':
            case ':':
            case '\n':
<span class="nc bnc" id="L858" title="All 2 branches missed.">                final String ichar = ((k=='\n')?&quot;\\n&quot;:&quot;&quot;+k);</span>
<span class="nc" id="L859">                throw new</span>
                    MalformedObjectNameException(&quot;Invalid character in key: `&quot;
                                                 + ichar + &quot;'&quot;);
            case '=':
                // we got the key.
<span class="nc" id="L864">                endKey = next-1;</span>
<span class="nc" id="L865">                break;</span>
            default:
<span class="nc bnc" id="L867" title="All 2 branches missed.">                if (next &lt; len) continue;</span>
<span class="nc" id="L868">                else endKey=next;</span>
            }
<span class="nc" id="L870">            break;</span>
        }
<span class="nc" id="L872">        return endKey;</span>
    }

    /**
     * Parse a value.
     * &lt;pre&gt;final int endVal=parseValue(s,startVal);&lt;/pre&gt;
     * &lt;p&gt;value starts at startVal (included), and ends at endVal (excluded).
     * If (startVal == endVal), then the key is empty.
     *
     * @param s The char array of the original string.
     * @param startValue index at which to begin parsing.
     * @return The first element of the int array indicates the index
     *         following the last character of the value. The second
     *         element of the int array indicates that the value is
     *         a pattern when its value equals 1.
     **/
    private static int[] parseValue(final char[] s, final int startValue)
        throws MalformedObjectNameException {

<span class="nc" id="L891">        boolean value_pattern = false;</span>

<span class="nc" id="L893">        int next   = startValue;</span>
<span class="nc" id="L894">        int endValue = startValue;</span>

<span class="nc" id="L896">        final int len = s.length;</span>
<span class="nc" id="L897">        final char q=s[startValue];</span>

<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (q == '&quot;') {</span>
            // quoted value
<span class="nc bnc" id="L901" title="All 2 branches missed.">            if (++next == len) throw new</span>
                MalformedObjectNameException(&quot;Invalid quote&quot;);
<span class="nc bnc" id="L903" title="All 2 branches missed.">            while (next &lt; len) {</span>
<span class="nc" id="L904">                char last = s[next];</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">                if (last == '\\') {</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">                    if (++next == len) throw new</span>
                        MalformedObjectNameException(
                           &quot;Invalid unterminated quoted character sequence&quot;);
<span class="nc" id="L909">                    last = s[next];</span>
<span class="nc bnc" id="L910" title="All 3 branches missed.">                    switch (last) {</span>
                        case '\\' :
                        case '?' :
                        case '*' :
                        case 'n' :
<span class="nc" id="L915">                            break;</span>
                        case '\&quot;' :
                            // We have an escaped quote. If this escaped
                            // quote is the last character, it does not
                            // qualify as a valid termination quote.
                            //
<span class="nc bnc" id="L921" title="All 2 branches missed.">                            if (next+1 == len) throw new</span>
                                MalformedObjectNameException(
                                                 &quot;Missing termination quote&quot;);
                            break;
                        default:
<span class="nc" id="L926">                            throw new</span>
                                MalformedObjectNameException(
                                &quot;Invalid quoted character sequence '\\&quot; +
                                last + &quot;'&quot;);
                    }
<span class="nc bnc" id="L931" title="All 2 branches missed.">                } else if (last == '\n') {</span>
<span class="nc" id="L932">                    throw new MalformedObjectNameException(</span>
                                                 &quot;Newline in quoted value&quot;);
<span class="nc bnc" id="L934" title="All 2 branches missed.">                } else if (last == '\&quot;') {</span>
<span class="nc" id="L935">                    next++;</span>
<span class="nc" id="L936">                    break;</span>
                } else {
<span class="nc bnc" id="L938" title="All 2 branches missed.">                    switch (last) {</span>
                        case '?' :
                        case '*' :
<span class="nc" id="L941">                            value_pattern = true;</span>
                            break;
                    }
                }
<span class="nc" id="L945">                next++;</span>

                // Check that last character is a termination quote.
                // We have already handled the case were the last
                // character is an escaped quote earlier.
                //
<span class="nc bnc" id="L951" title="All 4 branches missed.">                if ((next &gt;= len) &amp;&amp; (last != '\&quot;')) throw new</span>
                    MalformedObjectNameException(&quot;Missing termination quote&quot;);
<span class="nc" id="L953">            }</span>
<span class="nc" id="L954">            endValue = next;</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">            if (next &lt; len) {</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">                if (s[next++] != ',') throw new</span>
                    MalformedObjectNameException(&quot;Invalid quote&quot;);
            }
        } else {
            // Non quoted value.
<span class="nc bnc" id="L961" title="All 2 branches missed.">            while (next &lt; len) {</span>
<span class="nc" id="L962">                final char v=s[next++];</span>
<span class="nc bnc" id="L963" title="All 4 branches missed.">                switch(v) {</span>
                    case '*':
                    case '?':
<span class="nc" id="L966">                        value_pattern = true;</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">                        if (next &lt; len) continue;</span>
<span class="nc" id="L968">                        else endValue=next;</span>
<span class="nc" id="L969">                        break;</span>
                    case '=':
                    case ':':
                    case '\n' :
<span class="nc bnc" id="L973" title="All 2 branches missed.">                        final String ichar = ((v=='\n')?&quot;\\n&quot;:&quot;&quot;+v);</span>
<span class="nc" id="L974">                        throw new</span>
                            MalformedObjectNameException(&quot;Invalid character `&quot; +
                                                         ichar + &quot;' in value&quot;);
                    case ',':
<span class="nc" id="L978">                        endValue = next-1;</span>
<span class="nc" id="L979">                        break;</span>
                    default:
<span class="nc bnc" id="L981" title="All 2 branches missed.">                        if (next &lt; len) continue;</span>
<span class="nc" id="L982">                        else endValue=next;</span>
                }
<span class="nc" id="L984">                break;</span>
            }
        }
<span class="nc bnc" id="L987" title="All 2 branches missed.">        return new int[] { endValue, value_pattern ? 1 : 0 };</span>
    }

    /**
     * Check if the supplied value is a valid value.
     *
     * @return true if the value is a pattern, otherwise false.
     */
    private static boolean checkValue(String val)
        throws MalformedObjectNameException {

<span class="nc bnc" id="L998" title="All 2 branches missed.">        if (val == null) throw new</span>
            NullPointerException(&quot;Invalid value (null)&quot;);

<span class="nc" id="L1001">        final int len = val.length();</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">        if (len == 0)</span>
<span class="nc" id="L1003">            return false;</span>

<span class="nc" id="L1005">        final char[] s = val.toCharArray();</span>
<span class="nc" id="L1006">        final int[] result = parseValue(s,0);</span>
<span class="nc" id="L1007">        final int endValue = result[0];</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        final boolean value_pattern = result[1] == 1;</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        if (endValue &lt; len) throw new</span>
            MalformedObjectNameException(&quot;Invalid character in value: `&quot; +
                                         s[endValue] + &quot;'&quot;);
<span class="nc" id="L1012">        return value_pattern;</span>
    }

    /**
     * Check if the supplied key is a valid key.
     */
    private static void checkKey(String key)
        throws MalformedObjectNameException {

<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (key == null) throw new</span>
            NullPointerException(&quot;Invalid key (null)&quot;);

<span class="nc" id="L1024">        final int len = key.length();</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">        if (len == 0) throw new</span>
            MalformedObjectNameException(&quot;Invalid key (empty)&quot;);
<span class="nc" id="L1027">        final char[] k=key.toCharArray();</span>
<span class="nc" id="L1028">        final int endKey = parseKey(k,0);</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        if (endKey &lt; len) throw new</span>
            MalformedObjectNameException(&quot;Invalid character in value: `&quot; +
                                         k[endKey] + &quot;'&quot;);
<span class="nc" id="L1032">    }</span>


    // Category : Internal utilities &lt;==============================

    // Category : Internal accessors ------------------------------&gt;

    /**
     * Check if domain is a valid domain.  Set _domain_pattern if appropriate.
     */
    private boolean isDomain(String domain) {
<span class="nc bnc" id="L1043" title="All 2 branches missed.">        if (domain == null) return true;</span>
<span class="nc" id="L1044">        final int len = domain.length();</span>
<span class="nc" id="L1045">        int next = 0;</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        while (next &lt; len) {</span>
<span class="nc" id="L1047">            final char c = domain.charAt(next++);</span>
<span class="nc bnc" id="L1048" title="All 3 branches missed.">            switch (c) {</span>
                case ':' :
                case '\n' :
<span class="nc" id="L1051">                    return false;</span>
                case '*' :
                case '?' :
<span class="nc" id="L1054">                    _domain_pattern = true;</span>
                    break;
            }
<span class="nc" id="L1057">        }</span>
<span class="nc" id="L1058">        return true;</span>
    }

    // Category : Internal accessors &lt;==============================

    // Category : Serialization -----------------------------------&gt;

    /**
     * Deserializes an {@link ObjectName} from an {@link ObjectInputStream}.
     * @serialData &lt;ul&gt;
     *               &lt;li&gt;In the current serial form (value of property
     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; differs from
     *                   &lt;code&gt;1.0&lt;/code&gt;): the string
     *                   &amp;quot;&amp;lt;domain&amp;gt;:&amp;lt;properties&amp;gt;&amp;lt;wild&amp;gt;&amp;quot;,
     *                   where: &lt;ul&gt;
     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
     *                                of the {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;properties&amp;gt; represents the list of
     *                                properties, as returned by
     *                                {@link #getKeyPropertyListString}
     *                            &lt;li&gt;&amp;lt;wild&amp;gt; is empty if not
     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt;, or
     *                                is the character &quot;&lt;code&gt;*&lt;/code&gt;&quot; if
     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt;
     *                                and &amp;lt;properties&amp;gt; is empty, or
     *                                is &quot;&lt;code&gt;,*&lt;/code&gt;&quot; if
     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt; and
     *                                &amp;lt;properties&amp;gt; is not empty.
     *                            &lt;/li&gt;
     *                          &lt;/ul&gt;
     *                   The intent is that this string could be supplied
     *                   to the {@link #ObjectName(String)} constructor to
     *                   produce an equivalent {@link ObjectName}.
     *               &lt;/li&gt;
     *               &lt;li&gt;In the old serial form (value of property
     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; is
     *                   &lt;code&gt;1.0&lt;/code&gt;): &amp;lt;domain&amp;gt; &amp;lt;propertyList&amp;gt;
     *                   &amp;lt;propertyListString&amp;gt; &amp;lt;canonicalName&amp;gt;
     *                   &amp;lt;pattern&amp;gt; &amp;lt;propertyPattern&amp;gt;,
     *                   where: &lt;ul&gt;
     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
     *                                of the {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyList&amp;gt; is the
     *                                {@link Hashtable} that contains all the
     *                                pairs (key,value) for this
     *                                {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyListString&amp;gt; is the
     *                                {@link String} representation of the
     *                                list of properties in any order (not
     *                                mandatorily a canonical representation)
     *                                &lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;canonicalName&amp;gt; is the
     *                                {@link String} containing this
     *                                {@link ObjectName}'s canonical name&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;pattern&amp;gt; is a boolean which is
     *                                &lt;code&gt;true&lt;/code&gt; if this
     *                                {@link ObjectName} contains a pattern&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyPattern&amp;gt; is a boolean which
     *                                is &lt;code&gt;true&lt;/code&gt; if this
     *                                {@link ObjectName} contains a pattern in
     *                                the list of properties&lt;/li&gt;
     *                          &lt;/ul&gt;
     *               &lt;/li&gt;
     *             &lt;/ul&gt;
     */
    private void readObject(ObjectInputStream in)
        throws IOException, ClassNotFoundException {

        String cn;
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        if (compat) {</span>
            // Read an object serialized in the old serial form
            //
            //in.defaultReadObject();
<span class="nc" id="L1131">            final ObjectInputStream.GetField fields = in.readFields();</span>
<span class="nc" id="L1132">            String propListString =</span>
<span class="nc" id="L1133">                    (String)fields.get(&quot;propertyListString&quot;, &quot;&quot;);</span>

            // 6616825: take care of property patterns
<span class="nc" id="L1136">            final boolean propPattern =</span>
<span class="nc" id="L1137">                    fields.get(&quot;propertyPattern&quot; , false);</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">            if (propPattern) {</span>
<span class="nc" id="L1139">                propListString =</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">                        (propListString.length()==0?&quot;*&quot;:(propListString+&quot;,*&quot;));</span>
            }

<span class="nc" id="L1143">            cn = (String)fields.get(&quot;domain&quot;, &quot;default&quot;)+</span>
                &quot;:&quot;+ propListString;
<span class="nc" id="L1145">        } else {</span>
            // Read an object serialized in the new serial form
            //
<span class="nc" id="L1148">            in.defaultReadObject();</span>
<span class="nc" id="L1149">            cn = (String)in.readObject();</span>
        }

        try {
<span class="nc" id="L1153">            construct(cn);</span>
<span class="nc" id="L1154">        } catch (NullPointerException e) {</span>
<span class="nc" id="L1155">            throw new InvalidObjectException(e.toString());</span>
<span class="nc" id="L1156">        } catch (MalformedObjectNameException e) {</span>
<span class="nc" id="L1157">            throw new InvalidObjectException(e.toString());</span>
<span class="nc" id="L1158">        }</span>
<span class="nc" id="L1159">    }</span>


    /**
     * Serializes an {@link ObjectName} to an {@link ObjectOutputStream}.
     * @serialData &lt;ul&gt;
     *               &lt;li&gt;In the current serial form (value of property
     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; differs from
     *                   &lt;code&gt;1.0&lt;/code&gt;): the string
     *                   &amp;quot;&amp;lt;domain&amp;gt;:&amp;lt;properties&amp;gt;&amp;lt;wild&amp;gt;&amp;quot;,
     *                   where: &lt;ul&gt;
     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
     *                                of the {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;properties&amp;gt; represents the list of
     *                                properties, as returned by
     *                                {@link #getKeyPropertyListString}
     *                            &lt;li&gt;&amp;lt;wild&amp;gt; is empty if not
     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt;, or
     *                                is the character &quot;&lt;code&gt;*&lt;/code&gt;&quot; if
     *                                this &lt;code&gt;isPropertyPattern&lt;/code&gt;
     *                                and &amp;lt;properties&amp;gt; is empty, or
     *                                is &quot;&lt;code&gt;,*&lt;/code&gt;&quot; if
     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt; and
     *                                &amp;lt;properties&amp;gt; is not empty.
     *                            &lt;/li&gt;
     *                          &lt;/ul&gt;
     *                   The intent is that this string could be supplied
     *                   to the {@link #ObjectName(String)} constructor to
     *                   produce an equivalent {@link ObjectName}.
     *               &lt;/li&gt;
     *               &lt;li&gt;In the old serial form (value of property
     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; is
     *                   &lt;code&gt;1.0&lt;/code&gt;): &amp;lt;domain&amp;gt; &amp;lt;propertyList&amp;gt;
     *                   &amp;lt;propertyListString&amp;gt; &amp;lt;canonicalName&amp;gt;
     *                   &amp;lt;pattern&amp;gt; &amp;lt;propertyPattern&amp;gt;,
     *                   where: &lt;ul&gt;
     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
     *                                of the {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyList&amp;gt; is the
     *                                {@link Hashtable} that contains all the
     *                                pairs (key,value) for this
     *                                {@link ObjectName}&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyListString&amp;gt; is the
     *                                {@link String} representation of the
     *                                list of properties in any order (not
     *                                mandatorily a canonical representation)
     *                                &lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;canonicalName&amp;gt; is the
     *                                {@link String} containing this
     *                                {@link ObjectName}'s canonical name&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;pattern&amp;gt; is a boolean which is
     *                                &lt;code&gt;true&lt;/code&gt; if this
     *                                {@link ObjectName} contains a pattern&lt;/li&gt;
     *                            &lt;li&gt;&amp;lt;propertyPattern&amp;gt; is a boolean which
     *                                is &lt;code&gt;true&lt;/code&gt; if this
     *                                {@link ObjectName} contains a pattern in
     *                                the list of properties&lt;/li&gt;
     *                          &lt;/ul&gt;
     *               &lt;/li&gt;
     *             &lt;/ul&gt;
     */
    private void writeObject(ObjectOutputStream out)
            throws IOException {

<span class="nc bnc" id="L1223" title="All 2 branches missed.">      if (compat)</span>
      {
        // Serializes this instance in the old serial form
        // Read CR 6441274 before making any changes to this code
<span class="nc" id="L1227">        ObjectOutputStream.PutField fields = out.putFields();</span>
<span class="nc" id="L1228">        fields.put(&quot;domain&quot;, _canonicalName.substring(0, _domain_length));</span>
<span class="nc" id="L1229">        fields.put(&quot;propertyList&quot;, getKeyPropertyList());</span>
<span class="nc" id="L1230">        fields.put(&quot;propertyListString&quot;, getKeyPropertyListString());</span>
<span class="nc" id="L1231">        fields.put(&quot;canonicalName&quot;, _canonicalName);</span>
<span class="nc bnc" id="L1232" title="All 4 branches missed.">        fields.put(&quot;pattern&quot;, (_domain_pattern || _property_list_pattern));</span>
<span class="nc" id="L1233">        fields.put(&quot;propertyPattern&quot;, _property_list_pattern);</span>
<span class="nc" id="L1234">        out.writeFields();</span>
<span class="nc" id="L1235">      }</span>
      else
      {
        // Serializes this instance in the new serial form
        //
<span class="nc" id="L1240">        out.defaultWriteObject();</span>
<span class="nc" id="L1241">        out.writeObject(getSerializedNameString());</span>
      }
<span class="nc" id="L1243">    }</span>

    //  Category : Serialization &lt;===================================

    // Private methods &lt;========================================

    // Public methods ----------------------------------------&gt;

    // Category : ObjectName Construction ------------------------------&gt;

    /**
     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
     * an object obtained with {@link #ObjectName(String) new
     * ObjectName(name)} can be used.  The returned object may be of
     * a subclass of ObjectName.  Calling this method twice with the
     * same parameters may return the same object or two equal but
     * not identical objects.&lt;/p&gt;
     *
     * @param name  A string representation of the object name.
     *
     * @return an ObjectName corresponding to the given String.
     *
     * @exception MalformedObjectNameException The string passed as a
     * parameter does not have the right format.
     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; parameter
     * is null.
     *
     */
    public static ObjectName getInstance(String name)
            throws MalformedObjectNameException, NullPointerException {
<span class="nc" id="L1273">        return new ObjectName(name);</span>
    }

    /**
     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
     * an object obtained with {@link #ObjectName(String, String,
     * String) new ObjectName(domain, key, value)} can be used.  The
     * returned object may be of a subclass of ObjectName.  Calling
     * this method twice with the same parameters may return the same
     * object or two equal but not identical objects.&lt;/p&gt;
     *
     * @param domain  The domain part of the object name.
     * @param key  The attribute in the key property of the object name.
     * @param value The value in the key property of the object name.
     *
     * @return an ObjectName corresponding to the given domain,
     * key, and value.
     *
     * @exception MalformedObjectNameException The
     * &lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;value&lt;/code&gt;
     * contains an illegal character, or &lt;code&gt;value&lt;/code&gt; does not
     * follow the rules for quoting.
     * @exception NullPointerException One of the parameters is null.
     *
     */
    public static ObjectName getInstance(String domain, String key,
                                         String value)
            throws MalformedObjectNameException {
<span class="nc" id="L1301">        return new ObjectName(domain, key, value);</span>
    }

    /**
     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
     * an object obtained with {@link #ObjectName(String, Hashtable)
     * new ObjectName(domain, table)} can be used.  The returned
     * object may be of a subclass of ObjectName.  Calling this method
     * twice with the same parameters may return the same object or
     * two equal but not identical objects.&lt;/p&gt;
     *
     * @param domain  The domain part of the object name.
     * @param table A hash table containing one or more key
     * properties.  The key of each entry in the table is the key of a
     * key property in the object name.  The associated value in the
     * table is the associated value in the object name.
     *
     * @return an ObjectName corresponding to the given domain and
     * key mappings.
     *
     * @exception MalformedObjectNameException The &lt;code&gt;domain&lt;/code&gt;
     * contains an illegal character, or one of the keys or values in
     * &lt;code&gt;table&lt;/code&gt; contains an illegal character, or one of the
     * values in &lt;code&gt;table&lt;/code&gt; does not follow the rules for
     * quoting.
     * @exception NullPointerException One of the parameters is null.
     *
     */
    public static ObjectName getInstance(String domain,
                                         Hashtable&lt;String,String&gt; table)
        throws MalformedObjectNameException {
<span class="nc" id="L1332">        return new ObjectName(domain, table);</span>
    }

    /**
     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
     * the given object can be used.  The returned object may be of a
     * subclass of ObjectName.  If &lt;code&gt;name&lt;/code&gt; is of a subclass
     * of ObjectName, it is not guaranteed that the returned object
     * will be of the same class.&lt;/p&gt;
     *
     * &lt;p&gt;The returned value may or may not be identical to
     * &lt;code&gt;name&lt;/code&gt;.  Calling this method twice with the same
     * parameters may return the same object or two equal but not
     * identical objects.&lt;/p&gt;
     *
     * &lt;p&gt;Since ObjectName is immutable, it is not usually useful to
     * make a copy of an ObjectName.  The principal use of this method
     * is to guard against a malicious caller who might pass an
     * instance of a subclass with surprising behavior to sensitive
     * code.  Such code can call this method to obtain an ObjectName
     * that is known not to have surprising behavior.&lt;/p&gt;
     *
     * @param name an instance of the ObjectName class or of a subclass
     *
     * @return an instance of ObjectName or a subclass that is known to
     * have the same semantics.  If &lt;code&gt;name&lt;/code&gt; respects the
     * semantics of ObjectName, then the returned object is equal
     * (though not necessarily identical) to &lt;code&gt;name&lt;/code&gt;.
     *
     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; is null.
     *
     */
    public static ObjectName getInstance(ObjectName name) {
<span class="nc bnc" id="L1365" title="All 2 branches missed.">        if (name.getClass().equals(ObjectName.class))</span>
<span class="nc" id="L1366">            return name;</span>
<span class="nc" id="L1367">        return Util.newObjectName(name.getSerializedNameString());</span>
    }

    /**
     * Construct an object name from the given string.
     *
     * @param name  A string representation of the object name.
     *
     * @exception MalformedObjectNameException The string passed as a
     * parameter does not have the right format.
     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; parameter
     * is null.
     */
    public ObjectName(String name)
<span class="nc" id="L1381">        throws MalformedObjectNameException {</span>
<span class="nc" id="L1382">        construct(name);</span>
<span class="nc" id="L1383">    }</span>

    /**
     * Construct an object name with exactly one key property.
     *
     * @param domain  The domain part of the object name.
     * @param key  The attribute in the key property of the object name.
     * @param value The value in the key property of the object name.
     *
     * @exception MalformedObjectNameException The
     * &lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;value&lt;/code&gt;
     * contains an illegal character, or &lt;code&gt;value&lt;/code&gt; does not
     * follow the rules for quoting.
     * @exception NullPointerException One of the parameters is null.
     */
    public ObjectName(String domain, String key, String value)
<span class="nc" id="L1399">        throws MalformedObjectNameException {</span>
        // If key or value are null a NullPointerException
        // will be thrown by the put method in Hashtable.
        //
<span class="nc" id="L1403">        Map&lt;String,String&gt; table = Collections.singletonMap(key, value);</span>
<span class="nc" id="L1404">        construct(domain, table);</span>
<span class="nc" id="L1405">    }</span>

    /**
     * Construct an object name with several key properties from a Hashtable.
     *
     * @param domain  The domain part of the object name.
     * @param table A hash table containing one or more key
     * properties.  The key of each entry in the table is the key of a
     * key property in the object name.  The associated value in the
     * table is the associated value in the object name.
     *
     * @exception MalformedObjectNameException The &lt;code&gt;domain&lt;/code&gt;
     * contains an illegal character, or one of the keys or values in
     * &lt;code&gt;table&lt;/code&gt; contains an illegal character, or one of the
     * values in &lt;code&gt;table&lt;/code&gt; does not follow the rules for
     * quoting.
     * @exception NullPointerException One of the parameters is null.
     */
    public ObjectName(String domain, Hashtable&lt;String,String&gt; table)
<span class="nc" id="L1424">            throws MalformedObjectNameException {</span>
<span class="nc" id="L1425">        construct(domain, table);</span>
        /* The exception for when a key or value in the table is not a
           String is now ClassCastException rather than
           MalformedObjectNameException.  This was not previously
           specified.  */
<span class="nc" id="L1430">    }</span>

    // Category : ObjectName Construction &lt;==============================


    // Category : Getter methods ------------------------------&gt;

    /**
     * Checks whether the object name is a pattern.
     * &lt;p&gt;
     * An object name is a pattern if its domain contains a
     * wildcard or if the object name is a property pattern.
     *
     * @return  True if the name is a pattern, otherwise false.
     */
    public boolean isPattern() {
<span class="nc bnc" id="L1446" title="All 6 branches missed.">        return (_domain_pattern ||</span>
                _property_list_pattern ||
                _property_value_pattern);
    }

    /**
     * Checks whether the object name is a pattern on the domain part.
     *
     * @return  True if the name is a domain pattern, otherwise false.
     *
     */
    public boolean isDomainPattern() {
<span class="nc" id="L1458">        return _domain_pattern;</span>
    }

    /**
     * Checks whether the object name is a pattern on the key properties.
     * &lt;p&gt;
     * An object name is a pattern on the key properties if it is a
     * pattern on the key property list (e.g. &quot;d:k=v,*&quot;) or on the
     * property values (e.g. &quot;d:k=*&quot;) or on both (e.g. &quot;d:k=*,*&quot;).
     *
     * @return  True if the name is a property pattern, otherwise false.
     */
    public boolean isPropertyPattern() {
<span class="nc bnc" id="L1471" title="All 4 branches missed.">        return _property_list_pattern || _property_value_pattern;</span>
    }

    /**
     * Checks whether the object name is a pattern on the key property list.
     * &lt;p&gt;
     * For example, &quot;d:k=v,*&quot; and &quot;d:k=*,*&quot; are key property list patterns
     * whereas &quot;d:k=*&quot; is not.
     *
     * @return  True if the name is a property list pattern, otherwise false.
     *
     * @since 1.6
     */
    public boolean isPropertyListPattern() {
<span class="nc" id="L1485">        return _property_list_pattern;</span>
    }

    /**
     * Checks whether the object name is a pattern on the value part
     * of at least one of the key properties.
     * &lt;p&gt;
     * For example, &quot;d:k=*&quot; and &quot;d:k=*,*&quot; are property value patterns
     * whereas &quot;d:k=v,*&quot; is not.
     *
     * @return  True if the name is a property value pattern, otherwise false.
     *
     * @since 1.6
     */
    public boolean isPropertyValuePattern() {
<span class="nc" id="L1500">        return _property_value_pattern;</span>
    }

    /**
     * Checks whether the value associated with a key in a key
     * property is a pattern.
     *
     * @param property The property whose value is to be checked.
     *
     * @return True if the value associated with the given key property
     * is a pattern, otherwise false.
     *
     * @exception NullPointerException If &lt;code&gt;property&lt;/code&gt; is null.
     * @exception IllegalArgumentException If &lt;code&gt;property&lt;/code&gt; is not
     * a valid key property for this ObjectName.
     *
     * @since 1.6
     */
    public boolean isPropertyValuePattern(String property) {
<span class="nc bnc" id="L1519" title="All 2 branches missed.">        if (property == null)</span>
<span class="nc" id="L1520">            throw new NullPointerException(&quot;key property can't be null&quot;);</span>
<span class="nc bnc" id="L1521" title="All 2 branches missed.">        for (int i = 0; i &lt; _ca_array.length; i++) {</span>
<span class="nc" id="L1522">            Property prop = _ca_array[i];</span>
<span class="nc" id="L1523">            String key = prop.getKeyString(_canonicalName);</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">            if (key.equals(property))</span>
<span class="nc" id="L1525">                return (prop instanceof PatternProperty);</span>
        }
<span class="nc" id="L1527">        throw new IllegalArgumentException(&quot;key property not found&quot;);</span>
    }

    /**
     * &lt;p&gt;Returns the canonical form of the name; that is, a string
     * representation where the properties are sorted in lexical
     * order.&lt;/p&gt;
     *
     * &lt;p&gt;More precisely, the canonical form of the name is a String
     * consisting of the &lt;em&gt;domain part&lt;/em&gt;, a colon
     * (&lt;code&gt;:&lt;/code&gt;), the &lt;em&gt;canonical key property list&lt;/em&gt;, and
     * a &lt;em&gt;pattern indication&lt;/em&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The &lt;em&gt;canonical key property list&lt;/em&gt; is the same string
     * as described for {@link #getCanonicalKeyPropertyListString()}.&lt;/p&gt;
     *
     * &lt;p&gt;The &lt;em&gt;pattern indication&lt;/em&gt; is:
     * &lt;ul&gt;
     * &lt;li&gt;empty for an ObjectName
     * that is not a property list pattern;
     * &lt;li&gt;an asterisk for an ObjectName
     * that is a property list pattern with no keys; or
     * &lt;li&gt;a comma and an
     * asterisk (&lt;code&gt;,*&lt;/code&gt;) for an ObjectName that is a property
     * list pattern with at least one key.
     * &lt;/ul&gt;
     *
     * @return The canonical form of the name.
     */
    public String getCanonicalName()  {
<span class="nc" id="L1557">        return _canonicalName;</span>
    }

    /**
     * Returns the domain part.
     *
     * @return The domain.
     */
    public String getDomain()  {
<span class="nc" id="L1566">        return _canonicalName.substring(0, _domain_length);</span>
    }

    /**
     * Obtains the value associated with a key in a key property.
     *
     * @param property The property whose value is to be obtained.
     *
     * @return The value of the property, or null if there is no such
     * property in this ObjectName.
     *
     * @exception NullPointerException If &lt;code&gt;property&lt;/code&gt; is null.
     */
    public String getKeyProperty(String property) {
<span class="nc" id="L1580">        return _getKeyPropertyList().get(property);</span>
    }

    /**
     * &lt;p&gt;Returns the key properties as a Map.  The returned
     * value is a Map in which each key is a key in the
     * ObjectName's key property list and each value is the associated
     * value.&lt;/p&gt;
     *
     * &lt;p&gt;The returned value must not be modified.&lt;/p&gt;
     *
     * @return The table of key properties.
     */
    private Map&lt;String,String&gt; _getKeyPropertyList()  {
<span class="nc" id="L1594">        synchronized (this) {</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">            if (_propertyList == null) {</span>
                // build (lazy eval) the property list from the canonical
                // properties array
<span class="nc" id="L1598">                _propertyList = new HashMap&lt;String,String&gt;();</span>
<span class="nc" id="L1599">                int len = _ca_array.length;</span>
                Property prop;
<span class="nc bnc" id="L1601" title="All 2 branches missed.">                for (int i = len - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L1602">                    prop = _ca_array[i];</span>
<span class="nc" id="L1603">                    _propertyList.put(prop.getKeyString(_canonicalName),</span>
<span class="nc" id="L1604">                                      prop.getValueString(_canonicalName));</span>
                }
            }
<span class="nc" id="L1607">        }</span>
<span class="nc" id="L1608">        return _propertyList;</span>
    }

    /**
     * &lt;p&gt;Returns the key properties as a Hashtable.  The returned
     * value is a Hashtable in which each key is a key in the
     * ObjectName's key property list and each value is the associated
     * value.&lt;/p&gt;
     *
     * &lt;p&gt;The returned value may be unmodifiable.  If it is
     * modifiable, changing it has no effect on this ObjectName.&lt;/p&gt;
     *
     * @return The table of key properties.
     */
    // CR 6441274 depends on the modification property defined above
    public Hashtable&lt;String,String&gt; getKeyPropertyList()  {
<span class="nc" id="L1624">        return new Hashtable&lt;String,String&gt;(_getKeyPropertyList());</span>
    }

    /**
     * &lt;p&gt;Returns a string representation of the list of key
     * properties specified at creation time.  If this ObjectName was
     * constructed with the constructor {@link #ObjectName(String)},
     * the key properties in the returned String will be in the same
     * order as in the argument to the constructor.&lt;/p&gt;
     *
     * @return The key property list string.  This string is
     * independent of whether the ObjectName is a pattern.
     */
    public String getKeyPropertyListString()  {
        // BEWARE : we rebuild the propertyliststring at each call !!
<span class="nc bnc" id="L1639" title="All 2 branches missed.">        if (_kp_array.length == 0) return &quot;&quot;;</span>

        // the size of the string is the canonical one minus domain
        // part and pattern part
<span class="nc bnc" id="L1643" title="All 2 branches missed.">        final int total_size = _canonicalName.length() - _domain_length - 1</span>
            - (_property_list_pattern?2:0);

<span class="nc" id="L1646">        final char[] dest_chars = new char[total_size];</span>
<span class="nc" id="L1647">        final char[] value = _canonicalName.toCharArray();</span>
<span class="nc" id="L1648">        writeKeyPropertyListString(value,dest_chars,0);</span>
<span class="nc" id="L1649">        return new String(dest_chars);</span>
    }

    /**
     * &lt;p&gt;Returns the serialized string of the ObjectName.
     * properties specified at creation time.  If this ObjectName was
     * constructed with the constructor {@link #ObjectName(String)},
     * the key properties in the returned String will be in the same
     * order as in the argument to the constructor.&lt;/p&gt;
     *
     * @return The key property list string.  This string is
     * independent of whether the ObjectName is a pattern.
     */
    private String getSerializedNameString()  {

        // the size of the string is the canonical one
<span class="nc" id="L1665">        final int total_size = _canonicalName.length();</span>
<span class="nc" id="L1666">        final char[] dest_chars = new char[total_size];</span>
<span class="nc" id="L1667">        final char[] value = _canonicalName.toCharArray();</span>
<span class="nc" id="L1668">        final int offset = _domain_length+1;</span>

        // copy &quot;domain:&quot; into dest_chars
        //
<span class="nc" id="L1672">        System.arraycopy(value, 0, dest_chars, 0, offset);</span>

        // Add property list string
<span class="nc" id="L1675">        final int end = writeKeyPropertyListString(value,dest_chars,offset);</span>

        // Add &quot;,*&quot; if necessary
<span class="nc bnc" id="L1678" title="All 2 branches missed.">        if (_property_list_pattern) {</span>
<span class="nc bnc" id="L1679" title="All 2 branches missed.">            if (end == offset)  {</span>
                // Property list string is empty.
<span class="nc" id="L1681">                dest_chars[end] = '*';</span>
            } else {
                // Property list string is not empty.
<span class="nc" id="L1684">                dest_chars[end]   = ',';</span>
<span class="nc" id="L1685">                dest_chars[end+1] = '*';</span>
            }
        }

<span class="nc" id="L1689">        return new String(dest_chars);</span>
    }

    /**
     * &lt;p&gt;Write a string representation of the list of key
     * properties specified at creation time in the given array, starting
     * at the specified offset.  If this ObjectName was
     * constructed with the constructor {@link #ObjectName(String)},
     * the key properties in the returned String will be in the same
     * order as in the argument to the constructor.&lt;/p&gt;
     *
     * @return offset + #of chars written
     */
    private int writeKeyPropertyListString(char[] canonicalChars,
                                           char[] data, int offset)  {
<span class="nc bnc" id="L1704" title="All 2 branches missed.">        if (_kp_array.length == 0) return offset;</span>

<span class="nc" id="L1706">        final char[] dest_chars = data;</span>
<span class="nc" id="L1707">        final char[] value = canonicalChars;</span>

<span class="nc" id="L1709">        int index = offset;</span>
<span class="nc" id="L1710">        final int len = _kp_array.length;</span>
<span class="nc" id="L1711">        final int last = len - 1;</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L1713">            final Property prop = _kp_array[i];</span>
<span class="nc" id="L1714">            final int prop_len = prop._key_length + prop._value_length + 1;</span>
<span class="nc" id="L1715">            System.arraycopy(value, prop._key_index, dest_chars, index,</span>
                             prop_len);
<span class="nc" id="L1717">            index += prop_len;</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">            if (i &lt; last ) dest_chars[index++] = ',';</span>
        }
<span class="nc" id="L1720">        return index;</span>
    }



    /**
     * Returns a string representation of the list of key properties,
     * in which the key properties are sorted in lexical order. This
     * is used in lexicographic comparisons performed in order to
     * select MBeans based on their key property list.  Lexical order
     * is the order implied by {@link String#compareTo(String)
     * String.compareTo(String)}.
     *
     * @return The canonical key property list string.  This string is
     * independent of whether the ObjectName is a pattern.
     */
    public String getCanonicalKeyPropertyListString()  {
<span class="nc bnc" id="L1737" title="All 2 branches missed.">        if (_ca_array.length == 0) return &quot;&quot;;</span>

<span class="nc" id="L1739">        int len = _canonicalName.length();</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">        if (_property_list_pattern) len -= 2;</span>
<span class="nc" id="L1741">        return _canonicalName.substring(_domain_length +1, len);</span>
    }
    // Category : Getter methods &lt;===================================

    // Category : Utilities ----------------------------------------&gt;

    /**
     * &lt;p&gt;Returns a string representation of the object name.  The
     * format of this string is not specified, but users can expect
     * that two ObjectNames return the same string if and only if they
     * are equal.&lt;/p&gt;
     *
     * @return a string representation of this object name.
     */
    @Override
    public String toString()  {
<span class="nc" id="L1757">        return getSerializedNameString();</span>
    }

    /**
     * Compares the current object name with another object name.  Two
     * ObjectName instances are equal if and only if their canonical
     * forms are equal.  The canonical form is the string described
     * for {@link #getCanonicalName()}.
     *
     * @param object  The object name that the current object name is to be
     *        compared with.
     *
     * @return True if &lt;code&gt;object&lt;/code&gt; is an ObjectName whose
     * canonical form is equal to that of this ObjectName.
     */
    @Override
    public boolean equals(Object object)  {

        // same object case
<span class="nc bnc" id="L1776" title="All 2 branches missed.">        if (this == object) return true;</span>

        // object is not an object name case
<span class="nc bnc" id="L1779" title="All 2 branches missed.">        if (!(object instanceof ObjectName)) return false;</span>

        // equality when canonical names are the same
        // (because usage of intern())
<span class="nc" id="L1783">        ObjectName on = (ObjectName) object;</span>
<span class="nc" id="L1784">        String on_string = on._canonicalName;</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">        if (_canonicalName == on_string) return true;  // ES: OK</span>

        // Because we are sharing canonical form between object names,
        // we have finished the comparison at this stage ==&gt; unequal
<span class="nc" id="L1789">        return false;</span>
   }

    /**
     * Returns a hash code for this object name.
     *
     */
    @Override
    public int hashCode() {
<span class="nc" id="L1798">        return _canonicalName.hashCode();</span>
    }

    /**
     * &lt;p&gt;Returns a quoted form of the given String, suitable for
     * inclusion in an ObjectName.  The returned value can be used as
     * the value associated with a key in an ObjectName.  The String
     * &lt;code&gt;s&lt;/code&gt; may contain any character.  Appropriate quoting
     * ensures that the returned value is legal in an ObjectName.&lt;/p&gt;
     *
     * &lt;p&gt;The returned value consists of a quote ('&quot;'), a sequence of
     * characters corresponding to the characters of &lt;code&gt;s&lt;/code&gt;,
     * and another quote.  Characters in &lt;code&gt;s&lt;/code&gt; appear
     * unchanged within the returned value except:&lt;/p&gt;
     *
     * &lt;ul&gt;
     * &lt;li&gt;A quote ('&quot;') is replaced by a backslash (\) followed by a quote.&lt;/li&gt;
     * &lt;li&gt;An asterisk ('*') is replaced by a backslash (\) followed by an
     * asterisk.&lt;/li&gt;
     * &lt;li&gt;A question mark ('?') is replaced by a backslash (\) followed by
     * a question mark.&lt;/li&gt;
     * &lt;li&gt;A backslash ('\') is replaced by two backslashes.&lt;/li&gt;
     * &lt;li&gt;A newline character (the character '\n' in Java) is replaced
     * by a backslash followed by the character '\n'.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param s the String to be quoted.
     *
     * @return the quoted String.
     *
     * @exception NullPointerException if &lt;code&gt;s&lt;/code&gt; is null.
     *
     */
    public static String quote(String s) {
<span class="nc" id="L1832">        final StringBuilder buf = new StringBuilder(&quot;\&quot;&quot;);</span>
<span class="nc" id="L1833">        final int len = s.length();</span>
<span class="nc bnc" id="L1834" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L1835">            char c = s.charAt(i);</span>
<span class="nc bnc" id="L1836" title="All 3 branches missed.">            switch (c) {</span>
            case '\n':
<span class="nc" id="L1838">                c = 'n';</span>
<span class="nc" id="L1839">                buf.append('\\');</span>
<span class="nc" id="L1840">                break;</span>
            case '\\':
            case '\&quot;':
            case '*':
            case '?':
<span class="nc" id="L1845">                buf.append('\\');</span>
                break;
            }
<span class="nc" id="L1848">            buf.append(c);</span>
        }
<span class="nc" id="L1850">        buf.append('&quot;');</span>
<span class="nc" id="L1851">        return buf.toString();</span>
    }

    /**
     * &lt;p&gt;Returns an unquoted form of the given String.  If
     * &lt;code&gt;q&lt;/code&gt; is a String returned by {@link #quote quote(s)},
     * then &lt;code&gt;unquote(q).equals(s)&lt;/code&gt;.  If there is no String
     * &lt;code&gt;s&lt;/code&gt; for which &lt;code&gt;quote(s).equals(q)&lt;/code&gt;, then
     * unquote(q) throws an IllegalArgumentException.&lt;/p&gt;
     *
     * &lt;p&gt;These rules imply that there is a one-to-one mapping between
     * quoted and unquoted forms.&lt;/p&gt;
     *
     * @param q the String to be unquoted.
     *
     * @return the unquoted String.
     *
     * @exception IllegalArgumentException if &lt;code&gt;q&lt;/code&gt; could not
     * have been returned by the {@link #quote} method, for instance
     * if it does not begin and end with a quote (&quot;).
     *
     * @exception NullPointerException if &lt;code&gt;q&lt;/code&gt; is null.
     *
     */
    public static String unquote(String q) {
<span class="nc" id="L1876">        final StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L1877">        final int len = q.length();</span>
<span class="nc bnc" id="L1878" title="All 6 branches missed.">        if (len &lt; 2 || q.charAt(0) != '&quot;' || q.charAt(len - 1) != '&quot;')</span>
<span class="nc" id="L1879">            throw new IllegalArgumentException(&quot;Argument not quoted&quot;);</span>
<span class="nc bnc" id="L1880" title="All 2 branches missed.">        for (int i = 1; i &lt; len - 1; i++) {</span>
<span class="nc" id="L1881">            char c = q.charAt(i);</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">            if (c == '\\') {</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">                if (i == len - 2)</span>
<span class="nc" id="L1884">                    throw new IllegalArgumentException(&quot;Trailing backslash&quot;);</span>
<span class="nc" id="L1885">                c = q.charAt(++i);</span>
<span class="nc bnc" id="L1886" title="All 3 branches missed.">                switch (c) {</span>
                case 'n':
<span class="nc" id="L1888">                    c = '\n';</span>
<span class="nc" id="L1889">                    break;</span>
                case '\\':
                case '\&quot;':
                case '*':
                case '?':
<span class="nc" id="L1894">                    break;</span>
                default:
<span class="nc" id="L1896">                  throw new IllegalArgumentException(</span>
                                   &quot;Bad character '&quot; + c + &quot;' after backslash&quot;);
                }
            } else {
<span class="nc bnc" id="L1900" title="All 2 branches missed.">                switch (c) {</span>
                    case '*' :
                    case '?' :
                    case '\&quot;':
                    case '\n':
<span class="nc" id="L1905">                         throw new IllegalArgumentException(</span>
                                          &quot;Invalid unescaped character '&quot; + c +
                                          &quot;' in the string to unquote&quot;);
                }
            }
<span class="nc" id="L1910">            buf.append(c);</span>
        }
<span class="nc" id="L1912">        return buf.toString();</span>
    }

    /**
     * Defines the wildcard &quot;*:*&quot; ObjectName.
     *
     * @since 1.6
     */
<span class="nc" id="L1920">    public static final ObjectName WILDCARD = Util.newObjectName(&quot;*:*&quot;);</span>

    // Category : Utilities &lt;===================================

    // Category : QueryExp Interface ----------------------------------------&gt;

    /**
     * &lt;p&gt;Test whether this ObjectName, which may be a pattern,
     * matches another ObjectName.  If &lt;code&gt;name&lt;/code&gt; is a pattern,
     * the result is false.  If this ObjectName is a pattern, the
     * result is true if and only if &lt;code&gt;name&lt;/code&gt; matches the
     * pattern.  If neither this ObjectName nor &lt;code&gt;name&lt;/code&gt; is
     * a pattern, the result is true if and only if the two
     * ObjectNames are equal as described for the {@link
     * #equals(Object)} method.&lt;/p&gt;
     *
     * @param name The name of the MBean to compare to.
     *
     * @return True if &lt;code&gt;name&lt;/code&gt; matches this ObjectName.
     *
     * @exception NullPointerException if &lt;code&gt;name&lt;/code&gt; is null.
     *
     */
    public boolean apply(ObjectName name) {

<span class="nc bnc" id="L1945" title="All 2 branches missed.">        if (name == null) throw new NullPointerException();</span>

<span class="nc bnc" id="L1947" title="All 6 branches missed.">        if (name._domain_pattern ||</span>
            name._property_list_pattern ||
            name._property_value_pattern)
<span class="nc" id="L1950">            return false;</span>

        // No pattern
<span class="nc bnc" id="L1953" title="All 6 branches missed.">        if (!_domain_pattern &amp;&amp;</span>
            !_property_list_pattern &amp;&amp;
            !_property_value_pattern)
<span class="nc" id="L1956">            return _canonicalName.equals(name._canonicalName);</span>

<span class="nc bnc" id="L1958" title="All 4 branches missed.">        return matchDomains(name) &amp;&amp; matchKeys(name);</span>
    }

    private final boolean matchDomains(ObjectName name) {
<span class="nc bnc" id="L1962" title="All 2 branches missed.">        if (_domain_pattern) {</span>
            // wildmatch domains
            // This ObjectName is the pattern
            // The other ObjectName is the string.
<span class="nc" id="L1966">            return Util.wildmatch(name.getDomain(),getDomain());</span>
        }
<span class="nc" id="L1968">        return getDomain().equals(name.getDomain());</span>
    }

    private final boolean matchKeys(ObjectName name) {
        // If key property value pattern but not key property list
        // pattern, then the number of key properties must be equal
        //
<span class="nc bnc" id="L1975" title="All 6 branches missed.">        if (_property_value_pattern &amp;&amp;</span>
            !_property_list_pattern &amp;&amp;
            (name._ca_array.length != _ca_array.length))
<span class="nc" id="L1978">                return false;</span>

        // If key property value pattern or key property list pattern,
        // then every property inside pattern should exist in name
        //
<span class="nc bnc" id="L1983" title="All 4 branches missed.">        if (_property_value_pattern || _property_list_pattern) {</span>
<span class="nc" id="L1984">            final Map&lt;String,String&gt; nameProps = name._getKeyPropertyList();</span>
<span class="nc" id="L1985">            final Property[] props = _ca_array;</span>
<span class="nc" id="L1986">            final String cn = _canonicalName;</span>
<span class="nc bnc" id="L1987" title="All 2 branches missed.">            for (int i = props.length - 1; i &gt;= 0 ; i--) {</span>
                // Find value in given object name for key at current
                // index in receiver
                //
<span class="nc" id="L1991">                final Property p = props[i];</span>
<span class="nc" id="L1992">                final String   k = p.getKeyString(cn);</span>
<span class="nc" id="L1993">                final String   v = nameProps.get(k);</span>
                // Did we find a value for this key ?
                //
<span class="nc bnc" id="L1996" title="All 2 branches missed.">                if (v == null) return false;</span>
                // If this property is ok (same key, same value), go to next
                //
<span class="nc bnc" id="L1999" title="All 4 branches missed.">                if (_property_value_pattern &amp;&amp; (p instanceof PatternProperty)) {</span>
                    // wildmatch key property values
                    // p is the property pattern, v is the string
<span class="nc bnc" id="L2002" title="All 2 branches missed.">                    if (Util.wildmatch(v,p.getValueString(cn)))</span>
<span class="nc" id="L2003">                        continue;</span>
                    else
<span class="nc" id="L2005">                        return false;</span>
                }
<span class="nc bnc" id="L2007" title="All 2 branches missed.">                if (v.equals(p.getValueString(cn))) continue;</span>
<span class="nc" id="L2008">                return false;</span>
            }
<span class="nc" id="L2010">            return true;</span>
        }

        // If no pattern, then canonical names must be equal
        //
<span class="nc" id="L2015">        final String p1 = name.getCanonicalKeyPropertyListString();</span>
<span class="nc" id="L2016">        final String p2 = getCanonicalKeyPropertyListString();</span>
<span class="nc" id="L2017">        return (p1.equals(p2));</span>
    }

    /* Method inherited from QueryExp, no implementation needed here
       because ObjectName is not relative to an MBeanServer and does
       not contain a subquery.
    */
<span class="nc" id="L2024">    public void setMBeanServer(MBeanServer mbs) { }</span>

    // Category : QueryExp Interface &lt;=========================

    // Category : Comparable Interface ----------------------------------------&gt;

    /**
     * &lt;p&gt;Compares two ObjectName instances. The ordering relation between
     * ObjectNames is not completely specified but is intended to be such
     * that a sorted list of ObjectNames will appear in an order that is
     * convenient for a person to read.&lt;/p&gt;
     *
     * &lt;p&gt;In particular, if the two ObjectName instances have different
     * domains then their order is the lexicographical order of the domains.
     * The ordering of the key property list remains unspecified.&lt;/p&gt;
     *
     * &lt;p&gt;For example, the ObjectName instances below:&lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;Shapes:type=Square,name=3&lt;/li&gt;
     * &lt;li&gt;Colors:type=Red,name=2&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Triangle,side=isosceles,name=2&lt;/li&gt;
     * &lt;li&gt;Colors:type=Red,name=1&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Square,name=1&lt;/li&gt;
     * &lt;li&gt;Colors:type=Blue,name=1&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Square,name=2&lt;/li&gt;
     * &lt;li&gt;JMImplementation:type=MBeanServerDelegate&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Triangle,side=scalene,name=1&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;could be ordered as follows:&lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;Colors:type=Blue,name=1&lt;/li&gt;
     * &lt;li&gt;Colors:type=Red,name=1&lt;/li&gt;
     * &lt;li&gt;Colors:type=Red,name=2&lt;/li&gt;
     * &lt;li&gt;JMImplementation:type=MBeanServerDelegate&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Square,name=1&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Square,name=2&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Square,name=3&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Triangle,side=scalene,name=1&lt;/li&gt;
     * &lt;li&gt;Shapes:type=Triangle,side=isosceles,name=2&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param name the ObjectName to be compared.
     *
     * @return a negative integer, zero, or a positive integer as this
     *         ObjectName is less than, equal to, or greater than the
     *         specified ObjectName.
     *
     * @since 1.6
     */
    public int compareTo(ObjectName name) {
        // Quick optimization:
        //
<span class="nc bnc" id="L2076" title="All 2 branches missed.">        if (name == this) return 0;</span>

        // (1) Compare domains
        //
<span class="nc" id="L2080">        int domainValue = this.getDomain().compareTo(name.getDomain());</span>
<span class="nc bnc" id="L2081" title="All 2 branches missed.">        if (domainValue != 0)</span>
<span class="nc" id="L2082">            return domainValue;</span>

        // (2) Compare &quot;type=&quot; keys
        //
        // Within a given domain, all names with missing or empty &quot;type=&quot;
        // come before all names with non-empty type.
        //
        // When both types are missing or empty, canonical-name ordering
        // applies which is a total order.
        //
<span class="nc" id="L2092">        String thisTypeKey = this.getKeyProperty(&quot;type&quot;);</span>
<span class="nc" id="L2093">        String anotherTypeKey = name.getKeyProperty(&quot;type&quot;);</span>
<span class="nc bnc" id="L2094" title="All 2 branches missed.">        if (thisTypeKey == null)</span>
<span class="nc" id="L2095">            thisTypeKey = &quot;&quot;;</span>
<span class="nc bnc" id="L2096" title="All 2 branches missed.">        if (anotherTypeKey == null)</span>
<span class="nc" id="L2097">            anotherTypeKey = &quot;&quot;;</span>
<span class="nc" id="L2098">        int typeKeyValue = thisTypeKey.compareTo(anotherTypeKey);</span>
<span class="nc bnc" id="L2099" title="All 2 branches missed.">        if (typeKeyValue != 0)</span>
<span class="nc" id="L2100">            return typeKeyValue;</span>

        // (3) Compare canonical names
        //
<span class="nc" id="L2104">        return this.getCanonicalName().compareTo(name.getCanonicalName());</span>
    }

    // Category : Comparable Interface &lt;=========================

    // Public methods &lt;========================================

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>