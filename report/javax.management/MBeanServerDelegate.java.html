<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MBeanServerDelegate.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.management</a> &gt; <span class="el_source">MBeanServerDelegate.java</span></div><h1>MBeanServerDelegate.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management;

import com.sun.jmx.defaults.JmxProperties;
import com.sun.jmx.defaults.ServiceName;
import com.sun.jmx.mbeanserver.Util;

/**
 * Represents  the MBean server from the management point of view.
 * The MBeanServerDelegate MBean emits the MBeanServerNotifications when
 * an MBean is registered/unregistered in the MBean server.
 *
 * @since 1.5
 */
public class MBeanServerDelegate implements MBeanServerDelegateMBean,
                                            NotificationEmitter   {

    /** The MBean server agent identification.*/
    private String mbeanServerId ;

    /** The NotificationBroadcasterSupport object that sends the
        notifications */
    private final NotificationBroadcasterSupport broadcaster;

<span class="nc" id="L49">    private static long oldStamp = 0;</span>
    private final long stamp;
<span class="nc" id="L51">    private long sequenceNumber = 1;</span>

    private static final MBeanNotificationInfo[] notifsInfo;

    static {
<span class="nc" id="L56">        final String[] types  = {</span>
            MBeanServerNotification.UNREGISTRATION_NOTIFICATION,
            MBeanServerNotification.REGISTRATION_NOTIFICATION
        };
<span class="nc" id="L60">        notifsInfo = new MBeanNotificationInfo[1];</span>
<span class="nc" id="L61">        notifsInfo[0] =</span>
            new MBeanNotificationInfo(types,
                    &quot;javax.management.MBeanServerNotification&quot;,
                    &quot;Notifications sent by the MBeanServerDelegate MBean&quot;);
    }

    /**
     * Create a MBeanServerDelegate object.
     */
<span class="nc" id="L70">    public MBeanServerDelegate () {</span>
<span class="nc" id="L71">        stamp = getStamp();</span>
<span class="nc" id="L72">        broadcaster = new NotificationBroadcasterSupport() ;</span>
<span class="nc" id="L73">    }</span>


    /**
     * Returns the MBean server agent identity.
     *
     * @return the identity.
     */
    public synchronized String getMBeanServerId() {
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (mbeanServerId == null) {</span>
            String localHost;
            try {
<span class="nc" id="L85">                localHost = java.net.InetAddress.getLocalHost().getHostName();</span>
<span class="nc" id="L86">            } catch (java.net.UnknownHostException e) {</span>
<span class="nc" id="L87">                JmxProperties.MISC_LOGGER.finest(&quot;Can't get local host name, &quot; +</span>
                        &quot;using \&quot;localhost\&quot; instead. Cause is: &quot;+e);
<span class="nc" id="L89">                localHost = &quot;localhost&quot;;</span>
<span class="nc" id="L90">            }</span>
<span class="nc" id="L91">            mbeanServerId = localHost + &quot;_&quot; + stamp;</span>
        }
<span class="nc" id="L93">        return mbeanServerId;</span>
    }

    /**
     * Returns the full name of the JMX specification implemented
     * by this product.
     *
     * @return the specification name.
     */
    public String getSpecificationName() {
<span class="nc" id="L103">        return ServiceName.JMX_SPEC_NAME;</span>
    }

    /**
     * Returns the version of the JMX specification implemented
     * by this product.
     *
     * @return the specification version.
     */
    public String getSpecificationVersion() {
<span class="nc" id="L113">        return ServiceName.JMX_SPEC_VERSION;</span>
    }

    /**
     * Returns the vendor of the JMX specification implemented
     * by this product.
     *
     * @return the specification vendor.
     */
    public String getSpecificationVendor() {
<span class="nc" id="L123">        return ServiceName.JMX_SPEC_VENDOR;</span>
    }

    /**
     * Returns the JMX implementation name (the name of this product).
     *
     * @return the implementation name.
     */
    public String getImplementationName() {
<span class="nc" id="L132">        return ServiceName.JMX_IMPL_NAME;</span>
    }

    /**
     * Returns the JMX implementation version (the version of this product).
     *
     * @return the implementation version.
     */
    public String getImplementationVersion() {
        try {
<span class="nc" id="L142">            return System.getProperty(&quot;java.runtime.version&quot;);</span>
<span class="nc" id="L143">        } catch (SecurityException e) {</span>
<span class="nc" id="L144">            return &quot;&quot;;</span>
        }
    }

    /**
     * Returns the JMX implementation vendor (the vendor of this product).
     *
     * @return the implementation vendor.
     */
    public String getImplementationVendor()  {
<span class="nc" id="L154">        return ServiceName.JMX_IMPL_VENDOR;</span>
    }

    // From NotificationEmitter extends NotificationBroacaster
    //
    public MBeanNotificationInfo[] getNotificationInfo() {
<span class="nc" id="L160">        final int len = MBeanServerDelegate.notifsInfo.length;</span>
<span class="nc" id="L161">        final MBeanNotificationInfo[] infos =</span>
        new MBeanNotificationInfo[len];
<span class="nc" id="L163">        System.arraycopy(MBeanServerDelegate.notifsInfo,0,infos,0,len);</span>
<span class="nc" id="L164">        return infos;</span>
    }

    // From NotificationEmitter extends NotificationBroacaster
    //
    public synchronized
        void addNotificationListener(NotificationListener listener,
                                     NotificationFilter filter,
                                     Object handback)
        throws IllegalArgumentException {
<span class="nc" id="L174">        broadcaster.addNotificationListener(listener,filter,handback) ;</span>
<span class="nc" id="L175">    }</span>

    // From NotificationEmitter extends NotificationBroacaster
    //
    public synchronized
        void removeNotificationListener(NotificationListener listener,
                                        NotificationFilter filter,
                                        Object handback)
        throws ListenerNotFoundException {
<span class="nc" id="L184">        broadcaster.removeNotificationListener(listener,filter,handback) ;</span>
<span class="nc" id="L185">    }</span>

    // From NotificationEmitter extends NotificationBroacaster
    //
    public synchronized
        void removeNotificationListener(NotificationListener listener)
        throws ListenerNotFoundException {
<span class="nc" id="L192">        broadcaster.removeNotificationListener(listener) ;</span>
<span class="nc" id="L193">    }</span>

    /**
     * Enables the MBean server to send a notification.
     * If the passed &lt;var&gt;notification&lt;/var&gt; has a sequence number lesser
     * or equal to 0, then replace it with the delegate's own sequence
     * number.
     * @param notification The notification to send.
     *
     */
    public void sendNotification(Notification notification) {
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (notification.getSequenceNumber() &lt; 1) {</span>
<span class="nc" id="L205">            synchronized (this) {</span>
<span class="nc" id="L206">                notification.setSequenceNumber(this.sequenceNumber++);</span>
<span class="nc" id="L207">            }</span>
        }
<span class="nc" id="L209">        broadcaster.sendNotification(notification);</span>
<span class="nc" id="L210">    }</span>

    /**
     * Defines the default ObjectName of the MBeanServerDelegate.
     *
     * @since 1.6
     */
<span class="nc" id="L217">    public static final ObjectName DELEGATE_NAME =</span>
<span class="nc" id="L218">            Util.newObjectName(&quot;JMImplementation:type=MBeanServerDelegate&quot;);</span>

    /* Return a timestamp that is monotonically increasing even if
       System.currentTimeMillis() isn't (for example, if you call this
       constructor more than once in the same millisecond, or if the
       clock always returns the same value).  This means that the ids
       for a given JVM will always be distinact, though there is no
       such guarantee for two different JVMs.  */
    private static synchronized long getStamp() {
<span class="nc" id="L227">        long s = System.currentTimeMillis();</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (oldStamp &gt;= s) {</span>
<span class="nc" id="L229">            s = oldStamp + 1;</span>
        }
<span class="nc" id="L231">        oldStamp = s;</span>
<span class="nc" id="L232">        return s;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>