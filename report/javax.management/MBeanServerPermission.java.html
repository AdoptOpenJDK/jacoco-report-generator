<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MBeanServerPermission.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.management</a> &gt; <span class="el_source">MBeanServerPermission.java</span></div><h1>MBeanServerPermission.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.security.BasicPermission;
import java.security.Permission;
import java.security.PermissionCollection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Set;
import java.util.StringTokenizer;

/** A Permission to perform actions related to MBeanServers.
    The &lt;em&gt;name&lt;/em&gt; of the permission specifies the operation requested
    or granted by the permission.  For a granted permission, it can be
    &lt;code&gt;*&lt;/code&gt; to allow all of the MBeanServer operations specified below.
    Otherwise, for a granted or requested permission, it must be one of the
    following:
    &lt;dl&gt;
    &lt;dt&gt;createMBeanServer&lt;/dt&gt;
    &lt;dd&gt;Create a new MBeanServer object using the method
    {@link MBeanServerFactory#createMBeanServer()} or
    {@link MBeanServerFactory#createMBeanServer(java.lang.String)}.
    &lt;dt&gt;findMBeanServer&lt;/dt&gt;
    &lt;dd&gt;Find an MBeanServer with a given name, or all MBeanServers in this
    JVM, using the method {@link MBeanServerFactory#findMBeanServer}.
    &lt;dt&gt;newMBeanServer&lt;/dt&gt;
    &lt;dd&gt;Create a new MBeanServer object without keeping a reference to it,
    using the method {@link MBeanServerFactory#newMBeanServer()} or
    {@link MBeanServerFactory#newMBeanServer(java.lang.String)}.
    &lt;dt&gt;releaseMBeanServer&lt;/dt&gt;
    &lt;dd&gt;Remove the MBeanServerFactory's reference to an MBeanServer,
    using the method {@link MBeanServerFactory#releaseMBeanServer}.
    &lt;/dl&gt;
    The &lt;em&gt;name&lt;/em&gt; of the permission can also denote a list of one or more
    comma-separated operations.  Spaces are allowed at the beginning and
    end of the &lt;em&gt;name&lt;/em&gt; and before and after commas.
    &lt;p&gt;
    &lt;code&gt;MBeanServerPermission(&quot;createMBeanServer&quot;)&lt;/code&gt; implies
    &lt;code&gt;MBeanServerPermission(&quot;newMBeanServer&quot;)&lt;/code&gt;.
 *
 * @since 1.5
 */
public class MBeanServerPermission extends BasicPermission {
    private static final long serialVersionUID = -5661980843569388590L;

    private final static int
        CREATE = 0,
        FIND = 1,
        NEW = 2,
        RELEASE = 3,
        N_NAMES = 4;

<span class="nc" id="L79">    private final static String[] names = {</span>
        &quot;createMBeanServer&quot;,
        &quot;findMBeanServer&quot;,
        &quot;newMBeanServer&quot;,
        &quot;releaseMBeanServer&quot;,
    };

    private final static int
        CREATE_MASK = 1&lt;&lt;CREATE,
        FIND_MASK = 1&lt;&lt;FIND,
        NEW_MASK = 1&lt;&lt;NEW,
        RELEASE_MASK = 1&lt;&lt;RELEASE,
        ALL_MASK = CREATE_MASK|FIND_MASK|NEW_MASK|RELEASE_MASK;

    /*
     * Map from permission masks to canonical names.  This array is
     * filled in on demand.
     *
     * This isn't very scalable.  If we have more than five or six
     * permissions, we should consider doing this differently,
     * e.g. with a Map.
     */
<span class="nc" id="L101">    private final static String[] canonicalNames = new String[1 &lt;&lt; N_NAMES];</span>

    /*
     * The target names mask.  This is not private to avoid having to
     * generate accessor methods for accesses from the collection class.
     *
     * This mask includes implied bits.  So if it has CREATE_MASK then
     * it necessarily has NEW_MASK too.
     */
    transient int mask;

    /** &lt;p&gt;Create a new MBeanServerPermission with the given name.&lt;/p&gt;
        &lt;p&gt;This constructor is equivalent to
        &lt;code&gt;MBeanServerPermission(name,null)&lt;/code&gt;.&lt;/p&gt;
        @param name the name of the granted permission.  It must
        respect the constraints spelt out in the description of the
        {@link MBeanServerPermission} class.
        @exception NullPointerException if the name is null.
        @exception IllegalArgumentException if the name is not
        &lt;code&gt;*&lt;/code&gt; or one of the allowed names or a comma-separated
        list of the allowed names.
    */
    public MBeanServerPermission(String name) {
<span class="nc" id="L124">        this(name, null);</span>
<span class="nc" id="L125">    }</span>

    /** &lt;p&gt;Create a new MBeanServerPermission with the given name.&lt;/p&gt;
        @param name the name of the granted permission.  It must
        respect the constraints spelt out in the description of the
        {@link MBeanServerPermission} class.
        @param actions the associated actions.  This parameter is not
        currently used and must be null or the empty string.
        @exception NullPointerException if the name is null.
        @exception IllegalArgumentException if the name is not
        &lt;code&gt;*&lt;/code&gt; or one of the allowed names or a comma-separated
        list of the allowed names, or if &lt;code&gt;actions&lt;/code&gt; is a non-null
        non-empty string.
     *
     * @throws NullPointerException if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; is empty or
     * if arguments are invalid.
     */
    public MBeanServerPermission(String name, String actions) {
<span class="nc" id="L144">        super(getCanonicalName(parseMask(name)), actions);</span>

        /* It's annoying to have to parse the name twice, but since
           Permission.getName() is final and since we can't access &quot;this&quot;
           until after the call to the superclass constructor, there
           isn't any very clean way to do this.  MBeanServerPermission
           objects aren't constructed very often, luckily.  */
<span class="nc" id="L151">        mask = parseMask(name);</span>

        /* Check that actions is a null empty string */
<span class="nc bnc" id="L154" title="All 4 branches missed.">        if (actions != null &amp;&amp; actions.length() &gt; 0)</span>
<span class="nc" id="L155">            throw new IllegalArgumentException(&quot;MBeanServerPermission &quot; +</span>
                                               &quot;actions must be null: &quot; +
                                               actions);
<span class="nc" id="L158">    }</span>

    MBeanServerPermission(int mask) {
<span class="nc" id="L161">        super(getCanonicalName(mask));</span>
<span class="nc" id="L162">        this.mask = impliedMask(mask);</span>
<span class="nc" id="L163">    }</span>

    private void readObject(ObjectInputStream in)
            throws IOException, ClassNotFoundException {
<span class="nc" id="L167">        in.defaultReadObject();</span>
<span class="nc" id="L168">        mask = parseMask(getName());</span>
<span class="nc" id="L169">    }</span>

    static int simplifyMask(int mask) {
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if ((mask &amp; CREATE_MASK) != 0)</span>
<span class="nc" id="L173">            mask &amp;= ~NEW_MASK;</span>
<span class="nc" id="L174">        return mask;</span>
    }

    static int impliedMask(int mask) {
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if ((mask &amp; CREATE_MASK) != 0)</span>
<span class="nc" id="L179">            mask |= NEW_MASK;</span>
<span class="nc" id="L180">        return mask;</span>
    }

    static String getCanonicalName(int mask) {
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (mask == ALL_MASK)</span>
<span class="nc" id="L185">            return &quot;*&quot;;</span>

<span class="nc" id="L187">        mask = simplifyMask(mask);</span>

<span class="nc" id="L189">        synchronized (canonicalNames) {</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">            if (canonicalNames[mask] == null)</span>
<span class="nc" id="L191">                canonicalNames[mask] = makeCanonicalName(mask);</span>
<span class="nc" id="L192">        }</span>

<span class="nc" id="L194">        return canonicalNames[mask];</span>
    }

    private static String makeCanonicalName(int mask) {
<span class="nc" id="L198">        final StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        for (int i = 0; i &lt; N_NAMES; i++) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if ((mask &amp; (1&lt;&lt;i)) != 0) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (buf.length() &gt; 0)</span>
<span class="nc" id="L202">                    buf.append(',');</span>
<span class="nc" id="L203">                buf.append(names[i]);</span>
            }
        }
<span class="nc" id="L206">        return buf.toString().intern();</span>
        /* intern() avoids duplication when the mask has only
           one bit, so is equivalent to the string constants
           we have for the names[] array.  */
    }

    /* Convert the string into a bitmask, including bits that
       are implied by the permissions in the string.  */
    private static int parseMask(String name) {
        /* Check that target name is a non-null non-empty string */
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L217">            throw new NullPointerException(&quot;MBeanServerPermission: &quot; +</span>
                                           &quot;target name can't be null&quot;);
        }

<span class="nc" id="L221">        name = name.trim();</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (name.equals(&quot;*&quot;))</span>
<span class="nc" id="L223">            return ALL_MASK;</span>

        /* If the name is empty, nameIndex will barf. */
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (name.indexOf(',') &lt; 0)</span>
<span class="nc" id="L227">            return impliedMask(1 &lt;&lt; nameIndex(name.trim()));</span>

<span class="nc" id="L229">        int mask = 0;</span>

<span class="nc" id="L231">        StringTokenizer tok = new StringTokenizer(name, &quot;,&quot;);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        while (tok.hasMoreTokens()) {</span>
<span class="nc" id="L233">            String action = tok.nextToken();</span>
<span class="nc" id="L234">            int i = nameIndex(action.trim());</span>
<span class="nc" id="L235">            mask |= (1 &lt;&lt; i);</span>
<span class="nc" id="L236">        }</span>

<span class="nc" id="L238">        return impliedMask(mask);</span>
    }

    private static int nameIndex(String name)
            throws IllegalArgumentException {
<span class="nc bnc" id="L243" title="All 2 branches missed.">        for (int i = 0; i &lt; N_NAMES; i++) {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if (names[i].equals(name))</span>
<span class="nc" id="L245">                return i;</span>
        }
<span class="nc" id="L247">        final String msg =</span>
            &quot;Invalid MBeanServerPermission name: \&quot;&quot; + name + &quot;\&quot;&quot;;
<span class="nc" id="L249">        throw new IllegalArgumentException(msg);</span>
    }

    public int hashCode() {
<span class="nc" id="L253">        return mask;</span>
    }

    /**
     * &lt;p&gt;Checks if this MBeanServerPermission object &quot;implies&quot; the specified
     * permission.&lt;/p&gt;
     *
     * &lt;p&gt;More specifically, this method returns true if:&lt;/p&gt;
     *
     * &lt;ul&gt;
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; is an instance of MBeanServerPermission,&lt;/li&gt;
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;'s target names are a subset of this object's target
     * names&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;The &lt;code&gt;createMBeanServer&lt;/code&gt; permission implies the
     * &lt;code&gt;newMBeanServer&lt;/code&gt; permission.&lt;/p&gt;
     *
     * @param p the permission to check against.
     * @return true if the specified permission is implied by this object,
     * false if not.
     */
    public boolean implies(Permission p) {
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (!(p instanceof MBeanServerPermission))</span>
<span class="nc" id="L277">            return false;</span>

<span class="nc" id="L279">        MBeanServerPermission that = (MBeanServerPermission) p;</span>

<span class="nc bnc" id="L281" title="All 2 branches missed.">        return ((this.mask &amp; that.mask) == that.mask);</span>
    }

    /**
     * Checks two MBeanServerPermission objects for equality. Checks that
     * &lt;i&gt;obj&lt;/i&gt; is an MBeanServerPermission, and represents the same
     * list of allowable actions as this object.
     * &lt;P&gt;
     * @param obj the object we are testing for equality with this object.
     * @return true if the objects are equal.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L294">            return true;</span>

<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (! (obj instanceof MBeanServerPermission))</span>
<span class="nc" id="L297">            return false;</span>

<span class="nc" id="L299">        MBeanServerPermission that = (MBeanServerPermission) obj;</span>

<span class="nc bnc" id="L301" title="All 2 branches missed.">        return (this.mask == that.mask);</span>
    }

    public PermissionCollection newPermissionCollection() {
<span class="nc" id="L305">        return new MBeanServerPermissionCollection();</span>
    }
}

/**
 * Class returned by {@link MBeanServerPermission#newPermissionCollection()}.
 *
 * @serial include
 */

/*
 * Since every collection of MBSP can be represented by a single MBSP,
 * that is what our PermissionCollection does.  We need to define a
 * PermissionCollection because the one inherited from BasicPermission
 * doesn't know that createMBeanServer implies newMBeanServer.
 *
 * Though the serial form is defined, the TCK does not check it.  We do
 * not require independent implementations to duplicate it.  Even though
 * PermissionCollection is Serializable, instances of this class will
 * hardly ever be serialized, and different implementations do not
 * typically exchange serialized permission collections.
 *
 * If we did require that a particular form be respected here, we would
 * logically also have to require it for
 * MBeanPermission.newPermissionCollection, which would preclude an
 * implementation from defining a PermissionCollection there with an
 * optimized &quot;implies&quot; method.
 */
<span class="nc" id="L333">class MBeanServerPermissionCollection extends PermissionCollection {</span>
    /** @serial Null if no permissions in collection, otherwise a
        single permission that is the union of all permissions that
        have been added.  */
    private MBeanServerPermission collectionPermission;

    private static final long serialVersionUID = -5661980843569388590L;

    public synchronized void add(Permission permission) {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (!(permission instanceof MBeanServerPermission)) {</span>
<span class="nc" id="L343">            final String msg =</span>
                &quot;Permission not an MBeanServerPermission: &quot; + permission;
<span class="nc" id="L345">            throw new IllegalArgumentException(msg);</span>
        }
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (isReadOnly())</span>
<span class="nc" id="L348">            throw new SecurityException(&quot;Read-only permission collection&quot;);</span>
<span class="nc" id="L349">        MBeanServerPermission mbsp = (MBeanServerPermission) permission;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (collectionPermission == null)</span>
<span class="nc" id="L351">            collectionPermission = mbsp;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        else if (!collectionPermission.implies(permission)) {</span>
<span class="nc" id="L353">            int newmask = collectionPermission.mask | mbsp.mask;</span>
<span class="nc" id="L354">            collectionPermission = new MBeanServerPermission(newmask);</span>
        }
<span class="nc" id="L356">    }</span>

    public synchronized boolean implies(Permission permission) {
<span class="nc bnc" id="L359" title="All 2 branches missed.">        return (collectionPermission != null &amp;&amp;</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">                collectionPermission.implies(permission));</span>
    }

    public synchronized Enumeration&lt;Permission&gt; elements() {
        Set&lt;Permission&gt; set;
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (collectionPermission == null)</span>
<span class="nc" id="L366">            set = Collections.emptySet();</span>
        else
<span class="nc" id="L368">            set = Collections.singleton((Permission) collectionPermission);</span>
<span class="nc" id="L369">        return Collections.enumeration(set);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>