<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JMX.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.management</a> &gt; <span class="el_source">JMX.java</span></div><h1>JMX.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management;

import com.sun.jmx.mbeanserver.Introspector;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Modifier;
import java.lang.reflect.Proxy;
import sun.reflect.misc.ReflectUtil;

/**
 * Static methods from the JMX API.  There are no instances of this class.
 *
 * @since 1.6
 */
public class JMX {
    /* Code within this package can prove that by providing this instance of
     * this class.
     */
<span class="nc" id="L43">    static final JMX proof = new JMX();</span>

<span class="nc" id="L45">    private JMX() {}</span>

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#defaultValue&quot;&gt;{@code
     * defaultValue}&lt;/a&gt; field.
     */
    public static final String DEFAULT_VALUE_FIELD = &quot;defaultValue&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#immutableInfo&quot;&gt;{@code
     * immutableInfo}&lt;/a&gt; field.
     */
    public static final String IMMUTABLE_INFO_FIELD = &quot;immutableInfo&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#interfaceClassName&quot;&gt;{@code
     * interfaceClassName}&lt;/a&gt; field.
     */
    public static final String INTERFACE_CLASS_NAME_FIELD = &quot;interfaceClassName&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#legalValues&quot;&gt;{@code
     * legalValues}&lt;/a&gt; field.
     */
    public static final String LEGAL_VALUES_FIELD = &quot;legalValues&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#maxValue&quot;&gt;{@code
     * maxValue}&lt;/a&gt; field.
     */
    public static final String MAX_VALUE_FIELD = &quot;maxValue&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#minValue&quot;&gt;{@code
     * minValue}&lt;/a&gt; field.
     */
    public static final String MIN_VALUE_FIELD = &quot;minValue&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#mxbean&quot;&gt;{@code
     * mxbean}&lt;/a&gt; field.
     */
    public static final String MXBEAN_FIELD = &quot;mxbean&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#openType&quot;&gt;{@code
     * openType}&lt;/a&gt; field.
     */
    public static final String OPEN_TYPE_FIELD = &quot;openType&quot;;

    /**
     * The name of the &lt;a href=&quot;Descriptor.html#originalType&quot;&gt;{@code
     * originalType}&lt;/a&gt; field.
     */
    public static final String ORIGINAL_TYPE_FIELD = &quot;originalType&quot;;

    /**
     * &lt;p&gt;Make a proxy for a Standard MBean in a local or remote
     * MBean Server.&lt;/p&gt;
     *
     * &lt;p&gt;If you have an MBean Server {@code mbs} containing an MBean
     * with {@link ObjectName} {@code name}, and if the MBean's
     * management interface is described by the Java interface
     * {@code MyMBean}, you can construct a proxy for the MBean like
     * this:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * MyMBean proxy = JMX.newMBeanProxy(mbs, name, MyMBean.class);
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Suppose, for example, {@code MyMBean} looks like this:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * public interface MyMBean {
     *     public String getSomeAttribute();
     *     public void setSomeAttribute(String value);
     *     public void someOperation(String param1, int param2);
     * }
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Then you can execute:&lt;/p&gt;
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;{@code proxy.getSomeAttribute()} which will result in a
     * call to {@code mbs.}{@link MBeanServerConnection#getAttribute
     * getAttribute}{@code (name, &quot;SomeAttribute&quot;)}.
     *
     * &lt;li&gt;{@code proxy.setSomeAttribute(&quot;whatever&quot;)} which will result
     * in a call to {@code mbs.}{@link MBeanServerConnection#setAttribute
     * setAttribute}{@code (name, new Attribute(&quot;SomeAttribute&quot;, &quot;whatever&quot;))}.
     *
     * &lt;li&gt;{@code proxy.someOperation(&quot;param1&quot;, 2)} which will be
     * translated into a call to {@code mbs.}{@link
     * MBeanServerConnection#invoke invoke}{@code (name, &quot;someOperation&quot;, &lt;etc&gt;)}.
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;The object returned by this method is a
     * {@link Proxy} whose {@code InvocationHandler} is an
     * {@link MBeanServerInvocationHandler}.&lt;/p&gt;
     *
     * &lt;p&gt;This method is equivalent to {@link
     * #newMBeanProxy(MBeanServerConnection, ObjectName, Class,
     * boolean) newMBeanProxy(connection, objectName, interfaceClass,
     * false)}.&lt;/p&gt;
     *
     * @param connection the MBean server to forward to.
     * @param objectName the name of the MBean within
     * {@code connection} to forward to.
     * @param interfaceClass the management interface that the MBean
     * exports, which will also be implemented by the returned proxy.
     *
     * @param &lt;T&gt; allows the compiler to know that if the {@code
     * interfaceClass} parameter is {@code MyMBean.class}, for
     * example, then the return type is {@code MyMBean}.
     *
     * @return the new proxy instance.
     *
     * @throws IllegalArgumentException if {@code interfaceClass} is not
     * a &lt;a href=&quot;package-summary.html#mgIface&quot;&gt;compliant MBean
     * interface&lt;/a&gt;
     */
    public static &lt;T&gt; T newMBeanProxy(MBeanServerConnection connection,
                                      ObjectName objectName,
                                      Class&lt;T&gt; interfaceClass) {
<span class="nc" id="L171">        return newMBeanProxy(connection, objectName, interfaceClass, false);</span>
    }

    /**
     * &lt;p&gt;Make a proxy for a Standard MBean in a local or remote MBean
     * Server that may also support the methods of {@link
     * NotificationEmitter}.&lt;/p&gt;
     *
     * &lt;p&gt;This method behaves the same as {@link
     * #newMBeanProxy(MBeanServerConnection, ObjectName, Class)}, but
     * additionally, if {@code notificationEmitter} is {@code
     * true}, then the MBean is assumed to be a {@link
     * NotificationBroadcaster} or {@link NotificationEmitter} and the
     * returned proxy will implement {@link NotificationEmitter} as
     * well as {@code interfaceClass}.  A call to {@link
     * NotificationBroadcaster#addNotificationListener} on the proxy
     * will result in a call to {@link
     * MBeanServerConnection#addNotificationListener(ObjectName,
     * NotificationListener, NotificationFilter, Object)}, and
     * likewise for the other methods of {@link
     * NotificationBroadcaster} and {@link NotificationEmitter}.&lt;/p&gt;
     *
     * @param connection the MBean server to forward to.
     * @param objectName the name of the MBean within
     * {@code connection} to forward to.
     * @param interfaceClass the management interface that the MBean
     * exports, which will also be implemented by the returned proxy.
     * @param notificationEmitter make the returned proxy
     * implement {@link NotificationEmitter} by forwarding its methods
     * via {@code connection}.
     *
     * @param &lt;T&gt; allows the compiler to know that if the {@code
     * interfaceClass} parameter is {@code MyMBean.class}, for
     * example, then the return type is {@code MyMBean}.
     *
     * @return the new proxy instance.
     *
     * @throws IllegalArgumentException if {@code interfaceClass} is not
     * a &lt;a href=&quot;package-summary.html#mgIface&quot;&gt;compliant MBean
     * interface&lt;/a&gt;
     */
    public static &lt;T&gt; T newMBeanProxy(MBeanServerConnection connection,
                                      ObjectName objectName,
                                      Class&lt;T&gt; interfaceClass,
                                      boolean notificationEmitter) {
<span class="nc" id="L216">        return createProxy(connection, objectName, interfaceClass, notificationEmitter, false);</span>
    }

    /**
     * Make a proxy for an MXBean in a local or remote MBean Server.
     *
     * &lt;p&gt;If you have an MBean Server {@code mbs} containing an
     * MXBean with {@link ObjectName} {@code name}, and if the
     * MXBean's management interface is described by the Java
     * interface {@code MyMXBean}, you can construct a proxy for
     * the MXBean like this:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * MyMXBean proxy = JMX.newMXBeanProxy(mbs, name, MyMXBean.class);
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Suppose, for example, {@code MyMXBean} looks like this:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * public interface MyMXBean {
     *     public String getSimpleAttribute();
     *     public void setSimpleAttribute(String value);
     *     public {@link java.lang.management.MemoryUsage} getMappedAttribute();
     *     public void setMappedAttribute(MemoryUsage memoryUsage);
     *     public MemoryUsage someOperation(String param1, MemoryUsage param2);
     * }
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Then:&lt;/p&gt;
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;&lt;p&gt;{@code proxy.getSimpleAttribute()} will result in a
     * call to {@code mbs.}{@link MBeanServerConnection#getAttribute
     * getAttribute}{@code (name, &quot;SimpleAttribute&quot;)}.&lt;/p&gt;
     *
     * &lt;li&gt;&lt;p&gt;{@code proxy.setSimpleAttribute(&quot;whatever&quot;)} will result
     * in a call to {@code mbs.}{@link
     * MBeanServerConnection#setAttribute setAttribute}&lt;code&gt;(name,
     * new Attribute(&quot;SimpleAttribute&quot;, &quot;whatever&quot;))&lt;/code&gt;.&lt;/p&gt;
     *
     *     &lt;p&gt;Because {@code String} is a &lt;em&gt;simple type&lt;/em&gt;, in the
     *     sense of {@link javax.management.openmbean.SimpleType}, it
     *     is not changed in the context of an MXBean.  The MXBean
     *     proxy behaves the same as a Standard MBean proxy (see
     *     {@link #newMBeanProxy(MBeanServerConnection, ObjectName,
     *     Class) newMBeanProxy}) for the attribute {@code
     *     SimpleAttribute}.&lt;/p&gt;
     *
     * &lt;li&gt;&lt;p&gt;{@code proxy.getMappedAttribute()} will result in a call
     * to {@code mbs.getAttribute(&quot;MappedAttribute&quot;)}.  The MXBean
     * mapping rules mean that the actual type of the attribute {@code
     * MappedAttribute} will be {@link
     * javax.management.openmbean.CompositeData CompositeData} and
     * that is what the {@code mbs.getAttribute} call will return.
     * The proxy will then convert the {@code CompositeData} back into
     * the expected type {@code MemoryUsage} using the MXBean mapping
     * rules.&lt;/p&gt;
     *
     * &lt;li&gt;&lt;p&gt;Similarly, {@code proxy.setMappedAttribute(memoryUsage)}
     * will convert the {@code MemoryUsage} argument into a {@code
     * CompositeData} before calling {@code mbs.setAttribute}.&lt;/p&gt;
     *
     * &lt;li&gt;&lt;p&gt;{@code proxy.someOperation(&quot;whatever&quot;, memoryUsage)}
     * will convert the {@code MemoryUsage} argument into a {@code
     * CompositeData} and call {@code mbs.invoke}.  The value returned
     * by {@code mbs.invoke} will be also be a {@code CompositeData},
     * and the proxy will convert this into the expected type {@code
     * MemoryUsage} using the MXBean mapping rules.&lt;/p&gt;
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;The object returned by this method is a
     * {@link Proxy} whose {@code InvocationHandler} is an
     * {@link MBeanServerInvocationHandler}.&lt;/p&gt;
     *
     * &lt;p&gt;This method is equivalent to {@link
     * #newMXBeanProxy(MBeanServerConnection, ObjectName, Class,
     * boolean) newMXBeanProxy(connection, objectName, interfaceClass,
     * false)}.&lt;/p&gt;
     *
     * @param connection the MBean server to forward to.
     * @param objectName the name of the MBean within
     * {@code connection} to forward to.
     * @param interfaceClass the MXBean interface,
     * which will also be implemented by the returned proxy.
     *
     * @param &lt;T&gt; allows the compiler to know that if the {@code
     * interfaceClass} parameter is {@code MyMXBean.class}, for
     * example, then the return type is {@code MyMXBean}.
     *
     * @return the new proxy instance.
     *
     * @throws IllegalArgumentException if {@code interfaceClass} is not
     * a {@link javax.management.MXBean compliant MXBean interface}
     */
    public static &lt;T&gt; T newMXBeanProxy(MBeanServerConnection connection,
                                       ObjectName objectName,
                                       Class&lt;T&gt; interfaceClass) {
<span class="nc" id="L315">        return newMXBeanProxy(connection, objectName, interfaceClass, false);</span>
    }

    /**
     * &lt;p&gt;Make a proxy for an MXBean in a local or remote MBean
     * Server that may also support the methods of {@link
     * NotificationEmitter}.&lt;/p&gt;
     *
     * &lt;p&gt;This method behaves the same as {@link
     * #newMXBeanProxy(MBeanServerConnection, ObjectName, Class)}, but
     * additionally, if {@code notificationEmitter} is {@code
     * true}, then the MXBean is assumed to be a {@link
     * NotificationBroadcaster} or {@link NotificationEmitter} and the
     * returned proxy will implement {@link NotificationEmitter} as
     * well as {@code interfaceClass}.  A call to {@link
     * NotificationBroadcaster#addNotificationListener} on the proxy
     * will result in a call to {@link
     * MBeanServerConnection#addNotificationListener(ObjectName,
     * NotificationListener, NotificationFilter, Object)}, and
     * likewise for the other methods of {@link
     * NotificationBroadcaster} and {@link NotificationEmitter}.&lt;/p&gt;
     *
     * @param connection the MBean server to forward to.
     * @param objectName the name of the MBean within
     * {@code connection} to forward to.
     * @param interfaceClass the MXBean interface,
     * which will also be implemented by the returned proxy.
     * @param notificationEmitter make the returned proxy
     * implement {@link NotificationEmitter} by forwarding its methods
     * via {@code connection}.
     *
     * @param &lt;T&gt; allows the compiler to know that if the {@code
     * interfaceClass} parameter is {@code MyMXBean.class}, for
     * example, then the return type is {@code MyMXBean}.
     *
     * @return the new proxy instance.
     *
     * @throws IllegalArgumentException if {@code interfaceClass} is not
     * a {@link javax.management.MXBean compliant MXBean interface}
     */
    public static &lt;T&gt; T newMXBeanProxy(MBeanServerConnection connection,
                                       ObjectName objectName,
                                       Class&lt;T&gt; interfaceClass,
                                       boolean notificationEmitter) {
<span class="nc" id="L359">        return createProxy(connection, objectName, interfaceClass, notificationEmitter, true);</span>
    }

    /**
     * &lt;p&gt;Test whether an interface is an MXBean interface.
     * An interface is an MXBean interface if it is public,
     * annotated {@link MXBean &amp;#64;MXBean} or {@code @MXBean(true)}
     * or if it does not have an {@code @MXBean} annotation
     * and its name ends with &quot;{@code MXBean}&quot;.&lt;/p&gt;
     *
     * @param interfaceClass The candidate interface.
     *
     * @return true if {@code interfaceClass} is a
     * {@link javax.management.MXBean compliant MXBean interface}
     *
     * @throws NullPointerException if {@code interfaceClass} is null.
     */
    public static boolean isMXBeanInterface(Class&lt;?&gt; interfaceClass) {
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (!interfaceClass.isInterface())</span>
<span class="nc" id="L378">            return false;</span>
<span class="nc bnc" id="L379" title="All 4 branches missed.">        if (!Modifier.isPublic(interfaceClass.getModifiers()) &amp;&amp;</span>
            !Introspector.ALLOW_NONPUBLIC_MBEAN) {
<span class="nc" id="L381">            return false;</span>
        }
<span class="nc" id="L383">        MXBean a = interfaceClass.getAnnotation(MXBean.class);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (a != null)</span>
<span class="nc" id="L385">            return a.value();</span>
<span class="nc" id="L386">        return interfaceClass.getName().endsWith(&quot;MXBean&quot;);</span>
        // We don't bother excluding the case where the name is
        // exactly the string &quot;MXBean&quot; since that would mean there
        // was no package name, which is pretty unlikely in practice.
    }

    /**
     * Centralised M(X)Bean proxy creation code
     * @param connection {@linkplain MBeanServerConnection} to use
     * @param objectName M(X)Bean object name
     * @param interfaceClass M(X)Bean interface class
     * @param notificationEmitter Is a notification emitter?
     * @param isMXBean Is an MXBean?
     * @return Returns an M(X)Bean proxy generated for the provided interface class
     * @throws SecurityException
     * @throws IllegalArgumentException
     */
    private static &lt;T&gt; T createProxy(MBeanServerConnection connection,
                                     ObjectName objectName,
                                     Class&lt;T&gt; interfaceClass,
                                     boolean notificationEmitter,
                                     boolean isMXBean) {

        try {
<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (isMXBean) {</span>
                // Check interface for MXBean compliance
<span class="nc" id="L412">                Introspector.testComplianceMXBeanInterface(interfaceClass);</span>
            } else {
                // Check interface for MBean compliance
<span class="nc" id="L415">                Introspector.testComplianceMBeanInterface(interfaceClass);</span>
            }
<span class="nc" id="L417">        } catch (NotCompliantMBeanException e) {</span>
<span class="nc" id="L418">            throw new IllegalArgumentException(e);</span>
<span class="nc" id="L419">        }</span>

<span class="nc" id="L421">        InvocationHandler handler = new MBeanServerInvocationHandler(</span>
                connection, objectName, isMXBean);
        final Class&lt;?&gt;[] interfaces;
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (notificationEmitter) {</span>
<span class="nc" id="L425">            interfaces =</span>
                new Class&lt;?&gt;[] {interfaceClass, NotificationEmitter.class};
        } else
<span class="nc" id="L428">            interfaces = new Class&lt;?&gt;[] {interfaceClass};</span>

<span class="nc" id="L430">        Object proxy = Proxy.newProxyInstance(</span>
<span class="nc" id="L431">                interfaceClass.getClassLoader(),</span>
                interfaces,
                handler);
<span class="nc" id="L434">        return interfaceClass.cast(proxy);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>