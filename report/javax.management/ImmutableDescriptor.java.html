<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImmutableDescriptor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.management</a> &gt; <span class="el_source">ImmutableDescriptor.java</span></div><h1>ImmutableDescriptor.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management;

import com.sun.jmx.mbeanserver.Util;
import java.io.InvalidObjectException;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

/**
 * An immutable descriptor.
 * @since 1.6
 */
public class ImmutableDescriptor implements Descriptor {
    private static final long serialVersionUID = 8853308591080540165L;

    /**
     * The names of the fields in this ImmutableDescriptor with their
     * original case.  The names must be in alphabetical order as determined
     * by {@link String#CASE_INSENSITIVE_ORDER}.
     */
    private final String[] names;
    /**
     * The values of the fields in this ImmutableDescriptor.  The
     * elements in this array match the corresponding elements in the
     * {@code names} array.
     */
    private final Object[] values;

<span class="nc" id="L57">    private transient int hashCode = -1;</span>

    /**
     * An empty descriptor.
     */
<span class="nc" id="L62">    public static final ImmutableDescriptor EMPTY_DESCRIPTOR =</span>
            new ImmutableDescriptor();

    /**
     * Construct a descriptor containing the given fields and values.
     *
     * @throws IllegalArgumentException if either array is null, or
     * if the arrays have different sizes, or
     * if a field name is null or empty, or if the same field name
     * appears more than once.
     */
    public ImmutableDescriptor(String[] fieldNames, Object[] fieldValues) {
<span class="nc" id="L74">        this(makeMap(fieldNames, fieldValues));</span>
<span class="nc" id="L75">    }</span>

    /**
     * Construct a descriptor containing the given fields.  Each String
     * must be of the form {@code fieldName=fieldValue}.  The field name
     * ends at the first {@code =} character; for example if the String
     * is {@code a=b=c} then the field name is {@code a} and its value
     * is {@code b=c}.
     *
     * @throws IllegalArgumentException if the parameter is null, or
     * if a field name is empty, or if the same field name appears
     * more than once, or if one of the strings does not contain
     * an {@code =} character.
     */
    public ImmutableDescriptor(String... fields) {
<span class="nc" id="L90">        this(makeMap(fields));</span>
<span class="nc" id="L91">    }</span>

    /**
     * &lt;p&gt;Construct a descriptor where the names and values of the fields
     * are the keys and values of the given Map.&lt;/p&gt;
     *
     * @throws IllegalArgumentException if the parameter is null, or
     * if a field name is null or empty, or if the same field name appears
     * more than once (which can happen because field names are not case
     * sensitive).
     */
<span class="nc" id="L102">    public ImmutableDescriptor(Map&lt;String, ?&gt; fields) {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (fields == null)</span>
<span class="nc" id="L104">            throw new IllegalArgumentException(&quot;Null Map&quot;);</span>
<span class="nc" id="L105">        SortedMap&lt;String, Object&gt; map =</span>
                new TreeMap&lt;String, Object&gt;(String.CASE_INSENSITIVE_ORDER);
<span class="nc bnc" id="L107" title="All 2 branches missed.">        for (Map.Entry&lt;String, ?&gt; entry : fields.entrySet()) {</span>
<span class="nc" id="L108">            String name = entry.getKey();</span>
<span class="nc bnc" id="L109" title="All 4 branches missed.">            if (name == null || name.equals(&quot;&quot;))</span>
<span class="nc" id="L110">                throw new IllegalArgumentException(&quot;Empty or null field name&quot;);</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">            if (map.containsKey(name))</span>
<span class="nc" id="L112">                throw new IllegalArgumentException(&quot;Duplicate name: &quot; + name);</span>
<span class="nc" id="L113">            map.put(name, entry.getValue());</span>
<span class="nc" id="L114">        }</span>
<span class="nc" id="L115">        int size = map.size();</span>
<span class="nc" id="L116">        this.names = map.keySet().toArray(new String[size]);</span>
<span class="nc" id="L117">        this.values = map.values().toArray(new Object[size]);</span>
<span class="nc" id="L118">    }</span>

    /**
     * This method can replace a deserialized instance of this
     * class with another instance.  For example, it might replace
     * a deserialized empty ImmutableDescriptor with
     * {@link #EMPTY_DESCRIPTOR}.
     *
     * @return the replacement object, which may be {@code this}.
     *
     * @throws InvalidObjectException if the read object has invalid fields.
     */
    private Object readResolve() throws InvalidObjectException {

<span class="nc" id="L132">        boolean bad = false;</span>
<span class="nc bnc" id="L133" title="All 6 branches missed.">        if (names == null || values == null || names.length != values.length)</span>
<span class="nc" id="L134">            bad = true;</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (!bad) {</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">            if (names.length == 0 &amp;&amp; getClass() == ImmutableDescriptor.class)</span>
<span class="nc" id="L137">                return EMPTY_DESCRIPTOR;</span>
<span class="nc" id="L138">            final Comparator&lt;String&gt; compare = String.CASE_INSENSITIVE_ORDER;</span>
<span class="nc" id="L139">            String lastName = &quot;&quot;; // also catches illegal null name</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">            for (int i = 0; i &lt; names.length; i++) {</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">                if (names[i] == null ||</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                        compare.compare(lastName, names[i]) &gt;= 0) {</span>
<span class="nc" id="L143">                    bad = true;</span>
<span class="nc" id="L144">                    break;</span>
                }
<span class="nc" id="L146">                lastName = names[i];</span>
            }
        }
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (bad)</span>
<span class="nc" id="L150">            throw new InvalidObjectException(&quot;Bad names or values&quot;);</span>

<span class="nc" id="L152">        return this;</span>
    }

    private static SortedMap&lt;String, ?&gt; makeMap(String[] fieldNames,
                                                Object[] fieldValues) {
<span class="nc bnc" id="L157" title="All 4 branches missed.">        if (fieldNames == null || fieldValues == null)</span>
<span class="nc" id="L158">            throw new IllegalArgumentException(&quot;Null array parameter&quot;);</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (fieldNames.length != fieldValues.length)</span>
<span class="nc" id="L160">            throw new IllegalArgumentException(&quot;Different size arrays&quot;);</span>
<span class="nc" id="L161">        SortedMap&lt;String, Object&gt; map =</span>
                new TreeMap&lt;String, Object&gt;(String.CASE_INSENSITIVE_ORDER);
<span class="nc bnc" id="L163" title="All 2 branches missed.">        for (int i = 0; i &lt; fieldNames.length; i++) {</span>
<span class="nc" id="L164">            String name = fieldNames[i];</span>
<span class="nc bnc" id="L165" title="All 4 branches missed.">            if (name == null || name.equals(&quot;&quot;))</span>
<span class="nc" id="L166">                throw new IllegalArgumentException(&quot;Empty or null field name&quot;);</span>
<span class="nc" id="L167">            Object old = map.put(name, fieldValues[i]);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            if (old != null) {</span>
<span class="nc" id="L169">                throw new IllegalArgumentException(&quot;Duplicate field name: &quot; +</span>
                                                   name);
            }
        }
<span class="nc" id="L173">        return map;</span>
    }

    private static SortedMap&lt;String, ?&gt; makeMap(String[] fields) {
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (fields == null)</span>
<span class="nc" id="L178">            throw new IllegalArgumentException(&quot;Null fields parameter&quot;);</span>
<span class="nc" id="L179">        String[] fieldNames = new String[fields.length];</span>
<span class="nc" id="L180">        String[] fieldValues = new String[fields.length];</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc" id="L182">            String field = fields[i];</span>
<span class="nc" id="L183">            int eq = field.indexOf('=');</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (eq &lt; 0) {</span>
<span class="nc" id="L185">                throw new IllegalArgumentException(&quot;Missing = character: &quot; +</span>
                                                   field);
            }
<span class="nc" id="L188">            fieldNames[i] = field.substring(0, eq);</span>
            // makeMap will catch the case where the name is empty
<span class="nc" id="L190">            fieldValues[i] = field.substring(eq + 1);</span>
        }
<span class="nc" id="L192">        return makeMap(fieldNames, fieldValues);</span>
    }

    /**
     * &lt;p&gt;Return an {@code ImmutableDescriptor} whose contents are the union of
     * the given descriptors.  Every field name that appears in any of
     * the descriptors will appear in the result with the
     * value that it has when the method is called.  Subsequent changes
     * to any of the descriptors do not affect the ImmutableDescriptor
     * returned here.&lt;/p&gt;
     *
     * &lt;p&gt;In the simplest case, there is only one descriptor and the
     * returned {@code ImmutableDescriptor} is a copy of its fields at the
     * time this method is called:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * Descriptor d = something();
     * ImmutableDescriptor copy = ImmutableDescriptor.union(d);
     * &lt;/pre&gt;
     *
     * @param descriptors the descriptors to be combined.  Any of the
     * descriptors can be null, in which case it is skipped.
     *
     * @return an {@code ImmutableDescriptor} that is the union of the given
     * descriptors.  The returned object may be identical to one of the
     * input descriptors if it is an ImmutableDescriptor that contains all of
     * the required fields.
     *
     * @throws IllegalArgumentException if two Descriptors contain the
     * same field name with different associated values.  Primitive array
     * values are considered the same if they are of the same type with
     * the same elements.  Object array values are considered the same if
     * {@link Arrays#deepEquals(Object[],Object[])} returns true.
     */
    public static ImmutableDescriptor union(Descriptor... descriptors) {
        // Optimize the case where exactly one Descriptor is non-Empty
        // and it is immutable - we can just return it.
<span class="nc" id="L229">        int index = findNonEmpty(descriptors, 0);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (index &lt; 0)</span>
<span class="nc" id="L231">            return EMPTY_DESCRIPTOR;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (descriptors[index] instanceof ImmutableDescriptor</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                &amp;&amp; findNonEmpty(descriptors, index + 1) &lt; 0)</span>
<span class="nc" id="L234">            return (ImmutableDescriptor) descriptors[index];</span>

<span class="nc" id="L236">        Map&lt;String, Object&gt; map =</span>
            new TreeMap&lt;String, Object&gt;(String.CASE_INSENSITIVE_ORDER);
<span class="nc" id="L238">        ImmutableDescriptor biggestImmutable = EMPTY_DESCRIPTOR;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        for (Descriptor d : descriptors) {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            if (d != null) {</span>
                String[] names;
<span class="nc bnc" id="L242" title="All 2 branches missed.">                if (d instanceof ImmutableDescriptor) {</span>
<span class="nc" id="L243">                    ImmutableDescriptor id = (ImmutableDescriptor) d;</span>
<span class="nc" id="L244">                    names = id.names;</span>
<span class="nc bnc" id="L245" title="All 4 branches missed.">                    if (id.getClass() == ImmutableDescriptor.class</span>
                            &amp;&amp; names.length &gt; biggestImmutable.names.length)
<span class="nc" id="L247">                        biggestImmutable = id;</span>
<span class="nc" id="L248">                } else</span>
<span class="nc" id="L249">                    names = d.getFieldNames();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                for (String n : names) {</span>
<span class="nc" id="L251">                    Object v = d.getFieldValue(n);</span>
<span class="nc" id="L252">                    Object old = map.put(n, v);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">                    if (old != null) {</span>
                        boolean equal;
<span class="nc bnc" id="L255" title="All 2 branches missed.">                        if (old.getClass().isArray()) {</span>
<span class="nc" id="L256">                            equal = Arrays.deepEquals(new Object[] {old},</span>
                                                      new Object[] {v});
                        } else
<span class="nc" id="L259">                            equal = old.equals(v);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                        if (!equal) {</span>
<span class="nc" id="L261">                            final String msg =</span>
                                &quot;Inconsistent values for descriptor field &quot; +
                                n + &quot;: &quot; + old + &quot; :: &quot; + v;
<span class="nc" id="L264">                            throw new IllegalArgumentException(msg);</span>
                        }
                    }
                }
            }
        }
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (biggestImmutable.names.length == map.size())</span>
<span class="nc" id="L271">            return biggestImmutable;</span>
<span class="nc" id="L272">        return new ImmutableDescriptor(map);</span>
    }

    private static boolean isEmpty(Descriptor d) {
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (d == null)</span>
<span class="nc" id="L277">            return true;</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        else if (d instanceof ImmutableDescriptor)</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">            return ((ImmutableDescriptor) d).names.length == 0;</span>
        else
<span class="nc bnc" id="L281" title="All 2 branches missed.">            return (d.getFieldNames().length == 0);</span>
    }

    private static int findNonEmpty(Descriptor[] ds, int start) {
<span class="nc bnc" id="L285" title="All 2 branches missed.">        for (int i = start; i &lt; ds.length; i++) {</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            if (!isEmpty(ds[i]))</span>
<span class="nc" id="L287">                return i;</span>
        }
<span class="nc" id="L289">        return -1;</span>
    }

    private int fieldIndex(String name) {
<span class="nc" id="L293">        return Arrays.binarySearch(names, name, String.CASE_INSENSITIVE_ORDER);</span>
    }

    public final Object getFieldValue(String fieldName) {
<span class="nc" id="L297">        checkIllegalFieldName(fieldName);</span>
<span class="nc" id="L298">        int i = fieldIndex(fieldName);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (i &lt; 0)</span>
<span class="nc" id="L300">            return null;</span>
<span class="nc" id="L301">        Object v = values[i];</span>
<span class="nc bnc" id="L302" title="All 4 branches missed.">        if (v == null || !v.getClass().isArray())</span>
<span class="nc" id="L303">            return v;</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (v instanceof Object[])</span>
<span class="nc" id="L305">            return ((Object[]) v).clone();</span>
        // clone the primitive array, could use an 8-way if/else here
<span class="nc" id="L307">        int len = Array.getLength(v);</span>
<span class="nc" id="L308">        Object a = Array.newInstance(v.getClass().getComponentType(), len);</span>
<span class="nc" id="L309">        System.arraycopy(v, 0, a, 0, len);</span>
<span class="nc" id="L310">        return a;</span>
    }

    public final String[] getFields() {
<span class="nc" id="L314">        String[] result = new String[names.length];</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">        for (int i = 0; i &lt; result.length; i++) {</span>
<span class="nc" id="L316">            Object value = values[i];</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (value == null)</span>
<span class="nc" id="L318">                value = &quot;&quot;;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            else if (!(value instanceof String))</span>
<span class="nc" id="L320">                value = &quot;(&quot; + value + &quot;)&quot;;</span>
<span class="nc" id="L321">            result[i] = names[i] + &quot;=&quot; + value;</span>
        }
<span class="nc" id="L323">        return result;</span>
    }

    public final Object[] getFieldValues(String... fieldNames) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (fieldNames == null)</span>
<span class="nc" id="L328">            return values.clone();</span>
<span class="nc" id="L329">        Object[] result = new Object[fieldNames.length];</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        for (int i = 0; i &lt; fieldNames.length; i++) {</span>
<span class="nc" id="L331">            String name = fieldNames[i];</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">            if (name != null &amp;&amp; !name.equals(&quot;&quot;))</span>
<span class="nc" id="L333">                result[i] = getFieldValue(name);</span>
        }
<span class="nc" id="L335">        return result;</span>
    }

    public final String[] getFieldNames() {
<span class="nc" id="L339">        return names.clone();</span>
    }

    /**
     * Compares this descriptor to the given object.  The objects are equal if
     * the given object is also a Descriptor, and if the two Descriptors have
     * the same field names (possibly differing in case) and the same
     * associated values.  The respective values for a field in the two
     * Descriptors are equal if the following conditions hold:
     *
     * &lt;ul&gt;
     * &lt;li&gt;If one value is null then the other must be too.&lt;/li&gt;
     * &lt;li&gt;If one value is a primitive array then the other must be a primitive
     * array of the same type with the same elements.&lt;/li&gt;
     * &lt;li&gt;If one value is an object array then the other must be too and
     * {@link Arrays#deepEquals(Object[],Object[])} must return true.&lt;/li&gt;
     * &lt;li&gt;Otherwise {@link Object#equals(Object)} must return true.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param o the object to compare with.
     *
     * @return {@code true} if the objects are the same; {@code false}
     * otherwise.
     *
     */
    // Note: this Javadoc is copied from javax.management.Descriptor
    //       due to 6369229.
    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (o == this)</span>
<span class="nc" id="L369">            return true;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (!(o instanceof Descriptor))</span>
<span class="nc" id="L371">            return false;</span>
        String[] onames;
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (o instanceof ImmutableDescriptor) {</span>
<span class="nc" id="L374">            onames = ((ImmutableDescriptor) o).names;</span>
        } else {
<span class="nc" id="L376">            onames = ((Descriptor) o).getFieldNames();</span>
<span class="nc" id="L377">            Arrays.sort(onames, String.CASE_INSENSITIVE_ORDER);</span>
        }
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (names.length != onames.length)</span>
<span class="nc" id="L380">            return false;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        for (int i = 0; i &lt; names.length; i++) {</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            if (!names[i].equalsIgnoreCase(onames[i]))</span>
<span class="nc" id="L383">                return false;</span>
        }
        Object[] ovalues;
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (o instanceof ImmutableDescriptor)</span>
<span class="nc" id="L387">            ovalues = ((ImmutableDescriptor) o).values;</span>
        else
<span class="nc" id="L389">            ovalues = ((Descriptor) o).getFieldValues(onames);</span>
<span class="nc" id="L390">        return Arrays.deepEquals(values, ovalues);</span>
    }

    /**
     * &lt;p&gt;Returns the hash code value for this descriptor.  The hash
     * code is computed as the sum of the hash codes for each field in
     * the descriptor.  The hash code of a field with name {@code n}
     * and value {@code v} is {@code n.toLowerCase().hashCode() ^ h}.
     * Here {@code h} is the hash code of {@code v}, computed as
     * follows:&lt;/p&gt;
     *
     * &lt;ul&gt;
     * &lt;li&gt;If {@code v} is null then {@code h} is 0.&lt;/li&gt;
     * &lt;li&gt;If {@code v} is a primitive array then {@code h} is computed using
     * the appropriate overloading of {@code java.util.Arrays.hashCode}.&lt;/li&gt;
     * &lt;li&gt;If {@code v} is an object array then {@code h} is computed using
     * {@link Arrays#deepHashCode(Object[])}.&lt;/li&gt;
     * &lt;li&gt;Otherwise {@code h} is {@code v.hashCode()}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return A hash code value for this object.
     *
     */
    // Note: this Javadoc is copied from javax.management.Descriptor
    //       due to 6369229.
    @Override
    public int hashCode() {
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (hashCode == -1) {</span>
<span class="nc" id="L418">            hashCode = Util.hashCode(names, values);</span>
        }
<span class="nc" id="L420">        return hashCode;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L425">        StringBuilder sb = new StringBuilder(&quot;{&quot;);</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">        for (int i = 0; i &lt; names.length; i++) {</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">            if (i &gt; 0)</span>
<span class="nc" id="L428">                sb.append(&quot;, &quot;);</span>
<span class="nc" id="L429">            sb.append(names[i]).append(&quot;=&quot;);</span>
<span class="nc" id="L430">            Object v = values[i];</span>
<span class="nc bnc" id="L431" title="All 4 branches missed.">            if (v != null &amp;&amp; v.getClass().isArray()) {</span>
<span class="nc" id="L432">                String s = Arrays.deepToString(new Object[] {v});</span>
<span class="nc" id="L433">                s = s.substring(1, s.length() - 1); // remove [...]</span>
<span class="nc" id="L434">                v = s;</span>
            }
<span class="nc" id="L436">            sb.append(String.valueOf(v));</span>
        }
<span class="nc" id="L438">        return sb.append(&quot;}&quot;).toString();</span>
    }

    /**
     * Returns true if all of the fields have legal values given their
     * names.  This method always returns true, but a subclass can
     * override it to return false when appropriate.
     *
     * @return true if the values are legal.
     *
     * @exception RuntimeOperationsException if the validity checking fails.
     * The method returns false if the descriptor is not valid, but throws
     * this exception if the attempt to determine validity fails.
     */
    public boolean isValid() {
<span class="nc" id="L453">        return true;</span>
    }

    /**
     * &lt;p&gt;Returns a descriptor which is equal to this descriptor.
     * Changes to the returned descriptor will have no effect on this
     * descriptor, and vice versa.&lt;/p&gt;
     *
     * &lt;p&gt;This method returns the object on which it is called.
     * A subclass can override it
     * to return another object provided the contract is respected.
     *
     * @exception RuntimeOperationsException for illegal value for field Names
     * or field Values.
     * If the descriptor construction fails for any reason, this exception will
     * be thrown.
     */
    @Override
    public Descriptor clone() {
<span class="nc" id="L472">        return this;</span>
    }

    /**
     * This operation is unsupported since this class is immutable.  If
     * this call would change a mutable descriptor with the same contents,
     * then a {@link RuntimeOperationsException} wrapping an
     * {@link UnsupportedOperationException} is thrown.  Otherwise,
     * the behavior is the same as it would be for a mutable descriptor:
     * either an exception is thrown because of illegal parameters, or
     * there is no effect.
     */
    public final void setFields(String[] fieldNames, Object[] fieldValues)
        throws RuntimeOperationsException {
<span class="nc bnc" id="L486" title="All 4 branches missed.">        if (fieldNames == null || fieldValues == null)</span>
<span class="nc" id="L487">            illegal(&quot;Null argument&quot;);</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (fieldNames.length != fieldValues.length)</span>
<span class="nc" id="L489">            illegal(&quot;Different array sizes&quot;);</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        for (int i = 0; i &lt; fieldNames.length; i++)</span>
<span class="nc" id="L491">            checkIllegalFieldName(fieldNames[i]);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        for (int i = 0; i &lt; fieldNames.length; i++)</span>
<span class="nc" id="L493">            setField(fieldNames[i], fieldValues[i]);</span>
<span class="nc" id="L494">    }</span>

    /**
     * This operation is unsupported since this class is immutable.  If
     * this call would change a mutable descriptor with the same contents,
     * then a {@link RuntimeOperationsException} wrapping an
     * {@link UnsupportedOperationException} is thrown.  Otherwise,
     * the behavior is the same as it would be for a mutable descriptor:
     * either an exception is thrown because of illegal parameters, or
     * there is no effect.
     */
    public final void setField(String fieldName, Object fieldValue)
        throws RuntimeOperationsException {
<span class="nc" id="L507">        checkIllegalFieldName(fieldName);</span>
<span class="nc" id="L508">        int i = fieldIndex(fieldName);</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (i &lt; 0)</span>
<span class="nc" id="L510">            unsupported();</span>
<span class="nc" id="L511">        Object value = values[i];</span>
<span class="nc bnc" id="L512" title="All 4 branches missed.">        if ((value == null) ?</span>
                (fieldValue != null) :
<span class="nc bnc" id="L514" title="All 2 branches missed.">                !value.equals(fieldValue))</span>
<span class="nc" id="L515">            unsupported();</span>
<span class="nc" id="L516">    }</span>

    /**
     * Removes a field from the descriptor.
     *
     * @param fieldName String name of the field to be removed.
     * If the field name is illegal or the field is not found,
     * no exception is thrown.
     *
     * @exception RuntimeOperationsException if a field of the given name
     * exists and the descriptor is immutable.  The wrapped exception will
     * be an {@link UnsupportedOperationException}.
     */
    public final void removeField(String fieldName) {
<span class="nc bnc" id="L530" title="All 4 branches missed.">        if (fieldName != null &amp;&amp; fieldIndex(fieldName) &gt;= 0)</span>
<span class="nc" id="L531">            unsupported();</span>
<span class="nc" id="L532">    }</span>

    static Descriptor nonNullDescriptor(Descriptor d) {
<span class="nc bnc" id="L535" title="All 2 branches missed.">        if (d == null)</span>
<span class="nc" id="L536">            return EMPTY_DESCRIPTOR;</span>
        else
<span class="nc" id="L538">            return d;</span>
    }

    private static void checkIllegalFieldName(String name) {
<span class="nc bnc" id="L542" title="All 4 branches missed.">        if (name == null || name.equals(&quot;&quot;))</span>
<span class="nc" id="L543">            illegal(&quot;Null or empty field name&quot;);</span>
<span class="nc" id="L544">    }</span>

    private static void unsupported() {
<span class="nc" id="L547">        UnsupportedOperationException uoe =</span>
            new UnsupportedOperationException(&quot;Descriptor is read-only&quot;);
<span class="nc" id="L549">        throw new RuntimeOperationsException(uoe);</span>
    }

    private static void illegal(String message) {
<span class="nc" id="L553">        IllegalArgumentException iae = new IllegalArgumentException(message);</span>
<span class="nc" id="L554">        throw new RuntimeOperationsException(iae);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>