<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>StandardMBean.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.management</a> &gt; <span class="el_source">StandardMBean.java</span></div><h1>StandardMBean.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management;

import static com.sun.jmx.defaults.JmxProperties.MISC_LOGGER;
import com.sun.jmx.mbeanserver.DescriptorCache;
import com.sun.jmx.mbeanserver.Introspector;
import com.sun.jmx.mbeanserver.MBeanSupport;
import com.sun.jmx.mbeanserver.MXBeanSupport;
import com.sun.jmx.mbeanserver.StandardMBeanSupport;
import com.sun.jmx.mbeanserver.Util;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.logging.Level;
import javax.management.openmbean.OpenMBeanAttributeInfo;
import javax.management.openmbean.OpenMBeanAttributeInfoSupport;
import javax.management.openmbean.OpenMBeanConstructorInfo;
import javax.management.openmbean.OpenMBeanConstructorInfoSupport;
import javax.management.openmbean.OpenMBeanOperationInfo;
import javax.management.openmbean.OpenMBeanOperationInfoSupport;
import javax.management.openmbean.OpenMBeanParameterInfo;
import javax.management.openmbean.OpenMBeanParameterInfoSupport;

/**
 * &lt;p&gt;An MBean whose management interface is determined by reflection
 * on a Java interface.&lt;/p&gt;
 *
 * &lt;p&gt;This class brings more flexibility to the notion of Management
 * Interface in the use of Standard MBeans.  Straightforward use of
 * the patterns for Standard MBeans described in the JMX Specification
 * means that there is a fixed relationship between the implementation
 * class of an MBean and its management interface (i.e., if the
 * implementation class is Thing, the management interface must be
 * ThingMBean).  This class makes it possible to keep the convenience
 * of specifying the management interface with a Java interface,
 * without requiring that there be any naming relationship between the
 * implementation and interface classes.&lt;/p&gt;
 *
 * &lt;p&gt;By making a DynamicMBean out of an MBean, this class makes
 * it possible to select any interface implemented by the MBean as its
 * management interface, provided that it complies with JMX patterns
 * (i.e., attributes defined by getter/setter etc...).&lt;/p&gt;
 *
 * &lt;p&gt; This class also provides hooks that make it possible to supply
 * custom descriptions and names for the {@link MBeanInfo} returned by
 * the DynamicMBean interface.&lt;/p&gt;
 *
 * &lt;p&gt;Using this class, an MBean can be created with any
 * implementation class name &lt;i&gt;Impl&lt;/i&gt; and with a management
 * interface defined (as for current Standard MBeans) by any interface
 * &lt;i&gt;Intf&lt;/i&gt;, in one of two general ways:&lt;/p&gt;
 *
 * &lt;ul&gt;
 *
 * &lt;li&gt;Using the public constructor
 *     {@link #StandardMBean(java.lang.Object, java.lang.Class, boolean)
 *     StandardMBean(impl,interface)}:
 *     &lt;pre&gt;
 *     MBeanServer mbs;
 *     ...
 *     Impl impl = new Impl(...);
 *     StandardMBean mbean = new StandardMBean(impl, Intf.class, false);
 *     mbs.registerMBean(mbean, objectName);
 *     &lt;/pre&gt;&lt;/li&gt;
 *
 * &lt;li&gt;Subclassing StandardMBean:
 *     &lt;pre&gt;
 *     public class Impl extends StandardMBean implements Intf {
 *        public Impl() {
 *          super(Intf.class, false);
 *       }
 *       // implement methods of Intf
 *     }
 *
 *     [...]
 *
 *     MBeanServer mbs;
 *     ....
 *     Impl impl = new Impl();
 *     mbs.registerMBean(impl, objectName);
 *     &lt;/pre&gt;&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt;In either case, the class &lt;i&gt;Impl&lt;/i&gt; must implement the
 * interface &lt;i&gt;Intf&lt;/i&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;Standard MBeans based on the naming relationship between
 * implementation and interface classes are of course still
 * available.&lt;/p&gt;
 *
 * &lt;p&gt;This class may also be used to construct MXBeans.  The usage
 * is exactly the same as for Standard MBeans except that in the
 * examples above, the {@code false} parameter to the constructor or
 * {@code super(...)} invocation is instead {@code true}.&lt;/p&gt;
 *
 * @since 1.5
 */
public class StandardMBean implements DynamicMBean, MBeanRegistration {

<span class="nc" id="L128">    private final static DescriptorCache descriptors =</span>
<span class="nc" id="L129">        DescriptorCache.getInstance(JMX.proof);</span>

    /**
     * The DynamicMBean that wraps the MXBean or Standard MBean implementation.
     **/
    private volatile MBeanSupport&lt;?&gt; mbean;

    /**
     * The cached MBeanInfo.
     **/
    private volatile MBeanInfo cachedMBeanInfo;

    /**
     * Make a DynamicMBean out of &lt;var&gt;implementation&lt;/var&gt;, using the
     * specified &lt;var&gt;mbeanInterface&lt;/var&gt; class.
     * @param implementation The implementation of this MBean.
     *        If &lt;code&gt;null&lt;/code&gt;, and null implementation is allowed,
     *        then the implementation is assumed to be &lt;var&gt;this&lt;/var&gt;.
     * @param mbeanInterface The Management Interface exported by this
     *        MBean's implementation. If &lt;code&gt;null&lt;/code&gt;, then this
     *        object will use standard JMX design pattern to determine
     *        the management interface associated with the given
     *        implementation.
     * @param nullImplementationAllowed &lt;code&gt;true&lt;/code&gt; if a null
     *        implementation is allowed. If null implementation is allowed,
     *        and a null implementation is passed, then the implementation
     *        is assumed to be &lt;var&gt;this&lt;/var&gt;.
     * @exception IllegalArgumentException if the given
     *    &lt;var&gt;implementation&lt;/var&gt; is null, and null is not allowed.
     **/
    private &lt;T&gt; void construct(T implementation, Class&lt;T&gt; mbeanInterface,
                               boolean nullImplementationAllowed,
                               boolean isMXBean)
                               throws NotCompliantMBeanException {
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (implementation == null) {</span>
            // Have to use (T)this rather than mbeanInterface.cast(this)
            // because mbeanInterface might be null.
<span class="nc bnc" id="L166" title="All 2 branches missed.">            if (nullImplementationAllowed)</span>
<span class="nc" id="L167">                implementation = Util.&lt;T&gt;cast(this);</span>
<span class="nc" id="L168">            else throw new IllegalArgumentException(&quot;implementation is null&quot;);</span>
        }
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (isMXBean) {</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (mbeanInterface == null) {</span>
<span class="nc" id="L172">                mbeanInterface = Util.cast(Introspector.getMXBeanInterface(</span>
<span class="nc" id="L173">                        implementation.getClass()));</span>
            }
<span class="nc" id="L175">            this.mbean = new MXBeanSupport(implementation, mbeanInterface);</span>
        } else {
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (mbeanInterface == null) {</span>
<span class="nc" id="L178">                mbeanInterface = Util.cast(Introspector.getStandardMBeanInterface(</span>
<span class="nc" id="L179">                        implementation.getClass()));</span>
            }
<span class="nc" id="L181">            this.mbean =</span>
                    new StandardMBeanSupport(implementation, mbeanInterface);
        }
<span class="nc" id="L184">    }</span>

    /**
     * &lt;p&gt;Make a DynamicMBean out of the object
     * &lt;var&gt;implementation&lt;/var&gt;, using the specified
     * &lt;var&gt;mbeanInterface&lt;/var&gt; class.&lt;/p&gt;
     *
     * @param implementation The implementation of this MBean.
     * @param mbeanInterface The Management Interface exported by this
     *        MBean's implementation. If &lt;code&gt;null&lt;/code&gt;, then this
     *        object will use standard JMX design pattern to determine
     *        the management interface associated with the given
     *        implementation.
     * @param &lt;T&gt; Allows the compiler to check
     * that {@code implementation} does indeed implement the class
     * described by {@code mbeanInterface}.  The compiler can only
     * check this if {@code mbeanInterface} is a class literal such
     * as {@code MyMBean.class}.
     *
     * @exception IllegalArgumentException if the given
     *    &lt;var&gt;implementation&lt;/var&gt; is null.
     * @exception NotCompliantMBeanException if the &lt;var&gt;mbeanInterface&lt;/var&gt;
     *    does not follow JMX design patterns for Management Interfaces, or
     *    if the given &lt;var&gt;implementation&lt;/var&gt; does not implement the
     *    specified interface.
     **/
    public &lt;T&gt; StandardMBean(T implementation, Class&lt;T&gt; mbeanInterface)
<span class="nc" id="L211">        throws NotCompliantMBeanException {</span>
<span class="nc" id="L212">        construct(implementation, mbeanInterface, false, false);</span>
<span class="nc" id="L213">    }</span>

    /**
     * &lt;p&gt;Make a DynamicMBean out of &lt;var&gt;this&lt;/var&gt;, using the specified
     * &lt;var&gt;mbeanInterface&lt;/var&gt; class.&lt;/p&gt;
     *
     * &lt;p&gt;Calls {@link #StandardMBean(java.lang.Object, java.lang.Class)
     *       this(this,mbeanInterface)}.
     * This constructor is reserved to subclasses.&lt;/p&gt;
     *
     * @param mbeanInterface The Management Interface exported by this
     *        MBean.
     *
     * @exception NotCompliantMBeanException if the &lt;var&gt;mbeanInterface&lt;/var&gt;
     *    does not follow JMX design patterns for Management Interfaces, or
     *    if &lt;var&gt;this&lt;/var&gt; does not implement the specified interface.
     **/
    protected StandardMBean(Class&lt;?&gt; mbeanInterface)
<span class="nc" id="L231">        throws NotCompliantMBeanException {</span>
<span class="nc" id="L232">        construct(null, mbeanInterface, true, false);</span>
<span class="nc" id="L233">    }</span>

    /**
     * &lt;p&gt;Make a DynamicMBean out of the object
     * &lt;var&gt;implementation&lt;/var&gt;, using the specified
     * &lt;var&gt;mbeanInterface&lt;/var&gt; class, and choosing whether the
     * resultant MBean is an MXBean.  This constructor can be used
     * to make either Standard MBeans or MXBeans.  Unlike the
     * constructor {@link #StandardMBean(Object, Class)}, it
     * does not throw NotCompliantMBeanException.&lt;/p&gt;
     *
     * @param implementation The implementation of this MBean.
     * @param mbeanInterface The Management Interface exported by this
     *        MBean's implementation. If &lt;code&gt;null&lt;/code&gt;, then this
     *        object will use standard JMX design pattern to determine
     *        the management interface associated with the given
     *        implementation.
     * @param isMXBean If true, the {@code mbeanInterface} parameter
     * names an MXBean interface and the resultant MBean is an MXBean.
     * @param &lt;T&gt; Allows the compiler to check
     * that {@code implementation} does indeed implement the class
     * described by {@code mbeanInterface}.  The compiler can only
     * check this if {@code mbeanInterface} is a class literal such
     * as {@code MyMBean.class}.
     *
     * @exception IllegalArgumentException if the given
     *    &lt;var&gt;implementation&lt;/var&gt; is null, or if the &lt;var&gt;mbeanInterface&lt;/var&gt;
     *    does not follow JMX design patterns for Management Interfaces, or
     *    if the given &lt;var&gt;implementation&lt;/var&gt; does not implement the
     *    specified interface.
     *
     * @since 1.6
     **/
    public &lt;T&gt; StandardMBean(T implementation, Class&lt;T&gt; mbeanInterface,
<span class="nc" id="L267">                             boolean isMXBean) {</span>
        try {
<span class="nc" id="L269">            construct(implementation, mbeanInterface, false, isMXBean);</span>
<span class="nc" id="L270">        } catch (NotCompliantMBeanException e) {</span>
<span class="nc" id="L271">            throw new IllegalArgumentException(e);</span>
<span class="nc" id="L272">        }</span>
<span class="nc" id="L273">    }</span>

    /**
     * &lt;p&gt;Make a DynamicMBean out of &lt;var&gt;this&lt;/var&gt;, using the specified
     * &lt;var&gt;mbeanInterface&lt;/var&gt; class, and choosing whether the resulting
     * MBean is an MXBean.  This constructor can be used
     * to make either Standard MBeans or MXBeans.  Unlike the
     * constructor {@link #StandardMBean(Object, Class)}, it
     * does not throw NotCompliantMBeanException.&lt;/p&gt;
     *
     * &lt;p&gt;Calls {@link #StandardMBean(java.lang.Object, java.lang.Class, boolean)
     *       this(this, mbeanInterface, isMXBean)}.
     * This constructor is reserved to subclasses.&lt;/p&gt;
     *
     * @param mbeanInterface The Management Interface exported by this
     *        MBean.
     * @param isMXBean If true, the {@code mbeanInterface} parameter
     * names an MXBean interface and the resultant MBean is an MXBean.
     *
     * @exception IllegalArgumentException if the &lt;var&gt;mbeanInterface&lt;/var&gt;
     *    does not follow JMX design patterns for Management Interfaces, or
     *    if &lt;var&gt;this&lt;/var&gt; does not implement the specified interface.
     *
     * @since 1.6
     **/
<span class="nc" id="L298">    protected StandardMBean(Class&lt;?&gt; mbeanInterface, boolean isMXBean) {</span>
        try {
<span class="nc" id="L300">            construct(null, mbeanInterface, true, isMXBean);</span>
<span class="nc" id="L301">        } catch (NotCompliantMBeanException e) {</span>
<span class="nc" id="L302">            throw new IllegalArgumentException(e);</span>
<span class="nc" id="L303">        }</span>
<span class="nc" id="L304">    }</span>

    /**
     * &lt;p&gt;Replace the implementation object wrapped in this object.&lt;/p&gt;
     *
     * @param implementation The new implementation of this Standard MBean
     * (or MXBean). The &lt;code&gt;implementation&lt;/code&gt; object must implement
     * the Standard MBean (or MXBean) interface that was supplied when this
     * &lt;code&gt;StandardMBean&lt;/code&gt; was constructed.
     *
     * @exception IllegalArgumentException if the given
     * &lt;var&gt;implementation&lt;/var&gt; is null.
     *
     * @exception NotCompliantMBeanException if the given
     * &lt;var&gt;implementation&lt;/var&gt; does not implement the
     * Standard MBean (or MXBean) interface that was
     * supplied at construction.
     *
     * @see #getImplementation
     **/
    public void setImplementation(Object implementation)
        throws NotCompliantMBeanException {

<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (implementation == null)</span>
<span class="nc" id="L328">            throw new IllegalArgumentException(&quot;implementation is null&quot;);</span>

<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (isMXBean()) {</span>
<span class="nc" id="L331">            this.mbean = new MXBeanSupport(implementation,</span>
<span class="nc" id="L332">                    Util.&lt;Class&lt;Object&gt;&gt;cast(getMBeanInterface()));</span>
        } else {
<span class="nc" id="L334">            this.mbean = new StandardMBeanSupport(implementation,</span>
<span class="nc" id="L335">                    Util.&lt;Class&lt;Object&gt;&gt;cast(getMBeanInterface()));</span>
        }
<span class="nc" id="L337">    }</span>

    /**
     * Get the implementation of this Standard MBean (or MXBean).
     * @return The implementation of this Standard MBean (or MXBean).
     *
     * @see #setImplementation
     **/
    public Object getImplementation() {
<span class="nc" id="L346">        return mbean.getResource();</span>
    }

    /**
     * Get the Management Interface of this Standard MBean (or MXBean).
     * @return The management interface of this Standard MBean (or MXBean).
     **/
    public final Class&lt;?&gt; getMBeanInterface() {
<span class="nc" id="L354">        return mbean.getMBeanInterface();</span>
    }

    /**
     * Get the class of the implementation of this Standard MBean (or MXBean).
     * @return The class of the implementation of this Standard MBean (or MXBean).
     **/
    public Class&lt;?&gt; getImplementationClass() {
<span class="nc" id="L362">        return mbean.getResource().getClass();</span>
    }

    // ------------------------------------------------------------------
    // From the DynamicMBean interface.
    // ------------------------------------------------------------------
    public Object getAttribute(String attribute)
        throws AttributeNotFoundException,
               MBeanException,
               ReflectionException {
<span class="nc" id="L372">        return mbean.getAttribute(attribute);</span>
    }

    // ------------------------------------------------------------------
    // From the DynamicMBean interface.
    // ------------------------------------------------------------------
    public void setAttribute(Attribute attribute)
        throws AttributeNotFoundException,
               InvalidAttributeValueException,
               MBeanException,
               ReflectionException {
<span class="nc" id="L383">        mbean.setAttribute(attribute);</span>
<span class="nc" id="L384">    }</span>

    // ------------------------------------------------------------------
    // From the DynamicMBean interface.
    // ------------------------------------------------------------------
    public AttributeList getAttributes(String[] attributes) {
<span class="nc" id="L390">        return mbean.getAttributes(attributes);</span>
    }

    // ------------------------------------------------------------------
    // From the DynamicMBean interface.
    // ------------------------------------------------------------------
    public AttributeList setAttributes(AttributeList attributes) {
<span class="nc" id="L397">        return mbean.setAttributes(attributes);</span>
    }

    // ------------------------------------------------------------------
    // From the DynamicMBean interface.
    // ------------------------------------------------------------------
    public Object invoke(String actionName, Object params[], String signature[])
            throws MBeanException, ReflectionException {
<span class="nc" id="L405">        return mbean.invoke(actionName, params, signature);</span>
    }

    /**
     * Get the {@link MBeanInfo} for this MBean.
     * &lt;p&gt;
     * This method implements
     * {@link javax.management.DynamicMBean#getMBeanInfo()
     *   DynamicMBean.getMBeanInfo()}.
     * &lt;p&gt;
     * This method first calls {@link #getCachedMBeanInfo()} in order to
     * retrieve the cached MBeanInfo for this MBean, if any. If the
     * MBeanInfo returned by {@link #getCachedMBeanInfo()} is not null,
     * then it is returned.&lt;br&gt;
     * Otherwise, this method builds a default MBeanInfo for this MBean,
     * using the Management Interface specified for this MBean.
     * &lt;p&gt;
     * While building the MBeanInfo, this method calls the customization
     * hooks that make it possible for subclasses to supply their custom
     * descriptions, parameter names, etc...&lt;br&gt;
     * Finally, it calls {@link #cacheMBeanInfo(javax.management.MBeanInfo)
     * cacheMBeanInfo()} in order to cache the new MBeanInfo.
     * @return The cached MBeanInfo for that MBean, if not null, or a
     *         newly built MBeanInfo if none was cached.
     **/
    public MBeanInfo getMBeanInfo() {
        try {
<span class="nc" id="L432">            final MBeanInfo cached = getCachedMBeanInfo();</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (cached != null) return cached;</span>
<span class="nc" id="L434">        } catch (RuntimeException x) {</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            if (MISC_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L436">                MISC_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L437">                        MBeanServerFactory.class.getName(), &quot;getMBeanInfo&quot;,</span>
                        &quot;Failed to get cached MBeanInfo&quot;, x);
            }
<span class="nc" id="L440">        }</span>

<span class="nc bnc" id="L442" title="All 2 branches missed.">        if (MISC_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L443">            MISC_LOGGER.logp(Level.FINER,</span>
<span class="nc" id="L444">                    MBeanServerFactory.class.getName(), &quot;getMBeanInfo&quot;,</span>
                    &quot;Building MBeanInfo for &quot; +
<span class="nc" id="L446">                    getImplementationClass().getName());</span>
        }

<span class="nc" id="L449">        MBeanSupport&lt;?&gt; msupport = mbean;</span>
<span class="nc" id="L450">        final MBeanInfo bi = msupport.getMBeanInfo();</span>
<span class="nc" id="L451">        final Object impl = msupport.getResource();</span>

<span class="nc" id="L453">        final boolean immutableInfo = immutableInfo(this.getClass());</span>

<span class="nc" id="L455">        final String                  cname = getClassName(bi);</span>
<span class="nc" id="L456">        final String                  text  = getDescription(bi);</span>
<span class="nc" id="L457">        final MBeanConstructorInfo[]  ctors = getConstructors(bi,impl);</span>
<span class="nc" id="L458">        final MBeanAttributeInfo[]    attrs = getAttributes(bi);</span>
<span class="nc" id="L459">        final MBeanOperationInfo[]    ops   = getOperations(bi);</span>
<span class="nc" id="L460">        final MBeanNotificationInfo[] ntfs  = getNotifications(bi);</span>
<span class="nc" id="L461">        final Descriptor              desc  = getDescriptor(bi, immutableInfo);</span>

<span class="nc" id="L463">        final MBeanInfo nmbi = new MBeanInfo(</span>
                cname, text, attrs, ctors, ops, ntfs, desc);
        try {
<span class="nc" id="L466">            cacheMBeanInfo(nmbi);</span>
<span class="nc" id="L467">        } catch (RuntimeException x) {</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (MISC_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L469">                MISC_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L470">                        MBeanServerFactory.class.getName(), &quot;getMBeanInfo&quot;,</span>
                        &quot;Failed to cache MBeanInfo&quot;, x);
            }
<span class="nc" id="L473">        }</span>

<span class="nc" id="L475">        return nmbi;</span>
    }

    /**
     * Customization hook:
     * Get the className that will be used in the MBeanInfo returned by
     * this MBean.
     * &lt;br&gt;
     * Subclasses may redefine this method in order to supply their
     * custom class name.  The default implementation returns
     * {@link MBeanInfo#getClassName() info.getClassName()}.
     * @param info The default MBeanInfo derived by reflection.
     * @return the class name for the new MBeanInfo.
     **/
    protected String getClassName(MBeanInfo info) {
<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (info == null) return getImplementationClass().getName();</span>
<span class="nc" id="L491">        return info.getClassName();</span>
    }

    /**
     * Customization hook:
     * Get the description that will be used in the MBeanInfo returned by
     * this MBean.
     * &lt;br&gt;
     * Subclasses may redefine this method in order to supply their
     * custom MBean description.  The default implementation returns
     * {@link MBeanInfo#getDescription() info.getDescription()}.
     * @param info The default MBeanInfo derived by reflection.
     * @return the description for the new MBeanInfo.
     **/
    protected String getDescription(MBeanInfo info) {
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (info == null) return null;</span>
<span class="nc" id="L507">        return info.getDescription();</span>
    }

    /**
     * &lt;p&gt;Customization hook:
     * Get the description that will be used in the MBeanFeatureInfo
     * returned by this MBean.&lt;/p&gt;
     *
     * &lt;p&gt;Subclasses may redefine this method in order to supply
     * their custom description.  The default implementation returns
     * {@link MBeanFeatureInfo#getDescription()
     * info.getDescription()}.&lt;/p&gt;
     *
     * &lt;p&gt;This method is called by
     *      {@link #getDescription(MBeanAttributeInfo)},
     *      {@link #getDescription(MBeanOperationInfo)},
     *      {@link #getDescription(MBeanConstructorInfo)}.&lt;/p&gt;
     *
     * @param info The default MBeanFeatureInfo derived by reflection.
     * @return the description for the given MBeanFeatureInfo.
     **/
    protected String getDescription(MBeanFeatureInfo info) {
<span class="nc bnc" id="L529" title="All 2 branches missed.">        if (info == null) return null;</span>
<span class="nc" id="L530">        return info.getDescription();</span>
    }

    /**
     * Customization hook:
     * Get the description that will be used in the MBeanAttributeInfo
     * returned by this MBean.
     *
     * &lt;p&gt;Subclasses may redefine this method in order to supply their
     * custom description.  The default implementation returns {@link
     * #getDescription(MBeanFeatureInfo)
     * getDescription((MBeanFeatureInfo) info)}.
     * @param info The default MBeanAttributeInfo derived by reflection.
     * @return the description for the given MBeanAttributeInfo.
     **/
    protected String getDescription(MBeanAttributeInfo info) {
<span class="nc" id="L546">        return getDescription((MBeanFeatureInfo)info);</span>
    }

    /**
     * Customization hook:
     * Get the description that will be used in the MBeanConstructorInfo
     * returned by this MBean.
     * &lt;br&gt;
     * Subclasses may redefine this method in order to supply their
     * custom description.
     * The default implementation returns {@link
     * #getDescription(MBeanFeatureInfo)
     * getDescription((MBeanFeatureInfo) info)}.
     * @param info The default MBeanConstructorInfo derived by reflection.
     * @return the description for the given MBeanConstructorInfo.
     **/
    protected String getDescription(MBeanConstructorInfo info) {
<span class="nc" id="L563">        return getDescription((MBeanFeatureInfo)info);</span>
    }

    /**
     * Customization hook:
     * Get the description that will be used for the  &lt;var&gt;sequence&lt;/var&gt;
     * MBeanParameterInfo of the MBeanConstructorInfo returned by this MBean.
     * &lt;br&gt;
     * Subclasses may redefine this method in order to supply their
     * custom description.  The default implementation returns
     * {@link MBeanParameterInfo#getDescription() param.getDescription()}.
     *
     * @param ctor  The default MBeanConstructorInfo derived by reflection.
     * @param param The default MBeanParameterInfo derived by reflection.
     * @param sequence The sequence number of the parameter considered
     *        (&quot;0&quot; for the first parameter, &quot;1&quot; for the second parameter,
     *        etc...).
     * @return the description for the given MBeanParameterInfo.
     **/
    protected String getDescription(MBeanConstructorInfo ctor,
                                    MBeanParameterInfo   param,
                                    int sequence) {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (param == null) return null;</span>
<span class="nc" id="L586">        return param.getDescription();</span>
    }

    /**
     * Customization hook:
     * Get the name that will be used for the &lt;var&gt;sequence&lt;/var&gt;
     * MBeanParameterInfo of the MBeanConstructorInfo returned by this MBean.
     * &lt;br&gt;
     * Subclasses may redefine this method in order to supply their
     * custom parameter name.  The default implementation returns
     * {@link MBeanParameterInfo#getName() param.getName()}.
     *
     * @param ctor  The default MBeanConstructorInfo derived by reflection.
     * @param param The default MBeanParameterInfo derived by reflection.
     * @param sequence The sequence number of the parameter considered
     *        (&quot;0&quot; for the first parameter, &quot;1&quot; for the second parameter,
     *        etc...).
     * @return the name for the given MBeanParameterInfo.
     **/
    protected String getParameterName(MBeanConstructorInfo ctor,
                                      MBeanParameterInfo param,
                                      int sequence) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (param == null) return null;</span>
<span class="nc" id="L609">        return param.getName();</span>
    }

    /**
     * Customization hook:
     * Get the description that will be used in the MBeanOperationInfo
     * returned by this MBean.
     * &lt;br&gt;
     * Subclasses may redefine this method in order to supply their
     * custom description.  The default implementation returns
     * {@link #getDescription(MBeanFeatureInfo)
     * getDescription((MBeanFeatureInfo) info)}.
     * @param info The default MBeanOperationInfo derived by reflection.
     * @return the description for the given MBeanOperationInfo.
     **/
    protected String getDescription(MBeanOperationInfo info) {
<span class="nc" id="L625">        return getDescription((MBeanFeatureInfo)info);</span>
    }

    /**
     * Customization hook:
     * Get the &lt;var&gt;impact&lt;/var&gt; flag of the operation that will be used in
     * the MBeanOperationInfo returned by this MBean.
     * &lt;br&gt;
     * Subclasses may redefine this method in order to supply their
     * custom impact flag.  The default implementation returns
     * {@link MBeanOperationInfo#getImpact() info.getImpact()}.
     * @param info The default MBeanOperationInfo derived by reflection.
     * @return the impact flag for the given MBeanOperationInfo.
     **/
    protected int getImpact(MBeanOperationInfo info) {
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (info == null) return MBeanOperationInfo.UNKNOWN;</span>
<span class="nc" id="L641">        return info.getImpact();</span>
    }

    /**
     * Customization hook:
     * Get the name that will be used for the &lt;var&gt;sequence&lt;/var&gt;
     * MBeanParameterInfo of the MBeanOperationInfo returned by this MBean.
     * &lt;br&gt;
     * Subclasses may redefine this method in order to supply their
     * custom parameter name.  The default implementation returns
     * {@link MBeanParameterInfo#getName() param.getName()}.
     *
     * @param op    The default MBeanOperationInfo derived by reflection.
     * @param param The default MBeanParameterInfo derived by reflection.
     * @param sequence The sequence number of the parameter considered
     *        (&quot;0&quot; for the first parameter, &quot;1&quot; for the second parameter,
     *        etc...).
     * @return the name to use for the given MBeanParameterInfo.
     **/
    protected String getParameterName(MBeanOperationInfo op,
                                      MBeanParameterInfo param,
                                      int sequence) {
<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (param == null) return null;</span>
<span class="nc" id="L664">        return param.getName();</span>
    }

    /**
     * Customization hook:
     * Get the description that will be used for the  &lt;var&gt;sequence&lt;/var&gt;
     * MBeanParameterInfo of the MBeanOperationInfo returned by this MBean.
     * &lt;br&gt;
     * Subclasses may redefine this method in order to supply their
     * custom description.  The default implementation returns
     * {@link MBeanParameterInfo#getDescription() param.getDescription()}.
     *
     * @param op    The default MBeanOperationInfo derived by reflection.
     * @param param The default MBeanParameterInfo derived by reflection.
     * @param sequence The sequence number of the parameter considered
     *        (&quot;0&quot; for the first parameter, &quot;1&quot; for the second parameter,
     *        etc...).
     * @return the description for the given MBeanParameterInfo.
     **/
    protected String getDescription(MBeanOperationInfo op,
                                    MBeanParameterInfo param,
                                    int sequence) {
<span class="nc bnc" id="L686" title="All 2 branches missed.">        if (param == null) return null;</span>
<span class="nc" id="L687">        return param.getDescription();</span>
    }

    /**
     * Customization hook:
     * Get the MBeanConstructorInfo[] that will be used in the MBeanInfo
     * returned by this MBean.
     * &lt;br&gt;
     * By default, this method returns &lt;code&gt;null&lt;/code&gt; if the wrapped
     * implementation is not &lt;var&gt;this&lt;/var&gt;. Indeed, if the wrapped
     * implementation is not this object itself, it will not be possible
     * to recreate a wrapped implementation by calling the implementation
     * constructors through &lt;code&gt;MBeanServer.createMBean(...)&lt;/code&gt;.&lt;br&gt;
     * Otherwise, if the wrapped implementation is &lt;var&gt;this&lt;/var&gt;,
     * &lt;var&gt;ctors&lt;/var&gt; is returned.
     * &lt;br&gt;
     * Subclasses may redefine this method in order to modify this
     * behavior, if needed.
     * @param ctors The default MBeanConstructorInfo[] derived by reflection.
     * @param impl  The wrapped implementation. If &lt;code&gt;null&lt;/code&gt; is
     *        passed, the wrapped implementation is ignored and
     *        &lt;var&gt;ctors&lt;/var&gt; is returned.
     * @return the MBeanConstructorInfo[] for the new MBeanInfo.
     **/
    protected MBeanConstructorInfo[]
        getConstructors(MBeanConstructorInfo[] ctors, Object impl) {
<span class="nc bnc" id="L713" title="All 2 branches missed.">            if (ctors == null) return null;</span>
<span class="nc bnc" id="L714" title="All 4 branches missed.">            if (impl != null &amp;&amp; impl != this) return null;</span>
<span class="nc" id="L715">            return ctors;</span>
    }

    /**
     * Customization hook:
     * Get the MBeanNotificationInfo[] that will be used in the MBeanInfo
     * returned by this MBean.
     * &lt;br&gt;
     * Subclasses may redefine this method in order to supply their
     * custom notifications.
     * @param info The default MBeanInfo derived by reflection.
     * @return the MBeanNotificationInfo[] for the new MBeanInfo.
     **/
    MBeanNotificationInfo[] getNotifications(MBeanInfo info) {
<span class="nc" id="L729">        return null;</span>
    }

    /**
     * &lt;p&gt;Get the Descriptor that will be used in the MBeanInfo
     * returned by this MBean.&lt;/p&gt;
     *
     * &lt;p&gt;Subclasses may redefine this method in order to supply
     * their custom descriptor.&lt;/p&gt;
     *
     * &lt;p&gt;The default implementation of this method returns a Descriptor
     * that contains at least the field {@code interfaceClassName}, with
     * value {@link #getMBeanInterface()}.getName(). It may also contain
     * the field {@code immutableInfo}, with a value that is the string
     * {@code &quot;true&quot;} if the implementation can determine that the
     * {@code MBeanInfo} returned by {@link #getMBeanInfo()} will always
     * be the same. It may contain other fields: fields defined by the
     * JMX specification must have appropriate values, and other fields
     * must follow the conventions for non-standard field names.&lt;/p&gt;
     *
     * @param info The default MBeanInfo derived by reflection.
     * @return the Descriptor for the new MBeanInfo.
     */
    Descriptor getDescriptor(MBeanInfo info, boolean immutableInfo) {
        ImmutableDescriptor desc;
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (info == null ||</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">            info.getDescriptor() == null ||</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">            info.getDescriptor().getFieldNames().length == 0) {</span>
<span class="nc" id="L757">            final String interfaceClassNameS =</span>
<span class="nc" id="L758">                &quot;interfaceClassName=&quot; + getMBeanInterface().getName();</span>
<span class="nc" id="L759">            final String immutableInfoS =</span>
                &quot;immutableInfo=&quot; + immutableInfo;
<span class="nc" id="L761">            desc = new ImmutableDescriptor(interfaceClassNameS, immutableInfoS);</span>
<span class="nc" id="L762">            desc = descriptors.get(desc);</span>
<span class="nc" id="L763">        } else {</span>
<span class="nc" id="L764">            Descriptor d = info.getDescriptor();</span>
<span class="nc" id="L765">            Map&lt;String,Object&gt; fields = new HashMap&lt;String,Object&gt;();</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">            for (String fieldName : d.getFieldNames()) {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">                if (fieldName.equals(&quot;immutableInfo&quot;)) {</span>
                    // Replace immutableInfo as the underlying MBean/MXBean
                    // could already implement NotificationBroadcaster and
                    // return immutableInfo=true in its MBeanInfo.
<span class="nc" id="L771">                    fields.put(fieldName, Boolean.toString(immutableInfo));</span>
                } else {
<span class="nc" id="L773">                    fields.put(fieldName, d.getFieldValue(fieldName));</span>
                }
            }
<span class="nc" id="L776">            desc = new ImmutableDescriptor(fields);</span>
        }
<span class="nc" id="L778">        return desc;</span>
    }

    /**
     * Customization hook:
     * Return the MBeanInfo cached for this object.
     *
     * &lt;p&gt;Subclasses may redefine this method in order to implement their
     * own caching policy.  The default implementation stores one
     * {@link MBeanInfo} object per instance.
     *
     * @return The cached MBeanInfo, or null if no MBeanInfo is cached.
     *
     * @see #cacheMBeanInfo(MBeanInfo)
     **/
    protected MBeanInfo getCachedMBeanInfo() {
<span class="nc" id="L794">        return cachedMBeanInfo;</span>
    }

    /**
     * Customization hook:
     * cache the MBeanInfo built for this object.
     *
     * &lt;p&gt;Subclasses may redefine this method in order to implement
     * their own caching policy.  The default implementation stores
     * &lt;code&gt;info&lt;/code&gt; in this instance.  A subclass can define
     * other policies, such as not saving &lt;code&gt;info&lt;/code&gt; (so it is
     * reconstructed every time {@link #getMBeanInfo()} is called) or
     * sharing a unique {@link MBeanInfo} object when several
     * &lt;code&gt;StandardMBean&lt;/code&gt; instances have equal {@link
     * MBeanInfo} values.
     *
     * @param info the new &lt;code&gt;MBeanInfo&lt;/code&gt; to cache.  Any
     * previously cached value is discarded.  This parameter may be
     * null, in which case there is no new cached value.
     **/
    protected void cacheMBeanInfo(MBeanInfo info) {
<span class="nc" id="L815">        cachedMBeanInfo = info;</span>
<span class="nc" id="L816">    }</span>

    private boolean isMXBean() {
<span class="nc" id="L819">        return mbean.isMXBean();</span>
    }

    private static &lt;T&gt; boolean identicalArrays(T[] a, T[] b) {
<span class="nc bnc" id="L823" title="All 2 branches missed.">        if (a == b)</span>
<span class="nc" id="L824">            return true;</span>
<span class="nc bnc" id="L825" title="All 6 branches missed.">        if (a == null || b == null || a.length != b.length)</span>
<span class="nc" id="L826">            return false;</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">        for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">            if (a[i] != b[i])</span>
<span class="nc" id="L829">                return false;</span>
        }
<span class="nc" id="L831">        return true;</span>
    }

    private static &lt;T&gt; boolean equal(T a, T b) {
<span class="nc bnc" id="L835" title="All 2 branches missed.">        if (a == b)</span>
<span class="nc" id="L836">            return true;</span>
<span class="nc bnc" id="L837" title="All 4 branches missed.">        if (a == null || b == null)</span>
<span class="nc" id="L838">            return false;</span>
<span class="nc" id="L839">        return a.equals(b);</span>
    }

    private static MBeanParameterInfo
            customize(MBeanParameterInfo pi,
                      String name,
                      String description) {
<span class="nc bnc" id="L846" title="All 2 branches missed.">        if (equal(name, pi.getName()) &amp;&amp;</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">                equal(description, pi.getDescription()))</span>
<span class="nc" id="L848">            return pi;</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">        else if (pi instanceof OpenMBeanParameterInfo) {</span>
<span class="nc" id="L850">            OpenMBeanParameterInfo opi = (OpenMBeanParameterInfo) pi;</span>
<span class="nc" id="L851">            return new OpenMBeanParameterInfoSupport(name,</span>
                                                     description,
<span class="nc" id="L853">                                                     opi.getOpenType(),</span>
<span class="nc" id="L854">                                                     pi.getDescriptor());</span>
        } else {
<span class="nc" id="L856">            return new MBeanParameterInfo(name,</span>
<span class="nc" id="L857">                                          pi.getType(),</span>
                                          description,
<span class="nc" id="L859">                                          pi.getDescriptor());</span>
        }
    }

    private static MBeanConstructorInfo
            customize(MBeanConstructorInfo ci,
                      String description,
                      MBeanParameterInfo[] signature) {
<span class="nc bnc" id="L867" title="All 2 branches missed.">        if (equal(description, ci.getDescription()) &amp;&amp;</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">                identicalArrays(signature, ci.getSignature()))</span>
<span class="nc" id="L869">            return ci;</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (ci instanceof OpenMBeanConstructorInfo) {</span>
<span class="nc" id="L871">            OpenMBeanParameterInfo[] oparams =</span>
<span class="nc" id="L872">                paramsToOpenParams(signature);</span>
<span class="nc" id="L873">            return new OpenMBeanConstructorInfoSupport(ci.getName(),</span>
                                                       description,
                                                       oparams,
<span class="nc" id="L876">                                                       ci.getDescriptor());</span>
        } else {
<span class="nc" id="L878">            return new MBeanConstructorInfo(ci.getName(),</span>
                                            description,
                                            signature,
<span class="nc" id="L881">                                            ci.getDescriptor());</span>
        }
    }

    private static MBeanOperationInfo
            customize(MBeanOperationInfo oi,
                      String description,
                      MBeanParameterInfo[] signature,
                      int impact) {
<span class="nc bnc" id="L890" title="All 2 branches missed.">        if (equal(description, oi.getDescription()) &amp;&amp;</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">                identicalArrays(signature, oi.getSignature()) &amp;&amp;</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">                impact == oi.getImpact())</span>
<span class="nc" id="L893">            return oi;</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (oi instanceof OpenMBeanOperationInfo) {</span>
<span class="nc" id="L895">            OpenMBeanOperationInfo ooi = (OpenMBeanOperationInfo) oi;</span>
<span class="nc" id="L896">            OpenMBeanParameterInfo[] oparams =</span>
<span class="nc" id="L897">                paramsToOpenParams(signature);</span>
<span class="nc" id="L898">            return new OpenMBeanOperationInfoSupport(oi.getName(),</span>
                                                     description,
                                                     oparams,
<span class="nc" id="L901">                                                     ooi.getReturnOpenType(),</span>
                                                     impact,
<span class="nc" id="L903">                                                     oi.getDescriptor());</span>
        } else {
<span class="nc" id="L905">            return new MBeanOperationInfo(oi.getName(),</span>
                                          description,
                                          signature,
<span class="nc" id="L908">                                          oi.getReturnType(),</span>
                                          impact,
<span class="nc" id="L910">                                          oi.getDescriptor());</span>
        }
    }

    private static MBeanAttributeInfo
            customize(MBeanAttributeInfo ai,
                      String description) {
<span class="nc bnc" id="L917" title="All 2 branches missed.">        if (equal(description, ai.getDescription()))</span>
<span class="nc" id="L918">            return ai;</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">        if (ai instanceof OpenMBeanAttributeInfo) {</span>
<span class="nc" id="L920">            OpenMBeanAttributeInfo oai = (OpenMBeanAttributeInfo) ai;</span>
<span class="nc" id="L921">            return new OpenMBeanAttributeInfoSupport(ai.getName(),</span>
                                                     description,
<span class="nc" id="L923">                                                     oai.getOpenType(),</span>
<span class="nc" id="L924">                                                     ai.isReadable(),</span>
<span class="nc" id="L925">                                                     ai.isWritable(),</span>
<span class="nc" id="L926">                                                     ai.isIs(),</span>
<span class="nc" id="L927">                                                     ai.getDescriptor());</span>
        } else {
<span class="nc" id="L929">            return new MBeanAttributeInfo(ai.getName(),</span>
<span class="nc" id="L930">                                          ai.getType(),</span>
                                          description,
<span class="nc" id="L932">                                          ai.isReadable(),</span>
<span class="nc" id="L933">                                          ai.isWritable(),</span>
<span class="nc" id="L934">                                          ai.isIs(),</span>
<span class="nc" id="L935">                                          ai.getDescriptor());</span>
        }
    }

    private static OpenMBeanParameterInfo[]
            paramsToOpenParams(MBeanParameterInfo[] params) {
<span class="nc bnc" id="L941" title="All 2 branches missed.">        if (params instanceof OpenMBeanParameterInfo[])</span>
<span class="nc" id="L942">            return (OpenMBeanParameterInfo[]) params;</span>
<span class="nc" id="L943">        OpenMBeanParameterInfo[] oparams =</span>
            new OpenMBeanParameterInfoSupport[params.length];
<span class="nc" id="L945">        System.arraycopy(params, 0, oparams, 0, params.length);</span>
<span class="nc" id="L946">        return oparams;</span>
    }

    // ------------------------------------------------------------------
    // Build the custom MBeanConstructorInfo[]
    // ------------------------------------------------------------------
    private MBeanConstructorInfo[]
            getConstructors(MBeanInfo info, Object impl) {
<span class="nc" id="L954">        final MBeanConstructorInfo[] ctors =</span>
<span class="nc" id="L955">            getConstructors(info.getConstructors(), impl);</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">        if (ctors == null)</span>
<span class="nc" id="L957">            return null;</span>
<span class="nc" id="L958">        final int ctorlen = ctors.length;</span>
<span class="nc" id="L959">        final MBeanConstructorInfo[] nctors = new MBeanConstructorInfo[ctorlen];</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">        for (int i=0; i&lt;ctorlen; i++) {</span>
<span class="nc" id="L961">            final MBeanConstructorInfo c = ctors[i];</span>
<span class="nc" id="L962">            final MBeanParameterInfo[] params = c.getSignature();</span>
            final MBeanParameterInfo[] nps;
<span class="nc bnc" id="L964" title="All 2 branches missed.">            if (params != null) {</span>
<span class="nc" id="L965">                final int plen = params.length;</span>
<span class="nc" id="L966">                nps = new MBeanParameterInfo[plen];</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">                for (int ii=0;ii&lt;plen;ii++) {</span>
<span class="nc" id="L968">                    MBeanParameterInfo p = params[ii];</span>
<span class="nc" id="L969">                    nps[ii] = customize(p,</span>
<span class="nc" id="L970">                                        getParameterName(c,p,ii),</span>
<span class="nc" id="L971">                                        getDescription(c,p,ii));</span>
                }
<span class="nc" id="L973">            } else {</span>
<span class="nc" id="L974">                nps = null;</span>
            }
<span class="nc" id="L976">            nctors[i] =</span>
<span class="nc" id="L977">                customize(c, getDescription(c), nps);</span>
        }
<span class="nc" id="L979">        return nctors;</span>
    }

    // ------------------------------------------------------------------
    // Build the custom MBeanOperationInfo[]
    // ------------------------------------------------------------------
    private MBeanOperationInfo[] getOperations(MBeanInfo info) {
<span class="nc" id="L986">        final MBeanOperationInfo[] ops = info.getOperations();</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">        if (ops == null)</span>
<span class="nc" id="L988">            return null;</span>
<span class="nc" id="L989">        final int oplen = ops.length;</span>
<span class="nc" id="L990">        final MBeanOperationInfo[] nops = new MBeanOperationInfo[oplen];</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">        for (int i=0; i&lt;oplen; i++) {</span>
<span class="nc" id="L992">            final MBeanOperationInfo o = ops[i];</span>
<span class="nc" id="L993">            final MBeanParameterInfo[] params = o.getSignature();</span>
            final MBeanParameterInfo[] nps;
<span class="nc bnc" id="L995" title="All 2 branches missed.">            if (params != null) {</span>
<span class="nc" id="L996">                final int plen = params.length;</span>
<span class="nc" id="L997">                nps = new MBeanParameterInfo[plen];</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">                for (int ii=0;ii&lt;plen;ii++) {</span>
<span class="nc" id="L999">                    MBeanParameterInfo p = params[ii];</span>
<span class="nc" id="L1000">                    nps[ii] = customize(p,</span>
<span class="nc" id="L1001">                                        getParameterName(o,p,ii),</span>
<span class="nc" id="L1002">                                        getDescription(o,p,ii));</span>
                }
<span class="nc" id="L1004">            } else {</span>
<span class="nc" id="L1005">                nps = null;</span>
            }
<span class="nc" id="L1007">            nops[i] = customize(o, getDescription(o), nps, getImpact(o));</span>
        }
<span class="nc" id="L1009">        return nops;</span>
    }

    // ------------------------------------------------------------------
    // Build the custom MBeanAttributeInfo[]
    // ------------------------------------------------------------------
    private MBeanAttributeInfo[] getAttributes(MBeanInfo info) {
<span class="nc" id="L1016">        final MBeanAttributeInfo[] atts = info.getAttributes();</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">        if (atts == null)</span>
<span class="nc" id="L1018">            return null; // should not happen</span>
        final MBeanAttributeInfo[] natts;
<span class="nc" id="L1020">        final int attlen = atts.length;</span>
<span class="nc" id="L1021">        natts = new MBeanAttributeInfo[attlen];</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">        for (int i=0; i&lt;attlen; i++) {</span>
<span class="nc" id="L1023">            final MBeanAttributeInfo a = atts[i];</span>
<span class="nc" id="L1024">            natts[i] = customize(a, getDescription(a));</span>
        }
<span class="nc" id="L1026">        return natts;</span>
    }

    /**
     * &lt;p&gt;Allows the MBean to perform any operations it needs before
     * being registered in the MBean server.  If the name of the MBean
     * is not specified, the MBean can provide a name for its
     * registration.  If any exception is raised, the MBean will not be
     * registered in the MBean server.&lt;/p&gt;
     *
     * &lt;p&gt;The default implementation of this method returns the {@code name}
     * parameter.  It does nothing else for
     * Standard MBeans.  For MXBeans, it records the {@code MBeanServer}
     * and {@code ObjectName} parameters so they can be used to translate
     * inter-MXBean references.&lt;/p&gt;
     *
     * &lt;p&gt;It is good practice for a subclass that overrides this method
     * to call the overridden method via {@code super.preRegister(...)}.
     * This is necessary if this object is an MXBean that is referenced
     * by attributes or operations in other MXBeans.&lt;/p&gt;
     *
     * @param server The MBean server in which the MBean will be registered.
     *
     * @param name The object name of the MBean.  This name is null if
     * the name parameter to one of the &lt;code&gt;createMBean&lt;/code&gt; or
     * &lt;code&gt;registerMBean&lt;/code&gt; methods in the {@link MBeanServer}
     * interface is null.  In that case, this method must return a
     * non-null ObjectName for the new MBean.
     *
     * @return The name under which the MBean is to be registered.
     * This value must not be null.  If the &lt;code&gt;name&lt;/code&gt;
     * parameter is not null, it will usually but not necessarily be
     * the returned value.
     *
     * @throws IllegalArgumentException if this is an MXBean and
     * {@code name} is null.
     *
     * @throws InstanceAlreadyExistsException if this is an MXBean and
     * it has already been registered under another name (in this
     * MBean Server or another).
     *
     * @throws Exception no other checked exceptions are thrown by
     * this method but {@code Exception} is declared so that subclasses
     * can override the method and throw their own exceptions.
     *
     * @since 1.6
     */
    public ObjectName preRegister(MBeanServer server, ObjectName name)
            throws Exception {
<span class="nc" id="L1075">        mbean.register(server, name);</span>
<span class="nc" id="L1076">        return name;</span>
    }

    /**
     * &lt;p&gt;Allows the MBean to perform any operations needed after having been
     * registered in the MBean server or after the registration has failed.&lt;/p&gt;
     *
     * &lt;p&gt;The default implementation of this method does nothing for
     * Standard MBeans.  For MXBeans, it undoes any work done by
     * {@link #preRegister preRegister} if registration fails.&lt;/p&gt;
     *
     * &lt;p&gt;It is good practice for a subclass that overrides this method
     * to call the overridden method via {@code super.postRegister(...)}.
     * This is necessary if this object is an MXBean that is referenced
     * by attributes or operations in other MXBeans.&lt;/p&gt;
     *
     * @param registrationDone Indicates whether or not the MBean has
     * been successfully registered in the MBean server. The value
     * false means that the registration phase has failed.
     *
     * @since 1.6
     */
    public void postRegister(Boolean registrationDone) {
<span class="nc bnc" id="L1099" title="All 2 branches missed.">        if (!registrationDone)</span>
<span class="nc" id="L1100">            mbean.unregister();</span>
<span class="nc" id="L1101">    }</span>

    /**
     * &lt;p&gt;Allows the MBean to perform any operations it needs before
     * being unregistered by the MBean server.&lt;/p&gt;
     *
     * &lt;p&gt;The default implementation of this method does nothing.&lt;/p&gt;
     *
     * &lt;p&gt;It is good practice for a subclass that overrides this method
     * to call the overridden method via {@code super.preDeregister(...)}.&lt;/p&gt;
     *
     * @throws Exception no checked exceptions are throw by this method
     * but {@code Exception} is declared so that subclasses can override
     * this method and throw their own exceptions.
     *
     * @since 1.6
     */
    public void preDeregister() throws Exception {
<span class="nc" id="L1119">    }</span>

    /**
     * &lt;p&gt;Allows the MBean to perform any operations needed after having been
     * unregistered in the MBean server.&lt;/p&gt;
     *
     * &lt;p&gt;The default implementation of this method does nothing for
     * Standard MBeans.  For MXBeans, it removes any information that
     * was recorded by the {@link #preRegister preRegister} method.&lt;/p&gt;
     *
     * &lt;p&gt;It is good practice for a subclass that overrides this method
     * to call the overridden method via {@code super.postRegister(...)}.
     * This is necessary if this object is an MXBean that is referenced
     * by attributes or operations in other MXBeans.&lt;/p&gt;
     *
     * @since 1.6
     */
    public void postDeregister() {
<span class="nc" id="L1137">        mbean.unregister();</span>
<span class="nc" id="L1138">    }</span>

    //
    // MBeanInfo immutability
    //

    /**
     * Cached results of previous calls to immutableInfo. This is
     * a WeakHashMap so that we don't prevent a class from being
     * garbage collected just because we know whether its MBeanInfo
     * is immutable.
     */
<span class="nc" id="L1150">    private static final Map&lt;Class&lt;?&gt;, Boolean&gt; mbeanInfoSafeMap =</span>
        new WeakHashMap&lt;Class&lt;?&gt;, Boolean&gt;();

    /**
     * Return true if {@code subclass} is known to preserve the immutability
     * of the {@code MBeanInfo}. The {@code subclass} is considered to have
     * an immutable {@code MBeanInfo} if it does not override any of the
     * getMBeanInfo, getCachedMBeanInfo, cacheMBeanInfo and getNotificationInfo
     * methods.
     */
    static boolean immutableInfo(Class&lt;? extends StandardMBean&gt; subclass) {
<span class="nc bnc" id="L1161" title="All 4 branches missed.">        if (subclass == StandardMBean.class ||</span>
            subclass == StandardEmitterMBean.class)
<span class="nc" id="L1163">            return true;</span>
<span class="nc" id="L1164">        synchronized (mbeanInfoSafeMap) {</span>
<span class="nc" id="L1165">            Boolean safe = mbeanInfoSafeMap.get(subclass);</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">            if (safe == null) {</span>
                try {
<span class="nc" id="L1168">                    MBeanInfoSafeAction action =</span>
                        new MBeanInfoSafeAction(subclass);
<span class="nc" id="L1170">                    safe = AccessController.doPrivileged(action);</span>
<span class="nc" id="L1171">                } catch (Exception e) { // e.g. SecurityException</span>
                    /* We don't know, so we assume it isn't.  */
<span class="nc" id="L1173">                    safe = false;</span>
<span class="nc" id="L1174">                }</span>
<span class="nc" id="L1175">                mbeanInfoSafeMap.put(subclass, safe);</span>
            }
<span class="nc" id="L1177">            return safe;</span>
<span class="nc" id="L1178">        }</span>
    }

    static boolean overrides(Class&lt;?&gt; subclass, Class&lt;?&gt; superclass,
                             String name, Class&lt;?&gt;... params) {
<span class="nc bnc" id="L1183" title="All 2 branches missed.">        for (Class&lt;?&gt; c = subclass; c != superclass; c = c.getSuperclass()) {</span>
            try {
<span class="nc" id="L1185">                c.getDeclaredMethod(name, params);</span>
<span class="nc" id="L1186">                return true;</span>
<span class="nc" id="L1187">            } catch (NoSuchMethodException e) {</span>
                // OK: this class doesn't override it
            }
        }
<span class="nc" id="L1191">        return false;</span>
    }

    private static class MBeanInfoSafeAction
            implements PrivilegedAction&lt;Boolean&gt; {

        private final Class&lt;?&gt; subclass;

<span class="nc" id="L1199">        MBeanInfoSafeAction(Class&lt;?&gt; subclass) {</span>
<span class="nc" id="L1200">            this.subclass = subclass;</span>
<span class="nc" id="L1201">        }</span>

        public Boolean run() {
            // Check for &quot;void cacheMBeanInfo(MBeanInfo)&quot; method.
            //
<span class="nc bnc" id="L1206" title="All 2 branches missed.">            if (overrides(subclass, StandardMBean.class,</span>
                          &quot;cacheMBeanInfo&quot;, MBeanInfo.class))
<span class="nc" id="L1208">                return false;</span>

            // Check for &quot;MBeanInfo getCachedMBeanInfo()&quot; method.
            //
<span class="nc bnc" id="L1212" title="All 2 branches missed.">            if (overrides(subclass, StandardMBean.class,</span>
                          &quot;getCachedMBeanInfo&quot;, (Class&lt;?&gt;[]) null))
<span class="nc" id="L1214">                return false;</span>

            // Check for &quot;MBeanInfo getMBeanInfo()&quot; method.
            //
<span class="nc bnc" id="L1218" title="All 2 branches missed.">            if (overrides(subclass, StandardMBean.class,</span>
                          &quot;getMBeanInfo&quot;, (Class&lt;?&gt;[]) null))
<span class="nc" id="L1220">                return false;</span>

            // Check for &quot;MBeanNotificationInfo[] getNotificationInfo()&quot;
            // method.
            //
            // This method is taken into account for the MBeanInfo
            // immutability checks if and only if the given subclass is
            // StandardEmitterMBean itself or can be assigned to
            // StandardEmitterMBean.
            //
<span class="nc bnc" id="L1230" title="All 2 branches missed.">            if (StandardEmitterMBean.class.isAssignableFrom(subclass))</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">                if (overrides(subclass, StandardEmitterMBean.class,</span>
                              &quot;getNotificationInfo&quot;, (Class&lt;?&gt;[]) null))
<span class="nc" id="L1233">                    return false;</span>
<span class="nc" id="L1234">            return true;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>