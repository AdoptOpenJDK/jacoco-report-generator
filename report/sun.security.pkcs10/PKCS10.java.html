<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PKCS10.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.pkcs10</a> &gt; <span class="el_source">PKCS10.java</span></div><h1>PKCS10.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package sun.security.pkcs10;

import java.io.PrintStream;
import java.io.IOException;
import java.math.BigInteger;

import java.security.cert.CertificateException;
import java.security.NoSuchAlgorithmException;
import java.security.InvalidKeyException;
import java.security.Signature;
import java.security.SignatureException;
import java.security.PublicKey;

import java.util.Base64;

import sun.security.util.*;
import sun.security.x509.AlgorithmId;
import sun.security.x509.X509Key;
import sun.security.x509.X500Name;

/**
 * A PKCS #10 certificate request is created and sent to a Certificate
 * Authority, which then creates an X.509 certificate and returns it to
 * the entity that requested it. A certificate request basically consists
 * of the subject's X.500 name, public key, and optionally some attributes,
 * signed using the corresponding private key.
 *
 * The ASN.1 syntax for a Certification Request is:
 * &lt;pre&gt;
 * CertificationRequest ::= SEQUENCE {
 *    certificationRequestInfo CertificationRequestInfo,
 *    signatureAlgorithm       SignatureAlgorithmIdentifier,
 *    signature                Signature
 *  }
 *
 * SignatureAlgorithmIdentifier ::= AlgorithmIdentifier
 * Signature ::= BIT STRING
 *
 * CertificationRequestInfo ::= SEQUENCE {
 *    version                 Version,
 *    subject                 Name,
 *    subjectPublicKeyInfo    SubjectPublicKeyInfo,
 *    attributes [0] IMPLICIT Attributes
 * }
 * Attributes ::= SET OF Attribute
 * &lt;/pre&gt;
 *
 * @author David Brownell
 * @author Amit Kapoor
 * @author Hemma Prafullchandra
 */
public class PKCS10 {
    /**
     * Constructs an unsigned PKCS #10 certificate request.  Before this
     * request may be used, it must be encoded and signed.  Then it
     * must be retrieved in some conventional format (e.g. string).
     *
     * @param publicKey the public key that should be placed
     *          into the certificate generated by the CA.
     */
<span class="nc" id="L87">    public PKCS10(PublicKey publicKey) {</span>
<span class="nc" id="L88">        subjectPublicKeyInfo = publicKey;</span>
<span class="nc" id="L89">        attributeSet = new PKCS10Attributes();</span>
<span class="nc" id="L90">    }</span>

    /**
     * Constructs an unsigned PKCS #10 certificate request.  Before this
     * request may be used, it must be encoded and signed.  Then it
     * must be retrieved in some conventional format (e.g. string).
     *
     * @param publicKey the public key that should be placed
     *          into the certificate generated by the CA.
     * @param attributes additonal set of PKCS10 attributes requested
     *          for in the certificate.
     */
<span class="nc" id="L102">    public PKCS10(PublicKey publicKey, PKCS10Attributes attributes) {</span>
<span class="nc" id="L103">        subjectPublicKeyInfo = publicKey;</span>
<span class="nc" id="L104">        attributeSet = attributes;</span>
<span class="nc" id="L105">    }</span>

    /**
     * Parses an encoded, signed PKCS #10 certificate request, verifying
     * the request's signature as it does so.  This constructor would
     * typically be used by a Certificate Authority, from which a new
     * certificate would then be constructed.
     *
     * @param data the DER-encoded PKCS #10 request.
     * @exception IOException for low level errors reading the data
     * @exception SignatureException when the signature is invalid
     * @exception NoSuchAlgorithmException when the signature
     *  algorithm is not supported in this environment
     */
    public PKCS10(byte[] data)
<span class="nc" id="L120">    throws IOException, SignatureException, NoSuchAlgorithmException {</span>
        DerInputStream  in;
        DerValue[]      seq;
        AlgorithmId     id;
        byte[]          sigData;
        Signature       sig;

<span class="nc" id="L127">        encoded = data;</span>

        //
        // Outer sequence:  request, signature algorithm, signature.
        // Parse, and prepare to verify later.
        //
<span class="nc" id="L133">        in = new DerInputStream(data);</span>
<span class="nc" id="L134">        seq = in.getSequence(3);</span>

<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (seq.length != 3)</span>
<span class="nc" id="L137">            throw new IllegalArgumentException(&quot;not a PKCS #10 request&quot;);</span>

<span class="nc" id="L139">        data = seq[0].toByteArray();            // reusing this variable</span>
<span class="nc" id="L140">        id = AlgorithmId.parse(seq[1]);</span>
<span class="nc" id="L141">        sigData = seq[2].getBitString();</span>

        //
        // Inner sequence:  version, name, key, attributes
        //
        BigInteger      serial;
        DerValue        val;

<span class="nc" id="L149">        serial = seq[0].data.getBigInteger();</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (!serial.equals(BigInteger.ZERO))</span>
<span class="nc" id="L151">            throw new IllegalArgumentException(&quot;not PKCS #10 v1&quot;);</span>

<span class="nc" id="L153">        subject = new X500Name(seq[0].data);</span>
<span class="nc" id="L154">        subjectPublicKeyInfo = X509Key.parse(seq[0].data.getDerValue());</span>

        // Cope with a somewhat common illegal PKCS #10 format
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (seq[0].data.available() != 0)</span>
<span class="nc" id="L158">            attributeSet = new PKCS10Attributes(seq[0].data);</span>
        else
<span class="nc" id="L160">            attributeSet = new PKCS10Attributes();</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (seq[0].data.available() != 0)</span>
<span class="nc" id="L163">            throw new IllegalArgumentException(&quot;illegal PKCS #10 data&quot;);</span>

        //
        // OK, we parsed it all ... validate the signature using the
        // key and signature algorithm we found.
        //
        try {
<span class="nc" id="L170">            sig = Signature.getInstance(id.getName());</span>
<span class="nc" id="L171">            sig.initVerify(subjectPublicKeyInfo);</span>
<span class="nc" id="L172">            sig.update(data);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (!sig.verify(sigData))</span>
<span class="nc" id="L174">                throw new SignatureException(&quot;Invalid PKCS #10 signature&quot;);</span>
<span class="nc" id="L175">        } catch (InvalidKeyException e) {</span>
<span class="nc" id="L176">            throw new SignatureException(&quot;invalid key&quot;);</span>
<span class="nc" id="L177">        }</span>
<span class="nc" id="L178">    }</span>

    /**
     * Create the signed certificate request.  This will later be
     * retrieved in either string or binary format.
     *
     * @param subject identifies the signer (by X.500 name).
     * @param signature private key and signing algorithm to use.
     * @exception IOException on errors.
     * @exception CertificateException on certificate handling errors.
     * @exception SignatureException on signature handling errors.
     */
    public void encodeAndSign(X500Name subject, Signature signature)
    throws CertificateException, IOException, SignatureException {
        DerOutputStream out, scratch;
        byte[]          certificateRequestInfo;
        byte[]          sig;

<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (encoded != null)</span>
<span class="nc" id="L197">            throw new SignatureException(&quot;request is already signed&quot;);</span>

<span class="nc" id="L199">        this.subject = subject;</span>

        /*
         * Encode cert request info, wrap in a sequence for signing
         */
<span class="nc" id="L204">        scratch = new DerOutputStream();</span>
<span class="nc" id="L205">        scratch.putInteger(BigInteger.ZERO);            // PKCS #10 v1.0</span>
<span class="nc" id="L206">        subject.encode(scratch);                        // X.500 name</span>
<span class="nc" id="L207">        scratch.write(subjectPublicKeyInfo.getEncoded()); // public key</span>
<span class="nc" id="L208">        attributeSet.encode(scratch);</span>

<span class="nc" id="L210">        out = new DerOutputStream();</span>
<span class="nc" id="L211">        out.write(DerValue.tag_Sequence, scratch);      // wrap it!</span>
<span class="nc" id="L212">        certificateRequestInfo = out.toByteArray();</span>
<span class="nc" id="L213">        scratch = out;</span>

        /*
         * Sign it ...
         */
<span class="nc" id="L218">        signature.update(certificateRequestInfo, 0,</span>
                certificateRequestInfo.length);
<span class="nc" id="L220">        sig = signature.sign();</span>

        /*
         * Build guts of SIGNED macro
         */
<span class="nc" id="L225">        AlgorithmId algId = null;</span>
        try {
<span class="nc" id="L227">            algId = AlgorithmId.get(signature.getAlgorithm());</span>
<span class="nc" id="L228">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L229">            throw new SignatureException(nsae);</span>
<span class="nc" id="L230">        }</span>
<span class="nc" id="L231">        algId.encode(scratch);     // sig algorithm</span>
<span class="nc" id="L232">        scratch.putBitString(sig);                      // sig</span>

        /*
         * Wrap those guts in a sequence
         */
<span class="nc" id="L237">        out = new DerOutputStream();</span>
<span class="nc" id="L238">        out.write(DerValue.tag_Sequence, scratch);</span>
<span class="nc" id="L239">        encoded = out.toByteArray();</span>
<span class="nc" id="L240">    }</span>

    /**
     * Returns the subject's name.
     */
<span class="nc" id="L245">    public X500Name getSubjectName() { return subject; }</span>

    /**
     * Returns the subject's public key.
     */
    public PublicKey getSubjectPublicKeyInfo()
<span class="nc" id="L251">        { return subjectPublicKeyInfo; }</span>

    /**
     * Returns the additional attributes requested.
     */
    public PKCS10Attributes getAttributes()
<span class="nc" id="L257">        { return attributeSet; }</span>

    /**
     * Returns the encoded and signed certificate request as a
     * DER-encoded byte array.
     *
     * @return the certificate request, or null if encodeAndSign()
     *          has not yet been called.
     */
    public byte[] getEncoded() {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (encoded != null)</span>
<span class="nc" id="L268">            return encoded.clone();</span>
        else
<span class="nc" id="L270">            return null;</span>
    }

    /**
     * Prints an E-Mailable version of the certificate request on the print
     * stream passed.  The format is a common base64 encoded one, supported
     * by most Certificate Authorities because Netscape web servers have
     * used this for some time.  Some certificate authorities expect some
     * more information, in particular contact information for the web
     * server administrator.
     *
     * @param out the print stream where the certificate request
     *  will be printed.
     * @exception IOException when an output operation failed
     * @exception SignatureException when the certificate request was
     *  not yet signed.
     */
    public void print(PrintStream out)
    throws IOException, SignatureException {
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (encoded == null)</span>
<span class="nc" id="L290">            throw new SignatureException(&quot;Cert request was not signed&quot;);</span>


<span class="nc" id="L293">        out.println(&quot;-----BEGIN NEW CERTIFICATE REQUEST-----&quot;);</span>
<span class="nc" id="L294">        out.println(Base64.getMimeEncoder().encodeToString(encoded));</span>
<span class="nc" id="L295">        out.println(&quot;-----END NEW CERTIFICATE REQUEST-----&quot;);</span>
<span class="nc" id="L296">    }</span>

    /**
     * Provides a short description of this request.
     */
    public String toString() {
<span class="nc" id="L302">        return &quot;[PKCS #10 certificate request:\n&quot;</span>
<span class="nc" id="L303">            + subjectPublicKeyInfo.toString()</span>
            + &quot; subject: &lt;&quot; + subject + &quot;&gt;&quot; + &quot;\n&quot;
<span class="nc" id="L305">            + &quot; attributes: &quot; + attributeSet.toString()</span>
            + &quot;\n]&quot;;
    }

    /**
     * Compares this object for equality with the specified
     * object. If the &lt;code&gt;other&lt;/code&gt; object is an
     * &lt;code&gt;instanceof&lt;/code&gt; &lt;code&gt;PKCS10&lt;/code&gt;, then
     * its encoded form is retrieved and compared with the
     * encoded form of this certificate request.
     *
     * @param other the object to test for equality with this object.
     * @return true iff the encoded forms of the two certificate
     * requests match, false otherwise.
     */
    public boolean equals(Object other) {
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (this == other)</span>
<span class="nc" id="L322">            return true;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (!(other instanceof PKCS10))</span>
<span class="nc" id="L324">            return false;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (encoded == null) // not signed yet</span>
<span class="nc" id="L326">            return false;</span>
<span class="nc" id="L327">        byte[] otherEncoded = ((PKCS10)other).getEncoded();</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (otherEncoded == null)</span>
<span class="nc" id="L329">            return false;</span>

<span class="nc" id="L331">        return java.util.Arrays.equals(encoded, otherEncoded);</span>
    }

    /**
     * Returns a hashcode value for this certificate request from its
     * encoded form.
     *
     * @return the hashcode value.
     */
    public int hashCode() {
<span class="nc" id="L341">        int     retval = 0;</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (encoded != null)</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            for (int i = 1; i &lt; encoded.length; i++)</span>
<span class="nc" id="L344">             retval += encoded[i] * i;</span>
<span class="nc" id="L345">        return(retval);</span>
    }

    private X500Name            subject;
    private PublicKey           subjectPublicKeyInfo;
    private PKCS10Attributes    attributeSet;
    private byte[]              encoded;        // signed
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>