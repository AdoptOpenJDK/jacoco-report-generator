<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultSynthStyle.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.swing.plaf.synth</a> &gt; <span class="el_source">DefaultSynthStyle.java</span></div><h1>DefaultSynthStyle.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.swing.plaf.synth;

import javax.swing.plaf.synth.*;
import java.awt.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.plaf.*;

/**
 * Default implementation of SynthStyle. Has setters for the various
 * SynthStyle methods. Many of the properties can be specified for all states,
 * using SynthStyle directly, or a specific state using one of the StateInfo
 * methods.
 * &lt;p&gt;
 * Beyond the constructor a subclass should override the &lt;code&gt;addTo&lt;/code&gt;
 * and &lt;code&gt;clone&lt;/code&gt; methods, these are used when the Styles are being
 * merged into a resulting style.
 *
 * @author Scott Violet
 */
public class DefaultSynthStyle extends SynthStyle implements Cloneable {
    private static final String PENDING = &quot;Pending&quot;;

    /**
     * Should the component be opaque?
     */
    private boolean opaque;
    /**
     * Insets.
     */
    private Insets insets;
    /**
     * Information specific to ComponentState.
     */
    private StateInfo[] states;
    /**
     * User specific data.
     */
    private Map data;

    /**
     * Font to use if there is no matching StateInfo, or the StateInfo doesn't
     * define one.
     */
    private Font font;

    /**
     * SynthGraphics, may be null.
     */
    private SynthGraphicsUtils synthGraphics;

    /**
     * Painter to use if the StateInfo doesn't have one.
     */
    private SynthPainter painter;


    /**
     * Nullary constructor, intended for subclassers.
     */
<span class="nc" id="L86">    public DefaultSynthStyle() {</span>
<span class="nc" id="L87">    }</span>

    /**
     * Creates a new DefaultSynthStyle that is a copy of the passed in
     * style. Any StateInfo's of the passed in style are clonsed as well.
     *
     * @param style Style to duplicate
     */
<span class="nc" id="L95">    public DefaultSynthStyle(DefaultSynthStyle style) {</span>
<span class="nc" id="L96">        opaque = style.opaque;</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">        if (style.insets != null) {</span>
<span class="nc" id="L98">            insets = new Insets(style.insets.top, style.insets.left,</span>
                                style.insets.bottom, style.insets.right);
        }
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (style.states != null) {</span>
<span class="nc" id="L102">            states = new StateInfo[style.states.length];</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            for (int counter = style.states.length - 1; counter &gt;= 0;</span>
<span class="nc" id="L104">                     counter--) {</span>
<span class="nc" id="L105">                states[counter] = (StateInfo)style.states[counter].clone();</span>
            }
        }
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (style.data != null) {</span>
<span class="nc" id="L109">            data = new HashMap();</span>
<span class="nc" id="L110">            data.putAll(style.data);</span>
        }
<span class="nc" id="L112">        font = style.font;</span>
<span class="nc" id="L113">        synthGraphics = style.synthGraphics;</span>
<span class="nc" id="L114">        painter = style.painter;</span>
<span class="nc" id="L115">    }</span>

    /**
     * Creates a new DefaultSynthStyle.
     *
     * @param insets Insets for the Style
     * @param opaque Whether or not the background is completely painted in
     *        an opaque color
     * @param states StateInfos describing properties per state
     * @param data Style specific data.
     */
    public DefaultSynthStyle(Insets insets, boolean opaque,
<span class="nc" id="L127">                             StateInfo[] states, Map data) {</span>
<span class="nc" id="L128">        this.insets = insets;</span>
<span class="nc" id="L129">        this.opaque = opaque;</span>
<span class="nc" id="L130">        this.states = states;</span>
<span class="nc" id="L131">        this.data = data;</span>
<span class="nc" id="L132">    }</span>

    public Color getColor(SynthContext context, ColorType type) {
<span class="nc" id="L135">        return getColor(context.getComponent(), context.getRegion(),</span>
<span class="nc" id="L136">                        context.getComponentState(), type);</span>
    }

    public Color getColor(JComponent c, Region id, int state,
                          ColorType type) {
        // For the enabled state, prefer the widget's colors
<span class="nc bnc" id="L142" title="All 4 branches missed.">        if (!id.isSubregion() &amp;&amp; state == SynthConstants.ENABLED) {</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">            if (type == ColorType.BACKGROUND) {</span>
<span class="nc" id="L144">                return c.getBackground();</span>
            }
<span class="nc bnc" id="L146" title="All 2 branches missed.">            else if (type == ColorType.FOREGROUND) {</span>
<span class="nc" id="L147">                return c.getForeground();</span>
            }
<span class="nc bnc" id="L149" title="All 2 branches missed.">            else if (type == ColorType.TEXT_FOREGROUND) {</span>
                // If getForeground returns a non-UIResource it means the
                // developer has explicitly set the foreground, use it over
                // that of TEXT_FOREGROUND as that is typically the expected
                // behavior.
<span class="nc" id="L154">                Color color = c.getForeground();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                if (!(color instanceof UIResource)) {</span>
<span class="nc" id="L156">                    return color;</span>
                }
            }
        }
        // Then use what we've locally defined
<span class="nc" id="L161">        Color color = getColorForState(c, id, state, type);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (color == null) {</span>
            // No color, fallback to that of the widget.
<span class="nc bnc" id="L164" title="All 4 branches missed.">            if (type == ColorType.BACKGROUND ||</span>
                        type == ColorType.TEXT_BACKGROUND) {
<span class="nc" id="L166">                return c.getBackground();</span>
            }
<span class="nc bnc" id="L168" title="All 4 branches missed.">            else if (type == ColorType.FOREGROUND ||</span>
                     type == ColorType.TEXT_FOREGROUND) {
<span class="nc" id="L170">                return c.getForeground();</span>
            }
        }
<span class="nc" id="L173">        return color;</span>
    }

    protected Color getColorForState(SynthContext context, ColorType type) {
<span class="nc" id="L177">        return getColorForState(context.getComponent(), context.getRegion(),</span>
<span class="nc" id="L178">                                context.getComponentState(), type);</span>
    }

    /**
     * Returns the color for the specified state.
     *
     * @param c JComponent the style is associated with
     * @param id Region identifier
     * @param state State of the region.
     * @param type Type of color being requested.
     * @return Color to render with
     */
    protected Color getColorForState(JComponent c, Region id, int state,
                                     ColorType type) {
        // Use the best state.
<span class="nc" id="L193">        StateInfo si = getStateInfo(state);</span>
        Color color;
<span class="nc bnc" id="L195" title="All 4 branches missed.">        if (si != null &amp;&amp; (color = si.getColor(type)) != null) {</span>
<span class="nc" id="L196">            return color;</span>
        }
<span class="nc bnc" id="L198" title="All 4 branches missed.">        if (si == null || si.getComponentState() != 0) {</span>
<span class="nc" id="L199">            si = getStateInfo(0);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (si != null) {</span>
<span class="nc" id="L201">                return si.getColor(type);</span>
            }
        }
<span class="nc" id="L204">        return null;</span>
    }

    /**
     * Sets the font that is used if there is no matching StateInfo, or
     * it does not define a font.
     *
     * @param font Font to use for rendering
     */
    public void setFont(Font font) {
<span class="nc" id="L214">        this.font = font;</span>
<span class="nc" id="L215">    }</span>

    public Font getFont(SynthContext state) {
<span class="nc" id="L218">        return getFont(state.getComponent(), state.getRegion(),</span>
<span class="nc" id="L219">                       state.getComponentState());</span>
    }

    public Font getFont(JComponent c, Region id, int state) {
<span class="nc bnc" id="L223" title="All 4 branches missed.">        if (!id.isSubregion() &amp;&amp; state == SynthConstants.ENABLED) {</span>
<span class="nc" id="L224">            return c.getFont();</span>
        }
<span class="nc" id="L226">        Font cFont = c.getFont();</span>
<span class="nc bnc" id="L227" title="All 4 branches missed.">        if (cFont != null &amp;&amp; !(cFont instanceof UIResource)) {</span>
<span class="nc" id="L228">            return cFont;</span>
        }
<span class="nc" id="L230">        return getFontForState(c, id, state);</span>
    }

    /**
     * Returns the font for the specified state. This should NOT callback
     * to the JComponent.
     *
     * @param c JComponent the style is associated with
     * @param id Region identifier
     * @param state State of the region.
     * @return Font to render with
     */
    protected Font getFontForState(JComponent c, Region id, int state) {
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L244">            return this.font;</span>
        }
        // First pass, look for the best match
<span class="nc" id="L247">        StateInfo si = getStateInfo(state);</span>
        Font font;
<span class="nc bnc" id="L249" title="All 4 branches missed.">        if (si != null &amp;&amp; (font = si.getFont()) != null) {</span>
<span class="nc" id="L250">            return font;</span>
        }
<span class="nc bnc" id="L252" title="All 4 branches missed.">        if (si == null || si.getComponentState() != 0) {</span>
<span class="nc" id="L253">            si = getStateInfo(0);</span>
<span class="nc bnc" id="L254" title="All 4 branches missed.">            if (si != null &amp;&amp; (font = si.getFont()) != null) {</span>
<span class="nc" id="L255">                return font;</span>
            }
        }
        // Fallback font.
<span class="nc" id="L259">        return this.font;</span>
    }

    protected Font getFontForState(SynthContext context) {
<span class="nc" id="L263">        return getFontForState(context.getComponent(), context.getRegion(),</span>
<span class="nc" id="L264">                               context.getComponentState());</span>
    }

    /**
     * Sets the SynthGraphicsUtils that will be used for rendering.
     *
     * @param graphics SynthGraphics
     */
    public void setGraphicsUtils(SynthGraphicsUtils graphics) {
<span class="nc" id="L273">        this.synthGraphics = graphics;</span>
<span class="nc" id="L274">    }</span>

    /**
     * Returns a SynthGraphicsUtils.
     *
     * @param context SynthContext identifying requestor
     * @return SynthGraphicsUtils
     */
    public SynthGraphicsUtils getGraphicsUtils(SynthContext context) {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (synthGraphics == null) {</span>
<span class="nc" id="L284">            return super.getGraphicsUtils(context);</span>
        }
<span class="nc" id="L286">        return synthGraphics;</span>
    }

    /**
     * Sets the insets.
     *
     * @param Insets.
     */
    public void setInsets(Insets insets) {
<span class="nc" id="L295">        this.insets = insets;</span>
<span class="nc" id="L296">    }</span>

    /**
     * Returns the Insets. If &lt;code&gt;to&lt;/code&gt; is non-null the resulting
     * insets will be placed in it, otherwise a new Insets object will be
     * created and returned.
     *
     * @param context SynthContext identifying requestor
     * @param to Where to place Insets
     * @return Insets.
     */
    public Insets getInsets(SynthContext state, Insets to) {
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (to == null) {</span>
<span class="nc" id="L309">            to = new Insets(0, 0, 0, 0);</span>
        }
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (insets != null) {</span>
<span class="nc" id="L312">            to.left = insets.left;</span>
<span class="nc" id="L313">            to.right = insets.right;</span>
<span class="nc" id="L314">            to.top = insets.top;</span>
<span class="nc" id="L315">            to.bottom = insets.bottom;</span>
        }
        else {
<span class="nc" id="L318">            to.left = to.right = to.top = to.bottom = 0;</span>
        }
<span class="nc" id="L320">        return to;</span>
    }

    /**
     * Sets the Painter to use for the border.
     *
     * @param painter Painter for the Border.
     */
    public void setPainter(SynthPainter painter) {
<span class="nc" id="L329">        this.painter = painter;</span>
<span class="nc" id="L330">    }</span>

    /**
     * Returns the Painter for the passed in Component. This may return null.
     *
     * @param ss SynthContext identifying requestor
     * @return Painter for the border
     */
    public SynthPainter getPainter(SynthContext ss) {
<span class="nc" id="L339">        return painter;</span>
    }

    /**
     * Sets whether or not the JComponent should be opaque.
     *
     * @param opaque Whether or not the JComponent should be opaque.
     */
    public void setOpaque(boolean opaque) {
<span class="nc" id="L348">        this.opaque = opaque;</span>
<span class="nc" id="L349">    }</span>

    /**
     * Returns the value to initialize the opacity property of the Component
     * to. A Style should NOT assume the opacity will remain this value, the
     * developer may reset it or override it.
     *
     * @param ss SynthContext identifying requestor
     * @return opaque Whether or not the JComponent is opaque.
     */
    public boolean isOpaque(SynthContext ss) {
<span class="nc" id="L360">        return opaque;</span>
    }

    /**
     * Sets style specific values. This does NOT copy the data, it
     * assigns it directly to this Style.
     *
     * @param data Style specific values
     */
    public void setData(Map data) {
<span class="nc" id="L370">        this.data = data;</span>
<span class="nc" id="L371">    }</span>

    /**
     * Returns the style specific data.
     *
     * @return Style specific data.
     */
    public Map getData() {
<span class="nc" id="L379">        return data;</span>
    }

    /**
     * Getter for a region specific style property.
     *
     * @param state SynthContext identifying requestor
     * @param key Property being requested.
     * @return Value of the named property
     */
    public Object get(SynthContext state, Object key) {
        // Look for the best match
<span class="nc" id="L391">        StateInfo si = getStateInfo(state.getComponentState());</span>
<span class="nc bnc" id="L392" title="All 6 branches missed.">        if (si != null &amp;&amp; si.getData() != null &amp;&amp; getKeyFromData(si.getData(), key) != null) {</span>
<span class="nc" id="L393">            return getKeyFromData(si.getData(), key);</span>
        }
<span class="nc" id="L395">        si = getStateInfo(0);</span>
<span class="nc bnc" id="L396" title="All 6 branches missed.">        if (si != null &amp;&amp; si.getData() != null &amp;&amp; getKeyFromData(si.getData(), key) != null) {</span>
<span class="nc" id="L397">            return getKeyFromData(si.getData(), key);</span>
        }
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if(getKeyFromData(data, key) != null)</span>
<span class="nc" id="L400">          return getKeyFromData(data, key);</span>
<span class="nc" id="L401">        return getDefaultValue(state, key);</span>
    }


    private Object getKeyFromData(Map stateData, Object key) {
<span class="nc" id="L406">          Object value = null;</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">          if (stateData != null) {</span>

<span class="nc" id="L409">            synchronized(stateData) {</span>
<span class="nc" id="L410">                value = stateData.get(key);</span>
<span class="nc" id="L411">            }</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            while (value == PENDING) {</span>
<span class="nc" id="L413">                synchronized(stateData) {</span>
                    try {
<span class="nc" id="L415">                        stateData.wait();</span>
<span class="nc" id="L416">                    } catch (InterruptedException ie) {}</span>
<span class="nc" id="L417">                    value = stateData.get(key);</span>
<span class="nc" id="L418">                }</span>
            }
<span class="nc bnc" id="L420" title="All 2 branches missed.">            if (value instanceof UIDefaults.LazyValue) {</span>
<span class="nc" id="L421">                synchronized(stateData) {</span>
<span class="nc" id="L422">                    stateData.put(key, PENDING);</span>
<span class="nc" id="L423">                }</span>
<span class="nc" id="L424">                value = ((UIDefaults.LazyValue)value).createValue(null);</span>
<span class="nc" id="L425">                synchronized(stateData) {</span>
<span class="nc" id="L426">                    stateData.put(key, value);</span>
<span class="nc" id="L427">                    stateData.notifyAll();</span>
<span class="nc" id="L428">                }</span>
            }
        }
<span class="nc" id="L431">        return value;</span>
    }

    /**
     * Returns the default value for a particular property.  This is only
     * invoked if this style doesn't define a property for &lt;code&gt;key&lt;/code&gt;.
     *
     * @param state SynthContext identifying requestor
     * @param key Property being requested.
     * @return Value of the named property
     */
    public Object getDefaultValue(SynthContext context, Object key) {
<span class="nc" id="L443">        return super.get(context, key);</span>
    }

    /**
     * Creates a clone of this style.
     *
     * @return Clone of this style
     */
    public Object clone() {
        DefaultSynthStyle style;
        try {
<span class="nc" id="L454">            style = (DefaultSynthStyle)super.clone();</span>
<span class="nc" id="L455">        } catch (CloneNotSupportedException cnse) {</span>
<span class="nc" id="L456">            return null;</span>
<span class="nc" id="L457">        }</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        if (states != null) {</span>
<span class="nc" id="L459">            style.states = new StateInfo[states.length];</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            for (int counter = states.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L461">                style.states[counter] = (StateInfo)states[counter].clone();</span>
            }
        }
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (data != null) {</span>
<span class="nc" id="L465">            style.data = new HashMap();</span>
<span class="nc" id="L466">            style.data.putAll(data);</span>
        }
<span class="nc" id="L468">        return style;</span>
    }

    /**
     * Merges the contents of this Style with that of the passed in Style,
     * returning the resulting merged syle. Properties of this
     * &lt;code&gt;DefaultSynthStyle&lt;/code&gt; will take precedence over those of the
     * passed in &lt;code&gt;DefaultSynthStyle&lt;/code&gt;. For example, if this
     * style specifics a non-null font, the returned style will have its
     * font so to that regardless of the &lt;code&gt;style&lt;/code&gt;'s font.
     *
     * @param style Style to add our styles to
     * @return Merged style.
     */
    public DefaultSynthStyle addTo(DefaultSynthStyle style) {
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (insets != null) {</span>
<span class="nc" id="L484">            style.insets = this.insets;</span>
        }
<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (font != null) {</span>
<span class="nc" id="L487">            style.font = this.font;</span>
        }
<span class="nc bnc" id="L489" title="All 2 branches missed.">        if (painter != null) {</span>
<span class="nc" id="L490">            style.painter = this.painter;</span>
        }
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (synthGraphics != null) {</span>
<span class="nc" id="L493">            style.synthGraphics = this.synthGraphics;</span>
        }
<span class="nc" id="L495">        style.opaque = opaque;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (states != null) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">            if (style.states == null) {</span>
<span class="nc" id="L498">                style.states = new StateInfo[states.length];</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                for (int counter = states.length - 1; counter &gt;= 0; counter--){</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                    if (states[counter] != null) {</span>
<span class="nc" id="L501">                        style.states[counter] = (StateInfo)states[counter].</span>
<span class="nc" id="L502">                                                clone();</span>
                    }
                }
            }
            else {
                // Find the number of new states in unique, merging any
                // matching states as we go. Also, move any merge styles
                // to the end to give them precedence.
<span class="nc" id="L510">                int unique = 0;</span>
                // Number of StateInfos that match.
<span class="nc" id="L512">                int matchCount = 0;</span>
<span class="nc" id="L513">                int maxOStyles = style.states.length;</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                for (int thisCounter = states.length - 1; thisCounter &gt;= 0;</span>
<span class="nc" id="L515">                         thisCounter--) {</span>
<span class="nc" id="L516">                    int state = states[thisCounter].getComponentState();</span>
<span class="nc" id="L517">                    boolean found = false;</span>

<span class="nc" id="L519">                    for (int oCounter = maxOStyles - 1 - matchCount;</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">                             oCounter &gt;= 0; oCounter--) {</span>
<span class="nc" id="L521">                        if (state == style.states[oCounter].</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                                           getComponentState()) {</span>
<span class="nc" id="L523">                            style.states[oCounter] = states[thisCounter].</span>
<span class="nc" id="L524">                                        addTo(style.states[oCounter]);</span>
                            // Move StateInfo to end, giving it precedence.
<span class="nc" id="L526">                            StateInfo tmp = style.states[maxOStyles - 1 -</span>
                                                         matchCount];
<span class="nc" id="L528">                            style.states[maxOStyles - 1 - matchCount] =</span>
                                  style.states[oCounter];
<span class="nc" id="L530">                            style.states[oCounter] = tmp;</span>
<span class="nc" id="L531">                            matchCount++;</span>
<span class="nc" id="L532">                            found = true;</span>
<span class="nc" id="L533">                            break;</span>
                        }
                    }
<span class="nc bnc" id="L536" title="All 2 branches missed.">                    if (!found) {</span>
<span class="nc" id="L537">                        unique++;</span>
                    }
                }
<span class="nc bnc" id="L540" title="All 2 branches missed.">                if (unique != 0) {</span>
                    // There are states that exist in this Style that
                    // don't exist in the other style, recreate the array
                    // and add them.
<span class="nc" id="L544">                    StateInfo[] newStates = new StateInfo[</span>
                                   unique + maxOStyles];
<span class="nc" id="L546">                    int newIndex = maxOStyles;</span>

<span class="nc" id="L548">                    System.arraycopy(style.states, 0, newStates, 0,maxOStyles);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">                    for (int thisCounter = states.length - 1; thisCounter &gt;= 0;</span>
<span class="nc" id="L550">                             thisCounter--) {</span>
<span class="nc" id="L551">                        int state = states[thisCounter].getComponentState();</span>
<span class="nc" id="L552">                        boolean found = false;</span>

<span class="nc bnc" id="L554" title="All 2 branches missed.">                        for (int oCounter = maxOStyles - 1; oCounter &gt;= 0;</span>
<span class="nc" id="L555">                                 oCounter--) {</span>
<span class="nc" id="L556">                            if (state == style.states[oCounter].</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                                               getComponentState()) {</span>
<span class="nc" id="L558">                                found = true;</span>
<span class="nc" id="L559">                                break;</span>
                            }
                        }
<span class="nc bnc" id="L562" title="All 2 branches missed.">                        if (!found) {</span>
<span class="nc" id="L563">                            newStates[newIndex++] = (StateInfo)states[</span>
<span class="nc" id="L564">                                      thisCounter].clone();</span>
                        }
                    }
<span class="nc" id="L567">                    style.states = newStates;</span>
                }
            }
        }
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (data != null) {</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">            if (style.data == null) {</span>
<span class="nc" id="L573">                style.data = new HashMap();</span>
            }
<span class="nc" id="L575">            style.data.putAll(data);</span>
        }
<span class="nc" id="L577">        return style;</span>
    }

    /**
     * Sets the array of StateInfo's which are used to specify properties
     * specific to a particular style.
     *
     * @param states StateInfos
     */
    public void setStateInfo(StateInfo[] states) {
<span class="nc" id="L587">        this.states = states;</span>
<span class="nc" id="L588">    }</span>

    /**
     * Returns the array of StateInfo's that that are used to specify
     * properties specific to a particular style.
     *
     * @return Array of StateInfos.
     */
    public StateInfo[] getStateInfo() {
<span class="nc" id="L597">        return states;</span>
    }

    /**
     * Returns the best matching StateInfo for a particular state.
     *
     * @param state Component state.
     * @return Best matching StateInfo, or null
     */
    public StateInfo getStateInfo(int state) {
        // Use the StateInfo with the most bits that matches that of state.
        // If there is none, than fallback to
        // the StateInfo with a state of 0, indicating it'll match anything.

        // Consider if we have 3 StateInfos a, b and c with states:
        // SELECTED, SELECTED | ENABLED, 0
        //
        // Input                          Return Value
        // -----                          ------------
        // SELECTED                       a
        // SELECTED | ENABLED             b
        // MOUSE_OVER                     c
        // SELECTED | ENABLED | FOCUSED   b
        // ENABLED                        c

<span class="nc bnc" id="L622" title="All 2 branches missed.">        if (states != null) {</span>
<span class="nc" id="L623">            int bestCount = 0;</span>
<span class="nc" id="L624">            int bestIndex = -1;</span>
<span class="nc" id="L625">            int wildIndex = -1;</span>

<span class="nc bnc" id="L627" title="All 2 branches missed.">            if (state == 0) {</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">                for (int counter = states.length - 1; counter &gt;= 0;counter--) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">                    if (states[counter].getComponentState() == 0) {</span>
<span class="nc" id="L630">                        return states[counter];</span>
                    }
                }
<span class="nc" id="L633">                return null;</span>
            }
<span class="nc bnc" id="L635" title="All 2 branches missed.">            for (int counter = states.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L636">                int oState = states[counter].getComponentState();</span>

<span class="nc bnc" id="L638" title="All 2 branches missed.">                if (oState == 0) {</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">                    if (wildIndex == -1) {</span>
<span class="nc" id="L640">                        wildIndex = counter;</span>
                    }
                }
<span class="nc bnc" id="L643" title="All 2 branches missed.">                else if ((state &amp; oState) == oState) {</span>
                    // This is key, we need to make sure all bits of the
                    // StateInfo match, otherwise a StateInfo with
                    // SELECTED | ENABLED would match ENABLED, which we
                    // don't want.

                    // This comes from BigInteger.bitCnt
<span class="nc" id="L650">                    int bitCount = oState;</span>
<span class="nc" id="L651">                    bitCount -= (0xaaaaaaaa &amp; bitCount) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L652">                    bitCount = (bitCount &amp; 0x33333333) + ((bitCount &gt;&gt;&gt; 2) &amp;</span>
                                                      0x33333333);
<span class="nc" id="L654">                    bitCount = bitCount + (bitCount &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f;</span>
<span class="nc" id="L655">                    bitCount += bitCount &gt;&gt;&gt; 8;</span>
<span class="nc" id="L656">                    bitCount += bitCount &gt;&gt;&gt; 16;</span>
<span class="nc" id="L657">                    bitCount = bitCount &amp; 0xff;</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">                    if (bitCount &gt; bestCount) {</span>
<span class="nc" id="L659">                        bestIndex = counter;</span>
<span class="nc" id="L660">                        bestCount = bitCount;</span>
                    }
                }
            }
<span class="nc bnc" id="L664" title="All 2 branches missed.">            if (bestIndex != -1) {</span>
<span class="nc" id="L665">                return states[bestIndex];</span>
            }
<span class="nc bnc" id="L667" title="All 2 branches missed.">            if (wildIndex != -1) {</span>
<span class="nc" id="L668">                return states[wildIndex];</span>
            }
          }
<span class="nc" id="L671">          return null;</span>
    }


    public String toString() {
<span class="nc" id="L676">        StringBuffer buf = new StringBuffer();</span>

<span class="nc" id="L678">        buf.append(super.toString()).append(',');</span>

<span class="nc" id="L680">        buf.append(&quot;data=&quot;).append(data).append(',');</span>

<span class="nc" id="L682">        buf.append(&quot;font=&quot;).append(font).append(',');</span>

<span class="nc" id="L684">        buf.append(&quot;insets=&quot;).append(insets).append(',');</span>

<span class="nc" id="L686">        buf.append(&quot;synthGraphics=&quot;).append(synthGraphics).append(',');</span>

<span class="nc" id="L688">        buf.append(&quot;painter=&quot;).append(painter).append(',');</span>

<span class="nc" id="L690">        StateInfo[] states = getStateInfo();</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (states != null) {</span>
<span class="nc" id="L692">            buf.append(&quot;states[&quot;);</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">            for (StateInfo state : states) {</span>
<span class="nc" id="L694">                buf.append(state.toString()).append(',');</span>
            }
<span class="nc" id="L696">            buf.append(']').append(',');</span>
        }

        // remove last newline
<span class="nc" id="L700">        buf.deleteCharAt(buf.length() - 1);</span>

<span class="nc" id="L702">        return buf.toString();</span>
    }


    /**
     * StateInfo represents Style information specific to the state of
     * a component.
     */
    public static class StateInfo {
        private Map data;
        private Font font;
        private Color[] colors;
        private int state;

        /**
         * Creates a new StateInfo.
         */
<span class="nc" id="L719">        public StateInfo() {</span>
<span class="nc" id="L720">        }</span>

        /**
         * Creates a new StateInfo with the specified properties
         *
         * @param state Component state(s) that this StateInfo should be used
         * for
         * @param painter Painter responsible for rendering
         * @param bgPainter Painter responsible for rendering the background
         * @param font Font for this state
         * @param colors Colors for this state
         */
<span class="nc" id="L732">        public StateInfo(int state, Font font, Color[] colors) {</span>
<span class="nc" id="L733">            this.state = state;</span>
<span class="nc" id="L734">            this.font = font;</span>
<span class="nc" id="L735">            this.colors = colors;</span>
<span class="nc" id="L736">        }</span>

        /**
         * Creates a new StateInfo that is a copy of the passed in
         * StateInfo.
         *
         * @param info StateInfo to copy.
         */
<span class="nc" id="L744">        public StateInfo(StateInfo info) {</span>
<span class="nc" id="L745">            this.state = info.state;</span>
<span class="nc" id="L746">            this.font = info.font;</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">            if(info.data != null) {</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">               if(data == null) {</span>
<span class="nc" id="L749">                  data = new HashMap();</span>
               }
<span class="nc" id="L751">               data.putAll(info.data);</span>
            }
<span class="nc bnc" id="L753" title="All 2 branches missed.">            if (info.colors != null) {</span>
<span class="nc" id="L754">                this.colors = new Color[info.colors.length];</span>
<span class="nc" id="L755">                System.arraycopy(info.colors, 0, colors, 0,info.colors.length);</span>
            }
<span class="nc" id="L757">        }</span>

        public Map getData() {
<span class="nc" id="L760">            return data;</span>
        }

        public void setData(Map data) {
<span class="nc" id="L764">            this.data = data;</span>
<span class="nc" id="L765">        }</span>

        /**
         * Sets the font for this state.
         *
         * @param font Font to use for rendering
         */
        public void setFont(Font font) {
<span class="nc" id="L773">            this.font = font;</span>
<span class="nc" id="L774">        }</span>

        /**
         * Returns the font for this state.
         *
         * @return Returns the font to use for rendering this state
         */
        public Font getFont() {
<span class="nc" id="L782">            return font;</span>
        }

        /**
         * Sets the array of colors to use for rendering this state. This
         * is indexed by &lt;code&gt;ColorType.getID()&lt;/code&gt;.
         *
         * @param colors Array of colors
         */
        public void setColors(Color[] colors) {
<span class="nc" id="L792">            this.colors = colors;</span>
<span class="nc" id="L793">        }</span>

        /**
         * Returns the array of colors to use for rendering this state. This
         * is indexed by &lt;code&gt;ColorType.getID()&lt;/code&gt;.
         *
         * @return Array of colors
         */
        public Color[] getColors() {
<span class="nc" id="L802">            return colors;</span>
        }

        /**
         * Returns the Color to used for the specified ColorType.
         *
         * @return Color.
         */
        public Color getColor(ColorType type) {
<span class="nc bnc" id="L811" title="All 2 branches missed.">            if (colors != null) {</span>
<span class="nc" id="L812">                int id = type.getID();</span>

<span class="nc bnc" id="L814" title="All 2 branches missed.">                if (id &lt; colors.length) {</span>
<span class="nc" id="L815">                    return colors[id];</span>
                }
            }
<span class="nc" id="L818">            return null;</span>
        }

        /**
         * Merges the contents of this StateInfo with that of the passed in
         * StateInfo, returning the resulting merged StateInfo. Properties of
         * this &lt;code&gt;StateInfo&lt;/code&gt; will take precedence over those of the
         * passed in &lt;code&gt;StateInfo&lt;/code&gt;. For example, if this
         * StateInfo specifics a non-null font, the returned StateInfo will
         * have its font so to that regardless of the &lt;code&gt;StateInfo&lt;/code&gt;'s
         * font.
         *
         * @param info StateInfo to add our styles to
         * @return Merged StateInfo.
         */
        public StateInfo addTo(StateInfo info) {
<span class="nc bnc" id="L834" title="All 2 branches missed.">            if (font != null) {</span>
<span class="nc" id="L835">                info.font = font;</span>
            }
<span class="nc bnc" id="L837" title="All 2 branches missed.">            if(data != null) {</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">                if(info.data == null) {</span>
<span class="nc" id="L839">                    info.data = new HashMap();</span>
                }
<span class="nc" id="L841">                info.data.putAll(data);</span>
            }
<span class="nc bnc" id="L843" title="All 2 branches missed.">            if (colors != null) {</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">                if (info.colors == null) {</span>
<span class="nc" id="L845">                    info.colors = new Color[colors.length];</span>
<span class="nc" id="L846">                    System.arraycopy(colors, 0, info.colors, 0,</span>
                                     colors.length);
                }
                else {
<span class="nc bnc" id="L850" title="All 2 branches missed.">                    if (info.colors.length &lt; colors.length) {</span>
<span class="nc" id="L851">                        Color[] old = info.colors;</span>

<span class="nc" id="L853">                        info.colors = new Color[colors.length];</span>
<span class="nc" id="L854">                        System.arraycopy(old, 0, info.colors, 0, old.length);</span>
                    }
<span class="nc bnc" id="L856" title="All 2 branches missed.">                    for (int counter = colors.length - 1; counter &gt;= 0;</span>
<span class="nc" id="L857">                             counter--) {</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">                        if (colors[counter] != null) {</span>
<span class="nc" id="L859">                            info.colors[counter] = colors[counter];</span>
                        }
                    }
                }
            }
<span class="nc" id="L864">            return info;</span>
        }

        /**
         * Sets the state this StateInfo corresponds to.
         *
         * @see SynthConstants
         * @param state info.
         */
        public void setComponentState(int state) {
<span class="nc" id="L874">            this.state = state;</span>
<span class="nc" id="L875">        }</span>

        /**
         * Returns the state this StateInfo corresponds to.
         *
         * @see SynthConstants
         * @return state info.
         */
        public int getComponentState() {
<span class="nc" id="L884">            return state;</span>
        }

        /**
         * Returns the number of states that are similar between the
         * ComponentState this StateInfo represents and val.
         */
        private int getMatchCount(int val) {
            // This comes from BigInteger.bitCnt
<span class="nc" id="L893">            val &amp;= state;</span>
<span class="nc" id="L894">            val -= (0xaaaaaaaa &amp; val) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L895">            val = (val &amp; 0x33333333) + ((val &gt;&gt;&gt; 2) &amp; 0x33333333);</span>
<span class="nc" id="L896">            val = val + (val &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f;</span>
<span class="nc" id="L897">            val += val &gt;&gt;&gt; 8;</span>
<span class="nc" id="L898">            val += val &gt;&gt;&gt; 16;</span>
<span class="nc" id="L899">            return val &amp; 0xff;</span>
        }

        /**
         * Creates and returns a copy of this StateInfo.
         *
         * @return Copy of this StateInfo.
         */
        public Object clone() {
<span class="nc" id="L908">            return new StateInfo(this);</span>
        }

        public String toString() {
<span class="nc" id="L912">            StringBuffer buf = new StringBuffer();</span>

<span class="nc" id="L914">            buf.append(super.toString()).append(',');</span>

<span class="nc" id="L916">            buf.append(&quot;state=&quot;).append(Integer.toString(state)).append(',');</span>

<span class="nc" id="L918">            buf.append(&quot;font=&quot;).append(font).append(',');</span>

<span class="nc bnc" id="L920" title="All 2 branches missed.">            if (colors != null) {</span>
<span class="nc" id="L921">                buf.append(&quot;colors=&quot;).append(Arrays.asList(colors)).</span>
<span class="nc" id="L922">                    append(',');</span>
            }
<span class="nc" id="L924">            return buf.toString();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>