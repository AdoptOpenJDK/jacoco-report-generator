<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InputMethodEvent.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.event</a> &gt; <span class="el_source">InputMethodEvent.java</span></div><h1>InputMethodEvent.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.event;

import java.awt.AWTEvent;
import java.awt.Component;
import java.awt.EventQueue;
import java.awt.font.TextHitInfo;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.text.AttributedCharacterIterator;
import java.text.CharacterIterator;
import java.lang.annotation.Native;

/**
 * Input method events contain information about text that is being
 * composed using an input method. Whenever the text changes, the
 * input method sends an event. If the text component that's currently
 * using the input method is an active client, the event is dispatched
 * to that component. Otherwise, it is dispatched to a separate
 * composition window.
 *
 * &lt;p&gt;
 * The text included with the input method event consists of two parts:
 * committed text and composed text. Either part may be empty. The two
 * parts together replace any uncommitted composed text sent in previous events,
 * or the currently selected committed text.
 * Committed text should be integrated into the text component's persistent
 * data, it will not be sent again. Composed text may be sent repeatedly,
 * with changes to reflect the user's editing operations. Committed text
 * always precedes composed text.
 *
 * @author JavaSoft Asia/Pacific
 * @since 1.2
 */
public class InputMethodEvent extends AWTEvent {

    /**
     * Serial Version ID.
     */
    private static final long serialVersionUID = 4727190874778922661L;

    /**
     * Marks the first integer id for the range of input method event ids.
     */
    @Native public static final int INPUT_METHOD_FIRST = 1100;

    /**
     * The event type indicating changed input method text. This event is
     * generated by input methods while processing input.
     */
    @Native public static final int INPUT_METHOD_TEXT_CHANGED = INPUT_METHOD_FIRST;

    /**
     * The event type indicating a changed insertion point in input method text.
     * This event is
     * generated by input methods while processing input if only the caret changed.
     */
    @Native public static final int CARET_POSITION_CHANGED = INPUT_METHOD_FIRST + 1;

    /**
     * Marks the last integer id for the range of input method event ids.
     */
    @Native public static final int INPUT_METHOD_LAST = INPUT_METHOD_FIRST + 1;

    /**
     * The time stamp that indicates when the event was created.
     *
     * @serial
     * @see #getWhen
     * @since 1.4
     */
    long when;

    // Text object
    private transient AttributedCharacterIterator text;
    private transient int committedCharacterCount;
    private transient TextHitInfo caret;
    private transient TextHitInfo visiblePosition;

    /**
     * Constructs an &lt;code&gt;InputMethodEvent&lt;/code&gt; with the specified
     * source component, type, time, text, caret, and visiblePosition.
     * &lt;p&gt;
     * The offsets of caret and visiblePosition are relative to the current
     * composed text; that is, the composed text within &lt;code&gt;text&lt;/code&gt;
     * if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event,
     * the composed text within the &lt;code&gt;text&lt;/code&gt; of the
     * preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise.
     * &lt;p&gt;Note that passing in an invalid &lt;code&gt;id&lt;/code&gt; results in
     * unspecified behavior. This method throws an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     *
     * @param source the object where the event originated
     * @param id the event type
     * @param when a long integer that specifies the time the event occurred
     * @param text the combined committed and composed text,
     *      committed text first; must be &lt;code&gt;null&lt;/code&gt;
     *      when the event type is &lt;code&gt;CARET_POSITION_CHANGED&lt;/code&gt;;
     *      may be &lt;code&gt;null&lt;/code&gt; for
     *      &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; if there's no
     *      committed or composed text
     * @param committedCharacterCount the number of committed
     *      characters in the text
     * @param caret the caret (a.k.a. insertion point);
     *      &lt;code&gt;null&lt;/code&gt; if there's no caret within current
     *      composed text
     * @param visiblePosition the position that's most important
     *      to be visible; &lt;code&gt;null&lt;/code&gt; if there's no
     *      recommendation for a visible position within current
     *      composed text
     * @throws IllegalArgumentException if &lt;code&gt;id&lt;/code&gt; is not
     *      in the range
     *      &lt;code&gt;INPUT_METHOD_FIRST&lt;/code&gt;..&lt;code&gt;INPUT_METHOD_LAST&lt;/code&gt;;
     *      or if id is &lt;code&gt;CARET_POSITION_CHANGED&lt;/code&gt; and
     *      &lt;code&gt;text&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;;
     *      or if &lt;code&gt;committedCharacterCount&lt;/code&gt; is not in the range
     *      &lt;code&gt;0&lt;/code&gt;..&lt;code&gt;(text.getEndIndex() - text.getBeginIndex())&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;source&lt;/code&gt; is null
     *
     * @since 1.4
     */
    public InputMethodEvent(Component source, int id, long when,
            AttributedCharacterIterator text, int committedCharacterCount,
            TextHitInfo caret, TextHitInfo visiblePosition) {
<span class="nc" id="L150">        super(source, id);</span>
<span class="nc bnc" id="L151" title="All 4 branches missed.">        if (id &lt; INPUT_METHOD_FIRST || id &gt; INPUT_METHOD_LAST) {</span>
<span class="nc" id="L152">            throw new IllegalArgumentException(&quot;id outside of valid range&quot;);</span>
        }

<span class="nc bnc" id="L155" title="All 4 branches missed.">        if (id == CARET_POSITION_CHANGED &amp;&amp; text != null) {</span>
<span class="nc" id="L156">            throw new IllegalArgumentException(&quot;text must be null for CARET_POSITION_CHANGED&quot;);</span>
        }

<span class="nc" id="L159">        this.when = when;</span>
<span class="nc" id="L160">        this.text = text;</span>
<span class="nc" id="L161">        int textLength = 0;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (text != null) {</span>
<span class="nc" id="L163">            textLength = text.getEndIndex() - text.getBeginIndex();</span>
        }

<span class="nc bnc" id="L166" title="All 4 branches missed.">        if (committedCharacterCount &lt; 0 || committedCharacterCount &gt; textLength) {</span>
<span class="nc" id="L167">            throw new IllegalArgumentException(&quot;committedCharacterCount outside of valid range&quot;);</span>
        }
<span class="nc" id="L169">        this.committedCharacterCount = committedCharacterCount;</span>

<span class="nc" id="L171">        this.caret = caret;</span>
<span class="nc" id="L172">        this.visiblePosition = visiblePosition;</span>
<span class="nc" id="L173">   }</span>

    /**
     * Constructs an &lt;code&gt;InputMethodEvent&lt;/code&gt; with the specified
     * source component, type, text, caret, and visiblePosition.
     * &lt;p&gt;
     * The offsets of caret and visiblePosition are relative to the current
     * composed text; that is, the composed text within &lt;code&gt;text&lt;/code&gt;
     * if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event,
     * the composed text within the &lt;code&gt;text&lt;/code&gt; of the
     * preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise.
     * The time stamp for this event is initialized by invoking
     * {@link java.awt.EventQueue#getMostRecentEventTime()}.
     * &lt;p&gt;Note that passing in an invalid &lt;code&gt;id&lt;/code&gt; results in
     * unspecified behavior. This method throws an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     *
     * @param source the object where the event originated
     * @param id the event type
     * @param text the combined committed and composed text,
     *      committed text first; must be &lt;code&gt;null&lt;/code&gt;
     *      when the event type is &lt;code&gt;CARET_POSITION_CHANGED&lt;/code&gt;;
     *      may be &lt;code&gt;null&lt;/code&gt; for
     *      &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; if there's no
     *      committed or composed text
     * @param committedCharacterCount the number of committed
     *      characters in the text
     * @param caret the caret (a.k.a. insertion point);
     *      &lt;code&gt;null&lt;/code&gt; if there's no caret within current
     *      composed text
     * @param visiblePosition the position that's most important
     *      to be visible; &lt;code&gt;null&lt;/code&gt; if there's no
     *      recommendation for a visible position within current
     *      composed text
     * @throws IllegalArgumentException if &lt;code&gt;id&lt;/code&gt; is not
     *      in the range
     *      &lt;code&gt;INPUT_METHOD_FIRST&lt;/code&gt;..&lt;code&gt;INPUT_METHOD_LAST&lt;/code&gt;;
     *      or if id is &lt;code&gt;CARET_POSITION_CHANGED&lt;/code&gt; and
     *      &lt;code&gt;text&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;;
     *      or if &lt;code&gt;committedCharacterCount&lt;/code&gt; is not in the range
     *      &lt;code&gt;0&lt;/code&gt;..&lt;code&gt;(text.getEndIndex() - text.getBeginIndex())&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;source&lt;/code&gt; is null
     */
    public InputMethodEvent(Component source, int id,
            AttributedCharacterIterator text, int committedCharacterCount,
            TextHitInfo caret, TextHitInfo visiblePosition) {
<span class="nc" id="L220">        this(source, id, EventQueue.getMostRecentEventTime(), text,</span>
             committedCharacterCount, caret, visiblePosition);
<span class="nc" id="L222">    }</span>

    /**
     * Constructs an &lt;code&gt;InputMethodEvent&lt;/code&gt; with the
     * specified source component, type, caret, and visiblePosition.
     * The text is set to &lt;code&gt;null&lt;/code&gt;,
     * &lt;code&gt;committedCharacterCount&lt;/code&gt; to 0.
     * &lt;p&gt;
     * The offsets of &lt;code&gt;caret&lt;/code&gt; and &lt;code&gt;visiblePosition&lt;/code&gt;
     * are relative to the current composed text; that is,
     * the composed text within the &lt;code&gt;text&lt;/code&gt; of the
     * preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event if the
     * event being constructed as a &lt;code&gt;CARET_POSITION_CHANGED&lt;/code&gt; event.
     * For an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event without text,
     * &lt;code&gt;caret&lt;/code&gt; and &lt;code&gt;visiblePosition&lt;/code&gt; must be
     * &lt;code&gt;null&lt;/code&gt;.
     * The time stamp for this event is initialized by invoking
     * {@link java.awt.EventQueue#getMostRecentEventTime()}.
     * &lt;p&gt;Note that passing in an invalid &lt;code&gt;id&lt;/code&gt; results in
     * unspecified behavior. This method throws an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     *
     * @param source the object where the event originated
     * @param id the event type
     * @param caret the caret (a.k.a. insertion point);
     *      &lt;code&gt;null&lt;/code&gt; if there's no caret within current
     *      composed text
     * @param visiblePosition the position that's most important
     *      to be visible; &lt;code&gt;null&lt;/code&gt; if there's no
     *      recommendation for a visible position within current
     *      composed text
     * @throws IllegalArgumentException if &lt;code&gt;id&lt;/code&gt; is not
     *      in the range
     *      &lt;code&gt;INPUT_METHOD_FIRST&lt;/code&gt;..&lt;code&gt;INPUT_METHOD_LAST&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;source&lt;/code&gt; is null
     */
    public InputMethodEvent(Component source, int id, TextHitInfo caret,
            TextHitInfo visiblePosition) {
<span class="nc" id="L261">        this(source, id, EventQueue.getMostRecentEventTime(), null,</span>
             0, caret, visiblePosition);
<span class="nc" id="L263">    }</span>

    /**
     * Gets the combined committed and composed text.
     * Characters from index 0 to index &lt;code&gt;getCommittedCharacterCount() - 1&lt;/code&gt; are committed
     * text, the remaining characters are composed text.
     *
     * @return the text.
     * Always null for CARET_POSITION_CHANGED;
     * may be null for INPUT_METHOD_TEXT_CHANGED if there's no composed or committed text.
     */
    public AttributedCharacterIterator getText() {
<span class="nc" id="L275">        return text;</span>
    }

    /**
     * Gets the number of committed characters in the text.
     */
    public int getCommittedCharacterCount() {
<span class="nc" id="L282">        return committedCharacterCount;</span>
    }

    /**
     * Gets the caret.
     * &lt;p&gt;
     * The offset of the caret is relative to the current
     * composed text; that is, the composed text within getText()
     * if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event,
     * the composed text within getText() of the
     * preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise.
     *
     * @return the caret (a.k.a. insertion point).
     * Null if there's no caret within current composed text.
     */
    public TextHitInfo getCaret() {
<span class="nc" id="L298">        return caret;</span>
    }

    /**
     * Gets the position that's most important to be visible.
     * &lt;p&gt;
     * The offset of the visible position is relative to the current
     * composed text; that is, the composed text within getText()
     * if this is an &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event,
     * the composed text within getText() of the
     * preceding &lt;code&gt;INPUT_METHOD_TEXT_CHANGED&lt;/code&gt; event otherwise.
     *
     * @return the position that's most important to be visible.
     * Null if there's no recommendation for a visible position within current composed text.
     */
    public TextHitInfo getVisiblePosition() {
<span class="nc" id="L314">        return visiblePosition;</span>
    }

    /**
     * Consumes this event so that it will not be processed
     * in the default manner by the source which originated it.
     */
    public void consume() {
<span class="nc" id="L322">        consumed = true;</span>
<span class="nc" id="L323">    }</span>

    /**
     * Returns whether or not this event has been consumed.
     * @see #consume
     */
    public boolean isConsumed() {
<span class="nc" id="L330">        return consumed;</span>
    }

    /**
     * Returns the time stamp of when this event occurred.
     *
     * @return this event's timestamp
     * @since 1.4
     */
    public long getWhen() {
<span class="nc" id="L340">      return when;</span>
    }

    /**
     * Returns a parameter string identifying this event.
     * This method is useful for event-logging and for debugging.
     * It contains the event ID in text form, the characters of the
     * committed and composed text
     * separated by &quot;+&quot;, the number of committed characters,
     * the caret, and the visible position.
     *
     * @return a string identifying the event and its attributes
     */
    public String paramString() {
        String typeStr;
<span class="nc bnc" id="L355" title="All 3 branches missed.">        switch(id) {</span>
          case INPUT_METHOD_TEXT_CHANGED:
<span class="nc" id="L357">              typeStr = &quot;INPUT_METHOD_TEXT_CHANGED&quot;;</span>
<span class="nc" id="L358">              break;</span>
          case CARET_POSITION_CHANGED:
<span class="nc" id="L360">              typeStr = &quot;CARET_POSITION_CHANGED&quot;;</span>
<span class="nc" id="L361">              break;</span>
          default:
<span class="nc" id="L363">              typeStr = &quot;unknown type&quot;;</span>
        }

        String textString;
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L368">            textString = &quot;no text&quot;;</span>
        } else {
<span class="nc" id="L370">            StringBuilder textBuffer = new StringBuilder(&quot;\&quot;&quot;);</span>
<span class="nc" id="L371">            int committedCharacterCount = this.committedCharacterCount;</span>
<span class="nc" id="L372">            char c = text.first();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            while (committedCharacterCount-- &gt; 0) {</span>
<span class="nc" id="L374">                textBuffer.append(c);</span>
<span class="nc" id="L375">                c = text.next();</span>
            }
<span class="nc" id="L377">            textBuffer.append(&quot;\&quot; + \&quot;&quot;);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">            while (c != CharacterIterator.DONE) {</span>
<span class="nc" id="L379">                textBuffer.append(c);</span>
<span class="nc" id="L380">                c = text.next();</span>
            }
<span class="nc" id="L382">            textBuffer.append(&quot;\&quot;&quot;);</span>
<span class="nc" id="L383">            textString = textBuffer.toString();</span>
        }

<span class="nc" id="L386">        String countString = committedCharacterCount + &quot; characters committed&quot;;</span>

        String caretString;
<span class="nc bnc" id="L389" title="All 2 branches missed.">        if (caret == null) {</span>
<span class="nc" id="L390">            caretString = &quot;no caret&quot;;</span>
        } else {
<span class="nc" id="L392">            caretString = &quot;caret: &quot; + caret.toString();</span>
        }

        String visiblePositionString;
<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (visiblePosition == null) {</span>
<span class="nc" id="L397">            visiblePositionString = &quot;no visible position&quot;;</span>
        } else {
<span class="nc" id="L399">            visiblePositionString = &quot;visible position: &quot; + visiblePosition.toString();</span>
        }

<span class="nc" id="L402">        return typeStr + &quot;, &quot; + textString + &quot;, &quot; + countString + &quot;, &quot; + caretString + &quot;, &quot; + visiblePositionString;</span>
    }

    /**
     * Initializes the &lt;code&gt;when&lt;/code&gt; field if it is not present in the
     * object input stream. In that case, the field will be initialized by
     * invoking {@link java.awt.EventQueue#getMostRecentEventTime()}.
     */
    private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {
<span class="nc" id="L411">        s.defaultReadObject();</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (when == 0) {</span>
<span class="nc" id="L413">            when = EventQueue.getMostRecentEventTime();</span>
        }
<span class="nc" id="L415">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>