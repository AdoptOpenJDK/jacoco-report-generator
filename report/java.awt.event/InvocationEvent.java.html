<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>InvocationEvent.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.event</a> &gt; <span class="el_source">InvocationEvent.java</span></div><h1>InvocationEvent.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.event;

import sun.awt.AWTAccessor;

import java.awt.ActiveEvent;
import java.awt.AWTEvent;

/**
 * An event which executes the &lt;code&gt;run()&lt;/code&gt; method on a &lt;code&gt;Runnable
 * &lt;/code&gt; when dispatched by the AWT event dispatcher thread. This class can
 * be used as a reference implementation of &lt;code&gt;ActiveEvent&lt;/code&gt; rather
 * than declaring a new class and defining &lt;code&gt;dispatch()&lt;/code&gt;.&lt;p&gt;
 *
 * Instances of this class are placed on the &lt;code&gt;EventQueue&lt;/code&gt; by calls
 * to &lt;code&gt;invokeLater&lt;/code&gt; and &lt;code&gt;invokeAndWait&lt;/code&gt;. Client code
 * can use this fact to write replacement functions for &lt;code&gt;invokeLater
 * &lt;/code&gt; and &lt;code&gt;invokeAndWait&lt;/code&gt; without writing special-case code
 * in any &lt;code&gt;AWTEventListener&lt;/code&gt; objects.
 * &lt;p&gt;
 * An unspecified behavior will be caused if the {@code id} parameter
 * of any particular {@code InvocationEvent} instance is not
 * in the range from {@code INVOCATION_FIRST} to {@code INVOCATION_LAST}.
 *
 * @author      Fred Ecks
 * @author      David Mendenhall
 *
 * @see         java.awt.ActiveEvent
 * @see         java.awt.EventQueue#invokeLater
 * @see         java.awt.EventQueue#invokeAndWait
 * @see         AWTEventListener
 *
 * @since       1.2
 */
public class InvocationEvent extends AWTEvent implements ActiveEvent {

    static {
<span class="nc" id="L62">        AWTAccessor.setInvocationEventAccessor(new AWTAccessor.InvocationEventAccessor() {</span>
            @Override
            public void dispose(InvocationEvent invocationEvent) {
<span class="nc" id="L65">                invocationEvent.finishedDispatching(false);</span>
<span class="nc" id="L66">            }</span>
        });
<span class="nc" id="L68">    }</span>

    /**
     * Marks the first integer id for the range of invocation event ids.
     */
    public static final int INVOCATION_FIRST = 1200;

    /**
     * The default id for all InvocationEvents.
     */
    public static final int INVOCATION_DEFAULT = INVOCATION_FIRST;

    /**
     * Marks the last integer id for the range of invocation event ids.
     */
    public static final int INVOCATION_LAST = INVOCATION_DEFAULT;

    /**
     * The Runnable whose run() method will be called.
     */
    protected Runnable runnable;

    /**
     * The (potentially null) Object whose notifyAll() method will be called
     * immediately after the Runnable.run() method has returned or thrown an exception
     * or after the event was disposed.
     *
     * @see #isDispatched
     */
    protected volatile Object notifier;

    /**
     * The (potentially null) Runnable whose run() method will be called
     * immediately after the event was dispatched or disposed.
     *
     * @see #isDispatched
     * @since 1.8
     */
    private final Runnable listener;

    /**
     * Indicates whether the &lt;code&gt;run()&lt;/code&gt; method of the &lt;code&gt;runnable&lt;/code&gt;
     * was executed or not.
     *
     * @see #isDispatched
     * @since 1.7
     */
<span class="nc" id="L115">    private volatile boolean dispatched = false;</span>

    /**
     * Set to true if dispatch() catches Throwable and stores it in the
     * exception instance variable. If false, Throwables are propagated up
     * to the EventDispatchThread's dispatch loop.
     */
    protected boolean catchExceptions;

    /**
     * The (potentially null) Exception thrown during execution of the
     * Runnable.run() method. This variable will also be null if a particular
     * instance does not catch exceptions.
     */
<span class="nc" id="L129">    private Exception exception = null;</span>

    /**
     * The (potentially null) Throwable thrown during execution of the
     * Runnable.run() method. This variable will also be null if a particular
     * instance does not catch exceptions.
     */
<span class="nc" id="L136">    private Throwable throwable = null;</span>

    /**
     * The timestamp of when this event occurred.
     *
     * @serial
     * @see #getWhen
     */
    private long when;

    /*
     * JDK 1.1 serialVersionUID.
     */
    private static final long serialVersionUID = 436056344909459450L;

    /**
     * Constructs an &lt;code&gt;InvocationEvent&lt;/code&gt; with the specified
     * source which will execute the runnable's &lt;code&gt;run&lt;/code&gt;
     * method when dispatched.
     * &lt;p&gt;This is a convenience constructor.  An invocation of the form
     * &lt;tt&gt;InvocationEvent(source, runnable)&lt;/tt&gt;
     * behaves in exactly the same way as the invocation of
     * &lt;tt&gt;{@link #InvocationEvent(Object, Runnable, Object, boolean) InvocationEvent}(source, runnable, null, false)&lt;/tt&gt;.
     * &lt;p&gt; This method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * if &lt;code&gt;source&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     *
     * @param source    The &lt;code&gt;Object&lt;/code&gt; that originated the event
     * @param runnable  The &lt;code&gt;Runnable&lt;/code&gt; whose &lt;code&gt;run&lt;/code&gt;
     *                  method will be executed
     * @throws IllegalArgumentException if &lt;code&gt;source&lt;/code&gt; is null
     *
     * @see #getSource()
     * @see #InvocationEvent(Object, Runnable, Object, boolean)
     */
    public InvocationEvent(Object source, Runnable runnable) {
<span class="nc" id="L171">        this(source, INVOCATION_DEFAULT, runnable, null, null, false);</span>
<span class="nc" id="L172">    }</span>

    /**
     * Constructs an &lt;code&gt;InvocationEvent&lt;/code&gt; with the specified
     * source which will execute the runnable's &lt;code&gt;run&lt;/code&gt;
     * method when dispatched.  If notifier is non-&lt;code&gt;null&lt;/code&gt;,
     * &lt;code&gt;notifyAll()&lt;/code&gt; will be called on it
     * immediately after &lt;code&gt;run&lt;/code&gt; has returned or thrown an exception.
     * &lt;p&gt;An invocation of the form &lt;tt&gt;InvocationEvent(source,
     * runnable, notifier, catchThrowables)&lt;/tt&gt;
     * behaves in exactly the same way as the invocation of
     * &lt;tt&gt;{@link #InvocationEvent(Object, int, Runnable, Object, boolean) InvocationEvent}(source, InvocationEvent.INVOCATION_DEFAULT, runnable, notifier, catchThrowables)&lt;/tt&gt;.
     * &lt;p&gt;This method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * if &lt;code&gt;source&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     *
     * @param source            The &lt;code&gt;Object&lt;/code&gt; that originated
     *                          the event
     * @param runnable          The &lt;code&gt;Runnable&lt;/code&gt; whose
     *                          &lt;code&gt;run&lt;/code&gt; method will be
     *                          executed
     * @param notifier          The {@code Object} whose &lt;code&gt;notifyAll&lt;/code&gt;
     *                          method will be called after
     *                          &lt;code&gt;Runnable.run&lt;/code&gt; has returned or
     *                          thrown an exception or after the event was
     *                          disposed
     * @param catchThrowables   Specifies whether &lt;code&gt;dispatch&lt;/code&gt;
     *                          should catch Throwable when executing
     *                          the &lt;code&gt;Runnable&lt;/code&gt;'s &lt;code&gt;run&lt;/code&gt;
     *                          method, or should instead propagate those
     *                          Throwables to the EventDispatchThread's
     *                          dispatch loop
     * @throws IllegalArgumentException if &lt;code&gt;source&lt;/code&gt; is null
     *
     * @see #getSource()
     * @see     #InvocationEvent(Object, int, Runnable, Object, boolean)
     */
    public InvocationEvent(Object source, Runnable runnable, Object notifier,
                           boolean catchThrowables) {
<span class="nc" id="L210">        this(source, INVOCATION_DEFAULT, runnable, notifier, null, catchThrowables);</span>
<span class="nc" id="L211">    }</span>

    /**
     * Constructs an &lt;code&gt;InvocationEvent&lt;/code&gt; with the specified
     * source which will execute the runnable's &lt;code&gt;run&lt;/code&gt;
     * method when dispatched.  If listener is non-&lt;code&gt;null&lt;/code&gt;,
     * &lt;code&gt;listener.run()&lt;/code&gt; will be called immediately after
     * &lt;code&gt;run&lt;/code&gt; has returned, thrown an exception or the event
     * was disposed.
     * &lt;p&gt;This method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * if &lt;code&gt;source&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     *
     * @param source            The &lt;code&gt;Object&lt;/code&gt; that originated
     *                          the event
     * @param runnable          The &lt;code&gt;Runnable&lt;/code&gt; whose
     *                          &lt;code&gt;run&lt;/code&gt; method will be
     *                          executed
     * @param listener          The &lt;code&gt;Runnable&lt;/code&gt;Runnable whose
     *                          &lt;code&gt;run()&lt;/code&gt; method will be called
     *                          after the {@code InvocationEvent}
     *                          was dispatched or disposed
     * @param catchThrowables   Specifies whether &lt;code&gt;dispatch&lt;/code&gt;
     *                          should catch Throwable when executing
     *                          the &lt;code&gt;Runnable&lt;/code&gt;'s &lt;code&gt;run&lt;/code&gt;
     *                          method, or should instead propagate those
     *                          Throwables to the EventDispatchThread's
     *                          dispatch loop
     * @throws IllegalArgumentException if &lt;code&gt;source&lt;/code&gt; is null
     */
    public InvocationEvent(Object source, Runnable runnable, Runnable listener,
                           boolean catchThrowables)  {
<span class="nc" id="L242">        this(source, INVOCATION_DEFAULT, runnable, null, listener, catchThrowables);</span>
<span class="nc" id="L243">    }</span>

    /**
     * Constructs an &lt;code&gt;InvocationEvent&lt;/code&gt; with the specified
     * source and ID which will execute the runnable's &lt;code&gt;run&lt;/code&gt;
     * method when dispatched.  If notifier is non-&lt;code&gt;null&lt;/code&gt;,
     * &lt;code&gt;notifyAll&lt;/code&gt; will be called on it immediately after
     * &lt;code&gt;run&lt;/code&gt; has returned or thrown an exception.
     * &lt;p&gt;This method throws an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     *
     * @param source            The &lt;code&gt;Object&lt;/code&gt; that originated
     *                          the event
     * @param id     An integer indicating the type of event.
     *                     For information on allowable values, see
     *                     the class description for {@link InvocationEvent}
     * @param runnable          The &lt;code&gt;Runnable&lt;/code&gt; whose
     *                          &lt;code&gt;run&lt;/code&gt; method will be executed
     * @param notifier          The &lt;code&gt;Object&lt;/code&gt; whose &lt;code&gt;notifyAll&lt;/code&gt;
     *                          method will be called after
     *                          &lt;code&gt;Runnable.run&lt;/code&gt; has returned or
     *                          thrown an exception or after the event was
     *                          disposed
     * @param catchThrowables   Specifies whether &lt;code&gt;dispatch&lt;/code&gt;
     *                          should catch Throwable when executing the
     *                          &lt;code&gt;Runnable&lt;/code&gt;'s &lt;code&gt;run&lt;/code&gt;
     *                          method, or should instead propagate those
     *                          Throwables to the EventDispatchThread's
     *                          dispatch loop
     * @throws IllegalArgumentException if &lt;code&gt;source&lt;/code&gt; is null
     * @see #getSource()
     * @see #getID()
     */
    protected InvocationEvent(Object source, int id, Runnable runnable,
                              Object notifier, boolean catchThrowables) {
<span class="nc" id="L279">        this(source, id, runnable, notifier, null, catchThrowables);</span>
<span class="nc" id="L280">    }</span>

    private InvocationEvent(Object source, int id, Runnable runnable,
                            Object notifier, Runnable listener, boolean catchThrowables) {
<span class="nc" id="L284">        super(source, id);</span>
<span class="nc" id="L285">        this.runnable = runnable;</span>
<span class="nc" id="L286">        this.notifier = notifier;</span>
<span class="nc" id="L287">        this.listener = listener;</span>
<span class="nc" id="L288">        this.catchExceptions = catchThrowables;</span>
<span class="nc" id="L289">        this.when = System.currentTimeMillis();</span>
<span class="nc" id="L290">    }</span>
    /**
     * Executes the Runnable's &lt;code&gt;run()&lt;/code&gt; method and notifies the
     * notifier (if any) when &lt;code&gt;run()&lt;/code&gt; has returned or thrown an exception.
     *
     * @see #isDispatched
     */
    public void dispatch() {
        try {
<span class="nc bnc" id="L299" title="All 2 branches missed.">            if (catchExceptions) {</span>
                try {
<span class="nc" id="L301">                    runnable.run();</span>
                }
<span class="nc" id="L303">                catch (Throwable t) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                    if (t instanceof Exception) {</span>
<span class="nc" id="L305">                        exception = (Exception) t;</span>
                    }
<span class="nc" id="L307">                    throwable = t;</span>
<span class="nc" id="L308">                }</span>
            }
            else {
<span class="nc" id="L311">                runnable.run();</span>
            }
        } finally {
<span class="nc" id="L314">            finishedDispatching(true);</span>
<span class="nc" id="L315">        }</span>
<span class="nc" id="L316">    }</span>

    /**
     * Returns any Exception caught while executing the Runnable's &lt;code&gt;run()
     * &lt;/code&gt; method.
     *
     * @return  A reference to the Exception if one was thrown; null if no
     *          Exception was thrown or if this InvocationEvent does not
     *          catch exceptions
     */
    public Exception getException() {
<span class="nc bnc" id="L327" title="All 2 branches missed.">        return (catchExceptions) ? exception : null;</span>
    }

    /**
     * Returns any Throwable caught while executing the Runnable's &lt;code&gt;run()
     * &lt;/code&gt; method.
     *
     * @return  A reference to the Throwable if one was thrown; null if no
     *          Throwable was thrown or if this InvocationEvent does not
     *          catch Throwables
     * @since 1.5
     */
    public Throwable getThrowable() {
<span class="nc bnc" id="L340" title="All 2 branches missed.">        return (catchExceptions) ? throwable : null;</span>
    }

    /**
     * Returns the timestamp of when this event occurred.
     *
     * @return this event's timestamp
     * @since 1.4
     */
    public long getWhen() {
<span class="nc" id="L350">        return when;</span>
    }

    /**
     * Returns {@code true} if the event is dispatched or any exception is
     * thrown while dispatching, {@code false} otherwise. The method should
     * be called by a waiting thread that calls the {@code notifier.wait()} method.
     * Since spurious wakeups are possible (as explained in {@link Object#wait()}),
     * this method should be used in a waiting loop to ensure that the event
     * got dispatched:
     * &lt;pre&gt;
     *     while (!event.isDispatched()) {
     *         notifier.wait();
     *     }
     * &lt;/pre&gt;
     * If the waiting thread wakes up without dispatching the event,
     * the {@code isDispatched()} method returns {@code false}, and
     * the {@code while} loop executes once more, thus, causing
     * the awakened thread to revert to the waiting mode.
     * &lt;p&gt;
     * If the {@code notifier.notifyAll()} happens before the waiting thread
     * enters the {@code notifier.wait()} method, the {@code while} loop ensures
     * that the waiting thread will not enter the {@code notifier.wait()} method.
     * Otherwise, there is no guarantee that the waiting thread will ever be woken
     * from the wait.
     *
     * @return {@code true} if the event has been dispatched, or any exception
     * has been thrown while dispatching, {@code false} otherwise
     * @see #dispatch
     * @see #notifier
     * @see #catchExceptions
     * @since 1.7
     */
    public boolean isDispatched() {
<span class="nc" id="L384">        return dispatched;</span>
    }

    /**
     * Called when the event was dispatched or disposed
     * @param dispatched true if the event was dispatched
     *                   false if the event was disposed
     */
    private void finishedDispatching(boolean dispatched) {
<span class="nc" id="L393">        this.dispatched = dispatched;</span>

<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (notifier != null) {</span>
<span class="nc" id="L396">            synchronized (notifier) {</span>
<span class="nc" id="L397">                notifier.notifyAll();</span>
<span class="nc" id="L398">            }</span>
        }

<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L402">            listener.run();</span>
        }
<span class="nc" id="L404">    }</span>

    /**
     * Returns a parameter string identifying this event.
     * This method is useful for event-logging and for debugging.
     *
     * @return  A string identifying the event and its attributes
     */
    public String paramString() {
        String typeStr;
<span class="nc bnc" id="L414" title="All 2 branches missed.">        switch(id) {</span>
            case INVOCATION_DEFAULT:
<span class="nc" id="L416">                typeStr = &quot;INVOCATION_DEFAULT&quot;;</span>
<span class="nc" id="L417">                break;</span>
            default:
<span class="nc" id="L419">                typeStr = &quot;unknown type&quot;;</span>
        }
<span class="nc" id="L421">        return typeStr + &quot;,runnable=&quot; + runnable + &quot;,notifier=&quot; + notifier +</span>
            &quot;,catchExceptions=&quot; + catchExceptions + &quot;,when=&quot; + when;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>