<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Timer.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.management.timer</a> &gt; <span class="el_source">Timer.java</span></div><h1>Timer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management.timer;

import static com.sun.jmx.defaults.JmxProperties.TIMER_LOGGER;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.Vector;
import java.util.logging.Level;

// jmx imports
//
import javax.management.InstanceNotFoundException;
import javax.management.MBeanNotificationInfo;
import javax.management.MBeanRegistration;
import javax.management.MBeanServer;
import javax.management.NotificationBroadcasterSupport;
import javax.management.ObjectName;

/**
 *
 * Provides the implementation of the timer MBean.
 * The timer MBean sends out an alarm at a specified time
 * that wakes up all the listeners registered to receive timer notifications.
 * &lt;P&gt;
 *
 * This class manages a list of dated timer notifications.
 * A method allows users to add/remove as many notifications as required.
 * When a timer notification is emitted by the timer and becomes obsolete,
 * it is automatically removed from the list of timer notifications.
 * &lt;BR&gt;Additional timer notifications can be added into regularly repeating notifications.
 * &lt;P&gt;
 *
 * Note:
 * &lt;OL&gt;
 * &lt;LI&gt;When sending timer notifications, the timer updates the notification sequence number
 * irrespective of the notification type.
 * &lt;LI&gt;The timer service relies on the system date of the host where the &lt;CODE&gt;Timer&lt;/CODE&gt; class is loaded.
 * Listeners may receive untimely notifications
 * if their host has a different system date.
 * To avoid such problems, synchronize the system date of all host machines where timing is needed.
 * &lt;LI&gt;The default behavior for periodic notifications is &lt;i&gt;fixed-delay execution&lt;/i&gt;, as
 *     specified in {@link java.util.Timer}. In order to use &lt;i&gt;fixed-rate execution&lt;/i&gt;, use the
 *     overloaded {@link #addNotification(String, String, Object, Date, long, long, boolean)} method.
 * &lt;LI&gt;Notification listeners are potentially all executed in the same
 * thread.  Therefore, they should execute rapidly to avoid holding up
 * other listeners or perturbing the regularity of fixed-delay
 * executions.  See {@link NotificationBroadcasterSupport}.
 * &lt;/OL&gt;
 *
 * @since 1.5
 */
public class Timer extends NotificationBroadcasterSupport
        implements TimerMBean, MBeanRegistration {


    /*
     * ------------------------------------------
     *  PUBLIC VARIABLES
     * ------------------------------------------
     */

    /**
     * Number of milliseconds in one second.
     * Useful constant for the &lt;CODE&gt;addNotification&lt;/CODE&gt; method.
     */
    public static final long ONE_SECOND = 1000;

    /**
     * Number of milliseconds in one minute.
     * Useful constant for the &lt;CODE&gt;addNotification&lt;/CODE&gt; method.
     */
    public static final long ONE_MINUTE = 60*ONE_SECOND;

    /**
     * Number of milliseconds in one hour.
     * Useful constant for the &lt;CODE&gt;addNotification&lt;/CODE&gt; method.
     */
    public static final long ONE_HOUR   = 60*ONE_MINUTE;

    /**
     * Number of milliseconds in one day.
     * Useful constant for the &lt;CODE&gt;addNotification&lt;/CODE&gt; method.
     */
    public static final long ONE_DAY    = 24*ONE_HOUR;

    /**
     * Number of milliseconds in one week.
     * Useful constant for the &lt;CODE&gt;addNotification&lt;/CODE&gt; method.
     */
    public static final long ONE_WEEK   = 7*ONE_DAY;

    /*
     * ------------------------------------------
     *  PRIVATE VARIABLES
     * ------------------------------------------
     */

    /**
     * Table containing all the timer notifications of this timer,
     * with the associated date, period and number of occurrences.
     */
<span class="nc" id="L130">    final private Map&lt;Integer,Object[]&gt; timerTable =</span>
        new HashMap&lt;&gt;();

    /**
     * Past notifications sending on/off flag value.
     * This attribute is used to specify if the timer has to send past notifications after start.
     * &lt;BR&gt;The default value is set to &lt;CODE&gt;false&lt;/CODE&gt;.
     */
<span class="nc" id="L138">    private boolean sendPastNotifications = false;</span>

    /**
     * Timer state.
     * The default value is set to &lt;CODE&gt;false&lt;/CODE&gt;.
     */
<span class="nc" id="L144">    private transient boolean isActive = false;</span>

    /**
     * Timer sequence number.
     * The default value is set to 0.
     */
<span class="nc" id="L150">    private transient long sequenceNumber = 0;</span>

    // Flags needed to keep the indexes of the objects in the array.
    //
    private static final int TIMER_NOTIF_INDEX     = 0;
    private static final int TIMER_DATE_INDEX      = 1;
    private static final int TIMER_PERIOD_INDEX    = 2;
    private static final int TIMER_NB_OCCUR_INDEX  = 3;
    private static final int ALARM_CLOCK_INDEX     = 4;
    private static final int FIXED_RATE_INDEX      = 5;

    /**
     * The notification counter ID.
     * Used to keep the max key value inserted into the timer table.
     */
<span class="nc" id="L165">    volatile private int counterID = 0;</span>

    private java.util.Timer timer;

    /*
     * ------------------------------------------
     *  CONSTRUCTORS
     * ------------------------------------------
     */

    /**
     * Default constructor.
     */
<span class="nc" id="L178">    public Timer() {</span>
<span class="nc" id="L179">    }</span>

    /*
     * ------------------------------------------
     *  PUBLIC METHODS
     * ------------------------------------------
     */

    /**
     * Allows the timer MBean to perform any operations it needs before being registered
     * in the MBean server.
     * &lt;P&gt;
     * Not used in this context.
     *
     * @param server The MBean server in which the timer MBean will be registered.
     * @param name The object name of the timer MBean.
     *
     * @return The name of the timer MBean registered.
     *
     * @exception java.lang.Exception
     */
    public ObjectName preRegister(MBeanServer server, ObjectName name)
        throws java.lang.Exception {
<span class="nc" id="L202">        return name;</span>
    }

    /**
     * Allows the timer MBean to perform any operations needed after having been
     * registered in the MBean server or after the registration has failed.
     * &lt;P&gt;
     * Not used in this context.
     */
    public void postRegister (Boolean registrationDone) {
<span class="nc" id="L212">    }</span>

    /**
     * Allows the timer MBean to perform any operations it needs before being unregistered
     * by the MBean server.
     * &lt;P&gt;
     * Stops the timer.
     *
     * @exception java.lang.Exception
     */
    public void preDeregister() throws java.lang.Exception {

<span class="nc" id="L224">        TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                &quot;preDeregister&quot;, &quot;stop the timer&quot;);

        // Stop the timer.
        //
<span class="nc" id="L229">        stop();</span>
<span class="nc" id="L230">    }</span>

    /**
     * Allows the timer MBean to perform any operations needed after having been
     * unregistered by the MBean server.
     * &lt;P&gt;
     * Not used in this context.
     */
    public void postDeregister() {
<span class="nc" id="L239">    }</span>

    /*
     * This overrides the method in NotificationBroadcasterSupport.
     * Return the MBeanNotificationInfo[] array for this MBean.
     * The returned array has one element to indicate that the MBean
     * can emit TimerNotification.  The array of type strings
     * associated with this entry is a snapshot of the current types
     * that were given to addNotification.
     */
    public synchronized MBeanNotificationInfo[] getNotificationInfo() {
<span class="nc" id="L250">        Set&lt;String&gt; notifTypes = new TreeSet&lt;String&gt;();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">        for (Object[] entry : timerTable.values()) {</span>
<span class="nc" id="L252">            TimerNotification notif = (TimerNotification)</span>
                entry[TIMER_NOTIF_INDEX];
<span class="nc" id="L254">            notifTypes.add(notif.getType());</span>
<span class="nc" id="L255">        }</span>
<span class="nc" id="L256">        String[] notifTypesArray =</span>
<span class="nc" id="L257">            notifTypes.toArray(new String[0]);</span>
<span class="nc" id="L258">        return new MBeanNotificationInfo[] {</span>
            new MBeanNotificationInfo(notifTypesArray,
<span class="nc" id="L260">                                      TimerNotification.class.getName(),</span>
                                      &quot;Notification sent by Timer MBean&quot;)
        };
    }

    /**
     * Starts the timer.
     * &lt;P&gt;
     * If there is one or more timer notifications before the time in the list of notifications, the notification
     * is sent according to the &lt;CODE&gt;sendPastNotifications&lt;/CODE&gt; flag and then, updated
     * according to its period and remaining number of occurrences.
     * If the timer notification date remains earlier than the current date, this notification is just removed
     * from the list of notifications.
     */
    public synchronized void start() {

<span class="nc" id="L276">        TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                &quot;start&quot;, &quot;starting the timer&quot;);

        // Start the TimerAlarmClock.
        //
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (isActive == false) {</span>

<span class="nc" id="L283">            timer = new java.util.Timer();</span>

            TimerAlarmClock alarmClock;
            Date date;

<span class="nc" id="L288">            Date currentDate = new Date();</span>

            // Send or not past notifications depending on the flag.
            // Update the date and the number of occurrences of past notifications
            // to make them later than the current date.
            //
<span class="nc" id="L294">            sendPastNotifications(currentDate, sendPastNotifications);</span>

            // Update and start all the TimerAlarmClocks.
            // Here, all the notifications in the timer table are later than the current date.
            //
<span class="nc bnc" id="L299" title="All 2 branches missed.">            for (Object[] obj : timerTable.values()) {</span>

                // Retrieve the date notification and the TimerAlarmClock.
                //
<span class="nc" id="L303">                date = (Date)obj[TIMER_DATE_INDEX];</span>

                // Update all the TimerAlarmClock timeouts and start them.
                //
<span class="nc" id="L307">                boolean fixedRate = ((Boolean)obj[FIXED_RATE_INDEX]).booleanValue();</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">                if (fixedRate)</span>
                {
<span class="nc" id="L310">                  alarmClock = new TimerAlarmClock(this, date);</span>
<span class="nc" id="L311">                  obj[ALARM_CLOCK_INDEX] = (Object)alarmClock;</span>
<span class="nc" id="L312">                  timer.schedule(alarmClock, alarmClock.next);</span>
                }
                else
                {
<span class="nc" id="L316">                  alarmClock = new TimerAlarmClock(this, (date.getTime() - currentDate.getTime()));</span>
<span class="nc" id="L317">                  obj[ALARM_CLOCK_INDEX] = (Object)alarmClock;</span>
<span class="nc" id="L318">                  timer.schedule(alarmClock, alarmClock.timeout);</span>
                }
<span class="nc" id="L320">            }</span>

            // Set the state to ON.
            //
<span class="nc" id="L324">            isActive = true;</span>

<span class="nc" id="L326">            TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                    &quot;start&quot;, &quot;timer started&quot;);
<span class="nc" id="L328">        } else {</span>
<span class="nc" id="L329">            TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                    &quot;start&quot;, &quot;the timer is already activated&quot;);
        }
<span class="nc" id="L332">    }</span>

    /**
     * Stops the timer.
     */
    public synchronized void stop() {

<span class="nc" id="L339">        TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                &quot;stop&quot;, &quot;stopping the timer&quot;);

        // Stop the TimerAlarmClock.
        //
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (isActive == true) {</span>

<span class="nc bnc" id="L346" title="All 2 branches missed.">            for (Object[] obj : timerTable.values()) {</span>

                // Stop all the TimerAlarmClock.
                //
<span class="nc" id="L350">                TimerAlarmClock alarmClock = (TimerAlarmClock)obj[ALARM_CLOCK_INDEX];</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                if (alarmClock != null) {</span>
//                     alarmClock.interrupt();
//                     try {
//                         // Wait until the thread die.
//                         //
//                         alarmClock.join();
//                     } catch (InterruptedException ex) {
//                         // Ignore...
//                     }
//                     // Remove the reference on the TimerAlarmClock.
//                     //

<span class="nc" id="L363">                    alarmClock.cancel();</span>
                }
<span class="nc" id="L365">            }</span>

<span class="nc" id="L367">            timer.cancel();</span>

            // Set the state to OFF.
            //
<span class="nc" id="L371">            isActive = false;</span>

<span class="nc" id="L373">            TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                    &quot;stop&quot;, &quot;timer stopped&quot;);
        } else {
<span class="nc" id="L376">            TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                    &quot;stop&quot;, &quot;the timer is already deactivated&quot;);
        }
<span class="nc" id="L379">    }</span>

    /**
     * Creates a new timer notification with the specified &lt;CODE&gt;type&lt;/CODE&gt;, &lt;CODE&gt;message&lt;/CODE&gt;
     * and &lt;CODE&gt;userData&lt;/CODE&gt; and inserts it into the list of notifications with a given date,
     * period and number of occurrences.
     * &lt;P&gt;
     * If the timer notification to be inserted has a date that is before the current date,
     * the method behaves as if the specified date were the current date. &lt;BR&gt;
     * For once-off notifications, the notification is delivered immediately. &lt;BR&gt;
     * For periodic notifications, the first notification is delivered immediately and the
     * subsequent ones are spaced as specified by the period parameter.
     * &lt;P&gt;
     * Note that once the timer notification has been added into the list of notifications,
     * its associated date, period and number of occurrences cannot be updated.
     * &lt;P&gt;
     * In the case of a periodic notification, the value of parameter &lt;i&gt;fixedRate&lt;/i&gt; is used to
     * specify the execution scheme, as specified in {@link java.util.Timer}.
     *
     * @param type The timer notification type.
     * @param message The timer notification detailed message.
     * @param userData The timer notification user data object.
     * @param date The date when the notification occurs.
     * @param period The period of the timer notification (in milliseconds).
     * @param nbOccurences The total number the timer notification will be emitted.
     * @param fixedRate If &lt;code&gt;true&lt;/code&gt; and if the notification is periodic, the notification
     *                  is scheduled with a &lt;i&gt;fixed-rate&lt;/i&gt; execution scheme. If
     *                  &lt;code&gt;false&lt;/code&gt; and if the notification is periodic, the notification
     *                  is scheduled with a &lt;i&gt;fixed-delay&lt;/i&gt; execution scheme. Ignored if the
     *                  notification is not periodic.
     *
     * @return The identifier of the new created timer notification.
     *
     * @exception java.lang.IllegalArgumentException The date is {@code null} or
     * the period or the number of occurrences is negative.
     *
     * @see #addNotification(String, String, Object, Date, long, long)
     */
// NPCTE fix for bugId 4464388, esc 0,  MR, to be added after modification of jmx spec
//  public synchronized Integer addNotification(String type, String message, Serializable userData,
//                                                Date date, long period, long nbOccurences)
// end of NPCTE fix for bugId 4464388

    public synchronized Integer addNotification(String type, String message, Object userData,
                                                Date date, long period, long nbOccurences, boolean fixedRate)
        throws java.lang.IllegalArgumentException {

<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (date == null) {</span>
<span class="nc" id="L427">            throw new java.lang.IllegalArgumentException(&quot;Timer notification date cannot be null.&quot;);</span>
        }

        // Check that all the timer notification attributes are valid.
        //

        // Invalid timer period value exception:
        // Check that the period and the nbOccurences are POSITIVE VALUES.
        //
<span class="nc bnc" id="L436" title="All 4 branches missed.">        if ((period &lt; 0) || (nbOccurences &lt; 0)) {</span>
<span class="nc" id="L437">            throw new java.lang.IllegalArgumentException(&quot;Negative values for the periodicity&quot;);</span>
        }

<span class="nc" id="L440">        Date currentDate = new Date();</span>

        // Update the date if it is before the current date.
        //
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (currentDate.after(date)) {</span>

<span class="nc" id="L446">            date.setTime(currentDate.getTime());</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            if (TIMER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L448">                TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                        &quot;addNotification&quot;,
                        &quot;update timer notification to add with:&quot; +
                        &quot;\n\tNotification date = &quot; + date);
            }
        }

        // Create and add the timer notification into the timer table.
        //
<span class="nc" id="L457">        Integer notifID = Integer.valueOf(++counterID);</span>

        // The sequenceNumber and the timeStamp attributes are updated
        // when the notification is emitted by the timer.
        //
<span class="nc" id="L462">        TimerNotification notif = new TimerNotification(type, this, 0, 0, message, notifID);</span>
<span class="nc" id="L463">        notif.setUserData(userData);</span>

<span class="nc" id="L465">        Object[] obj = new Object[6];</span>

        TimerAlarmClock alarmClock;
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (fixedRate)</span>
        {
<span class="nc" id="L470">          alarmClock = new TimerAlarmClock(this, date);</span>
        }
        else
        {
<span class="nc" id="L474">          alarmClock = new TimerAlarmClock(this, (date.getTime() - currentDate.getTime()));</span>
        }

        // Fix bug 00417.B
        // The date registered into the timer is a clone from the date parameter.
        //
<span class="nc" id="L480">        Date d = new Date(date.getTime());</span>

<span class="nc" id="L482">        obj[TIMER_NOTIF_INDEX] = (Object)notif;</span>
<span class="nc" id="L483">        obj[TIMER_DATE_INDEX] = (Object)d;</span>
<span class="nc" id="L484">        obj[TIMER_PERIOD_INDEX] = (Object) period;</span>
<span class="nc" id="L485">        obj[TIMER_NB_OCCUR_INDEX] = (Object) nbOccurences;</span>
<span class="nc" id="L486">        obj[ALARM_CLOCK_INDEX] = (Object)alarmClock;</span>
<span class="nc" id="L487">        obj[FIXED_RATE_INDEX] = Boolean.valueOf(fixedRate);</span>

<span class="nc bnc" id="L489" title="All 2 branches missed.">        if (TIMER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L490">            StringBuilder strb = new StringBuilder()</span>
<span class="nc" id="L491">            .append(&quot;adding timer notification:\n\t&quot;)</span>
<span class="nc" id="L492">            .append(&quot;Notification source = &quot;)</span>
<span class="nc" id="L493">            .append(notif.getSource())</span>
<span class="nc" id="L494">            .append(&quot;\n\tNotification type = &quot;)</span>
<span class="nc" id="L495">            .append(notif.getType())</span>
<span class="nc" id="L496">            .append(&quot;\n\tNotification ID = &quot;)</span>
<span class="nc" id="L497">            .append(notifID)</span>
<span class="nc" id="L498">            .append(&quot;\n\tNotification date = &quot;)</span>
<span class="nc" id="L499">            .append(d)</span>
<span class="nc" id="L500">            .append(&quot;\n\tNotification period = &quot;)</span>
<span class="nc" id="L501">            .append(period)</span>
<span class="nc" id="L502">            .append(&quot;\n\tNotification nb of occurrences = &quot;)</span>
<span class="nc" id="L503">            .append(nbOccurences)</span>
<span class="nc" id="L504">            .append(&quot;\n\tNotification executes at fixed rate = &quot;)</span>
<span class="nc" id="L505">            .append(fixedRate);</span>
<span class="nc" id="L506">            TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
<span class="nc" id="L507">                    &quot;addNotification&quot;, strb.toString());</span>
        }

<span class="nc" id="L510">        timerTable.put(notifID, obj);</span>

        // Update and start the TimerAlarmClock.
        //
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (isActive == true) {</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">          if (fixedRate)</span>
          {
<span class="nc" id="L517">            timer.schedule(alarmClock, alarmClock.next);</span>
          }
          else
          {
<span class="nc" id="L521">            timer.schedule(alarmClock, alarmClock.timeout);</span>
          }
        }

<span class="nc" id="L525">        TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                &quot;addNotification&quot;, &quot;timer notification added&quot;);
<span class="nc" id="L527">        return notifID;</span>
    }

    /**
     * Creates a new timer notification with the specified &lt;CODE&gt;type&lt;/CODE&gt;, &lt;CODE&gt;message&lt;/CODE&gt;
     * and &lt;CODE&gt;userData&lt;/CODE&gt; and inserts it into the list of notifications with a given date,
     * period and number of occurrences.
     * &lt;P&gt;
     * If the timer notification to be inserted has a date that is before the current date,
     * the method behaves as if the specified date were the current date. &lt;BR&gt;
     * For once-off notifications, the notification is delivered immediately. &lt;BR&gt;
     * For periodic notifications, the first notification is delivered immediately and the
     * subsequent ones are spaced as specified by the period parameter.
     * &lt;P&gt;
     * Note that once the timer notification has been added into the list of notifications,
     * its associated date, period and number of occurrences cannot be updated.
     * &lt;P&gt;
     * In the case of a periodic notification, uses a &lt;i&gt;fixed-delay&lt;/i&gt; execution scheme, as specified in
     * {@link java.util.Timer}. In order to use a &lt;i&gt;fixed-rate&lt;/i&gt; execution scheme, use
     * {@link #addNotification(String, String, Object, Date, long, long, boolean)} instead.
     *
     * @param type The timer notification type.
     * @param message The timer notification detailed message.
     * @param userData The timer notification user data object.
     * @param date The date when the notification occurs.
     * @param period The period of the timer notification (in milliseconds).
     * @param nbOccurences The total number the timer notification will be emitted.
     *
     * @return The identifier of the new created timer notification.
     *
     * @exception java.lang.IllegalArgumentException The date is {@code null} or
     * the period or the number of occurrences is negative.
     *
     * @see #addNotification(String, String, Object, Date, long, long, boolean)
     */
// NPCTE fix for bugId 4464388, esc 0,  MR , to be added after modification of jmx spec
//  public synchronized Integer addNotification(String type, String message, Serializable userData,
//                                              Date date, long period)
// end of NPCTE fix for bugId 4464388 */

    public synchronized Integer addNotification(String type, String message, Object userData,
                                                Date date, long period, long nbOccurences)
        throws java.lang.IllegalArgumentException {

<span class="nc" id="L571">      return addNotification(type, message, userData, date, period, nbOccurences, false);</span>
    }

    /**
     * Creates a new timer notification with the specified &lt;CODE&gt;type&lt;/CODE&gt;, &lt;CODE&gt;message&lt;/CODE&gt;
     * and &lt;CODE&gt;userData&lt;/CODE&gt; and inserts it into the list of notifications with a given date
     * and period and a null number of occurrences.
     * &lt;P&gt;
     * The timer notification will repeat continuously using the timer period using a &lt;i&gt;fixed-delay&lt;/i&gt;
     * execution scheme, as specified in {@link java.util.Timer}. In order to use a &lt;i&gt;fixed-rate&lt;/i&gt;
     * execution scheme, use {@link #addNotification(String, String, Object, Date, long, long,
     * boolean)} instead.
     * &lt;P&gt;
     * If the timer notification to be inserted has a date that is before the current date,
     * the method behaves as if the specified date were the current date. The
     * first notification is delivered immediately and the subsequent ones are
     * spaced as specified by the period parameter.
     *
     * @param type The timer notification type.
     * @param message The timer notification detailed message.
     * @param userData The timer notification user data object.
     * @param date The date when the notification occurs.
     * @param period The period of the timer notification (in milliseconds).
     *
     * @return The identifier of the new created timer notification.
     *
     * @exception java.lang.IllegalArgumentException The date is {@code null} or
     * the period is negative.
     */
// NPCTE fix for bugId 4464388, esc 0,  MR , to be added after modification of jmx spec
//  public synchronized Integer addNotification(String type, String message, Serializable userData,
//                                              Date date, long period)
// end of NPCTE fix for bugId 4464388 */

    public synchronized Integer addNotification(String type, String message, Object userData,
                                                Date date, long period)
        throws java.lang.IllegalArgumentException {

<span class="nc" id="L609">        return (addNotification(type, message, userData, date, period, 0));</span>
    }

    /**
     * Creates a new timer notification with the specified &lt;CODE&gt;type&lt;/CODE&gt;, &lt;CODE&gt;message&lt;/CODE&gt;
     * and &lt;CODE&gt;userData&lt;/CODE&gt; and inserts it into the list of notifications with a given date
     * and a null period and number of occurrences.
     * &lt;P&gt;
     * The timer notification will be handled once at the specified date.
     * &lt;P&gt;
     * If the timer notification to be inserted has a date that is before the current date,
     * the method behaves as if the specified date were the current date and the
     * notification is delivered immediately.
     *
     * @param type The timer notification type.
     * @param message The timer notification detailed message.
     * @param userData The timer notification user data object.
     * @param date The date when the notification occurs.
     *
     * @return The identifier of the new created timer notification.
     *
     * @exception java.lang.IllegalArgumentException The date is {@code null}.
     */
// NPCTE fix for bugId 4464388, esc 0,  MR, to be added after modification of jmx spec
//  public synchronized Integer addNotification(String type, String message, Serializable userData, Date date)
//      throws java.lang.IllegalArgumentException {
// end of NPCTE fix for bugId 4464388

    public synchronized Integer addNotification(String type, String message, Object userData, Date date)
        throws java.lang.IllegalArgumentException {


<span class="nc" id="L641">        return (addNotification(type, message, userData, date, 0, 0));</span>
    }

    /**
     * Removes the timer notification corresponding to the specified identifier from the list of notifications.
     *
     * @param id The timer notification identifier.
     *
     * @exception InstanceNotFoundException The specified identifier does not correspond to any timer notification
     * in the list of notifications of this timer MBean.
     */
    public synchronized void removeNotification(Integer id) throws InstanceNotFoundException {

        // Check that the notification to remove is effectively in the timer table.
        //
<span class="nc bnc" id="L656" title="All 2 branches missed.">        if (timerTable.containsKey(id) == false) {</span>
<span class="nc" id="L657">            throw new InstanceNotFoundException(&quot;Timer notification to remove not in the list of notifications&quot;);</span>
        }

        // Stop the TimerAlarmClock.
        //
<span class="nc" id="L662">        Object[] obj = timerTable.get(id);</span>
<span class="nc" id="L663">        TimerAlarmClock alarmClock = (TimerAlarmClock)obj[ALARM_CLOCK_INDEX];</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (alarmClock != null) {</span>
//             alarmClock.interrupt();
//             try {
//                 // Wait until the thread die.
//                 //
//                 alarmClock.join();
//             } catch (InterruptedException e) {
//                 // Ignore...
//             }
//             // Remove the reference on the TimerAlarmClock.
//             //
<span class="nc" id="L675">            alarmClock.cancel();</span>
        }

        // Remove the timer notification from the timer table.
        //
<span class="nc bnc" id="L680" title="All 2 branches missed.">        if (TIMER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L681">            StringBuilder strb = new StringBuilder()</span>
<span class="nc" id="L682">            .append(&quot;removing timer notification:&quot;)</span>
<span class="nc" id="L683">            .append(&quot;\n\tNotification source = &quot;)</span>
<span class="nc" id="L684">            .append(((TimerNotification)obj[TIMER_NOTIF_INDEX]).getSource())</span>
<span class="nc" id="L685">            .append(&quot;\n\tNotification type = &quot;)</span>
<span class="nc" id="L686">            .append(((TimerNotification)obj[TIMER_NOTIF_INDEX]).getType())</span>
<span class="nc" id="L687">            .append(&quot;\n\tNotification ID = &quot;)</span>
<span class="nc" id="L688">            .append(((TimerNotification)obj[TIMER_NOTIF_INDEX]).getNotificationID())</span>
<span class="nc" id="L689">            .append(&quot;\n\tNotification date = &quot;)</span>
<span class="nc" id="L690">            .append(obj[TIMER_DATE_INDEX])</span>
<span class="nc" id="L691">            .append(&quot;\n\tNotification period = &quot;)</span>
<span class="nc" id="L692">            .append(obj[TIMER_PERIOD_INDEX])</span>
<span class="nc" id="L693">            .append(&quot;\n\tNotification nb of occurrences = &quot;)</span>
<span class="nc" id="L694">            .append(obj[TIMER_NB_OCCUR_INDEX])</span>
<span class="nc" id="L695">            .append(&quot;\n\tNotification executes at fixed rate = &quot;)</span>
<span class="nc" id="L696">            .append(obj[FIXED_RATE_INDEX]);</span>
<span class="nc" id="L697">            TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
<span class="nc" id="L698">                    &quot;removeNotification&quot;, strb.toString());</span>
        }

<span class="nc" id="L701">        timerTable.remove(id);</span>

<span class="nc" id="L703">        TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                &quot;removeNotification&quot;, &quot;timer notification removed&quot;);
<span class="nc" id="L705">    }</span>

    /**
     * Removes all the timer notifications corresponding to the specified type from the list of notifications.
     *
     * @param type The timer notification type.
     *
     * @exception InstanceNotFoundException The specified type does not correspond to any timer notification
     * in the list of notifications of this timer MBean.
     */
    public synchronized void removeNotifications(String type) throws InstanceNotFoundException {

<span class="nc" id="L717">        Vector&lt;Integer&gt; v = getNotificationIDs(type);</span>

<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (v.isEmpty())</span>
<span class="nc" id="L720">            throw new InstanceNotFoundException(&quot;Timer notifications to remove not in the list of notifications&quot;);</span>

<span class="nc bnc" id="L722" title="All 2 branches missed.">        for (Integer i : v)</span>
<span class="nc" id="L723">            removeNotification(i);</span>
<span class="nc" id="L724">    }</span>

    /**
     * Removes all the timer notifications from the list of notifications
     * and resets the counter used to update the timer notification identifiers.
     */
    public synchronized void removeAllNotifications() {

        TimerAlarmClock alarmClock;

<span class="nc bnc" id="L734" title="All 2 branches missed.">        for (Object[] obj : timerTable.values()) {</span>

            // Stop the TimerAlarmClock.
            //
<span class="nc" id="L738">            alarmClock = (TimerAlarmClock)obj[ALARM_CLOCK_INDEX];</span>
//             if (alarmClock != null) {
//                 alarmClock.interrupt();
//                 try {
//                     // Wait until the thread die.
//                     //
//                     alarmClock.join();
//                 } catch (InterruptedException ex) {
//                     // Ignore...
//                 }
                  // Remove the reference on the TimerAlarmClock.
                  //
//             }
<span class="nc" id="L751">            alarmClock.cancel();</span>
<span class="nc" id="L752">        }</span>

        // Remove all the timer notifications from the timer table.
<span class="nc" id="L755">        TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                &quot;removeAllNotifications&quot;, &quot;removing all timer notifications&quot;);

<span class="nc" id="L758">        timerTable.clear();</span>

<span class="nc" id="L760">        TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                &quot;removeAllNotifications&quot;, &quot;all timer notifications removed&quot;);
        // Reset the counterID.
        //
<span class="nc" id="L764">        counterID = 0;</span>

<span class="nc" id="L766">        TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                &quot;removeAllNotifications&quot;, &quot;timer notification counter ID reset&quot;);
<span class="nc" id="L768">    }</span>

    // GETTERS AND SETTERS
    //--------------------

    /**
     * Gets the number of timer notifications registered into the list of notifications.
     *
     * @return The number of timer notifications.
     */
    public synchronized int getNbNotifications() {
<span class="nc" id="L779">        return timerTable.size();</span>
    }

    /**
     * Gets all timer notification identifiers registered into the list of notifications.
     *
     * @return A vector of &lt;CODE&gt;Integer&lt;/CODE&gt; objects containing all the timer notification identifiers.
     * &lt;BR&gt;The vector is empty if there is no timer notification registered for this timer MBean.
     */
    public synchronized Vector&lt;Integer&gt; getAllNotificationIDs() {
<span class="nc" id="L789">        return new Vector&lt;Integer&gt;(timerTable.keySet());</span>
    }

    /**
     * Gets all the identifiers of timer notifications corresponding to the specified type.
     *
     * @param type The timer notification type.
     *
     * @return A vector of &lt;CODE&gt;Integer&lt;/CODE&gt; objects containing all the identifiers of
     * timer notifications with the specified &lt;CODE&gt;type&lt;/CODE&gt;.
     * &lt;BR&gt;The vector is empty if there is no timer notifications registered for this timer MBean
     * with the specified &lt;CODE&gt;type&lt;/CODE&gt;.
     */
    public synchronized Vector&lt;Integer&gt; getNotificationIDs(String type) {

        String s;

<span class="nc" id="L806">        Vector&lt;Integer&gt; v = new Vector&lt;Integer&gt;();</span>

<span class="nc bnc" id="L808" title="All 2 branches missed.">        for (Map.Entry&lt;Integer,Object[]&gt; entry : timerTable.entrySet()) {</span>
<span class="nc" id="L809">            Object[] obj = entry.getValue();</span>
<span class="nc" id="L810">            s = ((TimerNotification)obj[TIMER_NOTIF_INDEX]).getType();</span>
<span class="nc bnc" id="L811" title="All 6 branches missed.">            if ((type == null) ? s == null : type.equals(s))</span>
<span class="nc" id="L812">                v.addElement(entry.getKey());</span>
<span class="nc" id="L813">        }</span>
<span class="nc" id="L814">        return v;</span>
    }
    // 5089997: return is Vector&lt;Integer&gt; not Vector&lt;TimerNotification&gt;

    /**
     * Gets the timer notification type corresponding to the specified identifier.
     *
     * @param id The timer notification identifier.
     *
     * @return The timer notification type or null if the identifier is not mapped to any
     * timer notification registered for this timer MBean.
     */
    public synchronized String getNotificationType(Integer id) {

<span class="nc" id="L828">        Object[] obj = timerTable.get(id);</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">        if (obj != null) {</span>
<span class="nc" id="L830">            return ( ((TimerNotification)obj[TIMER_NOTIF_INDEX]).getType() );</span>
        }
<span class="nc" id="L832">        return null;</span>
    }

    /**
     * Gets the timer notification detailed message corresponding to the specified identifier.
     *
     * @param id The timer notification identifier.
     *
     * @return The timer notification detailed message or null if the identifier is not mapped to any
     * timer notification registered for this timer MBean.
     */
    public synchronized String getNotificationMessage(Integer id) {

<span class="nc" id="L845">        Object[] obj = timerTable.get(id);</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">        if (obj != null) {</span>
<span class="nc" id="L847">            return ( ((TimerNotification)obj[TIMER_NOTIF_INDEX]).getMessage() );</span>
        }
<span class="nc" id="L849">        return null;</span>
    }

    /**
     * Gets the timer notification user data object corresponding to the specified identifier.
     *
     * @param id The timer notification identifier.
     *
     * @return The timer notification user data object or null if the identifier is not mapped to any
     * timer notification registered for this timer MBean.
     */
    // NPCTE fix for bugId 4464388, esc 0, MR, 03 sept 2001, to be added after modification of jmx spec
    //public Serializable getNotificationUserData(Integer id) {
    // end of NPCTE fix for bugId 4464388

    public synchronized Object getNotificationUserData(Integer id) {
<span class="nc" id="L865">        Object[] obj = timerTable.get(id);</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">        if (obj != null) {</span>
<span class="nc" id="L867">            return ( ((TimerNotification)obj[TIMER_NOTIF_INDEX]).getUserData() );</span>
        }
<span class="nc" id="L869">        return null;</span>
    }

    /**
     * Gets a copy of the date associated to a timer notification.
     *
     * @param id The timer notification identifier.
     *
     * @return A copy of the date or null if the identifier is not mapped to any
     * timer notification registered for this timer MBean.
     */
    public synchronized Date getDate(Integer id) {

<span class="nc" id="L882">        Object[] obj = timerTable.get(id);</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">        if (obj != null) {</span>
<span class="nc" id="L884">            Date date = (Date)obj[TIMER_DATE_INDEX];</span>
<span class="nc" id="L885">            return (new Date(date.getTime()));</span>
        }
<span class="nc" id="L887">        return null;</span>
    }

    /**
     * Gets a copy of the period (in milliseconds) associated to a timer notification.
     *
     * @param id The timer notification identifier.
     *
     * @return A copy of the period or null if the identifier is not mapped to any
     * timer notification registered for this timer MBean.
     */
    public synchronized Long getPeriod(Integer id) {

<span class="nc" id="L900">        Object[] obj = timerTable.get(id);</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">        if (obj != null) {</span>
<span class="nc" id="L902">            return (Long)obj[TIMER_PERIOD_INDEX];</span>
        }
<span class="nc" id="L904">        return null;</span>
    }

    /**
     * Gets a copy of the remaining number of occurrences associated to a timer notification.
     *
     * @param id The timer notification identifier.
     *
     * @return A copy of the remaining number of occurrences or null if the identifier is not mapped to any
     * timer notification registered for this timer MBean.
     */
    public synchronized Long getNbOccurences(Integer id) {

<span class="nc" id="L917">        Object[] obj = timerTable.get(id);</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">        if (obj != null) {</span>
<span class="nc" id="L919">            return (Long)obj[TIMER_NB_OCCUR_INDEX];</span>
        }
<span class="nc" id="L921">        return null;</span>
    }

    /**
     * Gets a copy of the flag indicating whether a periodic notification is
     * executed at &lt;i&gt;fixed-delay&lt;/i&gt; or at &lt;i&gt;fixed-rate&lt;/i&gt;.
     *
     * @param id The timer notification identifier.
     *
     * @return A copy of the flag indicating whether a periodic notification is
     *         executed at &lt;i&gt;fixed-delay&lt;/i&gt; or at &lt;i&gt;fixed-rate&lt;/i&gt;.
     */
    public synchronized Boolean getFixedRate(Integer id) {

<span class="nc" id="L935">      Object[] obj = timerTable.get(id);</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">      if (obj != null) {</span>
<span class="nc" id="L937">        Boolean fixedRate = (Boolean)obj[FIXED_RATE_INDEX];</span>
<span class="nc" id="L938">        return (Boolean.valueOf(fixedRate.booleanValue()));</span>
      }
<span class="nc" id="L940">      return null;</span>
    }

    /**
     * Gets the flag indicating whether or not the timer sends past notifications.
     * &lt;BR&gt;The default value of the past notifications sending on/off flag is &lt;CODE&gt;false&lt;/CODE&gt;.
     *
     * @return The past notifications sending on/off flag value.
     *
     * @see #setSendPastNotifications
     */
    public boolean getSendPastNotifications() {
<span class="nc" id="L952">        return sendPastNotifications;</span>
    }

    /**
     * Sets the flag indicating whether the timer sends past notifications or not.
     * &lt;BR&gt;The default value of the past notifications sending on/off flag is &lt;CODE&gt;false&lt;/CODE&gt;.
     *
     * @param value The past notifications sending on/off flag value.
     *
     * @see #getSendPastNotifications
     */
    public void setSendPastNotifications(boolean value) {
<span class="nc" id="L964">        sendPastNotifications = value;</span>
<span class="nc" id="L965">    }</span>

    /**
     * Tests whether the timer MBean is active.
     * A timer MBean is marked active when the {@link #start start} method is called.
     * It becomes inactive when the {@link #stop stop} method is called.
     * &lt;BR&gt;The default value of the active on/off flag is &lt;CODE&gt;false&lt;/CODE&gt;.
     *
     * @return &lt;CODE&gt;true&lt;/CODE&gt; if the timer MBean is active, &lt;CODE&gt;false&lt;/CODE&gt; otherwise.
     */
    public boolean isActive() {
<span class="nc" id="L976">        return isActive;</span>
    }

    /**
     * Tests whether the list of timer notifications is empty.
     *
     * @return &lt;CODE&gt;true&lt;/CODE&gt; if the list of timer notifications is empty, &lt;CODE&gt;false&lt;/CODE&gt; otherwise.
     */
    public synchronized boolean isEmpty() {
<span class="nc" id="L985">        return (timerTable.isEmpty());</span>
    }

    /*
     * ------------------------------------------
     *  PRIVATE METHODS
     * ------------------------------------------
     */

    /**
     * Sends or not past notifications depending on the specified flag.
     *
     * @param currentDate The current date.
     * @param currentFlag The flag indicating if past notifications must be sent or not.
     */
    private synchronized void sendPastNotifications(Date currentDate, boolean currentFlag) {

        TimerNotification notif;
        Integer notifID;
        Date date;

<span class="nc" id="L1006">        ArrayList&lt;Object[]&gt; values =</span>
<span class="nc" id="L1007">            new ArrayList&lt;Object[]&gt;(timerTable.values());</span>

<span class="nc bnc" id="L1009" title="All 2 branches missed.">        for (Object[] obj : values) {</span>

            // Retrieve the timer notification and the date notification.
            //
<span class="nc" id="L1013">            notif = (TimerNotification)obj[TIMER_NOTIF_INDEX];</span>
<span class="nc" id="L1014">            notifID = notif.getNotificationID();</span>
<span class="nc" id="L1015">            date = (Date)obj[TIMER_DATE_INDEX];</span>

            // Update the timer notification while:
            //  - the timer notification date is earlier than the current date
            //  - the timer notification has not been removed from the timer table.
            //
<span class="nc bnc" id="L1021" title="All 4 branches missed.">            while ( (currentDate.after(date)) &amp;&amp; (timerTable.containsKey(notifID)) ) {</span>

<span class="nc bnc" id="L1023" title="All 2 branches missed.">                if (currentFlag == true) {</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                    if (TIMER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1025">                        StringBuilder strb = new StringBuilder()</span>
<span class="nc" id="L1026">                        .append(&quot;sending past timer notification:&quot;)</span>
<span class="nc" id="L1027">                        .append(&quot;\n\tNotification source = &quot;)</span>
<span class="nc" id="L1028">                        .append(notif.getSource())</span>
<span class="nc" id="L1029">                        .append(&quot;\n\tNotification type = &quot;)</span>
<span class="nc" id="L1030">                        .append(notif.getType())</span>
<span class="nc" id="L1031">                        .append(&quot;\n\tNotification ID = &quot;)</span>
<span class="nc" id="L1032">                        .append(notif.getNotificationID())</span>
<span class="nc" id="L1033">                        .append(&quot;\n\tNotification date = &quot;)</span>
<span class="nc" id="L1034">                        .append(date)</span>
<span class="nc" id="L1035">                        .append(&quot;\n\tNotification period = &quot;)</span>
<span class="nc" id="L1036">                        .append(obj[TIMER_PERIOD_INDEX])</span>
<span class="nc" id="L1037">                        .append(&quot;\n\tNotification nb of occurrences = &quot;)</span>
<span class="nc" id="L1038">                        .append(obj[TIMER_NB_OCCUR_INDEX])</span>
<span class="nc" id="L1039">                        .append(&quot;\n\tNotification executes at fixed rate = &quot;)</span>
<span class="nc" id="L1040">                        .append(obj[FIXED_RATE_INDEX]);</span>
<span class="nc" id="L1041">                        TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
<span class="nc" id="L1042">                                &quot;sendPastNotifications&quot;, strb.toString());</span>
                    }
<span class="nc" id="L1044">                    sendNotification(date, notif);</span>

<span class="nc" id="L1046">                    TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                            &quot;sendPastNotifications&quot;, &quot;past timer notification sent&quot;);
                }

                // Update the date and the number of occurrences of the timer notification.
                //
<span class="nc" id="L1052">                updateTimerTable(notif.getNotificationID());</span>
            }
<span class="nc" id="L1054">        }</span>
<span class="nc" id="L1055">    }</span>

    /**
     * If the timer notification is not periodic, it is removed from the list of notifications.
     * &lt;P&gt;
     * If the timer period of the timer notification has a non null periodicity,
     * the date of the timer notification is updated by adding the periodicity.
     * The associated TimerAlarmClock is updated by setting its timeout to the period value.
     * &lt;P&gt;
     * If the timer period has a defined number of occurrences, the timer
     * notification is updated if the number of occurrences has not yet been reached.
     * Otherwise it is removed from the list of notifications.
     *
     * @param notifID The timer notification identifier to update.
     */
    private synchronized void updateTimerTable(Integer notifID) {

        // Retrieve the timer notification and the TimerAlarmClock.
        //
<span class="nc" id="L1074">        Object[] obj = timerTable.get(notifID);</span>
<span class="nc" id="L1075">        Date date = (Date)obj[TIMER_DATE_INDEX];</span>
<span class="nc" id="L1076">        Long period = (Long)obj[TIMER_PERIOD_INDEX];</span>
<span class="nc" id="L1077">        Long nbOccurences = (Long)obj[TIMER_NB_OCCUR_INDEX];</span>
<span class="nc" id="L1078">        Boolean fixedRate = (Boolean)obj[FIXED_RATE_INDEX];</span>
<span class="nc" id="L1079">        TimerAlarmClock alarmClock = (TimerAlarmClock)obj[ALARM_CLOCK_INDEX];</span>

<span class="nc bnc" id="L1081" title="All 2 branches missed.">        if (period.longValue() != 0) {</span>

            // Update the date and the number of occurrences of the timer notification
            // and the TimerAlarmClock time out.
            // NOTES :
            //   nbOccurences = 0 notifies an infinite periodicity.
            //   nbOccurences = 1 notifies a finite periodicity that has reached its end.
            //   nbOccurences &gt; 1 notifies a finite periodicity that has not yet reached its end.
            //
<span class="nc bnc" id="L1090" title="All 4 branches missed.">            if ((nbOccurences.longValue() == 0) || (nbOccurences.longValue() &gt; 1)) {</span>

<span class="nc" id="L1092">                date.setTime(date.getTime() + period.longValue());</span>
<span class="nc" id="L1093">                obj[TIMER_NB_OCCUR_INDEX] = Long.valueOf(java.lang.Math.max(0L, (nbOccurences.longValue() - 1)));</span>
<span class="nc" id="L1094">                nbOccurences = (Long)obj[TIMER_NB_OCCUR_INDEX];</span>

<span class="nc bnc" id="L1096" title="All 2 branches missed.">                if (isActive == true) {</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                  if (fixedRate.booleanValue())</span>
                  {
<span class="nc" id="L1099">                    alarmClock = new TimerAlarmClock(this, date);</span>
<span class="nc" id="L1100">                    obj[ALARM_CLOCK_INDEX] = (Object)alarmClock;</span>
<span class="nc" id="L1101">                    timer.schedule(alarmClock, alarmClock.next);</span>
                  }
                  else
                  {
<span class="nc" id="L1105">                    alarmClock = new TimerAlarmClock(this, period.longValue());</span>
<span class="nc" id="L1106">                    obj[ALARM_CLOCK_INDEX] = (Object)alarmClock;</span>
<span class="nc" id="L1107">                    timer.schedule(alarmClock, alarmClock.timeout);</span>
                  }
                }
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                if (TIMER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1111">                    TimerNotification notif = (TimerNotification)obj[TIMER_NOTIF_INDEX];</span>
<span class="nc" id="L1112">                    StringBuilder strb = new StringBuilder()</span>
<span class="nc" id="L1113">                    .append(&quot;update timer notification with:&quot;)</span>
<span class="nc" id="L1114">                    .append(&quot;\n\tNotification source = &quot;)</span>
<span class="nc" id="L1115">                    .append(notif.getSource())</span>
<span class="nc" id="L1116">                    .append(&quot;\n\tNotification type = &quot;)</span>
<span class="nc" id="L1117">                    .append(notif.getType())</span>
<span class="nc" id="L1118">                    .append(&quot;\n\tNotification ID = &quot;)</span>
<span class="nc" id="L1119">                    .append(notifID)</span>
<span class="nc" id="L1120">                    .append(&quot;\n\tNotification date = &quot;)</span>
<span class="nc" id="L1121">                    .append(date)</span>
<span class="nc" id="L1122">                    .append(&quot;\n\tNotification period = &quot;)</span>
<span class="nc" id="L1123">                    .append(period)</span>
<span class="nc" id="L1124">                    .append(&quot;\n\tNotification nb of occurrences = &quot;)</span>
<span class="nc" id="L1125">                    .append(nbOccurences)</span>
<span class="nc" id="L1126">                    .append(&quot;\n\tNotification executes at fixed rate = &quot;)</span>
<span class="nc" id="L1127">                    .append(fixedRate);</span>
<span class="nc" id="L1128">                    TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
<span class="nc" id="L1129">                            &quot;updateTimerTable&quot;, strb.toString());</span>
<span class="nc" id="L1130">                }</span>
            }
            else {
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                if (alarmClock != null) {</span>
//                     alarmClock.interrupt();
//                     try {
//                         // Wait until the thread die.
//                         //
//                         alarmClock.join();
//                     } catch (InterruptedException e) {
//                         // Ignore...
//                     }
<span class="nc" id="L1142">                    alarmClock.cancel();</span>
                }
<span class="nc" id="L1144">                timerTable.remove(notifID);</span>
            }
        }
        else {
<span class="nc bnc" id="L1148" title="All 2 branches missed.">            if (alarmClock != null) {</span>
//                 alarmClock.interrupt();
//                 try {
//                     // Wait until the thread die.
//                     //
//                     alarmClock.join();
//                 } catch (InterruptedException e) {
//                     // Ignore...
//                 }

<span class="nc" id="L1158">                   alarmClock.cancel();</span>
            }
<span class="nc" id="L1160">            timerTable.remove(notifID);</span>
        }
<span class="nc" id="L1162">    }</span>

    /*
     * ------------------------------------------
     *  PACKAGE METHODS
     * ------------------------------------------
     */

    /**
     * This method is called by the timer each time
     * the TimerAlarmClock has exceeded its timeout.
     *
     * @param notification The TimerAlarmClock notification.
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    void notifyAlarmClock(TimerAlarmClockNotification notification) {

<span class="nc" id="L1179">        TimerNotification timerNotification = null;</span>
<span class="nc" id="L1180">        Date timerDate = null;</span>

        // Retrieve the timer notification associated to the alarm-clock.
        //
<span class="nc" id="L1184">        TimerAlarmClock alarmClock = (TimerAlarmClock)notification.getSource();</span>

<span class="nc" id="L1186">        synchronized(Timer.this) {</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            for (Object[] obj : timerTable.values()) {</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">                if (obj[ALARM_CLOCK_INDEX] == alarmClock) {</span>
<span class="nc" id="L1189">                    timerNotification = (TimerNotification)obj[TIMER_NOTIF_INDEX];</span>
<span class="nc" id="L1190">                    timerDate = (Date)obj[TIMER_DATE_INDEX];</span>
<span class="nc" id="L1191">                    break;</span>
                }
<span class="nc" id="L1193">            }</span>
<span class="nc" id="L1194">        }</span>

        // Notify the timer.
        //
<span class="nc" id="L1198">        sendNotification(timerDate, timerNotification);</span>

        // Update the notification and the TimerAlarmClock timeout.
        //
<span class="nc" id="L1202">        updateTimerTable(timerNotification.getNotificationID());</span>
<span class="nc" id="L1203">    }</span>

    /**
     * This method is used by the timer MBean to update and send a timer
     * notification to all the listeners registered for this kind of notification.
     *
     * @param timeStamp The notification emission date.
     * @param notification The timer notification to send.
     */
    void sendNotification(Date timeStamp, TimerNotification notification) {

<span class="nc bnc" id="L1214" title="All 2 branches missed.">        if (TIMER_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L1215">            StringBuilder strb = new StringBuilder()</span>
<span class="nc" id="L1216">            .append(&quot;sending timer notification:&quot;)</span>
<span class="nc" id="L1217">            .append(&quot;\n\tNotification source = &quot;)</span>
<span class="nc" id="L1218">            .append(notification.getSource())</span>
<span class="nc" id="L1219">            .append(&quot;\n\tNotification type = &quot;)</span>
<span class="nc" id="L1220">            .append(notification.getType())</span>
<span class="nc" id="L1221">            .append(&quot;\n\tNotification ID = &quot;)</span>
<span class="nc" id="L1222">            .append(notification.getNotificationID())</span>
<span class="nc" id="L1223">            .append(&quot;\n\tNotification date = &quot;)</span>
<span class="nc" id="L1224">            .append(timeStamp);</span>
<span class="nc" id="L1225">            TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
<span class="nc" id="L1226">                    &quot;sendNotification&quot;, strb.toString());</span>
        }
        long curSeqNumber;
<span class="nc" id="L1229">        synchronized(this) {</span>
<span class="nc" id="L1230">            sequenceNumber = sequenceNumber + 1;</span>
<span class="nc" id="L1231">            curSeqNumber = sequenceNumber;</span>
<span class="nc" id="L1232">        }</span>
<span class="nc" id="L1233">        synchronized (notification) {</span>
<span class="nc" id="L1234">            notification.setTimeStamp(timeStamp.getTime());</span>
<span class="nc" id="L1235">            notification.setSequenceNumber(curSeqNumber);</span>
<span class="nc" id="L1236">            this.sendNotification((TimerNotification)notification.cloneTimerNotification());</span>
<span class="nc" id="L1237">        }</span>

<span class="nc" id="L1239">        TIMER_LOGGER.logp(Level.FINER, Timer.class.getName(),</span>
                &quot;sendNotification&quot;, &quot;timer notification sent&quot;);
<span class="nc" id="L1241">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>