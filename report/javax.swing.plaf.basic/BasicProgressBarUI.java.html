<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BasicProgressBarUI.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.plaf.basic</a> &gt; <span class="el_source">BasicProgressBarUI.java</span></div><h1>BasicProgressBarUI.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.plaf.basic;

import sun.swing.SwingUtilities2;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.plaf.*;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import java.io.Serializable;
import sun.swing.DefaultLookup;

/**
 * A Basic L&amp;amp;F implementation of ProgressBarUI.
 *
 * @author Michael C. Albers
 * @author Kathy Walrath
 */
<span class="nc" id="L46">public class BasicProgressBarUI extends ProgressBarUI {</span>
    private int cachedPercent;
    private int cellLength, cellSpacing;
    // The &quot;selectionForeground&quot; is the color of the text when it is painted
    // over a filled area of the progress bar. The &quot;selectionBackground&quot;
    // is for the text over the unfilled progress bar area.
    private Color selectionForeground, selectionBackground;

    private Animator animator;

    protected JProgressBar progressBar;
    protected ChangeListener changeListener;
    private Handler handler;

    /**
     * The current state of the indeterminate animation's cycle.
     * 0, the initial value, means paint the first frame.
     * When the progress bar is indeterminate and showing,
     * the default animation thread updates this variable
     * by invoking incrementAnimationIndex()
     * every repaintInterval milliseconds.
     */
<span class="nc" id="L68">    private int animationIndex = 0;</span>

    /**
     * The number of frames per cycle. Under the default implementation,
     * this depends on the cycleTime and repaintInterval.  It
     * must be an even number for the default painting algorithm.  This
     * value is set in the initIndeterminateValues method.
     */
    private int numFrames;   //0 1|numFrames-1 ... numFrames/2

    /**
     * Interval (in ms) between repaints of the indeterminate progress bar.
     * The value of this method is set
     * (every time the progress bar changes to indeterminate mode)
     * using the
     * &quot;ProgressBar.repaintInterval&quot; key in the defaults table.
     */
    private int repaintInterval;

    /**
     * The number of milliseconds until the animation cycle repeats.
     * The value of this method is set
     * (every time the progress bar changes to indeterminate mode)
     * using the
     * &quot;ProgressBar.cycleTime&quot; key in the defaults table.
     */
    private int cycleTime;  //must be repaintInterval*2*aPositiveInteger

    //performance stuff
<span class="nc" id="L97">    private static boolean ADJUSTTIMER = true; //makes a BIG difference;</span>
                                               //make this false for
                                               //performance tests

    /**
     * Used to hold the location and size of the bouncing box (returned
     * by getBox) to be painted.
     *
     * @since 1.5
     */
    protected Rectangle boxRect;

    /**
     * The rectangle to be updated the next time the
     * animation thread calls repaint.  For bouncing-box
     * animation this rect should include the union of
     * the currently displayed box (which needs to be erased)
     * and the box to be displayed next.
     * This rectangle's values are set in
     * the setAnimationIndex method.
     */
    private Rectangle nextPaintRect;

    //cache
    /** The component's painting area, not including the border. */
    private Rectangle componentInnards;    //the current painting area
    private Rectangle oldComponentInnards; //used to see if the size changed

    /** For bouncing-box animation, the change in position per frame. */
<span class="nc" id="L126">    private double delta = 0.0;</span>

<span class="nc" id="L128">    private int maxPosition = 0; //maximum X (horiz) or Y box location</span>


    public static ComponentUI createUI(JComponent x) {
<span class="nc" id="L132">        return new BasicProgressBarUI();</span>
    }

    public void installUI(JComponent c) {
<span class="nc" id="L136">        progressBar = (JProgressBar)c;</span>
<span class="nc" id="L137">        installDefaults();</span>
<span class="nc" id="L138">        installListeners();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (progressBar.isIndeterminate()) {</span>
<span class="nc" id="L140">            initIndeterminateValues();</span>
        }
<span class="nc" id="L142">    }</span>

    public void uninstallUI(JComponent c) {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (progressBar.isIndeterminate()) {</span>
<span class="nc" id="L146">            cleanUpIndeterminateValues();</span>
        }
<span class="nc" id="L148">        uninstallDefaults();</span>
<span class="nc" id="L149">        uninstallListeners();</span>
<span class="nc" id="L150">        progressBar = null;</span>
<span class="nc" id="L151">    }</span>

    protected void installDefaults() {
<span class="nc" id="L154">        LookAndFeel.installProperty(progressBar, &quot;opaque&quot;, Boolean.TRUE);</span>
<span class="nc" id="L155">        LookAndFeel.installBorder(progressBar,&quot;ProgressBar.border&quot;);</span>
<span class="nc" id="L156">        LookAndFeel.installColorsAndFont(progressBar,</span>
                                         &quot;ProgressBar.background&quot;,
                                         &quot;ProgressBar.foreground&quot;,
                                         &quot;ProgressBar.font&quot;);
<span class="nc" id="L160">        cellLength = UIManager.getInt(&quot;ProgressBar.cellLength&quot;);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (cellLength == 0) cellLength = 1;</span>
<span class="nc" id="L162">        cellSpacing = UIManager.getInt(&quot;ProgressBar.cellSpacing&quot;);</span>
<span class="nc" id="L163">        selectionForeground = UIManager.getColor(&quot;ProgressBar.selectionForeground&quot;);</span>
<span class="nc" id="L164">        selectionBackground = UIManager.getColor(&quot;ProgressBar.selectionBackground&quot;);</span>
<span class="nc" id="L165">    }</span>

    protected void uninstallDefaults() {
<span class="nc" id="L168">        LookAndFeel.uninstallBorder(progressBar);</span>
<span class="nc" id="L169">    }</span>

    protected void installListeners() {
        //Listen for changes in the progress bar's data.
<span class="nc" id="L173">        changeListener = getHandler();</span>
<span class="nc" id="L174">        progressBar.addChangeListener(changeListener);</span>

        //Listen for changes between determinate and indeterminate state.
<span class="nc" id="L177">        progressBar.addPropertyChangeListener(getHandler());</span>
<span class="nc" id="L178">    }</span>

    private Handler getHandler() {
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (handler == null) {</span>
<span class="nc" id="L182">            handler = new Handler();</span>
        }
<span class="nc" id="L184">        return handler;</span>
    }

    /**
     * Starts the animation thread, creating and initializing
     * it if necessary. This method is invoked when an
     * indeterminate progress bar should start animating.
     * Reasons for this may include:
     * &lt;ul&gt;
     *    &lt;li&gt;The progress bar is determinate and becomes displayable
     *    &lt;li&gt;The progress bar is displayable and becomes determinate
     *    &lt;li&gt;The progress bar is displayable and determinate and this
     *        UI is installed
     * &lt;/ul&gt;
     * If you implement your own animation thread,
     * you must override this method.
     *
     * @since 1.4
     * @see #stopAnimationTimer
     */
    protected void startAnimationTimer() {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (animator == null) {</span>
<span class="nc" id="L206">            animator = new Animator();</span>
        }

<span class="nc" id="L209">        animator.start(getRepaintInterval());</span>
<span class="nc" id="L210">    }</span>

    /**
     * Stops the animation thread.
     * This method is invoked when the indeterminate
     * animation should be stopped. Reasons for this may include:
     * &lt;ul&gt;
     *    &lt;li&gt;The progress bar changes to determinate
     *    &lt;li&gt;The progress bar is no longer part of a displayable hierarchy
     *    &lt;li&gt;This UI in uninstalled
     * &lt;/ul&gt;
     * If you implement your own animation thread,
     * you must override this method.
     *
     * @since 1.4
     * @see #startAnimationTimer
     */
    protected void stopAnimationTimer() {
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (animator != null) {</span>
<span class="nc" id="L229">            animator.stop();</span>
        }
<span class="nc" id="L231">    }</span>

    /**
     * Removes all listeners installed by this object.
     */
    protected void uninstallListeners() {
<span class="nc" id="L237">        progressBar.removeChangeListener(changeListener);</span>
<span class="nc" id="L238">        progressBar.removePropertyChangeListener(getHandler());</span>
<span class="nc" id="L239">        handler = null;</span>
<span class="nc" id="L240">    }</span>


    /**
     * Returns the baseline.
     *
     * @throws NullPointerException {@inheritDoc}
     * @throws IllegalArgumentException {@inheritDoc}
     * @see javax.swing.JComponent#getBaseline(int, int)
     * @since 1.6
     */
    public int getBaseline(JComponent c, int width, int height) {
<span class="nc" id="L252">        super.getBaseline(c, width, height);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (progressBar.isStringPainted() &amp;&amp;</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc" id="L255">            FontMetrics metrics = progressBar.</span>
<span class="nc" id="L256">                    getFontMetrics(progressBar.getFont());</span>
<span class="nc" id="L257">            Insets insets = progressBar.getInsets();</span>
<span class="nc" id="L258">            int y = insets.top;</span>
<span class="nc" id="L259">            height = height - insets.top - insets.bottom;</span>
<span class="nc" id="L260">            return y + (height + metrics.getAscent() -</span>
<span class="nc" id="L261">                        metrics.getLeading() -</span>
<span class="nc" id="L262">                        metrics.getDescent()) / 2;</span>
        }
<span class="nc" id="L264">        return -1;</span>
    }

    /**
     * Returns an enum indicating how the baseline of the component
     * changes as the size changes.
     *
     * @throws NullPointerException {@inheritDoc}
     * @see javax.swing.JComponent#getBaseline(int, int)
     * @since 1.6
     */
    public Component.BaselineResizeBehavior getBaselineResizeBehavior(
            JComponent c) {
<span class="nc" id="L277">        super.getBaselineResizeBehavior(c);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (progressBar.isStringPainted() &amp;&amp;</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc" id="L280">            return Component.BaselineResizeBehavior.CENTER_OFFSET;</span>
        }
<span class="nc" id="L282">        return Component.BaselineResizeBehavior.OTHER;</span>
    }

    // Many of the Basic*UI components have the following methods.
    // This component does not have these methods because *ProgressBarUI
    //  is not a compound component and does not accept input.
    //
    // protected void installComponents()
    // protected void uninstallComponents()
    // protected void installKeyboardActions()
    // protected void uninstallKeyboardActions()

    protected Dimension getPreferredInnerHorizontal() {
<span class="nc" id="L295">        Dimension horizDim = (Dimension)DefaultLookup.get(progressBar, this,</span>
            &quot;ProgressBar.horizontalSize&quot;);
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (horizDim == null) {</span>
<span class="nc" id="L298">            horizDim = new Dimension(146, 12);</span>
        }
<span class="nc" id="L300">        return horizDim;</span>
    }

    protected Dimension getPreferredInnerVertical() {
<span class="nc" id="L304">        Dimension vertDim = (Dimension)DefaultLookup.get(progressBar, this,</span>
            &quot;ProgressBar.verticalSize&quot;);
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (vertDim == null) {</span>
<span class="nc" id="L307">            vertDim = new Dimension(12, 146);</span>
        }
<span class="nc" id="L309">        return vertDim;</span>
    }

    /**
     * The &quot;selectionForeground&quot; is the color of the text when it is painted
     * over a filled area of the progress bar.
     */
    protected Color getSelectionForeground() {
<span class="nc" id="L317">        return selectionForeground;</span>
    }

    /**
     * The &quot;selectionBackground&quot; is the color of the text when it is painted
     * over an unfilled area of the progress bar.
     */
    protected Color getSelectionBackground() {
<span class="nc" id="L325">        return selectionBackground;</span>
    }

    private int getCachedPercent() {
<span class="nc" id="L329">        return cachedPercent;</span>
    }

    private void setCachedPercent(int cachedPercent) {
<span class="nc" id="L333">        this.cachedPercent = cachedPercent;</span>
<span class="nc" id="L334">    }</span>

    /**
     * Returns the width (if HORIZONTAL) or height (if VERTICAL)
     * of each of the individual cells/units to be rendered in the
     * progress bar. However, for text rendering simplification and
     * aesthetic considerations, this function will return 1 when
     * the progress string is being rendered.
     *
     * @return the value representing the spacing between cells
     * @see    #setCellLength
     * @see    JProgressBar#isStringPainted
     */
    protected int getCellLength() {
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (progressBar.isStringPainted()) {</span>
<span class="nc" id="L349">            return 1;</span>
        } else {
<span class="nc" id="L351">            return cellLength;</span>
        }
    }

    protected void setCellLength(int cellLen) {
<span class="nc" id="L356">        this.cellLength = cellLen;</span>
<span class="nc" id="L357">    }</span>

    /**
     * Returns the spacing between each of the cells/units in the
     * progress bar. However, for text rendering simplification and
     * aesthetic considerations, this function will return 0 when
     * the progress string is being rendered.
     *
     * @return the value representing the spacing between cells
     * @see    #setCellSpacing
     * @see    JProgressBar#isStringPainted
     */
    protected int getCellSpacing() {
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (progressBar.isStringPainted()) {</span>
<span class="nc" id="L371">            return 0;</span>
        } else {
<span class="nc" id="L373">            return cellSpacing;</span>
        }
    }

    protected void setCellSpacing(int cellSpace) {
<span class="nc" id="L378">        this.cellSpacing = cellSpace;</span>
<span class="nc" id="L379">    }</span>

    /**
     * This determines the amount of the progress bar that should be filled
     * based on the percent done gathered from the model. This is a common
     * operation so it was abstracted out. It assumes that your progress bar
     * is linear. That is, if you are making a circular progress indicator,
     * you will want to override this method.
     */
    protected int getAmountFull(Insets b, int width, int height) {
<span class="nc" id="L389">        int amountFull = 0;</span>
<span class="nc" id="L390">        BoundedRangeModel model = progressBar.getModel();</span>

<span class="nc bnc" id="L392" title="All 2 branches missed.">        if ( (model.getMaximum() - model.getMinimum()) != 0) {</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc" id="L394">                amountFull = (int)Math.round(width *</span>
<span class="nc" id="L395">                                             progressBar.getPercentComplete());</span>
            } else {
<span class="nc" id="L397">                amountFull = (int)Math.round(height *</span>
<span class="nc" id="L398">                                             progressBar.getPercentComplete());</span>
            }
        }
<span class="nc" id="L401">        return amountFull;</span>
    }

    /**
     * Delegates painting to one of two methods:
     * paintDeterminate or paintIndeterminate.
     */
    public void paint(Graphics g, JComponent c) {
<span class="nc bnc" id="L409" title="All 2 branches missed.">        if (progressBar.isIndeterminate()) {</span>
<span class="nc" id="L410">            paintIndeterminate(g, c);</span>
        } else {
<span class="nc" id="L412">            paintDeterminate(g, c);</span>
        }
<span class="nc" id="L414">    }</span>

    /**
     * Stores the position and size of
     * the bouncing box that would be painted for the current animation index
     * in &lt;code&gt;r&lt;/code&gt; and returns &lt;code&gt;r&lt;/code&gt;.
     * Subclasses that add to the painting performed
     * in this class's implementation of &lt;code&gt;paintIndeterminate&lt;/code&gt; --
     * to draw an outline around the bouncing box, for example --
     * can use this method to get the location of the bouncing
     * box that was just painted.
     * By overriding this method,
     * you have complete control over the size and position
     * of the bouncing box,
     * without having to reimplement &lt;code&gt;paintIndeterminate&lt;/code&gt;.
     *
     * @param r  the Rectangle instance to be modified;
     *           may be &lt;code&gt;null&lt;/code&gt;
     * @return   &lt;code&gt;null&lt;/code&gt; if no box should be drawn;
     *           otherwise, returns the passed-in rectangle
     *           (if non-null)
     *           or a new rectangle
     *
     * @see #setAnimationIndex
     * @since 1.4
     */
    protected Rectangle getBox(Rectangle r) {
<span class="nc" id="L441">        int currentFrame = getAnimationIndex();</span>
<span class="nc" id="L442">        int middleFrame = numFrames/2;</span>

<span class="nc bnc" id="L444" title="All 6 branches missed.">        if (sizeChanged() || delta == 0.0 || maxPosition == 0.0) {</span>
<span class="nc" id="L445">            updateSizes();</span>
        }

<span class="nc" id="L448">        r = getGenericBox(r);</span>

<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (r == null) {</span>
<span class="nc" id="L451">            return null;</span>
        }
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (middleFrame &lt;= 0) {</span>
<span class="nc" id="L454">            return null;</span>
        }

        //assert currentFrame &gt;= 0 &amp;&amp; currentFrame &lt; numFrames
<span class="nc bnc" id="L458" title="All 2 branches missed.">        if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            if (currentFrame &lt; middleFrame) {</span>
<span class="nc" id="L460">                r.x = componentInnards.x</span>
<span class="nc" id="L461">                      + (int)Math.round(delta * (double)currentFrame);</span>
            } else {
<span class="nc" id="L463">                r.x = maxPosition</span>
<span class="nc" id="L464">                      - (int)Math.round(delta *</span>
                                        (currentFrame - middleFrame));
            }
        } else { //VERTICAL indeterminate progress bar
<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (currentFrame &lt; middleFrame) {</span>
<span class="nc" id="L469">                r.y = componentInnards.y</span>
<span class="nc" id="L470">                      + (int)Math.round(delta * currentFrame);</span>
            } else {
<span class="nc" id="L472">                r.y = maxPosition</span>
<span class="nc" id="L473">                      - (int)Math.round(delta *</span>
                                        (currentFrame - middleFrame));
            }
        }
<span class="nc" id="L477">        return r;</span>
    }

    /**
     * Updates delta, max position.
     * Assumes componentInnards is correct (e.g. call after sizeChanged()).
     */
    private void updateSizes() {
<span class="nc" id="L485">        int length = 0;</span>

<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc" id="L488">            length = getBoxLength(componentInnards.width,</span>
                                  componentInnards.height);
<span class="nc" id="L490">            maxPosition = componentInnards.x + componentInnards.width</span>
                          - length;

        } else { //VERTICAL progress bar
<span class="nc" id="L494">            length = getBoxLength(componentInnards.height,</span>
                                  componentInnards.width);
<span class="nc" id="L496">            maxPosition = componentInnards.y + componentInnards.height</span>
                          - length;
        }

        //If we're doing bouncing-box animation, update delta.
<span class="nc" id="L501">        delta = 2.0 * (double)maxPosition/(double)numFrames;</span>
<span class="nc" id="L502">    }</span>

    /**
     * Assumes that the component innards, max position, etc. are up-to-date.
     */
    private Rectangle getGenericBox(Rectangle r) {
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (r == null) {</span>
<span class="nc" id="L509">            r = new Rectangle();</span>
        }

<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc" id="L513">            r.width = getBoxLength(componentInnards.width,</span>
                                   componentInnards.height);
<span class="nc bnc" id="L515" title="All 2 branches missed.">            if (r.width &lt; 0) {</span>
<span class="nc" id="L516">                r = null;</span>
            } else {
<span class="nc" id="L518">                r.height = componentInnards.height;</span>
<span class="nc" id="L519">                r.y = componentInnards.y;</span>
            }
          // end of HORIZONTAL

        } else { //VERTICAL progress bar
<span class="nc" id="L524">            r.height = getBoxLength(componentInnards.height,</span>
                                    componentInnards.width);
<span class="nc bnc" id="L526" title="All 2 branches missed.">            if (r.height &lt; 0) {</span>
<span class="nc" id="L527">                r = null;</span>
            } else {
<span class="nc" id="L529">                r.width = componentInnards.width;</span>
<span class="nc" id="L530">                r.x = componentInnards.x;</span>
            }
        } // end of VERTICAL

<span class="nc" id="L534">        return r;</span>
    }

    /**
     * Returns the length
     * of the &quot;bouncing box&quot; to be painted.
     * This method is invoked by the
     * default implementation of &lt;code&gt;paintIndeterminate&lt;/code&gt;
     * to get the width (if the progress bar is horizontal)
     * or height (if vertical) of the box.
     * For example:
     * &lt;blockquote&gt;
     * &lt;pre&gt;
     *boxRect.width = getBoxLength(componentInnards.width,
     *                             componentInnards.height);
     * &lt;/pre&gt;
     * &lt;/blockquote&gt;
     *
     * @param availableLength  the amount of space available
     *                         for the bouncing box to move in;
     *                         for a horizontal progress bar,
     *                         for example,
     *                         this should be
     *                         the inside width of the progress bar
     *                         (the component width minus borders)
     * @param otherDimension   for a horizontal progress bar, this should be
     *                         the inside height of the progress bar; this
     *                         value might be used to constrain or determine
     *                         the return value
     *
     * @return the size of the box dimension being determined;
     *         must be no larger than &lt;code&gt;availableLength&lt;/code&gt;
     *
     * @see javax.swing.SwingUtilities#calculateInnerArea
     * @since 1.5
     */
    protected int getBoxLength(int availableLength, int otherDimension) {
<span class="nc" id="L571">        return (int)Math.round(availableLength/6.0);</span>
    }

    /**
     * All purpose paint method that should do the right thing for all
     * linear bouncing-box progress bars.
     * Override this if you are making another kind of
     * progress bar.
     *
     * @see #paintDeterminate
     *
     * @since 1.4
     */
    protected void paintIndeterminate(Graphics g, JComponent c) {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (!(g instanceof Graphics2D)) {</span>
<span class="nc" id="L586">            return;</span>
        }

<span class="nc" id="L589">        Insets b = progressBar.getInsets(); // area for border</span>
<span class="nc" id="L590">        int barRectWidth = progressBar.getWidth() - (b.right + b.left);</span>
<span class="nc" id="L591">        int barRectHeight = progressBar.getHeight() - (b.top + b.bottom);</span>

<span class="nc bnc" id="L593" title="All 4 branches missed.">        if (barRectWidth &lt;= 0 || barRectHeight &lt;= 0) {</span>
<span class="nc" id="L594">            return;</span>
        }

<span class="nc" id="L597">        Graphics2D g2 = (Graphics2D)g;</span>

        // Paint the bouncing box.
<span class="nc" id="L600">        boxRect = getBox(boxRect);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">        if (boxRect != null) {</span>
<span class="nc" id="L602">            g2.setColor(progressBar.getForeground());</span>
<span class="nc" id="L603">            g2.fillRect(boxRect.x, boxRect.y,</span>
                       boxRect.width, boxRect.height);
        }

        // Deal with possible text painting
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (progressBar.isStringPainted()) {</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">            if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc" id="L610">                paintString(g2, b.left, b.top,</span>
                            barRectWidth, barRectHeight,
                            boxRect.x, boxRect.width, b);
            }
            else {
<span class="nc" id="L615">                paintString(g2, b.left, b.top,</span>
                            barRectWidth, barRectHeight,
                            boxRect.y, boxRect.height, b);
            }
        }
<span class="nc" id="L620">    }</span>


    /**
     * All purpose paint method that should do the right thing for almost
     * all linear, determinate progress bars. By setting a few values in
     * the defaults
     * table, things should work just fine to paint your progress bar.
     * Naturally, override this if you are making a circular or
     * semi-circular progress bar.
     *
     * @see #paintIndeterminate
     *
     * @since 1.4
     */
    protected void paintDeterminate(Graphics g, JComponent c) {
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (!(g instanceof Graphics2D)) {</span>
<span class="nc" id="L637">            return;</span>
        }

<span class="nc" id="L640">        Insets b = progressBar.getInsets(); // area for border</span>
<span class="nc" id="L641">        int barRectWidth = progressBar.getWidth() - (b.right + b.left);</span>
<span class="nc" id="L642">        int barRectHeight = progressBar.getHeight() - (b.top + b.bottom);</span>

<span class="nc bnc" id="L644" title="All 4 branches missed.">        if (barRectWidth &lt;= 0 || barRectHeight &lt;= 0) {</span>
<span class="nc" id="L645">            return;</span>
        }

<span class="nc" id="L648">        int cellLength = getCellLength();</span>
<span class="nc" id="L649">        int cellSpacing = getCellSpacing();</span>
        // amount of progress to draw
<span class="nc" id="L651">        int amountFull = getAmountFull(b, barRectWidth, barRectHeight);</span>

<span class="nc" id="L653">        Graphics2D g2 = (Graphics2D)g;</span>
<span class="nc" id="L654">        g2.setColor(progressBar.getForeground());</span>

<span class="nc bnc" id="L656" title="All 2 branches missed.">        if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
            // draw the cells
<span class="nc bnc" id="L658" title="All 4 branches missed.">            if (cellSpacing == 0 &amp;&amp; amountFull &gt; 0) {</span>
                // draw one big Rect because there is no space between cells
<span class="nc" id="L660">                g2.setStroke(new BasicStroke((float)barRectHeight,</span>
                        BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL));
            } else {
                // draw each individual cell
<span class="nc" id="L664">                g2.setStroke(new BasicStroke((float)barRectHeight,</span>
                        BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
                        0.f, new float[] { cellLength, cellSpacing }, 0.f));
            }

<span class="nc bnc" id="L669" title="All 2 branches missed.">            if (BasicGraphicsUtils.isLeftToRight(c)) {</span>
<span class="nc" id="L670">                g2.drawLine(b.left, (barRectHeight/2) + b.top,</span>
                        amountFull + b.left, (barRectHeight/2) + b.top);
            } else {
<span class="nc" id="L673">                g2.drawLine((barRectWidth + b.left),</span>
                        (barRectHeight/2) + b.top,
                        barRectWidth + b.left - amountFull,
                        (barRectHeight/2) + b.top);
            }

        } else { // VERTICAL
            // draw the cells
<span class="nc bnc" id="L681" title="All 4 branches missed.">            if (cellSpacing == 0 &amp;&amp; amountFull &gt; 0) {</span>
                // draw one big Rect because there is no space between cells
<span class="nc" id="L683">                g2.setStroke(new BasicStroke((float)barRectWidth,</span>
                        BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL));
            } else {
                // draw each individual cell
<span class="nc" id="L687">                g2.setStroke(new BasicStroke((float)barRectWidth,</span>
                        BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
                        0f, new float[] { cellLength, cellSpacing }, 0f));
            }

<span class="nc" id="L692">            g2.drawLine(barRectWidth/2 + b.left,</span>
                    b.top + barRectHeight,
                    barRectWidth/2 + b.left,
                    b.top + barRectHeight - amountFull);
        }

        // Deal with possible text painting
<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (progressBar.isStringPainted()) {</span>
<span class="nc" id="L700">            paintString(g, b.left, b.top,</span>
                        barRectWidth, barRectHeight,
                        amountFull, b);
        }
<span class="nc" id="L704">    }</span>


    protected void paintString(Graphics g, int x, int y,
                               int width, int height,
                               int amountFull, Insets b) {
<span class="nc bnc" id="L710" title="All 2 branches missed.">        if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">            if (BasicGraphicsUtils.isLeftToRight(progressBar)) {</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                if (progressBar.isIndeterminate()) {</span>
<span class="nc" id="L713">                    boxRect = getBox(boxRect);</span>
<span class="nc" id="L714">                    paintString(g, x, y, width, height,</span>
                            boxRect.x, boxRect.width, b);
                } else {
<span class="nc" id="L717">                    paintString(g, x, y, width, height, x, amountFull, b);</span>
                }
            }
            else {
<span class="nc" id="L721">                paintString(g, x, y, width, height, x + width - amountFull,</span>
                            amountFull, b);
            }
        }
        else {
<span class="nc bnc" id="L726" title="All 2 branches missed.">            if (progressBar.isIndeterminate()) {</span>
<span class="nc" id="L727">                boxRect = getBox(boxRect);</span>
<span class="nc" id="L728">                paintString(g, x, y, width, height,</span>
                        boxRect.y, boxRect.height, b);
            } else {
<span class="nc" id="L731">                paintString(g, x, y, width, height, y + height - amountFull,</span>
                        amountFull, b);
            }
        }
<span class="nc" id="L735">    }</span>

    /**
     * Paints the progress string.
     *
     * @param g Graphics used for drawing.
     * @param x x location of bounding box
     * @param y y location of bounding box
     * @param width width of bounding box
     * @param height height of bounding box
     * @param fillStart start location, in x or y depending on orientation,
     *        of the filled portion of the progress bar.
     * @param amountFull size of the fill region, either width or height
     *        depending upon orientation.
     * @param b Insets of the progress bar.
     */
    private void paintString(Graphics g, int x, int y, int width, int height,
                             int fillStart, int amountFull, Insets b) {
<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (!(g instanceof Graphics2D)) {</span>
<span class="nc" id="L754">            return;</span>
        }

<span class="nc" id="L757">        Graphics2D g2 = (Graphics2D)g;</span>
<span class="nc" id="L758">        String progressString = progressBar.getString();</span>
<span class="nc" id="L759">        g2.setFont(progressBar.getFont());</span>
<span class="nc" id="L760">        Point renderLocation = getStringPlacement(g2, progressString,</span>
                                                  x, y, width, height);
<span class="nc" id="L762">        Rectangle oldClip = g2.getClipBounds();</span>

<span class="nc bnc" id="L764" title="All 2 branches missed.">        if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc" id="L765">            g2.setColor(getSelectionBackground());</span>
<span class="nc" id="L766">            SwingUtilities2.drawString(progressBar, g2, progressString,</span>
                                       renderLocation.x, renderLocation.y);
<span class="nc" id="L768">            g2.setColor(getSelectionForeground());</span>
<span class="nc" id="L769">            g2.clipRect(fillStart, y, amountFull, height);</span>
<span class="nc" id="L770">            SwingUtilities2.drawString(progressBar, g2, progressString,</span>
                                       renderLocation.x, renderLocation.y);
        } else { // VERTICAL
<span class="nc" id="L773">            g2.setColor(getSelectionBackground());</span>
<span class="nc" id="L774">            AffineTransform rotate =</span>
<span class="nc" id="L775">                    AffineTransform.getRotateInstance(Math.PI/2);</span>
<span class="nc" id="L776">            g2.setFont(progressBar.getFont().deriveFont(rotate));</span>
<span class="nc" id="L777">            renderLocation = getStringPlacement(g2, progressString,</span>
                                                  x, y, width, height);
<span class="nc" id="L779">            SwingUtilities2.drawString(progressBar, g2, progressString,</span>
                                       renderLocation.x, renderLocation.y);
<span class="nc" id="L781">            g2.setColor(getSelectionForeground());</span>
<span class="nc" id="L782">            g2.clipRect(x, fillStart, width, amountFull);</span>
<span class="nc" id="L783">            SwingUtilities2.drawString(progressBar, g2, progressString,</span>
                                       renderLocation.x, renderLocation.y);
        }
<span class="nc" id="L786">        g2.setClip(oldClip);</span>
<span class="nc" id="L787">    }</span>


    /**
     * Designate the place where the progress string will be painted.
     * This implementation places it at the center of the progress
     * bar (in both x and y). Override this if you want to right,
     * left, top, or bottom align the progress string or if you need
     * to nudge it around for any reason.
     */
    protected Point getStringPlacement(Graphics g, String progressString,
                                       int x,int y,int width,int height) {
<span class="nc" id="L799">        FontMetrics fontSizer = SwingUtilities2.getFontMetrics(progressBar, g,</span>
<span class="nc" id="L800">                                            progressBar.getFont());</span>
<span class="nc" id="L801">        int stringWidth = SwingUtilities2.stringWidth(progressBar, fontSizer,</span>
                                                      progressString);

<span class="nc bnc" id="L804" title="All 2 branches missed.">        if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc" id="L805">            return new Point(x + Math.round(width/2 - stringWidth/2),</span>
                             y + ((height +
<span class="nc" id="L807">                                 fontSizer.getAscent() -</span>
<span class="nc" id="L808">                                 fontSizer.getLeading() -</span>
<span class="nc" id="L809">                                 fontSizer.getDescent()) / 2));</span>
        } else { // VERTICAL
<span class="nc" id="L811">            return new Point(x + ((width - fontSizer.getAscent() +</span>
<span class="nc" id="L812">                    fontSizer.getLeading() + fontSizer.getDescent()) / 2),</span>
<span class="nc" id="L813">                    y + Math.round(height/2 - stringWidth/2));</span>
        }
    }


    public Dimension getPreferredSize(JComponent c) {
        Dimension       size;
<span class="nc" id="L820">        Insets          border = progressBar.getInsets();</span>
<span class="nc" id="L821">        FontMetrics     fontSizer = progressBar.getFontMetrics(</span>
<span class="nc" id="L822">                                                  progressBar.getFont());</span>

<span class="nc bnc" id="L824" title="All 2 branches missed.">        if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc" id="L825">            size = new Dimension(getPreferredInnerHorizontal());</span>
            // Ensure that the progress string will fit
<span class="nc bnc" id="L827" title="All 2 branches missed.">            if (progressBar.isStringPainted()) {</span>
                // I'm doing this for completeness.
<span class="nc" id="L829">                String progString = progressBar.getString();</span>
<span class="nc" id="L830">                int stringWidth = SwingUtilities2.stringWidth(</span>
                          progressBar, fontSizer, progString);
<span class="nc bnc" id="L832" title="All 2 branches missed.">                if (stringWidth &gt; size.width) {</span>
<span class="nc" id="L833">                    size.width = stringWidth;</span>
                }
                // This uses both Height and Descent to be sure that
                // there is more than enough room in the progress bar
                // for everything.
                // This does have a strange dependency on
                // getStringPlacememnt() in a funny way.
<span class="nc" id="L840">                int stringHeight = fontSizer.getHeight() +</span>
<span class="nc" id="L841">                                   fontSizer.getDescent();</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">                if (stringHeight &gt; size.height) {</span>
<span class="nc" id="L843">                    size.height = stringHeight;</span>
                }
<span class="nc" id="L845">            }</span>
        } else {
<span class="nc" id="L847">            size = new Dimension(getPreferredInnerVertical());</span>
            // Ensure that the progress string will fit.
<span class="nc bnc" id="L849" title="All 2 branches missed.">            if (progressBar.isStringPainted()) {</span>
<span class="nc" id="L850">                String progString = progressBar.getString();</span>
<span class="nc" id="L851">                int stringHeight = fontSizer.getHeight() +</span>
<span class="nc" id="L852">                        fontSizer.getDescent();</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">                if (stringHeight &gt; size.width) {</span>
<span class="nc" id="L854">                    size.width = stringHeight;</span>
                }
                // This is also for completeness.
<span class="nc" id="L857">                int stringWidth = SwingUtilities2.stringWidth(</span>
                                       progressBar, fontSizer, progString);
<span class="nc bnc" id="L859" title="All 2 branches missed.">                if (stringWidth &gt; size.height) {</span>
<span class="nc" id="L860">                    size.height = stringWidth;</span>
                }
            }
        }

<span class="nc" id="L865">        size.width += border.left + border.right;</span>
<span class="nc" id="L866">        size.height += border.top + border.bottom;</span>
<span class="nc" id="L867">        return size;</span>
    }

    /**
     * The Minimum size for this component is 10. The rationale here
     * is that there should be at least one pixel per 10 percent.
     */
    public Dimension getMinimumSize(JComponent c) {
<span class="nc" id="L875">        Dimension pref = getPreferredSize(progressBar);</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">        if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc" id="L877">            pref.width = 10;</span>
        } else {
<span class="nc" id="L879">            pref.height = 10;</span>
        }
<span class="nc" id="L881">        return pref;</span>
    }

    public Dimension getMaximumSize(JComponent c) {
<span class="nc" id="L885">        Dimension pref = getPreferredSize(progressBar);</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">        if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {</span>
<span class="nc" id="L887">            pref.width = Short.MAX_VALUE;</span>
        } else {
<span class="nc" id="L889">            pref.height = Short.MAX_VALUE;</span>
        }
<span class="nc" id="L891">        return pref;</span>
    }

    /**
     * Gets the index of the current animation frame.
     *
     * @since 1.4
     */
    protected int getAnimationIndex() {
<span class="nc" id="L900">        return animationIndex;</span>
    }

    /**
     * Returns the number of frames for the complete animation loop
     * used by an indeterminate JProgessBar. The progress chunk will go
     * from one end to the other and back during the entire loop. This
     * visual behavior may be changed by subclasses in other Look and Feels.
     *
     * @return the number of frames
     * @since 1.6
     */
    protected final int getFrameCount() {
<span class="nc" id="L913">        return numFrames;</span>
    }

    /**
     * Sets the index of the current animation frame
     * to the specified value and requests that the
     * progress bar be repainted.
     * Subclasses that don't use the default painting code
     * might need to override this method
     * to change the way that the &lt;code&gt;repaint&lt;/code&gt; method
     * is invoked.
     *
     * @param newValue the new animation index; no checking
     *                 is performed on its value
     * @see #incrementAnimationIndex
     *
     * @since 1.4
     */
    protected void setAnimationIndex(int newValue) {
<span class="nc bnc" id="L932" title="All 2 branches missed.">        if (animationIndex != newValue) {</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">            if (sizeChanged()) {</span>
<span class="nc" id="L934">                animationIndex = newValue;</span>
<span class="nc" id="L935">                maxPosition = 0;  //needs to be recalculated</span>
<span class="nc" id="L936">                delta = 0.0;      //needs to be recalculated</span>
<span class="nc" id="L937">                progressBar.repaint();</span>
<span class="nc" id="L938">                return;</span>
            }

            //Get the previous box drawn.
<span class="nc" id="L942">            nextPaintRect = getBox(nextPaintRect);</span>

            //Update the frame number.
<span class="nc" id="L945">            animationIndex = newValue;</span>

            //Get the next box to draw.
<span class="nc bnc" id="L948" title="All 2 branches missed.">            if (nextPaintRect != null) {</span>
<span class="nc" id="L949">                boxRect = getBox(boxRect);</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">                if (boxRect != null) {</span>
<span class="nc" id="L951">                    nextPaintRect.add(boxRect);</span>
                }
            }
        } else { //animationIndex == newValue
<span class="nc" id="L955">            return;</span>
        }

<span class="nc bnc" id="L958" title="All 2 branches missed.">        if (nextPaintRect != null) {</span>
<span class="nc" id="L959">            progressBar.repaint(nextPaintRect);</span>
        } else {
<span class="nc" id="L961">            progressBar.repaint();</span>
        }
<span class="nc" id="L963">    }</span>

    private boolean sizeChanged() {
<span class="nc bnc" id="L966" title="All 4 branches missed.">        if ((oldComponentInnards == null) || (componentInnards == null)) {</span>
<span class="nc" id="L967">            return true;</span>
        }

<span class="nc" id="L970">        oldComponentInnards.setRect(componentInnards);</span>
<span class="nc" id="L971">        componentInnards = SwingUtilities.calculateInnerArea(progressBar,</span>
                                                             componentInnards);
<span class="nc bnc" id="L973" title="All 2 branches missed.">        return !oldComponentInnards.equals(componentInnards);</span>
    }

    /**
     * Sets the index of the current animation frame,
     * to the next valid value,
     * which results in the progress bar being repainted.
     * The next valid value is, by default,
     * the current animation index plus one.
     * If the new value would be too large,
     * this method sets the index to 0.
     * Subclasses might need to override this method
     * to ensure that the index does not go over
     * the number of frames needed for the particular
     * progress bar instance.
     * This method is invoked by the default animation thread
     * every &lt;em&gt;X&lt;/em&gt; milliseconds,
     * where &lt;em&gt;X&lt;/em&gt; is specified by the &quot;ProgressBar.repaintInterval&quot;
     * UI default.
     *
     * @see #setAnimationIndex
     * @since 1.4
     */
    protected void incrementAnimationIndex() {
<span class="nc" id="L997">        int newValue = getAnimationIndex() + 1;</span>

<span class="nc bnc" id="L999" title="All 2 branches missed.">        if (newValue &lt; numFrames) {</span>
<span class="nc" id="L1000">            setAnimationIndex(newValue);</span>
        } else {
<span class="nc" id="L1002">            setAnimationIndex(0);</span>
        }
<span class="nc" id="L1004">    }</span>

    /**
     * Returns the desired number of milliseconds between repaints.
     * This value is meaningful
     * only if the progress bar is in indeterminate mode.
     * The repaint interval determines how often the
     * default animation thread's timer is fired.
     * It's also used by the default indeterminate progress bar
     * painting code when determining
     * how far to move the bouncing box per frame.
     * The repaint interval is specified by
     * the &quot;ProgressBar.repaintInterval&quot; UI default.
     *
     * @return  the repaint interval, in milliseconds
     */
    private int getRepaintInterval() {
<span class="nc" id="L1021">        return repaintInterval;</span>
    }

    private int initRepaintInterval() {
<span class="nc" id="L1025">        repaintInterval = DefaultLookup.getInt(progressBar,</span>
                this, &quot;ProgressBar.repaintInterval&quot;, 50);
<span class="nc" id="L1027">        return repaintInterval;</span>
    }

    /**
     * Returns the number of milliseconds per animation cycle.
     * This value is meaningful
     * only if the progress bar is in indeterminate mode.
     * The cycle time is used by the default indeterminate progress bar
     * painting code when determining
     * how far to move the bouncing box per frame.
     * The cycle time is specified by
     * the &quot;ProgressBar.cycleTime&quot; UI default
     * and adjusted, if necessary,
     * by the initIndeterminateDefaults method.
     *
     * @return  the cycle time, in milliseconds
     */
    private int getCycleTime() {
<span class="nc" id="L1045">        return cycleTime;</span>
    }

    private int initCycleTime() {
<span class="nc" id="L1049">        cycleTime = DefaultLookup.getInt(progressBar, this,</span>
                &quot;ProgressBar.cycleTime&quot;, 3000);
<span class="nc" id="L1051">        return cycleTime;</span>
    }


    /** Initialize cycleTime, repaintInterval, numFrames, animationIndex. */
    private void initIndeterminateDefaults() {
<span class="nc" id="L1057">        initRepaintInterval(); //initialize repaint interval</span>
<span class="nc" id="L1058">        initCycleTime();       //initialize cycle length</span>

        // Make sure repaintInterval is reasonable.
<span class="nc bnc" id="L1061" title="All 2 branches missed.">        if (repaintInterval &lt;= 0) {</span>
<span class="nc" id="L1062">            repaintInterval = 100;</span>
        }

        // Make sure cycleTime is reasonable.
<span class="nc bnc" id="L1066" title="All 2 branches missed.">        if (repaintInterval &gt; cycleTime) {</span>
<span class="nc" id="L1067">            cycleTime = repaintInterval * 20;</span>
        } else {
            // Force cycleTime to be a even multiple of repaintInterval.
<span class="nc" id="L1070">            int factor = (int)Math.ceil(</span>
                                 ((double)cycleTime)
                               / ((double)repaintInterval*2));
<span class="nc" id="L1073">            cycleTime = repaintInterval*factor*2;</span>
        }
<span class="nc" id="L1075">    }</span>

    /**
     * Invoked by PropertyChangeHandler.
     *
     *  NOTE: This might not be invoked until after the first
     *  paintIndeterminate call.
     */
    private void initIndeterminateValues() {
<span class="nc" id="L1084">        initIndeterminateDefaults();</span>
        //assert cycleTime/repaintInterval is a whole multiple of 2.
<span class="nc" id="L1086">        numFrames = cycleTime/repaintInterval;</span>
<span class="nc" id="L1087">        initAnimationIndex();</span>

<span class="nc" id="L1089">        boxRect = new Rectangle();</span>
<span class="nc" id="L1090">        nextPaintRect = new Rectangle();</span>
<span class="nc" id="L1091">        componentInnards = new Rectangle();</span>
<span class="nc" id="L1092">        oldComponentInnards = new Rectangle();</span>

        // we only bother installing the HierarchyChangeListener if we
        // are indeterminate
<span class="nc" id="L1096">        progressBar.addHierarchyListener(getHandler());</span>

        // start the animation thread if necessary
<span class="nc bnc" id="L1099" title="All 2 branches missed.">        if (progressBar.isDisplayable()) {</span>
<span class="nc" id="L1100">            startAnimationTimer();</span>
        }
<span class="nc" id="L1102">    }</span>

    /** Invoked by PropertyChangeHandler. */
    private void cleanUpIndeterminateValues() {
        // stop the animation thread if necessary
<span class="nc bnc" id="L1107" title="All 2 branches missed.">        if (progressBar.isDisplayable()) {</span>
<span class="nc" id="L1108">            stopAnimationTimer();</span>
        }

<span class="nc" id="L1111">        cycleTime = repaintInterval = 0;</span>
<span class="nc" id="L1112">        numFrames = animationIndex = 0;</span>
<span class="nc" id="L1113">        maxPosition = 0;</span>
<span class="nc" id="L1114">        delta = 0.0;</span>

<span class="nc" id="L1116">        boxRect = nextPaintRect = null;</span>
<span class="nc" id="L1117">        componentInnards = oldComponentInnards = null;</span>

<span class="nc" id="L1119">        progressBar.removeHierarchyListener(getHandler());</span>
<span class="nc" id="L1120">    }</span>

    // Called from initIndeterminateValues to initialize the animation index.
    // This assumes that numFrames is set to a correct value.
    private void initAnimationIndex() {
<span class="nc bnc" id="L1125" title="All 2 branches missed.">        if ((progressBar.getOrientation() == JProgressBar.HORIZONTAL) &amp;&amp;</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">            (BasicGraphicsUtils.isLeftToRight(progressBar))) {</span>
            // If this is a left-to-right progress bar,
            // start at the first frame.
<span class="nc" id="L1129">            setAnimationIndex(0);</span>
        } else {
            // If we go right-to-left or vertically, start at the right/bottom.
<span class="nc" id="L1132">            setAnimationIndex(numFrames/2);</span>
        }
<span class="nc" id="L1134">    }</span>

    //
    // Animation Thread
    //
    /**
     * Implements an animation thread that invokes repaint
     * at a fixed rate.  If ADJUSTTIMER is true, this thread
     * will continuously adjust the repaint interval to
     * try to make the actual time between repaints match
     * the requested rate.
     */
<span class="nc" id="L1146">    private class Animator implements ActionListener {</span>
        private Timer timer;
        private long previousDelay; //used to tune the repaint interval
        private int interval; //the fixed repaint interval
        private long lastCall; //the last time actionPerformed was called
<span class="nc" id="L1151">        private int MINIMUM_DELAY = 5;</span>

        /**
         * Creates a timer if one doesn't already exist,
         * then starts the timer thread.
         */
        private void start(int interval) {
<span class="nc" id="L1158">            previousDelay = interval;</span>
<span class="nc" id="L1159">            lastCall = 0;</span>

<span class="nc bnc" id="L1161" title="All 2 branches missed.">            if (timer == null) {</span>
<span class="nc" id="L1162">                timer = new Timer(interval, this);</span>
            } else {
<span class="nc" id="L1164">                timer.setDelay(interval);</span>
            }

<span class="nc bnc" id="L1167" title="All 2 branches missed.">            if (ADJUSTTIMER) {</span>
<span class="nc" id="L1168">                timer.setRepeats(false);</span>
<span class="nc" id="L1169">                timer.setCoalesce(false);</span>
            }

<span class="nc" id="L1172">            timer.start();</span>
<span class="nc" id="L1173">        }</span>

        /**
         * Stops the timer thread.
         */
        private void stop() {
<span class="nc" id="L1179">            timer.stop();</span>
<span class="nc" id="L1180">        }</span>

        /**
         * Reacts to the timer's action events.
         */
        public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if (ADJUSTTIMER) {</span>
<span class="nc" id="L1187">                long time = System.currentTimeMillis();</span>

<span class="nc bnc" id="L1189" title="All 2 branches missed.">                if (lastCall &gt; 0) { //adjust nextDelay</span>
                //XXX maybe should cache this after a while
                    //actual = time - lastCall
                    //difference = actual - interval
                    //nextDelay = previousDelay - difference
                    //          = previousDelay - (time - lastCall - interval)
<span class="nc" id="L1195">                   int nextDelay = (int)(previousDelay</span>
                                          - time + lastCall
<span class="nc" id="L1197">                                          + getRepaintInterval());</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">                    if (nextDelay &lt; MINIMUM_DELAY) {</span>
<span class="nc" id="L1199">                        nextDelay = MINIMUM_DELAY;</span>
                    }
<span class="nc" id="L1201">                    timer.setInitialDelay(nextDelay);</span>
<span class="nc" id="L1202">                    previousDelay = nextDelay;</span>
                }
<span class="nc" id="L1204">                timer.start();</span>
<span class="nc" id="L1205">                lastCall = time;</span>
            }

<span class="nc" id="L1208">            incrementAnimationIndex(); //paint next frame</span>
<span class="nc" id="L1209">        }</span>
    }


    /**
     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.
     * Instantiate it only within subclasses of {@code BasicProgressBarUI}.
     */
<span class="nc" id="L1217">    public class ChangeHandler implements ChangeListener {</span>
        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.
        public void stateChanged(ChangeEvent e) {
<span class="nc" id="L1223">            getHandler().stateChanged(e);</span>
<span class="nc" id="L1224">        }</span>
    }


<span class="nc" id="L1228">    private class Handler implements ChangeListener, PropertyChangeListener, HierarchyListener {</span>
        // ChangeListener
        public void stateChanged(ChangeEvent e) {
<span class="nc" id="L1231">            BoundedRangeModel model = progressBar.getModel();</span>
<span class="nc" id="L1232">            int newRange = model.getMaximum() - model.getMinimum();</span>
            int newPercent;
<span class="nc" id="L1234">            int oldPercent = getCachedPercent();</span>

<span class="nc bnc" id="L1236" title="All 2 branches missed.">            if (newRange &gt; 0) {</span>
<span class="nc" id="L1237">                newPercent = (int)((100 * (long)model.getValue()) / newRange);</span>
            } else {
<span class="nc" id="L1239">                newPercent = 0;</span>
            }

<span class="nc bnc" id="L1242" title="All 2 branches missed.">            if (newPercent != oldPercent) {</span>
<span class="nc" id="L1243">                setCachedPercent(newPercent);</span>
<span class="nc" id="L1244">                progressBar.repaint();</span>
            }
<span class="nc" id="L1246">        }</span>

        // PropertyChangeListener
        public void propertyChange(PropertyChangeEvent e) {
<span class="nc" id="L1250">            String prop = e.getPropertyName();</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">            if (&quot;indeterminate&quot; == prop) {</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">                if (progressBar.isIndeterminate()) {</span>
<span class="nc" id="L1253">                    initIndeterminateValues();</span>
                } else {
                    //clean up
<span class="nc" id="L1256">                    cleanUpIndeterminateValues();</span>
                }
<span class="nc" id="L1258">                progressBar.repaint();</span>
            }
<span class="nc" id="L1260">        }</span>

        // we don't want the animation to keep running if we're not displayable
        public void hierarchyChanged(HierarchyEvent he) {
<span class="nc bnc" id="L1264" title="All 2 branches missed.">            if ((he.getChangeFlags() &amp; HierarchyEvent.DISPLAYABILITY_CHANGED) != 0) {</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">                if (progressBar.isIndeterminate()) {</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">                    if (progressBar.isDisplayable()) {</span>
<span class="nc" id="L1267">                        startAnimationTimer();</span>
                    } else {
<span class="nc" id="L1269">                        stopAnimationTimer();</span>
                    }
                }
            }
<span class="nc" id="L1273">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>