<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BasicTabbedPaneUI.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.plaf.basic</a> &gt; <span class="el_source">BasicTabbedPaneUI.java</span></div><h1>BasicTabbedPaneUI.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.plaf.basic;

import sun.swing.SwingUtilities2;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.plaf.*;
import javax.swing.text.View;

import java.awt.*;
import java.awt.event.*;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import java.util.Vector;
import java.util.Hashtable;

import sun.swing.DefaultLookup;
import sun.swing.UIAction;

/**
 * A Basic L&amp;amp;F implementation of TabbedPaneUI.
 *
 * @author Amy Fowler
 * @author Philip Milne
 * @author Steve Wilson
 * @author Tom Santos
 * @author Dave Moore
 */
<span class="nc" id="L54">public class BasicTabbedPaneUI extends TabbedPaneUI implements SwingConstants {</span>


// Instance variables initialized at installation

    protected JTabbedPane tabPane;

    protected Color highlight;
    protected Color lightHighlight;
    protected Color shadow;
    protected Color darkShadow;
    protected Color focus;
    private   Color selectedColor;

    protected int textIconGap;

    protected int tabRunOverlay;

    protected Insets tabInsets;
    protected Insets selectedTabPadInsets;
    protected Insets tabAreaInsets;
    protected Insets contentBorderInsets;
    private boolean tabsOverlapBorder;
<span class="nc" id="L77">    private boolean tabsOpaque = true;</span>
<span class="nc" id="L78">    private boolean contentOpaque = true;</span>

    /**
     * As of Java 2 platform v1.3 this previously undocumented field is no
     * longer used.
     * Key bindings are now defined by the LookAndFeel, please refer to
     * the key bindings specification for further details.
     *
     * @deprecated As of Java 2 platform v1.3.
     */
    @Deprecated
    protected KeyStroke upKey;
    /**
     * As of Java 2 platform v1.3 this previously undocumented field is no
     * longer used.
     * Key bindings are now defined by the LookAndFeel, please refer to
     * the key bindings specification for further details.
     *
     * @deprecated As of Java 2 platform v1.3.
     */
    @Deprecated
    protected KeyStroke downKey;
    /**
     * As of Java 2 platform v1.3 this previously undocumented field is no
     * longer used.
     * Key bindings are now defined by the LookAndFeel, please refer to
     * the key bindings specification for further details.
     *
     * @deprecated As of Java 2 platform v1.3.
     */
    @Deprecated
    protected KeyStroke leftKey;
    /**
     * As of Java 2 platform v1.3 this previously undocumented field is no
     * longer used.
     * Key bindings are now defined by the LookAndFeel, please refer to
     * the key bindings specification for further details.
     *
     * @deprecated As of Java 2 platform v1.3.
     */
    @Deprecated
    protected KeyStroke rightKey;


// Transient variables (recalculated each time TabbedPane is layed out)

<span class="nc" id="L124">    protected int tabRuns[] = new int[10];</span>
<span class="nc" id="L125">    protected int runCount = 0;</span>
<span class="nc" id="L126">    protected int selectedRun = -1;</span>
<span class="nc" id="L127">    protected Rectangle rects[] = new Rectangle[0];</span>
    protected int maxTabHeight;
    protected int maxTabWidth;

// Listeners

    protected ChangeListener tabChangeListener;
    protected PropertyChangeListener propertyChangeListener;
    protected MouseListener mouseListener;
    protected FocusListener focusListener;

// Private instance data

<span class="nc" id="L140">    private Insets currentPadInsets = new Insets(0,0,0,0);</span>
<span class="nc" id="L141">    private Insets currentTabAreaInsets = new Insets(0,0,0,0);</span>

    private Component visibleComponent;
    // PENDING(api): See comment for ContainerHandler
    private Vector&lt;View&gt; htmlViews;

    private Hashtable&lt;Integer, Integer&gt; mnemonicToIndexMap;

    /**
     * InputMap used for mnemonics. Only non-null if the JTabbedPane has
     * mnemonics associated with it. Lazily created in initMnemonics.
     */
    private InputMap mnemonicInputMap;

    // For use when tabLayoutPolicy = SCROLL_TAB_LAYOUT
    private ScrollableTabSupport tabScroller;

    private TabContainer tabContainer;

    /**
     * A rectangle used for general layout calculations in order
     * to avoid constructing many new Rectangles on the fly.
     */
<span class="nc" id="L164">    protected transient Rectangle calcRect = new Rectangle(0,0,0,0);</span>

    /**
     * Tab that has focus.
     */
    private int focusIndex;

    /**
     * Combined listeners.
     */
    private Handler handler;

    /**
     * Index of the tab the mouse is over.
     */
    private int rolloverTabIndex;

    /**
     * This is set to true when a component is added/removed from the tab
     * pane and set to false when layout happens.  If true it indicates that
     * tabRuns is not valid and shouldn't be used.
     */
    private boolean isRunsDirty;

    private boolean calculatedBaseline;
    private int baseline;

// UI creation

    public static ComponentUI createUI(JComponent c) {
<span class="nc" id="L194">        return new BasicTabbedPaneUI();</span>
    }

    static void loadActionMap(LazyActionMap map) {
<span class="nc" id="L198">        map.put(new Actions(Actions.NEXT));</span>
<span class="nc" id="L199">        map.put(new Actions(Actions.PREVIOUS));</span>
<span class="nc" id="L200">        map.put(new Actions(Actions.RIGHT));</span>
<span class="nc" id="L201">        map.put(new Actions(Actions.LEFT));</span>
<span class="nc" id="L202">        map.put(new Actions(Actions.UP));</span>
<span class="nc" id="L203">        map.put(new Actions(Actions.DOWN));</span>
<span class="nc" id="L204">        map.put(new Actions(Actions.PAGE_UP));</span>
<span class="nc" id="L205">        map.put(new Actions(Actions.PAGE_DOWN));</span>
<span class="nc" id="L206">        map.put(new Actions(Actions.REQUEST_FOCUS));</span>
<span class="nc" id="L207">        map.put(new Actions(Actions.REQUEST_FOCUS_FOR_VISIBLE));</span>
<span class="nc" id="L208">        map.put(new Actions(Actions.SET_SELECTED));</span>
<span class="nc" id="L209">        map.put(new Actions(Actions.SELECT_FOCUSED));</span>
<span class="nc" id="L210">        map.put(new Actions(Actions.SCROLL_FORWARD));</span>
<span class="nc" id="L211">        map.put(new Actions(Actions.SCROLL_BACKWARD));</span>
<span class="nc" id="L212">    }</span>

// UI Installation/De-installation

    public void installUI(JComponent c) {
<span class="nc" id="L217">        this.tabPane = (JTabbedPane)c;</span>

<span class="nc" id="L219">        calculatedBaseline = false;</span>
<span class="nc" id="L220">        rolloverTabIndex = -1;</span>
<span class="nc" id="L221">        focusIndex = -1;</span>
<span class="nc" id="L222">        c.setLayout(createLayoutManager());</span>
<span class="nc" id="L223">        installComponents();</span>
<span class="nc" id="L224">        installDefaults();</span>
<span class="nc" id="L225">        installListeners();</span>
<span class="nc" id="L226">        installKeyboardActions();</span>
<span class="nc" id="L227">    }</span>

    public void uninstallUI(JComponent c) {
<span class="nc" id="L230">        uninstallKeyboardActions();</span>
<span class="nc" id="L231">        uninstallListeners();</span>
<span class="nc" id="L232">        uninstallDefaults();</span>
<span class="nc" id="L233">        uninstallComponents();</span>
<span class="nc" id="L234">        c.setLayout(null);</span>

<span class="nc" id="L236">        this.tabPane = null;</span>
<span class="nc" id="L237">    }</span>

    /**
     * Invoked by &lt;code&gt;installUI&lt;/code&gt; to create
     * a layout manager object to manage
     * the &lt;code&gt;JTabbedPane&lt;/code&gt;.
     *
     * @return a layout manager object
     *
     * @see TabbedPaneLayout
     * @see javax.swing.JTabbedPane#getTabLayoutPolicy
     */
    protected LayoutManager createLayoutManager() {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (tabPane.getTabLayoutPolicy() == JTabbedPane.SCROLL_TAB_LAYOUT) {</span>
<span class="nc" id="L251">            return new TabbedPaneScrollLayout();</span>
        } else { /* WRAP_TAB_LAYOUT */
<span class="nc" id="L253">            return new TabbedPaneLayout();</span>
        }
    }

    /* In an attempt to preserve backward compatibility for programs
     * which have extended BasicTabbedPaneUI to do their own layout, the
     * UI uses the installed layoutManager (and not tabLayoutPolicy) to
     * determine if scrollTabLayout is enabled.
     */
    private boolean scrollableTabLayoutEnabled() {
<span class="nc" id="L263">        return (tabPane.getLayout() instanceof TabbedPaneScrollLayout);</span>
    }

    /**
     * Creates and installs any required subcomponents for the JTabbedPane.
     * Invoked by installUI.
     *
     * @since 1.4
     */
    protected void installComponents() {
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (scrollableTabLayoutEnabled()) {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (tabScroller == null) {</span>
<span class="nc" id="L275">                tabScroller = new ScrollableTabSupport(tabPane.getTabPlacement());</span>
<span class="nc" id="L276">                tabPane.add(tabScroller.viewport);</span>
            }
        }
<span class="nc" id="L279">        installTabContainer();</span>
<span class="nc" id="L280">    }</span>

    private void installTabContainer() {
<span class="nc bnc" id="L283" title="All 2 branches missed.">         for (int i = 0; i &lt; tabPane.getTabCount(); i++) {</span>
<span class="nc" id="L284">             Component tabComponent = tabPane.getTabComponentAt(i);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">             if (tabComponent != null) {</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                 if(tabContainer == null) {</span>
<span class="nc" id="L287">                     tabContainer = new TabContainer();</span>
                 }
<span class="nc" id="L289">                 tabContainer.add(tabComponent);</span>
             }
         }
<span class="nc bnc" id="L292" title="All 2 branches missed.">         if(tabContainer == null) {</span>
<span class="nc" id="L293">             return;</span>
         }
<span class="nc bnc" id="L295" title="All 2 branches missed.">         if (scrollableTabLayoutEnabled()) {</span>
<span class="nc" id="L296">             tabScroller.tabPanel.add(tabContainer);</span>
         } else {
<span class="nc" id="L298">             tabPane.add(tabContainer);</span>
         }
<span class="nc" id="L300">    }</span>

    /**
     * Creates and returns a JButton that will provide the user
     * with a way to scroll the tabs in a particular direction. The
     * returned JButton must be instance of UIResource.
     *
     * @param direction One of the SwingConstants constants:
     * SOUTH, NORTH, EAST or WEST
     * @return Widget for user to
     * @see javax.swing.JTabbedPane#setTabPlacement
     * @see javax.swing.SwingConstants
     * @throws IllegalArgumentException if direction is not one of
     *         NORTH, SOUTH, EAST or WEST
     * @since 1.5
     */
    protected JButton createScrollButton(int direction) {
<span class="nc bnc" id="L317" title="All 8 branches missed.">        if (direction != SOUTH &amp;&amp; direction != NORTH &amp;&amp; direction != EAST &amp;&amp;</span>
                                  direction != WEST) {
<span class="nc" id="L319">            throw new IllegalArgumentException(&quot;Direction must be one of: &quot; +</span>
                                               &quot;SOUTH, NORTH, EAST or WEST&quot;);
        }
<span class="nc" id="L322">        return new ScrollableTabButton(direction);</span>
    }

    /**
     * Removes any installed subcomponents from the JTabbedPane.
     * Invoked by uninstallUI.
     *
     * @since 1.4
     */
    protected void uninstallComponents() {
<span class="nc" id="L332">        uninstallTabContainer();</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (scrollableTabLayoutEnabled()) {</span>
<span class="nc" id="L334">            tabPane.remove(tabScroller.viewport);</span>
<span class="nc" id="L335">            tabPane.remove(tabScroller.scrollForwardButton);</span>
<span class="nc" id="L336">            tabPane.remove(tabScroller.scrollBackwardButton);</span>
<span class="nc" id="L337">            tabScroller = null;</span>
        }
<span class="nc" id="L339">    }</span>

    private void uninstallTabContainer() {
<span class="nc bnc" id="L342" title="All 2 branches missed.">         if(tabContainer == null) {</span>
<span class="nc" id="L343">             return;</span>
         }
         // Remove all the tabComponents, making sure not to notify
         // the tabbedpane.
<span class="nc" id="L347">         tabContainer.notifyTabbedPane = false;</span>
<span class="nc" id="L348">         tabContainer.removeAll();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">         if(scrollableTabLayoutEnabled()) {</span>
<span class="nc" id="L350">             tabContainer.remove(tabScroller.croppedEdge);</span>
<span class="nc" id="L351">             tabScroller.tabPanel.remove(tabContainer);</span>
         } else {
<span class="nc" id="L353">           tabPane.remove(tabContainer);</span>
         }
<span class="nc" id="L355">         tabContainer = null;</span>
<span class="nc" id="L356">    }</span>

    protected void installDefaults() {
<span class="nc" id="L359">        LookAndFeel.installColorsAndFont(tabPane, &quot;TabbedPane.background&quot;,</span>
                                    &quot;TabbedPane.foreground&quot;, &quot;TabbedPane.font&quot;);
<span class="nc" id="L361">        highlight = UIManager.getColor(&quot;TabbedPane.light&quot;);</span>
<span class="nc" id="L362">        lightHighlight = UIManager.getColor(&quot;TabbedPane.highlight&quot;);</span>
<span class="nc" id="L363">        shadow = UIManager.getColor(&quot;TabbedPane.shadow&quot;);</span>
<span class="nc" id="L364">        darkShadow = UIManager.getColor(&quot;TabbedPane.darkShadow&quot;);</span>
<span class="nc" id="L365">        focus = UIManager.getColor(&quot;TabbedPane.focus&quot;);</span>
<span class="nc" id="L366">        selectedColor = UIManager.getColor(&quot;TabbedPane.selected&quot;);</span>

<span class="nc" id="L368">        textIconGap = UIManager.getInt(&quot;TabbedPane.textIconGap&quot;);</span>
<span class="nc" id="L369">        tabInsets = UIManager.getInsets(&quot;TabbedPane.tabInsets&quot;);</span>
<span class="nc" id="L370">        selectedTabPadInsets = UIManager.getInsets(&quot;TabbedPane.selectedTabPadInsets&quot;);</span>
<span class="nc" id="L371">        tabAreaInsets = UIManager.getInsets(&quot;TabbedPane.tabAreaInsets&quot;);</span>
<span class="nc" id="L372">        tabsOverlapBorder = UIManager.getBoolean(&quot;TabbedPane.tabsOverlapBorder&quot;);</span>
<span class="nc" id="L373">        contentBorderInsets = UIManager.getInsets(&quot;TabbedPane.contentBorderInsets&quot;);</span>
<span class="nc" id="L374">        tabRunOverlay = UIManager.getInt(&quot;TabbedPane.tabRunOverlay&quot;);</span>
<span class="nc" id="L375">        tabsOpaque = UIManager.getBoolean(&quot;TabbedPane.tabsOpaque&quot;);</span>
<span class="nc" id="L376">        contentOpaque = UIManager.getBoolean(&quot;TabbedPane.contentOpaque&quot;);</span>
<span class="nc" id="L377">        Object opaque = UIManager.get(&quot;TabbedPane.opaque&quot;);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (opaque == null) {</span>
<span class="nc" id="L379">            opaque = Boolean.FALSE;</span>
        }
<span class="nc" id="L381">        LookAndFeel.installProperty(tabPane, &quot;opaque&quot;, opaque);</span>

        // Fix for 6711145 BasicTabbedPanuUI should not throw a NPE if these
        // keys are missing. So we are setting them to there default values here
        // if the keys are missing.
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (tabInsets == null) tabInsets = new Insets(0,4,1,4);</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (selectedTabPadInsets == null) selectedTabPadInsets = new Insets(2,2,2,1);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (tabAreaInsets == null) tabAreaInsets = new Insets(3,2,0,2);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        if (contentBorderInsets == null) contentBorderInsets = new Insets(2,2,3,3);</span>
<span class="nc" id="L390">    }</span>

    protected void uninstallDefaults() {
<span class="nc" id="L393">        highlight = null;</span>
<span class="nc" id="L394">        lightHighlight = null;</span>
<span class="nc" id="L395">        shadow = null;</span>
<span class="nc" id="L396">        darkShadow = null;</span>
<span class="nc" id="L397">        focus = null;</span>
<span class="nc" id="L398">        tabInsets = null;</span>
<span class="nc" id="L399">        selectedTabPadInsets = null;</span>
<span class="nc" id="L400">        tabAreaInsets = null;</span>
<span class="nc" id="L401">        contentBorderInsets = null;</span>
<span class="nc" id="L402">    }</span>

    protected void installListeners() {
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if ((propertyChangeListener = createPropertyChangeListener()) != null) {</span>
<span class="nc" id="L406">            tabPane.addPropertyChangeListener(propertyChangeListener);</span>
        }
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if ((tabChangeListener = createChangeListener()) != null) {</span>
<span class="nc" id="L409">            tabPane.addChangeListener(tabChangeListener);</span>
        }
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if ((mouseListener = createMouseListener()) != null) {</span>
<span class="nc" id="L412">            tabPane.addMouseListener(mouseListener);</span>
        }
<span class="nc" id="L414">        tabPane.addMouseMotionListener(getHandler());</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if ((focusListener = createFocusListener()) != null) {</span>
<span class="nc" id="L416">            tabPane.addFocusListener(focusListener);</span>
        }
<span class="nc" id="L418">        tabPane.addContainerListener(getHandler());</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (tabPane.getTabCount()&gt;0) {</span>
<span class="nc" id="L420">            htmlViews = createHTMLVector();</span>
        }
<span class="nc" id="L422">    }</span>

    protected void uninstallListeners() {
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (mouseListener != null) {</span>
<span class="nc" id="L426">            tabPane.removeMouseListener(mouseListener);</span>
<span class="nc" id="L427">            mouseListener = null;</span>
        }
<span class="nc" id="L429">        tabPane.removeMouseMotionListener(getHandler());</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (focusListener != null) {</span>
<span class="nc" id="L431">            tabPane.removeFocusListener(focusListener);</span>
<span class="nc" id="L432">            focusListener = null;</span>
        }

<span class="nc" id="L435">        tabPane.removeContainerListener(getHandler());</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (htmlViews!=null) {</span>
<span class="nc" id="L437">            htmlViews.removeAllElements();</span>
<span class="nc" id="L438">            htmlViews = null;</span>
        }
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (tabChangeListener != null) {</span>
<span class="nc" id="L441">            tabPane.removeChangeListener(tabChangeListener);</span>
<span class="nc" id="L442">            tabChangeListener = null;</span>
        }
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (propertyChangeListener != null) {</span>
<span class="nc" id="L445">            tabPane.removePropertyChangeListener(propertyChangeListener);</span>
<span class="nc" id="L446">            propertyChangeListener = null;</span>
        }
<span class="nc" id="L448">        handler = null;</span>
<span class="nc" id="L449">    }</span>

    protected MouseListener createMouseListener() {
<span class="nc" id="L452">        return getHandler();</span>
    }

    protected FocusListener createFocusListener() {
<span class="nc" id="L456">        return getHandler();</span>
    }

    protected ChangeListener createChangeListener() {
<span class="nc" id="L460">        return getHandler();</span>
    }

    protected PropertyChangeListener createPropertyChangeListener() {
<span class="nc" id="L464">        return getHandler();</span>
    }

    private Handler getHandler() {
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (handler == null) {</span>
<span class="nc" id="L469">            handler = new Handler();</span>
        }
<span class="nc" id="L471">        return handler;</span>
    }

    protected void installKeyboardActions() {
<span class="nc" id="L475">        InputMap km = getInputMap(JComponent.</span>
                                  WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

<span class="nc" id="L478">        SwingUtilities.replaceUIInputMap(tabPane, JComponent.</span>
                                         WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,
                                         km);
<span class="nc" id="L481">        km = getInputMap(JComponent.WHEN_FOCUSED);</span>
<span class="nc" id="L482">        SwingUtilities.replaceUIInputMap(tabPane, JComponent.WHEN_FOCUSED, km);</span>

<span class="nc" id="L484">        LazyActionMap.installLazyActionMap(tabPane, BasicTabbedPaneUI.class,</span>
                                           &quot;TabbedPane.actionMap&quot;);
<span class="nc" id="L486">        updateMnemonics();</span>
<span class="nc" id="L487">    }</span>

    InputMap getInputMap(int condition) {
<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (condition == JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT) {</span>
<span class="nc" id="L491">            return (InputMap)DefaultLookup.get(tabPane, this,</span>
                                               &quot;TabbedPane.ancestorInputMap&quot;);
        }
<span class="nc bnc" id="L494" title="All 2 branches missed.">        else if (condition == JComponent.WHEN_FOCUSED) {</span>
<span class="nc" id="L495">            return (InputMap)DefaultLookup.get(tabPane, this,</span>
                                               &quot;TabbedPane.focusInputMap&quot;);
        }
<span class="nc" id="L498">        return null;</span>
    }

    protected void uninstallKeyboardActions() {
<span class="nc" id="L502">        SwingUtilities.replaceUIActionMap(tabPane, null);</span>
<span class="nc" id="L503">        SwingUtilities.replaceUIInputMap(tabPane, JComponent.</span>
                                         WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,
                                         null);
<span class="nc" id="L506">        SwingUtilities.replaceUIInputMap(tabPane, JComponent.WHEN_FOCUSED,</span>
                                         null);
<span class="nc" id="L508">        SwingUtilities.replaceUIInputMap(tabPane,</span>
                                         JComponent.WHEN_IN_FOCUSED_WINDOW,
                                         null);
<span class="nc" id="L511">        mnemonicToIndexMap = null;</span>
<span class="nc" id="L512">        mnemonicInputMap = null;</span>
<span class="nc" id="L513">    }</span>

    /**
     * Reloads the mnemonics. This should be invoked when a memonic changes,
     * when the title of a mnemonic changes, or when tabs are added/removed.
     */
    private void updateMnemonics() {
<span class="nc" id="L520">        resetMnemonics();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        for (int counter = tabPane.getTabCount() - 1; counter &gt;= 0;</span>
<span class="nc" id="L522">             counter--) {</span>
<span class="nc" id="L523">            int mnemonic = tabPane.getMnemonicAt(counter);</span>

<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (mnemonic &gt; 0) {</span>
<span class="nc" id="L526">                addMnemonic(counter, mnemonic);</span>
            }
        }
<span class="nc" id="L529">    }</span>

    /**
     * Resets the mnemonics bindings to an empty state.
     */
    private void resetMnemonics() {
<span class="nc bnc" id="L535" title="All 2 branches missed.">        if (mnemonicToIndexMap != null) {</span>
<span class="nc" id="L536">            mnemonicToIndexMap.clear();</span>
<span class="nc" id="L537">            mnemonicInputMap.clear();</span>
        }
<span class="nc" id="L539">    }</span>

    /**
     * Adds the specified mnemonic at the specified index.
     */
    private void addMnemonic(int index, int mnemonic) {
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (mnemonicToIndexMap == null) {</span>
<span class="nc" id="L546">            initMnemonics();</span>
        }
<span class="nc" id="L548">        mnemonicInputMap.put(KeyStroke.getKeyStroke(mnemonic, BasicLookAndFeel.getFocusAcceleratorKeyMask()),</span>
                             &quot;setSelectedIndex&quot;);
<span class="nc" id="L550">        mnemonicToIndexMap.put(Integer.valueOf(mnemonic), Integer.valueOf(index));</span>
<span class="nc" id="L551">    }</span>

    /**
     * Installs the state needed for mnemonics.
     */
    private void initMnemonics() {
<span class="nc" id="L557">        mnemonicToIndexMap = new Hashtable&lt;Integer, Integer&gt;();</span>
<span class="nc" id="L558">        mnemonicInputMap = new ComponentInputMapUIResource(tabPane);</span>
<span class="nc" id="L559">        mnemonicInputMap.setParent(SwingUtilities.getUIInputMap(tabPane,</span>
                              JComponent.WHEN_IN_FOCUSED_WINDOW));
<span class="nc" id="L561">        SwingUtilities.replaceUIInputMap(tabPane,</span>
                              JComponent.WHEN_IN_FOCUSED_WINDOW,
                                         mnemonicInputMap);
<span class="nc" id="L564">    }</span>

    /**
     * Sets the tab the mouse is over by location. This is a cover method
     * for &lt;code&gt;setRolloverTab(tabForCoordinate(x, y, false))&lt;/code&gt;.
     */
    private void setRolloverTab(int x, int y) {
        // NOTE:
        // This calls in with false otherwise it could trigger a validate,
        // which should NOT happen if the user is only dragging the
        // mouse around.
<span class="nc" id="L575">        setRolloverTab(tabForCoordinate(tabPane, x, y, false));</span>
<span class="nc" id="L576">    }</span>

    /**
     * Sets the tab the mouse is currently over to &lt;code&gt;index&lt;/code&gt;.
     * &lt;code&gt;index&lt;/code&gt; will be -1 if the mouse is no longer over any
     * tab. No checking is done to ensure the passed in index identifies a
     * valid tab.
     *
     * @param index Index of the tab the mouse is over.
     * @since 1.5
     */
    protected void setRolloverTab(int index) {
<span class="nc" id="L588">        rolloverTabIndex = index;</span>
<span class="nc" id="L589">    }</span>

    /**
     * Returns the tab the mouse is currently over, or {@code -1} if the mouse is no
     * longer over any tab.
     *
     * @return the tab the mouse is currently over, or {@code -1} if the mouse is no
     * longer over any tab
     * @since 1.5
     */
    protected int getRolloverTab() {
<span class="nc" id="L600">        return rolloverTabIndex;</span>
    }

    public Dimension getMinimumSize(JComponent c) {
        // Default to LayoutManager's minimumLayoutSize
<span class="nc" id="L605">        return null;</span>
    }

    public Dimension getMaximumSize(JComponent c) {
        // Default to LayoutManager's maximumLayoutSize
<span class="nc" id="L610">        return null;</span>
    }

    /**
     * Returns the baseline.
     *
     * @throws NullPointerException {@inheritDoc}
     * @throws IllegalArgumentException {@inheritDoc}
     * @see javax.swing.JComponent#getBaseline(int, int)
     * @since 1.6
     */
    public int getBaseline(JComponent c, int width, int height) {
<span class="nc" id="L622">        super.getBaseline(c, width, height);</span>
<span class="nc" id="L623">        int baseline = calculateBaselineIfNecessary();</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">        if (baseline != -1) {</span>
<span class="nc" id="L625">            int placement = tabPane.getTabPlacement();</span>
<span class="nc" id="L626">            Insets insets = tabPane.getInsets();</span>
<span class="nc" id="L627">            Insets tabAreaInsets = getTabAreaInsets(placement);</span>
<span class="nc bnc" id="L628" title="All 4 branches missed.">            switch(placement) {</span>
            case JTabbedPane.TOP:
<span class="nc" id="L630">                baseline += insets.top + tabAreaInsets.top;</span>
<span class="nc" id="L631">                return baseline;</span>
            case JTabbedPane.BOTTOM:
<span class="nc" id="L633">                baseline = height - insets.bottom -</span>
                    tabAreaInsets.bottom - maxTabHeight + baseline;
<span class="nc" id="L635">                return baseline;</span>
            case JTabbedPane.LEFT:
            case JTabbedPane.RIGHT:
<span class="nc" id="L638">                baseline += insets.top + tabAreaInsets.top;</span>
<span class="nc" id="L639">                return baseline;</span>
            }
        }
<span class="nc" id="L642">        return -1;</span>
    }

    /**
     * Returns an enum indicating how the baseline of the component
     * changes as the size changes.
     *
     * @throws NullPointerException {@inheritDoc}
     * @see javax.swing.JComponent#getBaseline(int, int)
     * @since 1.6
     */
    public Component.BaselineResizeBehavior getBaselineResizeBehavior(
            JComponent c) {
<span class="nc" id="L655">        super.getBaselineResizeBehavior(c);</span>
<span class="nc bnc" id="L656" title="All 3 branches missed.">        switch(tabPane.getTabPlacement()) {</span>
        case JTabbedPane.LEFT:
        case JTabbedPane.RIGHT:
        case JTabbedPane.TOP:
<span class="nc" id="L660">            return Component.BaselineResizeBehavior.CONSTANT_ASCENT;</span>
        case JTabbedPane.BOTTOM:
<span class="nc" id="L662">            return Component.BaselineResizeBehavior.CONSTANT_DESCENT;</span>
        }
<span class="nc" id="L664">        return Component.BaselineResizeBehavior.OTHER;</span>
    }

    /**
     * Returns the baseline for the specified tab.
     *
     * @param tab index of tab to get baseline for
     * @exception IndexOutOfBoundsException if index is out of range
     *            (index &amp;lt; 0 || index &amp;gt;= tab count)
     * @return baseline or a value &amp;lt; 0 indicating there is no reasonable
     *                  baseline
     * @since 1.6
     */
    protected int getBaseline(int tab) {
<span class="nc bnc" id="L678" title="All 2 branches missed.">        if (tabPane.getTabComponentAt(tab) != null) {</span>
<span class="nc" id="L679">            int offset = getBaselineOffset();</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">            if (offset != 0) {</span>
                // The offset is not applied to the tab component, and so
                // in general we can't get good alignment like with components
                // in the tab.
<span class="nc" id="L684">                return -1;</span>
            }
<span class="nc" id="L686">            Component c = tabPane.getTabComponentAt(tab);</span>
<span class="nc" id="L687">            Dimension pref = c.getPreferredSize();</span>
<span class="nc" id="L688">            Insets tabInsets = getTabInsets(tabPane.getTabPlacement(), tab);</span>
<span class="nc" id="L689">            int cellHeight = maxTabHeight - tabInsets.top - tabInsets.bottom;</span>
<span class="nc" id="L690">            return c.getBaseline(pref.width, pref.height) +</span>
                    (cellHeight - pref.height) / 2 + tabInsets.top;
        }
        else {
<span class="nc" id="L694">            View view = getTextViewForTab(tab);</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L696">                int viewHeight = (int)view.getPreferredSpan(View.Y_AXIS);</span>
<span class="nc" id="L697">                int baseline = BasicHTML.getHTMLBaseline(</span>
<span class="nc" id="L698">                    view, (int)view.getPreferredSpan(View.X_AXIS), viewHeight);</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">                if (baseline &gt;= 0) {</span>
<span class="nc" id="L700">                    return maxTabHeight / 2 - viewHeight / 2 + baseline +</span>
<span class="nc" id="L701">                        getBaselineOffset();</span>
                }
<span class="nc" id="L703">                return -1;</span>
            }
        }
<span class="nc" id="L706">        FontMetrics metrics = getFontMetrics();</span>
<span class="nc" id="L707">        int fontHeight = metrics.getHeight();</span>
<span class="nc" id="L708">        int fontBaseline = metrics.getAscent();</span>
<span class="nc" id="L709">        return maxTabHeight / 2 - fontHeight / 2 + fontBaseline +</span>
<span class="nc" id="L710">                getBaselineOffset();</span>
    }

    /**
     * Returns the amount the baseline is offset by.  This is typically
     * the same as &lt;code&gt;getTabLabelShiftY&lt;/code&gt;.
     *
     * @return amount to offset the baseline by
     * @since 1.6
     */
    protected int getBaselineOffset() {
<span class="nc bnc" id="L721" title="All 3 branches missed.">        switch(tabPane.getTabPlacement()) {</span>
        case JTabbedPane.TOP:
<span class="nc bnc" id="L723" title="All 2 branches missed.">            if (tabPane.getTabCount() &gt; 1) {</span>
<span class="nc" id="L724">                return 1;</span>
            }
            else {
<span class="nc" id="L727">                return -1;</span>
            }
        case JTabbedPane.BOTTOM:
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (tabPane.getTabCount() &gt; 1) {</span>
<span class="nc" id="L731">                return -1;</span>
            }
            else {
<span class="nc" id="L734">                return 1;</span>
            }
        default: // RIGHT|LEFT
<span class="nc" id="L737">            return (maxTabHeight % 2);</span>
        }
    }

    private int calculateBaselineIfNecessary() {
<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (!calculatedBaseline) {</span>
<span class="nc" id="L743">            calculatedBaseline = true;</span>
<span class="nc" id="L744">            baseline = -1;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">            if (tabPane.getTabCount() &gt; 0) {</span>
<span class="nc" id="L746">                calculateBaseline();</span>
            }
        }
<span class="nc" id="L749">        return baseline;</span>
    }

    private void calculateBaseline() {
<span class="nc" id="L753">        int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L754">        int tabPlacement = tabPane.getTabPlacement();</span>
<span class="nc" id="L755">        maxTabHeight = calculateMaxTabHeight(tabPlacement);</span>
<span class="nc" id="L756">        baseline = getBaseline(0);</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">        if (isHorizontalTabPlacement()) {</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">            for(int i = 1; i &lt; tabCount; i++) {</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">                if (getBaseline(i) != baseline) {</span>
<span class="nc" id="L760">                    baseline = -1;</span>
<span class="nc" id="L761">                    break;</span>
                }
            }
        }
        else {
            // left/right, tabs may be different sizes.
<span class="nc" id="L767">            FontMetrics fontMetrics = getFontMetrics();</span>
<span class="nc" id="L768">            int fontHeight = fontMetrics.getHeight();</span>
<span class="nc" id="L769">            int height = calculateTabHeight(tabPlacement, 0, fontHeight);</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">            for(int i = 1; i &lt; tabCount; i++) {</span>
<span class="nc" id="L771">                int newHeight = calculateTabHeight(tabPlacement, i,fontHeight);</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">                if (height != newHeight) {</span>
                    // assume different baseline
<span class="nc" id="L774">                    baseline = -1;</span>
<span class="nc" id="L775">                    break;</span>
                }
            }
        }
<span class="nc" id="L779">    }</span>

// UI Rendering

    public void paint(Graphics g, JComponent c) {
<span class="nc" id="L784">        int selectedIndex = tabPane.getSelectedIndex();</span>
<span class="nc" id="L785">        int tabPlacement = tabPane.getTabPlacement();</span>

<span class="nc" id="L787">        ensureCurrentLayout();</span>

        // Paint content border and tab area
<span class="nc bnc" id="L790" title="All 2 branches missed.">        if (tabsOverlapBorder) {</span>
<span class="nc" id="L791">            paintContentBorder(g, tabPlacement, selectedIndex);</span>
        }
        // If scrollable tabs are enabled, the tab area will be
        // painted by the scrollable tab panel instead.
        //
<span class="nc bnc" id="L796" title="All 2 branches missed.">        if (!scrollableTabLayoutEnabled()) { // WRAP_TAB_LAYOUT</span>
<span class="nc" id="L797">            paintTabArea(g, tabPlacement, selectedIndex);</span>
        }
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (!tabsOverlapBorder) {</span>
<span class="nc" id="L800">            paintContentBorder(g, tabPlacement, selectedIndex);</span>
        }
<span class="nc" id="L802">    }</span>

    /**
     * Paints the tabs in the tab area.
     * Invoked by paint().
     * The graphics parameter must be a valid &lt;code&gt;Graphics&lt;/code&gt;
     * object.  Tab placement may be either:
     * &lt;code&gt;JTabbedPane.TOP&lt;/code&gt;, &lt;code&gt;JTabbedPane.BOTTOM&lt;/code&gt;,
     * &lt;code&gt;JTabbedPane.LEFT&lt;/code&gt;, or &lt;code&gt;JTabbedPane.RIGHT&lt;/code&gt;.
     * The selected index must be a valid tabbed pane tab index (0 to
     * tab count - 1, inclusive) or -1 if no tab is currently selected.
     * The handling of invalid parameters is unspecified.
     *
     * @param g the graphics object to use for rendering
     * @param tabPlacement the placement for the tabs within the JTabbedPane
     * @param selectedIndex the tab index of the selected component
     *
     * @since 1.4
     */
    protected void paintTabArea(Graphics g, int tabPlacement, int selectedIndex) {
<span class="nc" id="L822">        int tabCount = tabPane.getTabCount();</span>

<span class="nc" id="L824">        Rectangle iconRect = new Rectangle(),</span>
<span class="nc" id="L825">                  textRect = new Rectangle();</span>
<span class="nc" id="L826">        Rectangle clipRect = g.getClipBounds();</span>

        // Paint tabRuns of tabs from back to front
<span class="nc bnc" id="L829" title="All 2 branches missed.">        for (int i = runCount - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L830">            int start = tabRuns[i];</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">            int next = tabRuns[(i == runCount - 1)? 0 : i + 1];</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">            int end = (next != 0? next - 1: tabCount - 1);</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">            for (int j = start; j &lt;= end; j++) {</span>
<span class="nc bnc" id="L834" title="All 4 branches missed.">                if (j != selectedIndex &amp;&amp; rects[j].intersects(clipRect)) {</span>
<span class="nc" id="L835">                    paintTab(g, tabPlacement, rects, j, iconRect, textRect);</span>
                }
            }
        }

        // Paint selected tab if its in the front run
        // since it may overlap other tabs
<span class="nc bnc" id="L842" title="All 4 branches missed.">        if (selectedIndex &gt;= 0 &amp;&amp; rects[selectedIndex].intersects(clipRect)) {</span>
<span class="nc" id="L843">            paintTab(g, tabPlacement, rects, selectedIndex, iconRect, textRect);</span>
        }
<span class="nc" id="L845">    }</span>

    protected void paintTab(Graphics g, int tabPlacement,
                            Rectangle[] rects, int tabIndex,
                            Rectangle iconRect, Rectangle textRect) {
<span class="nc" id="L850">        Rectangle tabRect = rects[tabIndex];</span>
<span class="nc" id="L851">        int selectedIndex = tabPane.getSelectedIndex();</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">        boolean isSelected = selectedIndex == tabIndex;</span>

<span class="nc bnc" id="L854" title="All 4 branches missed.">        if (tabsOpaque || tabPane.isOpaque()) {</span>
<span class="nc" id="L855">            paintTabBackground(g, tabPlacement, tabIndex, tabRect.x, tabRect.y,</span>
                    tabRect.width, tabRect.height, isSelected);
        }

<span class="nc" id="L859">        paintTabBorder(g, tabPlacement, tabIndex, tabRect.x, tabRect.y,</span>
                       tabRect.width, tabRect.height, isSelected);

<span class="nc" id="L862">        String title = tabPane.getTitleAt(tabIndex);</span>
<span class="nc" id="L863">        Font font = tabPane.getFont();</span>
<span class="nc" id="L864">        FontMetrics metrics = SwingUtilities2.getFontMetrics(tabPane, g, font);</span>
<span class="nc" id="L865">        Icon icon = getIconForTab(tabIndex);</span>

<span class="nc" id="L867">        layoutLabel(tabPlacement, metrics, tabIndex, title, icon,</span>
                    tabRect, iconRect, textRect, isSelected);

<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (tabPane.getTabComponentAt(tabIndex) == null) {</span>
<span class="nc" id="L871">            String clippedTitle = title;</span>

<span class="nc bnc" id="L873" title="All 4 branches missed.">            if (scrollableTabLayoutEnabled() &amp;&amp; tabScroller.croppedEdge.isParamsSet() &amp;&amp;</span>
<span class="nc bnc" id="L874" title="All 4 branches missed.">                    tabScroller.croppedEdge.getTabIndex() == tabIndex &amp;&amp; isHorizontalTabPlacement()) {</span>
<span class="nc" id="L875">                int availTextWidth = tabScroller.croppedEdge.getCropline() -</span>
<span class="nc" id="L876">                        (textRect.x - tabRect.x) - tabScroller.croppedEdge.getCroppedSideWidth();</span>
<span class="nc" id="L877">                clippedTitle = SwingUtilities2.clipStringIfNecessary(null, metrics, title, availTextWidth);</span>
<span class="nc bnc" id="L878" title="All 4 branches missed.">            } else if (!scrollableTabLayoutEnabled() &amp;&amp; isHorizontalTabPlacement()) {</span>
<span class="nc" id="L879">                clippedTitle = SwingUtilities2.clipStringIfNecessary(null, metrics, title, textRect.width);</span>
            }

<span class="nc" id="L882">            paintText(g, tabPlacement, font, metrics,</span>
                    tabIndex, clippedTitle, textRect, isSelected);

<span class="nc" id="L885">            paintIcon(g, tabPlacement, tabIndex, icon, iconRect, isSelected);</span>
        }
<span class="nc" id="L887">        paintFocusIndicator(g, tabPlacement, rects, tabIndex,</span>
                  iconRect, textRect, isSelected);
<span class="nc" id="L889">    }</span>

    private boolean isHorizontalTabPlacement() {
<span class="nc bnc" id="L892" title="All 4 branches missed.">        return tabPane.getTabPlacement() == TOP || tabPane.getTabPlacement() == BOTTOM;</span>
    }

    /* This method will create and return a polygon shape for the given tab rectangle
     * which has been cropped at the specified cropline with a torn edge visual.
     * e.g. A &quot;File&quot; tab which has cropped been cropped just after the &quot;i&quot;:
     *             -------------
     *             |  .....     |
     *             |  .          |
     *             |  ...  .    |
     *             |  .    .   |
     *             |  .    .    |
     *             |  .    .     |
     *             --------------
     *
     * The x, y arrays below define the pattern used to create a &quot;torn&quot; edge
     * segment which is repeated to fill the edge of the tab.
     * For tabs placed on TOP and BOTTOM, this righthand torn edge is created by
     * line segments which are defined by coordinates obtained by
     * subtracting xCropLen[i] from (tab.x + tab.width) and adding yCroplen[i]
     * to (tab.y).
     * For tabs placed on LEFT or RIGHT, the bottom torn edge is created by
     * subtracting xCropLen[i] from (tab.y + tab.height) and adding yCropLen[i]
     * to (tab.x).
     */
<span class="nc" id="L917">    private static int xCropLen[] = {1,1,0,0,1,1,2,2};</span>
<span class="nc" id="L918">    private static int yCropLen[] = {0,3,3,6,6,9,9,12};</span>
    private static final int CROP_SEGMENT = 12;

    private static Polygon createCroppedTabShape(int tabPlacement, Rectangle tabRect, int cropline) {
        int rlen;
        int start;
        int end;
        int ostart;

<span class="nc bnc" id="L927" title="All 2 branches missed.">        switch(tabPlacement) {</span>
          case LEFT:
          case RIGHT:
<span class="nc" id="L930">              rlen = tabRect.width;</span>
<span class="nc" id="L931">              start = tabRect.x;</span>
<span class="nc" id="L932">              end = tabRect.x + tabRect.width;</span>
<span class="nc" id="L933">              ostart = tabRect.y + tabRect.height;</span>
<span class="nc" id="L934">              break;</span>
          case TOP:
          case BOTTOM:
          default:
<span class="nc" id="L938">             rlen = tabRect.height;</span>
<span class="nc" id="L939">             start = tabRect.y;</span>
<span class="nc" id="L940">             end = tabRect.y + tabRect.height;</span>
<span class="nc" id="L941">             ostart = tabRect.x + tabRect.width;</span>
        }
<span class="nc" id="L943">        int rcnt = rlen/CROP_SEGMENT;</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">        if (rlen%CROP_SEGMENT &gt; 0) {</span>
<span class="nc" id="L945">            rcnt++;</span>
        }
<span class="nc" id="L947">        int npts = 2 + (rcnt*8);</span>
<span class="nc" id="L948">        int xp[] = new int[npts];</span>
<span class="nc" id="L949">        int yp[] = new int[npts];</span>
<span class="nc" id="L950">        int pcnt = 0;</span>

<span class="nc" id="L952">        xp[pcnt] = ostart;</span>
<span class="nc" id="L953">        yp[pcnt++] = end;</span>
<span class="nc" id="L954">        xp[pcnt] = ostart;</span>
<span class="nc" id="L955">        yp[pcnt++] = start;</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">        for(int i = 0; i &lt; rcnt; i++) {</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">            for(int j = 0; j &lt; xCropLen.length; j++) {</span>
<span class="nc" id="L958">                xp[pcnt] = cropline - xCropLen[j];</span>
<span class="nc" id="L959">                yp[pcnt] = start + (i*CROP_SEGMENT) + yCropLen[j];</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">                if (yp[pcnt] &gt;= end) {</span>
<span class="nc" id="L961">                    yp[pcnt] = end;</span>
<span class="nc" id="L962">                    pcnt++;</span>
<span class="nc" id="L963">                    break;</span>
                }
<span class="nc" id="L965">                pcnt++;</span>
            }
        }
<span class="nc bnc" id="L968" title="All 4 branches missed.">        if (tabPlacement == JTabbedPane.TOP || tabPlacement == JTabbedPane.BOTTOM) {</span>
<span class="nc" id="L969">           return new Polygon(xp, yp, pcnt);</span>

        } else { // LEFT or RIGHT
<span class="nc" id="L972">           return new Polygon(yp, xp, pcnt);</span>
        }
    }

    /* If tabLayoutPolicy == SCROLL_TAB_LAYOUT, this method will paint an edge
     * indicating the tab is cropped in the viewport display
     */
    private void paintCroppedTabEdge(Graphics g) {
<span class="nc" id="L980">        int tabIndex = tabScroller.croppedEdge.getTabIndex();</span>
<span class="nc" id="L981">        int cropline = tabScroller.croppedEdge.getCropline();</span>
        int x,y;
<span class="nc bnc" id="L983" title="All 2 branches missed.">        switch(tabPane.getTabPlacement()) {</span>
          case LEFT:
          case RIGHT:
<span class="nc" id="L986">            x = rects[tabIndex].x;</span>
<span class="nc" id="L987">            y = cropline;</span>
<span class="nc" id="L988">            int xx = x;</span>
<span class="nc" id="L989">            g.setColor(shadow);</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">            while(xx &lt;= x+rects[tabIndex].width) {</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">                for (int i=0; i &lt; xCropLen.length; i+=2) {</span>
<span class="nc" id="L992">                    g.drawLine(xx+yCropLen[i],y-xCropLen[i],</span>
                               xx+yCropLen[i+1]-1,y-xCropLen[i+1]);
                }
<span class="nc" id="L995">                xx+=CROP_SEGMENT;</span>
            }
            break;
          case TOP:
          case BOTTOM:
          default:
<span class="nc" id="L1001">            x = cropline;</span>
<span class="nc" id="L1002">            y = rects[tabIndex].y;</span>
<span class="nc" id="L1003">            int yy = y;</span>
<span class="nc" id="L1004">            g.setColor(shadow);</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            while(yy &lt;= y+rects[tabIndex].height) {</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                for (int i=0; i &lt; xCropLen.length; i+=2) {</span>
<span class="nc" id="L1007">                    g.drawLine(x-xCropLen[i],yy+yCropLen[i],</span>
                               x-xCropLen[i+1],yy+yCropLen[i+1]-1);
                }
<span class="nc" id="L1010">                yy+=CROP_SEGMENT;</span>
            }
        }
<span class="nc" id="L1013">    }</span>

    protected void layoutLabel(int tabPlacement,
                               FontMetrics metrics, int tabIndex,
                               String title, Icon icon,
                               Rectangle tabRect, Rectangle iconRect,
                               Rectangle textRect, boolean isSelected ) {
<span class="nc" id="L1020">        textRect.x = textRect.y = iconRect.x = iconRect.y = 0;</span>

<span class="nc" id="L1022">        View v = getTextViewForTab(tabIndex);</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">        if (v != null) {</span>
<span class="nc" id="L1024">            tabPane.putClientProperty(&quot;html&quot;, v);</span>
        }

<span class="nc" id="L1027">        SwingUtilities.layoutCompoundLabel(tabPane,</span>
                                           metrics, title, icon,
                                           SwingUtilities.CENTER,
                                           SwingUtilities.CENTER,
                                           SwingUtilities.CENTER,
                                           SwingUtilities.TRAILING,
                                           tabRect,
                                           iconRect,
                                           textRect,
                                           textIconGap);

<span class="nc" id="L1038">        tabPane.putClientProperty(&quot;html&quot;, null);</span>

<span class="nc" id="L1040">        int xNudge = getTabLabelShiftX(tabPlacement, tabIndex, isSelected);</span>
<span class="nc" id="L1041">        int yNudge = getTabLabelShiftY(tabPlacement, tabIndex, isSelected);</span>
<span class="nc" id="L1042">        iconRect.x += xNudge;</span>
<span class="nc" id="L1043">        iconRect.y += yNudge;</span>
<span class="nc" id="L1044">        textRect.x += xNudge;</span>
<span class="nc" id="L1045">        textRect.y += yNudge;</span>
<span class="nc" id="L1046">    }</span>

    protected void paintIcon(Graphics g, int tabPlacement,
                             int tabIndex, Icon icon, Rectangle iconRect,
                             boolean isSelected ) {
<span class="nc bnc" id="L1051" title="All 2 branches missed.">        if (icon != null) {</span>
<span class="nc" id="L1052">            icon.paintIcon(tabPane, g, iconRect.x, iconRect.y);</span>
        }
<span class="nc" id="L1054">    }</span>

    protected void paintText(Graphics g, int tabPlacement,
                             Font font, FontMetrics metrics, int tabIndex,
                             String title, Rectangle textRect,
                             boolean isSelected) {

<span class="nc" id="L1061">        g.setFont(font);</span>

<span class="nc" id="L1063">        View v = getTextViewForTab(tabIndex);</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">        if (v != null) {</span>
            // html
<span class="nc" id="L1066">            v.paint(g, textRect);</span>
        } else {
            // plain text
<span class="nc" id="L1069">            int mnemIndex = tabPane.getDisplayedMnemonicIndexAt(tabIndex);</span>

<span class="nc bnc" id="L1071" title="All 4 branches missed.">            if (tabPane.isEnabled() &amp;&amp; tabPane.isEnabledAt(tabIndex)) {</span>
<span class="nc" id="L1072">                Color fg = tabPane.getForegroundAt(tabIndex);</span>
<span class="nc bnc" id="L1073" title="All 4 branches missed.">                if (isSelected &amp;&amp; (fg instanceof UIResource)) {</span>
<span class="nc" id="L1074">                    Color selectedFG = UIManager.getColor(</span>
                                  &quot;TabbedPane.selectedForeground&quot;);
<span class="nc bnc" id="L1076" title="All 2 branches missed.">                    if (selectedFG != null) {</span>
<span class="nc" id="L1077">                        fg = selectedFG;</span>
                    }
                }
<span class="nc" id="L1080">                g.setColor(fg);</span>
<span class="nc" id="L1081">                SwingUtilities2.drawStringUnderlineCharAt(tabPane, g,</span>
                             title, mnemIndex,
<span class="nc" id="L1083">                             textRect.x, textRect.y + metrics.getAscent());</span>

<span class="nc" id="L1085">            } else { // tab disabled</span>
<span class="nc" id="L1086">                g.setColor(tabPane.getBackgroundAt(tabIndex).brighter());</span>
<span class="nc" id="L1087">                SwingUtilities2.drawStringUnderlineCharAt(tabPane, g,</span>
                             title, mnemIndex,
<span class="nc" id="L1089">                             textRect.x, textRect.y + metrics.getAscent());</span>
<span class="nc" id="L1090">                g.setColor(tabPane.getBackgroundAt(tabIndex).darker());</span>
<span class="nc" id="L1091">                SwingUtilities2.drawStringUnderlineCharAt(tabPane, g,</span>
                             title, mnemIndex,
<span class="nc" id="L1093">                             textRect.x - 1, textRect.y + metrics.getAscent() - 1);</span>

            }
        }
<span class="nc" id="L1097">    }</span>


    protected int getTabLabelShiftX(int tabPlacement, int tabIndex, boolean isSelected) {
<span class="nc" id="L1101">        Rectangle tabRect = rects[tabIndex];</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        String propKey = (isSelected ? &quot;selectedLabelShift&quot; : &quot;labelShift&quot;);</span>
<span class="nc" id="L1103">        int nudge = DefaultLookup.getInt(</span>
                tabPane, this, &quot;TabbedPane.&quot; + propKey, 1);

<span class="nc bnc" id="L1106" title="All 3 branches missed.">        switch (tabPlacement) {</span>
            case LEFT:
<span class="nc" id="L1108">                return nudge;</span>
            case RIGHT:
<span class="nc" id="L1110">                return -nudge;</span>
            case BOTTOM:
            case TOP:
            default:
<span class="nc" id="L1114">                return tabRect.width % 2;</span>
        }
    }

    protected int getTabLabelShiftY(int tabPlacement, int tabIndex, boolean isSelected) {
<span class="nc" id="L1119">        Rectangle tabRect = rects[tabIndex];</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">        int nudge = (isSelected ? DefaultLookup.getInt(tabPane, this, &quot;TabbedPane.selectedLabelShift&quot;, -1) :</span>
<span class="nc" id="L1121">                DefaultLookup.getInt(tabPane, this, &quot;TabbedPane.labelShift&quot;, 1));</span>

<span class="nc bnc" id="L1123" title="All 3 branches missed.">        switch (tabPlacement) {</span>
            case BOTTOM:
<span class="nc" id="L1125">                return -nudge;</span>
            case LEFT:
            case RIGHT:
<span class="nc" id="L1128">                return tabRect.height % 2;</span>
            case TOP:
            default:
<span class="nc" id="L1131">                return nudge;</span>
        }
    }

    protected void paintFocusIndicator(Graphics g, int tabPlacement,
                                       Rectangle[] rects, int tabIndex,
                                       Rectangle iconRect, Rectangle textRect,
                                       boolean isSelected) {
<span class="nc" id="L1139">        Rectangle tabRect = rects[tabIndex];</span>
<span class="nc bnc" id="L1140" title="All 4 branches missed.">        if (tabPane.hasFocus() &amp;&amp; isSelected) {</span>
            int x, y, w, h;
<span class="nc" id="L1142">            g.setColor(focus);</span>
<span class="nc bnc" id="L1143" title="All 4 branches missed.">            switch(tabPlacement) {</span>
              case LEFT:
<span class="nc" id="L1145">                  x = tabRect.x + 3;</span>
<span class="nc" id="L1146">                  y = tabRect.y + 3;</span>
<span class="nc" id="L1147">                  w = tabRect.width - 5;</span>
<span class="nc" id="L1148">                  h = tabRect.height - 6;</span>
<span class="nc" id="L1149">                  break;</span>
              case RIGHT:
<span class="nc" id="L1151">                  x = tabRect.x + 2;</span>
<span class="nc" id="L1152">                  y = tabRect.y + 3;</span>
<span class="nc" id="L1153">                  w = tabRect.width - 5;</span>
<span class="nc" id="L1154">                  h = tabRect.height - 6;</span>
<span class="nc" id="L1155">                  break;</span>
              case BOTTOM:
<span class="nc" id="L1157">                  x = tabRect.x + 3;</span>
<span class="nc" id="L1158">                  y = tabRect.y + 2;</span>
<span class="nc" id="L1159">                  w = tabRect.width - 6;</span>
<span class="nc" id="L1160">                  h = tabRect.height - 5;</span>
<span class="nc" id="L1161">                  break;</span>
              case TOP:
              default:
<span class="nc" id="L1164">                  x = tabRect.x + 3;</span>
<span class="nc" id="L1165">                  y = tabRect.y + 3;</span>
<span class="nc" id="L1166">                  w = tabRect.width - 6;</span>
<span class="nc" id="L1167">                  h = tabRect.height - 5;</span>
            }
<span class="nc" id="L1169">            BasicGraphicsUtils.drawDashedRect(g, x, y, w, h);</span>
        }
<span class="nc" id="L1171">    }</span>

    /**
      * this function draws the border around each tab
      * note that this function does now draw the background of the tab.
      * that is done elsewhere
      */
    protected void paintTabBorder(Graphics g, int tabPlacement,
                                  int tabIndex,
                                  int x, int y, int w, int h,
                                  boolean isSelected ) {
<span class="nc" id="L1182">        g.setColor(lightHighlight);</span>

<span class="nc bnc" id="L1184" title="All 4 branches missed.">        switch (tabPlacement) {</span>
          case LEFT:
<span class="nc" id="L1186">              g.drawLine(x+1, y+h-2, x+1, y+h-2); // bottom-left highlight</span>
<span class="nc" id="L1187">              g.drawLine(x, y+2, x, y+h-3); // left highlight</span>
<span class="nc" id="L1188">              g.drawLine(x+1, y+1, x+1, y+1); // top-left highlight</span>
<span class="nc" id="L1189">              g.drawLine(x+2, y, x+w-1, y); // top highlight</span>

<span class="nc" id="L1191">              g.setColor(shadow);</span>
<span class="nc" id="L1192">              g.drawLine(x+2, y+h-2, x+w-1, y+h-2); // bottom shadow</span>

<span class="nc" id="L1194">              g.setColor(darkShadow);</span>
<span class="nc" id="L1195">              g.drawLine(x+2, y+h-1, x+w-1, y+h-1); // bottom dark shadow</span>
<span class="nc" id="L1196">              break;</span>
          case RIGHT:
<span class="nc" id="L1198">              g.drawLine(x, y, x+w-3, y); // top highlight</span>

<span class="nc" id="L1200">              g.setColor(shadow);</span>
<span class="nc" id="L1201">              g.drawLine(x, y+h-2, x+w-3, y+h-2); // bottom shadow</span>
<span class="nc" id="L1202">              g.drawLine(x+w-2, y+2, x+w-2, y+h-3); // right shadow</span>

<span class="nc" id="L1204">              g.setColor(darkShadow);</span>
<span class="nc" id="L1205">              g.drawLine(x+w-2, y+1, x+w-2, y+1); // top-right dark shadow</span>
<span class="nc" id="L1206">              g.drawLine(x+w-2, y+h-2, x+w-2, y+h-2); // bottom-right dark shadow</span>
<span class="nc" id="L1207">              g.drawLine(x+w-1, y+2, x+w-1, y+h-3); // right dark shadow</span>
<span class="nc" id="L1208">              g.drawLine(x, y+h-1, x+w-3, y+h-1); // bottom dark shadow</span>
<span class="nc" id="L1209">              break;</span>
          case BOTTOM:
<span class="nc" id="L1211">              g.drawLine(x, y, x, y+h-3); // left highlight</span>
<span class="nc" id="L1212">              g.drawLine(x+1, y+h-2, x+1, y+h-2); // bottom-left highlight</span>

<span class="nc" id="L1214">              g.setColor(shadow);</span>
<span class="nc" id="L1215">              g.drawLine(x+2, y+h-2, x+w-3, y+h-2); // bottom shadow</span>
<span class="nc" id="L1216">              g.drawLine(x+w-2, y, x+w-2, y+h-3); // right shadow</span>

<span class="nc" id="L1218">              g.setColor(darkShadow);</span>
<span class="nc" id="L1219">              g.drawLine(x+2, y+h-1, x+w-3, y+h-1); // bottom dark shadow</span>
<span class="nc" id="L1220">              g.drawLine(x+w-2, y+h-2, x+w-2, y+h-2); // bottom-right dark shadow</span>
<span class="nc" id="L1221">              g.drawLine(x+w-1, y, x+w-1, y+h-3); // right dark shadow</span>
<span class="nc" id="L1222">              break;</span>
          case TOP:
          default:
<span class="nc" id="L1225">              g.drawLine(x, y+2, x, y+h-1); // left highlight</span>
<span class="nc" id="L1226">              g.drawLine(x+1, y+1, x+1, y+1); // top-left highlight</span>
<span class="nc" id="L1227">              g.drawLine(x+2, y, x+w-3, y); // top highlight</span>

<span class="nc" id="L1229">              g.setColor(shadow);</span>
<span class="nc" id="L1230">              g.drawLine(x+w-2, y+2, x+w-2, y+h-1); // right shadow</span>

<span class="nc" id="L1232">              g.setColor(darkShadow);</span>
<span class="nc" id="L1233">              g.drawLine(x+w-1, y+2, x+w-1, y+h-1); // right dark-shadow</span>
<span class="nc" id="L1234">              g.drawLine(x+w-2, y+1, x+w-2, y+1); // top-right shadow</span>
        }
<span class="nc" id="L1236">    }</span>

    protected void paintTabBackground(Graphics g, int tabPlacement,
                                      int tabIndex,
                                      int x, int y, int w, int h,
                                      boolean isSelected ) {
<span class="nc bnc" id="L1242" title="All 4 branches missed.">        g.setColor(!isSelected || selectedColor == null?</span>
<span class="nc" id="L1243">                   tabPane.getBackgroundAt(tabIndex) : selectedColor);</span>
<span class="nc bnc" id="L1244" title="All 4 branches missed.">        switch(tabPlacement) {</span>
          case LEFT:
<span class="nc" id="L1246">              g.fillRect(x+1, y+1, w-1, h-3);</span>
<span class="nc" id="L1247">              break;</span>
          case RIGHT:
<span class="nc" id="L1249">              g.fillRect(x, y+1, w-2, h-3);</span>
<span class="nc" id="L1250">              break;</span>
          case BOTTOM:
<span class="nc" id="L1252">              g.fillRect(x+1, y, w-3, h-1);</span>
<span class="nc" id="L1253">              break;</span>
          case TOP:
          default:
<span class="nc" id="L1256">              g.fillRect(x+1, y+1, w-3, h-1);</span>
        }
<span class="nc" id="L1258">    }</span>

    protected void paintContentBorder(Graphics g, int tabPlacement, int selectedIndex) {
<span class="nc" id="L1261">        int width = tabPane.getWidth();</span>
<span class="nc" id="L1262">        int height = tabPane.getHeight();</span>
<span class="nc" id="L1263">        Insets insets = tabPane.getInsets();</span>
<span class="nc" id="L1264">        Insets tabAreaInsets = getTabAreaInsets(tabPlacement);</span>

<span class="nc" id="L1266">        int x = insets.left;</span>
<span class="nc" id="L1267">        int y = insets.top;</span>
<span class="nc" id="L1268">        int w = width - insets.right - insets.left;</span>
<span class="nc" id="L1269">        int h = height - insets.top - insets.bottom;</span>

<span class="nc bnc" id="L1271" title="All 4 branches missed.">        switch(tabPlacement) {</span>
          case LEFT:
<span class="nc" id="L1273">              x += calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth);</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">              if (tabsOverlapBorder) {</span>
<span class="nc" id="L1275">                  x -= tabAreaInsets.right;</span>
              }
<span class="nc" id="L1277">              w -= (x - insets.left);</span>
<span class="nc" id="L1278">              break;</span>
          case RIGHT:
<span class="nc" id="L1280">              w -= calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth);</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">              if (tabsOverlapBorder) {</span>
<span class="nc" id="L1282">                  w += tabAreaInsets.left;</span>
              }
              break;
          case BOTTOM:
<span class="nc" id="L1286">              h -= calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight);</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">              if (tabsOverlapBorder) {</span>
<span class="nc" id="L1288">                  h += tabAreaInsets.top;</span>
              }
              break;
          case TOP:
          default:
<span class="nc" id="L1293">              y += calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight);</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">              if (tabsOverlapBorder) {</span>
<span class="nc" id="L1295">                  y -= tabAreaInsets.bottom;</span>
              }
<span class="nc" id="L1297">              h -= (y - insets.top);</span>
        }

<span class="nc bnc" id="L1300" title="All 6 branches missed.">            if ( tabPane.getTabCount() &gt; 0 &amp;&amp; (contentOpaque || tabPane.isOpaque()) ) {</span>
            // Fill region behind content area
<span class="nc" id="L1302">            Color color = UIManager.getColor(&quot;TabbedPane.contentAreaColor&quot;);</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">            if (color != null) {</span>
<span class="nc" id="L1304">                g.setColor(color);</span>
            }
<span class="nc bnc" id="L1306" title="All 4 branches missed.">            else if ( selectedColor == null || selectedIndex == -1 ) {</span>
<span class="nc" id="L1307">                g.setColor(tabPane.getBackground());</span>
            }
            else {
<span class="nc" id="L1310">                g.setColor(selectedColor);</span>
            }
<span class="nc" id="L1312">            g.fillRect(x,y,w,h);</span>
        }

<span class="nc" id="L1315">        paintContentBorderTopEdge(g, tabPlacement, selectedIndex, x, y, w, h);</span>
<span class="nc" id="L1316">        paintContentBorderLeftEdge(g, tabPlacement, selectedIndex, x, y, w, h);</span>
<span class="nc" id="L1317">        paintContentBorderBottomEdge(g, tabPlacement, selectedIndex, x, y, w, h);</span>
<span class="nc" id="L1318">        paintContentBorderRightEdge(g, tabPlacement, selectedIndex, x, y, w, h);</span>

<span class="nc" id="L1320">    }</span>

    protected void paintContentBorderTopEdge(Graphics g, int tabPlacement,
                                         int selectedIndex,
                                         int x, int y, int w, int h) {
<span class="nc bnc" id="L1325" title="All 2 branches missed.">        Rectangle selRect = selectedIndex &lt; 0? null :</span>
<span class="nc" id="L1326">                               getTabBounds(selectedIndex, calcRect);</span>

<span class="nc" id="L1328">        g.setColor(lightHighlight);</span>

        // Draw unbroken line if tabs are not on TOP, OR
        // selected tab is not in run adjacent to content, OR
        // selected tab is not visible (SCROLL_TAB_LAYOUT)
        //
<span class="nc bnc" id="L1334" title="All 10 branches missed.">        if (tabPlacement != TOP || selectedIndex &lt; 0 ||</span>
            (selRect.y + selRect.height + 1 &lt; y) ||
            (selRect.x &lt; x || selRect.x &gt; x + w)) {
<span class="nc" id="L1337">            g.drawLine(x, y, x+w-2, y);</span>
        } else {
            // Break line to show visual connection to selected tab
<span class="nc" id="L1340">            g.drawLine(x, y, selRect.x - 1, y);</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">            if (selRect.x + selRect.width &lt; x + w - 2) {</span>
<span class="nc" id="L1342">                g.drawLine(selRect.x + selRect.width, y,</span>
                           x+w-2, y);
            } else {
<span class="nc" id="L1345">                g.setColor(shadow);</span>
<span class="nc" id="L1346">                g.drawLine(x+w-2, y, x+w-2, y);</span>
            }
        }
<span class="nc" id="L1349">    }</span>

    protected void paintContentBorderLeftEdge(Graphics g, int tabPlacement,
                                               int selectedIndex,
                                               int x, int y, int w, int h) {
<span class="nc bnc" id="L1354" title="All 2 branches missed.">        Rectangle selRect = selectedIndex &lt; 0? null :</span>
<span class="nc" id="L1355">                               getTabBounds(selectedIndex, calcRect);</span>

<span class="nc" id="L1357">        g.setColor(lightHighlight);</span>

        // Draw unbroken line if tabs are not on LEFT, OR
        // selected tab is not in run adjacent to content, OR
        // selected tab is not visible (SCROLL_TAB_LAYOUT)
        //
<span class="nc bnc" id="L1363" title="All 10 branches missed.">        if (tabPlacement != LEFT || selectedIndex &lt; 0 ||</span>
            (selRect.x + selRect.width + 1 &lt; x) ||
            (selRect.y &lt; y || selRect.y &gt; y + h)) {
<span class="nc" id="L1366">            g.drawLine(x, y, x, y+h-2);</span>
        } else {
            // Break line to show visual connection to selected tab
<span class="nc" id="L1369">            g.drawLine(x, y, x, selRect.y - 1);</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">            if (selRect.y + selRect.height &lt; y + h - 2) {</span>
<span class="nc" id="L1371">                g.drawLine(x, selRect.y + selRect.height,</span>
                           x, y+h-2);
            }
        }
<span class="nc" id="L1375">    }</span>

    protected void paintContentBorderBottomEdge(Graphics g, int tabPlacement,
                                               int selectedIndex,
                                               int x, int y, int w, int h) {
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        Rectangle selRect = selectedIndex &lt; 0? null :</span>
<span class="nc" id="L1381">                               getTabBounds(selectedIndex, calcRect);</span>

<span class="nc" id="L1383">        g.setColor(shadow);</span>

        // Draw unbroken line if tabs are not on BOTTOM, OR
        // selected tab is not in run adjacent to content, OR
        // selected tab is not visible (SCROLL_TAB_LAYOUT)
        //
<span class="nc bnc" id="L1389" title="All 10 branches missed.">        if (tabPlacement != BOTTOM || selectedIndex &lt; 0 ||</span>
             (selRect.y - 1 &gt; h) ||
             (selRect.x &lt; x || selRect.x &gt; x + w)) {
<span class="nc" id="L1392">            g.drawLine(x+1, y+h-2, x+w-2, y+h-2);</span>
<span class="nc" id="L1393">            g.setColor(darkShadow);</span>
<span class="nc" id="L1394">            g.drawLine(x, y+h-1, x+w-1, y+h-1);</span>
        } else {
            // Break line to show visual connection to selected tab
<span class="nc" id="L1397">            g.drawLine(x+1, y+h-2, selRect.x - 1, y+h-2);</span>
<span class="nc" id="L1398">            g.setColor(darkShadow);</span>
<span class="nc" id="L1399">            g.drawLine(x, y+h-1, selRect.x - 1, y+h-1);</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">            if (selRect.x + selRect.width &lt; x + w - 2) {</span>
<span class="nc" id="L1401">                g.setColor(shadow);</span>
<span class="nc" id="L1402">                g.drawLine(selRect.x + selRect.width, y+h-2, x+w-2, y+h-2);</span>
<span class="nc" id="L1403">                g.setColor(darkShadow);</span>
<span class="nc" id="L1404">                g.drawLine(selRect.x + selRect.width, y+h-1, x+w-1, y+h-1);</span>
            }
        }

<span class="nc" id="L1408">    }</span>

    protected void paintContentBorderRightEdge(Graphics g, int tabPlacement,
                                               int selectedIndex,
                                               int x, int y, int w, int h) {
<span class="nc bnc" id="L1413" title="All 2 branches missed.">        Rectangle selRect = selectedIndex &lt; 0? null :</span>
<span class="nc" id="L1414">                               getTabBounds(selectedIndex, calcRect);</span>

<span class="nc" id="L1416">        g.setColor(shadow);</span>

        // Draw unbroken line if tabs are not on RIGHT, OR
        // selected tab is not in run adjacent to content, OR
        // selected tab is not visible (SCROLL_TAB_LAYOUT)
        //
<span class="nc bnc" id="L1422" title="All 10 branches missed.">        if (tabPlacement != RIGHT || selectedIndex &lt; 0 ||</span>
             (selRect.x - 1 &gt; w) ||
             (selRect.y &lt; y || selRect.y &gt; y + h)) {
<span class="nc" id="L1425">            g.drawLine(x+w-2, y+1, x+w-2, y+h-3);</span>
<span class="nc" id="L1426">            g.setColor(darkShadow);</span>
<span class="nc" id="L1427">            g.drawLine(x+w-1, y, x+w-1, y+h-1);</span>
        } else {
            // Break line to show visual connection to selected tab
<span class="nc" id="L1430">            g.drawLine(x+w-2, y+1, x+w-2, selRect.y - 1);</span>
<span class="nc" id="L1431">            g.setColor(darkShadow);</span>
<span class="nc" id="L1432">            g.drawLine(x+w-1, y, x+w-1, selRect.y - 1);</span>

<span class="nc bnc" id="L1434" title="All 2 branches missed.">            if (selRect.y + selRect.height &lt; y + h - 2) {</span>
<span class="nc" id="L1435">                g.setColor(shadow);</span>
<span class="nc" id="L1436">                g.drawLine(x+w-2, selRect.y + selRect.height,</span>
                           x+w-2, y+h-2);
<span class="nc" id="L1438">                g.setColor(darkShadow);</span>
<span class="nc" id="L1439">                g.drawLine(x+w-1, selRect.y + selRect.height,</span>
                           x+w-1, y+h-2);
            }
        }
<span class="nc" id="L1443">    }</span>

    private void ensureCurrentLayout() {
<span class="nc bnc" id="L1446" title="All 2 branches missed.">        if (!tabPane.isValid()) {</span>
<span class="nc" id="L1447">            tabPane.validate();</span>
        }
        /* If tabPane doesn't have a peer yet, the validate() call will
         * silently fail.  We handle that by forcing a layout if tabPane
         * is still invalid.  See bug 4237677.
         */
<span class="nc bnc" id="L1453" title="All 2 branches missed.">        if (!tabPane.isValid()) {</span>
<span class="nc" id="L1454">            TabbedPaneLayout layout = (TabbedPaneLayout)tabPane.getLayout();</span>
<span class="nc" id="L1455">            layout.calculateLayoutInfo();</span>
        }
<span class="nc" id="L1457">    }</span>


// TabbedPaneUI methods

    /**
     * Returns the bounds of the specified tab index.  The bounds are
     * with respect to the JTabbedPane's coordinate space.
     */
    public Rectangle getTabBounds(JTabbedPane pane, int i) {
<span class="nc" id="L1467">        ensureCurrentLayout();</span>
<span class="nc" id="L1468">        Rectangle tabRect = new Rectangle();</span>
<span class="nc" id="L1469">        return getTabBounds(i, tabRect);</span>
    }

    public int getTabRunCount(JTabbedPane pane) {
<span class="nc" id="L1473">        ensureCurrentLayout();</span>
<span class="nc" id="L1474">        return runCount;</span>
    }

    /**
     * Returns the tab index which intersects the specified point
     * in the JTabbedPane's coordinate space.
     */
    public int tabForCoordinate(JTabbedPane pane, int x, int y) {
<span class="nc" id="L1482">        return tabForCoordinate(pane, x, y, true);</span>
    }

    private int tabForCoordinate(JTabbedPane pane, int x, int y,
                                 boolean validateIfNecessary) {
<span class="nc bnc" id="L1487" title="All 2 branches missed.">        if (validateIfNecessary) {</span>
<span class="nc" id="L1488">            ensureCurrentLayout();</span>
        }
<span class="nc bnc" id="L1490" title="All 2 branches missed.">        if (isRunsDirty) {</span>
            // We didn't recalculate the layout, runs and tabCount may not
            // line up, bail.
<span class="nc" id="L1493">            return -1;</span>
        }
<span class="nc" id="L1495">        Point p = new Point(x, y);</span>

<span class="nc bnc" id="L1497" title="All 2 branches missed.">        if (scrollableTabLayoutEnabled()) {</span>
<span class="nc" id="L1498">            translatePointToTabPanel(x, y, p);</span>
<span class="nc" id="L1499">            Rectangle viewRect = tabScroller.viewport.getViewRect();</span>
<span class="nc bnc" id="L1500" title="All 2 branches missed.">            if (!viewRect.contains(p)) {</span>
<span class="nc" id="L1501">                return -1;</span>
            }
        }
<span class="nc" id="L1504">        int tabCount = tabPane.getTabCount();</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">        for (int i = 0; i &lt; tabCount; i++) {</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">            if (rects[i].contains(p.x, p.y)) {</span>
<span class="nc" id="L1507">                return i;</span>
            }
        }
<span class="nc" id="L1510">        return -1;</span>
    }

    /**
     * Returns the bounds of the specified tab in the coordinate space
     * of the JTabbedPane component.  This is required because the tab rects
     * are by default defined in the coordinate space of the component where
     * they are rendered, which could be the JTabbedPane
     * (for WRAP_TAB_LAYOUT) or a ScrollableTabPanel (SCROLL_TAB_LAYOUT).
     * This method should be used whenever the tab rectangle must be relative
     * to the JTabbedPane itself and the result should be placed in a
     * designated Rectangle object (rather than instantiating and returning
     * a new Rectangle each time). The tab index parameter must be a valid
     * tabbed pane tab index (0 to tab count - 1, inclusive).  The destination
     * rectangle parameter must be a valid &lt;code&gt;Rectangle&lt;/code&gt; instance.
     * The handling of invalid parameters is unspecified.
     *
     * @param tabIndex the index of the tab
     * @param dest the rectangle where the result should be placed
     * @return the resulting rectangle
     *
     * @since 1.4
     */
    protected Rectangle getTabBounds(int tabIndex, Rectangle dest) {
<span class="nc" id="L1534">        dest.width = rects[tabIndex].width;</span>
<span class="nc" id="L1535">        dest.height = rects[tabIndex].height;</span>

<span class="nc bnc" id="L1537" title="All 2 branches missed.">        if (scrollableTabLayoutEnabled()) { // SCROLL_TAB_LAYOUT</span>
            // Need to translate coordinates based on viewport location &amp;
            // view position
<span class="nc" id="L1540">            Point vpp = tabScroller.viewport.getLocation();</span>
<span class="nc" id="L1541">            Point viewp = tabScroller.viewport.getViewPosition();</span>
<span class="nc" id="L1542">            dest.x = rects[tabIndex].x + vpp.x - viewp.x;</span>
<span class="nc" id="L1543">            dest.y = rects[tabIndex].y + vpp.y - viewp.y;</span>

<span class="nc" id="L1545">        } else { // WRAP_TAB_LAYOUT</span>
<span class="nc" id="L1546">            dest.x = rects[tabIndex].x;</span>
<span class="nc" id="L1547">            dest.y = rects[tabIndex].y;</span>
        }
<span class="nc" id="L1549">        return dest;</span>
    }

    /**
     * Returns the index of the tab closest to the passed in location, note
     * that the returned tab may not contain the location x,y.
     */
    private int getClosestTab(int x, int y) {
<span class="nc" id="L1557">        int min = 0;</span>
<span class="nc" id="L1558">        int tabCount = Math.min(rects.length, tabPane.getTabCount());</span>
<span class="nc" id="L1559">        int max = tabCount;</span>
<span class="nc" id="L1560">        int tabPlacement = tabPane.getTabPlacement();</span>
<span class="nc bnc" id="L1561" title="All 4 branches missed.">        boolean useX = (tabPlacement == TOP || tabPlacement == BOTTOM);</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">        int want = (useX) ? x : y;</span>

<span class="nc bnc" id="L1564" title="All 2 branches missed.">        while (min != max) {</span>
<span class="nc" id="L1565">            int current = (max + min) / 2;</span>
            int minLoc;
            int maxLoc;

<span class="nc bnc" id="L1569" title="All 2 branches missed.">            if (useX) {</span>
<span class="nc" id="L1570">                minLoc = rects[current].x;</span>
<span class="nc" id="L1571">                maxLoc = minLoc + rects[current].width;</span>
            }
            else {
<span class="nc" id="L1574">                minLoc = rects[current].y;</span>
<span class="nc" id="L1575">                maxLoc = minLoc + rects[current].height;</span>
            }
<span class="nc bnc" id="L1577" title="All 2 branches missed.">            if (want &lt; minLoc) {</span>
<span class="nc" id="L1578">                max = current;</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">                if (min == max) {</span>
<span class="nc" id="L1580">                    return Math.max(0, current - 1);</span>
                }
            }
<span class="nc bnc" id="L1583" title="All 2 branches missed.">            else if (want &gt;= maxLoc) {</span>
<span class="nc" id="L1584">                min = current;</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">                if (max - min &lt;= 1) {</span>
<span class="nc" id="L1586">                    return Math.max(current + 1, tabCount - 1);</span>
                }
            }
            else {
<span class="nc" id="L1590">                return current;</span>
            }
<span class="nc" id="L1592">        }</span>
<span class="nc" id="L1593">        return min;</span>
    }

    /**
     * Returns a point which is translated from the specified point in the
     * JTabbedPane's coordinate space to the coordinate space of the
     * ScrollableTabPanel.  This is used for SCROLL_TAB_LAYOUT ONLY.
     */
    private Point translatePointToTabPanel(int srcx, int srcy, Point dest) {
<span class="nc" id="L1602">        Point vpp = tabScroller.viewport.getLocation();</span>
<span class="nc" id="L1603">        Point viewp = tabScroller.viewport.getViewPosition();</span>
<span class="nc" id="L1604">        dest.x = srcx - vpp.x + viewp.x;</span>
<span class="nc" id="L1605">        dest.y = srcy - vpp.y + viewp.y;</span>
<span class="nc" id="L1606">        return dest;</span>
    }

// BasicTabbedPaneUI methods

    protected Component getVisibleComponent() {
<span class="nc" id="L1612">        return visibleComponent;</span>
    }

    protected void setVisibleComponent(Component component) {
<span class="nc bnc" id="L1616" title="All 4 branches missed.">        if (visibleComponent != null</span>
                &amp;&amp; visibleComponent != component
<span class="nc bnc" id="L1618" title="All 2 branches missed.">                &amp;&amp; visibleComponent.getParent() == tabPane</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">                &amp;&amp; visibleComponent.isVisible()) {</span>

<span class="nc" id="L1621">            visibleComponent.setVisible(false);</span>
        }
<span class="nc bnc" id="L1623" title="All 4 branches missed.">        if (component != null &amp;&amp; !component.isVisible()) {</span>
<span class="nc" id="L1624">            component.setVisible(true);</span>
        }
<span class="nc" id="L1626">        visibleComponent = component;</span>
<span class="nc" id="L1627">    }</span>

    protected void assureRectsCreated(int tabCount) {
<span class="nc" id="L1630">        int rectArrayLen = rects.length;</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">        if (tabCount != rectArrayLen ) {</span>
<span class="nc" id="L1632">            Rectangle[] tempRectArray = new Rectangle[tabCount];</span>
<span class="nc" id="L1633">            System.arraycopy(rects, 0, tempRectArray, 0,</span>
<span class="nc" id="L1634">                             Math.min(rectArrayLen, tabCount));</span>
<span class="nc" id="L1635">            rects = tempRectArray;</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">            for (int rectIndex = rectArrayLen; rectIndex &lt; tabCount; rectIndex++) {</span>
<span class="nc" id="L1637">                rects[rectIndex] = new Rectangle();</span>
            }
        }

<span class="nc" id="L1641">    }</span>

    protected void expandTabRunsArray() {
<span class="nc" id="L1644">        int rectLen = tabRuns.length;</span>
<span class="nc" id="L1645">        int[] newArray = new int[rectLen+10];</span>
<span class="nc" id="L1646">        System.arraycopy(tabRuns, 0, newArray, 0, runCount);</span>
<span class="nc" id="L1647">        tabRuns = newArray;</span>
<span class="nc" id="L1648">    }</span>

    protected int getRunForTab(int tabCount, int tabIndex) {
<span class="nc bnc" id="L1651" title="All 2 branches missed.">        for (int i = 0; i &lt; runCount; i++) {</span>
<span class="nc" id="L1652">            int first = tabRuns[i];</span>
<span class="nc" id="L1653">            int last = lastTabInRun(tabCount, i);</span>
<span class="nc bnc" id="L1654" title="All 4 branches missed.">            if (tabIndex &gt;= first &amp;&amp; tabIndex &lt;= last) {</span>
<span class="nc" id="L1655">                return i;</span>
            }
        }
<span class="nc" id="L1658">        return 0;</span>
    }

    protected int lastTabInRun(int tabCount, int run) {
<span class="nc bnc" id="L1662" title="All 2 branches missed.">        if (runCount == 1) {</span>
<span class="nc" id="L1663">            return tabCount - 1;</span>
        }
<span class="nc bnc" id="L1665" title="All 2 branches missed.">        int nextRun = (run == runCount - 1? 0 : run + 1);</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">        if (tabRuns[nextRun] == 0) {</span>
<span class="nc" id="L1667">            return tabCount - 1;</span>
        }
<span class="nc" id="L1669">        return tabRuns[nextRun]-1;</span>
    }

    protected int getTabRunOverlay(int tabPlacement) {
<span class="nc" id="L1673">        return tabRunOverlay;</span>
    }

    protected int getTabRunIndent(int tabPlacement, int run) {
<span class="nc" id="L1677">        return 0;</span>
    }

    protected boolean shouldPadTabRun(int tabPlacement, int run) {
<span class="nc bnc" id="L1681" title="All 2 branches missed.">        return runCount &gt; 1;</span>
    }

    protected boolean shouldRotateTabRuns(int tabPlacement) {
<span class="nc" id="L1685">        return true;</span>
    }

    protected Icon getIconForTab(int tabIndex) {
<span class="nc bnc" id="L1689" title="All 4 branches missed.">        return (!tabPane.isEnabled() || !tabPane.isEnabledAt(tabIndex))?</span>
<span class="nc" id="L1690">                          tabPane.getDisabledIconAt(tabIndex) : tabPane.getIconAt(tabIndex);</span>
    }

    /**
     * Returns the text View object required to render stylized text (HTML) for
     * the specified tab or null if no specialized text rendering is needed
     * for this tab. This is provided to support html rendering inside tabs.
     *
     * @param tabIndex the index of the tab
     * @return the text view to render the tab's text or null if no
     *         specialized rendering is required
     *
     * @since 1.4
     */
    protected View getTextViewForTab(int tabIndex) {
<span class="nc bnc" id="L1705" title="All 2 branches missed.">        if (htmlViews != null) {</span>
<span class="nc" id="L1706">            return htmlViews.elementAt(tabIndex);</span>
        }
<span class="nc" id="L1708">        return null;</span>
    }

    protected int calculateTabHeight(int tabPlacement, int tabIndex, int fontHeight) {
<span class="nc" id="L1712">        int height = 0;</span>
<span class="nc" id="L1713">        Component c = tabPane.getTabComponentAt(tabIndex);</span>
<span class="nc bnc" id="L1714" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L1715">            height = c.getPreferredSize().height;</span>
        } else {
<span class="nc" id="L1717">            View v = getTextViewForTab(tabIndex);</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">            if (v != null) {</span>
                // html
<span class="nc" id="L1720">                height += (int) v.getPreferredSpan(View.Y_AXIS);</span>
            } else {
                // plain text
<span class="nc" id="L1723">                height += fontHeight;</span>
            }
<span class="nc" id="L1725">            Icon icon = getIconForTab(tabIndex);</span>

<span class="nc bnc" id="L1727" title="All 2 branches missed.">            if (icon != null) {</span>
<span class="nc" id="L1728">                height = Math.max(height, icon.getIconHeight());</span>
            }
        }
<span class="nc" id="L1731">        Insets tabInsets = getTabInsets(tabPlacement, tabIndex);</span>
<span class="nc" id="L1732">        height += tabInsets.top + tabInsets.bottom + 2;</span>
<span class="nc" id="L1733">        return height;</span>
    }

    protected int calculateMaxTabHeight(int tabPlacement) {
<span class="nc" id="L1737">        FontMetrics metrics = getFontMetrics();</span>
<span class="nc" id="L1738">        int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L1739">        int result = 0;</span>
<span class="nc" id="L1740">        int fontHeight = metrics.getHeight();</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">        for(int i = 0; i &lt; tabCount; i++) {</span>
<span class="nc" id="L1742">            result = Math.max(calculateTabHeight(tabPlacement, i, fontHeight), result);</span>
        }
<span class="nc" id="L1744">        return result;</span>
    }

    protected int calculateTabWidth(int tabPlacement, int tabIndex, FontMetrics metrics) {
<span class="nc" id="L1748">        Insets tabInsets = getTabInsets(tabPlacement, tabIndex);</span>
<span class="nc" id="L1749">        int width = tabInsets.left + tabInsets.right + 3;</span>
<span class="nc" id="L1750">        Component tabComponent = tabPane.getTabComponentAt(tabIndex);</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">        if (tabComponent != null) {</span>
<span class="nc" id="L1752">            width += tabComponent.getPreferredSize().width;</span>
        } else {
<span class="nc" id="L1754">            Icon icon = getIconForTab(tabIndex);</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">            if (icon != null) {</span>
<span class="nc" id="L1756">                width += icon.getIconWidth() + textIconGap;</span>
            }
<span class="nc" id="L1758">            View v = getTextViewForTab(tabIndex);</span>
<span class="nc bnc" id="L1759" title="All 2 branches missed.">            if (v != null) {</span>
                // html
<span class="nc" id="L1761">                width += (int) v.getPreferredSpan(View.X_AXIS);</span>
            } else {
                // plain text
<span class="nc" id="L1764">                String title = tabPane.getTitleAt(tabIndex);</span>
<span class="nc" id="L1765">                width += SwingUtilities2.stringWidth(tabPane, metrics, title);</span>
            }
        }
<span class="nc" id="L1768">        return width;</span>
    }

    protected int calculateMaxTabWidth(int tabPlacement) {
<span class="nc" id="L1772">        FontMetrics metrics = getFontMetrics();</span>
<span class="nc" id="L1773">        int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L1774">        int result = 0;</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">        for(int i = 0; i &lt; tabCount; i++) {</span>
<span class="nc" id="L1776">            result = Math.max(calculateTabWidth(tabPlacement, i, metrics), result);</span>
        }
<span class="nc" id="L1778">        return result;</span>
    }

    protected int calculateTabAreaHeight(int tabPlacement, int horizRunCount, int maxTabHeight) {
<span class="nc" id="L1782">        Insets tabAreaInsets = getTabAreaInsets(tabPlacement);</span>
<span class="nc" id="L1783">        int tabRunOverlay = getTabRunOverlay(tabPlacement);</span>
<span class="nc bnc" id="L1784" title="All 2 branches missed.">        return (horizRunCount &gt; 0?</span>
                horizRunCount * (maxTabHeight-tabRunOverlay) + tabRunOverlay +
                tabAreaInsets.top + tabAreaInsets.bottom :
                0);
    }

    protected int calculateTabAreaWidth(int tabPlacement, int vertRunCount, int maxTabWidth) {
<span class="nc" id="L1791">        Insets tabAreaInsets = getTabAreaInsets(tabPlacement);</span>
<span class="nc" id="L1792">        int tabRunOverlay = getTabRunOverlay(tabPlacement);</span>
<span class="nc bnc" id="L1793" title="All 2 branches missed.">        return (vertRunCount &gt; 0?</span>
                vertRunCount * (maxTabWidth-tabRunOverlay) + tabRunOverlay +
                tabAreaInsets.left + tabAreaInsets.right :
                0);
    }

    protected Insets getTabInsets(int tabPlacement, int tabIndex) {
<span class="nc" id="L1800">        return tabInsets;</span>
    }

    protected Insets getSelectedTabPadInsets(int tabPlacement) {
<span class="nc" id="L1804">        rotateInsets(selectedTabPadInsets, currentPadInsets, tabPlacement);</span>
<span class="nc" id="L1805">        return currentPadInsets;</span>
    }

    protected Insets getTabAreaInsets(int tabPlacement) {
<span class="nc" id="L1809">        rotateInsets(tabAreaInsets, currentTabAreaInsets, tabPlacement);</span>
<span class="nc" id="L1810">        return currentTabAreaInsets;</span>
    }

    protected Insets getContentBorderInsets(int tabPlacement) {
<span class="nc" id="L1814">        return contentBorderInsets;</span>
    }

    protected FontMetrics getFontMetrics() {
<span class="nc" id="L1818">        Font font = tabPane.getFont();</span>
<span class="nc" id="L1819">        return tabPane.getFontMetrics(font);</span>
    }


// Tab Navigation methods

    protected void navigateSelectedTab(int direction) {
<span class="nc" id="L1826">        int tabPlacement = tabPane.getTabPlacement();</span>
<span class="nc bnc" id="L1827" title="All 2 branches missed.">        int current = DefaultLookup.getBoolean(tabPane, this,</span>
                             &quot;TabbedPane.selectionFollowsFocus&quot;, true) ?
<span class="nc" id="L1829">                             tabPane.getSelectedIndex() : getFocusIndex();</span>
<span class="nc" id="L1830">        int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L1831">        boolean leftToRight = BasicGraphicsUtils.isLeftToRight(tabPane);</span>

        // If we have no tabs then don't navigate.
<span class="nc bnc" id="L1834" title="All 2 branches missed.">        if (tabCount &lt;= 0) {</span>
<span class="nc" id="L1835">            return;</span>
        }

        int offset;
<span class="nc bnc" id="L1839" title="All 2 branches missed.">        switch(tabPlacement) {</span>
          case LEFT:
          case RIGHT:
<span class="nc bnc" id="L1842" title="All 7 branches missed.">              switch(direction) {</span>
                 case NEXT:
<span class="nc" id="L1844">                     selectNextTab(current);</span>
<span class="nc" id="L1845">                     break;</span>
                 case PREVIOUS:
<span class="nc" id="L1847">                     selectPreviousTab(current);</span>
<span class="nc" id="L1848">                     break;</span>
                case NORTH:
<span class="nc" id="L1850">                    selectPreviousTabInRun(current);</span>
<span class="nc" id="L1851">                    break;</span>
                case SOUTH:
<span class="nc" id="L1853">                    selectNextTabInRun(current);</span>
<span class="nc" id="L1854">                    break;</span>
                case WEST:
<span class="nc" id="L1856">                    offset = getTabRunOffset(tabPlacement, tabCount, current, false);</span>
<span class="nc" id="L1857">                    selectAdjacentRunTab(tabPlacement, current, offset);</span>
<span class="nc" id="L1858">                    break;</span>
                case EAST:
<span class="nc" id="L1860">                    offset = getTabRunOffset(tabPlacement, tabCount, current, true);</span>
<span class="nc" id="L1861">                    selectAdjacentRunTab(tabPlacement, current, offset);</span>
<span class="nc" id="L1862">                    break;</span>
                default:
              }
<span class="nc" id="L1865">              break;</span>
          case BOTTOM:
          case TOP:
          default:
<span class="nc bnc" id="L1869" title="All 7 branches missed.">              switch(direction) {</span>
                case NEXT:
<span class="nc" id="L1871">                    selectNextTab(current);</span>
<span class="nc" id="L1872">                    break;</span>
                case PREVIOUS:
<span class="nc" id="L1874">                    selectPreviousTab(current);</span>
<span class="nc" id="L1875">                    break;</span>
                case NORTH:
<span class="nc" id="L1877">                    offset = getTabRunOffset(tabPlacement, tabCount, current, false);</span>
<span class="nc" id="L1878">                    selectAdjacentRunTab(tabPlacement, current, offset);</span>
<span class="nc" id="L1879">                    break;</span>
                case SOUTH:
<span class="nc" id="L1881">                    offset = getTabRunOffset(tabPlacement, tabCount, current, true);</span>
<span class="nc" id="L1882">                    selectAdjacentRunTab(tabPlacement, current, offset);</span>
<span class="nc" id="L1883">                    break;</span>
                case EAST:
<span class="nc bnc" id="L1885" title="All 2 branches missed.">                    if (leftToRight) {</span>
<span class="nc" id="L1886">                        selectNextTabInRun(current);</span>
                    } else {
<span class="nc" id="L1888">                        selectPreviousTabInRun(current);</span>
                    }
<span class="nc" id="L1890">                    break;</span>
                case WEST:
<span class="nc bnc" id="L1892" title="All 2 branches missed.">                    if (leftToRight) {</span>
<span class="nc" id="L1893">                        selectPreviousTabInRun(current);</span>
                    } else {
<span class="nc" id="L1895">                        selectNextTabInRun(current);</span>
                    }
<span class="nc" id="L1897">                    break;</span>
                default:
              }
        }
<span class="nc" id="L1901">    }</span>

    protected void selectNextTabInRun(int current) {
<span class="nc" id="L1904">        int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L1905">        int tabIndex = getNextTabIndexInRun(tabCount, current);</span>

<span class="nc bnc" id="L1907" title="All 4 branches missed.">        while(tabIndex != current &amp;&amp; !tabPane.isEnabledAt(tabIndex)) {</span>
<span class="nc" id="L1908">            tabIndex = getNextTabIndexInRun(tabCount, tabIndex);</span>
        }
<span class="nc" id="L1910">        navigateTo(tabIndex);</span>
<span class="nc" id="L1911">    }</span>

    protected void selectPreviousTabInRun(int current) {
<span class="nc" id="L1914">        int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L1915">        int tabIndex = getPreviousTabIndexInRun(tabCount, current);</span>

<span class="nc bnc" id="L1917" title="All 4 branches missed.">        while(tabIndex != current &amp;&amp; !tabPane.isEnabledAt(tabIndex)) {</span>
<span class="nc" id="L1918">            tabIndex = getPreviousTabIndexInRun(tabCount, tabIndex);</span>
        }
<span class="nc" id="L1920">        navigateTo(tabIndex);</span>
<span class="nc" id="L1921">    }</span>

    protected void selectNextTab(int current) {
<span class="nc" id="L1924">        int tabIndex = getNextTabIndex(current);</span>

<span class="nc bnc" id="L1926" title="All 4 branches missed.">        while (tabIndex != current &amp;&amp; !tabPane.isEnabledAt(tabIndex)) {</span>
<span class="nc" id="L1927">            tabIndex = getNextTabIndex(tabIndex);</span>
        }
<span class="nc" id="L1929">        navigateTo(tabIndex);</span>
<span class="nc" id="L1930">    }</span>

    protected void selectPreviousTab(int current) {
<span class="nc" id="L1933">        int tabIndex = getPreviousTabIndex(current);</span>

<span class="nc bnc" id="L1935" title="All 4 branches missed.">        while (tabIndex != current &amp;&amp; !tabPane.isEnabledAt(tabIndex)) {</span>
<span class="nc" id="L1936">            tabIndex = getPreviousTabIndex(tabIndex);</span>
        }
<span class="nc" id="L1938">        navigateTo(tabIndex);</span>
<span class="nc" id="L1939">    }</span>

    protected void selectAdjacentRunTab(int tabPlacement,
                                        int tabIndex, int offset) {
<span class="nc bnc" id="L1943" title="All 2 branches missed.">        if ( runCount &lt; 2 ) {</span>
<span class="nc" id="L1944">            return;</span>
        }
        int newIndex;
<span class="nc" id="L1947">        Rectangle r = rects[tabIndex];</span>
<span class="nc bnc" id="L1948" title="All 2 branches missed.">        switch(tabPlacement) {</span>
          case LEFT:
          case RIGHT:
<span class="nc" id="L1951">              newIndex = tabForCoordinate(tabPane, r.x + r.width/2 + offset,</span>
                                       r.y + r.height/2);
<span class="nc" id="L1953">              break;</span>
          case BOTTOM:
          case TOP:
          default:
<span class="nc" id="L1957">              newIndex = tabForCoordinate(tabPane, r.x + r.width/2,</span>
                                       r.y + r.height/2 + offset);
        }
<span class="nc bnc" id="L1960" title="All 2 branches missed.">        if (newIndex != -1) {</span>
<span class="nc bnc" id="L1961" title="All 4 branches missed.">            while (!tabPane.isEnabledAt(newIndex) &amp;&amp; newIndex != tabIndex) {</span>
<span class="nc" id="L1962">                newIndex = getNextTabIndex(newIndex);</span>
            }
<span class="nc" id="L1964">            navigateTo(newIndex);</span>
        }
<span class="nc" id="L1966">    }</span>

    private void navigateTo(int index) {
<span class="nc bnc" id="L1969" title="All 2 branches missed.">        if (DefaultLookup.getBoolean(tabPane, this,</span>
                             &quot;TabbedPane.selectionFollowsFocus&quot;, true)) {
<span class="nc" id="L1971">            tabPane.setSelectedIndex(index);</span>
        } else {
            // Just move focus (not selection)
<span class="nc" id="L1974">            setFocusIndex(index, true);</span>
        }
<span class="nc" id="L1976">    }</span>

    void setFocusIndex(int index, boolean repaint) {
<span class="nc bnc" id="L1979" title="All 4 branches missed.">        if (repaint &amp;&amp; !isRunsDirty) {</span>
<span class="nc" id="L1980">            repaintTab(focusIndex);</span>
<span class="nc" id="L1981">            focusIndex = index;</span>
<span class="nc" id="L1982">            repaintTab(focusIndex);</span>
        }
        else {
<span class="nc" id="L1985">            focusIndex = index;</span>
        }
<span class="nc" id="L1987">    }</span>

    /**
     * Repaints the specified tab.
     */
    private void repaintTab(int index) {
        // If we're not valid that means we will shortly be validated and
        // painted, which means we don't have to do anything here.
<span class="nc bnc" id="L1995" title="All 6 branches missed.">        if (!isRunsDirty &amp;&amp; index &gt;= 0 &amp;&amp; index &lt; tabPane.getTabCount()) {</span>
<span class="nc" id="L1996">            tabPane.repaint(getTabBounds(tabPane, index));</span>
        }
<span class="nc" id="L1998">    }</span>

    /**
     * Makes sure the focusIndex is valid.
     */
    private void validateFocusIndex() {
<span class="nc bnc" id="L2004" title="All 2 branches missed.">        if (focusIndex &gt;= tabPane.getTabCount()) {</span>
<span class="nc" id="L2005">            setFocusIndex(tabPane.getSelectedIndex(), false);</span>
        }
<span class="nc" id="L2007">    }</span>

    /**
     * Returns the index of the tab that has focus.
     *
     * @return index of tab that has focus
     * @since 1.5
     */
    protected int getFocusIndex() {
<span class="nc" id="L2016">        return focusIndex;</span>
    }

    protected int getTabRunOffset(int tabPlacement, int tabCount,
                                  int tabIndex, boolean forward) {
<span class="nc" id="L2021">        int run = getRunForTab(tabCount, tabIndex);</span>
        int offset;
<span class="nc bnc" id="L2023" title="All 4 branches missed.">        switch(tabPlacement) {</span>
          case LEFT: {
<span class="nc bnc" id="L2025" title="All 2 branches missed.">              if (run == 0) {</span>
<span class="nc bnc" id="L2026" title="All 2 branches missed.">                  offset = (forward?</span>
<span class="nc" id="L2027">                            -(calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth)-maxTabWidth) :</span>
                            -maxTabWidth);

<span class="nc bnc" id="L2030" title="All 2 branches missed.">              } else if (run == runCount - 1) {</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">                  offset = (forward?</span>
                            maxTabWidth :
<span class="nc" id="L2033">                            calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth)-maxTabWidth);</span>
              } else {
<span class="nc bnc" id="L2035" title="All 2 branches missed.">                  offset = (forward? maxTabWidth : -maxTabWidth);</span>
              }
<span class="nc" id="L2037">              break;</span>
          }
          case RIGHT: {
<span class="nc bnc" id="L2040" title="All 2 branches missed.">              if (run == 0) {</span>
<span class="nc bnc" id="L2041" title="All 2 branches missed.">                  offset = (forward?</span>
                            maxTabWidth :
<span class="nc" id="L2043">                            calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth)-maxTabWidth);</span>
<span class="nc bnc" id="L2044" title="All 2 branches missed.">              } else if (run == runCount - 1) {</span>
<span class="nc bnc" id="L2045" title="All 2 branches missed.">                  offset = (forward?</span>
<span class="nc" id="L2046">                            -(calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth)-maxTabWidth) :</span>
                            -maxTabWidth);
              } else {
<span class="nc bnc" id="L2049" title="All 2 branches missed.">                  offset = (forward? maxTabWidth : -maxTabWidth);</span>
              }
<span class="nc" id="L2051">              break;</span>
          }
          case BOTTOM: {
<span class="nc bnc" id="L2054" title="All 2 branches missed.">              if (run == 0) {</span>
<span class="nc bnc" id="L2055" title="All 2 branches missed.">                  offset = (forward?</span>
                            maxTabHeight :
<span class="nc" id="L2057">                            calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight)-maxTabHeight);</span>
<span class="nc bnc" id="L2058" title="All 2 branches missed.">              } else if (run == runCount - 1) {</span>
<span class="nc bnc" id="L2059" title="All 2 branches missed.">                  offset = (forward?</span>
<span class="nc" id="L2060">                            -(calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight)-maxTabHeight) :</span>
                            -maxTabHeight);
              } else {
<span class="nc bnc" id="L2063" title="All 2 branches missed.">                  offset = (forward? maxTabHeight : -maxTabHeight);</span>
              }
<span class="nc" id="L2065">              break;</span>
          }
          case TOP:
          default: {
<span class="nc bnc" id="L2069" title="All 2 branches missed.">              if (run == 0) {</span>
<span class="nc bnc" id="L2070" title="All 2 branches missed.">                  offset = (forward?</span>
<span class="nc" id="L2071">                            -(calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight)-maxTabHeight) :</span>
                            -maxTabHeight);
<span class="nc bnc" id="L2073" title="All 2 branches missed.">              } else if (run == runCount - 1) {</span>
<span class="nc bnc" id="L2074" title="All 2 branches missed.">                  offset = (forward?</span>
                            maxTabHeight :
<span class="nc" id="L2076">                            calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight)-maxTabHeight);</span>
              } else {
<span class="nc bnc" id="L2078" title="All 2 branches missed.">                  offset = (forward? maxTabHeight : -maxTabHeight);</span>
              }
          }
        }
<span class="nc" id="L2082">        return offset;</span>
    }

    protected int getPreviousTabIndex(int base) {
<span class="nc bnc" id="L2086" title="All 2 branches missed.">        int tabIndex = (base - 1 &gt;= 0? base - 1 : tabPane.getTabCount() - 1);</span>
<span class="nc bnc" id="L2087" title="All 2 branches missed.">        return (tabIndex &gt;= 0? tabIndex : 0);</span>
    }

    protected int getNextTabIndex(int base) {
<span class="nc" id="L2091">        return (base+1)%tabPane.getTabCount();</span>
    }

    protected int getNextTabIndexInRun(int tabCount, int base) {
<span class="nc bnc" id="L2095" title="All 2 branches missed.">        if (runCount &lt; 2) {</span>
<span class="nc" id="L2096">            return getNextTabIndex(base);</span>
        }
<span class="nc" id="L2098">        int currentRun = getRunForTab(tabCount, base);</span>
<span class="nc" id="L2099">        int next = getNextTabIndex(base);</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">        if (next == tabRuns[getNextTabRun(currentRun)]) {</span>
<span class="nc" id="L2101">            return tabRuns[currentRun];</span>
        }
<span class="nc" id="L2103">        return next;</span>
    }

    protected int getPreviousTabIndexInRun(int tabCount, int base) {
<span class="nc bnc" id="L2107" title="All 2 branches missed.">        if (runCount &lt; 2) {</span>
<span class="nc" id="L2108">            return getPreviousTabIndex(base);</span>
        }
<span class="nc" id="L2110">        int currentRun = getRunForTab(tabCount, base);</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">        if (base == tabRuns[currentRun]) {</span>
<span class="nc" id="L2112">            int previous = tabRuns[getNextTabRun(currentRun)]-1;</span>
<span class="nc bnc" id="L2113" title="All 2 branches missed.">            return (previous != -1? previous : tabCount-1);</span>
        }
<span class="nc" id="L2115">        return getPreviousTabIndex(base);</span>
    }

    protected int getPreviousTabRun(int baseRun) {
<span class="nc bnc" id="L2119" title="All 2 branches missed.">        int runIndex = (baseRun - 1 &gt;= 0? baseRun - 1 : runCount - 1);</span>
<span class="nc bnc" id="L2120" title="All 2 branches missed.">        return (runIndex &gt;= 0? runIndex : 0);</span>
    }

    protected int getNextTabRun(int baseRun) {
<span class="nc" id="L2124">        return (baseRun+1)%runCount;</span>
    }

    protected static void rotateInsets(Insets topInsets, Insets targetInsets, int targetPlacement) {

<span class="nc bnc" id="L2129" title="All 4 branches missed.">        switch(targetPlacement) {</span>
          case LEFT:
<span class="nc" id="L2131">              targetInsets.top = topInsets.left;</span>
<span class="nc" id="L2132">              targetInsets.left = topInsets.top;</span>
<span class="nc" id="L2133">              targetInsets.bottom = topInsets.right;</span>
<span class="nc" id="L2134">              targetInsets.right = topInsets.bottom;</span>
<span class="nc" id="L2135">              break;</span>
          case BOTTOM:
<span class="nc" id="L2137">              targetInsets.top = topInsets.bottom;</span>
<span class="nc" id="L2138">              targetInsets.left = topInsets.left;</span>
<span class="nc" id="L2139">              targetInsets.bottom = topInsets.top;</span>
<span class="nc" id="L2140">              targetInsets.right = topInsets.right;</span>
<span class="nc" id="L2141">              break;</span>
          case RIGHT:
<span class="nc" id="L2143">              targetInsets.top = topInsets.left;</span>
<span class="nc" id="L2144">              targetInsets.left = topInsets.bottom;</span>
<span class="nc" id="L2145">              targetInsets.bottom = topInsets.right;</span>
<span class="nc" id="L2146">              targetInsets.right = topInsets.top;</span>
<span class="nc" id="L2147">              break;</span>
          case TOP:
          default:
<span class="nc" id="L2150">              targetInsets.top = topInsets.top;</span>
<span class="nc" id="L2151">              targetInsets.left = topInsets.left;</span>
<span class="nc" id="L2152">              targetInsets.bottom = topInsets.bottom;</span>
<span class="nc" id="L2153">              targetInsets.right = topInsets.right;</span>
        }
<span class="nc" id="L2155">    }</span>

    // REMIND(aim,7/29/98): This method should be made
    // protected in the next release where
    // API changes are allowed
    boolean requestFocusForVisibleComponent() {
<span class="nc" id="L2161">        return SwingUtilities2.tabbedPaneChangeFocusTo(getVisibleComponent());</span>
    }

    private static class Actions extends UIAction {
        final static String NEXT = &quot;navigateNext&quot;;
        final static String PREVIOUS = &quot;navigatePrevious&quot;;
        final static String RIGHT = &quot;navigateRight&quot;;
        final static String LEFT = &quot;navigateLeft&quot;;
        final static String UP = &quot;navigateUp&quot;;
        final static String DOWN = &quot;navigateDown&quot;;
        final static String PAGE_UP = &quot;navigatePageUp&quot;;
        final static String PAGE_DOWN = &quot;navigatePageDown&quot;;
        final static String REQUEST_FOCUS = &quot;requestFocus&quot;;
        final static String REQUEST_FOCUS_FOR_VISIBLE =
                                    &quot;requestFocusForVisibleComponent&quot;;
        final static String SET_SELECTED = &quot;setSelectedIndex&quot;;
        final static String SELECT_FOCUSED = &quot;selectTabWithFocus&quot;;
        final static String SCROLL_FORWARD = &quot;scrollTabsForwardAction&quot;;
        final static String SCROLL_BACKWARD = &quot;scrollTabsBackwardAction&quot;;

        Actions(String key) {
<span class="nc" id="L2182">            super(key);</span>
<span class="nc" id="L2183">        }</span>

        public void actionPerformed(ActionEvent e) {
<span class="nc" id="L2186">            String key = getName();</span>
<span class="nc" id="L2187">            JTabbedPane pane = (JTabbedPane)e.getSource();</span>
<span class="nc" id="L2188">            BasicTabbedPaneUI ui = (BasicTabbedPaneUI)BasicLookAndFeel.</span>
<span class="nc" id="L2189">                       getUIOfType(pane.getUI(), BasicTabbedPaneUI.class);</span>

<span class="nc bnc" id="L2191" title="All 2 branches missed.">            if (ui == null) {</span>
<span class="nc" id="L2192">                return;</span>
            }
<span class="nc bnc" id="L2194" title="All 2 branches missed.">            if (key == NEXT) {</span>
<span class="nc" id="L2195">                ui.navigateSelectedTab(SwingConstants.NEXT);</span>
            }
<span class="nc bnc" id="L2197" title="All 2 branches missed.">            else if (key == PREVIOUS) {</span>
<span class="nc" id="L2198">                ui.navigateSelectedTab(SwingConstants.PREVIOUS);</span>
            }
<span class="nc bnc" id="L2200" title="All 2 branches missed.">            else if (key == RIGHT) {</span>
<span class="nc" id="L2201">                ui.navigateSelectedTab(SwingConstants.EAST);</span>
            }
<span class="nc bnc" id="L2203" title="All 2 branches missed.">            else if (key == LEFT) {</span>
<span class="nc" id="L2204">                ui.navigateSelectedTab(SwingConstants.WEST);</span>
            }
<span class="nc bnc" id="L2206" title="All 2 branches missed.">            else if (key == UP) {</span>
<span class="nc" id="L2207">                ui.navigateSelectedTab(SwingConstants.NORTH);</span>
            }
<span class="nc bnc" id="L2209" title="All 2 branches missed.">            else if (key == DOWN) {</span>
<span class="nc" id="L2210">                ui.navigateSelectedTab(SwingConstants.SOUTH);</span>
            }
<span class="nc bnc" id="L2212" title="All 2 branches missed.">            else if (key == PAGE_UP) {</span>
<span class="nc" id="L2213">                int tabPlacement = pane.getTabPlacement();</span>
<span class="nc bnc" id="L2214" title="All 4 branches missed.">                if (tabPlacement == TOP|| tabPlacement == BOTTOM) {</span>
<span class="nc" id="L2215">                    ui.navigateSelectedTab(SwingConstants.WEST);</span>
                } else {
<span class="nc" id="L2217">                    ui.navigateSelectedTab(SwingConstants.NORTH);</span>
                }
<span class="nc" id="L2219">            }</span>
<span class="nc bnc" id="L2220" title="All 2 branches missed.">            else if (key == PAGE_DOWN) {</span>
<span class="nc" id="L2221">                int tabPlacement = pane.getTabPlacement();</span>
<span class="nc bnc" id="L2222" title="All 4 branches missed.">                if (tabPlacement == TOP || tabPlacement == BOTTOM) {</span>
<span class="nc" id="L2223">                    ui.navigateSelectedTab(SwingConstants.EAST);</span>
                } else {
<span class="nc" id="L2225">                    ui.navigateSelectedTab(SwingConstants.SOUTH);</span>
                }
<span class="nc" id="L2227">            }</span>
<span class="nc bnc" id="L2228" title="All 2 branches missed.">            else if (key == REQUEST_FOCUS) {</span>
<span class="nc" id="L2229">                pane.requestFocus();</span>
            }
<span class="nc bnc" id="L2231" title="All 2 branches missed.">            else if (key == REQUEST_FOCUS_FOR_VISIBLE) {</span>
<span class="nc" id="L2232">                ui.requestFocusForVisibleComponent();</span>
            }
<span class="nc bnc" id="L2234" title="All 2 branches missed.">            else if (key == SET_SELECTED) {</span>
<span class="nc" id="L2235">                String command = e.getActionCommand();</span>

<span class="nc bnc" id="L2237" title="All 4 branches missed.">                if (command != null &amp;&amp; command.length() &gt; 0) {</span>
<span class="nc" id="L2238">                    int mnemonic = (int)e.getActionCommand().charAt(0);</span>
<span class="nc bnc" id="L2239" title="All 4 branches missed.">                    if (mnemonic &gt;= 'a' &amp;&amp; mnemonic &lt;='z') {</span>
<span class="nc" id="L2240">                        mnemonic  -= ('a' - 'A');</span>
                    }
<span class="nc" id="L2242">                    Integer index = ui.mnemonicToIndexMap.get(Integer.valueOf(mnemonic));</span>
<span class="nc bnc" id="L2243" title="All 4 branches missed.">                    if (index != null &amp;&amp; pane.isEnabledAt(index.intValue())) {</span>
<span class="nc" id="L2244">                        pane.setSelectedIndex(index.intValue());</span>
                    }
                }
<span class="nc" id="L2247">            }</span>
<span class="nc bnc" id="L2248" title="All 2 branches missed.">            else if (key == SELECT_FOCUSED) {</span>
<span class="nc" id="L2249">                int focusIndex = ui.getFocusIndex();</span>
<span class="nc bnc" id="L2250" title="All 2 branches missed.">                if (focusIndex != -1) {</span>
<span class="nc" id="L2251">                    pane.setSelectedIndex(focusIndex);</span>
                }
<span class="nc" id="L2253">            }</span>
<span class="nc bnc" id="L2254" title="All 2 branches missed.">            else if (key == SCROLL_FORWARD) {</span>
<span class="nc bnc" id="L2255" title="All 2 branches missed.">                if (ui.scrollableTabLayoutEnabled()) {</span>
<span class="nc" id="L2256">                    ui.tabScroller.scrollForward(pane.getTabPlacement());</span>
                }
            }
<span class="nc bnc" id="L2259" title="All 2 branches missed.">            else if (key == SCROLL_BACKWARD) {</span>
<span class="nc bnc" id="L2260" title="All 2 branches missed.">                if (ui.scrollableTabLayoutEnabled()) {</span>
<span class="nc" id="L2261">                    ui.tabScroller.scrollBackward(pane.getTabPlacement());</span>
                }
            }
<span class="nc" id="L2264">        }</span>
    }

    /**
     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.
     * Instantiate it only within subclasses of BasicTabbedPaneUI.
     */
<span class="nc" id="L2271">    public class TabbedPaneLayout implements LayoutManager {</span>

<span class="nc" id="L2273">        public void addLayoutComponent(String name, Component comp) {}</span>

<span class="nc" id="L2275">        public void removeLayoutComponent(Component comp) {}</span>

        public Dimension preferredLayoutSize(Container parent) {
<span class="nc" id="L2278">            return calculateSize(false);</span>
        }

        public Dimension minimumLayoutSize(Container parent) {
<span class="nc" id="L2282">            return calculateSize(true);</span>
        }

        protected Dimension calculateSize(boolean minimum) {
<span class="nc" id="L2286">            int tabPlacement = tabPane.getTabPlacement();</span>
<span class="nc" id="L2287">            Insets insets = tabPane.getInsets();</span>
<span class="nc" id="L2288">            Insets contentInsets = getContentBorderInsets(tabPlacement);</span>
<span class="nc" id="L2289">            Insets tabAreaInsets = getTabAreaInsets(tabPlacement);</span>

<span class="nc" id="L2291">            Dimension zeroSize = new Dimension(0,0);</span>
<span class="nc" id="L2292">            int height = 0;</span>
<span class="nc" id="L2293">            int width = 0;</span>
<span class="nc" id="L2294">            int cWidth = 0;</span>
<span class="nc" id="L2295">            int cHeight = 0;</span>

            // Determine minimum size required to display largest
            // child in each dimension
            //
<span class="nc bnc" id="L2300" title="All 2 branches missed.">            for (int i = 0; i &lt; tabPane.getTabCount(); i++) {</span>
<span class="nc" id="L2301">                Component component = tabPane.getComponentAt(i);</span>
<span class="nc bnc" id="L2302" title="All 2 branches missed.">                if (component != null) {</span>
<span class="nc bnc" id="L2303" title="All 2 branches missed.">                    Dimension size = minimum ? component.getMinimumSize() :</span>
<span class="nc" id="L2304">                                component.getPreferredSize();</span>

<span class="nc bnc" id="L2306" title="All 2 branches missed.">                    if (size != null) {</span>
<span class="nc" id="L2307">                        cHeight = Math.max(size.height, cHeight);</span>
<span class="nc" id="L2308">                        cWidth = Math.max(size.width, cWidth);</span>
                    }
                }
            }
            // Add content border insets to minimum size
<span class="nc" id="L2313">            width += cWidth;</span>
<span class="nc" id="L2314">            height += cHeight;</span>
            int tabExtent;

            // Calculate how much space the tabs will need, based on the
            // minimum size required to display largest child + content border
            //
<span class="nc bnc" id="L2320" title="All 2 branches missed.">            switch(tabPlacement) {</span>
              case LEFT:
              case RIGHT:
<span class="nc" id="L2323">                  height = Math.max(height, calculateMaxTabHeight(tabPlacement));</span>
<span class="nc" id="L2324">                  tabExtent = preferredTabAreaWidth(tabPlacement, height - tabAreaInsets.top - tabAreaInsets.bottom);</span>
<span class="nc" id="L2325">                  width += tabExtent;</span>
<span class="nc" id="L2326">                  break;</span>
              case TOP:
              case BOTTOM:
              default:
<span class="nc" id="L2330">                  width = Math.max(width, calculateMaxTabWidth(tabPlacement));</span>
<span class="nc" id="L2331">                  tabExtent = preferredTabAreaHeight(tabPlacement, width - tabAreaInsets.left - tabAreaInsets.right);</span>
<span class="nc" id="L2332">                  height += tabExtent;</span>
            }
<span class="nc" id="L2334">            return new Dimension(width + insets.left + insets.right + contentInsets.left + contentInsets.right,</span>
                             height + insets.bottom + insets.top + contentInsets.top + contentInsets.bottom);

        }

        protected int preferredTabAreaHeight(int tabPlacement, int width) {
<span class="nc" id="L2340">            FontMetrics metrics = getFontMetrics();</span>
<span class="nc" id="L2341">            int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L2342">            int total = 0;</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">            if (tabCount &gt; 0) {</span>
<span class="nc" id="L2344">                int rows = 1;</span>
<span class="nc" id="L2345">                int x = 0;</span>

<span class="nc" id="L2347">                int maxTabHeight = calculateMaxTabHeight(tabPlacement);</span>

<span class="nc bnc" id="L2349" title="All 2 branches missed.">                for (int i = 0; i &lt; tabCount; i++) {</span>
<span class="nc" id="L2350">                    int tabWidth = calculateTabWidth(tabPlacement, i, metrics);</span>

<span class="nc bnc" id="L2352" title="All 4 branches missed.">                    if (x != 0 &amp;&amp; x + tabWidth &gt; width) {</span>
<span class="nc" id="L2353">                        rows++;</span>
<span class="nc" id="L2354">                        x = 0;</span>
                    }
<span class="nc" id="L2356">                    x += tabWidth;</span>
                }
<span class="nc" id="L2358">                total = calculateTabAreaHeight(tabPlacement, rows, maxTabHeight);</span>
            }
<span class="nc" id="L2360">            return total;</span>
        }

        protected int preferredTabAreaWidth(int tabPlacement, int height) {
<span class="nc" id="L2364">            FontMetrics metrics = getFontMetrics();</span>
<span class="nc" id="L2365">            int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L2366">            int total = 0;</span>
<span class="nc bnc" id="L2367" title="All 2 branches missed.">            if (tabCount &gt; 0) {</span>
<span class="nc" id="L2368">                int columns = 1;</span>
<span class="nc" id="L2369">                int y = 0;</span>
<span class="nc" id="L2370">                int fontHeight = metrics.getHeight();</span>

<span class="nc" id="L2372">                maxTabWidth = calculateMaxTabWidth(tabPlacement);</span>

<span class="nc bnc" id="L2374" title="All 2 branches missed.">                for (int i = 0; i &lt; tabCount; i++) {</span>
<span class="nc" id="L2375">                    int tabHeight = calculateTabHeight(tabPlacement, i, fontHeight);</span>

<span class="nc bnc" id="L2377" title="All 4 branches missed.">                    if (y != 0 &amp;&amp; y + tabHeight &gt; height) {</span>
<span class="nc" id="L2378">                        columns++;</span>
<span class="nc" id="L2379">                        y = 0;</span>
                    }
<span class="nc" id="L2381">                    y += tabHeight;</span>
                }
<span class="nc" id="L2383">                total = calculateTabAreaWidth(tabPlacement, columns, maxTabWidth);</span>
            }
<span class="nc" id="L2385">            return total;</span>
        }

        public void layoutContainer(Container parent) {
            /* Some of the code in this method deals with changing the
            * visibility of components to hide and show the contents for the
            * selected tab. This is older code that has since been duplicated
            * in JTabbedPane.fireStateChanged(), so as to allow visibility
            * changes to happen sooner (see the note there). This code remains
            * for backward compatibility as there are some cases, such as
            * subclasses that don't fireStateChanged() where it may be used.
            * Any changes here need to be kept in synch with
            * JTabbedPane.fireStateChanged().
            */

<span class="nc" id="L2400">            setRolloverTab(-1);</span>

<span class="nc" id="L2402">            int tabPlacement = tabPane.getTabPlacement();</span>
<span class="nc" id="L2403">            Insets insets = tabPane.getInsets();</span>
<span class="nc" id="L2404">            int selectedIndex = tabPane.getSelectedIndex();</span>
<span class="nc" id="L2405">            Component visibleComponent = getVisibleComponent();</span>

<span class="nc" id="L2407">            calculateLayoutInfo();</span>

<span class="nc" id="L2409">            Component selectedComponent = null;</span>
<span class="nc bnc" id="L2410" title="All 2 branches missed.">            if (selectedIndex &lt; 0) {</span>
<span class="nc bnc" id="L2411" title="All 2 branches missed.">                if (visibleComponent != null) {</span>
                    // The last tab was removed, so remove the component
<span class="nc" id="L2413">                    setVisibleComponent(null);</span>
                }
            } else {
<span class="nc" id="L2416">                selectedComponent = tabPane.getComponentAt(selectedIndex);</span>
            }
            int cx, cy, cw, ch;
<span class="nc" id="L2419">            int totalTabWidth = 0;</span>
<span class="nc" id="L2420">            int totalTabHeight = 0;</span>
<span class="nc" id="L2421">            Insets contentInsets = getContentBorderInsets(tabPlacement);</span>

<span class="nc" id="L2423">            boolean shouldChangeFocus = false;</span>

            // In order to allow programs to use a single component
            // as the display for multiple tabs, we will not change
            // the visible compnent if the currently selected tab
            // has a null component.  This is a bit dicey, as we don't
            // explicitly state we support this in the spec, but since
            // programs are now depending on this, we're making it work.
            //
<span class="nc bnc" id="L2432" title="All 2 branches missed.">            if(selectedComponent != null) {</span>
<span class="nc bnc" id="L2433" title="All 4 branches missed.">                if(selectedComponent != visibleComponent &amp;&amp;</span>
                        visibleComponent != null) {
<span class="nc bnc" id="L2435" title="All 2 branches missed.">                    if(SwingUtilities.findFocusOwner(visibleComponent) != null) {</span>
<span class="nc" id="L2436">                        shouldChangeFocus = true;</span>
                    }
                }
<span class="nc" id="L2439">                setVisibleComponent(selectedComponent);</span>
            }

<span class="nc" id="L2442">            Rectangle bounds = tabPane.getBounds();</span>
<span class="nc" id="L2443">            int numChildren = tabPane.getComponentCount();</span>

<span class="nc bnc" id="L2445" title="All 2 branches missed.">            if(numChildren &gt; 0) {</span>

<span class="nc bnc" id="L2447" title="All 4 branches missed.">                switch(tabPlacement) {</span>
                    case LEFT:
<span class="nc" id="L2449">                        totalTabWidth = calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth);</span>
<span class="nc" id="L2450">                        cx = insets.left + totalTabWidth + contentInsets.left;</span>
<span class="nc" id="L2451">                        cy = insets.top + contentInsets.top;</span>
<span class="nc" id="L2452">                        break;</span>
                    case RIGHT:
<span class="nc" id="L2454">                        totalTabWidth = calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth);</span>
<span class="nc" id="L2455">                        cx = insets.left + contentInsets.left;</span>
<span class="nc" id="L2456">                        cy = insets.top + contentInsets.top;</span>
<span class="nc" id="L2457">                        break;</span>
                    case BOTTOM:
<span class="nc" id="L2459">                        totalTabHeight = calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight);</span>
<span class="nc" id="L2460">                        cx = insets.left + contentInsets.left;</span>
<span class="nc" id="L2461">                        cy = insets.top + contentInsets.top;</span>
<span class="nc" id="L2462">                        break;</span>
                    case TOP:
                    default:
<span class="nc" id="L2465">                        totalTabHeight = calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight);</span>
<span class="nc" id="L2466">                        cx = insets.left + contentInsets.left;</span>
<span class="nc" id="L2467">                        cy = insets.top + totalTabHeight + contentInsets.top;</span>
                }

<span class="nc" id="L2470">                cw = bounds.width - totalTabWidth -</span>
                        insets.left - insets.right -
                        contentInsets.left - contentInsets.right;
<span class="nc" id="L2473">                ch = bounds.height - totalTabHeight -</span>
                        insets.top - insets.bottom -
                        contentInsets.top - contentInsets.bottom;

<span class="nc bnc" id="L2477" title="All 2 branches missed.">                for(int i = 0; i &lt; numChildren; i++) {</span>
<span class="nc" id="L2478">                    Component child = tabPane.getComponent(i);</span>
<span class="nc bnc" id="L2479" title="All 2 branches missed.">                    if(child == tabContainer) {</span>

<span class="nc bnc" id="L2481" title="All 2 branches missed.">                        int tabContainerWidth = totalTabWidth == 0 ? bounds.width :</span>
                                totalTabWidth + insets.left + insets.right +
                                        contentInsets.left + contentInsets.right;
<span class="nc bnc" id="L2484" title="All 2 branches missed.">                        int tabContainerHeight = totalTabHeight == 0 ? bounds.height :</span>
                                totalTabHeight + insets.top + insets.bottom +
                                        contentInsets.top + contentInsets.bottom;

<span class="nc" id="L2488">                        int tabContainerX = 0;</span>
<span class="nc" id="L2489">                        int tabContainerY = 0;</span>
<span class="nc bnc" id="L2490" title="All 2 branches missed.">                        if(tabPlacement == BOTTOM) {</span>
<span class="nc" id="L2491">                            tabContainerY = bounds.height - tabContainerHeight;</span>
<span class="nc bnc" id="L2492" title="All 2 branches missed.">                        } else if(tabPlacement == RIGHT) {</span>
<span class="nc" id="L2493">                            tabContainerX = bounds.width - tabContainerWidth;</span>
                        }
<span class="nc" id="L2495">                        child.setBounds(tabContainerX, tabContainerY, tabContainerWidth, tabContainerHeight);</span>
<span class="nc" id="L2496">                    } else {</span>
<span class="nc" id="L2497">                        child.setBounds(cx, cy, cw, ch);</span>
                    }
                }
            }
<span class="nc" id="L2501">            layoutTabComponents();</span>
<span class="nc bnc" id="L2502" title="All 2 branches missed.">            if(shouldChangeFocus) {</span>
<span class="nc bnc" id="L2503" title="All 2 branches missed.">                if(!requestFocusForVisibleComponent()) {</span>
<span class="nc" id="L2504">                    tabPane.requestFocus();</span>
                }
            }
<span class="nc" id="L2507">        }</span>

        public void calculateLayoutInfo() {
<span class="nc" id="L2510">            int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L2511">            assureRectsCreated(tabCount);</span>
<span class="nc" id="L2512">            calculateTabRects(tabPane.getTabPlacement(), tabCount);</span>
<span class="nc" id="L2513">            isRunsDirty = false;</span>
<span class="nc" id="L2514">        }</span>

        private void layoutTabComponents() {
<span class="nc bnc" id="L2517" title="All 2 branches missed.">            if (tabContainer == null) {</span>
<span class="nc" id="L2518">                return;</span>
            }
<span class="nc" id="L2520">            Rectangle rect = new Rectangle();</span>
<span class="nc" id="L2521">            Point delta = new Point(-tabContainer.getX(), -tabContainer.getY());</span>
<span class="nc bnc" id="L2522" title="All 2 branches missed.">            if (scrollableTabLayoutEnabled()) {</span>
<span class="nc" id="L2523">                translatePointToTabPanel(0, 0, delta);</span>
            }
<span class="nc bnc" id="L2525" title="All 2 branches missed.">            for (int i = 0; i &lt; tabPane.getTabCount(); i++) {</span>
<span class="nc" id="L2526">                Component c = tabPane.getTabComponentAt(i);</span>
<span class="nc bnc" id="L2527" title="All 2 branches missed.">                if (c == null) {</span>
<span class="nc" id="L2528">                    continue;</span>
                }
<span class="nc" id="L2530">                getTabBounds(i, rect);</span>
<span class="nc" id="L2531">                Dimension preferredSize = c.getPreferredSize();</span>
<span class="nc" id="L2532">                Insets insets = getTabInsets(tabPane.getTabPlacement(), i);</span>
<span class="nc" id="L2533">                int outerX = rect.x + insets.left + delta.x;</span>
<span class="nc" id="L2534">                int outerY = rect.y + insets.top + delta.y;</span>
<span class="nc" id="L2535">                int outerWidth = rect.width - insets.left - insets.right;</span>
<span class="nc" id="L2536">                int outerHeight = rect.height - insets.top - insets.bottom;</span>
                //centralize component
<span class="nc" id="L2538">                int x = outerX + (outerWidth - preferredSize.width) / 2;</span>
<span class="nc" id="L2539">                int y = outerY + (outerHeight - preferredSize.height) / 2;</span>
<span class="nc" id="L2540">                int tabPlacement = tabPane.getTabPlacement();</span>
<span class="nc bnc" id="L2541" title="All 2 branches missed.">                boolean isSeleceted = i == tabPane.getSelectedIndex();</span>
<span class="nc" id="L2542">                c.setBounds(x + getTabLabelShiftX(tabPlacement, i, isSeleceted),</span>
<span class="nc" id="L2543">                            y + getTabLabelShiftY(tabPlacement, i, isSeleceted),</span>
                        preferredSize.width, preferredSize.height);
            }
<span class="nc" id="L2546">        }</span>

        protected void calculateTabRects(int tabPlacement, int tabCount) {
<span class="nc" id="L2549">            FontMetrics metrics = getFontMetrics();</span>
<span class="nc" id="L2550">            Dimension size = tabPane.getSize();</span>
<span class="nc" id="L2551">            Insets insets = tabPane.getInsets();</span>
<span class="nc" id="L2552">            Insets tabAreaInsets = getTabAreaInsets(tabPlacement);</span>
<span class="nc" id="L2553">            int fontHeight = metrics.getHeight();</span>
<span class="nc" id="L2554">            int selectedIndex = tabPane.getSelectedIndex();</span>
            int tabRunOverlay;
            int i, j;
            int x, y;
            int returnAt;
<span class="nc bnc" id="L2559" title="All 4 branches missed.">            boolean verticalTabRuns = (tabPlacement == LEFT || tabPlacement == RIGHT);</span>
<span class="nc" id="L2560">            boolean leftToRight = BasicGraphicsUtils.isLeftToRight(tabPane);</span>

            //
            // Calculate bounds within which a tab run must fit
            //
<span class="nc bnc" id="L2565" title="All 4 branches missed.">            switch(tabPlacement) {</span>
              case LEFT:
<span class="nc" id="L2567">                  maxTabWidth = calculateMaxTabWidth(tabPlacement);</span>
<span class="nc" id="L2568">                  x = insets.left + tabAreaInsets.left;</span>
<span class="nc" id="L2569">                  y = insets.top + tabAreaInsets.top;</span>
<span class="nc" id="L2570">                  returnAt = size.height - (insets.bottom + tabAreaInsets.bottom);</span>
<span class="nc" id="L2571">                  break;</span>
              case RIGHT:
<span class="nc" id="L2573">                  maxTabWidth = calculateMaxTabWidth(tabPlacement);</span>
<span class="nc" id="L2574">                  x = size.width - insets.right - tabAreaInsets.right - maxTabWidth;</span>
<span class="nc" id="L2575">                  y = insets.top + tabAreaInsets.top;</span>
<span class="nc" id="L2576">                  returnAt = size.height - (insets.bottom + tabAreaInsets.bottom);</span>
<span class="nc" id="L2577">                  break;</span>
              case BOTTOM:
<span class="nc" id="L2579">                  maxTabHeight = calculateMaxTabHeight(tabPlacement);</span>
<span class="nc" id="L2580">                  x = insets.left + tabAreaInsets.left;</span>
<span class="nc" id="L2581">                  y = size.height - insets.bottom - tabAreaInsets.bottom - maxTabHeight;</span>
<span class="nc" id="L2582">                  returnAt = size.width - (insets.right + tabAreaInsets.right);</span>
<span class="nc" id="L2583">                  break;</span>
              case TOP:
              default:
<span class="nc" id="L2586">                  maxTabHeight = calculateMaxTabHeight(tabPlacement);</span>
<span class="nc" id="L2587">                  x = insets.left + tabAreaInsets.left;</span>
<span class="nc" id="L2588">                  y = insets.top + tabAreaInsets.top;</span>
<span class="nc" id="L2589">                  returnAt = size.width - (insets.right + tabAreaInsets.right);</span>
                  break;
            }

<span class="nc" id="L2593">            tabRunOverlay = getTabRunOverlay(tabPlacement);</span>

<span class="nc" id="L2595">            runCount = 0;</span>
<span class="nc" id="L2596">            selectedRun = -1;</span>

<span class="nc bnc" id="L2598" title="All 2 branches missed.">            if (tabCount == 0) {</span>
<span class="nc" id="L2599">                return;</span>
            }

            // Run through tabs and partition them into runs
            Rectangle rect;
<span class="nc bnc" id="L2604" title="All 2 branches missed.">            for (i = 0; i &lt; tabCount; i++) {</span>
<span class="nc" id="L2605">                rect = rects[i];</span>

<span class="nc bnc" id="L2607" title="All 2 branches missed.">                if (!verticalTabRuns) {</span>
                    // Tabs on TOP or BOTTOM....
<span class="nc bnc" id="L2609" title="All 2 branches missed.">                    if (i &gt; 0) {</span>
<span class="nc" id="L2610">                        rect.x = rects[i-1].x + rects[i-1].width;</span>
                    } else {
<span class="nc" id="L2612">                        tabRuns[0] = 0;</span>
<span class="nc" id="L2613">                        runCount = 1;</span>
<span class="nc" id="L2614">                        maxTabWidth = 0;</span>
<span class="nc" id="L2615">                        rect.x = x;</span>
                    }
<span class="nc" id="L2617">                    rect.width = calculateTabWidth(tabPlacement, i, metrics);</span>
<span class="nc" id="L2618">                    maxTabWidth = Math.max(maxTabWidth, rect.width);</span>

                    // Never move a TAB down a run if it is in the first column.
                    // Even if there isn't enough room, moving it to a fresh
                    // line won't help.
<span class="nc bnc" id="L2623" title="All 4 branches missed.">                    if (rect.x != x &amp;&amp; rect.x + rect.width &gt; returnAt) {</span>
<span class="nc bnc" id="L2624" title="All 2 branches missed.">                        if (runCount &gt; tabRuns.length - 1) {</span>
<span class="nc" id="L2625">                            expandTabRunsArray();</span>
                        }
<span class="nc" id="L2627">                        tabRuns[runCount] = i;</span>
<span class="nc" id="L2628">                        runCount++;</span>
<span class="nc" id="L2629">                        rect.x = x;</span>
                    }
                    // Initialize y position in case there's just one run
<span class="nc" id="L2632">                    rect.y = y;</span>
<span class="nc" id="L2633">                    rect.height = maxTabHeight/* - 2*/;</span>

                } else {
                    // Tabs on LEFT or RIGHT...
<span class="nc bnc" id="L2637" title="All 2 branches missed.">                    if (i &gt; 0) {</span>
<span class="nc" id="L2638">                        rect.y = rects[i-1].y + rects[i-1].height;</span>
                    } else {
<span class="nc" id="L2640">                        tabRuns[0] = 0;</span>
<span class="nc" id="L2641">                        runCount = 1;</span>
<span class="nc" id="L2642">                        maxTabHeight = 0;</span>
<span class="nc" id="L2643">                        rect.y = y;</span>
                    }
<span class="nc" id="L2645">                    rect.height = calculateTabHeight(tabPlacement, i, fontHeight);</span>
<span class="nc" id="L2646">                    maxTabHeight = Math.max(maxTabHeight, rect.height);</span>

                    // Never move a TAB over a run if it is in the first run.
                    // Even if there isn't enough room, moving it to a fresh
                    // column won't help.
<span class="nc bnc" id="L2651" title="All 4 branches missed.">                    if (rect.y != y &amp;&amp; rect.y + rect.height &gt; returnAt) {</span>
<span class="nc bnc" id="L2652" title="All 2 branches missed.">                        if (runCount &gt; tabRuns.length - 1) {</span>
<span class="nc" id="L2653">                            expandTabRunsArray();</span>
                        }
<span class="nc" id="L2655">                        tabRuns[runCount] = i;</span>
<span class="nc" id="L2656">                        runCount++;</span>
<span class="nc" id="L2657">                        rect.y = y;</span>
                    }
                    // Initialize x position in case there's just one column
<span class="nc" id="L2660">                    rect.x = x;</span>
<span class="nc" id="L2661">                    rect.width = maxTabWidth/* - 2*/;</span>

                }
<span class="nc bnc" id="L2664" title="All 2 branches missed.">                if (i == selectedIndex) {</span>
<span class="nc" id="L2665">                    selectedRun = runCount - 1;</span>
                }
            }

<span class="nc bnc" id="L2669" title="All 2 branches missed.">            if (runCount &gt; 1) {</span>
                // Re-distribute tabs in case last run has leftover space
<span class="nc bnc" id="L2671" title="All 2 branches missed.">                normalizeTabRuns(tabPlacement, tabCount, verticalTabRuns? y : x, returnAt);</span>

<span class="nc" id="L2673">                selectedRun = getRunForTab(tabCount, selectedIndex);</span>

                // Rotate run array so that selected run is first
<span class="nc bnc" id="L2676" title="All 2 branches missed.">                if (shouldRotateTabRuns(tabPlacement)) {</span>
<span class="nc" id="L2677">                    rotateTabRuns(tabPlacement, selectedRun);</span>
                }
            }

            // Step through runs from back to front to calculate
            // tab y locations and to pad runs appropriately
<span class="nc bnc" id="L2683" title="All 2 branches missed.">            for (i = runCount - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L2684">                int start = tabRuns[i];</span>
<span class="nc bnc" id="L2685" title="All 2 branches missed.">                int next = tabRuns[i == (runCount - 1)? 0 : i + 1];</span>
<span class="nc bnc" id="L2686" title="All 2 branches missed.">                int end = (next != 0? next - 1 : tabCount - 1);</span>
<span class="nc bnc" id="L2687" title="All 2 branches missed.">                if (!verticalTabRuns) {</span>
<span class="nc bnc" id="L2688" title="All 2 branches missed.">                    for (j = start; j &lt;= end; j++) {</span>
<span class="nc" id="L2689">                        rect = rects[j];</span>
<span class="nc" id="L2690">                        rect.y = y;</span>
<span class="nc" id="L2691">                        rect.x += getTabRunIndent(tabPlacement, i);</span>
                    }
<span class="nc bnc" id="L2693" title="All 2 branches missed.">                    if (shouldPadTabRun(tabPlacement, i)) {</span>
<span class="nc" id="L2694">                        padTabRun(tabPlacement, start, end, returnAt);</span>
                    }
<span class="nc bnc" id="L2696" title="All 2 branches missed.">                    if (tabPlacement == BOTTOM) {</span>
<span class="nc" id="L2697">                        y -= (maxTabHeight - tabRunOverlay);</span>
                    } else {
<span class="nc" id="L2699">                        y += (maxTabHeight - tabRunOverlay);</span>
                    }
                } else {
<span class="nc bnc" id="L2702" title="All 2 branches missed.">                    for (j = start; j &lt;= end; j++) {</span>
<span class="nc" id="L2703">                        rect = rects[j];</span>
<span class="nc" id="L2704">                        rect.x = x;</span>
<span class="nc" id="L2705">                        rect.y += getTabRunIndent(tabPlacement, i);</span>
                    }
<span class="nc bnc" id="L2707" title="All 2 branches missed.">                    if (shouldPadTabRun(tabPlacement, i)) {</span>
<span class="nc" id="L2708">                        padTabRun(tabPlacement, start, end, returnAt);</span>
                    }
<span class="nc bnc" id="L2710" title="All 2 branches missed.">                    if (tabPlacement == RIGHT) {</span>
<span class="nc" id="L2711">                        x -= (maxTabWidth - tabRunOverlay);</span>
                    } else {
<span class="nc" id="L2713">                        x += (maxTabWidth - tabRunOverlay);</span>
                    }
                }
            }

            // Pad the selected tab so that it appears raised in front
<span class="nc" id="L2719">            padSelectedTab(tabPlacement, selectedIndex);</span>

            // if right to left and tab placement on the top or
            // the bottom, flip x positions and adjust by widths
<span class="nc bnc" id="L2723" title="All 4 branches missed.">            if (!leftToRight &amp;&amp; !verticalTabRuns) {</span>
<span class="nc" id="L2724">                int rightMargin = size.width</span>
                                  - (insets.right + tabAreaInsets.right);
<span class="nc bnc" id="L2726" title="All 2 branches missed.">                for (i = 0; i &lt; tabCount; i++) {</span>
<span class="nc" id="L2727">                    rects[i].x = rightMargin - rects[i].x - rects[i].width;</span>
                }
            }
<span class="nc" id="L2730">        }</span>


       /*
       * Rotates the run-index array so that the selected run is run[0]
       */
        protected void rotateTabRuns(int tabPlacement, int selectedRun) {
<span class="nc bnc" id="L2737" title="All 2 branches missed.">            for (int i = 0; i &lt; selectedRun; i++) {</span>
<span class="nc" id="L2738">                int save = tabRuns[0];</span>
<span class="nc bnc" id="L2739" title="All 2 branches missed.">                for (int j = 1; j &lt; runCount; j++) {</span>
<span class="nc" id="L2740">                    tabRuns[j - 1] = tabRuns[j];</span>
                }
<span class="nc" id="L2742">                tabRuns[runCount-1] = save;</span>
            }
<span class="nc" id="L2744">        }</span>

        protected void normalizeTabRuns(int tabPlacement, int tabCount,
                                     int start, int max) {
<span class="nc bnc" id="L2748" title="All 4 branches missed.">            boolean verticalTabRuns = (tabPlacement == LEFT || tabPlacement == RIGHT);</span>
<span class="nc" id="L2749">            int run = runCount - 1;</span>
<span class="nc" id="L2750">            boolean keepAdjusting = true;</span>
<span class="nc" id="L2751">            double weight = 1.25;</span>

            // At this point the tab runs are packed to fit as many
            // tabs as possible, which can leave the last run with a lot
            // of extra space (resulting in very fat tabs on the last run).
            // So we'll attempt to distribute this extra space more evenly
            // across the runs in order to make the runs look more consistent.
            //
            // Starting with the last run, determine whether the last tab in
            // the previous run would fit (generously) in this run; if so,
            // move tab to current run and shift tabs accordingly.  Cycle
            // through remaining runs using the same algorithm.
            //
<span class="nc bnc" id="L2764" title="All 2 branches missed.">            while (keepAdjusting) {</span>
<span class="nc" id="L2765">                int last = lastTabInRun(tabCount, run);</span>
<span class="nc" id="L2766">                int prevLast = lastTabInRun(tabCount, run-1);</span>
                int end;
                int prevLastLen;

<span class="nc bnc" id="L2770" title="All 2 branches missed.">                if (!verticalTabRuns) {</span>
<span class="nc" id="L2771">                    end = rects[last].x + rects[last].width;</span>
<span class="nc" id="L2772">                    prevLastLen = (int)(maxTabWidth*weight);</span>
                } else {
<span class="nc" id="L2774">                    end = rects[last].y + rects[last].height;</span>
<span class="nc" id="L2775">                    prevLastLen = (int)(maxTabHeight*weight*2);</span>
                }

                // Check if the run has enough extra space to fit the last tab
                // from the previous row...
<span class="nc bnc" id="L2780" title="All 2 branches missed.">                if (max - end &gt; prevLastLen) {</span>

                    // Insert tab from previous row and shift rest over
<span class="nc" id="L2783">                    tabRuns[run] = prevLast;</span>
<span class="nc bnc" id="L2784" title="All 2 branches missed.">                    if (!verticalTabRuns) {</span>
<span class="nc" id="L2785">                        rects[prevLast].x = start;</span>
                    } else {
<span class="nc" id="L2787">                        rects[prevLast].y = start;</span>
                    }
<span class="nc bnc" id="L2789" title="All 2 branches missed.">                    for (int i = prevLast+1; i &lt;= last; i++) {</span>
<span class="nc bnc" id="L2790" title="All 2 branches missed.">                        if (!verticalTabRuns) {</span>
<span class="nc" id="L2791">                            rects[i].x = rects[i-1].x + rects[i-1].width;</span>
                        } else {
<span class="nc" id="L2793">                            rects[i].y = rects[i-1].y + rects[i-1].height;</span>
                        }
                    }

<span class="nc bnc" id="L2797" title="All 2 branches missed.">                } else if (run == runCount - 1) {</span>
                    // no more room left in last run, so we're done!
<span class="nc" id="L2799">                    keepAdjusting = false;</span>
                }
<span class="nc bnc" id="L2801" title="All 2 branches missed.">                if (run - 1 &gt; 0) {</span>
                    // check previous run next...
<span class="nc" id="L2803">                    run -= 1;</span>
                } else {
                    // check last run again...but require a higher ratio
                    // of extraspace-to-tabsize because we don't want to
                    // end up with too many tabs on the last run!
<span class="nc" id="L2808">                    run = runCount - 1;</span>
<span class="nc" id="L2809">                    weight += .25;</span>
                }
<span class="nc" id="L2811">            }</span>
<span class="nc" id="L2812">        }</span>

        protected void padTabRun(int tabPlacement, int start, int end, int max) {
<span class="nc" id="L2815">            Rectangle lastRect = rects[end];</span>
<span class="nc bnc" id="L2816" title="All 4 branches missed.">            if (tabPlacement == TOP || tabPlacement == BOTTOM) {</span>
<span class="nc" id="L2817">                int runWidth = (lastRect.x + lastRect.width) - rects[start].x;</span>
<span class="nc" id="L2818">                int deltaWidth = max - (lastRect.x + lastRect.width);</span>
<span class="nc" id="L2819">                float factor = (float)deltaWidth / (float)runWidth;</span>

<span class="nc bnc" id="L2821" title="All 2 branches missed.">                for (int j = start; j &lt;= end; j++) {</span>
<span class="nc" id="L2822">                    Rectangle pastRect = rects[j];</span>
<span class="nc bnc" id="L2823" title="All 2 branches missed.">                    if (j &gt; start) {</span>
<span class="nc" id="L2824">                        pastRect.x = rects[j-1].x + rects[j-1].width;</span>
                    }
<span class="nc" id="L2826">                    pastRect.width += Math.round((float)pastRect.width * factor);</span>
                }
<span class="nc" id="L2828">                lastRect.width = max - lastRect.x;</span>
<span class="nc" id="L2829">            } else {</span>
<span class="nc" id="L2830">                int runHeight = (lastRect.y + lastRect.height) - rects[start].y;</span>
<span class="nc" id="L2831">                int deltaHeight = max - (lastRect.y + lastRect.height);</span>
<span class="nc" id="L2832">                float factor = (float)deltaHeight / (float)runHeight;</span>

<span class="nc bnc" id="L2834" title="All 2 branches missed.">                for (int j = start; j &lt;= end; j++) {</span>
<span class="nc" id="L2835">                    Rectangle pastRect = rects[j];</span>
<span class="nc bnc" id="L2836" title="All 2 branches missed.">                    if (j &gt; start) {</span>
<span class="nc" id="L2837">                        pastRect.y = rects[j-1].y + rects[j-1].height;</span>
                    }
<span class="nc" id="L2839">                    pastRect.height += Math.round((float)pastRect.height * factor);</span>
                }
<span class="nc" id="L2841">                lastRect.height = max - lastRect.y;</span>
            }
<span class="nc" id="L2843">        }</span>

        protected void padSelectedTab(int tabPlacement, int selectedIndex) {

<span class="nc bnc" id="L2847" title="All 2 branches missed.">            if (selectedIndex &gt;= 0) {</span>
<span class="nc" id="L2848">                Rectangle selRect = rects[selectedIndex];</span>
<span class="nc" id="L2849">                Insets padInsets = getSelectedTabPadInsets(tabPlacement);</span>
<span class="nc" id="L2850">                selRect.x -= padInsets.left;</span>
<span class="nc" id="L2851">                selRect.width += (padInsets.left + padInsets.right);</span>
<span class="nc" id="L2852">                selRect.y -= padInsets.top;</span>
<span class="nc" id="L2853">                selRect.height += (padInsets.top + padInsets.bottom);</span>

<span class="nc bnc" id="L2855" title="All 2 branches missed.">                if (!scrollableTabLayoutEnabled()) { // WRAP_TAB_LAYOUT</span>
                    // do not expand selected tab more then necessary
<span class="nc" id="L2857">                    Dimension size = tabPane.getSize();</span>
<span class="nc" id="L2858">                    Insets insets = tabPane.getInsets();</span>

<span class="nc bnc" id="L2860" title="All 4 branches missed.">                    if ((tabPlacement == LEFT) || (tabPlacement == RIGHT)) {</span>
<span class="nc" id="L2861">                        int top = insets.top - selRect.y;</span>
<span class="nc bnc" id="L2862" title="All 2 branches missed.">                        if (top &gt; 0) {</span>
<span class="nc" id="L2863">                            selRect.y += top;</span>
<span class="nc" id="L2864">                            selRect.height -= top;</span>
                        }
<span class="nc" id="L2866">                        int bottom = (selRect.y + selRect.height) + insets.bottom - size.height;</span>
<span class="nc bnc" id="L2867" title="All 2 branches missed.">                        if (bottom &gt; 0) {</span>
<span class="nc" id="L2868">                            selRect.height -= bottom;</span>
                        }
<span class="nc" id="L2870">                    } else {</span>
<span class="nc" id="L2871">                        int left = insets.left - selRect.x;</span>
<span class="nc bnc" id="L2872" title="All 2 branches missed.">                        if (left &gt; 0) {</span>
<span class="nc" id="L2873">                            selRect.x += left;</span>
<span class="nc" id="L2874">                            selRect.width -= left;</span>
                        }
<span class="nc" id="L2876">                        int right = (selRect.x + selRect.width) + insets.right - size.width;</span>
<span class="nc bnc" id="L2877" title="All 2 branches missed.">                        if (right &gt; 0) {</span>
<span class="nc" id="L2878">                            selRect.width -= right;</span>
                        }
                    }
                }
            }
<span class="nc" id="L2883">        }</span>
    }

<span class="nc" id="L2886">    private class TabbedPaneScrollLayout extends TabbedPaneLayout {</span>

        protected int preferredTabAreaHeight(int tabPlacement, int width) {
<span class="nc" id="L2889">            return calculateMaxTabHeight(tabPlacement);</span>
        }

        protected int preferredTabAreaWidth(int tabPlacement, int height) {
<span class="nc" id="L2893">            return calculateMaxTabWidth(tabPlacement);</span>
        }

        public void layoutContainer(Container parent) {
            /* Some of the code in this method deals with changing the
             * visibility of components to hide and show the contents for the
             * selected tab. This is older code that has since been duplicated
             * in JTabbedPane.fireStateChanged(), so as to allow visibility
             * changes to happen sooner (see the note there). This code remains
             * for backward compatibility as there are some cases, such as
             * subclasses that don't fireStateChanged() where it may be used.
             * Any changes here need to be kept in synch with
             * JTabbedPane.fireStateChanged().
             */

<span class="nc" id="L2908">            setRolloverTab(-1);</span>

<span class="nc" id="L2910">            int tabPlacement = tabPane.getTabPlacement();</span>
<span class="nc" id="L2911">            int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L2912">            Insets insets = tabPane.getInsets();</span>
<span class="nc" id="L2913">            int selectedIndex = tabPane.getSelectedIndex();</span>
<span class="nc" id="L2914">            Component visibleComponent = getVisibleComponent();</span>

<span class="nc" id="L2916">            calculateLayoutInfo();</span>

<span class="nc" id="L2918">            Component selectedComponent = null;</span>
<span class="nc bnc" id="L2919" title="All 2 branches missed.">            if (selectedIndex &lt; 0) {</span>
<span class="nc bnc" id="L2920" title="All 2 branches missed.">                if (visibleComponent != null) {</span>
                    // The last tab was removed, so remove the component
<span class="nc" id="L2922">                    setVisibleComponent(null);</span>
                }
            } else {
<span class="nc" id="L2925">                selectedComponent = tabPane.getComponentAt(selectedIndex);</span>
            }

<span class="nc bnc" id="L2928" title="All 2 branches missed.">            if (tabPane.getTabCount() == 0) {</span>
<span class="nc" id="L2929">                tabScroller.croppedEdge.resetParams();</span>
<span class="nc" id="L2930">                tabScroller.scrollForwardButton.setVisible(false);</span>
<span class="nc" id="L2931">                tabScroller.scrollBackwardButton.setVisible(false);</span>
<span class="nc" id="L2932">                return;</span>
            }

<span class="nc" id="L2935">            boolean shouldChangeFocus = false;</span>

            // In order to allow programs to use a single component
            // as the display for multiple tabs, we will not change
            // the visible compnent if the currently selected tab
            // has a null component.  This is a bit dicey, as we don't
            // explicitly state we support this in the spec, but since
            // programs are now depending on this, we're making it work.
            //
<span class="nc bnc" id="L2944" title="All 2 branches missed.">            if(selectedComponent != null) {</span>
<span class="nc bnc" id="L2945" title="All 4 branches missed.">                if(selectedComponent != visibleComponent &amp;&amp;</span>
                        visibleComponent != null) {
<span class="nc bnc" id="L2947" title="All 2 branches missed.">                    if(SwingUtilities.findFocusOwner(visibleComponent) != null) {</span>
<span class="nc" id="L2948">                        shouldChangeFocus = true;</span>
                    }
                }
<span class="nc" id="L2951">                setVisibleComponent(selectedComponent);</span>
            }
            int tx, ty, tw, th; // tab area bounds
            int cx, cy, cw, ch; // content area bounds
<span class="nc" id="L2955">            Insets contentInsets = getContentBorderInsets(tabPlacement);</span>
<span class="nc" id="L2956">            Rectangle bounds = tabPane.getBounds();</span>
<span class="nc" id="L2957">            int numChildren = tabPane.getComponentCount();</span>

<span class="nc bnc" id="L2959" title="All 2 branches missed.">            if(numChildren &gt; 0) {</span>
<span class="nc bnc" id="L2960" title="All 4 branches missed.">                switch(tabPlacement) {</span>
                    case LEFT:
                        // calculate tab area bounds
<span class="nc" id="L2963">                        tw = calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth);</span>
<span class="nc" id="L2964">                        th = bounds.height - insets.top - insets.bottom;</span>
<span class="nc" id="L2965">                        tx = insets.left;</span>
<span class="nc" id="L2966">                        ty = insets.top;</span>

                        // calculate content area bounds
<span class="nc" id="L2969">                        cx = tx + tw + contentInsets.left;</span>
<span class="nc" id="L2970">                        cy = ty + contentInsets.top;</span>
<span class="nc" id="L2971">                        cw = bounds.width - insets.left - insets.right - tw -</span>
                                contentInsets.left - contentInsets.right;
<span class="nc" id="L2973">                        ch = bounds.height - insets.top - insets.bottom -</span>
                                contentInsets.top - contentInsets.bottom;
<span class="nc" id="L2975">                        break;</span>
                    case RIGHT:
                        // calculate tab area bounds
<span class="nc" id="L2978">                        tw = calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth);</span>
<span class="nc" id="L2979">                        th = bounds.height - insets.top - insets.bottom;</span>
<span class="nc" id="L2980">                        tx = bounds.width - insets.right - tw;</span>
<span class="nc" id="L2981">                        ty = insets.top;</span>

                        // calculate content area bounds
<span class="nc" id="L2984">                        cx = insets.left + contentInsets.left;</span>
<span class="nc" id="L2985">                        cy = insets.top + contentInsets.top;</span>
<span class="nc" id="L2986">                        cw = bounds.width - insets.left - insets.right - tw -</span>
                                contentInsets.left - contentInsets.right;
<span class="nc" id="L2988">                        ch = bounds.height - insets.top - insets.bottom -</span>
                                contentInsets.top - contentInsets.bottom;
<span class="nc" id="L2990">                        break;</span>
                    case BOTTOM:
                        // calculate tab area bounds
<span class="nc" id="L2993">                        tw = bounds.width - insets.left - insets.right;</span>
<span class="nc" id="L2994">                        th = calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight);</span>
<span class="nc" id="L2995">                        tx = insets.left;</span>
<span class="nc" id="L2996">                        ty = bounds.height - insets.bottom - th;</span>

                        // calculate content area bounds
<span class="nc" id="L2999">                        cx = insets.left + contentInsets.left;</span>
<span class="nc" id="L3000">                        cy = insets.top + contentInsets.top;</span>
<span class="nc" id="L3001">                        cw = bounds.width - insets.left - insets.right -</span>
                                contentInsets.left - contentInsets.right;
<span class="nc" id="L3003">                        ch = bounds.height - insets.top - insets.bottom - th -</span>
                                contentInsets.top - contentInsets.bottom;
<span class="nc" id="L3005">                        break;</span>
                    case TOP:
                    default:
                        // calculate tab area bounds
<span class="nc" id="L3009">                        tw = bounds.width - insets.left - insets.right;</span>
<span class="nc" id="L3010">                        th = calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight);</span>
<span class="nc" id="L3011">                        tx = insets.left;</span>
<span class="nc" id="L3012">                        ty = insets.top;</span>

                        // calculate content area bounds
<span class="nc" id="L3015">                        cx = tx + contentInsets.left;</span>
<span class="nc" id="L3016">                        cy = ty + th + contentInsets.top;</span>
<span class="nc" id="L3017">                        cw = bounds.width - insets.left - insets.right -</span>
                                contentInsets.left - contentInsets.right;
<span class="nc" id="L3019">                        ch = bounds.height - insets.top - insets.bottom - th -</span>
                                contentInsets.top - contentInsets.bottom;
                }

<span class="nc bnc" id="L3023" title="All 2 branches missed.">                for(int i = 0; i &lt; numChildren; i++) {</span>
<span class="nc" id="L3024">                    Component child = tabPane.getComponent(i);</span>

<span class="nc bnc" id="L3026" title="All 4 branches missed.">                    if(tabScroller != null &amp;&amp; child == tabScroller.viewport) {</span>
<span class="nc" id="L3027">                        JViewport viewport = (JViewport) child;</span>
<span class="nc" id="L3028">                        Rectangle viewRect = viewport.getViewRect();</span>
<span class="nc" id="L3029">                        int vw = tw;</span>
<span class="nc" id="L3030">                        int vh = th;</span>
<span class="nc" id="L3031">                        Dimension butSize = tabScroller.scrollForwardButton.getPreferredSize();</span>
<span class="nc bnc" id="L3032" title="All 2 branches missed.">                        switch(tabPlacement) {</span>
                            case LEFT:
                            case RIGHT:
<span class="nc" id="L3035">                                int totalTabHeight = rects[tabCount - 1].y + rects[tabCount - 1].height;</span>
<span class="nc bnc" id="L3036" title="All 2 branches missed.">                                if(totalTabHeight &gt; th) {</span>
                                    // Allow space for scrollbuttons
<span class="nc bnc" id="L3038" title="All 2 branches missed.">                                    vh = (th &gt; 2 * butSize.height) ? th - 2 * butSize.height : 0;</span>
<span class="nc bnc" id="L3039" title="All 2 branches missed.">                                    if(totalTabHeight - viewRect.y &lt;= vh) {</span>
                                        // Scrolled to the end, so ensure the viewport size is
                                        // such that the scroll offset aligns with a tab
<span class="nc" id="L3042">                                        vh = totalTabHeight - viewRect.y;</span>
                                    }
                                }
                                break;
                            case BOTTOM:
                            case TOP:
                            default:
<span class="nc" id="L3049">                                int totalTabWidth = rects[tabCount - 1].x + rects[tabCount - 1].width;</span>
<span class="nc bnc" id="L3050" title="All 2 branches missed.">                                if(totalTabWidth &gt; tw) {</span>
                                    // Need to allow space for scrollbuttons
<span class="nc bnc" id="L3052" title="All 2 branches missed.">                                    vw = (tw &gt; 2 * butSize.width) ? tw - 2 * butSize.width : 0;</span>
<span class="nc bnc" id="L3053" title="All 2 branches missed.">                                    if(totalTabWidth - viewRect.x &lt;= vw) {</span>
                                        // Scrolled to the end, so ensure the viewport size is
                                        // such that the scroll offset aligns with a tab
<span class="nc" id="L3056">                                        vw = totalTabWidth - viewRect.x;</span>
                                    }
                                }
                        }
<span class="nc" id="L3060">                        child.setBounds(tx, ty, vw, vh);</span>

<span class="nc bnc" id="L3062" title="All 2 branches missed.">                    } else if(tabScroller != null &amp;&amp;</span>
<span class="nc bnc" id="L3063" title="All 2 branches missed.">                            (child == tabScroller.scrollForwardButton ||</span>
<span class="nc bnc" id="L3064" title="All 2 branches missed.">                            child == tabScroller.scrollBackwardButton)) {</span>
<span class="nc" id="L3065">                        Component scrollbutton = child;</span>
<span class="nc" id="L3066">                        Dimension bsize = scrollbutton.getPreferredSize();</span>
<span class="nc" id="L3067">                        int bx = 0;</span>
<span class="nc" id="L3068">                        int by = 0;</span>
<span class="nc" id="L3069">                        int bw = bsize.width;</span>
<span class="nc" id="L3070">                        int bh = bsize.height;</span>
<span class="nc" id="L3071">                        boolean visible = false;</span>

<span class="nc bnc" id="L3073" title="All 2 branches missed.">                        switch(tabPlacement) {</span>
                            case LEFT:
                            case RIGHT:
<span class="nc" id="L3076">                                int totalTabHeight = rects[tabCount - 1].y + rects[tabCount - 1].height;</span>
<span class="nc bnc" id="L3077" title="All 2 branches missed.">                                if(totalTabHeight &gt; th) {</span>
<span class="nc" id="L3078">                                    visible = true;</span>
<span class="nc bnc" id="L3079" title="All 2 branches missed.">                                    bx = (tabPlacement == LEFT ? tx + tw - bsize.width : tx);</span>
<span class="nc bnc" id="L3080" title="All 2 branches missed.">                                    by = (child == tabScroller.scrollForwardButton) ?</span>
                                            bounds.height - insets.bottom - bsize.height :
                                            bounds.height - insets.bottom - 2 * bsize.height;
                                }
                                break;

                            case BOTTOM:
                            case TOP:
                            default:
<span class="nc" id="L3089">                                int totalTabWidth = rects[tabCount - 1].x + rects[tabCount - 1].width;</span>

<span class="nc bnc" id="L3091" title="All 2 branches missed.">                                if(totalTabWidth &gt; tw) {</span>
<span class="nc" id="L3092">                                    visible = true;</span>
<span class="nc bnc" id="L3093" title="All 2 branches missed.">                                    bx = (child == tabScroller.scrollForwardButton) ?</span>
                                            bounds.width - insets.left - bsize.width :
                                            bounds.width - insets.left - 2 * bsize.width;
<span class="nc bnc" id="L3096" title="All 2 branches missed.">                                    by = (tabPlacement == TOP ? ty + th - bsize.height : ty);</span>
                                }
                        }
<span class="nc" id="L3099">                        child.setVisible(visible);</span>
<span class="nc bnc" id="L3100" title="All 2 branches missed.">                        if(visible) {</span>
<span class="nc" id="L3101">                            child.setBounds(bx, by, bw, bh);</span>
                        }

<span class="nc" id="L3104">                    } else {</span>
                        // All content children...
<span class="nc" id="L3106">                        child.setBounds(cx, cy, cw, ch);</span>
                    }
                }
<span class="nc" id="L3109">                super.layoutTabComponents();</span>
<span class="nc" id="L3110">                layoutCroppedEdge();</span>
<span class="nc bnc" id="L3111" title="All 2 branches missed.">                if(shouldChangeFocus) {</span>
<span class="nc bnc" id="L3112" title="All 2 branches missed.">                    if(!requestFocusForVisibleComponent()) {</span>
<span class="nc" id="L3113">                        tabPane.requestFocus();</span>
                    }
                }
            }
<span class="nc" id="L3117">        }</span>

        private void layoutCroppedEdge() {
<span class="nc" id="L3120">            tabScroller.croppedEdge.resetParams();</span>
<span class="nc" id="L3121">            Rectangle viewRect = tabScroller.viewport.getViewRect();</span>
            int cropline;
<span class="nc bnc" id="L3123" title="All 2 branches missed.">            for (int i = 0; i &lt; rects.length; i++) {</span>
<span class="nc" id="L3124">                Rectangle tabRect = rects[i];</span>
<span class="nc bnc" id="L3125" title="All 2 branches missed.">                switch (tabPane.getTabPlacement()) {</span>
                    case LEFT:
                    case RIGHT:
<span class="nc" id="L3128">                        cropline = viewRect.y + viewRect.height;</span>
<span class="nc bnc" id="L3129" title="All 4 branches missed.">                        if ((tabRect.y &lt; cropline) &amp;&amp; (tabRect.y + tabRect.height &gt; cropline)) {</span>
<span class="nc" id="L3130">                            tabScroller.croppedEdge.setParams(i, cropline - tabRect.y - 1,</span>
<span class="nc" id="L3131">                                    -currentTabAreaInsets.left,  0);</span>
                        }
                        break;
                    case TOP:
                    case BOTTOM:
                    default:
<span class="nc" id="L3137">                        cropline = viewRect.x + viewRect.width;</span>
<span class="nc bnc" id="L3138" title="All 4 branches missed.">                        if ((tabRect.x &lt; cropline - 1) &amp;&amp; (tabRect.x + tabRect.width &gt; cropline)) {</span>
<span class="nc" id="L3139">                            tabScroller.croppedEdge.setParams(i, cropline - tabRect.x - 1,</span>
<span class="nc" id="L3140">                                    0, -currentTabAreaInsets.top);</span>
                        }
                }
            }
<span class="nc" id="L3144">        }</span>

        protected void calculateTabRects(int tabPlacement, int tabCount) {
<span class="nc" id="L3147">            FontMetrics metrics = getFontMetrics();</span>
<span class="nc" id="L3148">            Dimension size = tabPane.getSize();</span>
<span class="nc" id="L3149">            Insets insets = tabPane.getInsets();</span>
<span class="nc" id="L3150">            Insets tabAreaInsets = getTabAreaInsets(tabPlacement);</span>
<span class="nc" id="L3151">            int fontHeight = metrics.getHeight();</span>
<span class="nc" id="L3152">            int selectedIndex = tabPane.getSelectedIndex();</span>
            int i;
<span class="nc bnc" id="L3154" title="All 4 branches missed.">            boolean verticalTabRuns = (tabPlacement == LEFT || tabPlacement == RIGHT);</span>
<span class="nc" id="L3155">            boolean leftToRight = BasicGraphicsUtils.isLeftToRight(tabPane);</span>
<span class="nc" id="L3156">            int x = tabAreaInsets.left;</span>
<span class="nc" id="L3157">            int y = tabAreaInsets.top;</span>
<span class="nc" id="L3158">            int totalWidth = 0;</span>
<span class="nc" id="L3159">            int totalHeight = 0;</span>

            //
            // Calculate bounds within which a tab run must fit
            //
<span class="nc bnc" id="L3164" title="All 2 branches missed.">            switch(tabPlacement) {</span>
              case LEFT:
              case RIGHT:
<span class="nc" id="L3167">                  maxTabWidth = calculateMaxTabWidth(tabPlacement);</span>
<span class="nc" id="L3168">                  break;</span>
              case BOTTOM:
              case TOP:
              default:
<span class="nc" id="L3172">                  maxTabHeight = calculateMaxTabHeight(tabPlacement);</span>
            }

<span class="nc" id="L3175">            runCount = 0;</span>
<span class="nc" id="L3176">            selectedRun = -1;</span>

<span class="nc bnc" id="L3178" title="All 2 branches missed.">            if (tabCount == 0) {</span>
<span class="nc" id="L3179">                return;</span>
            }

<span class="nc" id="L3182">            selectedRun = 0;</span>
<span class="nc" id="L3183">            runCount = 1;</span>

            // Run through tabs and lay them out in a single run
            Rectangle rect;
<span class="nc bnc" id="L3187" title="All 2 branches missed.">            for (i = 0; i &lt; tabCount; i++) {</span>
<span class="nc" id="L3188">                rect = rects[i];</span>

<span class="nc bnc" id="L3190" title="All 2 branches missed.">                if (!verticalTabRuns) {</span>
                    // Tabs on TOP or BOTTOM....
<span class="nc bnc" id="L3192" title="All 2 branches missed.">                    if (i &gt; 0) {</span>
<span class="nc" id="L3193">                        rect.x = rects[i-1].x + rects[i-1].width;</span>
                    } else {
<span class="nc" id="L3195">                        tabRuns[0] = 0;</span>
<span class="nc" id="L3196">                        maxTabWidth = 0;</span>
<span class="nc" id="L3197">                        totalHeight += maxTabHeight;</span>
<span class="nc" id="L3198">                        rect.x = x;</span>
                    }
<span class="nc" id="L3200">                    rect.width = calculateTabWidth(tabPlacement, i, metrics);</span>
<span class="nc" id="L3201">                    totalWidth = rect.x + rect.width;</span>
<span class="nc" id="L3202">                    maxTabWidth = Math.max(maxTabWidth, rect.width);</span>

<span class="nc" id="L3204">                    rect.y = y;</span>
<span class="nc" id="L3205">                    rect.height = maxTabHeight/* - 2*/;</span>

                } else {
                    // Tabs on LEFT or RIGHT...
<span class="nc bnc" id="L3209" title="All 2 branches missed.">                    if (i &gt; 0) {</span>
<span class="nc" id="L3210">                        rect.y = rects[i-1].y + rects[i-1].height;</span>
                    } else {
<span class="nc" id="L3212">                        tabRuns[0] = 0;</span>
<span class="nc" id="L3213">                        maxTabHeight = 0;</span>
<span class="nc" id="L3214">                        totalWidth = maxTabWidth;</span>
<span class="nc" id="L3215">                        rect.y = y;</span>
                    }
<span class="nc" id="L3217">                    rect.height = calculateTabHeight(tabPlacement, i, fontHeight);</span>
<span class="nc" id="L3218">                    totalHeight = rect.y + rect.height;</span>
<span class="nc" id="L3219">                    maxTabHeight = Math.max(maxTabHeight, rect.height);</span>

<span class="nc" id="L3221">                    rect.x = x;</span>
<span class="nc" id="L3222">                    rect.width = maxTabWidth/* - 2*/;</span>

                }
            }

<span class="nc bnc" id="L3227" title="All 2 branches missed.">            if (tabsOverlapBorder) {</span>
                // Pad the selected tab so that it appears raised in front
<span class="nc" id="L3229">                padSelectedTab(tabPlacement, selectedIndex);</span>
            }

            // if right to left and tab placement on the top or
            // the bottom, flip x positions and adjust by widths
<span class="nc bnc" id="L3234" title="All 4 branches missed.">            if (!leftToRight &amp;&amp; !verticalTabRuns) {</span>
<span class="nc" id="L3235">                int rightMargin = size.width</span>
                                  - (insets.right + tabAreaInsets.right);
<span class="nc bnc" id="L3237" title="All 2 branches missed.">                for (i = 0; i &lt; tabCount; i++) {</span>
<span class="nc" id="L3238">                    rects[i].x = rightMargin - rects[i].x - rects[i].width;</span>
                }
            }
<span class="nc" id="L3241">            tabScroller.tabPanel.setPreferredSize(new Dimension(totalWidth, totalHeight));</span>
<span class="nc" id="L3242">        }</span>
    }

    private class ScrollableTabSupport implements ActionListener,
                            ChangeListener {
        public ScrollableTabViewport viewport;
        public ScrollableTabPanel tabPanel;
        public JButton scrollForwardButton;
        public JButton scrollBackwardButton;
        public CroppedEdge croppedEdge;
        public int leadingTabIndex;

<span class="nc" id="L3254">        private Point tabViewPosition = new Point(0,0);</span>

<span class="nc" id="L3256">        ScrollableTabSupport(int tabPlacement) {</span>
<span class="nc" id="L3257">            viewport = new ScrollableTabViewport();</span>
<span class="nc" id="L3258">            tabPanel = new ScrollableTabPanel();</span>
<span class="nc" id="L3259">            viewport.setView(tabPanel);</span>
<span class="nc" id="L3260">            viewport.addChangeListener(this);</span>
<span class="nc" id="L3261">            croppedEdge = new CroppedEdge();</span>
<span class="nc" id="L3262">            createButtons();</span>
<span class="nc" id="L3263">        }</span>

        /**
         * Recreates the scroll buttons and adds them to the TabbedPane.
         */
        void createButtons() {
<span class="nc bnc" id="L3269" title="All 2 branches missed.">            if (scrollForwardButton != null) {</span>
<span class="nc" id="L3270">                tabPane.remove(scrollForwardButton);</span>
<span class="nc" id="L3271">                scrollForwardButton.removeActionListener(this);</span>
<span class="nc" id="L3272">                tabPane.remove(scrollBackwardButton);</span>
<span class="nc" id="L3273">                scrollBackwardButton.removeActionListener(this);</span>
            }
<span class="nc" id="L3275">            int tabPlacement = tabPane.getTabPlacement();</span>
<span class="nc bnc" id="L3276" title="All 4 branches missed.">            if (tabPlacement == TOP || tabPlacement == BOTTOM) {</span>
<span class="nc" id="L3277">                scrollForwardButton = createScrollButton(EAST);</span>
<span class="nc" id="L3278">                scrollBackwardButton = createScrollButton(WEST);</span>

            } else { // tabPlacement = LEFT || RIGHT
<span class="nc" id="L3281">                scrollForwardButton = createScrollButton(SOUTH);</span>
<span class="nc" id="L3282">                scrollBackwardButton = createScrollButton(NORTH);</span>
            }
<span class="nc" id="L3284">            scrollForwardButton.addActionListener(this);</span>
<span class="nc" id="L3285">            scrollBackwardButton.addActionListener(this);</span>
<span class="nc" id="L3286">            tabPane.add(scrollForwardButton);</span>
<span class="nc" id="L3287">            tabPane.add(scrollBackwardButton);</span>
<span class="nc" id="L3288">        }</span>

        public void scrollForward(int tabPlacement) {
<span class="nc" id="L3291">            Dimension viewSize = viewport.getViewSize();</span>
<span class="nc" id="L3292">            Rectangle viewRect = viewport.getViewRect();</span>

<span class="nc bnc" id="L3294" title="All 4 branches missed.">            if (tabPlacement == TOP || tabPlacement == BOTTOM) {</span>
<span class="nc bnc" id="L3295" title="All 2 branches missed.">                if (viewRect.width &gt;= viewSize.width - viewRect.x) {</span>
<span class="nc" id="L3296">                    return; // no room left to scroll</span>
                }
            } else { // tabPlacement == LEFT || tabPlacement == RIGHT
<span class="nc bnc" id="L3299" title="All 2 branches missed.">                if (viewRect.height &gt;= viewSize.height - viewRect.y) {</span>
<span class="nc" id="L3300">                    return;</span>
                }
            }
<span class="nc" id="L3303">            setLeadingTabIndex(tabPlacement, leadingTabIndex+1);</span>
<span class="nc" id="L3304">        }</span>

        public void scrollBackward(int tabPlacement) {
<span class="nc bnc" id="L3307" title="All 2 branches missed.">            if (leadingTabIndex == 0) {</span>
<span class="nc" id="L3308">                return; // no room left to scroll</span>
            }
<span class="nc" id="L3310">            setLeadingTabIndex(tabPlacement, leadingTabIndex-1);</span>
<span class="nc" id="L3311">        }</span>

        public void setLeadingTabIndex(int tabPlacement, int index) {
<span class="nc" id="L3314">            leadingTabIndex = index;</span>
<span class="nc" id="L3315">            Dimension viewSize = viewport.getViewSize();</span>
<span class="nc" id="L3316">            Rectangle viewRect = viewport.getViewRect();</span>

<span class="nc bnc" id="L3318" title="All 3 branches missed.">            switch(tabPlacement) {</span>
              case TOP:
              case BOTTOM:
<span class="nc bnc" id="L3321" title="All 2 branches missed.">                tabViewPosition.x = leadingTabIndex == 0? 0 : rects[leadingTabIndex].x;</span>

<span class="nc bnc" id="L3323" title="All 2 branches missed.">                if ((viewSize.width - tabViewPosition.x) &lt; viewRect.width) {</span>
                    // We've scrolled to the end, so adjust the viewport size
                    // to ensure the view position remains aligned on a tab boundary
<span class="nc" id="L3326">                    Dimension extentSize = new Dimension(viewSize.width - tabViewPosition.x,</span>
                                                         viewRect.height);
<span class="nc" id="L3328">                    viewport.setExtentSize(extentSize);</span>
<span class="nc" id="L3329">                }</span>
                break;
              case LEFT:
              case RIGHT:
<span class="nc bnc" id="L3333" title="All 2 branches missed.">                tabViewPosition.y = leadingTabIndex == 0? 0 : rects[leadingTabIndex].y;</span>

<span class="nc bnc" id="L3335" title="All 2 branches missed.">                if ((viewSize.height - tabViewPosition.y) &lt; viewRect.height) {</span>
                // We've scrolled to the end, so adjust the viewport size
                // to ensure the view position remains aligned on a tab boundary
<span class="nc" id="L3338">                     Dimension extentSize = new Dimension(viewRect.width,</span>
                                                          viewSize.height - tabViewPosition.y);
<span class="nc" id="L3340">                     viewport.setExtentSize(extentSize);</span>
                }
            }
<span class="nc" id="L3343">            viewport.setViewPosition(tabViewPosition);</span>
<span class="nc" id="L3344">        }</span>

        public void stateChanged(ChangeEvent e) {
<span class="nc" id="L3347">            updateView();</span>
<span class="nc" id="L3348">        }</span>

        private void updateView() {
<span class="nc" id="L3351">            int tabPlacement = tabPane.getTabPlacement();</span>
<span class="nc" id="L3352">            int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L3353">            assureRectsCreated(tabCount);</span>
<span class="nc" id="L3354">            Rectangle vpRect = viewport.getBounds();</span>
<span class="nc" id="L3355">            Dimension viewSize = viewport.getViewSize();</span>
<span class="nc" id="L3356">            Rectangle viewRect = viewport.getViewRect();</span>

<span class="nc" id="L3358">            leadingTabIndex = getClosestTab(viewRect.x, viewRect.y);</span>

            // If the tab isn't right aligned, adjust it.
<span class="nc bnc" id="L3361" title="All 2 branches missed.">            if (leadingTabIndex + 1 &lt; tabCount) {</span>
<span class="nc bnc" id="L3362" title="All 3 branches missed.">                switch (tabPlacement) {</span>
                case TOP:
                case BOTTOM:
<span class="nc bnc" id="L3365" title="All 2 branches missed.">                    if (rects[leadingTabIndex].x &lt; viewRect.x) {</span>
<span class="nc" id="L3366">                        leadingTabIndex++;</span>
                    }
                    break;
                case LEFT:
                case RIGHT:
<span class="nc bnc" id="L3371" title="All 2 branches missed.">                    if (rects[leadingTabIndex].y &lt; viewRect.y) {</span>
<span class="nc" id="L3372">                        leadingTabIndex++;</span>
                    }
                    break;
                }
            }
<span class="nc" id="L3377">            Insets contentInsets = getContentBorderInsets(tabPlacement);</span>
<span class="nc bnc" id="L3378" title="All 4 branches missed.">            switch(tabPlacement) {</span>
              case LEFT:
<span class="nc" id="L3380">                  tabPane.repaint(vpRect.x+vpRect.width, vpRect.y,</span>
                                  contentInsets.left, vpRect.height);
<span class="nc bnc" id="L3382" title="All 4 branches missed.">                  scrollBackwardButton.setEnabled(</span>
                          viewRect.y &gt; 0 &amp;&amp; leadingTabIndex &gt; 0);
<span class="nc bnc" id="L3384" title="All 4 branches missed.">                  scrollForwardButton.setEnabled(</span>
                          leadingTabIndex &lt; tabCount-1 &amp;&amp;
                          viewSize.height-viewRect.y &gt; viewRect.height);
<span class="nc" id="L3387">                  break;</span>
              case RIGHT:
<span class="nc" id="L3389">                  tabPane.repaint(vpRect.x-contentInsets.right, vpRect.y,</span>
                                  contentInsets.right, vpRect.height);
<span class="nc bnc" id="L3391" title="All 4 branches missed.">                  scrollBackwardButton.setEnabled(</span>
                          viewRect.y &gt; 0 &amp;&amp; leadingTabIndex &gt; 0);
<span class="nc bnc" id="L3393" title="All 4 branches missed.">                  scrollForwardButton.setEnabled(</span>
                          leadingTabIndex &lt; tabCount-1 &amp;&amp;
                          viewSize.height-viewRect.y &gt; viewRect.height);
<span class="nc" id="L3396">                  break;</span>
              case BOTTOM:
<span class="nc" id="L3398">                  tabPane.repaint(vpRect.x, vpRect.y-contentInsets.bottom,</span>
                                  vpRect.width, contentInsets.bottom);
<span class="nc bnc" id="L3400" title="All 4 branches missed.">                  scrollBackwardButton.setEnabled(</span>
                          viewRect.x &gt; 0 &amp;&amp; leadingTabIndex &gt; 0);
<span class="nc bnc" id="L3402" title="All 4 branches missed.">                  scrollForwardButton.setEnabled(</span>
                          leadingTabIndex &lt; tabCount-1 &amp;&amp;
                          viewSize.width-viewRect.x &gt; viewRect.width);
<span class="nc" id="L3405">                  break;</span>
              case TOP:
              default:
<span class="nc" id="L3408">                  tabPane.repaint(vpRect.x, vpRect.y+vpRect.height,</span>
                                  vpRect.width, contentInsets.top);
<span class="nc bnc" id="L3410" title="All 4 branches missed.">                  scrollBackwardButton.setEnabled(</span>
                          viewRect.x &gt; 0 &amp;&amp; leadingTabIndex &gt; 0);
<span class="nc bnc" id="L3412" title="All 4 branches missed.">                  scrollForwardButton.setEnabled(</span>
                          leadingTabIndex &lt; tabCount-1 &amp;&amp;
                          viewSize.width-viewRect.x &gt; viewRect.width);
            }
<span class="nc" id="L3416">        }</span>

        /**
         * ActionListener for the scroll buttons.
         */
        public void actionPerformed(ActionEvent e) {
<span class="nc" id="L3422">            ActionMap map = tabPane.getActionMap();</span>

<span class="nc bnc" id="L3424" title="All 2 branches missed.">            if (map != null) {</span>
                String actionKey;

<span class="nc bnc" id="L3427" title="All 2 branches missed.">                if (e.getSource() == scrollForwardButton) {</span>
<span class="nc" id="L3428">                    actionKey = &quot;scrollTabsForwardAction&quot;;</span>
                }
                else {
<span class="nc" id="L3431">                    actionKey = &quot;scrollTabsBackwardAction&quot;;</span>
                }
<span class="nc" id="L3433">                Action action = map.get(actionKey);</span>

<span class="nc bnc" id="L3435" title="All 4 branches missed.">                if (action != null &amp;&amp; action.isEnabled()) {</span>
<span class="nc" id="L3436">                    action.actionPerformed(new ActionEvent(tabPane,</span>
<span class="nc" id="L3437">                        ActionEvent.ACTION_PERFORMED, null, e.getWhen(),</span>
<span class="nc" id="L3438">                        e.getModifiers()));</span>
                }
            }
<span class="nc" id="L3441">        }</span>

        public String toString() {
<span class="nc" id="L3444">            return &quot;viewport.viewSize=&quot; + viewport.getViewSize() + &quot;\n&quot; +</span>
<span class="nc" id="L3445">                              &quot;viewport.viewRectangle=&quot;+viewport.getViewRect()+&quot;\n&quot;+</span>
                              &quot;leadingTabIndex=&quot;+leadingTabIndex+&quot;\n&quot;+
                              &quot;tabViewPosition=&quot; + tabViewPosition;
        }

    }

    private class ScrollableTabViewport extends JViewport implements UIResource {
<span class="nc" id="L3453">        public ScrollableTabViewport() {</span>
<span class="nc" id="L3454">            super();</span>
<span class="nc" id="L3455">            setName(&quot;TabbedPane.scrollableViewport&quot;);</span>
<span class="nc" id="L3456">            setScrollMode(SIMPLE_SCROLL_MODE);</span>
<span class="nc" id="L3457">            setOpaque(tabPane.isOpaque());</span>
<span class="nc" id="L3458">            Color bgColor = UIManager.getColor(&quot;TabbedPane.tabAreaBackground&quot;);</span>
<span class="nc bnc" id="L3459" title="All 2 branches missed.">            if (bgColor == null) {</span>
<span class="nc" id="L3460">                bgColor = tabPane.getBackground();</span>
            }
<span class="nc" id="L3462">            setBackground(bgColor);</span>
<span class="nc" id="L3463">        }</span>
    }

    private class ScrollableTabPanel extends JPanel implements UIResource {
<span class="nc" id="L3467">        public ScrollableTabPanel() {</span>
<span class="nc" id="L3468">            super(null);</span>
<span class="nc" id="L3469">            setOpaque(tabPane.isOpaque());</span>
<span class="nc" id="L3470">            Color bgColor = UIManager.getColor(&quot;TabbedPane.tabAreaBackground&quot;);</span>
<span class="nc bnc" id="L3471" title="All 2 branches missed.">            if (bgColor == null) {</span>
<span class="nc" id="L3472">                bgColor = tabPane.getBackground();</span>
            }
<span class="nc" id="L3474">            setBackground(bgColor);</span>
<span class="nc" id="L3475">        }</span>
        public void paintComponent(Graphics g) {
<span class="nc" id="L3477">            super.paintComponent(g);</span>
<span class="nc" id="L3478">            BasicTabbedPaneUI.this.paintTabArea(g, tabPane.getTabPlacement(),</span>
<span class="nc" id="L3479">                                                tabPane.getSelectedIndex());</span>
<span class="nc bnc" id="L3480" title="All 4 branches missed.">            if (tabScroller.croppedEdge.isParamsSet() &amp;&amp; tabContainer == null) {</span>
<span class="nc" id="L3481">                Rectangle croppedRect = rects[tabScroller.croppedEdge.getTabIndex()];</span>
<span class="nc" id="L3482">                g.translate(croppedRect.x, croppedRect.y);</span>
<span class="nc" id="L3483">                tabScroller.croppedEdge.paintComponent(g);</span>
<span class="nc" id="L3484">                g.translate(-croppedRect.x, -croppedRect.y);</span>
            }
<span class="nc" id="L3486">        }</span>

        public void doLayout() {
<span class="nc bnc" id="L3489" title="All 2 branches missed.">            if (getComponentCount() &gt; 0) {</span>
<span class="nc" id="L3490">                Component child = getComponent(0);</span>
<span class="nc" id="L3491">                child.setBounds(0, 0, getWidth(), getHeight());</span>
            }
<span class="nc" id="L3493">        }</span>
    }

    private class ScrollableTabButton extends BasicArrowButton implements UIResource,
                                                                            SwingConstants {
<span class="nc" id="L3498">        public ScrollableTabButton(int direction) {</span>
<span class="nc" id="L3499">            super(direction,</span>
<span class="nc" id="L3500">                  UIManager.getColor(&quot;TabbedPane.selected&quot;),</span>
<span class="nc" id="L3501">                  UIManager.getColor(&quot;TabbedPane.shadow&quot;),</span>
<span class="nc" id="L3502">                  UIManager.getColor(&quot;TabbedPane.darkShadow&quot;),</span>
<span class="nc" id="L3503">                  UIManager.getColor(&quot;TabbedPane.highlight&quot;));</span>
<span class="nc" id="L3504">        }</span>
    }


// Controller: event listeners

<span class="nc" id="L3510">    private class Handler implements ChangeListener, ContainerListener,</span>
                  FocusListener, MouseListener, MouseMotionListener,
                  PropertyChangeListener {
        //
        // PropertyChangeListener
        //
        public void propertyChange(PropertyChangeEvent e) {
<span class="nc" id="L3517">            JTabbedPane pane = (JTabbedPane)e.getSource();</span>
<span class="nc" id="L3518">            String name = e.getPropertyName();</span>
<span class="nc" id="L3519">            boolean isScrollLayout = scrollableTabLayoutEnabled();</span>
<span class="nc bnc" id="L3520" title="All 2 branches missed.">            if (name == &quot;mnemonicAt&quot;) {</span>
<span class="nc" id="L3521">                updateMnemonics();</span>
<span class="nc" id="L3522">                pane.repaint();</span>
            }
<span class="nc bnc" id="L3524" title="All 2 branches missed.">            else if (name == &quot;displayedMnemonicIndexAt&quot;) {</span>
<span class="nc" id="L3525">                pane.repaint();</span>
            }
<span class="nc bnc" id="L3527" title="All 2 branches missed.">            else if (name ==&quot;indexForTitle&quot;) {</span>
<span class="nc" id="L3528">                calculatedBaseline = false;</span>
<span class="nc" id="L3529">                Integer index = (Integer) e.getNewValue();</span>
                // remove the current index
                // to let updateHtmlViews() insert the correct one
<span class="nc bnc" id="L3532" title="All 2 branches missed.">                if (htmlViews != null) {</span>
<span class="nc" id="L3533">                    htmlViews.removeElementAt(index);</span>
                }
<span class="nc" id="L3535">                updateHtmlViews(index);</span>
<span class="nc bnc" id="L3536" title="All 2 branches missed.">            } else if (name == &quot;tabLayoutPolicy&quot;) {</span>
<span class="nc" id="L3537">                BasicTabbedPaneUI.this.uninstallUI(pane);</span>
<span class="nc" id="L3538">                BasicTabbedPaneUI.this.installUI(pane);</span>
<span class="nc" id="L3539">                calculatedBaseline = false;</span>
<span class="nc bnc" id="L3540" title="All 2 branches missed.">            } else if (name == &quot;tabPlacement&quot;) {</span>
<span class="nc bnc" id="L3541" title="All 2 branches missed.">                if (scrollableTabLayoutEnabled()) {</span>
<span class="nc" id="L3542">                    tabScroller.createButtons();</span>
                }
<span class="nc" id="L3544">                calculatedBaseline = false;</span>
<span class="nc bnc" id="L3545" title="All 4 branches missed.">            } else if (name == &quot;opaque&quot; &amp;&amp; isScrollLayout) {</span>
<span class="nc" id="L3546">                boolean newVal = ((Boolean)e.getNewValue()).booleanValue();</span>
<span class="nc" id="L3547">                tabScroller.tabPanel.setOpaque(newVal);</span>
<span class="nc" id="L3548">                tabScroller.viewport.setOpaque(newVal);</span>
<span class="nc bnc" id="L3549" title="All 4 branches missed.">            } else if (name == &quot;background&quot; &amp;&amp; isScrollLayout) {</span>
<span class="nc" id="L3550">                Color newVal = (Color)e.getNewValue();</span>
<span class="nc" id="L3551">                tabScroller.tabPanel.setBackground(newVal);</span>
<span class="nc" id="L3552">                tabScroller.viewport.setBackground(newVal);</span>
<span class="nc bnc" id="L3553" title="All 2 branches missed.">                Color newColor = selectedColor == null ? newVal : selectedColor;</span>
<span class="nc" id="L3554">                tabScroller.scrollForwardButton.setBackground(newColor);</span>
<span class="nc" id="L3555">                tabScroller.scrollBackwardButton.setBackground(newColor);</span>
<span class="nc bnc" id="L3556" title="All 2 branches missed.">            } else if (name == &quot;indexForTabComponent&quot;) {</span>
<span class="nc bnc" id="L3557" title="All 2 branches missed.">                if (tabContainer != null) {</span>
<span class="nc" id="L3558">                    tabContainer.removeUnusedTabComponents();</span>
                }
<span class="nc" id="L3560">                Component c = tabPane.getTabComponentAt(</span>
<span class="nc" id="L3561">                        (Integer)e.getNewValue());</span>
<span class="nc bnc" id="L3562" title="All 2 branches missed.">                if (c != null) {</span>
<span class="nc bnc" id="L3563" title="All 2 branches missed.">                    if (tabContainer == null) {</span>
<span class="nc" id="L3564">                        installTabContainer();</span>
                    } else {
<span class="nc" id="L3566">                        tabContainer.add(c);</span>
                    }
                }
<span class="nc" id="L3569">                tabPane.revalidate();</span>
<span class="nc" id="L3570">                tabPane.repaint();</span>
<span class="nc" id="L3571">                calculatedBaseline = false;</span>
<span class="nc bnc" id="L3572" title="All 2 branches missed.">            } else if (name == &quot;indexForNullComponent&quot;) {</span>
<span class="nc" id="L3573">                isRunsDirty = true;</span>
<span class="nc" id="L3574">                updateHtmlViews((Integer)e.getNewValue());</span>
<span class="nc bnc" id="L3575" title="All 2 branches missed.">            } else if (name == &quot;font&quot;) {</span>
<span class="nc" id="L3576">                calculatedBaseline = false;</span>
            }
<span class="nc" id="L3578">        }</span>

        private void updateHtmlViews(int index) {
<span class="nc" id="L3581">            String title = tabPane.getTitleAt(index);</span>
<span class="nc" id="L3582">            boolean isHTML = BasicHTML.isHTMLString(title);</span>
<span class="nc bnc" id="L3583" title="All 2 branches missed.">            if (isHTML) {</span>
<span class="nc bnc" id="L3584" title="All 2 branches missed.">                if (htmlViews==null) {    // Initialize vector</span>
<span class="nc" id="L3585">                    htmlViews = createHTMLVector();</span>
                } else {                  // Vector already exists
<span class="nc" id="L3587">                    View v = BasicHTML.createHTMLView(tabPane, title);</span>
<span class="nc" id="L3588">                    htmlViews.insertElementAt(v, index);</span>
<span class="nc" id="L3589">                }</span>
            } else {                             // Not HTML
<span class="nc bnc" id="L3591" title="All 2 branches missed.">                if (htmlViews!=null) {           // Add placeholder</span>
<span class="nc" id="L3592">                    htmlViews.insertElementAt(null, index);</span>
                }                                // else nada!
            }
<span class="nc" id="L3595">            updateMnemonics();</span>
<span class="nc" id="L3596">        }</span>

        //
        // ChangeListener
        //
        public void stateChanged(ChangeEvent e) {
<span class="nc" id="L3602">            JTabbedPane tabPane = (JTabbedPane)e.getSource();</span>
<span class="nc" id="L3603">            tabPane.revalidate();</span>
<span class="nc" id="L3604">            tabPane.repaint();</span>

<span class="nc" id="L3606">            setFocusIndex(tabPane.getSelectedIndex(), false);</span>

<span class="nc bnc" id="L3608" title="All 2 branches missed.">            if (scrollableTabLayoutEnabled()) {</span>
<span class="nc" id="L3609">                int index = tabPane.getSelectedIndex();</span>
<span class="nc bnc" id="L3610" title="All 4 branches missed.">                if (index &lt; rects.length &amp;&amp; index != -1) {</span>
<span class="nc" id="L3611">                    tabScroller.tabPanel.scrollRectToVisible(</span>
<span class="nc" id="L3612">                            (Rectangle)rects[index].clone());</span>
                }
            }
<span class="nc" id="L3615">        }</span>

        //
        // MouseListener
        //
        public void mouseClicked(MouseEvent e) {
<span class="nc" id="L3621">        }</span>

        public void mouseReleased(MouseEvent e) {
<span class="nc" id="L3624">        }</span>

        public void mouseEntered(MouseEvent e) {
<span class="nc" id="L3627">            setRolloverTab(e.getX(), e.getY());</span>
<span class="nc" id="L3628">        }</span>

        public void mouseExited(MouseEvent e) {
<span class="nc" id="L3631">            setRolloverTab(-1);</span>
<span class="nc" id="L3632">        }</span>

        public void mousePressed(MouseEvent e) {
<span class="nc bnc" id="L3635" title="All 2 branches missed.">            if (!tabPane.isEnabled()) {</span>
<span class="nc" id="L3636">                return;</span>
            }
<span class="nc" id="L3638">            int tabIndex = tabForCoordinate(tabPane, e.getX(), e.getY());</span>
<span class="nc bnc" id="L3639" title="All 4 branches missed.">            if (tabIndex &gt;= 0 &amp;&amp; tabPane.isEnabledAt(tabIndex)) {</span>
<span class="nc bnc" id="L3640" title="All 2 branches missed.">                if (tabIndex != tabPane.getSelectedIndex()) {</span>
                    // Clicking on unselected tab, change selection, do NOT
                    // request focus.
                    // This will trigger the focusIndex to change by way
                    // of stateChanged.
<span class="nc" id="L3645">                    tabPane.setSelectedIndex(tabIndex);</span>
                }
<span class="nc bnc" id="L3647" title="All 2 branches missed.">                else if (tabPane.isRequestFocusEnabled()) {</span>
                    // Clicking on selected tab, try and give the tabbedpane
                    // focus.  Repaint will occur in focusGained.
<span class="nc" id="L3650">                    tabPane.requestFocus();</span>
                }
            }
<span class="nc" id="L3653">        }</span>

        //
        // MouseMotionListener
        //
        public void mouseDragged(MouseEvent e) {
<span class="nc" id="L3659">        }</span>

        public void mouseMoved(MouseEvent e) {
<span class="nc" id="L3662">            setRolloverTab(e.getX(), e.getY());</span>
<span class="nc" id="L3663">        }</span>

        //
        // FocusListener
        //
        public void focusGained(FocusEvent e) {
<span class="nc" id="L3669">           setFocusIndex(tabPane.getSelectedIndex(), true);</span>
<span class="nc" id="L3670">        }</span>
        public void focusLost(FocusEvent e) {
<span class="nc" id="L3672">           repaintTab(focusIndex);</span>
<span class="nc" id="L3673">        }</span>


        //
        // ContainerListener
        //
    /* GES 2/3/99:
       The container listener code was added to support HTML
       rendering of tab titles.

       Ideally, we would be able to listen for property changes
       when a tab is added or its text modified.  At the moment
       there are no such events because the Beans spec doesn't
       allow 'indexed' property changes (i.e. tab 2's text changed
       from A to B).

       In order to get around this, we listen for tabs to be added
       or removed by listening for the container events.  we then
       queue up a runnable (so the component has a chance to complete
       the add) which checks the tab title of the new component to see
       if it requires HTML rendering.

       The Views (one per tab title requiring HTML rendering) are
       stored in the htmlViews Vector, which is only allocated after
       the first time we run into an HTML tab.  Note that this vector
       is kept in step with the number of pages, and nulls are added
       for those pages whose tab title do not require HTML rendering.

       This makes it easy for the paint and layout code to tell
       whether to invoke the HTML engine without having to check
       the string during time-sensitive operations.

       When we have added a way to listen for tab additions and
       changes to tab text, this code should be removed and
       replaced by something which uses that.  */

        public void componentAdded(ContainerEvent e) {
<span class="nc" id="L3710">            JTabbedPane tp = (JTabbedPane)e.getContainer();</span>
<span class="nc" id="L3711">            Component child = e.getChild();</span>
<span class="nc bnc" id="L3712" title="All 2 branches missed.">            if (child instanceof UIResource) {</span>
<span class="nc" id="L3713">                return;</span>
            }
<span class="nc" id="L3715">            isRunsDirty = true;</span>
<span class="nc" id="L3716">            updateHtmlViews(tp.indexOfComponent(child));</span>
<span class="nc" id="L3717">        }</span>
        public void componentRemoved(ContainerEvent e) {
<span class="nc" id="L3719">            JTabbedPane tp = (JTabbedPane)e.getContainer();</span>
<span class="nc" id="L3720">            Component child = e.getChild();</span>
<span class="nc bnc" id="L3721" title="All 2 branches missed.">            if (child instanceof UIResource) {</span>
<span class="nc" id="L3722">                return;</span>
            }

            // NOTE 4/15/2002 (joutwate):
            // This fix is implemented using client properties since there is
            // currently no IndexPropertyChangeEvent.  Once
            // IndexPropertyChangeEvents have been added this code should be
            // modified to use it.
<span class="nc" id="L3730">            Integer indexObj =</span>
<span class="nc" id="L3731">                (Integer)tp.getClientProperty(&quot;__index_to_remove__&quot;);</span>
<span class="nc bnc" id="L3732" title="All 2 branches missed.">            if (indexObj != null) {</span>
<span class="nc" id="L3733">                int index = indexObj.intValue();</span>
<span class="nc bnc" id="L3734" title="All 4 branches missed.">                if (htmlViews != null &amp;&amp; htmlViews.size() &gt; index) {</span>
<span class="nc" id="L3735">                    htmlViews.removeElementAt(index);</span>
                }
<span class="nc" id="L3737">                tp.putClientProperty(&quot;__index_to_remove__&quot;, null);</span>
            }
<span class="nc" id="L3739">            isRunsDirty = true;</span>
<span class="nc" id="L3740">            updateMnemonics();</span>

<span class="nc" id="L3742">            validateFocusIndex();</span>
<span class="nc" id="L3743">        }</span>
    }

    /**
     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.
     * Instantiate it only within subclasses of BasicTabbedPaneUI.
     */
<span class="nc" id="L3750">    public class PropertyChangeHandler implements PropertyChangeListener {</span>
        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.
        public void propertyChange(PropertyChangeEvent e) {
<span class="nc" id="L3756">            getHandler().propertyChange(e);</span>
<span class="nc" id="L3757">        }</span>
    }

    /**
     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.
     * Instantiate it only within subclasses of BasicTabbedPaneUI.
     */
<span class="nc" id="L3764">    public class TabSelectionHandler implements ChangeListener {</span>
        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.
        public void stateChanged(ChangeEvent e) {
<span class="nc" id="L3770">            getHandler().stateChanged(e);</span>
<span class="nc" id="L3771">        }</span>
    }

    /**
     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.
     * Instantiate it only within subclasses of BasicTabbedPaneUI.
     */
<span class="nc" id="L3778">    public class MouseHandler extends MouseAdapter {</span>
        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.
        public void mousePressed(MouseEvent e) {
<span class="nc" id="L3784">            getHandler().mousePressed(e);</span>
<span class="nc" id="L3785">        }</span>
    }

    /**
     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.
     * Instantiate it only within subclasses of BasicTabbedPaneUI.
     */
<span class="nc" id="L3792">    public class FocusHandler extends FocusAdapter {</span>
        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.
        public void focusGained(FocusEvent e) {
<span class="nc" id="L3798">            getHandler().focusGained(e);</span>
<span class="nc" id="L3799">        }</span>
        public void focusLost(FocusEvent e) {
<span class="nc" id="L3801">            getHandler().focusLost(e);</span>
<span class="nc" id="L3802">        }</span>
    }

    private Vector&lt;View&gt; createHTMLVector() {
<span class="nc" id="L3806">        Vector&lt;View&gt; htmlViews = new Vector&lt;View&gt;();</span>
<span class="nc" id="L3807">        int count = tabPane.getTabCount();</span>
<span class="nc bnc" id="L3808" title="All 2 branches missed.">        if (count&gt;0) {</span>
<span class="nc bnc" id="L3809" title="All 2 branches missed.">            for (int i=0 ; i&lt;count; i++) {</span>
<span class="nc" id="L3810">                String title = tabPane.getTitleAt(i);</span>
<span class="nc bnc" id="L3811" title="All 2 branches missed.">                if (BasicHTML.isHTMLString(title)) {</span>
<span class="nc" id="L3812">                    htmlViews.addElement(BasicHTML.createHTMLView(tabPane, title));</span>
                } else {
<span class="nc" id="L3814">                    htmlViews.addElement(null);</span>
                }
            }
        }
<span class="nc" id="L3818">        return htmlViews;</span>
    }

    private class TabContainer extends JPanel implements UIResource {
<span class="nc" id="L3822">        private boolean notifyTabbedPane = true;</span>

<span class="nc" id="L3824">        public TabContainer() {</span>
<span class="nc" id="L3825">            super(null);</span>
<span class="nc" id="L3826">            setOpaque(false);</span>
<span class="nc" id="L3827">        }</span>

        public void remove(Component comp) {
<span class="nc" id="L3830">            int index = tabPane.indexOfTabComponent(comp);</span>
<span class="nc" id="L3831">            super.remove(comp);</span>
<span class="nc bnc" id="L3832" title="All 4 branches missed.">            if (notifyTabbedPane &amp;&amp; index != -1) {</span>
<span class="nc" id="L3833">                tabPane.setTabComponentAt(index, null);</span>
            }
<span class="nc" id="L3835">        }</span>

        private void removeUnusedTabComponents() {
<span class="nc bnc" id="L3838" title="All 2 branches missed.">            for (Component c : getComponents()) {</span>
<span class="nc bnc" id="L3839" title="All 2 branches missed.">                if (!(c instanceof UIResource)) {</span>
<span class="nc" id="L3840">                    int index = tabPane.indexOfTabComponent(c);</span>
<span class="nc bnc" id="L3841" title="All 2 branches missed.">                    if (index == -1) {</span>
<span class="nc" id="L3842">                        super.remove(c);</span>
                    }
                }
            }
<span class="nc" id="L3846">        }</span>

        public boolean isOptimizedDrawingEnabled() {
<span class="nc bnc" id="L3849" title="All 4 branches missed.">            return tabScroller != null &amp;&amp; !tabScroller.croppedEdge.isParamsSet();</span>
        }

        public void doLayout() {
            // We layout tabComponents in JTabbedPane's layout manager
            // and use this method as a hook for repainting tabs
            // to update tabs area e.g. when the size of tabComponent was changed
<span class="nc bnc" id="L3856" title="All 2 branches missed.">            if (scrollableTabLayoutEnabled()) {</span>
<span class="nc" id="L3857">                tabScroller.tabPanel.repaint();</span>
<span class="nc" id="L3858">                tabScroller.updateView();</span>
            } else {
<span class="nc" id="L3860">                tabPane.repaint(getBounds());</span>
            }
<span class="nc" id="L3862">        }</span>
    }

<span class="nc" id="L3865">    private class CroppedEdge extends JPanel implements UIResource {</span>
        private Shape shape;
        private int tabIndex;
        private int cropline;
        private int cropx, cropy;

<span class="nc" id="L3871">        public CroppedEdge() {</span>
<span class="nc" id="L3872">            setOpaque(false);</span>
<span class="nc" id="L3873">        }</span>

        public void setParams(int tabIndex, int cropline, int cropx, int cropy) {
<span class="nc" id="L3876">            this.tabIndex = tabIndex;</span>
<span class="nc" id="L3877">            this.cropline = cropline;</span>
<span class="nc" id="L3878">            this.cropx = cropx;</span>
<span class="nc" id="L3879">            this.cropy = cropy;</span>
<span class="nc" id="L3880">            Rectangle tabRect = rects[tabIndex];</span>
<span class="nc" id="L3881">            setBounds(tabRect);</span>
<span class="nc" id="L3882">            shape = createCroppedTabShape(tabPane.getTabPlacement(), tabRect, cropline);</span>
<span class="nc bnc" id="L3883" title="All 4 branches missed.">            if (getParent() == null &amp;&amp; tabContainer != null) {</span>
<span class="nc" id="L3884">                tabContainer.add(this, 0);</span>
            }
<span class="nc" id="L3886">        }</span>

        public void resetParams() {
<span class="nc" id="L3889">            shape = null;</span>
<span class="nc bnc" id="L3890" title="All 4 branches missed.">            if (getParent() == tabContainer &amp;&amp; tabContainer != null) {</span>
<span class="nc" id="L3891">                tabContainer.remove(this);</span>
            }
<span class="nc" id="L3893">        }</span>

        public boolean isParamsSet() {
<span class="nc bnc" id="L3896" title="All 2 branches missed.">            return shape != null;</span>
        }

        public int getTabIndex() {
<span class="nc" id="L3900">            return tabIndex;</span>
        }

        public int getCropline() {
<span class="nc" id="L3904">            return cropline;</span>
        }

        public int getCroppedSideWidth() {
<span class="nc" id="L3908">            return 3;</span>
        }

        private Color getBgColor() {
<span class="nc" id="L3912">            Component parent = tabPane.getParent();</span>
<span class="nc bnc" id="L3913" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L3914">                Color bg = parent.getBackground();</span>
<span class="nc bnc" id="L3915" title="All 2 branches missed.">                if (bg != null) {</span>
<span class="nc" id="L3916">                    return bg;</span>
                }
            }
<span class="nc" id="L3919">            return UIManager.getColor(&quot;control&quot;);</span>
        }

        protected void paintComponent(Graphics g) {
<span class="nc" id="L3923">            super.paintComponent(g);</span>
<span class="nc bnc" id="L3924" title="All 4 branches missed.">            if (isParamsSet() &amp;&amp; g instanceof Graphics2D) {</span>
<span class="nc" id="L3925">                Graphics2D g2 = (Graphics2D) g;</span>
<span class="nc" id="L3926">                g2.clipRect(0, 0, getWidth(), getHeight());</span>
<span class="nc" id="L3927">                g2.setColor(getBgColor());</span>
<span class="nc" id="L3928">                g2.translate(cropx, cropy);</span>
<span class="nc" id="L3929">                g2.fill(shape);</span>
<span class="nc" id="L3930">                paintCroppedTabEdge(g);</span>
<span class="nc" id="L3931">                g2.translate(-cropx, -cropy);</span>
            }
<span class="nc" id="L3933">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>