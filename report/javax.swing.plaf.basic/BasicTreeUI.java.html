<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BasicTreeUI.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.plaf.basic</a> &gt; <span class="el_source">BasicTreeUI.java</span></div><h1>BasicTreeUI.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.plaf.basic;

import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.datatransfer.*;
import java.beans.*;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import javax.swing.plaf.ComponentUI;
import javax.swing.plaf.UIResource;
import javax.swing.plaf.TreeUI;
import javax.swing.tree.*;
import javax.swing.text.Position;
import javax.swing.plaf.basic.DragRecognitionSupport.BeforeDrag;
import sun.awt.AWTAccessor;
import sun.swing.SwingUtilities2;

import sun.swing.DefaultLookup;
import sun.swing.UIAction;

/**
 * The basic L&amp;amp;F for a hierarchical data structure.
 * &lt;p&gt;
 *
 * @author Scott Violet
 * @author Shannon Hickey (drag and drop)
 */

public class BasicTreeUI extends TreeUI
{
<span class="nc" id="L61">    private static final StringBuilder BASELINE_COMPONENT_KEY =</span>
        new StringBuilder(&quot;Tree.baselineComponent&quot;);

    // Old actions forward to an instance of this.
<span class="nc" id="L65">    static private final Actions SHARED_ACTION = new Actions();</span>

    transient protected Icon        collapsedIcon;
    transient protected Icon        expandedIcon;

    /**
      * Color used to draw hash marks.  If &lt;code&gt;null&lt;/code&gt; no hash marks
      * will be drawn.
      */
    private Color hashColor;

    /** Distance between left margin and where vertical dashes will be
      * drawn. */
    protected int               leftChildIndent;
    /** Distance to add to leftChildIndent to determine where cell
      * contents will be drawn. */
    protected int               rightChildIndent;
    /** Total distance that will be indented.  The sum of leftChildIndent
      * and rightChildIndent. */
    protected int               totalChildIndent;

    /** Minimum preferred size. */
    protected Dimension         preferredMinSize;

    /** Index of the row that was last selected. */
    protected int               lastSelectedRow;

    /** Component that we're going to be drawing into. */
    protected JTree             tree;

    /** Renderer that is being used to do the actual cell drawing. */
    transient protected TreeCellRenderer   currentCellRenderer;

    /** Set to true if the renderer that is currently in the tree was
     * created by this instance. */
    protected boolean           createdRenderer;

    /** Editor for the tree. */
    transient protected TreeCellEditor     cellEditor;

    /** Set to true if editor that is currently in the tree was
     * created by this instance. */
    protected boolean           createdCellEditor;

    /** Set to false when editing and shouldSelectCell() returns true meaning
      * the node should be selected before editing, used in completeEditing. */
    protected boolean           stopEditingInCompleteEditing;

    /** Used to paint the TreeCellRenderer. */
    protected CellRendererPane  rendererPane;

    /** Size needed to completely display all the nodes. */
    protected Dimension         preferredSize;

    /** Is the preferredSize valid? */
    protected boolean           validCachedPreferredSize;

    /** Object responsible for handling sizing and expanded issues. */
    // WARNING: Be careful with the bounds held by treeState. They are
    // always in terms of left-to-right. They get mapped to right-to-left
    // by the various methods of this class.
    protected AbstractLayoutCache  treeState;


    /** Used for minimizing the drawing of vertical lines. */
    protected Hashtable&lt;TreePath,Boolean&gt; drawingCache;

    /** True if doing optimizations for a largeModel. Subclasses that
     * don't support this may wish to override createLayoutCache to not
     * return a FixedHeightLayoutCache instance. */
    protected boolean           largeModel;

    /** Reponsible for telling the TreeState the size needed for a node. */
    protected AbstractLayoutCache.NodeDimensions     nodeDimensions;

    /** Used to determine what to display. */
    protected TreeModel         treeModel;

    /** Model maintaining the selection. */
    protected TreeSelectionModel treeSelectionModel;

    /** How much the depth should be offset to properly calculate
     * x locations. This is based on whether or not the root is visible,
     * and if the root handles are visible. */
    protected int               depthOffset;

    // Following 4 ivars are only valid when editing.

    /** When editing, this will be the Component that is doing the actual
      * editing. */
    protected Component         editingComponent;

    /** Path that is being edited. */
    protected TreePath          editingPath;

    /** Row that is being edited. Should only be referenced if
     * editingComponent is not null. */
    protected int               editingRow;

    /** Set to true if the editor has a different size than the renderer. */
    protected boolean           editorHasDifferentSize;

    /** Row correspondin to lead path. */
    private int                 leadRow;
    /** If true, the property change event for LEAD_SELECTION_PATH_PROPERTY,
     * or ANCHOR_SELECTION_PATH_PROPERTY will not generate a repaint. */
    private boolean             ignoreLAChange;

    /** Indicates the orientation. */
    private boolean             leftToRight;

    // Cached listeners
    private PropertyChangeListener propertyChangeListener;
    private PropertyChangeListener selectionModelPropertyChangeListener;
    private MouseListener mouseListener;
    private FocusListener focusListener;
    private KeyListener keyListener;
    /** Used for large models, listens for moved/resized events and
     * updates the validCachedPreferredSize bit accordingly. */
    private ComponentListener   componentListener;
    /** Listens for CellEditor events. */
    private CellEditorListener  cellEditorListener;
    /** Updates the display when the selection changes. */
    private TreeSelectionListener treeSelectionListener;
    /** Is responsible for updating the display based on model events. */
    private TreeModelListener treeModelListener;
    /** Updates the treestate as the nodes expand. */
    private TreeExpansionListener treeExpansionListener;

    /** UI property indicating whether to paint lines */
<span class="nc" id="L195">    private boolean paintLines = true;</span>

    /** UI property for painting dashed lines */
    private boolean lineTypeDashed;

    /**
     * The time factor to treate the series of typed alphanumeric key
     * as prefix for first letter navigation.
     */
<span class="nc" id="L204">    private long timeFactor = 1000L;</span>

    private Handler handler;

    /**
     * A temporary variable for communication between startEditingOnRelease
     * and startEditing.
     */
    private MouseEvent releaseEvent;

    public static ComponentUI createUI(JComponent x) {
<span class="nc" id="L215">        return new BasicTreeUI();</span>
    }


    static void loadActionMap(LazyActionMap map) {
<span class="nc" id="L220">        map.put(new Actions(Actions.SELECT_PREVIOUS));</span>
<span class="nc" id="L221">        map.put(new Actions(Actions.SELECT_PREVIOUS_CHANGE_LEAD));</span>
<span class="nc" id="L222">        map.put(new Actions(Actions.SELECT_PREVIOUS_EXTEND_SELECTION));</span>

<span class="nc" id="L224">        map.put(new Actions(Actions.SELECT_NEXT));</span>
<span class="nc" id="L225">        map.put(new Actions(Actions.SELECT_NEXT_CHANGE_LEAD));</span>
<span class="nc" id="L226">        map.put(new Actions(Actions.SELECT_NEXT_EXTEND_SELECTION));</span>

<span class="nc" id="L228">        map.put(new Actions(Actions.SELECT_CHILD));</span>
<span class="nc" id="L229">        map.put(new Actions(Actions.SELECT_CHILD_CHANGE_LEAD));</span>

<span class="nc" id="L231">        map.put(new Actions(Actions.SELECT_PARENT));</span>
<span class="nc" id="L232">        map.put(new Actions(Actions.SELECT_PARENT_CHANGE_LEAD));</span>

<span class="nc" id="L234">        map.put(new Actions(Actions.SCROLL_UP_CHANGE_SELECTION));</span>
<span class="nc" id="L235">        map.put(new Actions(Actions.SCROLL_UP_CHANGE_LEAD));</span>
<span class="nc" id="L236">        map.put(new Actions(Actions.SCROLL_UP_EXTEND_SELECTION));</span>

<span class="nc" id="L238">        map.put(new Actions(Actions.SCROLL_DOWN_CHANGE_SELECTION));</span>
<span class="nc" id="L239">        map.put(new Actions(Actions.SCROLL_DOWN_EXTEND_SELECTION));</span>
<span class="nc" id="L240">        map.put(new Actions(Actions.SCROLL_DOWN_CHANGE_LEAD));</span>

<span class="nc" id="L242">        map.put(new Actions(Actions.SELECT_FIRST));</span>
<span class="nc" id="L243">        map.put(new Actions(Actions.SELECT_FIRST_CHANGE_LEAD));</span>
<span class="nc" id="L244">        map.put(new Actions(Actions.SELECT_FIRST_EXTEND_SELECTION));</span>

<span class="nc" id="L246">        map.put(new Actions(Actions.SELECT_LAST));</span>
<span class="nc" id="L247">        map.put(new Actions(Actions.SELECT_LAST_CHANGE_LEAD));</span>
<span class="nc" id="L248">        map.put(new Actions(Actions.SELECT_LAST_EXTEND_SELECTION));</span>

<span class="nc" id="L250">        map.put(new Actions(Actions.TOGGLE));</span>

<span class="nc" id="L252">        map.put(new Actions(Actions.CANCEL_EDITING));</span>

<span class="nc" id="L254">        map.put(new Actions(Actions.START_EDITING));</span>

<span class="nc" id="L256">        map.put(new Actions(Actions.SELECT_ALL));</span>

<span class="nc" id="L258">        map.put(new Actions(Actions.CLEAR_SELECTION));</span>

<span class="nc" id="L260">        map.put(new Actions(Actions.SCROLL_LEFT));</span>
<span class="nc" id="L261">        map.put(new Actions(Actions.SCROLL_RIGHT));</span>

<span class="nc" id="L263">        map.put(new Actions(Actions.SCROLL_LEFT_EXTEND_SELECTION));</span>
<span class="nc" id="L264">        map.put(new Actions(Actions.SCROLL_RIGHT_EXTEND_SELECTION));</span>

<span class="nc" id="L266">        map.put(new Actions(Actions.SCROLL_RIGHT_CHANGE_LEAD));</span>
<span class="nc" id="L267">        map.put(new Actions(Actions.SCROLL_LEFT_CHANGE_LEAD));</span>

<span class="nc" id="L269">        map.put(new Actions(Actions.EXPAND));</span>
<span class="nc" id="L270">        map.put(new Actions(Actions.COLLAPSE));</span>
<span class="nc" id="L271">        map.put(new Actions(Actions.MOVE_SELECTION_TO_PARENT));</span>

<span class="nc" id="L273">        map.put(new Actions(Actions.ADD_TO_SELECTION));</span>
<span class="nc" id="L274">        map.put(new Actions(Actions.TOGGLE_AND_ANCHOR));</span>
<span class="nc" id="L275">        map.put(new Actions(Actions.EXTEND_TO));</span>
<span class="nc" id="L276">        map.put(new Actions(Actions.MOVE_SELECTION_TO));</span>

<span class="nc" id="L278">        map.put(TransferHandler.getCutAction());</span>
<span class="nc" id="L279">        map.put(TransferHandler.getCopyAction());</span>
<span class="nc" id="L280">        map.put(TransferHandler.getPasteAction());</span>
<span class="nc" id="L281">    }</span>


    public BasicTreeUI() {
<span class="nc" id="L285">        super();</span>
<span class="nc" id="L286">    }</span>

    protected Color getHashColor() {
<span class="nc" id="L289">        return hashColor;</span>
    }

    protected void setHashColor(Color color) {
<span class="nc" id="L293">        hashColor = color;</span>
<span class="nc" id="L294">    }</span>

    public void setLeftChildIndent(int newAmount) {
<span class="nc" id="L297">        leftChildIndent = newAmount;</span>
<span class="nc" id="L298">        totalChildIndent = leftChildIndent + rightChildIndent;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if(treeState != null)</span>
<span class="nc" id="L300">            treeState.invalidateSizes();</span>
<span class="nc" id="L301">        updateSize();</span>
<span class="nc" id="L302">    }</span>

    public int getLeftChildIndent() {
<span class="nc" id="L305">        return leftChildIndent;</span>
    }

    public void setRightChildIndent(int newAmount) {
<span class="nc" id="L309">        rightChildIndent = newAmount;</span>
<span class="nc" id="L310">        totalChildIndent = leftChildIndent + rightChildIndent;</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if(treeState != null)</span>
<span class="nc" id="L312">            treeState.invalidateSizes();</span>
<span class="nc" id="L313">        updateSize();</span>
<span class="nc" id="L314">    }</span>

    public int getRightChildIndent() {
<span class="nc" id="L317">        return rightChildIndent;</span>
    }

    public void setExpandedIcon(Icon newG) {
<span class="nc" id="L321">        expandedIcon = newG;</span>
<span class="nc" id="L322">    }</span>

    public Icon getExpandedIcon() {
<span class="nc" id="L325">        return expandedIcon;</span>
    }

    public void setCollapsedIcon(Icon newG) {
<span class="nc" id="L329">        collapsedIcon = newG;</span>
<span class="nc" id="L330">    }</span>

    public Icon getCollapsedIcon() {
<span class="nc" id="L333">        return collapsedIcon;</span>
    }

    //
    // Methods for configuring the behavior of the tree. None of them
    // push the value to the JTree instance. You should really only
    // call these methods on the JTree.
    //

    /**
     * Updates the componentListener, if necessary.
     */
    protected void setLargeModel(boolean largeModel) {
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if(getRowHeight() &lt; 1)</span>
<span class="nc" id="L347">            largeModel = false;</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if(this.largeModel != largeModel) {</span>
<span class="nc" id="L349">            completeEditing();</span>
<span class="nc" id="L350">            this.largeModel = largeModel;</span>
<span class="nc" id="L351">            treeState = createLayoutCache();</span>
<span class="nc" id="L352">            configureLayoutCache();</span>
<span class="nc" id="L353">            updateLayoutCacheExpandedNodesIfNecessary();</span>
<span class="nc" id="L354">            updateSize();</span>
        }
<span class="nc" id="L356">    }</span>

    protected boolean isLargeModel() {
<span class="nc" id="L359">        return largeModel;</span>
    }

    /**
     * Sets the row height, this is forwarded to the treeState.
     */
    protected void setRowHeight(int rowHeight) {
<span class="nc" id="L366">        completeEditing();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if(treeState != null) {</span>
<span class="nc" id="L368">            setLargeModel(tree.isLargeModel());</span>
<span class="nc" id="L369">            treeState.setRowHeight(rowHeight);</span>
<span class="nc" id="L370">            updateSize();</span>
        }
<span class="nc" id="L372">    }</span>

    protected int getRowHeight() {
<span class="nc bnc" id="L375" title="All 2 branches missed.">        return (tree == null) ? -1 : tree.getRowHeight();</span>
    }

    /**
     * Sets the TreeCellRenderer to &lt;code&gt;tcr&lt;/code&gt;. This invokes
     * &lt;code&gt;updateRenderer&lt;/code&gt;.
     */
    protected void setCellRenderer(TreeCellRenderer tcr) {
<span class="nc" id="L383">        completeEditing();</span>
<span class="nc" id="L384">        updateRenderer();</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if(treeState != null) {</span>
<span class="nc" id="L386">            treeState.invalidateSizes();</span>
<span class="nc" id="L387">            updateSize();</span>
        }
<span class="nc" id="L389">    }</span>

    /**
     * Return currentCellRenderer, which will either be the trees
     * renderer, or defaultCellRenderer, which ever wasn't null.
     */
    protected TreeCellRenderer getCellRenderer() {
<span class="nc" id="L396">        return currentCellRenderer;</span>
    }

    /**
     * Sets the TreeModel.
     */
    protected void setModel(TreeModel model) {
<span class="nc" id="L403">        completeEditing();</span>
<span class="nc bnc" id="L404" title="All 4 branches missed.">        if(treeModel != null &amp;&amp; treeModelListener != null)</span>
<span class="nc" id="L405">            treeModel.removeTreeModelListener(treeModelListener);</span>
<span class="nc" id="L406">        treeModel = model;</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if(treeModel != null) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if(treeModelListener != null)</span>
<span class="nc" id="L409">                treeModel.addTreeModelListener(treeModelListener);</span>
        }
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if(treeState != null) {</span>
<span class="nc" id="L412">            treeState.setModel(model);</span>
<span class="nc" id="L413">            updateLayoutCacheExpandedNodesIfNecessary();</span>
<span class="nc" id="L414">            updateSize();</span>
        }
<span class="nc" id="L416">    }</span>

    protected TreeModel getModel() {
<span class="nc" id="L419">        return treeModel;</span>
    }

    /**
     * Sets the root to being visible.
     */
    protected void setRootVisible(boolean newValue) {
<span class="nc" id="L426">        completeEditing();</span>
<span class="nc" id="L427">        updateDepthOffset();</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">        if(treeState != null) {</span>
<span class="nc" id="L429">            treeState.setRootVisible(newValue);</span>
<span class="nc" id="L430">            treeState.invalidateSizes();</span>
<span class="nc" id="L431">            updateSize();</span>
        }
<span class="nc" id="L433">    }</span>

    protected boolean isRootVisible() {
<span class="nc bnc" id="L436" title="All 2 branches missed.">        return (tree != null) ? tree.isRootVisible() : false;</span>
    }

    /**
     * Determines whether the node handles are to be displayed.
     */
    protected void setShowsRootHandles(boolean newValue) {
<span class="nc" id="L443">        completeEditing();</span>
<span class="nc" id="L444">        updateDepthOffset();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">        if(treeState != null) {</span>
<span class="nc" id="L446">            treeState.invalidateSizes();</span>
<span class="nc" id="L447">            updateSize();</span>
        }
<span class="nc" id="L449">    }</span>

    protected boolean getShowsRootHandles() {
<span class="nc bnc" id="L452" title="All 2 branches missed.">        return (tree != null) ? tree.getShowsRootHandles() : false;</span>
    }

    /**
     * Sets the cell editor.
     */
    protected void setCellEditor(TreeCellEditor editor) {
<span class="nc" id="L459">        updateCellEditor();</span>
<span class="nc" id="L460">    }</span>

    protected TreeCellEditor getCellEditor() {
<span class="nc bnc" id="L463" title="All 2 branches missed.">        return (tree != null) ? tree.getCellEditor() : null;</span>
    }

    /**
     * Configures the receiver to allow, or not allow, editing.
     */
    protected void setEditable(boolean newValue) {
<span class="nc" id="L470">        updateCellEditor();</span>
<span class="nc" id="L471">    }</span>

    protected boolean isEditable() {
<span class="nc bnc" id="L474" title="All 2 branches missed.">        return (tree != null) ? tree.isEditable() : false;</span>
    }

    /**
     * Resets the selection model. The appropriate listener are installed
     * on the model.
     */
    protected void setSelectionModel(TreeSelectionModel newLSM) {
<span class="nc" id="L482">        completeEditing();</span>
<span class="nc bnc" id="L483" title="All 4 branches missed.">        if(selectionModelPropertyChangeListener != null &amp;&amp;</span>
           treeSelectionModel != null)
<span class="nc" id="L485">            treeSelectionModel.removePropertyChangeListener</span>
<span class="nc" id="L486">                              (selectionModelPropertyChangeListener);</span>
<span class="nc bnc" id="L487" title="All 4 branches missed.">        if(treeSelectionListener != null &amp;&amp; treeSelectionModel != null)</span>
<span class="nc" id="L488">            treeSelectionModel.removeTreeSelectionListener</span>
<span class="nc" id="L489">                               (treeSelectionListener);</span>
<span class="nc" id="L490">        treeSelectionModel = newLSM;</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if(treeSelectionModel != null) {</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if(selectionModelPropertyChangeListener != null)</span>
<span class="nc" id="L493">                treeSelectionModel.addPropertyChangeListener</span>
<span class="nc" id="L494">                              (selectionModelPropertyChangeListener);</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">            if(treeSelectionListener != null)</span>
<span class="nc" id="L496">                treeSelectionModel.addTreeSelectionListener</span>
<span class="nc" id="L497">                                   (treeSelectionListener);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">            if(treeState != null)</span>
<span class="nc" id="L499">                treeState.setSelectionModel(treeSelectionModel);</span>
        }
<span class="nc bnc" id="L501" title="All 2 branches missed.">        else if(treeState != null)</span>
<span class="nc" id="L502">            treeState.setSelectionModel(null);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L504">            tree.repaint();</span>
<span class="nc" id="L505">    }</span>

    protected TreeSelectionModel getSelectionModel() {
<span class="nc" id="L508">        return treeSelectionModel;</span>
    }

    //
    // TreeUI methods
    //

    /**
      * Returns the Rectangle enclosing the label portion that the
      * last item in path will be drawn into.  Will return null if
      * any component in path is currently valid.
      */
    public Rectangle getPathBounds(JTree tree, TreePath path) {
<span class="nc bnc" id="L521" title="All 4 branches missed.">        if(tree != null &amp;&amp; treeState != null) {</span>
<span class="nc" id="L522">            return getPathBounds(path, tree.getInsets(), new Rectangle());</span>
        }
<span class="nc" id="L524">        return null;</span>
    }

    private Rectangle getPathBounds(TreePath path, Insets insets,
                                    Rectangle bounds) {
<span class="nc" id="L529">        bounds = treeState.getBounds(path, bounds);</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        if (bounds != null) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">            if (leftToRight) {</span>
<span class="nc" id="L532">                bounds.x += insets.left;</span>
            } else {
<span class="nc" id="L534">                bounds.x = tree.getWidth() - (bounds.x + bounds.width) -</span>
                        insets.right;
            }
<span class="nc" id="L537">            bounds.y += insets.top;</span>
        }
<span class="nc" id="L539">        return bounds;</span>
    }

    /**
      * Returns the path for passed in row.  If row is not visible
      * null is returned.
      */
    public TreePath getPathForRow(JTree tree, int row) {
<span class="nc bnc" id="L547" title="All 2 branches missed.">        return (treeState != null) ? treeState.getPathForRow(row) : null;</span>
    }

    /**
      * Returns the row that the last item identified in path is visible
      * at.  Will return -1 if any of the elements in path are not
      * currently visible.
      */
    public int getRowForPath(JTree tree, TreePath path) {
<span class="nc bnc" id="L556" title="All 2 branches missed.">        return (treeState != null) ? treeState.getRowForPath(path) : -1;</span>
    }

    /**
      * Returns the number of rows that are being displayed.
      */
    public int getRowCount(JTree tree) {
<span class="nc bnc" id="L563" title="All 2 branches missed.">        return (treeState != null) ? treeState.getRowCount() : 0;</span>
    }

    /**
      * Returns the path to the node that is closest to x,y.  If
      * there is nothing currently visible this will return null, otherwise
      * it'll always return a valid path.  If you need to test if the
      * returned object is exactly at x, y you should get the bounds for
      * the returned path and test x, y against that.
      */
    public TreePath getClosestPathForLocation(JTree tree, int x, int y) {
<span class="nc bnc" id="L574" title="All 4 branches missed.">        if(tree != null &amp;&amp; treeState != null) {</span>
            // TreeState doesn't care about the x location, hence it isn't
            // adjusted
<span class="nc" id="L577">            y -= tree.getInsets().top;</span>
<span class="nc" id="L578">            return treeState.getPathClosestTo(x, y);</span>
        }
<span class="nc" id="L580">        return null;</span>
    }

    /**
      * Returns true if the tree is being edited.  The item that is being
      * edited can be returned by getEditingPath().
      */
    public boolean isEditing(JTree tree) {
<span class="nc bnc" id="L588" title="All 2 branches missed.">        return (editingComponent != null);</span>
    }

    /**
      * Stops the current editing session.  This has no effect if the
      * tree isn't being edited.  Returns true if the editor allows the
      * editing session to stop.
      */
    public boolean stopEditing(JTree tree) {
<span class="nc bnc" id="L597" title="All 4 branches missed.">        if(editingComponent != null &amp;&amp; cellEditor.stopCellEditing()) {</span>
<span class="nc" id="L598">            completeEditing(false, false, true);</span>
<span class="nc" id="L599">            return true;</span>
        }
<span class="nc" id="L601">        return false;</span>
    }

    /**
      * Cancels the current editing session.
      */
    public void cancelEditing(JTree tree) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if(editingComponent != null) {</span>
<span class="nc" id="L609">            completeEditing(false, true, false);</span>
        }
<span class="nc" id="L611">    }</span>

    /**
      * Selects the last item in path and tries to edit it.  Editing will
      * fail if the CellEditor won't allow it for the selected item.
      */
    public void startEditingAtPath(JTree tree, TreePath path) {
<span class="nc" id="L618">        tree.scrollPathToVisible(path);</span>
<span class="nc bnc" id="L619" title="All 4 branches missed.">        if(path != null &amp;&amp; tree.isVisible(path))</span>
<span class="nc" id="L620">            startEditing(path, null);</span>
<span class="nc" id="L621">    }</span>

    /**
     * Returns the path to the element that is being edited.
     */
    public TreePath getEditingPath(JTree tree) {
<span class="nc" id="L627">        return editingPath;</span>
    }

    //
    // Install methods
    //

    public void installUI(JComponent c) {
<span class="nc bnc" id="L635" title="All 2 branches missed.">        if ( c == null ) {</span>
<span class="nc" id="L636">            throw new NullPointerException( &quot;null component passed to BasicTreeUI.installUI()&quot; );</span>
        }

<span class="nc" id="L639">        tree = (JTree)c;</span>

<span class="nc" id="L641">        prepareForUIInstall();</span>

        // Boilerplate install block
<span class="nc" id="L644">        installDefaults();</span>
<span class="nc" id="L645">        installKeyboardActions();</span>
<span class="nc" id="L646">        installComponents();</span>
<span class="nc" id="L647">        installListeners();</span>

<span class="nc" id="L649">        completeUIInstall();</span>
<span class="nc" id="L650">    }</span>

    /**
     * Invoked after the &lt;code&gt;tree&lt;/code&gt; instance variable has been
     * set, but before any defaults/listeners have been installed.
     */
    protected void prepareForUIInstall() {
<span class="nc" id="L657">        drawingCache = new Hashtable&lt;TreePath,Boolean&gt;(7);</span>

        // Data member initializations
<span class="nc" id="L660">        leftToRight = BasicGraphicsUtils.isLeftToRight(tree);</span>
<span class="nc" id="L661">        stopEditingInCompleteEditing = true;</span>
<span class="nc" id="L662">        lastSelectedRow = -1;</span>
<span class="nc" id="L663">        leadRow = -1;</span>
<span class="nc" id="L664">        preferredSize = new Dimension();</span>

<span class="nc" id="L666">        largeModel = tree.isLargeModel();</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">        if(getRowHeight() &lt;= 0)</span>
<span class="nc" id="L668">            largeModel = false;</span>
<span class="nc" id="L669">        setModel(tree.getModel());</span>
<span class="nc" id="L670">    }</span>

    /**
     * Invoked from installUI after all the defaults/listeners have been
     * installed.
     */
    protected void completeUIInstall() {
        // Custom install code

<span class="nc" id="L679">        this.setShowsRootHandles(tree.getShowsRootHandles());</span>

<span class="nc" id="L681">        updateRenderer();</span>

<span class="nc" id="L683">        updateDepthOffset();</span>

<span class="nc" id="L685">        setSelectionModel(tree.getSelectionModel());</span>

        // Create, if necessary, the TreeState instance.
<span class="nc" id="L688">        treeState = createLayoutCache();</span>
<span class="nc" id="L689">        configureLayoutCache();</span>

<span class="nc" id="L691">        updateSize();</span>
<span class="nc" id="L692">    }</span>

    protected void installDefaults() {
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if(tree.getBackground() == null ||</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">           tree.getBackground() instanceof UIResource) {</span>
<span class="nc" id="L697">            tree.setBackground(UIManager.getColor(&quot;Tree.background&quot;));</span>
        }
<span class="nc bnc" id="L699" title="All 4 branches missed.">        if(getHashColor() == null || getHashColor() instanceof UIResource) {</span>
<span class="nc" id="L700">            setHashColor(UIManager.getColor(&quot;Tree.hash&quot;));</span>
        }
<span class="nc bnc" id="L702" title="All 4 branches missed.">        if (tree.getFont() == null || tree.getFont() instanceof UIResource)</span>
<span class="nc" id="L703">            tree.setFont( UIManager.getFont(&quot;Tree.font&quot;) );</span>
        // JTree's original row height is 16.  To correctly display the
        // contents on Linux we should have set it to 18, Windows 19 and
        // Solaris 20.  As these values vary so much it's too hard to
        // be backward compatable and try to update the row height, we're
        // therefor NOT going to adjust the row height based on font.  If the
        // developer changes the font, it's there responsibility to update
        // the row height.

<span class="nc" id="L712">        setExpandedIcon( (Icon)UIManager.get( &quot;Tree.expandedIcon&quot; ) );</span>
<span class="nc" id="L713">        setCollapsedIcon( (Icon)UIManager.get( &quot;Tree.collapsedIcon&quot; ) );</span>

<span class="nc" id="L715">        setLeftChildIndent(((Integer)UIManager.get(&quot;Tree.leftChildIndent&quot;)).</span>
<span class="nc" id="L716">                           intValue());</span>
<span class="nc" id="L717">        setRightChildIndent(((Integer)UIManager.get(&quot;Tree.rightChildIndent&quot;)).</span>
<span class="nc" id="L718">                           intValue());</span>

<span class="nc" id="L720">        LookAndFeel.installProperty(tree, &quot;rowHeight&quot;,</span>
<span class="nc" id="L721">                                    UIManager.get(&quot;Tree.rowHeight&quot;));</span>

<span class="nc bnc" id="L723" title="All 4 branches missed.">        largeModel = (tree.isLargeModel() &amp;&amp; tree.getRowHeight() &gt; 0);</span>

<span class="nc" id="L725">        Object scrollsOnExpand = UIManager.get(&quot;Tree.scrollsOnExpand&quot;);</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if (scrollsOnExpand != null) {</span>
<span class="nc" id="L727">            LookAndFeel.installProperty(tree, &quot;scrollsOnExpand&quot;, scrollsOnExpand);</span>
        }

<span class="nc" id="L730">        paintLines = UIManager.getBoolean(&quot;Tree.paintLines&quot;);</span>
<span class="nc" id="L731">        lineTypeDashed = UIManager.getBoolean(&quot;Tree.lineTypeDashed&quot;);</span>

<span class="nc" id="L733">        Long l = (Long)UIManager.get(&quot;Tree.timeFactor&quot;);</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">        timeFactor = (l!=null) ? l.longValue() : 1000L;</span>

<span class="nc" id="L736">        Object showsRootHandles = UIManager.get(&quot;Tree.showsRootHandles&quot;);</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (showsRootHandles != null) {</span>
<span class="nc" id="L738">            LookAndFeel.installProperty(tree,</span>
                    JTree.SHOWS_ROOT_HANDLES_PROPERTY, showsRootHandles);
        }
<span class="nc" id="L741">    }</span>

    protected void installListeners() {
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if ( (propertyChangeListener = createPropertyChangeListener())</span>
             != null ) {
<span class="nc" id="L746">            tree.addPropertyChangeListener(propertyChangeListener);</span>
        }
<span class="nc bnc" id="L748" title="All 2 branches missed.">        if ( (mouseListener = createMouseListener()) != null ) {</span>
<span class="nc" id="L749">            tree.addMouseListener(mouseListener);</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">            if (mouseListener instanceof MouseMotionListener) {</span>
<span class="nc" id="L751">                tree.addMouseMotionListener((MouseMotionListener)mouseListener);</span>
            }
        }
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if ((focusListener = createFocusListener()) != null ) {</span>
<span class="nc" id="L755">            tree.addFocusListener(focusListener);</span>
        }
<span class="nc bnc" id="L757" title="All 2 branches missed.">        if ((keyListener = createKeyListener()) != null) {</span>
<span class="nc" id="L758">            tree.addKeyListener(keyListener);</span>
        }
<span class="nc bnc" id="L760" title="All 2 branches missed.">        if((treeExpansionListener = createTreeExpansionListener()) != null) {</span>
<span class="nc" id="L761">            tree.addTreeExpansionListener(treeExpansionListener);</span>
        }
<span class="nc bnc" id="L763" title="All 4 branches missed.">        if((treeModelListener = createTreeModelListener()) != null &amp;&amp;</span>
           treeModel != null) {
<span class="nc" id="L765">            treeModel.addTreeModelListener(treeModelListener);</span>
        }
<span class="nc" id="L767">        if((selectionModelPropertyChangeListener =</span>
<span class="nc bnc" id="L768" title="All 4 branches missed.">            createSelectionModelPropertyChangeListener()) != null &amp;&amp;</span>
           treeSelectionModel != null) {
<span class="nc" id="L770">            treeSelectionModel.addPropertyChangeListener</span>
<span class="nc" id="L771">                (selectionModelPropertyChangeListener);</span>
        }
<span class="nc bnc" id="L773" title="All 4 branches missed.">        if((treeSelectionListener = createTreeSelectionListener()) != null &amp;&amp;</span>
           treeSelectionModel != null) {
<span class="nc" id="L775">            treeSelectionModel.addTreeSelectionListener(treeSelectionListener);</span>
        }

<span class="nc" id="L778">        TransferHandler th = tree.getTransferHandler();</span>
<span class="nc bnc" id="L779" title="All 4 branches missed.">        if (th == null || th instanceof UIResource) {</span>
<span class="nc" id="L780">            tree.setTransferHandler(defaultTransferHandler);</span>
            // default TransferHandler doesn't support drop
            // so we don't want drop handling
<span class="nc bnc" id="L783" title="All 2 branches missed.">            if (tree.getDropTarget() instanceof UIResource) {</span>
<span class="nc" id="L784">                tree.setDropTarget(null);</span>
            }
        }

<span class="nc" id="L788">        LookAndFeel.installProperty(tree, &quot;opaque&quot;, Boolean.TRUE);</span>
<span class="nc" id="L789">    }</span>

    protected void installKeyboardActions() {
<span class="nc" id="L792">        InputMap km = getInputMap(JComponent.</span>
                                  WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

<span class="nc" id="L795">        SwingUtilities.replaceUIInputMap(tree, JComponent.</span>
                                         WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,
                                         km);
<span class="nc" id="L798">        km = getInputMap(JComponent.WHEN_FOCUSED);</span>
<span class="nc" id="L799">        SwingUtilities.replaceUIInputMap(tree, JComponent.WHEN_FOCUSED, km);</span>

<span class="nc" id="L801">        LazyActionMap.installLazyActionMap(tree, BasicTreeUI.class,</span>
                                           &quot;Tree.actionMap&quot;);
<span class="nc" id="L803">    }</span>

    InputMap getInputMap(int condition) {
<span class="nc bnc" id="L806" title="All 2 branches missed.">        if (condition == JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT) {</span>
<span class="nc" id="L807">            return (InputMap)DefaultLookup.get(tree, this,</span>
                                               &quot;Tree.ancestorInputMap&quot;);
        }
<span class="nc bnc" id="L810" title="All 2 branches missed.">        else if (condition == JComponent.WHEN_FOCUSED) {</span>
<span class="nc" id="L811">            InputMap keyMap = (InputMap)DefaultLookup.get(tree, this,</span>
                                                      &quot;Tree.focusInputMap&quot;);
            InputMap rtlKeyMap;

<span class="nc bnc" id="L815" title="All 2 branches missed.">            if (tree.getComponentOrientation().isLeftToRight() ||</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">                  ((rtlKeyMap = (InputMap)DefaultLookup.get(tree, this,</span>
                  &quot;Tree.focusInputMap.RightToLeft&quot;)) == null)) {
<span class="nc" id="L818">                return keyMap;</span>
            } else {
<span class="nc" id="L820">                rtlKeyMap.setParent(keyMap);</span>
<span class="nc" id="L821">                return rtlKeyMap;</span>
            }
        }
<span class="nc" id="L824">        return null;</span>
    }

    /**
     * Intalls the subcomponents of the tree, which is the renderer pane.
     */
    protected void installComponents() {
<span class="nc bnc" id="L831" title="All 2 branches missed.">        if ((rendererPane = createCellRendererPane()) != null) {</span>
<span class="nc" id="L832">            tree.add( rendererPane );</span>
        }
<span class="nc" id="L834">    }</span>

    //
    // Create methods.
    //

    /**
     * Creates an instance of NodeDimensions that is able to determine
     * the size of a given node in the tree.
     */
    protected AbstractLayoutCache.NodeDimensions createNodeDimensions() {
<span class="nc" id="L845">        return new NodeDimensionsHandler();</span>
    }

    /**
     * Creates a listener that is responsible that updates the UI based on
     * how the tree changes.
     */
    protected PropertyChangeListener createPropertyChangeListener() {
<span class="nc" id="L853">        return getHandler();</span>
    }

    private Handler getHandler() {
<span class="nc bnc" id="L857" title="All 2 branches missed.">        if (handler == null) {</span>
<span class="nc" id="L858">            handler = new Handler();</span>
        }
<span class="nc" id="L860">        return handler;</span>
    }

    /**
     * Creates the listener responsible for updating the selection based on
     * mouse events.
     */
    protected MouseListener createMouseListener() {
<span class="nc" id="L868">        return getHandler();</span>
    }

    /**
     * Creates a listener that is responsible for updating the display
     * when focus is lost/gained.
     */
    protected FocusListener createFocusListener() {
<span class="nc" id="L876">        return getHandler();</span>
    }

    /**
     * Creates the listener reponsible for getting key events from
     * the tree.
     */
    protected KeyListener createKeyListener() {
<span class="nc" id="L884">        return getHandler();</span>
    }

    /**
     * Creates the listener responsible for getting property change
     * events from the selection model.
     */
    protected PropertyChangeListener createSelectionModelPropertyChangeListener() {
<span class="nc" id="L892">        return getHandler();</span>
    }

    /**
     * Creates the listener that updates the display based on selection change
     * methods.
     */
    protected TreeSelectionListener createTreeSelectionListener() {
<span class="nc" id="L900">        return getHandler();</span>
    }

    /**
     * Creates a listener to handle events from the current editor.
     */
    protected CellEditorListener createCellEditorListener() {
<span class="nc" id="L907">        return getHandler();</span>
    }

    /**
     * Creates and returns a new ComponentHandler. This is used for
     * the large model to mark the validCachedPreferredSize as invalid
     * when the component moves.
     */
    protected ComponentListener createComponentListener() {
<span class="nc" id="L916">        return new ComponentHandler();</span>
    }

    /**
     * Creates and returns the object responsible for updating the treestate
     * when nodes expanded state changes.
     */
    protected TreeExpansionListener createTreeExpansionListener() {
<span class="nc" id="L924">        return getHandler();</span>
    }

    /**
     * Creates the object responsible for managing what is expanded, as
     * well as the size of nodes.
     */
    protected AbstractLayoutCache createLayoutCache() {
<span class="nc bnc" id="L932" title="All 4 branches missed.">        if(isLargeModel() &amp;&amp; getRowHeight() &gt; 0) {</span>
<span class="nc" id="L933">            return new FixedHeightLayoutCache();</span>
        }
<span class="nc" id="L935">        return new VariableHeightLayoutCache();</span>
    }

    /**
     * Returns the renderer pane that renderer components are placed in.
     */
    protected CellRendererPane createCellRendererPane() {
<span class="nc" id="L942">        return new CellRendererPane();</span>
    }

    /**
      * Creates a default cell editor.
      */
    protected TreeCellEditor createDefaultCellEditor() {
<span class="nc bnc" id="L949" title="All 4 branches missed.">        if(currentCellRenderer != null &amp;&amp;</span>
           (currentCellRenderer instanceof DefaultTreeCellRenderer)) {
<span class="nc" id="L951">            DefaultTreeCellEditor editor = new DefaultTreeCellEditor</span>
                        (tree, (DefaultTreeCellRenderer)currentCellRenderer);

<span class="nc" id="L954">            return editor;</span>
        }
<span class="nc" id="L956">        return new DefaultTreeCellEditor(tree, null);</span>
    }

    /**
      * Returns the default cell renderer that is used to do the
      * stamping of each node.
      */
    protected TreeCellRenderer createDefaultCellRenderer() {
<span class="nc" id="L964">        return new DefaultTreeCellRenderer();</span>
    }

    /**
     * Returns a listener that can update the tree when the model changes.
     */
    protected TreeModelListener createTreeModelListener() {
<span class="nc" id="L971">        return getHandler();</span>
    }

    //
    // Uninstall methods
    //

    public void uninstallUI(JComponent c) {
<span class="nc" id="L979">        completeEditing();</span>

<span class="nc" id="L981">        prepareForUIUninstall();</span>

<span class="nc" id="L983">        uninstallDefaults();</span>
<span class="nc" id="L984">        uninstallListeners();</span>
<span class="nc" id="L985">        uninstallKeyboardActions();</span>
<span class="nc" id="L986">        uninstallComponents();</span>

<span class="nc" id="L988">        completeUIUninstall();</span>
<span class="nc" id="L989">    }</span>

    protected void prepareForUIUninstall() {
<span class="nc" id="L992">    }</span>

    protected void completeUIUninstall() {
<span class="nc bnc" id="L995" title="All 2 branches missed.">        if(createdRenderer) {</span>
<span class="nc" id="L996">            tree.setCellRenderer(null);</span>
        }
<span class="nc bnc" id="L998" title="All 2 branches missed.">        if(createdCellEditor) {</span>
<span class="nc" id="L999">            tree.setCellEditor(null);</span>
        }
<span class="nc" id="L1001">        cellEditor = null;</span>
<span class="nc" id="L1002">        currentCellRenderer = null;</span>
<span class="nc" id="L1003">        rendererPane = null;</span>
<span class="nc" id="L1004">        componentListener = null;</span>
<span class="nc" id="L1005">        propertyChangeListener = null;</span>
<span class="nc" id="L1006">        mouseListener = null;</span>
<span class="nc" id="L1007">        focusListener = null;</span>
<span class="nc" id="L1008">        keyListener = null;</span>
<span class="nc" id="L1009">        setSelectionModel(null);</span>
<span class="nc" id="L1010">        treeState = null;</span>
<span class="nc" id="L1011">        drawingCache = null;</span>
<span class="nc" id="L1012">        selectionModelPropertyChangeListener = null;</span>
<span class="nc" id="L1013">        tree = null;</span>
<span class="nc" id="L1014">        treeModel = null;</span>
<span class="nc" id="L1015">        treeSelectionModel = null;</span>
<span class="nc" id="L1016">        treeSelectionListener = null;</span>
<span class="nc" id="L1017">        treeExpansionListener = null;</span>
<span class="nc" id="L1018">    }</span>

    protected void uninstallDefaults() {
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (tree.getTransferHandler() instanceof UIResource) {</span>
<span class="nc" id="L1022">            tree.setTransferHandler(null);</span>
        }
<span class="nc" id="L1024">    }</span>

    protected void uninstallListeners() {
<span class="nc bnc" id="L1027" title="All 2 branches missed.">        if(componentListener != null) {</span>
<span class="nc" id="L1028">            tree.removeComponentListener(componentListener);</span>
        }
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (propertyChangeListener != null) {</span>
<span class="nc" id="L1031">            tree.removePropertyChangeListener(propertyChangeListener);</span>
        }
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (mouseListener != null) {</span>
<span class="nc" id="L1034">            tree.removeMouseListener(mouseListener);</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            if (mouseListener instanceof MouseMotionListener) {</span>
<span class="nc" id="L1036">                tree.removeMouseMotionListener((MouseMotionListener)mouseListener);</span>
            }
        }
<span class="nc bnc" id="L1039" title="All 2 branches missed.">        if (focusListener != null) {</span>
<span class="nc" id="L1040">            tree.removeFocusListener(focusListener);</span>
        }
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        if (keyListener != null) {</span>
<span class="nc" id="L1043">            tree.removeKeyListener(keyListener);</span>
        }
<span class="nc bnc" id="L1045" title="All 2 branches missed.">        if(treeExpansionListener != null) {</span>
<span class="nc" id="L1046">            tree.removeTreeExpansionListener(treeExpansionListener);</span>
        }
<span class="nc bnc" id="L1048" title="All 4 branches missed.">        if(treeModel != null &amp;&amp; treeModelListener != null) {</span>
<span class="nc" id="L1049">            treeModel.removeTreeModelListener(treeModelListener);</span>
        }
<span class="nc bnc" id="L1051" title="All 4 branches missed.">        if(selectionModelPropertyChangeListener != null &amp;&amp;</span>
           treeSelectionModel != null) {
<span class="nc" id="L1053">            treeSelectionModel.removePropertyChangeListener</span>
<span class="nc" id="L1054">                (selectionModelPropertyChangeListener);</span>
        }
<span class="nc bnc" id="L1056" title="All 4 branches missed.">        if(treeSelectionListener != null &amp;&amp; treeSelectionModel != null) {</span>
<span class="nc" id="L1057">            treeSelectionModel.removeTreeSelectionListener</span>
<span class="nc" id="L1058">                               (treeSelectionListener);</span>
        }
<span class="nc" id="L1060">        handler = null;</span>
<span class="nc" id="L1061">    }</span>

    protected void uninstallKeyboardActions() {
<span class="nc" id="L1064">        SwingUtilities.replaceUIActionMap(tree, null);</span>
<span class="nc" id="L1065">        SwingUtilities.replaceUIInputMap(tree, JComponent.</span>
                                         WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,
                                         null);
<span class="nc" id="L1068">        SwingUtilities.replaceUIInputMap(tree, JComponent.WHEN_FOCUSED, null);</span>
<span class="nc" id="L1069">    }</span>

    /**
     * Uninstalls the renderer pane.
     */
    protected void uninstallComponents() {
<span class="nc bnc" id="L1075" title="All 2 branches missed.">        if(rendererPane != null) {</span>
<span class="nc" id="L1076">            tree.remove(rendererPane);</span>
        }
<span class="nc" id="L1078">    }</span>

    /**
     * Recomputes the right margin, and invalidates any tree states
     */
    private void redoTheLayout() {
<span class="nc bnc" id="L1084" title="All 2 branches missed.">        if (treeState != null) {</span>
<span class="nc" id="L1085">            treeState.invalidateSizes();</span>
        }
<span class="nc" id="L1087">    }</span>

    /**
     * Returns the baseline.
     *
     * @throws NullPointerException {@inheritDoc}
     * @throws IllegalArgumentException {@inheritDoc}
     * @see javax.swing.JComponent#getBaseline(int, int)
     * @since 1.6
     */
    public int getBaseline(JComponent c, int width, int height) {
<span class="nc" id="L1098">        super.getBaseline(c, width, height);</span>
<span class="nc" id="L1099">        UIDefaults lafDefaults = UIManager.getLookAndFeelDefaults();</span>
<span class="nc" id="L1100">        Component renderer = (Component)lafDefaults.get(</span>
                BASELINE_COMPONENT_KEY);
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        if (renderer == null) {</span>
<span class="nc" id="L1103">            TreeCellRenderer tcr = createDefaultCellRenderer();</span>
<span class="nc" id="L1104">            renderer = tcr.getTreeCellRendererComponent(</span>
                    tree, &quot;a&quot;, false, false, false, -1, false);
<span class="nc" id="L1106">            lafDefaults.put(BASELINE_COMPONENT_KEY, renderer);</span>
        }
<span class="nc" id="L1108">        int rowHeight = tree.getRowHeight();</span>
        int baseline;
<span class="nc bnc" id="L1110" title="All 2 branches missed.">        if (rowHeight &gt; 0) {</span>
<span class="nc" id="L1111">            baseline = renderer.getBaseline(Integer.MAX_VALUE, rowHeight);</span>
        }
        else {
<span class="nc" id="L1114">            Dimension pref = renderer.getPreferredSize();</span>
<span class="nc" id="L1115">            baseline = renderer.getBaseline(pref.width, pref.height);</span>
        }
<span class="nc" id="L1117">        return baseline + tree.getInsets().top;</span>
    }

    /**
     * Returns an enum indicating how the baseline of the component
     * changes as the size changes.
     *
     * @throws NullPointerException {@inheritDoc}
     * @see javax.swing.JComponent#getBaseline(int, int)
     * @since 1.6
     */
    public Component.BaselineResizeBehavior getBaselineResizeBehavior(
            JComponent c) {
<span class="nc" id="L1130">        super.getBaselineResizeBehavior(c);</span>
<span class="nc" id="L1131">        return Component.BaselineResizeBehavior.CONSTANT_ASCENT;</span>
    }

    //
    // Painting routines.
    //

    public void paint(Graphics g, JComponent c) {
<span class="nc bnc" id="L1139" title="All 2 branches missed.">        if (tree != c) {</span>
<span class="nc" id="L1140">            throw new InternalError(&quot;incorrect component&quot;);</span>
        }

        // Should never happen if installed for a UI
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        if(treeState == null) {</span>
<span class="nc" id="L1145">            return;</span>
        }

<span class="nc" id="L1148">        Rectangle        paintBounds = g.getClipBounds();</span>
<span class="nc" id="L1149">        Insets           insets = tree.getInsets();</span>
<span class="nc" id="L1150">        TreePath         initialPath = getClosestPathForLocation</span>
<span class="nc" id="L1151">                                       (tree, 0, paintBounds.y);</span>
<span class="nc" id="L1152">        Enumeration      paintingEnumerator = treeState.getVisiblePathsFrom</span>
<span class="nc" id="L1153">                                              (initialPath);</span>
<span class="nc" id="L1154">        int              row = treeState.getRowForPath(initialPath);</span>
<span class="nc" id="L1155">        int              endY = paintBounds.y + paintBounds.height;</span>

<span class="nc" id="L1157">        drawingCache.clear();</span>

<span class="nc bnc" id="L1159" title="All 4 branches missed.">        if(initialPath != null &amp;&amp; paintingEnumerator != null) {</span>
<span class="nc" id="L1160">            TreePath   parentPath = initialPath;</span>

            // Draw the lines, knobs, and rows

            // Find each parent and have them draw a line to their last child
<span class="nc" id="L1165">            parentPath = parentPath.getParentPath();</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">            while(parentPath != null) {</span>
<span class="nc" id="L1167">                paintVerticalPartOfLeg(g, paintBounds, insets, parentPath);</span>
<span class="nc" id="L1168">                drawingCache.put(parentPath, Boolean.TRUE);</span>
<span class="nc" id="L1169">                parentPath = parentPath.getParentPath();</span>
            }

<span class="nc" id="L1172">            boolean         done = false;</span>
            // Information for the node being rendered.
            boolean         isExpanded;
            boolean         hasBeenExpanded;
            boolean         isLeaf;
<span class="nc" id="L1177">            Rectangle       boundsBuffer = new Rectangle();</span>
            Rectangle       bounds;
            TreePath        path;
<span class="nc" id="L1180">            boolean         rootVisible = isRootVisible();</span>

<span class="nc bnc" id="L1182" title="All 4 branches missed.">            while(!done &amp;&amp; paintingEnumerator.hasMoreElements()) {</span>
<span class="nc" id="L1183">                path = (TreePath)paintingEnumerator.nextElement();</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">                if(path != null) {</span>
<span class="nc" id="L1185">                    isLeaf = treeModel.isLeaf(path.getLastPathComponent());</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">                    if(isLeaf)</span>
<span class="nc" id="L1187">                        isExpanded = hasBeenExpanded = false;</span>
                    else {
<span class="nc" id="L1189">                        isExpanded = treeState.getExpandedState(path);</span>
<span class="nc" id="L1190">                        hasBeenExpanded = tree.hasBeenExpanded(path);</span>
                    }
<span class="nc" id="L1192">                    bounds = getPathBounds(path, insets, boundsBuffer);</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">                    if(bounds == null)</span>
                        // This will only happen if the model changes out
                        // from under us (usually in another thread).
                        // Swing isn't multithreaded, but I'll put this
                        // check in anyway.
<span class="nc" id="L1198">                        return;</span>
                    // See if the vertical line to the parent has been drawn.
<span class="nc" id="L1200">                    parentPath = path.getParentPath();</span>
<span class="nc bnc" id="L1201" title="All 2 branches missed.">                    if(parentPath != null) {</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">                        if(drawingCache.get(parentPath) == null) {</span>
<span class="nc" id="L1203">                            paintVerticalPartOfLeg(g, paintBounds,</span>
                                                   insets, parentPath);
<span class="nc" id="L1205">                            drawingCache.put(parentPath, Boolean.TRUE);</span>
                        }
<span class="nc" id="L1207">                        paintHorizontalPartOfLeg(g, paintBounds, insets,</span>
                                                 bounds, path, row,
                                                 isExpanded,
                                                 hasBeenExpanded, isLeaf);
                    }
<span class="nc bnc" id="L1212" title="All 4 branches missed.">                    else if(rootVisible &amp;&amp; row == 0) {</span>
<span class="nc" id="L1213">                        paintHorizontalPartOfLeg(g, paintBounds, insets,</span>
                                                 bounds, path, row,
                                                 isExpanded,
                                                 hasBeenExpanded, isLeaf);
                    }
<span class="nc bnc" id="L1218" title="All 2 branches missed.">                    if(shouldPaintExpandControl(path, row, isExpanded,</span>
                                                hasBeenExpanded, isLeaf)) {
<span class="nc" id="L1220">                        paintExpandControl(g, paintBounds, insets, bounds,</span>
                                           path, row, isExpanded,
                                           hasBeenExpanded, isLeaf);
                    }
<span class="nc" id="L1224">                    paintRow(g, paintBounds, insets, bounds, path,</span>
                                 row, isExpanded, hasBeenExpanded, isLeaf);
<span class="nc bnc" id="L1226" title="All 2 branches missed.">                    if((bounds.y + bounds.height) &gt;= endY)</span>
<span class="nc" id="L1227">                        done = true;</span>
                }
                else {
<span class="nc" id="L1230">                    done = true;</span>
                }
<span class="nc" id="L1232">                row++;</span>
            }
        }

<span class="nc" id="L1236">        paintDropLine(g);</span>

        // Empty out the renderer pane, allowing renderers to be gc'ed.
<span class="nc" id="L1239">        rendererPane.removeAll();</span>

<span class="nc" id="L1241">        drawingCache.clear();</span>
<span class="nc" id="L1242">    }</span>

    /**
     * Tells if a {@code DropLocation} should be indicated by a line between
     * nodes. This is meant for {@code javax.swing.DropMode.INSERT} and
     * {@code javax.swing.DropMode.ON_OR_INSERT} drop modes.
     *
     * @param loc a {@code DropLocation}
     * @return {@code true} if the drop location should be shown as a line
     * @since 1.7
     */
    protected boolean isDropLine(JTree.DropLocation loc) {
<span class="nc bnc" id="L1254" title="All 6 branches missed.">        return loc != null &amp;&amp; loc.getPath() != null &amp;&amp; loc.getChildIndex() != -1;</span>
    }

    /**
     * Paints the drop line.
     *
     * @param g {@code Graphics} object to draw on
     * @since 1.7
     */
    protected void paintDropLine(Graphics g) {
<span class="nc" id="L1264">        JTree.DropLocation loc = tree.getDropLocation();</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">        if (!isDropLine(loc)) {</span>
<span class="nc" id="L1266">            return;</span>
        }

<span class="nc" id="L1269">        Color c = UIManager.getColor(&quot;Tree.dropLineColor&quot;);</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L1271">            g.setColor(c);</span>
<span class="nc" id="L1272">            Rectangle rect = getDropLineRect(loc);</span>
<span class="nc" id="L1273">            g.fillRect(rect.x, rect.y, rect.width, rect.height);</span>
        }
<span class="nc" id="L1275">    }</span>

    /**
     * Returns a unbounding box for the drop line.
     *
     * @param loc a {@code DropLocation}
     * @return bounding box for the drop line
     * @since 1.7
     */
    protected Rectangle getDropLineRect(JTree.DropLocation loc) {
        Rectangle rect;
<span class="nc" id="L1286">        TreePath path = loc.getPath();</span>
<span class="nc" id="L1287">        int index = loc.getChildIndex();</span>
<span class="nc" id="L1288">        boolean ltr = leftToRight;</span>

<span class="nc" id="L1290">        Insets insets = tree.getInsets();</span>

<span class="nc bnc" id="L1292" title="All 2 branches missed.">        if (tree.getRowCount() == 0) {</span>
<span class="nc" id="L1293">            rect = new Rectangle(insets.left,</span>
                                 insets.top,
<span class="nc" id="L1295">                                 tree.getWidth() - insets.left - insets.right,</span>
                                 0);
        } else {
<span class="nc" id="L1298">            TreeModel model = getModel();</span>
<span class="nc" id="L1299">            Object root = model.getRoot();</span>

<span class="nc bnc" id="L1301" title="All 2 branches missed.">            if (path.getLastPathComponent() == root</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">                    &amp;&amp; index &gt;= model.getChildCount(root)) {</span>

<span class="nc" id="L1304">                rect = tree.getRowBounds(tree.getRowCount() - 1);</span>
<span class="nc" id="L1305">                rect.y = rect.y + rect.height;</span>
                Rectangle xRect;

<span class="nc bnc" id="L1308" title="All 2 branches missed.">                if (!tree.isRootVisible()) {</span>
<span class="nc" id="L1309">                    xRect = tree.getRowBounds(0);</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">                } else if (model.getChildCount(root) == 0){</span>
<span class="nc" id="L1311">                    xRect = tree.getRowBounds(0);</span>
<span class="nc" id="L1312">                    xRect.x += totalChildIndent;</span>
<span class="nc" id="L1313">                    xRect.width -= totalChildIndent + totalChildIndent;</span>
                } else {
<span class="nc" id="L1315">                    TreePath lastChildPath = path.pathByAddingChild(</span>
<span class="nc" id="L1316">                        model.getChild(root, model.getChildCount(root) - 1));</span>
<span class="nc" id="L1317">                    xRect = tree.getPathBounds(lastChildPath);</span>
                }

<span class="nc" id="L1320">                rect.x = xRect.x;</span>
<span class="nc" id="L1321">                rect.width = xRect.width;</span>
<span class="nc" id="L1322">            } else {</span>
<span class="nc" id="L1323">                rect = tree.getPathBounds(path.pathByAddingChild(</span>
<span class="nc" id="L1324">                    model.getChild(path.getLastPathComponent(), index)));</span>
            }
        }

<span class="nc bnc" id="L1328" title="All 2 branches missed.">        if (rect.y != 0) {</span>
<span class="nc" id="L1329">            rect.y--;</span>
        }

<span class="nc bnc" id="L1332" title="All 2 branches missed.">        if (!ltr) {</span>
<span class="nc" id="L1333">            rect.x = rect.x + rect.width - 100;</span>
        }

<span class="nc" id="L1336">        rect.width = 100;</span>
<span class="nc" id="L1337">        rect.height = 2;</span>

<span class="nc" id="L1339">        return rect;</span>
    }

    /**
     * Paints the horizontal part of the leg. The receiver should
     * NOT modify &lt;code&gt;clipBounds&lt;/code&gt;, or &lt;code&gt;insets&lt;/code&gt;.&lt;p&gt;
     * NOTE: &lt;code&gt;parentRow&lt;/code&gt; can be -1 if the root is not visible.
     */
    protected void paintHorizontalPartOfLeg(Graphics g, Rectangle clipBounds,
                                            Insets insets, Rectangle bounds,
                                            TreePath path, int row,
                                            boolean isExpanded,
                                            boolean hasBeenExpanded, boolean
                                            isLeaf) {
<span class="nc bnc" id="L1353" title="All 2 branches missed.">        if (!paintLines) {</span>
<span class="nc" id="L1354">            return;</span>
        }

        // Don't paint the legs for the root'ish node if the
<span class="nc" id="L1358">        int depth = path.getPathCount() - 1;</span>
<span class="nc bnc" id="L1359" title="All 6 branches missed.">        if((depth == 0 || (depth == 1 &amp;&amp; !isRootVisible())) &amp;&amp;</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">           !getShowsRootHandles()) {</span>
<span class="nc" id="L1361">            return;</span>
        }

<span class="nc" id="L1364">        int clipLeft = clipBounds.x;</span>
<span class="nc" id="L1365">        int clipRight = clipBounds.x + clipBounds.width;</span>
<span class="nc" id="L1366">        int clipTop = clipBounds.y;</span>
<span class="nc" id="L1367">        int clipBottom = clipBounds.y + clipBounds.height;</span>
<span class="nc" id="L1368">        int lineY = bounds.y + bounds.height / 2;</span>

<span class="nc bnc" id="L1370" title="All 2 branches missed.">        if (leftToRight) {</span>
<span class="nc" id="L1371">            int leftX = bounds.x - getRightChildIndent();</span>
<span class="nc" id="L1372">            int nodeX = bounds.x - getHorizontalLegBuffer();</span>

<span class="nc bnc" id="L1374" title="All 10 branches missed.">            if(lineY &gt;= clipTop</span>
                    &amp;&amp; lineY &lt; clipBottom
                    &amp;&amp; nodeX &gt;= clipLeft
                    &amp;&amp; leftX &lt; clipRight
                    &amp;&amp; leftX &lt; nodeX) {

<span class="nc" id="L1380">                g.setColor(getHashColor());</span>
<span class="nc" id="L1381">                paintHorizontalLine(g, tree, lineY, leftX, nodeX - 1);</span>
            }
<span class="nc" id="L1383">        } else {</span>
<span class="nc" id="L1384">            int nodeX = bounds.x + bounds.width + getHorizontalLegBuffer();</span>
<span class="nc" id="L1385">            int rightX = bounds.x + bounds.width + getRightChildIndent();</span>

<span class="nc bnc" id="L1387" title="All 10 branches missed.">            if(lineY &gt;= clipTop</span>
                    &amp;&amp; lineY &lt; clipBottom
                    &amp;&amp; rightX &gt;= clipLeft
                    &amp;&amp; nodeX &lt; clipRight
                    &amp;&amp; nodeX &lt; rightX) {

<span class="nc" id="L1393">                g.setColor(getHashColor());</span>
<span class="nc" id="L1394">                paintHorizontalLine(g, tree, lineY, nodeX, rightX - 1);</span>
            }
        }
<span class="nc" id="L1397">    }</span>

    /**
     * Paints the vertical part of the leg. The receiver should
     * NOT modify &lt;code&gt;clipBounds&lt;/code&gt;, &lt;code&gt;insets&lt;/code&gt;.&lt;p&gt;
     */
    protected void paintVerticalPartOfLeg(Graphics g, Rectangle clipBounds,
                                          Insets insets, TreePath path) {
<span class="nc bnc" id="L1405" title="All 2 branches missed.">        if (!paintLines) {</span>
<span class="nc" id="L1406">            return;</span>
        }

<span class="nc" id="L1409">        int depth = path.getPathCount() - 1;</span>
<span class="nc bnc" id="L1410" title="All 6 branches missed.">        if (depth == 0 &amp;&amp; !getShowsRootHandles() &amp;&amp; !isRootVisible()) {</span>
<span class="nc" id="L1411">            return;</span>
        }
<span class="nc" id="L1413">        int lineX = getRowX(-1, depth + 1);</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">        if (leftToRight) {</span>
<span class="nc" id="L1415">            lineX = lineX - getRightChildIndent() + insets.left;</span>
        }
        else {
<span class="nc" id="L1418">            lineX = tree.getWidth() - lineX - insets.right +</span>
<span class="nc" id="L1419">                    getRightChildIndent() - 1;</span>
        }
<span class="nc" id="L1421">        int clipLeft = clipBounds.x;</span>
<span class="nc" id="L1422">        int clipRight = clipBounds.x + (clipBounds.width - 1);</span>

<span class="nc bnc" id="L1424" title="All 4 branches missed.">        if (lineX &gt;= clipLeft &amp;&amp; lineX &lt;= clipRight) {</span>
<span class="nc" id="L1425">            int clipTop = clipBounds.y;</span>
<span class="nc" id="L1426">            int clipBottom = clipBounds.y + clipBounds.height;</span>
<span class="nc" id="L1427">            Rectangle parentBounds = getPathBounds(tree, path);</span>
<span class="nc" id="L1428">            Rectangle lastChildBounds = getPathBounds(tree,</span>
<span class="nc" id="L1429">                                                     getLastChildPath(path));</span>

<span class="nc bnc" id="L1431" title="All 2 branches missed.">            if(lastChildBounds == null)</span>
                // This shouldn't happen, but if the model is modified
                // in another thread it is possible for this to happen.
                // Swing isn't multithreaded, but I'll add this check in
                // anyway.
<span class="nc" id="L1436">                return;</span>

            int       top;

<span class="nc bnc" id="L1440" title="All 2 branches missed.">            if(parentBounds == null) {</span>
<span class="nc" id="L1441">                top = Math.max(insets.top + getVerticalLegBuffer(),</span>
                               clipTop);
            }
            else
<span class="nc" id="L1445">                top = Math.max(parentBounds.y + parentBounds.height +</span>
<span class="nc" id="L1446">                               getVerticalLegBuffer(), clipTop);</span>
<span class="nc bnc" id="L1447" title="All 4 branches missed.">            if(depth == 0 &amp;&amp; !isRootVisible()) {</span>
<span class="nc" id="L1448">                TreeModel      model = getModel();</span>

<span class="nc bnc" id="L1450" title="All 2 branches missed.">                if(model != null) {</span>
<span class="nc" id="L1451">                    Object        root = model.getRoot();</span>

<span class="nc bnc" id="L1453" title="All 2 branches missed.">                    if(model.getChildCount(root) &gt; 0) {</span>
<span class="nc" id="L1454">                        parentBounds = getPathBounds(tree, path.</span>
<span class="nc" id="L1455">                                  pathByAddingChild(model.getChild(root, 0)));</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">                        if(parentBounds != null)</span>
<span class="nc" id="L1457">                            top = Math.max(insets.top + getVerticalLegBuffer(),</span>
                                           parentBounds.y +
                                           parentBounds.height / 2);
                    }
                }
            }

<span class="nc" id="L1464">            int bottom = Math.min(lastChildBounds.y +</span>
                                  (lastChildBounds.height / 2), clipBottom);

<span class="nc bnc" id="L1467" title="All 2 branches missed.">            if (top &lt;= bottom) {</span>
<span class="nc" id="L1468">                g.setColor(getHashColor());</span>
<span class="nc" id="L1469">                paintVerticalLine(g, tree, lineX, top, bottom);</span>
            }
        }
<span class="nc" id="L1472">    }</span>

    /**
     * Paints the expand (toggle) part of a row. The receiver should
     * NOT modify &lt;code&gt;clipBounds&lt;/code&gt;, or &lt;code&gt;insets&lt;/code&gt;.
     */
    protected void paintExpandControl(Graphics g,
                                      Rectangle clipBounds, Insets insets,
                                      Rectangle bounds, TreePath path,
                                      int row, boolean isExpanded,
                                      boolean hasBeenExpanded,
                                      boolean isLeaf) {
<span class="nc" id="L1484">        Object       value = path.getLastPathComponent();</span>

        // Draw icons if not a leaf and either hasn't been loaded,
        // or the model child count is &gt; 0.
<span class="nc bnc" id="L1488" title="All 4 branches missed.">        if (!isLeaf &amp;&amp; (!hasBeenExpanded ||</span>
<span class="nc bnc" id="L1489" title="All 2 branches missed.">                        treeModel.getChildCount(value) &gt; 0)) {</span>
            int middleXOfKnob;
<span class="nc bnc" id="L1491" title="All 2 branches missed.">            if (leftToRight) {</span>
<span class="nc" id="L1492">                middleXOfKnob = bounds.x - getRightChildIndent() + 1;</span>
            } else {
<span class="nc" id="L1494">                middleXOfKnob = bounds.x + bounds.width + getRightChildIndent() - 1;</span>
            }
<span class="nc" id="L1496">            int middleYOfKnob = bounds.y + (bounds.height / 2);</span>

<span class="nc bnc" id="L1498" title="All 2 branches missed.">            if (isExpanded) {</span>
<span class="nc" id="L1499">                Icon expandedIcon = getExpandedIcon();</span>
<span class="nc bnc" id="L1500" title="All 2 branches missed.">                if(expandedIcon != null)</span>
<span class="nc" id="L1501">                  drawCentered(tree, g, expandedIcon, middleXOfKnob,</span>
                               middleYOfKnob );
<span class="nc" id="L1503">            }</span>
            else {
<span class="nc" id="L1505">                Icon collapsedIcon = getCollapsedIcon();</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">                if(collapsedIcon != null)</span>
<span class="nc" id="L1507">                  drawCentered(tree, g, collapsedIcon, middleXOfKnob,</span>
                               middleYOfKnob);
            }
        }
<span class="nc" id="L1511">    }</span>

    /**
     * Paints the renderer part of a row. The receiver should
     * NOT modify &lt;code&gt;clipBounds&lt;/code&gt;, or &lt;code&gt;insets&lt;/code&gt;.
     */
    protected void paintRow(Graphics g, Rectangle clipBounds,
                            Insets insets, Rectangle bounds, TreePath path,
                            int row, boolean isExpanded,
                            boolean hasBeenExpanded, boolean isLeaf) {
        // Don't paint the renderer if editing this row.
<span class="nc bnc" id="L1522" title="All 4 branches missed.">        if(editingComponent != null &amp;&amp; editingRow == row)</span>
<span class="nc" id="L1523">            return;</span>

        int leadIndex;

<span class="nc bnc" id="L1527" title="All 2 branches missed.">        if(tree.hasFocus()) {</span>
<span class="nc" id="L1528">            leadIndex = getLeadSelectionRow();</span>
        }
        else
<span class="nc" id="L1531">            leadIndex = -1;</span>

        Component component;

<span class="nc" id="L1535">        component = currentCellRenderer.getTreeCellRendererComponent</span>
<span class="nc" id="L1536">                      (tree, path.getLastPathComponent(),</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">                       tree.isRowSelected(row), isExpanded, isLeaf, row,</span>
                       (leadIndex == row));

<span class="nc" id="L1540">        rendererPane.paintComponent(g, component, tree, bounds.x, bounds.y,</span>
                                    bounds.width, bounds.height, true);
<span class="nc" id="L1542">    }</span>

    /**
     * Returns true if the expand (toggle) control should be drawn for
     * the specified row.
     */
    protected boolean shouldPaintExpandControl(TreePath path, int row,
                                               boolean isExpanded,
                                               boolean hasBeenExpanded,
                                               boolean isLeaf) {
<span class="nc bnc" id="L1552" title="All 2 branches missed.">        if(isLeaf)</span>
<span class="nc" id="L1553">            return false;</span>

<span class="nc" id="L1555">        int              depth = path.getPathCount() - 1;</span>

<span class="nc bnc" id="L1557" title="All 6 branches missed.">        if((depth == 0 || (depth == 1 &amp;&amp; !isRootVisible())) &amp;&amp;</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">           !getShowsRootHandles())</span>
<span class="nc" id="L1559">            return false;</span>
<span class="nc" id="L1560">        return true;</span>
    }

    /**
     * Paints a vertical line.
     */
    protected void paintVerticalLine(Graphics g, JComponent c, int x, int top,
                                    int bottom) {
<span class="nc bnc" id="L1568" title="All 2 branches missed.">        if (lineTypeDashed) {</span>
<span class="nc" id="L1569">            drawDashedVerticalLine(g, x, top, bottom);</span>
        } else {
<span class="nc" id="L1571">            g.drawLine(x, top, x, bottom);</span>
        }
<span class="nc" id="L1573">    }</span>

    /**
     * Paints a horizontal line.
     */
    protected void paintHorizontalLine(Graphics g, JComponent c, int y,
                                      int left, int right) {
<span class="nc bnc" id="L1580" title="All 2 branches missed.">        if (lineTypeDashed) {</span>
<span class="nc" id="L1581">            drawDashedHorizontalLine(g, y, left, right);</span>
        } else {
<span class="nc" id="L1583">            g.drawLine(left, y, right, y);</span>
        }
<span class="nc" id="L1585">    }</span>

    /**
     * The vertical element of legs between nodes starts at the bottom of the
     * parent node by default.  This method makes the leg start below that.
     */
    protected int getVerticalLegBuffer() {
<span class="nc" id="L1592">        return 0;</span>
    }

    /**
     * The horizontal element of legs between nodes starts at the
     * right of the left-hand side of the child node by default.  This
     * method makes the leg end before that.
     */
    protected int getHorizontalLegBuffer() {
<span class="nc" id="L1601">        return 0;</span>
    }

    private int findCenteredX(int x, int iconWidth) {
<span class="nc bnc" id="L1605" title="All 2 branches missed.">        return leftToRight</span>
<span class="nc" id="L1606">               ? x - (int)Math.ceil(iconWidth / 2.0)</span>
<span class="nc" id="L1607">               : x - (int)Math.floor(iconWidth / 2.0);</span>
    }

    //
    // Generic painting methods
    //

    // Draws the icon centered at (x,y)
    protected void drawCentered(Component c, Graphics graphics, Icon icon,
                                int x, int y) {
<span class="nc" id="L1617">        icon.paintIcon(c, graphics,</span>
<span class="nc" id="L1618">                      findCenteredX(x, icon.getIconWidth()),</span>
<span class="nc" id="L1619">                      y - icon.getIconHeight() / 2);</span>
<span class="nc" id="L1620">    }</span>

    // This method is slow -- revisit when Java2D is ready.
    // assumes x1 &lt;= x2
    protected void drawDashedHorizontalLine(Graphics g, int y, int x1, int x2){
        // Drawing only even coordinates helps join line segments so they
        // appear as one line.  This can be defeated by translating the
        // Graphics by an odd amount.
<span class="nc" id="L1628">        x1 += (x1 % 2);</span>

<span class="nc bnc" id="L1630" title="All 2 branches missed.">        for (int x = x1; x &lt;= x2; x+=2) {</span>
<span class="nc" id="L1631">            g.drawLine(x, y, x, y);</span>
        }
<span class="nc" id="L1633">    }</span>

    // This method is slow -- revisit when Java2D is ready.
    // assumes y1 &lt;= y2
    protected void drawDashedVerticalLine(Graphics g, int x, int y1, int y2) {
        // Drawing only even coordinates helps join line segments so they
        // appear as one line.  This can be defeated by translating the
        // Graphics by an odd amount.
<span class="nc" id="L1641">        y1 += (y1 % 2);</span>

<span class="nc bnc" id="L1643" title="All 2 branches missed.">        for (int y = y1; y &lt;= y2; y+=2) {</span>
<span class="nc" id="L1644">            g.drawLine(x, y, x, y);</span>
        }
<span class="nc" id="L1646">    }</span>

    //
    // Various local methods
    //

    /**
     * Returns the location, along the x-axis, to render a particular row
     * at. The return value does not include any Insets specified on the JTree.
     * This does not check for the validity of the row or depth, it is assumed
     * to be correct and will not throw an Exception if the row or depth
     * doesn't match that of the tree.
     *
     * @param row Row to return x location for
     * @param depth Depth of the row
     * @return amount to indent the given row.
     * @since 1.5
     */
    protected int getRowX(int row, int depth) {
<span class="nc" id="L1665">        return totalChildIndent * (depth + depthOffset);</span>
    }

    /**
     * Makes all the nodes that are expanded in JTree expanded in LayoutCache.
     * This invokes updateExpandedDescendants with the root path.
     */
    protected void updateLayoutCacheExpandedNodes() {
<span class="nc bnc" id="L1673" title="All 4 branches missed.">        if(treeModel != null &amp;&amp; treeModel.getRoot() != null)</span>
<span class="nc" id="L1674">            updateExpandedDescendants(new TreePath(treeModel.getRoot()));</span>
<span class="nc" id="L1675">    }</span>

    private void updateLayoutCacheExpandedNodesIfNecessary() {
<span class="nc bnc" id="L1678" title="All 4 branches missed.">        if (treeModel != null &amp;&amp; treeModel.getRoot() != null) {</span>
<span class="nc" id="L1679">            TreePath rootPath = new TreePath(treeModel.getRoot());</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">            if (tree.isExpanded(rootPath)) {</span>
<span class="nc" id="L1681">                updateLayoutCacheExpandedNodes();</span>
            } else {
<span class="nc" id="L1683">                treeState.setExpandedState(rootPath, false);</span>
            }
        }
<span class="nc" id="L1686">    }</span>

    /**
     * Updates the expanded state of all the descendants of &lt;code&gt;path&lt;/code&gt;
     * by getting the expanded descendants from the tree and forwarding
     * to the tree state.
     */
    protected void updateExpandedDescendants(TreePath path) {
<span class="nc" id="L1694">        completeEditing();</span>
<span class="nc bnc" id="L1695" title="All 2 branches missed.">        if(treeState != null) {</span>
<span class="nc" id="L1696">            treeState.setExpandedState(path, true);</span>

<span class="nc" id="L1698">            Enumeration   descendants = tree.getExpandedDescendants(path);</span>

<span class="nc bnc" id="L1700" title="All 2 branches missed.">            if(descendants != null) {</span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">                while(descendants.hasMoreElements()) {</span>
<span class="nc" id="L1702">                    path = (TreePath)descendants.nextElement();</span>
<span class="nc" id="L1703">                    treeState.setExpandedState(path, true);</span>
                }
            }
<span class="nc" id="L1706">            updateLeadSelectionRow();</span>
<span class="nc" id="L1707">            updateSize();</span>
        }
<span class="nc" id="L1709">    }</span>

    /**
     * Returns a path to the last child of &lt;code&gt;parent&lt;/code&gt;.
     */
    protected TreePath getLastChildPath(TreePath parent) {
<span class="nc bnc" id="L1715" title="All 2 branches missed.">        if(treeModel != null) {</span>
<span class="nc" id="L1716">            int         childCount = treeModel.getChildCount</span>
<span class="nc" id="L1717">                (parent.getLastPathComponent());</span>

<span class="nc bnc" id="L1719" title="All 2 branches missed.">            if(childCount &gt; 0)</span>
<span class="nc" id="L1720">                return parent.pathByAddingChild(treeModel.getChild</span>
<span class="nc" id="L1721">                           (parent.getLastPathComponent(), childCount - 1));</span>
        }
<span class="nc" id="L1723">        return null;</span>
    }

    /**
     * Updates how much each depth should be offset by.
     */
    protected void updateDepthOffset() {
<span class="nc bnc" id="L1730" title="All 2 branches missed.">        if(isRootVisible()) {</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">            if(getShowsRootHandles())</span>
<span class="nc" id="L1732">                depthOffset = 1;</span>
            else
<span class="nc" id="L1734">                depthOffset = 0;</span>
        }
<span class="nc bnc" id="L1736" title="All 2 branches missed.">        else if(!getShowsRootHandles())</span>
<span class="nc" id="L1737">            depthOffset = -1;</span>
        else
<span class="nc" id="L1739">            depthOffset = 0;</span>
<span class="nc" id="L1740">    }</span>

    /**
      * Updates the cellEditor based on the editability of the JTree that
      * we're contained in.  If the tree is editable but doesn't have a
      * cellEditor, a basic one will be used.
      */
    protected void updateCellEditor() {
        TreeCellEditor        newEditor;

<span class="nc" id="L1750">        completeEditing();</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">        if(tree == null)</span>
<span class="nc" id="L1752">            newEditor = null;</span>
        else {
<span class="nc bnc" id="L1754" title="All 2 branches missed.">            if(tree.isEditable()) {</span>
<span class="nc" id="L1755">                newEditor = tree.getCellEditor();</span>
<span class="nc bnc" id="L1756" title="All 2 branches missed.">                if(newEditor == null) {</span>
<span class="nc" id="L1757">                    newEditor = createDefaultCellEditor();</span>
<span class="nc bnc" id="L1758" title="All 2 branches missed.">                    if(newEditor != null) {</span>
<span class="nc" id="L1759">                        tree.setCellEditor(newEditor);</span>
<span class="nc" id="L1760">                        createdCellEditor = true;</span>
                    }
                }
            }
            else
<span class="nc" id="L1765">                newEditor = null;</span>
        }
<span class="nc bnc" id="L1767" title="All 2 branches missed.">        if(newEditor != cellEditor) {</span>
<span class="nc bnc" id="L1768" title="All 4 branches missed.">            if(cellEditor != null &amp;&amp; cellEditorListener != null)</span>
<span class="nc" id="L1769">                cellEditor.removeCellEditorListener(cellEditorListener);</span>
<span class="nc" id="L1770">            cellEditor = newEditor;</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">            if(cellEditorListener == null)</span>
<span class="nc" id="L1772">                cellEditorListener = createCellEditorListener();</span>
<span class="nc bnc" id="L1773" title="All 4 branches missed.">            if(newEditor != null &amp;&amp; cellEditorListener != null)</span>
<span class="nc" id="L1774">                newEditor.addCellEditorListener(cellEditorListener);</span>
<span class="nc" id="L1775">            createdCellEditor = false;</span>
        }
<span class="nc" id="L1777">    }</span>

    /**
      * Messaged from the tree we're in when the renderer has changed.
      */
    protected void updateRenderer() {
<span class="nc bnc" id="L1783" title="All 2 branches missed.">        if(tree != null) {</span>
            TreeCellRenderer      newCellRenderer;

<span class="nc" id="L1786">            newCellRenderer = tree.getCellRenderer();</span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">            if(newCellRenderer == null) {</span>
<span class="nc" id="L1788">                tree.setCellRenderer(createDefaultCellRenderer());</span>
<span class="nc" id="L1789">                createdRenderer = true;</span>
            }
            else {
<span class="nc" id="L1792">                createdRenderer = false;</span>
<span class="nc" id="L1793">                currentCellRenderer = newCellRenderer;</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">                if(createdCellEditor) {</span>
<span class="nc" id="L1795">                    tree.setCellEditor(null);</span>
                }
            }
<span class="nc" id="L1798">        }</span>
        else {
<span class="nc" id="L1800">            createdRenderer = false;</span>
<span class="nc" id="L1801">            currentCellRenderer = null;</span>
        }
<span class="nc" id="L1803">        updateCellEditor();</span>
<span class="nc" id="L1804">    }</span>

    /**
     * Resets the TreeState instance based on the tree we're providing the
     * look and feel for.
     */
    protected void configureLayoutCache() {
<span class="nc bnc" id="L1811" title="All 4 branches missed.">        if(treeState != null &amp;&amp; tree != null) {</span>
<span class="nc bnc" id="L1812" title="All 2 branches missed.">            if(nodeDimensions == null)</span>
<span class="nc" id="L1813">                nodeDimensions = createNodeDimensions();</span>
<span class="nc" id="L1814">            treeState.setNodeDimensions(nodeDimensions);</span>
<span class="nc" id="L1815">            treeState.setRootVisible(tree.isRootVisible());</span>
<span class="nc" id="L1816">            treeState.setRowHeight(tree.getRowHeight());</span>
<span class="nc" id="L1817">            treeState.setSelectionModel(getSelectionModel());</span>
            // Only do this if necessary, may loss state if call with
            // same model as it currently has.
<span class="nc bnc" id="L1820" title="All 2 branches missed.">            if(treeState.getModel() != tree.getModel())</span>
<span class="nc" id="L1821">                treeState.setModel(tree.getModel());</span>
<span class="nc" id="L1822">            updateLayoutCacheExpandedNodesIfNecessary();</span>
            // Create a listener to update preferred size when bounds
            // changes, if necessary.
<span class="nc bnc" id="L1825" title="All 2 branches missed.">            if(isLargeModel()) {</span>
<span class="nc bnc" id="L1826" title="All 2 branches missed.">                if(componentListener == null) {</span>
<span class="nc" id="L1827">                    componentListener = createComponentListener();</span>
<span class="nc bnc" id="L1828" title="All 2 branches missed.">                    if(componentListener != null)</span>
<span class="nc" id="L1829">                        tree.addComponentListener(componentListener);</span>
                }
            }
<span class="nc bnc" id="L1832" title="All 2 branches missed.">            else if(componentListener != null) {</span>
<span class="nc" id="L1833">                tree.removeComponentListener(componentListener);</span>
<span class="nc" id="L1834">                componentListener = null;</span>
            }
        }
<span class="nc bnc" id="L1837" title="All 2 branches missed.">        else if(componentListener != null) {</span>
<span class="nc" id="L1838">            tree.removeComponentListener(componentListener);</span>
<span class="nc" id="L1839">            componentListener = null;</span>
        }
<span class="nc" id="L1841">    }</span>

    /**
     * Marks the cached size as being invalid, and messages the
     * tree with &lt;code&gt;treeDidChange&lt;/code&gt;.
     */
    protected void updateSize() {
<span class="nc" id="L1848">        validCachedPreferredSize = false;</span>
<span class="nc" id="L1849">        tree.treeDidChange();</span>
<span class="nc" id="L1850">    }</span>

    private void updateSize0() {
<span class="nc" id="L1853">        validCachedPreferredSize = false;</span>
<span class="nc" id="L1854">        tree.revalidate();</span>
<span class="nc" id="L1855">    }</span>

    /**
     * Updates the &lt;code&gt;preferredSize&lt;/code&gt; instance variable,
     * which is returned from &lt;code&gt;getPreferredSize()&lt;/code&gt;.&lt;p&gt;
     * For left to right orientations, the size is determined from the
     * current AbstractLayoutCache. For RTL orientations, the preferred size
     * becomes the width minus the minimum x position.
     */
    protected void updateCachedPreferredSize() {
<span class="nc bnc" id="L1865" title="All 2 branches missed.">        if(treeState != null) {</span>
<span class="nc" id="L1866">            Insets               i = tree.getInsets();</span>

<span class="nc bnc" id="L1868" title="All 2 branches missed.">            if(isLargeModel()) {</span>
<span class="nc" id="L1869">                Rectangle            visRect = tree.getVisibleRect();</span>

<span class="nc bnc" id="L1871" title="All 8 branches missed.">                if (visRect.x == 0 &amp;&amp; visRect.y == 0 &amp;&amp;</span>
                        visRect.width == 0 &amp;&amp; visRect.height == 0 &amp;&amp;
<span class="nc bnc" id="L1873" title="All 2 branches missed.">                        tree.getVisibleRowCount() &gt; 0) {</span>
                    // The tree doesn't have a valid bounds yet. Calculate
                    // based on visible row count.
<span class="nc" id="L1876">                    visRect.width = 1;</span>
<span class="nc" id="L1877">                    visRect.height = tree.getRowHeight() *</span>
<span class="nc" id="L1878">                            tree.getVisibleRowCount();</span>
                } else {
<span class="nc" id="L1880">                    visRect.x -= i.left;</span>
<span class="nc" id="L1881">                    visRect.y -= i.top;</span>
                }
                // we should consider a non-visible area above
<span class="nc" id="L1884">                Component component = SwingUtilities.getUnwrappedParent(tree);</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">                if (component instanceof JViewport) {</span>
<span class="nc" id="L1886">                    component = component.getParent();</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">                    if (component instanceof JScrollPane) {</span>
<span class="nc" id="L1888">                        JScrollPane pane = (JScrollPane) component;</span>
<span class="nc" id="L1889">                        JScrollBar bar = pane.getHorizontalScrollBar();</span>
<span class="nc bnc" id="L1890" title="All 4 branches missed.">                        if ((bar != null) &amp;&amp; bar.isVisible()) {</span>
<span class="nc" id="L1891">                            int height = bar.getHeight();</span>
<span class="nc" id="L1892">                            visRect.y -= height;</span>
<span class="nc" id="L1893">                            visRect.height += height;</span>
                        }
                    }
                }
<span class="nc" id="L1897">                preferredSize.width = treeState.getPreferredWidth(visRect);</span>
<span class="nc" id="L1898">            }</span>
            else {
<span class="nc" id="L1900">                preferredSize.width = treeState.getPreferredWidth(null);</span>
            }
<span class="nc" id="L1902">            preferredSize.height = treeState.getPreferredHeight();</span>
<span class="nc" id="L1903">            preferredSize.width += i.left + i.right;</span>
<span class="nc" id="L1904">            preferredSize.height += i.top + i.bottom;</span>
        }
<span class="nc" id="L1906">        validCachedPreferredSize = true;</span>
<span class="nc" id="L1907">    }</span>

    /**
      * Messaged from the VisibleTreeNode after it has been expanded.
      */
    protected void pathWasExpanded(TreePath path) {
<span class="nc bnc" id="L1913" title="All 2 branches missed.">        if(tree != null) {</span>
<span class="nc" id="L1914">            tree.fireTreeExpanded(path);</span>
        }
<span class="nc" id="L1916">    }</span>

    /**
      * Messaged from the VisibleTreeNode after it has collapsed.
      */
    protected void pathWasCollapsed(TreePath path) {
<span class="nc bnc" id="L1922" title="All 2 branches missed.">        if(tree != null) {</span>
<span class="nc" id="L1923">            tree.fireTreeCollapsed(path);</span>
        }
<span class="nc" id="L1925">    }</span>

    /**
      * Ensures that the rows identified by beginRow through endRow are
      * visible.
      */
    protected void ensureRowsAreVisible(int beginRow, int endRow) {
<span class="nc bnc" id="L1932" title="All 6 branches missed.">        if(tree != null &amp;&amp; beginRow &gt;= 0 &amp;&amp; endRow &lt; getRowCount(tree)) {</span>
<span class="nc" id="L1933">            boolean scrollVert = DefaultLookup.getBoolean(tree, this,</span>
                              &quot;Tree.scrollsHorizontallyAndVertically&quot;, false);
<span class="nc bnc" id="L1935" title="All 2 branches missed.">            if(beginRow == endRow) {</span>
<span class="nc" id="L1936">                Rectangle     scrollBounds = getPathBounds(tree, getPathForRow</span>
<span class="nc" id="L1937">                                                           (tree, beginRow));</span>

<span class="nc bnc" id="L1939" title="All 2 branches missed.">                if(scrollBounds != null) {</span>
<span class="nc bnc" id="L1940" title="All 2 branches missed.">                    if (!scrollVert) {</span>
<span class="nc" id="L1941">                        scrollBounds.x = tree.getVisibleRect().x;</span>
<span class="nc" id="L1942">                        scrollBounds.width = 1;</span>
                    }
<span class="nc" id="L1944">                    tree.scrollRectToVisible(scrollBounds);</span>
                }
<span class="nc" id="L1946">            }</span>
            else {
<span class="nc" id="L1948">                Rectangle   beginRect = getPathBounds(tree, getPathForRow</span>
<span class="nc" id="L1949">                                                      (tree, beginRow));</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">                if (beginRect != null) {</span>
<span class="nc" id="L1951">                    Rectangle   visRect = tree.getVisibleRect();</span>
<span class="nc" id="L1952">                    Rectangle   testRect = beginRect;</span>
<span class="nc" id="L1953">                    int         beginY = beginRect.y;</span>
<span class="nc" id="L1954">                    int         maxY = beginY + visRect.height;</span>

<span class="nc bnc" id="L1956" title="All 2 branches missed.">                    for(int counter = beginRow + 1; counter &lt;= endRow; counter++) {</span>
<span class="nc" id="L1957">                            testRect = getPathBounds(tree,</span>
<span class="nc" id="L1958">                                    getPathForRow(tree, counter));</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">                        if (testRect == null) {</span>
<span class="nc" id="L1960">                            return;</span>
                        }
<span class="nc bnc" id="L1962" title="All 2 branches missed.">                        if((testRect.y + testRect.height) &gt; maxY)</span>
<span class="nc" id="L1963">                                counter = endRow;</span>
                            }
<span class="nc" id="L1965">                        tree.scrollRectToVisible(new Rectangle(visRect.x, beginY, 1,</span>
                                                      testRect.y + testRect.height-
                                                      beginY));
                }
            }
        }
<span class="nc" id="L1971">    }</span>

    /** Sets the preferred minimum size.
      */
    public void setPreferredMinSize(Dimension newSize) {
<span class="nc" id="L1976">        preferredMinSize = newSize;</span>
<span class="nc" id="L1977">    }</span>

    /** Returns the minimum preferred size.
      */
    public Dimension getPreferredMinSize() {
<span class="nc bnc" id="L1982" title="All 2 branches missed.">        if(preferredMinSize == null)</span>
<span class="nc" id="L1983">            return null;</span>
<span class="nc" id="L1984">        return new Dimension(preferredMinSize);</span>
    }

    /** Returns the preferred size to properly display the tree,
      * this is a cover method for getPreferredSize(c, true).
      */
    public Dimension getPreferredSize(JComponent c) {
<span class="nc" id="L1991">        return getPreferredSize(c, true);</span>
    }

    /** Returns the preferred size to represent the tree in
      * &lt;I&gt;c&lt;/I&gt;.  If &lt;I&gt;checkConsistency&lt;/I&gt; is true
      * &lt;b&gt;checkConsistency&lt;/b&gt; is messaged first.
      */
    public Dimension getPreferredSize(JComponent c,
                                      boolean checkConsistency) {
<span class="nc" id="L2000">        Dimension       pSize = this.getPreferredMinSize();</span>

<span class="nc bnc" id="L2002" title="All 2 branches missed.">        if(!validCachedPreferredSize)</span>
<span class="nc" id="L2003">            updateCachedPreferredSize();</span>
<span class="nc bnc" id="L2004" title="All 2 branches missed.">        if(tree != null) {</span>
<span class="nc bnc" id="L2005" title="All 2 branches missed.">            if(pSize != null)</span>
<span class="nc" id="L2006">                return new Dimension(Math.max(pSize.width,</span>
                                              preferredSize.width),
<span class="nc" id="L2008">                              Math.max(pSize.height, preferredSize.height));</span>
<span class="nc" id="L2009">            return new Dimension(preferredSize.width, preferredSize.height);</span>
        }
<span class="nc bnc" id="L2011" title="All 2 branches missed.">        else if(pSize != null)</span>
<span class="nc" id="L2012">            return pSize;</span>
        else
<span class="nc" id="L2014">            return new Dimension(0, 0);</span>
    }

    /**
      * Returns the minimum size for this component.  Which will be
      * the min preferred size or 0, 0.
      */
    public Dimension getMinimumSize(JComponent c) {
<span class="nc bnc" id="L2022" title="All 2 branches missed.">        if(this.getPreferredMinSize() != null)</span>
<span class="nc" id="L2023">            return this.getPreferredMinSize();</span>
<span class="nc" id="L2024">        return new Dimension(0, 0);</span>
    }

    /**
      * Returns the maximum size for this component, which will be the
      * preferred size if the instance is currently in a JTree, or 0, 0.
      */
    public Dimension getMaximumSize(JComponent c) {
<span class="nc bnc" id="L2032" title="All 2 branches missed.">        if(tree != null)</span>
<span class="nc" id="L2033">            return getPreferredSize(tree);</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">        if(this.getPreferredMinSize() != null)</span>
<span class="nc" id="L2035">            return this.getPreferredMinSize();</span>
<span class="nc" id="L2036">        return new Dimension(0, 0);</span>
    }


    /**
     * Messages to stop the editing session. If the UI the receiver
     * is providing the look and feel for returns true from
     * &lt;code&gt;getInvokesStopCellEditing&lt;/code&gt;, stopCellEditing will
     * invoked on the current editor. Then completeEditing will
     * be messaged with false, true, false to cancel any lingering
     * editing.
     */
    protected void completeEditing() {
        /* If should invoke stopCellEditing, try that */
<span class="nc bnc" id="L2050" title="All 6 branches missed.">        if(tree.getInvokesStopCellEditing() &amp;&amp;</span>
           stopEditingInCompleteEditing &amp;&amp; editingComponent != null) {
<span class="nc" id="L2052">            cellEditor.stopCellEditing();</span>
        }
        /* Invoke cancelCellEditing, this will do nothing if stopCellEditing
           was successful. */
<span class="nc" id="L2056">        completeEditing(false, true, false);</span>
<span class="nc" id="L2057">    }</span>

    /**
      * Stops the editing session.  If messageStop is true the editor
      * is messaged with stopEditing, if messageCancel is true the
      * editor is messaged with cancelEditing. If messageTree is true
      * the treeModel is messaged with valueForPathChanged.
      */
    protected void completeEditing(boolean messageStop,
                                   boolean messageCancel,
                                   boolean messageTree) {
<span class="nc bnc" id="L2068" title="All 4 branches missed.">        if(stopEditingInCompleteEditing &amp;&amp; editingComponent != null) {</span>
<span class="nc" id="L2069">            Component             oldComponent = editingComponent;</span>
<span class="nc" id="L2070">            TreePath              oldPath = editingPath;</span>
<span class="nc" id="L2071">            TreeCellEditor        oldEditor = cellEditor;</span>
<span class="nc" id="L2072">            Object                newValue = oldEditor.getCellEditorValue();</span>
<span class="nc" id="L2073">            Rectangle             editingBounds = getPathBounds(tree,</span>
                                                                editingPath);
<span class="nc bnc" id="L2075" title="All 2 branches missed.">            boolean               requestFocus = (tree != null &amp;&amp;</span>
<span class="nc bnc" id="L2076" title="All 2 branches missed.">                                   (tree.hasFocus() || SwingUtilities.</span>
<span class="nc bnc" id="L2077" title="All 2 branches missed.">                                    findFocusOwner(editingComponent) != null));</span>

<span class="nc" id="L2079">            editingComponent = null;</span>
<span class="nc" id="L2080">            editingPath = null;</span>
<span class="nc bnc" id="L2081" title="All 2 branches missed.">            if(messageStop)</span>
<span class="nc" id="L2082">                oldEditor.stopCellEditing();</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">            else if(messageCancel)</span>
<span class="nc" id="L2084">                oldEditor.cancelCellEditing();</span>
<span class="nc" id="L2085">            tree.remove(oldComponent);</span>
<span class="nc bnc" id="L2086" title="All 2 branches missed.">            if(editorHasDifferentSize) {</span>
<span class="nc" id="L2087">                treeState.invalidatePathBounds(oldPath);</span>
<span class="nc" id="L2088">                updateSize();</span>
            }
<span class="nc bnc" id="L2090" title="All 2 branches missed.">            else if (editingBounds != null) {</span>
<span class="nc" id="L2091">                editingBounds.x = 0;</span>
<span class="nc" id="L2092">                editingBounds.width = tree.getSize().width;</span>
<span class="nc" id="L2093">                tree.repaint(editingBounds);</span>
            }
<span class="nc bnc" id="L2095" title="All 2 branches missed.">            if(requestFocus)</span>
<span class="nc" id="L2096">                tree.requestFocus();</span>
<span class="nc bnc" id="L2097" title="All 2 branches missed.">            if(messageTree)</span>
<span class="nc" id="L2098">                treeModel.valueForPathChanged(oldPath, newValue);</span>
        }
<span class="nc" id="L2100">    }</span>

    // cover method for startEditing that allows us to pass extra
    // information into that method via a class variable
    private boolean startEditingOnRelease(TreePath path,
                                          MouseEvent event,
                                          MouseEvent releaseEvent) {
<span class="nc" id="L2107">        this.releaseEvent = releaseEvent;</span>
        try {
<span class="nc" id="L2109">            return startEditing(path, event);</span>
        } finally {
<span class="nc" id="L2111">            this.releaseEvent = null;</span>
        }
    }

    /**
      * Will start editing for node if there is a cellEditor and
      * shouldSelectCell returns true.&lt;p&gt;
      * This assumes that path is valid and visible.
      */
    protected boolean startEditing(TreePath path, MouseEvent event) {
<span class="nc bnc" id="L2121" title="All 4 branches missed.">        if (isEditing(tree) &amp;&amp; tree.getInvokesStopCellEditing() &amp;&amp;</span>
<span class="nc bnc" id="L2122" title="All 2 branches missed.">                               !stopEditing(tree)) {</span>
<span class="nc" id="L2123">            return false;</span>
        }
<span class="nc" id="L2125">        completeEditing();</span>
<span class="nc bnc" id="L2126" title="All 4 branches missed.">        if(cellEditor != null &amp;&amp; tree.isPathEditable(path)) {</span>
<span class="nc" id="L2127">            int           row = getRowForPath(tree, path);</span>

<span class="nc bnc" id="L2129" title="All 2 branches missed.">            if(cellEditor.isCellEditable(event)) {</span>
<span class="nc" id="L2130">                editingComponent = cellEditor.getTreeCellEditorComponent</span>
<span class="nc" id="L2131">                      (tree, path.getLastPathComponent(),</span>
<span class="nc" id="L2132">                       tree.isPathSelected(path), tree.isExpanded(path),</span>
<span class="nc" id="L2133">                       treeModel.isLeaf(path.getLastPathComponent()), row);</span>
<span class="nc" id="L2134">                Rectangle           nodeBounds = getPathBounds(tree, path);</span>
<span class="nc bnc" id="L2135" title="All 2 branches missed.">                if (nodeBounds == null) {</span>
<span class="nc" id="L2136">                    return false;</span>
                }

<span class="nc" id="L2139">                editingRow = row;</span>

<span class="nc" id="L2141">                Dimension editorSize = editingComponent.getPreferredSize();</span>

                // Only allow odd heights if explicitly set.
<span class="nc bnc" id="L2144" title="All 2 branches missed.">                if(editorSize.height != nodeBounds.height &amp;&amp;</span>
<span class="nc bnc" id="L2145" title="All 2 branches missed.">                   getRowHeight() &gt; 0)</span>
<span class="nc" id="L2146">                    editorSize.height = getRowHeight();</span>

<span class="nc bnc" id="L2148" title="All 4 branches missed.">                if(editorSize.width != nodeBounds.width ||</span>
                   editorSize.height != nodeBounds.height) {
                    // Editor wants different width or height, invalidate
                    // treeState and relayout.
<span class="nc" id="L2152">                    editorHasDifferentSize = true;</span>
<span class="nc" id="L2153">                    treeState.invalidatePathBounds(path);</span>
<span class="nc" id="L2154">                    updateSize();</span>
                    // To make sure x/y are updated correctly, fetch
                    // the bounds again.
<span class="nc" id="L2157">                    nodeBounds = getPathBounds(tree, path);</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">                    if (nodeBounds == null) {</span>
<span class="nc" id="L2159">                        return false;</span>
                    }
                }
                else
<span class="nc" id="L2163">                    editorHasDifferentSize = false;</span>
<span class="nc" id="L2164">                tree.add(editingComponent);</span>
<span class="nc" id="L2165">                editingComponent.setBounds(nodeBounds.x, nodeBounds.y,</span>
                                           nodeBounds.width,
                                           nodeBounds.height);
<span class="nc" id="L2168">                editingPath = path;</span>
<span class="nc" id="L2169">                AWTAccessor.getComponentAccessor().revalidateSynchronously(editingComponent);</span>
<span class="nc" id="L2170">                editingComponent.repaint();</span>
<span class="nc bnc" id="L2171" title="All 2 branches missed.">                if(cellEditor.shouldSelectCell(event)) {</span>
<span class="nc" id="L2172">                    stopEditingInCompleteEditing = false;</span>
<span class="nc" id="L2173">                    tree.setSelectionRow(row);</span>
<span class="nc" id="L2174">                    stopEditingInCompleteEditing = true;</span>
                }

<span class="nc" id="L2177">                Component focusedComponent = SwingUtilities2.</span>
<span class="nc" id="L2178">                                 compositeRequestFocus(editingComponent);</span>
<span class="nc" id="L2179">                boolean selectAll = true;</span>

<span class="nc bnc" id="L2181" title="All 2 branches missed.">                if(event != null) {</span>
                    /* Find the component that will get forwarded all the
                       mouse events until mouseReleased. */
<span class="nc" id="L2184">                    Point          componentPoint = SwingUtilities.convertPoint</span>
<span class="nc" id="L2185">                        (tree, new Point(event.getX(), event.getY()),</span>
                         editingComponent);

                    /* Create an instance of BasicTreeMouseListener to handle
                       passing the mouse/motion events to the necessary
                       component. */
                    // We really want similar behavior to getMouseEventTarget,
                    // but it is package private.
<span class="nc" id="L2193">                    Component activeComponent = SwingUtilities.</span>
<span class="nc" id="L2194">                                    getDeepestComponentAt(editingComponent,</span>
                                       componentPoint.x, componentPoint.y);
<span class="nc bnc" id="L2196" title="All 2 branches missed.">                    if (activeComponent != null) {</span>
<span class="nc" id="L2197">                        MouseInputHandler handler =</span>
                            new MouseInputHandler(tree, activeComponent,
                                                  event, focusedComponent);

<span class="nc bnc" id="L2201" title="All 2 branches missed.">                        if (releaseEvent != null) {</span>
<span class="nc" id="L2202">                            handler.mouseReleased(releaseEvent);</span>
                        }

<span class="nc" id="L2205">                        selectAll = false;</span>
                    }
                }
<span class="nc bnc" id="L2208" title="All 4 branches missed.">                if (selectAll &amp;&amp; focusedComponent instanceof JTextField) {</span>
<span class="nc" id="L2209">                    ((JTextField)focusedComponent).selectAll();</span>
                }
<span class="nc" id="L2211">                return true;</span>
            }
            else
<span class="nc" id="L2214">                editingComponent = null;</span>
        }
<span class="nc" id="L2216">        return false;</span>
    }

    //
    // Following are primarily for handling mouse events.
    //

    /**
     * If the &lt;code&gt;mouseX&lt;/code&gt; and &lt;code&gt;mouseY&lt;/code&gt; are in the
     * expand/collapse region of the &lt;code&gt;row&lt;/code&gt;, this will toggle
     * the row.
     */
    protected void checkForClickInExpandControl(TreePath path,
                                                int mouseX, int mouseY) {
<span class="nc bnc" id="L2230" title="All 2 branches missed.">      if (isLocationInExpandControl(path, mouseX, mouseY)) {</span>
<span class="nc" id="L2231">          handleExpandControlClick(path, mouseX, mouseY);</span>
        }
<span class="nc" id="L2233">    }</span>

    /**
     * Returns true if &lt;code&gt;mouseX&lt;/code&gt; and &lt;code&gt;mouseY&lt;/code&gt; fall
     * in the area of row that is used to expand/collapse the node and
     * the node at &lt;code&gt;row&lt;/code&gt; does not represent a leaf.
     */
    protected boolean isLocationInExpandControl(TreePath path,
                                                int mouseX, int mouseY) {
<span class="nc bnc" id="L2242" title="All 4 branches missed.">        if(path != null &amp;&amp; !treeModel.isLeaf(path.getLastPathComponent())){</span>
            int                     boxWidth;
<span class="nc" id="L2244">            Insets                  i = tree.getInsets();</span>

<span class="nc bnc" id="L2246" title="All 2 branches missed.">            if(getExpandedIcon() != null)</span>
<span class="nc" id="L2247">                boxWidth = getExpandedIcon().getIconWidth();</span>
            else
<span class="nc" id="L2249">                boxWidth = 8;</span>

<span class="nc" id="L2251">            int boxLeftX = getRowX(tree.getRowForPath(path),</span>
<span class="nc" id="L2252">                                   path.getPathCount() - 1);</span>

<span class="nc bnc" id="L2254" title="All 2 branches missed.">            if (leftToRight) {</span>
<span class="nc" id="L2255">                boxLeftX = boxLeftX + i.left - getRightChildIndent() + 1;</span>
            } else {
<span class="nc" id="L2257">                boxLeftX = tree.getWidth() - boxLeftX - i.right + getRightChildIndent() - 1;</span>
            }

<span class="nc" id="L2260">            boxLeftX = findCenteredX(boxLeftX, boxWidth);</span>

<span class="nc bnc" id="L2262" title="All 4 branches missed.">            return (mouseX &gt;= boxLeftX &amp;&amp; mouseX &lt; (boxLeftX + boxWidth));</span>
        }
<span class="nc" id="L2264">        return false;</span>
    }

    /**
     * Messaged when the user clicks the particular row, this invokes
     * toggleExpandState.
     */
    protected void handleExpandControlClick(TreePath path, int mouseX,
                                            int mouseY) {
<span class="nc" id="L2273">        toggleExpandState(path);</span>
<span class="nc" id="L2274">    }</span>

    /**
     * Expands path if it is not expanded, or collapses row if it is expanded.
     * If expanding a path and JTree scrolls on expand, ensureRowsAreVisible
     * is invoked to scroll as many of the children to visible as possible
     * (tries to scroll to last visible descendant of path).
     */
    protected void toggleExpandState(TreePath path) {
<span class="nc bnc" id="L2283" title="All 2 branches missed.">        if(!tree.isExpanded(path)) {</span>
<span class="nc" id="L2284">            int       row = getRowForPath(tree, path);</span>

<span class="nc" id="L2286">            tree.expandPath(path);</span>
<span class="nc" id="L2287">            updateSize();</span>
<span class="nc bnc" id="L2288" title="All 2 branches missed.">            if(row != -1) {</span>
<span class="nc bnc" id="L2289" title="All 2 branches missed.">                if(tree.getScrollsOnExpand())</span>
<span class="nc" id="L2290">                    ensureRowsAreVisible(row, row + treeState.</span>
<span class="nc" id="L2291">                                         getVisibleChildCount(path));</span>
                else
<span class="nc" id="L2293">                    ensureRowsAreVisible(row, row);</span>
            }
<span class="nc" id="L2295">        }</span>
        else {
<span class="nc" id="L2297">            tree.collapsePath(path);</span>
<span class="nc" id="L2298">            updateSize();</span>
        }
<span class="nc" id="L2300">    }</span>

    /**
     * Returning true signifies a mouse event on the node should toggle
     * the selection of only the row under mouse.
     */
    protected boolean isToggleSelectionEvent(MouseEvent event) {
<span class="nc bnc" id="L2307" title="All 2 branches missed.">        return (SwingUtilities.isLeftMouseButton(event) &amp;&amp;</span>
<span class="nc bnc" id="L2308" title="All 2 branches missed.">                BasicGraphicsUtils.isMenuShortcutKeyDown(event));</span>
    }

    /**
     * Returning true signifies a mouse event on the node should select
     * from the anchor point.
     */
    protected boolean isMultiSelectEvent(MouseEvent event) {
<span class="nc bnc" id="L2316" title="All 2 branches missed.">        return (SwingUtilities.isLeftMouseButton(event) &amp;&amp;</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">                event.isShiftDown());</span>
    }

    /**
     * Returning true indicates the row under the mouse should be toggled
     * based on the event. This is invoked after checkForClickInExpandControl,
     * implying the location is not in the expand (toggle) control
     */
    protected boolean isToggleEvent(MouseEvent event) {
<span class="nc bnc" id="L2326" title="All 2 branches missed.">        if(!SwingUtilities.isLeftMouseButton(event)) {</span>
<span class="nc" id="L2327">            return false;</span>
        }
<span class="nc" id="L2329">        int           clickCount = tree.getToggleClickCount();</span>

<span class="nc bnc" id="L2331" title="All 2 branches missed.">        if(clickCount &lt;= 0) {</span>
<span class="nc" id="L2332">            return false;</span>
        }
<span class="nc bnc" id="L2334" title="All 2 branches missed.">        return ((event.getClickCount() % clickCount) == 0);</span>
    }

    /**
     * Messaged to update the selection based on a MouseEvent over a
     * particular row. If the event is a toggle selection event, the
     * row is either selected, or deselected. If the event identifies
     * a multi selection event, the selection is updated from the
     * anchor point. Otherwise the row is selected, and if the event
     * specified a toggle event the row is expanded/collapsed.
     */
    protected void selectPathForEvent(TreePath path, MouseEvent event) {
        /* Adjust from the anchor point. */
<span class="nc bnc" id="L2347" title="All 2 branches missed.">        if(isMultiSelectEvent(event)) {</span>
<span class="nc" id="L2348">            TreePath    anchor = getAnchorSelectionPath();</span>
<span class="nc bnc" id="L2349" title="All 2 branches missed.">            int         anchorRow = (anchor == null) ? -1 :</span>
<span class="nc" id="L2350">                                    getRowForPath(tree, anchor);</span>

<span class="nc bnc" id="L2352" title="All 2 branches missed.">            if(anchorRow == -1 || tree.getSelectionModel().</span>
<span class="nc bnc" id="L2353" title="All 2 branches missed.">                      getSelectionMode() == TreeSelectionModel.</span>
                      SINGLE_TREE_SELECTION) {
<span class="nc" id="L2355">                tree.setSelectionPath(path);</span>
            }
            else {
<span class="nc" id="L2358">                int          row = getRowForPath(tree, path);</span>
<span class="nc" id="L2359">                TreePath     lastAnchorPath = anchor;</span>

<span class="nc bnc" id="L2361" title="All 2 branches missed.">                if (isToggleSelectionEvent(event)) {</span>
<span class="nc bnc" id="L2362" title="All 2 branches missed.">                    if (tree.isRowSelected(anchorRow)) {</span>
<span class="nc" id="L2363">                        tree.addSelectionInterval(anchorRow, row);</span>
                    } else {
<span class="nc" id="L2365">                        tree.removeSelectionInterval(anchorRow, row);</span>
<span class="nc" id="L2366">                        tree.addSelectionInterval(row, row);</span>
                    }
<span class="nc bnc" id="L2368" title="All 2 branches missed.">                } else if(row &lt; anchorRow) {</span>
<span class="nc" id="L2369">                    tree.setSelectionInterval(row, anchorRow);</span>
                } else {
<span class="nc" id="L2371">                    tree.setSelectionInterval(anchorRow, row);</span>
                }
<span class="nc" id="L2373">                lastSelectedRow = row;</span>
<span class="nc" id="L2374">                setAnchorSelectionPath(lastAnchorPath);</span>
<span class="nc" id="L2375">                setLeadSelectionPath(path);</span>
            }
<span class="nc" id="L2377">        }</span>

        // Should this event toggle the selection of this row?
        /* Control toggles just this node. */
<span class="nc bnc" id="L2381" title="All 2 branches missed.">        else if(isToggleSelectionEvent(event)) {</span>
<span class="nc bnc" id="L2382" title="All 2 branches missed.">            if(tree.isPathSelected(path))</span>
<span class="nc" id="L2383">                tree.removeSelectionPath(path);</span>
            else
<span class="nc" id="L2385">                tree.addSelectionPath(path);</span>
<span class="nc" id="L2386">            lastSelectedRow = getRowForPath(tree, path);</span>
<span class="nc" id="L2387">            setAnchorSelectionPath(path);</span>
<span class="nc" id="L2388">            setLeadSelectionPath(path);</span>
        }

        /* Otherwise set the selection to just this interval. */
<span class="nc bnc" id="L2392" title="All 2 branches missed.">        else if(SwingUtilities.isLeftMouseButton(event)) {</span>
<span class="nc" id="L2393">            tree.setSelectionPath(path);</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">            if(isToggleEvent(event)) {</span>
<span class="nc" id="L2395">                toggleExpandState(path);</span>
            }
        }
<span class="nc" id="L2398">    }</span>

    /**
     * @return true if the node at &lt;code&gt;row&lt;/code&gt; is a leaf.
     */
    protected boolean isLeaf(int row) {
<span class="nc" id="L2404">        TreePath          path = getPathForRow(tree, row);</span>

<span class="nc bnc" id="L2406" title="All 2 branches missed.">        if(path != null)</span>
<span class="nc" id="L2407">            return treeModel.isLeaf(path.getLastPathComponent());</span>
        // Have to return something here...
<span class="nc" id="L2409">        return true;</span>
    }

    //
    // The following selection methods (lead/anchor) are covers for the
    // methods in JTree.
    //
    private void setAnchorSelectionPath(TreePath newPath) {
<span class="nc" id="L2417">        ignoreLAChange = true;</span>
        try {
<span class="nc" id="L2419">            tree.setAnchorSelectionPath(newPath);</span>
        } finally{
<span class="nc" id="L2421">            ignoreLAChange = false;</span>
<span class="nc" id="L2422">        }</span>
<span class="nc" id="L2423">    }</span>

    private TreePath getAnchorSelectionPath() {
<span class="nc" id="L2426">        return tree.getAnchorSelectionPath();</span>
    }

    private void setLeadSelectionPath(TreePath newPath) {
<span class="nc" id="L2430">        setLeadSelectionPath(newPath, false);</span>
<span class="nc" id="L2431">    }</span>

    private void setLeadSelectionPath(TreePath newPath, boolean repaint) {
<span class="nc bnc" id="L2434" title="All 2 branches missed.">        Rectangle       bounds = repaint ?</span>
<span class="nc" id="L2435">                            getPathBounds(tree, getLeadSelectionPath()) : null;</span>

<span class="nc" id="L2437">        ignoreLAChange = true;</span>
        try {
<span class="nc" id="L2439">            tree.setLeadSelectionPath(newPath);</span>
        } finally {
<span class="nc" id="L2441">            ignoreLAChange = false;</span>
<span class="nc" id="L2442">        }</span>
<span class="nc" id="L2443">        leadRow = getRowForPath(tree, newPath);</span>

<span class="nc bnc" id="L2445" title="All 2 branches missed.">        if (repaint) {</span>
<span class="nc bnc" id="L2446" title="All 2 branches missed.">            if (bounds != null) {</span>
<span class="nc" id="L2447">                tree.repaint(getRepaintPathBounds(bounds));</span>
            }
<span class="nc" id="L2449">            bounds = getPathBounds(tree, newPath);</span>
<span class="nc bnc" id="L2450" title="All 2 branches missed.">            if (bounds != null) {</span>
<span class="nc" id="L2451">                tree.repaint(getRepaintPathBounds(bounds));</span>
            }
        }
<span class="nc" id="L2454">    }</span>

    private Rectangle getRepaintPathBounds(Rectangle bounds) {
<span class="nc bnc" id="L2457" title="All 2 branches missed.">        if (UIManager.getBoolean(&quot;Tree.repaintWholeRow&quot;)) {</span>
<span class="nc" id="L2458">           bounds.x = 0;</span>
<span class="nc" id="L2459">           bounds.width = tree.getWidth();</span>
        }
<span class="nc" id="L2461">        return bounds;</span>
    }

    private TreePath getLeadSelectionPath() {
<span class="nc" id="L2465">        return tree.getLeadSelectionPath();</span>
    }

    /**
     * Updates the lead row of the selection.
     * @since 1.7
     */
    protected void updateLeadSelectionRow() {
<span class="nc" id="L2473">        leadRow = getRowForPath(tree, getLeadSelectionPath());</span>
<span class="nc" id="L2474">    }</span>

    /**
     * Returns the lead row of the selection.
     *
     * @return selection lead row
     * @since 1.7
     */
    protected int getLeadSelectionRow() {
<span class="nc" id="L2483">        return leadRow;</span>
    }

    /**
     * Extends the selection from the anchor to make &lt;code&gt;newLead&lt;/code&gt;
     * the lead of the selection. This does not scroll.
     */
    private void extendSelection(TreePath newLead) {
<span class="nc" id="L2491">        TreePath           aPath = getAnchorSelectionPath();</span>
<span class="nc bnc" id="L2492" title="All 2 branches missed.">        int                aRow = (aPath == null) ? -1 :</span>
<span class="nc" id="L2493">                                  getRowForPath(tree, aPath);</span>
<span class="nc" id="L2494">        int                newIndex = getRowForPath(tree, newLead);</span>

<span class="nc bnc" id="L2496" title="All 2 branches missed.">        if(aRow == -1) {</span>
<span class="nc" id="L2497">            tree.setSelectionRow(newIndex);</span>
        }
        else {
<span class="nc bnc" id="L2500" title="All 2 branches missed.">            if(aRow &lt; newIndex) {</span>
<span class="nc" id="L2501">                tree.setSelectionInterval(aRow, newIndex);</span>
            }
            else {
<span class="nc" id="L2504">                tree.setSelectionInterval(newIndex, aRow);</span>
            }
<span class="nc" id="L2506">            setAnchorSelectionPath(aPath);</span>
<span class="nc" id="L2507">            setLeadSelectionPath(newLead);</span>
        }
<span class="nc" id="L2509">    }</span>

    /**
     * Invokes &lt;code&gt;repaint&lt;/code&gt; on the JTree for the passed in TreePath,
     * &lt;code&gt;path&lt;/code&gt;.
     */
    private void repaintPath(TreePath path) {
<span class="nc bnc" id="L2516" title="All 2 branches missed.">        if (path != null) {</span>
<span class="nc" id="L2517">            Rectangle bounds = getPathBounds(tree, path);</span>
<span class="nc bnc" id="L2518" title="All 2 branches missed.">            if (bounds != null) {</span>
<span class="nc" id="L2519">                tree.repaint(bounds.x, bounds.y, bounds.width, bounds.height);</span>
            }
        }
<span class="nc" id="L2522">    }</span>

    /**
     * Updates the TreeState in response to nodes expanding/collapsing.
     */
<span class="nc" id="L2527">    public class TreeExpansionHandler implements TreeExpansionListener {</span>
        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.

        /**
         * Called whenever an item in the tree has been expanded.
         */
        public void treeExpanded(TreeExpansionEvent event) {
<span class="nc" id="L2537">            getHandler().treeExpanded(event);</span>
<span class="nc" id="L2538">        }</span>

        /**
         * Called whenever an item in the tree has been collapsed.
         */
        public void treeCollapsed(TreeExpansionEvent event) {
<span class="nc" id="L2544">            getHandler().treeCollapsed(event);</span>
<span class="nc" id="L2545">        }</span>
    } // BasicTreeUI.TreeExpansionHandler


    /**
     * Updates the preferred size when scrolling (if necessary).
     */
<span class="nc" id="L2552">    public class ComponentHandler extends ComponentAdapter implements</span>
                 ActionListener {
        /** Timer used when inside a scrollpane and the scrollbar is
         * adjusting. */
        protected Timer                timer;
        /** ScrollBar that is being adjusted. */
        protected JScrollBar           scrollBar;

        public void componentMoved(ComponentEvent e) {
<span class="nc bnc" id="L2561" title="All 2 branches missed.">            if(timer == null) {</span>
<span class="nc" id="L2562">                JScrollPane   scrollPane = getScrollPane();</span>

<span class="nc bnc" id="L2564" title="All 2 branches missed.">                if(scrollPane == null)</span>
<span class="nc" id="L2565">                    updateSize();</span>
                else {
<span class="nc" id="L2567">                    scrollBar = scrollPane.getVerticalScrollBar();</span>
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                    if(scrollBar == null ||</span>
<span class="nc bnc" id="L2569" title="All 2 branches missed.">                        !scrollBar.getValueIsAdjusting()) {</span>
                        // Try the horizontal scrollbar.
<span class="nc bnc" id="L2571" title="All 2 branches missed.">                        if((scrollBar = scrollPane.getHorizontalScrollBar())</span>
<span class="nc bnc" id="L2572" title="All 2 branches missed.">                            != null &amp;&amp; scrollBar.getValueIsAdjusting())</span>
<span class="nc" id="L2573">                            startTimer();</span>
                        else
<span class="nc" id="L2575">                            updateSize();</span>
                    }
                    else
<span class="nc" id="L2578">                        startTimer();</span>
                }
            }
<span class="nc" id="L2581">        }</span>

        /**
         * Creates, if necessary, and starts a Timer to check if need to
         * resize the bounds.
         */
        protected void startTimer() {
<span class="nc bnc" id="L2588" title="All 2 branches missed.">            if(timer == null) {</span>
<span class="nc" id="L2589">                timer = new Timer(200, this);</span>
<span class="nc" id="L2590">                timer.setRepeats(true);</span>
            }
<span class="nc" id="L2592">            timer.start();</span>
<span class="nc" id="L2593">        }</span>

        /**
         * Returns the JScrollPane housing the JTree, or null if one isn't
         * found.
         */
        protected JScrollPane getScrollPane() {
<span class="nc" id="L2600">            Component       c = tree.getParent();</span>

<span class="nc bnc" id="L2602" title="All 4 branches missed.">            while(c != null &amp;&amp; !(c instanceof JScrollPane))</span>
<span class="nc" id="L2603">                c = c.getParent();</span>
<span class="nc bnc" id="L2604" title="All 2 branches missed.">            if(c instanceof JScrollPane)</span>
<span class="nc" id="L2605">                return (JScrollPane)c;</span>
<span class="nc" id="L2606">            return null;</span>
        }

        /**
         * Public as a result of Timer. If the scrollBar is null, or
         * not adjusting, this stops the timer and updates the sizing.
         */
        public void actionPerformed(ActionEvent ae) {
<span class="nc bnc" id="L2614" title="All 4 branches missed.">            if(scrollBar == null || !scrollBar.getValueIsAdjusting()) {</span>
<span class="nc bnc" id="L2615" title="All 2 branches missed.">                if(timer != null)</span>
<span class="nc" id="L2616">                    timer.stop();</span>
<span class="nc" id="L2617">                updateSize();</span>
<span class="nc" id="L2618">                timer = null;</span>
<span class="nc" id="L2619">                scrollBar = null;</span>
            }
<span class="nc" id="L2621">        }</span>
    } // End of BasicTreeUI.ComponentHandler


    /**
     * Forwards all TreeModel events to the TreeState.
     */
<span class="nc" id="L2628">    public class TreeModelHandler implements TreeModelListener {</span>

        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.

        public void treeNodesChanged(TreeModelEvent e) {
<span class="nc" id="L2636">            getHandler().treeNodesChanged(e);</span>
<span class="nc" id="L2637">        }</span>

        public void treeNodesInserted(TreeModelEvent e) {
<span class="nc" id="L2640">            getHandler().treeNodesInserted(e);</span>
<span class="nc" id="L2641">        }</span>

        public void treeNodesRemoved(TreeModelEvent e) {
<span class="nc" id="L2644">            getHandler().treeNodesRemoved(e);</span>
<span class="nc" id="L2645">        }</span>

        public void treeStructureChanged(TreeModelEvent e) {
<span class="nc" id="L2648">            getHandler().treeStructureChanged(e);</span>
<span class="nc" id="L2649">        }</span>
    } // End of BasicTreeUI.TreeModelHandler


    /**
     * Listens for changes in the selection model and updates the display
     * accordingly.
     */
<span class="nc" id="L2657">    public class TreeSelectionHandler implements TreeSelectionListener {</span>

        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.

        /**
         * Messaged when the selection changes in the tree we're displaying
         * for.  Stops editing, messages super and displays the changed paths.
         */
        public void valueChanged(TreeSelectionEvent event) {
<span class="nc" id="L2669">            getHandler().valueChanged(event);</span>
<span class="nc" id="L2670">        }</span>
    }// End of BasicTreeUI.TreeSelectionHandler


    /**
     * Listener responsible for getting cell editing events and updating
     * the tree accordingly.
     */
<span class="nc" id="L2678">    public class CellEditorHandler implements CellEditorListener {</span>

        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.

        /** Messaged when editing has stopped in the tree. */
        public void editingStopped(ChangeEvent e) {
<span class="nc" id="L2687">            getHandler().editingStopped(e);</span>
<span class="nc" id="L2688">        }</span>

        /** Messaged when editing has been canceled in the tree. */
        public void editingCanceled(ChangeEvent e) {
<span class="nc" id="L2692">            getHandler().editingCanceled(e);</span>
<span class="nc" id="L2693">        }</span>
    } // BasicTreeUI.CellEditorHandler


    /**
     * This is used to get multiple key down events to appropriately generate
     * events.
     */
<span class="nc" id="L2701">    public class KeyHandler extends KeyAdapter {</span>

        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.

        // Also note these fields aren't use anymore, nor does Handler have
        // the old functionality. This behavior worked around an old bug
        // in JComponent that has long since been fixed.

        /** Key code that is being generated for. */
        protected Action              repeatKeyAction;

        /** Set to true while keyPressed is active. */
        protected boolean            isKeyDown;

        /**
         * Invoked when a key has been typed.
         *
         * Moves the keyboard focus to the first element
         * whose first letter matches the alphanumeric key
         * pressed by the user. Subsequent same key presses
         * move the keyboard focus to the next object that
         * starts with the same letter.
         */
        public void keyTyped(KeyEvent e) {
<span class="nc" id="L2728">            getHandler().keyTyped(e);</span>
<span class="nc" id="L2729">        }</span>

        public void keyPressed(KeyEvent e) {
<span class="nc" id="L2732">            getHandler().keyPressed(e);</span>
<span class="nc" id="L2733">        }</span>

        public void keyReleased(KeyEvent e) {
<span class="nc" id="L2736">            getHandler().keyReleased(e);</span>
<span class="nc" id="L2737">        }</span>
    } // End of BasicTreeUI.KeyHandler


    /**
     * Repaints the lead selection row when focus is lost/gained.
     */
<span class="nc" id="L2744">    public class FocusHandler implements FocusListener {</span>
        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.

        /**
         * Invoked when focus is activated on the tree we're in, redraws the
         * lead row.
         */
        public void focusGained(FocusEvent e) {
<span class="nc" id="L2755">            getHandler().focusGained(e);</span>
<span class="nc" id="L2756">        }</span>

        /**
         * Invoked when focus is activated on the tree we're in, redraws the
         * lead row.
         */
        public void focusLost(FocusEvent e) {
<span class="nc" id="L2763">            getHandler().focusLost(e);</span>
<span class="nc" id="L2764">        }</span>
    } // End of class BasicTreeUI.FocusHandler


    /**
     * Class responsible for getting size of node, method is forwarded
     * to BasicTreeUI method. X location does not include insets, that is
     * handled in getPathBounds.
     */
    // This returns locations that don't include any Insets.
<span class="nc" id="L2774">    public class NodeDimensionsHandler extends</span>
                 AbstractLayoutCache.NodeDimensions {
        /**
         * Responsible for getting the size of a particular node.
         */
        public Rectangle getNodeDimensions(Object value, int row,
                                           int depth, boolean expanded,
                                           Rectangle size) {
            // Return size of editing component, if editing and asking
            // for editing row.
<span class="nc bnc" id="L2784" title="All 4 branches missed.">            if(editingComponent != null &amp;&amp; editingRow == row) {</span>
<span class="nc" id="L2785">                Dimension        prefSize = editingComponent.</span>
<span class="nc" id="L2786">                                              getPreferredSize();</span>
<span class="nc" id="L2787">                int              rh = getRowHeight();</span>

<span class="nc bnc" id="L2789" title="All 4 branches missed.">                if(rh &gt; 0 &amp;&amp; rh != prefSize.height)</span>
<span class="nc" id="L2790">                    prefSize.height = rh;</span>
<span class="nc bnc" id="L2791" title="All 2 branches missed.">                if(size != null) {</span>
<span class="nc" id="L2792">                    size.x = getRowX(row, depth);</span>
<span class="nc" id="L2793">                    size.width = prefSize.width;</span>
<span class="nc" id="L2794">                    size.height = prefSize.height;</span>
                }
                else {
<span class="nc" id="L2797">                    size = new Rectangle(getRowX(row, depth), 0,</span>
                                         prefSize.width, prefSize.height);
                }
<span class="nc" id="L2800">                return size;</span>
            }
            // Not editing, use renderer.
<span class="nc bnc" id="L2803" title="All 2 branches missed.">            if(currentCellRenderer != null) {</span>
                Component          aComponent;

<span class="nc" id="L2806">                aComponent = currentCellRenderer.getTreeCellRendererComponent</span>
<span class="nc" id="L2807">                    (tree, value, tree.isRowSelected(row),</span>
<span class="nc" id="L2808">                     expanded, treeModel.isLeaf(value), row,</span>
                     false);
<span class="nc bnc" id="L2810" title="All 2 branches missed.">                if(tree != null) {</span>
                    // Only ever removed when UI changes, this is OK!
<span class="nc" id="L2812">                    rendererPane.add(aComponent);</span>
<span class="nc" id="L2813">                    aComponent.validate();</span>
                }
<span class="nc" id="L2815">                Dimension        prefSize = aComponent.getPreferredSize();</span>

<span class="nc bnc" id="L2817" title="All 2 branches missed.">                if(size != null) {</span>
<span class="nc" id="L2818">                    size.x = getRowX(row, depth);</span>
<span class="nc" id="L2819">                    size.width = prefSize.width;</span>
<span class="nc" id="L2820">                    size.height = prefSize.height;</span>
                }
                else {
<span class="nc" id="L2823">                    size = new Rectangle(getRowX(row, depth), 0,</span>
                                         prefSize.width, prefSize.height);
                }
<span class="nc" id="L2826">                return size;</span>
            }
<span class="nc" id="L2828">            return null;</span>
        }

        /**
         * @return amount to indent the given row.
         */
        protected int getRowX(int row, int depth) {
<span class="nc" id="L2835">            return BasicTreeUI.this.getRowX(row, depth);</span>
        }

    } // End of class BasicTreeUI.NodeDimensionsHandler


    /**
     * TreeMouseListener is responsible for updating the selection
     * based on mouse events.
     */
<span class="nc" id="L2845">    public class MouseHandler extends MouseAdapter implements MouseMotionListener</span>
 {
        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.

        /**
         * Invoked when a mouse button has been pressed on a component.
         */
        public void mousePressed(MouseEvent e) {
<span class="nc" id="L2856">            getHandler().mousePressed(e);</span>
<span class="nc" id="L2857">        }</span>

        public void mouseDragged(MouseEvent e) {
<span class="nc" id="L2860">            getHandler().mouseDragged(e);</span>
<span class="nc" id="L2861">        }</span>

        /**
         * Invoked when the mouse button has been moved on a component
         * (with no buttons no down).
         * @since 1.4
         */
        public void mouseMoved(MouseEvent e) {
<span class="nc" id="L2869">            getHandler().mouseMoved(e);</span>
<span class="nc" id="L2870">        }</span>

        public void mouseReleased(MouseEvent e) {
<span class="nc" id="L2873">            getHandler().mouseReleased(e);</span>
<span class="nc" id="L2874">        }</span>
    } // End of BasicTreeUI.MouseHandler


    /**
     * PropertyChangeListener for the tree. Updates the appropriate
     * variable, or TreeState, based on what changes.
     */
<span class="nc" id="L2882">    public class PropertyChangeHandler implements</span>
                       PropertyChangeListener {

        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.

        public void propertyChange(PropertyChangeEvent event) {
<span class="nc" id="L2891">            getHandler().propertyChange(event);</span>
<span class="nc" id="L2892">        }</span>
    } // End of BasicTreeUI.PropertyChangeHandler


    /**
     * Listener on the TreeSelectionModel, resets the row selection if
     * any of the properties of the model change.
     */
<span class="nc" id="L2900">    public class SelectionModelPropertyChangeHandler implements</span>
                      PropertyChangeListener {

        // NOTE: This class exists only for backward compatibility. All
        // its functionality has been moved into Handler. If you need to add
        // new functionality add it to the Handler, but make sure this
        // class calls into the Handler.

        public void propertyChange(PropertyChangeEvent event) {
<span class="nc" id="L2909">            getHandler().propertyChange(event);</span>
<span class="nc" id="L2910">        }</span>
    } // End of BasicTreeUI.SelectionModelPropertyChangeHandler


    /**
     * &lt;code&gt;TreeTraverseAction&lt;/code&gt; is the action used for left/right keys.
     * Will toggle the expandedness of a node, as well as potentially
     * incrementing the selection.
     */
    public class TreeTraverseAction extends AbstractAction {
        /** Determines direction to traverse, 1 means expand, -1 means
          * collapse. */
        protected int direction;
        /** True if the selection is reset, false means only the lead path
         * changes. */
        private boolean changeSelection;

        public TreeTraverseAction(int direction, String name) {
<span class="nc" id="L2928">            this(direction, name, true);</span>
<span class="nc" id="L2929">        }</span>

        private TreeTraverseAction(int direction, String name,
<span class="nc" id="L2932">                                   boolean changeSelection) {</span>
<span class="nc" id="L2933">            this.direction = direction;</span>
<span class="nc" id="L2934">            this.changeSelection = changeSelection;</span>
<span class="nc" id="L2935">        }</span>

        public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L2938" title="All 2 branches missed.">            if (tree != null) {</span>
<span class="nc" id="L2939">                SHARED_ACTION.traverse(tree, BasicTreeUI.this, direction,</span>
                                       changeSelection);
            }
<span class="nc" id="L2942">        }</span>

<span class="nc bnc" id="L2944" title="All 2 branches missed.">        public boolean isEnabled() { return (tree != null &amp;&amp;</span>
<span class="nc bnc" id="L2945" title="All 2 branches missed.">                                             tree.isEnabled()); }</span>
    } // BasicTreeUI.TreeTraverseAction


    /** TreePageAction handles page up and page down events.
      */
    public class TreePageAction extends AbstractAction {
        /** Specifies the direction to adjust the selection by. */
        protected int         direction;
        /** True indicates should set selection from anchor path. */
        private boolean       addToSelection;
        private boolean       changeSelection;

        public TreePageAction(int direction, String name) {
<span class="nc" id="L2959">            this(direction, name, false, true);</span>
<span class="nc" id="L2960">        }</span>

        private TreePageAction(int direction, String name,
                               boolean addToSelection,
<span class="nc" id="L2964">                               boolean changeSelection) {</span>
<span class="nc" id="L2965">            this.direction = direction;</span>
<span class="nc" id="L2966">            this.addToSelection = addToSelection;</span>
<span class="nc" id="L2967">            this.changeSelection = changeSelection;</span>
<span class="nc" id="L2968">        }</span>

        public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L2971" title="All 2 branches missed.">            if (tree != null) {</span>
<span class="nc" id="L2972">                SHARED_ACTION.page(tree, BasicTreeUI.this, direction,</span>
                                   addToSelection, changeSelection);
            }
<span class="nc" id="L2975">        }</span>

<span class="nc bnc" id="L2977" title="All 2 branches missed.">        public boolean isEnabled() { return (tree != null &amp;&amp;</span>
<span class="nc bnc" id="L2978" title="All 2 branches missed.">                                             tree.isEnabled()); }</span>

    } // BasicTreeUI.TreePageAction


    /** TreeIncrementAction is used to handle up/down actions.  Selection
      * is moved up or down based on direction.
      */
    public class TreeIncrementAction extends AbstractAction  {
        /** Specifies the direction to adjust the selection by. */
        protected int         direction;
        /** If true the new item is added to the selection, if false the
         * selection is reset. */
        private boolean       addToSelection;
        private boolean       changeSelection;

        public TreeIncrementAction(int direction, String name) {
<span class="nc" id="L2995">            this(direction, name, false, true);</span>
<span class="nc" id="L2996">        }</span>

        private TreeIncrementAction(int direction, String name,
                                   boolean addToSelection,
<span class="nc" id="L3000">                                    boolean changeSelection) {</span>
<span class="nc" id="L3001">            this.direction = direction;</span>
<span class="nc" id="L3002">            this.addToSelection = addToSelection;</span>
<span class="nc" id="L3003">            this.changeSelection = changeSelection;</span>
<span class="nc" id="L3004">        }</span>

        public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L3007" title="All 2 branches missed.">            if (tree != null) {</span>
<span class="nc" id="L3008">                SHARED_ACTION.increment(tree, BasicTreeUI.this, direction,</span>
                                        addToSelection, changeSelection);
            }
<span class="nc" id="L3011">        }</span>

<span class="nc bnc" id="L3013" title="All 2 branches missed.">        public boolean isEnabled() { return (tree != null &amp;&amp;</span>
<span class="nc bnc" id="L3014" title="All 2 branches missed.">                                             tree.isEnabled()); }</span>

    } // End of class BasicTreeUI.TreeIncrementAction

    /**
      * TreeHomeAction is used to handle end/home actions.
      * Scrolls either the first or last cell to be visible based on
      * direction.
      */
    public class TreeHomeAction extends AbstractAction {
        protected int            direction;
        /** Set to true if append to selection. */
        private boolean          addToSelection;
        private boolean          changeSelection;

        public TreeHomeAction(int direction, String name) {
<span class="nc" id="L3030">            this(direction, name, false, true);</span>
<span class="nc" id="L3031">        }</span>

        private TreeHomeAction(int direction, String name,
                               boolean addToSelection,
<span class="nc" id="L3035">                               boolean changeSelection) {</span>
<span class="nc" id="L3036">            this.direction = direction;</span>
<span class="nc" id="L3037">            this.changeSelection = changeSelection;</span>
<span class="nc" id="L3038">            this.addToSelection = addToSelection;</span>
<span class="nc" id="L3039">        }</span>

        public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L3042" title="All 2 branches missed.">            if (tree != null) {</span>
<span class="nc" id="L3043">                SHARED_ACTION.home(tree, BasicTreeUI.this, direction,</span>
                                   addToSelection, changeSelection);
            }
<span class="nc" id="L3046">        }</span>

<span class="nc bnc" id="L3048" title="All 2 branches missed.">        public boolean isEnabled() { return (tree != null &amp;&amp;</span>
<span class="nc bnc" id="L3049" title="All 2 branches missed.">                                             tree.isEnabled()); }</span>

    } // End of class BasicTreeUI.TreeHomeAction


    /**
      * For the first selected row expandedness will be toggled.
      */
    public class TreeToggleAction extends AbstractAction {
<span class="nc" id="L3058">        public TreeToggleAction(String name) {</span>
<span class="nc" id="L3059">        }</span>

        public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L3062" title="All 2 branches missed.">            if(tree != null) {</span>
<span class="nc" id="L3063">                SHARED_ACTION.toggle(tree, BasicTreeUI.this);</span>
            }
<span class="nc" id="L3065">        }</span>

<span class="nc bnc" id="L3067" title="All 2 branches missed.">        public boolean isEnabled() { return (tree != null &amp;&amp;</span>
<span class="nc bnc" id="L3068" title="All 2 branches missed.">                                             tree.isEnabled()); }</span>

    } // End of class BasicTreeUI.TreeToggleAction


    /**
     * ActionListener that invokes cancelEditing when action performed.
     */
    public class TreeCancelEditingAction extends AbstractAction {
<span class="nc" id="L3077">        public TreeCancelEditingAction(String name) {</span>
<span class="nc" id="L3078">        }</span>

        public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L3081" title="All 2 branches missed.">            if(tree != null) {</span>
<span class="nc" id="L3082">                SHARED_ACTION.cancelEditing(tree, BasicTreeUI.this);</span>
            }
<span class="nc" id="L3084">        }</span>

<span class="nc bnc" id="L3086" title="All 2 branches missed.">        public boolean isEnabled() { return (tree != null &amp;&amp;</span>
<span class="nc bnc" id="L3087" title="All 2 branches missed.">                                             tree.isEnabled() &amp;&amp;</span>
<span class="nc bnc" id="L3088" title="All 2 branches missed.">                                             isEditing(tree)); }</span>
    } // End of class BasicTreeUI.TreeCancelEditingAction


    /**
      * MouseInputHandler handles passing all mouse events,
      * including mouse motion events, until the mouse is released to
      * the destination it is constructed with. It is assumed all the
      * events are currently target at source.
      */
    public class MouseInputHandler extends Object implements
                     MouseInputListener
    {
        /** Source that events are coming from. */
        protected Component        source;
        /** Destination that receives all events. */
        protected Component        destination;
        private Component          focusComponent;
        private boolean            dispatchedEvent;

        public MouseInputHandler(Component source, Component destination,
                                      MouseEvent event){
<span class="nc" id="L3110">            this(source, destination, event, null);</span>
<span class="nc" id="L3111">        }</span>

        MouseInputHandler(Component source, Component destination,
<span class="nc" id="L3114">                          MouseEvent event, Component focusComponent) {</span>
<span class="nc" id="L3115">            this.source = source;</span>
<span class="nc" id="L3116">            this.destination = destination;</span>
<span class="nc" id="L3117">            this.source.addMouseListener(this);</span>
<span class="nc" id="L3118">            this.source.addMouseMotionListener(this);</span>

<span class="nc" id="L3120">            SwingUtilities2.setSkipClickCount(destination,</span>
<span class="nc" id="L3121">                                              event.getClickCount() - 1);</span>

            /* Dispatch the editing event! */
<span class="nc" id="L3124">            destination.dispatchEvent(SwingUtilities.convertMouseEvent</span>
<span class="nc" id="L3125">                                          (source, event, destination));</span>
<span class="nc" id="L3126">            this.focusComponent = focusComponent;</span>
<span class="nc" id="L3127">        }</span>

        public void mouseClicked(MouseEvent e) {
<span class="nc bnc" id="L3130" title="All 2 branches missed.">            if(destination != null) {</span>
<span class="nc" id="L3131">                dispatchedEvent = true;</span>
<span class="nc" id="L3132">                destination.dispatchEvent(SwingUtilities.convertMouseEvent</span>
<span class="nc" id="L3133">                                          (source, e, destination));</span>
            }
<span class="nc" id="L3135">        }</span>

        public void mousePressed(MouseEvent e) {
<span class="nc" id="L3138">        }</span>

        public void mouseReleased(MouseEvent e) {
<span class="nc bnc" id="L3141" title="All 2 branches missed.">            if(destination != null)</span>
<span class="nc" id="L3142">                destination.dispatchEvent(SwingUtilities.convertMouseEvent</span>
<span class="nc" id="L3143">                                          (source, e, destination));</span>
<span class="nc" id="L3144">            removeFromSource();</span>
<span class="nc" id="L3145">        }</span>

        public void mouseEntered(MouseEvent e) {
<span class="nc bnc" id="L3148" title="All 2 branches missed.">            if (!SwingUtilities.isLeftMouseButton(e)) {</span>
<span class="nc" id="L3149">                removeFromSource();</span>
            }
<span class="nc" id="L3151">        }</span>

        public void mouseExited(MouseEvent e) {
<span class="nc bnc" id="L3154" title="All 2 branches missed.">            if (!SwingUtilities.isLeftMouseButton(e)) {</span>
<span class="nc" id="L3155">                removeFromSource();</span>
            }
<span class="nc" id="L3157">        }</span>

        public void mouseDragged(MouseEvent e) {
<span class="nc bnc" id="L3160" title="All 2 branches missed.">            if(destination != null) {</span>
<span class="nc" id="L3161">                dispatchedEvent = true;</span>
<span class="nc" id="L3162">                destination.dispatchEvent(SwingUtilities.convertMouseEvent</span>
<span class="nc" id="L3163">                                          (source, e, destination));</span>
            }
<span class="nc" id="L3165">        }</span>

        public void mouseMoved(MouseEvent e) {
<span class="nc" id="L3168">            removeFromSource();</span>
<span class="nc" id="L3169">        }</span>

        protected void removeFromSource() {
<span class="nc bnc" id="L3172" title="All 2 branches missed.">            if(source != null) {</span>
<span class="nc" id="L3173">                source.removeMouseListener(this);</span>
<span class="nc" id="L3174">                source.removeMouseMotionListener(this);</span>
<span class="nc bnc" id="L3175" title="All 8 branches missed.">                if (focusComponent != null &amp;&amp;</span>
                      focusComponent == destination &amp;&amp; !dispatchedEvent &amp;&amp;
                      (focusComponent instanceof JTextField)) {
<span class="nc" id="L3178">                    ((JTextField)focusComponent).selectAll();</span>
                }
            }
<span class="nc" id="L3181">            source = destination = null;</span>
<span class="nc" id="L3182">        }</span>

    } // End of class BasicTreeUI.MouseInputHandler

<span class="nc" id="L3186">    private static final TransferHandler defaultTransferHandler = new TreeTransferHandler();</span>

<span class="nc" id="L3188">    static class TreeTransferHandler extends TransferHandler implements UIResource, Comparator&lt;TreePath&gt; {</span>

        private JTree tree;

        /**
         * Create a Transferable to use as the source for a data transfer.
         *
         * @param c  The component holding the data to be transfered.  This
         *  argument is provided to enable sharing of TransferHandlers by
         *  multiple components.
         * @return  The representation of the data to be transfered.
         *
         */
        protected Transferable createTransferable(JComponent c) {
<span class="nc bnc" id="L3202" title="All 2 branches missed.">            if (c instanceof JTree) {</span>
<span class="nc" id="L3203">                tree = (JTree) c;</span>
<span class="nc" id="L3204">                TreePath[] paths = tree.getSelectionPaths();</span>

<span class="nc bnc" id="L3206" title="All 4 branches missed.">                if (paths == null || paths.length == 0) {</span>
<span class="nc" id="L3207">                    return null;</span>
                }

<span class="nc" id="L3210">                StringBuffer plainBuf = new StringBuffer();</span>
<span class="nc" id="L3211">                StringBuffer htmlBuf = new StringBuffer();</span>

<span class="nc" id="L3213">                htmlBuf.append(&quot;&lt;html&gt;\n&lt;body&gt;\n&lt;ul&gt;\n&quot;);</span>

<span class="nc" id="L3215">                TreeModel model = tree.getModel();</span>
<span class="nc" id="L3216">                TreePath lastPath = null;</span>
<span class="nc" id="L3217">                TreePath[] displayPaths = getDisplayOrderPaths(paths);</span>

<span class="nc bnc" id="L3219" title="All 2 branches missed.">                for (TreePath path : displayPaths) {</span>
<span class="nc" id="L3220">                    Object node = path.getLastPathComponent();</span>
<span class="nc" id="L3221">                    boolean leaf = model.isLeaf(node);</span>
<span class="nc" id="L3222">                    String label = getDisplayString(path, true, leaf);</span>

<span class="nc" id="L3224">                    plainBuf.append(label + &quot;\n&quot;);</span>
<span class="nc" id="L3225">                    htmlBuf.append(&quot;  &lt;li&gt;&quot; + label + &quot;\n&quot;);</span>
                }

                // remove the last newline
<span class="nc" id="L3229">                plainBuf.deleteCharAt(plainBuf.length() - 1);</span>
<span class="nc" id="L3230">                htmlBuf.append(&quot;&lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;&quot;);</span>

<span class="nc" id="L3232">                tree = null;</span>

<span class="nc" id="L3234">                return new BasicTransferable(plainBuf.toString(), htmlBuf.toString());</span>
            }

<span class="nc" id="L3237">            return null;</span>
        }

        public int compare(TreePath o1, TreePath o2) {
<span class="nc" id="L3241">            int row1 = tree.getRowForPath(o1);</span>
<span class="nc" id="L3242">            int row2 = tree.getRowForPath(o2);</span>
<span class="nc" id="L3243">            return row1 - row2;</span>
        }

        String getDisplayString(TreePath path, boolean selected, boolean leaf) {
<span class="nc" id="L3247">            int row = tree.getRowForPath(path);</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">            boolean hasFocus = tree.getLeadSelectionRow() == row;</span>
<span class="nc" id="L3249">            Object node = path.getLastPathComponent();</span>
<span class="nc" id="L3250">            return tree.convertValueToText(node, selected, tree.isExpanded(row),</span>
                                           leaf, row, hasFocus);
        }

        /**
         * Selection paths are in selection order.  The conversion to
         * HTML requires display order.  This method resorts the paths
         * to be in the display order.
         */
        TreePath[] getDisplayOrderPaths(TreePath[] paths) {
            // sort the paths to display order rather than selection order
<span class="nc" id="L3261">            ArrayList&lt;TreePath&gt; selOrder = new ArrayList&lt;TreePath&gt;();</span>
<span class="nc bnc" id="L3262" title="All 2 branches missed.">            for (TreePath path : paths) {</span>
<span class="nc" id="L3263">                selOrder.add(path);</span>
            }
<span class="nc" id="L3265">            Collections.sort(selOrder, this);</span>
<span class="nc" id="L3266">            int n = selOrder.size();</span>
<span class="nc" id="L3267">            TreePath[] displayPaths = new TreePath[n];</span>
<span class="nc bnc" id="L3268" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L3269">                displayPaths[i] = selOrder.get(i);</span>
            }
<span class="nc" id="L3271">            return displayPaths;</span>
        }

        public int getSourceActions(JComponent c) {
<span class="nc" id="L3275">            return COPY;</span>
        }

    }


<span class="nc" id="L3281">    private class Handler implements CellEditorListener, FocusListener,</span>
                  KeyListener, MouseListener, MouseMotionListener,
                  PropertyChangeListener, TreeExpansionListener,
                  TreeModelListener, TreeSelectionListener,
                  BeforeDrag {
        //
        // KeyListener
        //
<span class="nc" id="L3289">        private String prefix = &quot;&quot;;</span>
<span class="nc" id="L3290">        private String typedString = &quot;&quot;;</span>
<span class="nc" id="L3291">        private long lastTime = 0L;</span>

        /**
         * Invoked when a key has been typed.
         *
         * Moves the keyboard focus to the first element whose prefix matches the
         * sequence of alphanumeric keys pressed by the user with delay less
         * than value of &lt;code&gt;timeFactor&lt;/code&gt; property (or 1000 milliseconds
         * if it is not defined). Subsequent same key presses move the keyboard
         * focus to the next object that starts with the same letter until another
         * key is pressed, then it is treated as the prefix with appropriate number
         * of the same letters followed by first typed another letter.
         */
        public void keyTyped(KeyEvent e) {
            // handle first letter navigation
<span class="nc bnc" id="L3306" title="All 6 branches missed.">            if(tree != null &amp;&amp; tree.getRowCount()&gt;0 &amp;&amp; tree.hasFocus() &amp;&amp;</span>
<span class="nc bnc" id="L3307" title="All 2 branches missed.">               tree.isEnabled()) {</span>
<span class="nc bnc" id="L3308" title="All 4 branches missed.">                if (e.isAltDown() || BasicGraphicsUtils.isMenuShortcutKeyDown(e) ||</span>
<span class="nc bnc" id="L3309" title="All 2 branches missed.">                    isNavigationKey(e)) {</span>
<span class="nc" id="L3310">                    return;</span>
                }
<span class="nc" id="L3312">                boolean startingFromSelection = true;</span>

<span class="nc" id="L3314">                char c = e.getKeyChar();</span>

<span class="nc" id="L3316">                long time = e.getWhen();</span>
<span class="nc" id="L3317">                int startingRow = tree.getLeadSelectionRow();</span>
<span class="nc bnc" id="L3318" title="All 2 branches missed.">                if (time - lastTime &lt; timeFactor) {</span>
<span class="nc" id="L3319">                    typedString += c;</span>
<span class="nc bnc" id="L3320" title="All 4 branches missed.">                    if((prefix.length() == 1) &amp;&amp; (c == prefix.charAt(0))) {</span>
                        // Subsequent same key presses move the keyboard focus to the next
                        // object that starts with the same letter.
<span class="nc" id="L3323">                        startingRow++;</span>
                    } else {
<span class="nc" id="L3325">                        prefix = typedString;</span>
                    }
                } else {
<span class="nc" id="L3328">                    startingRow++;</span>
<span class="nc" id="L3329">                    typedString = &quot;&quot; + c;</span>
<span class="nc" id="L3330">                    prefix = typedString;</span>
                }
<span class="nc" id="L3332">                lastTime = time;</span>

<span class="nc bnc" id="L3334" title="All 4 branches missed.">                if (startingRow &lt; 0 || startingRow &gt;= tree.getRowCount()) {</span>
<span class="nc" id="L3335">                    startingFromSelection = false;</span>
<span class="nc" id="L3336">                    startingRow = 0;</span>
                }
<span class="nc" id="L3338">                TreePath path = tree.getNextMatch(prefix, startingRow,</span>
                                                  Position.Bias.Forward);
<span class="nc bnc" id="L3340" title="All 2 branches missed.">                if (path != null) {</span>
<span class="nc" id="L3341">                    tree.setSelectionPath(path);</span>
<span class="nc" id="L3342">                    int row = getRowForPath(tree, path);</span>
<span class="nc" id="L3343">                    ensureRowsAreVisible(row, row);</span>
<span class="nc bnc" id="L3344" title="All 2 branches missed.">                } else if (startingFromSelection) {</span>
<span class="nc" id="L3345">                    path = tree.getNextMatch(prefix, 0,</span>
                                             Position.Bias.Forward);
<span class="nc bnc" id="L3347" title="All 2 branches missed.">                    if (path != null) {</span>
<span class="nc" id="L3348">                        tree.setSelectionPath(path);</span>
<span class="nc" id="L3349">                        int row = getRowForPath(tree, path);</span>
<span class="nc" id="L3350">                        ensureRowsAreVisible(row, row);</span>
                    }
                }
            }
<span class="nc" id="L3354">        }</span>

        /**
         * Invoked when a key has been pressed.
         *
         * Checks to see if the key event is a navigation key to prevent
         * dispatching these keys for the first letter navigation.
         */
        public void keyPressed(KeyEvent e) {
<span class="nc bnc" id="L3363" title="All 4 branches missed.">            if (tree != null &amp;&amp; isNavigationKey(e)) {</span>
<span class="nc" id="L3364">                prefix = &quot;&quot;;</span>
<span class="nc" id="L3365">                typedString = &quot;&quot;;</span>
<span class="nc" id="L3366">                lastTime = 0L;</span>
            }
<span class="nc" id="L3368">        }</span>

        public void keyReleased(KeyEvent e) {
<span class="nc" id="L3371">        }</span>

        /**
         * Returns whether or not the supplied key event maps to a key that is used for
         * navigation.  This is used for optimizing key input by only passing non-
         * navigation keys to the first letter navigation mechanism.
         */
        private boolean isNavigationKey(KeyEvent event) {
<span class="nc" id="L3379">            InputMap inputMap = tree.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);</span>
<span class="nc" id="L3380">            KeyStroke key = KeyStroke.getKeyStrokeForEvent(event);</span>

<span class="nc bnc" id="L3382" title="All 4 branches missed.">            return inputMap != null &amp;&amp; inputMap.get(key) != null;</span>
        }


        //
        // PropertyChangeListener
        //
        public void propertyChange(PropertyChangeEvent event) {
<span class="nc bnc" id="L3390" title="All 2 branches missed.">            if (event.getSource() == treeSelectionModel) {</span>
<span class="nc" id="L3391">                treeSelectionModel.resetRowSelection();</span>
            }
<span class="nc bnc" id="L3393" title="All 2 branches missed.">            else if(event.getSource() == tree) {</span>
<span class="nc" id="L3394">                String              changeName = event.getPropertyName();</span>

<span class="nc bnc" id="L3396" title="All 2 branches missed.">                if (changeName == JTree.LEAD_SELECTION_PATH_PROPERTY) {</span>
<span class="nc bnc" id="L3397" title="All 2 branches missed.">                    if (!ignoreLAChange) {</span>
<span class="nc" id="L3398">                        updateLeadSelectionRow();</span>
<span class="nc" id="L3399">                        repaintPath((TreePath)event.getOldValue());</span>
<span class="nc" id="L3400">                        repaintPath((TreePath)event.getNewValue());</span>
                    }
                }
<span class="nc bnc" id="L3403" title="All 2 branches missed.">                else if (changeName == JTree.ANCHOR_SELECTION_PATH_PROPERTY) {</span>
<span class="nc bnc" id="L3404" title="All 2 branches missed.">                    if (!ignoreLAChange) {</span>
<span class="nc" id="L3405">                        repaintPath((TreePath)event.getOldValue());</span>
<span class="nc" id="L3406">                        repaintPath((TreePath)event.getNewValue());</span>
                    }
                }
<span class="nc bnc" id="L3409" title="All 2 branches missed.">                if(changeName == JTree.CELL_RENDERER_PROPERTY) {</span>
<span class="nc" id="L3410">                    setCellRenderer((TreeCellRenderer)event.getNewValue());</span>
<span class="nc" id="L3411">                    redoTheLayout();</span>
                }
<span class="nc bnc" id="L3413" title="All 2 branches missed.">                else if(changeName == JTree.TREE_MODEL_PROPERTY) {</span>
<span class="nc" id="L3414">                    setModel((TreeModel)event.getNewValue());</span>
                }
<span class="nc bnc" id="L3416" title="All 2 branches missed.">                else if(changeName == JTree.ROOT_VISIBLE_PROPERTY) {</span>
<span class="nc" id="L3417">                    setRootVisible(((Boolean)event.getNewValue()).</span>
<span class="nc" id="L3418">                                   booleanValue());</span>
                }
<span class="nc bnc" id="L3420" title="All 2 branches missed.">                else if(changeName == JTree.SHOWS_ROOT_HANDLES_PROPERTY) {</span>
<span class="nc" id="L3421">                    setShowsRootHandles(((Boolean)event.getNewValue()).</span>
<span class="nc" id="L3422">                                        booleanValue());</span>
                }
<span class="nc bnc" id="L3424" title="All 2 branches missed.">                else if(changeName == JTree.ROW_HEIGHT_PROPERTY) {</span>
<span class="nc" id="L3425">                    setRowHeight(((Integer)event.getNewValue()).</span>
<span class="nc" id="L3426">                                 intValue());</span>
                }
<span class="nc bnc" id="L3428" title="All 2 branches missed.">                else if(changeName == JTree.CELL_EDITOR_PROPERTY) {</span>
<span class="nc" id="L3429">                    setCellEditor((TreeCellEditor)event.getNewValue());</span>
                }
<span class="nc bnc" id="L3431" title="All 2 branches missed.">                else if(changeName == JTree.EDITABLE_PROPERTY) {</span>
<span class="nc" id="L3432">                    setEditable(((Boolean)event.getNewValue()).booleanValue());</span>
                }
<span class="nc bnc" id="L3434" title="All 2 branches missed.">                else if(changeName == JTree.LARGE_MODEL_PROPERTY) {</span>
<span class="nc" id="L3435">                    setLargeModel(tree.isLargeModel());</span>
                }
<span class="nc bnc" id="L3437" title="All 2 branches missed.">                else if(changeName == JTree.SELECTION_MODEL_PROPERTY) {</span>
<span class="nc" id="L3438">                    setSelectionModel(tree.getSelectionModel());</span>
                }
<span class="nc bnc" id="L3440" title="All 2 branches missed.">                else if(changeName == &quot;font&quot;) {</span>
<span class="nc" id="L3441">                    completeEditing();</span>
<span class="nc bnc" id="L3442" title="All 2 branches missed.">                    if(treeState != null)</span>
<span class="nc" id="L3443">                        treeState.invalidateSizes();</span>
<span class="nc" id="L3444">                    updateSize();</span>
                }
<span class="nc bnc" id="L3446" title="All 2 branches missed.">                else if (changeName == &quot;componentOrientation&quot;) {</span>
<span class="nc bnc" id="L3447" title="All 2 branches missed.">                    if (tree != null) {</span>
<span class="nc" id="L3448">                        leftToRight = BasicGraphicsUtils.isLeftToRight(tree);</span>
<span class="nc" id="L3449">                        redoTheLayout();</span>
<span class="nc" id="L3450">                        tree.treeDidChange();</span>

<span class="nc" id="L3452">                        InputMap km = getInputMap(JComponent.WHEN_FOCUSED);</span>
<span class="nc" id="L3453">                        SwingUtilities.replaceUIInputMap(tree,</span>
                                                JComponent.WHEN_FOCUSED, km);
<span class="nc" id="L3455">                    }</span>
<span class="nc bnc" id="L3456" title="All 2 branches missed.">                } else if (&quot;dropLocation&quot; == changeName) {</span>
<span class="nc" id="L3457">                    JTree.DropLocation oldValue = (JTree.DropLocation)event.getOldValue();</span>
<span class="nc" id="L3458">                    repaintDropLocation(oldValue);</span>
<span class="nc" id="L3459">                    repaintDropLocation(tree.getDropLocation());</span>
                }
            }
<span class="nc" id="L3462">        }</span>

        private void repaintDropLocation(JTree.DropLocation loc) {
<span class="nc bnc" id="L3465" title="All 2 branches missed.">            if (loc == null) {</span>
<span class="nc" id="L3466">                return;</span>
            }

            Rectangle r;

<span class="nc bnc" id="L3471" title="All 2 branches missed.">            if (isDropLine(loc)) {</span>
<span class="nc" id="L3472">                r = getDropLineRect(loc);</span>
            } else {
<span class="nc" id="L3474">                r = tree.getPathBounds(loc.getPath());</span>
            }

<span class="nc bnc" id="L3477" title="All 2 branches missed.">            if (r != null) {</span>
<span class="nc" id="L3478">                tree.repaint(r);</span>
            }
<span class="nc" id="L3480">        }</span>

        //
        // MouseListener
        //

        // Whether or not the mouse press (which is being considered as part
        // of a drag sequence) also caused the selection change to be fully
        // processed.
        private boolean dragPressDidSelection;

        // Set to true when a drag gesture has been fully recognized and DnD
        // begins. Use this to ignore further mouse events which could be
        // delivered if DnD is cancelled (via ESCAPE for example)
        private boolean dragStarted;

        // The path over which the press occurred and the press event itself
        private TreePath pressedPath;
        private MouseEvent pressedEvent;

        // Used to detect whether the press event causes a selection change.
        // If it does, we won't try to start editing on the release.
        private boolean valueChangedOnPress;

        private boolean isActualPath(TreePath path, int x, int y) {
<span class="nc bnc" id="L3505" title="All 2 branches missed.">            if (path == null) {</span>
<span class="nc" id="L3506">                return false;</span>
            }

<span class="nc" id="L3509">            Rectangle bounds = getPathBounds(tree, path);</span>
<span class="nc bnc" id="L3510" title="All 4 branches missed.">            if (bounds == null || y &gt; (bounds.y + bounds.height)) {</span>
<span class="nc" id="L3511">                return false;</span>
            }

<span class="nc bnc" id="L3514" title="All 4 branches missed.">            return (x &gt;= bounds.x) &amp;&amp; (x &lt;= (bounds.x + bounds.width));</span>
        }

        public void mouseClicked(MouseEvent e) {
<span class="nc" id="L3518">        }</span>

        public void mouseEntered(MouseEvent e) {
<span class="nc" id="L3521">        }</span>

        public void mouseExited(MouseEvent e) {
<span class="nc" id="L3524">        }</span>

        /**
         * Invoked when a mouse button has been pressed on a component.
         */
        public void mousePressed(MouseEvent e) {
<span class="nc bnc" id="L3530" title="All 2 branches missed.">            if (SwingUtilities2.shouldIgnore(e, tree)) {</span>
<span class="nc" id="L3531">                return;</span>
            }

            // if we can't stop any ongoing editing, do nothing
<span class="nc bnc" id="L3535" title="All 4 branches missed.">            if (isEditing(tree) &amp;&amp; tree.getInvokesStopCellEditing()</span>
<span class="nc bnc" id="L3536" title="All 2 branches missed.">                                &amp;&amp; !stopEditing(tree)) {</span>
<span class="nc" id="L3537">                return;</span>
            }

<span class="nc" id="L3540">            completeEditing();</span>

<span class="nc" id="L3542">            pressedPath = getClosestPathForLocation(tree, e.getX(), e.getY());</span>

<span class="nc bnc" id="L3544" title="All 2 branches missed.">            if (tree.getDragEnabled()) {</span>
<span class="nc" id="L3545">                mousePressedDND(e);</span>
            } else {
<span class="nc" id="L3547">                SwingUtilities2.adjustFocus(tree);</span>
<span class="nc" id="L3548">                handleSelection(e);</span>
            }
<span class="nc" id="L3550">        }</span>

        private void mousePressedDND(MouseEvent e) {
<span class="nc" id="L3553">            pressedEvent = e;</span>
<span class="nc" id="L3554">            boolean grabFocus = true;</span>
<span class="nc" id="L3555">            dragStarted = false;</span>
<span class="nc" id="L3556">            valueChangedOnPress = false;</span>

            // if we have a valid path and this is a drag initiating event
<span class="nc bnc" id="L3559" title="All 2 branches missed.">            if (isActualPath(pressedPath, e.getX(), e.getY()) &amp;&amp;</span>
<span class="nc bnc" id="L3560" title="All 2 branches missed.">                    DragRecognitionSupport.mousePressed(e)) {</span>

<span class="nc" id="L3562">                dragPressDidSelection = false;</span>

<span class="nc bnc" id="L3564" title="All 2 branches missed.">                if (BasicGraphicsUtils.isMenuShortcutKeyDown(e)) {</span>
                    // do nothing for control - will be handled on release
                    // or when drag starts
<span class="nc" id="L3567">                    return;</span>
<span class="nc bnc" id="L3568" title="All 4 branches missed.">                } else if (!e.isShiftDown() &amp;&amp; tree.isPathSelected(pressedPath)) {</span>
                    // clicking on something that's already selected
                    // and need to make it the lead now
<span class="nc" id="L3571">                    setAnchorSelectionPath(pressedPath);</span>
<span class="nc" id="L3572">                    setLeadSelectionPath(pressedPath, true);</span>
<span class="nc" id="L3573">                    return;</span>
                }

<span class="nc" id="L3576">                dragPressDidSelection = true;</span>

                // could be a drag initiating event - don't grab focus
<span class="nc" id="L3579">                grabFocus = false;</span>
            }

<span class="nc bnc" id="L3582" title="All 2 branches missed.">            if (grabFocus) {</span>
<span class="nc" id="L3583">                SwingUtilities2.adjustFocus(tree);</span>
            }

<span class="nc" id="L3586">            handleSelection(e);</span>
<span class="nc" id="L3587">        }</span>

        void handleSelection(MouseEvent e) {
<span class="nc bnc" id="L3590" title="All 2 branches missed.">            if(pressedPath != null) {</span>
<span class="nc" id="L3591">                Rectangle bounds = getPathBounds(tree, pressedPath);</span>

<span class="nc bnc" id="L3593" title="All 4 branches missed.">                if (bounds == null || e.getY() &gt;= (bounds.y + bounds.height)) {</span>
<span class="nc" id="L3594">                    return;</span>
                }

                // Preferably checkForClickInExpandControl could take
                // the Event to do this it self!
<span class="nc bnc" id="L3599" title="All 2 branches missed.">                if(SwingUtilities.isLeftMouseButton(e)) {</span>
<span class="nc" id="L3600">                    checkForClickInExpandControl(pressedPath, e.getX(), e.getY());</span>
                }

<span class="nc" id="L3603">                int x = e.getX();</span>

                // Perhaps they clicked the cell itself. If so,
                // select it.
<span class="nc bnc" id="L3607" title="All 4 branches missed.">                if (x &gt;= bounds.x &amp;&amp; x &lt; (bounds.x + bounds.width)) {</span>
<span class="nc bnc" id="L3608" title="All 4 branches missed.">                    if (tree.getDragEnabled() || !startEditing(pressedPath, e)) {</span>
<span class="nc" id="L3609">                        selectPathForEvent(pressedPath, e);</span>
                    }
                }
            }
<span class="nc" id="L3613">        }</span>

        public void dragStarting(MouseEvent me) {
<span class="nc" id="L3616">            dragStarted = true;</span>

<span class="nc bnc" id="L3618" title="All 2 branches missed.">            if (BasicGraphicsUtils.isMenuShortcutKeyDown(me)) {</span>
<span class="nc" id="L3619">                tree.addSelectionPath(pressedPath);</span>
<span class="nc" id="L3620">                setAnchorSelectionPath(pressedPath);</span>
<span class="nc" id="L3621">                setLeadSelectionPath(pressedPath, true);</span>
            }

<span class="nc" id="L3624">            pressedEvent = null;</span>
<span class="nc" id="L3625">            pressedPath = null;</span>
<span class="nc" id="L3626">        }</span>

        public void mouseDragged(MouseEvent e) {
<span class="nc bnc" id="L3629" title="All 2 branches missed.">            if (SwingUtilities2.shouldIgnore(e, tree)) {</span>
<span class="nc" id="L3630">                return;</span>
            }

<span class="nc bnc" id="L3633" title="All 2 branches missed.">            if (tree.getDragEnabled()) {</span>
<span class="nc" id="L3634">                DragRecognitionSupport.mouseDragged(e, this);</span>
            }
<span class="nc" id="L3636">        }</span>

        /**
         * Invoked when the mouse button has been moved on a component
         * (with no buttons no down).
         */
        public void mouseMoved(MouseEvent e) {
<span class="nc" id="L3643">        }</span>

        public void mouseReleased(MouseEvent e) {
<span class="nc bnc" id="L3646" title="All 2 branches missed.">            if (SwingUtilities2.shouldIgnore(e, tree)) {</span>
<span class="nc" id="L3647">                return;</span>
            }

<span class="nc bnc" id="L3650" title="All 2 branches missed.">            if (tree.getDragEnabled()) {</span>
<span class="nc" id="L3651">                mouseReleasedDND(e);</span>
            }

<span class="nc" id="L3654">            pressedEvent = null;</span>
<span class="nc" id="L3655">            pressedPath = null;</span>
<span class="nc" id="L3656">        }</span>

        private void mouseReleasedDND(MouseEvent e) {
<span class="nc" id="L3659">            MouseEvent me = DragRecognitionSupport.mouseReleased(e);</span>
<span class="nc bnc" id="L3660" title="All 2 branches missed.">            if (me != null) {</span>
<span class="nc" id="L3661">                SwingUtilities2.adjustFocus(tree);</span>
<span class="nc bnc" id="L3662" title="All 2 branches missed.">                if (!dragPressDidSelection) {</span>
<span class="nc" id="L3663">                    handleSelection(me);</span>
                }
            }

<span class="nc bnc" id="L3667" title="All 2 branches missed.">            if (!dragStarted) {</span>

                // Note: We don't give the tree a chance to start editing if the
                // mouse press caused a selection change. Otherwise the default
                // tree cell editor will start editing on EVERY press and
                // release. If it turns out that this affects some editors, we
                // can always parameterize this with a client property. ex:
                //
                // if (pressedPath != null &amp;&amp;
                //         (Boolean.TRUE == tree.getClientProperty(&quot;Tree.DnD.canEditOnValueChange&quot;) ||
                //          !valueChangedOnPress) &amp;&amp; ...
<span class="nc bnc" id="L3678" title="All 4 branches missed.">                if (pressedPath != null &amp;&amp; !valueChangedOnPress &amp;&amp;</span>
<span class="nc bnc" id="L3679" title="All 2 branches missed.">                        isActualPath(pressedPath, pressedEvent.getX(), pressedEvent.getY())) {</span>

<span class="nc" id="L3681">                    startEditingOnRelease(pressedPath, pressedEvent, e);</span>
                }
            }
<span class="nc" id="L3684">        }</span>

        //
        // FocusListener
        //
        public void focusGained(FocusEvent e) {
<span class="nc bnc" id="L3690" title="All 2 branches missed.">            if(tree != null) {</span>
                Rectangle                 pBounds;

<span class="nc" id="L3693">                pBounds = getPathBounds(tree, tree.getLeadSelectionPath());</span>
<span class="nc bnc" id="L3694" title="All 2 branches missed.">                if(pBounds != null)</span>
<span class="nc" id="L3695">                    tree.repaint(getRepaintPathBounds(pBounds));</span>
<span class="nc" id="L3696">                pBounds = getPathBounds(tree, getLeadSelectionPath());</span>
<span class="nc bnc" id="L3697" title="All 2 branches missed.">                if(pBounds != null)</span>
<span class="nc" id="L3698">                    tree.repaint(getRepaintPathBounds(pBounds));</span>
            }
<span class="nc" id="L3700">        }</span>

        public void focusLost(FocusEvent e) {
<span class="nc" id="L3703">            focusGained(e);</span>
<span class="nc" id="L3704">        }</span>

        //
        // CellEditorListener
        //
        public void editingStopped(ChangeEvent e) {
<span class="nc" id="L3710">            completeEditing(false, false, true);</span>
<span class="nc" id="L3711">        }</span>

        /** Messaged when editing has been canceled in the tree. */
        public void editingCanceled(ChangeEvent e) {
<span class="nc" id="L3715">            completeEditing(false, false, false);</span>
<span class="nc" id="L3716">        }</span>


        //
        // TreeSelectionListener
        //
        public void valueChanged(TreeSelectionEvent event) {
<span class="nc" id="L3723">            valueChangedOnPress = true;</span>

            // Stop editing
<span class="nc" id="L3726">            completeEditing();</span>
            // Make sure all the paths are visible, if necessary.
            // PENDING: This should be tweaked when isAdjusting is added
<span class="nc bnc" id="L3729" title="All 4 branches missed.">            if(tree.getExpandsSelectedPaths() &amp;&amp; treeSelectionModel != null) {</span>
<span class="nc" id="L3730">                TreePath[]           paths = treeSelectionModel</span>
<span class="nc" id="L3731">                                         .getSelectionPaths();</span>

<span class="nc bnc" id="L3733" title="All 2 branches missed.">                if(paths != null) {</span>
<span class="nc bnc" id="L3734" title="All 2 branches missed.">                    for(int counter = paths.length - 1; counter &gt;= 0;</span>
<span class="nc" id="L3735">                        counter--) {</span>
<span class="nc" id="L3736">                        TreePath path = paths[counter].getParentPath();</span>
<span class="nc" id="L3737">                        boolean expand = true;</span>

<span class="nc bnc" id="L3739" title="All 2 branches missed.">                        while (path != null) {</span>
                            // Indicates this path isn't valid anymore,
                            // we shouldn't attempt to expand it then.
<span class="nc bnc" id="L3742" title="All 2 branches missed.">                            if (treeModel.isLeaf(path.getLastPathComponent())){</span>
<span class="nc" id="L3743">                                expand = false;</span>
<span class="nc" id="L3744">                                path = null;</span>
                            }
                            else {
<span class="nc" id="L3747">                                path = path.getParentPath();</span>
                            }
                        }
<span class="nc bnc" id="L3750" title="All 2 branches missed.">                        if (expand) {</span>
<span class="nc" id="L3751">                            tree.makeVisible(paths[counter]);</span>
                        }
                    }
                }
            }

<span class="nc" id="L3757">            TreePath oldLead = getLeadSelectionPath();</span>
<span class="nc" id="L3758">            lastSelectedRow = tree.getMinSelectionRow();</span>
<span class="nc" id="L3759">            TreePath lead = tree.getSelectionModel().getLeadSelectionPath();</span>
<span class="nc" id="L3760">            setAnchorSelectionPath(lead);</span>
<span class="nc" id="L3761">            setLeadSelectionPath(lead);</span>

<span class="nc" id="L3763">            TreePath[]       changedPaths = event.getPaths();</span>
            Rectangle        nodeBounds;
<span class="nc" id="L3765">            Rectangle        visRect = tree.getVisibleRect();</span>
<span class="nc" id="L3766">            boolean          paintPaths = true;</span>
<span class="nc" id="L3767">            int              nWidth = tree.getWidth();</span>

<span class="nc bnc" id="L3769" title="All 2 branches missed.">            if(changedPaths != null) {</span>
<span class="nc" id="L3770">                int              counter, maxCounter = changedPaths.length;</span>

<span class="nc bnc" id="L3772" title="All 2 branches missed.">                if(maxCounter &gt; 4) {</span>
<span class="nc" id="L3773">                    tree.repaint();</span>
<span class="nc" id="L3774">                    paintPaths = false;</span>
                }
                else {
<span class="nc bnc" id="L3777" title="All 2 branches missed.">                    for (counter = 0; counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L3778">                        nodeBounds = getPathBounds(tree,</span>
                                                   changedPaths[counter]);
<span class="nc bnc" id="L3780" title="All 2 branches missed.">                        if(nodeBounds != null &amp;&amp;</span>
<span class="nc bnc" id="L3781" title="All 2 branches missed.">                           visRect.intersects(nodeBounds))</span>
<span class="nc" id="L3782">                            tree.repaint(0, nodeBounds.y, nWidth,</span>
                                         nodeBounds.height);
                    }
                }
            }
<span class="nc bnc" id="L3787" title="All 2 branches missed.">            if(paintPaths) {</span>
<span class="nc" id="L3788">                nodeBounds = getPathBounds(tree, oldLead);</span>
<span class="nc bnc" id="L3789" title="All 4 branches missed.">                if(nodeBounds != null &amp;&amp; visRect.intersects(nodeBounds))</span>
<span class="nc" id="L3790">                    tree.repaint(0, nodeBounds.y, nWidth, nodeBounds.height);</span>
<span class="nc" id="L3791">                nodeBounds = getPathBounds(tree, lead);</span>
<span class="nc bnc" id="L3792" title="All 4 branches missed.">                if(nodeBounds != null &amp;&amp; visRect.intersects(nodeBounds))</span>
<span class="nc" id="L3793">                    tree.repaint(0, nodeBounds.y, nWidth, nodeBounds.height);</span>
            }
<span class="nc" id="L3795">        }</span>


        //
        // TreeExpansionListener
        //
        public void treeExpanded(TreeExpansionEvent event) {
<span class="nc bnc" id="L3802" title="All 4 branches missed.">            if(event != null &amp;&amp; tree != null) {</span>
<span class="nc" id="L3803">                TreePath      path = event.getPath();</span>

<span class="nc" id="L3805">                updateExpandedDescendants(path);</span>
            }
<span class="nc" id="L3807">        }</span>

        public void treeCollapsed(TreeExpansionEvent event) {
<span class="nc bnc" id="L3810" title="All 4 branches missed.">            if(event != null &amp;&amp; tree != null) {</span>
<span class="nc" id="L3811">                TreePath        path = event.getPath();</span>

<span class="nc" id="L3813">                completeEditing();</span>
<span class="nc bnc" id="L3814" title="All 4 branches missed.">                if(path != null &amp;&amp; tree.isVisible(path)) {</span>
<span class="nc" id="L3815">                    treeState.setExpandedState(path, false);</span>
<span class="nc" id="L3816">                    updateLeadSelectionRow();</span>
<span class="nc" id="L3817">                    updateSize();</span>
                }
            }
<span class="nc" id="L3820">        }</span>

        //
        // TreeModelListener
        //
        public void treeNodesChanged(TreeModelEvent e) {
<span class="nc bnc" id="L3826" title="All 4 branches missed.">            if(treeState != null &amp;&amp; e != null) {</span>
<span class="nc" id="L3827">                TreePath parentPath = SwingUtilities2.getTreePath(e, getModel());</span>
<span class="nc" id="L3828">                int[] indices = e.getChildIndices();</span>
<span class="nc bnc" id="L3829" title="All 4 branches missed.">                if (indices == null || indices.length == 0) {</span>
                    // The root has changed
<span class="nc" id="L3831">                    treeState.treeNodesChanged(e);</span>
<span class="nc" id="L3832">                    updateSize();</span>
                }
<span class="nc bnc" id="L3834" title="All 2 branches missed.">                else if (treeState.isExpanded(parentPath)) {</span>
                    // Changed nodes are visible
                    // Find the minimum index, we only need paint from there
                    // down.
<span class="nc" id="L3838">                    int minIndex = indices[0];</span>
<span class="nc bnc" id="L3839" title="All 2 branches missed.">                    for (int i = indices.length - 1; i &gt; 0; i--) {</span>
<span class="nc" id="L3840">                        minIndex = Math.min(indices[i], minIndex);</span>
                    }
<span class="nc" id="L3842">                    Object minChild = treeModel.getChild(</span>
<span class="nc" id="L3843">                            parentPath.getLastPathComponent(), minIndex);</span>
<span class="nc" id="L3844">                    TreePath minPath = parentPath.pathByAddingChild(minChild);</span>
<span class="nc" id="L3845">                    Rectangle minBounds = getPathBounds(tree, minPath);</span>

                    // Forward to the treestate
<span class="nc" id="L3848">                    treeState.treeNodesChanged(e);</span>

                    // Mark preferred size as bogus.
<span class="nc" id="L3851">                    updateSize0();</span>

                    // And repaint
<span class="nc" id="L3854">                    Rectangle newMinBounds = getPathBounds(tree, minPath);</span>
<span class="nc bnc" id="L3855" title="All 4 branches missed.">                    if (minBounds == null || newMinBounds == null) {</span>
<span class="nc" id="L3856">                        return;</span>
                    }

<span class="nc bnc" id="L3859" title="All 4 branches missed.">                    if (indices.length == 1 &amp;&amp;</span>
                            newMinBounds.height == minBounds.height) {
<span class="nc" id="L3861">                        tree.repaint(0, minBounds.y, tree.getWidth(),</span>
                                     minBounds.height);
                    }
                    else {
<span class="nc" id="L3865">                        tree.repaint(0, minBounds.y, tree.getWidth(),</span>
<span class="nc" id="L3866">                                     tree.getHeight() - minBounds.y);</span>
                    }
<span class="nc" id="L3868">                }</span>
                else {
                    // Nodes that changed aren't visible.  No need to paint
<span class="nc" id="L3871">                    treeState.treeNodesChanged(e);</span>
                }
            }
<span class="nc" id="L3874">        }</span>

        public void treeNodesInserted(TreeModelEvent e) {
<span class="nc bnc" id="L3877" title="All 4 branches missed.">            if(treeState != null &amp;&amp; e != null) {</span>
<span class="nc" id="L3878">                treeState.treeNodesInserted(e);</span>

<span class="nc" id="L3880">                updateLeadSelectionRow();</span>

<span class="nc" id="L3882">                TreePath       path = SwingUtilities2.getTreePath(e, getModel());</span>

<span class="nc bnc" id="L3884" title="All 2 branches missed.">                if(treeState.isExpanded(path)) {</span>
<span class="nc" id="L3885">                    updateSize();</span>
                }
                else {
                    // PENDING(sky): Need a method in TreeModelEvent
                    // that can return the count, getChildIndices allocs
                    // a new array!
<span class="nc" id="L3891">                    int[]      indices = e.getChildIndices();</span>
<span class="nc" id="L3892">                    int        childCount = treeModel.getChildCount</span>
<span class="nc" id="L3893">                                            (path.getLastPathComponent());</span>

<span class="nc bnc" id="L3895" title="All 4 branches missed.">                    if(indices != null &amp;&amp; (childCount - indices.length) == 0)</span>
<span class="nc" id="L3896">                        updateSize();</span>
                }
            }
<span class="nc" id="L3899">        }</span>

        public void treeNodesRemoved(TreeModelEvent e) {
<span class="nc bnc" id="L3902" title="All 4 branches missed.">            if(treeState != null &amp;&amp; e != null) {</span>
<span class="nc" id="L3903">                treeState.treeNodesRemoved(e);</span>

<span class="nc" id="L3905">                updateLeadSelectionRow();</span>

<span class="nc" id="L3907">                TreePath       path = SwingUtilities2.getTreePath(e, getModel());</span>

<span class="nc bnc" id="L3909" title="All 2 branches missed.">                if(treeState.isExpanded(path) ||</span>
<span class="nc bnc" id="L3910" title="All 2 branches missed.">                   treeModel.getChildCount(path.getLastPathComponent()) == 0)</span>
<span class="nc" id="L3911">                    updateSize();</span>
            }
<span class="nc" id="L3913">        }</span>

        public void treeStructureChanged(TreeModelEvent e) {
<span class="nc bnc" id="L3916" title="All 4 branches missed.">            if(treeState != null &amp;&amp; e != null) {</span>
<span class="nc" id="L3917">                treeState.treeStructureChanged(e);</span>

<span class="nc" id="L3919">                updateLeadSelectionRow();</span>

<span class="nc" id="L3921">                TreePath       pPath = SwingUtilities2.getTreePath(e, getModel());</span>

<span class="nc bnc" id="L3923" title="All 2 branches missed.">                if (pPath != null) {</span>
<span class="nc" id="L3924">                    pPath = pPath.getParentPath();</span>
                }
<span class="nc bnc" id="L3926" title="All 4 branches missed.">                if(pPath == null || treeState.isExpanded(pPath))</span>
<span class="nc" id="L3927">                    updateSize();</span>
            }
<span class="nc" id="L3929">        }</span>
    }



    private static class Actions extends UIAction {
        private static final String SELECT_PREVIOUS = &quot;selectPrevious&quot;;
        private static final String SELECT_PREVIOUS_CHANGE_LEAD =
                             &quot;selectPreviousChangeLead&quot;;
        private static final String SELECT_PREVIOUS_EXTEND_SELECTION =
                             &quot;selectPreviousExtendSelection&quot;;
        private static final String SELECT_NEXT = &quot;selectNext&quot;;
        private static final String SELECT_NEXT_CHANGE_LEAD =
                                    &quot;selectNextChangeLead&quot;;
        private static final String SELECT_NEXT_EXTEND_SELECTION =
                                    &quot;selectNextExtendSelection&quot;;
        private static final String SELECT_CHILD = &quot;selectChild&quot;;
        private static final String SELECT_CHILD_CHANGE_LEAD =
                                    &quot;selectChildChangeLead&quot;;
        private static final String SELECT_PARENT = &quot;selectParent&quot;;
        private static final String SELECT_PARENT_CHANGE_LEAD =
                                    &quot;selectParentChangeLead&quot;;
        private static final String SCROLL_UP_CHANGE_SELECTION =
                                    &quot;scrollUpChangeSelection&quot;;
        private static final String SCROLL_UP_CHANGE_LEAD =
                                    &quot;scrollUpChangeLead&quot;;
        private static final String SCROLL_UP_EXTEND_SELECTION =
                                    &quot;scrollUpExtendSelection&quot;;
        private static final String SCROLL_DOWN_CHANGE_SELECTION =
                                    &quot;scrollDownChangeSelection&quot;;
        private static final String SCROLL_DOWN_EXTEND_SELECTION =
                                    &quot;scrollDownExtendSelection&quot;;
        private static final String SCROLL_DOWN_CHANGE_LEAD =
                                    &quot;scrollDownChangeLead&quot;;
        private static final String SELECT_FIRST = &quot;selectFirst&quot;;
        private static final String SELECT_FIRST_CHANGE_LEAD =
                                    &quot;selectFirstChangeLead&quot;;
        private static final String SELECT_FIRST_EXTEND_SELECTION =
                                    &quot;selectFirstExtendSelection&quot;;
        private static final String SELECT_LAST = &quot;selectLast&quot;;
        private static final String SELECT_LAST_CHANGE_LEAD =
                                    &quot;selectLastChangeLead&quot;;
        private static final String SELECT_LAST_EXTEND_SELECTION =
                                    &quot;selectLastExtendSelection&quot;;
        private static final String TOGGLE = &quot;toggle&quot;;
        private static final String CANCEL_EDITING = &quot;cancel&quot;;
        private static final String START_EDITING = &quot;startEditing&quot;;
        private static final String SELECT_ALL = &quot;selectAll&quot;;
        private static final String CLEAR_SELECTION = &quot;clearSelection&quot;;
        private static final String SCROLL_LEFT = &quot;scrollLeft&quot;;
        private static final String SCROLL_RIGHT = &quot;scrollRight&quot;;
        private static final String SCROLL_LEFT_EXTEND_SELECTION =
                                    &quot;scrollLeftExtendSelection&quot;;
        private static final String SCROLL_RIGHT_EXTEND_SELECTION =
                                    &quot;scrollRightExtendSelection&quot;;
        private static final String SCROLL_RIGHT_CHANGE_LEAD =
                                    &quot;scrollRightChangeLead&quot;;
        private static final String SCROLL_LEFT_CHANGE_LEAD =
                                    &quot;scrollLeftChangeLead&quot;;
        private static final String EXPAND = &quot;expand&quot;;
        private static final String COLLAPSE = &quot;collapse&quot;;
        private static final String MOVE_SELECTION_TO_PARENT =
                                    &quot;moveSelectionToParent&quot;;

        // add the lead item to the selection without changing lead or anchor
        private static final String ADD_TO_SELECTION = &quot;addToSelection&quot;;

        // toggle the selected state of the lead item and move the anchor to it
        private static final String TOGGLE_AND_ANCHOR = &quot;toggleAndAnchor&quot;;

        // extend the selection to the lead item
        private static final String EXTEND_TO = &quot;extendTo&quot;;

        // move the anchor to the lead and ensure only that item is selected
        private static final String MOVE_SELECTION_TO = &quot;moveSelectionTo&quot;;

        Actions() {
<span class="nc" id="L4006">            super(null);</span>
<span class="nc" id="L4007">        }</span>

        Actions(String key) {
<span class="nc" id="L4010">            super(key);</span>
<span class="nc" id="L4011">        }</span>

        public boolean isEnabled(Object o) {
<span class="nc bnc" id="L4014" title="All 2 branches missed.">            if (o instanceof JTree) {</span>
<span class="nc bnc" id="L4015" title="All 2 branches missed.">                if (getName() == CANCEL_EDITING) {</span>
<span class="nc" id="L4016">                    return ((JTree)o).isEditing();</span>
                }
            }
<span class="nc" id="L4019">            return true;</span>
        }

        public void actionPerformed(ActionEvent e) {
<span class="nc" id="L4023">            JTree tree = (JTree)e.getSource();</span>
<span class="nc" id="L4024">            BasicTreeUI ui = (BasicTreeUI)BasicLookAndFeel.getUIOfType(</span>
<span class="nc" id="L4025">                             tree.getUI(), BasicTreeUI.class);</span>
<span class="nc bnc" id="L4026" title="All 2 branches missed.">            if (ui == null) {</span>
<span class="nc" id="L4027">                return;</span>
            }
<span class="nc" id="L4029">            String key = getName();</span>
<span class="nc bnc" id="L4030" title="All 2 branches missed.">            if (key == SELECT_PREVIOUS) {</span>
<span class="nc" id="L4031">                increment(tree, ui, -1, false, true);</span>
            }
<span class="nc bnc" id="L4033" title="All 2 branches missed.">            else if (key == SELECT_PREVIOUS_CHANGE_LEAD) {</span>
<span class="nc" id="L4034">                increment(tree, ui, -1, false, false);</span>
            }
<span class="nc bnc" id="L4036" title="All 2 branches missed.">            else if (key == SELECT_PREVIOUS_EXTEND_SELECTION) {</span>
<span class="nc" id="L4037">                increment(tree, ui, -1, true, true);</span>
            }
<span class="nc bnc" id="L4039" title="All 2 branches missed.">            else if (key == SELECT_NEXT) {</span>
<span class="nc" id="L4040">                increment(tree, ui, 1, false, true);</span>
            }
<span class="nc bnc" id="L4042" title="All 2 branches missed.">            else if (key == SELECT_NEXT_CHANGE_LEAD) {</span>
<span class="nc" id="L4043">                increment(tree, ui, 1, false, false);</span>
            }
<span class="nc bnc" id="L4045" title="All 2 branches missed.">            else if (key == SELECT_NEXT_EXTEND_SELECTION) {</span>
<span class="nc" id="L4046">                increment(tree, ui, 1, true, true);</span>
            }
<span class="nc bnc" id="L4048" title="All 2 branches missed.">            else if (key == SELECT_CHILD) {</span>
<span class="nc" id="L4049">                traverse(tree, ui, 1, true);</span>
            }
<span class="nc bnc" id="L4051" title="All 2 branches missed.">            else if (key == SELECT_CHILD_CHANGE_LEAD) {</span>
<span class="nc" id="L4052">                traverse(tree, ui, 1, false);</span>
            }
<span class="nc bnc" id="L4054" title="All 2 branches missed.">            else if (key == SELECT_PARENT) {</span>
<span class="nc" id="L4055">                traverse(tree, ui, -1, true);</span>
            }
<span class="nc bnc" id="L4057" title="All 2 branches missed.">            else if (key == SELECT_PARENT_CHANGE_LEAD) {</span>
<span class="nc" id="L4058">                traverse(tree, ui, -1, false);</span>
            }
<span class="nc bnc" id="L4060" title="All 2 branches missed.">            else if (key == SCROLL_UP_CHANGE_SELECTION) {</span>
<span class="nc" id="L4061">                page(tree, ui, -1, false, true);</span>
            }
<span class="nc bnc" id="L4063" title="All 2 branches missed.">            else if (key == SCROLL_UP_CHANGE_LEAD) {</span>
<span class="nc" id="L4064">                page(tree, ui, -1, false, false);</span>
            }
<span class="nc bnc" id="L4066" title="All 2 branches missed.">            else if (key == SCROLL_UP_EXTEND_SELECTION) {</span>
<span class="nc" id="L4067">                page(tree, ui, -1, true, true);</span>
            }
<span class="nc bnc" id="L4069" title="All 2 branches missed.">            else if (key == SCROLL_DOWN_CHANGE_SELECTION) {</span>
<span class="nc" id="L4070">                page(tree, ui, 1, false, true);</span>
            }
<span class="nc bnc" id="L4072" title="All 2 branches missed.">            else if (key == SCROLL_DOWN_EXTEND_SELECTION) {</span>
<span class="nc" id="L4073">                page(tree, ui, 1, true, true);</span>
            }
<span class="nc bnc" id="L4075" title="All 2 branches missed.">            else if (key == SCROLL_DOWN_CHANGE_LEAD) {</span>
<span class="nc" id="L4076">                page(tree, ui, 1, false, false);</span>
            }
<span class="nc bnc" id="L4078" title="All 2 branches missed.">            else if (key == SELECT_FIRST) {</span>
<span class="nc" id="L4079">                home(tree, ui, -1, false, true);</span>
            }
<span class="nc bnc" id="L4081" title="All 2 branches missed.">            else if (key == SELECT_FIRST_CHANGE_LEAD) {</span>
<span class="nc" id="L4082">                home(tree, ui, -1, false, false);</span>
            }
<span class="nc bnc" id="L4084" title="All 2 branches missed.">            else if (key == SELECT_FIRST_EXTEND_SELECTION) {</span>
<span class="nc" id="L4085">                home(tree, ui, -1, true, true);</span>
            }
<span class="nc bnc" id="L4087" title="All 2 branches missed.">            else if (key == SELECT_LAST) {</span>
<span class="nc" id="L4088">                home(tree, ui, 1, false, true);</span>
            }
<span class="nc bnc" id="L4090" title="All 2 branches missed.">            else if (key == SELECT_LAST_CHANGE_LEAD) {</span>
<span class="nc" id="L4091">                home(tree, ui, 1, false, false);</span>
            }
<span class="nc bnc" id="L4093" title="All 2 branches missed.">            else if (key == SELECT_LAST_EXTEND_SELECTION) {</span>
<span class="nc" id="L4094">                home(tree, ui, 1, true, true);</span>
            }
<span class="nc bnc" id="L4096" title="All 2 branches missed.">            else if (key == TOGGLE) {</span>
<span class="nc" id="L4097">                toggle(tree, ui);</span>
            }
<span class="nc bnc" id="L4099" title="All 2 branches missed.">            else if (key == CANCEL_EDITING) {</span>
<span class="nc" id="L4100">                cancelEditing(tree, ui);</span>
            }
<span class="nc bnc" id="L4102" title="All 2 branches missed.">            else if (key == START_EDITING) {</span>
<span class="nc" id="L4103">                startEditing(tree, ui);</span>
            }
<span class="nc bnc" id="L4105" title="All 2 branches missed.">            else if (key == SELECT_ALL) {</span>
<span class="nc" id="L4106">                selectAll(tree, ui, true);</span>
            }
<span class="nc bnc" id="L4108" title="All 2 branches missed.">            else if (key == CLEAR_SELECTION) {</span>
<span class="nc" id="L4109">                selectAll(tree, ui, false);</span>
            }
<span class="nc bnc" id="L4111" title="All 2 branches missed.">            else if (key == ADD_TO_SELECTION) {</span>
<span class="nc bnc" id="L4112" title="All 2 branches missed.">                if (ui.getRowCount(tree) &gt; 0) {</span>
<span class="nc" id="L4113">                    int lead = ui.getLeadSelectionRow();</span>
<span class="nc bnc" id="L4114" title="All 2 branches missed.">                    if (!tree.isRowSelected(lead)) {</span>
<span class="nc" id="L4115">                        TreePath aPath = ui.getAnchorSelectionPath();</span>
<span class="nc" id="L4116">                        tree.addSelectionRow(lead);</span>
<span class="nc" id="L4117">                        ui.setAnchorSelectionPath(aPath);</span>
                    }
<span class="nc" id="L4119">                }</span>
            }
<span class="nc bnc" id="L4121" title="All 2 branches missed.">            else if (key == TOGGLE_AND_ANCHOR) {</span>
<span class="nc bnc" id="L4122" title="All 2 branches missed.">                if (ui.getRowCount(tree) &gt; 0) {</span>
<span class="nc" id="L4123">                    int lead = ui.getLeadSelectionRow();</span>
<span class="nc" id="L4124">                    TreePath lPath = ui.getLeadSelectionPath();</span>
<span class="nc bnc" id="L4125" title="All 2 branches missed.">                    if (!tree.isRowSelected(lead)) {</span>
<span class="nc" id="L4126">                        tree.addSelectionRow(lead);</span>
                    } else {
<span class="nc" id="L4128">                        tree.removeSelectionRow(lead);</span>
<span class="nc" id="L4129">                        ui.setLeadSelectionPath(lPath);</span>
                    }
<span class="nc" id="L4131">                    ui.setAnchorSelectionPath(lPath);</span>
<span class="nc" id="L4132">                }</span>
            }
<span class="nc bnc" id="L4134" title="All 2 branches missed.">            else if (key == EXTEND_TO) {</span>
<span class="nc" id="L4135">                extendSelection(tree, ui);</span>
            }
<span class="nc bnc" id="L4137" title="All 2 branches missed.">            else if (key == MOVE_SELECTION_TO) {</span>
<span class="nc bnc" id="L4138" title="All 2 branches missed.">                if (ui.getRowCount(tree) &gt; 0) {</span>
<span class="nc" id="L4139">                    int lead = ui.getLeadSelectionRow();</span>
<span class="nc" id="L4140">                    tree.setSelectionInterval(lead, lead);</span>
<span class="nc" id="L4141">                }</span>
            }
<span class="nc bnc" id="L4143" title="All 2 branches missed.">            else if (key == SCROLL_LEFT) {</span>
<span class="nc" id="L4144">                scroll(tree, ui, SwingConstants.HORIZONTAL, -10);</span>
            }
<span class="nc bnc" id="L4146" title="All 2 branches missed.">            else if (key == SCROLL_RIGHT) {</span>
<span class="nc" id="L4147">                scroll(tree, ui, SwingConstants.HORIZONTAL, 10);</span>
            }
<span class="nc bnc" id="L4149" title="All 2 branches missed.">            else if (key == SCROLL_LEFT_EXTEND_SELECTION) {</span>
<span class="nc" id="L4150">                scrollChangeSelection(tree, ui, -1, true, true);</span>
            }
<span class="nc bnc" id="L4152" title="All 2 branches missed.">            else if (key == SCROLL_RIGHT_EXTEND_SELECTION) {</span>
<span class="nc" id="L4153">                scrollChangeSelection(tree, ui, 1, true, true);</span>
            }
<span class="nc bnc" id="L4155" title="All 2 branches missed.">            else if (key == SCROLL_RIGHT_CHANGE_LEAD) {</span>
<span class="nc" id="L4156">                scrollChangeSelection(tree, ui, 1, false, false);</span>
            }
<span class="nc bnc" id="L4158" title="All 2 branches missed.">            else if (key == SCROLL_LEFT_CHANGE_LEAD) {</span>
<span class="nc" id="L4159">                scrollChangeSelection(tree, ui, -1, false, false);</span>
            }
<span class="nc bnc" id="L4161" title="All 2 branches missed.">            else if (key == EXPAND) {</span>
<span class="nc" id="L4162">                expand(tree, ui);</span>
            }
<span class="nc bnc" id="L4164" title="All 2 branches missed.">            else if (key == COLLAPSE) {</span>
<span class="nc" id="L4165">                collapse(tree, ui);</span>
            }
<span class="nc bnc" id="L4167" title="All 2 branches missed.">            else if (key == MOVE_SELECTION_TO_PARENT) {</span>
<span class="nc" id="L4168">                moveSelectionToParent(tree, ui);</span>
            }
<span class="nc" id="L4170">        }</span>

        private void scrollChangeSelection(JTree tree, BasicTreeUI ui,
                           int direction, boolean addToSelection,
                           boolean changeSelection) {
            int           rowCount;

<span class="nc bnc" id="L4177" title="All 4 branches missed.">            if((rowCount = ui.getRowCount(tree)) &gt; 0 &amp;&amp;</span>
                ui.treeSelectionModel != null) {
                TreePath          newPath;
<span class="nc" id="L4180">                Rectangle         visRect = tree.getVisibleRect();</span>

<span class="nc bnc" id="L4182" title="All 2 branches missed.">                if (direction == -1) {</span>
<span class="nc" id="L4183">                    newPath = ui.getClosestPathForLocation(tree, visRect.x,</span>
                                                        visRect.y);
<span class="nc" id="L4185">                    visRect.x = Math.max(0, visRect.x - visRect.width);</span>
                }
                else {
<span class="nc" id="L4188">                    visRect.x = Math.min(Math.max(0, tree.getWidth() -</span>
                                   visRect.width), visRect.x + visRect.width);
<span class="nc" id="L4190">                    newPath = ui.getClosestPathForLocation(tree, visRect.x,</span>
                                                 visRect.y + visRect.height);
                }
                // Scroll
<span class="nc" id="L4194">                tree.scrollRectToVisible(visRect);</span>
                // select
<span class="nc bnc" id="L4196" title="All 2 branches missed.">                if (addToSelection) {</span>
<span class="nc" id="L4197">                    ui.extendSelection(newPath);</span>
                }
<span class="nc bnc" id="L4199" title="All 2 branches missed.">                else if(changeSelection) {</span>
<span class="nc" id="L4200">                    tree.setSelectionPath(newPath);</span>
                }
                else {
<span class="nc" id="L4203">                    ui.setLeadSelectionPath(newPath, true);</span>
                }
            }
<span class="nc" id="L4206">        }</span>

        private void scroll(JTree component, BasicTreeUI ui, int direction,
                            int amount) {
<span class="nc" id="L4210">            Rectangle visRect = component.getVisibleRect();</span>
<span class="nc" id="L4211">            Dimension size = component.getSize();</span>
<span class="nc bnc" id="L4212" title="All 2 branches missed.">            if (direction == SwingConstants.HORIZONTAL) {</span>
<span class="nc" id="L4213">                visRect.x += amount;</span>
<span class="nc" id="L4214">                visRect.x = Math.max(0, visRect.x);</span>
<span class="nc" id="L4215">                visRect.x = Math.min(Math.max(0, size.width - visRect.width),</span>
                                     visRect.x);
            }
            else {
<span class="nc" id="L4219">                visRect.y += amount;</span>
<span class="nc" id="L4220">                visRect.y = Math.max(0, visRect.y);</span>
<span class="nc" id="L4221">                visRect.y = Math.min(Math.max(0, size.width - visRect.height),</span>
                                     visRect.y);
            }
<span class="nc" id="L4224">            component.scrollRectToVisible(visRect);</span>
<span class="nc" id="L4225">        }</span>

        private void extendSelection(JTree tree, BasicTreeUI ui) {
<span class="nc bnc" id="L4228" title="All 2 branches missed.">            if (ui.getRowCount(tree) &gt; 0) {</span>
<span class="nc" id="L4229">                int       lead = ui.getLeadSelectionRow();</span>

<span class="nc bnc" id="L4231" title="All 2 branches missed.">                if (lead != -1) {</span>
<span class="nc" id="L4232">                    TreePath      leadP = ui.getLeadSelectionPath();</span>
<span class="nc" id="L4233">                    TreePath      aPath = ui.getAnchorSelectionPath();</span>
<span class="nc" id="L4234">                    int           aRow = ui.getRowForPath(tree, aPath);</span>

<span class="nc bnc" id="L4236" title="All 2 branches missed.">                    if(aRow == -1)</span>
<span class="nc" id="L4237">                        aRow = 0;</span>
<span class="nc" id="L4238">                    tree.setSelectionInterval(aRow, lead);</span>
<span class="nc" id="L4239">                    ui.setLeadSelectionPath(leadP);</span>
<span class="nc" id="L4240">                    ui.setAnchorSelectionPath(aPath);</span>
                }
            }
<span class="nc" id="L4243">        }</span>

        private void selectAll(JTree tree, BasicTreeUI ui, boolean selectAll) {
<span class="nc" id="L4246">            int                   rowCount = ui.getRowCount(tree);</span>

<span class="nc bnc" id="L4248" title="All 2 branches missed.">            if(rowCount &gt; 0) {</span>
<span class="nc bnc" id="L4249" title="All 2 branches missed.">                if(selectAll) {</span>
<span class="nc bnc" id="L4250" title="All 2 branches missed.">                    if (tree.getSelectionModel().getSelectionMode() ==</span>
                            TreeSelectionModel.SINGLE_TREE_SELECTION) {

<span class="nc" id="L4253">                        int lead = ui.getLeadSelectionRow();</span>
<span class="nc bnc" id="L4254" title="All 2 branches missed.">                        if (lead != -1) {</span>
<span class="nc" id="L4255">                            tree.setSelectionRow(lead);</span>
<span class="nc bnc" id="L4256" title="All 2 branches missed.">                        } else if (tree.getMinSelectionRow() == -1) {</span>
<span class="nc" id="L4257">                            tree.setSelectionRow(0);</span>
<span class="nc" id="L4258">                            ui.ensureRowsAreVisible(0, 0);</span>
                        }
<span class="nc" id="L4260">                        return;</span>
                    }

<span class="nc" id="L4263">                    TreePath      lastPath = ui.getLeadSelectionPath();</span>
<span class="nc" id="L4264">                    TreePath      aPath = ui.getAnchorSelectionPath();</span>

<span class="nc bnc" id="L4266" title="All 4 branches missed.">                    if(lastPath != null &amp;&amp; !tree.isVisible(lastPath)) {</span>
<span class="nc" id="L4267">                        lastPath = null;</span>
                    }
<span class="nc" id="L4269">                    tree.setSelectionInterval(0, rowCount - 1);</span>
<span class="nc bnc" id="L4270" title="All 2 branches missed.">                    if(lastPath != null) {</span>
<span class="nc" id="L4271">                        ui.setLeadSelectionPath(lastPath);</span>
                    }
<span class="nc bnc" id="L4273" title="All 4 branches missed.">                    if(aPath != null &amp;&amp; tree.isVisible(aPath)) {</span>
<span class="nc" id="L4274">                        ui.setAnchorSelectionPath(aPath);</span>
                    }
<span class="nc" id="L4276">                }</span>
                else {
<span class="nc" id="L4278">                    TreePath      lastPath = ui.getLeadSelectionPath();</span>
<span class="nc" id="L4279">                    TreePath      aPath = ui.getAnchorSelectionPath();</span>

<span class="nc" id="L4281">                    tree.clearSelection();</span>
<span class="nc" id="L4282">                    ui.setAnchorSelectionPath(aPath);</span>
<span class="nc" id="L4283">                    ui.setLeadSelectionPath(lastPath);</span>
                }
            }
<span class="nc" id="L4286">        }</span>

        private void startEditing(JTree tree, BasicTreeUI ui) {
<span class="nc" id="L4289">            TreePath   lead = ui.getLeadSelectionPath();</span>
<span class="nc bnc" id="L4290" title="All 2 branches missed.">            int        editRow = (lead != null) ?</span>
<span class="nc" id="L4291">                                     ui.getRowForPath(tree, lead) : -1;</span>

<span class="nc bnc" id="L4293" title="All 2 branches missed.">            if(editRow != -1) {</span>
<span class="nc" id="L4294">                tree.startEditingAtPath(lead);</span>
            }
<span class="nc" id="L4296">        }</span>

        private void cancelEditing(JTree tree, BasicTreeUI ui) {
<span class="nc" id="L4299">            tree.cancelEditing();</span>
<span class="nc" id="L4300">        }</span>

        private void toggle(JTree tree, BasicTreeUI ui) {
<span class="nc" id="L4303">            int            selRow = ui.getLeadSelectionRow();</span>

<span class="nc bnc" id="L4305" title="All 4 branches missed.">            if(selRow != -1 &amp;&amp; !ui.isLeaf(selRow)) {</span>
<span class="nc" id="L4306">                TreePath aPath = ui.getAnchorSelectionPath();</span>
<span class="nc" id="L4307">                TreePath lPath = ui.getLeadSelectionPath();</span>

<span class="nc" id="L4309">                ui.toggleExpandState(ui.getPathForRow(tree, selRow));</span>
<span class="nc" id="L4310">                ui.setAnchorSelectionPath(aPath);</span>
<span class="nc" id="L4311">                ui.setLeadSelectionPath(lPath);</span>
            }
<span class="nc" id="L4313">        }</span>

        private void expand(JTree tree, BasicTreeUI ui) {
<span class="nc" id="L4316">            int selRow = ui.getLeadSelectionRow();</span>
<span class="nc" id="L4317">            tree.expandRow(selRow);</span>
<span class="nc" id="L4318">        }</span>

        private void collapse(JTree tree, BasicTreeUI ui) {
<span class="nc" id="L4321">            int selRow = ui.getLeadSelectionRow();</span>
<span class="nc" id="L4322">            tree.collapseRow(selRow);</span>
<span class="nc" id="L4323">        }</span>

        private void increment(JTree tree, BasicTreeUI ui, int direction,
                               boolean addToSelection,
                               boolean changeSelection) {

            // disable moving of lead unless in discontiguous mode
<span class="nc bnc" id="L4330" title="All 4 branches missed.">            if (!addToSelection &amp;&amp; !changeSelection &amp;&amp;</span>
<span class="nc bnc" id="L4331" title="All 2 branches missed.">                    tree.getSelectionModel().getSelectionMode() !=</span>
                        TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION) {
<span class="nc" id="L4333">                changeSelection = true;</span>
            }

            int              rowCount;

<span class="nc bnc" id="L4338" title="All 2 branches missed.">            if(ui.treeSelectionModel != null &amp;&amp;</span>
<span class="nc bnc" id="L4339" title="All 2 branches missed.">                  (rowCount = tree.getRowCount()) &gt; 0) {</span>
<span class="nc" id="L4340">                int                  selIndex = ui.getLeadSelectionRow();</span>
                int                  newIndex;

<span class="nc bnc" id="L4343" title="All 2 branches missed.">                if(selIndex == -1) {</span>
<span class="nc bnc" id="L4344" title="All 2 branches missed.">                    if(direction == 1)</span>
<span class="nc" id="L4345">                        newIndex = 0;</span>
                    else
<span class="nc" id="L4347">                        newIndex = rowCount - 1;</span>
                }
                else
                    /* Aparently people don't like wrapping;( */
<span class="nc" id="L4351">                    newIndex = Math.min(rowCount - 1, Math.max</span>
<span class="nc" id="L4352">                                        (0, (selIndex + direction)));</span>
<span class="nc bnc" id="L4353" title="All 2 branches missed.">                if(addToSelection &amp;&amp; ui.treeSelectionModel.</span>
<span class="nc bnc" id="L4354" title="All 2 branches missed.">                        getSelectionMode() != TreeSelectionModel.</span>
                        SINGLE_TREE_SELECTION) {
<span class="nc" id="L4356">                    ui.extendSelection(tree.getPathForRow(newIndex));</span>
                }
<span class="nc bnc" id="L4358" title="All 2 branches missed.">                else if(changeSelection) {</span>
<span class="nc" id="L4359">                    tree.setSelectionInterval(newIndex, newIndex);</span>
                }
                else {
<span class="nc" id="L4362">                    ui.setLeadSelectionPath(tree.getPathForRow(newIndex),true);</span>
                }
<span class="nc" id="L4364">                ui.ensureRowsAreVisible(newIndex, newIndex);</span>
<span class="nc" id="L4365">                ui.lastSelectedRow = newIndex;</span>
            }
<span class="nc" id="L4367">        }</span>

        private void traverse(JTree tree, BasicTreeUI ui, int direction,
                              boolean changeSelection) {

            // disable moving of lead unless in discontiguous mode
<span class="nc bnc" id="L4373" title="All 2 branches missed.">            if (!changeSelection &amp;&amp;</span>
<span class="nc bnc" id="L4374" title="All 2 branches missed.">                    tree.getSelectionModel().getSelectionMode() !=</span>
                        TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION) {
<span class="nc" id="L4376">                changeSelection = true;</span>
            }

            int                rowCount;

<span class="nc bnc" id="L4381" title="All 2 branches missed.">            if((rowCount = tree.getRowCount()) &gt; 0) {</span>
<span class="nc" id="L4382">                int               minSelIndex = ui.getLeadSelectionRow();</span>
                int               newIndex;

<span class="nc bnc" id="L4385" title="All 2 branches missed.">                if(minSelIndex == -1)</span>
<span class="nc" id="L4386">                    newIndex = 0;</span>
                else {
                    /* Try and expand the node, otherwise go to next
                       node. */
<span class="nc bnc" id="L4390" title="All 2 branches missed.">                    if(direction == 1) {</span>
<span class="nc" id="L4391">                        TreePath minSelPath = ui.getPathForRow(tree, minSelIndex);</span>
<span class="nc" id="L4392">                        int childCount = tree.getModel().</span>
<span class="nc" id="L4393">                            getChildCount(minSelPath.getLastPathComponent());</span>
<span class="nc" id="L4394">                        newIndex = -1;</span>
<span class="nc bnc" id="L4395" title="All 2 branches missed.">                        if (!ui.isLeaf(minSelIndex)) {</span>
<span class="nc bnc" id="L4396" title="All 2 branches missed.">                            if (!tree.isExpanded(minSelIndex)) {</span>
<span class="nc" id="L4397">                                ui.toggleExpandState(minSelPath);</span>
                            }
<span class="nc bnc" id="L4399" title="All 2 branches missed.">                            else if (childCount &gt; 0) {</span>
<span class="nc" id="L4400">                                newIndex = Math.min(minSelIndex + 1, rowCount - 1);</span>
                            }
                        }
<span class="nc" id="L4403">                    }</span>
                    /* Try to collapse node. */
                    else {
<span class="nc bnc" id="L4406" title="All 2 branches missed.">                        if(!ui.isLeaf(minSelIndex) &amp;&amp;</span>
<span class="nc bnc" id="L4407" title="All 2 branches missed.">                           tree.isExpanded(minSelIndex)) {</span>
<span class="nc" id="L4408">                            ui.toggleExpandState(ui.getPathForRow</span>
<span class="nc" id="L4409">                                              (tree, minSelIndex));</span>
<span class="nc" id="L4410">                            newIndex = -1;</span>
                        }
                        else {
<span class="nc" id="L4413">                            TreePath         path = ui.getPathForRow(tree,</span>
                                                                  minSelIndex);

<span class="nc bnc" id="L4416" title="All 4 branches missed.">                            if(path != null &amp;&amp; path.getPathCount() &gt; 1) {</span>
<span class="nc" id="L4417">                                newIndex = ui.getRowForPath(tree, path.</span>
<span class="nc" id="L4418">                                                         getParentPath());</span>
                            }
                            else
<span class="nc" id="L4421">                                newIndex = -1;</span>
                        }
                    }
                }
<span class="nc bnc" id="L4425" title="All 2 branches missed.">                if(newIndex != -1) {</span>
<span class="nc bnc" id="L4426" title="All 2 branches missed.">                    if(changeSelection) {</span>
<span class="nc" id="L4427">                        tree.setSelectionInterval(newIndex, newIndex);</span>
                    }
                    else {
<span class="nc" id="L4430">                        ui.setLeadSelectionPath(ui.getPathForRow(</span>
                                                    tree, newIndex), true);
                    }
<span class="nc" id="L4433">                    ui.ensureRowsAreVisible(newIndex, newIndex);</span>
                }
            }
<span class="nc" id="L4436">        }</span>

        private void moveSelectionToParent(JTree tree, BasicTreeUI ui) {
<span class="nc" id="L4439">            int selRow = ui.getLeadSelectionRow();</span>
<span class="nc" id="L4440">            TreePath path = ui.getPathForRow(tree, selRow);</span>
<span class="nc bnc" id="L4441" title="All 4 branches missed.">            if (path != null &amp;&amp; path.getPathCount() &gt; 1) {</span>
<span class="nc" id="L4442">                int  newIndex = ui.getRowForPath(tree, path.getParentPath());</span>
<span class="nc bnc" id="L4443" title="All 2 branches missed.">                if (newIndex != -1) {</span>
<span class="nc" id="L4444">                    tree.setSelectionInterval(newIndex, newIndex);</span>
<span class="nc" id="L4445">                    ui.ensureRowsAreVisible(newIndex, newIndex);</span>
                }
            }
<span class="nc" id="L4448">        }</span>

        private void page(JTree tree, BasicTreeUI ui, int direction,
                          boolean addToSelection, boolean changeSelection) {

            // disable moving of lead unless in discontiguous mode
<span class="nc bnc" id="L4454" title="All 4 branches missed.">            if (!addToSelection &amp;&amp; !changeSelection &amp;&amp;</span>
<span class="nc bnc" id="L4455" title="All 2 branches missed.">                    tree.getSelectionModel().getSelectionMode() !=</span>
                        TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION) {
<span class="nc" id="L4457">                changeSelection = true;</span>
            }

            int           rowCount;

<span class="nc bnc" id="L4462" title="All 4 branches missed.">            if((rowCount = ui.getRowCount(tree)) &gt; 0 &amp;&amp;</span>
                           ui.treeSelectionModel != null) {
<span class="nc" id="L4464">                Dimension         maxSize = tree.getSize();</span>
<span class="nc" id="L4465">                TreePath          lead = ui.getLeadSelectionPath();</span>
                TreePath          newPath;
<span class="nc" id="L4467">                Rectangle         visRect = tree.getVisibleRect();</span>

<span class="nc bnc" id="L4469" title="All 2 branches missed.">                if(direction == -1) {</span>
                    // up.
<span class="nc" id="L4471">                    newPath = ui.getClosestPathForLocation(tree, visRect.x,</span>
                                                         visRect.y);
<span class="nc bnc" id="L4473" title="All 2 branches missed.">                    if(newPath.equals(lead)) {</span>
<span class="nc" id="L4474">                        visRect.y = Math.max(0, visRect.y - visRect.height);</span>
<span class="nc" id="L4475">                        newPath = tree.getClosestPathForLocation(visRect.x,</span>
                                                                 visRect.y);
                    }
                }
                else {
                    // down
<span class="nc" id="L4481">                    visRect.y = Math.min(maxSize.height, visRect.y +</span>
                                         visRect.height - 1);
<span class="nc" id="L4483">                    newPath = tree.getClosestPathForLocation(visRect.x,</span>
                                                             visRect.y);
<span class="nc bnc" id="L4485" title="All 2 branches missed.">                    if(newPath.equals(lead)) {</span>
<span class="nc" id="L4486">                        visRect.y = Math.min(maxSize.height, visRect.y +</span>
                                             visRect.height - 1);
<span class="nc" id="L4488">                        newPath = tree.getClosestPathForLocation(visRect.x,</span>
                                                                 visRect.y);
                    }
                }
<span class="nc" id="L4492">                Rectangle            newRect = ui.getPathBounds(tree, newPath);</span>
<span class="nc bnc" id="L4493" title="All 2 branches missed.">                if (newRect != null) {</span>
<span class="nc" id="L4494">                    newRect.x = visRect.x;</span>
<span class="nc" id="L4495">                    newRect.width = visRect.width;</span>
<span class="nc bnc" id="L4496" title="All 2 branches missed.">                    if(direction == -1) {</span>
<span class="nc" id="L4497">                        newRect.height = visRect.height;</span>
                    }
                    else {
<span class="nc" id="L4500">                        newRect.y -= (visRect.height - newRect.height);</span>
<span class="nc" id="L4501">                        newRect.height = visRect.height;</span>
                    }

<span class="nc bnc" id="L4504" title="All 2 branches missed.">                    if(addToSelection) {</span>
<span class="nc" id="L4505">                        ui.extendSelection(newPath);</span>
                    }
<span class="nc bnc" id="L4507" title="All 2 branches missed.">                    else if(changeSelection) {</span>
<span class="nc" id="L4508">                        tree.setSelectionPath(newPath);</span>
                    }
                    else {
<span class="nc" id="L4511">                        ui.setLeadSelectionPath(newPath, true);</span>
                    }
<span class="nc" id="L4513">                    tree.scrollRectToVisible(newRect);</span>
                }
            }
<span class="nc" id="L4516">        }</span>

        private void home(JTree tree, final BasicTreeUI ui, int direction,
                          boolean addToSelection, boolean changeSelection) {

            // disable moving of lead unless in discontiguous mode
<span class="nc bnc" id="L4522" title="All 4 branches missed.">            if (!addToSelection &amp;&amp; !changeSelection &amp;&amp;</span>
<span class="nc bnc" id="L4523" title="All 2 branches missed.">                    tree.getSelectionModel().getSelectionMode() !=</span>
                        TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION) {
<span class="nc" id="L4525">                changeSelection = true;</span>
            }

<span class="nc" id="L4528">            final int rowCount = ui.getRowCount(tree);</span>

<span class="nc bnc" id="L4530" title="All 2 branches missed.">            if (rowCount &gt; 0) {</span>
<span class="nc bnc" id="L4531" title="All 2 branches missed.">                if(direction == -1) {</span>
<span class="nc" id="L4532">                    ui.ensureRowsAreVisible(0, 0);</span>
<span class="nc bnc" id="L4533" title="All 2 branches missed.">                    if (addToSelection) {</span>
<span class="nc" id="L4534">                        TreePath        aPath = ui.getAnchorSelectionPath();</span>
<span class="nc bnc" id="L4535" title="All 2 branches missed.">                        int             aRow = (aPath == null) ? -1 :</span>
<span class="nc" id="L4536">                                        ui.getRowForPath(tree, aPath);</span>

<span class="nc bnc" id="L4538" title="All 2 branches missed.">                        if (aRow == -1) {</span>
<span class="nc" id="L4539">                            tree.setSelectionInterval(0, 0);</span>
                        }
                        else {
<span class="nc" id="L4542">                            tree.setSelectionInterval(0, aRow);</span>
<span class="nc" id="L4543">                            ui.setAnchorSelectionPath(aPath);</span>
<span class="nc" id="L4544">                            ui.setLeadSelectionPath(ui.getPathForRow(tree, 0));</span>
                        }
<span class="nc" id="L4546">                    }</span>
<span class="nc bnc" id="L4547" title="All 2 branches missed.">                    else if(changeSelection) {</span>
<span class="nc" id="L4548">                        tree.setSelectionInterval(0, 0);</span>
                    }
                    else {
<span class="nc" id="L4551">                        ui.setLeadSelectionPath(ui.getPathForRow(tree, 0),</span>
                                                true);
                    }
                }
                else {
<span class="nc" id="L4556">                    ui.ensureRowsAreVisible(rowCount - 1, rowCount - 1);</span>
<span class="nc bnc" id="L4557" title="All 2 branches missed.">                    if (addToSelection) {</span>
<span class="nc" id="L4558">                        TreePath        aPath = ui.getAnchorSelectionPath();</span>
<span class="nc bnc" id="L4559" title="All 2 branches missed.">                        int             aRow = (aPath == null) ? -1 :</span>
<span class="nc" id="L4560">                                        ui.getRowForPath(tree, aPath);</span>

<span class="nc bnc" id="L4562" title="All 2 branches missed.">                        if (aRow == -1) {</span>
<span class="nc" id="L4563">                            tree.setSelectionInterval(rowCount - 1,</span>
                                                      rowCount -1);
                        }
                        else {
<span class="nc" id="L4567">                            tree.setSelectionInterval(aRow, rowCount - 1);</span>
<span class="nc" id="L4568">                            ui.setAnchorSelectionPath(aPath);</span>
<span class="nc" id="L4569">                            ui.setLeadSelectionPath(ui.getPathForRow(tree,</span>
                                                               rowCount -1));
                        }
<span class="nc" id="L4572">                    }</span>
<span class="nc bnc" id="L4573" title="All 2 branches missed.">                    else if(changeSelection) {</span>
<span class="nc" id="L4574">                        tree.setSelectionInterval(rowCount - 1, rowCount - 1);</span>
                    }
                    else {
<span class="nc" id="L4577">                        ui.setLeadSelectionPath(ui.getPathForRow(tree,</span>
                                                          rowCount - 1), true);
                    }
<span class="nc bnc" id="L4580" title="All 2 branches missed.">                    if (ui.isLargeModel()){</span>
<span class="nc" id="L4581">                        SwingUtilities.invokeLater(new Runnable() {</span>
                            public void run() {
<span class="nc" id="L4583">                                ui.ensureRowsAreVisible(rowCount - 1, rowCount - 1);</span>
<span class="nc" id="L4584">                            }</span>
                        });
                    }
                }
            }
<span class="nc" id="L4589">        }</span>
    }
} // End of class BasicTreeUI
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>