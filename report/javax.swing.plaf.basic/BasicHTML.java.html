<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BasicHTML.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.plaf.basic</a> &gt; <span class="el_source">BasicHTML.java</span></div><h1>BasicHTML.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.plaf.basic;

import java.io.*;
import java.awt.*;
import java.net.URL;

import javax.swing.*;
import javax.swing.text.*;
import javax.swing.text.html.*;

import sun.swing.SwingUtilities2;

/**
 * Support for providing html views for the swing components.
 * This translates a simple html string to a javax.swing.text.View
 * implementation that can render the html and provide the necessary
 * layout semantics.
 *
 * @author  Timothy Prinzing
 * @since 1.3
 */
<span class="nc" id="L46">public class BasicHTML {</span>

    /**
     * Create an html renderer for the given component and
     * string of html.
     */
    public static View createHTMLView(JComponent c, String html) {
<span class="nc" id="L53">        BasicEditorKit kit = getFactory();</span>
<span class="nc" id="L54">        Document doc = kit.createDefaultDocument(c.getFont(),</span>
<span class="nc" id="L55">                                                 c.getForeground());</span>
<span class="nc" id="L56">        Object base = c.getClientProperty(documentBaseKey);</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">        if (base instanceof URL) {</span>
<span class="nc" id="L58">            ((HTMLDocument)doc).setBase((URL)base);</span>
        }
<span class="nc" id="L60">        Reader r = new StringReader(html);</span>
        try {
<span class="nc" id="L62">            kit.read(r, doc, 0);</span>
<span class="nc" id="L63">        } catch (Throwable e) {</span>
<span class="nc" id="L64">        }</span>
<span class="nc" id="L65">        ViewFactory f = kit.getViewFactory();</span>
<span class="nc" id="L66">        View hview = f.create(doc.getDefaultRootElement());</span>
<span class="nc" id="L67">        View v = new Renderer(c, f, hview);</span>
<span class="nc" id="L68">        return v;</span>
    }

    /**
     * Returns the baseline for the html renderer.
     *
     * @param view the View to get the baseline for
     * @param w the width to get the baseline for
     * @param h the height to get the baseline for
     * @throws IllegalArgumentException if width or height is &amp;lt; 0
     * @return baseline or a value &amp;lt; 0 indicating there is no reasonable
     *                  baseline
     * @see java.awt.FontMetrics
     * @see javax.swing.JComponent#getBaseline(int,int)
     * @since 1.6
     */
    public static int getHTMLBaseline(View view, int w, int h) {
<span class="nc bnc" id="L85" title="All 4 branches missed.">        if (w &lt; 0 || h &lt; 0) {</span>
<span class="nc" id="L86">            throw new IllegalArgumentException(</span>
                    &quot;Width and height must be &gt;= 0&quot;);
        }
<span class="nc bnc" id="L89" title="All 2 branches missed.">        if (view instanceof Renderer) {</span>
<span class="nc" id="L90">            return getBaseline(view.getView(0), w, h);</span>
        }
<span class="nc" id="L92">        return -1;</span>
    }

    /**
     * Gets the baseline for the specified component.  This digs out
     * the View client property, and if non-null the baseline is calculated
     * from it.  Otherwise the baseline is the value &lt;code&gt;y + ascent&lt;/code&gt;.
     */
    static int getBaseline(JComponent c, int y, int ascent,
                                  int w, int h) {
<span class="nc" id="L102">        View view = (View)c.getClientProperty(BasicHTML.propertyKey);</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (view != null) {</span>
<span class="nc" id="L104">            int baseline = getHTMLBaseline(view, w, h);</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (baseline &lt; 0) {</span>
<span class="nc" id="L106">                return baseline;</span>
            }
<span class="nc" id="L108">            return y + baseline;</span>
        }
<span class="nc" id="L110">        return y + ascent;</span>
    }

    /**
     * Gets the baseline for the specified View.
     */
    static int getBaseline(View view, int w, int h) {
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (hasParagraph(view)) {</span>
<span class="nc" id="L118">            view.setSize(w, h);</span>
<span class="nc" id="L119">            return getBaseline(view, new Rectangle(0, 0, w, h));</span>
        }
<span class="nc" id="L121">        return -1;</span>
    }

    private static int getBaseline(View view, Shape bounds) {
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (view.getViewCount() == 0) {</span>
<span class="nc" id="L126">            return -1;</span>
        }
<span class="nc" id="L128">        AttributeSet attributes = view.getElement().getAttributes();</span>
<span class="nc" id="L129">        Object name = null;</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (attributes != null) {</span>
<span class="nc" id="L131">            name = attributes.getAttribute(StyleConstants.NameAttribute);</span>
        }
<span class="nc" id="L133">        int index = 0;</span>
<span class="nc bnc" id="L134" title="All 4 branches missed.">        if (name == HTML.Tag.HTML &amp;&amp; view.getViewCount() &gt; 1) {</span>
            // For html on widgets the header is not visible, skip it.
<span class="nc" id="L136">            index++;</span>
        }
<span class="nc" id="L138">        bounds = view.getChildAllocation(index, bounds);</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (bounds == null) {</span>
<span class="nc" id="L140">            return -1;</span>
        }
<span class="nc" id="L142">        View child = view.getView(index);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (view instanceof javax.swing.text.ParagraphView) {</span>
            Rectangle rect;
<span class="nc bnc" id="L145" title="All 2 branches missed.">            if (bounds instanceof Rectangle) {</span>
<span class="nc" id="L146">                rect = (Rectangle)bounds;</span>
            }
            else {
<span class="nc" id="L149">                rect = bounds.getBounds();</span>
            }
<span class="nc" id="L151">            return rect.y + (int)(rect.height *</span>
<span class="nc" id="L152">                                  child.getAlignment(View.Y_AXIS));</span>
        }
<span class="nc" id="L154">        return getBaseline(child, bounds);</span>
    }

    private static boolean hasParagraph(View view) {
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (view instanceof javax.swing.text.ParagraphView) {</span>
<span class="nc" id="L159">            return true;</span>
        }
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (view.getViewCount() == 0) {</span>
<span class="nc" id="L162">            return false;</span>
        }
<span class="nc" id="L164">        AttributeSet attributes = view.getElement().getAttributes();</span>
<span class="nc" id="L165">        Object name = null;</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (attributes != null) {</span>
<span class="nc" id="L167">            name = attributes.getAttribute(StyleConstants.NameAttribute);</span>
        }
<span class="nc" id="L169">        int index = 0;</span>
<span class="nc bnc" id="L170" title="All 4 branches missed.">        if (name == HTML.Tag.HTML &amp;&amp; view.getViewCount() &gt; 1) {</span>
            // For html on widgets the header is not visible, skip it.
<span class="nc" id="L172">            index = 1;</span>
        }
<span class="nc" id="L174">        return hasParagraph(view.getView(index));</span>
    }

    /**
     * Check the given string to see if it should trigger the
     * html rendering logic in a non-text component that supports
     * html rendering.
     */
    public static boolean isHTMLString(String s) {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (s != null) {</span>
<span class="nc bnc" id="L184" title="All 6 branches missed.">            if ((s.length() &gt;= 6) &amp;&amp; (s.charAt(0) == '&lt;') &amp;&amp; (s.charAt(5) == '&gt;')) {</span>
<span class="nc" id="L185">                String tag = s.substring(1,5);</span>
<span class="nc" id="L186">                return tag.equalsIgnoreCase(propertyKey);</span>
            }
        }
<span class="nc" id="L189">        return false;</span>
    }

    /**
     * Stash the HTML render for the given text into the client
     * properties of the given JComponent. If the given text is
     * &lt;em&gt;NOT HTML&lt;/em&gt; the property will be cleared of any
     * renderer.
     * &lt;p&gt;
     * This method is useful for ComponentUI implementations
     * that are static (i.e. shared) and get their state
     * entirely from the JComponent.
     */
    public static void updateRenderer(JComponent c, String text) {
<span class="nc" id="L203">        View value = null;</span>
<span class="nc" id="L204">        View oldValue = (View)c.getClientProperty(BasicHTML.propertyKey);</span>
<span class="nc" id="L205">        Boolean htmlDisabled = (Boolean) c.getClientProperty(htmlDisable);</span>
<span class="nc bnc" id="L206" title="All 4 branches missed.">        if (htmlDisabled != Boolean.TRUE &amp;&amp; BasicHTML.isHTMLString(text)) {</span>
<span class="nc" id="L207">            value = BasicHTML.createHTMLView(c, text);</span>
        }
<span class="nc bnc" id="L209" title="All 4 branches missed.">        if (value != oldValue &amp;&amp; oldValue != null) {</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">            for (int i = 0; i &lt; oldValue.getViewCount(); i++) {</span>
<span class="nc" id="L211">                oldValue.getView(i).setParent(null);</span>
            }
        }
<span class="nc" id="L214">        c.putClientProperty(BasicHTML.propertyKey, value);</span>
<span class="nc" id="L215">    }</span>

    /**
     * If this client property of a JComponent is set to Boolean.TRUE
     * the component's 'text' property is never treated as HTML.
     */
    private static final String htmlDisable = &quot;html.disable&quot;;

    /**
     * Key to use for the html renderer when stored as a
     * client property of a JComponent.
     */
    public static final String propertyKey = &quot;html&quot;;

    /**
     * Key stored as a client property to indicate the base that relative
     * references are resolved against. For example, lets say you keep
     * your images in the directory resources relative to the code path,
     * you would use the following the set the base:
     * &lt;pre&gt;
     *   jComponent.putClientProperty(documentBaseKey,
     *                                xxx.class.getResource(&quot;resources/&quot;));
     * &lt;/pre&gt;
     */
    public static final String documentBaseKey = &quot;html.base&quot;;

    static BasicEditorKit getFactory() {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (basicHTMLFactory == null) {</span>
<span class="nc" id="L243">            basicHTMLViewFactory = new BasicHTMLViewFactory();</span>
<span class="nc" id="L244">            basicHTMLFactory = new BasicEditorKit();</span>
        }
<span class="nc" id="L246">        return basicHTMLFactory;</span>
    }

    /**
     * The source of the html renderers
     */
    private static BasicEditorKit basicHTMLFactory;

    /**
     * Creates the Views that visually represent the model.
     */
    private static ViewFactory basicHTMLViewFactory;

    /**
     * Overrides to the default stylesheet.  Should consider
     * just creating a completely fresh stylesheet.
     */
    private static final String styleChanges =
    &quot;p { margin-top: 0; margin-bottom: 0; margin-left: 0; margin-right: 0 }&quot; +
    &quot;body { margin-top: 0; margin-bottom: 0; margin-left: 0; margin-right: 0 }&quot;;

    /**
     * The views produced for the ComponentUI implementations aren't
     * going to be edited and don't need full html support.  This kit
     * alters the HTMLEditorKit to try and trim things down a bit.
     * It does the following:
     * &lt;ul&gt;
     * &lt;li&gt;It doesn't produce Views for things like comments,
     * head, title, unknown tags, etc.
     * &lt;li&gt;It installs a different set of css settings from the default
     * provided by HTMLEditorKit.
     * &lt;/ul&gt;
     */
<span class="nc" id="L279">    static class BasicEditorKit extends HTMLEditorKit {</span>
        /** Shared base style for all documents created by us use. */
        private static StyleSheet defaultStyles;

        /**
         * Overriden to return our own slimmed down style sheet.
         */
        public StyleSheet getStyleSheet() {
<span class="nc bnc" id="L287" title="All 2 branches missed.">            if (defaultStyles == null) {</span>
<span class="nc" id="L288">                defaultStyles = new StyleSheet();</span>
<span class="nc" id="L289">                StringReader r = new StringReader(styleChanges);</span>
                try {
<span class="nc" id="L291">                    defaultStyles.loadRules(r, null);</span>
<span class="nc" id="L292">                } catch (Throwable e) {</span>
                    // don't want to die in static initialization...
                    // just display things wrong.
<span class="nc" id="L295">                }</span>
<span class="nc" id="L296">                r.close();</span>
<span class="nc" id="L297">                defaultStyles.addStyleSheet(super.getStyleSheet());</span>
            }
<span class="nc" id="L299">            return defaultStyles;</span>
        }

        /**
         * Sets the async policy to flush everything in one chunk, and
         * to not display unknown tags.
         */
        public Document createDefaultDocument(Font defaultFont,
                                              Color foreground) {
<span class="nc" id="L308">            StyleSheet styles = getStyleSheet();</span>
<span class="nc" id="L309">            StyleSheet ss = new StyleSheet();</span>
<span class="nc" id="L310">            ss.addStyleSheet(styles);</span>
<span class="nc" id="L311">            BasicDocument doc = new BasicDocument(ss, defaultFont, foreground);</span>
<span class="nc" id="L312">            doc.setAsynchronousLoadPriority(Integer.MAX_VALUE);</span>
<span class="nc" id="L313">            doc.setPreservesUnknownTags(false);</span>
<span class="nc" id="L314">            return doc;</span>
        }

        /**
         * Returns the ViewFactory that is used to make sure the Views don't
         * load in the background.
         */
        public ViewFactory getViewFactory() {
<span class="nc" id="L322">            return basicHTMLViewFactory;</span>
        }
    }


    /**
     * BasicHTMLViewFactory extends HTMLFactory to force images to be loaded
     * synchronously.
     */
<span class="nc" id="L331">    static class BasicHTMLViewFactory extends HTMLEditorKit.HTMLFactory {</span>
        public View create(Element elem) {
<span class="nc" id="L333">            View view = super.create(elem);</span>

<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (view instanceof ImageView) {</span>
<span class="nc" id="L336">                ((ImageView)view).setLoadsSynchronously(true);</span>
            }
<span class="nc" id="L338">            return view;</span>
        }
    }


    /**
     * The subclass of HTMLDocument that is used as the model. getForeground
     * is overridden to return the foreground property from the Component this
     * was created for.
     */
    static class BasicDocument extends HTMLDocument {
        /** The host, that is where we are rendering. */
        // private JComponent host;

        BasicDocument(StyleSheet s, Font defaultFont, Color foreground) {
<span class="nc" id="L353">            super(s);</span>
<span class="nc" id="L354">            setPreservesUnknownTags(false);</span>
<span class="nc" id="L355">            setFontAndColor(defaultFont, foreground);</span>
<span class="nc" id="L356">        }</span>

        /**
         * Sets the default font and default color. These are set by
         * adding a rule for the body that specifies the font and color.
         * This allows the html to override these should it wish to have
         * a custom font or color.
         */
        private void setFontAndColor(Font font, Color fg) {
<span class="nc" id="L365">            getStyleSheet().addRule(sun.swing.SwingUtilities2.</span>
<span class="nc" id="L366">                                    displayPropertiesToCSS(font,fg));</span>
<span class="nc" id="L367">        }</span>
    }


    /**
     * Root text view that acts as an HTML renderer.
     */
<span class="nc" id="L374">    static class Renderer extends View {</span>

        Renderer(JComponent c, ViewFactory f, View v) {
<span class="nc" id="L377">            super(null);</span>
<span class="nc" id="L378">            host = c;</span>
<span class="nc" id="L379">            factory = f;</span>
<span class="nc" id="L380">            view = v;</span>
<span class="nc" id="L381">            view.setParent(this);</span>
            // initially layout to the preferred size
<span class="nc" id="L383">            setSize(view.getPreferredSpan(X_AXIS), view.getPreferredSpan(Y_AXIS));</span>
<span class="nc" id="L384">        }</span>

        /**
         * Fetches the attributes to use when rendering.  At the root
         * level there are no attributes.  If an attribute is resolved
         * up the view hierarchy this is the end of the line.
         */
        public AttributeSet getAttributes() {
<span class="nc" id="L392">            return null;</span>
        }

        /**
         * Determines the preferred span for this view along an axis.
         *
         * @param axis may be either X_AXIS or Y_AXIS
         * @return the span the view would like to be rendered into.
         *         Typically the view is told to render into the span
         *         that is returned, although there is no guarantee.
         *         The parent may choose to resize or break the view.
         */
        public float getPreferredSpan(int axis) {
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (axis == X_AXIS) {</span>
                // width currently laid out to
<span class="nc" id="L407">                return width;</span>
            }
<span class="nc" id="L409">            return view.getPreferredSpan(axis);</span>
        }

        /**
         * Determines the minimum span for this view along an axis.
         *
         * @param axis may be either X_AXIS or Y_AXIS
         * @return the span the view would like to be rendered into.
         *         Typically the view is told to render into the span
         *         that is returned, although there is no guarantee.
         *         The parent may choose to resize or break the view.
         */
        public float getMinimumSpan(int axis) {
<span class="nc" id="L422">            return view.getMinimumSpan(axis);</span>
        }

        /**
         * Determines the maximum span for this view along an axis.
         *
         * @param axis may be either X_AXIS or Y_AXIS
         * @return the span the view would like to be rendered into.
         *         Typically the view is told to render into the span
         *         that is returned, although there is no guarantee.
         *         The parent may choose to resize or break the view.
         */
        public float getMaximumSpan(int axis) {
<span class="nc" id="L435">            return Integer.MAX_VALUE;</span>
        }

        /**
         * Specifies that a preference has changed.
         * Child views can call this on the parent to indicate that
         * the preference has changed.  The root view routes this to
         * invalidate on the hosting component.
         * &lt;p&gt;
         * This can be called on a different thread from the
         * event dispatching thread and is basically unsafe to
         * propagate into the component.  To make this safe,
         * the operation is transferred over to the event dispatching
         * thread for completion.  It is a design goal that all view
         * methods be safe to call without concern for concurrency,
         * and this behavior helps make that true.
         *
         * @param child the child view
         * @param width true if the width preference has changed
         * @param height true if the height preference has changed
         */
        public void preferenceChanged(View child, boolean width, boolean height) {
<span class="nc" id="L457">            host.revalidate();</span>
<span class="nc" id="L458">            host.repaint();</span>
<span class="nc" id="L459">        }</span>

        /**
         * Determines the desired alignment for this view along an axis.
         *
         * @param axis may be either X_AXIS or Y_AXIS
         * @return the desired alignment, where 0.0 indicates the origin
         *     and 1.0 the full span away from the origin
         */
        public float getAlignment(int axis) {
<span class="nc" id="L469">            return view.getAlignment(axis);</span>
        }

        /**
         * Renders the view.
         *
         * @param g the graphics context
         * @param allocation the region to render into
         */
        public void paint(Graphics g, Shape allocation) {
<span class="nc" id="L479">            Rectangle alloc = allocation.getBounds();</span>
<span class="nc" id="L480">            view.setSize(alloc.width, alloc.height);</span>
<span class="nc" id="L481">            view.paint(g, allocation);</span>
<span class="nc" id="L482">        }</span>

        /**
         * Sets the view parent.
         *
         * @param parent the parent view
         */
        public void setParent(View parent) {
<span class="nc" id="L490">            throw new Error(&quot;Can't set parent on root view&quot;);</span>
        }

        /**
         * Returns the number of views in this view.  Since
         * this view simply wraps the root of the view hierarchy
         * it has exactly one child.
         *
         * @return the number of views
         * @see #getView
         */
        public int getViewCount() {
<span class="nc" id="L502">            return 1;</span>
        }

        /**
         * Gets the n-th view in this container.
         *
         * @param n the number of the view to get
         * @return the view
         */
        public View getView(int n) {
<span class="nc" id="L512">            return view;</span>
        }

        /**
         * Provides a mapping from the document model coordinate space
         * to the coordinate space of the view mapped to it.
         *
         * @param pos the position to convert
         * @param a the allocated region to render into
         * @return the bounding box of the given position
         */
        public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
<span class="nc" id="L524">            return view.modelToView(pos, a, b);</span>
        }

        /**
         * Provides a mapping from the document model coordinate space
         * to the coordinate space of the view mapped to it.
         *
         * @param p0 the position to convert &gt;= 0
         * @param b0 the bias toward the previous character or the
         *  next character represented by p0, in case the
         *  position is a boundary of two views.
         * @param p1 the position to convert &gt;= 0
         * @param b1 the bias toward the previous character or the
         *  next character represented by p1, in case the
         *  position is a boundary of two views.
         * @param a the allocated region to render into
         * @return the bounding box of the given position is returned
         * @exception BadLocationException  if the given position does
         *   not represent a valid location in the associated document
         * @exception IllegalArgumentException for an invalid bias argument
         * @see View#viewToModel
         */
        public Shape modelToView(int p0, Position.Bias b0, int p1,
                                 Position.Bias b1, Shape a) throws BadLocationException {
<span class="nc" id="L548">            return view.modelToView(p0, b0, p1, b1, a);</span>
        }

        /**
         * Provides a mapping from the view coordinate space to the logical
         * coordinate space of the model.
         *
         * @param x x coordinate of the view location to convert
         * @param y y coordinate of the view location to convert
         * @param a the allocated region to render into
         * @return the location within the model that best represents the
         *    given point in the view
         */
        public int viewToModel(float x, float y, Shape a, Position.Bias[] bias) {
<span class="nc" id="L562">            return view.viewToModel(x, y, a, bias);</span>
        }

        /**
         * Returns the document model underlying the view.
         *
         * @return the model
         */
        public Document getDocument() {
<span class="nc" id="L571">            return view.getDocument();</span>
        }

        /**
         * Returns the starting offset into the model for this view.
         *
         * @return the starting offset
         */
        public int getStartOffset() {
<span class="nc" id="L580">            return view.getStartOffset();</span>
        }

        /**
         * Returns the ending offset into the model for this view.
         *
         * @return the ending offset
         */
        public int getEndOffset() {
<span class="nc" id="L589">            return view.getEndOffset();</span>
        }

        /**
         * Gets the element that this view is mapped to.
         *
         * @return the view
         */
        public Element getElement() {
<span class="nc" id="L598">            return view.getElement();</span>
        }

        /**
         * Sets the view size.
         *
         * @param width the width
         * @param height the height
         */
        public void setSize(float width, float height) {
<span class="nc" id="L608">            this.width = (int) width;</span>
<span class="nc" id="L609">            view.setSize(width, height);</span>
<span class="nc" id="L610">        }</span>

        /**
         * Fetches the container hosting the view.  This is useful for
         * things like scheduling a repaint, finding out the host
         * components font, etc.  The default implementation
         * of this is to forward the query to the parent view.
         *
         * @return the container
         */
        public Container getContainer() {
<span class="nc" id="L621">            return host;</span>
        }

        /**
         * Fetches the factory to be used for building the
         * various view fragments that make up the view that
         * represents the model.  This is what determines
         * how the model will be represented.  This is implemented
         * to fetch the factory provided by the associated
         * EditorKit.
         *
         * @return the factory
         */
        public ViewFactory getViewFactory() {
<span class="nc" id="L635">            return factory;</span>
        }

        private int width;
        private View view;
        private ViewFactory factory;
        private JComponent host;

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>