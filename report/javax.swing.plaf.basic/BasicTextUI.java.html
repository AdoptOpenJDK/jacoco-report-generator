<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BasicTextUI.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.plaf.basic</a> &gt; <span class="el_source">BasicTextUI.java</span></div><h1>BasicTextUI.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.plaf.basic;

import java.util.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.datatransfer.*;
import java.awt.im.InputContext;
import java.beans.*;
import java.io.*;
import javax.swing.*;
import javax.swing.plaf.*;
import javax.swing.text.*;
import javax.swing.event.*;
import javax.swing.border.Border;
import javax.swing.plaf.UIResource;
import javax.swing.plaf.synth.SynthUI;
import sun.swing.DefaultLookup;
import sun.awt.AppContext;
import javax.swing.plaf.basic.DragRecognitionSupport.BeforeDrag;

/**
 * &lt;p&gt;
 * Basis of a text components look-and-feel.  This provides the
 * basic editor view and controller services that may be useful
 * when creating a look-and-feel for an extension of
 * &lt;code&gt;JTextComponent&lt;/code&gt;.
 * &lt;p&gt;
 * Most state is held in the associated &lt;code&gt;JTextComponent&lt;/code&gt;
 * as bound properties, and the UI installs default values for the
 * various properties.  This default will install something for
 * all of the properties.  Typically, a LAF implementation will
 * do more however.  At a minimum, a LAF would generally install
 * key bindings.
 * &lt;p&gt;
 * This class also provides some concurrency support if the
 * &lt;code&gt;Document&lt;/code&gt; associated with the JTextComponent is a subclass of
 * &lt;code&gt;AbstractDocument&lt;/code&gt;.  Access to the View (or View hierarchy) is
 * serialized between any thread mutating the model and the Swing
 * event thread (which is expected to render, do model/view coordinate
 * translation, etc).  &lt;em&gt;Any access to the root view should first
 * acquire a read-lock on the AbstractDocument and release that lock
 * in a finally block.&lt;/em&gt;
 * &lt;p&gt;
 * An important method to define is the {@link #getPropertyPrefix} method
 * which is used as the basis of the keys used to fetch defaults
 * from the UIManager.  The string should reflect the type of
 * TextUI (eg. TextField, TextArea, etc) without the particular
 * LAF part of the name (eg Metal, Motif, etc).
 * &lt;p&gt;
 * To build a view of the model, one of the following strategies
 * can be employed.
 * &lt;ol&gt;
 * &lt;li&gt;
 * One strategy is to simply redefine the
 * ViewFactory interface in the UI.  By default, this UI itself acts
 * as the factory for View implementations.  This is useful
 * for simple factories.  To do this reimplement the
 * {@link #create} method.
 * &lt;li&gt;
 * A common strategy for creating more complex types of documents
 * is to have the EditorKit implementation return a factory.  Since
 * the EditorKit ties all of the pieces necessary to maintain a type
 * of document, the factory is typically an important part of that
 * and should be produced by the EditorKit implementation.
 * &lt;/ol&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author Timothy Prinzing
 * @author Shannon Hickey (drag and drop)
 */
public abstract class BasicTextUI extends TextUI implements ViewFactory {

    /**
     * Creates a new UI.
     */
<span class="nc" id="L108">    public BasicTextUI() {</span>
<span class="nc" id="L109">        painted = false;</span>
<span class="nc" id="L110">    }</span>

    /**
     * Creates the object to use for a caret.  By default an
     * instance of BasicCaret is created.  This method
     * can be redefined to provide something else that implements
     * the InputPosition interface or a subclass of JCaret.
     *
     * @return the caret object
     */
    protected Caret createCaret() {
<span class="nc" id="L121">        return new BasicCaret();</span>
    }

    /**
     * Creates the object to use for adding highlights.  By default
     * an instance of BasicHighlighter is created.  This method
     * can be redefined to provide something else that implements
     * the Highlighter interface or a subclass of DefaultHighlighter.
     *
     * @return the highlighter
     */
    protected Highlighter createHighlighter() {
<span class="nc" id="L133">        return new BasicHighlighter();</span>
    }

    /**
     * Fetches the name of the keymap that will be installed/used
     * by default for this UI. This is implemented to create a
     * name based upon the classname.  The name is the the name
     * of the class with the package prefix removed.
     *
     * @return the name
     */
    protected String getKeymapName() {
<span class="nc" id="L145">        String nm = getClass().getName();</span>
<span class="nc" id="L146">        int index = nm.lastIndexOf('.');</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (index &gt;= 0) {</span>
<span class="nc" id="L148">            nm = nm.substring(index+1, nm.length());</span>
        }
<span class="nc" id="L150">        return nm;</span>
    }

    /**
     * Creates the keymap to use for the text component, and installs
     * any necessary bindings into it.  By default, the keymap is
     * shared between all instances of this type of TextUI. The
     * keymap has the name defined by the getKeymapName method.  If the
     * keymap is not found, then DEFAULT_KEYMAP from JTextComponent is used.
     * &lt;p&gt;
     * The set of bindings used to create the keymap is fetched
     * from the UIManager using a key formed by combining the
     * {@link #getPropertyPrefix} method
     * and the string &lt;code&gt;.keyBindings&lt;/code&gt;.  The type is expected
     * to be &lt;code&gt;JTextComponent.KeyBinding[]&lt;/code&gt;.
     *
     * @return the keymap
     * @see #getKeymapName
     * @see javax.swing.text.JTextComponent
     */
    protected Keymap createKeymap() {
<span class="nc" id="L171">        String nm = getKeymapName();</span>
<span class="nc" id="L172">        Keymap map = JTextComponent.getKeymap(nm);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (map == null) {</span>
<span class="nc" id="L174">            Keymap parent = JTextComponent.getKeymap(JTextComponent.DEFAULT_KEYMAP);</span>
<span class="nc" id="L175">            map = JTextComponent.addKeymap(nm, parent);</span>
<span class="nc" id="L176">            String prefix = getPropertyPrefix();</span>
<span class="nc" id="L177">            Object o = DefaultLookup.get(editor, this,</span>
                prefix + &quot;.keyBindings&quot;);
<span class="nc bnc" id="L179" title="All 4 branches missed.">            if ((o != null) &amp;&amp; (o instanceof JTextComponent.KeyBinding[])) {</span>
<span class="nc" id="L180">                JTextComponent.KeyBinding[] bindings = (JTextComponent.KeyBinding[]) o;</span>
<span class="nc" id="L181">                JTextComponent.loadKeymap(map, bindings, getComponent().getActions());</span>
            }
        }
<span class="nc" id="L184">        return map;</span>
    }

    /**
     * This method gets called when a bound property is changed
     * on the associated JTextComponent.  This is a hook
     * which UI implementations may change to reflect how the
     * UI displays bound properties of JTextComponent subclasses.
     * This is implemented to do nothing (i.e. the response to
     * properties in JTextComponent itself are handled prior
     * to calling this method).
     *
     * This implementation updates the background of the text
     * component if the editable and/or enabled state changes.
     *
     * @param evt the property change event
     */
    protected void propertyChange(PropertyChangeEvent evt) {
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (evt.getPropertyName().equals(&quot;editable&quot;) ||</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                evt.getPropertyName().equals(&quot;enabled&quot;)) {</span>

<span class="nc" id="L205">            updateBackground((JTextComponent)evt.getSource());</span>
        }
<span class="nc" id="L207">    }</span>

    /**
     * Updates the background of the text component based on whether the
     * text component is editable and/or enabled.
     *
     * @param c the JTextComponent that needs its background color updated
     */
    private void updateBackground(JTextComponent c) {
        // This is a temporary workaround.
        // This code does not correctly deal with Synth (Synth doesn't use
        // properties like this), nor does it deal with the situation where
        // the developer grabs the color from a JLabel and sets it as
        // the background for a JTextArea in all look and feels. The problem
        // scenario results if the Color obtained for the Label and TextArea
        // is ==, which is the case for the windows look and feel.
        // Until an appropriate solution is found, the code is being
        // reverted to what it was before the original fix.
<span class="nc bnc" id="L225" title="All 4 branches missed.">        if (this instanceof SynthUI || (c instanceof JTextArea)) {</span>
<span class="nc" id="L226">            return;</span>
        }
<span class="nc" id="L228">        Color background = c.getBackground();</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (background instanceof UIResource) {</span>
<span class="nc" id="L230">            String prefix = getPropertyPrefix();</span>

<span class="nc" id="L232">            Color disabledBG =</span>
<span class="nc" id="L233">                DefaultLookup.getColor(c, this, prefix + &quot;.disabledBackground&quot;, null);</span>
<span class="nc" id="L234">            Color inactiveBG =</span>
<span class="nc" id="L235">                DefaultLookup.getColor(c, this, prefix + &quot;.inactiveBackground&quot;, null);</span>
<span class="nc" id="L236">            Color bg =</span>
<span class="nc" id="L237">                DefaultLookup.getColor(c, this, prefix + &quot;.background&quot;, null);</span>

            /* In an ideal situation, the following check would not be necessary
             * and we would replace the color any time the previous color was a
             * UIResouce. However, it turns out that there is existing code that
             * uses the following inadvisable pattern to turn a text area into
             * what appears to be a multi-line label:
             *
             * JLabel label = new JLabel();
             * JTextArea area = new JTextArea();
             * area.setBackground(label.getBackground());
             * area.setEditable(false);
             *
             * JLabel's default background is a UIResource. As such, just
             * checking for UIResource would have us always changing the
             * background away from what the developer wanted.
             *
             * Therefore, for JTextArea/JEditorPane, we'll additionally check
             * that the color we're about to replace matches one that was
             * installed by us from the UIDefaults.
             */
<span class="nc bnc" id="L258" title="All 10 branches missed.">            if ((c instanceof JTextArea || c instanceof JEditorPane)</span>
                    &amp;&amp; background != disabledBG
                    &amp;&amp; background != inactiveBG
                    &amp;&amp; background != bg) {

<span class="nc" id="L263">                return;</span>
            }

<span class="nc" id="L266">            Color newColor = null;</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (!c.isEnabled()) {</span>
<span class="nc" id="L268">                newColor = disabledBG;</span>
            }
<span class="nc bnc" id="L270" title="All 4 branches missed.">            if (newColor == null &amp;&amp; !c.isEditable()) {</span>
<span class="nc" id="L271">                newColor = inactiveBG;</span>
            }
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (newColor == null) {</span>
<span class="nc" id="L274">                newColor = bg;</span>
            }
<span class="nc bnc" id="L276" title="All 4 branches missed.">            if (newColor != null &amp;&amp; newColor != background) {</span>
<span class="nc" id="L277">                c.setBackground(newColor);</span>
            }
        }
<span class="nc" id="L280">    }</span>

    /**
     * Gets the name used as a key to look up properties through the
     * UIManager.  This is used as a prefix to all the standard
     * text properties.
     *
     * @return the name
     */
    protected abstract String getPropertyPrefix();

    /**
     * Initializes component properties, such as font, foreground,
     * background, caret color, selection color, selected text color,
     * disabled text color, and border color.  The font, foreground, and
     * background properties are only set if their current value is either null
     * or a UIResource, other properties are set if the current
     * value is null.
     *
     * @see #uninstallDefaults
     * @see #installUI
     */
    protected void installDefaults()
    {
<span class="nc" id="L304">        String prefix = getPropertyPrefix();</span>
<span class="nc" id="L305">        Font f = editor.getFont();</span>
<span class="nc bnc" id="L306" title="All 4 branches missed.">        if ((f == null) || (f instanceof UIResource)) {</span>
<span class="nc" id="L307">            editor.setFont(UIManager.getFont(prefix + &quot;.font&quot;));</span>
        }

<span class="nc" id="L310">        Color bg = editor.getBackground();</span>
<span class="nc bnc" id="L311" title="All 4 branches missed.">        if ((bg == null) || (bg instanceof UIResource)) {</span>
<span class="nc" id="L312">            editor.setBackground(UIManager.getColor(prefix + &quot;.background&quot;));</span>
        }

<span class="nc" id="L315">        Color fg = editor.getForeground();</span>
<span class="nc bnc" id="L316" title="All 4 branches missed.">        if ((fg == null) || (fg instanceof UIResource)) {</span>
<span class="nc" id="L317">            editor.setForeground(UIManager.getColor(prefix + &quot;.foreground&quot;));</span>
        }

<span class="nc" id="L320">        Color color = editor.getCaretColor();</span>
<span class="nc bnc" id="L321" title="All 4 branches missed.">        if ((color == null) || (color instanceof UIResource)) {</span>
<span class="nc" id="L322">            editor.setCaretColor(UIManager.getColor(prefix + &quot;.caretForeground&quot;));</span>
        }

<span class="nc" id="L325">        Color s = editor.getSelectionColor();</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">        if ((s == null) || (s instanceof UIResource)) {</span>
<span class="nc" id="L327">            editor.setSelectionColor(UIManager.getColor(prefix + &quot;.selectionBackground&quot;));</span>
        }

<span class="nc" id="L330">        Color sfg = editor.getSelectedTextColor();</span>
<span class="nc bnc" id="L331" title="All 4 branches missed.">        if ((sfg == null) || (sfg instanceof UIResource)) {</span>
<span class="nc" id="L332">            editor.setSelectedTextColor(UIManager.getColor(prefix + &quot;.selectionForeground&quot;));</span>
        }

<span class="nc" id="L335">        Color dfg = editor.getDisabledTextColor();</span>
<span class="nc bnc" id="L336" title="All 4 branches missed.">        if ((dfg == null) || (dfg instanceof UIResource)) {</span>
<span class="nc" id="L337">            editor.setDisabledTextColor(UIManager.getColor(prefix + &quot;.inactiveForeground&quot;));</span>
        }

<span class="nc" id="L340">        Border b = editor.getBorder();</span>
<span class="nc bnc" id="L341" title="All 4 branches missed.">        if ((b == null) || (b instanceof UIResource)) {</span>
<span class="nc" id="L342">            editor.setBorder(UIManager.getBorder(prefix + &quot;.border&quot;));</span>
        }

<span class="nc" id="L345">        Insets margin = editor.getMargin();</span>
<span class="nc bnc" id="L346" title="All 4 branches missed.">        if (margin == null || margin instanceof UIResource) {</span>
<span class="nc" id="L347">            editor.setMargin(UIManager.getInsets(prefix + &quot;.margin&quot;));</span>
        }

<span class="nc" id="L350">        updateCursor();</span>
<span class="nc" id="L351">    }</span>

    private void installDefaults2() {
<span class="nc" id="L354">        editor.addMouseListener(dragListener);</span>
<span class="nc" id="L355">        editor.addMouseMotionListener(dragListener);</span>

<span class="nc" id="L357">        String prefix = getPropertyPrefix();</span>

<span class="nc" id="L359">        Caret caret = editor.getCaret();</span>
<span class="nc bnc" id="L360" title="All 4 branches missed.">        if (caret == null || caret instanceof UIResource) {</span>
<span class="nc" id="L361">            caret = createCaret();</span>
<span class="nc" id="L362">            editor.setCaret(caret);</span>

<span class="nc" id="L364">            int rate = DefaultLookup.getInt(getComponent(), this, prefix + &quot;.caretBlinkRate&quot;, 500);</span>
<span class="nc" id="L365">            caret.setBlinkRate(rate);</span>
        }

<span class="nc" id="L368">        Highlighter highlighter = editor.getHighlighter();</span>
<span class="nc bnc" id="L369" title="All 4 branches missed.">        if (highlighter == null || highlighter instanceof UIResource) {</span>
<span class="nc" id="L370">            editor.setHighlighter(createHighlighter());</span>
        }

<span class="nc" id="L373">        TransferHandler th = editor.getTransferHandler();</span>
<span class="nc bnc" id="L374" title="All 4 branches missed.">        if (th == null || th instanceof UIResource) {</span>
<span class="nc" id="L375">            editor.setTransferHandler(getTransferHandler());</span>
        }
<span class="nc" id="L377">    }</span>

    /**
     * Sets the component properties that have not been explicitly overridden
     * to {@code null}.  A property is considered overridden if its current
     * value is not a {@code UIResource}.
     *
     * @see #installDefaults
     * @see #uninstallUI
     */
    protected void uninstallDefaults()
    {
<span class="nc" id="L389">        editor.removeMouseListener(dragListener);</span>
<span class="nc" id="L390">        editor.removeMouseMotionListener(dragListener);</span>

<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (editor.getCaretColor() instanceof UIResource) {</span>
<span class="nc" id="L393">            editor.setCaretColor(null);</span>
        }

<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (editor.getSelectionColor() instanceof UIResource) {</span>
<span class="nc" id="L397">            editor.setSelectionColor(null);</span>
        }

<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (editor.getDisabledTextColor() instanceof UIResource) {</span>
<span class="nc" id="L401">            editor.setDisabledTextColor(null);</span>
        }

<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (editor.getSelectedTextColor() instanceof UIResource) {</span>
<span class="nc" id="L405">            editor.setSelectedTextColor(null);</span>
        }

<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (editor.getBorder() instanceof UIResource) {</span>
<span class="nc" id="L409">            editor.setBorder(null);</span>
        }

<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (editor.getMargin() instanceof UIResource) {</span>
<span class="nc" id="L413">            editor.setMargin(null);</span>
        }

<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (editor.getCaret() instanceof UIResource) {</span>
<span class="nc" id="L417">            editor.setCaret(null);</span>
        }

<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (editor.getHighlighter() instanceof UIResource) {</span>
<span class="nc" id="L421">            editor.setHighlighter(null);</span>
        }

<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (editor.getTransferHandler() instanceof UIResource) {</span>
<span class="nc" id="L425">            editor.setTransferHandler(null);</span>
        }

<span class="nc bnc" id="L428" title="All 2 branches missed.">        if (editor.getCursor() instanceof UIResource) {</span>
<span class="nc" id="L429">            editor.setCursor(null);</span>
        }
<span class="nc" id="L431">    }</span>

    /**
     * Installs listeners for the UI.
     */
    protected void installListeners() {
<span class="nc" id="L437">    }</span>

    /**
     * Uninstalls listeners for the UI.
     */
    protected void uninstallListeners() {
<span class="nc" id="L443">    }</span>

    protected void installKeyboardActions() {
        // backward compatibility support... keymaps for the UI
        // are now installed in the more friendly input map.
<span class="nc" id="L448">        editor.setKeymap(createKeymap());</span>

<span class="nc" id="L450">        InputMap km = getInputMap();</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (km != null) {</span>
<span class="nc" id="L452">            SwingUtilities.replaceUIInputMap(editor, JComponent.WHEN_FOCUSED,</span>
                                             km);
        }

<span class="nc" id="L456">        ActionMap map = getActionMap();</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">        if (map != null) {</span>
<span class="nc" id="L458">            SwingUtilities.replaceUIActionMap(editor, map);</span>
        }

<span class="nc" id="L461">        updateFocusAcceleratorBinding(false);</span>
<span class="nc" id="L462">    }</span>

    /**
     * Get the InputMap to use for the UI.
     */
    InputMap getInputMap() {
<span class="nc" id="L468">        InputMap map = new InputMapUIResource();</span>

<span class="nc" id="L470">        InputMap shared =</span>
<span class="nc" id="L471">            (InputMap)DefaultLookup.get(editor, this,</span>
<span class="nc" id="L472">            getPropertyPrefix() + &quot;.focusInputMap&quot;);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (shared != null) {</span>
<span class="nc" id="L474">            map.setParent(shared);</span>
        }
<span class="nc" id="L476">        return map;</span>
    }

    /**
     * Invoked when the focus accelerator changes, this will update the
     * key bindings as necessary.
     */
    void updateFocusAcceleratorBinding(boolean changed) {
<span class="nc" id="L484">        char accelerator = editor.getFocusAccelerator();</span>

<span class="nc bnc" id="L486" title="All 4 branches missed.">        if (changed || accelerator != '\0') {</span>
<span class="nc" id="L487">            InputMap km = SwingUtilities.getUIInputMap</span>
<span class="nc" id="L488">                        (editor, JComponent.WHEN_IN_FOCUSED_WINDOW);</span>

<span class="nc bnc" id="L490" title="All 4 branches missed.">            if (km == null &amp;&amp; accelerator != '\0') {</span>
<span class="nc" id="L491">                km = new ComponentInputMapUIResource(editor);</span>
<span class="nc" id="L492">                SwingUtilities.replaceUIInputMap(editor, JComponent.</span>
                                                 WHEN_IN_FOCUSED_WINDOW, km);
<span class="nc" id="L494">                ActionMap am = getActionMap();</span>
<span class="nc" id="L495">                SwingUtilities.replaceUIActionMap(editor, am);</span>
            }
<span class="nc bnc" id="L497" title="All 2 branches missed.">            if (km != null) {</span>
<span class="nc" id="L498">                km.clear();</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                if (accelerator != '\0') {</span>
<span class="nc" id="L500">                    km.put(KeyStroke.getKeyStroke(accelerator, BasicLookAndFeel.getFocusAcceleratorKeyMask()), &quot;requestFocus&quot;);</span>
                }
            }
        }
<span class="nc" id="L504">    }</span>


    /**
     * Invoked when editable property is changed.
     *
     * removing 'TAB' and 'SHIFT-TAB' from traversalKeysSet in case
     * editor is editable
     * adding 'TAB' and 'SHIFT-TAB' to traversalKeysSet in case
     * editor is non editable
     */

    void updateFocusTraversalKeys() {
        /*
         * Fix for 4514331 Non-editable JTextArea and similar
         * should allow Tab to keyboard - accessibility
         */
<span class="nc" id="L521">        EditorKit editorKit = getEditorKit(editor);</span>
<span class="nc bnc" id="L522" title="All 4 branches missed.">        if ( editorKit != null</span>
             &amp;&amp; editorKit instanceof DefaultEditorKit) {
<span class="nc" id="L524">            Set&lt;AWTKeyStroke&gt; storedForwardTraversalKeys = editor.</span>
<span class="nc" id="L525">                getFocusTraversalKeys(KeyboardFocusManager.</span>
                                      FORWARD_TRAVERSAL_KEYS);
<span class="nc" id="L527">            Set&lt;AWTKeyStroke&gt; storedBackwardTraversalKeys = editor.</span>
<span class="nc" id="L528">                getFocusTraversalKeys(KeyboardFocusManager.</span>
                                      BACKWARD_TRAVERSAL_KEYS);
<span class="nc" id="L530">            Set&lt;AWTKeyStroke&gt; forwardTraversalKeys =</span>
                new HashSet&lt;AWTKeyStroke&gt;(storedForwardTraversalKeys);
<span class="nc" id="L532">            Set&lt;AWTKeyStroke&gt; backwardTraversalKeys =</span>
                new HashSet&lt;AWTKeyStroke&gt;(storedBackwardTraversalKeys);
<span class="nc bnc" id="L534" title="All 2 branches missed.">            if (editor.isEditable()) {</span>
<span class="nc" id="L535">                forwardTraversalKeys.</span>
<span class="nc" id="L536">                    remove(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0));</span>
<span class="nc" id="L537">                backwardTraversalKeys.</span>
<span class="nc" id="L538">                    remove(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,</span>
                                                  InputEvent.SHIFT_MASK));
            } else {
<span class="nc" id="L541">                forwardTraversalKeys.add(KeyStroke.</span>
<span class="nc" id="L542">                                         getKeyStroke(KeyEvent.VK_TAB, 0));</span>
<span class="nc" id="L543">                backwardTraversalKeys.</span>
<span class="nc" id="L544">                    add(KeyStroke.</span>
<span class="nc" id="L545">                        getKeyStroke(KeyEvent.VK_TAB, InputEvent.SHIFT_MASK));</span>
            }
<span class="nc" id="L547">            LookAndFeel.installProperty(editor,</span>
                                        &quot;focusTraversalKeysForward&quot;,
                                         forwardTraversalKeys);
<span class="nc" id="L550">            LookAndFeel.installProperty(editor,</span>
                                        &quot;focusTraversalKeysBackward&quot;,
                                         backwardTraversalKeys);
        }

<span class="nc" id="L555">    }</span>

    /**
     * As needed updates cursor for the target editor.
     */
    private void updateCursor() {
<span class="nc bnc" id="L561" title="All 2 branches missed.">        if ((! editor.isCursorSet())</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">               || editor.getCursor() instanceof UIResource) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">            Cursor cursor = (editor.isEditable()) ? textCursor : null;</span>
<span class="nc" id="L564">            editor.setCursor(cursor);</span>
        }
<span class="nc" id="L566">    }</span>

    /**
     * Returns the &lt;code&gt;TransferHandler&lt;/code&gt; that will be installed if
     * their isn't one installed on the &lt;code&gt;JTextComponent&lt;/code&gt;.
     */
    TransferHandler getTransferHandler() {
<span class="nc" id="L573">        return defaultTransferHandler;</span>
    }

    /**
     * Fetch an action map to use.
     */
    ActionMap getActionMap() {
<span class="nc" id="L580">        String mapName = getPropertyPrefix() + &quot;.actionMap&quot;;</span>
<span class="nc" id="L581">        ActionMap map = (ActionMap)UIManager.get(mapName);</span>

<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (map == null) {</span>
<span class="nc" id="L584">            map = createActionMap();</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">            if (map != null) {</span>
<span class="nc" id="L586">                UIManager.getLookAndFeelDefaults().put(mapName, map);</span>
            }
        }
<span class="nc" id="L589">        ActionMap componentMap = new ActionMapUIResource();</span>
<span class="nc" id="L590">        componentMap.put(&quot;requestFocus&quot;, new FocusAction());</span>
        /*
         * fix for bug 4515750
         * JTextField &amp; non-editable JTextArea bind return key - default btn not accessible
         *
         * Wrap the return action so that it is only enabled when the
         * component is editable. This allows the default button to be
         * processed when the text component has focus and isn't editable.
         *
         */
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if (getEditorKit(editor) instanceof DefaultEditorKit) {</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">            if (map != null) {</span>
<span class="nc" id="L602">                Object obj = map.get(DefaultEditorKit.insertBreakAction);</span>
<span class="nc bnc" id="L603" title="All 4 branches missed.">                if (obj != null</span>
                    &amp;&amp; obj instanceof DefaultEditorKit.InsertBreakAction) {
<span class="nc" id="L605">                    Action action =  new TextActionWrapper((TextAction)obj);</span>
<span class="nc" id="L606">                    componentMap.put(action.getValue(Action.NAME),action);</span>
                }
            }
        }
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (map != null) {</span>
<span class="nc" id="L611">            componentMap.setParent(map);</span>
        }
<span class="nc" id="L613">        return componentMap;</span>
    }

    /**
     * Create a default action map.  This is basically the
     * set of actions found exported by the component.
     */
    ActionMap createActionMap() {
<span class="nc" id="L621">        ActionMap map = new ActionMapUIResource();</span>
<span class="nc" id="L622">        Action[] actions = editor.getActions();</span>
        //System.out.println(&quot;building map for UI: &quot; + getPropertyPrefix());
<span class="nc" id="L624">        int n = actions.length;</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L626">            Action a = actions[i];</span>
<span class="nc" id="L627">            map.put(a.getValue(Action.NAME), a);</span>
            //System.out.println(&quot;  &quot; + a.getValue(Action.NAME));
        }
<span class="nc" id="L630">        map.put(TransferHandler.getCutAction().getValue(Action.NAME),</span>
<span class="nc" id="L631">                TransferHandler.getCutAction());</span>
<span class="nc" id="L632">        map.put(TransferHandler.getCopyAction().getValue(Action.NAME),</span>
<span class="nc" id="L633">                TransferHandler.getCopyAction());</span>
<span class="nc" id="L634">        map.put(TransferHandler.getPasteAction().getValue(Action.NAME),</span>
<span class="nc" id="L635">                TransferHandler.getPasteAction());</span>
<span class="nc" id="L636">        return map;</span>
    }

    protected void uninstallKeyboardActions() {
<span class="nc" id="L640">        editor.setKeymap(null);</span>
<span class="nc" id="L641">        SwingUtilities.replaceUIInputMap(editor, JComponent.</span>
                                         WHEN_IN_FOCUSED_WINDOW, null);
<span class="nc" id="L643">        SwingUtilities.replaceUIActionMap(editor, null);</span>
<span class="nc" id="L644">    }</span>

    /**
     * Paints a background for the view.  This will only be
     * called if isOpaque() on the associated component is
     * true.  The default is to paint the background color
     * of the component.
     *
     * @param g the graphics context
     */
    protected void paintBackground(Graphics g) {
<span class="nc" id="L655">        g.setColor(editor.getBackground());</span>
<span class="nc" id="L656">        g.fillRect(0, 0, editor.getWidth(), editor.getHeight());</span>
<span class="nc" id="L657">    }</span>

    /**
     * Fetches the text component associated with this
     * UI implementation.  This will be null until
     * the ui has been installed.
     *
     * @return the editor component
     */
    protected final JTextComponent getComponent() {
<span class="nc" id="L667">        return editor;</span>
    }

    /**
     * Flags model changes.
     * This is called whenever the model has changed.
     * It is implemented to rebuild the view hierarchy
     * to represent the default root element of the
     * associated model.
     */
    protected void modelChanged() {
        // create a view hierarchy
<span class="nc" id="L679">        ViewFactory f = rootView.getViewFactory();</span>
<span class="nc" id="L680">        Document doc = editor.getDocument();</span>
<span class="nc" id="L681">        Element elem = doc.getDefaultRootElement();</span>
<span class="nc" id="L682">        setView(f.create(elem));</span>
<span class="nc" id="L683">    }</span>

    /**
     * Sets the current root of the view hierarchy and calls invalidate().
     * If there were any child components, they will be removed (i.e.
     * there are assumed to have come from components embedded in views).
     *
     * @param v the root view
     */
    protected final void setView(View v) {
<span class="nc" id="L693">        rootView.setView(v);</span>
<span class="nc" id="L694">        painted = false;</span>
<span class="nc" id="L695">        editor.revalidate();</span>
<span class="nc" id="L696">        editor.repaint();</span>
<span class="nc" id="L697">    }</span>

    /**
     * Paints the interface safely with a guarantee that
     * the model won't change from the view of this thread.
     * This does the following things, rendering from
     * back to front.
     * &lt;ol&gt;
     * &lt;li&gt;
     * If the component is marked as opaque, the background
     * is painted in the current background color of the
     * component.
     * &lt;li&gt;
     * The highlights (if any) are painted.
     * &lt;li&gt;
     * The view hierarchy is painted.
     * &lt;li&gt;
     * The caret is painted.
     * &lt;/ol&gt;
     *
     * @param g the graphics context
     */
    protected void paintSafely(Graphics g) {
<span class="nc" id="L720">        painted = true;</span>
<span class="nc" id="L721">        Highlighter highlighter = editor.getHighlighter();</span>
<span class="nc" id="L722">        Caret caret = editor.getCaret();</span>

        // paint the background
<span class="nc bnc" id="L725" title="All 2 branches missed.">        if (editor.isOpaque()) {</span>
<span class="nc" id="L726">            paintBackground(g);</span>
        }

        // paint the highlights
<span class="nc bnc" id="L730" title="All 2 branches missed.">        if (highlighter != null) {</span>
<span class="nc" id="L731">            highlighter.paint(g);</span>
        }

        // paint the view hierarchy
<span class="nc" id="L735">        Rectangle alloc = getVisibleEditorRect();</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">        if (alloc != null) {</span>
<span class="nc" id="L737">            rootView.paint(g, alloc);</span>
        }

        // paint the caret
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (caret != null) {</span>
<span class="nc" id="L742">            caret.paint(g);</span>
        }

<span class="nc bnc" id="L745" title="All 2 branches missed.">        if (dropCaret != null) {</span>
<span class="nc" id="L746">            dropCaret.paint(g);</span>
        }
<span class="nc" id="L748">    }</span>

    // --- ComponentUI methods --------------------------------------------

    /**
     * Installs the UI for a component.  This does the following
     * things.
     * &lt;ol&gt;
     * &lt;li&gt;
     * Sets the associated component to opaque if the opaque property
     * has not already been set by the client program. This will cause the
     * component's background color to be painted.
     * &lt;li&gt;
     * Installs the default caret and highlighter into the
     * associated component. These properties are only set if their
     * current value is either {@code null} or an instance of
     * {@link UIResource}.
     * &lt;li&gt;
     * Attaches to the editor and model.  If there is no
     * model, a default one is created.
     * &lt;li&gt;
     * Creates the view factory and the view hierarchy used
     * to represent the model.
     * &lt;/ol&gt;
     *
     * @param c the editor component
     * @see ComponentUI#installUI
     */
    public void installUI(JComponent c) {
<span class="nc bnc" id="L777" title="All 2 branches missed.">        if (c instanceof JTextComponent) {</span>
<span class="nc" id="L778">            editor = (JTextComponent) c;</span>

            // common case is background painted... this can
            // easily be changed by subclasses or from outside
            // of the component.
<span class="nc" id="L783">            LookAndFeel.installProperty(editor, &quot;opaque&quot;, Boolean.TRUE);</span>
<span class="nc" id="L784">            LookAndFeel.installProperty(editor, &quot;autoscrolls&quot;, Boolean.TRUE);</span>

            // install defaults
<span class="nc" id="L787">            installDefaults();</span>
<span class="nc" id="L788">            installDefaults2();</span>

            // attach to the model and editor
<span class="nc" id="L791">            editor.addPropertyChangeListener(updateHandler);</span>
<span class="nc" id="L792">            Document doc = editor.getDocument();</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">            if (doc == null) {</span>
                // no model, create a default one.  This will
                // fire a notification to the updateHandler
                // which takes care of the rest.
<span class="nc" id="L797">                editor.setDocument(getEditorKit(editor).createDefaultDocument());</span>
            } else {
<span class="nc" id="L799">                doc.addDocumentListener(updateHandler);</span>
<span class="nc" id="L800">                modelChanged();</span>
            }

            // install keymap
<span class="nc" id="L804">            installListeners();</span>
<span class="nc" id="L805">            installKeyboardActions();</span>

<span class="nc" id="L807">            LayoutManager oldLayout = editor.getLayout();</span>
<span class="nc bnc" id="L808" title="All 4 branches missed.">            if ((oldLayout == null) || (oldLayout instanceof UIResource)) {</span>
                // by default, use default LayoutManger implementation that
                // will position the components associated with a View object.
<span class="nc" id="L811">                editor.setLayout(updateHandler);</span>
            }

<span class="nc" id="L814">            updateBackground(editor);</span>
<span class="nc" id="L815">        } else {</span>
<span class="nc" id="L816">            throw new Error(&quot;TextUI needs JTextComponent&quot;);</span>
        }
<span class="nc" id="L818">    }</span>

    /**
     * Deinstalls the UI for a component.  This removes the listeners,
     * uninstalls the highlighter, removes views, and nulls out the keymap.
     *
     * @param c the editor component
     * @see ComponentUI#uninstallUI
     */
    public void uninstallUI(JComponent c) {
        // detach from the model
<span class="nc" id="L829">        editor.removePropertyChangeListener(updateHandler);</span>
<span class="nc" id="L830">        editor.getDocument().removeDocumentListener(updateHandler);</span>

        // view part
<span class="nc" id="L833">        painted = false;</span>
<span class="nc" id="L834">        uninstallDefaults();</span>
<span class="nc" id="L835">        rootView.setView(null);</span>
<span class="nc" id="L836">        c.removeAll();</span>
<span class="nc" id="L837">        LayoutManager lm = c.getLayout();</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">        if (lm instanceof UIResource) {</span>
<span class="nc" id="L839">            c.setLayout(null);</span>
        }

        // controller part
<span class="nc" id="L843">        uninstallKeyboardActions();</span>
<span class="nc" id="L844">        uninstallListeners();</span>

<span class="nc" id="L846">        editor = null;</span>
<span class="nc" id="L847">    }</span>

    /**
     * Superclass paints background in an uncontrollable way
     * (i.e. one might want an image tiled into the background).
     * To prevent this from happening twice, this method is
     * reimplemented to simply paint.
     * &lt;p&gt;
     * &lt;em&gt;NOTE:&lt;/em&gt; NOTE: Superclass is also not thread-safe in its
     * rendering of the background, although that is not an issue with the
     * default rendering.
     */
    public void update(Graphics g, JComponent c) {
<span class="nc" id="L860">        paint(g, c);</span>
<span class="nc" id="L861">    }</span>

    /**
     * Paints the interface.  This is routed to the
     * paintSafely method under the guarantee that
     * the model won't change from the view of this thread
     * while it's rendering (if the associated model is
     * derived from AbstractDocument).  This enables the
     * model to potentially be updated asynchronously.
     *
     * @param g the graphics context
     * @param c the editor component
     */
    public final void paint(Graphics g, JComponent c) {
<span class="nc bnc" id="L875" title="All 4 branches missed.">        if ((rootView.getViewCount() &gt; 0) &amp;&amp; (rootView.getView(0) != null)) {</span>
<span class="nc" id="L876">            Document doc = editor.getDocument();</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">            if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L878">                ((AbstractDocument)doc).readLock();</span>
            }
            try {
<span class="nc" id="L881">                paintSafely(g);</span>
            } finally {
<span class="nc bnc" id="L883" title="All 4 branches missed.">                if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L884">                    ((AbstractDocument)doc).readUnlock();</span>
                }
            }
        }
<span class="nc" id="L888">    }</span>

    /**
     * Gets the preferred size for the editor component.  If the component
     * has been given a size prior to receiving this request, it will
     * set the size of the view hierarchy to reflect the size of the component
     * before requesting the preferred size of the view hierarchy.  This
     * allows formatted views to format to the current component size before
     * answering the request.  Other views don't care about currently formatted
     * size and give the same answer either way.
     *
     * @param c the editor component
     * @return the size
     */
    public Dimension getPreferredSize(JComponent c) {
<span class="nc" id="L903">        Document doc = editor.getDocument();</span>
<span class="nc" id="L904">        Insets i = c.getInsets();</span>
<span class="nc" id="L905">        Dimension d = c.getSize();</span>

<span class="nc bnc" id="L907" title="All 2 branches missed.">        if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L908">            ((AbstractDocument)doc).readLock();</span>
        }
        try {
<span class="nc bnc" id="L911" title="All 4 branches missed.">            if ((d.width &gt; (i.left + i.right)) &amp;&amp; (d.height &gt; (i.top + i.bottom))) {</span>
<span class="nc" id="L912">                rootView.setSize(d.width - i.left - i.right, d.height - i.top - i.bottom);</span>
            }
<span class="nc bnc" id="L914" title="All 4 branches missed.">            else if (d.width == 0 &amp;&amp; d.height == 0) {</span>
                // Probably haven't been layed out yet, force some sort of
                // initial sizing.
<span class="nc" id="L917">                rootView.setSize(Integer.MAX_VALUE, Integer.MAX_VALUE);</span>
            }
<span class="nc" id="L919">            d.width = (int) Math.min((long) rootView.getPreferredSpan(View.X_AXIS) +</span>
                                     (long) i.left + (long) i.right, Integer.MAX_VALUE);
<span class="nc" id="L921">            d.height = (int) Math.min((long) rootView.getPreferredSpan(View.Y_AXIS) +</span>
                                      (long) i.top + (long) i.bottom, Integer.MAX_VALUE);
        } finally {
<span class="nc bnc" id="L924" title="All 4 branches missed.">            if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L925">                ((AbstractDocument)doc).readUnlock();</span>
            }
        }
<span class="nc" id="L928">        return d;</span>
    }

    /**
     * Gets the minimum size for the editor component.
     *
     * @param c the editor component
     * @return the size
     */
    public Dimension getMinimumSize(JComponent c) {
<span class="nc" id="L938">        Document doc = editor.getDocument();</span>
<span class="nc" id="L939">        Insets i = c.getInsets();</span>
<span class="nc" id="L940">        Dimension d = new Dimension();</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">        if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L942">            ((AbstractDocument)doc).readLock();</span>
        }
        try {
<span class="nc" id="L945">            d.width = (int) rootView.getMinimumSpan(View.X_AXIS) + i.left + i.right;</span>
<span class="nc" id="L946">            d.height = (int)  rootView.getMinimumSpan(View.Y_AXIS) + i.top + i.bottom;</span>
        } finally {
<span class="nc bnc" id="L948" title="All 4 branches missed.">            if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L949">                ((AbstractDocument)doc).readUnlock();</span>
            }
        }
<span class="nc" id="L952">        return d;</span>
    }

    /**
     * Gets the maximum size for the editor component.
     *
     * @param c the editor component
     * @return the size
     */
    public Dimension getMaximumSize(JComponent c) {
<span class="nc" id="L962">        Document doc = editor.getDocument();</span>
<span class="nc" id="L963">        Insets i = c.getInsets();</span>
<span class="nc" id="L964">        Dimension d = new Dimension();</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">        if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L966">            ((AbstractDocument)doc).readLock();</span>
        }
        try {
<span class="nc" id="L969">            d.width = (int) Math.min((long) rootView.getMaximumSpan(View.X_AXIS) +</span>
                                     (long) i.left + (long) i.right, Integer.MAX_VALUE);
<span class="nc" id="L971">            d.height = (int) Math.min((long) rootView.getMaximumSpan(View.Y_AXIS) +</span>
                                      (long) i.top + (long) i.bottom, Integer.MAX_VALUE);
        } finally {
<span class="nc bnc" id="L974" title="All 4 branches missed.">            if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L975">                ((AbstractDocument)doc).readUnlock();</span>
            }
        }
<span class="nc" id="L978">        return d;</span>
    }

    // ---- TextUI methods -------------------------------------------


    /**
     * Gets the allocation to give the root View.  Due
     * to an unfortunate set of historical events this
     * method is inappropriately named.  The Rectangle
     * returned has nothing to do with visibility.
     * The component must have a non-zero positive size for
     * this translation to be computed.
     *
     * @return the bounding box for the root view
     */
    protected Rectangle getVisibleEditorRect() {
<span class="nc" id="L995">        Rectangle alloc = editor.getBounds();</span>
<span class="nc bnc" id="L996" title="All 4 branches missed.">        if ((alloc.width &gt; 0) &amp;&amp; (alloc.height &gt; 0)) {</span>
<span class="nc" id="L997">            alloc.x = alloc.y = 0;</span>
<span class="nc" id="L998">            Insets insets = editor.getInsets();</span>
<span class="nc" id="L999">            alloc.x += insets.left;</span>
<span class="nc" id="L1000">            alloc.y += insets.top;</span>
<span class="nc" id="L1001">            alloc.width -= insets.left + insets.right;</span>
<span class="nc" id="L1002">            alloc.height -= insets.top + insets.bottom;</span>
<span class="nc" id="L1003">            return alloc;</span>
        }
<span class="nc" id="L1005">        return null;</span>
    }

    /**
     * Converts the given location in the model to a place in
     * the view coordinate system.
     * The component must have a non-zero positive size for
     * this translation to be computed.
     *
     * @param tc the text component for which this UI is installed
     * @param pos the local location in the model to translate &amp;gt;= 0
     * @return the coordinates as a rectangle, null if the model is not painted
     * @exception BadLocationException  if the given position does not
     *   represent a valid location in the associated document
     * @see TextUI#modelToView
     */
    public Rectangle modelToView(JTextComponent tc, int pos) throws BadLocationException {
<span class="nc" id="L1022">        return modelToView(tc, pos, Position.Bias.Forward);</span>
    }

    /**
     * Converts the given location in the model to a place in
     * the view coordinate system.
     * The component must have a non-zero positive size for
     * this translation to be computed.
     *
     * @param tc the text component for which this UI is installed
     * @param pos the local location in the model to translate &amp;gt;= 0
     * @return the coordinates as a rectangle, null if the model is not painted
     * @exception BadLocationException  if the given position does not
     *   represent a valid location in the associated document
     * @see TextUI#modelToView
     */
    public Rectangle modelToView(JTextComponent tc, int pos, Position.Bias bias) throws BadLocationException {
<span class="nc" id="L1039">        Document doc = editor.getDocument();</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">        if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1041">            ((AbstractDocument)doc).readLock();</span>
        }
        try {
<span class="nc" id="L1044">            Rectangle alloc = getVisibleEditorRect();</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">            if (alloc != null) {</span>
<span class="nc" id="L1046">                rootView.setSize(alloc.width, alloc.height);</span>
<span class="nc" id="L1047">                Shape s = rootView.modelToView(pos, alloc, bias);</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">                if (s != null) {</span>
<span class="nc" id="L1049">                  return s.getBounds();</span>
                }
            }
        } finally {
<span class="nc bnc" id="L1053" title="All 6 branches missed.">            if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1054">                ((AbstractDocument)doc).readUnlock();</span>
            }
        }
<span class="nc" id="L1057">        return null;</span>
    }

    /**
     * Converts the given place in the view coordinate system
     * to the nearest representative location in the model.
     * The component must have a non-zero positive size for
     * this translation to be computed.
     *
     * @param tc the text component for which this UI is installed
     * @param pt the location in the view to translate.  This
     *  should be in the same coordinate system as the mouse events.
     * @return the offset from the start of the document &amp;gt;= 0,
     *   -1 if not painted
     * @see TextUI#viewToModel
     */
    public int viewToModel(JTextComponent tc, Point pt) {
<span class="nc" id="L1074">        return viewToModel(tc, pt, discardBias);</span>
    }

    /**
     * Converts the given place in the view coordinate system
     * to the nearest representative location in the model.
     * The component must have a non-zero positive size for
     * this translation to be computed.
     *
     * @param tc the text component for which this UI is installed
     * @param pt the location in the view to translate.  This
     *  should be in the same coordinate system as the mouse events.
     * @return the offset from the start of the document &amp;gt;= 0,
     *   -1 if the component doesn't yet have a positive size.
     * @see TextUI#viewToModel
     */
    public int viewToModel(JTextComponent tc, Point pt,
                           Position.Bias[] biasReturn) {
<span class="nc" id="L1092">        int offs = -1;</span>
<span class="nc" id="L1093">        Document doc = editor.getDocument();</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">        if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1095">            ((AbstractDocument)doc).readLock();</span>
        }
        try {
<span class="nc" id="L1098">            Rectangle alloc = getVisibleEditorRect();</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">            if (alloc != null) {</span>
<span class="nc" id="L1100">                rootView.setSize(alloc.width, alloc.height);</span>
<span class="nc" id="L1101">                offs = rootView.viewToModel(pt.x, pt.y, alloc, biasReturn);</span>
            }
        } finally {
<span class="nc bnc" id="L1104" title="All 4 branches missed.">            if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1105">                ((AbstractDocument)doc).readUnlock();</span>
            }
        }
<span class="nc" id="L1108">        return offs;</span>
    }

    /**
     * {@inheritDoc}
     */
    public int getNextVisualPositionFrom(JTextComponent t, int pos,
                    Position.Bias b, int direction, Position.Bias[] biasRet)
                    throws BadLocationException{
<span class="nc" id="L1117">        Document doc = editor.getDocument();</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1119">            ((AbstractDocument)doc).readLock();</span>
        }
        try {
<span class="nc bnc" id="L1122" title="All 2 branches missed.">            if (painted) {</span>
<span class="nc" id="L1123">                Rectangle alloc = getVisibleEditorRect();</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">                if (alloc != null) {</span>
<span class="nc" id="L1125">                    rootView.setSize(alloc.width, alloc.height);</span>
                }
<span class="nc" id="L1127">                return rootView.getNextVisualPositionFrom(pos, b, alloc, direction,</span>
                                                          biasRet);
            }
        } finally {
<span class="nc bnc" id="L1131" title="All 6 branches missed.">            if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1132">                ((AbstractDocument)doc).readUnlock();</span>
            }
        }
<span class="nc" id="L1135">        return -1;</span>
    }

    /**
     * Causes the portion of the view responsible for the
     * given part of the model to be repainted.  Does nothing if
     * the view is not currently painted.
     *
     * @param tc the text component for which this UI is installed
     * @param p0 the beginning of the range &amp;gt;= 0
     * @param p1 the end of the range &amp;gt;= p0
     * @see TextUI#damageRange
     */
    public void damageRange(JTextComponent tc, int p0, int p1) {
<span class="nc" id="L1149">        damageRange(tc, p0, p1, Position.Bias.Forward, Position.Bias.Backward);</span>
<span class="nc" id="L1150">    }</span>

    /**
     * Causes the portion of the view responsible for the
     * given part of the model to be repainted.
     *
     * @param p0 the beginning of the range &amp;gt;= 0
     * @param p1 the end of the range &amp;gt;= p0
     */
    public void damageRange(JTextComponent t, int p0, int p1,
                            Position.Bias p0Bias, Position.Bias p1Bias) {
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        if (painted) {</span>
<span class="nc" id="L1162">            Rectangle alloc = getVisibleEditorRect();</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">            if (alloc != null) {</span>
<span class="nc" id="L1164">                Document doc = t.getDocument();</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">                if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1166">                    ((AbstractDocument)doc).readLock();</span>
                }
                try {
<span class="nc" id="L1169">                    rootView.setSize(alloc.width, alloc.height);</span>
<span class="nc" id="L1170">                    Shape toDamage = rootView.modelToView(p0, p0Bias,</span>
                            p1, p1Bias, alloc);
<span class="nc bnc" id="L1172" title="All 2 branches missed.">                    Rectangle rect = (toDamage instanceof Rectangle) ?</span>
<span class="nc" id="L1173">                            (Rectangle)toDamage : toDamage.getBounds();</span>
<span class="nc" id="L1174">                    editor.repaint(rect.x, rect.y, rect.width, rect.height);</span>
<span class="nc" id="L1175">                } catch (BadLocationException e) {</span>
                } finally {
<span class="nc bnc" id="L1177" title="All 6 branches missed.">                    if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1178">                        ((AbstractDocument)doc).readUnlock();</span>
                    }
                }
            }
        }
<span class="nc" id="L1183">    }</span>

    /**
     * Fetches the EditorKit for the UI.
     *
     * @param tc the text component for which this UI is installed
     * @return the editor capabilities
     * @see TextUI#getEditorKit
     */
    public EditorKit getEditorKit(JTextComponent tc) {
<span class="nc" id="L1193">        return defaultKit;</span>
    }

    /**
     * Fetches a View with the allocation of the associated
     * text component (i.e. the root of the hierarchy) that
     * can be traversed to determine how the model is being
     * represented spatially.
     * &lt;p&gt;
     * &lt;font color=red&gt;&lt;b&gt;NOTE:&lt;/b&gt;The View hierarchy can
     * be traversed from the root view, and other things
     * can be done as well.  Things done in this way cannot
     * be protected like simple method calls through the TextUI.
     * Therefore, proper operation in the presence of concurrency
     * must be arranged by any logic that calls this method!
     * &lt;/font&gt;
     *
     * @param tc the text component for which this UI is installed
     * @return the view
     * @see TextUI#getRootView
     */
    public View getRootView(JTextComponent tc) {
<span class="nc" id="L1215">        return rootView;</span>
    }


    /**
     * Returns the string to be used as the tooltip at the passed in location.
     * This forwards the method onto the root View.
     *
     * @see javax.swing.text.JTextComponent#getToolTipText
     * @see javax.swing.text.View#getToolTipText
     * @since 1.4
     */
    public String getToolTipText(JTextComponent t, Point pt) {
<span class="nc bnc" id="L1228" title="All 2 branches missed.">        if (!painted) {</span>
<span class="nc" id="L1229">            return null;</span>
        }
<span class="nc" id="L1231">        Document doc = editor.getDocument();</span>
<span class="nc" id="L1232">        String tt = null;</span>
<span class="nc" id="L1233">        Rectangle alloc = getVisibleEditorRect();</span>

<span class="nc bnc" id="L1235" title="All 2 branches missed.">        if (alloc != null) {</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">            if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1237">                ((AbstractDocument)doc).readLock();</span>
            }
            try {
<span class="nc" id="L1240">                tt = rootView.getToolTipText(pt.x, pt.y, alloc);</span>
            } finally {
<span class="nc bnc" id="L1242" title="All 4 branches missed.">                if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1243">                    ((AbstractDocument)doc).readUnlock();</span>
                }
            }
        }
<span class="nc" id="L1247">        return tt;</span>
    }

    // --- ViewFactory methods ------------------------------

    /**
     * Creates a view for an element.
     * If a subclass wishes to directly implement the factory
     * producing the view(s), it should reimplement this
     * method.  By default it simply returns null indicating
     * it is unable to represent the element.
     *
     * @param elem the element
     * @return the view
     */
    public View create(Element elem) {
<span class="nc" id="L1263">        return null;</span>
    }

    /**
     * Creates a view for an element.
     * If a subclass wishes to directly implement the factory
     * producing the view(s), it should reimplement this
     * method.  By default it simply returns null indicating
     * it is unable to represent the part of the element.
     *
     * @param elem the element
     * @param p0 the starting offset &amp;gt;= 0
     * @param p1 the ending offset &amp;gt;= p0
     * @return the view
     */
    public View create(Element elem, int p0, int p1) {
<span class="nc" id="L1279">        return null;</span>
    }

<span class="nc" id="L1282">    public static class BasicCaret extends DefaultCaret implements UIResource {}</span>

<span class="nc" id="L1284">    public static class BasicHighlighter extends DefaultHighlighter implements UIResource {}</span>

    static class BasicCursor extends Cursor implements UIResource {
        BasicCursor(int type) {
<span class="nc" id="L1288">            super(type);</span>
<span class="nc" id="L1289">        }</span>

        BasicCursor(String name) {
<span class="nc" id="L1292">            super(name);</span>
<span class="nc" id="L1293">        }</span>
    }

<span class="nc" id="L1296">    private static BasicCursor textCursor = new BasicCursor(Cursor.TEXT_CURSOR);</span>
    // ----- member variables ---------------------------------------

<span class="nc" id="L1299">    private static final EditorKit defaultKit = new DefaultEditorKit();</span>
    transient JTextComponent editor;
    transient boolean painted;
<span class="nc" id="L1302">    transient RootView rootView = new RootView();</span>
<span class="nc" id="L1303">    transient UpdateHandler updateHandler = new UpdateHandler();</span>
<span class="nc" id="L1304">    private static final TransferHandler defaultTransferHandler = new TextTransferHandler();</span>
<span class="nc" id="L1305">    private final DragListener dragListener = getDragListener();</span>
<span class="nc" id="L1306">    private static final Position.Bias[] discardBias = new Position.Bias[1];</span>
    private DefaultCaret dropCaret;

    /**
     * Root view that acts as a gateway between the component
     * and the View hierarchy.
     */
    class RootView extends View {

<span class="nc" id="L1315">        RootView() {</span>
<span class="nc" id="L1316">            super(null);</span>
<span class="nc" id="L1317">        }</span>

        void setView(View v) {
<span class="nc" id="L1320">            View oldView = view;</span>
<span class="nc" id="L1321">            view = null;</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">            if (oldView != null) {</span>
                // get rid of back reference so that the old
                // hierarchy can be garbage collected.
<span class="nc" id="L1325">                oldView.setParent(null);</span>
            }
<span class="nc bnc" id="L1327" title="All 2 branches missed.">            if (v != null) {</span>
<span class="nc" id="L1328">                v.setParent(this);</span>
            }
<span class="nc" id="L1330">            view = v;</span>
<span class="nc" id="L1331">        }</span>

        /**
         * Fetches the attributes to use when rendering.  At the root
         * level there are no attributes.  If an attribute is resolved
         * up the view hierarchy this is the end of the line.
         */
        public AttributeSet getAttributes() {
<span class="nc" id="L1339">            return null;</span>
        }

        /**
         * Determines the preferred span for this view along an axis.
         *
         * @param axis may be either X_AXIS or Y_AXIS
         * @return the span the view would like to be rendered into.
         *         Typically the view is told to render into the span
         *         that is returned, although there is no guarantee.
         *         The parent may choose to resize or break the view.
         */
        public float getPreferredSpan(int axis) {
<span class="nc bnc" id="L1352" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1353">                return view.getPreferredSpan(axis);</span>
            }
<span class="nc" id="L1355">            return 10;</span>
        }

        /**
         * Determines the minimum span for this view along an axis.
         *
         * @param axis may be either X_AXIS or Y_AXIS
         * @return the span the view would like to be rendered into.
         *         Typically the view is told to render into the span
         *         that is returned, although there is no guarantee.
         *         The parent may choose to resize or break the view.
         */
        public float getMinimumSpan(int axis) {
<span class="nc bnc" id="L1368" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1369">                return view.getMinimumSpan(axis);</span>
            }
<span class="nc" id="L1371">            return 10;</span>
        }

        /**
         * Determines the maximum span for this view along an axis.
         *
         * @param axis may be either X_AXIS or Y_AXIS
         * @return the span the view would like to be rendered into.
         *         Typically the view is told to render into the span
         *         that is returned, although there is no guarantee.
         *         The parent may choose to resize or break the view.
         */
        public float getMaximumSpan(int axis) {
<span class="nc" id="L1384">            return Integer.MAX_VALUE;</span>
        }

        /**
         * Specifies that a preference has changed.
         * Child views can call this on the parent to indicate that
         * the preference has changed.  The root view routes this to
         * invalidate on the hosting component.
         * &lt;p&gt;
         * This can be called on a different thread from the
         * event dispatching thread and is basically unsafe to
         * propagate into the component.  To make this safe,
         * the operation is transferred over to the event dispatching
         * thread for completion.  It is a design goal that all view
         * methods be safe to call without concern for concurrency,
         * and this behavior helps make that true.
         *
         * @param child the child view
         * @param width true if the width preference has changed
         * @param height true if the height preference has changed
         */
        public void preferenceChanged(View child, boolean width, boolean height) {
<span class="nc" id="L1406">            editor.revalidate();</span>
<span class="nc" id="L1407">        }</span>

        /**
         * Determines the desired alignment for this view along an axis.
         *
         * @param axis may be either X_AXIS or Y_AXIS
         * @return the desired alignment, where 0.0 indicates the origin
         *     and 1.0 the full span away from the origin
         */
        public float getAlignment(int axis) {
<span class="nc bnc" id="L1417" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1418">                return view.getAlignment(axis);</span>
            }
<span class="nc" id="L1420">            return 0;</span>
        }

        /**
         * Renders the view.
         *
         * @param g the graphics context
         * @param allocation the region to render into
         */
        public void paint(Graphics g, Shape allocation) {
<span class="nc bnc" id="L1430" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">                Rectangle alloc = (allocation instanceof Rectangle) ?</span>
<span class="nc" id="L1432">                          (Rectangle)allocation : allocation.getBounds();</span>
<span class="nc" id="L1433">                setSize(alloc.width, alloc.height);</span>
<span class="nc" id="L1434">                view.paint(g, allocation);</span>
            }
<span class="nc" id="L1436">        }</span>

        /**
         * Sets the view parent.
         *
         * @param parent the parent view
         */
        public void setParent(View parent) {
<span class="nc" id="L1444">            throw new Error(&quot;Can't set parent on root view&quot;);</span>
        }

        /**
         * Returns the number of views in this view.  Since
         * this view simply wraps the root of the view hierarchy
         * it has exactly one child.
         *
         * @return the number of views
         * @see #getView
         */
        public int getViewCount() {
<span class="nc" id="L1456">            return 1;</span>
        }

        /**
         * Gets the n-th view in this container.
         *
         * @param n the number of the view to get
         * @return the view
         */
        public View getView(int n) {
<span class="nc" id="L1466">            return view;</span>
        }

        /**
         * Returns the child view index representing the given position in
         * the model.  This is implemented to return the index of the only
         * child.
         *
         * @param pos the position &amp;gt;= 0
         * @return  index of the view representing the given position, or
         *   -1 if no view represents that position
         * @since 1.3
         */
        public int getViewIndex(int pos, Position.Bias b) {
<span class="nc" id="L1480">            return 0;</span>
        }

        /**
         * Fetches the allocation for the given child view.
         * This enables finding out where various views
         * are located, without assuming the views store
         * their location.  This returns the given allocation
         * since this view simply acts as a gateway between
         * the view hierarchy and the associated component.
         *
         * @param index the index of the child
         * @param a  the allocation to this view.
         * @return the allocation to the child
         */
        public Shape getChildAllocation(int index, Shape a) {
<span class="nc" id="L1496">            return a;</span>
        }

        /**
         * Provides a mapping from the document model coordinate space
         * to the coordinate space of the view mapped to it.
         *
         * @param pos the position to convert
         * @param a the allocated region to render into
         * @return the bounding box of the given position
         */
        public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
<span class="nc bnc" id="L1508" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1509">                return view.modelToView(pos, a, b);</span>
            }
<span class="nc" id="L1511">            return null;</span>
        }

        /**
         * Provides a mapping from the document model coordinate space
         * to the coordinate space of the view mapped to it.
         *
         * @param p0 the position to convert &amp;gt;= 0
         * @param b0 the bias toward the previous character or the
         *  next character represented by p0, in case the
         *  position is a boundary of two views.
         * @param p1 the position to convert &amp;gt;= 0
         * @param b1 the bias toward the previous character or the
         *  next character represented by p1, in case the
         *  position is a boundary of two views.
         * @param a the allocated region to render into
         * @return the bounding box of the given position is returned
         * @exception BadLocationException  if the given position does
         *   not represent a valid location in the associated document
         * @exception IllegalArgumentException for an invalid bias argument
         * @see View#viewToModel
         */
        public Shape modelToView(int p0, Position.Bias b0, int p1, Position.Bias b1, Shape a) throws BadLocationException {
<span class="nc bnc" id="L1534" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1535">                return view.modelToView(p0, b0, p1, b1, a);</span>
            }
<span class="nc" id="L1537">            return null;</span>
        }

        /**
         * Provides a mapping from the view coordinate space to the logical
         * coordinate space of the model.
         *
         * @param x x coordinate of the view location to convert
         * @param y y coordinate of the view location to convert
         * @param a the allocated region to render into
         * @return the location within the model that best represents the
         *    given point in the view
         */
        public int viewToModel(float x, float y, Shape a, Position.Bias[] bias) {
<span class="nc bnc" id="L1551" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1552">                int retValue = view.viewToModel(x, y, a, bias);</span>
<span class="nc" id="L1553">                return retValue;</span>
            }
<span class="nc" id="L1555">            return -1;</span>
        }

        /**
         * Provides a way to determine the next visually represented model
         * location that one might place a caret.  Some views may not be visible,
         * they might not be in the same order found in the model, or they just
         * might not allow access to some of the locations in the model.
         * This method enables specifying a position to convert
         * within the range of &amp;gt;=0.  If the value is -1, a position
         * will be calculated automatically.  If the value &amp;lt; -1,
         * the {@code BadLocationException} will be thrown.
         *
         * @param pos the position to convert &amp;gt;= 0
         * @param a the allocated region to render into
         * @param direction the direction from the current position that can
         *  be thought of as the arrow keys typically found on a keyboard.
         *  This may be SwingConstants.WEST, SwingConstants.EAST,
         *  SwingConstants.NORTH, or SwingConstants.SOUTH.
         * @return the location within the model that best represents the next
         *  location visual position.
         * @exception BadLocationException the given position is not a valid
         *                                 position within the document
         * @exception IllegalArgumentException for an invalid direction
         */
        public int getNextVisualPositionFrom(int pos, Position.Bias b, Shape a,
                                             int direction,
                                             Position.Bias[] biasRet)
            throws BadLocationException {
<span class="nc bnc" id="L1584" title="All 2 branches missed.">            if (pos &lt; -1) {</span>
<span class="nc" id="L1585">                throw new BadLocationException(&quot;invalid position&quot;, pos);</span>
            }
<span class="nc bnc" id="L1587" title="All 2 branches missed.">            if( view != null ) {</span>
<span class="nc" id="L1588">                int nextPos = view.getNextVisualPositionFrom(pos, b, a,</span>
                                                     direction, biasRet);
<span class="nc bnc" id="L1590" title="All 2 branches missed.">                if(nextPos != -1) {</span>
<span class="nc" id="L1591">                    pos = nextPos;</span>
                }
                else {
<span class="nc" id="L1594">                    biasRet[0] = b;</span>
                }
            }
<span class="nc" id="L1597">            return pos;</span>
        }

        /**
         * Gives notification that something was inserted into the document
         * in a location that this view is responsible for.
         *
         * @param e the change information from the associated document
         * @param a the current allocation of the view
         * @param f the factory to use to rebuild if the view has children
         */
        public void insertUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc bnc" id="L1609" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1610">                view.insertUpdate(e, a, f);</span>
            }
<span class="nc" id="L1612">        }</span>

        /**
         * Gives notification that something was removed from the document
         * in a location that this view is responsible for.
         *
         * @param e the change information from the associated document
         * @param a the current allocation of the view
         * @param f the factory to use to rebuild if the view has children
         */
        public void removeUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc bnc" id="L1623" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1624">                view.removeUpdate(e, a, f);</span>
            }
<span class="nc" id="L1626">        }</span>

        /**
         * Gives notification from the document that attributes were changed
         * in a location that this view is responsible for.
         *
         * @param e the change information from the associated document
         * @param a the current allocation of the view
         * @param f the factory to use to rebuild if the view has children
         */
        public void changedUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc bnc" id="L1637" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1638">                view.changedUpdate(e, a, f);</span>
            }
<span class="nc" id="L1640">        }</span>

        /**
         * Returns the document model underlying the view.
         *
         * @return the model
         */
        public Document getDocument() {
<span class="nc" id="L1648">            return editor.getDocument();</span>
        }

        /**
         * Returns the starting offset into the model for this view.
         *
         * @return the starting offset
         */
        public int getStartOffset() {
<span class="nc bnc" id="L1657" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1658">                return view.getStartOffset();</span>
            }
<span class="nc" id="L1660">            return getElement().getStartOffset();</span>
        }

        /**
         * Returns the ending offset into the model for this view.
         *
         * @return the ending offset
         */
        public int getEndOffset() {
<span class="nc bnc" id="L1669" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1670">                return view.getEndOffset();</span>
            }
<span class="nc" id="L1672">            return getElement().getEndOffset();</span>
        }

        /**
         * Gets the element that this view is mapped to.
         *
         * @return the view
         */
        public Element getElement() {
<span class="nc bnc" id="L1681" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1682">                return view.getElement();</span>
            }
<span class="nc" id="L1684">            return editor.getDocument().getDefaultRootElement();</span>
        }

        /**
         * Breaks this view on the given axis at the given length.
         *
         * @param axis may be either X_AXIS or Y_AXIS
         * @param len specifies where a break is desired in the span
         * @param the current allocation of the view
         * @return the fragment of the view that represents the given span
         *   if the view can be broken, otherwise null
         */
        public View breakView(int axis, float len, Shape a) {
<span class="nc" id="L1697">            throw new Error(&quot;Can't break root view&quot;);</span>
        }

        /**
         * Determines the resizability of the view along the
         * given axis.  A value of 0 or less is not resizable.
         *
         * @param axis may be either X_AXIS or Y_AXIS
         * @return the weight
         */
        public int getResizeWeight(int axis) {
<span class="nc bnc" id="L1708" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1709">                return view.getResizeWeight(axis);</span>
            }
<span class="nc" id="L1711">            return 0;</span>
        }

        /**
         * Sets the view size.
         *
         * @param width the width
         * @param height the height
         */
        public void setSize(float width, float height) {
<span class="nc bnc" id="L1721" title="All 2 branches missed.">            if (view != null) {</span>
<span class="nc" id="L1722">                view.setSize(width, height);</span>
            }
<span class="nc" id="L1724">        }</span>

        /**
         * Fetches the container hosting the view.  This is useful for
         * things like scheduling a repaint, finding out the host
         * components font, etc.  The default implementation
         * of this is to forward the query to the parent view.
         *
         * @return the container
         */
        public Container getContainer() {
<span class="nc" id="L1735">            return editor;</span>
        }

        /**
         * Fetches the factory to be used for building the
         * various view fragments that make up the view that
         * represents the model.  This is what determines
         * how the model will be represented.  This is implemented
         * to fetch the factory provided by the associated
         * EditorKit unless that is null, in which case this
         * simply returns the BasicTextUI itself which allows
         * subclasses to implement a simple factory directly without
         * creating extra objects.
         *
         * @return the factory
         */
        public ViewFactory getViewFactory() {
<span class="nc" id="L1752">            EditorKit kit = getEditorKit(editor);</span>
<span class="nc" id="L1753">            ViewFactory f = kit.getViewFactory();</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">            if (f != null) {</span>
<span class="nc" id="L1755">                return f;</span>
            }
<span class="nc" id="L1757">            return BasicTextUI.this;</span>
        }

        private View view;

    }

    /**
     * Handles updates from various places.  If the model is changed,
     * this class unregisters as a listener to the old model and
     * registers with the new model.  If the document model changes,
     * the change is forwarded to the root view.  If the focus
     * accelerator changes, a new keystroke is registered to request
     * focus.
     */
<span class="nc" id="L1772">    class UpdateHandler implements PropertyChangeListener, DocumentListener, LayoutManager2, UIResource {</span>

        // --- PropertyChangeListener methods -----------------------

        /**
         * This method gets called when a bound property is changed.
         * We are looking for document changes on the editor.
         */
        public final void propertyChange(PropertyChangeEvent evt) {
<span class="nc" id="L1781">            Object oldValue = evt.getOldValue();</span>
<span class="nc" id="L1782">            Object newValue = evt.getNewValue();</span>
<span class="nc" id="L1783">            String propertyName = evt.getPropertyName();</span>
<span class="nc bnc" id="L1784" title="All 4 branches missed.">            if ((oldValue instanceof Document) || (newValue instanceof Document)) {</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">                if (oldValue != null) {</span>
<span class="nc" id="L1786">                    ((Document)oldValue).removeDocumentListener(this);</span>
<span class="nc" id="L1787">                    i18nView = false;</span>
                }
<span class="nc bnc" id="L1789" title="All 2 branches missed.">                if (newValue != null) {</span>
<span class="nc" id="L1790">                    ((Document)newValue).addDocumentListener(this);</span>
<span class="nc bnc" id="L1791" title="All 2 branches missed.">                    if (&quot;document&quot; == propertyName) {</span>
<span class="nc" id="L1792">                        setView(null);</span>
<span class="nc" id="L1793">                        BasicTextUI.this.propertyChange(evt);</span>
<span class="nc" id="L1794">                        modelChanged();</span>
<span class="nc" id="L1795">                        return;</span>
                    }
                }
<span class="nc" id="L1798">                modelChanged();</span>
            }
<span class="nc bnc" id="L1800" title="All 2 branches missed.">            if (&quot;focusAccelerator&quot; == propertyName) {</span>
<span class="nc" id="L1801">                updateFocusAcceleratorBinding(true);</span>
<span class="nc bnc" id="L1802" title="All 2 branches missed.">            } else if (&quot;componentOrientation&quot; == propertyName) {</span>
                // Changes in ComponentOrientation require the views to be
                // rebuilt.
<span class="nc" id="L1805">                modelChanged();</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">            } else if (&quot;font&quot; == propertyName) {</span>
<span class="nc" id="L1807">                modelChanged();</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">            } else if (&quot;dropLocation&quot; == propertyName) {</span>
<span class="nc" id="L1809">                dropIndexChanged();</span>
<span class="nc bnc" id="L1810" title="All 2 branches missed.">            } else if (&quot;editable&quot; == propertyName) {</span>
<span class="nc" id="L1811">                updateCursor();</span>
<span class="nc" id="L1812">                modelChanged();</span>
            }
<span class="nc" id="L1814">            BasicTextUI.this.propertyChange(evt);</span>
<span class="nc" id="L1815">        }</span>

        private void dropIndexChanged() {
<span class="nc bnc" id="L1818" title="All 2 branches missed.">            if (editor.getDropMode() == DropMode.USE_SELECTION) {</span>
<span class="nc" id="L1819">                return;</span>
            }

<span class="nc" id="L1822">            JTextComponent.DropLocation dropLocation = editor.getDropLocation();</span>

<span class="nc bnc" id="L1824" title="All 2 branches missed.">            if (dropLocation == null) {</span>
<span class="nc bnc" id="L1825" title="All 2 branches missed.">                if (dropCaret != null) {</span>
<span class="nc" id="L1826">                    dropCaret.deinstall(editor);</span>
<span class="nc" id="L1827">                    editor.repaint(dropCaret);</span>
<span class="nc" id="L1828">                    dropCaret = null;</span>
                }
            } else {
<span class="nc bnc" id="L1831" title="All 2 branches missed.">                if (dropCaret == null) {</span>
<span class="nc" id="L1832">                    dropCaret = new BasicCaret();</span>
<span class="nc" id="L1833">                    dropCaret.install(editor);</span>
<span class="nc" id="L1834">                    dropCaret.setVisible(true);</span>
                }

<span class="nc" id="L1837">                dropCaret.setDot(dropLocation.getIndex(),</span>
<span class="nc" id="L1838">                                 dropLocation.getBias());</span>
            }
<span class="nc" id="L1840">        }</span>

        // --- DocumentListener methods -----------------------

        /**
         * The insert notification.  Gets sent to the root of the view structure
         * that represents the portion of the model being represented by the
         * editor.  The factory is added as an argument to the update so that
         * the views can update themselves in a dynamic (not hardcoded) way.
         *
         * @param e  The change notification from the currently associated
         *  document.
         * @see DocumentListener#insertUpdate
         */
        public final void insertUpdate(DocumentEvent e) {
<span class="nc" id="L1855">            Document doc = e.getDocument();</span>
<span class="nc" id="L1856">            Object o = doc.getProperty(&quot;i18n&quot;);</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">            if (o instanceof Boolean) {</span>
<span class="nc" id="L1858">                Boolean i18nFlag = (Boolean) o;</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">                if (i18nFlag.booleanValue() != i18nView) {</span>
                    // i18n flag changed, rebuild the view
<span class="nc" id="L1861">                    i18nView = i18nFlag.booleanValue();</span>
<span class="nc" id="L1862">                    modelChanged();</span>
<span class="nc" id="L1863">                    return;</span>
                }
            }

            // normal insert update
<span class="nc bnc" id="L1868" title="All 2 branches missed.">            Rectangle alloc = (painted) ? getVisibleEditorRect() : null;</span>
<span class="nc" id="L1869">            rootView.insertUpdate(e, alloc, rootView.getViewFactory());</span>
<span class="nc" id="L1870">        }</span>

        /**
         * The remove notification.  Gets sent to the root of the view structure
         * that represents the portion of the model being represented by the
         * editor.  The factory is added as an argument to the update so that
         * the views can update themselves in a dynamic (not hardcoded) way.
         *
         * @param e  The change notification from the currently associated
         *  document.
         * @see DocumentListener#removeUpdate
         */
        public final void removeUpdate(DocumentEvent e) {
<span class="nc bnc" id="L1883" title="All 2 branches missed.">            Rectangle alloc = (painted) ? getVisibleEditorRect() : null;</span>
<span class="nc" id="L1884">            rootView.removeUpdate(e, alloc, rootView.getViewFactory());</span>
<span class="nc" id="L1885">        }</span>

        /**
         * The change notification.  Gets sent to the root of the view structure
         * that represents the portion of the model being represented by the
         * editor.  The factory is added as an argument to the update so that
         * the views can update themselves in a dynamic (not hardcoded) way.
         *
         * @param e  The change notification from the currently associated
         *  document.
         * @see DocumentListener#changedUpdate(DocumentEvent)
         */
        public final void changedUpdate(DocumentEvent e) {
<span class="nc bnc" id="L1898" title="All 2 branches missed.">            Rectangle alloc = (painted) ? getVisibleEditorRect() : null;</span>
<span class="nc" id="L1899">            rootView.changedUpdate(e, alloc, rootView.getViewFactory());</span>
<span class="nc" id="L1900">        }</span>

        // --- LayoutManager2 methods --------------------------------

        /**
         * Adds the specified component with the specified name to
         * the layout.
         * @param name the component name
         * @param comp the component to be added
         */
        public void addLayoutComponent(String name, Component comp) {
            // not supported
<span class="nc" id="L1912">        }</span>

        /**
         * Removes the specified component from the layout.
         * @param comp the component to be removed
         */
        public void removeLayoutComponent(Component comp) {
<span class="nc bnc" id="L1919" title="All 2 branches missed.">            if (constraints != null) {</span>
                // remove the constraint record
<span class="nc" id="L1921">                constraints.remove(comp);</span>
            }
<span class="nc" id="L1923">        }</span>

        /**
         * Calculates the preferred size dimensions for the specified
         * panel given the components in the specified parent container.
         * @param parent the component to be laid out
         *
         * @see #minimumLayoutSize
         */
        public Dimension preferredLayoutSize(Container parent) {
            // should not be called (JComponent uses UI instead)
<span class="nc" id="L1934">            return null;</span>
        }

        /**
         * Calculates the minimum size dimensions for the specified
         * panel given the components in the specified parent container.
         * @param parent the component to be laid out
         * @see #preferredLayoutSize
         */
        public Dimension minimumLayoutSize(Container parent) {
            // should not be called (JComponent uses UI instead)
<span class="nc" id="L1945">            return null;</span>
        }

        /**
         * Lays out the container in the specified panel.  This is
         * implemented to position all components that were added
         * with a View object as a constraint.  The current allocation
         * of the associated View is used as the location of the
         * component.
         * &lt;p&gt;
         * A read-lock is acquired on the document to prevent the
         * view tree from being modified while the layout process
         * is active.
         *
         * @param parent the component which needs to be laid out
         */
        public void layoutContainer(Container parent) {
<span class="nc bnc" id="L1962" title="All 4 branches missed.">            if ((constraints != null) &amp;&amp; (! constraints.isEmpty())) {</span>
<span class="nc" id="L1963">                Rectangle alloc = getVisibleEditorRect();</span>
<span class="nc bnc" id="L1964" title="All 2 branches missed.">                if (alloc != null) {</span>
<span class="nc" id="L1965">                    Document doc = editor.getDocument();</span>
<span class="nc bnc" id="L1966" title="All 2 branches missed.">                    if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1967">                        ((AbstractDocument)doc).readLock();</span>
                    }
                    try {
<span class="nc" id="L1970">                        rootView.setSize(alloc.width, alloc.height);</span>
<span class="nc" id="L1971">                        Enumeration&lt;Component&gt; components = constraints.keys();</span>
<span class="nc bnc" id="L1972" title="All 2 branches missed.">                        while (components.hasMoreElements()) {</span>
<span class="nc" id="L1973">                            Component comp = components.nextElement();</span>
<span class="nc" id="L1974">                            View v = (View) constraints.get(comp);</span>
<span class="nc" id="L1975">                            Shape ca = calculateViewPosition(alloc, v);</span>
<span class="nc bnc" id="L1976" title="All 2 branches missed.">                            if (ca != null) {</span>
<span class="nc bnc" id="L1977" title="All 2 branches missed.">                                Rectangle compAlloc = (ca instanceof Rectangle) ?</span>
<span class="nc" id="L1978">                                    (Rectangle) ca : ca.getBounds();</span>
<span class="nc" id="L1979">                                comp.setBounds(compAlloc);</span>
                            }
<span class="nc" id="L1981">                        }</span>
                    } finally {
<span class="nc bnc" id="L1983" title="All 4 branches missed.">                        if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1984">                            ((AbstractDocument)doc).readUnlock();</span>
                        }
                    }
                }
            }
<span class="nc" id="L1989">        }</span>

        /**
         * Find the Shape representing the given view.
         */
        Shape calculateViewPosition(Shape alloc, View v) {
<span class="nc" id="L1995">            int pos = v.getStartOffset();</span>
<span class="nc" id="L1996">            View child = null;</span>
<span class="nc bnc" id="L1997" title="All 4 branches missed.">            for (View parent = rootView; (parent != null) &amp;&amp; (parent != v); parent = child) {</span>
<span class="nc" id="L1998">                int index = parent.getViewIndex(pos, Position.Bias.Forward);</span>
<span class="nc" id="L1999">                alloc = parent.getChildAllocation(index, alloc);</span>
<span class="nc" id="L2000">                child = parent.getView(index);</span>
            }
<span class="nc bnc" id="L2002" title="All 2 branches missed.">            return (child != null) ? alloc : null;</span>
        }

        /**
         * Adds the specified component to the layout, using the specified
         * constraint object.  We only store those components that were added
         * with a constraint that is of type View.
         *
         * @param comp the component to be added
         * @param constraint  where/how the component is added to the layout.
         */
        public void addLayoutComponent(Component comp, Object constraint) {
<span class="nc bnc" id="L2014" title="All 2 branches missed.">            if (constraint instanceof View) {</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">                if (constraints == null) {</span>
<span class="nc" id="L2016">                    constraints = new Hashtable&lt;Component, Object&gt;(7);</span>
                }
<span class="nc" id="L2018">                constraints.put(comp, constraint);</span>
            }
<span class="nc" id="L2020">        }</span>

        /**
         * Returns the maximum size of this component.
         * @see java.awt.Component#getMinimumSize()
         * @see java.awt.Component#getPreferredSize()
         * @see LayoutManager
         */
        public Dimension maximumLayoutSize(Container target) {
            // should not be called (JComponent uses UI instead)
<span class="nc" id="L2030">            return null;</span>
        }

        /**
         * Returns the alignment along the x axis.  This specifies how
         * the component would like to be aligned relative to other
         * components.  The value should be a number between 0 and 1
         * where 0 represents alignment along the origin, 1 is aligned
         * the furthest away from the origin, 0.5 is centered, etc.
         */
        public float getLayoutAlignmentX(Container target) {
<span class="nc" id="L2041">            return 0.5f;</span>
        }

        /**
         * Returns the alignment along the y axis.  This specifies how
         * the component would like to be aligned relative to other
         * components.  The value should be a number between 0 and 1
         * where 0 represents alignment along the origin, 1 is aligned
         * the furthest away from the origin, 0.5 is centered, etc.
         */
        public float getLayoutAlignmentY(Container target) {
<span class="nc" id="L2052">            return 0.5f;</span>
        }

        /**
         * Invalidates the layout, indicating that if the layout manager
         * has cached information it should be discarded.
         */
        public void invalidateLayout(Container target) {
<span class="nc" id="L2060">        }</span>

        /**
         * The &quot;layout constraints&quot; for the LayoutManager2 implementation.
         * These are View objects for those components that are represented
         * by a View in the View tree.
         */
        private Hashtable&lt;Component, Object&gt; constraints;

<span class="nc" id="L2069">        private boolean i18nView = false;</span>
    }

    /**
     * Wrapper for text actions to return isEnabled false in case editor is non editable
     */
    class TextActionWrapper extends TextAction {
<span class="nc" id="L2076">        public TextActionWrapper(TextAction action) {</span>
<span class="nc" id="L2077">            super((String)action.getValue(Action.NAME));</span>
<span class="nc" id="L2078">            this.action = action;</span>
<span class="nc" id="L2079">        }</span>
        /**
         * The operation to perform when this action is triggered.
         *
         * @param e the action event
         */
        public void actionPerformed(ActionEvent e) {
<span class="nc" id="L2086">            action.actionPerformed(e);</span>
<span class="nc" id="L2087">        }</span>
        public boolean isEnabled() {
<span class="nc bnc" id="L2089" title="All 4 branches missed.">            return (editor == null || editor.isEditable()) ? action.isEnabled() : false;</span>
        }
<span class="nc" id="L2091">        TextAction action = null;</span>
    }


    /**
     * Registered in the ActionMap.
     */
<span class="nc" id="L2098">    class FocusAction extends AbstractAction {</span>

        public void actionPerformed(ActionEvent e) {
<span class="nc" id="L2101">            editor.requestFocus();</span>
<span class="nc" id="L2102">        }</span>

        public boolean isEnabled() {
<span class="nc" id="L2105">            return editor.isEditable();</span>
        }
    }

    private static DragListener getDragListener() {
<span class="nc" id="L2110">        synchronized(DragListener.class) {</span>
            DragListener listener =
<span class="nc" id="L2112">                (DragListener)AppContext.getAppContext().</span>
<span class="nc" id="L2113">                    get(DragListener.class);</span>

<span class="nc bnc" id="L2115" title="All 2 branches missed.">            if (listener == null) {</span>
<span class="nc" id="L2116">                listener = new DragListener();</span>
<span class="nc" id="L2117">                AppContext.getAppContext().put(DragListener.class, listener);</span>
            }

<span class="nc" id="L2120">            return listener;</span>
<span class="nc" id="L2121">        }</span>
    }

    /**
     * Listens for mouse events for the purposes of detecting drag gestures.
     * BasicTextUI will maintain one of these per AppContext.
     */
<span class="nc" id="L2128">    static class DragListener extends MouseInputAdapter</span>
                              implements BeforeDrag {

        private boolean dragStarted;

        public void dragStarting(MouseEvent me) {
<span class="nc" id="L2134">            dragStarted = true;</span>
<span class="nc" id="L2135">        }</span>

        public void mousePressed(MouseEvent e) {
<span class="nc" id="L2138">            JTextComponent c = (JTextComponent)e.getSource();</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">            if (c.getDragEnabled()) {</span>
<span class="nc" id="L2140">                dragStarted = false;</span>
<span class="nc bnc" id="L2141" title="All 4 branches missed.">                if (isDragPossible(e) &amp;&amp; DragRecognitionSupport.mousePressed(e)) {</span>
<span class="nc" id="L2142">                    e.consume();</span>
                }
            }
<span class="nc" id="L2145">        }</span>

        public void mouseReleased(MouseEvent e) {
<span class="nc" id="L2148">            JTextComponent c = (JTextComponent)e.getSource();</span>
<span class="nc bnc" id="L2149" title="All 2 branches missed.">            if (c.getDragEnabled()) {</span>
<span class="nc bnc" id="L2150" title="All 2 branches missed.">                if (dragStarted) {</span>
<span class="nc" id="L2151">                    e.consume();</span>
                }

<span class="nc" id="L2154">                DragRecognitionSupport.mouseReleased(e);</span>
            }
<span class="nc" id="L2156">        }</span>

        public void mouseDragged(MouseEvent e) {
<span class="nc" id="L2159">            JTextComponent c = (JTextComponent)e.getSource();</span>
<span class="nc bnc" id="L2160" title="All 2 branches missed.">            if (c.getDragEnabled()) {</span>
<span class="nc bnc" id="L2161" title="All 4 branches missed.">                if (dragStarted || DragRecognitionSupport.mouseDragged(e, this)) {</span>
<span class="nc" id="L2162">                    e.consume();</span>
                }
            }
<span class="nc" id="L2165">        }</span>

        /**
         * Determines if the following are true:
         * &lt;ul&gt;
         * &lt;li&gt;the component is enabled
         * &lt;li&gt;the press event is located over a selection
         * &lt;/ul&gt;
         */
        protected boolean isDragPossible(MouseEvent e) {
<span class="nc" id="L2175">            JTextComponent c = (JTextComponent)e.getSource();</span>
<span class="nc bnc" id="L2176" title="All 2 branches missed.">            if (c.isEnabled()) {</span>
<span class="nc" id="L2177">                Caret caret = c.getCaret();</span>
<span class="nc" id="L2178">                int dot = caret.getDot();</span>
<span class="nc" id="L2179">                int mark = caret.getMark();</span>
<span class="nc bnc" id="L2180" title="All 2 branches missed.">                if (dot != mark) {</span>
<span class="nc" id="L2181">                    Point p = new Point(e.getX(), e.getY());</span>
<span class="nc" id="L2182">                    int pos = c.viewToModel(p);</span>

<span class="nc" id="L2184">                    int p0 = Math.min(dot, mark);</span>
<span class="nc" id="L2185">                    int p1 = Math.max(dot, mark);</span>
<span class="nc bnc" id="L2186" title="All 4 branches missed.">                    if ((pos &gt;= p0) &amp;&amp; (pos &lt; p1)) {</span>
<span class="nc" id="L2187">                        return true;</span>
                    }
                }
            }
<span class="nc" id="L2191">            return false;</span>
        }
    }

<span class="nc" id="L2195">    static class TextTransferHandler extends TransferHandler implements UIResource {</span>

        private JTextComponent exportComp;
        private boolean shouldRemove;
        private int p0;
        private int p1;

        /**
         * Whether or not this is a drop using
         * &lt;code&gt;DropMode.INSERT&lt;/code&gt;.
         */
<span class="nc" id="L2206">        private boolean modeBetween = false;</span>

        /**
         * Whether or not this is a drop.
         */
<span class="nc" id="L2211">        private boolean isDrop = false;</span>

        /**
         * The drop action.
         */
<span class="nc" id="L2216">        private int dropAction = MOVE;</span>

        /**
         * The drop bias.
         */
        private Position.Bias dropBias;

        /**
         * Try to find a flavor that can be used to import a Transferable.
         * The set of usable flavors are tried in the following order:
         * &lt;ol&gt;
         *     &lt;li&gt;First, an attempt is made to find a flavor matching the content type
         *         of the EditorKit for the component.
         *     &lt;li&gt;Second, an attempt to find a text/plain flavor is made.
         *     &lt;li&gt;Third, an attempt to find a flavor representing a String reference
         *         in the same VM is made.
         *     &lt;li&gt;Lastly, DataFlavor.stringFlavor is searched for.
         * &lt;/ol&gt;
         */
        protected DataFlavor getImportFlavor(DataFlavor[] flavors, JTextComponent c) {
<span class="nc" id="L2236">            DataFlavor plainFlavor = null;</span>
<span class="nc" id="L2237">            DataFlavor refFlavor = null;</span>
<span class="nc" id="L2238">            DataFlavor stringFlavor = null;</span>

<span class="nc bnc" id="L2240" title="All 2 branches missed.">            if (c instanceof JEditorPane) {</span>
<span class="nc bnc" id="L2241" title="All 2 branches missed.">                for (int i = 0; i &lt; flavors.length; i++) {</span>
<span class="nc" id="L2242">                    String mime = flavors[i].getMimeType();</span>
<span class="nc bnc" id="L2243" title="All 2 branches missed.">                    if (mime.startsWith(((JEditorPane)c).getEditorKit().getContentType())) {</span>
<span class="nc" id="L2244">                        return flavors[i];</span>
<span class="nc bnc" id="L2245" title="All 4 branches missed.">                    } else if (plainFlavor == null &amp;&amp; mime.startsWith(&quot;text/plain&quot;)) {</span>
<span class="nc" id="L2246">                        plainFlavor = flavors[i];</span>
<span class="nc bnc" id="L2247" title="All 4 branches missed.">                    } else if (refFlavor == null &amp;&amp; mime.startsWith(&quot;application/x-java-jvm-local-objectref&quot;)</span>
<span class="nc bnc" id="L2248" title="All 2 branches missed.">                                                 &amp;&amp; flavors[i].getRepresentationClass() == java.lang.String.class) {</span>
<span class="nc" id="L2249">                        refFlavor = flavors[i];</span>
<span class="nc bnc" id="L2250" title="All 4 branches missed.">                    } else if (stringFlavor == null &amp;&amp; flavors[i].equals(DataFlavor.stringFlavor)) {</span>
<span class="nc" id="L2251">                        stringFlavor = flavors[i];</span>
                    }
                }
<span class="nc bnc" id="L2254" title="All 2 branches missed.">                if (plainFlavor != null) {</span>
<span class="nc" id="L2255">                    return plainFlavor;</span>
<span class="nc bnc" id="L2256" title="All 2 branches missed.">                } else if (refFlavor != null) {</span>
<span class="nc" id="L2257">                    return refFlavor;</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">                } else if (stringFlavor != null) {</span>
<span class="nc" id="L2259">                    return stringFlavor;</span>
                }
<span class="nc" id="L2261">                return null;</span>
            }


<span class="nc bnc" id="L2265" title="All 2 branches missed.">            for (int i = 0; i &lt; flavors.length; i++) {</span>
<span class="nc" id="L2266">                String mime = flavors[i].getMimeType();</span>
<span class="nc bnc" id="L2267" title="All 2 branches missed.">                if (mime.startsWith(&quot;text/plain&quot;)) {</span>
<span class="nc" id="L2268">                    return flavors[i];</span>
<span class="nc bnc" id="L2269" title="All 4 branches missed.">                } else if (refFlavor == null &amp;&amp; mime.startsWith(&quot;application/x-java-jvm-local-objectref&quot;)</span>
<span class="nc bnc" id="L2270" title="All 2 branches missed.">                                             &amp;&amp; flavors[i].getRepresentationClass() == java.lang.String.class) {</span>
<span class="nc" id="L2271">                    refFlavor = flavors[i];</span>
<span class="nc bnc" id="L2272" title="All 4 branches missed.">                } else if (stringFlavor == null &amp;&amp; flavors[i].equals(DataFlavor.stringFlavor)) {</span>
<span class="nc" id="L2273">                    stringFlavor = flavors[i];</span>
                }
            }
<span class="nc bnc" id="L2276" title="All 2 branches missed.">            if (refFlavor != null) {</span>
<span class="nc" id="L2277">                return refFlavor;</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">            } else if (stringFlavor != null) {</span>
<span class="nc" id="L2279">                return stringFlavor;</span>
            }
<span class="nc" id="L2281">            return null;</span>
        }

        /**
         * Import the given stream data into the text component.
         */
        protected void handleReaderImport(Reader in, JTextComponent c, boolean useRead)
                                               throws BadLocationException, IOException {
<span class="nc bnc" id="L2289" title="All 2 branches missed.">            if (useRead) {</span>
<span class="nc" id="L2290">                int startPosition = c.getSelectionStart();</span>
<span class="nc" id="L2291">                int endPosition = c.getSelectionEnd();</span>
<span class="nc" id="L2292">                int length = endPosition - startPosition;</span>
<span class="nc" id="L2293">                EditorKit kit = c.getUI().getEditorKit(c);</span>
<span class="nc" id="L2294">                Document doc = c.getDocument();</span>
<span class="nc bnc" id="L2295" title="All 2 branches missed.">                if (length &gt; 0) {</span>
<span class="nc" id="L2296">                    doc.remove(startPosition, length);</span>
                }
<span class="nc" id="L2298">                kit.read(in, doc, startPosition);</span>
<span class="nc" id="L2299">            } else {</span>
<span class="nc" id="L2300">                char[] buff = new char[1024];</span>
                int nch;
<span class="nc" id="L2302">                boolean lastWasCR = false;</span>
                int last;
<span class="nc" id="L2304">                StringBuffer sbuff = null;</span>

                // Read in a block at a time, mapping \r\n to \n, as well as single
                // \r to \n.
<span class="nc bnc" id="L2308" title="All 2 branches missed.">                while ((nch = in.read(buff, 0, buff.length)) != -1) {</span>
<span class="nc bnc" id="L2309" title="All 2 branches missed.">                    if (sbuff == null) {</span>
<span class="nc" id="L2310">                        sbuff = new StringBuffer(nch);</span>
                    }
<span class="nc" id="L2312">                    last = 0;</span>
<span class="nc bnc" id="L2313" title="All 2 branches missed.">                    for(int counter = 0; counter &lt; nch; counter++) {</span>
<span class="nc bnc" id="L2314" title="All 3 branches missed.">                        switch(buff[counter]) {</span>
                        case '\r':
<span class="nc bnc" id="L2316" title="All 2 branches missed.">                            if (lastWasCR) {</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">                                if (counter == 0) {</span>
<span class="nc" id="L2318">                                    sbuff.append('\n');</span>
                                } else {
<span class="nc" id="L2320">                                    buff[counter - 1] = '\n';</span>
                                }
                            } else {
<span class="nc" id="L2323">                                lastWasCR = true;</span>
                            }
<span class="nc" id="L2325">                            break;</span>
                        case '\n':
<span class="nc bnc" id="L2327" title="All 2 branches missed.">                            if (lastWasCR) {</span>
<span class="nc bnc" id="L2328" title="All 2 branches missed.">                                if (counter &gt; (last + 1)) {</span>
<span class="nc" id="L2329">                                    sbuff.append(buff, last, counter - last - 1);</span>
                                }
                                // else nothing to do, can skip \r, next write will
                                // write \n
<span class="nc" id="L2333">                                lastWasCR = false;</span>
<span class="nc" id="L2334">                                last = counter;</span>
                            }
                            break;
                        default:
<span class="nc bnc" id="L2338" title="All 2 branches missed.">                            if (lastWasCR) {</span>
<span class="nc bnc" id="L2339" title="All 2 branches missed.">                                if (counter == 0) {</span>
<span class="nc" id="L2340">                                    sbuff.append('\n');</span>
                                } else {
<span class="nc" id="L2342">                                    buff[counter - 1] = '\n';</span>
                                }
<span class="nc" id="L2344">                                lastWasCR = false;</span>
                            }
                            break;
                        }
                    }
<span class="nc bnc" id="L2349" title="All 2 branches missed.">                    if (last &lt; nch) {</span>
<span class="nc bnc" id="L2350" title="All 2 branches missed.">                        if (lastWasCR) {</span>
<span class="nc bnc" id="L2351" title="All 2 branches missed.">                            if (last &lt; (nch - 1)) {</span>
<span class="nc" id="L2352">                                sbuff.append(buff, last, nch - last - 1);</span>
                            }
                        } else {
<span class="nc" id="L2355">                            sbuff.append(buff, last, nch - last);</span>
                        }
                    }
                }
<span class="nc bnc" id="L2359" title="All 2 branches missed.">                if (lastWasCR) {</span>
<span class="nc" id="L2360">                    sbuff.append('\n');</span>
                }
<span class="nc bnc" id="L2362" title="All 2 branches missed.">                c.replaceSelection(sbuff != null ? sbuff.toString() : &quot;&quot;);</span>
            }
<span class="nc" id="L2364">        }</span>

        // --- TransferHandler methods ------------------------------------

        /**
         * This is the type of transfer actions supported by the source.  Some models are
         * not mutable, so a transfer operation of COPY only should
         * be advertised in that case.
         *
         * @param c  The component holding the data to be transfered.  This
         *  argument is provided to enable sharing of TransferHandlers by
         *  multiple components.
         * @return  This is implemented to return NONE if the component is a JPasswordField
         *  since exporting data via user gestures is not allowed.  If the text component is
         *  editable, COPY_OR_MOVE is returned, otherwise just COPY is allowed.
         */
        public int getSourceActions(JComponent c) {
<span class="nc bnc" id="L2381" title="All 2 branches missed.">            if (c instanceof JPasswordField &amp;&amp;</span>
<span class="nc bnc" id="L2382" title="All 2 branches missed.">                c.getClientProperty(&quot;JPasswordField.cutCopyAllowed&quot;) !=</span>
                Boolean.TRUE) {
<span class="nc" id="L2384">                return NONE;</span>
            }

<span class="nc bnc" id="L2387" title="All 2 branches missed.">            return ((JTextComponent)c).isEditable() ? COPY_OR_MOVE : COPY;</span>
        }

        /**
         * Create a Transferable to use as the source for a data transfer.
         *
         * @param comp  The component holding the data to be transfered.  This
         *  argument is provided to enable sharing of TransferHandlers by
         *  multiple components.
         * @return  The representation of the data to be transfered.
         *
         */
        protected Transferable createTransferable(JComponent comp) {
<span class="nc" id="L2400">            exportComp = (JTextComponent)comp;</span>
<span class="nc" id="L2401">            shouldRemove = true;</span>
<span class="nc" id="L2402">            p0 = exportComp.getSelectionStart();</span>
<span class="nc" id="L2403">            p1 = exportComp.getSelectionEnd();</span>
<span class="nc bnc" id="L2404" title="All 2 branches missed.">            return (p0 != p1) ? (new TextTransferable(exportComp, p0, p1)) : null;</span>
        }

        /**
         * This method is called after data has been exported.  This method should remove
         * the data that was transfered if the action was MOVE.
         *
         * @param source The component that was the source of the data.
         * @param data   The data that was transferred or possibly null
         *               if the action is &lt;code&gt;NONE&lt;/code&gt;.
         * @param action The actual action that was performed.
         */
        protected void exportDone(JComponent source, Transferable data, int action) {
            // only remove the text if shouldRemove has not been set to
            // false by importData and only if the action is a move
<span class="nc bnc" id="L2419" title="All 4 branches missed.">            if (shouldRemove &amp;&amp; action == MOVE) {</span>
<span class="nc" id="L2420">                TextTransferable t = (TextTransferable)data;</span>
<span class="nc" id="L2421">                t.removeText();</span>
            }

<span class="nc" id="L2424">            exportComp = null;</span>
<span class="nc" id="L2425">        }</span>

        public boolean importData(TransferSupport support) {
<span class="nc" id="L2428">            isDrop = support.isDrop();</span>

<span class="nc bnc" id="L2430" title="All 2 branches missed.">            if (isDrop) {</span>
<span class="nc" id="L2431">                modeBetween =</span>
<span class="nc bnc" id="L2432" title="All 2 branches missed.">                    ((JTextComponent)support.getComponent()).getDropMode() == DropMode.INSERT;</span>

<span class="nc" id="L2434">                dropBias = ((JTextComponent.DropLocation)support.getDropLocation()).getBias();</span>

<span class="nc" id="L2436">                dropAction = support.getDropAction();</span>
            }

            try {
<span class="nc" id="L2440">                return super.importData(support);</span>
            } finally {
<span class="nc" id="L2442">                isDrop = false;</span>
<span class="nc" id="L2443">                modeBetween = false;</span>
<span class="nc" id="L2444">                dropBias = null;</span>
<span class="nc" id="L2445">                dropAction = MOVE;</span>
            }
        }

        /**
         * This method causes a transfer to a component from a clipboard or a
         * DND drop operation.  The Transferable represents the data to be
         * imported into the component.
         *
         * @param comp  The component to receive the transfer.  This
         *  argument is provided to enable sharing of TransferHandlers by
         *  multiple components.
         * @param t     The data to import
         * @return  true if the data was inserted into the component, false otherwise.
         */
        public boolean importData(JComponent comp, Transferable t) {
<span class="nc" id="L2461">            JTextComponent c = (JTextComponent)comp;</span>

<span class="nc bnc" id="L2463" title="All 2 branches missed.">            int pos = modeBetween</span>
<span class="nc" id="L2464">                      ? c.getDropLocation().getIndex() : c.getCaretPosition();</span>

            // if we are importing to the same component that we exported from
            // then don't actually do anything if the drop location is inside
            // the drag location and set shouldRemove to false so that exportDone
            // knows not to remove any data
<span class="nc bnc" id="L2470" title="All 8 branches missed.">            if (dropAction == MOVE &amp;&amp; c == exportComp &amp;&amp; pos &gt;= p0 &amp;&amp; pos &lt;= p1) {</span>
<span class="nc" id="L2471">                shouldRemove = false;</span>
<span class="nc" id="L2472">                return true;</span>
            }

<span class="nc" id="L2475">            boolean imported = false;</span>
<span class="nc" id="L2476">            DataFlavor importFlavor = getImportFlavor(t.getTransferDataFlavors(), c);</span>
<span class="nc bnc" id="L2477" title="All 2 branches missed.">            if (importFlavor != null) {</span>
                try {
<span class="nc" id="L2479">                    boolean useRead = false;</span>
<span class="nc bnc" id="L2480" title="All 2 branches missed.">                    if (comp instanceof JEditorPane) {</span>
<span class="nc" id="L2481">                        JEditorPane ep = (JEditorPane)comp;</span>
<span class="nc bnc" id="L2482" title="All 2 branches missed.">                        if (!ep.getContentType().startsWith(&quot;text/plain&quot;) &amp;&amp;</span>
<span class="nc bnc" id="L2483" title="All 2 branches missed.">                                importFlavor.getMimeType().startsWith(ep.getContentType())) {</span>
<span class="nc" id="L2484">                            useRead = true;</span>
                        }
                    }
<span class="nc" id="L2487">                    InputContext ic = c.getInputContext();</span>
<span class="nc bnc" id="L2488" title="All 2 branches missed.">                    if (ic != null) {</span>
<span class="nc" id="L2489">                        ic.endComposition();</span>
                    }
<span class="nc" id="L2491">                    Reader r = importFlavor.getReaderForText(t);</span>

<span class="nc bnc" id="L2493" title="All 2 branches missed.">                    if (modeBetween) {</span>
<span class="nc" id="L2494">                        Caret caret = c.getCaret();</span>
<span class="nc bnc" id="L2495" title="All 2 branches missed.">                        if (caret instanceof DefaultCaret) {</span>
<span class="nc" id="L2496">                            ((DefaultCaret)caret).setDot(pos, dropBias);</span>
                        } else {
<span class="nc" id="L2498">                            c.setCaretPosition(pos);</span>
                        }
                    }

<span class="nc" id="L2502">                    handleReaderImport(r, c, useRead);</span>

<span class="nc bnc" id="L2504" title="All 2 branches missed.">                    if (isDrop) {</span>
<span class="nc" id="L2505">                        c.requestFocus();</span>
<span class="nc" id="L2506">                        Caret caret = c.getCaret();</span>
<span class="nc bnc" id="L2507" title="All 2 branches missed.">                        if (caret instanceof DefaultCaret) {</span>
<span class="nc" id="L2508">                            int newPos = caret.getDot();</span>
<span class="nc" id="L2509">                            Position.Bias newBias = ((DefaultCaret)caret).getDotBias();</span>

<span class="nc" id="L2511">                            ((DefaultCaret)caret).setDot(pos, dropBias);</span>
<span class="nc" id="L2512">                            ((DefaultCaret)caret).moveDot(newPos, newBias);</span>
<span class="nc" id="L2513">                        } else {</span>
<span class="nc" id="L2514">                            c.select(pos, c.getCaretPosition());</span>
                        }
                    }

<span class="nc" id="L2518">                    imported = true;</span>
<span class="nc" id="L2519">                } catch (UnsupportedFlavorException ufe) {</span>
<span class="nc" id="L2520">                } catch (BadLocationException ble) {</span>
<span class="nc" id="L2521">                } catch (IOException ioe) {</span>
<span class="nc" id="L2522">                }</span>
            }
<span class="nc" id="L2524">            return imported;</span>
        }

        /**
         * This method indicates if a component would accept an import of the given
         * set of data flavors prior to actually attempting to import it.
         *
         * @param comp  The component to receive the transfer.  This
         *  argument is provided to enable sharing of TransferHandlers by
         *  multiple components.
         * @param flavors  The data formats available
         * @return  true if the data can be inserted into the component, false otherwise.
         */
        public boolean canImport(JComponent comp, DataFlavor[] flavors) {
<span class="nc" id="L2538">            JTextComponent c = (JTextComponent)comp;</span>
<span class="nc bnc" id="L2539" title="All 4 branches missed.">            if (!(c.isEditable() &amp;&amp; c.isEnabled())) {</span>
<span class="nc" id="L2540">                return false;</span>
            }
<span class="nc bnc" id="L2542" title="All 2 branches missed.">            return (getImportFlavor(flavors, c) != null);</span>
        }

        /**
         * A possible implementation of the Transferable interface
         * for text components.  For a JEditorPane with a rich set
         * of EditorKit implementations, conversions could be made
         * giving a wider set of formats.  This is implemented to
         * offer up only the active content type and text/plain
         * (if that is not the active format) since that can be
         * extracted from other formats.
         */
<span class="nc" id="L2554">        static class TextTransferable extends BasicTransferable {</span>

            TextTransferable(JTextComponent c, int start, int end) {
<span class="nc" id="L2557">                super(null, null);</span>

<span class="nc" id="L2559">                this.c = c;</span>

<span class="nc" id="L2561">                Document doc = c.getDocument();</span>

                try {
<span class="nc" id="L2564">                    p0 = doc.createPosition(start);</span>
<span class="nc" id="L2565">                    p1 = doc.createPosition(end);</span>

<span class="nc" id="L2567">                    plainData = c.getSelectedText();</span>

<span class="nc bnc" id="L2569" title="All 2 branches missed.">                    if (c instanceof JEditorPane) {</span>
<span class="nc" id="L2570">                        JEditorPane ep = (JEditorPane)c;</span>

<span class="nc" id="L2572">                        mimeType = ep.getContentType();</span>

<span class="nc bnc" id="L2574" title="All 2 branches missed.">                        if (mimeType.startsWith(&quot;text/plain&quot;)) {</span>
<span class="nc" id="L2575">                            return;</span>
                        }

<span class="nc" id="L2578">                        StringWriter sw = new StringWriter(p1.getOffset() - p0.getOffset());</span>
<span class="nc" id="L2579">                        ep.getEditorKit().write(sw, doc, p0.getOffset(), p1.getOffset() - p0.getOffset());</span>

<span class="nc bnc" id="L2581" title="All 2 branches missed.">                        if (mimeType.startsWith(&quot;text/html&quot;)) {</span>
<span class="nc" id="L2582">                            htmlData = sw.toString();</span>
                        } else {
<span class="nc" id="L2584">                            richText = sw.toString();</span>
                        }
                    }
<span class="nc" id="L2587">                } catch (BadLocationException ble) {</span>
<span class="nc" id="L2588">                } catch (IOException ioe) {</span>
<span class="nc" id="L2589">                }</span>
<span class="nc" id="L2590">            }</span>

            void removeText() {
<span class="nc bnc" id="L2593" title="All 6 branches missed.">                if ((p0 != null) &amp;&amp; (p1 != null) &amp;&amp; (p0.getOffset() != p1.getOffset())) {</span>
                    try {
<span class="nc" id="L2595">                        Document doc = c.getDocument();</span>
<span class="nc" id="L2596">                        doc.remove(p0.getOffset(), p1.getOffset() - p0.getOffset());</span>
<span class="nc" id="L2597">                    } catch (BadLocationException e) {</span>
<span class="nc" id="L2598">                    }</span>
                }
<span class="nc" id="L2600">            }</span>

            // ---- EditorKit other than plain or HTML text -----------------------

            /**
             * If the EditorKit is not for text/plain or text/html, that format
             * is supported through the &quot;richer flavors&quot; part of BasicTransferable.
             */
            protected DataFlavor[] getRicherFlavors() {
<span class="nc bnc" id="L2609" title="All 2 branches missed.">                if (richText == null) {</span>
<span class="nc" id="L2610">                    return null;</span>
                }

                try {
<span class="nc" id="L2614">                    DataFlavor[] flavors = new DataFlavor[3];</span>
<span class="nc" id="L2615">                    flavors[0] = new DataFlavor(mimeType + &quot;;class=java.lang.String&quot;);</span>
<span class="nc" id="L2616">                    flavors[1] = new DataFlavor(mimeType + &quot;;class=java.io.Reader&quot;);</span>
<span class="nc" id="L2617">                    flavors[2] = new DataFlavor(mimeType + &quot;;class=java.io.InputStream;charset=unicode&quot;);</span>
<span class="nc" id="L2618">                    return flavors;</span>
<span class="nc" id="L2619">                } catch (ClassNotFoundException cle) {</span>
                    // fall through to unsupported (should not happen)
                }

<span class="nc" id="L2623">                return null;</span>
            }

            /**
             * The only richer format supported is the file list flavor
             */
            protected Object getRicherData(DataFlavor flavor) throws UnsupportedFlavorException {
<span class="nc bnc" id="L2630" title="All 2 branches missed.">                if (richText == null) {</span>
<span class="nc" id="L2631">                    return null;</span>
                }

<span class="nc bnc" id="L2634" title="All 2 branches missed.">                if (String.class.equals(flavor.getRepresentationClass())) {</span>
<span class="nc" id="L2635">                    return richText;</span>
<span class="nc bnc" id="L2636" title="All 2 branches missed.">                } else if (Reader.class.equals(flavor.getRepresentationClass())) {</span>
<span class="nc" id="L2637">                    return new StringReader(richText);</span>
<span class="nc bnc" id="L2638" title="All 2 branches missed.">                } else if (InputStream.class.equals(flavor.getRepresentationClass())) {</span>
<span class="nc" id="L2639">                    return new StringBufferInputStream(richText);</span>
                }
<span class="nc" id="L2641">                throw new UnsupportedFlavorException(flavor);</span>
            }

            Position p0;
            Position p1;
            String mimeType;
            String richText;
            JTextComponent c;
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>