<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>HTMLWriter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text.html</a> &gt; <span class="el_source">HTMLWriter.java</span></div><h1>HTMLWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text.html;

import javax.swing.text.*;
import java.io.Writer;
import java.util.Stack;
import java.util.Enumeration;
import java.util.Vector;
import java.io.IOException;
import java.util.StringTokenizer;
import java.util.NoSuchElementException;
import java.net.URL;

/**
 * This is a writer for HTMLDocuments.
 *
 * @author  Sunita Mani
 */


public class HTMLWriter extends AbstractWriter {
    /*
     * Stores all elements for which end tags have to
     * be emitted.
     */
<span class="nc" id="L49">    private Stack&lt;Element&gt; blockElementStack = new Stack&lt;Element&gt;();</span>
<span class="nc" id="L50">    private boolean inContent = false;</span>
<span class="nc" id="L51">    private boolean inPre = false;</span>
    /** When inPre is true, this will indicate the end offset of the pre
     * element. */
    private int preEndOffset;
<span class="nc" id="L55">    private boolean inTextArea = false;</span>
<span class="nc" id="L56">    private boolean newlineOutputed = false;</span>
    private boolean completeDoc;

    /*
     * Stores all embedded tags. Embedded tags are tags that are
     * stored as attributes in other tags. Generally they're
     * character level attributes.  Examples include
     * &amp;lt;b&amp;gt;, &amp;lt;i&amp;gt;, &amp;lt;font&amp;gt;, and &amp;lt;a&amp;gt;.
     */
<span class="nc" id="L65">    private Vector&lt;HTML.Tag&gt; tags = new Vector&lt;HTML.Tag&gt;(10);</span>

    /**
     * Values for the tags.
     */
<span class="nc" id="L70">    private Vector&lt;Object&gt; tagValues = new Vector&lt;Object&gt;(10);</span>

    /**
     * Used when writing out content.
     */
    private Segment segment;

    /*
     * This is used in closeOutUnwantedEmbeddedTags.
     */
<span class="nc" id="L80">    private Vector&lt;HTML.Tag&gt; tagsToRemove = new Vector&lt;HTML.Tag&gt;(10);</span>

    /**
     * Set to true after the head has been output.
     */
    private boolean wroteHead;

    /**
     * Set to true when entities (such as &amp;lt;) should be replaced.
     */
    private boolean replaceEntities;

    /**
     * Temporary buffer.
     */
    private char[] tempChars;


    /**
     * Creates a new HTMLWriter.
     *
     * @param w   a Writer
     * @param doc  an HTMLDocument
     *
     */
    public HTMLWriter(Writer w, HTMLDocument doc) {
<span class="nc" id="L106">        this(w, doc, 0, doc.getLength());</span>
<span class="nc" id="L107">    }</span>

    /**
     * Creates a new HTMLWriter.
     *
     * @param w  a Writer
     * @param doc an HTMLDocument
     * @param pos the document location from which to fetch the content
     * @param len the amount to write out
     */
    public HTMLWriter(Writer w, HTMLDocument doc, int pos, int len) {
<span class="nc" id="L118">        super(w, doc, pos, len);</span>
<span class="nc bnc" id="L119" title="All 4 branches missed.">        completeDoc = (pos == 0 &amp;&amp; len == doc.getLength());</span>
<span class="nc" id="L120">        setLineLength(80);</span>
<span class="nc" id="L121">    }</span>

    /**
     * Iterates over the
     * Element tree and controls the writing out of
     * all the tags and its attributes.
     *
     * @exception IOException on any I/O error
     * @exception BadLocationException if pos represents an invalid
     *            location within the document.
     *
     */
    public void write() throws IOException, BadLocationException {
<span class="nc" id="L134">        ElementIterator it = getElementIterator();</span>
<span class="nc" id="L135">        Element current = null;</span>
        Element next;

<span class="nc" id="L138">        wroteHead = false;</span>
<span class="nc" id="L139">        setCurrentLineLength(0);</span>
<span class="nc" id="L140">        replaceEntities = false;</span>
<span class="nc" id="L141">        setCanWrapLines(false);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (segment == null) {</span>
<span class="nc" id="L143">            segment = new Segment();</span>
        }
<span class="nc" id="L145">        inPre = false;</span>
<span class="nc" id="L146">        boolean forcedBody = false;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        while ((next = it.next()) != null) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (!inRange(next)) {</span>
<span class="nc bnc" id="L149" title="All 4 branches missed.">                if (completeDoc &amp;&amp; next.getAttributes().getAttribute(</span>
                        StyleConstants.NameAttribute) == HTML.Tag.BODY) {
<span class="nc" id="L151">                    forcedBody = true;</span>
                }
                else {
                    continue;
                }
            }
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (current != null) {</span>

                /*
                  if next is child of current increment indent
                */

<span class="nc bnc" id="L163" title="All 2 branches missed.">                if (indentNeedsIncrementing(current, next)) {</span>
<span class="nc" id="L164">                    incrIndent();</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                } else if (current.getParentElement() != next.getParentElement()) {</span>
                    /*
                       next and current are not siblings
                       so emit end tags for items on the stack until the
                       item on top of the stack, is the parent of the
                       next.
                    */
<span class="nc" id="L172">                    Element top = blockElementStack.peek();</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">                    while (top != next.getParentElement()) {</span>
                        /*
                           pop() will return top.
                        */
<span class="nc" id="L177">                        blockElementStack.pop();</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                        if (!synthesizedElement(top)) {</span>
<span class="nc" id="L179">                            AttributeSet attrs = top.getAttributes();</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                            if (!matchNameAttribute(attrs, HTML.Tag.PRE) &amp;&amp;</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                                !isFormElementWithContent(attrs)) {</span>
<span class="nc" id="L182">                                decrIndent();</span>
                            }
<span class="nc" id="L184">                            endTag(top);</span>
                        }
<span class="nc" id="L186">                        top = blockElementStack.peek();</span>
                    }
<span class="nc bnc" id="L188" title="All 2 branches missed.">                } else if (current.getParentElement() == next.getParentElement()) {</span>
                    /*
                       if next and current are siblings the indent level
                       is correct.  But, we need to make sure that if current is
                       on the stack, we pop it off, and put out its end tag.
                    */
<span class="nc" id="L194">                    Element top = blockElementStack.peek();</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">                    if (top == current) {</span>
<span class="nc" id="L196">                        blockElementStack.pop();</span>
<span class="nc" id="L197">                        endTag(top);</span>
                    }
                }
            }
<span class="nc bnc" id="L201" title="All 4 branches missed.">            if (!next.isLeaf() || isFormElementWithContent(next.getAttributes())) {</span>
<span class="nc" id="L202">                blockElementStack.push(next);</span>
<span class="nc" id="L203">                startTag(next);</span>
            } else {
<span class="nc" id="L205">                emptyTag(next);</span>
            }
<span class="nc" id="L207">            current = next;</span>
        }
        /* Emit all remaining end tags */

        /* A null parameter ensures that all embedded tags
           currently in the tags vector have their
           corresponding end tags written out.
        */
<span class="nc" id="L215">        closeOutUnwantedEmbeddedTags(null);</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (forcedBody) {</span>
<span class="nc" id="L218">            blockElementStack.pop();</span>
<span class="nc" id="L219">            endTag(current);</span>
        }
<span class="nc bnc" id="L221" title="All 2 branches missed.">        while (!blockElementStack.empty()) {</span>
<span class="nc" id="L222">            current = blockElementStack.pop();</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            if (!synthesizedElement(current)) {</span>
<span class="nc" id="L224">                AttributeSet attrs = current.getAttributes();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">                if (!matchNameAttribute(attrs, HTML.Tag.PRE) &amp;&amp;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">                              !isFormElementWithContent(attrs)) {</span>
<span class="nc" id="L227">                    decrIndent();</span>
                }
<span class="nc" id="L229">                endTag(current);</span>
<span class="nc" id="L230">            }</span>
        }

<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (completeDoc) {</span>
<span class="nc" id="L234">            writeAdditionalComments();</span>
        }

<span class="nc" id="L237">        segment.array = null;</span>
<span class="nc" id="L238">    }</span>


    /**
     * Writes out the attribute set.  Ignores all
     * attributes with a key of type HTML.Tag,
     * attributes with a key of type StyleConstants,
     * and attributes with a key of type
     * HTML.Attribute.ENDTAG.
     *
     * @param attr   an AttributeSet
     * @exception IOException on any I/O error
     *
     */
    protected void writeAttributes(AttributeSet attr) throws IOException {
        // translate css attributes to html
<span class="nc" id="L254">        convAttr.removeAttributes(convAttr);</span>
<span class="nc" id="L255">        convertToHTML32(attr, convAttr);</span>

<span class="nc" id="L257">        Enumeration names = convAttr.getAttributeNames();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        while (names.hasMoreElements()) {</span>
<span class="nc" id="L259">            Object name = names.nextElement();</span>
<span class="nc bnc" id="L260" title="All 6 branches missed.">            if (name instanceof HTML.Tag ||</span>
                name instanceof StyleConstants ||
                name == HTML.Attribute.ENDTAG) {
<span class="nc" id="L263">                continue;</span>
            }
<span class="nc" id="L265">            write(&quot; &quot; + name + &quot;=\&quot;&quot; + convAttr.getAttribute(name) + &quot;\&quot;&quot;);</span>
<span class="nc" id="L266">        }</span>
<span class="nc" id="L267">    }</span>

    /**
     * Writes out all empty elements (all tags that have no
     * corresponding end tag).
     *
     * @param elem   an Element
     * @exception IOException on any I/O error
     * @exception BadLocationException if pos represents an invalid
     *            location within the document.
     */
    protected void emptyTag(Element elem) throws BadLocationException, IOException {

<span class="nc bnc" id="L280" title="All 4 branches missed.">        if (!inContent &amp;&amp; !inPre) {</span>
<span class="nc" id="L281">            indentSmart();</span>
        }

<span class="nc" id="L284">        AttributeSet attr = elem.getAttributes();</span>
<span class="nc" id="L285">        closeOutUnwantedEmbeddedTags(attr);</span>
<span class="nc" id="L286">        writeEmbeddedTags(attr);</span>

<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (matchNameAttribute(attr, HTML.Tag.CONTENT)) {</span>
<span class="nc" id="L289">            inContent = true;</span>
<span class="nc" id="L290">            text(elem);</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        } else if (matchNameAttribute(attr, HTML.Tag.COMMENT)) {</span>
<span class="nc" id="L292">            comment(elem);</span>
        }  else {
<span class="nc" id="L294">            boolean isBlock = isBlockTag(elem.getAttributes());</span>
<span class="nc bnc" id="L295" title="All 4 branches missed.">            if (inContent &amp;&amp; isBlock ) {</span>
<span class="nc" id="L296">                writeLineSeparator();</span>
<span class="nc" id="L297">                indentSmart();</span>
            }

<span class="nc bnc" id="L300" title="All 2 branches missed.">            Object nameTag = (attr != null) ? attr.getAttribute</span>
<span class="nc" id="L301">                              (StyleConstants.NameAttribute) : null;</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            Object endTag = (attr != null) ? attr.getAttribute</span>
<span class="nc" id="L303">                              (HTML.Attribute.ENDTAG) : null;</span>

<span class="nc" id="L305">            boolean outputEndTag = false;</span>
            // If an instance of an UNKNOWN Tag, or an instance of a
            // tag that is only visible during editing
            //
<span class="nc bnc" id="L309" title="All 6 branches missed.">            if (nameTag != null &amp;&amp; endTag != null &amp;&amp;</span>
                (endTag instanceof String) &amp;&amp;
<span class="nc bnc" id="L311" title="All 2 branches missed.">                endTag.equals(&quot;true&quot;)) {</span>
<span class="nc" id="L312">                outputEndTag = true;</span>
            }

<span class="nc bnc" id="L315" title="All 4 branches missed.">            if (completeDoc &amp;&amp; matchNameAttribute(attr, HTML.Tag.HEAD)) {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                if (outputEndTag) {</span>
                    // Write out any styles.
<span class="nc" id="L318">                    writeStyles(((HTMLDocument)getDocument()).getStyleSheet());</span>
                }
<span class="nc" id="L320">                wroteHead = true;</span>
            }

<span class="nc" id="L323">            write('&lt;');</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">            if (outputEndTag) {</span>
<span class="nc" id="L325">                write('/');</span>
            }
<span class="nc" id="L327">            write(elem.getName());</span>
<span class="nc" id="L328">            writeAttributes(attr);</span>
<span class="nc" id="L329">            write('&gt;');</span>
<span class="nc bnc" id="L330" title="All 4 branches missed.">            if (matchNameAttribute(attr, HTML.Tag.TITLE) &amp;&amp; !outputEndTag) {</span>
<span class="nc" id="L331">                Document doc = elem.getDocument();</span>
<span class="nc" id="L332">                String title = (String)doc.getProperty(Document.TitleProperty);</span>
<span class="nc" id="L333">                write(title);</span>
<span class="nc bnc" id="L334" title="All 4 branches missed.">            } else if (!inContent || isBlock) {</span>
<span class="nc" id="L335">                writeLineSeparator();</span>
<span class="nc bnc" id="L336" title="All 4 branches missed.">                if (isBlock &amp;&amp; inContent) {</span>
<span class="nc" id="L337">                    indentSmart();</span>
                }
            }
        }
<span class="nc" id="L341">    }</span>

    /**
     * Determines if the HTML.Tag associated with the
     * element is a block tag.
     *
     * @param attr  an AttributeSet
     * @return  true if tag is block tag, false otherwise.
     */
    protected boolean isBlockTag(AttributeSet attr) {
<span class="nc" id="L351">        Object o = attr.getAttribute(StyleConstants.NameAttribute);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (o instanceof HTML.Tag) {</span>
<span class="nc" id="L353">            HTML.Tag name = (HTML.Tag) o;</span>
<span class="nc" id="L354">            return name.isBlock();</span>
        }
<span class="nc" id="L356">        return false;</span>
    }


    /**
     * Writes out a start tag for the element.
     * Ignores all synthesized elements.
     *
     * @param elem   an Element
     * @exception IOException on any I/O error
     */
    protected void startTag(Element elem) throws IOException, BadLocationException {

<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (synthesizedElement(elem)) {</span>
<span class="nc" id="L370">            return;</span>
        }

        // Determine the name, as an HTML.Tag.
<span class="nc" id="L374">        AttributeSet attr = elem.getAttributes();</span>
<span class="nc" id="L375">        Object nameAttribute = attr.getAttribute(StyleConstants.NameAttribute);</span>
        HTML.Tag name;
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (nameAttribute instanceof HTML.Tag) {</span>
<span class="nc" id="L378">            name = (HTML.Tag)nameAttribute;</span>
        }
        else {
<span class="nc" id="L381">            name = null;</span>
        }

<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (name == HTML.Tag.PRE) {</span>
<span class="nc" id="L385">            inPre = true;</span>
<span class="nc" id="L386">            preEndOffset = elem.getEndOffset();</span>
        }

        // write out end tags for item on stack
<span class="nc" id="L390">        closeOutUnwantedEmbeddedTags(attr);</span>

<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (inContent) {</span>
<span class="nc" id="L393">            writeLineSeparator();</span>
<span class="nc" id="L394">            inContent = false;</span>
<span class="nc" id="L395">            newlineOutputed = false;</span>
        }

<span class="nc bnc" id="L398" title="All 6 branches missed.">        if (completeDoc &amp;&amp; name == HTML.Tag.BODY &amp;&amp; !wroteHead) {</span>
            // If the head has not been output, output it and the styles.
<span class="nc" id="L400">            wroteHead = true;</span>
<span class="nc" id="L401">            indentSmart();</span>
<span class="nc" id="L402">            write(&quot;&lt;head&gt;&quot;);</span>
<span class="nc" id="L403">            writeLineSeparator();</span>
<span class="nc" id="L404">            incrIndent();</span>
<span class="nc" id="L405">            writeStyles(((HTMLDocument)getDocument()).getStyleSheet());</span>
<span class="nc" id="L406">            decrIndent();</span>
<span class="nc" id="L407">            writeLineSeparator();</span>
<span class="nc" id="L408">            indentSmart();</span>
<span class="nc" id="L409">            write(&quot;&lt;/head&gt;&quot;);</span>
<span class="nc" id="L410">            writeLineSeparator();</span>
        }

<span class="nc" id="L413">        indentSmart();</span>
<span class="nc" id="L414">        write('&lt;');</span>
<span class="nc" id="L415">        write(elem.getName());</span>
<span class="nc" id="L416">        writeAttributes(attr);</span>
<span class="nc" id="L417">        write('&gt;');</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (name != HTML.Tag.PRE) {</span>
<span class="nc" id="L419">            writeLineSeparator();</span>
        }

<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (name == HTML.Tag.TEXTAREA) {</span>
<span class="nc" id="L423">            textAreaContent(elem.getAttributes());</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        } else if (name == HTML.Tag.SELECT) {</span>
<span class="nc" id="L425">            selectContent(elem.getAttributes());</span>
<span class="nc bnc" id="L426" title="All 4 branches missed.">        } else if (completeDoc &amp;&amp; name == HTML.Tag.BODY) {</span>
            // Write out the maps, which is not stored as Elements in
            // the Document.
<span class="nc" id="L429">            writeMaps(((HTMLDocument)getDocument()).getMaps());</span>
        }
<span class="nc bnc" id="L431" title="All 2 branches missed.">        else if (name == HTML.Tag.HEAD) {</span>
<span class="nc" id="L432">            HTMLDocument document = (HTMLDocument)getDocument();</span>
<span class="nc" id="L433">            wroteHead = true;</span>
<span class="nc" id="L434">            incrIndent();</span>
<span class="nc" id="L435">            writeStyles(document.getStyleSheet());</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            if (document.hasBaseTag()) {</span>
<span class="nc" id="L437">                indentSmart();</span>
<span class="nc" id="L438">                write(&quot;&lt;base href=\&quot;&quot; + document.getBase() + &quot;\&quot;&gt;&quot;);</span>
<span class="nc" id="L439">                writeLineSeparator();</span>
            }
<span class="nc" id="L441">            decrIndent();</span>
        }

<span class="nc" id="L444">    }</span>


    /**
     * Writes out text that is contained in a TEXTAREA form
     * element.
     *
     * @param attr  an AttributeSet
     * @exception IOException on any I/O error
     * @exception BadLocationException if pos represents an invalid
     *            location within the document.
     */
    protected void textAreaContent(AttributeSet attr) throws BadLocationException, IOException {
<span class="nc" id="L457">        Document doc = (Document)attr.getAttribute(StyleConstants.ModelAttribute);</span>
<span class="nc bnc" id="L458" title="All 4 branches missed.">        if (doc != null &amp;&amp; doc.getLength() &gt; 0) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            if (segment == null) {</span>
<span class="nc" id="L460">                segment = new Segment();</span>
            }
<span class="nc" id="L462">            doc.getText(0, doc.getLength(), segment);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">            if (segment.count &gt; 0) {</span>
<span class="nc" id="L464">                inTextArea = true;</span>
<span class="nc" id="L465">                incrIndent();</span>
<span class="nc" id="L466">                indentSmart();</span>
<span class="nc" id="L467">                setCanWrapLines(true);</span>
<span class="nc" id="L468">                replaceEntities = true;</span>
<span class="nc" id="L469">                write(segment.array, segment.offset, segment.count);</span>
<span class="nc" id="L470">                replaceEntities = false;</span>
<span class="nc" id="L471">                setCanWrapLines(false);</span>
<span class="nc" id="L472">                writeLineSeparator();</span>
<span class="nc" id="L473">                inTextArea = false;</span>
<span class="nc" id="L474">                decrIndent();</span>
            }
        }
<span class="nc" id="L477">    }</span>


    /**
     * Writes out text.  If a range is specified when the constructor
     * is invoked, then only the appropriate range of text is written
     * out.
     *
     * @param elem   an Element
     * @exception IOException on any I/O error
     * @exception BadLocationException if pos represents an invalid
     *            location within the document.
     */
    protected void text(Element elem) throws BadLocationException, IOException {
<span class="nc" id="L491">        int start = Math.max(getStartOffset(), elem.getStartOffset());</span>
<span class="nc" id="L492">        int end = Math.min(getEndOffset(), elem.getEndOffset());</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (start &lt; end) {</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">            if (segment == null) {</span>
<span class="nc" id="L495">                segment = new Segment();</span>
            }
<span class="nc" id="L497">            getDocument().getText(start, end - start, segment);</span>
<span class="nc" id="L498">            newlineOutputed = false;</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">            if (segment.count &gt; 0) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                if (segment.array[segment.offset + segment.count - 1] == '\n'){</span>
<span class="nc" id="L501">                    newlineOutputed = true;</span>
                }
<span class="nc bnc" id="L503" title="All 4 branches missed.">                if (inPre &amp;&amp; end == preEndOffset) {</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                    if (segment.count &gt; 1) {</span>
<span class="nc" id="L505">                        segment.count--;</span>
                    }
                    else {
<span class="nc" id="L508">                        return;</span>
                    }
                }
<span class="nc" id="L511">                replaceEntities = true;</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">                setCanWrapLines(!inPre);</span>
<span class="nc" id="L513">                write(segment.array, segment.offset, segment.count);</span>
<span class="nc" id="L514">                setCanWrapLines(false);</span>
<span class="nc" id="L515">                replaceEntities = false;</span>
            }
        }
<span class="nc" id="L518">    }</span>

    /**
     * Writes out the content of the SELECT form element.
     *
     * @param attr the AttributeSet associated with the form element
     * @exception IOException on any I/O error
     */
    protected void selectContent(AttributeSet attr) throws IOException {
<span class="nc" id="L527">        Object model = attr.getAttribute(StyleConstants.ModelAttribute);</span>
<span class="nc" id="L528">        incrIndent();</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">        if (model instanceof OptionListModel) {</span>
<span class="nc" id="L530">            OptionListModel&lt;Option&gt; listModel = (OptionListModel&lt;Option&gt;) model;</span>
<span class="nc" id="L531">            int size = listModel.getSize();</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L533">                Option option = listModel.getElementAt(i);</span>
<span class="nc" id="L534">                writeOption(option);</span>
            }
<span class="nc bnc" id="L536" title="All 2 branches missed.">        } else if (model instanceof OptionComboBoxModel) {</span>
<span class="nc" id="L537">            OptionComboBoxModel&lt;Option&gt; comboBoxModel = (OptionComboBoxModel&lt;Option&gt;) model;</span>
<span class="nc" id="L538">            int size = comboBoxModel.getSize();</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L540">                Option option = comboBoxModel.getElementAt(i);</span>
<span class="nc" id="L541">                writeOption(option);</span>
            }
        }
<span class="nc" id="L544">        decrIndent();</span>
<span class="nc" id="L545">    }</span>


    /**
     * Writes out the content of the Option form element.
     * @param option  an Option
     * @exception IOException on any I/O error
     *
     */
    protected void writeOption(Option option) throws IOException {

<span class="nc" id="L556">        indentSmart();</span>
<span class="nc" id="L557">        write('&lt;');</span>
<span class="nc" id="L558">        write(&quot;option&quot;);</span>
        // PENDING: should this be changed to check for null first?
<span class="nc" id="L560">        Object value = option.getAttributes().getAttribute</span>
<span class="nc" id="L561">                              (HTML.Attribute.VALUE);</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L563">            write(&quot; value=&quot;+ value);</span>
        }
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (option.isSelected()) {</span>
<span class="nc" id="L566">            write(&quot; selected&quot;);</span>
        }
<span class="nc" id="L568">        write('&gt;');</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">        if (option.getLabel() != null) {</span>
<span class="nc" id="L570">            write(option.getLabel());</span>
        }
<span class="nc" id="L572">        writeLineSeparator();</span>
<span class="nc" id="L573">    }</span>

    /**
     * Writes out an end tag for the element.
     *
     * @param elem    an Element
     * @exception IOException on any I/O error
     */
    protected void endTag(Element elem) throws IOException {
<span class="nc bnc" id="L582" title="All 2 branches missed.">        if (synthesizedElement(elem)) {</span>
<span class="nc" id="L583">            return;</span>
        }

        // write out end tags for item on stack
<span class="nc" id="L587">        closeOutUnwantedEmbeddedTags(elem.getAttributes());</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">        if (inContent) {</span>
<span class="nc bnc" id="L589" title="All 4 branches missed.">            if (!newlineOutputed &amp;&amp; !inPre) {</span>
<span class="nc" id="L590">                writeLineSeparator();</span>
            }
<span class="nc" id="L592">            newlineOutputed = false;</span>
<span class="nc" id="L593">            inContent = false;</span>
        }
<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (!inPre) {</span>
<span class="nc" id="L596">            indentSmart();</span>
        }
<span class="nc bnc" id="L598" title="All 2 branches missed.">        if (matchNameAttribute(elem.getAttributes(), HTML.Tag.PRE)) {</span>
<span class="nc" id="L599">            inPre = false;</span>
        }
<span class="nc" id="L601">        write('&lt;');</span>
<span class="nc" id="L602">        write('/');</span>
<span class="nc" id="L603">        write(elem.getName());</span>
<span class="nc" id="L604">        write('&gt;');</span>
<span class="nc" id="L605">        writeLineSeparator();</span>
<span class="nc" id="L606">    }</span>



    /**
     * Writes out comments.
     *
     * @param elem    an Element
     * @exception IOException on any I/O error
     * @exception BadLocationException if pos represents an invalid
     *            location within the document.
     */
    protected void comment(Element elem) throws BadLocationException, IOException {
<span class="nc" id="L619">        AttributeSet as = elem.getAttributes();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (matchNameAttribute(as, HTML.Tag.COMMENT)) {</span>
<span class="nc" id="L621">            Object comment = as.getAttribute(HTML.Attribute.COMMENT);</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (comment instanceof String) {</span>
<span class="nc" id="L623">                writeComment((String)comment);</span>
            }
            else {
<span class="nc" id="L626">                writeComment(null);</span>
            }
        }
<span class="nc" id="L629">    }</span>


    /**
     * Writes out comment string.
     *
     * @param string   the comment
     * @exception IOException on any I/O error
     * @exception BadLocationException if pos represents an invalid
     *            location within the document.
     */
    void writeComment(String string) throws IOException {
<span class="nc" id="L641">        write(&quot;&lt;!--&quot;);</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">        if (string != null) {</span>
<span class="nc" id="L643">            write(string);</span>
        }
<span class="nc" id="L645">        write(&quot;--&gt;&quot;);</span>
<span class="nc" id="L646">        writeLineSeparator();</span>
<span class="nc" id="L647">        indentSmart();</span>
<span class="nc" id="L648">    }</span>


    /**
     * Writes out any additional comments (comments outside of the body)
     * stored under the property HTMLDocument.AdditionalComments.
     */
    void writeAdditionalComments() throws IOException {
<span class="nc" id="L656">        Object comments = getDocument().getProperty</span>
<span class="nc" id="L657">                                        (HTMLDocument.AdditionalComments);</span>

<span class="nc bnc" id="L659" title="All 2 branches missed.">        if (comments instanceof Vector) {</span>
<span class="nc" id="L660">            Vector v = (Vector)comments;</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">            for (int counter = 0, maxCounter = v.size(); counter &lt; maxCounter;</span>
<span class="nc" id="L662">                 counter++) {</span>
<span class="nc" id="L663">                writeComment(v.elementAt(counter).toString());</span>
            }
        }
<span class="nc" id="L666">    }</span>


    /**
     * Returns true if the element is a
     * synthesized element.  Currently we are only testing
     * for the p-implied tag.
     */
    protected boolean synthesizedElement(Element elem) {
<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (matchNameAttribute(elem.getAttributes(), HTML.Tag.IMPLIED)) {</span>
<span class="nc" id="L676">            return true;</span>
        }
<span class="nc" id="L678">        return false;</span>
    }


    /**
     * Returns true if the StyleConstants.NameAttribute is
     * equal to the tag that is passed in as a parameter.
     */
    protected boolean matchNameAttribute(AttributeSet attr, HTML.Tag tag) {
<span class="nc" id="L687">        Object o = attr.getAttribute(StyleConstants.NameAttribute);</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (o instanceof HTML.Tag) {</span>
<span class="nc" id="L689">            HTML.Tag name = (HTML.Tag) o;</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if (name == tag) {</span>
<span class="nc" id="L691">                return true;</span>
            }
        }
<span class="nc" id="L694">        return false;</span>
    }

    /**
     * Searches for embedded tags in the AttributeSet
     * and writes them out.  It also stores these tags in a vector
     * so that when appropriate the corresponding end tags can be
     * written out.
     *
     * @exception IOException on any I/O error
     */
    protected void writeEmbeddedTags(AttributeSet attr) throws IOException {

        // translate css attributes to html
<span class="nc" id="L708">        attr = convertToHTML(attr, oConvAttr);</span>

<span class="nc" id="L710">        Enumeration names = attr.getAttributeNames();</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">        while (names.hasMoreElements()) {</span>
<span class="nc" id="L712">            Object name = names.nextElement();</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">            if (name instanceof HTML.Tag) {</span>
<span class="nc" id="L714">                HTML.Tag tag = (HTML.Tag)name;</span>
<span class="nc bnc" id="L715" title="All 4 branches missed.">                if (tag == HTML.Tag.FORM || tags.contains(tag)) {</span>
<span class="nc" id="L716">                    continue;</span>
                }
<span class="nc" id="L718">                write('&lt;');</span>
<span class="nc" id="L719">                write(tag.toString());</span>
<span class="nc" id="L720">                Object o = attr.getAttribute(tag);</span>
<span class="nc bnc" id="L721" title="All 4 branches missed.">                if (o != null &amp;&amp; o instanceof AttributeSet) {</span>
<span class="nc" id="L722">                    writeAttributes((AttributeSet)o);</span>
                }
<span class="nc" id="L724">                write('&gt;');</span>
<span class="nc" id="L725">                tags.addElement(tag);</span>
<span class="nc" id="L726">                tagValues.addElement(o);</span>
            }
<span class="nc" id="L728">        }</span>
<span class="nc" id="L729">    }</span>


    /**
     * Searches the attribute set for a tag, both of which
     * are passed in as a parameter.  Returns true if no match is found
     * and false otherwise.
     */
    private boolean noMatchForTagInAttributes(AttributeSet attr, HTML.Tag t,
                                              Object tagValue) {
<span class="nc bnc" id="L739" title="All 4 branches missed.">        if (attr != null &amp;&amp; attr.isDefined(t)) {</span>
<span class="nc" id="L740">            Object newValue = attr.getAttribute(t);</span>

<span class="nc bnc" id="L742" title="All 6 branches missed.">            if ((tagValue == null) ? (newValue == null) :</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">                (newValue != null &amp;&amp; tagValue.equals(newValue))) {</span>
<span class="nc" id="L744">                return false;</span>
            }
        }
<span class="nc" id="L747">        return true;</span>
    }


    /**
     * Searches the attribute set and for each tag
     * that is stored in the tag vector.  If the tag is not found,
     * then the tag is removed from the vector and a corresponding
     * end tag is written out.
     *
     * @exception IOException on any I/O error
     */
    protected void closeOutUnwantedEmbeddedTags(AttributeSet attr) throws IOException {

<span class="nc" id="L761">        tagsToRemove.removeAllElements();</span>

        // translate css attributes to html
<span class="nc" id="L764">        attr = convertToHTML(attr, null);</span>

        HTML.Tag t;
        Object tValue;
<span class="nc" id="L768">        int firstIndex = -1;</span>
<span class="nc" id="L769">        int size = tags.size();</span>
        // First, find all the tags that need to be removed.
<span class="nc bnc" id="L771" title="All 2 branches missed.">        for (int i = size - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L772">            t = tags.elementAt(i);</span>
<span class="nc" id="L773">            tValue = tagValues.elementAt(i);</span>
<span class="nc bnc" id="L774" title="All 4 branches missed.">            if ((attr == null) || noMatchForTagInAttributes(attr, t, tValue)) {</span>
<span class="nc" id="L775">                firstIndex = i;</span>
<span class="nc" id="L776">                tagsToRemove.addElement(t);</span>
            }
        }
<span class="nc bnc" id="L779" title="All 2 branches missed.">        if (firstIndex != -1) {</span>
            // Then close them out.
<span class="nc bnc" id="L781" title="All 2 branches missed.">            boolean removeAll = ((size - firstIndex) == tagsToRemove.size());</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">            for (int i = size - 1; i &gt;= firstIndex; i--) {</span>
<span class="nc" id="L783">                t = tags.elementAt(i);</span>
<span class="nc bnc" id="L784" title="All 4 branches missed.">                if (removeAll || tagsToRemove.contains(t)) {</span>
<span class="nc" id="L785">                    tags.removeElementAt(i);</span>
<span class="nc" id="L786">                    tagValues.removeElementAt(i);</span>
                }
<span class="nc" id="L788">                write('&lt;');</span>
<span class="nc" id="L789">                write('/');</span>
<span class="nc" id="L790">                write(t.toString());</span>
<span class="nc" id="L791">                write('&gt;');</span>
            }
            // Have to output any tags after firstIndex that still remaing,
            // as we closed them out, but they should remain open.
<span class="nc" id="L795">            size = tags.size();</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">            for (int i = firstIndex; i &lt; size; i++) {</span>
<span class="nc" id="L797">                t = tags.elementAt(i);</span>
<span class="nc" id="L798">                write('&lt;');</span>
<span class="nc" id="L799">                write(t.toString());</span>
<span class="nc" id="L800">                Object o = tagValues.elementAt(i);</span>
<span class="nc bnc" id="L801" title="All 4 branches missed.">                if (o != null &amp;&amp; o instanceof AttributeSet) {</span>
<span class="nc" id="L802">                    writeAttributes((AttributeSet)o);</span>
                }
<span class="nc" id="L804">                write('&gt;');</span>
            }
        }
<span class="nc" id="L807">    }</span>


    /**
     * Determines if the element associated with the attributeset
     * is a TEXTAREA or SELECT.  If true, returns true else
     * false
     */
    private boolean isFormElementWithContent(AttributeSet attr) {
<span class="nc bnc" id="L816" title="All 2 branches missed.">        return matchNameAttribute(attr, HTML.Tag.TEXTAREA) ||</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">                matchNameAttribute(attr, HTML.Tag.SELECT);</span>
    }


    /**
     * Determines whether a the indentation needs to be
     * incremented.  Basically, if next is a child of current, and
     * next is NOT a synthesized element, the indent level will be
     * incremented.  If there is a parent-child relationship and &quot;next&quot;
     * is a synthesized element, then its children must be indented.
     * This state is maintained by the indentNext boolean.
     *
     * @return boolean that's true if indent level
     *         needs incrementing.
     */
<span class="nc" id="L832">    private boolean indentNext = false;</span>
    private boolean indentNeedsIncrementing(Element current, Element next) {
<span class="nc bnc" id="L834" title="All 4 branches missed.">        if ((next.getParentElement() == current) &amp;&amp; !inPre) {</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">            if (indentNext) {</span>
<span class="nc" id="L836">                indentNext = false;</span>
<span class="nc" id="L837">                return true;</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">            } else if (synthesizedElement(next)) {</span>
<span class="nc" id="L839">                indentNext = true;</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">            } else if (!synthesizedElement(current)){</span>
<span class="nc" id="L841">                return true;</span>
            }
        }
<span class="nc" id="L844">        return false;</span>
    }

    /**
     * Outputs the maps as elements. Maps are not stored as elements in
     * the document, and as such this is used to output them.
     */
    void writeMaps(Enumeration maps) throws IOException {
<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (maps != null) {</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">            while(maps.hasMoreElements()) {</span>
<span class="nc" id="L854">                Map map = (Map)maps.nextElement();</span>
<span class="nc" id="L855">                String name = map.getName();</span>

<span class="nc" id="L857">                incrIndent();</span>
<span class="nc" id="L858">                indentSmart();</span>
<span class="nc" id="L859">                write(&quot;&lt;map&quot;);</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">                if (name != null) {</span>
<span class="nc" id="L861">                    write(&quot; name=\&quot;&quot;);</span>
<span class="nc" id="L862">                    write(name);</span>
<span class="nc" id="L863">                    write(&quot;\&quot;&gt;&quot;);</span>
                }
                else {
<span class="nc" id="L866">                    write('&gt;');</span>
                }
<span class="nc" id="L868">                writeLineSeparator();</span>
<span class="nc" id="L869">                incrIndent();</span>

                // Output the areas
<span class="nc" id="L872">                AttributeSet[] areas = map.getAreas();</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">                if (areas != null) {</span>
<span class="nc" id="L874">                    for (int counter = 0, maxCounter = areas.length;</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">                         counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L876">                        indentSmart();</span>
<span class="nc" id="L877">                        write(&quot;&lt;area&quot;);</span>
<span class="nc" id="L878">                        writeAttributes(areas[counter]);</span>
<span class="nc" id="L879">                        write(&quot;&gt;&lt;/area&gt;&quot;);</span>
<span class="nc" id="L880">                        writeLineSeparator();</span>
                    }
                }
<span class="nc" id="L883">                decrIndent();</span>
<span class="nc" id="L884">                indentSmart();</span>
<span class="nc" id="L885">                write(&quot;&lt;/map&gt;&quot;);</span>
<span class="nc" id="L886">                writeLineSeparator();</span>
<span class="nc" id="L887">                decrIndent();</span>
<span class="nc" id="L888">            }</span>
        }
<span class="nc" id="L890">    }</span>

    /**
     * Outputs the styles as a single element. Styles are not stored as
     * elements, but part of the document. For the time being styles are
     * written out as a comment, inside a style tag.
     */
    void writeStyles(StyleSheet sheet) throws IOException {
<span class="nc bnc" id="L898" title="All 2 branches missed.">        if (sheet != null) {</span>
<span class="nc" id="L899">            Enumeration styles = sheet.getStyleNames();</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">            if (styles != null) {</span>
<span class="nc" id="L901">                boolean outputStyle = false;</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">                while (styles.hasMoreElements()) {</span>
<span class="nc" id="L903">                    String name = (String)styles.nextElement();</span>
                    // Don't write out the default style.
<span class="nc bnc" id="L905" title="All 2 branches missed.">                    if (!StyleContext.DEFAULT_STYLE.equals(name) &amp;&amp;</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">                        writeStyle(name, sheet.getStyle(name), outputStyle)) {</span>
<span class="nc" id="L907">                        outputStyle = true;</span>
                    }
<span class="nc" id="L909">                }</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">                if (outputStyle) {</span>
<span class="nc" id="L911">                    writeStyleEndTag();</span>
                }
            }
        }
<span class="nc" id="L915">    }</span>

    /**
     * Outputs the named style. &lt;code&gt;outputStyle&lt;/code&gt; indicates
     * whether or not a style has been output yet. This will return
     * true if a style is written.
     */
    boolean writeStyle(String name, Style style, boolean outputStyle)
                 throws IOException{
<span class="nc" id="L924">        boolean didOutputStyle = false;</span>
<span class="nc" id="L925">        Enumeration attributes = style.getAttributeNames();</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">        if (attributes != null) {</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">            while (attributes.hasMoreElements()) {</span>
<span class="nc" id="L928">                Object attribute = attributes.nextElement();</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">                if (attribute instanceof CSS.Attribute) {</span>
<span class="nc" id="L930">                    String value = style.getAttribute(attribute).toString();</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">                    if (value != null) {</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">                        if (!outputStyle) {</span>
<span class="nc" id="L933">                            writeStyleStartTag();</span>
<span class="nc" id="L934">                            outputStyle = true;</span>
                        }
<span class="nc bnc" id="L936" title="All 2 branches missed.">                        if (!didOutputStyle) {</span>
<span class="nc" id="L937">                            didOutputStyle = true;</span>
<span class="nc" id="L938">                            indentSmart();</span>
<span class="nc" id="L939">                            write(name);</span>
<span class="nc" id="L940">                            write(&quot; {&quot;);</span>
                        }
                        else {
<span class="nc" id="L943">                            write(&quot;;&quot;);</span>
                        }
<span class="nc" id="L945">                        write(' ');</span>
<span class="nc" id="L946">                        write(attribute.toString());</span>
<span class="nc" id="L947">                        write(&quot;: &quot;);</span>
<span class="nc" id="L948">                        write(value);</span>
                    }
                }
<span class="nc" id="L951">            }</span>
        }
<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (didOutputStyle) {</span>
<span class="nc" id="L954">            write(&quot; }&quot;);</span>
<span class="nc" id="L955">            writeLineSeparator();</span>
        }
<span class="nc" id="L957">        return didOutputStyle;</span>
    }

    void writeStyleStartTag() throws IOException {
<span class="nc" id="L961">        indentSmart();</span>
<span class="nc" id="L962">        write(&quot;&lt;style type=\&quot;text/css\&quot;&gt;&quot;);</span>
<span class="nc" id="L963">        incrIndent();</span>
<span class="nc" id="L964">        writeLineSeparator();</span>
<span class="nc" id="L965">        indentSmart();</span>
<span class="nc" id="L966">        write(&quot;&lt;!--&quot;);</span>
<span class="nc" id="L967">        incrIndent();</span>
<span class="nc" id="L968">        writeLineSeparator();</span>
<span class="nc" id="L969">    }</span>

    void writeStyleEndTag() throws IOException {
<span class="nc" id="L972">        decrIndent();</span>
<span class="nc" id="L973">        indentSmart();</span>
<span class="nc" id="L974">        write(&quot;--&gt;&quot;);</span>
<span class="nc" id="L975">        writeLineSeparator();</span>
<span class="nc" id="L976">        decrIndent();</span>
<span class="nc" id="L977">        indentSmart();</span>
<span class="nc" id="L978">        write(&quot;&lt;/style&gt;&quot;);</span>
<span class="nc" id="L979">        writeLineSeparator();</span>
<span class="nc" id="L980">        indentSmart();</span>
<span class="nc" id="L981">    }</span>

    // --- conversion support ---------------------------

    /**
     * Convert the give set of attributes to be html for
     * the purpose of writing them out.  Any keys that
     * have been converted will not appear in the resultant
     * set.  Any keys not converted will appear in the
     * resultant set the same as the received set.&lt;p&gt;
     * This will put the converted values into &lt;code&gt;to&lt;/code&gt;, unless
     * it is null in which case a temporary AttributeSet will be returned.
     */
    AttributeSet convertToHTML(AttributeSet from, MutableAttributeSet to) {
<span class="nc bnc" id="L995" title="All 2 branches missed.">        if (to == null) {</span>
<span class="nc" id="L996">            to = convAttr;</span>
        }
<span class="nc" id="L998">        to.removeAttributes(to);</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">        if (writeCSS) {</span>
<span class="nc" id="L1000">            convertToHTML40(from, to);</span>
        } else {
<span class="nc" id="L1002">            convertToHTML32(from, to);</span>
        }
<span class="nc" id="L1004">        return to;</span>
    }

    /**
     * If true, the writer will emit CSS attributes in preference
     * to HTML tags/attributes (i.e. It will emit an HTML 4.0
     * style).
     */
<span class="nc" id="L1012">    private boolean writeCSS = false;</span>

    /**
     * Buffer for the purpose of attribute conversion
     */
<span class="nc" id="L1017">    private MutableAttributeSet convAttr = new SimpleAttributeSet();</span>

    /**
     * Buffer for the purpose of attribute conversion. This can be
     * used if convAttr is being used.
     */
<span class="nc" id="L1023">    private MutableAttributeSet oConvAttr = new SimpleAttributeSet();</span>

    /**
     * Create an older style of HTML attributes.  This will
     * convert character level attributes that have a StyleConstants
     * mapping over to an HTML tag/attribute.  Other CSS attributes
     * will be placed in an HTML style attribute.
     */
    private static void convertToHTML32(AttributeSet from, MutableAttributeSet to) {
<span class="nc bnc" id="L1032" title="All 2 branches missed.">        if (from == null) {</span>
<span class="nc" id="L1033">            return;</span>
        }
<span class="nc" id="L1035">        Enumeration keys = from.getAttributeNames();</span>
<span class="nc" id="L1036">        String value = &quot;&quot;;</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        while (keys.hasMoreElements()) {</span>
<span class="nc" id="L1038">            Object key = keys.nextElement();</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            if (key instanceof CSS.Attribute) {</span>
<span class="nc bnc" id="L1040" title="All 6 branches missed.">                if ((key == CSS.Attribute.FONT_FAMILY) ||</span>
                    (key == CSS.Attribute.FONT_SIZE) ||
                    (key == CSS.Attribute.COLOR)) {

<span class="nc" id="L1044">                    createFontAttribute((CSS.Attribute)key, from, to);</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                } else if (key == CSS.Attribute.FONT_WEIGHT) {</span>
                    // add a bold tag is weight is bold
<span class="nc" id="L1047">                    CSS.FontWeight weightValue = (CSS.FontWeight)</span>
<span class="nc" id="L1048">                        from.getAttribute(CSS.Attribute.FONT_WEIGHT);</span>
<span class="nc bnc" id="L1049" title="All 4 branches missed.">                    if ((weightValue != null) &amp;&amp; (weightValue.getValue() &gt; 400)) {</span>
<span class="nc" id="L1050">                        addAttribute(to, HTML.Tag.B, SimpleAttributeSet.EMPTY);</span>
                    }
<span class="nc bnc" id="L1052" title="All 2 branches missed.">                } else if (key == CSS.Attribute.FONT_STYLE) {</span>
<span class="nc" id="L1053">                    String s = from.getAttribute(key).toString();</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                    if (s.indexOf(&quot;italic&quot;) &gt;= 0) {</span>
<span class="nc" id="L1055">                        addAttribute(to, HTML.Tag.I, SimpleAttributeSet.EMPTY);</span>
                    }
<span class="nc bnc" id="L1057" title="All 2 branches missed.">                } else if (key == CSS.Attribute.TEXT_DECORATION) {</span>
<span class="nc" id="L1058">                    String decor = from.getAttribute(key).toString();</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">                    if (decor.indexOf(&quot;underline&quot;) &gt;= 0) {</span>
<span class="nc" id="L1060">                        addAttribute(to, HTML.Tag.U, SimpleAttributeSet.EMPTY);</span>
                    }
<span class="nc bnc" id="L1062" title="All 2 branches missed.">                    if (decor.indexOf(&quot;line-through&quot;) &gt;= 0) {</span>
<span class="nc" id="L1063">                        addAttribute(to, HTML.Tag.STRIKE, SimpleAttributeSet.EMPTY);</span>
                    }
<span class="nc bnc" id="L1065" title="All 2 branches missed.">                } else if (key == CSS.Attribute.VERTICAL_ALIGN) {</span>
<span class="nc" id="L1066">                    String vAlign = from.getAttribute(key).toString();</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                    if (vAlign.indexOf(&quot;sup&quot;) &gt;= 0) {</span>
<span class="nc" id="L1068">                        addAttribute(to, HTML.Tag.SUP, SimpleAttributeSet.EMPTY);</span>
                    }
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                    if (vAlign.indexOf(&quot;sub&quot;) &gt;= 0) {</span>
<span class="nc" id="L1071">                        addAttribute(to, HTML.Tag.SUB, SimpleAttributeSet.EMPTY);</span>
                    }
<span class="nc bnc" id="L1073" title="All 2 branches missed.">                } else if (key == CSS.Attribute.TEXT_ALIGN) {</span>
<span class="nc" id="L1074">                    addAttribute(to, HTML.Attribute.ALIGN,</span>
<span class="nc" id="L1075">                                    from.getAttribute(key).toString());</span>
                } else {
                    // default is to store in a HTML style attribute
<span class="nc bnc" id="L1078" title="All 2 branches missed.">                    if (value.length() &gt; 0) {</span>
<span class="nc" id="L1079">                        value = value + &quot;; &quot;;</span>
                    }
<span class="nc" id="L1081">                    value = value + key + &quot;: &quot; + from.getAttribute(key);</span>
                }
            } else {
<span class="nc" id="L1084">                Object attr = from.getAttribute(key);</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">                if (attr instanceof AttributeSet) {</span>
<span class="nc" id="L1086">                    attr = ((AttributeSet)attr).copyAttributes();</span>
                }
<span class="nc" id="L1088">                addAttribute(to, key, attr);</span>
            }
<span class="nc" id="L1090">        }</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">        if (value.length() &gt; 0) {</span>
<span class="nc" id="L1092">            to.addAttribute(HTML.Attribute.STYLE, value);</span>
        }
<span class="nc" id="L1094">    }</span>

    /**
     * Add an attribute only if it doesn't exist so that we don't
     * loose information replacing it with SimpleAttributeSet.EMPTY
     */
    private static void addAttribute(MutableAttributeSet to, Object key, Object value) {
<span class="nc" id="L1101">        Object attr = to.getAttribute(key);</span>
<span class="nc bnc" id="L1102" title="All 4 branches missed.">        if (attr == null || attr == SimpleAttributeSet.EMPTY) {</span>
<span class="nc" id="L1103">            to.addAttribute(key, value);</span>
        } else {
<span class="nc bnc" id="L1105" title="All 4 branches missed.">            if (attr instanceof MutableAttributeSet &amp;&amp;</span>
                value instanceof AttributeSet) {
<span class="nc" id="L1107">                ((MutableAttributeSet)attr).addAttributes((AttributeSet)value);</span>
            }
        }
<span class="nc" id="L1110">    }</span>

    /**
     * Create/update an HTML &amp;lt;font&amp;gt; tag attribute.  The
     * value of the attribute should be a MutableAttributeSet so
     * that the attributes can be updated as they are discovered.
     */
    private static void createFontAttribute(CSS.Attribute a, AttributeSet from,
                                    MutableAttributeSet to) {
<span class="nc" id="L1119">        MutableAttributeSet fontAttr = (MutableAttributeSet)</span>
<span class="nc" id="L1120">            to.getAttribute(HTML.Tag.FONT);</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">        if (fontAttr == null) {</span>
<span class="nc" id="L1122">            fontAttr = new SimpleAttributeSet();</span>
<span class="nc" id="L1123">            to.addAttribute(HTML.Tag.FONT, fontAttr);</span>
        }
        // edit the parameters to the font tag
<span class="nc" id="L1126">        String htmlValue = from.getAttribute(a).toString();</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        if (a == CSS.Attribute.FONT_FAMILY) {</span>
<span class="nc" id="L1128">            fontAttr.addAttribute(HTML.Attribute.FACE, htmlValue);</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">        } else if (a == CSS.Attribute.FONT_SIZE) {</span>
<span class="nc" id="L1130">            fontAttr.addAttribute(HTML.Attribute.SIZE, htmlValue);</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">        } else if (a == CSS.Attribute.COLOR) {</span>
<span class="nc" id="L1132">            fontAttr.addAttribute(HTML.Attribute.COLOR, htmlValue);</span>
        }
<span class="nc" id="L1134">    }</span>

    /**
     * Copies the given AttributeSet to a new set, converting
     * any CSS attributes found to arguments of an HTML style
     * attribute.
     */
    private static void convertToHTML40(AttributeSet from, MutableAttributeSet to) {
<span class="nc" id="L1142">        Enumeration keys = from.getAttributeNames();</span>
<span class="nc" id="L1143">        String value = &quot;&quot;;</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        while (keys.hasMoreElements()) {</span>
<span class="nc" id="L1145">            Object key = keys.nextElement();</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">            if (key instanceof CSS.Attribute) {</span>
<span class="nc" id="L1147">                value = value + &quot; &quot; + key + &quot;=&quot; + from.getAttribute(key) + &quot;;&quot;;</span>
            } else {
<span class="nc" id="L1149">                to.addAttribute(key, from.getAttribute(key));</span>
            }
<span class="nc" id="L1151">        }</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">        if (value.length() &gt; 0) {</span>
<span class="nc" id="L1153">            to.addAttribute(HTML.Attribute.STYLE, value);</span>
        }
<span class="nc" id="L1155">    }</span>

    //
    // Overrides the writing methods to only break a string when
    // canBreakString is true.
    // In a future release it is likely AbstractWriter will get this
    // functionality.
    //

    /**
     * Writes the line separator. This is overriden to make sure we don't
     * replace the newline content in case it is outside normal ascii.
     * @since 1.3
     */
    protected void writeLineSeparator() throws IOException {
<span class="nc" id="L1170">        boolean oldReplace = replaceEntities;</span>
<span class="nc" id="L1171">        replaceEntities = false;</span>
<span class="nc" id="L1172">        super.writeLineSeparator();</span>
<span class="nc" id="L1173">        replaceEntities = oldReplace;</span>
<span class="nc" id="L1174">        indented = false;</span>
<span class="nc" id="L1175">    }</span>

    /**
     * This method is overriden to map any character entities, such as
     * &amp;lt; to &amp;amp;lt;. &lt;code&gt;super.output&lt;/code&gt; will be invoked to
     * write the content.
     * @since 1.3
     */
    protected void output(char[] chars, int start, int length)
                   throws IOException {
<span class="nc bnc" id="L1185" title="All 2 branches missed.">        if (!replaceEntities) {</span>
<span class="nc" id="L1186">            super.output(chars, start, length);</span>
<span class="nc" id="L1187">            return;</span>
        }
<span class="nc" id="L1189">        int last = start;</span>
<span class="nc" id="L1190">        length += start;</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">        for (int counter = start; counter &lt; length; counter++) {</span>
            // This will change, we need better support character level
            // entities.
<span class="nc bnc" id="L1194" title="All 6 branches missed.">            switch(chars[counter]) {</span>
                // Character level entities.
            case '&lt;':
<span class="nc bnc" id="L1197" title="All 2 branches missed.">                if (counter &gt; last) {</span>
<span class="nc" id="L1198">                    super.output(chars, last, counter - last);</span>
                }
<span class="nc" id="L1200">                last = counter + 1;</span>
<span class="nc" id="L1201">                output(&quot;&amp;lt;&quot;);</span>
<span class="nc" id="L1202">                break;</span>
            case '&gt;':
<span class="nc bnc" id="L1204" title="All 2 branches missed.">                if (counter &gt; last) {</span>
<span class="nc" id="L1205">                    super.output(chars, last, counter - last);</span>
                }
<span class="nc" id="L1207">                last = counter + 1;</span>
<span class="nc" id="L1208">                output(&quot;&amp;gt;&quot;);</span>
<span class="nc" id="L1209">                break;</span>
            case '&amp;':
<span class="nc bnc" id="L1211" title="All 2 branches missed.">                if (counter &gt; last) {</span>
<span class="nc" id="L1212">                    super.output(chars, last, counter - last);</span>
                }
<span class="nc" id="L1214">                last = counter + 1;</span>
<span class="nc" id="L1215">                output(&quot;&amp;amp;&quot;);</span>
<span class="nc" id="L1216">                break;</span>
            case '&quot;':
<span class="nc bnc" id="L1218" title="All 2 branches missed.">                if (counter &gt; last) {</span>
<span class="nc" id="L1219">                    super.output(chars, last, counter - last);</span>
                }
<span class="nc" id="L1221">                last = counter + 1;</span>
<span class="nc" id="L1222">                output(&quot;&amp;quot;&quot;);</span>
<span class="nc" id="L1223">                break;</span>
                // Special characters
            case '\n':
            case '\t':
            case '\r':
<span class="nc" id="L1228">                break;</span>
            default:
<span class="nc bnc" id="L1230" title="All 4 branches missed.">                if (chars[counter] &lt; ' ' || chars[counter] &gt; 127) {</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">                    if (counter &gt; last) {</span>
<span class="nc" id="L1232">                        super.output(chars, last, counter - last);</span>
                    }
<span class="nc" id="L1234">                    last = counter + 1;</span>
                    // If the character is outside of ascii, write the
                    // numeric value.
<span class="nc" id="L1237">                    output(&quot;&amp;#&quot;);</span>
<span class="nc" id="L1238">                    output(String.valueOf((int)chars[counter]));</span>
<span class="nc" id="L1239">                    output(&quot;;&quot;);</span>
                }
                break;
            }
        }
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        if (last &lt; length) {</span>
<span class="nc" id="L1245">            super.output(chars, last, length - last);</span>
        }
<span class="nc" id="L1247">    }</span>

    /**
     * This directly invokes super's &lt;code&gt;output&lt;/code&gt; after converting
     * &lt;code&gt;string&lt;/code&gt; to a char[].
     */
    private void output(String string) throws IOException {
<span class="nc" id="L1254">        int length = string.length();</span>
<span class="nc bnc" id="L1255" title="All 4 branches missed.">        if (tempChars == null || tempChars.length &lt; length) {</span>
<span class="nc" id="L1256">            tempChars = new char[length];</span>
        }
<span class="nc" id="L1258">        string.getChars(0, length, tempChars, 0);</span>
<span class="nc" id="L1259">        super.output(tempChars, 0, length);</span>
<span class="nc" id="L1260">    }</span>

<span class="nc" id="L1262">    private boolean indented = false;</span>

    /**
     * Writes indent only once per line.
     */
    private void indentSmart() throws IOException {
<span class="nc bnc" id="L1268" title="All 2 branches missed.">        if (!indented) {</span>
<span class="nc" id="L1269">            indent();</span>
<span class="nc" id="L1270">            indented = true;</span>
        }
<span class="nc" id="L1272">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>