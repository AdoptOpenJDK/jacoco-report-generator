<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>StyleSheet.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text.html</a> &gt; <span class="el_source">StyleSheet.java</span></div><h1>StyleSheet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text.html;

import sun.swing.SwingUtilities2;
import java.util.*;
import java.awt.*;
import java.io.*;
import java.net.*;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.UIManager;
import javax.swing.border.*;
import javax.swing.event.ChangeListener;
import javax.swing.text.*;

/**
 * Support for defining the visual characteristics of
 * HTML views being rendered.  The StyleSheet is used to
 * translate the HTML model into visual characteristics.
 * This enables views to be customized by a look-and-feel,
 * multiple views over the same model can be rendered
 * differently, etc.  This can be thought of as a CSS
 * rule repository.  The key for CSS attributes is an
 * object of type CSS.Attribute.  The type of the value
 * is up to the StyleSheet implementation, but the
 * &lt;code&gt;toString&lt;/code&gt; method is required
 * to return a string representation of CSS value.
 * &lt;p&gt;
 * The primary entry point for HTML View implementations
 * to get their attributes is the
 * {@link #getViewAttributes getViewAttributes}
 * method.  This should be implemented to establish the
 * desired policy used to associate attributes with the view.
 * Each HTMLEditorKit (i.e. and therefore each associated
 * JEditorPane) can have its own StyleSheet, but by default one
 * sheet will be shared by all of the HTMLEditorKit instances.
 * HTMLDocument instance can also have a StyleSheet, which
 * holds the document-specific CSS specifications.
 * &lt;p&gt;
 * In order for Views to store less state and therefore be
 * more lightweight, the StyleSheet can act as a factory for
 * painters that handle some of the rendering tasks.  This allows
 * implementations to determine what they want to cache
 * and have the sharing potentially at the level that a
 * selector is common to multiple views.  Since the StyleSheet
 * may be used by views over multiple documents and typically
 * the HTML attributes don't effect the selector being used,
 * the potential for sharing is significant.
 * &lt;p&gt;
 * The rules are stored as named styles, and other information
 * is stored to translate the context of an element to a
 * rule quickly.  The following code fragment will display
 * the named styles, and therefore the CSS rules contained.
 * &lt;pre&gt;&lt;code&gt;
 * &amp;nbsp;
 * &amp;nbsp; import java.util.*;
 * &amp;nbsp; import javax.swing.text.*;
 * &amp;nbsp; import javax.swing.text.html.*;
 * &amp;nbsp;
 * &amp;nbsp; public class ShowStyles {
 * &amp;nbsp;
 * &amp;nbsp;     public static void main(String[] args) {
 * &amp;nbsp;       HTMLEditorKit kit = new HTMLEditorKit();
 * &amp;nbsp;       HTMLDocument doc = (HTMLDocument) kit.createDefaultDocument();
 * &amp;nbsp;       StyleSheet styles = doc.getStyleSheet();
 * &amp;nbsp;
 * &amp;nbsp;       Enumeration rules = styles.getStyleNames();
 * &amp;nbsp;       while (rules.hasMoreElements()) {
 * &amp;nbsp;           String name = (String) rules.nextElement();
 * &amp;nbsp;           Style rule = styles.getStyle(name);
 * &amp;nbsp;           System.out.println(rule.toString());
 * &amp;nbsp;       }
 * &amp;nbsp;       System.exit(0);
 * &amp;nbsp;     }
 * &amp;nbsp; }
 * &amp;nbsp;
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * The semantics for when a CSS style should overide visual attributes
 * defined by an element are not well defined. For example, the html
 * &lt;code&gt;&amp;lt;body bgcolor=red&amp;gt;&lt;/code&gt; makes the body have a red
 * background. But if the html file also contains the CSS rule
 * &lt;code&gt;body { background: blue }&lt;/code&gt; it becomes less clear as to
 * what color the background of the body should be. The current
 * implementation gives visual attributes defined in the element the
 * highest precedence, that is they are always checked before any styles.
 * Therefore, in the previous example the background would have a
 * red color as the body element defines the background color to be red.
 * &lt;p&gt;
 * As already mentioned this supports CSS. We don't support the full CSS
 * spec. Refer to the javadoc of the CSS class to see what properties
 * we support. The two major CSS parsing related
 * concepts we do not currently
 * support are pseudo selectors, such as &lt;code&gt;A:link { color: red }&lt;/code&gt;,
 * and the &lt;code&gt;important&lt;/code&gt; modifier.
 * &lt;p&gt;
 * &lt;font color=&quot;red&quot;&gt;Note: This implementation is currently
 * incomplete.  It can be replaced with alternative implementations
 * that are complete.  Future versions of this class will provide
 * better CSS support.&lt;/font&gt;
 *
 * @author  Timothy Prinzing
 * @author  Sunita Mani
 * @author  Sara Swanson
 * @author  Jill Nakata
 */
public class StyleSheet extends StyleContext {
    // As the javadoc states, this class maintains a mapping between
    // a CSS selector (such as p.bar) and a Style.
    // This consists of a number of parts:
    // . Each selector is broken down into its constituent simple selectors,
    //   and stored in an inverted graph, for example:
    //     p { color: red } ol p { font-size: 10pt } ul p { font-size: 12pt }
    //   results in the graph:
    //          root
    //           |
    //           p
    //          / \
    //         ol ul
    //   each node (an instance of SelectorMapping) has an associated
    //   specificity and potentially a Style.
    // . Every rule that is asked for (either by way of getRule(String) or
    //   getRule(HTML.Tag, Element)) results in a unique instance of
    //   ResolvedStyle. ResolvedStyles contain the AttributeSets from the
    //   SelectorMapping.
    // . When a new rule is created it is inserted into the graph, and
    //   the AttributeSets of each ResolvedStyles are updated appropriately.
    // . This class creates special AttributeSets, LargeConversionSet and
    //   SmallConversionSet, that maintain a mapping between StyleConstants
    //   and CSS so that developers that wish to use the StyleConstants
    //   methods can do so.
    // . When one of the AttributeSets is mutated by way of a
    //   StyleConstants key, all the associated CSS keys are removed. This is
    //   done so that the two representations don't get out of sync. For
    //   example, if the developer adds StyleConsants.BOLD, FALSE to an
    //   AttributeSet that contains HTML.Tag.B, the HTML.Tag.B entry will
    //   be removed.

    /**
     * Construct a StyleSheet
     */
    public StyleSheet() {
<span class="nc" id="L166">        super();</span>
<span class="nc" id="L167">        selectorMapping = new SelectorMapping(0);</span>
<span class="nc" id="L168">        resolvedStyles = new Hashtable&lt;String, ResolvedStyle&gt;();</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (css == null) {</span>
<span class="nc" id="L170">            css = new CSS();</span>
        }
<span class="nc" id="L172">    }</span>

    /**
     * Fetches the style to use to render the given type
     * of HTML tag.  The element given is representing
     * the tag and can be used to determine the nesting
     * for situations where the attributes will differ
     * if nesting inside of elements.
     *
     * @param t the type to translate to visual attributes
     * @param e the element representing the tag; the element
     *  can be used to determine the nesting for situations where
     *  the attributes will differ if nested inside of other
     *  elements
     * @return the set of CSS attributes to use to render
     *  the tag
     */
    public Style getRule(HTML.Tag t, Element e) {
<span class="nc" id="L190">        SearchBuffer sb = SearchBuffer.obtainSearchBuffer();</span>

        try {
            // Build an array of all the parent elements.
<span class="nc" id="L194">            Vector&lt;Element&gt; searchContext = sb.getVector();</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">            for (Element p = e; p != null; p = p.getParentElement()) {</span>
<span class="nc" id="L197">                searchContext.addElement(p);</span>
            }

            // Build a fully qualified selector.
<span class="nc" id="L201">            int              n = searchContext.size();</span>
<span class="nc" id="L202">            StringBuffer     cacheLookup = sb.getStringBuffer();</span>
            AttributeSet     attr;
            String           eName;
            Object           name;

            // &gt;= 1 as the HTML.Tag for the 0th element is passed in.
<span class="nc bnc" id="L208" title="All 2 branches missed.">            for (int counter = n - 1; counter &gt;= 1; counter--) {</span>
<span class="nc" id="L209">                e = searchContext.elementAt(counter);</span>
<span class="nc" id="L210">                attr = e.getAttributes();</span>
<span class="nc" id="L211">                name = attr.getAttribute(StyleConstants.NameAttribute);</span>
<span class="nc" id="L212">                eName = name.toString();</span>
<span class="nc" id="L213">                cacheLookup.append(eName);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                if (attr != null) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                    if (attr.isDefined(HTML.Attribute.ID)) {</span>
<span class="nc" id="L216">                        cacheLookup.append('#');</span>
<span class="nc" id="L217">                        cacheLookup.append(attr.getAttribute</span>
<span class="nc" id="L218">                                           (HTML.Attribute.ID));</span>
                    }
<span class="nc bnc" id="L220" title="All 2 branches missed.">                    else if (attr.isDefined(HTML.Attribute.CLASS)) {</span>
<span class="nc" id="L221">                        cacheLookup.append('.');</span>
<span class="nc" id="L222">                        cacheLookup.append(attr.getAttribute</span>
<span class="nc" id="L223">                                           (HTML.Attribute.CLASS));</span>
                    }
                }
<span class="nc" id="L226">                cacheLookup.append(' ');</span>
            }
<span class="nc" id="L228">            cacheLookup.append(t.toString());</span>
<span class="nc" id="L229">            e = searchContext.elementAt(0);</span>
<span class="nc" id="L230">            attr = e.getAttributes();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if (e.isLeaf()) {</span>
                // For leafs, we use the second tier attributes.
<span class="nc" id="L233">                Object testAttr = attr.getAttribute(t);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                if (testAttr instanceof AttributeSet) {</span>
<span class="nc" id="L235">                    attr = (AttributeSet)testAttr;</span>
                }
                else {
<span class="nc" id="L238">                    attr = null;</span>
                }
            }
<span class="nc bnc" id="L241" title="All 2 branches missed.">            if (attr != null) {</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                if (attr.isDefined(HTML.Attribute.ID)) {</span>
<span class="nc" id="L243">                    cacheLookup.append('#');</span>
<span class="nc" id="L244">                    cacheLookup.append(attr.getAttribute(HTML.Attribute.ID));</span>
                }
<span class="nc bnc" id="L246" title="All 2 branches missed.">                else if (attr.isDefined(HTML.Attribute.CLASS)) {</span>
<span class="nc" id="L247">                    cacheLookup.append('.');</span>
<span class="nc" id="L248">                    cacheLookup.append(attr.getAttribute</span>
<span class="nc" id="L249">                                       (HTML.Attribute.CLASS));</span>
                }
            }

<span class="nc" id="L253">            Style style = getResolvedStyle(cacheLookup.toString(),</span>
                                           searchContext, t);
<span class="nc" id="L255">            return style;</span>
        }
        finally {
<span class="nc" id="L258">            SearchBuffer.releaseSearchBuffer(sb);</span>
        }
    }

    /**
     * Fetches the rule that best matches the selector given
     * in string form. Where &lt;code&gt;selector&lt;/code&gt; is a space separated
     * String of the element names. For example, &lt;code&gt;selector&lt;/code&gt;
     * might be 'html body tr td''&lt;p&gt;
     * The attributes of the returned Style will change
     * as rules are added and removed. That is if you to ask for a rule
     * with a selector &quot;table p&quot; and a new rule was added with a selector
     * of &quot;p&quot; the returned Style would include the new attributes from
     * the rule &quot;p&quot;.
     */
    public Style getRule(String selector) {
<span class="nc" id="L274">        selector = cleanSelectorString(selector);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (selector != null) {</span>
<span class="nc" id="L276">            Style style = getResolvedStyle(selector);</span>
<span class="nc" id="L277">            return style;</span>
        }
<span class="nc" id="L279">        return null;</span>
    }

    /**
     * Adds a set of rules to the sheet.  The rules are expected to
     * be in valid CSS format.  Typically this would be called as
     * a result of parsing a &amp;lt;style&amp;gt; tag.
     */
    public void addRule(String rule) {
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (rule != null) {</span>
            //tweaks to control display properties
            //see BasicEditorPaneUI
            final String baseUnitsDisable = &quot;BASE_SIZE_DISABLE&quot;;
            final String baseUnits = &quot;BASE_SIZE &quot;;
            final String w3cLengthUnitsEnable = &quot;W3C_LENGTH_UNITS_ENABLE&quot;;
            final String w3cLengthUnitsDisable = &quot;W3C_LENGTH_UNITS_DISABLE&quot;;
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (rule == baseUnitsDisable) {</span>
<span class="nc" id="L296">                sizeMap = sizeMapDefault;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">            } else if (rule.startsWith(baseUnits)) {</span>
<span class="nc" id="L298">                rebaseSizeMap(Integer.</span>
<span class="nc" id="L299">                              parseInt(rule.substring(baseUnits.length())));</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">            } else if (rule == w3cLengthUnitsEnable) {</span>
<span class="nc" id="L301">                w3cLengthUnits = true;</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            } else if (rule == w3cLengthUnitsDisable) {</span>
<span class="nc" id="L303">                w3cLengthUnits = false;</span>
            } else {
<span class="nc" id="L305">                CssParser parser = new CssParser();</span>
                try {
<span class="nc" id="L307">                    parser.parse(getBase(), new StringReader(rule), false, false);</span>
<span class="nc" id="L308">                } catch (IOException ioe) { }</span>
            }
        }
<span class="nc" id="L311">    }</span>

    /**
     * Translates a CSS declaration to an AttributeSet that represents
     * the CSS declaration.  Typically this would be called as a
     * result of encountering an HTML style attribute.
     */
    public AttributeSet getDeclaration(String decl) {
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (decl == null) {</span>
<span class="nc" id="L320">            return SimpleAttributeSet.EMPTY;</span>
        }
<span class="nc" id="L322">        CssParser parser = new CssParser();</span>
<span class="nc" id="L323">        return parser.parseDeclaration(decl);</span>
    }

    /**
     * Loads a set of rules that have been specified in terms of
     * CSS1 grammar.  If there are collisions with existing rules,
     * the newly specified rule will win.
     *
     * @param in the stream to read the CSS grammar from
     * @param ref the reference URL.  This value represents the
     *  location of the stream and may be null.  All relative
     *  URLs specified in the stream will be based upon this
     *  parameter.
     */
    public void loadRules(Reader in, URL ref) throws IOException {
<span class="nc" id="L338">        CssParser parser = new CssParser();</span>
<span class="nc" id="L339">        parser.parse(ref, in, false, false);</span>
<span class="nc" id="L340">    }</span>

    /**
     * Fetches a set of attributes to use in the view for
     * displaying.  This is basically a set of attributes that
     * can be used for View.getAttributes.
     */
    public AttributeSet getViewAttributes(View v) {
<span class="nc" id="L348">        return new ViewAttributeSet(v);</span>
    }

    /**
     * Removes a named style previously added to the document.
     *
     * @param nm  the name of the style to remove
     */
    public void removeStyle(String nm) {
<span class="nc" id="L357">        Style       aStyle = getStyle(nm);</span>

<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (aStyle != null) {</span>
<span class="nc" id="L360">            String selector = cleanSelectorString(nm);</span>
<span class="nc" id="L361">            String[] selectors = getSimpleSelectors(selector);</span>
<span class="nc" id="L362">            synchronized(this) {</span>
<span class="nc" id="L363">                SelectorMapping mapping = getRootSelectorMapping();</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                for (int i = selectors.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L365">                    mapping = mapping.getChildSelectorMapping(selectors[i],</span>
                                                              true);
                }
<span class="nc" id="L368">                Style rule = mapping.getStyle();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                if (rule != null) {</span>
<span class="nc" id="L370">                    mapping.setStyle(null);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                    if (resolvedStyles.size() &gt; 0) {</span>
<span class="nc" id="L372">                        Enumeration&lt;ResolvedStyle&gt; values = resolvedStyles.elements();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">                        while (values.hasMoreElements()) {</span>
<span class="nc" id="L374">                            ResolvedStyle style = values.nextElement();</span>
<span class="nc" id="L375">                            style.removeStyle(rule);</span>
<span class="nc" id="L376">                        }</span>
                    }
                }
<span class="nc" id="L379">            }</span>
        }
<span class="nc" id="L381">        super.removeStyle(nm);</span>
<span class="nc" id="L382">    }</span>

    /**
     * Adds the rules from the StyleSheet &lt;code&gt;ss&lt;/code&gt; to those of
     * the receiver. &lt;code&gt;ss's&lt;/code&gt; rules will override the rules of
     * any previously added style sheets. An added StyleSheet will never
     * override the rules of the receiving style sheet.
     *
     * @since 1.3
     */
    public void addStyleSheet(StyleSheet ss) {
<span class="nc" id="L393">        synchronized(this) {</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (linkedStyleSheets == null) {</span>
<span class="nc" id="L395">                linkedStyleSheets = new Vector&lt;StyleSheet&gt;();</span>
            }
<span class="nc bnc" id="L397" title="All 2 branches missed.">            if (!linkedStyleSheets.contains(ss)) {</span>
<span class="nc" id="L398">                int index = 0;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                if (ss instanceof javax.swing.plaf.UIResource</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">                    &amp;&amp; linkedStyleSheets.size() &gt; 1) {</span>
<span class="nc" id="L401">                    index = linkedStyleSheets.size() - 1;</span>
                }
<span class="nc" id="L403">                linkedStyleSheets.insertElementAt(ss, index);</span>
<span class="nc" id="L404">                linkStyleSheetAt(ss, index);</span>
            }
<span class="nc" id="L406">        }</span>
<span class="nc" id="L407">    }</span>

    /**
     * Removes the StyleSheet &lt;code&gt;ss&lt;/code&gt; from those of the receiver.
     *
     * @since 1.3
     */
    public void removeStyleSheet(StyleSheet ss) {
<span class="nc" id="L415">        synchronized(this) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">            if (linkedStyleSheets != null) {</span>
<span class="nc" id="L417">                int index = linkedStyleSheets.indexOf(ss);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                if (index != -1) {</span>
<span class="nc" id="L419">                    linkedStyleSheets.removeElementAt(index);</span>
<span class="nc" id="L420">                    unlinkStyleSheet(ss, index);</span>
<span class="nc bnc" id="L421" title="All 4 branches missed.">                    if (index == 0 &amp;&amp; linkedStyleSheets.size() == 0) {</span>
<span class="nc" id="L422">                        linkedStyleSheets = null;</span>
                    }
                }
            }
<span class="nc" id="L426">        }</span>
<span class="nc" id="L427">    }</span>

    //
    // The following is used to import style sheets.
    //

    /**
     * Returns an array of the linked StyleSheets. Will return null
     * if there are no linked StyleSheets.
     *
     * @since 1.3
     */
    public StyleSheet[] getStyleSheets() {
        StyleSheet[] retValue;

<span class="nc" id="L442">        synchronized(this) {</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">            if (linkedStyleSheets != null) {</span>
<span class="nc" id="L444">                retValue = new StyleSheet[linkedStyleSheets.size()];</span>
<span class="nc" id="L445">                linkedStyleSheets.copyInto(retValue);</span>
            }
            else {
<span class="nc" id="L448">                retValue = null;</span>
            }
<span class="nc" id="L450">        }</span>
<span class="nc" id="L451">        return retValue;</span>
    }

    /**
     * Imports a style sheet from &lt;code&gt;url&lt;/code&gt;. The resulting rules
     * are directly added to the receiver. If you do not want the rules
     * to become part of the receiver, create a new StyleSheet and use
     * addStyleSheet to link it in.
     *
     * @since 1.3
     */
    public void importStyleSheet(URL url) {
        try {
            InputStream is;

<span class="nc" id="L466">            is = url.openStream();</span>
<span class="nc" id="L467">            Reader r = new BufferedReader(new InputStreamReader(is));</span>
<span class="nc" id="L468">            CssParser parser = new CssParser();</span>
<span class="nc" id="L469">            parser.parse(url, r, false, true);</span>
<span class="nc" id="L470">            r.close();</span>
<span class="nc" id="L471">            is.close();</span>
<span class="nc" id="L472">        } catch (Throwable e) {</span>
            // on error we simply have no styles... the html
            // will look mighty wrong but still function.
<span class="nc" id="L475">        }</span>
<span class="nc" id="L476">    }</span>

    /**
     * Sets the base. All import statements that are relative, will be
     * relative to &lt;code&gt;base&lt;/code&gt;.
     *
     * @since 1.3
     */
    public void setBase(URL base) {
<span class="nc" id="L485">        this.base = base;</span>
<span class="nc" id="L486">    }</span>

    /**
     * Returns the base.
     *
     * @since 1.3
     */
    public URL getBase() {
<span class="nc" id="L494">        return base;</span>
    }

    /**
     * Adds a CSS attribute to the given set.
     *
     * @since 1.3
     */
    public void addCSSAttribute(MutableAttributeSet attr, CSS.Attribute key,
                                String value) {
<span class="nc" id="L504">        css.addInternalCSSValue(attr, key, value);</span>
<span class="nc" id="L505">    }</span>

    /**
     * Adds a CSS attribute to the given set.
     *
     * @since 1.3
     */
    public boolean addCSSAttributeFromHTML(MutableAttributeSet attr,
                                           CSS.Attribute key, String value) {
<span class="nc" id="L514">        Object iValue = css.getCssValue(key, value);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (iValue != null) {</span>
<span class="nc" id="L516">            attr.addAttribute(key, iValue);</span>
<span class="nc" id="L517">            return true;</span>
        }
<span class="nc" id="L519">        return false;</span>
    }

    // ---- Conversion functionality ---------------------------------

    /**
     * Converts a set of HTML attributes to an equivalent
     * set of CSS attributes.
     *
     * @param htmlAttrSet AttributeSet containing the HTML attributes.
     */
    public AttributeSet translateHTMLToCSS(AttributeSet htmlAttrSet) {
<span class="nc" id="L531">        AttributeSet cssAttrSet = css.translateHTMLToCSS(htmlAttrSet);</span>

<span class="nc" id="L533">        MutableAttributeSet cssStyleSet = addStyle(null, null);</span>
<span class="nc" id="L534">        cssStyleSet.addAttributes(cssAttrSet);</span>

<span class="nc" id="L536">        return cssStyleSet;</span>
    }

    /**
     * Adds an attribute to the given set, and returns
     * the new representative set.  This is reimplemented to
     * convert StyleConstant attributes to CSS prior to forwarding
     * to the superclass behavior.  The StyleConstants attribute
     * has no corresponding CSS entry, the StyleConstants attribute
     * is stored (but will likely be unused).
     *
     * @param old the old attribute set
     * @param key the non-null attribute key
     * @param value the attribute value
     * @return the updated attribute set
     * @see MutableAttributeSet#addAttribute
     */
    public AttributeSet addAttribute(AttributeSet old, Object key,
                                     Object value) {
<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (css == null) {</span>
            // supers constructor will call this before returning,
            // and we need to make sure CSS is non null.
<span class="nc" id="L558">            css = new CSS();</span>
        }
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (key instanceof StyleConstants) {</span>
<span class="nc" id="L561">            HTML.Tag tag = HTML.getTagForStyleConstantsKey(</span>
                                (StyleConstants)key);

<span class="nc bnc" id="L564" title="All 4 branches missed.">            if (tag != null &amp;&amp; old.isDefined(tag)) {</span>
<span class="nc" id="L565">                old = removeAttribute(old, tag);</span>
            }

<span class="nc" id="L568">            Object cssValue = css.styleConstantsValueToCSSValue</span>
<span class="nc" id="L569">                              ((StyleConstants)key, value);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">            if (cssValue != null) {</span>
<span class="nc" id="L571">                Object cssKey = css.styleConstantsKeyToCSSKey</span>
<span class="nc" id="L572">                                    ((StyleConstants)key);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">                if (cssKey != null) {</span>
<span class="nc" id="L574">                    return super.addAttribute(old, cssKey, cssValue);</span>
                }
            }
        }
<span class="nc" id="L578">        return super.addAttribute(old, key, value);</span>
    }

    /**
     * Adds a set of attributes to the element.  If any of these attributes
     * are StyleConstants attributes, they will be converted to CSS prior
     * to forwarding to the superclass behavior.
     *
     * @param old the old attribute set
     * @param attr the attributes to add
     * @return the updated attribute set
     * @see MutableAttributeSet#addAttribute
     */
    public AttributeSet addAttributes(AttributeSet old, AttributeSet attr) {
<span class="nc bnc" id="L592" title="All 2 branches missed.">        if (!(attr instanceof HTMLDocument.TaggedAttributeSet)) {</span>
<span class="nc" id="L593">            old = removeHTMLTags(old, attr);</span>
        }
<span class="nc" id="L595">        return super.addAttributes(old, convertAttributeSet(attr));</span>
    }

    /**
     * Removes an attribute from the set.  If the attribute is a StyleConstants
     * attribute, the request will be converted to a CSS attribute prior to
     * forwarding to the superclass behavior.
     *
     * @param old the old set of attributes
     * @param key the non-null attribute name
     * @return the updated attribute set
     * @see MutableAttributeSet#removeAttribute
     */
    public AttributeSet removeAttribute(AttributeSet old, Object key) {
<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (key instanceof StyleConstants) {</span>
<span class="nc" id="L610">            HTML.Tag tag = HTML.getTagForStyleConstantsKey(</span>
                                   (StyleConstants)key);
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (tag != null) {</span>
<span class="nc" id="L613">                old = super.removeAttribute(old, tag);</span>
            }

<span class="nc" id="L616">            Object cssKey = css.styleConstantsKeyToCSSKey((StyleConstants)key);</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">            if (cssKey != null) {</span>
<span class="nc" id="L618">                return super.removeAttribute(old, cssKey);</span>
            }
        }
<span class="nc" id="L621">        return super.removeAttribute(old, key);</span>
    }

    /**
     * Removes a set of attributes for the element.  If any of the attributes
     * is a StyleConstants attribute, the request will be converted to a CSS
     * attribute prior to forwarding to the superclass behavior.
     *
     * @param old the old attribute set
     * @param names the attribute names
     * @return the updated attribute set
     * @see MutableAttributeSet#removeAttributes
     */
    public AttributeSet removeAttributes(AttributeSet old, Enumeration&lt;?&gt; names) {
        // PENDING: Should really be doing something similar to
        // removeHTMLTags here, but it is rather expensive to have to
        // clone names
<span class="nc" id="L638">        return super.removeAttributes(old, names);</span>
    }

    /**
     * Removes a set of attributes. If any of the attributes
     * is a StyleConstants attribute, the request will be converted to a CSS
     * attribute prior to forwarding to the superclass behavior.
     *
     * @param old the old attribute set
     * @param attrs the attributes
     * @return the updated attribute set
     * @see MutableAttributeSet#removeAttributes
     */
    public AttributeSet removeAttributes(AttributeSet old, AttributeSet attrs) {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (old != attrs) {</span>
<span class="nc" id="L653">            old = removeHTMLTags(old, attrs);</span>
        }
<span class="nc" id="L655">        return super.removeAttributes(old, convertAttributeSet(attrs));</span>
    }

    /**
     * Creates a compact set of attributes that might be shared.
     * This is a hook for subclasses that want to alter the
     * behavior of SmallAttributeSet.  This can be reimplemented
     * to return an AttributeSet that provides some sort of
     * attribute conversion.
     *
     * @param a The set of attributes to be represented in the
     *  the compact form.
     */
    protected SmallAttributeSet createSmallAttributeSet(AttributeSet a) {
<span class="nc" id="L669">        return new SmallConversionSet(a);</span>
    }

    /**
     * Creates a large set of attributes that should trade off
     * space for time.  This set will not be shared.  This is
     * a hook for subclasses that want to alter the behavior
     * of the larger attribute storage format (which is
     * SimpleAttributeSet by default).   This can be reimplemented
     * to return a MutableAttributeSet that provides some sort of
     * attribute conversion.
     *
     * @param a The set of attributes to be represented in the
     *  the larger form.
     */
    protected MutableAttributeSet createLargeAttributeSet(AttributeSet a) {
<span class="nc" id="L685">        return new LargeConversionSet(a);</span>
    }

    /**
     * For any StyleConstants key in attr that has an associated HTML.Tag,
     * it is removed from old. The resulting AttributeSet is then returned.
     */
    private AttributeSet removeHTMLTags(AttributeSet old, AttributeSet attr) {
<span class="nc bnc" id="L693" title="All 4 branches missed.">        if (!(attr instanceof LargeConversionSet) &amp;&amp;</span>
            !(attr instanceof SmallConversionSet)) {
<span class="nc" id="L695">            Enumeration names = attr.getAttributeNames();</span>

<span class="nc bnc" id="L697" title="All 2 branches missed.">            while (names.hasMoreElements()) {</span>
<span class="nc" id="L698">                Object key = names.nextElement();</span>

<span class="nc bnc" id="L700" title="All 2 branches missed.">                if (key instanceof StyleConstants) {</span>
<span class="nc" id="L701">                    HTML.Tag tag = HTML.getTagForStyleConstantsKey(</span>
                        (StyleConstants)key);

<span class="nc bnc" id="L704" title="All 4 branches missed.">                    if (tag != null &amp;&amp; old.isDefined(tag)) {</span>
<span class="nc" id="L705">                        old = super.removeAttribute(old, tag);</span>
                    }
                }
<span class="nc" id="L708">            }</span>
        }
<span class="nc" id="L710">        return old;</span>
    }

    /**
     * Converts a set of attributes (if necessary) so that
     * any attributes that were specified as StyleConstants
     * attributes and have a CSS mapping, will be converted
     * to CSS attributes.
     */
    AttributeSet convertAttributeSet(AttributeSet a) {
<span class="nc bnc" id="L720" title="All 4 branches missed.">        if ((a instanceof LargeConversionSet) ||</span>
            (a instanceof SmallConversionSet)) {
            // known to be converted.
<span class="nc" id="L723">            return a;</span>
        }
        // in most cases, there are no StyleConstants attributes
        // so we iterate the collection of keys to avoid creating
        // a new set.
<span class="nc" id="L728">        Enumeration names = a.getAttributeNames();</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">        while (names.hasMoreElements()) {</span>
<span class="nc" id="L730">            Object name = names.nextElement();</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">            if (name instanceof StyleConstants) {</span>
                // we really need to do a conversion, iterate again
                // building a new set.
<span class="nc" id="L734">                MutableAttributeSet converted = new LargeConversionSet();</span>
<span class="nc" id="L735">                Enumeration keys = a.getAttributeNames();</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">                while (keys.hasMoreElements()) {</span>
<span class="nc" id="L737">                    Object key = keys.nextElement();</span>
<span class="nc" id="L738">                    Object cssValue = null;</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">                    if (key instanceof StyleConstants) {</span>
                        // convert the StyleConstants attribute if possible
<span class="nc" id="L741">                        Object cssKey = css.styleConstantsKeyToCSSKey</span>
<span class="nc" id="L742">                                            ((StyleConstants)key);</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">                        if (cssKey != null) {</span>
<span class="nc" id="L744">                            Object value = a.getAttribute(key);</span>
<span class="nc" id="L745">                            cssValue = css.styleConstantsValueToCSSValue</span>
<span class="nc" id="L746">                                           ((StyleConstants)key, value);</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">                            if (cssValue != null) {</span>
<span class="nc" id="L748">                                converted.addAttribute(cssKey, cssValue);</span>
                            }
                        }
                    }
<span class="nc bnc" id="L752" title="All 2 branches missed.">                    if (cssValue == null) {</span>
<span class="nc" id="L753">                        converted.addAttribute(key, a.getAttribute(key));</span>
                    }
<span class="nc" id="L755">                }</span>
<span class="nc" id="L756">                return converted;</span>
            }
<span class="nc" id="L758">        }</span>
<span class="nc" id="L759">        return a;</span>
    }

    /**
     * Large set of attributes that does conversion of requests
     * for attributes of type StyleConstants.
     */
    class LargeConversionSet extends SimpleAttributeSet {

        /**
         * Creates a new attribute set based on a supplied set of attributes.
         *
         * @param source the set of attributes
         */
<span class="nc" id="L773">        public LargeConversionSet(AttributeSet source) {</span>
<span class="nc" id="L774">            super(source);</span>
<span class="nc" id="L775">        }</span>

<span class="nc" id="L777">        public LargeConversionSet() {</span>
<span class="nc" id="L778">            super();</span>
<span class="nc" id="L779">        }</span>

        /**
         * Checks whether a given attribute is defined.
         *
         * @param key the attribute key
         * @return true if the attribute is defined
         * @see AttributeSet#isDefined
         */
        public boolean isDefined(Object key) {
<span class="nc bnc" id="L789" title="All 2 branches missed.">            if (key instanceof StyleConstants) {</span>
<span class="nc" id="L790">                Object cssKey = css.styleConstantsKeyToCSSKey</span>
<span class="nc" id="L791">                                    ((StyleConstants)key);</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">                if (cssKey != null) {</span>
<span class="nc" id="L793">                    return super.isDefined(cssKey);</span>
                }
            }
<span class="nc" id="L796">            return super.isDefined(key);</span>
        }

        /**
         * Gets the value of an attribute.
         *
         * @param key the attribute name
         * @return the attribute value
         * @see AttributeSet#getAttribute
         */
        public Object getAttribute(Object key) {
<span class="nc bnc" id="L807" title="All 2 branches missed.">            if (key instanceof StyleConstants) {</span>
<span class="nc" id="L808">                Object cssKey = css.styleConstantsKeyToCSSKey</span>
<span class="nc" id="L809">                                    ((StyleConstants)key);</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">                if (cssKey != null) {</span>
<span class="nc" id="L811">                    Object value = super.getAttribute(cssKey);</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">                    if (value != null) {</span>
<span class="nc" id="L813">                        return css.cssValueToStyleConstantsValue</span>
<span class="nc" id="L814">                                           ((StyleConstants)key, value);</span>
                    }
                }
            }
<span class="nc" id="L818">            return super.getAttribute(key);</span>
        }
    }

    /**
     * Small set of attributes that does conversion of requests
     * for attributes of type StyleConstants.
     */
    class SmallConversionSet extends SmallAttributeSet {

        /**
         * Creates a new attribute set based on a supplied set of attributes.
         *
         * @param attrs the set of attributes
         */
<span class="nc" id="L833">        public SmallConversionSet(AttributeSet attrs) {</span>
<span class="nc" id="L834">            super(attrs);</span>
<span class="nc" id="L835">        }</span>

        /**
         * Checks whether a given attribute is defined.
         *
         * @param key the attribute key
         * @return true if the attribute is defined
         * @see AttributeSet#isDefined
         */
        public boolean isDefined(Object key) {
<span class="nc bnc" id="L845" title="All 2 branches missed.">            if (key instanceof StyleConstants) {</span>
<span class="nc" id="L846">                Object cssKey = css.styleConstantsKeyToCSSKey</span>
<span class="nc" id="L847">                                    ((StyleConstants)key);</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">                if (cssKey != null) {</span>
<span class="nc" id="L849">                    return super.isDefined(cssKey);</span>
                }
            }
<span class="nc" id="L852">            return super.isDefined(key);</span>
        }

        /**
         * Gets the value of an attribute.
         *
         * @param key the attribute name
         * @return the attribute value
         * @see AttributeSet#getAttribute
         */
        public Object getAttribute(Object key) {
<span class="nc bnc" id="L863" title="All 2 branches missed.">            if (key instanceof StyleConstants) {</span>
<span class="nc" id="L864">                Object cssKey = css.styleConstantsKeyToCSSKey</span>
<span class="nc" id="L865">                                    ((StyleConstants)key);</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">                if (cssKey != null) {</span>
<span class="nc" id="L867">                    Object value = super.getAttribute(cssKey);</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">                    if (value != null) {</span>
<span class="nc" id="L869">                        return css.cssValueToStyleConstantsValue</span>
<span class="nc" id="L870">                                           ((StyleConstants)key, value);</span>
                    }
                }
            }
<span class="nc" id="L874">            return super.getAttribute(key);</span>
        }
    }

    // ---- Resource handling ----------------------------------------

    /**
     * Fetches the font to use for the given set of attributes.
     */
    public Font getFont(AttributeSet a) {
<span class="nc" id="L884">        return css.getFont(this, a, 12, this);</span>
    }

    /**
     * Takes a set of attributes and turn it into a foreground color
     * specification.  This might be used to specify things
     * like brighter, more hue, etc.
     *
     * @param a the set of attributes
     * @return the color
     */
    public Color getForeground(AttributeSet a) {
<span class="nc" id="L896">        Color c = css.getColor(a, CSS.Attribute.COLOR);</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L898">            return Color.black;</span>
        }
<span class="nc" id="L900">        return c;</span>
    }

    /**
     * Takes a set of attributes and turn it into a background color
     * specification.  This might be used to specify things
     * like brighter, more hue, etc.
     *
     * @param a the set of attributes
     * @return the color
     */
    public Color getBackground(AttributeSet a) {
<span class="nc" id="L912">        return css.getColor(a, CSS.Attribute.BACKGROUND_COLOR);</span>
    }

    /**
     * Fetches the box formatter to use for the given set
     * of CSS attributes.
     */
    public BoxPainter getBoxPainter(AttributeSet a) {
<span class="nc" id="L920">        return new BoxPainter(a, css, this);</span>
    }

    /**
     * Fetches the list formatter to use for the given set
     * of CSS attributes.
     */
    public ListPainter getListPainter(AttributeSet a) {
<span class="nc" id="L928">        return new ListPainter(a, this);</span>
    }

    /**
     * Sets the base font size, with valid values between 1 and 7.
     */
    public void setBaseFontSize(int sz) {
<span class="nc" id="L935">        css.setBaseFontSize(sz);</span>
<span class="nc" id="L936">    }</span>

    /**
     * Sets the base font size from the passed in String. The string
     * can either identify a specific font size, with legal values between
     * 1 and 7, or identify a relative font size such as +1 or -2.
     */
    public void setBaseFontSize(String size) {
<span class="nc" id="L944">        css.setBaseFontSize(size);</span>
<span class="nc" id="L945">    }</span>

    public static int getIndexOfSize(float pt) {
<span class="nc" id="L948">        return CSS.getIndexOfSize(pt, sizeMapDefault);</span>
    }

    /**
     * Returns the point size, given a size index.
     */
    public float getPointSize(int index) {
<span class="nc" id="L955">        return css.getPointSize(index, this);</span>
    }

    /**
     *  Given a string such as &quot;+2&quot;, &quot;-2&quot;, or &quot;2&quot;,
     *  returns a point size value.
     */
    public float getPointSize(String size) {
<span class="nc" id="L963">        return css.getPointSize(size, this);</span>
    }

    /**
     * Converts a color string such as &quot;RED&quot; or &quot;#NNNNNN&quot; to a Color.
     * Note: This will only convert the HTML3.2 color strings
     *       or a string of length 7;
     *       otherwise, it will return null.
     */
    public Color stringToColor(String string) {
<span class="nc" id="L973">        return CSS.stringToColor(string);</span>
    }

    /**
     * Returns the ImageIcon to draw in the background for
     * &lt;code&gt;attr&lt;/code&gt;.
     */
    ImageIcon getBackgroundImage(AttributeSet attr) {
<span class="nc" id="L981">        Object value = attr.getAttribute(CSS.Attribute.BACKGROUND_IMAGE);</span>

<span class="nc bnc" id="L983" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L984">            return ((CSS.BackgroundImage)value).getImage(getBase());</span>
        }
<span class="nc" id="L986">        return null;</span>
    }

    /**
     * Adds a rule into the StyleSheet.
     *
     * @param selector the selector to use for the rule.
     *  This will be a set of simple selectors, and must
     *  be a length of 1 or greater.
     * @param declaration the set of CSS attributes that
     *  make up the rule.
     */
    void addRule(String[] selector, AttributeSet declaration,
                 boolean isLinked) {
<span class="nc" id="L1000">        int n = selector.length;</span>
<span class="nc" id="L1001">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1002">        sb.append(selector[0]);</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">        for (int counter = 1; counter &lt; n; counter++) {</span>
<span class="nc" id="L1004">            sb.append(' ');</span>
<span class="nc" id="L1005">            sb.append(selector[counter]);</span>
        }
<span class="nc" id="L1007">        String selectorName = sb.toString();</span>
<span class="nc" id="L1008">        Style rule = getStyle(selectorName);</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        if (rule == null) {</span>
            // Notice how the rule is first created, and it not part of
            // the synchronized block. It is done like this as creating
            // a new rule will fire a ChangeEvent. We do not want to be
            // holding the lock when calling to other objects, it can
            // result in deadlock.
<span class="nc" id="L1015">            Style altRule = addStyle(selectorName, null);</span>
<span class="nc" id="L1016">            synchronized(this) {</span>
<span class="nc" id="L1017">                SelectorMapping mapping = getRootSelectorMapping();</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">                for (int i = n - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L1019">                    mapping = mapping.getChildSelectorMapping</span>
<span class="nc" id="L1020">                                      (selector[i], true);</span>
                }
<span class="nc" id="L1022">                rule = mapping.getStyle();</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">                if (rule == null) {</span>
<span class="nc" id="L1024">                    rule = altRule;</span>
<span class="nc" id="L1025">                    mapping.setStyle(rule);</span>
<span class="nc" id="L1026">                    refreshResolvedRules(selectorName, selector, rule,</span>
<span class="nc" id="L1027">                                         mapping.getSpecificity());</span>
                }
<span class="nc" id="L1029">            }</span>
        }
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        if (isLinked) {</span>
<span class="nc" id="L1032">            rule = getLinkedStyle(rule);</span>
        }
<span class="nc" id="L1034">        rule.addAttributes(declaration);</span>
<span class="nc" id="L1035">    }</span>

    //
    // The following gaggle of methods is used in maintaining the rules from
    // the sheet.
    //

    /**
     * Updates the attributes of the rules to reference any related
     * rules in &lt;code&gt;ss&lt;/code&gt;.
     */
    private synchronized void linkStyleSheetAt(StyleSheet ss, int index) {
<span class="nc bnc" id="L1047" title="All 2 branches missed.">        if (resolvedStyles.size() &gt; 0) {</span>
<span class="nc" id="L1048">            Enumeration&lt;ResolvedStyle&gt; values = resolvedStyles.elements();</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">            while (values.hasMoreElements()) {</span>
<span class="nc" id="L1050">                ResolvedStyle rule = values.nextElement();</span>
<span class="nc" id="L1051">                rule.insertExtendedStyleAt(ss.getRule(rule.getName()),</span>
                                           index);
<span class="nc" id="L1053">            }</span>
        }
<span class="nc" id="L1055">    }</span>

    /**
     * Removes references to the rules in &lt;code&gt;ss&lt;/code&gt;.
     * &lt;code&gt;index&lt;/code&gt; gives the index the StyleSheet was at, that is
     * how many StyleSheets had been added before it.
     */
    private synchronized void unlinkStyleSheet(StyleSheet ss, int index) {
<span class="nc bnc" id="L1063" title="All 2 branches missed.">        if (resolvedStyles.size() &gt; 0) {</span>
<span class="nc" id="L1064">            Enumeration&lt;ResolvedStyle&gt; values = resolvedStyles.elements();</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            while (values.hasMoreElements()) {</span>
<span class="nc" id="L1066">                ResolvedStyle rule = values.nextElement();</span>
<span class="nc" id="L1067">                rule.removeExtendedStyleAt(index);</span>
<span class="nc" id="L1068">            }</span>
        }
<span class="nc" id="L1070">    }</span>

    /**
     * Returns the simple selectors that comprise selector.
     */
    /* protected */
    String[] getSimpleSelectors(String selector) {
<span class="nc" id="L1077">        selector = cleanSelectorString(selector);</span>
<span class="nc" id="L1078">        SearchBuffer sb = SearchBuffer.obtainSearchBuffer();</span>
<span class="nc" id="L1079">        Vector&lt;String&gt; selectors = sb.getVector();</span>
<span class="nc" id="L1080">        int lastIndex = 0;</span>
<span class="nc" id="L1081">        int length = selector.length();</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">        while (lastIndex != -1) {</span>
<span class="nc" id="L1083">            int newIndex = selector.indexOf(' ', lastIndex);</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">            if (newIndex != -1) {</span>
<span class="nc" id="L1085">                selectors.addElement(selector.substring(lastIndex, newIndex));</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">                if (++newIndex == length) {</span>
<span class="nc" id="L1087">                    lastIndex = -1;</span>
                }
                else {
<span class="nc" id="L1090">                    lastIndex = newIndex;</span>
                }
            }
            else {
<span class="nc" id="L1094">                selectors.addElement(selector.substring(lastIndex));</span>
<span class="nc" id="L1095">                lastIndex = -1;</span>
            }
<span class="nc" id="L1097">        }</span>
<span class="nc" id="L1098">        String[] retValue = new String[selectors.size()];</span>
<span class="nc" id="L1099">        selectors.copyInto(retValue);</span>
<span class="nc" id="L1100">        SearchBuffer.releaseSearchBuffer(sb);</span>
<span class="nc" id="L1101">        return retValue;</span>
    }

    /**
     * Returns a string that only has one space between simple selectors,
     * which may be the passed in String.
     */
    /*protected*/ String cleanSelectorString(String selector) {
<span class="nc" id="L1109">        boolean lastWasSpace = true;</span>
<span class="nc" id="L1110">        for (int counter = 0, maxCounter = selector.length();</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">             counter &lt; maxCounter; counter++) {</span>
<span class="nc bnc" id="L1112" title="All 3 branches missed.">            switch(selector.charAt(counter)) {</span>
            case ' ':
<span class="nc bnc" id="L1114" title="All 2 branches missed.">                if (lastWasSpace) {</span>
<span class="nc" id="L1115">                    return _cleanSelectorString(selector);</span>
                }
<span class="nc" id="L1117">                lastWasSpace = true;</span>
<span class="nc" id="L1118">                break;</span>
            case '\n':
            case '\r':
            case '\t':
<span class="nc" id="L1122">                return _cleanSelectorString(selector);</span>
            default:
<span class="nc" id="L1124">                lastWasSpace = false;</span>
            }
        }
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        if (lastWasSpace) {</span>
<span class="nc" id="L1128">            return _cleanSelectorString(selector);</span>
        }
        // It was fine.
<span class="nc" id="L1131">        return selector;</span>
    }

    /**
     * Returns a new String that contains only one space between non
     * white space characters.
     */
    private String _cleanSelectorString(String selector) {
<span class="nc" id="L1139">        SearchBuffer sb = SearchBuffer.obtainSearchBuffer();</span>
<span class="nc" id="L1140">        StringBuffer buff = sb.getStringBuffer();</span>
<span class="nc" id="L1141">        boolean lastWasSpace = true;</span>
<span class="nc" id="L1142">        int lastIndex = 0;</span>
<span class="nc" id="L1143">        char[] chars = selector.toCharArray();</span>
<span class="nc" id="L1144">        int numChars = chars.length;</span>
<span class="nc" id="L1145">        String retValue = null;</span>
        try {
<span class="nc bnc" id="L1147" title="All 2 branches missed.">            for (int counter = 0; counter &lt; numChars; counter++) {</span>
<span class="nc bnc" id="L1148" title="All 3 branches missed.">                switch(chars[counter]) {</span>
                case ' ':
<span class="nc bnc" id="L1150" title="All 2 branches missed.">                    if (!lastWasSpace) {</span>
<span class="nc" id="L1151">                        lastWasSpace = true;</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">                        if (lastIndex &lt; counter) {</span>
<span class="nc" id="L1153">                            buff.append(chars, lastIndex,</span>
                                        1 + counter - lastIndex);
                        }
                    }
<span class="nc" id="L1157">                    lastIndex = counter + 1;</span>
<span class="nc" id="L1158">                    break;</span>
                case '\n':
                case '\r':
                case '\t':
<span class="nc bnc" id="L1162" title="All 2 branches missed.">                    if (!lastWasSpace) {</span>
<span class="nc" id="L1163">                        lastWasSpace = true;</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">                        if (lastIndex &lt; counter) {</span>
<span class="nc" id="L1165">                            buff.append(chars, lastIndex,</span>
                                        counter - lastIndex);
<span class="nc" id="L1167">                            buff.append(' ');</span>
                        }
                    }
<span class="nc" id="L1170">                    lastIndex = counter + 1;</span>
<span class="nc" id="L1171">                    break;</span>
                default:
<span class="nc" id="L1173">                    lastWasSpace = false;</span>
                    break;
                }
            }
<span class="nc bnc" id="L1177" title="All 4 branches missed.">            if (lastWasSpace &amp;&amp; buff.length() &gt; 0) {</span>
                // Remove last space.
<span class="nc" id="L1179">                buff.setLength(buff.length() - 1);</span>
            }
<span class="nc bnc" id="L1181" title="All 2 branches missed.">            else if (lastIndex &lt; numChars) {</span>
<span class="nc" id="L1182">                buff.append(chars, lastIndex, numChars - lastIndex);</span>
            }
<span class="nc" id="L1184">            retValue = buff.toString();</span>
        }
        finally {
<span class="nc" id="L1187">            SearchBuffer.releaseSearchBuffer(sb);</span>
<span class="nc" id="L1188">        }</span>
<span class="nc" id="L1189">        return retValue;</span>
    }

    /**
     * Returns the root selector mapping that all selectors are relative
     * to. This is an inverted graph of the selectors.
     */
    private SelectorMapping getRootSelectorMapping() {
<span class="nc" id="L1197">        return selectorMapping;</span>
    }

    /**
     * Returns the specificity of the passed in String. It assumes the
     * passed in string doesn't contain junk, that is each selector is
     * separated by a space and each selector at most contains one . or one
     * #. A simple selector has a weight of 1, an id selector has a weight
     * of 100, and a class selector has a weight of 10000.
     */
    /*protected*/ static int getSpecificity(String selector) {
<span class="nc" id="L1208">        int specificity = 0;</span>
<span class="nc" id="L1209">        boolean lastWasSpace = true;</span>

<span class="nc" id="L1211">        for (int counter = 0, maxCounter = selector.length();</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">             counter &lt; maxCounter; counter++) {</span>
<span class="nc bnc" id="L1213" title="All 4 branches missed.">            switch(selector.charAt(counter)) {</span>
            case '.':
<span class="nc" id="L1215">                specificity += 100;</span>
<span class="nc" id="L1216">                break;</span>
            case '#':
<span class="nc" id="L1218">                specificity += 10000;</span>
<span class="nc" id="L1219">                break;</span>
            case ' ':
<span class="nc" id="L1221">                lastWasSpace = true;</span>
<span class="nc" id="L1222">                break;</span>
            default:
<span class="nc bnc" id="L1224" title="All 2 branches missed.">                if (lastWasSpace) {</span>
<span class="nc" id="L1225">                    lastWasSpace = false;</span>
<span class="nc" id="L1226">                    specificity += 1;</span>
                }
            }
        }
<span class="nc" id="L1230">        return specificity;</span>
    }

    /**
     * Returns the style that linked attributes should be added to. This
     * will create the style if necessary.
     */
    private Style getLinkedStyle(Style localStyle) {
        // NOTE: This is not synchronized, and the caller of this does
        // not synchronize. There is the chance for one of the callers to
        // overwrite the existing resolved parent, but it is quite rare.
        // The reason this is left like this is because setResolveParent
        // will fire a ChangeEvent. It is really, REALLY bad for us to
        // hold a lock when calling outside of us, it may cause a deadlock.
<span class="nc" id="L1244">        Style retStyle = (Style)localStyle.getResolveParent();</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">        if (retStyle == null) {</span>
<span class="nc" id="L1246">            retStyle = addStyle(null, null);</span>
<span class="nc" id="L1247">            localStyle.setResolveParent(retStyle);</span>
        }
<span class="nc" id="L1249">        return retStyle;</span>
    }

    /**
     * Returns the resolved style for &lt;code&gt;selector&lt;/code&gt;. This will
     * create the resolved style, if necessary.
     */
    private synchronized Style getResolvedStyle(String selector,
                                                Vector elements,
                                                HTML.Tag t) {
<span class="nc" id="L1259">        Style retStyle = resolvedStyles.get(selector);</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">        if (retStyle == null) {</span>
<span class="nc" id="L1261">            retStyle = createResolvedStyle(selector, elements, t);</span>
        }
<span class="nc" id="L1263">        return retStyle;</span>
    }

    /**
     * Returns the resolved style for &lt;code&gt;selector&lt;/code&gt;. This will
     * create the resolved style, if necessary.
     */
    private synchronized Style getResolvedStyle(String selector) {
<span class="nc" id="L1271">        Style retStyle = resolvedStyles.get(selector);</span>
<span class="nc bnc" id="L1272" title="All 2 branches missed.">        if (retStyle == null) {</span>
<span class="nc" id="L1273">            retStyle = createResolvedStyle(selector);</span>
        }
<span class="nc" id="L1275">        return retStyle;</span>
    }

    /**
     * Adds &lt;code&gt;mapping&lt;/code&gt; to &lt;code&gt;elements&lt;/code&gt;. It is added
     * such that &lt;code&gt;elements&lt;/code&gt; will remain ordered by
     * specificity.
     */
    private void addSortedStyle(SelectorMapping mapping, Vector&lt;SelectorMapping&gt; elements) {
<span class="nc" id="L1284">        int       size = elements.size();</span>

<span class="nc bnc" id="L1286" title="All 2 branches missed.">        if (size &gt; 0) {</span>
<span class="nc" id="L1287">            int     specificity = mapping.getSpecificity();</span>

<span class="nc bnc" id="L1289" title="All 2 branches missed.">            for (int counter = 0; counter &lt; size; counter++) {</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">                if (specificity &gt;= elements.elementAt(counter).getSpecificity()) {</span>
<span class="nc" id="L1291">                    elements.insertElementAt(mapping, counter);</span>
<span class="nc" id="L1292">                    return;</span>
                }
            }
        }
<span class="nc" id="L1296">        elements.addElement(mapping);</span>
<span class="nc" id="L1297">    }</span>

    /**
     * Adds &lt;code&gt;parentMapping&lt;/code&gt; to &lt;code&gt;styles&lt;/code&gt;, and
     * recursively calls this method if &lt;code&gt;parentMapping&lt;/code&gt; has
     * any child mappings for any of the Elements in &lt;code&gt;elements&lt;/code&gt;.
     */
    private synchronized void getStyles(SelectorMapping parentMapping,
                           Vector&lt;SelectorMapping&gt; styles,
                           String[] tags, String[] ids, String[] classes,
                           int index, int numElements,
                           Hashtable&lt;SelectorMapping, SelectorMapping&gt; alreadyChecked) {
        // Avoid desending the same mapping twice.
<span class="nc bnc" id="L1310" title="All 2 branches missed.">        if (alreadyChecked.contains(parentMapping)) {</span>
<span class="nc" id="L1311">            return;</span>
        }
<span class="nc" id="L1313">        alreadyChecked.put(parentMapping, parentMapping);</span>
<span class="nc" id="L1314">        Style style = parentMapping.getStyle();</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">        if (style != null) {</span>
<span class="nc" id="L1316">            addSortedStyle(parentMapping, styles);</span>
        }
<span class="nc bnc" id="L1318" title="All 2 branches missed.">        for (int counter = index; counter &lt; numElements; counter++) {</span>
<span class="nc" id="L1319">            String tagString = tags[counter];</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">            if (tagString != null) {</span>
<span class="nc" id="L1321">                SelectorMapping childMapping = parentMapping.</span>
<span class="nc" id="L1322">                                getChildSelectorMapping(tagString, false);</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">                if (childMapping != null) {</span>
<span class="nc" id="L1324">                    getStyles(childMapping, styles, tags, ids, classes,</span>
                              counter + 1, numElements, alreadyChecked);
                }
<span class="nc bnc" id="L1327" title="All 2 branches missed.">                if (classes[counter] != null) {</span>
<span class="nc" id="L1328">                    String className = classes[counter];</span>
<span class="nc" id="L1329">                    childMapping = parentMapping.getChildSelectorMapping(</span>
                                         tagString + &quot;.&quot; + className, false);
<span class="nc bnc" id="L1331" title="All 2 branches missed.">                    if (childMapping != null) {</span>
<span class="nc" id="L1332">                        getStyles(childMapping, styles, tags, ids, classes,</span>
                                  counter + 1, numElements, alreadyChecked);
                    }
<span class="nc" id="L1335">                    childMapping = parentMapping.getChildSelectorMapping(</span>
                                         &quot;.&quot; + className, false);
<span class="nc bnc" id="L1337" title="All 2 branches missed.">                    if (childMapping != null) {</span>
<span class="nc" id="L1338">                        getStyles(childMapping, styles, tags, ids, classes,</span>
                                  counter + 1, numElements, alreadyChecked);
                    }
                }
<span class="nc bnc" id="L1342" title="All 2 branches missed.">                if (ids[counter] != null) {</span>
<span class="nc" id="L1343">                    String idName = ids[counter];</span>
<span class="nc" id="L1344">                    childMapping = parentMapping.getChildSelectorMapping(</span>
                                         tagString + &quot;#&quot; + idName, false);
<span class="nc bnc" id="L1346" title="All 2 branches missed.">                    if (childMapping != null) {</span>
<span class="nc" id="L1347">                        getStyles(childMapping, styles, tags, ids, classes,</span>
                                  counter + 1, numElements, alreadyChecked);
                    }
<span class="nc" id="L1350">                    childMapping = parentMapping.getChildSelectorMapping(</span>
                                   &quot;#&quot; + idName, false);
<span class="nc bnc" id="L1352" title="All 2 branches missed.">                    if (childMapping != null) {</span>
<span class="nc" id="L1353">                        getStyles(childMapping, styles, tags, ids, classes,</span>
                                  counter + 1, numElements, alreadyChecked);
                    }
                }
            }
        }
<span class="nc" id="L1359">    }</span>

    /**
     * Creates and returns a Style containing all the rules that match
     *  &lt;code&gt;selector&lt;/code&gt;.
     */
    private synchronized Style createResolvedStyle(String selector,
                                      String[] tags,
                                      String[] ids, String[] classes) {
<span class="nc" id="L1368">        SearchBuffer sb = SearchBuffer.obtainSearchBuffer();</span>
<span class="nc" id="L1369">        Vector&lt;SelectorMapping&gt; tempVector = sb.getVector();</span>
<span class="nc" id="L1370">        Hashtable&lt;SelectorMapping, SelectorMapping&gt; tempHashtable = sb.getHashtable();</span>
        // Determine all the Styles that are appropriate, placing them
        // in tempVector
        try {
<span class="nc" id="L1374">            SelectorMapping mapping = getRootSelectorMapping();</span>
<span class="nc" id="L1375">            int numElements = tags.length;</span>
<span class="nc" id="L1376">            String tagString = tags[0];</span>
<span class="nc" id="L1377">            SelectorMapping childMapping = mapping.getChildSelectorMapping(</span>
                                                   tagString, false);
<span class="nc bnc" id="L1379" title="All 2 branches missed.">            if (childMapping != null) {</span>
<span class="nc" id="L1380">                getStyles(childMapping, tempVector, tags, ids, classes, 1,</span>
                          numElements, tempHashtable);
            }
<span class="nc bnc" id="L1383" title="All 2 branches missed.">            if (classes[0] != null) {</span>
<span class="nc" id="L1384">                String className = classes[0];</span>
<span class="nc" id="L1385">                childMapping = mapping.getChildSelectorMapping(</span>
                                       tagString + &quot;.&quot; + className, false);
<span class="nc bnc" id="L1387" title="All 2 branches missed.">                if (childMapping != null) {</span>
<span class="nc" id="L1388">                    getStyles(childMapping, tempVector, tags, ids, classes, 1,</span>
                              numElements, tempHashtable);
                }
<span class="nc" id="L1391">                childMapping = mapping.getChildSelectorMapping(</span>
                                       &quot;.&quot; + className, false);
<span class="nc bnc" id="L1393" title="All 2 branches missed.">                if (childMapping != null) {</span>
<span class="nc" id="L1394">                    getStyles(childMapping, tempVector, tags, ids, classes,</span>
                              1, numElements, tempHashtable);
                }
            }
<span class="nc bnc" id="L1398" title="All 2 branches missed.">            if (ids[0] != null) {</span>
<span class="nc" id="L1399">                String idName = ids[0];</span>
<span class="nc" id="L1400">                childMapping = mapping.getChildSelectorMapping(</span>
                                       tagString + &quot;#&quot; + idName, false);
<span class="nc bnc" id="L1402" title="All 2 branches missed.">                if (childMapping != null) {</span>
<span class="nc" id="L1403">                    getStyles(childMapping, tempVector, tags, ids, classes,</span>
                              1, numElements, tempHashtable);
                }
<span class="nc" id="L1406">                childMapping = mapping.getChildSelectorMapping(</span>
                                       &quot;#&quot; + idName, false);
<span class="nc bnc" id="L1408" title="All 2 branches missed.">                if (childMapping != null) {</span>
<span class="nc" id="L1409">                    getStyles(childMapping, tempVector, tags, ids, classes,</span>
                              1, numElements, tempHashtable);
                }
            }
            // Create a new Style that will delegate to all the matching
            // Styles.
<span class="nc bnc" id="L1415" title="All 2 branches missed.">            int numLinkedSS = (linkedStyleSheets != null) ?</span>
<span class="nc" id="L1416">                              linkedStyleSheets.size() : 0;</span>
<span class="nc" id="L1417">            int numStyles = tempVector.size();</span>
<span class="nc" id="L1418">            AttributeSet[] attrs = new AttributeSet[numStyles + numLinkedSS];</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">            for (int counter = 0; counter &lt; numStyles; counter++) {</span>
<span class="nc" id="L1420">                attrs[counter] = tempVector.elementAt(counter).getStyle();</span>
            }
            // Get the AttributeSet from linked style sheets.
<span class="nc bnc" id="L1423" title="All 2 branches missed.">            for (int counter = 0; counter &lt; numLinkedSS; counter++) {</span>
<span class="nc" id="L1424">                AttributeSet attr = linkedStyleSheets.elementAt(counter).getRule(selector);</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">                if (attr == null) {</span>
<span class="nc" id="L1426">                    attrs[counter + numStyles] = SimpleAttributeSet.EMPTY;</span>
                }
                else {
<span class="nc" id="L1429">                    attrs[counter + numStyles] = attr;</span>
                }
            }
<span class="nc" id="L1432">            ResolvedStyle retStyle = new ResolvedStyle(selector, attrs,</span>
                                                       numStyles);
<span class="nc" id="L1434">            resolvedStyles.put(selector, retStyle);</span>
<span class="nc" id="L1435">            return retStyle;</span>
        }
        finally {
<span class="nc" id="L1438">            SearchBuffer.releaseSearchBuffer(sb);</span>
        }
    }

    /**
     * Creates and returns a Style containing all the rules that
     * matches &lt;code&gt;selector&lt;/code&gt;.
     *
     * @param elements  a Vector of all the Elements
     *                  the style is being asked for. The
     *                  first Element is the deepest Element, with the last Element
     *                  representing the root.
     * @param t         the Tag to use for
     *                  the first Element in &lt;code&gt;elements&lt;/code&gt;
     */
    private Style createResolvedStyle(String selector, Vector elements,
                                      HTML.Tag t) {
<span class="nc" id="L1455">        int numElements = elements.size();</span>
        // Build three arrays, one for tags, one for class's, and one for
        // id's
<span class="nc" id="L1458">        String tags[] = new String[numElements];</span>
<span class="nc" id="L1459">        String ids[] = new String[numElements];</span>
<span class="nc" id="L1460">        String classes[] = new String[numElements];</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">        for (int counter = 0; counter &lt; numElements; counter++) {</span>
<span class="nc" id="L1462">            Element e = (Element)elements.elementAt(counter);</span>
<span class="nc" id="L1463">            AttributeSet attr = e.getAttributes();</span>
<span class="nc bnc" id="L1464" title="All 4 branches missed.">            if (counter == 0 &amp;&amp; e.isLeaf()) {</span>
                // For leafs, we use the second tier attributes.
<span class="nc" id="L1466">                Object testAttr = attr.getAttribute(t);</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">                if (testAttr instanceof AttributeSet) {</span>
<span class="nc" id="L1468">                    attr = (AttributeSet)testAttr;</span>
                }
                else {
<span class="nc" id="L1471">                    attr = null;</span>
                }
            }
<span class="nc bnc" id="L1474" title="All 2 branches missed.">            if (attr != null) {</span>
<span class="nc" id="L1475">                HTML.Tag tag = (HTML.Tag)attr.getAttribute(StyleConstants.</span>
                                                           NameAttribute);
<span class="nc bnc" id="L1477" title="All 2 branches missed.">                if (tag != null) {</span>
<span class="nc" id="L1478">                    tags[counter] = tag.toString();</span>
                }
                else {
<span class="nc" id="L1481">                    tags[counter] = null;</span>
                }
<span class="nc bnc" id="L1483" title="All 2 branches missed.">                if (attr.isDefined(HTML.Attribute.CLASS)) {</span>
<span class="nc" id="L1484">                    classes[counter] = attr.getAttribute</span>
<span class="nc" id="L1485">                                      (HTML.Attribute.CLASS).toString();</span>
                }
                else {
<span class="nc" id="L1488">                    classes[counter] = null;</span>
                }
<span class="nc bnc" id="L1490" title="All 2 branches missed.">                if (attr.isDefined(HTML.Attribute.ID)) {</span>
<span class="nc" id="L1491">                    ids[counter] = attr.getAttribute(HTML.Attribute.ID).</span>
<span class="nc" id="L1492">                                        toString();</span>
                }
                else {
<span class="nc" id="L1495">                    ids[counter] = null;</span>
                }
<span class="nc" id="L1497">            }</span>
            else {
<span class="nc" id="L1499">                tags[counter] = ids[counter] = classes[counter] = null;</span>
            }
        }
<span class="nc" id="L1502">        tags[0] = t.toString();</span>
<span class="nc" id="L1503">        return createResolvedStyle(selector, tags, ids, classes);</span>
    }

    /**
     * Creates and returns a Style containing all the rules that match
     *  &lt;code&gt;selector&lt;/code&gt;. It is assumed that each simple selector
     * in &lt;code&gt;selector&lt;/code&gt; is separated by a space.
     */
    private Style createResolvedStyle(String selector) {
<span class="nc" id="L1512">        SearchBuffer sb = SearchBuffer.obtainSearchBuffer();</span>
        // Will contain the tags, ids, and classes, in that order.
<span class="nc" id="L1514">        Vector&lt;String&gt; elements = sb.getVector();</span>
        try {
            boolean done;
<span class="nc" id="L1517">            int dotIndex = 0;</span>
            int spaceIndex;
<span class="nc" id="L1519">            int poundIndex = 0;</span>
<span class="nc" id="L1520">            int lastIndex = 0;</span>
<span class="nc" id="L1521">            int length = selector.length();</span>
<span class="nc bnc" id="L1522" title="All 2 branches missed.">            while (lastIndex &lt; length) {</span>
<span class="nc bnc" id="L1523" title="All 2 branches missed.">                if (dotIndex == lastIndex) {</span>
<span class="nc" id="L1524">                    dotIndex = selector.indexOf('.', lastIndex);</span>
                }
<span class="nc bnc" id="L1526" title="All 2 branches missed.">                if (poundIndex == lastIndex) {</span>
<span class="nc" id="L1527">                    poundIndex = selector.indexOf('#', lastIndex);</span>
                }
<span class="nc" id="L1529">                spaceIndex = selector.indexOf(' ', lastIndex);</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">                if (spaceIndex == -1) {</span>
<span class="nc" id="L1531">                    spaceIndex = length;</span>
                }
<span class="nc bnc" id="L1533" title="All 8 branches missed.">                if (dotIndex != -1 &amp;&amp; poundIndex != -1 &amp;&amp;</span>
                    dotIndex &lt; spaceIndex &amp;&amp; poundIndex &lt; spaceIndex) {
<span class="nc bnc" id="L1535" title="All 2 branches missed.">                    if (poundIndex &lt; dotIndex) {</span>
                        // #.
<span class="nc bnc" id="L1537" title="All 2 branches missed.">                        if (lastIndex == poundIndex) {</span>
<span class="nc" id="L1538">                            elements.addElement(&quot;&quot;);</span>
                        }
                        else {
<span class="nc" id="L1541">                            elements.addElement(selector.substring(lastIndex,</span>
                                                                  poundIndex));
                        }
<span class="nc bnc" id="L1544" title="All 2 branches missed.">                        if ((dotIndex + 1) &lt; spaceIndex) {</span>
<span class="nc" id="L1545">                            elements.addElement(selector.substring</span>
<span class="nc" id="L1546">                                                (dotIndex + 1, spaceIndex));</span>
                        }
                        else {
<span class="nc" id="L1549">                            elements.addElement(null);</span>
                        }
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                        if ((poundIndex + 1) == dotIndex) {</span>
<span class="nc" id="L1552">                            elements.addElement(null);</span>
                        }
                        else {
<span class="nc" id="L1555">                            elements.addElement(selector.substring</span>
<span class="nc" id="L1556">                                                (poundIndex + 1, dotIndex));</span>
                        }
                    }
<span class="nc bnc" id="L1559" title="All 2 branches missed.">                    else if(poundIndex &lt; spaceIndex) {</span>
                        // .#
<span class="nc bnc" id="L1561" title="All 2 branches missed.">                        if (lastIndex == dotIndex) {</span>
<span class="nc" id="L1562">                            elements.addElement(&quot;&quot;);</span>
                        }
                        else {
<span class="nc" id="L1565">                            elements.addElement(selector.substring(lastIndex,</span>
                                                                  dotIndex));
                        }
<span class="nc bnc" id="L1568" title="All 2 branches missed.">                        if ((dotIndex + 1) &lt; poundIndex) {</span>
<span class="nc" id="L1569">                            elements.addElement(selector.substring</span>
<span class="nc" id="L1570">                                                (dotIndex + 1, poundIndex));</span>
                        }
                        else {
<span class="nc" id="L1573">                            elements.addElement(null);</span>
                        }
<span class="nc bnc" id="L1575" title="All 2 branches missed.">                        if ((poundIndex + 1) == spaceIndex) {</span>
<span class="nc" id="L1576">                            elements.addElement(null);</span>
                        }
                        else {
<span class="nc" id="L1579">                            elements.addElement(selector.substring</span>
<span class="nc" id="L1580">                                                (poundIndex + 1, spaceIndex));</span>
                        }
                    }
<span class="nc" id="L1583">                    dotIndex = poundIndex = spaceIndex + 1;</span>
                }
<span class="nc bnc" id="L1585" title="All 4 branches missed.">                else if (dotIndex != -1 &amp;&amp; dotIndex &lt; spaceIndex) {</span>
                    // .
<span class="nc bnc" id="L1587" title="All 2 branches missed.">                    if (dotIndex == lastIndex) {</span>
<span class="nc" id="L1588">                        elements.addElement(&quot;&quot;);</span>
                    }
                    else {
<span class="nc" id="L1591">                        elements.addElement(selector.substring(lastIndex,</span>
                                                               dotIndex));
                    }
<span class="nc bnc" id="L1594" title="All 2 branches missed.">                    if ((dotIndex + 1) == spaceIndex) {</span>
<span class="nc" id="L1595">                        elements.addElement(null);</span>
                    }
                    else {
<span class="nc" id="L1598">                        elements.addElement(selector.substring(dotIndex + 1,</span>
                                                               spaceIndex));
                    }
<span class="nc" id="L1601">                    elements.addElement(null);</span>
<span class="nc" id="L1602">                    dotIndex = spaceIndex + 1;</span>
                }
<span class="nc bnc" id="L1604" title="All 4 branches missed.">                else if (poundIndex != -1 &amp;&amp; poundIndex &lt; spaceIndex) {</span>
                    // #
<span class="nc bnc" id="L1606" title="All 2 branches missed.">                    if (poundIndex == lastIndex) {</span>
<span class="nc" id="L1607">                        elements.addElement(&quot;&quot;);</span>
                    }
                    else {
<span class="nc" id="L1610">                        elements.addElement(selector.substring(lastIndex,</span>
                                                               poundIndex));
                    }
<span class="nc" id="L1613">                    elements.addElement(null);</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">                    if ((poundIndex + 1) == spaceIndex) {</span>
<span class="nc" id="L1615">                        elements.addElement(null);</span>
                    }
                    else {
<span class="nc" id="L1618">                        elements.addElement(selector.substring(poundIndex + 1,</span>
                                                               spaceIndex));
                    }
<span class="nc" id="L1621">                    poundIndex = spaceIndex + 1;</span>
                }
                else {
                    // id
<span class="nc" id="L1625">                    elements.addElement(selector.substring(lastIndex,</span>
                                                           spaceIndex));
<span class="nc" id="L1627">                    elements.addElement(null);</span>
<span class="nc" id="L1628">                    elements.addElement(null);</span>
                }
<span class="nc" id="L1630">                lastIndex = spaceIndex + 1;</span>
            }
            // Create the tag, id, and class arrays.
<span class="nc" id="L1633">            int total = elements.size();</span>
<span class="nc" id="L1634">            int numTags = total / 3;</span>
<span class="nc" id="L1635">            String[] tags = new String[numTags];</span>
<span class="nc" id="L1636">            String[] ids = new String[numTags];</span>
<span class="nc" id="L1637">            String[] classes = new String[numTags];</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">            for (int index = 0, eIndex = total - 3; index &lt; numTags;</span>
<span class="nc" id="L1639">                 index++, eIndex -= 3) {</span>
<span class="nc" id="L1640">                tags[index] = elements.elementAt(eIndex);</span>
<span class="nc" id="L1641">                classes[index] = elements.elementAt(eIndex + 1);</span>
<span class="nc" id="L1642">                ids[index] = elements.elementAt(eIndex + 2);</span>
            }
<span class="nc" id="L1644">            return createResolvedStyle(selector, tags, ids, classes);</span>
        }
        finally {
<span class="nc" id="L1647">            SearchBuffer.releaseSearchBuffer(sb);</span>
        }
    }

    /**
     * Should be invoked when a new rule is added that did not previously
     * exist. Goes through and refreshes the necessary resolved
     * rules.
     */
    private synchronized void refreshResolvedRules(String selectorName,
                                                   String[] selector,
                                                   Style newStyle,
                                                   int specificity) {
<span class="nc bnc" id="L1660" title="All 2 branches missed.">        if (resolvedStyles.size() &gt; 0) {</span>
<span class="nc" id="L1661">            Enumeration&lt;ResolvedStyle&gt; values = resolvedStyles.elements();</span>
<span class="nc bnc" id="L1662" title="All 2 branches missed.">            while (values.hasMoreElements()) {</span>
<span class="nc" id="L1663">                ResolvedStyle style = values.nextElement();</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">                if (style.matches(selectorName)) {</span>
<span class="nc" id="L1665">                    style.insertStyle(newStyle, specificity);</span>
                }
<span class="nc" id="L1667">            }</span>
        }
<span class="nc" id="L1669">    }</span>


    /**
     * A temporary class used to hold a Vector, a StringBuffer and a
     * Hashtable. This is used to avoid allocing a lot of garbage when
     * searching for rules. Use the static method obtainSearchBuffer and
     * releaseSearchBuffer to get a SearchBuffer, and release it when
     * done.
     */
<span class="nc" id="L1679">    private static class SearchBuffer {</span>
        /** A stack containing instances of SearchBuffer. Used in getting
         * rules. */
<span class="nc" id="L1682">        static Stack&lt;SearchBuffer&gt; searchBuffers = new Stack&lt;SearchBuffer&gt;();</span>
        // A set of temporary variables that can be used in whatever way.
<span class="nc" id="L1684">        Vector vector = null;</span>
<span class="nc" id="L1685">        StringBuffer stringBuffer = null;</span>
<span class="nc" id="L1686">        Hashtable hashtable = null;</span>

        /**
         * Returns an instance of SearchBuffer. Be sure and issue
         * a releaseSearchBuffer when done with it.
         */
        static SearchBuffer obtainSearchBuffer() {
            SearchBuffer sb;
            try {
<span class="nc bnc" id="L1695" title="All 2 branches missed.">                if(!searchBuffers.empty()) {</span>
<span class="nc" id="L1696">                   sb = searchBuffers.pop();</span>
                } else {
<span class="nc" id="L1698">                   sb = new SearchBuffer();</span>
                }
<span class="nc" id="L1700">            } catch (EmptyStackException ese) {</span>
<span class="nc" id="L1701">                sb = new SearchBuffer();</span>
<span class="nc" id="L1702">            }</span>
<span class="nc" id="L1703">            return sb;</span>
        }

        /**
         * Adds &lt;code&gt;sb&lt;/code&gt; to the stack of SearchBuffers that can
         * be used.
         */
        static void releaseSearchBuffer(SearchBuffer sb) {
<span class="nc" id="L1711">            sb.empty();</span>
<span class="nc" id="L1712">            searchBuffers.push(sb);</span>
<span class="nc" id="L1713">        }</span>

        StringBuffer getStringBuffer() {
<span class="nc bnc" id="L1716" title="All 2 branches missed.">            if (stringBuffer == null) {</span>
<span class="nc" id="L1717">                stringBuffer = new StringBuffer();</span>
            }
<span class="nc" id="L1719">            return stringBuffer;</span>
        }

        Vector getVector() {
<span class="nc bnc" id="L1723" title="All 2 branches missed.">            if (vector == null) {</span>
<span class="nc" id="L1724">                vector = new Vector();</span>
            }
<span class="nc" id="L1726">            return vector;</span>
        }

        Hashtable getHashtable() {
<span class="nc bnc" id="L1730" title="All 2 branches missed.">            if (hashtable == null) {</span>
<span class="nc" id="L1731">                hashtable = new Hashtable();</span>
            }
<span class="nc" id="L1733">            return hashtable;</span>
        }

        void empty() {
<span class="nc bnc" id="L1737" title="All 2 branches missed.">            if (stringBuffer != null) {</span>
<span class="nc" id="L1738">                stringBuffer.setLength(0);</span>
            }
<span class="nc bnc" id="L1740" title="All 2 branches missed.">            if (vector != null) {</span>
<span class="nc" id="L1741">                vector.removeAllElements();</span>
            }
<span class="nc bnc" id="L1743" title="All 2 branches missed.">            if (hashtable != null) {</span>
<span class="nc" id="L1744">                hashtable.clear();</span>
            }
<span class="nc" id="L1746">        }</span>
    }


<span class="nc" id="L1750">    static final Border noBorder = new EmptyBorder(0,0,0,0);</span>

    /**
     * Class to carry out some of the duties of
     * CSS formatting.  Implementations of this
     * class enable views to present the CSS formatting
     * while not knowing anything about how the CSS values
     * are being cached.
     * &lt;p&gt;
     * As a delegate of Views, this object is responsible for
     * the insets of a View and making sure the background
     * is maintained according to the CSS attributes.
     */
    public static class BoxPainter implements Serializable {

<span class="nc" id="L1765">        BoxPainter(AttributeSet a, CSS css, StyleSheet ss) {</span>
<span class="nc" id="L1766">            this.ss = ss;</span>
<span class="nc" id="L1767">            this.css = css;</span>
<span class="nc" id="L1768">            border = getBorder(a);</span>
<span class="nc" id="L1769">            binsets = border.getBorderInsets(null);</span>
<span class="nc" id="L1770">            topMargin = getLength(CSS.Attribute.MARGIN_TOP, a);</span>
<span class="nc" id="L1771">            bottomMargin = getLength(CSS.Attribute.MARGIN_BOTTOM, a);</span>
<span class="nc" id="L1772">            leftMargin = getLength(CSS.Attribute.MARGIN_LEFT, a);</span>
<span class="nc" id="L1773">            rightMargin = getLength(CSS.Attribute.MARGIN_RIGHT, a);</span>
<span class="nc" id="L1774">            bg = ss.getBackground(a);</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">            if (ss.getBackgroundImage(a) != null) {</span>
<span class="nc" id="L1776">                bgPainter = new BackgroundImagePainter(a, css, ss);</span>
            }
<span class="nc" id="L1778">        }</span>

        /**
         * Fetches a border to render for the given attributes.
         * PENDING(prinz) This is pretty badly hacked at the
         * moment.
         */
        Border getBorder(AttributeSet a) {
<span class="nc" id="L1786">            return new CSSBorder(a);</span>
        }

        /**
         * Fetches the color to use for borders.  This will either be
         * the value specified by the border-color attribute (which
         * is not inherited), or it will default to the color attribute
         * (which is inherited).
         */
        Color getBorderColor(AttributeSet a) {
<span class="nc" id="L1796">            Color color = css.getColor(a, CSS.Attribute.BORDER_COLOR);</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">            if (color == null) {</span>
<span class="nc" id="L1798">                color = css.getColor(a, CSS.Attribute.COLOR);</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">                if (color == null) {</span>
<span class="nc" id="L1800">                    return Color.black;</span>
                }
            }
<span class="nc" id="L1803">            return color;</span>
        }

        /**
         * Fetches the inset needed on a given side to
         * account for the margin, border, and padding.
         *
         * @param side The size of the box to fetch the
         *  inset for.  This can be View.TOP,
         *  View.LEFT, View.BOTTOM, or View.RIGHT.
         * @param v the view making the request.  This is
         *  used to get the AttributeSet, and may be used to
         *  resolve percentage arguments.
         * @exception IllegalArgumentException for an invalid direction
         */
        public float getInset(int side, View v) {
<span class="nc" id="L1819">            AttributeSet a = v.getAttributes();</span>
<span class="nc" id="L1820">            float inset = 0;</span>
<span class="nc bnc" id="L1821" title="All 5 branches missed.">            switch(side) {</span>
            case View.LEFT:
<span class="nc" id="L1823">                inset += getOrientationMargin(HorizontalMargin.LEFT,</span>
<span class="nc" id="L1824">                                              leftMargin, a, isLeftToRight(v));</span>
<span class="nc" id="L1825">                inset += binsets.left;</span>
<span class="nc" id="L1826">                inset += getLength(CSS.Attribute.PADDING_LEFT, a);</span>
<span class="nc" id="L1827">                break;</span>
            case View.RIGHT:
<span class="nc" id="L1829">                inset += getOrientationMargin(HorizontalMargin.RIGHT,</span>
<span class="nc" id="L1830">                                              rightMargin, a, isLeftToRight(v));</span>
<span class="nc" id="L1831">                inset += binsets.right;</span>
<span class="nc" id="L1832">                inset += getLength(CSS.Attribute.PADDING_RIGHT, a);</span>
<span class="nc" id="L1833">                break;</span>
            case View.TOP:
<span class="nc" id="L1835">                inset += topMargin;</span>
<span class="nc" id="L1836">                inset += binsets.top;</span>
<span class="nc" id="L1837">                inset += getLength(CSS.Attribute.PADDING_TOP, a);</span>
<span class="nc" id="L1838">                break;</span>
            case View.BOTTOM:
<span class="nc" id="L1840">                inset += bottomMargin;</span>
<span class="nc" id="L1841">                inset += binsets.bottom;</span>
<span class="nc" id="L1842">                inset += getLength(CSS.Attribute.PADDING_BOTTOM, a);</span>
<span class="nc" id="L1843">                break;</span>
            default:
<span class="nc" id="L1845">                throw new IllegalArgumentException(&quot;Invalid side: &quot; + side);</span>
            }
<span class="nc" id="L1847">            return inset;</span>
        }

        /**
         * Paints the CSS box according to the attributes
         * given.  This should paint the border, padding,
         * and background.
         *
         * @param g the rendering surface.
         * @param x the x coordinate of the allocated area to
         *  render into.
         * @param y the y coordinate of the allocated area to
         *  render into.
         * @param w the width of the allocated area to render into.
         * @param h the height of the allocated area to render into.
         * @param v the view making the request.  This is
         *  used to get the AttributeSet, and may be used to
         *  resolve percentage arguments.
         */
        public void paint(Graphics g, float x, float y, float w, float h, View v) {
            // PENDING(prinz) implement real rendering... which would
            // do full set of border and background capabilities.
            // remove margin

<span class="nc" id="L1871">            float dx = 0;</span>
<span class="nc" id="L1872">            float dy = 0;</span>
<span class="nc" id="L1873">            float dw = 0;</span>
<span class="nc" id="L1874">            float dh = 0;</span>
<span class="nc" id="L1875">            AttributeSet a = v.getAttributes();</span>
<span class="nc" id="L1876">            boolean isLeftToRight = isLeftToRight(v);</span>
<span class="nc" id="L1877">            float localLeftMargin = getOrientationMargin(HorizontalMargin.LEFT,</span>
                                                         leftMargin,
                                                         a, isLeftToRight);
<span class="nc" id="L1880">            float localRightMargin = getOrientationMargin(HorizontalMargin.RIGHT,</span>
                                                          rightMargin,
                                                          a, isLeftToRight);
<span class="nc bnc" id="L1883" title="All 2 branches missed.">            if (!(v instanceof HTMLEditorKit.HTMLFactory.BodyBlockView)) {</span>
<span class="nc" id="L1884">                dx = localLeftMargin;</span>
<span class="nc" id="L1885">                dy = topMargin;</span>
<span class="nc" id="L1886">                dw = -(localLeftMargin + localRightMargin);</span>
<span class="nc" id="L1887">                dh = -(topMargin + bottomMargin);</span>
            }
<span class="nc bnc" id="L1889" title="All 2 branches missed.">            if (bg != null) {</span>
<span class="nc" id="L1890">                g.setColor(bg);</span>
<span class="nc" id="L1891">                g.fillRect((int) (x + dx),</span>
                           (int) (y + dy),
                           (int) (w + dw),
                           (int) (h + dh));
            }
<span class="nc bnc" id="L1896" title="All 2 branches missed.">            if (bgPainter != null) {</span>
<span class="nc" id="L1897">                bgPainter.paint(g, x + dx, y + dy, w + dw, h + dh, v);</span>
            }
<span class="nc" id="L1899">            x += localLeftMargin;</span>
<span class="nc" id="L1900">            y += topMargin;</span>
<span class="nc" id="L1901">            w -= localLeftMargin + localRightMargin;</span>
<span class="nc" id="L1902">            h -= topMargin + bottomMargin;</span>
<span class="nc bnc" id="L1903" title="All 2 branches missed.">            if (border instanceof BevelBorder) {</span>
                //BevelBorder does not support border width
<span class="nc" id="L1905">                int bw = (int) getLength(CSS.Attribute.BORDER_TOP_WIDTH, a);</span>
<span class="nc bnc" id="L1906" title="All 2 branches missed.">                for (int i = bw - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L1907">                    border.paintBorder(null, g, (int) x + i, (int) y + i,</span>
                                       (int) w - 2 * i, (int) h - 2 * i);
                }
<span class="nc" id="L1910">            } else {</span>
<span class="nc" id="L1911">                border.paintBorder(null, g, (int) x, (int) y, (int) w, (int) h);</span>
            }
<span class="nc" id="L1913">        }</span>

        float getLength(CSS.Attribute key, AttributeSet a) {
<span class="nc" id="L1916">            return css.getLength(a, key, ss);</span>
        }

        static boolean isLeftToRight(View v) {
<span class="nc" id="L1920">            boolean ret = true;</span>
<span class="nc bnc" id="L1921" title="All 2 branches missed.">            if (isOrientationAware(v)) {</span>
                Container container;
<span class="nc bnc" id="L1923" title="All 4 branches missed.">                if (v != null &amp;&amp; (container = v.getContainer()) != null) {</span>
<span class="nc" id="L1924">                    ret = container.getComponentOrientation().isLeftToRight();</span>
                }
            }
<span class="nc" id="L1927">            return ret;</span>
        }

        /*
         * only certain tags are concerned about orientation
         * &lt;dir&gt;, &lt;menu&gt;, &lt;ul&gt;, &lt;ol&gt;
         * for all others we return true. It is implemented this way
         * for performance purposes
         */
        static boolean isOrientationAware(View v) {
<span class="nc" id="L1937">            boolean ret = false;</span>
            AttributeSet attr;
            Object obj;
<span class="nc bnc" id="L1940" title="All 2 branches missed.">            if (v != null</span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">                &amp;&amp; (attr = v.getElement().getAttributes()) != null</span>
<span class="nc bnc" id="L1942" title="All 10 branches missed.">                &amp;&amp; (obj = attr.getAttribute(StyleConstants.NameAttribute)) instanceof HTML.Tag</span>
                &amp;&amp; (obj == HTML.Tag.DIR
                    || obj == HTML.Tag.MENU
                    || obj == HTML.Tag.UL
                    || obj == HTML.Tag.OL)) {
<span class="nc" id="L1947">                ret = true;</span>
            }

<span class="nc" id="L1950">            return ret;</span>
        }

<span class="nc" id="L1953">        static enum HorizontalMargin { LEFT, RIGHT }</span>

        /**
         * for &lt;dir&gt;, &lt;menu&gt;, &lt;ul&gt; etc.
         * margins are Left-To-Right/Right-To-Left depended.
         * see 5088268 for more details
         * margin-(left|right)-(ltr|rtl) were introduced to describe it
         * if margin-(left|right) is present we are to use it.
         *
         * @param side The horizontal side to fetch margin for
         *  This can be HorizontalMargin.LEFT or HorizontalMargin.RIGHT
         * @param cssMargin margin from css
         * @param a AttributeSet for the View we getting margin for
         * @param isLeftToRight
         * @return orientation depended margin
         */
        float getOrientationMargin(HorizontalMargin side, float cssMargin,
                                   AttributeSet a, boolean isLeftToRight) {
<span class="nc" id="L1971">            float margin = cssMargin;</span>
<span class="nc" id="L1972">            float orientationMargin = cssMargin;</span>
<span class="nc" id="L1973">            Object cssMarginValue = null;</span>
<span class="nc bnc" id="L1974" title="All 3 branches missed.">            switch (side) {</span>
            case RIGHT:
                {
<span class="nc bnc" id="L1977" title="All 2 branches missed.">                    orientationMargin = (isLeftToRight) ?</span>
<span class="nc" id="L1978">                        getLength(CSS.Attribute.MARGIN_RIGHT_LTR, a) :</span>
<span class="nc" id="L1979">                        getLength(CSS.Attribute.MARGIN_RIGHT_RTL, a);</span>
<span class="nc" id="L1980">                    cssMarginValue = a.getAttribute(CSS.Attribute.MARGIN_RIGHT);</span>
                }
<span class="nc" id="L1982">                break;</span>
            case LEFT :
                {
<span class="nc bnc" id="L1985" title="All 2 branches missed.">                    orientationMargin = (isLeftToRight) ?</span>
<span class="nc" id="L1986">                        getLength(CSS.Attribute.MARGIN_LEFT_LTR, a) :</span>
<span class="nc" id="L1987">                        getLength(CSS.Attribute.MARGIN_LEFT_RTL, a);</span>
<span class="nc" id="L1988">                    cssMarginValue = a.getAttribute(CSS.Attribute.MARGIN_LEFT);</span>
                }
                break;
            }

<span class="nc bnc" id="L1993" title="All 4 branches missed.">            if (cssMarginValue == null</span>
                &amp;&amp; orientationMargin != Integer.MIN_VALUE) {
<span class="nc" id="L1995">                margin = orientationMargin;</span>
            }
<span class="nc" id="L1997">            return margin;</span>
        }

        float topMargin;
        float bottomMargin;
        float leftMargin;
        float rightMargin;
        // Bitmask, used to indicate what margins are relative:
        // bit 0 for top, 1 for bottom, 2 for left and 3 for right.
        short marginFlags;
        Border border;
        Insets binsets;
        CSS css;
        StyleSheet ss;
        Color bg;
        BackgroundImagePainter bgPainter;
    }

    /**
     * Class to carry out some of the duties of CSS list
     * formatting.  Implementations of this
     * class enable views to present the CSS formatting
     * while not knowing anything about how the CSS values
     * are being cached.
     */
    public static class ListPainter implements Serializable {

<span class="nc" id="L2024">        ListPainter(AttributeSet attr, StyleSheet ss) {</span>
<span class="nc" id="L2025">            this.ss = ss;</span>
            /* Get the image to use as a list bullet */
<span class="nc" id="L2027">            String imgstr = (String)attr.getAttribute(CSS.Attribute.</span>
                                                      LIST_STYLE_IMAGE);
<span class="nc" id="L2029">            type = null;</span>
<span class="nc bnc" id="L2030" title="All 4 branches missed.">            if (imgstr != null &amp;&amp; !imgstr.equals(&quot;none&quot;)) {</span>
<span class="nc" id="L2031">                String tmpstr = null;</span>
                try {
<span class="nc" id="L2033">                    StringTokenizer st = new StringTokenizer(imgstr, &quot;()&quot;);</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">                    if (st.hasMoreTokens())</span>
<span class="nc" id="L2035">                        tmpstr = st.nextToken();</span>
<span class="nc bnc" id="L2036" title="All 2 branches missed.">                    if (st.hasMoreTokens())</span>
<span class="nc" id="L2037">                        tmpstr = st.nextToken();</span>
<span class="nc" id="L2038">                    URL u = new URL(tmpstr);</span>
<span class="nc" id="L2039">                    img = new ImageIcon(u);</span>
<span class="nc" id="L2040">                } catch (MalformedURLException e) {</span>
<span class="nc bnc" id="L2041" title="All 6 branches missed.">                    if (tmpstr != null &amp;&amp; ss != null &amp;&amp; ss.getBase() != null) {</span>
                        try {
<span class="nc" id="L2043">                            URL u = new URL(ss.getBase(), tmpstr);</span>
<span class="nc" id="L2044">                            img = new ImageIcon(u);</span>
<span class="nc" id="L2045">                        } catch (MalformedURLException murle) {</span>
<span class="nc" id="L2046">                            img = null;</span>
<span class="nc" id="L2047">                        }</span>
                    }
                    else {
<span class="nc" id="L2050">                        img = null;</span>
                    }
<span class="nc" id="L2052">                }</span>
            }

            /* Get the type of bullet to use in the list */
<span class="nc bnc" id="L2056" title="All 2 branches missed.">            if (img == null) {</span>
<span class="nc" id="L2057">                type = (CSS.Value)attr.getAttribute(CSS.Attribute.</span>
                                                    LIST_STYLE_TYPE);
            }
<span class="nc" id="L2060">            start = 1;</span>

<span class="nc" id="L2062">            paintRect = new Rectangle();</span>
<span class="nc" id="L2063">        }</span>

        /**
         * Returns a string that represents the value
         * of the HTML.Attribute.TYPE attribute.
         * If this attributes is not defined, then
         * then the type defaults to &quot;disc&quot; unless
         * the tag is on Ordered list.  In the case
         * of the latter, the default type is &quot;decimal&quot;.
         */
        private CSS.Value getChildType(View childView) {
<span class="nc" id="L2074">            CSS.Value childtype = (CSS.Value)childView.getAttributes().</span>
<span class="nc" id="L2075">                                  getAttribute(CSS.Attribute.LIST_STYLE_TYPE);</span>

<span class="nc bnc" id="L2077" title="All 2 branches missed.">            if (childtype == null) {</span>
<span class="nc bnc" id="L2078" title="All 2 branches missed.">                if (type == null) {</span>
                    // Parent view.
<span class="nc" id="L2080">                    View v = childView.getParent();</span>
<span class="nc" id="L2081">                    HTMLDocument doc = (HTMLDocument)v.getDocument();</span>
<span class="nc bnc" id="L2082" title="All 2 branches missed.">                    if (doc.matchNameAttribute(v.getElement().getAttributes(),</span>
                                               HTML.Tag.OL)) {
<span class="nc" id="L2084">                        childtype = CSS.Value.DECIMAL;</span>
                    } else {
<span class="nc" id="L2086">                        childtype = CSS.Value.DISC;</span>
                    }
<span class="nc" id="L2088">                } else {</span>
<span class="nc" id="L2089">                    childtype = type;</span>
                }
            }
<span class="nc" id="L2092">            return childtype;</span>
        }

        /**
         * Obtains the starting index from &lt;code&gt;parent&lt;/code&gt;.
         */
        private void getStart(View parent) {
<span class="nc" id="L2099">            checkedForStart = true;</span>
<span class="nc" id="L2100">            Element element = parent.getElement();</span>
<span class="nc bnc" id="L2101" title="All 2 branches missed.">            if (element != null) {</span>
<span class="nc" id="L2102">                AttributeSet attr = element.getAttributes();</span>
                Object startValue;
<span class="nc bnc" id="L2104" title="All 4 branches missed.">                if (attr != null &amp;&amp; attr.isDefined(HTML.Attribute.START) &amp;&amp;</span>
                    (startValue = attr.getAttribute
<span class="nc bnc" id="L2106" title="All 4 branches missed.">                     (HTML.Attribute.START)) != null &amp;&amp;</span>
                    (startValue instanceof String)) {

                    try {
<span class="nc" id="L2110">                        start = Integer.parseInt((String)startValue);</span>
                    }
<span class="nc" id="L2112">                    catch (NumberFormatException nfe) {}</span>
                }
            }
<span class="nc" id="L2115">        }</span>

        /**
         * Returns an integer that should be used to render the child at
         * &lt;code&gt;childIndex&lt;/code&gt; with. The retValue will usually be
         * &lt;code&gt;childIndex&lt;/code&gt; + 1, unless &lt;code&gt;parentView&lt;/code&gt;
         * has some Views that do not represent LI's, or one of the views
         * has a HTML.Attribute.START specified.
         */
        private int getRenderIndex(View parentView, int childIndex) {
<span class="nc bnc" id="L2125" title="All 2 branches missed.">            if (!checkedForStart) {</span>
<span class="nc" id="L2126">                getStart(parentView);</span>
            }
<span class="nc" id="L2128">            int retIndex = childIndex;</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">            for (int counter = childIndex; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L2130">                AttributeSet as = parentView.getElement().getElement(counter).</span>
<span class="nc" id="L2131">                                  getAttributes();</span>
<span class="nc bnc" id="L2132" title="All 2 branches missed.">                if (as.getAttribute(StyleConstants.NameAttribute) !=</span>
                    HTML.Tag.LI) {
<span class="nc" id="L2134">                    retIndex--;</span>
<span class="nc bnc" id="L2135" title="All 2 branches missed.">                } else if (as.isDefined(HTML.Attribute.VALUE)) {</span>
<span class="nc" id="L2136">                    Object value = as.getAttribute(HTML.Attribute.VALUE);</span>
<span class="nc bnc" id="L2137" title="All 4 branches missed.">                    if (value != null &amp;&amp;</span>
                        (value instanceof String)) {
                        try {
<span class="nc" id="L2140">                            int iValue = Integer.parseInt((String)value);</span>
<span class="nc" id="L2141">                            return retIndex - counter + iValue;</span>
                        }
<span class="nc" id="L2143">                        catch (NumberFormatException nfe) {}</span>
                    }
                }
            }
<span class="nc" id="L2147">            return retIndex + start;</span>
        }

        /**
         * Paints the CSS list decoration according to the
         * attributes given.
         *
         * @param g the rendering surface.
         * @param x the x coordinate of the list item allocation
         * @param y the y coordinate of the list item allocation
         * @param w the width of the list item allocation
         * @param h the height of the list item allocation
         * @param v the allocated area to paint into.
         * @param item which list item is being painted.  This
         *  is a number greater than or equal to 0.
         */
        public void paint(Graphics g, float x, float y, float w, float h, View v, int item) {
<span class="nc" id="L2164">            View cv = v.getView(item);</span>
<span class="nc" id="L2165">            Container host = v.getContainer();</span>
<span class="nc" id="L2166">            Object name = cv.getElement().getAttributes().getAttribute</span>
<span class="nc" id="L2167">                         (StyleConstants.NameAttribute);</span>
            // Only draw something if the View is a list item. This won't
            // be the case for comments.
<span class="nc bnc" id="L2170" title="All 4 branches missed.">            if (!(name instanceof HTML.Tag) ||</span>
                name != HTML.Tag.LI) {
<span class="nc" id="L2172">                return;</span>
            }
            // deside on what side draw bullets, etc.
<span class="nc" id="L2175">            isLeftToRight =</span>
<span class="nc" id="L2176">                host.getComponentOrientation().isLeftToRight();</span>

            // How the list indicator is aligned is not specified, it is
            // left up to the UA. IE and NS differ on this behavior.
            // This is closer to NS where we align to the first line of text.
            // If the child is not text we draw the indicator at the
            // origin (0).
<span class="nc" id="L2183">            float align = 0;</span>
<span class="nc bnc" id="L2184" title="All 2 branches missed.">            if (cv.getViewCount() &gt; 0) {</span>
<span class="nc" id="L2185">                View pView = cv.getView(0);</span>
<span class="nc" id="L2186">                Object cName = pView.getElement().getAttributes().</span>
<span class="nc" id="L2187">                               getAttribute(StyleConstants.NameAttribute);</span>
<span class="nc bnc" id="L2188" title="All 4 branches missed.">                if ((cName == HTML.Tag.P || cName == HTML.Tag.IMPLIED) &amp;&amp;</span>
<span class="nc bnc" id="L2189" title="All 2 branches missed.">                              pView.getViewCount() &gt; 0) {</span>
<span class="nc" id="L2190">                    paintRect.setBounds((int)x, (int)y, (int)w, (int)h);</span>
<span class="nc" id="L2191">                    Shape shape = cv.getChildAllocation(0, paintRect);</span>
<span class="nc bnc" id="L2192" title="All 2 branches missed.">                    if (shape != null &amp;&amp; (shape = pView.getView(0).</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">                                 getChildAllocation(0, shape)) != null) {</span>
<span class="nc bnc" id="L2194" title="All 2 branches missed.">                        Rectangle rect = (shape instanceof Rectangle) ?</span>
<span class="nc" id="L2195">                                         (Rectangle)shape : shape.getBounds();</span>

<span class="nc" id="L2197">                        align = pView.getView(0).getAlignment(View.Y_AXIS);</span>
<span class="nc" id="L2198">                        y = rect.y;</span>
<span class="nc" id="L2199">                        h = rect.height;</span>
                    }
                }
            }

            // set the color of a decoration
<span class="nc bnc" id="L2205" title="All 4 branches missed.">            Color c = (host.isEnabled()</span>
                ? (ss != null
<span class="nc" id="L2207">                    ? ss.getForeground(cv.getAttributes())</span>
<span class="nc" id="L2208">                    : host.getForeground())</span>
<span class="nc" id="L2209">                : UIManager.getColor(&quot;textInactiveText&quot;));</span>
<span class="nc" id="L2210">            g.setColor(c);</span>

<span class="nc bnc" id="L2212" title="All 2 branches missed.">            if (img != null) {</span>
<span class="nc" id="L2213">                drawIcon(g, (int) x, (int) y, (int) w, (int) h, align, host);</span>
<span class="nc" id="L2214">                return;</span>
            }
<span class="nc" id="L2216">            CSS.Value childtype = getChildType(cv);</span>
<span class="nc" id="L2217">            Font font = ((StyledDocument)cv.getDocument()).</span>
<span class="nc" id="L2218">                                         getFont(cv.getAttributes());</span>
<span class="nc bnc" id="L2219" title="All 2 branches missed.">            if (font != null) {</span>
<span class="nc" id="L2220">                g.setFont(font);</span>
            }
<span class="nc bnc" id="L2222" title="All 6 branches missed.">            if (childtype == CSS.Value.SQUARE || childtype == CSS.Value.CIRCLE</span>
                || childtype == CSS.Value.DISC) {
<span class="nc" id="L2224">                drawShape(g, childtype, (int) x, (int) y,</span>
                          (int) w, (int) h, align);
<span class="nc bnc" id="L2226" title="All 2 branches missed.">            } else if (childtype == CSS.Value.DECIMAL) {</span>
<span class="nc" id="L2227">                drawLetter(g, '1', (int) x, (int) y, (int) w, (int) h, align,</span>
<span class="nc" id="L2228">                           getRenderIndex(v, item));</span>
<span class="nc bnc" id="L2229" title="All 2 branches missed.">            } else if (childtype == CSS.Value.LOWER_ALPHA) {</span>
<span class="nc" id="L2230">                drawLetter(g, 'a', (int) x, (int) y, (int) w, (int) h, align,</span>
<span class="nc" id="L2231">                           getRenderIndex(v, item));</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">            } else if (childtype == CSS.Value.UPPER_ALPHA) {</span>
<span class="nc" id="L2233">                drawLetter(g, 'A', (int) x, (int) y, (int) w, (int) h, align,</span>
<span class="nc" id="L2234">                           getRenderIndex(v, item));</span>
<span class="nc bnc" id="L2235" title="All 2 branches missed.">            } else if (childtype == CSS.Value.LOWER_ROMAN) {</span>
<span class="nc" id="L2236">                drawLetter(g, 'i', (int) x, (int) y, (int) w, (int) h, align,</span>
<span class="nc" id="L2237">                           getRenderIndex(v, item));</span>
<span class="nc bnc" id="L2238" title="All 2 branches missed.">            } else if (childtype == CSS.Value.UPPER_ROMAN) {</span>
<span class="nc" id="L2239">                drawLetter(g, 'I', (int) x, (int) y, (int) w, (int) h, align,</span>
<span class="nc" id="L2240">                           getRenderIndex(v, item));</span>
            }
<span class="nc" id="L2242">        }</span>

        /**
         * Draws the bullet icon specified by the list-style-image argument.
         *
         * @param g     the graphics context
         * @param ax    x coordinate to place the bullet
         * @param ay    y coordinate to place the bullet
         * @param aw    width of the container the bullet is placed in
         * @param ah    height of the container the bullet is placed in
         * @param align preferred alignment factor for the child view
         */
        void drawIcon(Graphics g, int ax, int ay, int aw, int ah,
                      float align, Component c) {
            // Align to bottom of icon.
<span class="nc bnc" id="L2257" title="All 2 branches missed.">            int gap = isLeftToRight ? - (img.getIconWidth() + bulletgap) :</span>
                                        (aw + bulletgap);
<span class="nc" id="L2259">            int x = ax + gap;</span>
<span class="nc" id="L2260">            int y = Math.max(ay, ay + (int)(align * ah) -img.getIconHeight());</span>

<span class="nc" id="L2262">            img.paintIcon(c, g, x, y);</span>
<span class="nc" id="L2263">        }</span>

        /**
         * Draws the graphical bullet item specified by the type argument.
         *
         * @param g     the graphics context
         * @param type  type of bullet to draw (circle, square, disc)
         * @param ax    x coordinate to place the bullet
         * @param ay    y coordinate to place the bullet
         * @param aw    width of the container the bullet is placed in
         * @param ah    height of the container the bullet is placed in
         * @param align preferred alignment factor for the child view
         */
        void drawShape(Graphics g, CSS.Value type, int ax, int ay, int aw,
                       int ah, float align) {
            // Align to bottom of shape.
<span class="nc bnc" id="L2279" title="All 2 branches missed.">            int gap = isLeftToRight ? - (bulletgap + 8) : (aw + bulletgap);</span>
<span class="nc" id="L2280">            int x = ax + gap;</span>
<span class="nc" id="L2281">            int y = Math.max(ay, ay + (int)(align * ah) - 8);</span>

<span class="nc bnc" id="L2283" title="All 2 branches missed.">            if (type == CSS.Value.SQUARE) {</span>
<span class="nc" id="L2284">                g.drawRect(x, y, 8, 8);</span>
<span class="nc bnc" id="L2285" title="All 2 branches missed.">            } else if (type == CSS.Value.CIRCLE) {</span>
<span class="nc" id="L2286">                g.drawOval(x, y, 8, 8);</span>
            } else {
<span class="nc" id="L2288">                g.fillOval(x, y, 8, 8);</span>
            }
<span class="nc" id="L2290">        }</span>

        /**
         * Draws the letter or number for an ordered list.
         *
         * @param g     the graphics context
         * @param letter type of ordered list to draw
         * @param ax    x coordinate to place the bullet
         * @param ay    y coordinate to place the bullet
         * @param aw    width of the container the bullet is placed in
         * @param ah    height of the container the bullet is placed in
         * @param index position of the list item in the list
         */
        void drawLetter(Graphics g, char letter, int ax, int ay, int aw,
                        int ah, float align, int index) {
<span class="nc" id="L2305">            String str = formatItemNum(index, letter);</span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">            str = isLeftToRight ? str + &quot;.&quot; : &quot;.&quot; + str;</span>
<span class="nc" id="L2307">            FontMetrics fm = SwingUtilities2.getFontMetrics(null, g);</span>
<span class="nc" id="L2308">            int stringwidth = SwingUtilities2.stringWidth(null, fm, str);</span>
<span class="nc bnc" id="L2309" title="All 2 branches missed.">            int gap = isLeftToRight ? - (stringwidth + bulletgap) :</span>
                                        (aw + bulletgap);
<span class="nc" id="L2311">            int x = ax + gap;</span>
<span class="nc" id="L2312">            int y = Math.max(ay + fm.getAscent(), ay + (int)(ah * align));</span>
<span class="nc" id="L2313">            SwingUtilities2.drawString(null, g, str, x, y);</span>
<span class="nc" id="L2314">        }</span>

        /**
         * Converts the item number into the ordered list number
         * (i.e.  1 2 3, i ii iii, a b c, etc.
         *
         * @param itemNum number to format
         * @param type    type of ordered list
         */
        String formatItemNum(int itemNum, char type) {
<span class="nc" id="L2324">            String numStyle = &quot;1&quot;;</span>

<span class="nc" id="L2326">            boolean uppercase = false;</span>

            String formattedNum;

<span class="nc bnc" id="L2330" title="All 5 branches missed.">            switch (type) {</span>
            case '1':
            default:
<span class="nc" id="L2333">                formattedNum = String.valueOf(itemNum);</span>
<span class="nc" id="L2334">                break;</span>

            case 'A':
<span class="nc" id="L2337">                uppercase = true;</span>
                // fall through
            case 'a':
<span class="nc" id="L2340">                formattedNum = formatAlphaNumerals(itemNum);</span>
<span class="nc" id="L2341">                break;</span>

            case 'I':
<span class="nc" id="L2344">                uppercase = true;</span>
                // fall through
            case 'i':
<span class="nc" id="L2347">                formattedNum = formatRomanNumerals(itemNum);</span>
            }

<span class="nc bnc" id="L2350" title="All 2 branches missed.">            if (uppercase) {</span>
<span class="nc" id="L2351">                formattedNum = formattedNum.toUpperCase();</span>
            }

<span class="nc" id="L2354">            return formattedNum;</span>
        }

        /**
         * Converts the item number into an alphabetic character
         *
         * @param itemNum number to format
         */
        String formatAlphaNumerals(int itemNum) {
            String result;

<span class="nc bnc" id="L2365" title="All 2 branches missed.">            if (itemNum &gt; 26) {</span>
<span class="nc" id="L2366">                result = formatAlphaNumerals(itemNum / 26) +</span>
<span class="nc" id="L2367">                    formatAlphaNumerals(itemNum % 26);</span>
            } else {
                // -1 because item is 1 based.
<span class="nc" id="L2370">                result = String.valueOf((char)('a' + itemNum - 1));</span>
            }

<span class="nc" id="L2373">            return result;</span>
        }

        /* list of roman numerals */
<span class="nc" id="L2377">        static final char romanChars[][] = {</span>
            {'i', 'v'},
            {'x', 'l' },
            {'c', 'd' },
            {'m', '?' },
        };

        /**
         * Converts the item number into a roman numeral
         *
         * @param num  number to format
         */
        String formatRomanNumerals(int num) {
<span class="nc" id="L2390">            return formatRomanNumerals(0, num);</span>
        }

        /**
         * Converts the item number into a roman numeral
         *
         * @param num  number to format
         */
        String formatRomanNumerals(int level, int num) {
<span class="nc bnc" id="L2399" title="All 2 branches missed.">            if (num &lt; 10) {</span>
<span class="nc" id="L2400">                return formatRomanDigit(level, num);</span>
            } else {
<span class="nc" id="L2402">                return formatRomanNumerals(level + 1, num / 10) +</span>
<span class="nc" id="L2403">                    formatRomanDigit(level, num % 10);</span>
            }
        }


        /**
         * Converts the item number into a roman numeral
         *
         * @param level position
         * @param digit digit to format
         */
        String formatRomanDigit(int level, int digit) {
<span class="nc" id="L2415">            String result = &quot;&quot;;</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">            if (digit == 9) {</span>
<span class="nc" id="L2417">                result = result + romanChars[level][0];</span>
<span class="nc" id="L2418">                result = result + romanChars[level + 1][0];</span>
<span class="nc" id="L2419">                return result;</span>
<span class="nc bnc" id="L2420" title="All 2 branches missed.">            } else if (digit == 4) {</span>
<span class="nc" id="L2421">                result = result + romanChars[level][0];</span>
<span class="nc" id="L2422">                result = result + romanChars[level][1];</span>
<span class="nc" id="L2423">                return result;</span>
<span class="nc bnc" id="L2424" title="All 2 branches missed.">            } else if (digit &gt;= 5) {</span>
<span class="nc" id="L2425">                result = result + romanChars[level][1];</span>
<span class="nc" id="L2426">                digit -= 5;</span>
            }

<span class="nc bnc" id="L2429" title="All 2 branches missed.">            for (int i = 0; i &lt; digit; i++) {</span>
<span class="nc" id="L2430">                result = result + romanChars[level][0];</span>
            }

<span class="nc" id="L2433">            return result;</span>
        }

        private Rectangle paintRect;
        private boolean checkedForStart;
        private int start;
        private CSS.Value type;
        URL imageurl;
<span class="nc" id="L2441">        private StyleSheet ss = null;</span>
<span class="nc" id="L2442">        Icon img = null;</span>
<span class="nc" id="L2443">        private int bulletgap = 5;</span>
        private boolean isLeftToRight;
    }


    /**
     * Paints the background image.
     */
    static class BackgroundImagePainter implements Serializable {
        ImageIcon   backgroundImage;
        float       hPosition;
        float       vPosition;
        // bit mask: 0 for repeat x, 1 for repeat y, 2 for horiz relative,
        // 3 for vert relative
        short       flags;
        // These are used when painting, updatePaintCoordinates updates them.
        private int paintX;
        private int paintY;
        private int paintMaxX;
        private int paintMaxY;

<span class="nc" id="L2464">        BackgroundImagePainter(AttributeSet a, CSS css, StyleSheet ss) {</span>
<span class="nc" id="L2465">            backgroundImage = ss.getBackgroundImage(a);</span>
            // Determine the position.
<span class="nc" id="L2467">            CSS.BackgroundPosition pos = (CSS.BackgroundPosition)a.getAttribute</span>
<span class="nc" id="L2468">                                           (CSS.Attribute.BACKGROUND_POSITION);</span>
<span class="nc bnc" id="L2469" title="All 2 branches missed.">            if (pos != null) {</span>
<span class="nc" id="L2470">                hPosition = pos.getHorizontalPosition();</span>
<span class="nc" id="L2471">                vPosition = pos.getVerticalPosition();</span>
<span class="nc bnc" id="L2472" title="All 2 branches missed.">                if (pos.isHorizontalPositionRelativeToSize()) {</span>
<span class="nc" id="L2473">                    flags |= 4;</span>
                }
<span class="nc bnc" id="L2475" title="All 2 branches missed.">                else if (pos.isHorizontalPositionRelativeToSize()) {</span>
<span class="nc" id="L2476">                    hPosition *= css.getFontSize(a, 12, ss);</span>
                }
<span class="nc bnc" id="L2478" title="All 2 branches missed.">                if (pos.isVerticalPositionRelativeToSize()) {</span>
<span class="nc" id="L2479">                    flags |= 8;</span>
                }
<span class="nc bnc" id="L2481" title="All 2 branches missed.">                else if (pos.isVerticalPositionRelativeToFontSize()) {</span>
<span class="nc" id="L2482">                    vPosition *= css.getFontSize(a, 12, ss);</span>
                }
            }
            // Determine any repeating values.
<span class="nc" id="L2486">            CSS.Value repeats = (CSS.Value)a.getAttribute(CSS.Attribute.</span>
                                                          BACKGROUND_REPEAT);
<span class="nc bnc" id="L2488" title="All 4 branches missed.">            if (repeats == null || repeats == CSS.Value.BACKGROUND_REPEAT) {</span>
<span class="nc" id="L2489">                flags |= 3;</span>
            }
<span class="nc bnc" id="L2491" title="All 2 branches missed.">            else if (repeats == CSS.Value.BACKGROUND_REPEAT_X) {</span>
<span class="nc" id="L2492">                flags |= 1;</span>
            }
<span class="nc bnc" id="L2494" title="All 2 branches missed.">            else if (repeats == CSS.Value.BACKGROUND_REPEAT_Y) {</span>
<span class="nc" id="L2495">                flags |= 2;</span>
            }
<span class="nc" id="L2497">        }</span>

        void paint(Graphics g, float x, float y, float w, float h, View v) {
<span class="nc" id="L2500">            Rectangle clip = g.getClipRect();</span>
<span class="nc bnc" id="L2501" title="All 2 branches missed.">            if (clip != null) {</span>
                // Constrain the clip so that images don't draw outside the
                // legal bounds.
<span class="nc" id="L2504">                g.clipRect((int)x, (int)y, (int)w, (int)h);</span>
            }
<span class="nc bnc" id="L2506" title="All 2 branches missed.">            if ((flags &amp; 3) == 0) {</span>
                // no repeating
<span class="nc" id="L2508">                int width = backgroundImage.getIconWidth();</span>
<span class="nc" id="L2509">                int height = backgroundImage.getIconWidth();</span>
<span class="nc bnc" id="L2510" title="All 2 branches missed.">                if ((flags &amp; 4) == 4) {</span>
<span class="nc" id="L2511">                    paintX = (int)(x + w * hPosition -</span>
                                  (float)width * hPosition);
                }
                else {
<span class="nc" id="L2515">                    paintX = (int)x + (int)hPosition;</span>
                }
<span class="nc bnc" id="L2517" title="All 2 branches missed.">                if ((flags &amp; 8) == 8) {</span>
<span class="nc" id="L2518">                    paintY = (int)(y + h * vPosition -</span>
                                  (float)height * vPosition);
                }
                else {
<span class="nc" id="L2522">                    paintY = (int)y + (int)vPosition;</span>
                }
<span class="nc bnc" id="L2524" title="All 10 branches missed.">                if (clip == null ||</span>
                    !((paintX + width &lt;= clip.x) ||
                      (paintY + height &lt;= clip.y) ||
                      (paintX &gt;= clip.x + clip.width) ||
                      (paintY &gt;= clip.y + clip.height))) {
<span class="nc" id="L2529">                    backgroundImage.paintIcon(null, g, paintX, paintY);</span>
                }
<span class="nc" id="L2531">            }</span>
            else {
<span class="nc" id="L2533">                int width = backgroundImage.getIconWidth();</span>
<span class="nc" id="L2534">                int height = backgroundImage.getIconHeight();</span>
<span class="nc bnc" id="L2535" title="All 4 branches missed.">                if (width &gt; 0 &amp;&amp; height &gt; 0) {</span>
<span class="nc" id="L2536">                    paintX = (int)x;</span>
<span class="nc" id="L2537">                    paintY = (int)y;</span>
<span class="nc" id="L2538">                    paintMaxX = (int)(x + w);</span>
<span class="nc" id="L2539">                    paintMaxY = (int)(y + h);</span>
<span class="nc bnc" id="L2540" title="All 2 branches missed.">                    if (updatePaintCoordinates(clip, width, height)) {</span>
<span class="nc bnc" id="L2541" title="All 2 branches missed.">                        while (paintX &lt; paintMaxX) {</span>
<span class="nc" id="L2542">                            int ySpot = paintY;</span>
<span class="nc bnc" id="L2543" title="All 2 branches missed.">                            while (ySpot &lt; paintMaxY) {</span>
<span class="nc" id="L2544">                                backgroundImage.paintIcon(null, g, paintX,</span>
                                                          ySpot);
<span class="nc" id="L2546">                                ySpot += height;</span>
                            }
<span class="nc" id="L2548">                            paintX += width;</span>
<span class="nc" id="L2549">                        }</span>
                    }
                }
            }
<span class="nc bnc" id="L2553" title="All 2 branches missed.">            if (clip != null) {</span>
                // Reset clip.
<span class="nc" id="L2555">                g.setClip(clip.x, clip.y, clip.width, clip.height);</span>
            }
<span class="nc" id="L2557">        }</span>

        private boolean updatePaintCoordinates
                 (Rectangle clip, int width, int height){
<span class="nc bnc" id="L2561" title="All 2 branches missed.">            if ((flags &amp; 3) == 1) {</span>
<span class="nc" id="L2562">                paintMaxY = paintY + 1;</span>
            }
<span class="nc bnc" id="L2564" title="All 2 branches missed.">            else if ((flags &amp; 3) == 2) {</span>
<span class="nc" id="L2565">                paintMaxX = paintX + 1;</span>
            }
<span class="nc bnc" id="L2567" title="All 2 branches missed.">            if (clip != null) {</span>
<span class="nc bnc" id="L2568" title="All 6 branches missed.">                if ((flags &amp; 3) == 1 &amp;&amp; ((paintY + height &lt;= clip.y) ||</span>
                                         (paintY &gt; clip.y + clip.height))) {
                    // not visible.
<span class="nc" id="L2571">                    return false;</span>
                }
<span class="nc bnc" id="L2573" title="All 6 branches missed.">                if ((flags &amp; 3) == 2 &amp;&amp; ((paintX + width &lt;= clip.x) ||</span>
                                         (paintX &gt; clip.x + clip.width))) {
                    // not visible.
<span class="nc" id="L2576">                    return false;</span>
                }
<span class="nc bnc" id="L2578" title="All 2 branches missed.">                if ((flags &amp; 1) == 1) {</span>
<span class="nc bnc" id="L2579" title="All 2 branches missed.">                    if ((clip.x + clip.width) &lt; paintMaxX) {</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">                        if ((clip.x + clip.width - paintX) % width == 0) {</span>
<span class="nc" id="L2581">                            paintMaxX = clip.x + clip.width;</span>
                        }
                        else {
<span class="nc" id="L2584">                            paintMaxX = ((clip.x + clip.width - paintX) /</span>
                                         width + 1) * width + paintX;
                        }
                    }
<span class="nc bnc" id="L2588" title="All 2 branches missed.">                    if (clip.x &gt; paintX) {</span>
<span class="nc" id="L2589">                        paintX = (clip.x - paintX) / width * width + paintX;</span>
                    }
                }
<span class="nc bnc" id="L2592" title="All 2 branches missed.">                if ((flags &amp; 2) == 2) {</span>
<span class="nc bnc" id="L2593" title="All 2 branches missed.">                    if ((clip.y + clip.height) &lt; paintMaxY) {</span>
<span class="nc bnc" id="L2594" title="All 2 branches missed.">                        if ((clip.y + clip.height - paintY) % height == 0) {</span>
<span class="nc" id="L2595">                            paintMaxY = clip.y + clip.height;</span>
                        }
                        else {
<span class="nc" id="L2598">                            paintMaxY = ((clip.y + clip.height - paintY) /</span>
                                         height + 1) * height + paintY;
                        }
                    }
<span class="nc bnc" id="L2602" title="All 2 branches missed.">                    if (clip.y &gt; paintY) {</span>
<span class="nc" id="L2603">                        paintY = (clip.y - paintY) / height * height + paintY;</span>
                    }
                }
            }
            // Valid
<span class="nc" id="L2608">            return true;</span>
        }
    }


    /**
     * A subclass of MuxingAttributeSet that translates between
     * CSS and HTML and StyleConstants. The AttributeSets used are
     * the CSS rules that match the Views Elements.
     */
    class ViewAttributeSet extends MuxingAttributeSet {
<span class="nc" id="L2619">        ViewAttributeSet(View v) {</span>
<span class="nc" id="L2620">            host = v;</span>

            // PENDING(prinz) fix this up to be a more realistic
            // implementation.
<span class="nc" id="L2624">            Document doc = v.getDocument();</span>
<span class="nc" id="L2625">            SearchBuffer sb = SearchBuffer.obtainSearchBuffer();</span>
<span class="nc" id="L2626">            Vector&lt;AttributeSet&gt; muxList = sb.getVector();</span>
            try {
<span class="nc bnc" id="L2628" title="All 2 branches missed.">                if (doc instanceof HTMLDocument) {</span>
<span class="nc" id="L2629">                    StyleSheet styles = StyleSheet.this;</span>
<span class="nc" id="L2630">                    Element elem = v.getElement();</span>
<span class="nc" id="L2631">                    AttributeSet a = elem.getAttributes();</span>
<span class="nc" id="L2632">                    AttributeSet htmlAttr = styles.translateHTMLToCSS(a);</span>

<span class="nc bnc" id="L2634" title="All 2 branches missed.">                    if (htmlAttr.getAttributeCount() != 0) {</span>
<span class="nc" id="L2635">                        muxList.addElement(htmlAttr);</span>
                    }
<span class="nc bnc" id="L2637" title="All 2 branches missed.">                    if (elem.isLeaf()) {</span>
<span class="nc" id="L2638">                        Enumeration keys = a.getAttributeNames();</span>
<span class="nc bnc" id="L2639" title="All 2 branches missed.">                        while (keys.hasMoreElements()) {</span>
<span class="nc" id="L2640">                            Object key = keys.nextElement();</span>
<span class="nc bnc" id="L2641" title="All 2 branches missed.">                            if (key instanceof HTML.Tag) {</span>
<span class="nc bnc" id="L2642" title="All 2 branches missed.">                                if (key == HTML.Tag.A) {</span>
<span class="nc" id="L2643">                                    Object o = a.getAttribute(key);</span>
                                /**
                                   In the case of an A tag, the css rules
                                   apply only for tags that have their
                                   href attribute defined and not for
                                   anchors that only have their name attributes
                                   defined, i.e anchors that function as
                                   destinations.  Hence we do not add the
                                   attributes for that latter kind of
                                   anchors.  When CSS2 support is added,
                                   it will be possible to specificity this
                                   kind of conditional behaviour in the
                                   stylesheet.
                                 **/
<span class="nc bnc" id="L2657" title="All 4 branches missed.">                                    if (o != null &amp;&amp; o instanceof AttributeSet) {</span>
<span class="nc" id="L2658">                                        AttributeSet attr = (AttributeSet)o;</span>
<span class="nc bnc" id="L2659" title="All 2 branches missed.">                                        if (attr.getAttribute(HTML.Attribute.HREF) == null) {</span>
<span class="nc" id="L2660">                                            continue;</span>
                                        }
                                    }
                                }
<span class="nc" id="L2664">                                AttributeSet cssRule = styles.getRule((HTML.Tag) key, elem);</span>
<span class="nc bnc" id="L2665" title="All 2 branches missed.">                                if (cssRule != null) {</span>
<span class="nc" id="L2666">                                    muxList.addElement(cssRule);</span>
                                }
                            }
<span class="nc" id="L2669">                        }</span>
<span class="nc" id="L2670">                    } else {</span>
<span class="nc" id="L2671">                        HTML.Tag t = (HTML.Tag) a.getAttribute</span>
<span class="nc" id="L2672">                                     (StyleConstants.NameAttribute);</span>
<span class="nc" id="L2673">                        AttributeSet cssRule = styles.getRule(t, elem);</span>
<span class="nc bnc" id="L2674" title="All 2 branches missed.">                        if (cssRule != null) {</span>
<span class="nc" id="L2675">                            muxList.addElement(cssRule);</span>
                        }
                    }
                }
<span class="nc" id="L2679">                AttributeSet[] attrs = new AttributeSet[muxList.size()];</span>
<span class="nc" id="L2680">                muxList.copyInto(attrs);</span>
<span class="nc" id="L2681">                setAttributes(attrs);</span>
            }
            finally {
<span class="nc" id="L2684">                SearchBuffer.releaseSearchBuffer(sb);</span>
<span class="nc" id="L2685">            }</span>
<span class="nc" id="L2686">        }</span>

        //  --- AttributeSet methods ----------------------------

        /**
         * Checks whether a given attribute is defined.
         * This will convert the key over to CSS if the
         * key is a StyleConstants key that has a CSS
         * mapping.
         *
         * @param key the attribute key
         * @return true if the attribute is defined
         * @see AttributeSet#isDefined
         */
        public boolean isDefined(Object key) {
<span class="nc bnc" id="L2701" title="All 2 branches missed.">            if (key instanceof StyleConstants) {</span>
<span class="nc" id="L2702">                Object cssKey = css.styleConstantsKeyToCSSKey</span>
<span class="nc" id="L2703">                                    ((StyleConstants)key);</span>
<span class="nc bnc" id="L2704" title="All 2 branches missed.">                if (cssKey != null) {</span>
<span class="nc" id="L2705">                    key = cssKey;</span>
                }
            }
<span class="nc" id="L2708">            return super.isDefined(key);</span>
        }

        /**
         * Gets the value of an attribute.  If the requested
         * attribute is a StyleConstants attribute that has
         * a CSS mapping, the request will be converted.
         *
         * @param key the attribute name
         * @return the attribute value
         * @see AttributeSet#getAttribute
         */
        public Object getAttribute(Object key) {
<span class="nc bnc" id="L2721" title="All 2 branches missed.">            if (key instanceof StyleConstants) {</span>
<span class="nc" id="L2722">                Object cssKey = css.styleConstantsKeyToCSSKey</span>
<span class="nc" id="L2723">                               ((StyleConstants)key);</span>
<span class="nc bnc" id="L2724" title="All 2 branches missed.">                if (cssKey != null) {</span>
<span class="nc" id="L2725">                    Object value = doGetAttribute(cssKey);</span>
<span class="nc bnc" id="L2726" title="All 2 branches missed.">                    if (value instanceof CSS.CssValue) {</span>
<span class="nc" id="L2727">                        return ((CSS.CssValue)value).toStyleConstants</span>
<span class="nc" id="L2728">                                     ((StyleConstants)key, host);</span>
                    }
                }
            }
<span class="nc" id="L2732">            return doGetAttribute(key);</span>
        }

        Object doGetAttribute(Object key) {
<span class="nc" id="L2736">            Object retValue = super.getAttribute(key);</span>
<span class="nc bnc" id="L2737" title="All 2 branches missed.">            if (retValue != null) {</span>
<span class="nc" id="L2738">                return retValue;</span>
            }
            // didn't find it... try parent if it's a css attribute
            // that is inherited.
<span class="nc bnc" id="L2742" title="All 2 branches missed.">            if (key instanceof CSS.Attribute) {</span>
<span class="nc" id="L2743">                CSS.Attribute css = (CSS.Attribute) key;</span>
<span class="nc bnc" id="L2744" title="All 2 branches missed.">                if (css.isInherited()) {</span>
<span class="nc" id="L2745">                    AttributeSet parent = getResolveParent();</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">                    if (parent != null)</span>
<span class="nc" id="L2747">                        return parent.getAttribute(key);</span>
                }
            }
<span class="nc" id="L2750">            return null;</span>
        }

        /**
         * If not overriden, the resolving parent defaults to
         * the parent element.
         *
         * @return the attributes from the parent
         * @see AttributeSet#getResolveParent
         */
        public AttributeSet getResolveParent() {
<span class="nc bnc" id="L2761" title="All 2 branches missed.">            if (host == null) {</span>
<span class="nc" id="L2762">                return null;</span>
            }
<span class="nc" id="L2764">            View parent = host.getParent();</span>
<span class="nc bnc" id="L2765" title="All 2 branches missed.">            return (parent != null) ? parent.getAttributes() : null;</span>
        }

        /** View created for. */
        View host;
    }


    /**
     * A subclass of MuxingAttributeSet that implements Style. Currently
     * the MutableAttributeSet methods are unimplemented, that is they
     * do nothing.
     */
    // PENDING(sky): Decide what to do with this. Either make it
    // contain a SimpleAttributeSet that modify methods are delegated to,
    // or change getRule to return an AttributeSet and then don't make this
    // implement Style.
    static class ResolvedStyle extends MuxingAttributeSet implements
                  Serializable, Style {
        ResolvedStyle(String name, AttributeSet[] attrs, int extendedIndex) {
<span class="nc" id="L2785">            super(attrs);</span>
<span class="nc" id="L2786">            this.name = name;</span>
<span class="nc" id="L2787">            this.extendedIndex = extendedIndex;</span>
<span class="nc" id="L2788">        }</span>

        /**
         * Inserts a Style into the receiver so that the styles the
         * receiver represents are still ordered by specificity.
         * &lt;code&gt;style&lt;/code&gt; will be added before any extended styles, that
         * is before extendedIndex.
         */
        synchronized void insertStyle(Style style, int specificity) {
<span class="nc" id="L2797">            AttributeSet[] attrs = getAttributes();</span>
<span class="nc" id="L2798">            int maxCounter = attrs.length;</span>
<span class="nc" id="L2799">            int counter = 0;</span>
<span class="nc bnc" id="L2800" title="All 2 branches missed.">            for (;counter &lt; extendedIndex; counter++) {</span>
<span class="nc bnc" id="L2801" title="All 2 branches missed.">                if (specificity &gt; getSpecificity(((Style)attrs[counter]).</span>
<span class="nc" id="L2802">                                                 getName())) {</span>
<span class="nc" id="L2803">                    break;</span>
                }
            }
<span class="nc" id="L2806">            insertAttributeSetAt(style, counter);</span>
<span class="nc" id="L2807">            extendedIndex++;</span>
<span class="nc" id="L2808">        }</span>

        /**
         * Removes a previously added style. This will do nothing if
         * &lt;code&gt;style&lt;/code&gt; is not referenced by the receiver.
         */
        synchronized void removeStyle(Style style) {
<span class="nc" id="L2815">            AttributeSet[] attrs = getAttributes();</span>

<span class="nc bnc" id="L2817" title="All 2 branches missed.">            for (int counter = attrs.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc bnc" id="L2818" title="All 2 branches missed.">                if (attrs[counter] == style) {</span>
<span class="nc" id="L2819">                    removeAttributeSetAt(counter);</span>
<span class="nc bnc" id="L2820" title="All 2 branches missed.">                    if (counter &lt; extendedIndex) {</span>
<span class="nc" id="L2821">                        extendedIndex--;</span>
                    }
                    break;
                }
            }
<span class="nc" id="L2826">        }</span>

        /**
         * Adds &lt;code&gt;s&lt;/code&gt; as one of the Attributesets to look up
         * attributes in.
         */
        synchronized void insertExtendedStyleAt(Style attr, int index) {
<span class="nc" id="L2833">            insertAttributeSetAt(attr, extendedIndex + index);</span>
<span class="nc" id="L2834">        }</span>

        /**
         * Adds &lt;code&gt;s&lt;/code&gt; as one of the AttributeSets to look up
         * attributes in. It will be the AttributeSet last checked.
         */
        synchronized void addExtendedStyle(Style attr) {
<span class="nc" id="L2841">            insertAttributeSetAt(attr, getAttributes().length);</span>
<span class="nc" id="L2842">        }</span>

        /**
         * Removes the style at &lt;code&gt;index&lt;/code&gt; +
         * &lt;code&gt;extendedIndex&lt;/code&gt;.
         */
        synchronized void removeExtendedStyleAt(int index) {
<span class="nc" id="L2849">            removeAttributeSetAt(extendedIndex + index);</span>
<span class="nc" id="L2850">        }</span>

        /**
         * Returns true if the receiver matches &lt;code&gt;selector&lt;/code&gt;, where
         * a match is defined by the CSS rule matching.
         * Each simple selector must be separated by a single space.
         */
        protected boolean matches(String selector) {
<span class="nc" id="L2858">            int sLast = selector.length();</span>

<span class="nc bnc" id="L2860" title="All 2 branches missed.">            if (sLast == 0) {</span>
<span class="nc" id="L2861">                return false;</span>
            }
<span class="nc" id="L2863">            int thisLast = name.length();</span>
<span class="nc" id="L2864">            int sCurrent = selector.lastIndexOf(' ');</span>
<span class="nc" id="L2865">            int thisCurrent = name.lastIndexOf(' ');</span>
<span class="nc bnc" id="L2866" title="All 2 branches missed.">            if (sCurrent &gt;= 0) {</span>
<span class="nc" id="L2867">                sCurrent++;</span>
            }
<span class="nc bnc" id="L2869" title="All 2 branches missed.">            if (thisCurrent &gt;= 0) {</span>
<span class="nc" id="L2870">                thisCurrent++;</span>
            }
<span class="nc bnc" id="L2872" title="All 2 branches missed.">            if (!matches(selector, sCurrent, sLast, thisCurrent, thisLast)) {</span>
<span class="nc" id="L2873">                return false;</span>
            }
<span class="nc bnc" id="L2875" title="All 2 branches missed.">            while (sCurrent != -1) {</span>
<span class="nc" id="L2876">                sLast = sCurrent - 1;</span>
<span class="nc" id="L2877">                sCurrent = selector.lastIndexOf(' ', sLast - 1);</span>
<span class="nc bnc" id="L2878" title="All 2 branches missed.">                if (sCurrent &gt;= 0) {</span>
<span class="nc" id="L2879">                    sCurrent++;</span>
                }
<span class="nc" id="L2881">                boolean match = false;</span>
<span class="nc bnc" id="L2882" title="All 4 branches missed.">                while (!match &amp;&amp; thisCurrent != -1) {</span>
<span class="nc" id="L2883">                    thisLast = thisCurrent - 1;</span>
<span class="nc" id="L2884">                    thisCurrent = name.lastIndexOf(' ', thisLast - 1);</span>
<span class="nc bnc" id="L2885" title="All 2 branches missed.">                    if (thisCurrent &gt;= 0) {</span>
<span class="nc" id="L2886">                        thisCurrent++;</span>
                    }
<span class="nc" id="L2888">                    match = matches(selector, sCurrent, sLast, thisCurrent,</span>
                                    thisLast);
                }
<span class="nc bnc" id="L2891" title="All 2 branches missed.">                if (!match) {</span>
<span class="nc" id="L2892">                    return false;</span>
                }
<span class="nc" id="L2894">            }</span>
<span class="nc" id="L2895">            return true;</span>
        }

        /**
         * Returns true if the substring of the receiver, in the range
         * thisCurrent, thisLast matches the substring of selector in
         * the ranme sCurrent to sLast based on CSS selector matching.
         */
        boolean matches(String selector, int sCurrent, int sLast,
                       int thisCurrent, int thisLast) {
<span class="nc" id="L2905">            sCurrent = Math.max(sCurrent, 0);</span>
<span class="nc" id="L2906">            thisCurrent = Math.max(thisCurrent, 0);</span>
<span class="nc" id="L2907">            int thisDotIndex = boundedIndexOf(name, '.', thisCurrent,</span>
                                              thisLast);
<span class="nc" id="L2909">            int thisPoundIndex = boundedIndexOf(name, '#', thisCurrent,</span>
                                                thisLast);
<span class="nc" id="L2911">            int sDotIndex = boundedIndexOf(selector, '.', sCurrent, sLast);</span>
<span class="nc" id="L2912">            int sPoundIndex = boundedIndexOf(selector, '#', sCurrent, sLast);</span>
<span class="nc bnc" id="L2913" title="All 2 branches missed.">            if (sDotIndex != -1) {</span>
                // Selector has a '.', which indicates name must match it,
                // or if the '.' starts the selector than name must have
                // the same class (doesn't matter what element name).
<span class="nc bnc" id="L2917" title="All 2 branches missed.">                if (thisDotIndex == -1) {</span>
<span class="nc" id="L2918">                    return false;</span>
                }
<span class="nc bnc" id="L2920" title="All 2 branches missed.">                if (sCurrent == sDotIndex) {</span>
<span class="nc bnc" id="L2921" title="All 2 branches missed.">                    if ((thisLast - thisDotIndex) != (sLast - sDotIndex) ||</span>
<span class="nc bnc" id="L2922" title="All 2 branches missed.">                        !selector.regionMatches(sCurrent, name, thisDotIndex,</span>
                                                (thisLast - thisDotIndex))) {
<span class="nc" id="L2924">                        return false;</span>
                    }
                }
                else {
                    // Has to fully match.
<span class="nc bnc" id="L2929" title="All 2 branches missed.">                    if ((sLast - sCurrent) != (thisLast - thisCurrent) ||</span>
<span class="nc bnc" id="L2930" title="All 2 branches missed.">                        !selector.regionMatches(sCurrent, name, thisCurrent,</span>
                                                (thisLast - thisCurrent))) {
<span class="nc" id="L2932">                        return false;</span>
                    }
                }
<span class="nc" id="L2935">                return true;</span>
            }
<span class="nc bnc" id="L2937" title="All 2 branches missed.">            if (sPoundIndex != -1) {</span>
                // Selector has a '#', which indicates name must match it,
                // or if the '#' starts the selector than name must have
                // the same id (doesn't matter what element name).
<span class="nc bnc" id="L2941" title="All 2 branches missed.">                if (thisPoundIndex == -1) {</span>
<span class="nc" id="L2942">                    return false;</span>
                }
<span class="nc bnc" id="L2944" title="All 2 branches missed.">                if (sCurrent == sPoundIndex) {</span>
<span class="nc bnc" id="L2945" title="All 2 branches missed.">                    if ((thisLast - thisPoundIndex) !=(sLast - sPoundIndex) ||</span>
<span class="nc bnc" id="L2946" title="All 2 branches missed.">                        !selector.regionMatches(sCurrent, name, thisPoundIndex,</span>
                                                (thisLast - thisPoundIndex))) {
<span class="nc" id="L2948">                        return false;</span>
                    }
                }
                else {
                    // Has to fully match.
<span class="nc bnc" id="L2953" title="All 2 branches missed.">                    if ((sLast - sCurrent) != (thisLast - thisCurrent) ||</span>
<span class="nc bnc" id="L2954" title="All 2 branches missed.">                        !selector.regionMatches(sCurrent, name, thisCurrent,</span>
                                               (thisLast - thisCurrent))) {
<span class="nc" id="L2956">                        return false;</span>
                    }
                }
<span class="nc" id="L2959">                return true;</span>
            }
<span class="nc bnc" id="L2961" title="All 2 branches missed.">            if (thisDotIndex != -1) {</span>
                // Receiver references a class, just check element name.
<span class="nc bnc" id="L2963" title="All 2 branches missed.">                return (((thisDotIndex - thisCurrent) == (sLast - sCurrent)) &amp;&amp;</span>
<span class="nc bnc" id="L2964" title="All 2 branches missed.">                        selector.regionMatches(sCurrent, name, thisCurrent,</span>
                                               thisDotIndex - thisCurrent));
            }
<span class="nc bnc" id="L2967" title="All 2 branches missed.">            if (thisPoundIndex != -1) {</span>
                // Receiver references an id, just check element name.
<span class="nc bnc" id="L2969" title="All 2 branches missed.">                return (((thisPoundIndex - thisCurrent) ==(sLast - sCurrent))&amp;&amp;</span>
<span class="nc bnc" id="L2970" title="All 2 branches missed.">                        selector.regionMatches(sCurrent, name, thisCurrent,</span>
                                               thisPoundIndex - thisCurrent));
            }
            // Fail through, no classes or ides, just check string.
<span class="nc bnc" id="L2974" title="All 2 branches missed.">            return (((thisLast - thisCurrent) == (sLast - sCurrent)) &amp;&amp;</span>
<span class="nc bnc" id="L2975" title="All 2 branches missed.">                    selector.regionMatches(sCurrent, name, thisCurrent,</span>
                                           thisLast - thisCurrent));
        }

        /**
         * Similar to String.indexOf, but allows an upper bound
         * (this is slower in that it will still check string starting at
         * start.
         */
        int boundedIndexOf(String string, char search, int start,
                           int end) {
<span class="nc" id="L2986">            int retValue = string.indexOf(search, start);</span>
<span class="nc bnc" id="L2987" title="All 2 branches missed.">            if (retValue &gt;= end) {</span>
<span class="nc" id="L2988">                return -1;</span>
            }
<span class="nc" id="L2990">            return retValue;</span>
        }

<span class="nc" id="L2993">        public void addAttribute(Object name, Object value) {}</span>
<span class="nc" id="L2994">        public void addAttributes(AttributeSet attributes) {}</span>
<span class="nc" id="L2995">        public void removeAttribute(Object name) {}</span>
<span class="nc" id="L2996">        public void removeAttributes(Enumeration&lt;?&gt; names) {}</span>
<span class="nc" id="L2997">        public void removeAttributes(AttributeSet attributes) {}</span>
<span class="nc" id="L2998">        public void setResolveParent(AttributeSet parent) {}</span>
<span class="nc" id="L2999">        public String getName() {return name;}</span>
<span class="nc" id="L3000">        public void addChangeListener(ChangeListener l) {}</span>
<span class="nc" id="L3001">        public void removeChangeListener(ChangeListener l) {}</span>
        public ChangeListener[] getChangeListeners() {
<span class="nc" id="L3003">            return new ChangeListener[0];</span>
        }

        /** The name of the Style, which is the selector.
         * This will NEVER change!
         */
        String name;
        /** Start index of styles coming from other StyleSheets. */
        private int extendedIndex;
    }


    /**
     * SelectorMapping contains a specifitiy, as an integer, and an associated
     * Style. It can also reference children &lt;code&gt;SelectorMapping&lt;/code&gt;s,
     * so that it behaves like a tree.
     * &lt;p&gt;
     * This is not thread safe, it is assumed the caller will take the
     * necessary precations if this is to be used in a threaded environment.
     */
    static class SelectorMapping implements Serializable {
<span class="nc" id="L3024">        public SelectorMapping(int specificity) {</span>
<span class="nc" id="L3025">            this.specificity = specificity;</span>
<span class="nc" id="L3026">        }</span>

        /**
         * Returns the specificity this mapping represents.
         */
        public int getSpecificity() {
<span class="nc" id="L3032">            return specificity;</span>
        }

        /**
         * Sets the Style associated with this mapping.
         */
        public void setStyle(Style style) {
<span class="nc" id="L3039">            this.style = style;</span>
<span class="nc" id="L3040">        }</span>

        /**
         * Returns the Style associated with this mapping.
         */
        public Style getStyle() {
<span class="nc" id="L3046">            return style;</span>
        }

        /**
         * Returns the child mapping identified by the simple selector
         * &lt;code&gt;selector&lt;/code&gt;. If a child mapping does not exist for
         *&lt;code&gt;selector&lt;/code&gt;, and &lt;code&gt;create&lt;/code&gt; is true, a new
         * one will be created.
         */
        public SelectorMapping getChildSelectorMapping(String selector,
                                                       boolean create) {
<span class="nc" id="L3057">            SelectorMapping retValue = null;</span>

<span class="nc bnc" id="L3059" title="All 2 branches missed.">            if (children != null) {</span>
<span class="nc" id="L3060">                retValue = children.get(selector);</span>
            }
<span class="nc bnc" id="L3062" title="All 2 branches missed.">            else if (create) {</span>
<span class="nc" id="L3063">                children = new HashMap&lt;String, SelectorMapping&gt;(7);</span>
            }
<span class="nc bnc" id="L3065" title="All 4 branches missed.">            if (retValue == null &amp;&amp; create) {</span>
<span class="nc" id="L3066">                int specificity = getChildSpecificity(selector);</span>

<span class="nc" id="L3068">                retValue = createChildSelectorMapping(specificity);</span>
<span class="nc" id="L3069">                children.put(selector, retValue);</span>
            }
<span class="nc" id="L3071">            return retValue;</span>
        }

        /**
         * Creates a child &lt;code&gt;SelectorMapping&lt;/code&gt; with the specified
         * &lt;code&gt;specificity&lt;/code&gt;.
         */
        protected SelectorMapping createChildSelectorMapping(int specificity) {
<span class="nc" id="L3079">            return new SelectorMapping(specificity);</span>
        }

        /**
         * Returns the specificity for the child selector
         * &lt;code&gt;selector&lt;/code&gt;.
         */
        protected int getChildSpecificity(String selector) {
            // class (.) 100
            // id (#)    10000
<span class="nc" id="L3089">            char    firstChar = selector.charAt(0);</span>
<span class="nc" id="L3090">            int     specificity = getSpecificity();</span>

<span class="nc bnc" id="L3092" title="All 2 branches missed.">            if (firstChar == '.') {</span>
<span class="nc" id="L3093">                specificity += 100;</span>
            }
<span class="nc bnc" id="L3095" title="All 2 branches missed.">            else if (firstChar == '#') {</span>
<span class="nc" id="L3096">                specificity += 10000;</span>
            }
            else {
<span class="nc" id="L3099">                specificity += 1;</span>
<span class="nc bnc" id="L3100" title="All 2 branches missed.">                if (selector.indexOf('.') != -1) {</span>
<span class="nc" id="L3101">                    specificity += 100;</span>
                }
<span class="nc bnc" id="L3103" title="All 2 branches missed.">                if (selector.indexOf('#') != -1) {</span>
<span class="nc" id="L3104">                    specificity += 10000;</span>
                }
            }
<span class="nc" id="L3107">            return specificity;</span>
        }

        /**
         * The specificity for this selector.
         */
        private int specificity;
        /**
         * Style for this selector.
         */
        private Style style;
        /**
         * Any sub selectors. Key will be String, and value will be
         * another SelectorMapping.
         */
        private HashMap&lt;String, SelectorMapping&gt; children;
    }


    // ---- Variables ---------------------------------------------

    final static int DEFAULT_FONT_SIZE = 3;

    private CSS css;

    /**
     * An inverted graph of the selectors.
     */
    private SelectorMapping selectorMapping;

    /** Maps from selector (as a string) to Style that includes all
     * relevant styles. */
    private Hashtable&lt;String, ResolvedStyle&gt; resolvedStyles;

    /** Vector of StyleSheets that the rules are to reference.
     */
    private Vector&lt;StyleSheet&gt; linkedStyleSheets;

    /** Where the style sheet was found. Used for relative imports. */
    private URL base;


    /**
     * Default parser for CSS specifications that get loaded into
     * the StyleSheet.&lt;p&gt;
     * This class is NOT thread safe, do not ask it to parse while it is
     * in the middle of parsing.
     */
<span class="nc" id="L3155">    class CssParser implements CSSParser.CSSParserCallback {</span>

        /**
         * Parses the passed in CSS declaration into an AttributeSet.
         */
        public AttributeSet parseDeclaration(String string) {
            try {
<span class="nc" id="L3162">                return parseDeclaration(new StringReader(string));</span>
<span class="nc" id="L3163">            } catch (IOException ioe) {}</span>
<span class="nc" id="L3164">            return null;</span>
        }

        /**
         * Parses the passed in CSS declaration into an AttributeSet.
         */
        public AttributeSet parseDeclaration(Reader r) throws IOException {
<span class="nc" id="L3171">            parse(base, r, true, false);</span>
<span class="nc" id="L3172">            return declaration.copyAttributes();</span>
        }

        /**
         * Parse the given CSS stream
         */
        public void parse(URL base, Reader r, boolean parseDeclaration,
                          boolean isLink) throws IOException {
<span class="nc" id="L3180">            this.base = base;</span>
<span class="nc" id="L3181">            this.isLink = isLink;</span>
<span class="nc" id="L3182">            this.parsingDeclaration = parseDeclaration;</span>
<span class="nc" id="L3183">            declaration.removeAttributes(declaration);</span>
<span class="nc" id="L3184">            selectorTokens.removeAllElements();</span>
<span class="nc" id="L3185">            selectors.removeAllElements();</span>
<span class="nc" id="L3186">            propertyName = null;</span>
<span class="nc" id="L3187">            parser.parse(r, this, parseDeclaration);</span>
<span class="nc" id="L3188">        }</span>

        //
        // CSSParserCallback methods, public to implement the interface.
        //

        /**
         * Invoked when a valid @import is encountered, will call
         * &lt;code&gt;importStyleSheet&lt;/code&gt; if a
         * &lt;code&gt;MalformedURLException&lt;/code&gt; is not thrown in creating
         * the URL.
         */
        public void handleImport(String importString) {
<span class="nc" id="L3201">            URL url = CSS.getURL(base, importString);</span>
<span class="nc bnc" id="L3202" title="All 2 branches missed.">            if (url != null) {</span>
<span class="nc" id="L3203">                importStyleSheet(url);</span>
            }
<span class="nc" id="L3205">        }</span>

        /**
         * A selector has been encountered.
         */
        public void handleSelector(String selector) {
            //class and index selectors are case sensitive
<span class="nc bnc" id="L3212" title="All 2 branches missed.">            if (!(selector.startsWith(&quot;.&quot;)</span>
<span class="nc bnc" id="L3213" title="All 2 branches missed.">                  || selector.startsWith(&quot;#&quot;))) {</span>
<span class="nc" id="L3214">                selector = selector.toLowerCase();</span>
            }
<span class="nc" id="L3216">            int length = selector.length();</span>

<span class="nc bnc" id="L3218" title="All 2 branches missed.">            if (selector.endsWith(&quot;,&quot;)) {</span>
<span class="nc bnc" id="L3219" title="All 2 branches missed.">                if (length &gt; 1) {</span>
<span class="nc" id="L3220">                    selector = selector.substring(0, length - 1);</span>
<span class="nc" id="L3221">                    selectorTokens.addElement(selector);</span>
                }
<span class="nc" id="L3223">                addSelector();</span>
            }
<span class="nc bnc" id="L3225" title="All 2 branches missed.">            else if (length &gt; 0) {</span>
<span class="nc" id="L3226">                selectorTokens.addElement(selector);</span>
            }
<span class="nc" id="L3228">        }</span>

        /**
         * Invoked when the start of a rule is encountered.
         */
        public void startRule() {
<span class="nc bnc" id="L3234" title="All 2 branches missed.">            if (selectorTokens.size() &gt; 0) {</span>
<span class="nc" id="L3235">                addSelector();</span>
            }
<span class="nc" id="L3237">            propertyName = null;</span>
<span class="nc" id="L3238">        }</span>

        /**
         * Invoked when a property name is encountered.
         */
        public void handleProperty(String property) {
<span class="nc" id="L3244">            propertyName = property;</span>
<span class="nc" id="L3245">        }</span>

        /**
         * Invoked when a property value is encountered.
         */
        public void handleValue(String value) {
<span class="nc bnc" id="L3251" title="All 6 branches missed.">            if (propertyName != null &amp;&amp; value != null &amp;&amp; value.length() &gt; 0) {</span>
<span class="nc" id="L3252">                CSS.Attribute cssKey = CSS.getAttribute(propertyName);</span>
<span class="nc bnc" id="L3253" title="All 2 branches missed.">                if (cssKey != null) {</span>
                    // There is currently no mechanism to determine real
                    // base that style sheet was loaded from. For the time
                    // being, this maps for LIST_STYLE_IMAGE, which appear
                    // to be the only one that currently matters. A more
                    // general mechanism is definately needed.
<span class="nc bnc" id="L3259" title="All 2 branches missed.">                    if (cssKey == CSS.Attribute.LIST_STYLE_IMAGE) {</span>
<span class="nc bnc" id="L3260" title="All 4 branches missed.">                        if (value != null &amp;&amp; !value.equals(&quot;none&quot;)) {</span>
<span class="nc" id="L3261">                            URL url = CSS.getURL(base, value);</span>

<span class="nc bnc" id="L3263" title="All 2 branches missed.">                            if (url != null) {</span>
<span class="nc" id="L3264">                                value = url.toString();</span>
                            }
                        }
                    }
<span class="nc" id="L3268">                    addCSSAttribute(declaration, cssKey, value);</span>
                }
<span class="nc" id="L3270">                propertyName = null;</span>
            }
<span class="nc" id="L3272">        }</span>

        /**
         * Invoked when the end of a rule is encountered.
         */
        public void endRule() {
<span class="nc" id="L3278">            int n = selectors.size();</span>
<span class="nc bnc" id="L3279" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L3280">                String[] selector = selectors.elementAt(i);</span>
<span class="nc bnc" id="L3281" title="All 2 branches missed.">                if (selector.length &gt; 0) {</span>
<span class="nc" id="L3282">                    StyleSheet.this.addRule(selector, declaration, isLink);</span>
                }
            }
<span class="nc" id="L3285">            declaration.removeAttributes(declaration);</span>
<span class="nc" id="L3286">            selectors.removeAllElements();</span>
<span class="nc" id="L3287">        }</span>

        private void addSelector() {
<span class="nc" id="L3290">            String[] selector = new String[selectorTokens.size()];</span>
<span class="nc" id="L3291">            selectorTokens.copyInto(selector);</span>
<span class="nc" id="L3292">            selectors.addElement(selector);</span>
<span class="nc" id="L3293">            selectorTokens.removeAllElements();</span>
<span class="nc" id="L3294">        }</span>


<span class="nc" id="L3297">        Vector&lt;String[]&gt; selectors = new Vector&lt;String[]&gt;();</span>
<span class="nc" id="L3298">        Vector&lt;String&gt; selectorTokens = new Vector&lt;String&gt;();</span>
        /** Name of the current property. */
        String propertyName;
<span class="nc" id="L3301">        MutableAttributeSet declaration = new SimpleAttributeSet();</span>
        /** True if parsing a declaration, that is the Reader will not
         * contain a selector. */
        boolean parsingDeclaration;
        /** True if the attributes are coming from a linked/imported style. */
        boolean isLink;
        /** Where the CSS stylesheet lives. */
        URL base;
<span class="nc" id="L3309">        CSSParser parser = new CSSParser();</span>
    }

    void rebaseSizeMap(int base) {
        final int minimalFontSize = 4;
<span class="nc" id="L3314">        sizeMap = new int[sizeMapDefault.length];</span>
<span class="nc bnc" id="L3315" title="All 2 branches missed.">        for (int i = 0; i &lt; sizeMapDefault.length; i++) {</span>
<span class="nc" id="L3316">            sizeMap[i] = Math.max(base * sizeMapDefault[i] /</span>
                                  sizeMapDefault[CSS.baseFontSizeIndex],
                                  minimalFontSize);
        }

<span class="nc" id="L3321">    }</span>

    int[] getSizeMap() {
<span class="nc" id="L3324">        return sizeMap;</span>
    }
    boolean isW3CLengthUnits() {
<span class="nc" id="L3327">        return w3cLengthUnits;</span>
    }

    /**
     * The HTML/CSS size model has seven slots
     * that one can assign sizes to.
     */
<span class="nc" id="L3334">    static final int sizeMapDefault[] = { 8, 10, 12, 14, 18, 24, 36 };</span>

<span class="nc" id="L3336">    private int sizeMap[] = sizeMapDefault;</span>
<span class="nc" id="L3337">    private boolean w3cLengthUnits = false;</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>