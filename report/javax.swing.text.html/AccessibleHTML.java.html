<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AccessibleHTML.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text.html</a> &gt; <span class="el_source">AccessibleHTML.java</span></div><h1>AccessibleHTML.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.text.html;

import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.util.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.accessibility.*;
import java.text.BreakIterator;

/*
 * The AccessibleHTML class provide information about the contents
 * of a HTML document to assistive technologies.
 *
 * @author  Lynn Monsanto
 */
class AccessibleHTML implements Accessible {

    /**
     * The editor.
     */
    private JEditorPane editor;
    /**
     * Current model.
     */
    private Document model;
    /**
     * DocumentListener installed on the current model.
     */
    private DocumentListener docListener;
    /**
     * PropertyChangeListener installed on the editor
     */
    private PropertyChangeListener propChangeListener;
    /**
     * The root ElementInfo for the document
     */
    private ElementInfo rootElementInfo;
    /*
     * The root accessible context for the document
     */
    private RootHTMLAccessibleContext rootHTMLAccessibleContext;

<span class="nc" id="L71">    public AccessibleHTML(JEditorPane pane) {</span>
<span class="nc" id="L72">        editor = pane;</span>
<span class="nc" id="L73">        propChangeListener = new PropertyChangeHandler();</span>
<span class="nc" id="L74">        setDocument(editor.getDocument());</span>

<span class="nc" id="L76">        docListener = new DocumentHandler();</span>
<span class="nc" id="L77">    }</span>

    /**
     * Sets the document.
     */
    private void setDocument(Document document) {
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (model != null) {</span>
<span class="nc" id="L84">            model.removeDocumentListener(docListener);</span>
        }
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (editor != null) {</span>
<span class="nc" id="L87">            editor.removePropertyChangeListener(propChangeListener);</span>
        }
<span class="nc" id="L89">        this.model = document;</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">        if (model != null) {</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">            if (rootElementInfo != null) {</span>
<span class="nc" id="L92">                rootElementInfo.invalidate(false);</span>
            }
<span class="nc" id="L94">            buildInfo();</span>
<span class="nc" id="L95">            model.addDocumentListener(docListener);</span>
        }
        else {
<span class="nc" id="L98">            rootElementInfo = null;</span>
        }
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (editor != null) {</span>
<span class="nc" id="L101">            editor.addPropertyChangeListener(propChangeListener);</span>
        }
<span class="nc" id="L103">    }</span>

    /**
     * Returns the Document currently presenting information for.
     */
    private Document getDocument() {
<span class="nc" id="L109">        return model;</span>
    }

    /**
     * Returns the JEditorPane providing information for.
     */
    private JEditorPane getTextComponent() {
<span class="nc" id="L116">        return editor;</span>
    }

    /**
     * Returns the ElementInfo representing the root Element.
     */
    private ElementInfo getRootInfo() {
<span class="nc" id="L123">        return rootElementInfo;</span>
    }

    /**
     * Returns the root &lt;code&gt;View&lt;/code&gt; associated with the current text
     * component.
     */
    private View getRootView() {
<span class="nc" id="L131">        return getTextComponent().getUI().getRootView(getTextComponent());</span>
    }

    /**
     * Returns the bounds the root View will be rendered in.
     */
    private Rectangle getRootEditorRect() {
<span class="nc" id="L138">        Rectangle alloc = getTextComponent().getBounds();</span>
<span class="nc bnc" id="L139" title="All 4 branches missed.">        if ((alloc.width &gt; 0) &amp;&amp; (alloc.height &gt; 0)) {</span>
<span class="nc" id="L140">            alloc.x = alloc.y = 0;</span>
<span class="nc" id="L141">            Insets insets = editor.getInsets();</span>
<span class="nc" id="L142">            alloc.x += insets.left;</span>
<span class="nc" id="L143">            alloc.y += insets.top;</span>
<span class="nc" id="L144">            alloc.width -= insets.left + insets.right;</span>
<span class="nc" id="L145">            alloc.height -= insets.top + insets.bottom;</span>
<span class="nc" id="L146">            return alloc;</span>
        }
<span class="nc" id="L148">        return null;</span>
    }

    /**
     * If possible acquires a lock on the Document.  If a lock has been
     * obtained a key will be retured that should be passed to
     * &lt;code&gt;unlock&lt;/code&gt;.
     */
    private Object lock() {
<span class="nc" id="L157">        Document document = getDocument();</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (document instanceof AbstractDocument) {</span>
<span class="nc" id="L160">            ((AbstractDocument)document).readLock();</span>
<span class="nc" id="L161">            return document;</span>
        }
<span class="nc" id="L163">        return null;</span>
    }

    /**
     * Releases a lock previously obtained via &lt;code&gt;lock&lt;/code&gt;.
     */
    private void unlock(Object key) {
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (key != null) {</span>
<span class="nc" id="L171">            ((AbstractDocument)key).readUnlock();</span>
        }
<span class="nc" id="L173">    }</span>

    /**
     * Rebuilds the information from the current info.
     */
    private void buildInfo() {
<span class="nc" id="L179">        Object lock = lock();</span>

        try {
<span class="nc" id="L182">            Document doc = getDocument();</span>
<span class="nc" id="L183">            Element root = doc.getDefaultRootElement();</span>

<span class="nc" id="L185">            rootElementInfo = new ElementInfo(root);</span>
<span class="nc" id="L186">            rootElementInfo.validate();</span>
        } finally {
<span class="nc" id="L188">            unlock(lock);</span>
<span class="nc" id="L189">        }</span>
<span class="nc" id="L190">    }</span>

    /*
     * Create an ElementInfo subclass based on the passed in Element.
     */
    ElementInfo createElementInfo(Element e, ElementInfo parent) {
<span class="nc" id="L196">        AttributeSet attrs = e.getAttributes();</span>

<span class="nc bnc" id="L198" title="All 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L199">            Object name = attrs.getAttribute(StyleConstants.NameAttribute);</span>

<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (name == HTML.Tag.IMG) {</span>
<span class="nc" id="L202">                return new IconElementInfo(e, parent);</span>
            }
<span class="nc bnc" id="L204" title="All 4 branches missed.">            else if (name == HTML.Tag.CONTENT || name == HTML.Tag.CAPTION) {</span>
<span class="nc" id="L205">                return new TextElementInfo(e, parent);</span>
            }
<span class="nc bnc" id="L207" title="All 2 branches missed.">            else if (name == HTML.Tag.TABLE) {</span>
<span class="nc" id="L208">                return new TableElementInfo(e, parent);</span>
            }
        }
<span class="nc" id="L211">        return null;</span>
    }

    /**
     * Returns the root AccessibleContext for the document
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (rootHTMLAccessibleContext == null) {</span>
<span class="nc" id="L219">            rootHTMLAccessibleContext =</span>
                new RootHTMLAccessibleContext(rootElementInfo);
        }
<span class="nc" id="L222">        return rootHTMLAccessibleContext;</span>
    }

    /*
     * The roow AccessibleContext for the document
     */
    private class RootHTMLAccessibleContext extends HTMLAccessibleContext {

<span class="nc" id="L230">        public RootHTMLAccessibleContext(ElementInfo elementInfo) {</span>
<span class="nc" id="L231">            super(elementInfo);</span>
<span class="nc" id="L232">        }</span>

        /**
         * Gets the accessibleName property of this object.  The accessibleName
         * property of an object is a localized String that designates the purpose
         * of the object.  For example, the accessibleName property of a label
         * or button might be the text of the label or button itself.  In the
         * case of an object that doesn't display its name, the accessibleName
         * should still be set.  For example, in the case of a text field used
         * to enter the name of a city, the accessibleName for the en_US locale
         * could be 'city.'
         *
         * @return the localized name of the object; null if this
         * object does not have a name
         *
         * @see #setAccessibleName
         */
        public String getAccessibleName() {
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (model != null) {</span>
<span class="nc" id="L251">                return (String)model.getProperty(Document.TitleProperty);</span>
            } else {
<span class="nc" id="L253">                return null;</span>
            }
        }

        /**
         * Gets the accessibleDescription property of this object.  If this
         * property isn't set, returns the content type of this
         * &lt;code&gt;JEditorPane&lt;/code&gt; instead (e.g. &quot;plain/text&quot;, &quot;html/text&quot;).
         *
         * @return the localized description of the object; &lt;code&gt;null&lt;/code&gt;
         *      if this object does not have a description
         *
         * @see #setAccessibleName
         */
        public String getAccessibleDescription() {
<span class="nc" id="L268">            return editor.getContentType();</span>
        }

        /**
         * Gets the role of this object.  The role of the object is the generic
         * purpose or use of the class of this object.  For example, the role
         * of a push button is AccessibleRole.PUSH_BUTTON.  The roles in
         * AccessibleRole are provided so component developers can pick from
         * a set of predefined roles.  This enables assistive technologies to
         * provide a consistent interface to various tweaked subclasses of
         * components (e.g., use AccessibleRole.PUSH_BUTTON for all components
         * that act like a push button) as well as distinguish between subclasses
         * that behave differently (e.g., AccessibleRole.CHECK_BOX for check boxes
         * and AccessibleRole.RADIO_BUTTON for radio buttons).
         * &lt;p&gt;Note that the AccessibleRole class is also extensible, so
         * custom component developers can define their own AccessibleRole's
         * if the set of predefined roles is inadequate.
         *
         * @return an instance of AccessibleRole describing the role of the object
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L290">            return AccessibleRole.TEXT;</span>
        }
    }

    /*
     * Base AccessibleContext class for HTML elements
     */
    protected abstract class HTMLAccessibleContext extends AccessibleContext
        implements Accessible, AccessibleComponent {

        protected ElementInfo elementInfo;

<span class="nc" id="L302">        public HTMLAccessibleContext(ElementInfo elementInfo) {</span>
<span class="nc" id="L303">            this.elementInfo = elementInfo;</span>
<span class="nc" id="L304">        }</span>

        // begin AccessibleContext implementation ...
        public AccessibleContext getAccessibleContext() {
<span class="nc" id="L308">            return this;</span>
        }

        /**
         * Gets the state set of this object.
         *
         * @return an instance of AccessibleStateSet describing the states
         * of the object
         * @see AccessibleStateSet
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L319">            AccessibleStateSet states = new AccessibleStateSet();</span>
<span class="nc" id="L320">            Component comp = getTextComponent();</span>

<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (comp.isEnabled()) {</span>
<span class="nc" id="L323">                states.add(AccessibleState.ENABLED);</span>
            }
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (comp instanceof JTextComponent &amp;&amp;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                ((JTextComponent)comp).isEditable()) {</span>

<span class="nc" id="L328">                states.add(AccessibleState.EDITABLE);</span>
<span class="nc" id="L329">                states.add(AccessibleState.FOCUSABLE);</span>
            }
<span class="nc bnc" id="L331" title="All 2 branches missed.">            if (comp.isVisible()) {</span>
<span class="nc" id="L332">                states.add(AccessibleState.VISIBLE);</span>
            }
<span class="nc bnc" id="L334" title="All 2 branches missed.">            if (comp.isShowing()) {</span>
<span class="nc" id="L335">                states.add(AccessibleState.SHOWING);</span>
            }
<span class="nc" id="L337">            return states;</span>
        }

        /**
         * Gets the 0-based index of this object in its accessible parent.
         *
         * @return the 0-based index of this object in its parent; -1 if this
         * object does not have an accessible parent.
         *
         * @see #getAccessibleParent
         * @see #getAccessibleChildrenCount
         * @see #getAccessibleChild
         */
        public int getAccessibleIndexInParent() {
<span class="nc" id="L351">            return elementInfo.getIndexInParent();</span>
        }

        /**
         * Returns the number of accessible children of the object.
         *
         * @return the number of accessible children of the object.
         */
        public int getAccessibleChildrenCount() {
<span class="nc" id="L360">            return elementInfo.getChildCount();</span>
        }

        /**
         * Returns the specified Accessible child of the object.  The Accessible
         * children of an Accessible object are zero-based, so the first child
         * of an Accessible child is at index 0, the second child is at index 1,
         * and so on.
         *
         * @param i zero-based index of child
         * @return the Accessible child of the object
         * @see #getAccessibleChildrenCount
         */
        public Accessible getAccessibleChild(int i) {
<span class="nc" id="L374">            ElementInfo childInfo = elementInfo.getChild(i);</span>
<span class="nc bnc" id="L375" title="All 4 branches missed.">            if (childInfo != null &amp;&amp; childInfo instanceof Accessible) {</span>
<span class="nc" id="L376">                return (Accessible)childInfo;</span>
            } else {
<span class="nc" id="L378">                return null;</span>
            }
        }

        /**
         * Gets the locale of the component. If the component does not have a
         * locale, then the locale of its parent is returned.
         *
         * @return this component's locale.  If this component does not have
         * a locale, the locale of its parent is returned.
         *
         * @exception IllegalComponentStateException
         * If the Component does not have its own locale and has not yet been
         * added to a containment hierarchy such that the locale can be
         * determined from the containing parent.
         */
        public Locale getLocale() throws IllegalComponentStateException {
<span class="nc" id="L395">            return editor.getLocale();</span>
        }
        // ... end AccessibleContext implementation

        // begin AccessibleComponent implementation ...
        public AccessibleComponent getAccessibleComponent() {
<span class="nc" id="L401">            return this;</span>
        }

        /**
         * Gets the background color of this object.
         *
         * @return the background color, if supported, of the object;
         * otherwise, null
         * @see #setBackground
         */
        public Color getBackground() {
<span class="nc" id="L412">            return getTextComponent().getBackground();</span>
        }

        /**
         * Sets the background color of this object.
         *
         * @param c the new Color for the background
         * @see #setBackground
         */
        public void setBackground(Color c) {
<span class="nc" id="L422">            getTextComponent().setBackground(c);</span>
<span class="nc" id="L423">        }</span>

        /**
         * Gets the foreground color of this object.
         *
         * @return the foreground color, if supported, of the object;
         * otherwise, null
         * @see #setForeground
         */
        public Color getForeground() {
<span class="nc" id="L433">            return getTextComponent().getForeground();</span>
        }

        /**
         * Sets the foreground color of this object.
         *
         * @param c the new Color for the foreground
         * @see #getForeground
         */
        public void setForeground(Color c) {
<span class="nc" id="L443">            getTextComponent().setForeground(c);</span>
<span class="nc" id="L444">        }</span>

        /**
         * Gets the Cursor of this object.
         *
         * @return the Cursor, if supported, of the object; otherwise, null
         * @see #setCursor
         */
        public Cursor getCursor() {
<span class="nc" id="L453">            return getTextComponent().getCursor();</span>
        }

        /**
         * Sets the Cursor of this object.
         *
         * @param cursor the new Cursor for the object
         * @see #getCursor
         */
        public void setCursor(Cursor cursor) {
<span class="nc" id="L463">            getTextComponent().setCursor(cursor);</span>
<span class="nc" id="L464">        }</span>

        /**
         * Gets the Font of this object.
         *
         * @return the Font,if supported, for the object; otherwise, null
         * @see #setFont
         */
        public Font getFont() {
<span class="nc" id="L473">            return getTextComponent().getFont();</span>
        }

        /**
         * Sets the Font of this object.
         *
         * @param f the new Font for the object
         * @see #getFont
         */
        public void setFont(Font f) {
<span class="nc" id="L483">            getTextComponent().setFont(f);</span>
<span class="nc" id="L484">        }</span>

        /**
         * Gets the FontMetrics of this object.
         *
         * @param f the Font
         * @return the FontMetrics, if supported, the object; otherwise, null
         * @see #getFont
         */
        public FontMetrics getFontMetrics(Font f) {
<span class="nc" id="L494">            return getTextComponent().getFontMetrics(f);</span>
        }

        /**
         * Determines if the object is enabled.  Objects that are enabled
         * will also have the AccessibleState.ENABLED state set in their
         * AccessibleStateSets.
         *
         * @return true if object is enabled; otherwise, false
         * @see #setEnabled
         * @see AccessibleContext#getAccessibleStateSet
         * @see AccessibleState#ENABLED
         * @see AccessibleStateSet
         */
        public boolean isEnabled() {
<span class="nc" id="L509">            return getTextComponent().isEnabled();</span>
        }

        /**
         * Sets the enabled state of the object.
         *
         * @param b if true, enables this object; otherwise, disables it
         * @see #isEnabled
         */
        public void setEnabled(boolean b) {
<span class="nc" id="L519">            getTextComponent().setEnabled(b);</span>
<span class="nc" id="L520">        }</span>

        /**
         * Determines if the object is visible.  Note: this means that the
         * object intends to be visible; however, it may not be
         * showing on the screen because one of the objects that this object
         * is contained by is currently not visible.  To determine if an object
         * is showing on the screen, use isShowing().
         * &lt;p&gt;Objects that are visible will also have the
         * AccessibleState.VISIBLE state set in their AccessibleStateSets.
         *
         * @return true if object is visible; otherwise, false
         * @see #setVisible
         * @see AccessibleContext#getAccessibleStateSet
         * @see AccessibleState#VISIBLE
         * @see AccessibleStateSet
         */
        public boolean isVisible() {
<span class="nc" id="L538">            return getTextComponent().isVisible();</span>
        }

        /**
         * Sets the visible state of the object.
         *
         * @param b if true, shows this object; otherwise, hides it
         * @see #isVisible
         */
        public void setVisible(boolean b) {
<span class="nc" id="L548">            getTextComponent().setVisible(b);</span>
<span class="nc" id="L549">        }</span>

        /**
         * Determines if the object is showing.  This is determined by checking
         * the visibility of the object and its ancestors.
         * Note: this
         * will return true even if the object is obscured by another (for
         * example, it is underneath a menu that was pulled down).
         *
         * @return true if object is showing; otherwise, false
         */
        public boolean isShowing() {
<span class="nc" id="L561">            return getTextComponent().isShowing();</span>
        }

        /**
         * Checks whether the specified point is within this object's bounds,
         * where the point's x and y coordinates are defined to be relative
         * to the coordinate system of the object.
         *
         * @param p the Point relative to the coordinate system of the object
         * @return true if object contains Point; otherwise false
         * @see #getBounds
         */
        public boolean contains(Point p) {
<span class="nc" id="L574">            Rectangle r = getBounds();</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (r != null) {</span>
<span class="nc" id="L576">                return r.contains(p.x, p.y);</span>
            } else {
<span class="nc" id="L578">                return false;</span>
            }
        }

        /**
         * Returns the location of the object on the screen.
         *
         * @return the location of the object on screen; null if this object
         * is not on the screen
         * @see #getBounds
         * @see #getLocation
         */
        public Point getLocationOnScreen() {
<span class="nc" id="L591">            Point editorLocation = getTextComponent().getLocationOnScreen();</span>
<span class="nc" id="L592">            Rectangle r = getBounds();</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">            if (r != null) {</span>
<span class="nc" id="L594">                return new Point(editorLocation.x + r.x,</span>
                                 editorLocation.y + r.y);
            } else {
<span class="nc" id="L597">                return null;</span>
            }
        }

        /**
         * Gets the location of the object relative to the parent in the form
         * of a point specifying the object's top-left corner in the screen's
         * coordinate space.
         *
         * @return An instance of Point representing the top-left corner of the
         * object's bounds in the coordinate space of the screen; null if
         * this object or its parent are not on the screen
         * @see #getBounds
         * @see #getLocationOnScreen
         */
        public Point getLocation() {
<span class="nc" id="L613">            Rectangle r = getBounds();</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">            if (r != null) {</span>
<span class="nc" id="L615">                return new Point(r.x, r.y);</span>
            } else {
<span class="nc" id="L617">                return null;</span>
            }
        }

        /**
         * Sets the location of the object relative to the parent.
         * @param p the new position for the top-left corner
         * @see #getLocation
         */
        public void setLocation(Point p) {
<span class="nc" id="L627">        }</span>

        /**
         * Gets the bounds of this object in the form of a Rectangle object.
         * The bounds specify this object's width, height, and location
         * relative to its parent.
         *
         * @return A rectangle indicating this component's bounds; null if
         * this object is not on the screen.
         * @see #contains
         */
        public Rectangle getBounds() {
<span class="nc" id="L639">            return elementInfo.getBounds();</span>
        }

        /**
         * Sets the bounds of this object in the form of a Rectangle object.
         * The bounds specify this object's width, height, and location
         * relative to its parent.
         *
         * @param r rectangle indicating this component's bounds
         * @see #getBounds
         */
        public void setBounds(Rectangle r) {
<span class="nc" id="L651">        }</span>

        /**
         * Returns the size of this object in the form of a Dimension object.
         * The height field of the Dimension object contains this object's
         * height, and the width field of the Dimension object contains this
         * object's width.
         *
         * @return A Dimension object that indicates the size of this component;
         * null if this object is not on the screen
         * @see #setSize
         */
        public Dimension getSize() {
<span class="nc" id="L664">            Rectangle r = getBounds();</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">            if (r != null) {</span>
<span class="nc" id="L666">                return new Dimension(r.width, r.height);</span>
            } else {
<span class="nc" id="L668">                return null;</span>
            }
        }

        /**
         * Resizes this object so that it has width and height.
         *
         * @param d The dimension specifying the new size of the object.
         * @see #getSize
         */
        public void setSize(Dimension d) {
<span class="nc" id="L679">            Component comp = getTextComponent();</span>
<span class="nc" id="L680">            comp.setSize(d);</span>
<span class="nc" id="L681">        }</span>

        /**
         * Returns the Accessible child, if one exists, contained at the local
         * coordinate Point.
         *
         * @param p The point relative to the coordinate system of this object.
         * @return the Accessible, if it exists, at the specified location;
         * otherwise null
         */
        public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L692">            ElementInfo innerMostElement = getElementInfoAt(rootElementInfo, p);</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">            if (innerMostElement instanceof Accessible) {</span>
<span class="nc" id="L694">                return (Accessible)innerMostElement;</span>
            } else {
<span class="nc" id="L696">                return null;</span>
            }
        }

        private ElementInfo getElementInfoAt(ElementInfo elementInfo, Point p) {
<span class="nc bnc" id="L701" title="All 2 branches missed.">            if (elementInfo.getBounds() == null) {</span>
<span class="nc" id="L702">                return null;</span>
            }
<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (elementInfo.getChildCount() == 0 &amp;&amp;</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                elementInfo.getBounds().contains(p)) {</span>
<span class="nc" id="L706">                return elementInfo;</span>

            } else {
<span class="nc bnc" id="L709" title="All 2 branches missed.">                if (elementInfo instanceof TableElementInfo) {</span>
                    // Handle table caption as a special case since it's the
                    // only table child that is not a table row.
<span class="nc" id="L712">                    ElementInfo captionInfo =</span>
<span class="nc" id="L713">                        ((TableElementInfo)elementInfo).getCaptionInfo();</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">                    if (captionInfo != null) {</span>
<span class="nc" id="L715">                        Rectangle bounds = captionInfo.getBounds();</span>
<span class="nc bnc" id="L716" title="All 4 branches missed.">                        if (bounds != null &amp;&amp; bounds.contains(p)) {</span>
<span class="nc" id="L717">                            return captionInfo;</span>
                        }
                    }
                }
<span class="nc bnc" id="L721" title="All 2 branches missed.">                for (int i = 0; i &lt; elementInfo.getChildCount(); i++)</span>
{
<span class="nc" id="L723">                    ElementInfo childInfo = elementInfo.getChild(i);</span>
<span class="nc" id="L724">                    ElementInfo retValue = getElementInfoAt(childInfo, p);</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                    if (retValue != null) {</span>
<span class="nc" id="L726">                        return retValue;</span>
                    }
                }
            }
<span class="nc" id="L730">            return null;</span>
        }

        /**
         * Returns whether this object can accept focus or not.   Objects that
         * can accept focus will also have the AccessibleState.FOCUSABLE state
         * set in their AccessibleStateSets.
         *
         * @return true if object can accept focus; otherwise false
         * @see AccessibleContext#getAccessibleStateSet
         * @see AccessibleState#FOCUSABLE
         * @see AccessibleState#FOCUSED
         * @see AccessibleStateSet
         */
        public boolean isFocusTraversable() {
<span class="nc" id="L745">            Component comp = getTextComponent();</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">            if (comp instanceof JTextComponent) {</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">                if (((JTextComponent)comp).isEditable()) {</span>
<span class="nc" id="L748">                    return true;</span>
                }
            }
<span class="nc" id="L751">            return false;</span>
        }

        /**
         * Requests focus for this object.  If this object cannot accept focus,
         * nothing will happen.  Otherwise, the object will attempt to take
         * focus.
         * @see #isFocusTraversable
         */
        public void requestFocus() {
            // TIGER - 4856191
<span class="nc bnc" id="L762" title="All 2 branches missed.">            if (! isFocusTraversable()) {</span>
<span class="nc" id="L763">                return;</span>
            }

<span class="nc" id="L766">            Component comp = getTextComponent();</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">            if (comp instanceof JTextComponent) {</span>

<span class="nc" id="L769">                comp.requestFocusInWindow();</span>

                try {
<span class="nc bnc" id="L772" title="All 2 branches missed.">                    if (elementInfo.validateIfNecessary()) {</span>
                        // set the caret position to the start of this component
<span class="nc" id="L774">                        Element elem = elementInfo.getElement();</span>
<span class="nc" id="L775">                        ((JTextComponent)comp).setCaretPosition(elem.getStartOffset());</span>

                        // fire a AccessibleState.FOCUSED property change event
<span class="nc" id="L778">                        AccessibleContext ac = editor.getAccessibleContext();</span>
<span class="nc" id="L779">                        PropertyChangeEvent pce = new PropertyChangeEvent(this,</span>
                            AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                            null, AccessibleState.FOCUSED);
<span class="nc" id="L782">                        ac.firePropertyChange(</span>
                            AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                            null, pce);
                    }
<span class="nc" id="L786">                } catch (IllegalArgumentException e) {</span>
                    // don't fire property change event
<span class="nc" id="L788">                }</span>
            }
<span class="nc" id="L790">        }</span>

        /**
         * Adds the specified focus listener to receive focus events from this
         * component.
         *
         * @param l the focus listener
         * @see #removeFocusListener
         */
        public void addFocusListener(FocusListener l) {
<span class="nc" id="L800">            getTextComponent().addFocusListener(l);</span>
<span class="nc" id="L801">        }</span>

        /**
         * Removes the specified focus listener so it no longer receives focus
         * events from this component.
         *
         * @param l the focus listener
         * @see #addFocusListener
         */
        public void removeFocusListener(FocusListener l) {
<span class="nc" id="L811">            getTextComponent().removeFocusListener(l);</span>
<span class="nc" id="L812">        }</span>
        // ... end AccessibleComponent implementation
    } // ... end HTMLAccessibleContext



    /*
     * ElementInfo for text
     */
    class TextElementInfo extends ElementInfo implements Accessible {

<span class="nc" id="L823">        TextElementInfo(Element element, ElementInfo parent) {</span>
<span class="nc" id="L824">            super(element, parent);</span>
<span class="nc" id="L825">        }</span>

        // begin AccessibleText implementation ...
        private AccessibleContext accessibleContext;

        public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L831" title="All 2 branches missed.">            if (accessibleContext == null) {</span>
<span class="nc" id="L832">                accessibleContext = new TextAccessibleContext(this);</span>
            }
<span class="nc" id="L834">            return accessibleContext;</span>
        }

        /*
         * AccessibleContext for text elements
         */
        public class TextAccessibleContext extends HTMLAccessibleContext
            implements AccessibleText {

<span class="nc" id="L843">            public TextAccessibleContext(ElementInfo elementInfo) {</span>
<span class="nc" id="L844">                super(elementInfo);</span>
<span class="nc" id="L845">            }</span>

            public AccessibleText getAccessibleText() {
<span class="nc" id="L848">                return this;</span>
            }

            /**
             * Gets the accessibleName property of this object.  The accessibleName
             * property of an object is a localized String that designates the purpose
             * of the object.  For example, the accessibleName property of a label
             * or button might be the text of the label or button itself.  In the
             * case of an object that doesn't display its name, the accessibleName
             * should still be set.  For example, in the case of a text field used
             * to enter the name of a city, the accessibleName for the en_US locale
             * could be 'city.'
             *
             * @return the localized name of the object; null if this
             * object does not have a name
             *
             * @see #setAccessibleName
             */
            public String getAccessibleName() {
<span class="nc bnc" id="L867" title="All 2 branches missed.">                if (model != null) {</span>
<span class="nc" id="L868">                    return (String)model.getProperty(Document.TitleProperty);</span>
                } else {
<span class="nc" id="L870">                    return null;</span>
                }
            }

            /**
             * Gets the accessibleDescription property of this object.  If this
             * property isn't set, returns the content type of this
             * &lt;code&gt;JEditorPane&lt;/code&gt; instead (e.g. &quot;plain/text&quot;, &quot;html/text&quot;).
             *
             * @return the localized description of the object; &lt;code&gt;null&lt;/code&gt;
             *  if this object does not have a description
             *
             * @see #setAccessibleName
             */
            public String getAccessibleDescription() {
<span class="nc" id="L885">                return editor.getContentType();</span>
            }

            /**
             * Gets the role of this object.  The role of the object is the generic
             * purpose or use of the class of this object.  For example, the role
             * of a push button is AccessibleRole.PUSH_BUTTON.  The roles in
             * AccessibleRole are provided so component developers can pick from
             * a set of predefined roles.  This enables assistive technologies to
             * provide a consistent interface to various tweaked subclasses of
             * components (e.g., use AccessibleRole.PUSH_BUTTON for all components
             * that act like a push button) as well as distinguish between subclasses
             * that behave differently (e.g., AccessibleRole.CHECK_BOX for check boxes
             * and AccessibleRole.RADIO_BUTTON for radio buttons).
             * &lt;p&gt;Note that the AccessibleRole class is also extensible, so
             * custom component developers can define their own AccessibleRole's
             * if the set of predefined roles is inadequate.
             *
             * @return an instance of AccessibleRole describing the role of the object
             * @see AccessibleRole
             */
            public AccessibleRole getAccessibleRole() {
<span class="nc" id="L907">                return AccessibleRole.TEXT;</span>
            }

            /**
             * Given a point in local coordinates, return the zero-based index
             * of the character under that Point.  If the point is invalid,
             * this method returns -1.
             *
             * @param p the Point in local coordinates
             * @return the zero-based index of the character under Point p; if
             * Point is invalid returns -1.
             */
            public int getIndexAtPoint(Point p) {
<span class="nc" id="L920">                View v = getView();</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">                if (v != null) {</span>
<span class="nc" id="L922">                    return v.viewToModel(p.x, p.y, getBounds());</span>
                } else {
<span class="nc" id="L924">                    return -1;</span>
                }
            }

            /**
             * Determine the bounding box of the character at the given
             * index into the string.  The bounds are returned in local
             * coordinates.  If the index is invalid an empty rectangle is
             * returned.
             *
             * @param i the index into the String
             * @return the screen coordinates of the character's the bounding box,
             * if index is invalid returns an empty rectangle.
             */
            public Rectangle getCharacterBounds(int i) {
                try {
<span class="nc" id="L940">                    return editor.getUI().modelToView(editor, i);</span>
<span class="nc" id="L941">                } catch (BadLocationException e) {</span>
<span class="nc" id="L942">                    return null;</span>
                }
            }

            /**
             * Return the number of characters (valid indicies)
             *
             * @return the number of characters
             */
            public int getCharCount() {
<span class="nc bnc" id="L952" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc" id="L953">                    Element elem = elementInfo.getElement();</span>
<span class="nc" id="L954">                    return elem.getEndOffset() - elem.getStartOffset();</span>
                }
<span class="nc" id="L956">                return 0;</span>
            }

            /**
             * Return the zero-based offset of the caret.
             *
             * Note: That to the right of the caret will have the same index
             * value as the offset (the caret is between two characters).
             * @return the zero-based offset of the caret.
             */
            public int getCaretPosition() {
<span class="nc" id="L967">                View v = getView();</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">                if (v == null) {</span>
<span class="nc" id="L969">                    return -1;</span>
                }
<span class="nc" id="L971">                Container c = v.getContainer();</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">                if (c == null) {</span>
<span class="nc" id="L973">                    return -1;</span>
                }
<span class="nc bnc" id="L975" title="All 2 branches missed.">                if (c instanceof JTextComponent) {</span>
<span class="nc" id="L976">                    return ((JTextComponent)c).getCaretPosition();</span>
                } else {
<span class="nc" id="L978">                    return -1;</span>
                }
            }

            /**
             * IndexedSegment extends Segment adding the offset into the
             * the model the &lt;code&gt;Segment&lt;/code&gt; was asked for.
             */
<span class="nc" id="L986">            private class IndexedSegment extends Segment {</span>
                /**
                 * Offset into the model that the position represents.
                 */
                public int modelOffset;
            }

            public String getAtIndex(int part, int index) {
<span class="nc" id="L994">                return getAtIndex(part, index, 0);</span>
            }


            public String getAfterIndex(int part, int index) {
<span class="nc" id="L999">                return getAtIndex(part, index, 1);</span>
            }

            public String getBeforeIndex(int part, int index) {
<span class="nc" id="L1003">                return getAtIndex(part, index, -1);</span>
            }

            /**
             * Gets the word, sentence, or character at &lt;code&gt;index&lt;/code&gt;.
             * If &lt;code&gt;direction&lt;/code&gt; is non-null this will find the
             * next/previous word/sentence/character.
             */
            private String getAtIndex(int part, int index, int direction) {
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L1013">                    ((AbstractDocument)model).readLock();</span>
                }
                try {
<span class="nc bnc" id="L1016" title="All 4 branches missed.">                    if (index &lt; 0 || index &gt;= model.getLength()) {</span>
<span class="nc" id="L1017">                        return null;</span>
                    }
<span class="nc bnc" id="L1019" title="All 3 branches missed.">                    switch (part) {</span>
                    case AccessibleText.CHARACTER:
<span class="nc bnc" id="L1021" title="All 4 branches missed.">                        if (index + direction &lt; model.getLength() &amp;&amp;</span>
                            index + direction &gt;= 0) {
<span class="nc" id="L1023">                            return model.getText(index + direction, 1);</span>
                        }
                        break;


                    case AccessibleText.WORD:
                    case AccessibleText.SENTENCE:
<span class="nc" id="L1030">                        IndexedSegment seg = getSegmentAt(part, index);</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">                        if (seg != null) {</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                            if (direction != 0) {</span>
                                int next;


<span class="nc bnc" id="L1036" title="All 2 branches missed.">                                if (direction &lt; 0) {</span>
<span class="nc" id="L1037">                                    next = seg.modelOffset - 1;</span>
                                }
                                else {
<span class="nc" id="L1040">                                    next = seg.modelOffset + direction * seg.count;</span>
                                }
<span class="nc bnc" id="L1042" title="All 4 branches missed.">                                if (next &gt;= 0 &amp;&amp; next &lt;= model.getLength()) {</span>
<span class="nc" id="L1043">                                    seg = getSegmentAt(part, next);</span>
                                }
                                else {
<span class="nc" id="L1046">                                    seg = null;</span>
                                }
                            }
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                            if (seg != null) {</span>
<span class="nc" id="L1050">                                return new String(seg.array, seg.offset,</span>
                                                  seg.count);
                            }
                        }
                        break;

                    default:
                        break;
                    }
<span class="nc" id="L1059">                } catch (BadLocationException e) {</span>
                } finally {
<span class="nc bnc" id="L1061" title="All 12 branches missed.">                    if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L1062">                        ((AbstractDocument)model).readUnlock();</span>
                    }
                }
<span class="nc" id="L1065">                return null;</span>
            }

            /*
             * Returns the paragraph element for the specified index.
             */
            private Element getParagraphElement(int index) {
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                if (model instanceof PlainDocument ) {</span>
<span class="nc" id="L1073">                    PlainDocument sdoc = (PlainDocument)model;</span>
<span class="nc" id="L1074">                    return sdoc.getParagraphElement(index);</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">                } else if (model instanceof StyledDocument) {</span>
<span class="nc" id="L1076">                    StyledDocument sdoc = (StyledDocument)model;</span>
<span class="nc" id="L1077">                    return sdoc.getParagraphElement(index);</span>
                } else {
                    Element para;
<span class="nc bnc" id="L1080" title="All 2 branches missed.">                    for (para = model.getDefaultRootElement(); ! para.isLeaf(); ) {</span>
<span class="nc" id="L1081">                        int pos = para.getElementIndex(index);</span>
<span class="nc" id="L1082">                        para = para.getElement(pos);</span>
<span class="nc" id="L1083">                    }</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">                    if (para == null) {</span>
<span class="nc" id="L1085">                        return null;</span>
                    }
<span class="nc" id="L1087">                    return para.getParentElement();</span>
                }
            }

            /*
             * Returns a &lt;code&gt;Segment&lt;/code&gt; containing the paragraph text
             * at &lt;code&gt;index&lt;/code&gt;, or null if &lt;code&gt;index&lt;/code&gt; isn't
             * valid.
             */
            private IndexedSegment getParagraphElementText(int index)
                throws BadLocationException {
<span class="nc" id="L1098">                Element para = getParagraphElement(index);</span>


<span class="nc bnc" id="L1101" title="All 2 branches missed.">                if (para != null) {</span>
<span class="nc" id="L1102">                    IndexedSegment segment = new IndexedSegment();</span>
                    try {
<span class="nc" id="L1104">                        int length = para.getEndOffset() - para.getStartOffset();</span>
<span class="nc" id="L1105">                        model.getText(para.getStartOffset(), length, segment);</span>
<span class="nc" id="L1106">                    } catch (BadLocationException e) {</span>
<span class="nc" id="L1107">                        return null;</span>
<span class="nc" id="L1108">                    }</span>
<span class="nc" id="L1109">                    segment.modelOffset = para.getStartOffset();</span>
<span class="nc" id="L1110">                    return segment;</span>
                }
<span class="nc" id="L1112">                return null;</span>
            }


            /**
             * Returns the Segment at &lt;code&gt;index&lt;/code&gt; representing either
             * the paragraph or sentence as identified by &lt;code&gt;part&lt;/code&gt;, or
             * null if a valid paragraph/sentence can't be found. The offset
             * will point to the start of the word/sentence in the array, and
             * the modelOffset will point to the location of the word/sentence
             * in the model.
             */
            private IndexedSegment getSegmentAt(int part, int index)
                throws BadLocationException {

<span class="nc" id="L1127">                IndexedSegment seg = getParagraphElementText(index);</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">                if (seg == null) {</span>
<span class="nc" id="L1129">                    return null;</span>
                }
                BreakIterator iterator;
<span class="nc bnc" id="L1132" title="All 3 branches missed.">                switch (part) {</span>
                case AccessibleText.WORD:
<span class="nc" id="L1134">                    iterator = BreakIterator.getWordInstance(getLocale());</span>
<span class="nc" id="L1135">                    break;</span>
                case AccessibleText.SENTENCE:
<span class="nc" id="L1137">                    iterator = BreakIterator.getSentenceInstance(getLocale());</span>
<span class="nc" id="L1138">                    break;</span>
                default:
<span class="nc" id="L1140">                    return null;</span>
                }
<span class="nc" id="L1142">                seg.first();</span>
<span class="nc" id="L1143">                iterator.setText(seg);</span>
<span class="nc" id="L1144">                int end = iterator.following(index - seg.modelOffset + seg.offset);</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">                if (end == BreakIterator.DONE) {</span>
<span class="nc" id="L1146">                    return null;</span>
                }
<span class="nc bnc" id="L1148" title="All 2 branches missed.">                if (end &gt; seg.offset + seg.count) {</span>
<span class="nc" id="L1149">                    return null;</span>
                }
<span class="nc" id="L1151">                int begin = iterator.previous();</span>
<span class="nc bnc" id="L1152" title="All 4 branches missed.">                if (begin == BreakIterator.DONE ||</span>
                    begin &gt;= seg.offset + seg.count) {
<span class="nc" id="L1154">                    return null;</span>
                }
<span class="nc" id="L1156">                seg.modelOffset = seg.modelOffset + begin - seg.offset;</span>
<span class="nc" id="L1157">                seg.offset = begin;</span>
<span class="nc" id="L1158">                seg.count = end - begin;</span>
<span class="nc" id="L1159">                return seg;</span>
            }

            /**
             * Return the AttributeSet for a given character at a given index
             *
             * @param i the zero-based index into the text
             * @return the AttributeSet of the character
             */
            public AttributeSet getCharacterAttribute(int i) {
<span class="nc bnc" id="L1169" title="All 2 branches missed.">                if (model instanceof StyledDocument) {</span>
<span class="nc" id="L1170">                    StyledDocument doc = (StyledDocument)model;</span>
<span class="nc" id="L1171">                    Element elem = doc.getCharacterElement(i);</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">                    if (elem != null) {</span>
<span class="nc" id="L1173">                        return elem.getAttributes();</span>
                    }
                }
<span class="nc" id="L1176">                return null;</span>
            }

            /**
             * Returns the start offset within the selected text.
             * If there is no selection, but there is
             * a caret, the start and end offsets will be the same.
             *
             * @return the index into the text of the start of the selection
             */
            public int getSelectionStart() {
<span class="nc" id="L1187">                return editor.getSelectionStart();</span>
            }

            /**
             * Returns the end offset within the selected text.
             * If there is no selection, but there is
             * a caret, the start and end offsets will be the same.
             *
             * @return the index into the text of the end of the selection
             */
            public int getSelectionEnd() {
<span class="nc" id="L1198">                return editor.getSelectionEnd();</span>
            }

            /**
             * Returns the portion of the text that is selected.
             *
             * @return the String portion of the text that is selected
             */
            public String getSelectedText() {
<span class="nc" id="L1207">                return editor.getSelectedText();</span>
            }

            /*
             * Returns the text substring starting at the specified
             * offset with the specified length.
             */
            private String getText(int offset, int length)
                throws BadLocationException {

<span class="nc bnc" id="L1217" title="All 4 branches missed.">                if (model != null &amp;&amp; model instanceof StyledDocument) {</span>
<span class="nc" id="L1218">                    StyledDocument doc = (StyledDocument)model;</span>
<span class="nc" id="L1219">                    return model.getText(offset, length);</span>
                } else {
<span class="nc" id="L1221">                    return null;</span>
                }
            }
        }
    }

    /*
     * ElementInfo for images
     */
    private class IconElementInfo extends ElementInfo implements Accessible {

<span class="nc" id="L1232">        private int width = -1;</span>
<span class="nc" id="L1233">        private int height = -1;</span>

<span class="nc" id="L1235">        IconElementInfo(Element element, ElementInfo parent) {</span>
<span class="nc" id="L1236">            super(element, parent);</span>
<span class="nc" id="L1237">        }</span>

        protected void invalidate(boolean first) {
<span class="nc" id="L1240">            super.invalidate(first);</span>
<span class="nc" id="L1241">            width = height = -1;</span>
<span class="nc" id="L1242">        }</span>

        private int getImageSize(Object key) {
<span class="nc bnc" id="L1245" title="All 2 branches missed.">            if (validateIfNecessary()) {</span>
<span class="nc" id="L1246">                int size = getIntAttr(getAttributes(), key, -1);</span>

<span class="nc bnc" id="L1248" title="All 2 branches missed.">                if (size == -1) {</span>
<span class="nc" id="L1249">                    View v = getView();</span>

<span class="nc" id="L1251">                    size = 0;</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">                    if (v instanceof ImageView) {</span>
<span class="nc" id="L1253">                        Image img = ((ImageView)v).getImage();</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">                        if (img != null) {</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">                            if (key == HTML.Attribute.WIDTH) {</span>
<span class="nc" id="L1256">                                size = img.getWidth(null);</span>
                            }
                            else {
<span class="nc" id="L1259">                                size = img.getHeight(null);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L1264">                return size;</span>
            }
<span class="nc" id="L1266">            return 0;</span>
        }

        // begin AccessibleIcon implementation ...
        private AccessibleContext accessibleContext;

        public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L1273" title="All 2 branches missed.">            if (accessibleContext == null) {</span>
<span class="nc" id="L1274">                accessibleContext = new IconAccessibleContext(this);</span>
            }
<span class="nc" id="L1276">            return accessibleContext;</span>
        }

        /*
         * AccessibleContext for images
         */
        protected class IconAccessibleContext extends HTMLAccessibleContext
            implements AccessibleIcon  {

<span class="nc" id="L1285">            public IconAccessibleContext(ElementInfo elementInfo) {</span>
<span class="nc" id="L1286">                super(elementInfo);</span>
<span class="nc" id="L1287">            }</span>

            /**
             * Gets the accessibleName property of this object.  The accessibleName
             * property of an object is a localized String that designates the purpose
             * of the object.  For example, the accessibleName property of a label
             * or button might be the text of the label or button itself.  In the
             * case of an object that doesn't display its name, the accessibleName
             * should still be set.  For example, in the case of a text field used
             * to enter the name of a city, the accessibleName for the en_US locale
             * could be 'city.'
             *
             * @return the localized name of the object; null if this
             * object does not have a name
             *
             * @see #setAccessibleName
             */
            public String getAccessibleName() {
<span class="nc" id="L1305">                return getAccessibleIconDescription();</span>
            }

            /**
             * Gets the accessibleDescription property of this object.  If this
             * property isn't set, returns the content type of this
             * &lt;code&gt;JEditorPane&lt;/code&gt; instead (e.g. &quot;plain/text&quot;, &quot;html/text&quot;).
             *
             * @return the localized description of the object; &lt;code&gt;null&lt;/code&gt;
             *  if this object does not have a description
             *
             * @see #setAccessibleName
             */
            public String getAccessibleDescription() {
<span class="nc" id="L1319">                return editor.getContentType();</span>
            }

            /**
             * Gets the role of this object.  The role of the object is the generic
             * purpose or use of the class of this object.  For example, the role
             * of a push button is AccessibleRole.PUSH_BUTTON.  The roles in
             * AccessibleRole are provided so component developers can pick from
             * a set of predefined roles.  This enables assistive technologies to
             * provide a consistent interface to various tweaked subclasses of
             * components (e.g., use AccessibleRole.PUSH_BUTTON for all components
             * that act like a push button) as well as distinguish between subclasses
             * that behave differently (e.g., AccessibleRole.CHECK_BOX for check boxes
             * and AccessibleRole.RADIO_BUTTON for radio buttons).
             * &lt;p&gt;Note that the AccessibleRole class is also extensible, so
             * custom component developers can define their own AccessibleRole's
             * if the set of predefined roles is inadequate.
             *
             * @return an instance of AccessibleRole describing the role of the object
             * @see AccessibleRole
             */
            public AccessibleRole getAccessibleRole() {
<span class="nc" id="L1341">                return AccessibleRole.ICON;</span>
            }

            public AccessibleIcon [] getAccessibleIcon() {
<span class="nc" id="L1345">                AccessibleIcon [] icons = new AccessibleIcon[1];</span>
<span class="nc" id="L1346">                icons[0] = this;</span>
<span class="nc" id="L1347">                return icons;</span>
            }

            /**
             * Gets the description of the icon.  This is meant to be a brief
             * textual description of the object.  For example, it might be
             * presented to a blind user to give an indication of the purpose
             * of the icon.
             *
             * @return the description of the icon
             */
            public String getAccessibleIconDescription() {
<span class="nc" id="L1359">                return ((ImageView)getView()).getAltText();</span>
            }

            /**
             * Sets the description of the icon.  This is meant to be a brief
             * textual description of the object.  For example, it might be
             * presented to a blind user to give an indication of the purpose
             * of the icon.
             *
             * @param description the description of the icon
             */
            public void setAccessibleIconDescription(String description) {
<span class="nc" id="L1371">            }</span>

            /**
             * Gets the width of the icon
             *
             * @return the width of the icon.
             */
            public int getAccessibleIconWidth() {
<span class="nc bnc" id="L1379" title="All 2 branches missed.">                if (width == -1) {</span>
<span class="nc" id="L1380">                    width = getImageSize(HTML.Attribute.WIDTH);</span>
                }
<span class="nc" id="L1382">                return width;</span>
            }

            /**
             * Gets the height of the icon
             *
             * @return the height of the icon.
             */
            public int getAccessibleIconHeight() {
<span class="nc bnc" id="L1391" title="All 2 branches missed.">                if (height == -1) {</span>
<span class="nc" id="L1392">                    height = getImageSize(HTML.Attribute.HEIGHT);</span>
                }
<span class="nc" id="L1394">                return height;</span>
            }
        }
        // ... end AccessibleIconImplementation
    }


    /**
     * TableElementInfo encapsulates information about a HTML.Tag.TABLE.
     * To make access fast it crates a grid containing the children to
     * allow for access by row, column. TableElementInfo will contain
     * TableRowElementInfos, which will contain TableCellElementInfos.
     * Any time one of the rows or columns becomes invalid the table is
     * invalidated.  This is because any time one of the child attributes
     * changes the size of the grid may have changed.
     */
    private class TableElementInfo extends ElementInfo
        implements Accessible {

        protected ElementInfo caption;

        /**
         * Allocation of the table by row x column. There may be holes (eg
         * nulls) depending upon the html, any cell that has a rowspan/colspan
         * &gt; 1 will be contained multiple times in the grid.
         */
        private TableCellElementInfo[][] grid;


<span class="nc" id="L1423">        TableElementInfo(Element e, ElementInfo parent) {</span>
<span class="nc" id="L1424">            super(e, parent);</span>
<span class="nc" id="L1425">        }</span>

        public ElementInfo getCaptionInfo() {
<span class="nc" id="L1428">            return caption;</span>
        }

        /**
         * Overriden to update the grid when validating.
         */
        protected void validate() {
<span class="nc" id="L1435">            super.validate();</span>
<span class="nc" id="L1436">            updateGrid();</span>
<span class="nc" id="L1437">        }</span>

        /**
         * Overriden to only alloc instances of TableRowElementInfos.
         */
        protected void loadChildren(Element e) {

<span class="nc bnc" id="L1444" title="All 2 branches missed.">            for (int counter = 0; counter &lt; e.getElementCount(); counter++) {</span>
<span class="nc" id="L1445">                Element child = e.getElement(counter);</span>
<span class="nc" id="L1446">                AttributeSet attrs = child.getAttributes();</span>

<span class="nc bnc" id="L1448" title="All 2 branches missed.">                if (attrs.getAttribute(StyleConstants.NameAttribute) ==</span>
                                       HTML.Tag.TR) {
<span class="nc" id="L1450">                    addChild(new TableRowElementInfo(child, this, counter));</span>

<span class="nc bnc" id="L1452" title="All 2 branches missed.">                } else if (attrs.getAttribute(StyleConstants.NameAttribute) ==</span>
                                       HTML.Tag.CAPTION) {
                    // Handle captions as a special case since all other
                    // children are table rows.
<span class="nc" id="L1456">                    caption = createElementInfo(child, this);</span>
                }
            }
<span class="nc" id="L1459">        }</span>

        /**
         * Updates the grid.
         */
        private void updateGrid() {
            // Determine the max row/col count.
<span class="nc" id="L1466">            int delta = 0;</span>
<span class="nc" id="L1467">            int maxCols = 0;</span>
            int rows;
<span class="nc bnc" id="L1469" title="All 2 branches missed.">            for (int counter = 0; counter &lt; getChildCount(); counter++) {</span>
<span class="nc" id="L1470">                TableRowElementInfo row = getRow(counter);</span>
<span class="nc" id="L1471">                int prev = 0;</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">                for (int y = 0; y &lt; delta; y++) {</span>
<span class="nc" id="L1473">                    prev = Math.max(prev, getRow(counter - y - 1).</span>
                                    getColumnCount(y + 2));
                }
<span class="nc" id="L1476">                delta = Math.max(row.getRowCount(), delta);</span>
<span class="nc" id="L1477">                delta--;</span>
<span class="nc" id="L1478">                maxCols = Math.max(maxCols, row.getColumnCount() + prev);</span>
            }
<span class="nc" id="L1480">            rows = getChildCount() + delta;</span>

            // Alloc
<span class="nc" id="L1483">            grid = new TableCellElementInfo[rows][];</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">            for (int counter = 0; counter &lt; rows; counter++) {</span>
<span class="nc" id="L1485">                grid[counter] = new TableCellElementInfo[maxCols];</span>
            }
            // Update
<span class="nc bnc" id="L1488" title="All 2 branches missed.">            for (int counter = 0; counter &lt; rows; counter++) {</span>
<span class="nc" id="L1489">                getRow(counter).updateGrid(counter);</span>
            }
<span class="nc" id="L1491">        }</span>

        /**
         * Returns the TableCellElementInfo at the specified index.
         */
        public TableRowElementInfo getRow(int index) {
<span class="nc" id="L1497">            return (TableRowElementInfo)getChild(index);</span>
        }

        /**
         * Returns the TableCellElementInfo by row and column.
         */
        public TableCellElementInfo getCell(int r, int c) {
<span class="nc bnc" id="L1504" title="All 6 branches missed.">            if (validateIfNecessary() &amp;&amp; r &lt; grid.length &amp;&amp;</span>
                                         c &lt; grid[0].length) {
<span class="nc" id="L1506">                return grid[r][c];</span>
            }
<span class="nc" id="L1508">            return null;</span>
        }

        /**
         * Returns the rowspan of the specified entry.
         */
        public int getRowExtentAt(int r, int c) {
<span class="nc" id="L1515">            TableCellElementInfo cell = getCell(r, c);</span>

<span class="nc bnc" id="L1517" title="All 2 branches missed.">            if (cell != null) {</span>
<span class="nc" id="L1518">                int rows = cell.getRowCount();</span>
<span class="nc" id="L1519">                int delta = 1;</span>

<span class="nc bnc" id="L1521" title="All 4 branches missed.">                while ((r - delta) &gt;= 0 &amp;&amp; grid[r - delta][c] == cell) {</span>
<span class="nc" id="L1522">                    delta++;</span>
                }
<span class="nc" id="L1524">                return rows - delta + 1;</span>
            }
<span class="nc" id="L1526">            return 0;</span>
        }

        /**
         * Returns the colspan of the specified entry.
         */
        public int getColumnExtentAt(int r, int c) {
<span class="nc" id="L1533">            TableCellElementInfo cell = getCell(r, c);</span>

<span class="nc bnc" id="L1535" title="All 2 branches missed.">            if (cell != null) {</span>
<span class="nc" id="L1536">                int cols = cell.getColumnCount();</span>
<span class="nc" id="L1537">                int delta = 1;</span>

<span class="nc bnc" id="L1539" title="All 4 branches missed.">                while ((c - delta) &gt;= 0 &amp;&amp; grid[r][c - delta] == cell) {</span>
<span class="nc" id="L1540">                    delta++;</span>
                }
<span class="nc" id="L1542">                return cols - delta + 1;</span>
            }
<span class="nc" id="L1544">            return 0;</span>
        }

        /**
         * Returns the number of rows in the table.
         */
        public int getRowCount() {
<span class="nc bnc" id="L1551" title="All 2 branches missed.">            if (validateIfNecessary()) {</span>
<span class="nc" id="L1552">                return grid.length;</span>
            }
<span class="nc" id="L1554">            return 0;</span>
        }

        /**
         * Returns the number of columns in the table.
         */
        public int getColumnCount() {
<span class="nc bnc" id="L1561" title="All 4 branches missed.">            if (validateIfNecessary() &amp;&amp; grid.length &gt; 0) {</span>
<span class="nc" id="L1562">                return grid[0].length;</span>
            }
<span class="nc" id="L1564">            return 0;</span>
        }

        // begin AccessibleTable implementation ...
        private AccessibleContext accessibleContext;

        public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L1571" title="All 2 branches missed.">            if (accessibleContext == null) {</span>
<span class="nc" id="L1572">                accessibleContext = new TableAccessibleContext(this);</span>
            }
<span class="nc" id="L1574">            return accessibleContext;</span>
        }

        /*
         * AccessibleContext for tables
         */
        public class TableAccessibleContext extends HTMLAccessibleContext
            implements AccessibleTable {

            private AccessibleHeadersTable rowHeadersTable;

<span class="nc" id="L1585">            public TableAccessibleContext(ElementInfo elementInfo) {</span>
<span class="nc" id="L1586">                super(elementInfo);</span>
<span class="nc" id="L1587">            }</span>

            /**
             * Gets the accessibleName property of this object.  The accessibleName
             * property of an object is a localized String that designates the purpose
             * of the object.  For example, the accessibleName property of a label
             * or button might be the text of the label or button itself.  In the
             * case of an object that doesn't display its name, the accessibleName
             * should still be set.  For example, in the case of a text field used
             * to enter the name of a city, the accessibleName for the en_US locale
             * could be 'city.'
             *
             * @return the localized name of the object; null if this
             * object does not have a name
             *
             * @see #setAccessibleName
             */
            public String getAccessibleName() {
                // return the role of the object
<span class="nc" id="L1606">                return getAccessibleRole().toString();</span>
            }

            /**
             * Gets the accessibleDescription property of this object.  If this
             * property isn't set, returns the content type of this
             * &lt;code&gt;JEditorPane&lt;/code&gt; instead (e.g. &quot;plain/text&quot;, &quot;html/text&quot;).
             *
             * @return the localized description of the object; &lt;code&gt;null&lt;/code&gt;
             *  if this object does not have a description
             *
             * @see #setAccessibleName
             */
            public String getAccessibleDescription() {
<span class="nc" id="L1620">                return editor.getContentType();</span>
            }

            /**
             * Gets the role of this object.  The role of the object is the generic
             * purpose or use of the class of this object.  For example, the role
             * of a push button is AccessibleRole.PUSH_BUTTON.  The roles in
             * AccessibleRole are provided so component developers can pick from
             * a set of predefined roles.  This enables assistive technologies to
             * provide a consistent interface to various tweaked subclasses of
             * components (e.g., use AccessibleRole.PUSH_BUTTON for all components
             * that act like a push button) as well as distinguish between subclasses
             * that behave differently (e.g., AccessibleRole.CHECK_BOX for check boxes
             * and AccessibleRole.RADIO_BUTTON for radio buttons).
             * &lt;p&gt;Note that the AccessibleRole class is also extensible, so
             * custom component developers can define their own AccessibleRole's
             * if the set of predefined roles is inadequate.
             *
             * @return an instance of AccessibleRole describing the role of the object
             * @see AccessibleRole
             */
            public AccessibleRole getAccessibleRole() {
<span class="nc" id="L1642">                return AccessibleRole.TABLE;</span>
            }

            /**
             * Gets the 0-based index of this object in its accessible parent.
             *
             * @return the 0-based index of this object in its parent; -1 if this
             * object does not have an accessible parent.
             *
             * @see #getAccessibleParent
             * @see #getAccessibleChildrenCount
             * @gsee #getAccessibleChild
             */
            public int getAccessibleIndexInParent() {
<span class="nc" id="L1656">                return elementInfo.getIndexInParent();</span>
            }

            /**
             * Returns the number of accessible children of the object.
             *
             * @return the number of accessible children of the object.
             */
            public int getAccessibleChildrenCount() {
<span class="nc" id="L1665">                return ((TableElementInfo)elementInfo).getRowCount() *</span>
<span class="nc" id="L1666">                    ((TableElementInfo)elementInfo).getColumnCount();</span>
            }

            /**
             * Returns the specified Accessible child of the object.  The Accessible
             * children of an Accessible object are zero-based, so the first child
             * of an Accessible child is at index 0, the second child is at index 1,
             * and so on.
             *
             * @param i zero-based index of child
             * @return the Accessible child of the object
             * @see #getAccessibleChildrenCount
             */
            public Accessible getAccessibleChild(int i) {
<span class="nc" id="L1680">                int rowCount = ((TableElementInfo)elementInfo).getRowCount();</span>
<span class="nc" id="L1681">                int columnCount = ((TableElementInfo)elementInfo).getColumnCount();</span>
<span class="nc" id="L1682">                int r = i / rowCount;</span>
<span class="nc" id="L1683">                int c = i % columnCount;</span>
<span class="nc bnc" id="L1684" title="All 8 branches missed.">                if (r &lt; 0 || r &gt;= rowCount || c &lt; 0 || c &gt;= columnCount) {</span>
<span class="nc" id="L1685">                    return null;</span>
                } else {
<span class="nc" id="L1687">                    return getAccessibleAt(r, c);</span>
                }
            }

            public AccessibleTable getAccessibleTable() {
<span class="nc" id="L1692">                return this;</span>
            }

            /**
             * Returns the caption for the table.
             *
             * @return the caption for the table
             */
            public Accessible getAccessibleCaption() {
<span class="nc" id="L1701">                ElementInfo captionInfo = getCaptionInfo();</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">                if (captionInfo instanceof Accessible) {</span>
<span class="nc" id="L1703">                    return (Accessible)caption;</span>
                } else {
<span class="nc" id="L1705">                    return null;</span>
                }
            }

            /**
             * Sets the caption for the table.
             *
             * @param a the caption for the table
             */
            public void setAccessibleCaption(Accessible a) {
<span class="nc" id="L1715">            }</span>

            /**
             * Returns the summary description of the table.
             *
             * @return the summary description of the table
             */
            public Accessible getAccessibleSummary() {
<span class="nc" id="L1723">                return null;</span>
            }

            /**
             * Sets the summary description of the table
             *
             * @param a the summary description of the table
             */
            public void setAccessibleSummary(Accessible a) {
<span class="nc" id="L1732">            }</span>

            /**
             * Returns the number of rows in the table.
             *
             * @return the number of rows in the table
             */
            public int getAccessibleRowCount() {
<span class="nc" id="L1740">                return ((TableElementInfo)elementInfo).getRowCount();</span>
            }

            /**
             * Returns the number of columns in the table.
             *
             * @return the number of columns in the table
             */
            public int getAccessibleColumnCount() {
<span class="nc" id="L1749">                return ((TableElementInfo)elementInfo).getColumnCount();</span>
            }

            /**
             * Returns the Accessible at a specified row and column
             * in the table.
             *
             * @param r zero-based row of the table
             * @param c zero-based column of the table
             * @return the Accessible at the specified row and column
             */
            public Accessible getAccessibleAt(int r, int c) {
<span class="nc" id="L1761">                TableCellElementInfo cellInfo = getCell(r, c);</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">                if (cellInfo != null) {</span>
<span class="nc" id="L1763">                    return cellInfo.getAccessible();</span>
                } else {
<span class="nc" id="L1765">                    return null;</span>
                }
            }

            /**
             * Returns the number of rows occupied by the Accessible at
             * a specified row and column in the table.
             *
             * @return the number of rows occupied by the Accessible at a
             * given specified (row, column)
             */
            public int getAccessibleRowExtentAt(int r, int c) {
<span class="nc" id="L1777">                return ((TableElementInfo)elementInfo).getRowExtentAt(r, c);</span>
            }

            /**
             * Returns the number of columns occupied by the Accessible at
             * a specified row and column in the table.
             *
             * @return the number of columns occupied by the Accessible at a
             * given specified row and column
             */
            public int getAccessibleColumnExtentAt(int r, int c) {
<span class="nc" id="L1788">                return ((TableElementInfo)elementInfo).getColumnExtentAt(r, c);</span>
            }

            /**
             * Returns the row headers as an AccessibleTable.
             *
             * @return an AccessibleTable representing the row
             * headers
             */
            public AccessibleTable getAccessibleRowHeader() {
<span class="nc" id="L1798">                return rowHeadersTable;</span>
            }

            /**
             * Sets the row headers.
             *
             * @param table an AccessibleTable representing the
             * row headers
             */
            public void setAccessibleRowHeader(AccessibleTable table) {
<span class="nc" id="L1808">            }</span>

            /**
             * Returns the column headers as an AccessibleTable.
             *
             * @return an AccessibleTable representing the column
             * headers
             */
            public AccessibleTable getAccessibleColumnHeader() {
<span class="nc" id="L1817">                return null;</span>
            }

            /**
             * Sets the column headers.
             *
             * @param table an AccessibleTable representing the
             * column headers
             */
            public void setAccessibleColumnHeader(AccessibleTable table) {
<span class="nc" id="L1827">            }</span>

            /**
             * Returns the description of the specified row in the table.
             *
             * @param r zero-based row of the table
             * @return the description of the row
             */
            public Accessible getAccessibleRowDescription(int r) {
<span class="nc" id="L1836">                return null;</span>
            }

            /**
             * Sets the description text of the specified row of the table.
             *
             * @param r zero-based row of the table
             * @param a the description of the row
             */
            public void setAccessibleRowDescription(int r, Accessible a) {
<span class="nc" id="L1846">            }</span>

            /**
             * Returns the description text of the specified column in the table.
             *
             * @param c zero-based column of the table
             * @return the text description of the column
             */
            public Accessible getAccessibleColumnDescription(int c) {
<span class="nc" id="L1855">                return null;</span>
            }

            /**
             * Sets the description text of the specified column in the table.
             *
             * @param c zero-based column of the table
             * @param a the text description of the column
             */
            public void setAccessibleColumnDescription(int c, Accessible a) {
<span class="nc" id="L1865">            }</span>

            /**
             * Returns a boolean value indicating whether the accessible at
             * a specified row and column is selected.
             *
             * @param r zero-based row of the table
             * @param c zero-based column of the table
             * @return the boolean value true if the accessible at the
             * row and column is selected. Otherwise, the boolean value
             * false
             */
            public boolean isAccessibleSelected(int r, int c) {
<span class="nc bnc" id="L1878" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc bnc" id="L1879" title="All 6 branches missed.">                    if (r &lt; 0 || r &gt;= getAccessibleRowCount() ||</span>
<span class="nc bnc" id="L1880" title="All 2 branches missed.">                        c &lt; 0 || c &gt;= getAccessibleColumnCount()) {</span>
<span class="nc" id="L1881">                        return false;</span>
                    }
<span class="nc" id="L1883">                    TableCellElementInfo cell = getCell(r, c);</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">                    if (cell != null) {</span>
<span class="nc" id="L1885">                        Element elem = cell.getElement();</span>
<span class="nc" id="L1886">                        int start = elem.getStartOffset();</span>
<span class="nc" id="L1887">                        int end = elem.getEndOffset();</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">                        return start &gt;= editor.getSelectionStart() &amp;&amp;</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">                            end &lt;= editor.getSelectionEnd();</span>
                    }
                }
<span class="nc" id="L1892">                return false;</span>
            }

            /**
             * Returns a boolean value indicating whether the specified row
             * is selected.
             *
             * @param r zero-based row of the table
             * @return the boolean value true if the specified row is selected.
             * Otherwise, false.
             */
            public boolean isAccessibleRowSelected(int r) {
<span class="nc bnc" id="L1904" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc bnc" id="L1905" title="All 4 branches missed.">                    if (r &lt; 0 || r &gt;= getAccessibleRowCount()) {</span>
<span class="nc" id="L1906">                        return false;</span>
                    }
<span class="nc" id="L1908">                    int nColumns = getAccessibleColumnCount();</span>

<span class="nc" id="L1910">                    TableCellElementInfo startCell = getCell(r, 0);</span>
<span class="nc bnc" id="L1911" title="All 2 branches missed.">                    if (startCell == null) {</span>
<span class="nc" id="L1912">                        return false;</span>
                    }
<span class="nc" id="L1914">                    int start = startCell.getElement().getStartOffset();</span>

<span class="nc" id="L1916">                    TableCellElementInfo endCell = getCell(r, nColumns-1);</span>
<span class="nc bnc" id="L1917" title="All 2 branches missed.">                    if (endCell == null) {</span>
<span class="nc" id="L1918">                        return false;</span>
                    }
<span class="nc" id="L1920">                    int end = endCell.getElement().getEndOffset();</span>

<span class="nc bnc" id="L1922" title="All 2 branches missed.">                    return start &gt;= editor.getSelectionStart() &amp;&amp;</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">                        end &lt;= editor.getSelectionEnd();</span>
                }
<span class="nc" id="L1925">                return false;</span>
            }

            /**
             * Returns a boolean value indicating whether the specified column
             * is selected.
             *
             * @param c zero-based column of the table
             * @return the boolean value true if the specified column is selected.
             * Otherwise, false.
             */
            public boolean isAccessibleColumnSelected(int c) {
<span class="nc bnc" id="L1937" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc bnc" id="L1938" title="All 4 branches missed.">                    if (c &lt; 0 || c &gt;= getAccessibleColumnCount()) {</span>
<span class="nc" id="L1939">                        return false;</span>
                    }
<span class="nc" id="L1941">                    int nRows = getAccessibleRowCount();</span>

<span class="nc" id="L1943">                    TableCellElementInfo startCell = getCell(0, c);</span>
<span class="nc bnc" id="L1944" title="All 2 branches missed.">                    if (startCell == null) {</span>
<span class="nc" id="L1945">                        return false;</span>
                    }
<span class="nc" id="L1947">                    int start = startCell.getElement().getStartOffset();</span>

<span class="nc" id="L1949">                    TableCellElementInfo endCell = getCell(nRows-1, c);</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">                    if (endCell == null) {</span>
<span class="nc" id="L1951">                        return false;</span>
                    }
<span class="nc" id="L1953">                    int end = endCell.getElement().getEndOffset();</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">                    return start &gt;= editor.getSelectionStart() &amp;&amp;</span>
<span class="nc bnc" id="L1955" title="All 2 branches missed.">                        end &lt;= editor.getSelectionEnd();</span>
                }
<span class="nc" id="L1957">                return false;</span>
            }

            /**
             * Returns the selected rows in a table.
             *
             * @return an array of selected rows where each element is a
             * zero-based row of the table
             */
            public int [] getSelectedAccessibleRows() {
<span class="nc bnc" id="L1967" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc" id="L1968">                    int nRows = getAccessibleRowCount();</span>
<span class="nc" id="L1969">                    Vector&lt;Integer&gt; vec = new Vector&lt;Integer&gt;();</span>

<span class="nc bnc" id="L1971" title="All 2 branches missed.">                    for (int i = 0; i &lt; nRows; i++) {</span>
<span class="nc bnc" id="L1972" title="All 2 branches missed.">                        if (isAccessibleRowSelected(i)) {</span>
<span class="nc" id="L1973">                            vec.addElement(Integer.valueOf(i));</span>
                        }
                    }
<span class="nc" id="L1976">                    int retval[] = new int[vec.size()];</span>
<span class="nc bnc" id="L1977" title="All 2 branches missed.">                    for (int i = 0; i &lt; retval.length; i++) {</span>
<span class="nc" id="L1978">                        retval[i] = vec.elementAt(i).intValue();</span>
                    }
<span class="nc" id="L1980">                    return retval;</span>
                }
<span class="nc" id="L1982">                return new int[0];</span>
            }

            /**
             * Returns the selected columns in a table.
             *
             * @return an array of selected columns where each element is a
             * zero-based column of the table
             */
            public int [] getSelectedAccessibleColumns() {
<span class="nc bnc" id="L1992" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc" id="L1993">                    int nColumns = getAccessibleRowCount();</span>
<span class="nc" id="L1994">                    Vector&lt;Integer&gt; vec = new Vector&lt;Integer&gt;();</span>

<span class="nc bnc" id="L1996" title="All 2 branches missed.">                    for (int i = 0; i &lt; nColumns; i++) {</span>
<span class="nc bnc" id="L1997" title="All 2 branches missed.">                        if (isAccessibleColumnSelected(i)) {</span>
<span class="nc" id="L1998">                            vec.addElement(Integer.valueOf(i));</span>
                        }
                    }
<span class="nc" id="L2001">                    int retval[] = new int[vec.size()];</span>
<span class="nc bnc" id="L2002" title="All 2 branches missed.">                    for (int i = 0; i &lt; retval.length; i++) {</span>
<span class="nc" id="L2003">                        retval[i] = vec.elementAt(i).intValue();</span>
                    }
<span class="nc" id="L2005">                    return retval;</span>
                }
<span class="nc" id="L2007">                return new int[0];</span>
            }

            // begin AccessibleExtendedTable implementation -------------

            /**
             * Returns the row number of an index in the table.
             *
             * @param index the zero-based index in the table
             * @return the zero-based row of the table if one exists;
             * otherwise -1.
             */
            public int getAccessibleRow(int index) {
<span class="nc bnc" id="L2020" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc" id="L2021">                    int numCells = getAccessibleColumnCount() *</span>
<span class="nc" id="L2022">                        getAccessibleRowCount();</span>
<span class="nc bnc" id="L2023" title="All 2 branches missed.">                    if (index &gt;= numCells) {</span>
<span class="nc" id="L2024">                        return -1;</span>
                    } else {
<span class="nc" id="L2026">                        return index / getAccessibleColumnCount();</span>
                    }
                }
<span class="nc" id="L2029">                return -1;</span>
            }

            /**
             * Returns the column number of an index in the table.
             *
             * @param index the zero-based index in the table
             * @return the zero-based column of the table if one exists;
             * otherwise -1.
             */
            public int getAccessibleColumn(int index) {
<span class="nc bnc" id="L2040" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc" id="L2041">                    int numCells = getAccessibleColumnCount() *</span>
<span class="nc" id="L2042">                        getAccessibleRowCount();</span>
<span class="nc bnc" id="L2043" title="All 2 branches missed.">                    if (index &gt;= numCells) {</span>
<span class="nc" id="L2044">                        return -1;</span>
                    } else {
<span class="nc" id="L2046">                        return index % getAccessibleColumnCount();</span>
                    }
                }
<span class="nc" id="L2049">                return -1;</span>
            }

            /**
             * Returns the index at a row and column in the table.
             *
             * @param r zero-based row of the table
             * @param c zero-based column of the table
             * @return the zero-based index in the table if one exists;
             * otherwise -1.
             */
            public int getAccessibleIndex(int r, int c) {
<span class="nc bnc" id="L2061" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc bnc" id="L2062" title="All 2 branches missed.">                    if (r &gt;= getAccessibleRowCount() ||</span>
<span class="nc bnc" id="L2063" title="All 2 branches missed.">                        c &gt;= getAccessibleColumnCount()) {</span>
<span class="nc" id="L2064">                        return -1;</span>
                    } else {
<span class="nc" id="L2066">                        return r * getAccessibleColumnCount() + c;</span>
                    }
                }
<span class="nc" id="L2069">                return -1;</span>
            }

            /**
             * Returns the row header at a row in a table.
             * @param r zero-based row of the table
             *
             * @return a String representing the row header
             * if one exists; otherwise null.
             */
            public String getAccessibleRowHeader(int r) {
<span class="nc bnc" id="L2080" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc" id="L2081">                    TableCellElementInfo cellInfo = getCell(r, 0);</span>
<span class="nc bnc" id="L2082" title="All 2 branches missed.">                    if (cellInfo.isHeaderCell()) {</span>
<span class="nc" id="L2083">                        View v = cellInfo.getView();</span>
<span class="nc bnc" id="L2084" title="All 4 branches missed.">                        if (v != null &amp;&amp; model != null) {</span>
                            try {
<span class="nc" id="L2086">                                return model.getText(v.getStartOffset(),</span>
<span class="nc" id="L2087">                                                     v.getEndOffset() -</span>
<span class="nc" id="L2088">                                                     v.getStartOffset());</span>
<span class="nc" id="L2089">                            } catch (BadLocationException e) {</span>
<span class="nc" id="L2090">                                return null;</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2095">                return null;</span>
            }

            /**
             * Returns the column header at a column in a table.
             * @param c zero-based column of the table
             *
             * @return a String representing the column header
             * if one exists; otherwise null.
             */
            public String getAccessibleColumnHeader(int c) {
<span class="nc bnc" id="L2106" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc" id="L2107">                    TableCellElementInfo cellInfo = getCell(0, c);</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">                    if (cellInfo.isHeaderCell()) {</span>
<span class="nc" id="L2109">                        View v = cellInfo.getView();</span>
<span class="nc bnc" id="L2110" title="All 4 branches missed.">                        if (v != null &amp;&amp; model != null) {</span>
                            try {
<span class="nc" id="L2112">                                return model.getText(v.getStartOffset(),</span>
<span class="nc" id="L2113">                                                     v.getEndOffset() -</span>
<span class="nc" id="L2114">                                                     v.getStartOffset());</span>
<span class="nc" id="L2115">                            } catch (BadLocationException e) {</span>
<span class="nc" id="L2116">                                return null;</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2121">                return null;</span>
            }

            public void addRowHeader(TableCellElementInfo cellInfo, int rowNumber) {
<span class="nc bnc" id="L2125" title="All 2 branches missed.">                if (rowHeadersTable == null) {</span>
<span class="nc" id="L2126">                    rowHeadersTable = new AccessibleHeadersTable();</span>
                }
<span class="nc" id="L2128">                rowHeadersTable.addHeader(cellInfo, rowNumber);</span>
<span class="nc" id="L2129">            }</span>
            // end of AccessibleExtendedTable implementation ------------

<span class="nc" id="L2132">            protected class AccessibleHeadersTable implements AccessibleTable {</span>

                // Header information is modeled as a Hashtable of
                // ArrayLists where each Hashtable entry represents
                // a row containing one or more headers.
<span class="nc" id="L2137">                private Hashtable&lt;Integer, ArrayList&lt;TableCellElementInfo&gt;&gt; headers =</span>
                        new Hashtable&lt;Integer, ArrayList&lt;TableCellElementInfo&gt;&gt;();
<span class="nc" id="L2139">                private int rowCount = 0;</span>
<span class="nc" id="L2140">                private int columnCount = 0;</span>

                public void addHeader(TableCellElementInfo cellInfo, int rowNumber) {
<span class="nc" id="L2143">                    Integer rowInteger = Integer.valueOf(rowNumber);</span>
<span class="nc" id="L2144">                    ArrayList&lt;TableCellElementInfo&gt; list = headers.get(rowInteger);</span>
<span class="nc bnc" id="L2145" title="All 2 branches missed.">                    if (list == null) {</span>
<span class="nc" id="L2146">                        list = new ArrayList&lt;TableCellElementInfo&gt;();</span>
<span class="nc" id="L2147">                        headers.put(rowInteger, list);</span>
                    }
<span class="nc" id="L2149">                    list.add(cellInfo);</span>
<span class="nc" id="L2150">                }</span>

                /**
                 * Returns the caption for the table.
                 *
                 * @return the caption for the table
                 */
                public Accessible getAccessibleCaption() {
<span class="nc" id="L2158">                    return null;</span>
                }

                /**
                 * Sets the caption for the table.
                 *
                 * @param a the caption for the table
                 */
                public void setAccessibleCaption(Accessible a) {
<span class="nc" id="L2167">                }</span>

                /**
                 * Returns the summary description of the table.
                 *
                 * @return the summary description of the table
                 */
                public Accessible getAccessibleSummary() {
<span class="nc" id="L2175">                    return null;</span>
                }

                /**
                 * Sets the summary description of the table
                 *
                 * @param a the summary description of the table
                 */
                public void setAccessibleSummary(Accessible a) {
<span class="nc" id="L2184">                }</span>

                /**
                 * Returns the number of rows in the table.
                 *
                 * @return the number of rows in the table
                 */
                public int getAccessibleRowCount() {
<span class="nc" id="L2192">                    return rowCount;</span>
                }

                /**
                 * Returns the number of columns in the table.
                 *
                 * @return the number of columns in the table
                 */
                public int getAccessibleColumnCount() {
<span class="nc" id="L2201">                    return columnCount;</span>
                }

                private TableCellElementInfo getElementInfoAt(int r, int c) {
<span class="nc" id="L2205">                    ArrayList&lt;TableCellElementInfo&gt; list = headers.get(Integer.valueOf(r));</span>
<span class="nc bnc" id="L2206" title="All 2 branches missed.">                    if (list != null) {</span>
<span class="nc" id="L2207">                        return list.get(c);</span>
                    } else {
<span class="nc" id="L2209">                        return null;</span>
                    }
                }

                /**
                 * Returns the Accessible at a specified row and column
                 * in the table.
                 *
                 * @param r zero-based row of the table
                 * @param c zero-based column of the table
                 * @return the Accessible at the specified row and column
                 */
                public Accessible getAccessibleAt(int r, int c) {
<span class="nc" id="L2222">                    ElementInfo elementInfo = getElementInfoAt(r, c);</span>
<span class="nc bnc" id="L2223" title="All 2 branches missed.">                    if (elementInfo instanceof Accessible) {</span>
<span class="nc" id="L2224">                        return (Accessible)elementInfo;</span>
                    } else {
<span class="nc" id="L2226">                        return null;</span>
                    }
                }

                /**
                 * Returns the number of rows occupied by the Accessible at
                 * a specified row and column in the table.
                 *
                 * @return the number of rows occupied by the Accessible at a
                 * given specified (row, column)
                 */
                public int getAccessibleRowExtentAt(int r, int c) {
<span class="nc" id="L2238">                    TableCellElementInfo elementInfo = getElementInfoAt(r, c);</span>
<span class="nc bnc" id="L2239" title="All 2 branches missed.">                    if (elementInfo != null) {</span>
<span class="nc" id="L2240">                        return elementInfo.getRowCount();</span>
                    } else {
<span class="nc" id="L2242">                        return 0;</span>
                    }
                }

                /**
                 * Returns the number of columns occupied by the Accessible at
                 * a specified row and column in the table.
                 *
                 * @return the number of columns occupied by the Accessible at a
                 * given specified row and column
                 */
                public int getAccessibleColumnExtentAt(int r, int c) {
<span class="nc" id="L2254">                    TableCellElementInfo elementInfo = getElementInfoAt(r, c);</span>
<span class="nc bnc" id="L2255" title="All 2 branches missed.">                    if (elementInfo != null) {</span>
<span class="nc" id="L2256">                        return elementInfo.getRowCount();</span>
                    } else {
<span class="nc" id="L2258">                        return 0;</span>
                    }
                }

                /**
                 * Returns the row headers as an AccessibleTable.
                 *
                 * @return an AccessibleTable representing the row
                 * headers
                 */
                public AccessibleTable getAccessibleRowHeader() {
<span class="nc" id="L2269">                    return null;</span>
                }

                /**
                 * Sets the row headers.
                 *
                 * @param table an AccessibleTable representing the
                 * row headers
                 */
                public void setAccessibleRowHeader(AccessibleTable table) {
<span class="nc" id="L2279">                }</span>

                /**
                 * Returns the column headers as an AccessibleTable.
                 *
                 * @return an AccessibleTable representing the column
                 * headers
                 */
                public AccessibleTable getAccessibleColumnHeader() {
<span class="nc" id="L2288">                    return null;</span>
                }

                /**
                 * Sets the column headers.
                 *
                 * @param table an AccessibleTable representing the
                 * column headers
                 */
                public void setAccessibleColumnHeader(AccessibleTable table) {
<span class="nc" id="L2298">                }</span>

                /**
                 * Returns the description of the specified row in the table.
                 *
                 * @param r zero-based row of the table
                 * @return the description of the row
                 */
                public Accessible getAccessibleRowDescription(int r) {
<span class="nc" id="L2307">                    return null;</span>
                }

                /**
                 * Sets the description text of the specified row of the table.
                 *
                 * @param r zero-based row of the table
                 * @param a the description of the row
                 */
                public void setAccessibleRowDescription(int r, Accessible a) {
<span class="nc" id="L2317">                }</span>

                /**
                 * Returns the description text of the specified column in the table.
                 *
                 * @param c zero-based column of the table
                 * @return the text description of the column
                 */
                public Accessible getAccessibleColumnDescription(int c) {
<span class="nc" id="L2326">                    return null;</span>
                }

                /**
                 * Sets the description text of the specified column in the table.
                 *
                 * @param c zero-based column of the table
                 * @param a the text description of the column
                 */
                public void setAccessibleColumnDescription(int c, Accessible a) {
<span class="nc" id="L2336">                }</span>

                /**
                 * Returns a boolean value indicating whether the accessible at
                 * a specified row and column is selected.
                 *
                 * @param r zero-based row of the table
                 * @param c zero-based column of the table
                 * @return the boolean value true if the accessible at the
                 * row and column is selected. Otherwise, the boolean value
                 * false
                 */
                public boolean isAccessibleSelected(int r, int c) {
<span class="nc" id="L2349">                    return false;</span>
                }

                /**
                 * Returns a boolean value indicating whether the specified row
                 * is selected.
                 *
                 * @param r zero-based row of the table
                 * @return the boolean value true if the specified row is selected.
                 * Otherwise, false.
                 */
                public boolean isAccessibleRowSelected(int r) {
<span class="nc" id="L2361">                    return false;</span>
                }

                /**
                 * Returns a boolean value indicating whether the specified column
                 * is selected.
                 *
                 * @param c zero-based column of the table
                 * @return the boolean value true if the specified column is selected.
                 * Otherwise, false.
                 */
                public boolean isAccessibleColumnSelected(int c) {
<span class="nc" id="L2373">                    return false;</span>
                }

                /**
                 * Returns the selected rows in a table.
                 *
                 * @return an array of selected rows where each element is a
                 * zero-based row of the table
                 */
                public int [] getSelectedAccessibleRows() {
<span class="nc" id="L2383">                    return new int [0];</span>
                }

                /**
                 * Returns the selected columns in a table.
                 *
                 * @return an array of selected columns where each element is a
                 * zero-based column of the table
                 */
                public int [] getSelectedAccessibleColumns() {
<span class="nc" id="L2393">                    return new int [0];</span>
                }
            }
        } // ... end AccessibleHeadersTable

        /*
         * ElementInfo for table rows
         */
        private class TableRowElementInfo extends ElementInfo {

            private TableElementInfo parent;
            private int rowNumber;

<span class="nc" id="L2406">            TableRowElementInfo(Element e, TableElementInfo parent, int rowNumber) {</span>
<span class="nc" id="L2407">                super(e, parent);</span>
<span class="nc" id="L2408">                this.parent = parent;</span>
<span class="nc" id="L2409">                this.rowNumber = rowNumber;</span>
<span class="nc" id="L2410">            }</span>

            protected void loadChildren(Element e) {
<span class="nc bnc" id="L2413" title="All 2 branches missed.">                for (int x = 0; x &lt; e.getElementCount(); x++) {</span>
<span class="nc" id="L2414">                    AttributeSet attrs = e.getElement(x).getAttributes();</span>

<span class="nc bnc" id="L2416" title="All 2 branches missed.">                    if (attrs.getAttribute(StyleConstants.NameAttribute) ==</span>
                            HTML.Tag.TH) {
<span class="nc" id="L2418">                        TableCellElementInfo headerElementInfo =</span>
<span class="nc" id="L2419">                            new TableCellElementInfo(e.getElement(x), this, true);</span>
<span class="nc" id="L2420">                        addChild(headerElementInfo);</span>

<span class="nc" id="L2422">                        AccessibleTable at =</span>
<span class="nc" id="L2423">                            parent.getAccessibleContext().getAccessibleTable();</span>
<span class="nc" id="L2424">                        TableAccessibleContext tableElement =</span>
                            (TableAccessibleContext)at;
<span class="nc" id="L2426">                        tableElement.addRowHeader(headerElementInfo, rowNumber);</span>

<span class="nc bnc" id="L2428" title="All 2 branches missed.">                    } else if (attrs.getAttribute(StyleConstants.NameAttribute) ==</span>
                            HTML.Tag.TD) {
<span class="nc" id="L2430">                        addChild(new TableCellElementInfo(e.getElement(x), this,</span>
                                                          false));
                    }
                }
<span class="nc" id="L2434">            }</span>

            /**
             * Returns the max of the rowspans of the cells in this row.
             */
            public int getRowCount() {
<span class="nc" id="L2440">                int rowCount = 1;</span>
<span class="nc bnc" id="L2441" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc bnc" id="L2442" title="All 2 branches missed.">                    for (int counter = 0; counter &lt; getChildCount();</span>
<span class="nc" id="L2443">                         counter++) {</span>

<span class="nc" id="L2445">                        TableCellElementInfo cell = (TableCellElementInfo)</span>
<span class="nc" id="L2446">                                                    getChild(counter);</span>

<span class="nc bnc" id="L2448" title="All 2 branches missed.">                        if (cell.validateIfNecessary()) {</span>
<span class="nc" id="L2449">                            rowCount = Math.max(rowCount, cell.getRowCount());</span>
                        }
                    }
                }
<span class="nc" id="L2453">                return rowCount;</span>
            }

            /**
             * Returns the sum of the column spans of the individual
             * cells in this row.
             */
            public int getColumnCount() {
<span class="nc" id="L2461">                int colCount = 0;</span>
<span class="nc bnc" id="L2462" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc bnc" id="L2463" title="All 2 branches missed.">                    for (int counter = 0; counter &lt; getChildCount();</span>
<span class="nc" id="L2464">                         counter++) {</span>
<span class="nc" id="L2465">                        TableCellElementInfo cell = (TableCellElementInfo)</span>
<span class="nc" id="L2466">                                                    getChild(counter);</span>

<span class="nc bnc" id="L2468" title="All 2 branches missed.">                        if (cell.validateIfNecessary()) {</span>
<span class="nc" id="L2469">                            colCount += cell.getColumnCount();</span>
                        }
                    }
                }
<span class="nc" id="L2473">                return colCount;</span>
            }

            /**
             * Overriden to invalidate the table as well as
             * TableRowElementInfo.
             */
            protected void invalidate(boolean first) {
<span class="nc" id="L2481">                super.invalidate(first);</span>
<span class="nc" id="L2482">                getParent().invalidate(true);</span>
<span class="nc" id="L2483">            }</span>

            /**
             * Places the TableCellElementInfos for this element in
             * the grid.
             */
            private void updateGrid(int row) {
<span class="nc bnc" id="L2490" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc" id="L2491">                    boolean emptyRow = false;</span>

<span class="nc bnc" id="L2493" title="All 2 branches missed.">                    while (!emptyRow) {</span>
<span class="nc bnc" id="L2494" title="All 2 branches missed.">                        for (int counter = 0; counter &lt; grid[row].length;</span>
<span class="nc" id="L2495">                                 counter++) {</span>
<span class="nc bnc" id="L2496" title="All 2 branches missed.">                            if (grid[row][counter] == null) {</span>
<span class="nc" id="L2497">                                emptyRow = true;</span>
<span class="nc" id="L2498">                                break;</span>
                            }
                        }
<span class="nc bnc" id="L2501" title="All 2 branches missed.">                        if (!emptyRow) {</span>
<span class="nc" id="L2502">                            row++;</span>
                        }
                    }
<span class="nc bnc" id="L2505" title="All 2 branches missed.">                    for (int col = 0, counter = 0; counter &lt; getChildCount();</span>
<span class="nc" id="L2506">                             counter++) {</span>
<span class="nc" id="L2507">                        TableCellElementInfo cell = (TableCellElementInfo)</span>
<span class="nc" id="L2508">                                                    getChild(counter);</span>

<span class="nc bnc" id="L2510" title="All 2 branches missed.">                        while (grid[row][col] != null) {</span>
<span class="nc" id="L2511">                            col++;</span>
                        }
<span class="nc" id="L2513">                        for (int rowCount = cell.getRowCount() - 1;</span>
<span class="nc bnc" id="L2514" title="All 2 branches missed.">                             rowCount &gt;= 0; rowCount--) {</span>
<span class="nc" id="L2515">                            for (int colCount = cell.getColumnCount() - 1;</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">                                 colCount &gt;= 0; colCount--) {</span>
<span class="nc" id="L2517">                                grid[row + rowCount][col + colCount] = cell;</span>
                            }
                        }
<span class="nc" id="L2520">                        col += cell.getColumnCount();</span>
                    }
                }
<span class="nc" id="L2523">            }</span>

            /**
             * Returns the column count of the number of columns that have
             * a rowcount &gt;= rowspan.
             */
            private int getColumnCount(int rowspan) {
<span class="nc bnc" id="L2530" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc" id="L2531">                    int cols = 0;</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">                    for (int counter = 0; counter &lt; getChildCount();</span>
<span class="nc" id="L2533">                         counter++) {</span>
<span class="nc" id="L2534">                        TableCellElementInfo cell = (TableCellElementInfo)</span>
<span class="nc" id="L2535">                                                    getChild(counter);</span>

<span class="nc bnc" id="L2537" title="All 2 branches missed.">                        if (cell.getRowCount() &gt;= rowspan) {</span>
<span class="nc" id="L2538">                            cols += cell.getColumnCount();</span>
                        }
                    }
<span class="nc" id="L2541">                    return cols;</span>
                }
<span class="nc" id="L2543">                return 0;</span>
            }
        }

        /**
         * TableCellElementInfo is used to represents the cells of
         * the table.
         */
        private class TableCellElementInfo extends ElementInfo {

            private Accessible accessible;
            private boolean isHeaderCell;

<span class="nc" id="L2556">            TableCellElementInfo(Element e, ElementInfo parent) {</span>
<span class="nc" id="L2557">                super(e, parent);</span>
<span class="nc" id="L2558">                this.isHeaderCell = false;</span>
<span class="nc" id="L2559">            }</span>

            TableCellElementInfo(Element e, ElementInfo parent,
<span class="nc" id="L2562">                                 boolean isHeaderCell) {</span>
<span class="nc" id="L2563">                super(e, parent);</span>
<span class="nc" id="L2564">                this.isHeaderCell = isHeaderCell;</span>
<span class="nc" id="L2565">            }</span>

            /*
             * Returns whether this table cell is a header
             */
            public boolean isHeaderCell() {
<span class="nc" id="L2571">                return this.isHeaderCell;</span>
            }

            /*
             * Returns the Accessible representing this table cell
             */
            public Accessible getAccessible() {
<span class="nc" id="L2578">                accessible = null;</span>
<span class="nc" id="L2579">                getAccessible(this);</span>
<span class="nc" id="L2580">                return accessible;</span>
            }

            /*
             * Gets the outermost Accessible in the table cell
             */
            private void getAccessible(ElementInfo elementInfo) {
<span class="nc bnc" id="L2587" title="All 2 branches missed.">                if (elementInfo instanceof Accessible) {</span>
<span class="nc" id="L2588">                    accessible = (Accessible)elementInfo;</span>
                } else {
<span class="nc bnc" id="L2590" title="All 2 branches missed.">                    for (int i = 0; i &lt; elementInfo.getChildCount(); i++) {</span>
<span class="nc" id="L2591">                        getAccessible(elementInfo.getChild(i));</span>
                    }
                }
<span class="nc" id="L2594">            }</span>

            /**
             * Returns the rowspan attribute.
             */
            public int getRowCount() {
<span class="nc bnc" id="L2600" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc" id="L2601">                    return Math.max(1, getIntAttr(getAttributes(),</span>
                                                  HTML.Attribute.ROWSPAN, 1));
                }
<span class="nc" id="L2604">                return 0;</span>
            }

            /**
             * Returns the colspan attribute.
             */
            public int getColumnCount() {
<span class="nc bnc" id="L2611" title="All 2 branches missed.">                if (validateIfNecessary()) {</span>
<span class="nc" id="L2612">                    return Math.max(1, getIntAttr(getAttributes(),</span>
                                                  HTML.Attribute.COLSPAN, 1));
                }
<span class="nc" id="L2615">                return 0;</span>
            }

            /**
             * Overriden to invalidate the TableRowElementInfo as well as
             * the TableCellElementInfo.
             */
            protected void invalidate(boolean first) {
<span class="nc" id="L2623">                super.invalidate(first);</span>
<span class="nc" id="L2624">                getParent().invalidate(true);</span>
<span class="nc" id="L2625">            }</span>
        }
    }


    /**
     * ElementInfo provides a slim down view of an Element.  Each ElementInfo
     * can have any number of child ElementInfos that are not necessarily
     * direct children of the Element. As the Document changes various
     * ElementInfos become invalidated. Before accessing a particular portion
     * of an ElementInfo you should make sure it is valid by invoking
     * &lt;code&gt;validateIfNecessary&lt;/code&gt;, this will return true if
     * successful, on the other hand a false return value indicates the
     * ElementInfo is not valid and can never become valid again (usually
     * the result of the Element the ElementInfo encapsulates being removed).
     */
    private class ElementInfo {

        /**
         * The children of this ElementInfo.
         */
        private ArrayList&lt;ElementInfo&gt; children;
        /**
         * The Element this ElementInfo is providing information for.
         */
        private Element element;
        /**
         * The parent ElementInfo, will be null for the root.
         */
        private ElementInfo parent;
        /**
         * Indicates the validity of the ElementInfo.
         */
        private boolean isValid;
        /**
         * Indicates if the ElementInfo can become valid.
         */
        private boolean canBeValid;


        /**
         * Creates the root ElementInfo.
         */
        ElementInfo(Element element) {
<span class="nc" id="L2669">            this(element, null);</span>
<span class="nc" id="L2670">        }</span>

        /**
         * Creates an ElementInfo representing &lt;code&gt;element&lt;/code&gt; with
         * the specified parent.
         */
<span class="nc" id="L2676">        ElementInfo(Element element, ElementInfo parent) {</span>
<span class="nc" id="L2677">            this.element = element;</span>
<span class="nc" id="L2678">            this.parent = parent;</span>
<span class="nc" id="L2679">            isValid = false;</span>
<span class="nc" id="L2680">            canBeValid = true;</span>
<span class="nc" id="L2681">        }</span>

        /**
         * Validates the receiver. This recreates the children as well. This
         * will be invoked within a &lt;code&gt;readLock&lt;/code&gt;. If this is overriden
         * it MUST invoke supers implementation first!
         */
        protected void validate() {
<span class="nc" id="L2689">            isValid = true;</span>
<span class="nc" id="L2690">            loadChildren(getElement());</span>
<span class="nc" id="L2691">        }</span>

        /**
         * Recreates the direct children of &lt;code&gt;info&lt;/code&gt;.
         */
        protected void loadChildren(Element parent) {
<span class="nc bnc" id="L2697" title="All 2 branches missed.">            if (!parent.isLeaf()) {</span>
<span class="nc" id="L2698">                for (int counter = 0, maxCounter = parent.getElementCount();</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">                    counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L2700">                    Element e = parent.getElement(counter);</span>
<span class="nc" id="L2701">                    ElementInfo childInfo = createElementInfo(e, this);</span>

<span class="nc bnc" id="L2703" title="All 2 branches missed.">                    if (childInfo != null) {</span>
<span class="nc" id="L2704">                        addChild(childInfo);</span>
                    }
                    else {
<span class="nc" id="L2707">                        loadChildren(e);</span>
                    }
                }
            }
<span class="nc" id="L2711">        }</span>

        /**
         * Returns the index of the child in the parent, or -1 for the
         * root or if the parent isn't valid.
         */
        public int getIndexInParent() {
<span class="nc bnc" id="L2718" title="All 4 branches missed.">            if (parent == null || !parent.isValid()) {</span>
<span class="nc" id="L2719">                return -1;</span>
            }
<span class="nc" id="L2721">            return parent.indexOf(this);</span>
        }

        /**
         * Returns the Element this &lt;code&gt;ElementInfo&lt;/code&gt; represents.
         */
        public Element getElement() {
<span class="nc" id="L2728">            return element;</span>
        }

        /**
         * Returns the parent of this Element, or null for the root.
         */
        public ElementInfo getParent() {
<span class="nc" id="L2735">            return parent;</span>
        }

        /**
         * Returns the index of the specified child, or -1 if
         * &lt;code&gt;child&lt;/code&gt; isn't a valid child.
         */
        public int indexOf(ElementInfo child) {
<span class="nc" id="L2743">            ArrayList children = this.children;</span>

<span class="nc bnc" id="L2745" title="All 2 branches missed.">            if (children != null) {</span>
<span class="nc" id="L2746">                return children.indexOf(child);</span>
            }
<span class="nc" id="L2748">            return -1;</span>
        }

        /**
         * Returns the child ElementInfo at &lt;code&gt;index&lt;/code&gt;, or null
         * if &lt;code&gt;index&lt;/code&gt; isn't a valid index.
         */
        public ElementInfo getChild(int index) {
<span class="nc bnc" id="L2756" title="All 2 branches missed.">            if (validateIfNecessary()) {</span>
<span class="nc" id="L2757">                ArrayList&lt;ElementInfo&gt; children = this.children;</span>

<span class="nc bnc" id="L2759" title="All 4 branches missed.">                if (children != null &amp;&amp; index &gt;= 0 &amp;&amp;</span>
<span class="nc bnc" id="L2760" title="All 2 branches missed.">                                        index &lt; children.size()) {</span>
<span class="nc" id="L2761">                    return children.get(index);</span>
                }
            }
<span class="nc" id="L2764">            return null;</span>
        }

        /**
         * Returns the number of children the ElementInfo contains.
         */
        public int getChildCount() {
<span class="nc" id="L2771">            validateIfNecessary();</span>
<span class="nc bnc" id="L2772" title="All 2 branches missed.">            return (children == null) ? 0 : children.size();</span>
        }

        /**
         * Adds a new child to this ElementInfo.
         */
        protected void addChild(ElementInfo child) {
<span class="nc bnc" id="L2779" title="All 2 branches missed.">            if (children == null) {</span>
<span class="nc" id="L2780">                children = new ArrayList&lt;ElementInfo&gt;();</span>
            }
<span class="nc" id="L2782">            children.add(child);</span>
<span class="nc" id="L2783">        }</span>

        /**
         * Returns the View corresponding to this ElementInfo, or null
         * if the ElementInfo can't be validated.
         */
        protected View getView() {
<span class="nc bnc" id="L2790" title="All 2 branches missed.">            if (!validateIfNecessary()) {</span>
<span class="nc" id="L2791">                return null;</span>
            }
<span class="nc" id="L2793">            Object lock = lock();</span>
            try {
<span class="nc" id="L2795">                View rootView = getRootView();</span>
<span class="nc" id="L2796">                Element e = getElement();</span>
<span class="nc" id="L2797">                int start = e.getStartOffset();</span>

<span class="nc bnc" id="L2799" title="All 2 branches missed.">                if (rootView != null) {</span>
<span class="nc" id="L2800">                    return getView(rootView, e, start);</span>
                }
<span class="nc" id="L2802">                return null;</span>
            } finally {
<span class="nc" id="L2804">                unlock(lock);</span>
            }
        }

        /**
         * Returns the Bounds for this ElementInfo, or null
         * if the ElementInfo can't be validated.
         */
        public Rectangle getBounds() {
<span class="nc bnc" id="L2813" title="All 2 branches missed.">            if (!validateIfNecessary()) {</span>
<span class="nc" id="L2814">                return null;</span>
            }
<span class="nc" id="L2816">            Object lock = lock();</span>
            try {
<span class="nc" id="L2818">                Rectangle bounds = getRootEditorRect();</span>
<span class="nc" id="L2819">                View rootView = getRootView();</span>
<span class="nc" id="L2820">                Element e = getElement();</span>

<span class="nc bnc" id="L2822" title="All 4 branches missed.">                if (bounds != null &amp;&amp; rootView != null) {</span>
                    try {
<span class="nc" id="L2824">                        return rootView.modelToView(e.getStartOffset(),</span>
                                                    Position.Bias.Forward,
<span class="nc" id="L2826">                                                    e.getEndOffset(),</span>
                                                    Position.Bias.Backward,
<span class="nc" id="L2828">                                                    bounds).getBounds();</span>
<span class="nc" id="L2829">                    } catch (BadLocationException ble) { }</span>
                }
            } finally {
<span class="nc" id="L2832">                unlock(lock);</span>
<span class="nc" id="L2833">            }</span>
<span class="nc" id="L2834">            return null;</span>
        }

        /**
         * Returns true if this ElementInfo is valid.
         */
        protected boolean isValid() {
<span class="nc" id="L2841">            return isValid;</span>
        }

        /**
         * Returns the AttributeSet associated with the Element, this will
         * return null if the ElementInfo can't be validated.
         */
        protected AttributeSet getAttributes() {
<span class="nc bnc" id="L2849" title="All 2 branches missed.">            if (validateIfNecessary()) {</span>
<span class="nc" id="L2850">                return getElement().getAttributes();</span>
            }
<span class="nc" id="L2852">            return null;</span>
        }

        /**
         * Returns the AttributeSet associated with the View that is
         * representing this Element, this will
         * return null if the ElementInfo can't be validated.
         */
        protected AttributeSet getViewAttributes() {
<span class="nc bnc" id="L2861" title="All 2 branches missed.">            if (validateIfNecessary()) {</span>
<span class="nc" id="L2862">                View view = getView();</span>

<span class="nc bnc" id="L2864" title="All 2 branches missed.">                if (view != null) {</span>
<span class="nc" id="L2865">                    return view.getElement().getAttributes();</span>
                }
<span class="nc" id="L2867">                return getElement().getAttributes();</span>
            }
<span class="nc" id="L2869">            return null;</span>
        }

        /**
         * Convenience method for getting an integer attribute from the passed
         * in AttributeSet.
         */
        protected int getIntAttr(AttributeSet attrs, Object key, int deflt) {
<span class="nc bnc" id="L2877" title="All 4 branches missed.">            if (attrs != null &amp;&amp; attrs.isDefined(key)) {</span>
                int i;
<span class="nc" id="L2879">                String val = (String)attrs.getAttribute(key);</span>
<span class="nc bnc" id="L2880" title="All 2 branches missed.">                if (val == null) {</span>
<span class="nc" id="L2881">                    i = deflt;</span>
                }
                else {
                    try {
<span class="nc" id="L2885">                        i = Math.max(0, Integer.parseInt(val));</span>
<span class="nc" id="L2886">                    } catch (NumberFormatException x) {</span>
<span class="nc" id="L2887">                        i = deflt;</span>
<span class="nc" id="L2888">                    }</span>
                }
<span class="nc" id="L2890">                return i;</span>
            }
<span class="nc" id="L2892">            return deflt;</span>
        }

        /**
         * Validates the ElementInfo if necessary.  Some ElementInfos may
         * never be valid again.  You should check &lt;code&gt;isValid&lt;/code&gt; before
         * using one.  This will reload the children and invoke
         * &lt;code&gt;validate&lt;/code&gt; if the ElementInfo is invalid and can become
         * valid again. This will return true if the receiver is valid.
         */
        protected boolean validateIfNecessary() {
<span class="nc bnc" id="L2903" title="All 4 branches missed.">            if (!isValid() &amp;&amp; canBeValid) {</span>
<span class="nc" id="L2904">                children = null;</span>
<span class="nc" id="L2905">                Object lock = lock();</span>

                try {
<span class="nc" id="L2908">                    validate();</span>
                } finally {
<span class="nc" id="L2910">                    unlock(lock);</span>
<span class="nc" id="L2911">                }</span>
            }
<span class="nc" id="L2913">            return isValid();</span>
        }

        /**
         * Invalidates the ElementInfo. Subclasses should override this
         * if they need to reset state once invalid.
         */
        protected void invalidate(boolean first) {
<span class="nc bnc" id="L2921" title="All 2 branches missed.">            if (!isValid()) {</span>
<span class="nc bnc" id="L2922" title="All 4 branches missed.">                if (canBeValid &amp;&amp; !first) {</span>
<span class="nc" id="L2923">                    canBeValid = false;</span>
                }
<span class="nc" id="L2925">                return;</span>
            }
<span class="nc" id="L2927">            isValid = false;</span>
<span class="nc" id="L2928">            canBeValid = first;</span>
<span class="nc bnc" id="L2929" title="All 2 branches missed.">            if (children != null) {</span>
<span class="nc bnc" id="L2930" title="All 2 branches missed.">                for (ElementInfo child : children) {</span>
<span class="nc" id="L2931">                    child.invalidate(false);</span>
<span class="nc" id="L2932">                }</span>
<span class="nc" id="L2933">                children = null;</span>
            }
<span class="nc" id="L2935">        }</span>

        private View getView(View parent, Element e, int start) {
<span class="nc bnc" id="L2938" title="All 2 branches missed.">            if (parent.getElement() == e) {</span>
<span class="nc" id="L2939">                return parent;</span>
            }
<span class="nc" id="L2941">            int index = parent.getViewIndex(start, Position.Bias.Forward);</span>

<span class="nc bnc" id="L2943" title="All 4 branches missed.">            if (index != -1 &amp;&amp; index &lt; parent.getViewCount()) {</span>
<span class="nc" id="L2944">                return getView(parent.getView(index), e, start);</span>
            }
<span class="nc" id="L2946">            return null;</span>
        }

        private int getClosestInfoIndex(int index) {
<span class="nc bnc" id="L2950" title="All 2 branches missed.">            for (int counter = 0; counter &lt; getChildCount(); counter++) {</span>
<span class="nc" id="L2951">                ElementInfo info = getChild(counter);</span>

<span class="nc bnc" id="L2953" title="All 2 branches missed.">                if (index &lt; info.getElement().getEndOffset() ||</span>
<span class="nc bnc" id="L2954" title="All 2 branches missed.">                    index == info.getElement().getStartOffset()) {</span>
<span class="nc" id="L2955">                    return counter;</span>
                }
            }
<span class="nc" id="L2958">            return -1;</span>
        }

        private void update(DocumentEvent e) {
<span class="nc bnc" id="L2962" title="All 2 branches missed.">            if (!isValid()) {</span>
<span class="nc" id="L2963">                return;</span>
            }
<span class="nc" id="L2965">            ElementInfo parent = getParent();</span>
<span class="nc" id="L2966">            Element element = getElement();</span>

            do {
<span class="nc" id="L2969">                DocumentEvent.ElementChange ec = e.getChange(element);</span>
<span class="nc bnc" id="L2970" title="All 2 branches missed.">                if (ec != null) {</span>
<span class="nc bnc" id="L2971" title="All 2 branches missed.">                    if (element == getElement()) {</span>
                        // One of our children changed.
<span class="nc" id="L2973">                        invalidate(true);</span>
                    }
<span class="nc bnc" id="L2975" title="All 2 branches missed.">                    else if (parent != null) {</span>
<span class="nc bnc" id="L2976" title="All 2 branches missed.">                        parent.invalidate(parent == getRootInfo());</span>
                    }
<span class="nc" id="L2978">                    return;</span>
                }
<span class="nc" id="L2980">                element = element.getParentElement();</span>
<span class="nc bnc" id="L2981" title="All 4 branches missed.">            } while (parent != null &amp;&amp; element != null &amp;&amp;</span>
<span class="nc bnc" id="L2982" title="All 2 branches missed.">                     element != parent.getElement());</span>

<span class="nc bnc" id="L2984" title="All 2 branches missed.">            if (getChildCount() &gt; 0) {</span>
<span class="nc" id="L2985">                Element elem = getElement();</span>
<span class="nc" id="L2986">                int pos = e.getOffset();</span>
<span class="nc" id="L2987">                int index0 = getClosestInfoIndex(pos);</span>
<span class="nc bnc" id="L2988" title="All 2 branches missed.">                if (index0 == -1 &amp;&amp;</span>
<span class="nc bnc" id="L2989" title="All 2 branches missed.">                    e.getType() == DocumentEvent.EventType.REMOVE &amp;&amp;</span>
<span class="nc bnc" id="L2990" title="All 2 branches missed.">                    pos &gt;= elem.getEndOffset()) {</span>
                    // Event beyond our offsets. We may have represented this,
                    // that is the remove may have removed one of our child
                    // Elements that represented this, so, we should foward
                    // to last element.
<span class="nc" id="L2995">                    index0 = getChildCount() - 1;</span>
                }
<span class="nc bnc" id="L2997" title="All 2 branches missed.">                ElementInfo info = (index0 &gt;= 0) ? getChild(index0) : null;</span>
<span class="nc bnc" id="L2998" title="All 2 branches missed.">                if (info != null &amp;&amp;</span>
<span class="nc bnc" id="L2999" title="All 4 branches missed.">                    (info.getElement().getStartOffset() == pos) &amp;&amp; (pos &gt; 0)) {</span>
                    // If at a boundary, forward the event to the previous
                    // ElementInfo too.
<span class="nc" id="L3002">                    index0 = Math.max(index0 - 1, 0);</span>
                }
                int index1;
<span class="nc bnc" id="L3005" title="All 2 branches missed.">                if (e.getType() != DocumentEvent.EventType.REMOVE) {</span>
<span class="nc" id="L3006">                    index1 = getClosestInfoIndex(pos + e.getLength());</span>
<span class="nc bnc" id="L3007" title="All 2 branches missed.">                    if (index1 &lt; 0) {</span>
<span class="nc" id="L3008">                        index1 = getChildCount() - 1;</span>
                    }
                }
                else {
<span class="nc" id="L3012">                    index1 = index0;</span>
                    // A remove may result in empty elements.
<span class="nc bnc" id="L3014" title="All 2 branches missed.">                    while ((index1 + 1) &lt; getChildCount() &amp;&amp;</span>
<span class="nc" id="L3015">                           getChild(index1 + 1).getElement().getEndOffset() ==</span>
<span class="nc bnc" id="L3016" title="All 2 branches missed.">                           getChild(index1 + 1).getElement().getStartOffset()){</span>
<span class="nc" id="L3017">                        index1++;</span>
                    }
                }
<span class="nc" id="L3020">                index0 = Math.max(index0, 0);</span>
                // The check for isValid is here as in the process of
                // forwarding update our child may invalidate us.
<span class="nc bnc" id="L3023" title="All 4 branches missed.">                for (int i = index0; i &lt;= index1 &amp;&amp; isValid(); i++) {</span>
<span class="nc" id="L3024">                    getChild(i).update(e);</span>
                }
            }
<span class="nc" id="L3027">        }</span>
    }

    /**
     * DocumentListener installed on the current Document.  Will invoke
     * &lt;code&gt;update&lt;/code&gt; on the &lt;code&gt;RootInfo&lt;/code&gt; in response to
     * any event.
     */
<span class="nc" id="L3035">    private class DocumentHandler implements DocumentListener {</span>
        public void insertUpdate(DocumentEvent e) {
<span class="nc" id="L3037">            getRootInfo().update(e);</span>
<span class="nc" id="L3038">        }</span>
        public void removeUpdate(DocumentEvent e) {
<span class="nc" id="L3040">            getRootInfo().update(e);</span>
<span class="nc" id="L3041">        }</span>
        public void changedUpdate(DocumentEvent e) {
<span class="nc" id="L3043">            getRootInfo().update(e);</span>
<span class="nc" id="L3044">        }</span>
    }

    /*
     * PropertyChangeListener installed on the editor.
     */
<span class="nc" id="L3050">    private class PropertyChangeHandler implements PropertyChangeListener {</span>
        public void propertyChange(PropertyChangeEvent evt) {
<span class="nc bnc" id="L3052" title="All 2 branches missed.">            if (evt.getPropertyName().equals(&quot;document&quot;)) {</span>
                // handle the document change
<span class="nc" id="L3054">                setDocument(editor.getDocument());</span>
            }
<span class="nc" id="L3056">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>