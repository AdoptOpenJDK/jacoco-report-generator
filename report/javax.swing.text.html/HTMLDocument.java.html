<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>HTMLDocument.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text.html</a> &gt; <span class="el_source">HTMLDocument.java</span></div><h1>HTMLDocument.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text.html;

import java.awt.font.TextAttribute;
import java.util.*;
import java.net.URL;
import java.net.MalformedURLException;
import java.io.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.undo.*;
import sun.swing.SwingUtilities2;
import static sun.swing.SwingUtilities2.IMPLIED_CR;

/**
 * A document that models HTML.  The purpose of this model is to
 * support both browsing and editing.  As a result, the structure
 * described by an HTML document is not exactly replicated by default.
 * The element structure that is modeled by default, is built by the
 * class &lt;code&gt;HTMLDocument.HTMLReader&lt;/code&gt;, which implements the
 * &lt;code&gt;HTMLEditorKit.ParserCallback&lt;/code&gt; protocol that the parser
 * expects.  To change the structure one can subclass
 * &lt;code&gt;HTMLReader&lt;/code&gt;, and reimplement the method {@link
 * #getReader(int)} to return the new reader implementation.  The
 * documentation for &lt;code&gt;HTMLReader&lt;/code&gt; should be consulted for
 * the details of the default structure created.  The intent is that
 * the document be non-lossy (although reproducing the HTML format may
 * result in a different format).
 *
 * &lt;p&gt;The document models only HTML, and makes no attempt to store
 * view attributes in it.  The elements are identified by the
 * &lt;code&gt;StyleContext.NameAttribute&lt;/code&gt; attribute, which should
 * always have a value of type &lt;code&gt;HTML.Tag&lt;/code&gt; that identifies
 * the kind of element.  Some of the elements (such as comments) are
 * synthesized.  The &lt;code&gt;HTMLFactory&lt;/code&gt; uses this attribute to
 * determine what kind of view to build.&lt;/p&gt;
 *
 * &lt;p&gt;This document supports incremental loading.  The
 * &lt;code&gt;TokenThreshold&lt;/code&gt; property controls how much of the parse
 * is buffered before trying to update the element structure of the
 * document.  This property is set by the &lt;code&gt;EditorKit&lt;/code&gt; so
 * that subclasses can disable it.&lt;/p&gt;
 *
 * &lt;p&gt;The &lt;code&gt;Base&lt;/code&gt; property determines the URL against which
 * relative URLs are resolved.  By default, this will be the
 * &lt;code&gt;Document.StreamDescriptionProperty&lt;/code&gt; if the value of the
 * property is a URL.  If a &amp;lt;BASE&amp;gt; tag is encountered, the base
 * will become the URL specified by that tag.  Because the base URL is
 * a property, it can of course be set directly.&lt;/p&gt;
 *
 * &lt;p&gt;The default content storage mechanism for this document is a gap
 * buffer (&lt;code&gt;GapContent&lt;/code&gt;).  Alternatives can be supplied by
 * using the constructor that takes a &lt;code&gt;Content&lt;/code&gt;
 * implementation.&lt;/p&gt;
 *
 * &lt;h2&gt;Modifying HTMLDocument&lt;/h2&gt;
 *
 * &lt;p&gt;In addition to the methods provided by Document and
 * StyledDocument for mutating an HTMLDocument, HTMLDocument provides
 * a number of convenience methods.  The following methods can be used
 * to insert HTML content into an existing document.&lt;/p&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #setInnerHTML(Element, String)}&lt;/li&gt;
 *   &lt;li&gt;{@link #setOuterHTML(Element, String)}&lt;/li&gt;
 *   &lt;li&gt;{@link #insertBeforeStart(Element, String)}&lt;/li&gt;
 *   &lt;li&gt;{@link #insertAfterStart(Element, String)}&lt;/li&gt;
 *   &lt;li&gt;{@link #insertBeforeEnd(Element, String)}&lt;/li&gt;
 *   &lt;li&gt;{@link #insertAfterEnd(Element, String)}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The following examples illustrate using these methods.  Each
 * example assumes the HTML document is initialized in the following
 * way:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * JEditorPane p = new JEditorPane();
 * p.setContentType(&quot;text/html&quot;);
 * p.setText(&quot;...&quot;); // Document text is provided below.
 * HTMLDocument d = (HTMLDocument) p.getDocument();
 * &lt;/pre&gt;
 *
 * &lt;p&gt;With the following HTML content:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;html&amp;gt;
 *   &amp;lt;head&amp;gt;
 *     &amp;lt;title&amp;gt;An example HTMLDocument&amp;lt;/title&amp;gt;
 *     &amp;lt;style type=&quot;text/css&quot;&amp;gt;
 *       div { background-color: silver; }
 *       ul { color: red; }
 *     &amp;lt;/style&amp;gt;
 *   &amp;lt;/head&amp;gt;
 *   &amp;lt;body&amp;gt;
 *     &amp;lt;div id=&quot;BOX&quot;&amp;gt;
 *       &amp;lt;p&amp;gt;Paragraph 1&amp;lt;/p&amp;gt;
 *       &amp;lt;p&amp;gt;Paragraph 2&amp;lt;/p&amp;gt;
 *     &amp;lt;/div&amp;gt;
 *   &amp;lt;/body&amp;gt;
 * &amp;lt;/html&amp;gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;All the methods for modifying an HTML document require an {@link
 * Element}.  Elements can be obtained from an HTML document by using
 * the method {@link #getElement(Element e, Object attribute, Object
 * value)}.  It returns the first descendant element that contains the
 * specified attribute with the given value, in depth-first order.
 * For example, &lt;code&gt;d.getElement(d.getDefaultRootElement(),
 * StyleConstants.NameAttribute, HTML.Tag.P)&lt;/code&gt; returns the first
 * paragraph element.&lt;/p&gt;
 *
 * &lt;p&gt;A convenient shortcut for locating elements is the method {@link
 * #getElement(String)}; returns an element whose &lt;code&gt;ID&lt;/code&gt;
 * attribute matches the specified value.  For example,
 * &lt;code&gt;d.getElement(&quot;BOX&quot;)&lt;/code&gt; returns the &lt;code&gt;DIV&lt;/code&gt;
 * element.&lt;/p&gt;
 *
 * &lt;p&gt;The {@link #getIterator(HTML.Tag t)} method can also be used for
 * finding all occurrences of the specified HTML tag in the
 * document.&lt;/p&gt;
 *
 * &lt;h3&gt;Inserting elements&lt;/h3&gt;
 *
 * &lt;p&gt;Elements can be inserted before or after the existing children
 * of any non-leaf element by using the methods
 * &lt;code&gt;insertAfterStart&lt;/code&gt; and &lt;code&gt;insertBeforeEnd&lt;/code&gt;.
 * For example, if &lt;code&gt;e&lt;/code&gt; is the &lt;code&gt;DIV&lt;/code&gt; element,
 * &lt;code&gt;d.insertAfterStart(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
 * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list before the first
 * paragraph, and &lt;code&gt;d.insertBeforeEnd(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
 * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list after the last
 * paragraph.  The &lt;code&gt;DIV&lt;/code&gt; block becomes the parent of the
 * newly inserted elements.&lt;/p&gt;
 *
 * &lt;p&gt;Sibling elements can be inserted before or after any element by
 * using the methods &lt;code&gt;insertBeforeStart&lt;/code&gt; and
 * &lt;code&gt;insertAfterEnd&lt;/code&gt;.  For example, if &lt;code&gt;e&lt;/code&gt; is the
 * &lt;code&gt;DIV&lt;/code&gt; element, &lt;code&gt;d.insertBeforeStart(e,
 * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list
 * before the &lt;code&gt;DIV&lt;/code&gt; element, and &lt;code&gt;d.insertAfterEnd(e,
 * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list
 * after the &lt;code&gt;DIV&lt;/code&gt; element.  The newly inserted elements
 * become siblings of the &lt;code&gt;DIV&lt;/code&gt; element.&lt;/p&gt;
 *
 * &lt;h3&gt;Replacing elements&lt;/h3&gt;
 *
 * &lt;p&gt;Elements and all their descendants can be replaced by using the
 * methods &lt;code&gt;setInnerHTML&lt;/code&gt; and &lt;code&gt;setOuterHTML&lt;/code&gt;.
 * For example, if &lt;code&gt;e&lt;/code&gt; is the &lt;code&gt;DIV&lt;/code&gt; element,
 * &lt;code&gt;d.setInnerHTML(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
 * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; replaces all children paragraphs with
 * the list, and &lt;code&gt;d.setOuterHTML(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
 * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; replaces the &lt;code&gt;DIV&lt;/code&gt; element
 * itself.  In latter case the parent of the list is the
 * &lt;code&gt;BODY&lt;/code&gt; element.
 *
 * &lt;h3&gt;Summary&lt;/h3&gt;
 *
 * &lt;p&gt;The following table shows the example document and the results
 * of various methods described above.&lt;/p&gt;
 *
 * &lt;table border=1 cellspacing=0&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Example&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;insertAfterStart&lt;/code&gt;&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;insertBeforeEnd&lt;/code&gt;&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;insertBeforeStart&lt;/code&gt;&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;insertAfterEnd&lt;/code&gt;&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;setInnerHTML&lt;/code&gt;&lt;/th&gt;
 *     &lt;th&gt;&lt;code&gt;setOuterHTML&lt;/code&gt;&lt;/th&gt;
 *   &lt;/tr&gt;
 *   &lt;tr valign=&quot;top&quot;&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;p&gt;Paragraph 1&lt;/p&gt;
 *         &lt;p&gt;Paragraph 2&lt;/p&gt;
 *       &lt;/div&gt;
 *     &lt;/td&gt;
 * &lt;!--insertAfterStart--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;ul style=&quot;color: red;&quot;&gt;
 *           &lt;li&gt;List Item&lt;/li&gt;
 *         &lt;/ul&gt;
 *         &lt;p&gt;Paragraph 1&lt;/p&gt;
 *         &lt;p&gt;Paragraph 2&lt;/p&gt;
 *       &lt;/div&gt;
 *     &lt;/td&gt;
 * &lt;!--insertBeforeEnd--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;p&gt;Paragraph 1&lt;/p&gt;
 *         &lt;p&gt;Paragraph 2&lt;/p&gt;
 *         &lt;ul style=&quot;color: red;&quot;&gt;
 *           &lt;li&gt;List Item&lt;/li&gt;
 *         &lt;/ul&gt;
 *       &lt;/div&gt;
 *     &lt;/td&gt;
 * &lt;!--insertBeforeStart--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;ul style=&quot;color: red;&quot;&gt;
 *         &lt;li&gt;List Item&lt;/li&gt;
 *       &lt;/ul&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;p&gt;Paragraph 1&lt;/p&gt;
 *         &lt;p&gt;Paragraph 2&lt;/p&gt;
 *       &lt;/div&gt;
 *     &lt;/td&gt;
 * &lt;!--insertAfterEnd--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;p&gt;Paragraph 1&lt;/p&gt;
 *         &lt;p&gt;Paragraph 2&lt;/p&gt;
 *       &lt;/div&gt;
 *       &lt;ul style=&quot;color: red;&quot;&gt;
 *         &lt;li&gt;List Item&lt;/li&gt;
 *       &lt;/ul&gt;
 *     &lt;/td&gt;
 * &lt;!--setInnerHTML--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;div style=&quot;background-color: silver;&quot;&gt;
 *         &lt;ul style=&quot;color: red;&quot;&gt;
 *           &lt;li&gt;List Item&lt;/li&gt;
 *         &lt;/ul&gt;
 *       &lt;/div&gt;
 *     &lt;/td&gt;
 * &lt;!--setOuterHTML--&gt;
 *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
 *       &lt;ul style=&quot;color: red;&quot;&gt;
 *         &lt;li&gt;List Item&lt;/li&gt;
 *       &lt;/ul&gt;
 *     &lt;/td&gt;
 *   &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; Serialized objects of this class will
 * not be compatible with future Swing releases. The current
 * serialization support is appropriate for short term storage or RMI
 * between applications running the same version of Swing.  As of 1.4,
 * support for long term storage of all JavaBeans&amp;trade;
 * has been added to the
 * &lt;code&gt;java.beans&lt;/code&gt; package.  Please see {@link
 * java.beans.XMLEncoder}.&lt;/p&gt;
 *
 * @author  Timothy Prinzing
 * @author  Scott Violet
 * @author  Sunita Mani
 */
public class HTMLDocument extends DefaultStyledDocument {
    /**
     * Constructs an HTML document using the default buffer size
     * and a default &lt;code&gt;StyleSheet&lt;/code&gt;.  This is a convenience
     * method for the constructor
     * &lt;code&gt;HTMLDocument(Content, StyleSheet)&lt;/code&gt;.
     */
    public HTMLDocument() {
<span class="nc" id="L281">        this(new GapContent(BUFFER_SIZE_DEFAULT), new StyleSheet());</span>
<span class="nc" id="L282">    }</span>

    /**
     * Constructs an HTML document with the default content
     * storage implementation and the specified style/attribute
     * storage mechanism.  This is a convenience method for the
     * constructor
     * &lt;code&gt;HTMLDocument(Content, StyleSheet)&lt;/code&gt;.
     *
     * @param styles  the styles
     */
    public HTMLDocument(StyleSheet styles) {
<span class="nc" id="L294">        this(new GapContent(BUFFER_SIZE_DEFAULT), styles);</span>
<span class="nc" id="L295">    }</span>

    /**
     * Constructs an HTML document with the given content
     * storage implementation and the given style/attribute
     * storage mechanism.
     *
     * @param c  the container for the content
     * @param styles the styles
     */
    public HTMLDocument(Content c, StyleSheet styles) {
<span class="nc" id="L306">        super(c, styles);</span>
<span class="nc" id="L307">    }</span>

    /**
     * Fetches the reader for the parser to use when loading the document
     * with HTML.  This is implemented to return an instance of
     * &lt;code&gt;HTMLDocument.HTMLReader&lt;/code&gt;.
     * Subclasses can reimplement this
     * method to change how the document gets structured if desired.
     * (For example, to handle custom tags, or structurally represent character
     * style elements.)
     *
     * @param pos the starting position
     * @return the reader used by the parser to load the document
     */
    public HTMLEditorKit.ParserCallback getReader(int pos) {
<span class="nc" id="L322">        Object desc = getProperty(Document.StreamDescriptionProperty);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (desc instanceof URL) {</span>
<span class="nc" id="L324">            setBase((URL)desc);</span>
        }
<span class="nc" id="L326">        HTMLReader reader = new HTMLReader(pos);</span>
<span class="nc" id="L327">        return reader;</span>
    }

    /**
     * Returns the reader for the parser to use to load the document
     * with HTML.  This is implemented to return an instance of
     * &lt;code&gt;HTMLDocument.HTMLReader&lt;/code&gt;.
     * Subclasses can reimplement this
     * method to change how the document gets structured if desired.
     * (For example, to handle custom tags, or structurally represent character
     * style elements.)
     * &lt;p&gt;This is a convenience method for
     * &lt;code&gt;getReader(int, int, int, HTML.Tag, TRUE)&lt;/code&gt;.
     *
     * @param popDepth   the number of &lt;code&gt;ElementSpec.EndTagTypes&lt;/code&gt;
     *          to generate before inserting
     * @param pushDepth  the number of &lt;code&gt;ElementSpec.StartTagTypes&lt;/code&gt;
     *          with a direction of &lt;code&gt;ElementSpec.JoinNextDirection&lt;/code&gt;
     *          that should be generated before inserting,
     *          but after the end tags have been generated
     * @param insertTag  the first tag to start inserting into document
     * @return the reader used by the parser to load the document
     */
    public HTMLEditorKit.ParserCallback getReader(int pos, int popDepth,
                                                  int pushDepth,
                                                  HTML.Tag insertTag) {
<span class="nc" id="L353">        return getReader(pos, popDepth, pushDepth, insertTag, true);</span>
    }

    /**
     * Fetches the reader for the parser to use to load the document
     * with HTML.  This is implemented to return an instance of
     * HTMLDocument.HTMLReader.  Subclasses can reimplement this
     * method to change how the document get structured if desired
     * (e.g. to handle custom tags, structurally represent character
     * style elements, etc.).
     *
     * @param popDepth   the number of &lt;code&gt;ElementSpec.EndTagTypes&lt;/code&gt;
     *          to generate before inserting
     * @param pushDepth  the number of &lt;code&gt;ElementSpec.StartTagTypes&lt;/code&gt;
     *          with a direction of &lt;code&gt;ElementSpec.JoinNextDirection&lt;/code&gt;
     *          that should be generated before inserting,
     *          but after the end tags have been generated
     * @param insertTag  the first tag to start inserting into document
     * @param insertInsertTag  false if all the Elements after insertTag should
     *        be inserted; otherwise insertTag will be inserted
     * @return the reader used by the parser to load the document
     */
    HTMLEditorKit.ParserCallback getReader(int pos, int popDepth,
                                           int pushDepth,
                                           HTML.Tag insertTag,
                                           boolean insertInsertTag) {
<span class="nc" id="L379">        Object desc = getProperty(Document.StreamDescriptionProperty);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (desc instanceof URL) {</span>
<span class="nc" id="L381">            setBase((URL)desc);</span>
        }
<span class="nc" id="L383">        HTMLReader reader = new HTMLReader(pos, popDepth, pushDepth,</span>
                                           insertTag, insertInsertTag, false,
                                           true);
<span class="nc" id="L386">        return reader;</span>
    }

    /**
     * Returns the location to resolve relative URLs against.  By
     * default this will be the document's URL if the document
     * was loaded from a URL.  If a base tag is found and
     * can be parsed, it will be used as the base location.
     *
     * @return the base location
     */
    public URL getBase() {
<span class="nc" id="L398">        return base;</span>
    }

    /**
     * Sets the location to resolve relative URLs against.  By
     * default this will be the document's URL if the document
     * was loaded from a URL.  If a base tag is found and
     * can be parsed, it will be used as the base location.
     * &lt;p&gt;This also sets the base of the &lt;code&gt;StyleSheet&lt;/code&gt;
     * to be &lt;code&gt;u&lt;/code&gt; as well as the base of the document.
     *
     * @param u  the desired base URL
     */
    public void setBase(URL u) {
<span class="nc" id="L412">        base = u;</span>
<span class="nc" id="L413">        getStyleSheet().setBase(u);</span>
<span class="nc" id="L414">    }</span>

    /**
     * Inserts new elements in bulk.  This is how elements get created
     * in the document.  The parsing determines what structure is needed
     * and creates the specification as a set of tokens that describe the
     * edit while leaving the document free of a write-lock.  This method
     * can then be called in bursts by the reader to acquire a write-lock
     * for a shorter duration (i.e. while the document is actually being
     * altered).
     *
     * @param offset the starting offset
     * @param data the element data
     * @exception BadLocationException  if the given position does not
     *   represent a valid location in the associated document.
     */
    protected void insert(int offset, ElementSpec[] data) throws BadLocationException {
<span class="nc" id="L431">        super.insert(offset, data);</span>
<span class="nc" id="L432">    }</span>

    /**
     * Updates document structure as a result of text insertion.  This
     * will happen within a write lock.  This implementation simply
     * parses the inserted content for line breaks and builds up a set
     * of instructions for the element buffer.
     *
     * @param chng a description of the document change
     * @param attr the attributes
     */
    protected void insertUpdate(DefaultDocumentEvent chng, AttributeSet attr) {
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if(attr == null) {</span>
<span class="nc" id="L445">            attr = contentAttributeSet;</span>
        }

        // If this is the composed text element, merge the content attribute to it
<span class="nc bnc" id="L449" title="All 2 branches missed.">        else if (attr.isDefined(StyleConstants.ComposedTextAttribute)) {</span>
<span class="nc" id="L450">            ((MutableAttributeSet)attr).addAttributes(contentAttributeSet);</span>
        }

<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (attr.isDefined(IMPLIED_CR)) {</span>
<span class="nc" id="L454">            ((MutableAttributeSet)attr).removeAttribute(IMPLIED_CR);</span>
        }

<span class="nc" id="L457">        super.insertUpdate(chng, attr);</span>
<span class="nc" id="L458">    }</span>

    /**
     * Replaces the contents of the document with the given
     * element specifications.  This is called before insert if
     * the loading is done in bursts.  This is the only method called
     * if loading the document entirely in one burst.
     *
     * @param data  the new contents of the document
     */
    protected void create(ElementSpec[] data) {
<span class="nc" id="L469">        super.create(data);</span>
<span class="nc" id="L470">    }</span>

    /**
     * Sets attributes for a paragraph.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param offset the offset into the paragraph (must be at least 0)
     * @param length the number of characters affected (must be at least 0)
     * @param s the attributes
     * @param replace whether to replace existing attributes, or merge them
     */
    public void setParagraphAttributes(int offset, int length, AttributeSet s,
                                       boolean replace) {
        try {
<span class="nc" id="L488">            writeLock();</span>
            // Make sure we send out a change for the length of the paragraph.
<span class="nc" id="L490">            int end = Math.min(offset + length, getLength());</span>
<span class="nc" id="L491">            Element e = getParagraphElement(offset);</span>
<span class="nc" id="L492">            offset = e.getStartOffset();</span>
<span class="nc" id="L493">            e = getParagraphElement(end);</span>
<span class="nc" id="L494">            length = Math.max(0, e.getEndOffset() - offset);</span>
<span class="nc" id="L495">            DefaultDocumentEvent changes =</span>
                new DefaultDocumentEvent(offset, length,
                                         DocumentEvent.EventType.CHANGE);
<span class="nc" id="L498">            AttributeSet sCopy = s.copyAttributes();</span>
<span class="nc" id="L499">            int lastEnd = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            for (int pos = offset; pos &lt;= end; pos = lastEnd) {</span>
<span class="nc" id="L501">                Element paragraph = getParagraphElement(pos);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                if (lastEnd == paragraph.getEndOffset()) {</span>
<span class="nc" id="L503">                    lastEnd++;</span>
                }
                else {
<span class="nc" id="L506">                    lastEnd = paragraph.getEndOffset();</span>
                }
<span class="nc" id="L508">                MutableAttributeSet attr =</span>
<span class="nc" id="L509">                    (MutableAttributeSet) paragraph.getAttributes();</span>
<span class="nc" id="L510">                changes.addEdit(new AttributeUndoableEdit(paragraph, sCopy, replace));</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">                if (replace) {</span>
<span class="nc" id="L512">                    attr.removeAttributes(attr);</span>
                }
<span class="nc" id="L514">                attr.addAttributes(s);</span>
            }
<span class="nc" id="L516">            changes.end();</span>
<span class="nc" id="L517">            fireChangedUpdate(changes);</span>
<span class="nc" id="L518">            fireUndoableEditUpdate(new UndoableEditEvent(this, changes));</span>
        } finally {
<span class="nc" id="L520">            writeUnlock();</span>
<span class="nc" id="L521">        }</span>
<span class="nc" id="L522">    }</span>

    /**
     * Fetches the &lt;code&gt;StyleSheet&lt;/code&gt; with the document-specific display
     * rules (CSS) that were specified in the HTML document itself.
     *
     * @return the &lt;code&gt;StyleSheet&lt;/code&gt;
     */
    public StyleSheet getStyleSheet() {
<span class="nc" id="L531">        return (StyleSheet) getAttributeContext();</span>
    }

    /**
     * Fetches an iterator for the specified HTML tag.
     * This can be used for things like iterating over the
     * set of anchors contained, or iterating over the input
     * elements.
     *
     * @param t the requested &lt;code&gt;HTML.Tag&lt;/code&gt;
     * @return the &lt;code&gt;Iterator&lt;/code&gt; for the given HTML tag
     * @see javax.swing.text.html.HTML.Tag
     */
    public Iterator getIterator(HTML.Tag t) {
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (t.isBlock()) {</span>
            // TBD
<span class="nc" id="L547">            return null;</span>
        }
<span class="nc" id="L549">        return new LeafIterator(t, this);</span>
    }

    /**
     * Creates a document leaf element that directly represents
     * text (doesn't have any children).  This is implemented
     * to return an element of type
     * &lt;code&gt;HTMLDocument.RunElement&lt;/code&gt;.
     *
     * @param parent the parent element
     * @param a the attributes for the element
     * @param p0 the beginning of the range (must be at least 0)
     * @param p1 the end of the range (must be at least p0)
     * @return the new element
     */
    protected Element createLeafElement(Element parent, AttributeSet a, int p0, int p1) {
<span class="nc" id="L565">        return new RunElement(parent, a, p0, p1);</span>
    }

    /**
     * Creates a document branch element, that can contain other elements.
     * This is implemented to return an element of type
     * &lt;code&gt;HTMLDocument.BlockElement&lt;/code&gt;.
     *
     * @param parent the parent element
     * @param a the attributes
     * @return the element
     */
    protected Element createBranchElement(Element parent, AttributeSet a) {
<span class="nc" id="L578">        return new BlockElement(parent, a);</span>
    }

    /**
     * Creates the root element to be used to represent the
     * default document structure.
     *
     * @return the element base
     */
    protected AbstractElement createDefaultRoot() {
        // grabs a write-lock for this initialization and
        // abandon it during initialization so in normal
        // operation we can detect an illegitimate attempt
        // to mutate attributes.
<span class="nc" id="L592">        writeLock();</span>
<span class="nc" id="L593">        MutableAttributeSet a = new SimpleAttributeSet();</span>
<span class="nc" id="L594">        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.HTML);</span>
<span class="nc" id="L595">        BlockElement html = new BlockElement(null, a.copyAttributes());</span>
<span class="nc" id="L596">        a.removeAttributes(a);</span>
<span class="nc" id="L597">        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.BODY);</span>
<span class="nc" id="L598">        BlockElement body = new BlockElement(html, a.copyAttributes());</span>
<span class="nc" id="L599">        a.removeAttributes(a);</span>
<span class="nc" id="L600">        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.P);</span>
<span class="nc" id="L601">        getStyleSheet().addCSSAttributeFromHTML(a, CSS.Attribute.MARGIN_TOP, &quot;0&quot;);</span>
<span class="nc" id="L602">        BlockElement paragraph = new BlockElement(body, a.copyAttributes());</span>
<span class="nc" id="L603">        a.removeAttributes(a);</span>
<span class="nc" id="L604">        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.CONTENT);</span>
<span class="nc" id="L605">        RunElement brk = new RunElement(paragraph, a, 0, 1);</span>
<span class="nc" id="L606">        Element[] buff = new Element[1];</span>
<span class="nc" id="L607">        buff[0] = brk;</span>
<span class="nc" id="L608">        paragraph.replace(0, 0, buff);</span>
<span class="nc" id="L609">        buff[0] = paragraph;</span>
<span class="nc" id="L610">        body.replace(0, 0, buff);</span>
<span class="nc" id="L611">        buff[0] = body;</span>
<span class="nc" id="L612">        html.replace(0, 0, buff);</span>
<span class="nc" id="L613">        writeUnlock();</span>
<span class="nc" id="L614">        return html;</span>
    }

    /**
     * Sets the number of tokens to buffer before trying to update
     * the documents element structure.
     *
     * @param n  the number of tokens to buffer
     */
    public void setTokenThreshold(int n) {
<span class="nc" id="L624">        putProperty(TokenThreshold, new Integer(n));</span>
<span class="nc" id="L625">    }</span>

    /**
     * Gets the number of tokens to buffer before trying to update
     * the documents element structure.  The default value is
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.
     *
     * @return the number of tokens to buffer
     */
    public int getTokenThreshold() {
<span class="nc" id="L635">        Integer i = (Integer) getProperty(TokenThreshold);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (i != null) {</span>
<span class="nc" id="L637">            return i.intValue();</span>
        }
<span class="nc" id="L639">        return Integer.MAX_VALUE;</span>
    }

    /**
     * Determines how unknown tags are handled by the parser.
     * If set to true, unknown
     * tags are put in the model, otherwise they are dropped.
     *
     * @param preservesTags  true if unknown tags should be
     *          saved in the model, otherwise tags are dropped
     * @see javax.swing.text.html.HTML.Tag
     */
    public void setPreservesUnknownTags(boolean preservesTags) {
<span class="nc" id="L652">        preservesUnknownTags = preservesTags;</span>
<span class="nc" id="L653">    }</span>

    /**
     * Returns the behavior the parser observes when encountering
     * unknown tags.
     *
     * @see javax.swing.text.html.HTML.Tag
     * @return true if unknown tags are to be preserved when parsing
     */
    public boolean getPreservesUnknownTags() {
<span class="nc" id="L663">        return preservesUnknownTags;</span>
    }

    /**
     * Processes &lt;code&gt;HyperlinkEvents&lt;/code&gt; that
     * are generated by documents in an HTML frame.
     * The &lt;code&gt;HyperlinkEvent&lt;/code&gt; type, as the parameter suggests,
     * is &lt;code&gt;HTMLFrameHyperlinkEvent&lt;/code&gt;.
     * In addition to the typical information contained in a
     * &lt;code&gt;HyperlinkEvent&lt;/code&gt;,
     * this event contains the element that corresponds to the frame in
     * which the click happened (the source element) and the
     * target name.  The target name has 4 possible values:
     * &lt;ul&gt;
     * &lt;li&gt;  _self
     * &lt;li&gt;  _parent
     * &lt;li&gt;  _top
     * &lt;li&gt;  a named frame
     * &lt;/ul&gt;
     *
     * If target is _self, the action is to change the value of the
     * &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute and fires a
     * &lt;code&gt;ChangedUpdate&lt;/code&gt; event.
     *&lt;p&gt;
     * If the target is _parent, then it deletes the parent element,
     * which is a &amp;lt;FRAMESET&amp;gt; element, and inserts a new &amp;lt;FRAME&amp;gt;
     * element, and sets its &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute
     * to have a value equal to the destination URL and fire a
     * &lt;code&gt;RemovedUpdate&lt;/code&gt; and &lt;code&gt;InsertUpdate&lt;/code&gt;.
     *&lt;p&gt;
     * If the target is _top, this method does nothing. In the implementation
     * of the view for a frame, namely the &lt;code&gt;FrameView&lt;/code&gt;,
     * the processing of _top is handled.  Given that _top implies
     * replacing the entire document, it made sense to handle this outside
     * of the document that it will replace.
     *&lt;p&gt;
     * If the target is a named frame, then the element hierarchy is searched
     * for an element with a name equal to the target, its
     * &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute is updated and a
     * &lt;code&gt;ChangedUpdate&lt;/code&gt; event is fired.
     *
     * @param e the event
     */
    public void processHTMLFrameHyperlinkEvent(HTMLFrameHyperlinkEvent e) {
<span class="nc" id="L707">        String frameName = e.getTarget();</span>
<span class="nc" id="L708">        Element element = e.getSourceElement();</span>
<span class="nc" id="L709">        String urlStr = e.getURL().toString();</span>

<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (frameName.equals(&quot;_self&quot;)) {</span>
            /*
              The source and destination elements
              are the same.
            */
<span class="nc" id="L716">            updateFrame(element, urlStr);</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">        } else if (frameName.equals(&quot;_parent&quot;)) {</span>
            /*
              The destination is the parent of the frame.
            */
<span class="nc" id="L721">            updateFrameSet(element.getParentElement(), urlStr);</span>
        } else {
            /*
              locate a named frame
            */
<span class="nc" id="L726">            Element targetElement = findFrame(frameName);</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (targetElement != null) {</span>
<span class="nc" id="L728">                updateFrame(targetElement, urlStr);</span>
            }
        }
<span class="nc" id="L731">    }</span>


    /**
     * Searches the element hierarchy for an FRAME element
     * that has its name attribute equal to the &lt;code&gt;frameName&lt;/code&gt;.
     *
     * @param frameName
     * @return the element whose NAME attribute has a value of
     *          &lt;code&gt;frameName&lt;/code&gt;; returns &lt;code&gt;null&lt;/code&gt;
     *          if not found
     */
    private Element findFrame(String frameName) {
<span class="nc" id="L744">        ElementIterator it = new ElementIterator(this);</span>
        Element next;

<span class="nc bnc" id="L747" title="All 2 branches missed.">        while ((next = it.next()) != null) {</span>
<span class="nc" id="L748">            AttributeSet attr = next.getAttributes();</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">            if (matchNameAttribute(attr, HTML.Tag.FRAME)) {</span>
<span class="nc" id="L750">                String frameTarget = (String)attr.getAttribute(HTML.Attribute.NAME);</span>
<span class="nc bnc" id="L751" title="All 4 branches missed.">                if (frameTarget != null &amp;&amp; frameTarget.equals(frameName)) {</span>
<span class="nc" id="L752">                    break;</span>
                }
            }
<span class="nc" id="L755">        }</span>
<span class="nc" id="L756">        return next;</span>
    }

    /**
     * Returns true if &lt;code&gt;StyleConstants.NameAttribute&lt;/code&gt; is
     * equal to the tag that is passed in as a parameter.
     *
     * @param attr the attributes to be matched
     * @param tag the value to be matched
     * @return true if there is a match, false otherwise
     * @see javax.swing.text.html.HTML.Attribute
     */
    static boolean matchNameAttribute(AttributeSet attr, HTML.Tag tag) {
<span class="nc" id="L769">        Object o = attr.getAttribute(StyleConstants.NameAttribute);</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">        if (o instanceof HTML.Tag) {</span>
<span class="nc" id="L771">            HTML.Tag name = (HTML.Tag) o;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">            if (name == tag) {</span>
<span class="nc" id="L773">                return true;</span>
            }
        }
<span class="nc" id="L776">        return false;</span>
    }

    /**
     * Replaces a frameset branch Element with a frame leaf element.
     *
     * @param element the frameset element to remove
     * @param url     the value for the SRC attribute for the
     *                new frame that will replace the frameset
     */
    private void updateFrameSet(Element element, String url) {
        try {
<span class="nc" id="L788">            int startOffset = element.getStartOffset();</span>
<span class="nc" id="L789">            int endOffset = Math.min(getLength(), element.getEndOffset());</span>
<span class="nc" id="L790">            String html = &quot;&lt;frame&quot;;</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">            if (url != null) {</span>
<span class="nc" id="L792">                html += &quot; src=\&quot;&quot; + url + &quot;\&quot;&quot;;</span>
            }
<span class="nc" id="L794">            html += &quot;&gt;&quot;;</span>
<span class="nc" id="L795">            installParserIfNecessary();</span>
<span class="nc" id="L796">            setOuterHTML(element, html);</span>
<span class="nc" id="L797">        } catch (BadLocationException e1) {</span>
            // Should handle this better
<span class="nc" id="L799">        } catch (IOException ioe) {</span>
            // Should handle this better
<span class="nc" id="L801">        }</span>
<span class="nc" id="L802">    }</span>


    /**
     * Updates the Frame elements &lt;code&gt;HTML.Attribute.SRC attribute&lt;/code&gt;
     * and fires a &lt;code&gt;ChangedUpdate&lt;/code&gt; event.
     *
     * @param element a FRAME element whose SRC attribute will be updated
     * @param url     a string specifying the new value for the SRC attribute
     */
    private void updateFrame(Element element, String url) {

        try {
<span class="nc" id="L815">            writeLock();</span>
<span class="nc" id="L816">            DefaultDocumentEvent changes = new DefaultDocumentEvent(element.getStartOffset(),</span>
                                                                    1,
                                                                    DocumentEvent.EventType.CHANGE);
<span class="nc" id="L819">            AttributeSet sCopy = element.getAttributes().copyAttributes();</span>
<span class="nc" id="L820">            MutableAttributeSet attr = (MutableAttributeSet) element.getAttributes();</span>
<span class="nc" id="L821">            changes.addEdit(new AttributeUndoableEdit(element, sCopy, false));</span>
<span class="nc" id="L822">            attr.removeAttribute(HTML.Attribute.SRC);</span>
<span class="nc" id="L823">            attr.addAttribute(HTML.Attribute.SRC, url);</span>
<span class="nc" id="L824">            changes.end();</span>
<span class="nc" id="L825">            fireChangedUpdate(changes);</span>
<span class="nc" id="L826">            fireUndoableEditUpdate(new UndoableEditEvent(this, changes));</span>
        } finally {
<span class="nc" id="L828">            writeUnlock();</span>
<span class="nc" id="L829">        }</span>
<span class="nc" id="L830">    }</span>


    /**
     * Returns true if the document will be viewed in a frame.
     * @return true if document will be viewed in a frame, otherwise false
     */
    boolean isFrameDocument() {
<span class="nc" id="L838">        return frameDocument;</span>
    }

    /**
     * Sets a boolean state about whether the document will be
     * viewed in a frame.
     * @param frameDoc  true if the document will be viewed in a frame,
     *          otherwise false
     */
    void setFrameDocumentState(boolean frameDoc) {
<span class="nc" id="L848">        this.frameDocument = frameDoc;</span>
<span class="nc" id="L849">    }</span>

    /**
     * Adds the specified map, this will remove a Map that has been
     * previously registered with the same name.
     *
     * @param map  the &lt;code&gt;Map&lt;/code&gt; to be registered
     */
    void addMap(Map map) {
<span class="nc" id="L858">        String     name = map.getName();</span>

<span class="nc bnc" id="L860" title="All 2 branches missed.">        if (name != null) {</span>
<span class="nc" id="L861">            Object     maps = getProperty(MAP_PROPERTY);</span>

<span class="nc bnc" id="L863" title="All 2 branches missed.">            if (maps == null) {</span>
<span class="nc" id="L864">                maps = new Hashtable(11);</span>
<span class="nc" id="L865">                putProperty(MAP_PROPERTY, maps);</span>
            }
<span class="nc bnc" id="L867" title="All 2 branches missed.">            if (maps instanceof Hashtable) {</span>
<span class="nc" id="L868">                ((Hashtable)maps).put(&quot;#&quot; + name, map);</span>
            }
        }
<span class="nc" id="L871">    }</span>

    /**
     * Removes a previously registered map.
     * @param map the &lt;code&gt;Map&lt;/code&gt; to be removed
     */
    void removeMap(Map map) {
<span class="nc" id="L878">        String     name = map.getName();</span>

<span class="nc bnc" id="L880" title="All 2 branches missed.">        if (name != null) {</span>
<span class="nc" id="L881">            Object     maps = getProperty(MAP_PROPERTY);</span>

<span class="nc bnc" id="L883" title="All 2 branches missed.">            if (maps instanceof Hashtable) {</span>
<span class="nc" id="L884">                ((Hashtable)maps).remove(&quot;#&quot; + name);</span>
            }
        }
<span class="nc" id="L887">    }</span>

    /**
     * Returns the Map associated with the given name.
     * @param name the name of the desired &lt;code&gt;Map&lt;/code&gt;
     * @return the &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; if it can't
     *          be found, or if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     */
    Map getMap(String name) {
<span class="nc bnc" id="L896" title="All 2 branches missed.">        if (name != null) {</span>
<span class="nc" id="L897">            Object     maps = getProperty(MAP_PROPERTY);</span>

<span class="nc bnc" id="L899" title="All 4 branches missed.">            if (maps != null &amp;&amp; (maps instanceof Hashtable)) {</span>
<span class="nc" id="L900">                return (Map)((Hashtable)maps).get(name);</span>
            }
        }
<span class="nc" id="L903">        return null;</span>
    }

    /**
     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of the possible Maps.
     * @return the enumerated list of maps, or &lt;code&gt;null&lt;/code&gt;
     *          if the maps are not an instance of &lt;code&gt;Hashtable&lt;/code&gt;
     */
    Enumeration getMaps() {
<span class="nc" id="L912">        Object     maps = getProperty(MAP_PROPERTY);</span>

<span class="nc bnc" id="L914" title="All 2 branches missed.">        if (maps instanceof Hashtable) {</span>
<span class="nc" id="L915">            return ((Hashtable)maps).elements();</span>
        }
<span class="nc" id="L917">        return null;</span>
    }

    /**
     * Sets the content type language used for style sheets that do not
     * explicitly specify the type. The default is text/css.
     * @param contentType  the content type language for the style sheets
     */
    /* public */
    void setDefaultStyleSheetType(String contentType) {
<span class="nc" id="L927">        putProperty(StyleType, contentType);</span>
<span class="nc" id="L928">    }</span>

    /**
     * Returns the content type language used for style sheets. The default
     * is text/css.
     * @return the content type language used for the style sheets
     */
    /* public */
    String getDefaultStyleSheetType() {
<span class="nc" id="L937">        String retValue = (String)getProperty(StyleType);</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">        if (retValue == null) {</span>
<span class="nc" id="L939">            return &quot;text/css&quot;;</span>
        }
<span class="nc" id="L941">        return retValue;</span>
    }

    /**
     * Sets the parser that is used by the methods that insert html
     * into the existing document, such as &lt;code&gt;setInnerHTML&lt;/code&gt;,
     * and &lt;code&gt;setOuterHTML&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;code&gt;HTMLEditorKit.createDefaultDocument&lt;/code&gt; will set the parser
     * for you. If you create an &lt;code&gt;HTMLDocument&lt;/code&gt; by hand,
     * be sure and set the parser accordingly.
     * @param parser the parser to be used for text insertion
     *
     * @since 1.3
     */
    public void setParser(HTMLEditorKit.Parser parser) {
<span class="nc" id="L957">        this.parser = parser;</span>
<span class="nc" id="L958">        putProperty(&quot;__PARSER__&quot;, null);</span>
<span class="nc" id="L959">    }</span>

    /**
     * Returns the parser that is used when inserting HTML into the existing
     * document.
     * @return the parser used for text insertion
     *
     * @since 1.3
     */
    public HTMLEditorKit.Parser getParser() {
<span class="nc" id="L969">        Object p = getProperty(&quot;__PARSER__&quot;);</span>

<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (p instanceof HTMLEditorKit.Parser) {</span>
<span class="nc" id="L972">            return (HTMLEditorKit.Parser)p;</span>
        }
<span class="nc" id="L974">        return parser;</span>
    }

    /**
     * Replaces the children of the given element with the contents
     * specified as an HTML string.
     *
     * &lt;p&gt;This will be seen as at least two events, n inserts followed by
     * a remove.&lt;/p&gt;
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;setInnerHTML(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
     * results in the following structure (new elements are &lt;font
     * color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *         \
     *         &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt;
     *           \
     *           &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Parameter &lt;code&gt;elem&lt;/code&gt; must not be a leaf element,
     * otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     * If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter
     * is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
     * if the document was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the branch element whose children will be replaced
     * @param htmlText the string to be parsed and assigned to &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;elem&lt;/code&gt; is a leaf
     * @throws IllegalStateException if an &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt;
     *         has not been defined
     * @since 1.3
     */
    public void setInnerHTML(Element elem, String htmlText) throws
                             BadLocationException, IOException {
<span class="nc" id="L1028">        verifyParser();</span>
<span class="nc bnc" id="L1029" title="All 4 branches missed.">        if (elem != null &amp;&amp; elem.isLeaf()) {</span>
<span class="nc" id="L1030">            throw new IllegalArgumentException</span>
                (&quot;Can not set inner HTML of a leaf&quot;);
        }
<span class="nc bnc" id="L1033" title="All 4 branches missed.">        if (elem != null &amp;&amp; htmlText != null) {</span>
<span class="nc" id="L1034">            int oldCount = elem.getElementCount();</span>
<span class="nc" id="L1035">            int insertPosition = elem.getStartOffset();</span>
<span class="nc" id="L1036">            insertHTML(elem, elem.getStartOffset(), htmlText, true);</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (elem.getElementCount() &gt; oldCount) {</span>
                // Elements were inserted, do the cleanup.
<span class="nc" id="L1039">                removeElements(elem, elem.getElementCount() - oldCount,</span>
                               oldCount);
            }
        }
<span class="nc" id="L1043">    }</span>

    /**
     * Replaces the given element in the parent with the contents
     * specified as an HTML string.
     *
     * &lt;p&gt;This will be seen as at least two events, n inserts followed by
     * a remove.&lt;/p&gt;
     *
     * &lt;p&gt;When replacing a leaf this will attempt to make sure there is
     * a newline present if one is needed. This may result in an additional
     * element being inserted. Consider, if you were to replace a character
     * element that contained a newline with &amp;lt;img&amp;gt; this would create
     * two elements, one for the image, and one for the newline.&lt;/p&gt;
     *
     * &lt;p&gt;If you try to replace the element at length you will most
     * likely end up with two elements, eg
     * &lt;code&gt;setOuterHTML(getCharacterElement (getLength()),
     * &quot;blah&quot;)&lt;/code&gt; will result in two leaf elements at the end, one
     * representing 'blah', and the other representing the end
     * element.&lt;/p&gt;
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;setOuterHTML(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
     * results in the following structure (new elements are &lt;font
     * color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *    &amp;lt;body&amp;gt;
     *      |
     *     &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt;
     *       \
     *       &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt;
     * parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the
     * document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * HTMLEditorKit.Parser set. This will be the case if the document
     * was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the element to replace
     * @param htmlText the string to be parsed and inserted in place of &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
     *         been set
     * @since 1.3
     */
    public void setOuterHTML(Element elem, String htmlText) throws
                            BadLocationException, IOException {
<span class="nc" id="L1105">        verifyParser();</span>
<span class="nc bnc" id="L1106" title="All 6 branches missed.">        if (elem != null &amp;&amp; elem.getParentElement() != null &amp;&amp;</span>
            htmlText != null) {
<span class="nc" id="L1108">            int start = elem.getStartOffset();</span>
<span class="nc" id="L1109">            int end = elem.getEndOffset();</span>
<span class="nc" id="L1110">            int startLength = getLength();</span>
            // We don't want a newline if elem is a leaf, and doesn't contain
            // a newline.
<span class="nc bnc" id="L1113" title="All 2 branches missed.">            boolean wantsNewline = !elem.isLeaf();</span>
<span class="nc bnc" id="L1114" title="All 4 branches missed.">            if (!wantsNewline &amp;&amp; (end &gt; startLength ||</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">                                 getText(end - 1, 1).charAt(0) == NEWLINE[0])){</span>
<span class="nc" id="L1116">                wantsNewline = true;</span>
            }
<span class="nc" id="L1118">            Element parent = elem.getParentElement();</span>
<span class="nc" id="L1119">            int oldCount = parent.getElementCount();</span>
<span class="nc" id="L1120">            insertHTML(parent, start, htmlText, wantsNewline);</span>
            // Remove old.
<span class="nc" id="L1122">            int newLength = getLength();</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">            if (oldCount != parent.getElementCount()) {</span>
<span class="nc" id="L1124">                int removeIndex = parent.getElementIndex(start + newLength -</span>
                                                         startLength);
<span class="nc" id="L1126">                removeElements(parent, removeIndex, 1);</span>
            }
        }
<span class="nc" id="L1129">    }</span>

    /**
     * Inserts the HTML specified as a string at the start
     * of the element.
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;insertAfterStart(elem,
     * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt; results in the following structure
     * (new elements are &lt;font color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *        &amp;lt;body&amp;gt;
     *          |
     *        &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *       /  |  \
     *    &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt; &amp;lt;p&amp;gt; &amp;lt;p&amp;gt;
     *     /
     *  &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Unlike the &lt;code&gt;insertBeforeStart&lt;/code&gt; method, new
     *  elements become &lt;em&gt;children&lt;/em&gt; of the specified element,
     *  not siblings.&lt;/p&gt;
     *
     * &lt;p&gt;Parameter &lt;code&gt;elem&lt;/code&gt; must not be a leaf element,
     * otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     * If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter
     * is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
     * if the document was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the branch element to be the root for the new text
     * @param htmlText the string to be parsed and assigned to &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;elem&lt;/code&gt; is a leaf
     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
     *         been set on the document
     * @since 1.3
     */
    public void insertAfterStart(Element elem, String htmlText) throws
                                 BadLocationException, IOException {
<span class="nc" id="L1183">        verifyParser();</span>

<span class="nc bnc" id="L1185" title="All 4 branches missed.">        if (elem == null || htmlText == null) {</span>
<span class="nc" id="L1186">            return;</span>
        }

<span class="nc bnc" id="L1189" title="All 2 branches missed.">        if (elem.isLeaf()) {</span>
<span class="nc" id="L1190">            throw new IllegalArgumentException</span>
                (&quot;Can not insert HTML after start of a leaf&quot;);
        }
<span class="nc" id="L1193">        insertHTML(elem, elem.getStartOffset(), htmlText, false);</span>
<span class="nc" id="L1194">    }</span>

    /**
     * Inserts the HTML specified as a string at the end of
     * the element.
     *
     * &lt;p&gt; If &lt;code&gt;elem&lt;/code&gt;'s children are leaves, and the
     * character at a &lt;code&gt;elem.getEndOffset() - 1&lt;/code&gt; is a newline,
     * this will insert before the newline so that there isn't text after
     * the newline.&lt;/p&gt;
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;insertBeforeEnd(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
     * results in the following structure (new elements are &lt;font
     * color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *        &amp;lt;body&amp;gt;
     *          |
     *        &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *       /  |  \
     *     &amp;lt;p&amp;gt; &amp;lt;p&amp;gt; &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt;
     *               \
     *               &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Unlike the &lt;code&gt;insertAfterEnd&lt;/code&gt; method, new elements
     * become &lt;em&gt;children&lt;/em&gt; of the specified element, not
     * siblings.&lt;/p&gt;
     *
     * &lt;p&gt;Parameter &lt;code&gt;elem&lt;/code&gt; must not be a leaf element,
     * otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     * If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter
     * is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
     * if the document was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the element to be the root for the new text
     * @param htmlText the string to be parsed and assigned to &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;elem&lt;/code&gt; is a leaf
     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
     *         been set on the document
     * @since 1.3
     */
    public void insertBeforeEnd(Element elem, String htmlText) throws
                                BadLocationException, IOException {
<span class="nc" id="L1253">        verifyParser();</span>
<span class="nc bnc" id="L1254" title="All 4 branches missed.">        if (elem != null &amp;&amp; elem.isLeaf()) {</span>
<span class="nc" id="L1255">            throw new IllegalArgumentException</span>
                (&quot;Can not set inner HTML before end of leaf&quot;);
        }
<span class="nc bnc" id="L1258" title="All 2 branches missed.">        if (elem != null) {</span>
<span class="nc" id="L1259">            int offset = elem.getEndOffset();</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">            if (elem.getElement(elem.getElementIndex(offset - 1)).isLeaf() &amp;&amp;</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">                getText(offset - 1, 1).charAt(0) == NEWLINE[0]) {</span>
<span class="nc" id="L1262">                offset--;</span>
            }
<span class="nc" id="L1264">            insertHTML(elem, offset, htmlText, false);</span>
        }
<span class="nc" id="L1266">    }</span>

    /**
     * Inserts the HTML specified as a string before the start of
     * the given element.
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;insertBeforeStart(elem,
     * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt; results in the following structure
     * (new elements are &lt;font color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *        &amp;lt;body&amp;gt;
     *         /  \
     *      &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt; &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *       /    /  \
     *     &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt; &amp;lt;p&amp;gt;  &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Unlike the &lt;code&gt;insertAfterStart&lt;/code&gt; method, new
     * elements become &lt;em&gt;siblings&lt;/em&gt; of the specified element, not
     * children.&lt;/p&gt;
     *
     * &lt;p&gt;If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt;
     * parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the
     * document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
     * if the document was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the element the content is inserted before
     * @param htmlText the string to be parsed and inserted before &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
     *         been set on the document
     * @since 1.3
     */
    public void insertBeforeStart(Element elem, String htmlText) throws
                                  BadLocationException, IOException {
<span class="nc" id="L1316">        verifyParser();</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">        if (elem != null) {</span>
<span class="nc" id="L1318">            Element parent = elem.getParentElement();</span>

<span class="nc bnc" id="L1320" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L1321">                insertHTML(parent, elem.getStartOffset(), htmlText, false);</span>
            }
        }
<span class="nc" id="L1324">    }</span>

    /**
     * Inserts the HTML specified as a string after the the end of the
     * given element.
     *
     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *     &amp;lt;body&amp;gt;
     *       |
     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
     *      /  \
     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Invoking &lt;code&gt;insertAfterEnd(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
     * results in the following structure (new elements are &lt;font
     * color=&quot;red&quot;&gt;in red&lt;/font&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     *        &amp;lt;body&amp;gt;
     *         /  \
     *      &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt; &lt;font color=&quot;red&quot;&gt;&amp;lt;ul&amp;gt;&lt;/font&gt;
     *       / \    \
     *     &amp;lt;p&amp;gt; &amp;lt;p&amp;gt;  &lt;font color=&quot;red&quot;&gt;&amp;lt;li&amp;gt;&lt;/font&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Unlike the &lt;code&gt;insertBeforeEnd&lt;/code&gt; method, new elements
     * become &lt;em&gt;siblings&lt;/em&gt; of the specified element, not
     * children.&lt;/p&gt;
     *
     * &lt;p&gt;If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt;
     * parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the
     * document.&lt;/p&gt;
     *
     * &lt;p&gt;For this to work correctly, the document must have an
     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
     * if the document was created from an HTMLEditorKit via the
     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
     *
     * @param elem the element the content is inserted after
     * @param htmlText the string to be parsed and inserted after &lt;code&gt;elem&lt;/code&gt;
     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
     *         been set on the document
     * @since 1.3
     */
    public void insertAfterEnd(Element elem, String htmlText) throws
                               BadLocationException, IOException {
<span class="nc" id="L1374">        verifyParser();</span>
<span class="nc bnc" id="L1375" title="All 2 branches missed.">        if (elem != null) {</span>
<span class="nc" id="L1376">            Element parent = elem.getParentElement();</span>

<span class="nc bnc" id="L1378" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L1379">                int offset = elem.getEndOffset();</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">                if (offset &gt; getLength()) {</span>
<span class="nc" id="L1381">                    offset--;</span>
                }
<span class="nc bnc" id="L1383" title="All 2 branches missed.">                else if (elem.isLeaf() &amp;&amp; getText(offset - 1, 1).</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">                    charAt(0) == NEWLINE[0]) {</span>
<span class="nc" id="L1385">                    offset--;</span>
                }
<span class="nc" id="L1387">                insertHTML(parent, offset, htmlText, false);</span>
            }
        }
<span class="nc" id="L1390">    }</span>

    /**
     * Returns the element that has the given id &lt;code&gt;Attribute&lt;/code&gt;.
     * If the element can't be found, &lt;code&gt;null&lt;/code&gt; is returned.
     * Note that this method works on an &lt;code&gt;Attribute&lt;/code&gt;,
     * &lt;i&gt;not&lt;/i&gt; a character tag.  In the following HTML snippet:
     * &lt;code&gt;&amp;lt;a id=&quot;HelloThere&quot;&amp;gt;&lt;/code&gt; the attribute is
     * 'id' and the character tag is 'a'.
     * This is a convenience method for
     * &lt;code&gt;getElement(RootElement, HTML.Attribute.id, id)&lt;/code&gt;.
     * This is not thread-safe.
     *
     * @param id  the string representing the desired &lt;code&gt;Attribute&lt;/code&gt;
     * @return the element with the specified &lt;code&gt;Attribute&lt;/code&gt;
     *          or &lt;code&gt;null&lt;/code&gt; if it can't be found,
     *          or &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;id&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @see javax.swing.text.html.HTML.Attribute
     * @since 1.3
     */
    public Element getElement(String id) {
<span class="nc bnc" id="L1411" title="All 2 branches missed.">        if (id == null) {</span>
<span class="nc" id="L1412">            return null;</span>
        }
<span class="nc" id="L1414">        return getElement(getDefaultRootElement(), HTML.Attribute.ID, id,</span>
                          true);
    }

    /**
     * Returns the child element of &lt;code&gt;e&lt;/code&gt; that contains the
     * attribute, &lt;code&gt;attribute&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt; if one isn't found. This is not thread-safe.
     *
     * @param e the root element where the search begins
     * @param attribute the desired &lt;code&gt;Attribute&lt;/code&gt;
     * @param value the values for the specified &lt;code&gt;Attribute&lt;/code&gt;
     * @return the element with the specified &lt;code&gt;Attribute&lt;/code&gt;
     *          and the specified &lt;code&gt;value&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
     *          if it can't be found
     * @see javax.swing.text.html.HTML.Attribute
     * @since 1.3
     */
    public Element getElement(Element e, Object attribute, Object value) {
<span class="nc" id="L1433">        return getElement(e, attribute, value, true);</span>
    }

    /**
     * Returns the child element of &lt;code&gt;e&lt;/code&gt; that contains the
     * attribute, &lt;code&gt;attribute&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt; if one isn't found. This is not thread-safe.
     * &lt;p&gt;
     * If &lt;code&gt;searchLeafAttributes&lt;/code&gt; is true, and &lt;code&gt;e&lt;/code&gt; is
     * a leaf, any attributes that are instances of &lt;code&gt;HTML.Tag&lt;/code&gt;
     * with a value that is an &lt;code&gt;AttributeSet&lt;/code&gt; will also be checked.
     *
     * @param e the root element where the search begins
     * @param attribute the desired &lt;code&gt;Attribute&lt;/code&gt;
     * @param value the values for the specified &lt;code&gt;Attribute&lt;/code&gt;
     * @return the element with the specified &lt;code&gt;Attribute&lt;/code&gt;
     *          and the specified &lt;code&gt;value&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
     *          if it can't be found
     * @see javax.swing.text.html.HTML.Attribute
     */
    private Element getElement(Element e, Object attribute, Object value,
                               boolean searchLeafAttributes) {
<span class="nc" id="L1455">        AttributeSet attr = e.getAttributes();</span>

<span class="nc bnc" id="L1457" title="All 4 branches missed.">        if (attr != null &amp;&amp; attr.isDefined(attribute)) {</span>
<span class="nc bnc" id="L1458" title="All 2 branches missed.">            if (value.equals(attr.getAttribute(attribute))) {</span>
<span class="nc" id="L1459">                return e;</span>
            }
        }
<span class="nc bnc" id="L1462" title="All 2 branches missed.">        if (!e.isLeaf()) {</span>
<span class="nc" id="L1463">            for (int counter = 0, maxCounter = e.getElementCount();</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">                 counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L1465">                Element retValue = getElement(e.getElement(counter), attribute,</span>
                                              value, searchLeafAttributes);

<span class="nc bnc" id="L1468" title="All 2 branches missed.">                if (retValue != null) {</span>
<span class="nc" id="L1469">                    return retValue;</span>
                }
            }
        }
<span class="nc bnc" id="L1473" title="All 4 branches missed.">        else if (searchLeafAttributes &amp;&amp; attr != null) {</span>
            // For some leaf elements we store the actual attributes inside
            // the AttributeSet of the Element (such as anchors).
<span class="nc" id="L1476">            Enumeration names = attr.getAttributeNames();</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">            if (names != null) {</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                while (names.hasMoreElements()) {</span>
<span class="nc" id="L1479">                    Object name = names.nextElement();</span>
<span class="nc bnc" id="L1480" title="All 2 branches missed.">                    if ((name instanceof HTML.Tag) &amp;&amp;</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">                        (attr.getAttribute(name) instanceof AttributeSet)) {</span>

<span class="nc" id="L1483">                        AttributeSet check = (AttributeSet)attr.</span>
<span class="nc" id="L1484">                                             getAttribute(name);</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">                        if (check.isDefined(attribute) &amp;&amp;</span>
<span class="nc bnc" id="L1486" title="All 2 branches missed.">                            value.equals(check.getAttribute(attribute))) {</span>
<span class="nc" id="L1487">                            return e;</span>
                        }
                    }
<span class="nc" id="L1490">                }</span>
            }
        }
<span class="nc" id="L1493">        return null;</span>
    }

    /**
     * Verifies the document has an &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set.
     * If &lt;code&gt;getParser&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, this will throw an
     * IllegalStateException.
     *
     * @throws IllegalStateException if the document does not have a Parser
     */
    private void verifyParser() {
<span class="nc bnc" id="L1504" title="All 2 branches missed.">        if (getParser() == null) {</span>
<span class="nc" id="L1505">            throw new IllegalStateException(&quot;No HTMLEditorKit.Parser&quot;);</span>
        }
<span class="nc" id="L1507">    }</span>

    /**
     * Installs a default Parser if one has not been installed yet.
     */
    private void installParserIfNecessary() {
<span class="nc bnc" id="L1513" title="All 2 branches missed.">        if (getParser() == null) {</span>
<span class="nc" id="L1514">            setParser(new HTMLEditorKit().getParser());</span>
        }
<span class="nc" id="L1516">    }</span>

    /**
     * Inserts a string of HTML into the document at the given position.
     * &lt;code&gt;parent&lt;/code&gt; is used to identify the location to insert the
     * &lt;code&gt;html&lt;/code&gt;. If &lt;code&gt;parent&lt;/code&gt; is a leaf this can have
     * unexpected results.
     */
    private void insertHTML(Element parent, int offset, String html,
                            boolean wantsTrailingNewline)
                 throws BadLocationException, IOException {
<span class="nc bnc" id="L1527" title="All 4 branches missed.">        if (parent != null &amp;&amp; html != null) {</span>
<span class="nc" id="L1528">            HTMLEditorKit.Parser parser = getParser();</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">            if (parser != null) {</span>
<span class="nc" id="L1530">                int lastOffset = Math.max(0, offset - 1);</span>
<span class="nc" id="L1531">                Element charElement = getCharacterElement(lastOffset);</span>
<span class="nc" id="L1532">                Element commonParent = parent;</span>
<span class="nc" id="L1533">                int pop = 0;</span>
<span class="nc" id="L1534">                int push = 0;</span>

<span class="nc bnc" id="L1536" title="All 2 branches missed.">                if (parent.getStartOffset() &gt; lastOffset) {</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">                    while (commonParent != null &amp;&amp;</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">                           commonParent.getStartOffset() &gt; lastOffset) {</span>
<span class="nc" id="L1539">                        commonParent = commonParent.getParentElement();</span>
<span class="nc" id="L1540">                        push++;</span>
                    }
<span class="nc bnc" id="L1542" title="All 2 branches missed.">                    if (commonParent == null) {</span>
<span class="nc" id="L1543">                        throw new BadLocationException(&quot;No common parent&quot;,</span>
                                                       offset);
                    }
                }
<span class="nc bnc" id="L1547" title="All 4 branches missed.">                while (charElement != null &amp;&amp; charElement != commonParent) {</span>
<span class="nc" id="L1548">                    pop++;</span>
<span class="nc" id="L1549">                    charElement = charElement.getParentElement();</span>
                }
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                if (charElement != null) {</span>
                    // Found it, do the insert.
<span class="nc" id="L1553">                    HTMLReader reader = new HTMLReader(offset, pop - 1, push,</span>
                                                       null, false, true,
                                                       wantsTrailingNewline);

<span class="nc" id="L1557">                    parser.parse(new StringReader(html), reader, true);</span>
<span class="nc" id="L1558">                    reader.flush();</span>
                }
            }
        }
<span class="nc" id="L1562">    }</span>

    /**
     * Removes child Elements of the passed in Element &lt;code&gt;e&lt;/code&gt;. This
     * will do the necessary cleanup to ensure the element representing the
     * end character is correctly created.
     * &lt;p&gt;This is not a general purpose method, it assumes that &lt;code&gt;e&lt;/code&gt;
     * will still have at least one child after the remove, and it assumes
     * the character at &lt;code&gt;e.getStartOffset() - 1&lt;/code&gt; is a newline and
     * is of length 1.
     */
    private void removeElements(Element e, int index, int count) throws BadLocationException {
<span class="nc" id="L1574">        writeLock();</span>
        try {
<span class="nc" id="L1576">            int start = e.getElement(index).getStartOffset();</span>
<span class="nc" id="L1577">            int end = e.getElement(index + count - 1).getEndOffset();</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">            if (end &gt; getLength()) {</span>
<span class="nc" id="L1579">                removeElementsAtEnd(e, index, count, start, end);</span>
            }
            else {
<span class="nc" id="L1582">                removeElements(e, index, count, start, end);</span>
            }
        } finally {
<span class="nc" id="L1585">            writeUnlock();</span>
<span class="nc" id="L1586">        }</span>
<span class="nc" id="L1587">    }</span>

    /**
     * Called to remove child elements of &lt;code&gt;e&lt;/code&gt; when one of the
     * elements to remove is representing the end character.
     * &lt;p&gt;Since the Content will not allow a removal to the end character
     * this will do a remove from &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;.
     * The end Element(s) will be removed, and the element representing
     * &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;start&lt;/code&gt; will be recreated. This
     * Element has to be recreated as after the content removal its offsets
     * become &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;start - 1&lt;/code&gt;.
     */
    private void removeElementsAtEnd(Element e, int index, int count,
                         int start, int end) throws BadLocationException {
        // index must be &gt; 0 otherwise no insert would have happened.
<span class="nc" id="L1602">        boolean isLeaf = (e.getElement(index - 1).isLeaf());</span>
<span class="nc" id="L1603">        DefaultDocumentEvent dde = new DefaultDocumentEvent(</span>
                       start - 1, end - start + 1, DocumentEvent.
                       EventType.REMOVE);

<span class="nc bnc" id="L1607" title="All 2 branches missed.">        if (isLeaf) {</span>
<span class="nc" id="L1608">            Element endE = getCharacterElement(getLength());</span>
            // e.getElement(index - 1) should represent the newline.
<span class="nc" id="L1610">            index--;</span>
<span class="nc bnc" id="L1611" title="All 2 branches missed.">            if (endE.getParentElement() != e) {</span>
                // The hiearchies don't match, we'll have to manually
                // recreate the leaf at e.getElement(index - 1)
<span class="nc" id="L1614">                replace(dde, e, index, ++count, start, end, true, true);</span>
            }
            else {
                // The hierarchies for the end Element and
                // e.getElement(index - 1), match, we can safely remove
                // the Elements and the end content will be aligned
                // appropriately.
<span class="nc" id="L1621">                replace(dde, e, index, count, start, end, true, false);</span>
            }
<span class="nc" id="L1623">        }</span>
        else {
            // Not a leaf, descend until we find the leaf representing
            // start - 1 and remove it.
<span class="nc" id="L1627">            Element newLineE = e.getElement(index - 1);</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">            while (!newLineE.isLeaf()) {</span>
<span class="nc" id="L1629">                newLineE = newLineE.getElement(newLineE.getElementCount() - 1);</span>
            }
<span class="nc" id="L1631">            newLineE = newLineE.getParentElement();</span>
<span class="nc" id="L1632">            replace(dde, e, index, count, start, end, false, false);</span>
<span class="nc" id="L1633">            replace(dde, newLineE, newLineE.getElementCount() - 1, 1, start,</span>
                    end, true, true);
        }
<span class="nc" id="L1636">        postRemoveUpdate(dde);</span>
<span class="nc" id="L1637">        dde.end();</span>
<span class="nc" id="L1638">        fireRemoveUpdate(dde);</span>
<span class="nc" id="L1639">        fireUndoableEditUpdate(new UndoableEditEvent(this, dde));</span>
<span class="nc" id="L1640">    }</span>

    /**
     * This is used by &lt;code&gt;removeElementsAtEnd&lt;/code&gt;, it removes
     * &lt;code&gt;count&lt;/code&gt; elements starting at &lt;code&gt;start&lt;/code&gt; from
     * &lt;code&gt;e&lt;/code&gt;.  If &lt;code&gt;remove&lt;/code&gt; is true text of length
     * &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;end - 1&lt;/code&gt; is removed.  If
     * &lt;code&gt;create&lt;/code&gt; is true a new leaf is created of length 1.
     */
    private void replace(DefaultDocumentEvent dde, Element e, int index,
                         int count, int start, int end, boolean remove,
                         boolean create) throws BadLocationException {
        Element[] added;
<span class="nc" id="L1653">        AttributeSet attrs = e.getElement(index).getAttributes();</span>
<span class="nc" id="L1654">        Element[] removed = new Element[count];</span>

<span class="nc bnc" id="L1656" title="All 2 branches missed.">        for (int counter = 0; counter &lt; count; counter++) {</span>
<span class="nc" id="L1657">            removed[counter] = e.getElement(counter + index);</span>
        }
<span class="nc bnc" id="L1659" title="All 2 branches missed.">        if (remove) {</span>
<span class="nc" id="L1660">            UndoableEdit u = getContent().remove(start - 1, end - start);</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">            if (u != null) {</span>
<span class="nc" id="L1662">                dde.addEdit(u);</span>
            }
        }
<span class="nc bnc" id="L1665" title="All 2 branches missed.">        if (create) {</span>
<span class="nc" id="L1666">            added = new Element[1];</span>
<span class="nc" id="L1667">            added[0] = createLeafElement(e, attrs, start - 1, start);</span>
        }
        else {
<span class="nc" id="L1670">            added = new Element[0];</span>
        }
<span class="nc" id="L1672">        dde.addEdit(new ElementEdit(e, index, removed, added));</span>
<span class="nc" id="L1673">        ((AbstractDocument.BranchElement)e).replace(</span>
                                             index, removed.length, added);
<span class="nc" id="L1675">    }</span>

    /**
     * Called to remove child Elements when the end is not touched.
     */
    private void removeElements(Element e, int index, int count,
                             int start, int end) throws BadLocationException {
<span class="nc" id="L1682">        Element[] removed = new Element[count];</span>
<span class="nc" id="L1683">        Element[] added = new Element[0];</span>
<span class="nc bnc" id="L1684" title="All 2 branches missed.">        for (int counter = 0; counter &lt; count; counter++) {</span>
<span class="nc" id="L1685">            removed[counter] = e.getElement(counter + index);</span>
        }
<span class="nc" id="L1687">        DefaultDocumentEvent dde = new DefaultDocumentEvent</span>
                (start, end - start, DocumentEvent.EventType.REMOVE);
<span class="nc" id="L1689">        ((AbstractDocument.BranchElement)e).replace(index, removed.length,</span>
                                                    added);
<span class="nc" id="L1691">        dde.addEdit(new ElementEdit(e, index, removed, added));</span>
<span class="nc" id="L1692">        UndoableEdit u = getContent().remove(start, end - start);</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">        if (u != null) {</span>
<span class="nc" id="L1694">            dde.addEdit(u);</span>
        }
<span class="nc" id="L1696">        postRemoveUpdate(dde);</span>
<span class="nc" id="L1697">        dde.end();</span>
<span class="nc" id="L1698">        fireRemoveUpdate(dde);</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">        if (u != null) {</span>
<span class="nc" id="L1700">            fireUndoableEditUpdate(new UndoableEditEvent(this, dde));</span>
        }
<span class="nc" id="L1702">    }</span>


    // These two are provided for inner class access. The are named different
    // than the super class as the super class implementations are final.
    void obtainLock() {
<span class="nc" id="L1708">        writeLock();</span>
<span class="nc" id="L1709">    }</span>

    void releaseLock() {
<span class="nc" id="L1712">        writeUnlock();</span>
<span class="nc" id="L1713">    }</span>

    //
    // Provided for inner class access.
    //

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param e the event
     * @see EventListenerList
     */
    protected void fireChangedUpdate(DocumentEvent e) {
<span class="nc" id="L1729">        super.fireChangedUpdate(e);</span>
<span class="nc" id="L1730">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param e the event
     * @see EventListenerList
     */
    protected void fireUndoableEditUpdate(UndoableEditEvent e) {
<span class="nc" id="L1742">        super.fireUndoableEditUpdate(e);</span>
<span class="nc" id="L1743">    }</span>

    boolean hasBaseTag() {
<span class="nc" id="L1746">        return hasBaseTag;</span>
    }

    String getBaseTarget() {
<span class="nc" id="L1750">        return baseTarget;</span>
    }

    /*
     * state defines whether the document is a frame document
     * or not.
     */
<span class="nc" id="L1757">    private boolean frameDocument = false;</span>
<span class="nc" id="L1758">    private boolean preservesUnknownTags = true;</span>

    /*
     * Used to store button groups for radio buttons in
     * a form.
     */
    private HashMap&lt;String, ButtonGroup&gt; radioButtonGroupsMap;

    /**
     * Document property for the number of tokens to buffer
     * before building an element subtree to represent them.
     */
    static final String TokenThreshold = &quot;token threshold&quot;;

    private static final int MaxThreshold = 10000;

    private static final int StepThreshold = 5;


    /**
     * Document property key value. The value for the key will be a Vector
     * of Strings that are comments not found in the body.
     */
    public static final String AdditionalComments = &quot;AdditionalComments&quot;;

    /**
     * Document property key value. The value for the key will be a
     * String indicating the default type of stylesheet links.
     */
    /* public */ static final String StyleType = &quot;StyleType&quot;;

    /**
     * The location to resolve relative URLs against.  By
     * default this will be the document's URL if the document
     * was loaded from a URL.  If a base tag is found and
     * can be parsed, it will be used as the base location.
     */
    URL base;

    /**
     * does the document have base tag
     */
<span class="nc" id="L1800">    boolean hasBaseTag = false;</span>

    /**
     * BASE tag's TARGET attribute value
     */
<span class="nc" id="L1805">    private String baseTarget = null;</span>

    /**
     * The parser that is used when inserting html into the existing
     * document.
     */
    private HTMLEditorKit.Parser parser;

    /**
     * Used for inserts when a null AttributeSet is supplied.
     */
    private static AttributeSet contentAttributeSet;

    /**
     * Property Maps are registered under, will be a Hashtable.
     */
<span class="nc" id="L1821">    static String MAP_PROPERTY = &quot;__MAP__&quot;;</span>

    private static char[] NEWLINE;

    /**
     * I18N property key.
     *
     * @see AbstractDocument#I18NProperty
     */
    private static final String I18NProperty = &quot;i18n&quot;;

    static {
<span class="nc" id="L1833">        contentAttributeSet = new SimpleAttributeSet();</span>
<span class="nc" id="L1834">        ((MutableAttributeSet)contentAttributeSet).</span>
<span class="nc" id="L1835">                        addAttribute(StyleConstants.NameAttribute,</span>
                                     HTML.Tag.CONTENT);
<span class="nc" id="L1837">        NEWLINE = new char[1];</span>
<span class="nc" id="L1838">        NEWLINE[0] = '\n';</span>
<span class="nc" id="L1839">    }</span>


    /**
     * An iterator to iterate over a particular type of
     * tag.  The iterator is not thread safe.  If reliable
     * access to the document is not already ensured by
     * the context under which the iterator is being used,
     * its use should be performed under the protection of
     * Document.render.
     */
<span class="nc" id="L1850">    public static abstract class Iterator {</span>

        /**
         * Return the attributes for this tag.
         * @return the &lt;code&gt;AttributeSet&lt;/code&gt; for this tag, or
         *      &lt;code&gt;null&lt;/code&gt; if none can be found
         */
        public abstract AttributeSet getAttributes();

        /**
         * Returns the start of the range for which the current occurrence of
         * the tag is defined and has the same attributes.
         *
         * @return the start of the range, or -1 if it can't be found
         */
        public abstract int getStartOffset();

        /**
         * Returns the end of the range for which the current occurrence of
         * the tag is defined and has the same attributes.
         *
         * @return the end of the range
         */
        public abstract int getEndOffset();

        /**
         * Move the iterator forward to the next occurrence
         * of the tag it represents.
         */
        public abstract void next();

        /**
         * Indicates if the iterator is currently
         * representing an occurrence of a tag.  If
         * false there are no more tags for this iterator.
         * @return true if the iterator is currently representing an
         *              occurrence of a tag, otherwise returns false
         */
        public abstract boolean isValid();

        /**
         * Type of tag this iterator represents.
         */
        public abstract HTML.Tag getTag();
    }

    /**
     * An iterator to iterate over a particular type of tag.
     */
    static class LeafIterator extends Iterator {

<span class="nc" id="L1901">        LeafIterator(HTML.Tag t, Document doc) {</span>
<span class="nc" id="L1902">            tag = t;</span>
<span class="nc" id="L1903">            pos = new ElementIterator(doc);</span>
<span class="nc" id="L1904">            endOffset = 0;</span>
<span class="nc" id="L1905">            next();</span>
<span class="nc" id="L1906">        }</span>

        /**
         * Returns the attributes for this tag.
         * @return the &lt;code&gt;AttributeSet&lt;/code&gt; for this tag,
         *              or &lt;code&gt;null&lt;/code&gt; if none can be found
         */
        public AttributeSet getAttributes() {
<span class="nc" id="L1914">            Element elem = pos.current();</span>
<span class="nc bnc" id="L1915" title="All 2 branches missed.">            if (elem != null) {</span>
<span class="nc" id="L1916">                AttributeSet a = (AttributeSet)</span>
<span class="nc" id="L1917">                    elem.getAttributes().getAttribute(tag);</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">                if (a == null) {</span>
<span class="nc" id="L1919">                    a = elem.getAttributes();</span>
                }
<span class="nc" id="L1921">                return a;</span>
            }
<span class="nc" id="L1923">            return null;</span>
        }

        /**
         * Returns the start of the range for which the current occurrence of
         * the tag is defined and has the same attributes.
         *
         * @return the start of the range, or -1 if it can't be found
         */
        public int getStartOffset() {
<span class="nc" id="L1933">            Element elem = pos.current();</span>
<span class="nc bnc" id="L1934" title="All 2 branches missed.">            if (elem != null) {</span>
<span class="nc" id="L1935">                return elem.getStartOffset();</span>
            }
<span class="nc" id="L1937">            return -1;</span>
        }

        /**
         * Returns the end of the range for which the current occurrence of
         * the tag is defined and has the same attributes.
         *
         * @return the end of the range
         */
        public int getEndOffset() {
<span class="nc" id="L1947">            return endOffset;</span>
        }

        /**
         * Moves the iterator forward to the next occurrence
         * of the tag it represents.
         */
        public void next() {
<span class="nc bnc" id="L1955" title="All 2 branches missed.">            for (nextLeaf(pos); isValid(); nextLeaf(pos)) {</span>
<span class="nc" id="L1956">                Element elem = pos.current();</span>
<span class="nc bnc" id="L1957" title="All 2 branches missed.">                if (elem.getStartOffset() &gt;= endOffset) {</span>
<span class="nc" id="L1958">                    AttributeSet a = pos.current().getAttributes();</span>

<span class="nc bnc" id="L1960" title="All 2 branches missed.">                    if (a.isDefined(tag) ||</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">                        a.getAttribute(StyleConstants.NameAttribute) == tag) {</span>

                        // we found the next one
<span class="nc" id="L1964">                        setEndOffset();</span>
<span class="nc" id="L1965">                        break;</span>
                    }
                }
            }
<span class="nc" id="L1969">        }</span>

        /**
         * Returns the type of tag this iterator represents.
         *
         * @return the &lt;code&gt;HTML.Tag&lt;/code&gt; that this iterator represents.
         * @see javax.swing.text.html.HTML.Tag
         */
        public HTML.Tag getTag() {
<span class="nc" id="L1978">            return tag;</span>
        }

        /**
         * Returns true if the current position is not &lt;code&gt;null&lt;/code&gt;.
         * @return true if current position is not &lt;code&gt;null&lt;/code&gt;,
         *              otherwise returns false
         */
        public boolean isValid() {
<span class="nc bnc" id="L1987" title="All 2 branches missed.">            return (pos.current() != null);</span>
        }

        /**
         * Moves the given iterator to the next leaf element.
         * @param iter  the iterator to be scanned
         */
        void nextLeaf(ElementIterator iter) {
<span class="nc bnc" id="L1995" title="All 2 branches missed.">            for (iter.next(); iter.current() != null; iter.next()) {</span>
<span class="nc" id="L1996">                Element e = iter.current();</span>
<span class="nc bnc" id="L1997" title="All 2 branches missed.">                if (e.isLeaf()) {</span>
<span class="nc" id="L1998">                    break;</span>
                }
            }
<span class="nc" id="L2001">        }</span>

        /**
         * Marches a cloned iterator forward to locate the end
         * of the run.  This sets the value of &lt;code&gt;endOffset&lt;/code&gt;.
         */
        void setEndOffset() {
<span class="nc" id="L2008">            AttributeSet a0 = getAttributes();</span>
<span class="nc" id="L2009">            endOffset = pos.current().getEndOffset();</span>
<span class="nc" id="L2010">            ElementIterator fwd = (ElementIterator) pos.clone();</span>
<span class="nc bnc" id="L2011" title="All 2 branches missed.">            for (nextLeaf(fwd); fwd.current() != null; nextLeaf(fwd)) {</span>
<span class="nc" id="L2012">                Element e = fwd.current();</span>
<span class="nc" id="L2013">                AttributeSet a1 = (AttributeSet) e.getAttributes().getAttribute(tag);</span>
<span class="nc bnc" id="L2014" title="All 4 branches missed.">                if ((a1 == null) || (! a1.equals(a0))) {</span>
<span class="nc" id="L2015">                    break;</span>
                }
<span class="nc" id="L2017">                endOffset = e.getEndOffset();</span>
            }
<span class="nc" id="L2019">        }</span>

        private int endOffset;
        private HTML.Tag tag;
        private ElementIterator pos;

    }

    /**
     * An HTML reader to load an HTML document with an HTML
     * element structure.  This is a set of callbacks from
     * the parser, implemented to create a set of elements
     * tagged with attributes.  The parse builds up tokens
     * (ElementSpec) that describe the element subtree desired,
     * and burst it into the document under the protection of
     * a write lock using the insert method on the document
     * outer class.
     * &lt;p&gt;
     * The reader can be configured by registering actions
     * (of type &lt;code&gt;HTMLDocument.HTMLReader.TagAction&lt;/code&gt;)
     * that describe how to handle the action.  The idea behind
     * the actions provided is that the most natural text editing
     * operations can be provided if the element structure boils
     * down to paragraphs with runs of some kind of style
     * in them.  Some things are more naturally specified
     * structurally, so arbitrary structure should be allowed
     * above the paragraphs, but will need to be edited with structural
     * actions.  The implication of this is that some of the
     * HTML elements specified in the stream being parsed will
     * be collapsed into attributes, and in some cases paragraphs
     * will be synthesized.  When HTML elements have been
     * converted to attributes, the attribute key will be of
     * type HTML.Tag, and the value will be of type AttributeSet
     * so that no information is lost.  This enables many of the
     * existing actions to work so that the user can type input,
     * hit the return key, backspace, delete, etc and have a
     * reasonable result.  Selections can be created, and attributes
     * applied or removed, etc.  With this in mind, the work done
     * by the reader can be categorized into the following kinds
     * of tasks:
     * &lt;dl&gt;
     * &lt;dt&gt;Block
     * &lt;dd&gt;Build the structure like it's specified in the stream.
     * This produces elements that contain other elements.
     * &lt;dt&gt;Paragraph
     * &lt;dd&gt;Like block except that it's expected that the element
     * will be used with a paragraph view so a paragraph element
     * won't need to be synthesized.
     * &lt;dt&gt;Character
     * &lt;dd&gt;Contribute the element as an attribute that will start
     * and stop at arbitrary text locations.  This will ultimately
     * be mixed into a run of text, with all of the currently
     * flattened HTML character elements.
     * &lt;dt&gt;Special
     * &lt;dd&gt;Produce an embedded graphical element.
     * &lt;dt&gt;Form
     * &lt;dd&gt;Produce an element that is like the embedded graphical
     * element, except that it also has a component model associated
     * with it.
     * &lt;dt&gt;Hidden
     * &lt;dd&gt;Create an element that is hidden from view when the
     * document is being viewed read-only, and visible when the
     * document is being edited.  This is useful to keep the
     * model from losing information, and used to store things
     * like comments and unrecognized tags.
     *
     * &lt;/dl&gt;
     * &lt;p&gt;
     * Currently, &amp;lt;APPLET&amp;gt;, &amp;lt;PARAM&amp;gt;, &amp;lt;MAP&amp;gt;, &amp;lt;AREA&amp;gt;, &amp;lt;LINK&amp;gt;,
     * &amp;lt;SCRIPT&amp;gt; and &amp;lt;STYLE&amp;gt; are unsupported.
     *
     * &lt;p&gt;
     * The assignment of the actions described is shown in the
     * following table for the tags defined in &lt;code&gt;HTML.Tag&lt;/code&gt;.&lt;P&gt;
     * &lt;table border=1 summary=&quot;HTML tags and assigned actions&quot;&gt;
     * &lt;tr&gt;&lt;th&gt;Tag&lt;/th&gt;&lt;th&gt;Action&lt;/th&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.A&lt;/code&gt;         &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.ADDRESS&lt;/code&gt;   &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.APPLET&lt;/code&gt;    &lt;td&gt;HiddenAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.AREA&lt;/code&gt;      &lt;td&gt;AreaAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.B&lt;/code&gt;         &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BASE&lt;/code&gt;      &lt;td&gt;BaseAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BASEFONT&lt;/code&gt;  &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BIG&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BLOCKQUOTE&lt;/code&gt;&lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BODY&lt;/code&gt;      &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.BR&lt;/code&gt;        &lt;td&gt;SpecialAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.CAPTION&lt;/code&gt;   &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.CENTER&lt;/code&gt;    &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.CITE&lt;/code&gt;      &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.CODE&lt;/code&gt;      &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DD&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DFN&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DIR&lt;/code&gt;       &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DIV&lt;/code&gt;       &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DL&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.DT&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.EM&lt;/code&gt;        &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.FONT&lt;/code&gt;      &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.FORM&lt;/code&gt;      &lt;td&gt;As of 1.4 a BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.FRAME&lt;/code&gt;     &lt;td&gt;SpecialAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.FRAMESET&lt;/code&gt;  &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H1&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H2&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H3&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H4&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H5&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.H6&lt;/code&gt;        &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.HEAD&lt;/code&gt;      &lt;td&gt;HeadAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.HR&lt;/code&gt;        &lt;td&gt;SpecialAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.HTML&lt;/code&gt;      &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.I&lt;/code&gt;         &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.IMG&lt;/code&gt;       &lt;td&gt;SpecialAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.INPUT&lt;/code&gt;     &lt;td&gt;FormAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.ISINDEX&lt;/code&gt;   &lt;td&gt;IsndexAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.KBD&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.LI&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.LINK&lt;/code&gt;      &lt;td&gt;LinkAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.MAP&lt;/code&gt;       &lt;td&gt;MapAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.MENU&lt;/code&gt;      &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.META&lt;/code&gt;      &lt;td&gt;MetaAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.NOFRAMES&lt;/code&gt;  &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.OBJECT&lt;/code&gt;    &lt;td&gt;SpecialAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.OL&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.OPTION&lt;/code&gt;    &lt;td&gt;FormAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.P&lt;/code&gt;         &lt;td&gt;ParagraphAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.PARAM&lt;/code&gt;     &lt;td&gt;HiddenAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.PRE&lt;/code&gt;       &lt;td&gt;PreAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SAMP&lt;/code&gt;      &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SCRIPT&lt;/code&gt;    &lt;td&gt;HiddenAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SELECT&lt;/code&gt;    &lt;td&gt;FormAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SMALL&lt;/code&gt;     &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.STRIKE&lt;/code&gt;    &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.S&lt;/code&gt;         &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.STRONG&lt;/code&gt;    &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.STYLE&lt;/code&gt;     &lt;td&gt;StyleAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SUB&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.SUP&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TABLE&lt;/code&gt;     &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TD&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TEXTAREA&lt;/code&gt;  &lt;td&gt;FormAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TH&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TITLE&lt;/code&gt;     &lt;td&gt;TitleAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TR&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.TT&lt;/code&gt;        &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.U&lt;/code&gt;         &lt;td&gt;CharacterAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.UL&lt;/code&gt;        &lt;td&gt;BlockAction
     * &lt;tr&gt;&lt;td&gt;&lt;code&gt;HTML.Tag.VAR&lt;/code&gt;       &lt;td&gt;CharacterAction
     * &lt;/table&gt;
     * &lt;p&gt;
     * Once &amp;lt;/html&amp;gt; is encountered, the Actions are no longer notified.
     */
    public class HTMLReader extends HTMLEditorKit.ParserCallback {

        public HTMLReader(int offset) {
<span class="nc" id="L2174">            this(offset, 0, 0, null);</span>
<span class="nc" id="L2175">        }</span>

        public HTMLReader(int offset, int popDepth, int pushDepth,
                          HTML.Tag insertTag) {
<span class="nc" id="L2179">            this(offset, popDepth, pushDepth, insertTag, true, false, true);</span>
<span class="nc" id="L2180">        }</span>

        /**
         * Generates a RuntimeException (will eventually generate
         * a BadLocationException when API changes are alloced) if inserting
         * into non empty document, &lt;code&gt;insertTag&lt;/code&gt; is
         * non-&lt;code&gt;null&lt;/code&gt;, and &lt;code&gt;offset&lt;/code&gt; is not in the body.
         */
        // PENDING(sky): Add throws BadLocationException and remove
        // RuntimeException
        HTMLReader(int offset, int popDepth, int pushDepth,
                   HTML.Tag insertTag, boolean insertInsertTag,
<span class="nc" id="L2192">                   boolean insertAfterImplied, boolean wantsTrailingNewline) {</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">            emptyDocument = (getLength() == 0);</span>
<span class="nc" id="L2194">            isStyleCSS = &quot;text/css&quot;.equals(getDefaultStyleSheetType());</span>
<span class="nc" id="L2195">            this.offset = offset;</span>
<span class="nc" id="L2196">            threshold = HTMLDocument.this.getTokenThreshold();</span>
<span class="nc" id="L2197">            tagMap = new Hashtable&lt;HTML.Tag, TagAction&gt;(57);</span>
<span class="nc" id="L2198">            TagAction na = new TagAction();</span>
<span class="nc" id="L2199">            TagAction ba = new BlockAction();</span>
<span class="nc" id="L2200">            TagAction pa = new ParagraphAction();</span>
<span class="nc" id="L2201">            TagAction ca = new CharacterAction();</span>
<span class="nc" id="L2202">            TagAction sa = new SpecialAction();</span>
<span class="nc" id="L2203">            TagAction fa = new FormAction();</span>
<span class="nc" id="L2204">            TagAction ha = new HiddenAction();</span>
<span class="nc" id="L2205">            TagAction conv = new ConvertAction();</span>

            // register handlers for the well known tags
<span class="nc" id="L2208">            tagMap.put(HTML.Tag.A, new AnchorAction());</span>
<span class="nc" id="L2209">            tagMap.put(HTML.Tag.ADDRESS, ca);</span>
<span class="nc" id="L2210">            tagMap.put(HTML.Tag.APPLET, ha);</span>
<span class="nc" id="L2211">            tagMap.put(HTML.Tag.AREA, new AreaAction());</span>
<span class="nc" id="L2212">            tagMap.put(HTML.Tag.B, conv);</span>
<span class="nc" id="L2213">            tagMap.put(HTML.Tag.BASE, new BaseAction());</span>
<span class="nc" id="L2214">            tagMap.put(HTML.Tag.BASEFONT, ca);</span>
<span class="nc" id="L2215">            tagMap.put(HTML.Tag.BIG, ca);</span>
<span class="nc" id="L2216">            tagMap.put(HTML.Tag.BLOCKQUOTE, ba);</span>
<span class="nc" id="L2217">            tagMap.put(HTML.Tag.BODY, ba);</span>
<span class="nc" id="L2218">            tagMap.put(HTML.Tag.BR, sa);</span>
<span class="nc" id="L2219">            tagMap.put(HTML.Tag.CAPTION, ba);</span>
<span class="nc" id="L2220">            tagMap.put(HTML.Tag.CENTER, ba);</span>
<span class="nc" id="L2221">            tagMap.put(HTML.Tag.CITE, ca);</span>
<span class="nc" id="L2222">            tagMap.put(HTML.Tag.CODE, ca);</span>
<span class="nc" id="L2223">            tagMap.put(HTML.Tag.DD, ba);</span>
<span class="nc" id="L2224">            tagMap.put(HTML.Tag.DFN, ca);</span>
<span class="nc" id="L2225">            tagMap.put(HTML.Tag.DIR, ba);</span>
<span class="nc" id="L2226">            tagMap.put(HTML.Tag.DIV, ba);</span>
<span class="nc" id="L2227">            tagMap.put(HTML.Tag.DL, ba);</span>
<span class="nc" id="L2228">            tagMap.put(HTML.Tag.DT, pa);</span>
<span class="nc" id="L2229">            tagMap.put(HTML.Tag.EM, ca);</span>
<span class="nc" id="L2230">            tagMap.put(HTML.Tag.FONT, conv);</span>
<span class="nc" id="L2231">            tagMap.put(HTML.Tag.FORM, new FormTagAction());</span>
<span class="nc" id="L2232">            tagMap.put(HTML.Tag.FRAME, sa);</span>
<span class="nc" id="L2233">            tagMap.put(HTML.Tag.FRAMESET, ba);</span>
<span class="nc" id="L2234">            tagMap.put(HTML.Tag.H1, pa);</span>
<span class="nc" id="L2235">            tagMap.put(HTML.Tag.H2, pa);</span>
<span class="nc" id="L2236">            tagMap.put(HTML.Tag.H3, pa);</span>
<span class="nc" id="L2237">            tagMap.put(HTML.Tag.H4, pa);</span>
<span class="nc" id="L2238">            tagMap.put(HTML.Tag.H5, pa);</span>
<span class="nc" id="L2239">            tagMap.put(HTML.Tag.H6, pa);</span>
<span class="nc" id="L2240">            tagMap.put(HTML.Tag.HEAD, new HeadAction());</span>
<span class="nc" id="L2241">            tagMap.put(HTML.Tag.HR, sa);</span>
<span class="nc" id="L2242">            tagMap.put(HTML.Tag.HTML, ba);</span>
<span class="nc" id="L2243">            tagMap.put(HTML.Tag.I, conv);</span>
<span class="nc" id="L2244">            tagMap.put(HTML.Tag.IMG, sa);</span>
<span class="nc" id="L2245">            tagMap.put(HTML.Tag.INPUT, fa);</span>
<span class="nc" id="L2246">            tagMap.put(HTML.Tag.ISINDEX, new IsindexAction());</span>
<span class="nc" id="L2247">            tagMap.put(HTML.Tag.KBD, ca);</span>
<span class="nc" id="L2248">            tagMap.put(HTML.Tag.LI, ba);</span>
<span class="nc" id="L2249">            tagMap.put(HTML.Tag.LINK, new LinkAction());</span>
<span class="nc" id="L2250">            tagMap.put(HTML.Tag.MAP, new MapAction());</span>
<span class="nc" id="L2251">            tagMap.put(HTML.Tag.MENU, ba);</span>
<span class="nc" id="L2252">            tagMap.put(HTML.Tag.META, new MetaAction());</span>
<span class="nc" id="L2253">            tagMap.put(HTML.Tag.NOBR, ca);</span>
<span class="nc" id="L2254">            tagMap.put(HTML.Tag.NOFRAMES, ba);</span>
<span class="nc" id="L2255">            tagMap.put(HTML.Tag.OBJECT, sa);</span>
<span class="nc" id="L2256">            tagMap.put(HTML.Tag.OL, ba);</span>
<span class="nc" id="L2257">            tagMap.put(HTML.Tag.OPTION, fa);</span>
<span class="nc" id="L2258">            tagMap.put(HTML.Tag.P, pa);</span>
<span class="nc" id="L2259">            tagMap.put(HTML.Tag.PARAM, new ObjectAction());</span>
<span class="nc" id="L2260">            tagMap.put(HTML.Tag.PRE, new PreAction());</span>
<span class="nc" id="L2261">            tagMap.put(HTML.Tag.SAMP, ca);</span>
<span class="nc" id="L2262">            tagMap.put(HTML.Tag.SCRIPT, ha);</span>
<span class="nc" id="L2263">            tagMap.put(HTML.Tag.SELECT, fa);</span>
<span class="nc" id="L2264">            tagMap.put(HTML.Tag.SMALL, ca);</span>
<span class="nc" id="L2265">            tagMap.put(HTML.Tag.SPAN, ca);</span>
<span class="nc" id="L2266">            tagMap.put(HTML.Tag.STRIKE, conv);</span>
<span class="nc" id="L2267">            tagMap.put(HTML.Tag.S, ca);</span>
<span class="nc" id="L2268">            tagMap.put(HTML.Tag.STRONG, ca);</span>
<span class="nc" id="L2269">            tagMap.put(HTML.Tag.STYLE, new StyleAction());</span>
<span class="nc" id="L2270">            tagMap.put(HTML.Tag.SUB, conv);</span>
<span class="nc" id="L2271">            tagMap.put(HTML.Tag.SUP, conv);</span>
<span class="nc" id="L2272">            tagMap.put(HTML.Tag.TABLE, ba);</span>
<span class="nc" id="L2273">            tagMap.put(HTML.Tag.TD, ba);</span>
<span class="nc" id="L2274">            tagMap.put(HTML.Tag.TEXTAREA, fa);</span>
<span class="nc" id="L2275">            tagMap.put(HTML.Tag.TH, ba);</span>
<span class="nc" id="L2276">            tagMap.put(HTML.Tag.TITLE, new TitleAction());</span>
<span class="nc" id="L2277">            tagMap.put(HTML.Tag.TR, ba);</span>
<span class="nc" id="L2278">            tagMap.put(HTML.Tag.TT, ca);</span>
<span class="nc" id="L2279">            tagMap.put(HTML.Tag.U, conv);</span>
<span class="nc" id="L2280">            tagMap.put(HTML.Tag.UL, ba);</span>
<span class="nc" id="L2281">            tagMap.put(HTML.Tag.VAR, ca);</span>

<span class="nc bnc" id="L2283" title="All 2 branches missed.">            if (insertTag != null) {</span>
<span class="nc" id="L2284">                this.insertTag = insertTag;</span>
<span class="nc" id="L2285">                this.popDepth = popDepth;</span>
<span class="nc" id="L2286">                this.pushDepth = pushDepth;</span>
<span class="nc" id="L2287">                this.insertInsertTag = insertInsertTag;</span>
<span class="nc" id="L2288">                foundInsertTag = false;</span>
            }
            else {
<span class="nc" id="L2291">                foundInsertTag = true;</span>
            }
<span class="nc bnc" id="L2293" title="All 2 branches missed.">            if (insertAfterImplied) {</span>
<span class="nc" id="L2294">                this.popDepth = popDepth;</span>
<span class="nc" id="L2295">                this.pushDepth = pushDepth;</span>
<span class="nc" id="L2296">                this.insertAfterImplied = true;</span>
<span class="nc" id="L2297">                foundInsertTag = false;</span>
<span class="nc" id="L2298">                midInsert = false;</span>
<span class="nc" id="L2299">                this.insertInsertTag = true;</span>
<span class="nc" id="L2300">                this.wantsTrailingNewline = wantsTrailingNewline;</span>
            }
            else {
<span class="nc bnc" id="L2303" title="All 4 branches missed.">                midInsert = (!emptyDocument &amp;&amp; insertTag == null);</span>
<span class="nc bnc" id="L2304" title="All 2 branches missed.">                if (midInsert) {</span>
<span class="nc" id="L2305">                    generateEndsSpecsForMidInsert();</span>
                }
            }

            /**
             * This block initializes the &lt;code&gt;inParagraph&lt;/code&gt; flag.
             * It is left in &lt;code&gt;false&lt;/code&gt; value automatically
             * if the target document is empty or future inserts
             * were positioned into the 'body' tag.
             */
<span class="nc bnc" id="L2315" title="All 4 branches missed.">            if (!emptyDocument &amp;&amp; !midInsert) {</span>
<span class="nc" id="L2316">                int targetOffset = Math.max(this.offset - 1, 0);</span>
<span class="nc" id="L2317">                Element elem =</span>
<span class="nc" id="L2318">                        HTMLDocument.this.getCharacterElement(targetOffset);</span>
                /* Going up by the left document structure path */
<span class="nc bnc" id="L2320" title="All 2 branches missed.">                for (int i = 0; i &lt;= this.popDepth; i++) {</span>
<span class="nc" id="L2321">                    elem = elem.getParentElement();</span>
                }
                /* Going down by the right document structure path */
<span class="nc bnc" id="L2324" title="All 2 branches missed.">                for (int i = 0; i &lt; this.pushDepth; i++) {</span>
<span class="nc" id="L2325">                    int index = elem.getElementIndex(this.offset);</span>
<span class="nc" id="L2326">                    elem = elem.getElement(index);</span>
                }
<span class="nc" id="L2328">                AttributeSet attrs = elem.getAttributes();</span>
<span class="nc bnc" id="L2329" title="All 2 branches missed.">                if (attrs != null) {</span>
<span class="nc" id="L2330">                    HTML.Tag tagToInsertInto =</span>
<span class="nc" id="L2331">                            (HTML.Tag) attrs.getAttribute(StyleConstants.NameAttribute);</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">                    if (tagToInsertInto != null) {</span>
<span class="nc" id="L2333">                        this.inParagraph = tagToInsertInto.isParagraph();</span>
                    }
                }
            }
<span class="nc" id="L2337">        }</span>

        /**
         * Generates an initial batch of end &lt;code&gt;ElementSpecs&lt;/code&gt;
         * in parseBuffer to position future inserts into the body.
         */
        private void generateEndsSpecsForMidInsert() {
<span class="nc" id="L2344">            int           count = heightToElementWithName(HTML.Tag.BODY,</span>
<span class="nc" id="L2345">                                                   Math.max(0, offset - 1));</span>
<span class="nc" id="L2346">            boolean       joinNext = false;</span>

<span class="nc bnc" id="L2348" title="All 4 branches missed.">            if (count == -1 &amp;&amp; offset &gt; 0) {</span>
<span class="nc" id="L2349">                count = heightToElementWithName(HTML.Tag.BODY, offset);</span>
<span class="nc bnc" id="L2350" title="All 2 branches missed.">                if (count != -1) {</span>
                    // Previous isn't in body, but current is. Have to
                    // do some end specs, followed by join next.
<span class="nc" id="L2353">                    count = depthTo(offset - 1) - 1;</span>
<span class="nc" id="L2354">                    joinNext = true;</span>
                }
            }
<span class="nc bnc" id="L2357" title="All 2 branches missed.">            if (count == -1) {</span>
<span class="nc" id="L2358">                throw new RuntimeException(&quot;Must insert new content into body element-&quot;);</span>
            }
<span class="nc bnc" id="L2360" title="All 2 branches missed.">            if (count != -1) {</span>
                // Insert a newline, if necessary.
                try {
<span class="nc bnc" id="L2363" title="All 4 branches missed.">                    if (!joinNext &amp;&amp; offset &gt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L2364" title="All 2 branches missed.">                        !getText(offset - 1, 1).equals(&quot;\n&quot;)) {</span>
<span class="nc" id="L2365">                        SimpleAttributeSet newAttrs = new SimpleAttributeSet();</span>
<span class="nc" id="L2366">                        newAttrs.addAttribute(StyleConstants.NameAttribute,</span>
                                              HTML.Tag.CONTENT);
<span class="nc" id="L2368">                        ElementSpec spec = new ElementSpec(newAttrs,</span>
<span class="nc" id="L2369">                                    ElementSpec.ContentType, NEWLINE, 0, 1);</span>
<span class="nc" id="L2370">                        parseBuffer.addElement(spec);</span>
                    }
                    // Should never throw, but will catch anyway.
<span class="nc" id="L2373">                } catch (BadLocationException ble) {}</span>
<span class="nc bnc" id="L2374" title="All 2 branches missed.">                while (count-- &gt; 0) {</span>
<span class="nc" id="L2375">                    parseBuffer.addElement(new ElementSpec</span>
                                           (null, ElementSpec.EndTagType));
                }
<span class="nc bnc" id="L2378" title="All 2 branches missed.">                if (joinNext) {</span>
<span class="nc" id="L2379">                    ElementSpec spec = new ElementSpec(null, ElementSpec.</span>
                                                       StartTagType);

<span class="nc" id="L2382">                    spec.setDirection(ElementSpec.JoinNextDirection);</span>
<span class="nc" id="L2383">                    parseBuffer.addElement(spec);</span>
                }
            }
            // We should probably throw an exception if (count == -1)
            // Or look for the body and reset the offset.
<span class="nc" id="L2388">        }</span>

        /**
         * @return number of parents to reach the child at offset.
         */
        private int depthTo(int offset) {
<span class="nc" id="L2394">            Element       e = getDefaultRootElement();</span>
<span class="nc" id="L2395">            int           count = 0;</span>

<span class="nc bnc" id="L2397" title="All 2 branches missed.">            while (!e.isLeaf()) {</span>
<span class="nc" id="L2398">                count++;</span>
<span class="nc" id="L2399">                e = e.getElement(e.getElementIndex(offset));</span>
            }
<span class="nc" id="L2401">            return count;</span>
        }

        /**
         * @return number of parents of the leaf at &lt;code&gt;offset&lt;/code&gt;
         *         until a parent with name, &lt;code&gt;name&lt;/code&gt; has been
         *         found. -1 indicates no matching parent with
         *         &lt;code&gt;name&lt;/code&gt;.
         */
        private int heightToElementWithName(Object name, int offset) {
<span class="nc" id="L2411">            Element       e = getCharacterElement(offset).getParentElement();</span>
<span class="nc" id="L2412">            int           count = 0;</span>

<span class="nc bnc" id="L2414" title="All 2 branches missed.">            while (e != null &amp;&amp; e.getAttributes().getAttribute</span>
<span class="nc bnc" id="L2415" title="All 2 branches missed.">                   (StyleConstants.NameAttribute) != name) {</span>
<span class="nc" id="L2416">                count++;</span>
<span class="nc" id="L2417">                e = e.getParentElement();</span>
            }
<span class="nc bnc" id="L2419" title="All 2 branches missed.">            return (e == null) ? -1 : count;</span>
        }

        /**
         * This will make sure there aren't two BODYs (the second is
         * typically created when you do a remove all, and then an insert).
         */
        private void adjustEndElement() {
<span class="nc" id="L2427">            int length = getLength();</span>
<span class="nc bnc" id="L2428" title="All 2 branches missed.">            if (length == 0) {</span>
<span class="nc" id="L2429">                return;</span>
            }
<span class="nc" id="L2431">            obtainLock();</span>
            try {
<span class="nc" id="L2433">                Element[] pPath = getPathTo(length - 1);</span>
<span class="nc" id="L2434">                int pLength = pPath.length;</span>
<span class="nc bnc" id="L2435" title="All 2 branches missed.">                if (pLength &gt; 1 &amp;&amp; pPath[1].getAttributes().getAttribute</span>
<span class="nc bnc" id="L2436" title="All 2 branches missed.">                         (StyleConstants.NameAttribute) == HTML.Tag.BODY &amp;&amp;</span>
<span class="nc bnc" id="L2437" title="All 2 branches missed.">                         pPath[1].getEndOffset() == length) {</span>
<span class="nc" id="L2438">                    String lastText = getText(length - 1, 1);</span>
                    DefaultDocumentEvent event;
                    Element[] added;
                    Element[] removed;
                    int index;
                    // Remove the fake second body.
<span class="nc" id="L2444">                    added = new Element[0];</span>
<span class="nc" id="L2445">                    removed = new Element[1];</span>
<span class="nc" id="L2446">                    index = pPath[0].getElementIndex(length);</span>
<span class="nc" id="L2447">                    removed[0] = pPath[0].getElement(index);</span>
<span class="nc" id="L2448">                    ((BranchElement)pPath[0]).replace(index, 1, added);</span>
<span class="nc" id="L2449">                    ElementEdit firstEdit = new ElementEdit(pPath[0], index,</span>
                                                            removed, added);

                    // Insert a new element to represent the end that the
                    // second body was representing.
<span class="nc" id="L2454">                    SimpleAttributeSet sas = new SimpleAttributeSet();</span>
<span class="nc" id="L2455">                    sas.addAttribute(StyleConstants.NameAttribute,</span>
                                         HTML.Tag.CONTENT);
<span class="nc" id="L2457">                    sas.addAttribute(IMPLIED_CR, Boolean.TRUE);</span>
<span class="nc" id="L2458">                    added = new Element[1];</span>
<span class="nc" id="L2459">                    added[0] = createLeafElement(pPath[pLength - 1],</span>
                                                     sas, length, length + 1);
<span class="nc" id="L2461">                    index = pPath[pLength - 1].getElementCount();</span>
<span class="nc" id="L2462">                    ((BranchElement)pPath[pLength - 1]).replace(index, 0,</span>
                                                                added);
<span class="nc" id="L2464">                    event = new DefaultDocumentEvent(length, 1,</span>
                                            DocumentEvent.EventType.CHANGE);
<span class="nc" id="L2466">                    event.addEdit(new ElementEdit(pPath[pLength - 1],</span>
                                         index, new Element[0], added));
<span class="nc" id="L2468">                    event.addEdit(firstEdit);</span>
<span class="nc" id="L2469">                    event.end();</span>
<span class="nc" id="L2470">                    fireChangedUpdate(event);</span>
<span class="nc" id="L2471">                    fireUndoableEditUpdate(new UndoableEditEvent(this, event));</span>

<span class="nc bnc" id="L2473" title="All 2 branches missed.">                    if (lastText.equals(&quot;\n&quot;)) {</span>
                        // We now have two \n's, one part of the Document.
                        // We need to remove one
<span class="nc" id="L2476">                        event = new DefaultDocumentEvent(length - 1, 1,</span>
                                           DocumentEvent.EventType.REMOVE);
<span class="nc" id="L2478">                        removeUpdate(event);</span>
<span class="nc" id="L2479">                        UndoableEdit u = getContent().remove(length - 1, 1);</span>
<span class="nc bnc" id="L2480" title="All 2 branches missed.">                        if (u != null) {</span>
<span class="nc" id="L2481">                            event.addEdit(u);</span>
                        }
<span class="nc" id="L2483">                        postRemoveUpdate(event);</span>
                        // Mark the edit as done.
<span class="nc" id="L2485">                        event.end();</span>
<span class="nc" id="L2486">                        fireRemoveUpdate(event);</span>
<span class="nc" id="L2487">                        fireUndoableEditUpdate(new UndoableEditEvent(</span>
                                               this, event));
                    }
                }
            }
<span class="nc" id="L2492">            catch (BadLocationException ble) {</span>
            }
            finally {
<span class="nc" id="L2495">                releaseLock();</span>
<span class="nc" id="L2496">            }</span>
<span class="nc" id="L2497">        }</span>

        private Element[] getPathTo(int offset) {
<span class="nc" id="L2500">            Stack&lt;Element&gt; elements = new Stack&lt;Element&gt;();</span>
<span class="nc" id="L2501">            Element e = getDefaultRootElement();</span>
            int index;
<span class="nc bnc" id="L2503" title="All 2 branches missed.">            while (!e.isLeaf()) {</span>
<span class="nc" id="L2504">                elements.push(e);</span>
<span class="nc" id="L2505">                e = e.getElement(e.getElementIndex(offset));</span>
            }
<span class="nc" id="L2507">            Element[] retValue = new Element[elements.size()];</span>
<span class="nc" id="L2508">            elements.copyInto(retValue);</span>
<span class="nc" id="L2509">            return retValue;</span>
        }

        // -- HTMLEditorKit.ParserCallback methods --------------------

        /**
         * The last method called on the reader.  It allows
         * any pending changes to be flushed into the document.
         * Since this is currently loading synchronously, the entire
         * set of changes are pushed in at this point.
         */
        public void flush() throws BadLocationException {
<span class="nc bnc" id="L2521" title="All 4 branches missed.">            if (emptyDocument &amp;&amp; !insertAfterImplied) {</span>
<span class="nc bnc" id="L2522" title="All 2 branches missed.">                if (HTMLDocument.this.getLength() &gt; 0 ||</span>
<span class="nc bnc" id="L2523" title="All 2 branches missed.">                                      parseBuffer.size() &gt; 0) {</span>
<span class="nc" id="L2524">                    flushBuffer(true);</span>
<span class="nc" id="L2525">                    adjustEndElement();</span>
                }
                // We won't insert when
            }
            else {
<span class="nc" id="L2530">                flushBuffer(true);</span>
            }
<span class="nc" id="L2532">        }</span>

        /**
         * Called by the parser to indicate a block of text was
         * encountered.
         */
        public void handleText(char[] data, int pos) {
<span class="nc bnc" id="L2539" title="All 6 branches missed.">            if (receivedEndHTML || (midInsert &amp;&amp; !inBody)) {</span>
<span class="nc" id="L2540">                return;</span>
            }

            // see if complex glyph layout support is needed
<span class="nc bnc" id="L2544" title="All 2 branches missed.">            if(HTMLDocument.this.getProperty(I18NProperty).equals( Boolean.FALSE ) ) {</span>
                // if a default direction of right-to-left has been specified,
                // we want complex layout even if the text is all left to right.
<span class="nc" id="L2547">                Object d = getProperty(TextAttribute.RUN_DIRECTION);</span>
<span class="nc bnc" id="L2548" title="All 4 branches missed.">                if ((d != null) &amp;&amp; (d.equals(TextAttribute.RUN_DIRECTION_RTL))) {</span>
<span class="nc" id="L2549">                    HTMLDocument.this.putProperty( I18NProperty, Boolean.TRUE);</span>
                } else {
<span class="nc bnc" id="L2551" title="All 2 branches missed.">                    if (SwingUtilities2.isComplexLayout(data, 0, data.length)) {</span>
<span class="nc" id="L2552">                        HTMLDocument.this.putProperty( I18NProperty, Boolean.TRUE);</span>
                    }
                }
            }

<span class="nc bnc" id="L2557" title="All 2 branches missed.">            if (inTextArea) {</span>
<span class="nc" id="L2558">                textAreaContent(data);</span>
<span class="nc bnc" id="L2559" title="All 2 branches missed.">            } else if (inPre) {</span>
<span class="nc" id="L2560">                preContent(data);</span>
<span class="nc bnc" id="L2561" title="All 2 branches missed.">            } else if (inTitle) {</span>
<span class="nc" id="L2562">                putProperty(Document.TitleProperty, new String(data));</span>
<span class="nc bnc" id="L2563" title="All 2 branches missed.">            } else if (option != null) {</span>
<span class="nc" id="L2564">                option.setLabel(new String(data));</span>
<span class="nc bnc" id="L2565" title="All 2 branches missed.">            } else if (inStyle) {</span>
<span class="nc bnc" id="L2566" title="All 2 branches missed.">                if (styles != null) {</span>
<span class="nc" id="L2567">                    styles.addElement(new String(data));</span>
                }
<span class="nc bnc" id="L2569" title="All 2 branches missed.">            } else if (inBlock &gt; 0) {</span>
<span class="nc bnc" id="L2570" title="All 4 branches missed.">                if (!foundInsertTag &amp;&amp; insertAfterImplied) {</span>
                    // Assume content should be added.
<span class="nc" id="L2572">                    foundInsertTag(false);</span>
<span class="nc" id="L2573">                    foundInsertTag = true;</span>
<span class="nc" id="L2574">                    inParagraph = impliedP = true;</span>
                }
<span class="nc bnc" id="L2576" title="All 2 branches missed.">                if (data.length &gt;= 1) {</span>
<span class="nc" id="L2577">                    addContent(data, 0, data.length);</span>
                }
            }
<span class="nc" id="L2580">        }</span>

        /**
         * Callback from the parser.  Route to the appropriate
         * handler for the tag.
         */
        public void handleStartTag(HTML.Tag t, MutableAttributeSet a, int pos) {
<span class="nc bnc" id="L2587" title="All 2 branches missed.">            if (receivedEndHTML) {</span>
<span class="nc" id="L2588">                return;</span>
            }
<span class="nc bnc" id="L2590" title="All 4 branches missed.">            if (midInsert &amp;&amp; !inBody) {</span>
<span class="nc bnc" id="L2591" title="All 2 branches missed.">                if (t == HTML.Tag.BODY) {</span>
<span class="nc" id="L2592">                    inBody = true;</span>
                    // Increment inBlock since we know we are in the body,
                    // this is needed incase an implied-p is needed. If
                    // inBlock isn't incremented, and an implied-p is
                    // encountered, addContent won't be called!
<span class="nc" id="L2597">                    inBlock++;</span>
                }
<span class="nc" id="L2599">                return;</span>
            }
<span class="nc bnc" id="L2601" title="All 4 branches missed.">            if (!inBody &amp;&amp; t == HTML.Tag.BODY) {</span>
<span class="nc" id="L2602">                inBody = true;</span>
            }
<span class="nc bnc" id="L2604" title="All 4 branches missed.">            if (isStyleCSS &amp;&amp; a.isDefined(HTML.Attribute.STYLE)) {</span>
                // Map the style attributes.
<span class="nc" id="L2606">                String decl = (String)a.getAttribute(HTML.Attribute.STYLE);</span>
<span class="nc" id="L2607">                a.removeAttribute(HTML.Attribute.STYLE);</span>
<span class="nc" id="L2608">                styleAttributes = getStyleSheet().getDeclaration(decl);</span>
<span class="nc" id="L2609">                a.addAttributes(styleAttributes);</span>
<span class="nc" id="L2610">            }</span>
            else {
<span class="nc" id="L2612">                styleAttributes = null;</span>
            }
<span class="nc" id="L2614">            TagAction action = tagMap.get(t);</span>

<span class="nc bnc" id="L2616" title="All 2 branches missed.">            if (action != null) {</span>
<span class="nc" id="L2617">                action.start(t, a);</span>
            }
<span class="nc" id="L2619">        }</span>

        public void handleComment(char[] data, int pos) {
<span class="nc bnc" id="L2622" title="All 2 branches missed.">            if (receivedEndHTML) {</span>
<span class="nc" id="L2623">                addExternalComment(new String(data));</span>
<span class="nc" id="L2624">                return;</span>
            }
<span class="nc bnc" id="L2626" title="All 2 branches missed.">            if (inStyle) {</span>
<span class="nc bnc" id="L2627" title="All 2 branches missed.">                if (styles != null) {</span>
<span class="nc" id="L2628">                    styles.addElement(new String(data));</span>
                }
            }
<span class="nc bnc" id="L2631" title="All 2 branches missed.">            else if (getPreservesUnknownTags()) {</span>
<span class="nc bnc" id="L2632" title="All 6 branches missed.">                if (inBlock == 0 &amp;&amp; (foundInsertTag ||</span>
                                     insertTag != HTML.Tag.COMMENT)) {
                    // Comment outside of body, will not be able to show it,
                    // but can add it as a property on the Document.
<span class="nc" id="L2636">                    addExternalComment(new String(data));</span>
<span class="nc" id="L2637">                    return;</span>
                }
<span class="nc" id="L2639">                SimpleAttributeSet sas = new SimpleAttributeSet();</span>
<span class="nc" id="L2640">                sas.addAttribute(HTML.Attribute.COMMENT, new String(data));</span>
<span class="nc" id="L2641">                addSpecialElement(HTML.Tag.COMMENT, sas);</span>
            }

<span class="nc" id="L2644">            TagAction action = tagMap.get(HTML.Tag.COMMENT);</span>
<span class="nc bnc" id="L2645" title="All 2 branches missed.">            if (action != null) {</span>
<span class="nc" id="L2646">                action.start(HTML.Tag.COMMENT, new SimpleAttributeSet());</span>
<span class="nc" id="L2647">                action.end(HTML.Tag.COMMENT);</span>
            }
<span class="nc" id="L2649">        }</span>

        /**
         * Adds the comment &lt;code&gt;comment&lt;/code&gt; to the set of comments
         * maintained outside of the scope of elements.
         */
        private void addExternalComment(String comment) {
<span class="nc" id="L2656">            Object comments = getProperty(AdditionalComments);</span>
<span class="nc bnc" id="L2657" title="All 4 branches missed.">            if (comments != null &amp;&amp; !(comments instanceof Vector)) {</span>
                // No place to put comment.
<span class="nc" id="L2659">                return;</span>
            }
<span class="nc bnc" id="L2661" title="All 2 branches missed.">            if (comments == null) {</span>
<span class="nc" id="L2662">                comments = new Vector();</span>
<span class="nc" id="L2663">                putProperty(AdditionalComments, comments);</span>
            }
<span class="nc" id="L2665">            ((Vector)comments).addElement(comment);</span>
<span class="nc" id="L2666">        }</span>

        /**
         * Callback from the parser.  Route to the appropriate
         * handler for the tag.
         */
        public void handleEndTag(HTML.Tag t, int pos) {
<span class="nc bnc" id="L2673" title="All 6 branches missed.">            if (receivedEndHTML || (midInsert &amp;&amp; !inBody)) {</span>
<span class="nc" id="L2674">                return;</span>
            }
<span class="nc bnc" id="L2676" title="All 2 branches missed.">            if (t == HTML.Tag.HTML) {</span>
<span class="nc" id="L2677">                receivedEndHTML = true;</span>
            }
<span class="nc bnc" id="L2679" title="All 2 branches missed.">            if (t == HTML.Tag.BODY) {</span>
<span class="nc" id="L2680">                inBody = false;</span>
<span class="nc bnc" id="L2681" title="All 2 branches missed.">                if (midInsert) {</span>
<span class="nc" id="L2682">                    inBlock--;</span>
                }
            }
<span class="nc" id="L2685">            TagAction action = tagMap.get(t);</span>
<span class="nc bnc" id="L2686" title="All 2 branches missed.">            if (action != null) {</span>
<span class="nc" id="L2687">                action.end(t);</span>
            }
<span class="nc" id="L2689">        }</span>

        /**
         * Callback from the parser.  Route to the appropriate
         * handler for the tag.
         */
        public void handleSimpleTag(HTML.Tag t, MutableAttributeSet a, int pos) {
<span class="nc bnc" id="L2696" title="All 6 branches missed.">            if (receivedEndHTML || (midInsert &amp;&amp; !inBody)) {</span>
<span class="nc" id="L2697">                return;</span>
            }

<span class="nc bnc" id="L2700" title="All 4 branches missed.">            if (isStyleCSS &amp;&amp; a.isDefined(HTML.Attribute.STYLE)) {</span>
                // Map the style attributes.
<span class="nc" id="L2702">                String decl = (String)a.getAttribute(HTML.Attribute.STYLE);</span>
<span class="nc" id="L2703">                a.removeAttribute(HTML.Attribute.STYLE);</span>
<span class="nc" id="L2704">                styleAttributes = getStyleSheet().getDeclaration(decl);</span>
<span class="nc" id="L2705">                a.addAttributes(styleAttributes);</span>
<span class="nc" id="L2706">            }</span>
            else {
<span class="nc" id="L2708">                styleAttributes = null;</span>
            }

<span class="nc" id="L2711">            TagAction action = tagMap.get(t);</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">            if (action != null) {</span>
<span class="nc" id="L2713">                action.start(t, a);</span>
<span class="nc" id="L2714">                action.end(t);</span>
            }
<span class="nc bnc" id="L2716" title="All 2 branches missed.">            else if (getPreservesUnknownTags()) {</span>
                // unknown tag, only add if should preserve it.
<span class="nc" id="L2718">                addSpecialElement(t, a);</span>
            }
<span class="nc" id="L2720">        }</span>

        /**
         * This is invoked after the stream has been parsed, but before
         * &lt;code&gt;flush&lt;/code&gt;. &lt;code&gt;eol&lt;/code&gt; will be one of \n, \r
         * or \r\n, which ever is encountered the most in parsing the
         * stream.
         *
         * @since 1.3
         */
        public void handleEndOfLineString(String eol) {
<span class="nc bnc" id="L2731" title="All 4 branches missed.">            if (emptyDocument &amp;&amp; eol != null) {</span>
<span class="nc" id="L2732">                putProperty(DefaultEditorKit.EndOfLineStringProperty,</span>
                            eol);
            }
<span class="nc" id="L2735">        }</span>

        // ---- tag handling support ------------------------------

        /**
         * Registers a handler for the given tag.  By default
         * all of the well-known tags will have been registered.
         * This can be used to change the handling of a particular
         * tag or to add support for custom tags.
         */
        protected void registerTag(HTML.Tag t, TagAction a) {
<span class="nc" id="L2746">            tagMap.put(t, a);</span>
<span class="nc" id="L2747">        }</span>

        /**
         * An action to be performed in response
         * to parsing a tag.  This allows customization
         * of how each tag is handled and avoids a large
         * switch statement.
         */
<span class="nc" id="L2755">        public class TagAction {</span>

            /**
             * Called when a start tag is seen for the
             * type of tag this action was registered
             * to.  The tag argument indicates the actual
             * tag for those actions that are shared across
             * many tags.  By default this does nothing and
             * completely ignores the tag.
             */
            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc" id="L2766">            }</span>

            /**
             * Called when an end tag is seen for the
             * type of tag this action was registered
             * to.  The tag argument indicates the actual
             * tag for those actions that are shared across
             * many tags.  By default this does nothing and
             * completely ignores the tag.
             */
            public void end(HTML.Tag t) {
<span class="nc" id="L2777">            }</span>

        }

<span class="nc" id="L2781">        public class BlockAction extends TagAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet attr) {
<span class="nc" id="L2784">                blockOpen(t, attr);</span>
<span class="nc" id="L2785">            }</span>

            public void end(HTML.Tag t) {
<span class="nc" id="L2788">                blockClose(t);</span>
<span class="nc" id="L2789">            }</span>
        }


        /**
         * Action used for the actual element form tag. This is named such
         * as there was already a public class named FormAction.
         */
<span class="nc" id="L2797">        private class FormTagAction extends BlockAction {</span>
            public void start(HTML.Tag t, MutableAttributeSet attr) {
<span class="nc" id="L2799">                super.start(t, attr);</span>
                // initialize a ButtonGroupsMap when
                // FORM tag is encountered.  This will
                // be used for any radio buttons that
                // might be defined in the FORM.
                // for new group new ButtonGroup will be created (fix for 4529702)
                // group name is a key in radioButtonGroupsMap
<span class="nc" id="L2806">                radioButtonGroupsMap = new HashMap&lt;String, ButtonGroup&gt;();</span>
<span class="nc" id="L2807">            }</span>

            public void end(HTML.Tag t) {
<span class="nc" id="L2810">                super.end(t);</span>
                // reset the button group to null since
                // the form has ended.
<span class="nc" id="L2813">                radioButtonGroupsMap = null;</span>
<span class="nc" id="L2814">            }</span>
        }


<span class="nc" id="L2818">        public class ParagraphAction extends BlockAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc" id="L2821">                super.start(t, a);</span>
<span class="nc" id="L2822">                inParagraph = true;</span>
<span class="nc" id="L2823">            }</span>

            public void end(HTML.Tag t) {
<span class="nc" id="L2826">                super.end(t);</span>
<span class="nc" id="L2827">                inParagraph = false;</span>
<span class="nc" id="L2828">            }</span>
        }

<span class="nc" id="L2831">        public class SpecialAction extends TagAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc" id="L2834">                addSpecialElement(t, a);</span>
<span class="nc" id="L2835">            }</span>

        }

<span class="nc" id="L2839">        public class IsindexAction extends TagAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc" id="L2842">                blockOpen(HTML.Tag.IMPLIED, new SimpleAttributeSet());</span>
<span class="nc" id="L2843">                addSpecialElement(t, a);</span>
<span class="nc" id="L2844">                blockClose(HTML.Tag.IMPLIED);</span>
<span class="nc" id="L2845">            }</span>

        }


<span class="nc" id="L2850">        public class HiddenAction extends TagAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc" id="L2853">                addSpecialElement(t, a);</span>
<span class="nc" id="L2854">            }</span>

            public void end(HTML.Tag t) {
<span class="nc bnc" id="L2857" title="All 2 branches missed.">                if (!isEmpty(t)) {</span>
<span class="nc" id="L2858">                    MutableAttributeSet a = new SimpleAttributeSet();</span>
<span class="nc" id="L2859">                    a.addAttribute(HTML.Attribute.ENDTAG, &quot;true&quot;);</span>
<span class="nc" id="L2860">                    addSpecialElement(t, a);</span>
                }
<span class="nc" id="L2862">            }</span>

            boolean isEmpty(HTML.Tag t) {
<span class="nc bnc" id="L2865" title="All 4 branches missed.">                if (t == HTML.Tag.APPLET ||</span>
                    t == HTML.Tag.SCRIPT) {
<span class="nc" id="L2867">                    return false;</span>
                }
<span class="nc" id="L2869">                return true;</span>
            }
        }


        /**
         * Subclass of HiddenAction to set the content type for style sheets,
         * and to set the name of the default style sheet.
         */
<span class="nc" id="L2878">        class MetaAction extends HiddenAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc" id="L2881">                Object equiv = a.getAttribute(HTML.Attribute.HTTPEQUIV);</span>
<span class="nc bnc" id="L2882" title="All 2 branches missed.">                if (equiv != null) {</span>
<span class="nc" id="L2883">                    equiv = ((String)equiv).toLowerCase();</span>
<span class="nc bnc" id="L2884" title="All 2 branches missed.">                    if (equiv.equals(&quot;content-style-type&quot;)) {</span>
<span class="nc" id="L2885">                        String value = (String)a.getAttribute</span>
<span class="nc" id="L2886">                                       (HTML.Attribute.CONTENT);</span>
<span class="nc" id="L2887">                        setDefaultStyleSheetType(value);</span>
<span class="nc" id="L2888">                        isStyleCSS = &quot;text/css&quot;.equals</span>
<span class="nc" id="L2889">                                      (getDefaultStyleSheetType());</span>
<span class="nc" id="L2890">                    }</span>
<span class="nc bnc" id="L2891" title="All 2 branches missed.">                    else if (equiv.equals(&quot;default-style&quot;)) {</span>
<span class="nc" id="L2892">                        defaultStyle = (String)a.getAttribute</span>
<span class="nc" id="L2893">                                       (HTML.Attribute.CONTENT);</span>
                    }
                }
<span class="nc" id="L2896">                super.start(t, a);</span>
<span class="nc" id="L2897">            }</span>

            boolean isEmpty(HTML.Tag t) {
<span class="nc" id="L2900">                return true;</span>
            }
        }


        /**
         * End if overridden to create the necessary stylesheets that
         * are referenced via the link tag. It is done in this manner
         * as the meta tag can be used to specify an alternate style sheet,
         * and is not guaranteed to come before the link tags.
         */
<span class="nc" id="L2911">        class HeadAction extends BlockAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc" id="L2914">                inHead = true;</span>
                // This check of the insertTag is put in to avoid considering
                // the implied-p that is generated for the head. This allows
                // inserts for HR to work correctly.
<span class="nc bnc" id="L2918" title="All 6 branches missed.">                if ((insertTag == null &amp;&amp; !insertAfterImplied) ||</span>
                    (insertTag == HTML.Tag.HEAD) ||
<span class="nc bnc" id="L2920" title="All 4 branches missed.">                    (insertAfterImplied &amp;&amp;</span>
<span class="nc bnc" id="L2921" title="All 2 branches missed.">                     (foundInsertTag || !a.isDefined(IMPLIED)))) {</span>
<span class="nc" id="L2922">                    super.start(t, a);</span>
                }
<span class="nc" id="L2924">            }</span>

            public void end(HTML.Tag t) {
<span class="nc" id="L2927">                inHead = inStyle = false;</span>
                // See if there is a StyleSheet to link to.
<span class="nc bnc" id="L2929" title="All 2 branches missed.">                if (styles != null) {</span>
<span class="nc" id="L2930">                    boolean isDefaultCSS = isStyleCSS;</span>
<span class="nc" id="L2931">                    for (int counter = 0, maxCounter = styles.size();</span>
<span class="nc bnc" id="L2932" title="All 2 branches missed.">                         counter &lt; maxCounter;) {</span>
<span class="nc" id="L2933">                        Object value = styles.elementAt(counter);</span>
<span class="nc bnc" id="L2934" title="All 2 branches missed.">                        if (value == HTML.Tag.LINK) {</span>
<span class="nc" id="L2935">                            handleLink((AttributeSet)styles.</span>
<span class="nc" id="L2936">                                       elementAt(++counter));</span>
<span class="nc" id="L2937">                            counter++;</span>
                        }
                        else {
                            // Rule.
                            // First element gives type.
<span class="nc" id="L2942">                            String type = (String)styles.elementAt(++counter);</span>
<span class="nc bnc" id="L2943" title="All 2 branches missed.">                            boolean isCSS = (type == null) ? isDefaultCSS :</span>
<span class="nc" id="L2944">                                            type.equals(&quot;text/css&quot;);</span>
<span class="nc bnc" id="L2945" title="All 2 branches missed.">                            while (++counter &lt; maxCounter &amp;&amp;</span>
<span class="nc bnc" id="L2946" title="All 2 branches missed.">                                   (styles.elementAt(counter)</span>
                                    instanceof String)) {
<span class="nc bnc" id="L2948" title="All 2 branches missed.">                                if (isCSS) {</span>
<span class="nc" id="L2949">                                    addCSSRules((String)styles.elementAt</span>
<span class="nc" id="L2950">                                                (counter));</span>
                                }
                            }
                        }
<span class="nc" id="L2954">                    }</span>
                }
<span class="nc bnc" id="L2956" title="All 6 branches missed.">                if ((insertTag == null &amp;&amp; !insertAfterImplied) ||</span>
                    insertTag == HTML.Tag.HEAD ||
<span class="nc bnc" id="L2958" title="All 4 branches missed.">                    (insertAfterImplied &amp;&amp; foundInsertTag)) {</span>
<span class="nc" id="L2959">                    super.end(t);</span>
                }
<span class="nc" id="L2961">            }</span>

            boolean isEmpty(HTML.Tag t) {
<span class="nc" id="L2964">                return false;</span>
            }

            private void handleLink(AttributeSet attr) {
                // Link.
<span class="nc" id="L2969">                String type = (String)attr.getAttribute(HTML.Attribute.TYPE);</span>
<span class="nc bnc" id="L2970" title="All 2 branches missed.">                if (type == null) {</span>
<span class="nc" id="L2971">                    type = getDefaultStyleSheetType();</span>
                }
                // Only choose if type==text/css
                // Select link if rel==stylesheet.
                // Otherwise if rel==alternate stylesheet and
                //   title matches default style.
<span class="nc bnc" id="L2977" title="All 2 branches missed.">                if (type.equals(&quot;text/css&quot;)) {</span>
<span class="nc" id="L2978">                    String rel = (String)attr.getAttribute(HTML.Attribute.REL);</span>
<span class="nc" id="L2979">                    String title = (String)attr.getAttribute</span>
<span class="nc" id="L2980">                                               (HTML.Attribute.TITLE);</span>
<span class="nc" id="L2981">                    String media = (String)attr.getAttribute</span>
<span class="nc" id="L2982">                                                   (HTML.Attribute.MEDIA);</span>
<span class="nc bnc" id="L2983" title="All 2 branches missed.">                    if (media == null) {</span>
<span class="nc" id="L2984">                        media = &quot;all&quot;;</span>
                    }
                    else {
<span class="nc" id="L2987">                        media = media.toLowerCase();</span>
                    }
<span class="nc bnc" id="L2989" title="All 2 branches missed.">                    if (rel != null) {</span>
<span class="nc" id="L2990">                        rel = rel.toLowerCase();</span>
<span class="nc bnc" id="L2991" title="All 2 branches missed.">                        if ((media.indexOf(&quot;all&quot;) != -1 ||</span>
<span class="nc bnc" id="L2992" title="All 2 branches missed.">                             media.indexOf(&quot;screen&quot;) != -1) &amp;&amp;</span>
<span class="nc bnc" id="L2993" title="All 2 branches missed.">                            (rel.equals(&quot;stylesheet&quot;) ||</span>
<span class="nc bnc" id="L2994" title="All 2 branches missed.">                             (rel.equals(&quot;alternate stylesheet&quot;) &amp;&amp;</span>
<span class="nc bnc" id="L2995" title="All 2 branches missed.">                              title.equals(defaultStyle)))) {</span>
<span class="nc" id="L2996">                            linkCSSStyleSheet((String)attr.getAttribute</span>
<span class="nc" id="L2997">                                              (HTML.Attribute.HREF));</span>
                        }
                    }
                }
<span class="nc" id="L3001">            }</span>
        }


        /**
         * A subclass to add the AttributeSet to styles if the
         * attributes contains an attribute for 'rel' with value
         * 'stylesheet' or 'alternate stylesheet'.
         */
<span class="nc" id="L3010">        class LinkAction extends HiddenAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc" id="L3013">                String rel = (String)a.getAttribute(HTML.Attribute.REL);</span>
<span class="nc bnc" id="L3014" title="All 2 branches missed.">                if (rel != null) {</span>
<span class="nc" id="L3015">                    rel = rel.toLowerCase();</span>
<span class="nc bnc" id="L3016" title="All 2 branches missed.">                    if (rel.equals(&quot;stylesheet&quot;) ||</span>
<span class="nc bnc" id="L3017" title="All 2 branches missed.">                        rel.equals(&quot;alternate stylesheet&quot;)) {</span>
<span class="nc bnc" id="L3018" title="All 2 branches missed.">                        if (styles == null) {</span>
<span class="nc" id="L3019">                            styles = new Vector&lt;Object&gt;(3);</span>
                        }
<span class="nc" id="L3021">                        styles.addElement(t);</span>
<span class="nc" id="L3022">                        styles.addElement(a.copyAttributes());</span>
                    }
                }
<span class="nc" id="L3025">                super.start(t, a);</span>
<span class="nc" id="L3026">            }</span>
        }

<span class="nc" id="L3029">        class MapAction extends TagAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc" id="L3032">                lastMap = new Map((String)a.getAttribute(HTML.Attribute.NAME));</span>
<span class="nc" id="L3033">                addMap(lastMap);</span>
<span class="nc" id="L3034">            }</span>

            public void end(HTML.Tag t) {
<span class="nc" id="L3037">            }</span>
        }


<span class="nc" id="L3041">        class AreaAction extends TagAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc bnc" id="L3044" title="All 2 branches missed.">                if (lastMap != null) {</span>
<span class="nc" id="L3045">                    lastMap.addArea(a.copyAttributes());</span>
                }
<span class="nc" id="L3047">            }</span>

            public void end(HTML.Tag t) {
<span class="nc" id="L3050">            }</span>
        }


<span class="nc" id="L3054">        class StyleAction extends TagAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc bnc" id="L3057" title="All 2 branches missed.">                if (inHead) {</span>
<span class="nc bnc" id="L3058" title="All 2 branches missed.">                    if (styles == null) {</span>
<span class="nc" id="L3059">                        styles = new Vector&lt;Object&gt;(3);</span>
                    }
<span class="nc" id="L3061">                    styles.addElement(t);</span>
<span class="nc" id="L3062">                    styles.addElement(a.getAttribute(HTML.Attribute.TYPE));</span>
<span class="nc" id="L3063">                    inStyle = true;</span>
                }
<span class="nc" id="L3065">            }</span>

            public void end(HTML.Tag t) {
<span class="nc" id="L3068">                inStyle = false;</span>
<span class="nc" id="L3069">            }</span>

            boolean isEmpty(HTML.Tag t) {
<span class="nc" id="L3072">                return false;</span>
            }
        }


<span class="nc" id="L3077">        public class PreAction extends BlockAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet attr) {
<span class="nc" id="L3080">                inPre = true;</span>
<span class="nc" id="L3081">                blockOpen(t, attr);</span>
<span class="nc" id="L3082">                attr.addAttribute(CSS.Attribute.WHITE_SPACE, &quot;pre&quot;);</span>
<span class="nc" id="L3083">                blockOpen(HTML.Tag.IMPLIED, attr);</span>
<span class="nc" id="L3084">            }</span>

            public void end(HTML.Tag t) {
<span class="nc" id="L3087">                blockClose(HTML.Tag.IMPLIED);</span>
                // set inPre to false after closing, so that if a newline
                // is added it won't generate a blockOpen.
<span class="nc" id="L3090">                inPre = false;</span>
<span class="nc" id="L3091">                blockClose(t);</span>
<span class="nc" id="L3092">            }</span>
        }

<span class="nc" id="L3095">        public class CharacterAction extends TagAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet attr) {
<span class="nc" id="L3098">                pushCharacterStyle();</span>
<span class="nc bnc" id="L3099" title="All 2 branches missed.">                if (!foundInsertTag) {</span>
                    // Note that the third argument should really be based off
                    // inParagraph and impliedP. If we're wrong (that is
                    // insertTagDepthDelta shouldn't be changed), we'll end up
                    // removing an extra EndSpec, which won't matter anyway.
<span class="nc" id="L3104">                    boolean insert = canInsertTag(t, attr, false);</span>
<span class="nc bnc" id="L3105" title="All 2 branches missed.">                    if (foundInsertTag) {</span>
<span class="nc bnc" id="L3106" title="All 2 branches missed.">                        if (!inParagraph) {</span>
<span class="nc" id="L3107">                            inParagraph = impliedP = true;</span>
                        }
                    }
<span class="nc bnc" id="L3110" title="All 2 branches missed.">                    if (!insert) {</span>
<span class="nc" id="L3111">                        return;</span>
                    }
                }
<span class="nc bnc" id="L3114" title="All 2 branches missed.">                if (attr.isDefined(IMPLIED)) {</span>
<span class="nc" id="L3115">                    attr.removeAttribute(IMPLIED);</span>
                }
<span class="nc" id="L3117">                charAttr.addAttribute(t, attr.copyAttributes());</span>
<span class="nc bnc" id="L3118" title="All 2 branches missed.">                if (styleAttributes != null) {</span>
<span class="nc" id="L3119">                    charAttr.addAttributes(styleAttributes);</span>
                }
<span class="nc" id="L3121">            }</span>

            public void end(HTML.Tag t) {
<span class="nc" id="L3124">                popCharacterStyle();</span>
<span class="nc" id="L3125">            }</span>
        }

        /**
         * Provides conversion of HTML tag/attribute
         * mappings that have a corresponding StyleConstants
         * and CSS mapping.  The conversion is to CSS attributes.
         */
<span class="nc" id="L3133">        class ConvertAction extends TagAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet attr) {
<span class="nc" id="L3136">                pushCharacterStyle();</span>
<span class="nc bnc" id="L3137" title="All 2 branches missed.">                if (!foundInsertTag) {</span>
                    // Note that the third argument should really be based off
                    // inParagraph and impliedP. If we're wrong (that is
                    // insertTagDepthDelta shouldn't be changed), we'll end up
                    // removing an extra EndSpec, which won't matter anyway.
<span class="nc" id="L3142">                    boolean insert = canInsertTag(t, attr, false);</span>
<span class="nc bnc" id="L3143" title="All 2 branches missed.">                    if (foundInsertTag) {</span>
<span class="nc bnc" id="L3144" title="All 2 branches missed.">                        if (!inParagraph) {</span>
<span class="nc" id="L3145">                            inParagraph = impliedP = true;</span>
                        }
                    }
<span class="nc bnc" id="L3148" title="All 2 branches missed.">                    if (!insert) {</span>
<span class="nc" id="L3149">                        return;</span>
                    }
                }
<span class="nc bnc" id="L3152" title="All 2 branches missed.">                if (attr.isDefined(IMPLIED)) {</span>
<span class="nc" id="L3153">                    attr.removeAttribute(IMPLIED);</span>
                }
<span class="nc bnc" id="L3155" title="All 2 branches missed.">                if (styleAttributes != null) {</span>
<span class="nc" id="L3156">                    charAttr.addAttributes(styleAttributes);</span>
                }
                // We also need to add attr, otherwise we lose custom
                // attributes, including class/id for style lookups, and
                // further confuse style lookup (doesn't have tag).
<span class="nc" id="L3161">                charAttr.addAttribute(t, attr.copyAttributes());</span>
<span class="nc" id="L3162">                StyleSheet sheet = getStyleSheet();</span>
<span class="nc bnc" id="L3163" title="All 2 branches missed.">                if (t == HTML.Tag.B) {</span>
<span class="nc" id="L3164">                    sheet.addCSSAttribute(charAttr, CSS.Attribute.FONT_WEIGHT, &quot;bold&quot;);</span>
<span class="nc bnc" id="L3165" title="All 2 branches missed.">                } else if (t == HTML.Tag.I) {</span>
<span class="nc" id="L3166">                    sheet.addCSSAttribute(charAttr, CSS.Attribute.FONT_STYLE, &quot;italic&quot;);</span>
<span class="nc bnc" id="L3167" title="All 2 branches missed.">                } else if (t == HTML.Tag.U) {</span>
<span class="nc" id="L3168">                    Object v = charAttr.getAttribute(CSS.Attribute.TEXT_DECORATION);</span>
<span class="nc" id="L3169">                    String value = &quot;underline&quot;;</span>
<span class="nc bnc" id="L3170" title="All 2 branches missed.">                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;</span>
<span class="nc" id="L3171">                    sheet.addCSSAttribute(charAttr, CSS.Attribute.TEXT_DECORATION, value);</span>
<span class="nc bnc" id="L3172" title="All 2 branches missed.">                } else if (t == HTML.Tag.STRIKE) {</span>
<span class="nc" id="L3173">                    Object v = charAttr.getAttribute(CSS.Attribute.TEXT_DECORATION);</span>
<span class="nc" id="L3174">                    String value = &quot;line-through&quot;;</span>
<span class="nc bnc" id="L3175" title="All 2 branches missed.">                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;</span>
<span class="nc" id="L3176">                    sheet.addCSSAttribute(charAttr, CSS.Attribute.TEXT_DECORATION, value);</span>
<span class="nc bnc" id="L3177" title="All 2 branches missed.">                } else if (t == HTML.Tag.SUP) {</span>
<span class="nc" id="L3178">                    Object v = charAttr.getAttribute(CSS.Attribute.VERTICAL_ALIGN);</span>
<span class="nc" id="L3179">                    String value = &quot;sup&quot;;</span>
<span class="nc bnc" id="L3180" title="All 2 branches missed.">                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;</span>
<span class="nc" id="L3181">                    sheet.addCSSAttribute(charAttr, CSS.Attribute.VERTICAL_ALIGN, value);</span>
<span class="nc bnc" id="L3182" title="All 2 branches missed.">                } else if (t == HTML.Tag.SUB) {</span>
<span class="nc" id="L3183">                    Object v = charAttr.getAttribute(CSS.Attribute.VERTICAL_ALIGN);</span>
<span class="nc" id="L3184">                    String value = &quot;sub&quot;;</span>
<span class="nc bnc" id="L3185" title="All 2 branches missed.">                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;</span>
<span class="nc" id="L3186">                    sheet.addCSSAttribute(charAttr, CSS.Attribute.VERTICAL_ALIGN, value);</span>
<span class="nc bnc" id="L3187" title="All 2 branches missed.">                } else if (t == HTML.Tag.FONT) {</span>
<span class="nc" id="L3188">                    String color = (String) attr.getAttribute(HTML.Attribute.COLOR);</span>
<span class="nc bnc" id="L3189" title="All 2 branches missed.">                    if (color != null) {</span>
<span class="nc" id="L3190">                        sheet.addCSSAttribute(charAttr, CSS.Attribute.COLOR, color);</span>
                    }
<span class="nc" id="L3192">                    String face = (String) attr.getAttribute(HTML.Attribute.FACE);</span>
<span class="nc bnc" id="L3193" title="All 2 branches missed.">                    if (face != null) {</span>
<span class="nc" id="L3194">                        sheet.addCSSAttribute(charAttr, CSS.Attribute.FONT_FAMILY, face);</span>
                    }
<span class="nc" id="L3196">                    String size = (String) attr.getAttribute(HTML.Attribute.SIZE);</span>
<span class="nc bnc" id="L3197" title="All 2 branches missed.">                    if (size != null) {</span>
<span class="nc" id="L3198">                        sheet.addCSSAttributeFromHTML(charAttr, CSS.Attribute.FONT_SIZE, size);</span>
                    }
                }
<span class="nc" id="L3201">            }</span>

            public void end(HTML.Tag t) {
<span class="nc" id="L3204">                popCharacterStyle();</span>
<span class="nc" id="L3205">            }</span>

        }

<span class="nc" id="L3209">        class AnchorAction extends CharacterAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet attr) {
                // set flag to catch empty anchors
<span class="nc" id="L3213">                emptyAnchor = true;</span>
<span class="nc" id="L3214">                super.start(t, attr);</span>
<span class="nc" id="L3215">            }</span>

            public void end(HTML.Tag t) {
<span class="nc bnc" id="L3218" title="All 2 branches missed.">                if (emptyAnchor) {</span>
                    // if the anchor was empty it was probably a
                    // named anchor point and we don't want to throw
                    // it away.
<span class="nc" id="L3222">                    char[] one = new char[1];</span>
<span class="nc" id="L3223">                    one[0] = '\n';</span>
<span class="nc" id="L3224">                    addContent(one, 0, 1);</span>
                }
<span class="nc" id="L3226">                super.end(t);</span>
<span class="nc" id="L3227">            }</span>
        }

<span class="nc" id="L3230">        class TitleAction extends HiddenAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet attr) {
<span class="nc" id="L3233">                inTitle = true;</span>
<span class="nc" id="L3234">                super.start(t, attr);</span>
<span class="nc" id="L3235">            }</span>

            public void end(HTML.Tag t) {
<span class="nc" id="L3238">                inTitle = false;</span>
<span class="nc" id="L3239">                super.end(t);</span>
<span class="nc" id="L3240">            }</span>

            boolean isEmpty(HTML.Tag t) {
<span class="nc" id="L3243">                return false;</span>
            }
        }


<span class="nc" id="L3248">        class BaseAction extends TagAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet attr) {
<span class="nc" id="L3251">                String href = (String) attr.getAttribute(HTML.Attribute.HREF);</span>
<span class="nc bnc" id="L3252" title="All 2 branches missed.">                if (href != null) {</span>
                    try {
<span class="nc" id="L3254">                        URL newBase = new URL(base, href);</span>
<span class="nc" id="L3255">                        setBase(newBase);</span>
<span class="nc" id="L3256">                        hasBaseTag = true;</span>
<span class="nc" id="L3257">                    } catch (MalformedURLException ex) {</span>
<span class="nc" id="L3258">                    }</span>
                }
<span class="nc" id="L3260">                baseTarget = (String) attr.getAttribute(HTML.Attribute.TARGET);</span>
<span class="nc" id="L3261">            }</span>
        }

<span class="nc" id="L3264">        class ObjectAction extends SpecialAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet a) {
<span class="nc bnc" id="L3267" title="All 2 branches missed.">                if (t == HTML.Tag.PARAM) {</span>
<span class="nc" id="L3268">                    addParameter(a);</span>
                } else {
<span class="nc" id="L3270">                    super.start(t, a);</span>
                }
<span class="nc" id="L3272">            }</span>

            public void end(HTML.Tag t) {
<span class="nc bnc" id="L3275" title="All 2 branches missed.">                if (t != HTML.Tag.PARAM) {</span>
<span class="nc" id="L3276">                    super.end(t);</span>
                }
<span class="nc" id="L3278">            }</span>

            void addParameter(AttributeSet a) {
<span class="nc" id="L3281">                String name = (String) a.getAttribute(HTML.Attribute.NAME);</span>
<span class="nc" id="L3282">                String value = (String) a.getAttribute(HTML.Attribute.VALUE);</span>
<span class="nc bnc" id="L3283" title="All 4 branches missed.">                if ((name != null) &amp;&amp; (value != null)) {</span>
<span class="nc" id="L3284">                    ElementSpec objSpec = parseBuffer.lastElement();</span>
<span class="nc" id="L3285">                    MutableAttributeSet objAttr = (MutableAttributeSet) objSpec.getAttributes();</span>
<span class="nc" id="L3286">                    objAttr.addAttribute(name, value);</span>
                }
<span class="nc" id="L3288">            }</span>
        }

        /**
         * Action to support forms by building all of the elements
         * used to represent form controls.  This will process
         * the &amp;lt;INPUT&amp;gt;, &amp;lt;TEXTAREA&amp;gt;, &amp;lt;SELECT&amp;gt;,
         * and &amp;lt;OPTION&amp;gt; tags.  The element created by
         * this action is expected to have the attribute
         * &lt;code&gt;StyleConstants.ModelAttribute&lt;/code&gt; set to
         * the model that holds the state for the form control.
         * This enables multiple views, and allows document to
         * be iterated over picking up the data of the form.
         * The following are the model assignments for the
         * various type of form elements.
         * &lt;table summary=&quot;model assignments for the various types of form elements&quot;&gt;
         * &lt;tr&gt;
         *   &lt;th&gt;Element Type
         *   &lt;th&gt;Model Type
         * &lt;tr&gt;
         *   &lt;td&gt;input, type button
         *   &lt;td&gt;{@link DefaultButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type checkbox
         *   &lt;td&gt;{@link javax.swing.JToggleButton.ToggleButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type image
         *   &lt;td&gt;{@link DefaultButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type password
         *   &lt;td&gt;{@link PlainDocument}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type radio
         *   &lt;td&gt;{@link javax.swing.JToggleButton.ToggleButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type reset
         *   &lt;td&gt;{@link DefaultButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type submit
         *   &lt;td&gt;{@link DefaultButtonModel}
         * &lt;tr&gt;
         *   &lt;td&gt;input, type text or type is null.
         *   &lt;td&gt;{@link PlainDocument}
         * &lt;tr&gt;
         *   &lt;td&gt;select
         *   &lt;td&gt;{@link DefaultComboBoxModel} or an {@link DefaultListModel}, with an item type of Option
         * &lt;tr&gt;
         *   &lt;td&gt;textarea
         *   &lt;td&gt;{@link PlainDocument}
         * &lt;/table&gt;
         *
         */
<span class="nc" id="L3340">        public class FormAction extends SpecialAction {</span>

            public void start(HTML.Tag t, MutableAttributeSet attr) {
<span class="nc bnc" id="L3343" title="All 2 branches missed.">                if (t == HTML.Tag.INPUT) {</span>
<span class="nc" id="L3344">                    String type = (String)</span>
<span class="nc" id="L3345">                        attr.getAttribute(HTML.Attribute.TYPE);</span>
                    /*
                     * if type is not defined the default is
                     * assumed to be text.
                     */
<span class="nc bnc" id="L3350" title="All 2 branches missed.">                    if (type == null) {</span>
<span class="nc" id="L3351">                        type = &quot;text&quot;;</span>
<span class="nc" id="L3352">                        attr.addAttribute(HTML.Attribute.TYPE, &quot;text&quot;);</span>
                    }
<span class="nc" id="L3354">                    setModel(type, attr);</span>
<span class="nc bnc" id="L3355" title="All 2 branches missed.">                } else if (t == HTML.Tag.TEXTAREA) {</span>
<span class="nc" id="L3356">                    inTextArea = true;</span>
<span class="nc" id="L3357">                    textAreaDocument = new TextAreaDocument();</span>
<span class="nc" id="L3358">                    attr.addAttribute(StyleConstants.ModelAttribute,</span>
                                      textAreaDocument);
<span class="nc bnc" id="L3360" title="All 2 branches missed.">                } else if (t == HTML.Tag.SELECT) {</span>
<span class="nc" id="L3361">                    int size = HTML.getIntegerAttributeValue(attr,</span>
                                                             HTML.Attribute.SIZE,
                                                             1);
<span class="nc bnc" id="L3364" title="All 2 branches missed.">                    boolean multiple = attr.getAttribute(HTML.Attribute.MULTIPLE) != null;</span>
<span class="nc bnc" id="L3365" title="All 4 branches missed.">                    if ((size &gt; 1) || multiple) {</span>
<span class="nc" id="L3366">                        OptionListModel&lt;Option&gt; m = new OptionListModel&lt;Option&gt;();</span>
<span class="nc bnc" id="L3367" title="All 2 branches missed.">                        if (multiple) {</span>
<span class="nc" id="L3368">                            m.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);</span>
                        }
<span class="nc" id="L3370">                        selectModel = m;</span>
<span class="nc" id="L3371">                    } else {</span>
<span class="nc" id="L3372">                        selectModel = new OptionComboBoxModel&lt;Option&gt;();</span>
                    }
<span class="nc" id="L3374">                    attr.addAttribute(StyleConstants.ModelAttribute,</span>
                                      selectModel);

                }

                // build the element, unless this is an option.
<span class="nc bnc" id="L3380" title="All 2 branches missed.">                if (t == HTML.Tag.OPTION) {</span>
<span class="nc" id="L3381">                    option = new Option(attr);</span>

<span class="nc bnc" id="L3383" title="All 2 branches missed.">                    if (selectModel instanceof OptionListModel) {</span>
<span class="nc" id="L3384">                        OptionListModel&lt;Option&gt; m = (OptionListModel&lt;Option&gt;) selectModel;</span>
<span class="nc" id="L3385">                        m.addElement(option);</span>
<span class="nc bnc" id="L3386" title="All 2 branches missed.">                        if (option.isSelected()) {</span>
<span class="nc" id="L3387">                            m.addSelectionInterval(optionCount, optionCount);</span>
<span class="nc" id="L3388">                            m.setInitialSelection(optionCount);</span>
                        }
<span class="nc bnc" id="L3390" title="All 2 branches missed.">                    } else if (selectModel instanceof OptionComboBoxModel) {</span>
<span class="nc" id="L3391">                        OptionComboBoxModel&lt;Option&gt; m = (OptionComboBoxModel&lt;Option&gt;) selectModel;</span>
<span class="nc" id="L3392">                        m.addElement(option);</span>
<span class="nc bnc" id="L3393" title="All 2 branches missed.">                        if (option.isSelected()) {</span>
<span class="nc" id="L3394">                            m.setSelectedItem(option);</span>
<span class="nc" id="L3395">                            m.setInitialSelection(option);</span>
                        }
                    }
<span class="nc" id="L3398">                    optionCount++;</span>
                } else {
<span class="nc" id="L3400">                    super.start(t, attr);</span>
                }
<span class="nc" id="L3402">            }</span>

            public void end(HTML.Tag t) {
<span class="nc bnc" id="L3405" title="All 2 branches missed.">                if (t == HTML.Tag.OPTION) {</span>
<span class="nc" id="L3406">                    option = null;</span>
                } else {
<span class="nc bnc" id="L3408" title="All 2 branches missed.">                    if (t == HTML.Tag.SELECT) {</span>
<span class="nc" id="L3409">                        selectModel = null;</span>
<span class="nc" id="L3410">                        optionCount = 0;</span>
<span class="nc bnc" id="L3411" title="All 2 branches missed.">                    } else if (t == HTML.Tag.TEXTAREA) {</span>
<span class="nc" id="L3412">                        inTextArea = false;</span>

                        /* Now that the textarea has ended,
                         * store the entire initial text
                         * of the text area.  This will
                         * enable us to restore the initial
                         * state if a reset is requested.
                         */
<span class="nc" id="L3420">                        textAreaDocument.storeInitialText();</span>
                    }
<span class="nc" id="L3422">                    super.end(t);</span>
                }
<span class="nc" id="L3424">            }</span>

            void setModel(String type, MutableAttributeSet attr) {
<span class="nc bnc" id="L3427" title="All 2 branches missed.">                if (type.equals(&quot;submit&quot;) ||</span>
<span class="nc bnc" id="L3428" title="All 2 branches missed.">                    type.equals(&quot;reset&quot;) ||</span>
<span class="nc bnc" id="L3429" title="All 2 branches missed.">                    type.equals(&quot;image&quot;)) {</span>

                    // button model
<span class="nc" id="L3432">                    attr.addAttribute(StyleConstants.ModelAttribute,</span>
                                      new DefaultButtonModel());
<span class="nc bnc" id="L3434" title="All 2 branches missed.">                } else if (type.equals(&quot;text&quot;) ||</span>
<span class="nc bnc" id="L3435" title="All 2 branches missed.">                           type.equals(&quot;password&quot;)) {</span>
                    // plain text model
<span class="nc" id="L3437">                    int maxLength = HTML.getIntegerAttributeValue(</span>
                                       attr, HTML.Attribute.MAXLENGTH, -1);
                    Document doc;

<span class="nc bnc" id="L3441" title="All 2 branches missed.">                    if (maxLength &gt; 0) {</span>
<span class="nc" id="L3442">                        doc = new FixedLengthDocument(maxLength);</span>
                    }
                    else {
<span class="nc" id="L3445">                        doc = new PlainDocument();</span>
                    }
<span class="nc" id="L3447">                    String value = (String)</span>
<span class="nc" id="L3448">                        attr.getAttribute(HTML.Attribute.VALUE);</span>
                    try {
<span class="nc" id="L3450">                        doc.insertString(0, value, null);</span>
<span class="nc" id="L3451">                    } catch (BadLocationException e) {</span>
<span class="nc" id="L3452">                    }</span>
<span class="nc" id="L3453">                    attr.addAttribute(StyleConstants.ModelAttribute, doc);</span>
<span class="nc bnc" id="L3454" title="All 2 branches missed.">                } else if (type.equals(&quot;file&quot;)) {</span>
                    // plain text model
<span class="nc" id="L3456">                    attr.addAttribute(StyleConstants.ModelAttribute,</span>
                                      new PlainDocument());
<span class="nc bnc" id="L3458" title="All 2 branches missed.">                } else if (type.equals(&quot;checkbox&quot;) ||</span>
<span class="nc bnc" id="L3459" title="All 2 branches missed.">                           type.equals(&quot;radio&quot;)) {</span>
<span class="nc" id="L3460">                    JToggleButton.ToggleButtonModel model = new JToggleButton.ToggleButtonModel();</span>
<span class="nc bnc" id="L3461" title="All 2 branches missed.">                    if (type.equals(&quot;radio&quot;)) {</span>
<span class="nc" id="L3462">                        String name = (String) attr.getAttribute(HTML.Attribute.NAME);</span>
<span class="nc bnc" id="L3463" title="All 2 branches missed.">                        if ( radioButtonGroupsMap == null ) { //fix for 4772743</span>
<span class="nc" id="L3464">                           radioButtonGroupsMap = new HashMap&lt;String, ButtonGroup&gt;();</span>
                        }
<span class="nc" id="L3466">                        ButtonGroup radioButtonGroup = radioButtonGroupsMap.get(name);</span>
<span class="nc bnc" id="L3467" title="All 2 branches missed.">                        if (radioButtonGroup == null) {</span>
<span class="nc" id="L3468">                            radioButtonGroup = new ButtonGroup();</span>
<span class="nc" id="L3469">                            radioButtonGroupsMap.put(name,radioButtonGroup);</span>
                        }
<span class="nc" id="L3471">                        model.setGroup(radioButtonGroup);</span>
                    }
<span class="nc bnc" id="L3473" title="All 2 branches missed.">                    boolean checked = (attr.getAttribute(HTML.Attribute.CHECKED) != null);</span>
<span class="nc" id="L3474">                    model.setSelected(checked);</span>
<span class="nc" id="L3475">                    attr.addAttribute(StyleConstants.ModelAttribute, model);</span>
                }
<span class="nc" id="L3477">            }</span>

            /**
             * If a &amp;lt;SELECT&amp;gt; tag is being processed, this
             * model will be a reference to the model being filled
             * with the &amp;lt;OPTION&amp;gt; elements (which produce
             * objects of type &lt;code&gt;Option&lt;/code&gt;.
             */
            Object selectModel;
            int optionCount;
        }


        // --- utility methods used by the reader ------------------

        /**
         * Pushes the current character style on a stack in preparation
         * for forming a new nested character style.
         */
        protected void pushCharacterStyle() {
<span class="nc" id="L3497">            charAttrStack.push(charAttr.copyAttributes());</span>
<span class="nc" id="L3498">        }</span>

        /**
         * Pops a previously pushed character style off the stack
         * to return to a previous style.
         */
        protected void popCharacterStyle() {
<span class="nc bnc" id="L3505" title="All 2 branches missed.">            if (!charAttrStack.empty()) {</span>
<span class="nc" id="L3506">                charAttr = (MutableAttributeSet) charAttrStack.peek();</span>
<span class="nc" id="L3507">                charAttrStack.pop();</span>
            }
<span class="nc" id="L3509">        }</span>

        /**
         * Adds the given content to the textarea document.
         * This method gets called when we are in a textarea
         * context.  Therefore all text that is seen belongs
         * to the text area and is hence added to the
         * TextAreaDocument associated with the text area.
         */
        protected void textAreaContent(char[] data) {
            try {
<span class="nc" id="L3520">                textAreaDocument.insertString(textAreaDocument.getLength(), new String(data), null);</span>
<span class="nc" id="L3521">            } catch (BadLocationException e) {</span>
                // Should do something reasonable
<span class="nc" id="L3523">            }</span>
<span class="nc" id="L3524">        }</span>

        /**
         * Adds the given content that was encountered in a
         * PRE element.  This synthesizes lines to hold the
         * runs of text, and makes calls to addContent to
         * actually add the text.
         */
        protected void preContent(char[] data) {
<span class="nc" id="L3533">            int last = 0;</span>
<span class="nc bnc" id="L3534" title="All 2 branches missed.">            for (int i = 0; i &lt; data.length; i++) {</span>
<span class="nc bnc" id="L3535" title="All 2 branches missed.">                if (data[i] == '\n') {</span>
<span class="nc" id="L3536">                    addContent(data, last, i - last + 1);</span>
<span class="nc" id="L3537">                    blockClose(HTML.Tag.IMPLIED);</span>
<span class="nc" id="L3538">                    MutableAttributeSet a = new SimpleAttributeSet();</span>
<span class="nc" id="L3539">                    a.addAttribute(CSS.Attribute.WHITE_SPACE, &quot;pre&quot;);</span>
<span class="nc" id="L3540">                    blockOpen(HTML.Tag.IMPLIED, a);</span>
<span class="nc" id="L3541">                    last = i + 1;</span>
                }
            }
<span class="nc bnc" id="L3544" title="All 2 branches missed.">            if (last &lt; data.length) {</span>
<span class="nc" id="L3545">                addContent(data, last, data.length - last);</span>
            }
<span class="nc" id="L3547">        }</span>

        /**
         * Adds an instruction to the parse buffer to create a
         * block element with the given attributes.
         */
        protected void blockOpen(HTML.Tag t, MutableAttributeSet attr) {
<span class="nc bnc" id="L3554" title="All 2 branches missed.">            if (impliedP) {</span>
<span class="nc" id="L3555">                blockClose(HTML.Tag.IMPLIED);</span>
            }

<span class="nc" id="L3558">            inBlock++;</span>

<span class="nc bnc" id="L3560" title="All 2 branches missed.">            if (!canInsertTag(t, attr, true)) {</span>
<span class="nc" id="L3561">                return;</span>
            }
<span class="nc bnc" id="L3563" title="All 2 branches missed.">            if (attr.isDefined(IMPLIED)) {</span>
<span class="nc" id="L3564">                attr.removeAttribute(IMPLIED);</span>
            }
<span class="nc" id="L3566">            lastWasNewline = false;</span>
<span class="nc" id="L3567">            attr.addAttribute(StyleConstants.NameAttribute, t);</span>
<span class="nc" id="L3568">            ElementSpec es = new ElementSpec(</span>
<span class="nc" id="L3569">                attr.copyAttributes(), ElementSpec.StartTagType);</span>
<span class="nc" id="L3570">            parseBuffer.addElement(es);</span>
<span class="nc" id="L3571">        }</span>

        /**
         * Adds an instruction to the parse buffer to close out
         * a block element of the given type.
         */
        protected void blockClose(HTML.Tag t) {
<span class="nc" id="L3578">            inBlock--;</span>

<span class="nc bnc" id="L3580" title="All 2 branches missed.">            if (!foundInsertTag) {</span>
<span class="nc" id="L3581">                return;</span>
            }

            // Add a new line, if the last character wasn't one. This is
            // needed for proper positioning of the cursor. addContent
            // with true will force an implied paragraph to be generated if
            // there isn't one. This may result in a rather bogus structure
            // (perhaps a table with a child pargraph), but the paragraph
            // is needed for proper positioning and display.
<span class="nc bnc" id="L3590" title="All 2 branches missed.">            if(!lastWasNewline) {</span>
<span class="nc" id="L3591">                pushCharacterStyle();</span>
<span class="nc" id="L3592">                charAttr.addAttribute(IMPLIED_CR, Boolean.TRUE);</span>
<span class="nc" id="L3593">                addContent(NEWLINE, 0, 1, true);</span>
<span class="nc" id="L3594">                popCharacterStyle();</span>
<span class="nc" id="L3595">                lastWasNewline = true;</span>
            }

<span class="nc bnc" id="L3598" title="All 2 branches missed.">            if (impliedP) {</span>
<span class="nc" id="L3599">                impliedP = false;</span>
<span class="nc" id="L3600">                inParagraph = false;</span>
<span class="nc bnc" id="L3601" title="All 2 branches missed.">                if (t != HTML.Tag.IMPLIED) {</span>
<span class="nc" id="L3602">                    blockClose(HTML.Tag.IMPLIED);</span>
                }
            }
            // an open/close with no content will be removed, so we
            // add a space of content to keep the element being formed.
<span class="nc bnc" id="L3607" title="All 2 branches missed.">            ElementSpec prev = (parseBuffer.size() &gt; 0) ?</span>
<span class="nc" id="L3608">                parseBuffer.lastElement() : null;</span>
<span class="nc bnc" id="L3609" title="All 4 branches missed.">            if (prev != null &amp;&amp; prev.getType() == ElementSpec.StartTagType) {</span>
<span class="nc" id="L3610">                char[] one = new char[1];</span>
<span class="nc" id="L3611">                one[0] = ' ';</span>
<span class="nc" id="L3612">                addContent(one, 0, 1);</span>
            }
<span class="nc" id="L3614">            ElementSpec es = new ElementSpec(</span>
                null, ElementSpec.EndTagType);
<span class="nc" id="L3616">            parseBuffer.addElement(es);</span>
<span class="nc" id="L3617">        }</span>

        /**
         * Adds some text with the current character attributes.
         *
         * @param data the content to add
         * @param offs the initial offset
         * @param length the length
         */
        protected void addContent(char[] data, int offs, int length) {
<span class="nc" id="L3627">            addContent(data, offs, length, true);</span>
<span class="nc" id="L3628">        }</span>

        /**
         * Adds some text with the current character attributes.
         *
         * @param data the content to add
         * @param offs the initial offset
         * @param length the length
         * @param generateImpliedPIfNecessary whether to generate implied
         * paragraphs
         */
        protected void addContent(char[] data, int offs, int length,
                                  boolean generateImpliedPIfNecessary) {
<span class="nc bnc" id="L3641" title="All 2 branches missed.">            if (!foundInsertTag) {</span>
<span class="nc" id="L3642">                return;</span>
            }

<span class="nc bnc" id="L3645" title="All 6 branches missed.">            if (generateImpliedPIfNecessary &amp;&amp; (! inParagraph) &amp;&amp; (! inPre)) {</span>
<span class="nc" id="L3646">                blockOpen(HTML.Tag.IMPLIED, new SimpleAttributeSet());</span>
<span class="nc" id="L3647">                inParagraph = true;</span>
<span class="nc" id="L3648">                impliedP = true;</span>
            }
<span class="nc" id="L3650">            emptyAnchor = false;</span>
<span class="nc" id="L3651">            charAttr.addAttribute(StyleConstants.NameAttribute, HTML.Tag.CONTENT);</span>
<span class="nc" id="L3652">            AttributeSet a = charAttr.copyAttributes();</span>
<span class="nc" id="L3653">            ElementSpec es = new ElementSpec(</span>
                a, ElementSpec.ContentType, data, offs, length);
<span class="nc" id="L3655">            parseBuffer.addElement(es);</span>

<span class="nc bnc" id="L3657" title="All 2 branches missed.">            if (parseBuffer.size() &gt; threshold) {</span>
<span class="nc bnc" id="L3658" title="All 2 branches missed.">                if ( threshold &lt;= MaxThreshold ) {</span>
<span class="nc" id="L3659">                    threshold *= StepThreshold;</span>
                }
                try {
<span class="nc" id="L3662">                    flushBuffer(false);</span>
<span class="nc" id="L3663">                } catch (BadLocationException ble) {</span>
<span class="nc" id="L3664">                }</span>
            }
<span class="nc bnc" id="L3666" title="All 2 branches missed.">            if(length &gt; 0) {</span>
<span class="nc bnc" id="L3667" title="All 2 branches missed.">                lastWasNewline = (data[offs + length - 1] == '\n');</span>
            }
<span class="nc" id="L3669">        }</span>

        /**
         * Adds content that is basically specified entirely
         * in the attribute set.
         */
        protected void addSpecialElement(HTML.Tag t, MutableAttributeSet a) {
<span class="nc bnc" id="L3676" title="All 6 branches missed.">            if ((t != HTML.Tag.FRAME) &amp;&amp; (! inParagraph) &amp;&amp; (! inPre)) {</span>
<span class="nc" id="L3677">                nextTagAfterPImplied = t;</span>
<span class="nc" id="L3678">                blockOpen(HTML.Tag.IMPLIED, new SimpleAttributeSet());</span>
<span class="nc" id="L3679">                nextTagAfterPImplied = null;</span>
<span class="nc" id="L3680">                inParagraph = true;</span>
<span class="nc" id="L3681">                impliedP = true;</span>
            }
<span class="nc bnc" id="L3683" title="All 2 branches missed.">            if (!canInsertTag(t, a, t.isBlock())) {</span>
<span class="nc" id="L3684">                return;</span>
            }
<span class="nc bnc" id="L3686" title="All 2 branches missed.">            if (a.isDefined(IMPLIED)) {</span>
<span class="nc" id="L3687">                a.removeAttribute(IMPLIED);</span>
            }
<span class="nc" id="L3689">            emptyAnchor = false;</span>
<span class="nc" id="L3690">            a.addAttributes(charAttr);</span>
<span class="nc" id="L3691">            a.addAttribute(StyleConstants.NameAttribute, t);</span>
<span class="nc" id="L3692">            char[] one = new char[1];</span>
<span class="nc" id="L3693">            one[0] = ' ';</span>
<span class="nc" id="L3694">            ElementSpec es = new ElementSpec(</span>
<span class="nc" id="L3695">                a.copyAttributes(), ElementSpec.ContentType, one, 0, 1);</span>
<span class="nc" id="L3696">            parseBuffer.addElement(es);</span>
            // Set this to avoid generating a newline for frames, frames
            // shouldn't have any content, and shouldn't need a newline.
<span class="nc bnc" id="L3699" title="All 2 branches missed.">            if (t == HTML.Tag.FRAME) {</span>
<span class="nc" id="L3700">                lastWasNewline = true;</span>
            }
<span class="nc" id="L3702">        }</span>

        /**
         * Flushes the current parse buffer into the document.
         * @param endOfStream true if there is no more content to parser
         */
        void flushBuffer(boolean endOfStream) throws BadLocationException {
<span class="nc" id="L3709">            int oldLength = HTMLDocument.this.getLength();</span>
<span class="nc" id="L3710">            int size = parseBuffer.size();</span>
<span class="nc bnc" id="L3711" title="All 8 branches missed.">            if (endOfStream &amp;&amp; (insertTag != null || insertAfterImplied) &amp;&amp;</span>
                size &gt; 0) {
<span class="nc" id="L3713">                adjustEndSpecsForPartialInsert();</span>
<span class="nc" id="L3714">                size = parseBuffer.size();</span>
            }
<span class="nc" id="L3716">            ElementSpec[] spec = new ElementSpec[size];</span>
<span class="nc" id="L3717">            parseBuffer.copyInto(spec);</span>

<span class="nc bnc" id="L3719" title="All 6 branches missed.">            if (oldLength == 0 &amp;&amp; (insertTag == null &amp;&amp; !insertAfterImplied)) {</span>
<span class="nc" id="L3720">                create(spec);</span>
            } else {
<span class="nc" id="L3722">                insert(offset, spec);</span>
            }
<span class="nc" id="L3724">            parseBuffer.removeAllElements();</span>
<span class="nc" id="L3725">            offset += HTMLDocument.this.getLength() - oldLength;</span>
<span class="nc" id="L3726">            flushCount++;</span>
<span class="nc" id="L3727">        }</span>

        /**
         * This will be invoked for the last flush, if &lt;code&gt;insertTag&lt;/code&gt;
         * is non null.
         */
        private void adjustEndSpecsForPartialInsert() {
<span class="nc" id="L3734">            int size = parseBuffer.size();</span>
<span class="nc bnc" id="L3735" title="All 2 branches missed.">            if (insertTagDepthDelta &lt; 0) {</span>
                // When inserting via an insertTag, the depths (of the tree
                // being read in, and existing hierarchy) may not match up.
                // This attemps to clean it up.
<span class="nc" id="L3739">                int removeCounter = insertTagDepthDelta;</span>
<span class="nc bnc" id="L3740" title="All 4 branches missed.">                while (removeCounter &lt; 0 &amp;&amp; size &gt;= 0 &amp;&amp;</span>
<span class="nc" id="L3741">                        parseBuffer.elementAt(size - 1).</span>
<span class="nc bnc" id="L3742" title="All 2 branches missed.">                       getType() == ElementSpec.EndTagType) {</span>
<span class="nc" id="L3743">                    parseBuffer.removeElementAt(--size);</span>
<span class="nc" id="L3744">                    removeCounter++;</span>
                }
            }
<span class="nc bnc" id="L3747" title="All 6 branches missed.">            if (flushCount == 0 &amp;&amp; (!insertAfterImplied ||</span>
                                    !wantsTrailingNewline)) {
                // If this starts with content (or popDepth &gt; 0 &amp;&amp;
                // pushDepth &gt; 0) and ends with EndTagTypes, make sure
                // the last content isn't a \n, otherwise will end up with
                // an extra \n in the middle of content.
<span class="nc" id="L3753">                int index = 0;</span>
<span class="nc bnc" id="L3754" title="All 2 branches missed.">                if (pushDepth &gt; 0) {</span>
<span class="nc bnc" id="L3755" title="All 2 branches missed.">                    if (parseBuffer.elementAt(0).getType() ==</span>
                        ElementSpec.ContentType) {
<span class="nc" id="L3757">                        index++;</span>
                    }
                }
<span class="nc" id="L3760">                index += (popDepth + pushDepth);</span>
<span class="nc" id="L3761">                int cCount = 0;</span>
<span class="nc" id="L3762">                int cStart = index;</span>
<span class="nc bnc" id="L3763" title="All 2 branches missed.">                while (index &lt; size &amp;&amp; parseBuffer.elementAt</span>
<span class="nc bnc" id="L3764" title="All 2 branches missed.">                        (index).getType() == ElementSpec.ContentType) {</span>
<span class="nc" id="L3765">                    index++;</span>
<span class="nc" id="L3766">                    cCount++;</span>
                }
<span class="nc bnc" id="L3768" title="All 2 branches missed.">                if (cCount &gt; 1) {</span>
<span class="nc bnc" id="L3769" title="All 2 branches missed.">                    while (index &lt; size &amp;&amp; parseBuffer.elementAt</span>
<span class="nc bnc" id="L3770" title="All 2 branches missed.">                            (index).getType() == ElementSpec.EndTagType) {</span>
<span class="nc" id="L3771">                        index++;</span>
                    }
<span class="nc bnc" id="L3773" title="All 2 branches missed.">                    if (index == size) {</span>
<span class="nc" id="L3774">                        char[] lastText = parseBuffer.elementAt</span>
<span class="nc" id="L3775">                                (cStart + cCount - 1).getArray();</span>
<span class="nc bnc" id="L3776" title="All 4 branches missed.">                        if (lastText.length == 1 &amp;&amp; lastText[0] == NEWLINE[0]){</span>
<span class="nc" id="L3777">                            index = cStart + cCount - 1;</span>
<span class="nc bnc" id="L3778" title="All 2 branches missed.">                            while (size &gt; index) {</span>
<span class="nc" id="L3779">                                parseBuffer.removeElementAt(--size);</span>
                            }
                        }
                    }
                }
            }
<span class="nc bnc" id="L3785" title="All 2 branches missed.">            if (wantsTrailingNewline) {</span>
                // Make sure there is in fact a newline
<span class="nc bnc" id="L3787" title="All 2 branches missed.">                for (int counter = parseBuffer.size() - 1; counter &gt;= 0;</span>
<span class="nc" id="L3788">                                   counter--) {</span>
<span class="nc" id="L3789">                    ElementSpec spec = parseBuffer.elementAt(counter);</span>
<span class="nc bnc" id="L3790" title="All 2 branches missed.">                    if (spec.getType() == ElementSpec.ContentType) {</span>
<span class="nc bnc" id="L3791" title="All 2 branches missed.">                        if (spec.getArray()[spec.getLength() - 1] != '\n') {</span>
<span class="nc" id="L3792">                            SimpleAttributeSet attrs =new SimpleAttributeSet();</span>

<span class="nc" id="L3794">                            attrs.addAttribute(StyleConstants.NameAttribute,</span>
                                               HTML.Tag.CONTENT);
<span class="nc" id="L3796">                            parseBuffer.insertElementAt(new ElementSpec(</span>
                                    attrs,
<span class="nc" id="L3798">                                    ElementSpec.ContentType, NEWLINE, 0, 1),</span>
                                    counter + 1);
<span class="nc" id="L3800">                        }</span>
                        break;
                    }
                }
            }
<span class="nc" id="L3805">        }</span>

        /**
         * Adds the CSS rules in &lt;code&gt;rules&lt;/code&gt;.
         */
        void addCSSRules(String rules) {
<span class="nc" id="L3811">            StyleSheet ss = getStyleSheet();</span>
<span class="nc" id="L3812">            ss.addRule(rules);</span>
<span class="nc" id="L3813">        }</span>

        /**
         * Adds the CSS stylesheet at &lt;code&gt;href&lt;/code&gt; to the known list
         * of stylesheets.
         */
        void linkCSSStyleSheet(String href) {
            URL url;
            try {
<span class="nc" id="L3822">                url = new URL(base, href);</span>
<span class="nc" id="L3823">            } catch (MalformedURLException mfe) {</span>
                try {
<span class="nc" id="L3825">                    url = new URL(href);</span>
<span class="nc" id="L3826">                } catch (MalformedURLException mfe2) {</span>
<span class="nc" id="L3827">                    url = null;</span>
<span class="nc" id="L3828">                }</span>
<span class="nc" id="L3829">            }</span>
<span class="nc bnc" id="L3830" title="All 2 branches missed.">            if (url != null) {</span>
<span class="nc" id="L3831">                getStyleSheet().importStyleSheet(url);</span>
            }
<span class="nc" id="L3833">        }</span>

        /**
         * Returns true if can insert starting at &lt;code&gt;t&lt;/code&gt;. This
         * will return false if the insert tag is set, and hasn't been found
         * yet.
         */
        private boolean canInsertTag(HTML.Tag t, AttributeSet attr,
                                     boolean isBlockTag) {
<span class="nc bnc" id="L3842" title="All 2 branches missed.">            if (!foundInsertTag) {</span>
<span class="nc bnc" id="L3843" title="All 6 branches missed.">                boolean needPImplied = ((t == HTML.Tag.IMPLIED)</span>
                                                          &amp;&amp; (!inParagraph)
                                                          &amp;&amp; (!inPre));
<span class="nc bnc" id="L3846" title="All 4 branches missed.">                if (needPImplied &amp;&amp; (nextTagAfterPImplied != null)) {</span>

                    /*
                     * If insertTag == null then just proceed to
                     * foundInsertTag() call below and return true.
                     */
<span class="nc bnc" id="L3852" title="All 2 branches missed.">                    if (insertTag != null) {</span>
<span class="nc" id="L3853">                        boolean nextTagIsInsertTag =</span>
<span class="nc" id="L3854">                                isInsertTag(nextTagAfterPImplied);</span>
<span class="nc bnc" id="L3855" title="All 4 branches missed.">                        if ( (! nextTagIsInsertTag) || (! insertInsertTag) ) {</span>
<span class="nc" id="L3856">                            return false;</span>
                        }
<span class="nc" id="L3858">                    }</span>
                    /*
                     *  Proceed to foundInsertTag() call...
                     */
<span class="nc bnc" id="L3862" title="All 8 branches missed.">                 } else if ((insertTag != null &amp;&amp; !isInsertTag(t))</span>
                               || (insertAfterImplied
                                    &amp;&amp; (attr == null
<span class="nc bnc" id="L3865" title="All 4 branches missed.">                                        || attr.isDefined(IMPLIED)</span>
                                        || t == HTML.Tag.IMPLIED
                                       )
                                   )
                           ) {
<span class="nc" id="L3870">                    return false;</span>
                }

                // Allow the insert if t matches the insert tag, or
                // insertAfterImplied is true and the element is implied.
<span class="nc" id="L3875">                foundInsertTag(isBlockTag);</span>
<span class="nc bnc" id="L3876" title="All 2 branches missed.">                if (!insertInsertTag) {</span>
<span class="nc" id="L3877">                    return false;</span>
                }
            }
<span class="nc" id="L3880">            return true;</span>
        }

        private boolean isInsertTag(HTML.Tag tag) {
<span class="nc bnc" id="L3884" title="All 2 branches missed.">            return (insertTag == tag);</span>
        }

        private void foundInsertTag(boolean isBlockTag) {
<span class="nc" id="L3888">            foundInsertTag = true;</span>
<span class="nc bnc" id="L3889" title="All 6 branches missed.">            if (!insertAfterImplied &amp;&amp; (popDepth &gt; 0 || pushDepth &gt; 0)) {</span>
                try {
<span class="nc bnc" id="L3891" title="All 4 branches missed.">                    if (offset == 0 || !getText(offset - 1, 1).equals(&quot;\n&quot;)) {</span>
                        // Need to insert a newline.
<span class="nc" id="L3893">                        AttributeSet newAttrs = null;</span>
<span class="nc" id="L3894">                        boolean joinP = true;</span>

<span class="nc bnc" id="L3896" title="All 2 branches missed.">                        if (offset != 0) {</span>
                            // Determine if we can use JoinPrevious, we can't
                            // if the Element has some attributes that are
                            // not meant to be duplicated.
<span class="nc" id="L3900">                            Element charElement = getCharacterElement</span>
<span class="nc" id="L3901">                                                    (offset - 1);</span>
<span class="nc" id="L3902">                            AttributeSet attrs = charElement.getAttributes();</span>

<span class="nc bnc" id="L3904" title="All 2 branches missed.">                            if (attrs.isDefined(StyleConstants.</span>
                                                ComposedTextAttribute)) {
<span class="nc" id="L3906">                                joinP = false;</span>
                            }
                            else {
<span class="nc" id="L3909">                                Object name = attrs.getAttribute</span>
<span class="nc" id="L3910">                                              (StyleConstants.NameAttribute);</span>
<span class="nc bnc" id="L3911" title="All 2 branches missed.">                                if (name instanceof HTML.Tag) {</span>
<span class="nc" id="L3912">                                    HTML.Tag tag = (HTML.Tag)name;</span>
<span class="nc bnc" id="L3913" title="All 8 branches missed.">                                    if (tag == HTML.Tag.IMG ||</span>
                                        tag == HTML.Tag.HR ||
                                        tag == HTML.Tag.COMMENT ||
                                        (tag instanceof HTML.UnknownTag)) {
<span class="nc" id="L3917">                                        joinP = false;</span>
                                    }
                                }
                            }
                        }
<span class="nc bnc" id="L3922" title="All 2 branches missed.">                        if (!joinP) {</span>
                            // If not joining with the previous element, be
                            // sure and set the name (otherwise it will be
                            // inherited).
<span class="nc" id="L3926">                            newAttrs = new SimpleAttributeSet();</span>
<span class="nc" id="L3927">                            ((SimpleAttributeSet)newAttrs).addAttribute</span>
<span class="nc" id="L3928">                                              (StyleConstants.NameAttribute,</span>
                                               HTML.Tag.CONTENT);
                        }
<span class="nc" id="L3931">                        ElementSpec es = new ElementSpec(newAttrs,</span>
<span class="nc" id="L3932">                                     ElementSpec.ContentType, NEWLINE, 0,</span>
<span class="nc" id="L3933">                                     NEWLINE.length);</span>
<span class="nc bnc" id="L3934" title="All 2 branches missed.">                        if (joinP) {</span>
<span class="nc" id="L3935">                            es.setDirection(ElementSpec.</span>
                                            JoinPreviousDirection);
                        }
<span class="nc" id="L3938">                        parseBuffer.addElement(es);</span>
                    }
<span class="nc" id="L3940">                } catch (BadLocationException ble) {}</span>
            }
            // pops
<span class="nc bnc" id="L3943" title="All 2 branches missed.">            for (int counter = 0; counter &lt; popDepth; counter++) {</span>
<span class="nc" id="L3944">                parseBuffer.addElement(new ElementSpec(null, ElementSpec.</span>
                                                       EndTagType));
            }
            // pushes
<span class="nc bnc" id="L3948" title="All 2 branches missed.">            for (int counter = 0; counter &lt; pushDepth; counter++) {</span>
<span class="nc" id="L3949">                ElementSpec es = new ElementSpec(null, ElementSpec.</span>
                                                 StartTagType);
<span class="nc" id="L3951">                es.setDirection(ElementSpec.JoinNextDirection);</span>
<span class="nc" id="L3952">                parseBuffer.addElement(es);</span>
            }
<span class="nc" id="L3954">            insertTagDepthDelta = depthTo(Math.max(0, offset - 1)) -</span>
                                  popDepth + pushDepth - inBlock;
<span class="nc bnc" id="L3956" title="All 2 branches missed.">            if (isBlockTag) {</span>
                // A start spec will be added (for this tag), so we account
                // for it here.
<span class="nc" id="L3959">                insertTagDepthDelta++;</span>
            }
            else {
                // An implied paragraph close (end spec) is going to be added,
                // so we account for it here.
<span class="nc" id="L3964">                insertTagDepthDelta--;</span>
<span class="nc" id="L3965">                inParagraph = true;</span>
<span class="nc" id="L3966">                lastWasNewline = false;</span>
            }
<span class="nc" id="L3968">        }</span>

        /**
         * This is set to true when and end is invoked for &lt;html&gt;.
         */
        private boolean receivedEndHTML;
        /** Number of times &lt;code&gt;flushBuffer&lt;/code&gt; has been invoked. */
        private int flushCount;
        /** If true, behavior is similar to insertTag, but instead of
         * waiting for insertTag will wait for first Element without
         * an 'implied' attribute and begin inserting then. */
        private boolean insertAfterImplied;
        /** This is only used if insertAfterImplied is true. If false, only
         * inserting content, and there is a trailing newline it is removed. */
        private boolean wantsTrailingNewline;
        int threshold;
        int offset;
<span class="nc" id="L3985">        boolean inParagraph = false;</span>
<span class="nc" id="L3986">        boolean impliedP = false;</span>
<span class="nc" id="L3987">        boolean inPre = false;</span>
<span class="nc" id="L3988">        boolean inTextArea = false;</span>
<span class="nc" id="L3989">        TextAreaDocument textAreaDocument = null;</span>
<span class="nc" id="L3990">        boolean inTitle = false;</span>
<span class="nc" id="L3991">        boolean lastWasNewline = true;</span>
        boolean emptyAnchor;
        /** True if (!emptyDocument &amp;&amp; insertTag == null), this is used so
         * much it is cached. */
        boolean midInsert;
        /** True when the body has been encountered. */
        boolean inBody;
        /** If non null, gives parent Tag that insert is to happen at. */
        HTML.Tag insertTag;
        /** If true, the insertTag is inserted, otherwise elements after
         * the insertTag is found are inserted. */
        boolean insertInsertTag;
        /** Set to true when insertTag has been found. */
        boolean foundInsertTag;
        /** When foundInsertTag is set to true, this will be updated to
         * reflect the delta between the two structures. That is, it
         * will be the depth the inserts are happening at minus the
         * depth of the tags being passed in. A value of 0 (the common
         * case) indicates the structures match, a value greater than 0 indicates
         * the insert is happening at a deeper depth than the stream is
         * parsing, and a value less than 0 indicates the insert is happening earlier
         * in the tree that the parser thinks and that we will need to remove
         * EndTagType specs in the flushBuffer method.
         */
        int insertTagDepthDelta;
        /** How many parents to ascend before insert new elements. */
        int popDepth;
        /** How many parents to descend (relative to popDepth) before
         * inserting. */
        int pushDepth;
        /** Last Map that was encountered. */
        Map lastMap;
        /** Set to true when a style element is encountered. */
<span class="nc" id="L4024">        boolean inStyle = false;</span>
        /** Name of style to use. Obtained from Meta tag. */
        String defaultStyle;
        /** Vector describing styles that should be include. Will consist
         * of a bunch of HTML.Tags, which will either be:
         * &lt;p&gt;LINK: in which case it is followed by an AttributeSet
         * &lt;p&gt;STYLE: in which case the following element is a String
         * indicating the type (may be null), and the elements following
         * it until the next HTML.Tag are the rules as Strings.
         */
        Vector&lt;Object&gt; styles;
        /** True if inside the head tag. */
<span class="nc" id="L4036">        boolean inHead = false;</span>
        /** Set to true if the style language is text/css. Since this is
         * used alot, it is cached. */
        boolean isStyleCSS;
        /** True if inserting into an empty document. */
        boolean emptyDocument;
        /** Attributes from a style Attribute. */
        AttributeSet styleAttributes;

        /**
         * Current option, if in an option element (needed to
         * load the label.
         */
        Option option;

<span class="nc" id="L4051">        protected Vector&lt;ElementSpec&gt; parseBuffer = new Vector&lt;ElementSpec&gt;();</span>
<span class="nc" id="L4052">        protected MutableAttributeSet charAttr = new TaggedAttributeSet();</span>
<span class="nc" id="L4053">        Stack&lt;AttributeSet&gt; charAttrStack = new Stack&lt;AttributeSet&gt;();</span>
        Hashtable&lt;HTML.Tag, TagAction&gt; tagMap;
<span class="nc" id="L4055">        int inBlock = 0;</span>

        /**
         * This attribute is sometimes used to refer to next tag
         * to be handled after p-implied when the latter is
         * the current tag which is being handled.
         */
<span class="nc" id="L4062">        private HTML.Tag nextTagAfterPImplied = null;</span>
    }


    /**
     * Used by StyleSheet to determine when to avoid removing HTML.Tags
     * matching StyleConstants.
     */
    static class TaggedAttributeSet extends SimpleAttributeSet {
        TaggedAttributeSet() {
<span class="nc" id="L4072">            super();</span>
<span class="nc" id="L4073">        }</span>
    }


    /**
     * An element that represents a chunk of text that has
     * a set of HTML character level attributes assigned to
     * it.
     */
    public class RunElement extends LeafElement {

        /**
         * Constructs an element that represents content within the
         * document (has no children).
         *
         * @param parent  the parent element
         * @param a       the element attributes
         * @param offs0   the start offset (must be at least 0)
         * @param offs1   the end offset (must be at least offs0)
         * @since 1.4
         */
<span class="nc" id="L4094">        public RunElement(Element parent, AttributeSet a, int offs0, int offs1) {</span>
<span class="nc" id="L4095">            super(parent, a, offs0, offs1);</span>
<span class="nc" id="L4096">        }</span>

        /**
         * Gets the name of the element.
         *
         * @return the name, null if none
         */
        public String getName() {
<span class="nc" id="L4104">            Object o = getAttribute(StyleConstants.NameAttribute);</span>
<span class="nc bnc" id="L4105" title="All 2 branches missed.">            if (o != null) {</span>
<span class="nc" id="L4106">                return o.toString();</span>
            }
<span class="nc" id="L4108">            return super.getName();</span>
        }

        /**
         * Gets the resolving parent.  HTML attributes are not inherited
         * at the model level so we override this to return null.
         *
         * @return null, there are none
         * @see AttributeSet#getResolveParent
         */
        public AttributeSet getResolveParent() {
<span class="nc" id="L4119">            return null;</span>
        }
    }

    /**
     * An element that represents a structural &lt;em&gt;block&lt;/em&gt; of
     * HTML.
     */
    public class BlockElement extends BranchElement {

        /**
         * Constructs a composite element that initially contains
         * no children.
         *
         * @param parent  the parent element
         * @param a       the attributes for the element
         * @since 1.4
         */
<span class="nc" id="L4137">        public BlockElement(Element parent, AttributeSet a) {</span>
<span class="nc" id="L4138">            super(parent, a);</span>
<span class="nc" id="L4139">        }</span>

        /**
         * Gets the name of the element.
         *
         * @return the name, null if none
         */
        public String getName() {
<span class="nc" id="L4147">            Object o = getAttribute(StyleConstants.NameAttribute);</span>
<span class="nc bnc" id="L4148" title="All 2 branches missed.">            if (o != null) {</span>
<span class="nc" id="L4149">                return o.toString();</span>
            }
<span class="nc" id="L4151">            return super.getName();</span>
        }

        /**
         * Gets the resolving parent.  HTML attributes are not inherited
         * at the model level so we override this to return null.
         *
         * @return null, there are none
         * @see AttributeSet#getResolveParent
         */
        public AttributeSet getResolveParent() {
<span class="nc" id="L4162">            return null;</span>
        }

    }


    /**
     * Document that allows you to set the maximum length of the text.
     */
    private static class FixedLengthDocument extends PlainDocument {
        private int maxLength;

<span class="nc" id="L4174">        public FixedLengthDocument(int maxLength) {</span>
<span class="nc" id="L4175">            this.maxLength = maxLength;</span>
<span class="nc" id="L4176">        }</span>

        public void insertString(int offset, String str, AttributeSet a)
            throws BadLocationException {
<span class="nc bnc" id="L4180" title="All 4 branches missed.">            if (str != null &amp;&amp; str.length() + getLength() &lt;= maxLength) {</span>
<span class="nc" id="L4181">                super.insertString(offset, str, a);</span>
            }
<span class="nc" id="L4183">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>