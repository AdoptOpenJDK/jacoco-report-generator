<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MinimalHTMLWriter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text.html</a> &gt; <span class="el_source">MinimalHTMLWriter.java</span></div><h1>MinimalHTMLWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.text.html;

import java.io.Writer;
import java.io.IOException;
import java.util.*;
import java.awt.Color;
import javax.swing.text.*;

/**
 * MinimalHTMLWriter is a fallback writer used by the
 * HTMLEditorKit to write out HTML for a document that
 * is a not produced by the EditorKit.
 *
 * The format for the document is:
 * &lt;pre&gt;
 * &amp;lt;html&amp;gt;
 *   &amp;lt;head&amp;gt;
 *     &amp;lt;style&amp;gt;
 *        &amp;lt;!-- list of named styles
 *         p.normal {
 *            font-family: SansSerif;
 *            margin-height: 0;
 *            font-size: 14
 *         }
 *        --&amp;gt;
 *      &amp;lt;/style&amp;gt;
 *   &amp;lt;/head&amp;gt;
 *   &amp;lt;body&amp;gt;
 *    &amp;lt;p style=normal&amp;gt;
 *        &lt;b&gt;Bold, italic, and underline attributes
 *        of the run are emitted as HTML tags.
 *        The remaining attributes are emitted as
 *        part of the style attribute of a &amp;lt;span&amp;gt; tag.
 *        The syntax is similar to inline styles.&lt;/b&gt;
 *    &amp;lt;/p&amp;gt;
 *   &amp;lt;/body&amp;gt;
 * &amp;lt;/html&amp;gt;
 * &lt;/pre&gt;
 *
 * @author Sunita Mani
 */

public class MinimalHTMLWriter extends AbstractWriter {

    /**
     * These static finals are used to
     * tweak and query the fontMask about which
     * of these tags need to be generated or
     * terminated.
     */
    private static final int BOLD = 0x01;
    private static final int ITALIC = 0x02;
    private static final int UNDERLINE = 0x04;

    // Used to map StyleConstants to CSS.
<span class="nc" id="L81">    private static final CSS css = new CSS();</span>

<span class="nc" id="L83">    private int fontMask = 0;</span>

<span class="nc" id="L85">    int startOffset = 0;</span>
<span class="nc" id="L86">    int endOffset = 0;</span>

    /**
     * Stores the attributes of the previous run.
     * Used to compare with the current run's
     * attributeset.  If identical, then a
     * &amp;lt;span&amp;gt; tag is not emitted.
     */
    private AttributeSet fontAttributes;

    /**
     * Maps from style name as held by the Document, to the archived
     * style name (style name written out). These may differ.
     */
    private Hashtable&lt;String, String&gt; styleNameMapping;

    /**
     * Creates a new MinimalHTMLWriter.
     *
     * @param w  Writer
     * @param doc StyledDocument
     *
     */
    public MinimalHTMLWriter(Writer w, StyledDocument doc) {
<span class="nc" id="L110">        super(w, doc);</span>
<span class="nc" id="L111">    }</span>

    /**
     * Creates a new MinimalHTMLWriter.
     *
     * @param w  Writer
     * @param doc StyledDocument
     * @param pos The location in the document to fetch the
     *   content.
     * @param len The amount to write out.
     *
     */
    public MinimalHTMLWriter(Writer w, StyledDocument doc, int pos, int len) {
<span class="nc" id="L124">        super(w, doc, pos, len);</span>
<span class="nc" id="L125">    }</span>

    /**
     * Generates HTML output
     * from a StyledDocument.
     *
     * @exception IOException on any I/O error
     * @exception BadLocationException if pos represents an invalid
     *            location within the document.
     *
     */
    public void write() throws IOException, BadLocationException {
<span class="nc" id="L137">        styleNameMapping = new Hashtable&lt;String, String&gt;();</span>
<span class="nc" id="L138">        writeStartTag(&quot;&lt;html&gt;&quot;);</span>
<span class="nc" id="L139">        writeHeader();</span>
<span class="nc" id="L140">        writeBody();</span>
<span class="nc" id="L141">        writeEndTag(&quot;&lt;/html&gt;&quot;);</span>
<span class="nc" id="L142">    }</span>


    /**
     * Writes out all the attributes for the
     * following types:
     *  StyleConstants.ParagraphConstants,
     *  StyleConstants.CharacterConstants,
     *  StyleConstants.FontConstants,
     *  StyleConstants.ColorConstants.
     * The attribute name and value are separated by a colon.
     * Each pair is separated by a semicolon.
     *
     * @exception IOException on any I/O error
     */
    protected void writeAttributes(AttributeSet attr) throws IOException {
<span class="nc" id="L158">        Enumeration attributeNames = attr.getAttributeNames();</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        while (attributeNames.hasMoreElements()) {</span>
<span class="nc" id="L160">            Object name = attributeNames.nextElement();</span>
<span class="nc bnc" id="L161" title="All 8 branches missed.">            if ((name instanceof StyleConstants.ParagraphConstants) ||</span>
                (name instanceof StyleConstants.CharacterConstants) ||
                (name instanceof StyleConstants.FontConstants) ||
                (name instanceof StyleConstants.ColorConstants)) {
<span class="nc" id="L165">                indent();</span>
<span class="nc" id="L166">                write(name.toString());</span>
<span class="nc" id="L167">                write(':');</span>
<span class="nc" id="L168">                write(css.styleConstantsValueToCSSValue</span>
<span class="nc" id="L169">                      ((StyleConstants)name, attr.getAttribute(name)).</span>
<span class="nc" id="L170">                      toString());</span>
<span class="nc" id="L171">                write(';');</span>
<span class="nc" id="L172">                write(NEWLINE);</span>
            }
<span class="nc" id="L174">        }</span>
<span class="nc" id="L175">    }</span>


    /**
     * Writes out text.
     *
     * @exception IOException on any I/O error
     */
    protected void text(Element elem) throws IOException, BadLocationException {
<span class="nc" id="L184">        String contentStr = getText(elem);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if ((contentStr.length() &gt; 0) &amp;&amp;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            (contentStr.charAt(contentStr.length()-1) == NEWLINE)) {</span>
<span class="nc" id="L187">            contentStr = contentStr.substring(0, contentStr.length()-1);</span>
        }
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (contentStr.length() &gt; 0) {</span>
<span class="nc" id="L190">            write(contentStr);</span>
        }
<span class="nc" id="L192">    }</span>

    /**
     * Writes out a start tag appropriately
     * indented.  Also increments the indent level.
     *
     * @exception IOException on any I/O error
     */
    protected void writeStartTag(String tag) throws IOException {
<span class="nc" id="L201">        indent();</span>
<span class="nc" id="L202">        write(tag);</span>
<span class="nc" id="L203">        write(NEWLINE);</span>
<span class="nc" id="L204">        incrIndent();</span>
<span class="nc" id="L205">    }</span>


    /**
     * Writes out an end tag appropriately
     * indented.  Also decrements the indent level.
     *
     * @exception IOException on any I/O error
     */
    protected void writeEndTag(String endTag) throws IOException {
<span class="nc" id="L215">        decrIndent();</span>
<span class="nc" id="L216">        indent();</span>
<span class="nc" id="L217">        write(endTag);</span>
<span class="nc" id="L218">        write(NEWLINE);</span>
<span class="nc" id="L219">    }</span>


    /**
     * Writes out the &amp;lt;head&amp;gt; and &amp;lt;style&amp;gt;
     * tags, and then invokes writeStyles() to write
     * out all the named styles as the content of the
     * &amp;lt;style&amp;gt; tag.  The content is surrounded by
     * valid HTML comment markers to ensure that the
     * document is viewable in applications/browsers
     * that do not support the tag.
     *
     * @exception IOException on any I/O error
     */
    protected void writeHeader() throws IOException {
<span class="nc" id="L234">        writeStartTag(&quot;&lt;head&gt;&quot;);</span>
<span class="nc" id="L235">        writeStartTag(&quot;&lt;style&gt;&quot;);</span>
<span class="nc" id="L236">        writeStartTag(&quot;&lt;!--&quot;);</span>
<span class="nc" id="L237">        writeStyles();</span>
<span class="nc" id="L238">        writeEndTag(&quot;--&gt;&quot;);</span>
<span class="nc" id="L239">        writeEndTag(&quot;&lt;/style&gt;&quot;);</span>
<span class="nc" id="L240">        writeEndTag(&quot;&lt;/head&gt;&quot;);</span>
<span class="nc" id="L241">    }</span>



    /**
     * Writes out all the named styles as the
     * content of the &amp;lt;style&amp;gt; tag.
     *
     * @exception IOException on any I/O error
     */
    protected void writeStyles() throws IOException {
        /*
         *  Access to DefaultStyledDocument done to workaround
         *  a missing API in styled document to access the
         *  stylenames.
         */
<span class="nc" id="L257">        DefaultStyledDocument styledDoc =  ((DefaultStyledDocument)getDocument());</span>
<span class="nc" id="L258">        Enumeration styleNames = styledDoc.getStyleNames();</span>

<span class="nc bnc" id="L260" title="All 2 branches missed.">        while (styleNames.hasMoreElements()) {</span>
<span class="nc" id="L261">            Style s = styledDoc.getStyle((String)styleNames.nextElement());</span>

            /** PENDING: Once the name attribute is removed
                from the list we check check for 0. **/
<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (s.getAttributeCount() == 1 &amp;&amp;</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">                s.isDefined(StyleConstants.NameAttribute)) {</span>
<span class="nc" id="L267">                continue;</span>
            }
<span class="nc" id="L269">            indent();</span>
<span class="nc" id="L270">            write(&quot;p.&quot; + addStyleName(s.getName()));</span>
<span class="nc" id="L271">            write(&quot; {\n&quot;);</span>
<span class="nc" id="L272">            incrIndent();</span>
<span class="nc" id="L273">            writeAttributes(s);</span>
<span class="nc" id="L274">            decrIndent();</span>
<span class="nc" id="L275">            indent();</span>
<span class="nc" id="L276">            write(&quot;}\n&quot;);</span>
<span class="nc" id="L277">        }</span>
<span class="nc" id="L278">    }</span>


    /**
     * Iterates over the elements in the document
     * and processes elements based on whether they are
     * branch elements or leaf elements.  This method specially handles
     * leaf elements that are text.
     *
     * @exception IOException on any I/O error
     */
    protected void writeBody() throws IOException, BadLocationException {
<span class="nc" id="L290">        ElementIterator it = getElementIterator();</span>

        /*
          This will be a section element for a styled document.
          We represent this element in HTML as the body tags.
          Therefore we ignore it.
         */
<span class="nc" id="L297">        it.current();</span>

        Element next;

<span class="nc" id="L301">        writeStartTag(&quot;&lt;body&gt;&quot;);</span>

<span class="nc" id="L303">        boolean inContent = false;</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">        while((next = it.next()) != null) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (!inRange(next)) {</span>
<span class="nc" id="L307">                continue;</span>
            }
<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (next instanceof AbstractDocument.BranchElement) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                if (inContent) {</span>
<span class="nc" id="L311">                    writeEndParagraph();</span>
<span class="nc" id="L312">                    inContent = false;</span>
<span class="nc" id="L313">                    fontMask = 0;</span>
                }
<span class="nc" id="L315">                writeStartParagraph(next);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            } else if (isText(next)) {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                writeContent(next, !inContent);</span>
<span class="nc" id="L318">                inContent = true;</span>
            } else {
<span class="nc" id="L320">                writeLeaf(next);</span>
<span class="nc" id="L321">                inContent = true;</span>
            }
        }
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (inContent) {</span>
<span class="nc" id="L325">            writeEndParagraph();</span>
        }
<span class="nc" id="L327">        writeEndTag(&quot;&lt;/body&gt;&quot;);</span>
<span class="nc" id="L328">    }</span>


    /**
     * Emits an end tag for a &amp;lt;p&amp;gt;
     * tag.  Before writing out the tag, this method ensures
     * that all other tags that have been opened are
     * appropriately closed off.
     *
     * @exception IOException on any I/O error
     */
    protected void writeEndParagraph() throws IOException {
<span class="nc" id="L340">        writeEndMask(fontMask);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (inFontTag()) {</span>
<span class="nc" id="L342">            endSpanTag();</span>
        } else {
<span class="nc" id="L344">            write(NEWLINE);</span>
        }
<span class="nc" id="L346">        writeEndTag(&quot;&lt;/p&gt;&quot;);</span>
<span class="nc" id="L347">    }</span>


    /**
     * Emits the start tag for a paragraph. If
     * the paragraph has a named style associated with it,
     * then this method also generates a class attribute for the
     * &amp;lt;p&amp;gt; tag and sets its value to be the name of the
     * style.
     *
     * @exception IOException on any I/O error
     */
    protected void writeStartParagraph(Element elem) throws IOException {
<span class="nc" id="L360">        AttributeSet attr = elem.getAttributes();</span>
<span class="nc" id="L361">        Object resolveAttr = attr.getAttribute(StyleConstants.ResolveAttribute);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (resolveAttr instanceof StyleContext.NamedStyle) {</span>
<span class="nc" id="L363">            writeStartTag(&quot;&lt;p class=&quot; + mapStyleName(((StyleContext.NamedStyle)resolveAttr).getName()) + &quot;&gt;&quot;);</span>
        } else {
<span class="nc" id="L365">            writeStartTag(&quot;&lt;p&gt;&quot;);</span>
        }
<span class="nc" id="L367">    }</span>


    /**
     * Responsible for writing out other non-text leaf
     * elements.
     *
     * @exception IOException on any I/O error
     */
    protected void writeLeaf(Element elem) throws IOException {
<span class="nc" id="L377">        indent();</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (elem.getName() == StyleConstants.IconElementName) {</span>
<span class="nc" id="L379">            writeImage(elem);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        } else if (elem.getName() == StyleConstants.ComponentElementName) {</span>
<span class="nc" id="L381">            writeComponent(elem);</span>
        }
<span class="nc" id="L383">    }</span>


    /**
     * Responsible for handling Icon Elements;
     * deliberately unimplemented.  How to implement this method is
     * an issue of policy.  For example, if you're generating
     * an &amp;lt;img&amp;gt; tag, how should you
     * represent the src attribute (the location of the image)?
     * In certain cases it could be a URL, in others it could
     * be read from a stream.
     *
     * @param elem element of type StyleConstants.IconElementName
     */
    protected void writeImage(Element elem) throws IOException {
<span class="nc" id="L398">    }</span>


    /**
     * Responsible for handling Component Elements;
     * deliberately unimplemented.
     * How this method is implemented is a matter of policy.
     */
    protected void writeComponent(Element elem) throws IOException {
<span class="nc" id="L407">    }</span>


    /**
     * Returns true if the element is a text element.
     *
     */
    protected boolean isText(Element elem) {
<span class="nc bnc" id="L415" title="All 2 branches missed.">        return (elem.getName() == AbstractDocument.ContentElementName);</span>
    }


    /**
     * Writes out the attribute set
     * in an HTML-compliant manner.
     *
     * @exception IOException on any I/O error
     * @exception BadLocationException if pos represents an invalid
     *            location within the document.
     */
    protected void writeContent(Element elem,  boolean needsIndenting)
        throws IOException, BadLocationException {

<span class="nc" id="L430">        AttributeSet attr = elem.getAttributes();</span>
<span class="nc" id="L431">        writeNonHTMLAttributes(attr);</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (needsIndenting) {</span>
<span class="nc" id="L433">            indent();</span>
        }
<span class="nc" id="L435">        writeHTMLTags(attr);</span>
<span class="nc" id="L436">        text(elem);</span>
<span class="nc" id="L437">    }</span>


    /**
     * Generates
     * bold &amp;lt;b&amp;gt;, italic &amp;lt;i&amp;gt;, and &amp;lt;u&amp;gt; tags for the
     * text based on its attribute settings.
     *
     * @exception IOException on any I/O error
     */

    protected void writeHTMLTags(AttributeSet attr) throws IOException {

<span class="nc" id="L450">        int oldMask = fontMask;</span>
<span class="nc" id="L451">        setFontMask(attr);</span>

<span class="nc" id="L453">        int endMask = 0;</span>
<span class="nc" id="L454">        int startMask = 0;</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if ((oldMask &amp; BOLD) != 0) {</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            if ((fontMask &amp; BOLD) == 0) {</span>
<span class="nc" id="L457">                endMask |= BOLD;</span>
            }
<span class="nc bnc" id="L459" title="All 2 branches missed.">        } else if ((fontMask &amp; BOLD) != 0) {</span>
<span class="nc" id="L460">            startMask |= BOLD;</span>
        }

<span class="nc bnc" id="L463" title="All 2 branches missed.">        if ((oldMask &amp; ITALIC) != 0) {</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">            if ((fontMask &amp; ITALIC) == 0) {</span>
<span class="nc" id="L465">                endMask |= ITALIC;</span>
            }
<span class="nc bnc" id="L467" title="All 2 branches missed.">        } else if ((fontMask &amp; ITALIC) != 0) {</span>
<span class="nc" id="L468">            startMask |= ITALIC;</span>
        }

<span class="nc bnc" id="L471" title="All 2 branches missed.">        if ((oldMask &amp; UNDERLINE) != 0) {</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            if ((fontMask &amp; UNDERLINE) == 0) {</span>
<span class="nc" id="L473">                endMask |= UNDERLINE;</span>
            }
<span class="nc bnc" id="L475" title="All 2 branches missed.">        } else if ((fontMask &amp; UNDERLINE) != 0) {</span>
<span class="nc" id="L476">            startMask |= UNDERLINE;</span>
        }
<span class="nc" id="L478">        writeEndMask(endMask);</span>
<span class="nc" id="L479">        writeStartMask(startMask);</span>
<span class="nc" id="L480">    }</span>


    /**
     * Tweaks the appropriate bits of fontMask
     * to reflect whether the text is to be displayed in
     * bold, italic, and/or with an underline.
     *
     */
    private void setFontMask(AttributeSet attr) {
<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (StyleConstants.isBold(attr)) {</span>
<span class="nc" id="L491">            fontMask |= BOLD;</span>
        }

<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (StyleConstants.isItalic(attr)) {</span>
<span class="nc" id="L495">            fontMask |= ITALIC;</span>
        }

<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (StyleConstants.isUnderline(attr)) {</span>
<span class="nc" id="L499">            fontMask |= UNDERLINE;</span>
        }
<span class="nc" id="L501">    }</span>




    /**
     * Writes out start tags &amp;lt;u&amp;gt;, &amp;lt;i&amp;gt;, and &amp;lt;b&amp;gt; based on
     * the mask settings.
     *
     * @exception IOException on any I/O error
     */
    private void writeStartMask(int mask) throws IOException  {
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (mask != 0) {</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">            if ((mask &amp; UNDERLINE) != 0) {</span>
<span class="nc" id="L515">                write(&quot;&lt;u&gt;&quot;);</span>
            }
<span class="nc bnc" id="L517" title="All 2 branches missed.">            if ((mask &amp; ITALIC) != 0) {</span>
<span class="nc" id="L518">                write(&quot;&lt;i&gt;&quot;);</span>
            }
<span class="nc bnc" id="L520" title="All 2 branches missed.">            if ((mask &amp; BOLD) != 0) {</span>
<span class="nc" id="L521">                write(&quot;&lt;b&gt;&quot;);</span>
            }
        }
<span class="nc" id="L524">    }</span>

    /**
     * Writes out end tags for &amp;lt;u&amp;gt;, &amp;lt;i&amp;gt;, and &amp;lt;b&amp;gt; based on
     * the mask settings.
     *
     * @exception IOException on any I/O error
     */
    private void writeEndMask(int mask) throws IOException {
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (mask != 0) {</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">            if ((mask &amp; BOLD) != 0) {</span>
<span class="nc" id="L535">                write(&quot;&lt;/b&gt;&quot;);</span>
            }
<span class="nc bnc" id="L537" title="All 2 branches missed.">            if ((mask &amp; ITALIC) != 0) {</span>
<span class="nc" id="L538">                write(&quot;&lt;/i&gt;&quot;);</span>
            }
<span class="nc bnc" id="L540" title="All 2 branches missed.">            if ((mask &amp; UNDERLINE) != 0) {</span>
<span class="nc" id="L541">                write(&quot;&lt;/u&gt;&quot;);</span>
            }
        }
<span class="nc" id="L544">    }</span>


    /**
     * Writes out the remaining
     * character-level attributes (attributes other than bold,
     * italic, and underline) in an HTML-compliant way.  Given that
     * attributes such as font family and font size have no direct
     * mapping to HTML tags, a &amp;lt;span&amp;gt; tag is generated and its
     * style attribute is set to contain the list of remaining
     * attributes just like inline styles.
     *
     * @exception IOException on any I/O error
     */
    protected void writeNonHTMLAttributes(AttributeSet attr) throws IOException {

<span class="nc" id="L560">        String style = &quot;&quot;;</span>
<span class="nc" id="L561">        String separator = &quot;; &quot;;</span>

<span class="nc bnc" id="L563" title="All 4 branches missed.">        if (inFontTag() &amp;&amp; fontAttributes.isEqual(attr)) {</span>
<span class="nc" id="L564">            return;</span>
        }

<span class="nc" id="L567">        boolean first = true;</span>
<span class="nc" id="L568">        Color color = (Color)attr.getAttribute(StyleConstants.Foreground);</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">        if (color != null) {</span>
<span class="nc" id="L570">            style += &quot;color: &quot; + css.styleConstantsValueToCSSValue</span>
<span class="nc" id="L571">                                    ((StyleConstants)StyleConstants.Foreground,</span>
                                     color);
<span class="nc" id="L573">            first = false;</span>
        }
<span class="nc" id="L575">        Integer size = (Integer)attr.getAttribute(StyleConstants.FontSize);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">        if (size != null) {</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">            if (!first) {</span>
<span class="nc" id="L578">                style += separator;</span>
            }
<span class="nc" id="L580">            style += &quot;font-size: &quot; + size.intValue() + &quot;pt&quot;;</span>
<span class="nc" id="L581">            first = false;</span>
        }

<span class="nc" id="L584">        String family = (String)attr.getAttribute(StyleConstants.FontFamily);</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (family != null) {</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">            if (!first) {</span>
<span class="nc" id="L587">                style += separator;</span>
            }
<span class="nc" id="L589">            style += &quot;font-family: &quot; + family;</span>
<span class="nc" id="L590">            first = false;</span>
        }

<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (style.length() &gt; 0) {</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (fontMask != 0) {</span>
<span class="nc" id="L595">                writeEndMask(fontMask);</span>
<span class="nc" id="L596">                fontMask = 0;</span>
            }
<span class="nc" id="L598">            startSpanTag(style);</span>
<span class="nc" id="L599">            fontAttributes = attr;</span>
        }
<span class="nc bnc" id="L601" title="All 2 branches missed.">        else if (fontAttributes != null) {</span>
<span class="nc" id="L602">            writeEndMask(fontMask);</span>
<span class="nc" id="L603">            fontMask = 0;</span>
<span class="nc" id="L604">            endSpanTag();</span>
        }
<span class="nc" id="L606">    }</span>


    /**
     * Returns true if we are currently in a &amp;lt;font&amp;gt; tag.
     */
    protected boolean inFontTag() {
<span class="nc bnc" id="L613" title="All 2 branches missed.">        return (fontAttributes != null);</span>
    }

    /**
     * This is no longer used, instead &amp;lt;span&amp;gt; will be written out.
     * &lt;p&gt;
     * Writes out an end tag for the &amp;lt;font&amp;gt; tag.
     *
     * @exception IOException on any I/O error
     */
    protected void endFontTag() throws IOException {
<span class="nc" id="L624">        write(NEWLINE);</span>
<span class="nc" id="L625">        writeEndTag(&quot;&lt;/font&gt;&quot;);</span>
<span class="nc" id="L626">        fontAttributes = null;</span>
<span class="nc" id="L627">    }</span>


    /**
     * This is no longer used, instead &amp;lt;span&amp;gt; will be written out.
     * &lt;p&gt;
     * Writes out a start tag for the &amp;lt;font&amp;gt; tag.
     * Because font tags cannot be nested,
     * this method closes out
     * any enclosing font tag before writing out a
     * new start tag.
     *
     * @exception IOException on any I/O error
     */
    protected void startFontTag(String style) throws IOException {
<span class="nc" id="L642">        boolean callIndent = false;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">        if (inFontTag()) {</span>
<span class="nc" id="L644">            endFontTag();</span>
<span class="nc" id="L645">            callIndent = true;</span>
        }
<span class="nc" id="L647">        writeStartTag(&quot;&lt;font style=\&quot;&quot; + style + &quot;\&quot;&gt;&quot;);</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">        if (callIndent) {</span>
<span class="nc" id="L649">            indent();</span>
        }
<span class="nc" id="L651">    }</span>

    /**
     * Writes out a start tag for the &amp;lt;font&amp;gt; tag.
     * Because font tags cannot be nested,
     * this method closes out
     * any enclosing font tag before writing out a
     * new start tag.
     *
     * @exception IOException on any I/O error
     */
    private void startSpanTag(String style) throws IOException {
<span class="nc" id="L663">        boolean callIndent = false;</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (inFontTag()) {</span>
<span class="nc" id="L665">            endSpanTag();</span>
<span class="nc" id="L666">            callIndent = true;</span>
        }
<span class="nc" id="L668">        writeStartTag(&quot;&lt;span style=\&quot;&quot; + style + &quot;\&quot;&gt;&quot;);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">        if (callIndent) {</span>
<span class="nc" id="L670">            indent();</span>
        }
<span class="nc" id="L672">    }</span>

    /**
     * Writes out an end tag for the &amp;lt;span&amp;gt; tag.
     *
     * @exception IOException on any I/O error
     */
    private void endSpanTag() throws IOException {
<span class="nc" id="L680">        write(NEWLINE);</span>
<span class="nc" id="L681">        writeEndTag(&quot;&lt;/span&gt;&quot;);</span>
<span class="nc" id="L682">        fontAttributes = null;</span>
<span class="nc" id="L683">    }</span>

    /**
     * Adds the style named &lt;code&gt;style&lt;/code&gt; to the style mapping. This
     * returns the name that should be used when outputting. CSS does not
     * allow the full Unicode set to be used as a style name.
     */
    private String addStyleName(String style) {
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (styleNameMapping == null) {</span>
<span class="nc" id="L692">            return style;</span>
        }
<span class="nc" id="L694">        StringBuilder sb = null;</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">        for (int counter = style.length() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">            if (!isValidCharacter(style.charAt(counter))) {</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">                if (sb == null) {</span>
<span class="nc" id="L698">                    sb = new StringBuilder(style);</span>
                }
<span class="nc" id="L700">                sb.setCharAt(counter, 'a');</span>
            }
        }
<span class="nc bnc" id="L703" title="All 2 branches missed.">        String mappedName = (sb != null) ? sb.toString() : style;</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">        while (styleNameMapping.get(mappedName) != null) {</span>
<span class="nc" id="L705">            mappedName = mappedName + 'x';</span>
        }
<span class="nc" id="L707">        styleNameMapping.put(style, mappedName);</span>
<span class="nc" id="L708">        return mappedName;</span>
    }

    /**
     * Returns the mapped style name corresponding to &lt;code&gt;style&lt;/code&gt;.
     */
    private String mapStyleName(String style) {
<span class="nc bnc" id="L715" title="All 2 branches missed.">        if (styleNameMapping == null) {</span>
<span class="nc" id="L716">            return style;</span>
        }
<span class="nc" id="L718">        String retValue = styleNameMapping.get(style);</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">        return (retValue == null) ? style : retValue;</span>
    }

    private boolean isValidCharacter(char character) {
<span class="nc bnc" id="L723" title="All 8 branches missed.">        return ((character &gt;= 'a' &amp;&amp; character &lt;= 'z') ||</span>
                (character &gt;= 'A' &amp;&amp; character &lt;= 'Z'));
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>