<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StampedLock.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.concurrent.locks</a> &gt; <span class="el_source">StampedLock.java</span></div><h1>StampedLock.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent.locks;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.LockSupport;

/**
 * A capability-based lock with three modes for controlling read/write
 * access.  The state of a StampedLock consists of a version and mode.
 * Lock acquisition methods return a stamp that represents and
 * controls access with respect to a lock state; &quot;try&quot; versions of
 * these methods may instead return the special value zero to
 * represent failure to acquire access. Lock release and conversion
 * methods require stamps as arguments, and fail if they do not match
 * the state of the lock. The three modes are:
 *
 * &lt;ul&gt;
 *
 *  &lt;li&gt;&lt;b&gt;Writing.&lt;/b&gt; Method {@link #writeLock} possibly blocks
 *   waiting for exclusive access, returning a stamp that can be used
 *   in method {@link #unlockWrite} to release the lock. Untimed and
 *   timed versions of {@code tryWriteLock} are also provided. When
 *   the lock is held in write mode, no read locks may be obtained,
 *   and all optimistic read validations will fail.  &lt;/li&gt;
 *
 *  &lt;li&gt;&lt;b&gt;Reading.&lt;/b&gt; Method {@link #readLock} possibly blocks
 *   waiting for non-exclusive access, returning a stamp that can be
 *   used in method {@link #unlockRead} to release the lock. Untimed
 *   and timed versions of {@code tryReadLock} are also provided. &lt;/li&gt;
 *
 *  &lt;li&gt;&lt;b&gt;Optimistic Reading.&lt;/b&gt; Method {@link #tryOptimisticRead}
 *   returns a non-zero stamp only if the lock is not currently held
 *   in write mode. Method {@link #validate} returns true if the lock
 *   has not been acquired in write mode since obtaining a given
 *   stamp.  This mode can be thought of as an extremely weak version
 *   of a read-lock, that can be broken by a writer at any time.  The
 *   use of optimistic mode for short read-only code segments often
 *   reduces contention and improves throughput.  However, its use is
 *   inherently fragile.  Optimistic read sections should only read
 *   fields and hold them in local variables for later use after
 *   validation. Fields read while in optimistic mode may be wildly
 *   inconsistent, so usage applies only when you are familiar enough
 *   with data representations to check consistency and/or repeatedly
 *   invoke method {@code validate()}.  For example, such steps are
 *   typically required when first reading an object or array
 *   reference, and then accessing one of its fields, elements or
 *   methods. &lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt;This class also supports methods that conditionally provide
 * conversions across the three modes. For example, method {@link
 * #tryConvertToWriteLock} attempts to &quot;upgrade&quot; a mode, returning
 * a valid write stamp if (1) already in writing mode (2) in reading
 * mode and there are no other readers or (3) in optimistic mode and
 * the lock is available. The forms of these methods are designed to
 * help reduce some of the code bloat that otherwise occurs in
 * retry-based designs.
 *
 * &lt;p&gt;StampedLocks are designed for use as internal utilities in the
 * development of thread-safe components. Their use relies on
 * knowledge of the internal properties of the data, objects, and
 * methods they are protecting.  They are not reentrant, so locked
 * bodies should not call other unknown methods that may try to
 * re-acquire locks (although you may pass a stamp to other methods
 * that can use or convert it).  The use of read lock modes relies on
 * the associated code sections being side-effect-free.  Unvalidated
 * optimistic read sections cannot call methods that are not known to
 * tolerate potential inconsistencies.  Stamps use finite
 * representations, and are not cryptographically secure (i.e., a
 * valid stamp may be guessable). Stamp values may recycle after (no
 * sooner than) one year of continuous operation. A stamp held without
 * use or validation for longer than this period may fail to validate
 * correctly.  StampedLocks are serializable, but always deserialize
 * into initial unlocked state, so they are not useful for remote
 * locking.
 *
 * &lt;p&gt;The scheduling policy of StampedLock does not consistently
 * prefer readers over writers or vice versa.  All &quot;try&quot; methods are
 * best-effort and do not necessarily conform to any scheduling or
 * fairness policy. A zero return from any &quot;try&quot; method for acquiring
 * or converting locks does not carry any information about the state
 * of the lock; a subsequent invocation may succeed.
 *
 * &lt;p&gt;Because it supports coordinated usage across multiple lock
 * modes, this class does not directly implement the {@link Lock} or
 * {@link ReadWriteLock} interfaces. However, a StampedLock may be
 * viewed {@link #asReadLock()}, {@link #asWriteLock()}, or {@link
 * #asReadWriteLock()} in applications requiring only the associated
 * set of functionality.
 *
 * &lt;p&gt;&lt;b&gt;Sample Usage.&lt;/b&gt; The following illustrates some usage idioms
 * in a class that maintains simple two-dimensional points. The sample
 * code illustrates some try/catch conventions even though they are
 * not strictly needed here because no exceptions can occur in their
 * bodies.&lt;br&gt;
 *
 *  &lt;pre&gt;{@code
 * class Point {
 *   private double x, y;
 *   private final StampedLock sl = new StampedLock();
 *
 *   void move(double deltaX, double deltaY) { // an exclusively locked method
 *     long stamp = sl.writeLock();
 *     try {
 *       x += deltaX;
 *       y += deltaY;
 *     } finally {
 *       sl.unlockWrite(stamp);
 *     }
 *   }
 *
 *   double distanceFromOrigin() { // A read-only method
 *     long stamp = sl.tryOptimisticRead();
 *     double currentX = x, currentY = y;
 *     if (!sl.validate(stamp)) {
 *        stamp = sl.readLock();
 *        try {
 *          currentX = x;
 *          currentY = y;
 *        } finally {
 *           sl.unlockRead(stamp);
 *        }
 *     }
 *     return Math.sqrt(currentX * currentX + currentY * currentY);
 *   }
 *
 *   void moveIfAtOrigin(double newX, double newY) { // upgrade
 *     // Could instead start with optimistic, not read mode
 *     long stamp = sl.readLock();
 *     try {
 *       while (x == 0.0 &amp;&amp; y == 0.0) {
 *         long ws = sl.tryConvertToWriteLock(stamp);
 *         if (ws != 0L) {
 *           stamp = ws;
 *           x = newX;
 *           y = newY;
 *           break;
 *         }
 *         else {
 *           sl.unlockRead(stamp);
 *           stamp = sl.writeLock();
 *         }
 *       }
 *     } finally {
 *       sl.unlock(stamp);
 *     }
 *   }
 * }}&lt;/pre&gt;
 *
 * @since 1.8
 * @author Doug Lea
 */
public class StampedLock implements java.io.Serializable {
    /*
     * Algorithmic notes:
     *
     * The design employs elements of Sequence locks
     * (as used in linux kernels; see Lameter's
     * http://www.lameter.com/gelato2005.pdf
     * and elsewhere; see
     * Boehm's http://www.hpl.hp.com/techreports/2012/HPL-2012-68.html)
     * and Ordered RW locks (see Shirako et al
     * http://dl.acm.org/citation.cfm?id=2312015)
     *
     * Conceptually, the primary state of the lock includes a sequence
     * number that is odd when write-locked and even otherwise.
     * However, this is offset by a reader count that is non-zero when
     * read-locked.  The read count is ignored when validating
     * &quot;optimistic&quot; seqlock-reader-style stamps.  Because we must use
     * a small finite number of bits (currently 7) for readers, a
     * supplementary reader overflow word is used when the number of
     * readers exceeds the count field. We do this by treating the max
     * reader count value (RBITS) as a spinlock protecting overflow
     * updates.
     *
     * Waiters use a modified form of CLH lock used in
     * AbstractQueuedSynchronizer (see its internal documentation for
     * a fuller account), where each node is tagged (field mode) as
     * either a reader or writer. Sets of waiting readers are grouped
     * (linked) under a common node (field cowait) so act as a single
     * node with respect to most CLH mechanics.  By virtue of the
     * queue structure, wait nodes need not actually carry sequence
     * numbers; we know each is greater than its predecessor.  This
     * simplifies the scheduling policy to a mainly-FIFO scheme that
     * incorporates elements of Phase-Fair locks (see Brandenburg &amp;
     * Anderson, especially http://www.cs.unc.edu/~bbb/diss/).  In
     * particular, we use the phase-fair anti-barging rule: If an
     * incoming reader arrives while read lock is held but there is a
     * queued writer, this incoming reader is queued.  (This rule is
     * responsible for some of the complexity of method acquireRead,
     * but without it, the lock becomes highly unfair.) Method release
     * does not (and sometimes cannot) itself wake up cowaiters. This
     * is done by the primary thread, but helped by any other threads
     * with nothing better to do in methods acquireRead and
     * acquireWrite.
     *
     * These rules apply to threads actually queued. All tryLock forms
     * opportunistically try to acquire locks regardless of preference
     * rules, and so may &quot;barge&quot; their way in.  Randomized spinning is
     * used in the acquire methods to reduce (increasingly expensive)
     * context switching while also avoiding sustained memory
     * thrashing among many threads.  We limit spins to the head of
     * queue. A thread spin-waits up to SPINS times (where each
     * iteration decreases spin count with 50% probability) before
     * blocking. If, upon wakening it fails to obtain lock, and is
     * still (or becomes) the first waiting thread (which indicates
     * that some other thread barged and obtained lock), it escalates
     * spins (up to MAX_HEAD_SPINS) to reduce the likelihood of
     * continually losing to barging threads.
     *
     * Nearly all of these mechanics are carried out in methods
     * acquireWrite and acquireRead, that, as typical of such code,
     * sprawl out because actions and retries rely on consistent sets
     * of locally cached reads.
     *
     * As noted in Boehm's paper (above), sequence validation (mainly
     * method validate()) requires stricter ordering rules than apply
     * to normal volatile reads (of &quot;state&quot;).  To force orderings of
     * reads before a validation and the validation itself in those
     * cases where this is not already forced, we use
     * Unsafe.loadFence.
     *
     * The memory layout keeps lock state and queue pointers together
     * (normally on the same cache line). This usually works well for
     * read-mostly loads. In most other cases, the natural tendency of
     * adaptive-spin CLH locks to reduce memory contention lessens
     * motivation to further spread out contended locations, but might
     * be subject to future improvements.
     */

    private static final long serialVersionUID = -6001602636862214147L;

    /** Number of processors, for spin control */
<span class="fc" id="L272">    private static final int NCPU = Runtime.getRuntime().availableProcessors();</span>

    /** Maximum number of retries before enqueuing on acquisition */
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">    private static final int SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 6 : 0;</span>

    /** Maximum number of retries before blocking at head on acquisition */
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">    private static final int HEAD_SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 10 : 0;</span>

    /** Maximum number of retries before re-blocking */
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">    private static final int MAX_HEAD_SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 16 : 0;</span>

    /** The period for yielding when waiting for overflow spinlock */
    private static final int OVERFLOW_YIELD_RATE = 7; // must be power 2 - 1

    /** The number of bits to use for reader count before overflowing */
    private static final int LG_READERS = 7;

    // Values for lock state and stamp operations
    private static final long RUNIT = 1L;
    private static final long WBIT  = 1L &lt;&lt; LG_READERS;
    private static final long RBITS = WBIT - 1L;
    private static final long RFULL = RBITS - 1L;
    private static final long ABITS = RBITS | WBIT;
    private static final long SBITS = ~RBITS; // note overlap with ABITS

    // Initial value for lock state; avoid failure value zero
    private static final long ORIGIN = WBIT &lt;&lt; 1;

    // Special value from cancelled acquire methods so caller can throw IE
    private static final long INTERRUPTED = 1L;

    // Values for node status; order matters
    private static final int WAITING   = -1;
    private static final int CANCELLED =  1;

    // Modes for nodes (int not boolean to allow arithmetic)
    private static final int RMODE = 0;
    private static final int WMODE = 1;

    /** Wait nodes */
    static final class WNode {
        volatile WNode prev;
        volatile WNode next;
        volatile WNode cowait;    // list of linked readers
        volatile Thread thread;   // non-null while possibly parked
        volatile int status;      // 0, WAITING, or CANCELLED
        final int mode;           // RMODE or WMODE
<span class="fc" id="L319">        WNode(int m, WNode p) { mode = m; prev = p; }</span>
    }

    /** Head of CLH queue */
    private transient volatile WNode whead;
    /** Tail (last) of CLH queue */
    private transient volatile WNode wtail;

    // views
    transient ReadLockView readLockView;
    transient WriteLockView writeLockView;
    transient ReadWriteLockView readWriteLockView;

    /** Lock sequence/state */
    private transient volatile long state;
    /** extra reader count when state read count saturated */
    private transient int readerOverflow;

    /**
     * Creates a new lock, initially in unlocked state.
     */
<span class="fc" id="L340">    public StampedLock() {</span>
<span class="fc" id="L341">        state = ORIGIN;</span>
<span class="fc" id="L342">    }</span>

    /**
     * Exclusively acquires the lock, blocking if necessary
     * until available.
     *
     * @return a stamp that can be used to unlock or convert mode
     */
    public long writeLock() {
        long s, next;  // bypass acquireWrite in fully unlocked case only
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        return ((((s = state) &amp; ABITS) == 0L &amp;&amp;</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">                 U.compareAndSwapLong(this, STATE, s, next = s + WBIT)) ?</span>
<span class="pc" id="L354">                next : acquireWrite(false, 0L));</span>
    }

    /**
     * Exclusively acquires the lock if it is immediately available.
     *
     * @return a stamp that can be used to unlock or convert mode,
     * or zero if the lock is not available
     */
    public long tryWriteLock() {
        long s, next;
<span class="nc bnc" id="L365" title="All 2 branches missed.">        return ((((s = state) &amp; ABITS) == 0L &amp;&amp;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                 U.compareAndSwapLong(this, STATE, s, next = s + WBIT)) ?</span>
                next : 0L);
    }

    /**
     * Exclusively acquires the lock if it is available within the
     * given time and the current thread has not been interrupted.
     * Behavior under timeout and interruption matches that specified
     * for method {@link Lock#tryLock(long,TimeUnit)}.
     *
     * @param time the maximum time to wait for the lock
     * @param unit the time unit of the {@code time} argument
     * @return a stamp that can be used to unlock or convert mode,
     * or zero if the lock is not available
     * @throws InterruptedException if the current thread is interrupted
     * before acquiring the lock
     */
    public long tryWriteLock(long time, TimeUnit unit)
        throws InterruptedException {
<span class="nc" id="L385">        long nanos = unit.toNanos(time);</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (!Thread.interrupted()) {</span>
            long next, deadline;
<span class="nc bnc" id="L388" title="All 2 branches missed.">            if ((next = tryWriteLock()) != 0L)</span>
<span class="nc" id="L389">                return next;</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (nanos &lt;= 0L)</span>
<span class="nc" id="L391">                return 0L;</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if ((deadline = System.nanoTime() + nanos) == 0L)</span>
<span class="nc" id="L393">                deadline = 1L;</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if ((next = acquireWrite(true, deadline)) != INTERRUPTED)</span>
<span class="nc" id="L395">                return next;</span>
        }
<span class="nc" id="L397">        throw new InterruptedException();</span>
    }

    /**
     * Exclusively acquires the lock, blocking if necessary
     * until available or the current thread is interrupted.
     * Behavior under interruption matches that specified
     * for method {@link Lock#lockInterruptibly()}.
     *
     * @return a stamp that can be used to unlock or convert mode
     * @throws InterruptedException if the current thread is interrupted
     * before acquiring the lock
     */
    public long writeLockInterruptibly() throws InterruptedException {
        long next;
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (!Thread.interrupted() &amp;&amp;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            (next = acquireWrite(true, 0L)) != INTERRUPTED)</span>
<span class="nc" id="L414">            return next;</span>
<span class="nc" id="L415">        throw new InterruptedException();</span>
    }

    /**
     * Non-exclusively acquires the lock, blocking if necessary
     * until available.
     *
     * @return a stamp that can be used to unlock or convert mode
     */
    public long readLock() {
<span class="fc" id="L425">        long s = state, next;  // bypass acquireRead on common uncontended case</span>
<span class="pc bpc" id="L426" title="1 of 4 branches missed.">        return ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;</span>
<span class="pc bnc" id="L427" title="All 2 branches missed.">                 U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) ?</span>
<span class="fc" id="L428">                next : acquireRead(false, 0L));</span>
    }

    /**
     * Non-exclusively acquires the lock if it is immediately available.
     *
     * @return a stamp that can be used to unlock or convert mode,
     * or zero if the lock is not available
     */
    public long tryReadLock() {
        for (;;) {
            long s, m, next;
<span class="nc bnc" id="L440" title="All 2 branches missed.">            if ((m = (s = state) &amp; ABITS) == WBIT)</span>
<span class="nc" id="L441">                return 0L;</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            else if (m &lt; RFULL) {</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">                if (U.compareAndSwapLong(this, STATE, s, next = s + RUNIT))</span>
<span class="nc" id="L444">                    return next;</span>
            }
<span class="nc bnc" id="L446" title="All 2 branches missed.">            else if ((next = tryIncReaderOverflow(s)) != 0L)</span>
<span class="nc" id="L447">                return next;</span>
<span class="nc" id="L448">        }</span>
    }

    /**
     * Non-exclusively acquires the lock if it is available within the
     * given time and the current thread has not been interrupted.
     * Behavior under timeout and interruption matches that specified
     * for method {@link Lock#tryLock(long,TimeUnit)}.
     *
     * @param time the maximum time to wait for the lock
     * @param unit the time unit of the {@code time} argument
     * @return a stamp that can be used to unlock or convert mode,
     * or zero if the lock is not available
     * @throws InterruptedException if the current thread is interrupted
     * before acquiring the lock
     */
    public long tryReadLock(long time, TimeUnit unit)
        throws InterruptedException {
        long s, m, next, deadline;
<span class="nc" id="L467">        long nanos = unit.toNanos(time);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (!Thread.interrupted()) {</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">            if ((m = (s = state) &amp; ABITS) != WBIT) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">                if (m &lt; RFULL) {</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">                    if (U.compareAndSwapLong(this, STATE, s, next = s + RUNIT))</span>
<span class="nc" id="L472">                        return next;</span>
                }
<span class="nc bnc" id="L474" title="All 2 branches missed.">                else if ((next = tryIncReaderOverflow(s)) != 0L)</span>
<span class="nc" id="L475">                    return next;</span>
            }
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (nanos &lt;= 0L)</span>
<span class="nc" id="L478">                return 0L;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">            if ((deadline = System.nanoTime() + nanos) == 0L)</span>
<span class="nc" id="L480">                deadline = 1L;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if ((next = acquireRead(true, deadline)) != INTERRUPTED)</span>
<span class="nc" id="L482">                return next;</span>
        }
<span class="nc" id="L484">        throw new InterruptedException();</span>
    }

    /**
     * Non-exclusively acquires the lock, blocking if necessary
     * until available or the current thread is interrupted.
     * Behavior under interruption matches that specified
     * for method {@link Lock#lockInterruptibly()}.
     *
     * @return a stamp that can be used to unlock or convert mode
     * @throws InterruptedException if the current thread is interrupted
     * before acquiring the lock
     */
    public long readLockInterruptibly() throws InterruptedException {
        long next;
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (!Thread.interrupted() &amp;&amp;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            (next = acquireRead(true, 0L)) != INTERRUPTED)</span>
<span class="nc" id="L501">            return next;</span>
<span class="nc" id="L502">        throw new InterruptedException();</span>
    }

    /**
     * Returns a stamp that can later be validated, or zero
     * if exclusively locked.
     *
     * @return a stamp, or zero if exclusively locked
     */
    public long tryOptimisticRead() {
        long s;
<span class="nc bnc" id="L513" title="All 2 branches missed.">        return (((s = state) &amp; WBIT) == 0L) ? (s &amp; SBITS) : 0L;</span>
    }

    /**
     * Returns true if the lock has not been exclusively acquired
     * since issuance of the given stamp. Always returns false if the
     * stamp is zero. Always returns true if the stamp represents a
     * currently held lock. Invoking this method with a value not
     * obtained from {@link #tryOptimisticRead} or a locking method
     * for this lock has no defined effect or result.
     *
     * @param stamp a stamp
     * @return {@code true} if the lock has not been exclusively acquired
     * since issuance of the given stamp; else false
     */
    public boolean validate(long stamp) {
<span class="nc" id="L529">        U.loadFence();</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        return (stamp &amp; SBITS) == (state &amp; SBITS);</span>
    }

    /**
     * If the lock state matches the given stamp, releases the
     * exclusive lock.
     *
     * @param stamp a stamp returned by a write-lock operation
     * @throws IllegalMonitorStateException if the stamp does
     * not match the current state of this lock
     */
    public void unlockWrite(long stamp) {
        WNode h;
<span class="pc bpc" id="L543" title="2 of 4 branches missed.">        if (state != stamp || (stamp &amp; WBIT) == 0L)</span>
<span class="nc" id="L544">            throw new IllegalMonitorStateException();</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">        state = (stamp += WBIT) == 0L ? ORIGIN : stamp;</span>
<span class="pc bpc" id="L546" title="2 of 4 branches missed.">        if ((h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="fc" id="L547">            release(h);</span>
<span class="fc" id="L548">    }</span>

    /**
     * If the lock state matches the given stamp, releases the
     * non-exclusive lock.
     *
     * @param stamp a stamp returned by a read-lock operation
     * @throws IllegalMonitorStateException if the stamp does
     * not match the current state of this lock
     */
    public void unlockRead(long stamp) {
        long s, m; WNode h;
        for (;;) {
<span class="pc bpc" id="L561" title="4 of 8 branches missed.">            if (((s = state) &amp; SBITS) != (stamp &amp; SBITS) ||</span>
                (stamp &amp; ABITS) == 0L || (m = s &amp; ABITS) == 0L || m == WBIT)
<span class="nc" id="L563">                throw new IllegalMonitorStateException();</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            if (m &lt; RFULL) {</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">                if (U.compareAndSwapLong(this, STATE, s, s - RUNIT)) {</span>
<span class="pc bpc" id="L566" title="2 of 6 branches missed.">                    if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="nc" id="L567">                        release(h);</span>
                    break;
                }
            }
<span class="nc bnc" id="L571" title="All 2 branches missed.">            else if (tryDecReaderOverflow(s) != 0L)</span>
<span class="nc" id="L572">                break;</span>
        }
<span class="fc" id="L574">    }</span>

    /**
     * If the lock state matches the given stamp, releases the
     * corresponding mode of the lock.
     *
     * @param stamp a stamp returned by a lock operation
     * @throws IllegalMonitorStateException if the stamp does
     * not match the current state of this lock
     */
    public void unlock(long stamp) {
<span class="nc" id="L585">        long a = stamp &amp; ABITS, m, s; WNode h;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">        while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">            if ((m = s &amp; ABITS) == 0L)</span>
<span class="nc" id="L588">                break;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">            else if (m == WBIT) {</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">                if (a != m)</span>
<span class="nc" id="L591">                    break;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">                state = (s += WBIT) == 0L ? ORIGIN : s;</span>
<span class="nc bnc" id="L593" title="All 4 branches missed.">                if ((h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="nc" id="L594">                    release(h);</span>
<span class="nc" id="L595">                return;</span>
            }
<span class="nc bnc" id="L597" title="All 4 branches missed.">            else if (a == 0L || a &gt;= WBIT)</span>
<span class="nc" id="L598">                break;</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">            else if (m &lt; RFULL) {</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                if (U.compareAndSwapLong(this, STATE, s, s - RUNIT)) {</span>
<span class="nc bnc" id="L601" title="All 6 branches missed.">                    if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="nc" id="L602">                        release(h);</span>
<span class="nc" id="L603">                    return;</span>
                }
            }
<span class="nc bnc" id="L606" title="All 2 branches missed.">            else if (tryDecReaderOverflow(s) != 0L)</span>
<span class="nc" id="L607">                return;</span>
        }
<span class="nc" id="L609">        throw new IllegalMonitorStateException();</span>
    }

    /**
     * If the lock state matches the given stamp, performs one of
     * the following actions. If the stamp represents holding a write
     * lock, returns it.  Or, if a read lock, if the write lock is
     * available, releases the read lock and returns a write stamp.
     * Or, if an optimistic read, returns a write stamp only if
     * immediately available. This method returns zero in all other
     * cases.
     *
     * @param stamp a stamp
     * @return a valid write stamp, or zero on failure
     */
    public long tryConvertToWriteLock(long stamp) {
<span class="nc" id="L625">        long a = stamp &amp; ABITS, m, s, next;</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">        while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">            if ((m = s &amp; ABITS) == 0L) {</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">                if (a != 0L)</span>
<span class="nc" id="L629">                    break;</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">                if (U.compareAndSwapLong(this, STATE, s, next = s + WBIT))</span>
<span class="nc" id="L631">                    return next;</span>
            }
<span class="nc bnc" id="L633" title="All 2 branches missed.">            else if (m == WBIT) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                if (a != m)</span>
<span class="nc" id="L635">                    break;</span>
<span class="nc" id="L636">                return stamp;</span>
            }
<span class="nc bnc" id="L638" title="All 4 branches missed.">            else if (m == RUNIT &amp;&amp; a != 0L) {</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">                if (U.compareAndSwapLong(this, STATE, s,</span>
                                         next = s - RUNIT + WBIT))
<span class="nc" id="L641">                    return next;</span>
            }
            else
                break;
        }
<span class="nc" id="L646">        return 0L;</span>
    }

    /**
     * If the lock state matches the given stamp, performs one of
     * the following actions. If the stamp represents holding a write
     * lock, releases it and obtains a read lock.  Or, if a read lock,
     * returns it. Or, if an optimistic read, acquires a read lock and
     * returns a read stamp only if immediately available. This method
     * returns zero in all other cases.
     *
     * @param stamp a stamp
     * @return a valid read stamp, or zero on failure
     */
    public long tryConvertToReadLock(long stamp) {
<span class="nc" id="L661">        long a = stamp &amp; ABITS, m, s, next; WNode h;</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">            if ((m = s &amp; ABITS) == 0L) {</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">                if (a != 0L)</span>
<span class="nc" id="L665">                    break;</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                else if (m &lt; RFULL) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                    if (U.compareAndSwapLong(this, STATE, s, next = s + RUNIT))</span>
<span class="nc" id="L668">                        return next;</span>
                }
<span class="nc bnc" id="L670" title="All 2 branches missed.">                else if ((next = tryIncReaderOverflow(s)) != 0L)</span>
<span class="nc" id="L671">                    return next;</span>
            }
<span class="nc bnc" id="L673" title="All 2 branches missed.">            else if (m == WBIT) {</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                if (a != m)</span>
<span class="nc" id="L675">                    break;</span>
<span class="nc" id="L676">                state = next = s + (WBIT + RUNIT);</span>
<span class="nc bnc" id="L677" title="All 4 branches missed.">                if ((h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="nc" id="L678">                    release(h);</span>
<span class="nc" id="L679">                return next;</span>
            }
<span class="nc bnc" id="L681" title="All 4 branches missed.">            else if (a != 0L &amp;&amp; a &lt; WBIT)</span>
<span class="nc" id="L682">                return stamp;</span>
            else
                break;
        }
<span class="nc" id="L686">        return 0L;</span>
    }

    /**
     * If the lock state matches the given stamp then, if the stamp
     * represents holding a lock, releases it and returns an
     * observation stamp.  Or, if an optimistic read, returns it if
     * validated. This method returns zero in all other cases, and so
     * may be useful as a form of &quot;tryUnlock&quot;.
     *
     * @param stamp a stamp
     * @return a valid optimistic read stamp, or zero on failure
     */
    public long tryConvertToOptimisticRead(long stamp) {
<span class="nc" id="L700">        long a = stamp &amp; ABITS, m, s, next; WNode h;</span>
<span class="nc" id="L701">        U.loadFence();</span>
        for (;;) {
<span class="nc bnc" id="L703" title="All 2 branches missed.">            if (((s = state) &amp; SBITS) != (stamp &amp; SBITS))</span>
<span class="nc" id="L704">                break;</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">            if ((m = s &amp; ABITS) == 0L) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                if (a != 0L)</span>
<span class="nc" id="L707">                    break;</span>
<span class="nc" id="L708">                return s;</span>
            }
<span class="nc bnc" id="L710" title="All 2 branches missed.">            else if (m == WBIT) {</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">                if (a != m)</span>
<span class="nc" id="L712">                    break;</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">                state = next = (s += WBIT) == 0L ? ORIGIN : s;</span>
<span class="nc bnc" id="L714" title="All 4 branches missed.">                if ((h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="nc" id="L715">                    release(h);</span>
<span class="nc" id="L716">                return next;</span>
            }
<span class="nc bnc" id="L718" title="All 4 branches missed.">            else if (a == 0L || a &gt;= WBIT)</span>
<span class="nc" id="L719">                break;</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">            else if (m &lt; RFULL) {</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                if (U.compareAndSwapLong(this, STATE, s, next = s - RUNIT)) {</span>
<span class="nc bnc" id="L722" title="All 6 branches missed.">                    if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="nc" id="L723">                        release(h);</span>
<span class="nc" id="L724">                    return next &amp; SBITS;</span>
                }
            }
<span class="nc bnc" id="L727" title="All 2 branches missed.">            else if ((next = tryDecReaderOverflow(s)) != 0L)</span>
<span class="nc" id="L728">                return next &amp; SBITS;</span>
        }
<span class="nc" id="L730">        return 0L;</span>
    }

    /**
     * Releases the write lock if it is held, without requiring a
     * stamp value. This method may be useful for recovery after
     * errors.
     *
     * @return {@code true} if the lock was held, else false
     */
    public boolean tryUnlockWrite() {
        long s; WNode h;
<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (((s = state) &amp; WBIT) != 0L) {</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">            state = (s += WBIT) == 0L ? ORIGIN : s;</span>
<span class="nc bnc" id="L744" title="All 4 branches missed.">            if ((h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="nc" id="L745">                release(h);</span>
<span class="nc" id="L746">            return true;</span>
        }
<span class="nc" id="L748">        return false;</span>
    }

    /**
     * Releases one hold of the read lock if it is held, without
     * requiring a stamp value. This method may be useful for recovery
     * after errors.
     *
     * @return {@code true} if the read lock was held, else false
     */
    public boolean tryUnlockRead() {
        long s, m; WNode h;
<span class="nc bnc" id="L760" title="All 4 branches missed.">        while ((m = (s = state) &amp; ABITS) != 0L &amp;&amp; m &lt; WBIT) {</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">            if (m &lt; RFULL) {</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">                if (U.compareAndSwapLong(this, STATE, s, s - RUNIT)) {</span>
<span class="nc bnc" id="L763" title="All 6 branches missed.">                    if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="nc" id="L764">                        release(h);</span>
<span class="nc" id="L765">                    return true;</span>
                }
            }
<span class="nc bnc" id="L768" title="All 2 branches missed.">            else if (tryDecReaderOverflow(s) != 0L)</span>
<span class="nc" id="L769">                return true;</span>
        }
<span class="nc" id="L771">        return false;</span>
    }

    // status monitoring methods

    /**
     * Returns combined state-held and overflow read count for given
     * state s.
     */
    private int getReadLockCount(long s) {
        long readers;
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if ((readers = s &amp; RBITS) &gt;= RFULL)</span>
<span class="nc" id="L783">            readers = RFULL + readerOverflow;</span>
<span class="nc" id="L784">        return (int) readers;</span>
    }

    /**
     * Returns {@code true} if the lock is currently held exclusively.
     *
     * @return {@code true} if the lock is currently held exclusively
     */
    public boolean isWriteLocked() {
<span class="nc bnc" id="L793" title="All 2 branches missed.">        return (state &amp; WBIT) != 0L;</span>
    }

    /**
     * Returns {@code true} if the lock is currently held non-exclusively.
     *
     * @return {@code true} if the lock is currently held non-exclusively
     */
    public boolean isReadLocked() {
<span class="nc bnc" id="L802" title="All 2 branches missed.">        return (state &amp; RBITS) != 0L;</span>
    }

    /**
     * Queries the number of read locks held for this lock. This
     * method is designed for use in monitoring system state, not for
     * synchronization control.
     * @return the number of read locks held
     */
    public int getReadLockCount() {
<span class="nc" id="L812">        return getReadLockCount(state);</span>
    }

    /**
     * Returns a string identifying this lock, as well as its lock
     * state.  The state, in brackets, includes the String {@code
     * &quot;Unlocked&quot;} or the String {@code &quot;Write-locked&quot;} or the String
     * {@code &quot;Read-locks:&quot;} followed by the current number of
     * read-locks held.
     *
     * @return a string identifying this lock, as well as its lock state
     */
    public String toString() {
<span class="nc" id="L825">        long s = state;</span>
<span class="nc bnc" id="L826" title="All 4 branches missed.">        return super.toString() +</span>
            ((s &amp; ABITS) == 0L ? &quot;[Unlocked]&quot; :
             (s &amp; WBIT) != 0L ? &quot;[Write-locked]&quot; :
<span class="nc" id="L829">             &quot;[Read-locks:&quot; + getReadLockCount(s) + &quot;]&quot;);</span>
    }

    // views

    /**
     * Returns a plain {@link Lock} view of this StampedLock in which
     * the {@link Lock#lock} method is mapped to {@link #readLock},
     * and similarly for other methods. The returned Lock does not
     * support a {@link Condition}; method {@link
     * Lock#newCondition()} throws {@code
     * UnsupportedOperationException}.
     *
     * @return the lock
     */
    public Lock asReadLock() {
        ReadLockView v;
<span class="nc bnc" id="L846" title="All 2 branches missed.">        return ((v = readLockView) != null ? v :</span>
                (readLockView = new ReadLockView()));
    }

    /**
     * Returns a plain {@link Lock} view of this StampedLock in which
     * the {@link Lock#lock} method is mapped to {@link #writeLock},
     * and similarly for other methods. The returned Lock does not
     * support a {@link Condition}; method {@link
     * Lock#newCondition()} throws {@code
     * UnsupportedOperationException}.
     *
     * @return the lock
     */
    public Lock asWriteLock() {
        WriteLockView v;
<span class="nc bnc" id="L862" title="All 2 branches missed.">        return ((v = writeLockView) != null ? v :</span>
                (writeLockView = new WriteLockView()));
    }

    /**
     * Returns a {@link ReadWriteLock} view of this StampedLock in
     * which the {@link ReadWriteLock#readLock()} method is mapped to
     * {@link #asReadLock()}, and {@link ReadWriteLock#writeLock()} to
     * {@link #asWriteLock()}.
     *
     * @return the lock
     */
    public ReadWriteLock asReadWriteLock() {
        ReadWriteLockView v;
<span class="nc bnc" id="L876" title="All 2 branches missed.">        return ((v = readWriteLockView) != null ? v :</span>
                (readWriteLockView = new ReadWriteLockView()));
    }

    // view classes

<span class="nc" id="L882">    final class ReadLockView implements Lock {</span>
<span class="nc" id="L883">        public void lock() { readLock(); }</span>
        public void lockInterruptibly() throws InterruptedException {
<span class="nc" id="L885">            readLockInterruptibly();</span>
<span class="nc" id="L886">        }</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">        public boolean tryLock() { return tryReadLock() != 0L; }</span>
        public boolean tryLock(long time, TimeUnit unit)
            throws InterruptedException {
<span class="nc bnc" id="L890" title="All 2 branches missed.">            return tryReadLock(time, unit) != 0L;</span>
        }
<span class="nc" id="L892">        public void unlock() { unstampedUnlockRead(); }</span>
        public Condition newCondition() {
<span class="nc" id="L894">            throw new UnsupportedOperationException();</span>
        }
    }

<span class="nc" id="L898">    final class WriteLockView implements Lock {</span>
<span class="nc" id="L899">        public void lock() { writeLock(); }</span>
        public void lockInterruptibly() throws InterruptedException {
<span class="nc" id="L901">            writeLockInterruptibly();</span>
<span class="nc" id="L902">        }</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">        public boolean tryLock() { return tryWriteLock() != 0L; }</span>
        public boolean tryLock(long time, TimeUnit unit)
            throws InterruptedException {
<span class="nc bnc" id="L906" title="All 2 branches missed.">            return tryWriteLock(time, unit) != 0L;</span>
        }
<span class="nc" id="L908">        public void unlock() { unstampedUnlockWrite(); }</span>
        public Condition newCondition() {
<span class="nc" id="L910">            throw new UnsupportedOperationException();</span>
        }
    }

<span class="nc" id="L914">    final class ReadWriteLockView implements ReadWriteLock {</span>
<span class="nc" id="L915">        public Lock readLock() { return asReadLock(); }</span>
<span class="nc" id="L916">        public Lock writeLock() { return asWriteLock(); }</span>
    }

    // Unlock methods without stamp argument checks for view classes.
    // Needed because view-class lock methods throw away stamps.

    final void unstampedUnlockWrite() {
        WNode h; long s;
<span class="nc bnc" id="L924" title="All 2 branches missed.">        if (((s = state) &amp; WBIT) == 0L)</span>
<span class="nc" id="L925">            throw new IllegalMonitorStateException();</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">        state = (s += WBIT) == 0L ? ORIGIN : s;</span>
<span class="nc bnc" id="L927" title="All 4 branches missed.">        if ((h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="nc" id="L928">            release(h);</span>
<span class="nc" id="L929">    }</span>

    final void unstampedUnlockRead() {
        for (;;) {
            long s, m; WNode h;
<span class="nc bnc" id="L934" title="All 4 branches missed.">            if ((m = (s = state) &amp; ABITS) == 0L || m &gt;= WBIT)</span>
<span class="nc" id="L935">                throw new IllegalMonitorStateException();</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">            else if (m &lt; RFULL) {</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">                if (U.compareAndSwapLong(this, STATE, s, s - RUNIT)) {</span>
<span class="nc bnc" id="L938" title="All 6 branches missed.">                    if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="nc" id="L939">                        release(h);</span>
                    break;
                }
            }
<span class="nc bnc" id="L943" title="All 2 branches missed.">            else if (tryDecReaderOverflow(s) != 0L)</span>
<span class="nc" id="L944">                break;</span>
<span class="nc" id="L945">        }</span>
<span class="nc" id="L946">    }</span>

    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
<span class="nc" id="L950">        s.defaultReadObject();</span>
<span class="nc" id="L951">        state = ORIGIN; // reset to unlocked state</span>
<span class="nc" id="L952">    }</span>

    // internals

    /**
     * Tries to increment readerOverflow by first setting state
     * access bits value to RBITS, indicating hold of spinlock,
     * then updating, then releasing.
     *
     * @param s a reader overflow stamp: (s &amp; ABITS) &gt;= RFULL
     * @return new stamp on success, else zero
     */
    private long tryIncReaderOverflow(long s) {
        // assert (s &amp; ABITS) &gt;= RFULL;
<span class="nc bnc" id="L966" title="All 2 branches missed.">        if ((s &amp; ABITS) == RFULL) {</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">            if (U.compareAndSwapLong(this, STATE, s, s | RBITS)) {</span>
<span class="nc" id="L968">                ++readerOverflow;</span>
<span class="nc" id="L969">                state = s;</span>
<span class="nc" id="L970">                return s;</span>
            }
        }
<span class="nc bnc" id="L973" title="All 2 branches missed.">        else if ((LockSupport.nextSecondarySeed() &amp;</span>
                  OVERFLOW_YIELD_RATE) == 0)
<span class="nc" id="L975">            Thread.yield();</span>
<span class="nc" id="L976">        return 0L;</span>
    }

    /**
     * Tries to decrement readerOverflow.
     *
     * @param s a reader overflow stamp: (s &amp; ABITS) &gt;= RFULL
     * @return new stamp on success, else zero
     */
    private long tryDecReaderOverflow(long s) {
        // assert (s &amp; ABITS) &gt;= RFULL;
<span class="nc bnc" id="L987" title="All 2 branches missed.">        if ((s &amp; ABITS) == RFULL) {</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">            if (U.compareAndSwapLong(this, STATE, s, s | RBITS)) {</span>
                int r; long next;
<span class="nc bnc" id="L990" title="All 2 branches missed.">                if ((r = readerOverflow) &gt; 0) {</span>
<span class="nc" id="L991">                    readerOverflow = r - 1;</span>
<span class="nc" id="L992">                    next = s;</span>
                }
                else
<span class="nc" id="L995">                    next = s - RUNIT;</span>
<span class="nc" id="L996">                 state = next;</span>
<span class="nc" id="L997">                 return next;</span>
            }
        }
<span class="nc bnc" id="L1000" title="All 2 branches missed.">        else if ((LockSupport.nextSecondarySeed() &amp;</span>
                  OVERFLOW_YIELD_RATE) == 0)
<span class="nc" id="L1002">            Thread.yield();</span>
<span class="nc" id="L1003">        return 0L;</span>
    }

    /**
     * Wakes up the successor of h (normally whead). This is normally
     * just h.next, but may require traversal from wtail if next
     * pointers are lagging. This may fail to wake up an acquiring
     * thread when one or more have been cancelled, but the cancel
     * methods themselves provide extra safeguards to ensure liveness.
     */
    private void release(WNode h) {
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">        if (h != null) {</span>
            WNode q; Thread w;
<span class="fc" id="L1016">            U.compareAndSwapInt(h, WSTATUS, WAITING, 0);</span>
<span class="pc bpc" id="L1017" title="2 of 4 branches missed.">            if ((q = h.next) == null || q.status == CANCELLED) {</span>
<span class="nc bnc" id="L1018" title="All 4 branches missed.">                for (WNode t = wtail; t != null &amp;&amp; t != h; t = t.prev)</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                    if (t.status &lt;= 0)</span>
<span class="nc" id="L1020">                        q = t;</span>
            }
<span class="pc bpc" id="L1022" title="2 of 4 branches missed.">            if (q != null &amp;&amp; (w = q.thread) != null)</span>
<span class="fc" id="L1023">                U.unpark(w);</span>
        }
<span class="fc" id="L1025">    }</span>

    /**
     * See above for explanation.
     *
     * @param interruptible true if should check interrupts and if so
     * return INTERRUPTED
     * @param deadline if nonzero, the System.nanoTime value to timeout
     * at (and return zero)
     * @return next state, or INTERRUPTED
     */
    private long acquireWrite(boolean interruptible, long deadline) {
<span class="nc" id="L1037">        WNode node = null, p;</span>
<span class="nc" id="L1038">        for (int spins = -1;;) { // spin while enqueuing</span>
            long m, s, ns;
<span class="nc bnc" id="L1040" title="All 2 branches missed.">            if ((m = (s = state) &amp; ABITS) == 0L) {</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">                if (U.compareAndSwapLong(this, STATE, s, ns = s + WBIT))</span>
<span class="nc" id="L1042">                    return ns;</span>
            }
<span class="nc bnc" id="L1044" title="All 2 branches missed.">            else if (spins &lt; 0)</span>
<span class="nc bnc" id="L1045" title="All 4 branches missed.">                spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : 0;</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            else if (spins &gt; 0) {</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                if (LockSupport.nextSecondarySeed() &gt;= 0)</span>
<span class="nc" id="L1048">                    --spins;</span>
            }
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            else if ((p = wtail) == null) { // initialize queue</span>
<span class="nc" id="L1051">                WNode hd = new WNode(WMODE, null);</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">                if (U.compareAndSwapObject(this, WHEAD, null, hd))</span>
<span class="nc" id="L1053">                    wtail = hd;</span>
<span class="nc" id="L1054">            }</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">            else if (node == null)</span>
<span class="nc" id="L1056">                node = new WNode(WMODE, p);</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">            else if (node.prev != p)</span>
<span class="nc" id="L1058">                node.prev = p;</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">            else if (U.compareAndSwapObject(this, WTAIL, p, node)) {</span>
<span class="nc" id="L1060">                p.next = node;</span>
<span class="nc" id="L1061">                break;</span>
            }
<span class="nc" id="L1063">        }</span>

<span class="nc" id="L1065">        for (int spins = -1;;) {</span>
            WNode h, np, pp; int ps;
<span class="nc bnc" id="L1067" title="All 2 branches missed.">            if ((h = whead) == p) {</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                if (spins &lt; 0)</span>
<span class="nc" id="L1069">                    spins = HEAD_SPINS;</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                else if (spins &lt; MAX_HEAD_SPINS)</span>
<span class="nc" id="L1071">                    spins &lt;&lt;= 1;</span>
<span class="nc" id="L1072">                for (int k = spins;;) { // spin at head</span>
                    long s, ns;
<span class="nc bnc" id="L1074" title="All 2 branches missed.">                    if (((s = state) &amp; ABITS) == 0L) {</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">                        if (U.compareAndSwapLong(this, STATE, s,</span>
                                                 ns = s + WBIT)) {
<span class="nc" id="L1077">                            whead = node;</span>
<span class="nc" id="L1078">                            node.prev = null;</span>
<span class="nc" id="L1079">                            return ns;</span>
                        }
                    }
<span class="nc bnc" id="L1082" title="All 4 branches missed.">                    else if (LockSupport.nextSecondarySeed() &gt;= 0 &amp;&amp;</span>
                             --k &lt;= 0)
<span class="nc" id="L1084">                        break;</span>
<span class="nc" id="L1085">                }</span>
            }
<span class="nc bnc" id="L1087" title="All 2 branches missed.">            else if (h != null) { // help release stale waiters</span>
                WNode c; Thread w;
<span class="nc bnc" id="L1089" title="All 2 branches missed.">                while ((c = h.cowait) != null) {</span>
<span class="nc bnc" id="L1090" title="All 4 branches missed.">                    if (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span>
                        (w = c.thread) != null)
<span class="nc" id="L1092">                        U.unpark(w);</span>
                }
            }
<span class="nc bnc" id="L1095" title="All 2 branches missed.">            if (whead == h) {</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">                if ((np = node.prev) != p) {</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                    if (np != null)</span>
<span class="nc" id="L1098">                        (p = np).next = node;   // stale</span>
                }
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                else if ((ps = p.status) == 0)</span>
<span class="nc" id="L1101">                    U.compareAndSwapInt(p, WSTATUS, 0, WAITING);</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">                else if (ps == CANCELLED) {</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">                    if ((pp = p.prev) != null) {</span>
<span class="nc" id="L1104">                        node.prev = pp;</span>
<span class="nc" id="L1105">                        pp.next = node;</span>
                    }
                }
                else {
                    long time; // 0 argument to park means no timeout
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                    if (deadline == 0L)</span>
<span class="nc" id="L1111">                        time = 0L;</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">                    else if ((time = deadline - System.nanoTime()) &lt;= 0L)</span>
<span class="nc" id="L1113">                        return cancelWaiter(node, node, false);</span>
<span class="nc" id="L1114">                    Thread wt = Thread.currentThread();</span>
<span class="nc" id="L1115">                    U.putObject(wt, PARKBLOCKER, this);</span>
<span class="nc" id="L1116">                    node.thread = wt;</span>
<span class="nc bnc" id="L1117" title="All 10 branches missed.">                    if (p.status &lt; 0 &amp;&amp; (p != h || (state &amp; ABITS) != 0L) &amp;&amp;</span>
                        whead == h &amp;&amp; node.prev == p)
<span class="nc" id="L1119">                        U.park(false, time);  // emulate LockSupport.park</span>
<span class="nc" id="L1120">                    node.thread = null;</span>
<span class="nc" id="L1121">                    U.putObject(wt, PARKBLOCKER, null);</span>
<span class="nc bnc" id="L1122" title="All 4 branches missed.">                    if (interruptible &amp;&amp; Thread.interrupted())</span>
<span class="nc" id="L1123">                        return cancelWaiter(node, node, true);</span>
                }
            }
<span class="nc" id="L1126">        }</span>
    }

    /**
     * See above for explanation.
     *
     * @param interruptible true if should check interrupts and if so
     * return INTERRUPTED
     * @param deadline if nonzero, the System.nanoTime value to timeout
     * at (and return zero)
     * @return next state, or INTERRUPTED
     */
    private long acquireRead(boolean interruptible, long deadline) {
<span class="fc" id="L1139">        WNode node = null, p;</span>
<span class="fc" id="L1140">        for (int spins = -1;;) {</span>
            WNode h;
<span class="fc bfc" id="L1142" title="All 2 branches covered.">            if ((h = whead) == (p = wtail)) {</span>
                for (long m, s, ns;;) {
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">                    if ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span>
<span class="pc bpc" id="L1145" title="3 of 4 branches missed.">                        U.compareAndSwapLong(this, STATE, s, ns = s + RUNIT) :</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">                        (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != 0L))</span>
<span class="nc" id="L1147">                        return ns;</span>
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">                    else if (m &gt;= WBIT) {</span>
<span class="fc bfc" id="L1149" title="All 2 branches covered.">                        if (spins &gt; 0) {</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">                            if (LockSupport.nextSecondarySeed() &gt;= 0)</span>
<span class="fc" id="L1151">                                --spins;</span>
                        }
                        else {
<span class="fc bfc" id="L1154" title="All 2 branches covered.">                            if (spins == 0) {</span>
<span class="fc" id="L1155">                                WNode nh = whead, np = wtail;</span>
<span class="pc bpc" id="L1156" title="1 of 6 branches missed.">                                if ((nh == h &amp;&amp; np == p) || (h = nh) != (p = np))</span>
<span class="fc" id="L1157">                                    break;</span>
                            }
<span class="fc" id="L1159">                            spins = SPINS;</span>
                        }
                    }
                }
            }
<span class="fc bfc" id="L1164" title="All 2 branches covered.">            if (p == null) { // initialize queue</span>
<span class="fc" id="L1165">                WNode hd = new WNode(WMODE, null);</span>
<span class="pc bpc" id="L1166" title="1 of 2 branches missed.">                if (U.compareAndSwapObject(this, WHEAD, null, hd))</span>
<span class="fc" id="L1167">                    wtail = hd;</span>
<span class="fc" id="L1168">            }</span>
<span class="fc bfc" id="L1169" title="All 2 branches covered.">            else if (node == null)</span>
<span class="fc" id="L1170">                node = new WNode(RMODE, p);</span>
<span class="pc bpc" id="L1171" title="1 of 4 branches missed.">            else if (h == p || p.mode != RMODE) {</span>
<span class="pc bpc" id="L1172" title="1 of 2 branches missed.">                if (node.prev != p)</span>
<span class="nc" id="L1173">                    node.prev = p;</span>
<span class="fc bfc" id="L1174" title="All 2 branches covered.">                else if (U.compareAndSwapObject(this, WTAIL, p, node)) {</span>
<span class="fc" id="L1175">                    p.next = node;</span>
<span class="fc" id="L1176">                    break;</span>
                }
            }
<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">            else if (!U.compareAndSwapObject(p, WCOWAIT,</span>
                                             node.cowait = p.cowait, node))
<span class="nc" id="L1181">                node.cowait = null;</span>
            else {
                for (;;) {
                    WNode pp, c; Thread w;
<span class="pc bpc" id="L1185" title="2 of 4 branches missed.">                    if ((h = whead) != null &amp;&amp; (c = h.cowait) != null &amp;&amp;</span>
<span class="nc bnc" id="L1186" title="All 4 branches missed.">                        U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span>
                        (w = c.thread) != null) // help release
<span class="nc" id="L1188">                        U.unpark(w);</span>
<span class="pc bpc" id="L1189" title="3 of 6 branches missed.">                    if (h == (pp = p.prev) || h == p || pp == null) {</span>
                        long m, s, ns;
                        do {
<span class="fc bfc" id="L1192" title="All 2 branches covered.">                            if ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span>
<span class="pc bpc" id="L1193" title="2 of 4 branches missed.">                                U.compareAndSwapLong(this, STATE, s,</span>
                                                     ns = s + RUNIT) :
                                (m &lt; WBIT &amp;&amp;
<span class="nc bnc" id="L1196" title="All 2 branches missed.">                                 (ns = tryIncReaderOverflow(s)) != 0L))</span>
<span class="fc" id="L1197">                                return ns;</span>
<span class="pc bpc" id="L1198" title="1 of 2 branches missed.">                        } while (m &lt; WBIT);</span>
                    }
<span class="pc bpc" id="L1200" title="2 of 4 branches missed.">                    if (whead == h &amp;&amp; p.prev == pp) {</span>
                        long time;
<span class="pc bpc" id="L1202" title="3 of 6 branches missed.">                        if (pp == null || h == p || p.status &gt; 0) {</span>
<span class="nc" id="L1203">                            node = null; // throw away</span>
<span class="nc" id="L1204">                            break;</span>
                        }
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">                        if (deadline == 0L)</span>
<span class="fc" id="L1207">                            time = 0L;</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                        else if ((time = deadline - System.nanoTime()) &lt;= 0L)</span>
<span class="nc" id="L1209">                            return cancelWaiter(node, p, false);</span>
<span class="fc" id="L1210">                        Thread wt = Thread.currentThread();</span>
<span class="fc" id="L1211">                        U.putObject(wt, PARKBLOCKER, this);</span>
<span class="fc" id="L1212">                        node.thread = wt;</span>
<span class="pc bpc" id="L1213" title="4 of 8 branches missed.">                        if ((h != pp || (state &amp; ABITS) == WBIT) &amp;&amp;</span>
                            whead == h &amp;&amp; p.prev == pp)
<span class="fc" id="L1215">                            U.park(false, time);</span>
<span class="fc" id="L1216">                        node.thread = null;</span>
<span class="fc" id="L1217">                        U.putObject(wt, PARKBLOCKER, null);</span>
<span class="pc bpc" id="L1218" title="3 of 4 branches missed.">                        if (interruptible &amp;&amp; Thread.interrupted())</span>
<span class="nc" id="L1219">                            return cancelWaiter(node, p, true);</span>
                    }
<span class="fc" id="L1221">                }</span>
            }
<span class="fc" id="L1223">        }</span>

<span class="fc" id="L1225">        for (int spins = -1;;) {</span>
            WNode h, np, pp; int ps;
<span class="pc bpc" id="L1227" title="1 of 2 branches missed.">            if ((h = whead) == p) {</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">                if (spins &lt; 0)</span>
<span class="fc" id="L1229">                    spins = HEAD_SPINS;</span>
<span class="pc bpc" id="L1230" title="1 of 2 branches missed.">                else if (spins &lt; MAX_HEAD_SPINS)</span>
<span class="fc" id="L1231">                    spins &lt;&lt;= 1;</span>
<span class="fc" id="L1232">                for (int k = spins;;) { // spin at head</span>
                    long m, s, ns;
<span class="fc bfc" id="L1234" title="All 2 branches covered.">                    if ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span>
<span class="pc bpc" id="L1235" title="2 of 4 branches missed.">                        U.compareAndSwapLong(this, STATE, s, ns = s + RUNIT) :</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">                        (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != 0L)) {</span>
                        WNode c; Thread w;
<span class="fc" id="L1238">                        whead = node;</span>
<span class="fc" id="L1239">                        node.prev = null;</span>
<span class="fc bfc" id="L1240" title="All 2 branches covered.">                        while ((c = node.cowait) != null) {</span>
<span class="pc bpc" id="L1241" title="2 of 4 branches missed.">                            if (U.compareAndSwapObject(node, WCOWAIT,</span>
                                                       c, c.cowait) &amp;&amp;
                                (w = c.thread) != null)
<span class="fc" id="L1244">                                U.unpark(w);</span>
                        }
<span class="fc" id="L1246">                        return ns;</span>
                    }
<span class="pc bpc" id="L1248" title="1 of 2 branches missed.">                    else if (m &gt;= WBIT &amp;&amp;</span>
<span class="fc bfc" id="L1249" title="All 4 branches covered.">                             LockSupport.nextSecondarySeed() &gt;= 0 &amp;&amp; --k &lt;= 0)</span>
<span class="fc" id="L1250">                        break;</span>
<span class="fc" id="L1251">                }</span>
            }
<span class="nc bnc" id="L1253" title="All 2 branches missed.">            else if (h != null) {</span>
                WNode c; Thread w;
<span class="nc bnc" id="L1255" title="All 2 branches missed.">                while ((c = h.cowait) != null) {</span>
<span class="nc bnc" id="L1256" title="All 4 branches missed.">                    if (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span>
                        (w = c.thread) != null)
<span class="nc" id="L1258">                        U.unpark(w);</span>
                }
            }
<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">            if (whead == h) {</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">                if ((np = node.prev) != p) {</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">                    if (np != null)</span>
<span class="nc" id="L1264">                        (p = np).next = node;   // stale</span>
                }
<span class="fc bfc" id="L1266" title="All 2 branches covered.">                else if ((ps = p.status) == 0)</span>
<span class="fc" id="L1267">                    U.compareAndSwapInt(p, WSTATUS, 0, WAITING);</span>
<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">                else if (ps == CANCELLED) {</span>
<span class="nc bnc" id="L1269" title="All 2 branches missed.">                    if ((pp = p.prev) != null) {</span>
<span class="nc" id="L1270">                        node.prev = pp;</span>
<span class="nc" id="L1271">                        pp.next = node;</span>
                    }
                }
                else {
                    long time;
<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">                    if (deadline == 0L)</span>
<span class="fc" id="L1277">                        time = 0L;</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">                    else if ((time = deadline - System.nanoTime()) &lt;= 0L)</span>
<span class="nc" id="L1279">                        return cancelWaiter(node, node, false);</span>
<span class="fc" id="L1280">                    Thread wt = Thread.currentThread();</span>
<span class="fc" id="L1281">                    U.putObject(wt, PARKBLOCKER, this);</span>
<span class="fc" id="L1282">                    node.thread = wt;</span>
<span class="pc bpc" id="L1283" title="5 of 10 branches missed.">                    if (p.status &lt; 0 &amp;&amp;</span>
                        (p != h || (state &amp; ABITS) == WBIT) &amp;&amp;
                        whead == h &amp;&amp; node.prev == p)
<span class="fc" id="L1286">                        U.park(false, time);</span>
<span class="fc" id="L1287">                    node.thread = null;</span>
<span class="fc" id="L1288">                    U.putObject(wt, PARKBLOCKER, null);</span>
<span class="pc bpc" id="L1289" title="3 of 4 branches missed.">                    if (interruptible &amp;&amp; Thread.interrupted())</span>
<span class="nc" id="L1290">                        return cancelWaiter(node, node, true);</span>
                }
            }
<span class="fc" id="L1293">        }</span>
    }

    /**
     * If node non-null, forces cancel status and unsplices it from
     * queue if possible and wakes up any cowaiters (of the node, or
     * group, as applicable), and in any case helps release current
     * first waiter if lock is free. (Calling with null arguments
     * serves as a conditional form of release, which is not currently
     * needed but may be needed under possible future cancellation
     * policies). This is a variant of cancellation methods in
     * AbstractQueuedSynchronizer (see its detailed explanation in AQS
     * internal documentation).
     *
     * @param node if nonnull, the waiter
     * @param group either node or the group node is cowaiting with
     * @param interrupted if already interrupted
     * @return INTERRUPTED if interrupted or Thread.interrupted, else zero
     */
    private long cancelWaiter(WNode node, WNode group, boolean interrupted) {
<span class="nc bnc" id="L1313" title="All 4 branches missed.">        if (node != null &amp;&amp; group != null) {</span>
            Thread w;
<span class="nc" id="L1315">            node.status = CANCELLED;</span>
            // unsplice cancelled nodes from group
<span class="nc bnc" id="L1317" title="All 2 branches missed.">            for (WNode p = group, q; (q = p.cowait) != null;) {</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">                if (q.status == CANCELLED) {</span>
<span class="nc" id="L1319">                    U.compareAndSwapObject(p, WCOWAIT, q, q.cowait);</span>
<span class="nc" id="L1320">                    p = group; // restart</span>
                }
                else
<span class="nc" id="L1323">                    p = q;</span>
            }
<span class="nc bnc" id="L1325" title="All 2 branches missed.">            if (group == node) {</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">                for (WNode r = group.cowait; r != null; r = r.cowait) {</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">                    if ((w = r.thread) != null)</span>
<span class="nc" id="L1328">                        U.unpark(w);       // wake up uncancelled co-waiters</span>
                }
<span class="nc bnc" id="L1330" title="All 2 branches missed.">                for (WNode pred = node.prev; pred != null; ) { // unsplice</span>
                    WNode succ, pp;        // find valid successor
<span class="nc bnc" id="L1332" title="All 4 branches missed.">                    while ((succ = node.next) == null ||</span>
                           succ.status == CANCELLED) {
<span class="nc" id="L1334">                        WNode q = null;    // find successor the slow way</span>
<span class="nc bnc" id="L1335" title="All 4 branches missed.">                        for (WNode t = wtail; t != null &amp;&amp; t != node; t = t.prev)</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">                            if (t.status != CANCELLED)</span>
<span class="nc" id="L1337">                                q = t;     // don't link if succ cancelled</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">                        if (succ == q ||   // ensure accurate successor</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">                            U.compareAndSwapObject(node, WNEXT,</span>
                                                   succ, succ = q)) {
<span class="nc bnc" id="L1341" title="All 4 branches missed.">                            if (succ == null &amp;&amp; node == wtail)</span>
<span class="nc" id="L1342">                                U.compareAndSwapObject(this, WTAIL, node, pred);</span>
                            break;
                        }
<span class="nc" id="L1345">                    }</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">                    if (pred.next == node) // unsplice pred link</span>
<span class="nc" id="L1347">                        U.compareAndSwapObject(pred, WNEXT, node, succ);</span>
<span class="nc bnc" id="L1348" title="All 4 branches missed.">                    if (succ != null &amp;&amp; (w = succ.thread) != null) {</span>
<span class="nc" id="L1349">                        succ.thread = null;</span>
<span class="nc" id="L1350">                        U.unpark(w);       // wake up succ to observe new pred</span>
                    }
<span class="nc bnc" id="L1352" title="All 4 branches missed.">                    if (pred.status != CANCELLED || (pp = pred.prev) == null)</span>
<span class="nc" id="L1353">                        break;</span>
<span class="nc" id="L1354">                    node.prev = pp;        // repeat if new pred wrong/cancelled</span>
<span class="nc" id="L1355">                    U.compareAndSwapObject(pp, WNEXT, pred, succ);</span>
<span class="nc" id="L1356">                    pred = pp;</span>
<span class="nc" id="L1357">                }</span>
            }
        }
        WNode h; // Possibly release first waiter
<span class="nc bnc" id="L1361" title="All 2 branches missed.">        while ((h = whead) != null) {</span>
            long s; WNode q; // similar to release() but check eligibility
<span class="nc bnc" id="L1363" title="All 4 branches missed.">            if ((q = h.next) == null || q.status == CANCELLED) {</span>
<span class="nc bnc" id="L1364" title="All 4 branches missed.">                for (WNode t = wtail; t != null &amp;&amp; t != h; t = t.prev)</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">                    if (t.status &lt;= 0)</span>
<span class="nc" id="L1366">                        q = t;</span>
            }
<span class="nc bnc" id="L1368" title="All 2 branches missed.">            if (h == whead) {</span>
<span class="nc bnc" id="L1369" title="All 10 branches missed.">                if (q != null &amp;&amp; h.status == 0 &amp;&amp;</span>
                    ((s = state) &amp; ABITS) != WBIT &amp;&amp; // waiter is eligible
                    (s == 0L || q.mode == RMODE))
<span class="nc" id="L1372">                    release(h);</span>
                break;
            }
<span class="nc" id="L1375">        }</span>
<span class="nc bnc" id="L1376" title="All 4 branches missed.">        return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;</span>
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe U;
    private static final long STATE;
    private static final long WHEAD;
    private static final long WTAIL;
    private static final long WNEXT;
    private static final long WSTATUS;
    private static final long WCOWAIT;
    private static final long PARKBLOCKER;

    static {
        try {
<span class="fc" id="L1391">            U = sun.misc.Unsafe.getUnsafe();</span>
<span class="fc" id="L1392">            Class&lt;?&gt; k = StampedLock.class;</span>
<span class="fc" id="L1393">            Class&lt;?&gt; wk = WNode.class;</span>
<span class="fc" id="L1394">            STATE = U.objectFieldOffset</span>
<span class="fc" id="L1395">                (k.getDeclaredField(&quot;state&quot;));</span>
<span class="fc" id="L1396">            WHEAD = U.objectFieldOffset</span>
<span class="fc" id="L1397">                (k.getDeclaredField(&quot;whead&quot;));</span>
<span class="fc" id="L1398">            WTAIL = U.objectFieldOffset</span>
<span class="fc" id="L1399">                (k.getDeclaredField(&quot;wtail&quot;));</span>
<span class="fc" id="L1400">            WSTATUS = U.objectFieldOffset</span>
<span class="fc" id="L1401">                (wk.getDeclaredField(&quot;status&quot;));</span>
<span class="fc" id="L1402">            WNEXT = U.objectFieldOffset</span>
<span class="fc" id="L1403">                (wk.getDeclaredField(&quot;next&quot;));</span>
<span class="fc" id="L1404">            WCOWAIT = U.objectFieldOffset</span>
<span class="fc" id="L1405">                (wk.getDeclaredField(&quot;cowait&quot;));</span>
<span class="fc" id="L1406">            Class&lt;?&gt; tk = Thread.class;</span>
<span class="fc" id="L1407">            PARKBLOCKER = U.objectFieldOffset</span>
<span class="fc" id="L1408">                (tk.getDeclaredField(&quot;parkBlocker&quot;));</span>

<span class="nc" id="L1410">        } catch (Exception e) {</span>
<span class="nc" id="L1411">            throw new Error(e);</span>
<span class="fc" id="L1412">        }</span>
<span class="fc" id="L1413">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>