<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Reference.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.org.apache.xml.internal.security.signature</a> &gt; <span class="el_source">Reference.java</span></div><h1>Reference.java</h1><pre class="source lang-java linenums">/*
 * reserved comment block
 * DO NOT REMOVE OR ALTER!
 */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.sun.org.apache.xml.internal.security.signature;

import java.io.IOException;
import java.io.OutputStream;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import com.sun.org.apache.xml.internal.security.algorithms.MessageDigestAlgorithm;
import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException;
import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceData;
import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceNodeSetData;
import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceOctetStreamData;
import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceSubTreeData;
import com.sun.org.apache.xml.internal.security.transforms.InvalidTransformException;
import com.sun.org.apache.xml.internal.security.transforms.Transform;
import com.sun.org.apache.xml.internal.security.transforms.TransformationException;
import com.sun.org.apache.xml.internal.security.transforms.Transforms;
import com.sun.org.apache.xml.internal.security.transforms.params.InclusiveNamespaces;
import com.sun.org.apache.xml.internal.security.utils.Base64;
import com.sun.org.apache.xml.internal.security.utils.Constants;
import com.sun.org.apache.xml.internal.security.utils.DigesterOutputStream;
import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
import com.sun.org.apache.xml.internal.security.utils.UnsyncBufferedOutputStream;
import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverException;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;

/**
 * Handles &lt;code&gt;&amp;lt;ds:Reference&amp;gt;&lt;/code&gt; elements.
 *
 * This includes:
 *
 * Constructs a &lt;CODE&gt;ds:Reference&lt;/CODE&gt; from an {@link org.w3c.dom.Element}.
 *
 * &lt;p&gt;Create a new reference&lt;/p&gt;
 * &lt;pre&gt;
 * Document doc;
 * MessageDigestAlgorithm sha1 = MessageDigestAlgorithm.getInstance(&quot;http://#sha1&quot;);
 * Reference ref = new Reference(new XMLSignatureInput(new FileInputStream(&quot;1.gif&quot;),
 *                               &quot;http://localhost/1.gif&quot;,
 *                               (Transforms) null, sha1);
 * Element refElem = ref.toElement(doc);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Verify a reference&lt;/p&gt;
 * &lt;pre&gt;
 * Element refElem = doc.getElement(&quot;Reference&quot;); // PSEUDO
 * Reference ref = new Reference(refElem);
 * String url = ref.getURI();
 * ref.setData(new XMLSignatureInput(new FileInputStream(url)));
 * if (ref.verify()) {
 *    System.out.println(&quot;verified&quot;);
 * }
 * &lt;/pre&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;element name=&quot;Reference&quot; type=&quot;ds:ReferenceType&quot;/&amp;gt;
 *  &amp;lt;complexType name=&quot;ReferenceType&quot;&amp;gt;
 *    &amp;lt;sequence&amp;gt;
 *      &amp;lt;element ref=&quot;ds:Transforms&quot; minOccurs=&quot;0&quot;/&amp;gt;
 *      &amp;lt;element ref=&quot;ds:DigestMethod&quot;/&amp;gt;
 *      &amp;lt;element ref=&quot;ds:DigestValue&quot;/&amp;gt;
 *    &amp;lt;/sequence&amp;gt;
 *    &amp;lt;attribute name=&quot;Id&quot; type=&quot;ID&quot; use=&quot;optional&quot;/&amp;gt;
 *    &amp;lt;attribute name=&quot;URI&quot; type=&quot;anyURI&quot; use=&quot;optional&quot;/&amp;gt;
 *    &amp;lt;attribute name=&quot;Type&quot; type=&quot;anyURI&quot; use=&quot;optional&quot;/&amp;gt;
 *  &amp;lt;/complexType&amp;gt;
 * &lt;/pre&gt;
 *
 * @author Christian Geuer-Pollmann
 * @see ObjectContainer
 * @see Manifest
 */
public class Reference extends SignatureElementProxy {

    /** Field OBJECT_URI */
    public static final String OBJECT_URI = Constants.SignatureSpecNS + Constants._TAG_OBJECT;

    /** Field MANIFEST_URI */
    public static final String MANIFEST_URI = Constants.SignatureSpecNS + Constants._TAG_MANIFEST;

    /**
     * The maximum number of transforms per reference, if secure validation is enabled.
     */
    public static final int MAXIMUM_TRANSFORM_COUNT = 5;

    private boolean secureValidation;

    /**
     * Look up useC14N11 system property. If true, an explicit C14N11 transform
     * will be added if necessary when generating the signature. See section
     * 3.1.1 of http://www.w3.org/2007/xmlsec/Drafts/xmldsig-core/ for more info.
     */
<span class="nc" id="L127">    private static boolean useC14N11 = (</span>
<span class="nc" id="L128">        AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {</span>
            public Boolean run() {
<span class="nc" id="L130">                return Boolean.valueOf(Boolean.getBoolean(&quot;com.sun.org.apache.xml.internal.security.useC14N11&quot;));</span>
            }
<span class="nc" id="L132">        })).booleanValue();</span>

    /** {@link org.apache.commons.logging} logging facility */
<span class="nc" id="L135">    private static final java.util.logging.Logger log =</span>
<span class="nc" id="L136">        java.util.logging.Logger.getLogger(Reference.class.getName());</span>

    private Manifest manifest;
    private XMLSignatureInput transformsOutput;

    private Transforms transforms;

    private Element digestMethodElem;

    private Element digestValueElement;

    private ReferenceData referenceData;

    /**
     * Constructor Reference
     *
     * @param doc the {@link Document} in which &lt;code&gt;XMLsignature&lt;/code&gt; is placed
     * @param baseURI the URI of the resource where the XML instance will be stored
     * @param referenceURI URI indicate where is data which will digested
     * @param manifest
     * @param transforms {@link Transforms} applied to data
     * @param messageDigestAlgorithm {@link MessageDigestAlgorithm Digest algorithm} which is
     * applied to the data
     * TODO should we throw XMLSignatureException if MessageDigestAlgoURI is wrong?
     * @throws XMLSignatureException
     */
    protected Reference(
        Document doc, String baseURI, String referenceURI, Manifest manifest,
        Transforms transforms, String messageDigestAlgorithm
    ) throws XMLSignatureException {
<span class="nc" id="L166">        super(doc);</span>

<span class="nc" id="L168">        XMLUtils.addReturnToElement(this.constructionElement);</span>

<span class="nc" id="L170">        this.baseURI = baseURI;</span>
<span class="nc" id="L171">        this.manifest = manifest;</span>

<span class="nc" id="L173">        this.setURI(referenceURI);</span>

        // important: The ds:Reference must be added to the associated ds:Manifest
        //            or ds:SignedInfo _before_ the this.resolverResult() is called.
        // this.manifest.appendChild(this.constructionElement);
        // this.manifest.appendChild(this.doc.createTextNode(&quot;\n&quot;));

<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (transforms != null) {</span>
<span class="nc" id="L181">            this.transforms=transforms;</span>
<span class="nc" id="L182">            this.constructionElement.appendChild(transforms.getElement());</span>
<span class="nc" id="L183">            XMLUtils.addReturnToElement(this.constructionElement);</span>
        }
<span class="nc" id="L185">        MessageDigestAlgorithm mda =</span>
<span class="nc" id="L186">            MessageDigestAlgorithm.getInstance(this.doc, messageDigestAlgorithm);</span>

<span class="nc" id="L188">        digestMethodElem = mda.getElement();</span>
<span class="nc" id="L189">        this.constructionElement.appendChild(digestMethodElem);</span>
<span class="nc" id="L190">        XMLUtils.addReturnToElement(this.constructionElement);</span>

<span class="nc" id="L192">        digestValueElement =</span>
<span class="nc" id="L193">            XMLUtils.createElementInSignatureSpace(this.doc, Constants._TAG_DIGESTVALUE);</span>

<span class="nc" id="L195">        this.constructionElement.appendChild(digestValueElement);</span>
<span class="nc" id="L196">        XMLUtils.addReturnToElement(this.constructionElement);</span>
<span class="nc" id="L197">    }</span>


    /**
     * Build a {@link Reference} from an {@link Element}
     *
     * @param element &lt;code&gt;Reference&lt;/code&gt; element
     * @param baseURI the URI of the resource where the XML instance was stored
     * @param manifest is the {@link Manifest} of {@link SignedInfo} in which the Reference occurs.
     * We need this because the Manifest has the individual {@link ResourceResolver}s which have
     * been set by the user
     * @throws XMLSecurityException
     */
    protected Reference(Element element, String baseURI, Manifest manifest) throws XMLSecurityException {
<span class="nc" id="L211">        this(element, baseURI, manifest, false);</span>
<span class="nc" id="L212">    }</span>

    /**
     * Build a {@link Reference} from an {@link Element}
     *
     * @param element &lt;code&gt;Reference&lt;/code&gt; element
     * @param baseURI the URI of the resource where the XML instance was stored
     * @param manifest is the {@link Manifest} of {@link SignedInfo} in which the Reference occurs.
     * @param secureValidation whether secure validation is enabled or not
     * We need this because the Manifest has the individual {@link ResourceResolver}s which have
     * been set by the user
     * @throws XMLSecurityException
     */
    protected Reference(Element element, String baseURI, Manifest manifest, boolean secureValidation)
        throws XMLSecurityException {
<span class="nc" id="L227">        super(element, baseURI);</span>
<span class="nc" id="L228">        this.secureValidation = secureValidation;</span>
<span class="nc" id="L229">        this.baseURI = baseURI;</span>
<span class="nc" id="L230">        Element el = XMLUtils.getNextElement(element.getFirstChild());</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (Constants._TAG_TRANSFORMS.equals(el.getLocalName())</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">            &amp;&amp; Constants.SignatureSpecNS.equals(el.getNamespaceURI())) {</span>
<span class="nc" id="L233">            transforms = new Transforms(el, this.baseURI);</span>
<span class="nc" id="L234">            transforms.setSecureValidation(secureValidation);</span>
<span class="nc bnc" id="L235" title="All 4 branches missed.">            if (secureValidation &amp;&amp; transforms.getLength() &gt; MAXIMUM_TRANSFORM_COUNT) {</span>
<span class="nc" id="L236">                Object exArgs[] = { transforms.getLength(), MAXIMUM_TRANSFORM_COUNT };</span>

<span class="nc" id="L238">                throw new XMLSecurityException(&quot;signature.tooManyTransforms&quot;, exArgs);</span>
            }
<span class="nc" id="L240">            el = XMLUtils.getNextElement(el.getNextSibling());</span>
        }
<span class="nc" id="L242">        digestMethodElem = el;</span>
<span class="nc" id="L243">        digestValueElement = XMLUtils.getNextElement(digestMethodElem.getNextSibling());</span>
<span class="nc" id="L244">        this.manifest = manifest;</span>
<span class="nc" id="L245">    }</span>

    /**
     * Returns {@link MessageDigestAlgorithm}
     *
     *
     * @return {@link MessageDigestAlgorithm}
     *
     * @throws XMLSignatureException
     */
    public MessageDigestAlgorithm getMessageDigestAlgorithm() throws XMLSignatureException {
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (digestMethodElem == null) {</span>
<span class="nc" id="L257">            return null;</span>
        }

<span class="nc" id="L260">        String uri = digestMethodElem.getAttributeNS(null, Constants._ATT_ALGORITHM);</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (uri == null) {</span>
<span class="nc" id="L263">            return null;</span>
        }

<span class="nc bnc" id="L266" title="All 4 branches missed.">        if (secureValidation &amp;&amp; MessageDigestAlgorithm.ALGO_ID_DIGEST_NOT_RECOMMENDED_MD5.equals(uri)) {</span>
<span class="nc" id="L267">            Object exArgs[] = { uri };</span>

<span class="nc" id="L269">            throw new XMLSignatureException(&quot;signature.signatureAlgorithm&quot;, exArgs);</span>
        }

<span class="nc" id="L272">        return MessageDigestAlgorithm.getInstance(this.doc, uri);</span>
    }

    /**
     * Sets the &lt;code&gt;URI&lt;/code&gt; of this &lt;code&gt;Reference&lt;/code&gt; element
     *
     * @param uri the &lt;code&gt;URI&lt;/code&gt; of this &lt;code&gt;Reference&lt;/code&gt; element
     */
    public void setURI(String uri) {
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (uri != null) {</span>
<span class="nc" id="L282">            this.constructionElement.setAttributeNS(null, Constants._ATT_URI, uri);</span>
        }
<span class="nc" id="L284">    }</span>

    /**
     * Returns the &lt;code&gt;URI&lt;/code&gt; of this &lt;code&gt;Reference&lt;/code&gt; element
     *
     * @return URI the &lt;code&gt;URI&lt;/code&gt; of this &lt;code&gt;Reference&lt;/code&gt; element
     */
    public String getURI() {
<span class="nc" id="L292">        return this.constructionElement.getAttributeNS(null, Constants._ATT_URI);</span>
    }

    /**
     * Sets the &lt;code&gt;Id&lt;/code&gt; attribute of this &lt;code&gt;Reference&lt;/code&gt; element
     *
     * @param id the &lt;code&gt;Id&lt;/code&gt; attribute of this &lt;code&gt;Reference&lt;/code&gt; element
     */
    public void setId(String id) {
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (id != null) {</span>
<span class="nc" id="L302">            this.constructionElement.setAttributeNS(null, Constants._ATT_ID, id);</span>
<span class="nc" id="L303">            this.constructionElement.setIdAttributeNS(null, Constants._ATT_ID, true);</span>
        }
<span class="nc" id="L305">    }</span>

    /**
     * Returns the &lt;code&gt;Id&lt;/code&gt; attribute of this &lt;code&gt;Reference&lt;/code&gt; element
     *
     * @return Id the &lt;code&gt;Id&lt;/code&gt; attribute of this &lt;code&gt;Reference&lt;/code&gt; element
     */
    public String getId() {
<span class="nc" id="L313">        return this.constructionElement.getAttributeNS(null, Constants._ATT_ID);</span>
    }

    /**
     * Sets the &lt;code&gt;type&lt;/code&gt; atttibute of the Reference indicate whether an
     * &lt;code&gt;ds:Object&lt;/code&gt;, &lt;code&gt;ds:SignatureProperty&lt;/code&gt;, or &lt;code&gt;ds:Manifest&lt;/code&gt;
     * element.
     *
     * @param type the &lt;code&gt;type&lt;/code&gt; attribute of the Reference
     */
    public void setType(String type) {
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (type != null) {</span>
<span class="nc" id="L325">            this.constructionElement.setAttributeNS(null, Constants._ATT_TYPE, type);</span>
        }
<span class="nc" id="L327">    }</span>

    /**
     * Return the &lt;code&gt;type&lt;/code&gt; atttibute of the Reference indicate whether an
     * &lt;code&gt;ds:Object&lt;/code&gt;, &lt;code&gt;ds:SignatureProperty&lt;/code&gt;, or &lt;code&gt;ds:Manifest&lt;/code&gt;
     * element
     *
     * @return the &lt;code&gt;type&lt;/code&gt; attribute of the Reference
     */
    public String getType() {
<span class="nc" id="L337">        return this.constructionElement.getAttributeNS(null, Constants._ATT_TYPE);</span>
    }

    /**
     * Method isReferenceToObject
     *
     * This returns true if the &lt;CODE&gt;Type&lt;/CODE&gt; attribute of the
     * &lt;CODE&gt;Reference&lt;/CODE&gt; element points to a &lt;CODE&gt;#Object&lt;/CODE&gt; element
     *
     * @return true if the Reference type indicates that this Reference points to an
     * &lt;code&gt;Object&lt;/code&gt;
     */
    public boolean typeIsReferenceToObject() {
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (Reference.OBJECT_URI.equals(this.getType())) {</span>
<span class="nc" id="L351">            return true;</span>
        }

<span class="nc" id="L354">        return false;</span>
    }

    /**
     * Method isReferenceToManifest
     *
     * This returns true if the &lt;CODE&gt;Type&lt;/CODE&gt; attribute of the
     * &lt;CODE&gt;Reference&lt;/CODE&gt; element points to a &lt;CODE&gt;#Manifest&lt;/CODE&gt; element
     *
     * @return true if the Reference type indicates that this Reference points to a
     * {@link Manifest}
     */
    public boolean typeIsReferenceToManifest() {
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (Reference.MANIFEST_URI.equals(this.getType())) {</span>
<span class="nc" id="L368">            return true;</span>
        }

<span class="nc" id="L371">        return false;</span>
    }

    /**
     * Method setDigestValueElement
     *
     * @param digestValue
     */
    private void setDigestValueElement(byte[] digestValue) {
<span class="nc" id="L380">        Node n = digestValueElement.getFirstChild();</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        while (n != null) {</span>
<span class="nc" id="L382">            digestValueElement.removeChild(n);</span>
<span class="nc" id="L383">            n = n.getNextSibling();</span>
        }

<span class="nc" id="L386">        String base64codedValue = Base64.encode(digestValue);</span>
<span class="nc" id="L387">        Text t = this.doc.createTextNode(base64codedValue);</span>

<span class="nc" id="L389">        digestValueElement.appendChild(t);</span>
<span class="nc" id="L390">    }</span>

    /**
     * Method generateDigestValue
     *
     * @throws ReferenceNotInitializedException
     * @throws XMLSignatureException
     */
    public void generateDigestValue()
        throws XMLSignatureException, ReferenceNotInitializedException {
<span class="nc" id="L400">        this.setDigestValueElement(this.calculateDigest(false));</span>
<span class="nc" id="L401">    }</span>

    /**
     * Returns the XMLSignatureInput which is created by de-referencing the URI attribute.
     * @return the XMLSignatureInput of the source of this reference
     * @throws ReferenceNotInitializedException If the resolver found any
     * problem resolving the reference
     */
    public XMLSignatureInput getContentsBeforeTransformation()
        throws ReferenceNotInitializedException {
        try {
<span class="nc" id="L412">            Attr uriAttr =</span>
<span class="nc" id="L413">                this.constructionElement.getAttributeNodeNS(null, Constants._ATT_URI);</span>

<span class="nc" id="L415">            ResourceResolver resolver =</span>
<span class="nc" id="L416">                ResourceResolver.getInstance(</span>
<span class="nc" id="L417">                    uriAttr, this.baseURI, this.manifest.getPerManifestResolvers(), secureValidation</span>
                );
<span class="nc" id="L419">            resolver.addProperties(this.manifest.getResolverProperties());</span>

<span class="nc" id="L421">            return resolver.resolve(uriAttr, this.baseURI, secureValidation);</span>
<span class="nc" id="L422">        }  catch (ResourceResolverException ex) {</span>
<span class="nc" id="L423">            throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
        }
    }

    private XMLSignatureInput getContentsAfterTransformation(
        XMLSignatureInput input, OutputStream os
    ) throws XMLSignatureException {
        try {
<span class="nc" id="L431">            Transforms transforms = this.getTransforms();</span>
<span class="nc" id="L432">            XMLSignatureInput output = null;</span>

<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (transforms != null) {</span>
<span class="nc" id="L435">                output = transforms.performTransforms(input, os);</span>
<span class="nc" id="L436">                this.transformsOutput = output;//new XMLSignatureInput(output.getBytes());</span>

                //this.transformsOutput.setSourceURI(output.getSourceURI());
            } else {
<span class="nc" id="L440">                output = input;</span>
            }

<span class="nc" id="L443">            return output;</span>
<span class="nc" id="L444">        } catch (ResourceResolverException ex) {</span>
<span class="nc" id="L445">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L446">        } catch (CanonicalizationException ex) {</span>
<span class="nc" id="L447">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L448">        } catch (InvalidCanonicalizerException ex) {</span>
<span class="nc" id="L449">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L450">        } catch (TransformationException ex) {</span>
<span class="nc" id="L451">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L452">        } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L453">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
        }
    }

    /**
     * Returns the XMLSignatureInput which is the result of the Transforms.
     * @return a XMLSignatureInput with all transformations applied.
     * @throws XMLSignatureException
     */
    public XMLSignatureInput getContentsAfterTransformation()
        throws XMLSignatureException {
<span class="nc" id="L464">        XMLSignatureInput input = this.getContentsBeforeTransformation();</span>
<span class="nc" id="L465">        cacheDereferencedElement(input);</span>

<span class="nc" id="L467">        return this.getContentsAfterTransformation(input, null);</span>
    }

    /**
     * This method returns the XMLSignatureInput which represents the node set before
     * some kind of canonicalization is applied for the first time.
     * @return Gets a the node doing everything till the first c14n is needed
     *
     * @throws XMLSignatureException
     */
    public XMLSignatureInput getNodesetBeforeFirstCanonicalization()
        throws XMLSignatureException {
        try {
<span class="nc" id="L480">            XMLSignatureInput input = this.getContentsBeforeTransformation();</span>
<span class="nc" id="L481">            cacheDereferencedElement(input);</span>
<span class="nc" id="L482">            XMLSignatureInput output = input;</span>
<span class="nc" id="L483">            Transforms transforms = this.getTransforms();</span>

<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (transforms != null) {</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                doTransforms: for (int i = 0; i &lt; transforms.getLength(); i++) {</span>
<span class="nc" id="L487">                    Transform t = transforms.item(i);</span>
<span class="nc" id="L488">                    String uri = t.getURI();</span>

<span class="nc bnc" id="L490" title="All 2 branches missed.">                    if (uri.equals(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS)</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">                        || uri.equals(Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS)</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                        || uri.equals(Transforms.TRANSFORM_C14N_OMIT_COMMENTS)</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                        || uri.equals(Transforms.TRANSFORM_C14N_WITH_COMMENTS)) {</span>
<span class="nc" id="L494">                        break doTransforms;</span>
                    }

<span class="nc" id="L497">                    output = t.performTransform(output, null);</span>
                }

<span class="nc" id="L500">            output.setSourceURI(input.getSourceURI());</span>
            }
<span class="nc" id="L502">            return output;</span>
<span class="nc" id="L503">        } catch (IOException ex) {</span>
<span class="nc" id="L504">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L505">        } catch (ResourceResolverException ex) {</span>
<span class="nc" id="L506">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L507">        } catch (CanonicalizationException ex) {</span>
<span class="nc" id="L508">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L509">        } catch (InvalidCanonicalizerException ex) {</span>
<span class="nc" id="L510">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L511">        } catch (TransformationException ex) {</span>
<span class="nc" id="L512">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L513">        } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L514">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
        }
    }

    /**
     * Method getHTMLRepresentation
     * @return The HTML of the transformation
     * @throws XMLSignatureException
     */
    public String getHTMLRepresentation() throws XMLSignatureException {
        try {
<span class="nc" id="L525">            XMLSignatureInput nodes = this.getNodesetBeforeFirstCanonicalization();</span>

<span class="nc" id="L527">            Transforms transforms = this.getTransforms();</span>
<span class="nc" id="L528">            Transform c14nTransform = null;</span>

<span class="nc bnc" id="L530" title="All 2 branches missed.">            if (transforms != null) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                doTransforms: for (int i = 0; i &lt; transforms.getLength(); i++) {</span>
<span class="nc" id="L532">                    Transform t = transforms.item(i);</span>
<span class="nc" id="L533">                    String uri = t.getURI();</span>

<span class="nc bnc" id="L535" title="All 2 branches missed.">                    if (uri.equals(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS)</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                        || uri.equals(Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS)) {</span>
<span class="nc" id="L537">                        c14nTransform = t;</span>
<span class="nc" id="L538">                        break doTransforms;</span>
                    }
                }
            }

<span class="nc" id="L543">            Set&lt;String&gt; inclusiveNamespaces = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">            if (c14nTransform != null</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">                &amp;&amp; (c14nTransform.length(</span>
                    InclusiveNamespaces.ExclusiveCanonicalizationNamespace,
                    InclusiveNamespaces._TAG_EC_INCLUSIVENAMESPACES) == 1)) {

                // there is one InclusiveNamespaces element
<span class="nc" id="L550">                InclusiveNamespaces in =</span>
                    new InclusiveNamespaces(
<span class="nc" id="L552">                        XMLUtils.selectNode(</span>
<span class="nc" id="L553">                            c14nTransform.getElement().getFirstChild(),</span>
                            InclusiveNamespaces.ExclusiveCanonicalizationNamespace,
                            InclusiveNamespaces._TAG_EC_INCLUSIVENAMESPACES,
                            0
<span class="nc" id="L557">                        ), this.getBaseURI());</span>

<span class="nc" id="L559">                inclusiveNamespaces =</span>
<span class="nc" id="L560">                    InclusiveNamespaces.prefixStr2Set(in.getInclusiveNamespaces());</span>
            }

<span class="nc" id="L563">            return nodes.getHTMLRepresentation(inclusiveNamespaces);</span>
<span class="nc" id="L564">        } catch (TransformationException ex) {</span>
<span class="nc" id="L565">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L566">        } catch (InvalidTransformException ex) {</span>
<span class="nc" id="L567">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L568">        } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L569">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
        }
    }

    /**
     * This method only works works after a call to verify.
     * @return the transformed output(i.e. what is going to be digested).
     */
    public XMLSignatureInput getTransformsOutput() {
<span class="nc" id="L578">        return this.transformsOutput;</span>
    }

    /**
     * Get the ReferenceData that corresponds to the cached representation of the dereferenced
     * object before transformation.
     */
    public ReferenceData getReferenceData() {
<span class="nc" id="L586">        return referenceData;</span>
    }

    /**
     * This method returns the {@link XMLSignatureInput} which is referenced by the
     * &lt;CODE&gt;URI&lt;/CODE&gt; Attribute.
     * @param os where to write the transformation can be null.
     * @return the element to digest
     *
     * @throws XMLSignatureException
     * @see Manifest#verifyReferences()
     */
    protected XMLSignatureInput dereferenceURIandPerformTransforms(OutputStream os)
        throws XMLSignatureException {
        try {
<span class="nc" id="L601">            XMLSignatureInput input = this.getContentsBeforeTransformation();</span>
<span class="nc" id="L602">            cacheDereferencedElement(input);</span>

<span class="nc" id="L604">            XMLSignatureInput output = this.getContentsAfterTransformation(input, os);</span>
<span class="nc" id="L605">            this.transformsOutput = output;</span>
<span class="nc" id="L606">            return output;</span>
<span class="nc" id="L607">        } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L608">            throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
        }
    }

    /**
     * Store the dereferenced Element(s) so that it/they can be retrieved later.
     */
    private void cacheDereferencedElement(XMLSignatureInput input) {
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (input.isNodeSet()) {</span>
            try {
<span class="nc" id="L618">                final Set&lt;Node&gt; s = input.getNodeSet();</span>
<span class="nc" id="L619">                referenceData = new ReferenceNodeSetData() {</span>
                    public Iterator&lt;Node&gt; iterator() {
<span class="nc" id="L621">                        return new Iterator&lt;Node&gt;() {</span>

<span class="nc" id="L623">                            Iterator&lt;Node&gt; sIterator = s.iterator();</span>

                            public boolean hasNext() {
<span class="nc" id="L626">                                return sIterator.hasNext();</span>
                            }

                            public Node next() {
<span class="nc" id="L630">                                return sIterator.next();</span>
                            }

                            public void remove() {
<span class="nc" id="L634">                                throw new UnsupportedOperationException();</span>
                            }
                        };
                    }
                };
<span class="nc" id="L639">            } catch (Exception e) {</span>
                // log a warning
<span class="nc" id="L641">                log.log(java.util.logging.Level.WARNING, &quot;cannot cache dereferenced data: &quot; + e);</span>
<span class="nc" id="L642">            }</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">        } else if (input.isElement()) {</span>
<span class="nc" id="L644">            referenceData = new ReferenceSubTreeData</span>
<span class="nc" id="L645">                (input.getSubNode(), input.isExcludeComments());</span>
<span class="nc bnc" id="L646" title="All 4 branches missed.">        } else if (input.isOctetStream() || input.isByteArray()) {</span>
            try {
<span class="nc" id="L648">                referenceData = new ReferenceOctetStreamData</span>
<span class="nc" id="L649">                    (input.getOctetStream(), input.getSourceURI(),</span>
<span class="nc" id="L650">                        input.getMIMEType());</span>
<span class="nc" id="L651">            } catch (IOException ioe) {</span>
                // log a warning
<span class="nc" id="L653">                log.log(java.util.logging.Level.WARNING, &quot;cannot cache dereferenced data: &quot; + ioe);</span>
<span class="nc" id="L654">            }</span>
        }
<span class="nc" id="L656">    }</span>

    /**
     * Method getTransforms
     *
     * @return The transforms that applied this reference.
     * @throws InvalidTransformException
     * @throws TransformationException
     * @throws XMLSecurityException
     * @throws XMLSignatureException
     */
    public Transforms getTransforms()
        throws XMLSignatureException, InvalidTransformException,
        TransformationException, XMLSecurityException {
<span class="nc" id="L670">        return transforms;</span>
    }

    /**
     * Method getReferencedBytes
     *
     * @return the bytes that will be used to generated digest.
     * @throws ReferenceNotInitializedException
     * @throws XMLSignatureException
     */
    public byte[] getReferencedBytes()
        throws ReferenceNotInitializedException, XMLSignatureException {
        try {
<span class="nc" id="L683">            XMLSignatureInput output = this.dereferenceURIandPerformTransforms(null);</span>
<span class="nc" id="L684">            return output.getBytes();</span>
<span class="nc" id="L685">        } catch (IOException ex) {</span>
<span class="nc" id="L686">            throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L687">        } catch (CanonicalizationException ex) {</span>
<span class="nc" id="L688">            throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
        }
    }


    /**
     * Method calculateDigest
     *
     * @param validating true if validating the reference
     * @return reference Calculate the digest of this reference.
     * @throws ReferenceNotInitializedException
     * @throws XMLSignatureException
     */
    private byte[] calculateDigest(boolean validating)
        throws ReferenceNotInitializedException, XMLSignatureException {
<span class="nc" id="L703">        OutputStream os = null;</span>
        try {
<span class="nc" id="L705">            MessageDigestAlgorithm mda = this.getMessageDigestAlgorithm();</span>

<span class="nc" id="L707">            mda.reset();</span>
<span class="nc" id="L708">            DigesterOutputStream diOs = new DigesterOutputStream(mda);</span>
<span class="nc" id="L709">            os = new UnsyncBufferedOutputStream(diOs);</span>
<span class="nc" id="L710">            XMLSignatureInput output = this.dereferenceURIandPerformTransforms(os);</span>
            // if signing and c14n11 property == true explicitly add
            // C14N11 transform if needed
<span class="nc bnc" id="L713" title="All 6 branches missed.">            if (Reference.useC14N11 &amp;&amp; !validating &amp;&amp; !output.isOutputStreamSet()</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">                &amp;&amp; !output.isOctetStream()) {</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                if (transforms == null) {</span>
<span class="nc" id="L716">                    transforms = new Transforms(this.doc);</span>
<span class="nc" id="L717">                    transforms.setSecureValidation(secureValidation);</span>
<span class="nc" id="L718">                    this.constructionElement.insertBefore(transforms.getElement(), digestMethodElem);</span>
                }
<span class="nc" id="L720">                transforms.addTransform(Transforms.TRANSFORM_C14N11_OMIT_COMMENTS);</span>
<span class="nc" id="L721">                output.updateOutputStream(os, true);</span>
            } else {
<span class="nc" id="L723">                output.updateOutputStream(os);</span>
            }
<span class="nc" id="L725">            os.flush();</span>

<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (output.getOctetStreamReal() != null) {</span>
<span class="nc" id="L728">                output.getOctetStreamReal().close();</span>
            }

            //this.getReferencedBytes(diOs);
            //mda.update(data);

<span class="nc" id="L734">            return diOs.getDigestValue();</span>
<span class="nc" id="L735">        } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L736">            throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L737">        } catch (IOException ex) {</span>
<span class="nc" id="L738">            throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
        } finally {
<span class="nc bnc" id="L740" title="All 4 branches missed.">            if (os != null) {</span>
                try {
<span class="nc" id="L742">                    os.close();</span>
<span class="nc" id="L743">                } catch (IOException ex) {</span>
<span class="nc" id="L744">                    throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L745">                }</span>
            }
        }
    }

    /**
     * Returns the digest value.
     *
     * @return the digest value.
     * @throws Base64DecodingException if Reference contains no proper base64 encoded data.
     * @throws XMLSecurityException if the Reference does not contain a DigestValue element
     */
    public byte[] getDigestValue() throws Base64DecodingException, XMLSecurityException {
<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (digestValueElement == null) {</span>
            // The required element is not in the XML!
<span class="nc" id="L760">            Object[] exArgs ={ Constants._TAG_DIGESTVALUE, Constants.SignatureSpecNS };</span>
<span class="nc" id="L761">            throw new XMLSecurityException(</span>
                &quot;signature.Verification.NoSignatureElement&quot;, exArgs
            );
        }
<span class="nc" id="L765">        return Base64.decode(digestValueElement);</span>
    }


    /**
     * Tests reference validation is success or false
     *
     * @return true if reference validation is success, otherwise false
     * @throws ReferenceNotInitializedException
     * @throws XMLSecurityException
     */
    public boolean verify()
        throws ReferenceNotInitializedException, XMLSecurityException {
<span class="nc" id="L778">        byte[] elemDig = this.getDigestValue();</span>
<span class="nc" id="L779">        byte[] calcDig = this.calculateDigest(true);</span>
<span class="nc" id="L780">        boolean equal = MessageDigestAlgorithm.isEqual(elemDig, calcDig);</span>

<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (!equal) {</span>
<span class="nc" id="L783">            log.log(java.util.logging.Level.WARNING, &quot;Verification failed for URI \&quot;&quot; + this.getURI() + &quot;\&quot;&quot;);</span>
<span class="nc" id="L784">            log.log(java.util.logging.Level.WARNING, &quot;Expected Digest: &quot; + Base64.encode(elemDig));</span>
<span class="nc" id="L785">            log.log(java.util.logging.Level.WARNING, &quot;Actual Digest: &quot; + Base64.encode(calcDig));</span>
        } else {
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L788">                log.log(java.util.logging.Level.FINE, &quot;Verification successful for URI \&quot;&quot; + this.getURI() + &quot;\&quot;&quot;);</span>
            }
        }

<span class="nc" id="L792">        return equal;</span>
    }

    /**
     * Method getBaseLocalName
     * @inheritDoc
     */
    public String getBaseLocalName() {
<span class="nc" id="L800">        return Constants._TAG_REFERENCE;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>