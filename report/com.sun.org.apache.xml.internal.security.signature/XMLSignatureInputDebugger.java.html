<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>XMLSignatureInputDebugger.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.org.apache.xml.internal.security.signature</a> &gt; <span class="el_source">XMLSignatureInputDebugger.java</span></div><h1>XMLSignatureInputDebugger.java</h1><pre class="source lang-java linenums">/*
 * reserved comment block
 * DO NOT REMOVE OR ALTER!
 */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.sun.org.apache.xml.internal.security.signature;

import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Arrays;
import java.util.Set;

import com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare;
import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
import org.w3c.dom.Attr;
import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.ProcessingInstruction;

/**
 * Class XMLSignatureInputDebugger
 */
public class XMLSignatureInputDebugger {

    /** Field _xmlSignatureInput */
    private Set&lt;Node&gt; xpathNodeSet;

    private Set&lt;String&gt; inclusiveNamespaces;

    /** Field doc */
<span class="nc" id="L52">    private Document doc = null;</span>

    /** Field writer */
<span class="nc" id="L55">    private Writer writer = null;</span>

    /** The HTML Prefix* */
    static final String HTMLPrefix =
        &quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot;&gt;\n&quot;
        + &quot;&lt;html&gt;\n&quot;
        + &quot;&lt;head&gt;\n&quot;
        + &quot;&lt;title&gt;Caninical XML node set&lt;/title&gt;\n&quot;
        + &quot;&lt;style type=\&quot;text/css\&quot;&gt;\n&quot;
        + &quot;&lt;!-- \n&quot;
        + &quot;.INCLUDED { \n&quot;
        + &quot;   color: #000000; \n&quot;
        + &quot;   background-color: \n&quot;
        + &quot;   #FFFFFF; \n&quot;
        + &quot;   font-weight: bold; } \n&quot;
        + &quot;.EXCLUDED { \n&quot;
        + &quot;   color: #666666; \n&quot;
        + &quot;   background-color: \n&quot;
        + &quot;   #999999; } \n&quot;
        + &quot;.INCLUDEDINCLUSIVENAMESPACE { \n&quot;
        + &quot;   color: #0000FF; \n&quot;
        + &quot;   background-color: #FFFFFF; \n&quot;
        + &quot;   font-weight: bold; \n&quot;
        + &quot;   font-style: italic; } \n&quot;
        + &quot;.EXCLUDEDINCLUSIVENAMESPACE { \n&quot;
        + &quot;   color: #0000FF; \n&quot;
        + &quot;   background-color: #999999; \n&quot;
        + &quot;   font-style: italic; } \n&quot;
        + &quot;--&gt; \n&quot;
        + &quot;&lt;/style&gt; \n&quot;
        + &quot;&lt;/head&gt;\n&quot;
        + &quot;&lt;body bgcolor=\&quot;#999999\&quot;&gt;\n&quot;
        + &quot;&lt;h1&gt;Explanation of the output&lt;/h1&gt;\n&quot;
        + &quot;&lt;p&gt;The following text contains the nodeset of the given Reference before it is canonicalized. There exist four different styles to indicate how a given node is treated.&lt;/p&gt;\n&quot;
        + &quot;&lt;ul&gt;\n&quot;
        + &quot;&lt;li class=\&quot;INCLUDED\&quot;&gt;A node which is in the node set is labeled using the INCLUDED style.&lt;/li&gt;\n&quot;
        + &quot;&lt;li class=\&quot;EXCLUDED\&quot;&gt;A node which is &lt;em&gt;NOT&lt;/em&gt; in the node set is labeled EXCLUDED style.&lt;/li&gt;\n&quot;
        + &quot;&lt;li class=\&quot;INCLUDEDINCLUSIVENAMESPACE\&quot;&gt;A namespace which is in the node set AND in the InclusiveNamespaces PrefixList is labeled using the INCLUDEDINCLUSIVENAMESPACE style.&lt;/li&gt;\n&quot;
        + &quot;&lt;li class=\&quot;EXCLUDEDINCLUSIVENAMESPACE\&quot;&gt;A namespace which is in NOT the node set AND in the InclusiveNamespaces PrefixList is labeled using the INCLUDEDINCLUSIVENAMESPACE style.&lt;/li&gt;\n&quot;
        + &quot;&lt;/ul&gt;\n&quot; + &quot;&lt;h1&gt;Output&lt;/h1&gt;\n&quot; + &quot;&lt;pre&gt;\n&quot;;

    /** HTML Suffix * */
    static final String HTMLSuffix = &quot;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&quot;;

    static final String HTMLExcludePrefix = &quot;&lt;span class=\&quot;EXCLUDED\&quot;&gt;&quot;;

    static final String HTMLIncludePrefix = &quot;&lt;span class=\&quot;INCLUDED\&quot;&gt;&quot;;

    static final String HTMLIncludeOrExcludeSuffix = &quot;&lt;/span&gt;&quot;;

    static final String HTMLIncludedInclusiveNamespacePrefix = &quot;&lt;span class=\&quot;INCLUDEDINCLUSIVENAMESPACE\&quot;&gt;&quot;;

    static final String HTMLExcludedInclusiveNamespacePrefix = &quot;&lt;span class=\&quot;EXCLUDEDINCLUSIVENAMESPACE\&quot;&gt;&quot;;

    private static final int NODE_BEFORE_DOCUMENT_ELEMENT = -1;

    private static final int NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT = 0;

    private static final int NODE_AFTER_DOCUMENT_ELEMENT = 1;

<span class="nc" id="L115">    static final AttrCompare ATTR_COMPARE = new AttrCompare();</span>

    /**
     * Constructor XMLSignatureInputDebugger
     *
     * @param xmlSignatureInput the signature to pretty print
     */
<span class="nc" id="L122">    public XMLSignatureInputDebugger(XMLSignatureInput xmlSignatureInput) {</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (!xmlSignatureInput.isNodeSet()) {</span>
<span class="nc" id="L124">            this.xpathNodeSet = null;</span>
        } else {
<span class="nc" id="L126">            this.xpathNodeSet = xmlSignatureInput.getInputNodeSet();</span>
        }
<span class="nc" id="L128">    }</span>

    /**
     * Constructor XMLSignatureInputDebugger
     *
     * @param xmlSignatureInput the signatur to pretty print
     * @param inclusiveNamespace
     */
    public XMLSignatureInputDebugger(
        XMLSignatureInput xmlSignatureInput,
        Set&lt;String&gt; inclusiveNamespace
    ) {
<span class="nc" id="L140">        this(xmlSignatureInput);</span>
<span class="nc" id="L141">        this.inclusiveNamespaces = inclusiveNamespace;</span>
<span class="nc" id="L142">    }</span>

    /**
     * Method getHTMLRepresentation
     *
     * @return The HTML Representation.
     * @throws XMLSignatureException
     */
    public String getHTMLRepresentation() throws XMLSignatureException {
<span class="nc bnc" id="L151" title="All 4 branches missed.">        if ((this.xpathNodeSet == null) || (this.xpathNodeSet.size() == 0)) {</span>
<span class="nc" id="L152">            return HTMLPrefix + &quot;&lt;blink&gt;no node set, sorry&lt;/blink&gt;&quot; + HTMLSuffix;</span>
        }

        // get only a single node as anchor to fetch the owner document
<span class="nc" id="L156">        Node n = this.xpathNodeSet.iterator().next();</span>

<span class="nc" id="L158">        this.doc = XMLUtils.getOwnerDocument(n);</span>

        try {
<span class="nc" id="L161">            this.writer = new StringWriter();</span>

<span class="nc" id="L163">            this.canonicalizeXPathNodeSet(this.doc);</span>
<span class="nc" id="L164">            this.writer.close();</span>

<span class="nc" id="L166">            return this.writer.toString();</span>
<span class="nc" id="L167">        } catch (IOException ex) {</span>
<span class="nc" id="L168">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
        } finally {
<span class="nc" id="L170">            this.xpathNodeSet = null;</span>
<span class="nc" id="L171">            this.doc = null;</span>
<span class="nc" id="L172">            this.writer = null;</span>
        }
    }

    /**
     * Method canonicalizeXPathNodeSet
     *
     * @param currentNode
     * @throws XMLSignatureException
     * @throws IOException
     */
    private void canonicalizeXPathNodeSet(Node currentNode)
        throws XMLSignatureException, IOException {

<span class="nc" id="L186">        int currentNodeType = currentNode.getNodeType();</span>
<span class="nc bnc" id="L187" title="All 7 branches missed.">        switch (currentNodeType) {</span>


        case Node.ENTITY_NODE:
        case Node.NOTATION_NODE:
        case Node.DOCUMENT_FRAGMENT_NODE:
        case Node.ATTRIBUTE_NODE:
<span class="nc" id="L194">            throw new XMLSignatureException(&quot;empty&quot;);</span>
        case Node.DOCUMENT_NODE:
<span class="nc" id="L196">            this.writer.write(HTMLPrefix);</span>

<span class="nc" id="L198">            for (Node currentChild = currentNode.getFirstChild();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                currentChild != null; currentChild = currentChild.getNextSibling()) {</span>
<span class="nc" id="L200">                this.canonicalizeXPathNodeSet(currentChild);</span>
            }

<span class="nc" id="L203">            this.writer.write(HTMLSuffix);</span>
<span class="nc" id="L204">            break;</span>

        case Node.COMMENT_NODE:
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (this.xpathNodeSet.contains(currentNode)) {</span>
<span class="nc" id="L208">                this.writer.write(HTMLIncludePrefix);</span>
            } else {
<span class="nc" id="L210">                this.writer.write(HTMLExcludePrefix);</span>
            }

<span class="nc" id="L213">            int position = getPositionRelativeToDocumentElement(currentNode);</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">            if (position == NODE_AFTER_DOCUMENT_ELEMENT) {</span>
<span class="nc" id="L216">                this.writer.write(&quot;\n&quot;);</span>
            }

<span class="nc" id="L219">            this.outputCommentToWriter((Comment) currentNode);</span>

<span class="nc bnc" id="L221" title="All 2 branches missed.">            if (position == NODE_BEFORE_DOCUMENT_ELEMENT) {</span>
<span class="nc" id="L222">                this.writer.write(&quot;\n&quot;);</span>
            }

<span class="nc" id="L225">            this.writer.write(HTMLIncludeOrExcludeSuffix);</span>
<span class="nc" id="L226">            break;</span>

        case Node.PROCESSING_INSTRUCTION_NODE:
<span class="nc bnc" id="L229" title="All 2 branches missed.">            if (this.xpathNodeSet.contains(currentNode)) {</span>
<span class="nc" id="L230">                this.writer.write(HTMLIncludePrefix);</span>
            } else {
<span class="nc" id="L232">                this.writer.write(HTMLExcludePrefix);</span>
            }

<span class="nc" id="L235">            position = getPositionRelativeToDocumentElement(currentNode);</span>

<span class="nc bnc" id="L237" title="All 2 branches missed.">            if (position == NODE_AFTER_DOCUMENT_ELEMENT) {</span>
<span class="nc" id="L238">                this.writer.write(&quot;\n&quot;);</span>
            }

<span class="nc" id="L241">            this.outputPItoWriter((ProcessingInstruction) currentNode);</span>

<span class="nc bnc" id="L243" title="All 2 branches missed.">            if (position == NODE_BEFORE_DOCUMENT_ELEMENT) {</span>
<span class="nc" id="L244">                this.writer.write(&quot;\n&quot;);</span>
            }

<span class="nc" id="L247">            this.writer.write(HTMLIncludeOrExcludeSuffix);</span>
<span class="nc" id="L248">            break;</span>

        case Node.TEXT_NODE:
        case Node.CDATA_SECTION_NODE:
<span class="nc bnc" id="L252" title="All 2 branches missed.">            if (this.xpathNodeSet.contains(currentNode)) {</span>
<span class="nc" id="L253">                this.writer.write(HTMLIncludePrefix);</span>
            } else {
<span class="nc" id="L255">                this.writer.write(HTMLExcludePrefix);</span>
            }

<span class="nc" id="L258">            outputTextToWriter(currentNode.getNodeValue());</span>

<span class="nc" id="L260">            for (Node nextSibling = currentNode.getNextSibling();</span>
                (nextSibling != null)
<span class="nc bnc" id="L262" title="All 4 branches missed.">                &amp;&amp; ((nextSibling.getNodeType() == Node.TEXT_NODE)</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                    || (nextSibling.getNodeType() == Node.CDATA_SECTION_NODE));</span>
<span class="nc" id="L264">                nextSibling = nextSibling.getNextSibling()) {</span>
                /*
                 * The XPath data model allows to select only the first of a
                 * sequence of mixed text and CDATA nodes. But we must output
                 * them all, so we must search:
                 *
                 * @see http://nagoya.apache.org/bugzilla/show_bug.cgi?id=6329
                 */
<span class="nc" id="L272">                this.outputTextToWriter(nextSibling.getNodeValue());</span>
            }

<span class="nc" id="L275">            this.writer.write(HTMLIncludeOrExcludeSuffix);</span>
<span class="nc" id="L276">            break;</span>

        case Node.ELEMENT_NODE:
<span class="nc" id="L279">            Element currentElement = (Element) currentNode;</span>

<span class="nc bnc" id="L281" title="All 2 branches missed.">            if (this.xpathNodeSet.contains(currentNode)) {</span>
<span class="nc" id="L282">                this.writer.write(HTMLIncludePrefix);</span>
            } else {
<span class="nc" id="L284">                this.writer.write(HTMLExcludePrefix);</span>
            }

<span class="nc" id="L287">            this.writer.write(&quot;&amp;lt;&quot;);</span>
<span class="nc" id="L288">            this.writer.write(currentElement.getTagName());</span>

<span class="nc" id="L290">            this.writer.write(HTMLIncludeOrExcludeSuffix);</span>

            // we output all Attrs which are available
<span class="nc" id="L293">            NamedNodeMap attrs = currentElement.getAttributes();</span>
<span class="nc" id="L294">            int attrsLength = attrs.getLength();</span>
<span class="nc" id="L295">            Attr attrs2[] = new Attr[attrsLength];</span>

<span class="nc bnc" id="L297" title="All 2 branches missed.">            for (int i = 0; i &lt; attrsLength; i++) {</span>
<span class="nc" id="L298">                attrs2[i] = (Attr)attrs.item(i);</span>
            }

<span class="nc" id="L301">            Arrays.sort(attrs2, ATTR_COMPARE);</span>
<span class="nc" id="L302">            Object attrs3[] = attrs2;</span>

<span class="nc bnc" id="L304" title="All 2 branches missed.">            for (int i = 0; i &lt; attrsLength; i++) {</span>
<span class="nc" id="L305">                Attr a = (Attr) attrs3[i];</span>
<span class="nc" id="L306">                boolean included = this.xpathNodeSet.contains(a);</span>
<span class="nc" id="L307">                boolean inclusive = this.inclusiveNamespaces.contains(a.getName());</span>

<span class="nc bnc" id="L309" title="All 2 branches missed.">                if (included) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                    if (inclusive) {</span>
                        // included and inclusive
<span class="nc" id="L312">                        this.writer.write(HTMLIncludedInclusiveNamespacePrefix);</span>
                    } else {
                        // included and not inclusive
<span class="nc" id="L315">                        this.writer.write(HTMLIncludePrefix);</span>
                    }
                } else {
<span class="nc bnc" id="L318" title="All 2 branches missed.">                    if (inclusive) {</span>
                        // excluded and inclusive
<span class="nc" id="L320">                        this.writer.write(HTMLExcludedInclusiveNamespacePrefix);</span>
                    } else {
                        // excluded and not inclusive
<span class="nc" id="L323">                        this.writer.write(HTMLExcludePrefix);</span>
                    }
                }

<span class="nc" id="L327">                this.outputAttrToWriter(a.getNodeName(), a.getNodeValue());</span>
<span class="nc" id="L328">                this.writer.write(HTMLIncludeOrExcludeSuffix);</span>
            }

<span class="nc bnc" id="L331" title="All 2 branches missed.">            if (this.xpathNodeSet.contains(currentNode)) {</span>
<span class="nc" id="L332">                this.writer.write(HTMLIncludePrefix);</span>
            } else {
<span class="nc" id="L334">                this.writer.write(HTMLExcludePrefix);</span>
            }

<span class="nc" id="L337">            this.writer.write(&quot;&amp;gt;&quot;);</span>

<span class="nc" id="L339">            this.writer.write(HTMLIncludeOrExcludeSuffix);</span>

            // traversal
<span class="nc" id="L342">            for (Node currentChild = currentNode.getFirstChild();</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                currentChild != null;</span>
<span class="nc" id="L344">                currentChild = currentChild.getNextSibling()) {</span>
<span class="nc" id="L345">                this.canonicalizeXPathNodeSet(currentChild);</span>
            }

<span class="nc bnc" id="L348" title="All 2 branches missed.">            if (this.xpathNodeSet.contains(currentNode)) {</span>
<span class="nc" id="L349">                this.writer.write(HTMLIncludePrefix);</span>
            } else {
<span class="nc" id="L351">                this.writer.write(HTMLExcludePrefix);</span>
            }

<span class="nc" id="L354">            this.writer.write(&quot;&amp;lt;/&quot;);</span>
<span class="nc" id="L355">            this.writer.write(currentElement.getTagName());</span>
<span class="nc" id="L356">            this.writer.write(&quot;&amp;gt;&quot;);</span>

<span class="nc" id="L358">            this.writer.write(HTMLIncludeOrExcludeSuffix);</span>
<span class="nc" id="L359">            break;</span>

        case Node.DOCUMENT_TYPE_NODE:
        default:
            break;
        }
<span class="nc" id="L365">    }</span>

    /**
     * Checks whether a Comment or ProcessingInstruction is before or after the
     * document element. This is needed for prepending or appending &quot;\n&quot;s.
     *
     * @param currentNode
     *            comment or pi to check
     * @return NODE_BEFORE_DOCUMENT_ELEMENT,
     *         NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT or
     *         NODE_AFTER_DOCUMENT_ELEMENT
     * @see #NODE_BEFORE_DOCUMENT_ELEMENT
     * @see #NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT
     * @see #NODE_AFTER_DOCUMENT_ELEMENT
     */
    private int getPositionRelativeToDocumentElement(Node currentNode) {
<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (currentNode == null) {</span>
<span class="nc" id="L382">            return NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;</span>
        }

<span class="nc" id="L385">        Document doc = currentNode.getOwnerDocument();</span>

<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (currentNode.getParentNode() != doc) {</span>
<span class="nc" id="L388">            return NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;</span>
        }

<span class="nc" id="L391">        Element documentElement = doc.getDocumentElement();</span>

<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (documentElement == null) {</span>
<span class="nc" id="L394">            return NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;</span>
        }

<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (documentElement == currentNode) {</span>
<span class="nc" id="L398">            return NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;</span>
        }

<span class="nc bnc" id="L401" title="All 2 branches missed.">        for (Node x = currentNode; x != null; x = x.getNextSibling()) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if (x == documentElement) {</span>
<span class="nc" id="L403">                return NODE_BEFORE_DOCUMENT_ELEMENT;</span>
            }
        }

<span class="nc" id="L407">        return NODE_AFTER_DOCUMENT_ELEMENT;</span>
    }

    /**
     * Normalizes an {@link Attr}ibute value
     *
     * The string value of the node is modified by replacing
     * &lt;UL&gt;
     * &lt;LI&gt;all ampersands (&amp;) with &lt;CODE&gt;&amp;amp;amp;&lt;/CODE&gt;&lt;/LI&gt;
     * &lt;LI&gt;all open angle brackets (&lt;) with &lt;CODE&gt;&amp;amp;lt;&lt;/CODE&gt;&lt;/LI&gt;
     * &lt;LI&gt;all quotation mark characters with &lt;CODE&gt;&amp;amp;quot;&lt;/CODE&gt;&lt;/LI&gt;
     * &lt;LI&gt;and the whitespace characters &lt;CODE&gt;#x9&lt;/CODE&gt;, #xA, and #xD,
     * with character references. The character references are written in
     * uppercase hexadecimal with no leading zeroes (for example, &lt;CODE&gt;#xD&lt;/CODE&gt;
     * is represented by the character reference &lt;CODE&gt;&amp;amp;#xD;&lt;/CODE&gt;)&lt;/LI&gt;
     * &lt;/UL&gt;
     *
     * @param name
     * @param value
     * @throws IOException
     */
    private void outputAttrToWriter(String name, String value) throws IOException {
<span class="nc" id="L429">        this.writer.write(&quot; &quot;);</span>
<span class="nc" id="L430">        this.writer.write(name);</span>
<span class="nc" id="L431">        this.writer.write(&quot;=\&quot;&quot;);</span>

<span class="nc" id="L433">        int length = value.length();</span>

<span class="nc bnc" id="L435" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L436">            char c = value.charAt(i);</span>

<span class="nc bnc" id="L438" title="All 7 branches missed.">            switch (c) {</span>

            case '&amp;':
<span class="nc" id="L441">                this.writer.write(&quot;&amp;amp;amp;&quot;);</span>
<span class="nc" id="L442">                break;</span>

            case '&lt;':
<span class="nc" id="L445">                this.writer.write(&quot;&amp;amp;lt;&quot;);</span>
<span class="nc" id="L446">                break;</span>

            case '&quot;':
<span class="nc" id="L449">                this.writer.write(&quot;&amp;amp;quot;&quot;);</span>
<span class="nc" id="L450">                break;</span>

            case 0x09: // '\t'
<span class="nc" id="L453">                this.writer.write(&quot;&amp;amp;#x9;&quot;);</span>
<span class="nc" id="L454">                break;</span>

            case 0x0A: // '\n'
<span class="nc" id="L457">                this.writer.write(&quot;&amp;amp;#xA;&quot;);</span>
<span class="nc" id="L458">                break;</span>

            case 0x0D: // '\r'
<span class="nc" id="L461">                this.writer.write(&quot;&amp;amp;#xD;&quot;);</span>
<span class="nc" id="L462">                break;</span>

            default:
<span class="nc" id="L465">                this.writer.write(c);</span>
                break;
            }
        }

<span class="nc" id="L470">        this.writer.write(&quot;\&quot;&quot;);</span>
<span class="nc" id="L471">    }</span>

    /**
     * Normalizes a {@link org.w3c.dom.Comment} value
     *
     * @param currentPI
     * @throws IOException
     */
    private void outputPItoWriter(ProcessingInstruction currentPI) throws IOException {

<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (currentPI == null) {</span>
<span class="nc" id="L482">            return;</span>
        }

<span class="nc" id="L485">        this.writer.write(&quot;&amp;lt;?&quot;);</span>

<span class="nc" id="L487">        String target = currentPI.getTarget();</span>
<span class="nc" id="L488">        int length = target.length();</span>

<span class="nc bnc" id="L490" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L491">            char c = target.charAt(i);</span>

<span class="nc bnc" id="L493" title="All 4 branches missed.">            switch (c) {</span>

            case 0x0D:
<span class="nc" id="L496">                this.writer.write(&quot;&amp;amp;#xD;&quot;);</span>
<span class="nc" id="L497">                break;</span>

            case ' ':
<span class="nc" id="L500">                this.writer.write(&quot;&amp;middot;&quot;);</span>
<span class="nc" id="L501">                break;</span>

            case '\n':
<span class="nc" id="L504">                this.writer.write(&quot;&amp;para;\n&quot;);</span>
<span class="nc" id="L505">                break;</span>

            default:
<span class="nc" id="L508">                this.writer.write(c);</span>
                break;
            }
        }

<span class="nc" id="L513">        String data = currentPI.getData();</span>

<span class="nc" id="L515">        length = data.length();</span>

<span class="nc bnc" id="L517" title="All 2 branches missed.">        if (length &gt; 0) {</span>
<span class="nc" id="L518">            this.writer.write(&quot; &quot;);</span>

<span class="nc bnc" id="L520" title="All 2 branches missed.">            for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L521">                char c = data.charAt(i);</span>

<span class="nc bnc" id="L523" title="All 2 branches missed.">                switch (c) {</span>

                case 0x0D:
<span class="nc" id="L526">                    this.writer.write(&quot;&amp;amp;#xD;&quot;);</span>
<span class="nc" id="L527">                    break;</span>

                default:
<span class="nc" id="L530">                    this.writer.write(c);</span>
                    break;
                }
            }
        }

<span class="nc" id="L536">        this.writer.write(&quot;?&amp;gt;&quot;);</span>
<span class="nc" id="L537">    }</span>

    /**
     * Method outputCommentToWriter
     *
     * @param currentComment
     * @throws IOException
     */
    private void outputCommentToWriter(Comment currentComment) throws IOException {

<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (currentComment == null) {</span>
<span class="nc" id="L548">            return;</span>
        }

<span class="nc" id="L551">        this.writer.write(&quot;&amp;lt;!--&quot;);</span>

<span class="nc" id="L553">        String data = currentComment.getData();</span>
<span class="nc" id="L554">        int length = data.length();</span>

<span class="nc bnc" id="L556" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L557">            char c = data.charAt(i);</span>

<span class="nc bnc" id="L559" title="All 4 branches missed.">            switch (c) {</span>

            case 0x0D:
<span class="nc" id="L562">                this.writer.write(&quot;&amp;amp;#xD;&quot;);</span>
<span class="nc" id="L563">                break;</span>

            case ' ':
<span class="nc" id="L566">                this.writer.write(&quot;&amp;middot;&quot;);</span>
<span class="nc" id="L567">                break;</span>

            case '\n':
<span class="nc" id="L570">                this.writer.write(&quot;&amp;para;\n&quot;);</span>
<span class="nc" id="L571">                break;</span>

            default:
<span class="nc" id="L574">                this.writer.write(c);</span>
                break;
            }
        }

<span class="nc" id="L579">        this.writer.write(&quot;--&amp;gt;&quot;);</span>
<span class="nc" id="L580">    }</span>

    /**
     * Method outputTextToWriter
     *
     * @param text
     * @throws IOException
     */
    private void outputTextToWriter(String text) throws IOException {
<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L590">            return;</span>
        }

<span class="nc" id="L593">        int length = text.length();</span>

<span class="nc bnc" id="L595" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L596">            char c = text.charAt(i);</span>

<span class="nc bnc" id="L598" title="All 7 branches missed.">            switch (c) {</span>

            case '&amp;':
<span class="nc" id="L601">                this.writer.write(&quot;&amp;amp;amp;&quot;);</span>
<span class="nc" id="L602">                break;</span>

            case '&lt;':
<span class="nc" id="L605">                this.writer.write(&quot;&amp;amp;lt;&quot;);</span>
<span class="nc" id="L606">                break;</span>

            case '&gt;':
<span class="nc" id="L609">                this.writer.write(&quot;&amp;amp;gt;&quot;);</span>
<span class="nc" id="L610">                break;</span>

            case 0xD:
<span class="nc" id="L613">                this.writer.write(&quot;&amp;amp;#xD;&quot;);</span>
<span class="nc" id="L614">                break;</span>

            case ' ':
<span class="nc" id="L617">                this.writer.write(&quot;&amp;middot;&quot;);</span>
<span class="nc" id="L618">                break;</span>

            case '\n':
<span class="nc" id="L621">                this.writer.write(&quot;&amp;para;\n&quot;);</span>
<span class="nc" id="L622">                break;</span>

            default:
<span class="nc" id="L625">                this.writer.write(c);</span>
                break;
            }
        }
<span class="nc" id="L629">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>