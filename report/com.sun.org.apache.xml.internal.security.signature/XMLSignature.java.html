<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>XMLSignature.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.org.apache.xml.internal.security.signature</a> &gt; <span class="el_source">XMLSignature.java</span></div><h1>XMLSignature.java</h1><pre class="source lang-java linenums">/*
 * reserved comment block
 * DO NOT REMOVE OR ALTER!
 */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.sun.org.apache.xml.internal.security.signature;

import java.io.IOException;
import java.io.OutputStream;
import java.security.Key;
import java.security.PublicKey;
import java.security.cert.X509Certificate;

import javax.crypto.SecretKey;

import com.sun.org.apache.xml.internal.security.algorithms.SignatureAlgorithm;
import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException;
import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
import com.sun.org.apache.xml.internal.security.keys.KeyInfo;
import com.sun.org.apache.xml.internal.security.keys.content.X509Data;
import com.sun.org.apache.xml.internal.security.transforms.Transforms;
import com.sun.org.apache.xml.internal.security.utils.Base64;
import com.sun.org.apache.xml.internal.security.utils.Constants;
import com.sun.org.apache.xml.internal.security.utils.I18n;
import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
import com.sun.org.apache.xml.internal.security.utils.SignerOutputStream;
import com.sun.org.apache.xml.internal.security.utils.UnsyncBufferedOutputStream;
import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverSpi;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

/**
 * Handles &lt;code&gt;&amp;lt;ds:Signature&amp;gt;&lt;/code&gt; elements.
 * This is the main class that deals with creating and verifying signatures.
 *
 * &lt;p&gt;There are 2 types of constructors for this class. The ones that take a
 * document, baseURI and 1 or more Java Objects. This is mostly used for
 * signing purposes.
 * The other constructor is the one that takes a DOM Element and a baseURI.
 * This is used mostly with for verifying, when you have a SignatureElement.
 *
 * There are a few different types of methods:
 * &lt;ul&gt;&lt;li&gt;The addDocument* methods are used to add References with optional
 * transforms during signing. &lt;/li&gt;
 * &lt;li&gt;addKeyInfo* methods are to add Certificates and Keys to the
 * KeyInfo tags during signing. &lt;/li&gt;
 * &lt;li&gt;appendObject allows a user to add any XML Structure as an
 * ObjectContainer during signing.&lt;/li&gt;
 * &lt;li&gt;sign and checkSignatureValue methods are used to sign and validate the
 * signature. &lt;/li&gt;&lt;/ul&gt;
 */
public final class XMLSignature extends SignatureElementProxy {

    /** MAC - Required HMAC-SHA1 */
    public static final String ALGO_ID_MAC_HMAC_SHA1 =
        Constants.SignatureSpecNS + &quot;hmac-sha1&quot;;

    /** Signature - Required DSAwithSHA1 (DSS) */
    public static final String ALGO_ID_SIGNATURE_DSA =
        Constants.SignatureSpecNS + &quot;dsa-sha1&quot;;

    /** Signature - Recommended RSAwithSHA1 */
    public static final String ALGO_ID_SIGNATURE_RSA =
        Constants.SignatureSpecNS + &quot;rsa-sha1&quot;;

    /** Signature - Recommended RSAwithSHA1 */
    public static final String ALGO_ID_SIGNATURE_RSA_SHA1 =
        Constants.SignatureSpecNS + &quot;rsa-sha1&quot;;

    /** Signature - NOT Recommended RSAwithMD5 */
    public static final String ALGO_ID_SIGNATURE_NOT_RECOMMENDED_RSA_MD5 =
        Constants.MoreAlgorithmsSpecNS + &quot;rsa-md5&quot;;

    /** Signature - Optional RSAwithRIPEMD160 */
    public static final String ALGO_ID_SIGNATURE_RSA_RIPEMD160 =
        Constants.MoreAlgorithmsSpecNS + &quot;rsa-ripemd160&quot;;

    /** Signature - Optional RSAwithSHA256 */
    public static final String ALGO_ID_SIGNATURE_RSA_SHA256 =
        Constants.MoreAlgorithmsSpecNS + &quot;rsa-sha256&quot;;

    /** Signature - Optional RSAwithSHA384 */
    public static final String ALGO_ID_SIGNATURE_RSA_SHA384 =
        Constants.MoreAlgorithmsSpecNS + &quot;rsa-sha384&quot;;

    /** Signature - Optional RSAwithSHA512 */
    public static final String ALGO_ID_SIGNATURE_RSA_SHA512 =
        Constants.MoreAlgorithmsSpecNS + &quot;rsa-sha512&quot;;

    /** HMAC - NOT Recommended HMAC-MD5 */
    public static final String ALGO_ID_MAC_HMAC_NOT_RECOMMENDED_MD5 =
        Constants.MoreAlgorithmsSpecNS + &quot;hmac-md5&quot;;

    /** HMAC - Optional HMAC-RIPEMD160 */
    public static final String ALGO_ID_MAC_HMAC_RIPEMD160 =
        Constants.MoreAlgorithmsSpecNS + &quot;hmac-ripemd160&quot;;

    /** HMAC - Optional HMAC-SHA256 */
    public static final String ALGO_ID_MAC_HMAC_SHA256 =
        Constants.MoreAlgorithmsSpecNS + &quot;hmac-sha256&quot;;

    /** HMAC - Optional HMAC-SHA284 */
    public static final String ALGO_ID_MAC_HMAC_SHA384 =
        Constants.MoreAlgorithmsSpecNS + &quot;hmac-sha384&quot;;

    /** HMAC - Optional HMAC-SHA512 */
    public static final String ALGO_ID_MAC_HMAC_SHA512 =
        Constants.MoreAlgorithmsSpecNS + &quot;hmac-sha512&quot;;

    /**Signature - Optional ECDSAwithSHA1 */
    public static final String ALGO_ID_SIGNATURE_ECDSA_SHA1 =
        &quot;http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1&quot;;

    /**Signature - Optional ECDSAwithSHA256 */
    public static final String ALGO_ID_SIGNATURE_ECDSA_SHA256 =
        &quot;http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256&quot;;

    /**Signature - Optional ECDSAwithSHA384 */
    public static final String ALGO_ID_SIGNATURE_ECDSA_SHA384 =
        &quot;http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384&quot;;

    /**Signature - Optional ECDSAwithSHA512 */
    public static final String ALGO_ID_SIGNATURE_ECDSA_SHA512 =
        &quot;http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512&quot;;

    /** {@link org.apache.commons.logging} logging facility */
<span class="nc" id="L153">    private static java.util.logging.Logger log =</span>
<span class="nc" id="L154">        java.util.logging.Logger.getLogger(XMLSignature.class.getName());</span>

    /** ds:Signature.ds:SignedInfo element */
    private SignedInfo signedInfo;

    /** ds:Signature.ds:KeyInfo */
    private KeyInfo keyInfo;

    /**
     * Checking the digests in References in a Signature are mandatory, but for
     * References inside a Manifest it is application specific. This boolean is
     * to indicate that the References inside Manifests should be validated.
     */
<span class="nc" id="L167">    private boolean followManifestsDuringValidation = false;</span>

    private Element signatureValueElement;

    private static final int MODE_SIGN = 0;
    private static final int MODE_VERIFY = 1;
<span class="nc" id="L173">    private int state = MODE_SIGN;</span>

    /**
     * This creates a new &lt;CODE&gt;ds:Signature&lt;/CODE&gt; Element and adds an empty
     * &lt;CODE&gt;ds:SignedInfo&lt;/CODE&gt;.
     * The &lt;code&gt;ds:SignedInfo&lt;/code&gt; is initialized with the specified Signature
     * algorithm and Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS which is REQUIRED
     * by the spec. This method's main use is for creating a new signature.
     *
     * @param doc Document in which the signature will be appended after creation.
     * @param baseURI URI to be used as context for all relative URIs.
     * @param signatureMethodURI signature algorithm to use.
     * @throws XMLSecurityException
     */
    public XMLSignature(Document doc, String baseURI, String signatureMethodURI)
        throws XMLSecurityException {
<span class="nc" id="L189">        this(doc, baseURI, signatureMethodURI, 0, Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS);</span>
<span class="nc" id="L190">    }</span>

    /**
     * Constructor XMLSignature
     *
     * @param doc
     * @param baseURI
     * @param signatureMethodURI the Signature method to be used.
     * @param hmacOutputLength
     * @throws XMLSecurityException
     */
    public XMLSignature(Document doc, String baseURI, String signatureMethodURI,
                        int hmacOutputLength) throws XMLSecurityException {
<span class="nc" id="L203">        this(</span>
            doc, baseURI, signatureMethodURI, hmacOutputLength,
            Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS
        );
<span class="nc" id="L207">    }</span>

    /**
     * Constructor XMLSignature
     *
     * @param doc
     * @param baseURI
     * @param signatureMethodURI the Signature method to be used.
     * @param canonicalizationMethodURI the canonicalization algorithm to be
     * used to c14nize the SignedInfo element.
     * @throws XMLSecurityException
     */
    public XMLSignature(
        Document doc,
        String baseURI,
        String signatureMethodURI,
        String canonicalizationMethodURI
    ) throws XMLSecurityException {
<span class="nc" id="L225">        this(doc, baseURI, signatureMethodURI, 0, canonicalizationMethodURI);</span>
<span class="nc" id="L226">    }</span>

    /**
     * Constructor XMLSignature
     *
     * @param doc
     * @param baseURI
     * @param signatureMethodURI
     * @param hmacOutputLength
     * @param canonicalizationMethodURI
     * @throws XMLSecurityException
     */
    public XMLSignature(
        Document doc,
        String baseURI,
        String signatureMethodURI,
        int hmacOutputLength,
        String canonicalizationMethodURI
    ) throws XMLSecurityException {
<span class="nc" id="L245">        super(doc);</span>

<span class="nc" id="L247">        String xmlnsDsPrefix = getDefaultPrefix(Constants.SignatureSpecNS);</span>
<span class="nc bnc" id="L248" title="All 4 branches missed.">        if (xmlnsDsPrefix == null || xmlnsDsPrefix.length() == 0) {</span>
<span class="nc" id="L249">            this.constructionElement.setAttributeNS(</span>
                Constants.NamespaceSpecNS, &quot;xmlns&quot;, Constants.SignatureSpecNS
            );
        } else {
<span class="nc" id="L253">            this.constructionElement.setAttributeNS(</span>
                Constants.NamespaceSpecNS, &quot;xmlns:&quot; + xmlnsDsPrefix, Constants.SignatureSpecNS
            );
        }
<span class="nc" id="L257">        XMLUtils.addReturnToElement(this.constructionElement);</span>

<span class="nc" id="L259">        this.baseURI = baseURI;</span>
<span class="nc" id="L260">        this.signedInfo =</span>
            new SignedInfo(
                this.doc, signatureMethodURI, hmacOutputLength, canonicalizationMethodURI
            );

<span class="nc" id="L265">        this.constructionElement.appendChild(this.signedInfo.getElement());</span>
<span class="nc" id="L266">        XMLUtils.addReturnToElement(this.constructionElement);</span>

        // create an empty SignatureValue; this is filled by setSignatureValueElement
<span class="nc" id="L269">        signatureValueElement =</span>
<span class="nc" id="L270">            XMLUtils.createElementInSignatureSpace(this.doc, Constants._TAG_SIGNATUREVALUE);</span>

<span class="nc" id="L272">        this.constructionElement.appendChild(signatureValueElement);</span>
<span class="nc" id="L273">        XMLUtils.addReturnToElement(this.constructionElement);</span>
<span class="nc" id="L274">    }</span>

    /**
     *  Creates a XMLSignature in a Document
     * @param doc
     * @param baseURI
     * @param SignatureMethodElem
     * @param CanonicalizationMethodElem
     * @throws XMLSecurityException
     */
    public XMLSignature(
        Document doc,
        String baseURI,
        Element SignatureMethodElem,
        Element CanonicalizationMethodElem
    ) throws XMLSecurityException {
<span class="nc" id="L290">        super(doc);</span>

<span class="nc" id="L292">        String xmlnsDsPrefix = getDefaultPrefix(Constants.SignatureSpecNS);</span>
<span class="nc bnc" id="L293" title="All 4 branches missed.">        if (xmlnsDsPrefix == null || xmlnsDsPrefix.length() == 0) {</span>
<span class="nc" id="L294">            this.constructionElement.setAttributeNS(</span>
                Constants.NamespaceSpecNS, &quot;xmlns&quot;, Constants.SignatureSpecNS
            );
        } else {
<span class="nc" id="L298">            this.constructionElement.setAttributeNS(</span>
                Constants.NamespaceSpecNS, &quot;xmlns:&quot; + xmlnsDsPrefix, Constants.SignatureSpecNS
            );
        }
<span class="nc" id="L302">        XMLUtils.addReturnToElement(this.constructionElement);</span>

<span class="nc" id="L304">        this.baseURI = baseURI;</span>
<span class="nc" id="L305">        this.signedInfo =</span>
            new SignedInfo(this.doc, SignatureMethodElem, CanonicalizationMethodElem);

<span class="nc" id="L308">        this.constructionElement.appendChild(this.signedInfo.getElement());</span>
<span class="nc" id="L309">        XMLUtils.addReturnToElement(this.constructionElement);</span>

        // create an empty SignatureValue; this is filled by setSignatureValueElement
<span class="nc" id="L312">        signatureValueElement =</span>
<span class="nc" id="L313">            XMLUtils.createElementInSignatureSpace(this.doc, Constants._TAG_SIGNATUREVALUE);</span>

<span class="nc" id="L315">        this.constructionElement.appendChild(signatureValueElement);</span>
<span class="nc" id="L316">        XMLUtils.addReturnToElement(this.constructionElement);</span>
<span class="nc" id="L317">    }</span>

    /**
     * This will parse the element and construct the Java Objects.
     * That will allow a user to validate the signature.
     *
     * @param element ds:Signature element that contains the whole signature
     * @param baseURI URI to be prepended to all relative URIs
     * @throws XMLSecurityException
     * @throws XMLSignatureException if the signature is badly formatted
     */
    public XMLSignature(Element element, String baseURI)
        throws XMLSignatureException, XMLSecurityException {
<span class="nc" id="L330">        this(element, baseURI, false);</span>
<span class="nc" id="L331">    }</span>

    /**
     * This will parse the element and construct the Java Objects.
     * That will allow a user to validate the signature.
     *
     * @param element ds:Signature element that contains the whole signature
     * @param baseURI URI to be prepended to all relative URIs
     * @param secureValidation whether secure secureValidation is enabled or not
     * @throws XMLSecurityException
     * @throws XMLSignatureException if the signature is badly formatted
     */
    public XMLSignature(Element element, String baseURI, boolean secureValidation)
        throws XMLSignatureException, XMLSecurityException {
<span class="nc" id="L345">        super(element, baseURI);</span>

        // check out SignedInfo child
<span class="nc" id="L348">        Element signedInfoElem = XMLUtils.getNextElement(element.getFirstChild());</span>

        // check to see if it is there
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if (signedInfoElem == null) {</span>
<span class="nc" id="L352">            Object exArgs[] = { Constants._TAG_SIGNEDINFO, Constants._TAG_SIGNATURE };</span>
<span class="nc" id="L353">            throw new XMLSignatureException(&quot;xml.WrongContent&quot;, exArgs);</span>
        }

        // create a SignedInfo object from that element
<span class="nc" id="L357">        this.signedInfo = new SignedInfo(signedInfoElem, baseURI, secureValidation);</span>
        // get signedInfoElem again in case it has changed
<span class="nc" id="L359">        signedInfoElem = XMLUtils.getNextElement(element.getFirstChild());</span>

        // check out SignatureValue child
<span class="nc" id="L362">        this.signatureValueElement =</span>
<span class="nc" id="L363">            XMLUtils.getNextElement(signedInfoElem.getNextSibling());</span>

        // check to see if it exists
<span class="nc bnc" id="L366" title="All 2 branches missed.">        if (signatureValueElement == null) {</span>
<span class="nc" id="L367">            Object exArgs[] = { Constants._TAG_SIGNATUREVALUE, Constants._TAG_SIGNATURE };</span>
<span class="nc" id="L368">            throw new XMLSignatureException(&quot;xml.WrongContent&quot;, exArgs);</span>
        }
<span class="nc" id="L370">        Attr signatureValueAttr = signatureValueElement.getAttributeNodeNS(null, &quot;Id&quot;);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (signatureValueAttr != null) {</span>
<span class="nc" id="L372">            signatureValueElement.setIdAttributeNode(signatureValueAttr, true);</span>
        }

        // &lt;element ref=&quot;ds:KeyInfo&quot; minOccurs=&quot;0&quot;/&gt;
<span class="nc" id="L376">        Element keyInfoElem =</span>
<span class="nc" id="L377">            XMLUtils.getNextElement(signatureValueElement.getNextSibling());</span>

        // If it exists use it, but it's not mandatory
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (keyInfoElem != null</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">            &amp;&amp; keyInfoElem.getNamespaceURI().equals(Constants.SignatureSpecNS)</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            &amp;&amp; keyInfoElem.getLocalName().equals(Constants._TAG_KEYINFO)) {</span>
<span class="nc" id="L383">            this.keyInfo = new KeyInfo(keyInfoElem, baseURI);</span>
<span class="nc" id="L384">            this.keyInfo.setSecureValidation(secureValidation);</span>
        }

        // &lt;element ref=&quot;ds:Object&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
<span class="nc" id="L388">        Element objectElem =</span>
<span class="nc" id="L389">            XMLUtils.getNextElement(signatureValueElement.getNextSibling());</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        while (objectElem != null) {</span>
<span class="nc" id="L391">            Attr objectAttr = objectElem.getAttributeNodeNS(null, &quot;Id&quot;);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (objectAttr != null) {</span>
<span class="nc" id="L393">                objectElem.setIdAttributeNode(objectAttr, true);</span>
            }

<span class="nc" id="L396">            NodeList nodes = objectElem.getChildNodes();</span>
<span class="nc" id="L397">            int length = nodes.getLength();</span>
            // Register Ids of the Object child elements
<span class="nc bnc" id="L399" title="All 2 branches missed.">            for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L400">                Node child = nodes.item(i);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">                if (child.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="nc" id="L402">                    Element childElem = (Element)child;</span>
<span class="nc" id="L403">                    String tag = childElem.getLocalName();</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                    if (tag.equals(&quot;Manifest&quot;)) {</span>
<span class="nc" id="L405">                        new Manifest(childElem, baseURI);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                    } else if (tag.equals(&quot;SignatureProperties&quot;)) {</span>
<span class="nc" id="L407">                        new SignatureProperties(childElem, baseURI);</span>
                    }
                }
            }

<span class="nc" id="L412">            objectElem = XMLUtils.getNextElement(objectElem.getNextSibling());</span>
<span class="nc" id="L413">        }</span>

<span class="nc" id="L415">        this.state = MODE_VERIFY;</span>
<span class="nc" id="L416">    }</span>

    /**
     * Sets the &lt;code&gt;Id&lt;/code&gt; attribute
     *
     * @param id Id value for the id attribute on the Signature Element
     */
    public void setId(String id) {
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (id != null) {</span>
<span class="nc" id="L425">            this.constructionElement.setAttributeNS(null, Constants._ATT_ID, id);</span>
<span class="nc" id="L426">            this.constructionElement.setIdAttributeNS(null, Constants._ATT_ID, true);</span>
        }
<span class="nc" id="L428">    }</span>

    /**
     * Returns the &lt;code&gt;Id&lt;/code&gt; attribute
     *
     * @return the &lt;code&gt;Id&lt;/code&gt; attribute
     */
    public String getId() {
<span class="nc" id="L436">        return this.constructionElement.getAttributeNS(null, Constants._ATT_ID);</span>
    }

    /**
     * Returns the completely parsed &lt;code&gt;SignedInfo&lt;/code&gt; object.
     *
     * @return the completely parsed &lt;code&gt;SignedInfo&lt;/code&gt; object.
     */
    public SignedInfo getSignedInfo() {
<span class="nc" id="L445">        return this.signedInfo;</span>
    }

    /**
     * Returns the octet value of the SignatureValue element.
     * Throws an XMLSignatureException if it has no or wrong content.
     *
     * @return the value of the SignatureValue element.
     * @throws XMLSignatureException If there is no content
     */
    public byte[] getSignatureValue() throws XMLSignatureException {
        try {
<span class="nc" id="L457">            return Base64.decode(signatureValueElement);</span>
<span class="nc" id="L458">        } catch (Base64DecodingException ex) {</span>
<span class="nc" id="L459">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
        }
    }

    /**
     * Base64 encodes and sets the bytes as the content of the SignatureValue
     * Node.
     *
     * @param bytes bytes to be used by SignatureValue before Base64 encoding
     */
    private void setSignatureValueElement(byte[] bytes) {

<span class="nc bnc" id="L471" title="All 2 branches missed.">        while (signatureValueElement.hasChildNodes()) {</span>
<span class="nc" id="L472">            signatureValueElement.removeChild(signatureValueElement.getFirstChild());</span>
        }

<span class="nc" id="L475">        String base64codedValue = Base64.encode(bytes);</span>

<span class="nc bnc" id="L477" title="All 4 branches missed.">        if (base64codedValue.length() &gt; 76 &amp;&amp; !XMLUtils.ignoreLineBreaks()) {</span>
<span class="nc" id="L478">            base64codedValue = &quot;\n&quot; + base64codedValue + &quot;\n&quot;;</span>
        }

<span class="nc" id="L481">        Text t = this.doc.createTextNode(base64codedValue);</span>
<span class="nc" id="L482">        signatureValueElement.appendChild(t);</span>
<span class="nc" id="L483">    }</span>

    /**
     * Returns the KeyInfo child. If we are in signing mode and the KeyInfo
     * does not exist yet, it is created on demand and added to the Signature.
     * &lt;br&gt;
     * This allows to add arbitrary content to the KeyInfo during signing.
     *
     * @return the KeyInfo object
     */
    public KeyInfo getKeyInfo() {
        // check to see if we are signing and if we have to create a keyinfo
<span class="nc bnc" id="L495" title="All 4 branches missed.">        if (this.state == MODE_SIGN &amp;&amp; this.keyInfo == null) {</span>

            // create the KeyInfo
<span class="nc" id="L498">            this.keyInfo = new KeyInfo(this.doc);</span>

            // get the Element from KeyInfo
<span class="nc" id="L501">            Element keyInfoElement = this.keyInfo.getElement();</span>
<span class="nc" id="L502">            Element firstObject =</span>
<span class="nc" id="L503">                XMLUtils.selectDsNode(</span>
<span class="nc" id="L504">                    this.constructionElement.getFirstChild(), Constants._TAG_OBJECT, 0</span>
                );

<span class="nc bnc" id="L507" title="All 2 branches missed.">            if (firstObject != null) {</span>
                // add it before the object
<span class="nc" id="L509">                this.constructionElement.insertBefore(keyInfoElement, firstObject);</span>
<span class="nc" id="L510">                XMLUtils.addReturnBeforeChild(this.constructionElement, firstObject);</span>
            } else {
                // add it as the last element to the signature
<span class="nc" id="L513">                this.constructionElement.appendChild(keyInfoElement);</span>
<span class="nc" id="L514">                XMLUtils.addReturnToElement(this.constructionElement);</span>
            }
        }

<span class="nc" id="L518">        return this.keyInfo;</span>
    }

    /**
     * Appends an Object (not a &lt;code&gt;java.lang.Object&lt;/code&gt; but an Object
     * element) to the Signature. Please note that this is only possible
     * when signing.
     *
     * @param object ds:Object to be appended.
     * @throws XMLSignatureException When this object is used to verify.
     */
    public void appendObject(ObjectContainer object) throws XMLSignatureException {
        //try {
        //if (this.state != MODE_SIGN) {
        // throw new XMLSignatureException(
        //  &quot;signature.operationOnlyBeforeSign&quot;);
        //}

<span class="nc" id="L536">        this.constructionElement.appendChild(object.getElement());</span>
<span class="nc" id="L537">        XMLUtils.addReturnToElement(this.constructionElement);</span>
        //} catch (XMLSecurityException ex) {
        // throw new XMLSignatureException(&quot;empty&quot;, ex);
        //}
<span class="nc" id="L541">    }</span>

    /**
     * Returns the &lt;code&gt;i&lt;code&gt;th &lt;code&gt;ds:Object&lt;/code&gt; child of the signature
     * or null if no such &lt;code&gt;ds:Object&lt;/code&gt; element exists.
     *
     * @param i
     * @return the &lt;code&gt;i&lt;code&gt;th &lt;code&gt;ds:Object&lt;/code&gt; child of the signature
     * or null if no such &lt;code&gt;ds:Object&lt;/code&gt; element exists.
     */
    public ObjectContainer getObjectItem(int i) {
<span class="nc" id="L552">        Element objElem =</span>
<span class="nc" id="L553">            XMLUtils.selectDsNode(</span>
<span class="nc" id="L554">                this.constructionElement.getFirstChild(), Constants._TAG_OBJECT, i</span>
            );

        try {
<span class="nc" id="L558">            return new ObjectContainer(objElem, this.baseURI);</span>
<span class="nc" id="L559">        } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L560">            return null;</span>
        }
    }

    /**
     * Returns the number of all &lt;code&gt;ds:Object&lt;/code&gt; elements.
     *
     * @return the number of all &lt;code&gt;ds:Object&lt;/code&gt; elements.
     */
    public int getObjectLength() {
<span class="nc" id="L570">        return this.length(Constants.SignatureSpecNS, Constants._TAG_OBJECT);</span>
    }

    /**
     * Digests all References in the SignedInfo, calculates the signature value
     * and sets it in the SignatureValue Element.
     *
     * @param signingKey the {@link java.security.PrivateKey} or
     * {@link javax.crypto.SecretKey} that is used to sign.
     * @throws XMLSignatureException
     */
    public void sign(Key signingKey) throws XMLSignatureException {

<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (signingKey instanceof PublicKey) {</span>
<span class="nc" id="L584">            throw new IllegalArgumentException(</span>
<span class="nc" id="L585">                I18n.translate(&quot;algorithms.operationOnlyVerification&quot;)</span>
            );
        }

        try {
            //Create a SignatureAlgorithm object
<span class="nc" id="L591">            SignedInfo si = this.getSignedInfo();</span>
<span class="nc" id="L592">            SignatureAlgorithm sa = si.getSignatureAlgorithm();</span>
<span class="nc" id="L593">            OutputStream so = null;</span>
            try {
                // initialize SignatureAlgorithm for signing
<span class="nc" id="L596">                sa.initSign(signingKey);</span>

                // generate digest values for all References in this SignedInfo
<span class="nc" id="L599">                si.generateDigestValues();</span>
<span class="nc" id="L600">                so = new UnsyncBufferedOutputStream(new SignerOutputStream(sa));</span>
                // get the canonicalized bytes from SignedInfo
<span class="nc" id="L602">                si.signInOctetStream(so);</span>
<span class="nc" id="L603">            } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L604">                throw ex;</span>
            } finally {
<span class="nc bnc" id="L606" title="All 4 branches missed.">                if (so != null) {</span>
                    try {
<span class="nc" id="L608">                        so.close();</span>
<span class="nc" id="L609">                    } catch (IOException ex) {</span>
<span class="nc bnc" id="L610" title="All 4 branches missed.">                        if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L611">                            log.log(java.util.logging.Level.FINE, ex.getMessage(), ex);</span>
                        }
<span class="nc" id="L613">                    }</span>
                }
            }

            // set them on the SignatureValue element
<span class="nc" id="L618">            this.setSignatureValueElement(sa.sign());</span>
<span class="nc" id="L619">        } catch (XMLSignatureException ex) {</span>
<span class="nc" id="L620">            throw ex;</span>
<span class="nc" id="L621">        } catch (CanonicalizationException ex) {</span>
<span class="nc" id="L622">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L623">        } catch (InvalidCanonicalizerException ex) {</span>
<span class="nc" id="L624">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L625">        } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L626">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L627">        }</span>
<span class="nc" id="L628">    }</span>

    /**
     * Adds a {@link ResourceResolver} to enable the retrieval of resources.
     *
     * @param resolver
     */
    public void addResourceResolver(ResourceResolver resolver) {
<span class="nc" id="L636">        this.getSignedInfo().addResourceResolver(resolver);</span>
<span class="nc" id="L637">    }</span>

    /**
     * Adds a {@link ResourceResolverSpi} to enable the retrieval of resources.
     *
     * @param resolver
     */
    public void addResourceResolver(ResourceResolverSpi resolver) {
<span class="nc" id="L645">        this.getSignedInfo().addResourceResolver(resolver);</span>
<span class="nc" id="L646">    }</span>

    /**
     * Extracts the public key from the certificate and verifies if the signature
     * is valid by re-digesting all References, comparing those against the
     * stored DigestValues and then checking to see if the Signatures match on
     * the SignedInfo.
     *
     * @param cert Certificate that contains the public key part of the keypair
     * that was used to sign.
     * @return true if the signature is valid, false otherwise
     * @throws XMLSignatureException
     */
    public boolean checkSignatureValue(X509Certificate cert)
        throws XMLSignatureException {
        // see if cert is null
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (cert != null) {</span>
            // check the values with the public key from the cert
<span class="nc" id="L664">            return this.checkSignatureValue(cert.getPublicKey());</span>
        }

<span class="nc" id="L667">        Object exArgs[] = { &quot;Didn't get a certificate&quot; };</span>
<span class="nc" id="L668">        throw new XMLSignatureException(&quot;empty&quot;, exArgs);</span>
    }

    /**
     * Verifies if the signature is valid by redigesting all References,
     * comparing those against the stored DigestValues and then checking to see
     * if the Signatures match on the SignedInfo.
     *
     * @param pk {@link java.security.PublicKey} part of the keypair or
     * {@link javax.crypto.SecretKey} that was used to sign
     * @return true if the signature is valid, false otherwise
     * @throws XMLSignatureException
     */
    public boolean checkSignatureValue(Key pk) throws XMLSignatureException {
        //COMMENT: pk suggests it can only be a public key?
        //check to see if the key is not null
<span class="nc bnc" id="L684" title="All 2 branches missed.">        if (pk == null) {</span>
<span class="nc" id="L685">            Object exArgs[] = { &quot;Didn't get a key&quot; };</span>
<span class="nc" id="L686">            throw new XMLSignatureException(&quot;empty&quot;, exArgs);</span>
        }
        // all references inside the signedinfo need to be dereferenced and
        // digested again to see if the outcome matches the stored value in the
        // SignedInfo.
        // If followManifestsDuringValidation is true it will do the same for
        // References inside a Manifest.
        try {
<span class="nc" id="L694">            SignedInfo si = this.getSignedInfo();</span>
            //create a SignatureAlgorithms from the SignatureMethod inside
            //SignedInfo. This is used to validate the signature.
<span class="nc" id="L697">            SignatureAlgorithm sa = si.getSignatureAlgorithm();</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">            if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L699">                log.log(java.util.logging.Level.FINE, &quot;signatureMethodURI = &quot; + sa.getAlgorithmURI());</span>
<span class="nc" id="L700">                log.log(java.util.logging.Level.FINE, &quot;jceSigAlgorithm    = &quot; + sa.getJCEAlgorithmString());</span>
<span class="nc" id="L701">                log.log(java.util.logging.Level.FINE, &quot;jceSigProvider     = &quot; + sa.getJCEProviderName());</span>
<span class="nc" id="L702">                log.log(java.util.logging.Level.FINE, &quot;PublicKey = &quot; + pk);</span>
            }
<span class="nc" id="L704">            byte sigBytes[] = null;</span>
            try {
<span class="nc" id="L706">                sa.initVerify(pk);</span>

                // Get the canonicalized (normalized) SignedInfo
<span class="nc" id="L709">                SignerOutputStream so = new SignerOutputStream(sa);</span>
<span class="nc" id="L710">                OutputStream bos = new UnsyncBufferedOutputStream(so);</span>

<span class="nc" id="L712">                si.signInOctetStream(bos);</span>
<span class="nc" id="L713">                bos.close();</span>
                // retrieve the byte[] from the stored signature
<span class="nc" id="L715">                sigBytes = this.getSignatureValue();</span>
<span class="nc" id="L716">            } catch (IOException ex) {</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">                if (log.isLoggable(java.util.logging.Level.FINE)) {</span>
<span class="nc" id="L718">                    log.log(java.util.logging.Level.FINE, ex.getMessage(), ex);</span>
                }
                // Impossible...
<span class="nc" id="L721">            } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L722">                throw ex;</span>
<span class="nc" id="L723">            }</span>

            // have SignatureAlgorithm sign the input bytes and compare them to
            // the bytes that were stored in the signature.
<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (!sa.verify(sigBytes)) {</span>
<span class="nc" id="L728">                log.log(java.util.logging.Level.WARNING, &quot;Signature verification failed.&quot;);</span>
<span class="nc" id="L729">                return false;</span>
            }

<span class="nc" id="L732">            return si.verify(this.followManifestsDuringValidation);</span>
<span class="nc" id="L733">        } catch (XMLSignatureException ex) {</span>
<span class="nc" id="L734">            throw ex;</span>
<span class="nc" id="L735">        } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L736">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
        }
    }

    /**
     * Add a Reference with full parameters to this Signature
     *
     * @param referenceURI URI of the resource to be signed. Can be null in
     * which case the dereferencing is application specific. Can be &quot;&quot; in which
     * it's the parent node (or parent document?). There can only be one &quot;&quot; in
     * each signature.
     * @param trans Optional list of transformations to be done before digesting
     * @param digestURI Mandatory URI of the digesting algorithm to use.
     * @param referenceId Optional id attribute for this Reference
     * @param referenceType Optional mimetype for the URI
     * @throws XMLSignatureException
     */
    public void addDocument(
        String referenceURI,
        Transforms trans,
        String digestURI,
        String referenceId,
        String referenceType
    ) throws XMLSignatureException {
<span class="nc" id="L760">        this.signedInfo.addDocument(</span>
            this.baseURI, referenceURI, trans, digestURI, referenceId, referenceType
        );
<span class="nc" id="L763">    }</span>

    /**
     * This method is a proxy method for the {@link Manifest#addDocument} method.
     *
     * @param referenceURI URI according to the XML Signature specification.
     * @param trans List of transformations to be applied.
     * @param digestURI URI of the digest algorithm to be used.
     * @see Manifest#addDocument
     * @throws XMLSignatureException
     */
    public void addDocument(
        String referenceURI,
        Transforms trans,
        String digestURI
    ) throws XMLSignatureException {
<span class="nc" id="L779">        this.signedInfo.addDocument(this.baseURI, referenceURI, trans, digestURI, null, null);</span>
<span class="nc" id="L780">    }</span>

    /**
     * Adds a Reference with just the URI and the transforms. This used the
     * SHA1 algorithm as a default digest algorithm.
     *
     * @param referenceURI URI according to the XML Signature specification.
     * @param trans List of transformations to be applied.
     * @throws XMLSignatureException
     */
    public void addDocument(String referenceURI, Transforms trans)
        throws XMLSignatureException {
<span class="nc" id="L792">        this.signedInfo.addDocument(</span>
            this.baseURI, referenceURI, trans, Constants.ALGO_ID_DIGEST_SHA1, null, null
        );
<span class="nc" id="L795">    }</span>

    /**
     * Add a Reference with just this URI. It uses SHA1 by default as the digest
     * algorithm
     *
     * @param referenceURI URI according to the XML Signature specification.
     * @throws XMLSignatureException
     */
    public void addDocument(String referenceURI) throws XMLSignatureException {
<span class="nc" id="L805">        this.signedInfo.addDocument(</span>
            this.baseURI, referenceURI, null, Constants.ALGO_ID_DIGEST_SHA1, null, null
        );
<span class="nc" id="L808">    }</span>

    /**
     * Add an X509 Certificate to the KeyInfo. This will include the whole cert
     * inside X509Data/X509Certificate tags.
     *
     * @param cert Certificate to be included. This should be the certificate of
     * the key that was used to sign.
     * @throws XMLSecurityException
     */
    public void addKeyInfo(X509Certificate cert) throws XMLSecurityException {
<span class="nc" id="L819">        X509Data x509data = new X509Data(this.doc);</span>

<span class="nc" id="L821">        x509data.addCertificate(cert);</span>
<span class="nc" id="L822">        this.getKeyInfo().add(x509data);</span>
<span class="nc" id="L823">    }</span>

    /**
     * Add this public key to the KeyInfo. This will include the complete key in
     * the KeyInfo structure.
     *
     * @param pk
     */
    public void addKeyInfo(PublicKey pk) {
<span class="nc" id="L832">        this.getKeyInfo().add(pk);</span>
<span class="nc" id="L833">    }</span>

    /**
     * Proxy method for {@link SignedInfo#createSecretKey(byte[])}. If you want
     * to create a MAC, this method helps you to obtain the
     * {@link javax.crypto.SecretKey} from octets.
     *
     * @param secretKeyBytes
     * @return the secret key created.
     * @see SignedInfo#createSecretKey(byte[])
     */
    public SecretKey createSecretKey(byte[] secretKeyBytes) {
<span class="nc" id="L845">        return this.getSignedInfo().createSecretKey(secretKeyBytes);</span>
    }

    /**
     * Signal whether Manifest should be automatically validated.
     * Checking the digests in References in a Signature are mandatory, but for
     * References inside a Manifest it is application specific. This boolean is
     * to indicate that the References inside Manifests should be validated.
     *
     * @param followManifests
     * @see &lt;a href=&quot;http://www.w3.org/TR/xmldsig-core/#sec-CoreValidation&quot;&gt;
     * Core validation section in the XML Signature Rec.&lt;/a&gt;
     */
    public void setFollowNestedManifests(boolean followManifests) {
<span class="nc" id="L859">        this.followManifestsDuringValidation = followManifests;</span>
<span class="nc" id="L860">    }</span>

    /**
     * Get the local name of this element
     *
     * @return Constants._TAG_SIGNATURE
     */
    public String getBaseLocalName() {
<span class="nc" id="L868">        return Constants._TAG_SIGNATURE;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>