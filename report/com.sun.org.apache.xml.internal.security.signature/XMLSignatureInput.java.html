<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>XMLSignatureInput.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.org.apache.xml.internal.security.signature</a> &gt; <span class="el_source">XMLSignatureInput.java</span></div><h1>XMLSignatureInput.java</h1><pre class="source lang-java linenums">/*
 * reserved comment block
 * DO NOT REMOVE OR ALTER!
 */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.sun.org.apache.xml.internal.security.signature;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
import com.sun.org.apache.xml.internal.security.c14n.implementations.CanonicalizerBase;
import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315OmitComments;
import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer11_OmitComments;
import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityRuntimeException;
import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

/**
 * Class XMLSignatureInput
 *
 * @author Christian Geuer-Pollmann
 * $todo$ check whether an XMLSignatureInput can be _both_, octet stream _and_ node set?
 */
public class XMLSignatureInput {
    /*
     * The XMLSignature Input can be either:
     *   A byteArray like with/or without InputStream.
     *   Or a nodeSet like defined either:
     *       * as a collection of nodes
     *       * or as subnode excluding or not comments and excluding or
     *         not other nodes.
     */

    /**
     * Some InputStreams do not support the {@link java.io.InputStream#reset}
     * method, so we read it in completely and work on our Proxy.
     */
<span class="nc" id="L71">    private InputStream inputOctetStreamProxy = null;</span>
    /**
     * The original NodeSet for this XMLSignatureInput
     */
<span class="nc" id="L75">    private Set&lt;Node&gt; inputNodeSet = null;</span>
    /**
     * The original Element
     */
<span class="nc" id="L79">    private Node subNode = null;</span>
    /**
     * Exclude Node *for enveloped transformations*
     */
<span class="nc" id="L83">    private Node excludeNode = null;</span>
    /**
     *
     */
<span class="nc" id="L87">    private boolean excludeComments = false;</span>

<span class="nc" id="L89">    private boolean isNodeSet = false;</span>
    /**
     * A cached bytes
     */
<span class="nc" id="L93">    private byte[] bytes = null;</span>

    /**
     * Some Transforms may require explicit MIME type, charset (IANA registered
     * &quot;character set&quot;), or other such information concerning the data they are
     * receiving from an earlier Transform or the source data, although no
     * Transform algorithm specified in this document needs such explicit
     * information. Such data characteristics are provided as parameters to the
     * Transform algorithm and should be described in the specification for the
     * algorithm.
     */
<span class="nc" id="L104">    private String mimeType = null;</span>

    /**
     * Field sourceURI
     */
<span class="nc" id="L109">    private String sourceURI = null;</span>

    /**
     * Node Filter list.
     */
<span class="nc" id="L114">    private List&lt;NodeFilter&gt; nodeFilters = new ArrayList&lt;NodeFilter&gt;();</span>

<span class="nc" id="L116">    private boolean needsToBeExpanded = false;</span>
<span class="nc" id="L117">    private OutputStream outputStream = null;</span>

    private DocumentBuilderFactory dfactory;

    /**
     * Construct a XMLSignatureInput from an octet array.
     * &lt;p&gt;
     * This is a comfort method, which internally converts the byte[] array into
     * an InputStream
     * &lt;p&gt;NOTE: no defensive copy&lt;/p&gt;
     * @param inputOctets an octet array which including XML document or node
     */
<span class="nc" id="L129">    public XMLSignatureInput(byte[] inputOctets) {</span>
        // NO defensive copy
<span class="nc" id="L131">        this.bytes = inputOctets;</span>
<span class="nc" id="L132">    }</span>

    /**
     * Constructs a &lt;code&gt;XMLSignatureInput&lt;/code&gt; from an octet stream. The
     * stream is directly read.
     *
     * @param inputOctetStream
     */
<span class="nc" id="L140">    public XMLSignatureInput(InputStream inputOctetStream)  {</span>
<span class="nc" id="L141">        this.inputOctetStreamProxy = inputOctetStream;</span>
<span class="nc" id="L142">    }</span>

    /**
     * Construct a XMLSignatureInput from a subtree rooted by rootNode. This
     * method included the node and &lt;I&gt;all&lt;/I&gt; his descendants in the output.
     *
     * @param rootNode
     */
<span class="nc" id="L150">    public XMLSignatureInput(Node rootNode) {</span>
<span class="nc" id="L151">        this.subNode = rootNode;</span>
<span class="nc" id="L152">    }</span>

    /**
     * Constructor XMLSignatureInput
     *
     * @param inputNodeSet
     */
<span class="nc" id="L159">    public XMLSignatureInput(Set&lt;Node&gt; inputNodeSet) {</span>
<span class="nc" id="L160">        this.inputNodeSet = inputNodeSet;</span>
<span class="nc" id="L161">    }</span>

    /**
     * Check if the structure needs to be expanded.
     * @return true if so.
     */
    public boolean isNeedsToBeExpanded() {
<span class="nc" id="L168">        return needsToBeExpanded;</span>
    }

    /**
     * Set if the structure needs to be expanded.
     * @param needsToBeExpanded true if so.
     */
    public void setNeedsToBeExpanded(boolean needsToBeExpanded) {
<span class="nc" id="L176">        this.needsToBeExpanded = needsToBeExpanded;</span>
<span class="nc" id="L177">    }</span>

    /**
     * Returns the node set from input which was specified as the parameter of
     * {@link XMLSignatureInput} constructor
     *
     * @return the node set
     * @throws SAXException
     * @throws IOException
     * @throws ParserConfigurationException
     * @throws CanonicalizationException
     */
    public Set&lt;Node&gt; getNodeSet() throws CanonicalizationException, ParserConfigurationException,
        IOException, SAXException {
<span class="nc" id="L191">        return getNodeSet(false);</span>
    }

    /**
     * Get the Input NodeSet.
     * @return the Input NodeSet.
     */
    public Set&lt;Node&gt; getInputNodeSet() {
<span class="nc" id="L199">        return inputNodeSet;</span>
    }

    /**
     * Returns the node set from input which was specified as the parameter of
     * {@link XMLSignatureInput} constructor
     * @param circumvent
     *
     * @return the node set
     * @throws SAXException
     * @throws IOException
     * @throws ParserConfigurationException
     * @throws CanonicalizationException
     */
    public Set&lt;Node&gt; getNodeSet(boolean circumvent) throws ParserConfigurationException,
        IOException, SAXException, CanonicalizationException {
<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (inputNodeSet != null) {</span>
<span class="nc" id="L216">            return inputNodeSet;</span>
        }
<span class="nc bnc" id="L218" title="All 4 branches missed.">        if (inputOctetStreamProxy == null &amp;&amp; subNode != null) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (circumvent) {</span>
<span class="nc" id="L220">                XMLUtils.circumventBug2650(XMLUtils.getOwnerDocument(subNode));</span>
            }
<span class="nc" id="L222">            inputNodeSet = new LinkedHashSet&lt;Node&gt;();</span>
<span class="nc" id="L223">            XMLUtils.getSet(subNode, inputNodeSet, excludeNode, excludeComments);</span>
<span class="nc" id="L224">            return inputNodeSet;</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        } else if (isOctetStream()) {</span>
<span class="nc" id="L226">            convertToNodes();</span>
<span class="nc" id="L227">            Set&lt;Node&gt; result = new LinkedHashSet&lt;Node&gt;();</span>
<span class="nc" id="L228">            XMLUtils.getSet(subNode, result, null, false);</span>
<span class="nc" id="L229">            return result;</span>
        }

<span class="nc" id="L232">        throw new RuntimeException(&quot;getNodeSet() called but no input data present&quot;);</span>
    }

    /**
     * Returns the Octet stream(byte Stream) from input which was specified as
     * the parameter of {@link XMLSignatureInput} constructor
     *
     * @return the Octet stream(byte Stream) from input which was specified as
     * the parameter of {@link XMLSignatureInput} constructor
     * @throws IOException
     */
    public InputStream getOctetStream() throws IOException  {
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (inputOctetStreamProxy != null) {</span>
<span class="nc" id="L245">            return inputOctetStreamProxy;</span>
        }

<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (bytes != null) {</span>
<span class="nc" id="L249">            inputOctetStreamProxy = new ByteArrayInputStream(bytes);</span>
<span class="nc" id="L250">            return inputOctetStreamProxy;</span>
        }

<span class="nc" id="L253">        return null;</span>
    }

    /**
     * @return real octet stream
     */
    public InputStream getOctetStreamReal() {
<span class="nc" id="L260">        return inputOctetStreamProxy;</span>
    }

    /**
     * Returns the byte array from input which was specified as the parameter of
     * {@link XMLSignatureInput} constructor
     *
     * @return the byte[] from input which was specified as the parameter of
     * {@link XMLSignatureInput} constructor
     *
     * @throws CanonicalizationException
     * @throws IOException
     */
    public byte[] getBytes() throws IOException, CanonicalizationException {
<span class="nc" id="L274">        byte[] inputBytes = getBytesFromInputStream();</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (inputBytes != null) {</span>
<span class="nc" id="L276">            return inputBytes;</span>
        }
<span class="nc" id="L278">        Canonicalizer20010315OmitComments c14nizer = new Canonicalizer20010315OmitComments();</span>
<span class="nc" id="L279">        bytes = c14nizer.engineCanonicalize(this);</span>
<span class="nc" id="L280">        return bytes;</span>
    }

    /**
     * Determines if the object has been set up with a Node set
     *
     * @return true if the object has been set up with a Node set
     */
    public boolean isNodeSet() {
<span class="nc bnc" id="L289" title="All 6 branches missed.">        return ((inputOctetStreamProxy == null</span>
            &amp;&amp; inputNodeSet != null) || isNodeSet);
    }

    /**
     * Determines if the object has been set up with an Element
     *
     * @return true if the object has been set up with an Element
     */
    public boolean isElement() {
<span class="nc bnc" id="L299" title="All 8 branches missed.">        return (inputOctetStreamProxy == null &amp;&amp; subNode != null</span>
            &amp;&amp; inputNodeSet == null &amp;&amp; !isNodeSet);
    }

    /**
     * Determines if the object has been set up with an octet stream
     *
     * @return true if the object has been set up with an octet stream
     */
    public boolean isOctetStream() {
<span class="nc bnc" id="L309" title="All 8 branches missed.">        return ((inputOctetStreamProxy != null || bytes != null)</span>
          &amp;&amp; (inputNodeSet == null &amp;&amp; subNode == null));
    }

    /**
     * Determines if {@link #setOutputStream} has been called with a
     * non-null OutputStream.
     *
     * @return true if {@link #setOutputStream} has been called with a
     * non-null OutputStream
     */
    public boolean isOutputStreamSet() {
<span class="nc bnc" id="L321" title="All 2 branches missed.">        return outputStream != null;</span>
    }

    /**
     * Determines if the object has been set up with a ByteArray
     *
     * @return true is the object has been set up with an octet stream
     */
    public boolean isByteArray() {
<span class="nc bnc" id="L330" title="All 6 branches missed.">        return (bytes != null &amp;&amp; (this.inputNodeSet == null &amp;&amp; subNode == null));</span>
    }

    /**
     * Is the object correctly set up?
     *
     * @return true if the object has been set up correctly
     */
    public boolean isInitialized() {
<span class="nc bnc" id="L339" title="All 4 branches missed.">        return isOctetStream() || isNodeSet();</span>
    }

    /**
     * Returns mimeType
     *
     * @return mimeType
     */
    public String getMIMEType() {
<span class="nc" id="L348">        return mimeType;</span>
    }

    /**
     * Sets mimeType
     *
     * @param mimeType
     */
    public void setMIMEType(String mimeType) {
<span class="nc" id="L357">        this.mimeType = mimeType;</span>
<span class="nc" id="L358">    }</span>

    /**
     * Return SourceURI
     *
     * @return SourceURI
     */
    public String getSourceURI() {
<span class="nc" id="L366">        return sourceURI;</span>
    }

    /**
     * Sets SourceURI
     *
     * @param sourceURI
     */
    public void setSourceURI(String sourceURI) {
<span class="nc" id="L375">        this.sourceURI = sourceURI;</span>
<span class="nc" id="L376">    }</span>

    /**
     * Method toString
     * @inheritDoc
     */
    public String toString() {
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (isNodeSet()) {</span>
<span class="nc" id="L384">            return &quot;XMLSignatureInput/NodeSet/&quot; + inputNodeSet.size()</span>
<span class="nc" id="L385">                   + &quot; nodes/&quot; + getSourceURI();</span>
        }
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (isElement()) {</span>
<span class="nc" id="L388">            return &quot;XMLSignatureInput/Element/&quot; + subNode</span>
                + &quot; exclude &quot;+ excludeNode + &quot; comments:&quot;
<span class="nc" id="L390">                + excludeComments +&quot;/&quot; + getSourceURI();</span>
        }
        try {
<span class="nc" id="L393">            return &quot;XMLSignatureInput/OctetStream/&quot; + getBytes().length</span>
<span class="nc" id="L394">                   + &quot; octets/&quot; + getSourceURI();</span>
<span class="nc" id="L395">        } catch (IOException iex) {</span>
<span class="nc" id="L396">            return &quot;XMLSignatureInput/OctetStream//&quot; + getSourceURI();</span>
<span class="nc" id="L397">        } catch (CanonicalizationException cex) {</span>
<span class="nc" id="L398">            return &quot;XMLSignatureInput/OctetStream//&quot; + getSourceURI();</span>
        }
    }

    /**
     * Method getHTMLRepresentation
     *
     * @throws XMLSignatureException
     * @return The HTML representation for this XMLSignature
     */
    public String getHTMLRepresentation() throws XMLSignatureException {
<span class="nc" id="L409">        XMLSignatureInputDebugger db = new XMLSignatureInputDebugger(this);</span>
<span class="nc" id="L410">        return db.getHTMLRepresentation();</span>
    }

    /**
     * Method getHTMLRepresentation
     *
     * @param inclusiveNamespaces
     * @throws XMLSignatureException
     * @return The HTML representation for this XMLSignature
     */
    public String getHTMLRepresentation(Set&lt;String&gt; inclusiveNamespaces)
       throws XMLSignatureException {
<span class="nc" id="L422">        XMLSignatureInputDebugger db =</span>
            new XMLSignatureInputDebugger(this, inclusiveNamespaces);
<span class="nc" id="L424">        return db.getHTMLRepresentation();</span>
    }

    /**
     * Gets the exclude node of this XMLSignatureInput
     * @return Returns the excludeNode.
     */
    public Node getExcludeNode() {
<span class="nc" id="L432">        return excludeNode;</span>
    }

    /**
     * Sets the exclude node of this XMLSignatureInput
     * @param excludeNode The excludeNode to set.
     */
    public void setExcludeNode(Node excludeNode) {
<span class="nc" id="L440">        this.excludeNode = excludeNode;</span>
<span class="nc" id="L441">    }</span>

    /**
     * Gets the node of this XMLSignatureInput
     * @return The excludeNode set.
     */
    public Node getSubNode() {
<span class="nc" id="L448">        return subNode;</span>
    }

    /**
     * @return Returns the excludeComments.
     */
    public boolean isExcludeComments() {
<span class="nc" id="L455">        return excludeComments;</span>
    }

    /**
     * @param excludeComments The excludeComments to set.
     */
    public void setExcludeComments(boolean excludeComments) {
<span class="nc" id="L462">        this.excludeComments = excludeComments;</span>
<span class="nc" id="L463">    }</span>

    /**
     * @param diOs
     * @throws IOException
     * @throws CanonicalizationException
     */
    public void updateOutputStream(OutputStream diOs)
        throws CanonicalizationException, IOException {
<span class="nc" id="L472">        updateOutputStream(diOs, false);</span>
<span class="nc" id="L473">    }</span>

    public void updateOutputStream(OutputStream diOs, boolean c14n11)
        throws CanonicalizationException, IOException {
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (diOs == outputStream) {</span>
<span class="nc" id="L478">            return;</span>
        }
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (bytes != null) {</span>
<span class="nc" id="L481">            diOs.write(bytes);</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        } else if (inputOctetStreamProxy == null) {</span>
<span class="nc" id="L483">            CanonicalizerBase c14nizer = null;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">            if (c14n11) {</span>
<span class="nc" id="L485">                c14nizer = new Canonicalizer11_OmitComments();</span>
            } else {
<span class="nc" id="L487">                c14nizer = new Canonicalizer20010315OmitComments();</span>
            }
<span class="nc" id="L489">            c14nizer.setWriter(diOs);</span>
<span class="nc" id="L490">            c14nizer.engineCanonicalize(this);</span>
<span class="nc" id="L491">        } else {</span>
<span class="nc" id="L492">            byte[] buffer = new byte[4 * 1024];</span>
<span class="nc" id="L493">            int bytesread = 0;</span>
            try {
<span class="nc bnc" id="L495" title="All 2 branches missed.">                while ((bytesread = inputOctetStreamProxy.read(buffer)) != -1) {</span>
<span class="nc" id="L496">                    diOs.write(buffer, 0, bytesread);</span>
                }
<span class="nc" id="L498">            } catch (IOException ex) {</span>
<span class="nc" id="L499">                inputOctetStreamProxy.close();</span>
<span class="nc" id="L500">                throw ex;</span>
<span class="nc" id="L501">            }</span>
        }
<span class="nc" id="L503">    }</span>

    /**
     * @param os
     */
    public void setOutputStream(OutputStream os) {
<span class="nc" id="L509">        outputStream = os;</span>
<span class="nc" id="L510">    }</span>

    private byte[] getBytesFromInputStream() throws IOException {
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (bytes != null) {</span>
<span class="nc" id="L514">            return bytes;</span>
        }
<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (inputOctetStreamProxy == null) {</span>
<span class="nc" id="L517">            return null;</span>
        }
        try {
<span class="nc" id="L520">            bytes = JavaUtils.getBytesFromStream(inputOctetStreamProxy);</span>
        } finally {
<span class="nc" id="L522">            inputOctetStreamProxy.close();</span>
<span class="nc" id="L523">        }</span>
<span class="nc" id="L524">        return bytes;</span>
    }

    /**
     * @param filter
     */
    public void addNodeFilter(NodeFilter filter) {
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (isOctetStream()) {</span>
            try {
<span class="nc" id="L533">                convertToNodes();</span>
<span class="nc" id="L534">            } catch (Exception e) {</span>
<span class="nc" id="L535">                throw new XMLSecurityRuntimeException(</span>
                    &quot;signature.XMLSignatureInput.nodesetReference&quot;, e
                );
<span class="nc" id="L538">            }</span>
        }
<span class="nc" id="L540">        nodeFilters.add(filter);</span>
<span class="nc" id="L541">    }</span>

    /**
     * @return the node filters
     */
    public List&lt;NodeFilter&gt; getNodeFilters() {
<span class="nc" id="L547">        return nodeFilters;</span>
    }

    /**
     * @param b
     */
    public void setNodeSet(boolean b) {
<span class="nc" id="L554">        isNodeSet = b;</span>
<span class="nc" id="L555">    }</span>

    void convertToNodes() throws CanonicalizationException,
        ParserConfigurationException, IOException, SAXException {
<span class="nc bnc" id="L559" title="All 2 branches missed.">        if (dfactory == null) {</span>
<span class="nc" id="L560">            dfactory = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L561">            dfactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);</span>
<span class="nc" id="L562">            dfactory.setValidating(false);</span>
<span class="nc" id="L563">            dfactory.setNamespaceAware(true);</span>
        }
<span class="nc" id="L565">        DocumentBuilder db = dfactory.newDocumentBuilder();</span>
        // select all nodes, also the comments.
        try {
<span class="nc" id="L568">            db.setErrorHandler(new com.sun.org.apache.xml.internal.security.utils.IgnoreAllErrorHandler());</span>

<span class="nc" id="L570">            Document doc = db.parse(this.getOctetStream());</span>
<span class="nc" id="L571">            this.subNode = doc;</span>
<span class="nc" id="L572">        } catch (SAXException ex) {</span>
            // if a not-wellformed nodeset exists, put a container around it...
<span class="nc" id="L574">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>

<span class="nc" id="L576">            baos.write(&quot;&lt;container&gt;&quot;.getBytes(&quot;UTF-8&quot;));</span>
<span class="nc" id="L577">            baos.write(this.getBytes());</span>
<span class="nc" id="L578">            baos.write(&quot;&lt;/container&gt;&quot;.getBytes(&quot;UTF-8&quot;));</span>

<span class="nc" id="L580">            byte result[] = baos.toByteArray();</span>
<span class="nc" id="L581">            Document document = db.parse(new ByteArrayInputStream(result));</span>
<span class="nc" id="L582">            this.subNode = document.getDocumentElement().getFirstChild().getFirstChild();</span>
        } finally {
<span class="nc bnc" id="L584" title="All 6 branches missed.">            if (this.inputOctetStreamProxy != null) {</span>
<span class="nc" id="L585">                this.inputOctetStreamProxy.close();</span>
            }
<span class="nc" id="L587">            this.inputOctetStreamProxy = null;</span>
<span class="nc" id="L588">            this.bytes = null;</span>
<span class="nc" id="L589">        }</span>
<span class="nc" id="L590">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>