<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Vset.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.tree</a> &gt; <span class="el_source">Vset.java</span></div><h1>Vset.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.tree;

import sun.tools.java.*;

/**
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public final
class Vset implements Constants {
    long vset;                  // DA bits for first 64 variables
    long uset;                  // DU bits for first 64 variables

    // The extension array is interleaved, consisting of alternating
    // blocks of 64 DA bits followed by 64 DU bits followed by 64 DA
    // bits, and so on.

    long x[];                   // extension array for more bits

    // An infinite vector of zeroes or an infinite vector of ones is
    // represented by a special value of the extension array.
    //
    // IMPORTANT: The condition 'this.x == fullX' is used as a marker for
    // unreachable code, i.e., for a dead-end.  We maintain the invariant
    // that (this.x != fullX || (this.vset == -1 &amp;&amp; this.uset == -1)).
    // A dead-end has the peculiar property that all variables are both
    // definitely assigned and definitely unassigned.  We always force this
    // condition to hold, even when the normal bitvector operations performed
    // during DA/DU analysis would produce a different result.  This supresses
    // reporting of DA/DU errors in unreachable code.

<span class="nc" id="L58">    static final long emptyX[] = new long[0]; // all zeroes</span>
<span class="nc" id="L59">    static final long fullX[]  = new long[0]; // all ones</span>

    // For more thorough testing of long vset support, it is helpful to
    // temporarily redefine this value to a smaller number, such as 1 or 2.

    static final int VBITS = 64; // number of bits in vset (uset)

    /**
     * This is the Vset which reports all vars assigned and unassigned.
     * This impossibility is degenerately true exactly when
     * control flow cannot reach this point.
     */

    // We distinguish a canonical dead-end value generated initially for
    // statements that do not complete normally, making the next one unreachable.
    // Once an unreachable statement is reported, a non-canonical dead-end value
    // is used for subsequent statements in order to suppress redundant error
    // messages.

<span class="nc" id="L78">    static final Vset DEAD_END = new Vset(-1, -1, fullX);</span>

    /**
     * Create an empty Vset.
     */
<span class="nc" id="L83">    public Vset() {</span>
<span class="nc" id="L84">        this.x = emptyX;</span>
<span class="nc" id="L85">    }</span>

<span class="nc" id="L87">    private Vset(long vset, long uset, long x[]) {</span>
<span class="nc" id="L88">        this.vset = vset;</span>
<span class="nc" id="L89">        this.uset = uset;</span>
<span class="nc" id="L90">        this.x = x;</span>
<span class="nc" id="L91">    }</span>

    /**
     * Create an copy of the given Vset.
     * (However, DEAD_END simply returns itself.)
     */
    public Vset copy() {
<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (this == DEAD_END) {</span>
<span class="nc" id="L99">            return this;</span>
        }
<span class="nc" id="L101">        Vset vs = new Vset(vset, uset, x);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (x.length &gt; 0) {</span>
<span class="nc" id="L103">            vs.growX(x.length); // recopy the extension vector</span>
        }
<span class="nc" id="L105">        return vs;</span>
    }

    private void growX(int length) {
<span class="nc" id="L109">        long newX[] = new long[length];</span>
<span class="nc" id="L110">        long oldX[] = x;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        for (int i = 0; i &lt; oldX.length; i++) {</span>
<span class="nc" id="L112">            newX[i] = oldX[i];</span>
        }
<span class="nc" id="L114">        x = newX;</span>
<span class="nc" id="L115">    }</span>

    /**
     * Ask if this is a vset for a dead end.
     * Answer true only for the canonical dead-end, DEAD_END.
     * A canonical dead-end is produced only as a result of
     * a statement that cannot complete normally, as specified
     * by the JLS.  Due to the special-case rules for if-then
     * and if-then-else, this may fail to detect actual unreachable
     * code that could easily be identified.
     */

    public boolean isDeadEnd() {
<span class="nc bnc" id="L128" title="All 2 branches missed.">        return (this == DEAD_END);</span>
    }

    /**
     * Ask if this is a vset for a dead end.
     * Answer true for any dead-end.
     * Since 'clearDeadEnd' has no effect on this predicate,
     * if-then and if-then-else are handled in the more 'obvious'
     * and precise way.  This predicate is to be preferred for
     * dead code elimination purposes.
     * (Presently used in workaround for bug 4173473 in MethodExpression.java)
     */
    public boolean isReallyDeadEnd() {
<span class="nc bnc" id="L141" title="All 2 branches missed.">        return (x == fullX);</span>
    }

    /**
     * Replace canonical DEAD_END with a distinct but
     * equivalent Vset.  The bits are unaltered, but
     * the result does not answer true to 'isDeadEnd'.
     * &lt;p&gt;
     * Used mostly for error recovery, but see
     * 'IfStatement.check', where it is used to
     * implement the special-case treatment of
     * statement reachability for such statements.
     */
    public Vset clearDeadEnd() {
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (this == DEAD_END) {</span>
<span class="nc" id="L156">            return new Vset(-1, -1, fullX);</span>
        }
<span class="nc" id="L158">        return this;</span>
    }

    /**
     * Ask if a var is definitely assigned.
     */
    public boolean testVar(int varNumber) {
<span class="nc" id="L165">        long bit = (1L &lt;&lt; varNumber);</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (varNumber &gt;= VBITS) {</span>
<span class="nc" id="L167">            int i = (varNumber / VBITS - 1) * 2;</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            if (i &gt;= x.length) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">                return (x == fullX);</span>
            }
<span class="nc bnc" id="L171" title="All 2 branches missed.">            return (x[i] &amp; bit) != 0;</span>
        } else {
<span class="nc bnc" id="L173" title="All 2 branches missed.">            return (vset &amp; bit) != 0;</span>
        }
    }

    /**
     * Ask if a var is definitely un-assigned.
     * (This is not just the negation of testVar:
     * It's possible for neither to be true.)
     */
    public boolean testVarUnassigned(int varNumber) {
<span class="nc" id="L183">        long bit = (1L &lt;&lt; varNumber);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (varNumber &gt;= VBITS) {</span>
            // index &quot;uset&quot; extension
<span class="nc" id="L186">            int i = ((varNumber / VBITS - 1) * 2) + 1;</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (i &gt;= x.length) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                return (x == fullX);</span>
            }
<span class="nc bnc" id="L190" title="All 2 branches missed.">            return (x[i] &amp; bit) != 0;</span>
        } else {
<span class="nc bnc" id="L192" title="All 2 branches missed.">            return (uset &amp; bit) != 0;</span>
        }
    }

    /**
     * Note that a var is definitely assigned.
     * (Side-effecting.)
     */
    public Vset addVar(int varNumber) {
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (x == fullX) {</span>
<span class="nc" id="L202">            return this;</span>
        }

        // gen DA, kill DU

<span class="nc" id="L207">        long bit = (1L &lt;&lt; varNumber);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (varNumber &gt;= VBITS) {</span>
<span class="nc" id="L209">            int i = (varNumber / VBITS - 1) * 2;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (i &gt;= x.length) {</span>
<span class="nc" id="L211">                growX(i+1);</span>
            }
<span class="nc" id="L213">            x[i] |= bit;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if (i+1 &lt; x.length) {</span>
<span class="nc" id="L215">                x[i+1] &amp;=~ bit;</span>
            }
<span class="nc" id="L217">        } else {</span>
<span class="nc" id="L218">            vset |= bit;</span>
<span class="nc" id="L219">            uset &amp;=~ bit;</span>
        }
<span class="nc" id="L221">        return this;</span>
    }

    /**
     * Note that a var is definitely un-assigned.
     * (Side-effecting.)
     */
    public Vset addVarUnassigned(int varNumber) {
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (x == fullX) {</span>
<span class="nc" id="L230">            return this;</span>
        }

        // gen DU, kill DA

<span class="nc" id="L235">        long bit = (1L &lt;&lt; varNumber);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (varNumber &gt;= VBITS) {</span>
            // index &quot;uset&quot; extension
<span class="nc" id="L238">            int i = ((varNumber / VBITS - 1) * 2) + 1;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (i &gt;= x.length) {</span>
<span class="nc" id="L240">                growX(i+1);</span>
            }
<span class="nc" id="L242">            x[i] |= bit;</span>
<span class="nc" id="L243">            x[i-1] &amp;=~ bit;</span>
<span class="nc" id="L244">        } else {</span>
<span class="nc" id="L245">            uset |= bit;</span>
<span class="nc" id="L246">            vset &amp;=~ bit;</span>
        }
<span class="nc" id="L248">        return this;</span>
    }

    /**
     * Retract any assertion about the var.
     * This operation is ineffective on a dead-end.
     * (Side-effecting.)
     */
    public Vset clearVar(int varNumber) {
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (x == fullX) {</span>
<span class="nc" id="L258">            return this;</span>
        }
<span class="nc" id="L260">        long bit = (1L &lt;&lt; varNumber);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">        if (varNumber &gt;= VBITS) {</span>
<span class="nc" id="L262">            int i = (varNumber / VBITS - 1) * 2;</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">            if (i &gt;= x.length) {</span>
<span class="nc" id="L264">                return this;</span>
            }
<span class="nc" id="L266">            x[i] &amp;=~ bit;</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (i+1 &lt; x.length) {</span>
<span class="nc" id="L268">                x[i+1] &amp;=~ bit;</span>
            }
<span class="nc" id="L270">        } else {</span>
<span class="nc" id="L271">            vset &amp;=~ bit;</span>
<span class="nc" id="L272">            uset &amp;=~ bit;</span>
        }
<span class="nc" id="L274">        return this;</span>
    }

    /**
     * Join with another vset.  This is set intersection.
     * (Side-effecting.)
     */
    public Vset join(Vset other) {

        // Return a dead-end if both vsets are dead-ends.
        // Return the canonical DEAD_END only if both vsets
        // are the canonical DEAD_END.  Otherwise, an incoming
        // dead-end vset has already produced an error message,
        // and is now assumed to be reachable.
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (this == DEAD_END) {</span>
<span class="nc" id="L289">            return other.copy();</span>
        }
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (other == DEAD_END) {</span>
<span class="nc" id="L292">            return this;</span>
        }
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (x == fullX) {</span>
<span class="nc" id="L295">            return other.copy();</span>
        }
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (other.x == fullX) {</span>
<span class="nc" id="L298">            return this;</span>
        }

        // DA = DA intersection DA
        // DU = DU intersection DU

<span class="nc" id="L304">        vset &amp;= other.vset;</span>
<span class="nc" id="L305">        uset &amp;= other.uset;</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (other.x == emptyX) {</span>
<span class="nc" id="L308">            x = emptyX;</span>
        } else {
            // ASSERT(otherX.length &gt; 0);
<span class="nc" id="L311">            long otherX[] = other.x;</span>
<span class="nc" id="L312">            int selfLength = x.length;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">            int limit = (otherX.length &lt; selfLength) ? otherX.length : selfLength;</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">            for (int i = 0; i &lt; limit; i++) {</span>
<span class="nc" id="L315">                x[i] &amp;= otherX[i];</span>
            }
            // If self is longer than other, all remaining
            // bits are implicitly 0.  In the result, then,
            // the remaining DA and DU bits are cleared.
<span class="nc bnc" id="L320" title="All 2 branches missed.">            for (int i = limit; i &lt; selfLength; i++) {</span>
<span class="nc" id="L321">                x[i] = 0;</span>
            }
        }
<span class="nc" id="L324">        return this;</span>
    }

    /**
     * Add in the definite assignment bits of another vset,
     * but join the definite unassignment bits.  This unusual
     * operation is used only for 'finally' blocks.  The
     * original vset 'this' is destroyed by this operation.
     * (Part of fix for 4068688.)
     */

    public Vset addDAandJoinDU(Vset other) {

        // Return a dead-end if either vset is a dead end.
        // If either vset is the canonical DEAD_END, the
        // result is also the canonical DEAD_END.
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (this == DEAD_END) {</span>
<span class="nc" id="L341">            return this;</span>
        }
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (other == DEAD_END) {</span>
<span class="nc" id="L344">            return other;</span>
        }
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (x == fullX) {</span>
<span class="nc" id="L347">            return this;</span>
        }
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (other.x == fullX) {</span>
<span class="nc" id="L350">            return other.copy();</span>
        }

        // DA = DA union DA'
        // DU = (DU intersection DU') - DA'

<span class="nc" id="L356">        vset = vset | other.vset;</span>
<span class="nc" id="L357">        uset = (uset &amp; other.uset) &amp; ~other.vset;</span>

<span class="nc" id="L359">        int selfLength = x.length;</span>
<span class="nc" id="L360">        long otherX[] = other.x;</span>
<span class="nc" id="L361">        int otherLength = otherX.length;</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (otherX != emptyX) {</span>
            // ASSERT(otherX.length &gt; 0);
<span class="nc bnc" id="L365" title="All 2 branches missed.">            if (otherLength &gt; selfLength) {</span>
<span class="nc" id="L366">                growX(otherLength);</span>
            }
<span class="nc" id="L368">            int i = 0;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">            while (i &lt; otherLength) {</span>
<span class="nc" id="L370">                x[i] |= otherX[i];</span>
<span class="nc" id="L371">                i++;</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                if (i == otherLength) break;</span>
<span class="nc" id="L373">                x[i] = ((x[i] &amp; otherX[i]) &amp; ~otherX[i-1]);</span>
<span class="nc" id="L374">                i++;</span>
            }
        }
        // If self is longer than other, all remaining
        // bits are implicitly 0. In the result, then,
        // the remaining DA bits are left unchanged, and
        // the DU bits are all cleared. First, align
        // index to the next block of DU bits (odd index).
<span class="nc bnc" id="L382" title="All 2 branches missed.">        for (int i = (otherLength | 1); i &lt; selfLength; i += 2) {</span>
<span class="nc" id="L383">            x[i] = 0;</span>
        }
<span class="nc" id="L385">        return this;</span>
    }


    /**
     * Construct a vset consisting of the DA bits of the first argument
     * and the DU bits of the second argument.  This is a higly unusual
     * operation, as it implies a case where the flowgraph for DA analysis
     * differs from that for DU analysis.  It is only needed for analysing
     * 'try' blocks.  The result is a dead-end iff the first argument is
     * dead-end. (Part of fix for 4068688.)
     */

    public static Vset firstDAandSecondDU(Vset sourceDA, Vset sourceDU) {

        // Note that reachability status is received via 'sourceDA' only!
        // This is a consequence of the fact that reachability and DA
        // analysis are performed on an identical flow graph, whereas the
        // flowgraph for DU analysis differs in the case of a 'try' statement.
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (sourceDA.x == fullX) {</span>
<span class="nc" id="L405">            return sourceDA.copy();</span>
        }

<span class="nc" id="L408">        long sourceDAx[] = sourceDA.x;</span>
<span class="nc" id="L409">        int lenDA = sourceDAx.length;</span>
<span class="nc" id="L410">        long sourceDUx[] = sourceDU.x;</span>
<span class="nc" id="L411">        int lenDU = sourceDUx.length;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        int limit = (lenDA &gt; lenDU) ? lenDA : lenDU;</span>
<span class="nc" id="L413">        long x[] = emptyX;</span>

<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (limit &gt; 0) {</span>
<span class="nc" id="L416">            x = new long[limit];</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            for (int i = 0; i &lt; lenDA; i += 2) {</span>
<span class="nc" id="L418">                x[i] = sourceDAx[i];</span>
            }
<span class="nc bnc" id="L420" title="All 2 branches missed.">            for (int i = 1; i &lt; lenDU; i += 2) {</span>
<span class="nc" id="L421">                x[i] = sourceDUx[i];</span>
            }
        }

<span class="nc" id="L425">        return new Vset(sourceDA.vset, sourceDU.uset, x);</span>
    }

    /**
     * Remove variables from the vset that are no longer part of
     * a context.  Zeroes are stored past varNumber.
     * (Side-effecting.)&lt;p&gt;
     * However, if this is a dead end, keep it so.
     * That is, leave an infinite tail of bits set.
     */
    public Vset removeAdditionalVars(int varNumber) {
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (x == fullX) {</span>
<span class="nc" id="L437">            return this;</span>
        }
<span class="nc" id="L439">        long bit = (1L &lt;&lt; varNumber);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (varNumber &gt;= VBITS) {</span>
<span class="nc" id="L441">            int i = (varNumber / VBITS - 1) * 2;</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            if (i &lt; x.length) {</span>
<span class="nc" id="L443">                x[i] &amp;= (bit - 1);</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                if (++i &lt; x.length) {</span>
<span class="nc" id="L445">                    x[i] &amp;= (bit - 1); // do the &quot;uset&quot; extension also</span>
                }
<span class="nc bnc" id="L447" title="All 2 branches missed.">                while (++i &lt; x.length) {</span>
<span class="nc" id="L448">                    x[i] = 0;</span>
                }
            }
<span class="nc" id="L451">        } else {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (x.length &gt; 0) {</span>
<span class="nc" id="L453">                x = emptyX;</span>
            }
<span class="nc" id="L455">            vset &amp;= (bit - 1);</span>
<span class="nc" id="L456">            uset &amp;= (bit - 1);</span>
        }
<span class="nc" id="L458">        return this;</span>
    }

    /**
     * Return one larger than the highest bit set.
     */
    public int varLimit() {
        long vset;
        int result;
    scan: {
<span class="nc bnc" id="L468" title="All 2 branches missed.">            for (int i = (x.length / 2) * 2; i &gt;= 0; i -= 2) {</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">                if (i == x.length)  continue; // oops</span>
<span class="nc" id="L470">                vset = x[i];</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">                if (i+1 &lt; x.length) {</span>
<span class="nc" id="L472">                    vset |= x[i+1]; // check the &quot;uset&quot; also</span>
                }
<span class="nc bnc" id="L474" title="All 2 branches missed.">                if (vset != 0) {</span>
<span class="nc" id="L475">                    result = (i/2 + 1) * VBITS;</span>
<span class="nc" id="L476">                    break scan;</span>
                }
            }
<span class="nc" id="L479">            vset = this.vset;</span>
<span class="nc" id="L480">            vset |= this.uset;  // check the &quot;uset&quot; also</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (vset != 0) {</span>
<span class="nc" id="L482">                result = 0;</span>
<span class="nc" id="L483">                break scan;</span>
            } else {
<span class="nc" id="L485">                return 0;</span>
            }
        }
<span class="nc bnc" id="L488" title="All 2 branches missed.">        while (vset != 0) {</span>
<span class="nc" id="L489">            result += 1;</span>
<span class="nc" id="L490">            vset &gt;&gt;&gt;= 1;</span>
        }
<span class="nc" id="L492">        return result;</span>
    }

    public String toString() {
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (this == DEAD_END)</span>
<span class="nc" id="L497">            return &quot;{DEAD_END}&quot;;</span>
<span class="nc" id="L498">        StringBuffer sb = new StringBuffer(&quot;{&quot;);</span>
<span class="nc" id="L499">        int maxVar = VBITS * (1 + (x.length+1)/2);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        for (int i = 0; i &lt; maxVar; i++) {</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">            if (!testVarUnassigned(i)) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                if (sb.length() &gt; 1) {</span>
<span class="nc" id="L503">                    sb.append(' ');</span>
                }
<span class="nc" id="L505">                sb.append(i);</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                if (!testVar(i)) {</span>
<span class="nc" id="L507">                    sb.append('?'); // not definitely unassigned</span>
                }
            }
        }
<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (x == fullX) {</span>
<span class="nc" id="L512">            sb.append(&quot;...DEAD_END&quot;);</span>
        }
<span class="nc" id="L514">        sb.append('}');</span>
<span class="nc" id="L515">        return sb.toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>