<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AssignOpExpression.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.tree</a> &gt; <span class="el_source">AssignOpExpression.java</span></div><h1>AssignOpExpression.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.tree;

import sun.tools.java.*;
import sun.tools.asm.Assembler;
import java.io.PrintStream;
import java.util.Hashtable;

/**
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public abstract
class AssignOpExpression extends BinaryAssignExpression {
    protected Type itype;       // Type of intermediate result, before assigning
<span class="nc" id="L41">    final int NOINC = Integer.MAX_VALUE;</span>

<span class="nc" id="L43">    protected FieldUpdater updater = null;   // Used also in 'AssignAddExpression'.</span>

    /**
     * Constructor
     */
    public AssignOpExpression(int op, long where, Expression left, Expression right) {
<span class="nc" id="L49">        super(op, where, left, right);</span>
<span class="nc" id="L50">    }</span>

    /**
     * Select the type
     *
     */

    final void selectType(Environment env, Context ctx, int tm) {
<span class="nc" id="L58">        Type rtype = null;      // special conversion type for RHS</span>
<span class="nc bnc" id="L59" title="All 5 branches missed.">        switch(op) {</span>
            case ASGADD:
<span class="nc bnc" id="L61" title="All 2 branches missed.">                if (left.type == Type.tString) {</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">                    if (right.type == Type.tVoid) {</span>
                        // The type of the right hand side can be
                        // anything except void.  Fix for 4119864.
<span class="nc" id="L65">                        env.error(where, &quot;incompatible.type&quot;,</span>
                                  opNames[op], Type.tVoid, Type.tString);
<span class="nc" id="L67">                        type = Type.tError;</span>
                    } else {
<span class="nc" id="L69">                        type = itype = Type.tString;</span>
                    }
<span class="nc" id="L71">                    return;</span>
                }
                /* Fall through */
            case ASGDIV: case ASGMUL: case ASGSUB: case ASGREM:
<span class="nc bnc" id="L75" title="All 2 branches missed.">                if ((tm &amp; TM_DOUBLE) != 0) {</span>
<span class="nc" id="L76">                    itype = Type.tDouble;</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">                } else if ((tm &amp; TM_FLOAT) != 0) {</span>
<span class="nc" id="L78">                    itype = Type.tFloat;</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">                } else if ((tm &amp; TM_LONG) != 0) {</span>
<span class="nc" id="L80">                    itype = Type.tLong;</span>
                } else {
<span class="nc" id="L82">                    itype = Type.tInt;</span>
                }
<span class="nc" id="L84">                break;</span>

            case ASGBITAND: case ASGBITOR: case ASGBITXOR:
<span class="nc bnc" id="L87" title="All 2 branches missed.">                if ((tm &amp; TM_BOOLEAN) != 0) {</span>
<span class="nc" id="L88">                    itype = Type.tBoolean;</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">                } else if ((tm &amp; TM_LONG) != 0) {</span>
<span class="nc" id="L90">                    itype = Type.tLong;</span>
                } else {
<span class="nc" id="L92">                    itype = Type.tInt;</span>
                }
<span class="nc" id="L94">                break;</span>

            case ASGLSHIFT: case ASGRSHIFT: case ASGURSHIFT:
<span class="nc" id="L97">                rtype = Type.tInt;</span>

                // Fix for bug 4134459.
                // We allow any integral type (even long) to
                // be the right hand side of a shift operation.
<span class="nc bnc" id="L102" title="All 2 branches missed.">                if (right.type.inMask(TM_INTEGER)) {</span>
<span class="nc" id="L103">                    right = new ConvertExpression(where, Type.tInt, right);</span>
                }
                // The intermediate type of the expression is the
                // type of the left hand side after undergoing
                // unary (not binary) type promotion.  We ignore
                // tm -- it contains information about both left
                // and right hand sides -- and we compute the
                // type only from the type of the lhs.
<span class="nc bnc" id="L111" title="All 2 branches missed.">                if (left.type == Type.tLong) {</span>
<span class="nc" id="L112">                    itype = Type.tLong;</span>
                } else {
<span class="nc" id="L114">                    itype = Type.tInt;</span>
                }

<span class="nc" id="L117">                break;</span>

            default:
<span class="nc" id="L120">                throw new CompilerError(&quot;Bad assignOp type: &quot; + op);</span>
        }
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (rtype == null) {</span>
<span class="nc" id="L123">            rtype = itype;</span>
        }
<span class="nc" id="L125">        right = convert(env, ctx, rtype, right);</span>
        // The result is always the type of the left operand.

<span class="nc" id="L128">        type = left.type;</span>
<span class="nc" id="L129">    }</span>


    /**
     * Get the increment, return NOINC if an increment is not possible
     */
    int getIncrement() {
<span class="nc bnc" id="L136" title="All 6 branches missed.">        if ((left.op == IDENT) &amp;&amp; type.isType(TC_INT) &amp;&amp; (right.op == INTVAL))</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">            if ((op == ASGADD) || (op == ASGSUB))</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                if (((IdentifierExpression)left).field.isLocal()) {</span>
<span class="nc" id="L139">                    int val = ((IntExpression)right).value;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                    if (op == ASGSUB)</span>
<span class="nc" id="L141">                        val = -val;</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                    if (val == (short)val)</span>
<span class="nc" id="L143">                        return val;</span>
                }
<span class="nc" id="L145">        return NOINC;</span>
    }


    /**
     * Check an assignment expression
     */
    public Vset checkValue(Environment env, Context ctx, Vset vset, Hashtable exp) {
<span class="nc" id="L153">        vset = left.checkAssignOp(env, ctx, vset, exp, this);</span>
<span class="nc" id="L154">        vset = right.checkValue(env, ctx, vset, exp);</span>
<span class="nc" id="L155">        int tm = left.type.getTypeMask() | right.type.getTypeMask();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if ((tm &amp; TM_ERROR) != 0) {</span>
<span class="nc" id="L157">            return vset;</span>
        }
<span class="nc" id="L159">        selectType(env, ctx, tm);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (!type.isType(TC_ERROR)) {</span>
<span class="nc" id="L161">            convert(env, ctx, itype, left);</span>
        }
<span class="nc" id="L163">        updater = left.getUpdater(env, ctx);  // Must be called after 'checkAssignOp'.</span>
<span class="nc" id="L164">        return vset;</span>
    }

    /**
     * Inline
     */
    public Expression inlineValue(Environment env, Context ctx) {
        // Why not inlineLHS?  But that does not work.
<span class="nc" id="L172">        left = left.inlineValue(env, ctx);</span>
<span class="nc" id="L173">        right = right.inlineValue(env, ctx);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (updater != null) {</span>
<span class="nc" id="L175">            updater = updater.inline(env, ctx);</span>
        }
<span class="nc" id="L177">        return this;</span>
    }

    /**
     * Create a copy of the expression for method inlining
     */
    public Expression copyInline(Context ctx) {
<span class="nc" id="L184">        AssignOpExpression e = (AssignOpExpression)clone();</span>
<span class="nc" id="L185">        e.left = left.copyInline(ctx);</span>
<span class="nc" id="L186">        e.right = right.copyInline(ctx);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (updater != null) {</span>
<span class="nc" id="L188">            e.updater = updater.copyInline(ctx);</span>
        }
<span class="nc" id="L190">        return e;</span>
    }

    /**
     * The cost of inlining this statement
     */
    public int costInline(int thresh, Environment env, Context ctx) {
        /*----------*
        return (getIncrement() != NOINC)
            ? 2
            : (3 + super.costInline(thresh, env, ctx));
        *----------*/
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (updater == null) {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            return (getIncrement() != NOINC)</span>
                // Increment variable in place.  Count 3 bytes for 'iinc'.
                ? 3
                // Cost of rhs expression + cost of lhs expression + cost
                // of load/op/store instructions.  E.g.: iload = 1 or 2,
                // istore = 1 or 2, iadd = 1.  Cost could be higher if
                // getfield/putfield or conversions needed, lower if rhs is
                // a small constant.  Costs are highly approximate.
<span class="nc" id="L211">                : right.costInline(thresh, env, ctx) +</span>
<span class="nc" id="L212">                      left.costInline(thresh, env, ctx) + 4;</span>
        } else {
            // Cost of rhs expression + (2 * cost of access method call) +
            // cost of operator.  Does not account for cost of conversions,
            // or duplications in value-needed context.
<span class="nc" id="L217">            return right.costInline(thresh, env, ctx) +</span>
<span class="nc" id="L218">                updater.costInline(thresh, env, ctx, true) + 1;</span>
        }
    }

    /**
     * Code
     */
    void code(Environment env, Context ctx, Assembler asm, boolean valNeeded) {

        // Handle cases in which a '+=' or '-=' operator can be optimized using
        // the 'iinc' instruction.  See also 'IncDecExpression.codeIncDec'.
        // The 'iinc' instruction cannot be used if an access method call is required.
<span class="nc" id="L230">        int val = getIncrement();</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">        if (val != NOINC &amp;&amp; updater == null) {</span>
<span class="nc" id="L232">            int v = ((LocalMember)((IdentifierExpression)left).field).number;</span>
<span class="nc" id="L233">            int[] operands = { v, val };</span>
<span class="nc" id="L234">            asm.add(where, opc_iinc, operands);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (valNeeded) {</span>
<span class="nc" id="L236">                left.codeValue(env, ctx, asm);</span>
            }
<span class="nc" id="L238">            return;</span>
        }

<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (updater == null) {</span>
            // Field is directly accessible.
<span class="nc" id="L243">            int depth = left.codeLValue(env, ctx, asm);</span>
<span class="nc" id="L244">            codeDup(env, ctx, asm, depth, 0);</span>
<span class="nc" id="L245">            left.codeLoad(env, ctx, asm);</span>
<span class="nc" id="L246">            codeConversion(env, ctx, asm, left.type, itype);</span>
<span class="nc" id="L247">            right.codeValue(env, ctx, asm);</span>
<span class="nc" id="L248">            codeOperation(env, ctx, asm);</span>
<span class="nc" id="L249">            codeConversion(env, ctx, asm, itype, type);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (valNeeded) {</span>
<span class="nc" id="L251">                codeDup(env, ctx, asm, type.stackSize(), depth);</span>
            }
<span class="nc" id="L253">            left.codeStore(env, ctx, asm);</span>
<span class="nc" id="L254">        } else {</span>
            // Must use access methods.
<span class="nc" id="L256">            updater.startUpdate(env, ctx, asm, false);</span>
<span class="nc" id="L257">            codeConversion(env, ctx, asm, left.type, itype);</span>
<span class="nc" id="L258">            right.codeValue(env, ctx, asm);</span>
<span class="nc" id="L259">            codeOperation(env, ctx, asm);</span>
<span class="nc" id="L260">            codeConversion(env, ctx, asm, itype, type);</span>
<span class="nc" id="L261">            updater.finishUpdate(env, ctx, asm, valNeeded);</span>
        }
<span class="nc" id="L263">    }</span>

    public void codeValue(Environment env, Context ctx, Assembler asm) {
<span class="nc" id="L266">        code(env, ctx, asm, true);</span>
<span class="nc" id="L267">    }</span>
    public void code(Environment env, Context ctx, Assembler asm) {
<span class="nc" id="L269">        code(env, ctx, asm, false);</span>
<span class="nc" id="L270">    }</span>

    /**
     * Print
     */
    public void print(PrintStream out) {
<span class="nc" id="L276">        out.print(&quot;(&quot; + opNames[op] + &quot; &quot;);</span>
<span class="nc" id="L277">        left.print(out);</span>
<span class="nc" id="L278">        out.print(&quot; &quot;);</span>
<span class="nc" id="L279">        right.print(out);</span>
<span class="nc" id="L280">        out.print(&quot;)&quot;);</span>
<span class="nc" id="L281">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>