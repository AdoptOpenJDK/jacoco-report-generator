<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Statement.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.tree</a> &gt; <span class="el_source">Statement.java</span></div><h1>Statement.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.tree;

import sun.tools.java.*;
import sun.tools.asm.Assembler;
import sun.tools.asm.Label;
import java.io.PrintStream;
import java.util.Hashtable;

/**
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public
class Statement extends Node {
<span class="nc" id="L41">    public static final Vset DEAD_END = Vset.DEAD_END;</span>
<span class="nc" id="L42">    Identifier labels[] = null;</span>

    /**
     * Constructor
     */
    Statement(int op, long where) {
<span class="nc" id="L48">        super(op, where);</span>
<span class="nc" id="L49">    }</span>

    /**
     * An empty statement.  Its costInline is infinite.
     */
<span class="nc" id="L54">    public static final Statement empty = new Statement(STAT, 0);</span>

    /**
     * The largest possible interesting inline cost value.
     */
<span class="nc" id="L59">    public static final int MAXINLINECOST =</span>
<span class="nc" id="L60">                      Integer.getInteger(&quot;javac.maxinlinecost&quot;,</span>
<span class="nc" id="L61">                                         30).intValue();</span>

    /**
     * Insert a bit of code at the front of a statement.
     * Side-effect s2, if it is a CompoundStatement.
     */
    public static Statement insertStatement(Statement s1, Statement s2) {
<span class="nc bnc" id="L68" title="All 2 branches missed.">        if (s2 == null) {</span>
<span class="nc" id="L69">            s2 = s1;</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        } else if (s2 instanceof CompoundStatement) {</span>
            // Do not add another level of block nesting.
<span class="nc" id="L72">            ((CompoundStatement)s2).insertStatement(s1);</span>
        } else {
<span class="nc" id="L74">            Statement body[] = { s1, s2 };</span>
<span class="nc" id="L75">            s2 = new CompoundStatement(s1.getWhere(), body);</span>
        }
<span class="nc" id="L77">        return s2;</span>
    }

    /**
     * Set the label of a statement
     */
    public void setLabel(Environment env, Expression e) {
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if (e.op == IDENT) {</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">            if (labels == null) {</span>
<span class="nc" id="L86">                labels = new Identifier[1];</span>
            } else {
                // this should almost never happen.  Multiple labels on
                // the same statement.  But handle it gracefully.
<span class="nc" id="L90">                Identifier newLabels[] = new Identifier[labels.length + 1];</span>
<span class="nc" id="L91">                System.arraycopy(labels, 0, newLabels, 1, labels.length);</span>
<span class="nc" id="L92">                labels = newLabels;</span>
            }
<span class="nc" id="L94">            labels[0] = ((IdentifierExpression)e).id;</span>
        } else {
<span class="nc" id="L96">            env.error(e.where, &quot;invalid.label&quot;);</span>
        }
<span class="nc" id="L98">    }</span>

    /**
     * Check a statement
     */
    public Vset checkMethod(Environment env, Context ctx, Vset vset, Hashtable exp) {
        // Set up ctx.getReturnContext() for the sake of ReturnStatement.check().
<span class="nc" id="L105">        CheckContext mctx = new CheckContext(ctx, new Statement(METHOD, 0));</span>
<span class="nc" id="L106">        ctx = mctx;</span>

<span class="nc" id="L108">        vset = check(env, ctx, vset, exp);</span>

        // Check for return
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (!ctx.field.getType().getReturnType().isType(TC_VOID)) {</span>
            // In general, we suppress further error messages due to
            // unreachable statements after reporting the first error
            // along a flow path (using 'clearDeadEnd').   Here, we
            // report an error anyway, because the end of the method
            // should be unreachable despite the earlier error.  The
            // difference in treatment is due to the fact that, in this
            // case, the error is reachability, not unreachability.
            // NOTE: In addition to this subtle difference in the quality
            // of the error diagnostics, this treatment is essential to
            // preserve the correctness of using 'clearDeadEnd' to implement
            // the special-case reachability rules for if-then and if-then-else.
<span class="nc bnc" id="L123" title="All 2 branches missed.">            if (!vset.isDeadEnd()) {</span>
<span class="nc" id="L124">                env.error(ctx.field.getWhere(), &quot;return.required.at.end&quot;, ctx.field);</span>
            }
        }

        // Simulate a return at the end.
<span class="nc" id="L129">        vset = vset.join(mctx.vsBreak);</span>

<span class="nc" id="L131">        return vset;</span>
    }
    Vset checkDeclaration(Environment env, Context ctx, Vset vset, int mod, Type t, Hashtable exp) {
<span class="nc" id="L134">        throw new CompilerError(&quot;checkDeclaration&quot;);</span>
    }

    /**
     * Make sure the labels on this statement do not duplicate the
     * labels on any enclosing statement.  Provided as a convenience
     * for subclasses.
     */
    protected void checkLabel(Environment env, Context ctx) {
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (labels != null) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            loop: for (int i = 0; i &lt; labels.length; i++) {</span>
                // Make sure there is not a double label on this statement.
<span class="nc bnc" id="L146" title="All 2 branches missed.">                for (int j = i+1; j &lt; labels.length; j++) {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">                    if (labels[i] == labels[j]) {</span>
<span class="nc" id="L148">                        env.error(where, &quot;nested.duplicate.label&quot;, labels[i]);</span>
<span class="nc" id="L149">                        continue loop;</span>
                    }
                }

                // Make sure no enclosing statement has the same label.
<span class="nc" id="L154">                CheckContext destCtx =</span>
<span class="nc" id="L155">                    (CheckContext) ctx.getLabelContext(labels[i]);</span>

<span class="nc bnc" id="L157" title="All 2 branches missed.">                if (destCtx != null) {</span>
                    // Check to make sure the label is in not uplevel.
<span class="nc bnc" id="L159" title="All 2 branches missed.">                    if (destCtx.frameNumber == ctx.frameNumber) {</span>
<span class="nc" id="L160">                        env.error(where, &quot;nested.duplicate.label&quot;, labels[i]);</span>
                    }
                }
            } // end loop
        }
<span class="nc" id="L165">    }</span>

    Vset check(Environment env, Context ctx, Vset vset, Hashtable exp) {
<span class="nc" id="L168">        throw new CompilerError(&quot;check&quot;);</span>
    }

    /** This is called in contexts where declarations are valid. */
    Vset checkBlockStatement(Environment env, Context ctx, Vset vset, Hashtable exp) {
<span class="nc" id="L173">        return check(env, ctx, vset, exp);</span>
    }

    Vset reach(Environment env, Vset vset) {
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (vset.isDeadEnd()) {</span>
<span class="nc" id="L178">            env.error(where, &quot;stat.not.reached&quot;);</span>
<span class="nc" id="L179">            vset = vset.clearDeadEnd();</span>
        }
<span class="nc" id="L181">        return vset;</span>
    }

    /**
     * Inline
     */
    public Statement inline(Environment env, Context ctx) {
<span class="nc" id="L188">        return this;</span>
    }

    /**
     * Eliminate this statement, which is only possible if it has no label.
     */
    public Statement eliminate(Environment env, Statement s) {
<span class="nc bnc" id="L195" title="All 4 branches missed.">        if ((s != null) &amp;&amp; (labels != null)) {</span>
<span class="nc" id="L196">            Statement args[] = {s};</span>
<span class="nc" id="L197">            s = new CompoundStatement(where, args);</span>
<span class="nc" id="L198">            s.labels = labels;</span>
        }
<span class="nc" id="L200">        return s;</span>
    }


    /**
     * Code
     */
    public void code(Environment env, Context ctx, Assembler asm) {
<span class="nc" id="L208">        throw new CompilerError(&quot;code&quot;);</span>
    }

    /**
     * Generate the code to call all finally's for a break, continue, or
     * return statement.  We must call &quot;jsr&quot; on all the cleanup code between
     * the current context &quot;ctx&quot;, and the destination context &quot;stopctx&quot;.
     * If 'save' isn't null, there is also a value on the top of the stack
     */
    void codeFinally(Environment env, Context ctx, Assembler asm,
                        Context stopctx, Type save) {
<span class="nc" id="L219">        Integer num = null;</span>
<span class="nc" id="L220">        boolean haveCleanup = false; // there is a finally or synchronize;</span>
<span class="nc" id="L221">        boolean haveNonLocalFinally = false; // some finally doesn't return;</span>

<span class="nc bnc" id="L223" title="All 4 branches missed.">        for (Context c = ctx; (c != null) &amp;&amp; (c != stopctx); c = c.prev) {</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">            if (c.node == null)</span>
<span class="nc" id="L225">                continue;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (c.node.op == SYNCHRONIZED) {</span>
<span class="nc" id="L227">                haveCleanup = true;</span>
<span class="nc bnc" id="L228" title="All 4 branches missed.">            } else if (c.node.op == FINALLY</span>
                          &amp;&amp; ((CodeContext)c).contLabel != null) {
                // c.contLabel == null indicates we're in the &quot;finally&quot; part
<span class="nc" id="L231">                haveCleanup = true;</span>
<span class="nc" id="L232">                FinallyStatement st = ((FinallyStatement)(c.node));</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                if (!st.finallyCanFinish) {</span>
<span class="nc" id="L234">                    haveNonLocalFinally = true;</span>
                    // after hitting a non-local finally, no need generating
                    // further code, because it won't get executed.
<span class="nc" id="L237">                    break;</span>
                }
            }
        }
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (!haveCleanup) {</span>
            // there is no cleanup that needs to be done.  Just quit.
<span class="nc" id="L243">            return;</span>
        }
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (save != null) {</span>
            // This statement has a return value on the stack.
<span class="nc" id="L247">            ClassDefinition def = ctx.field.getClassDefinition();</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            if (!haveNonLocalFinally) {</span>
                // Save the return value in the register which should have
                // been reserved.
<span class="nc" id="L251">                LocalMember lf = ctx.getLocalField(idFinallyReturnValue);</span>
<span class="nc" id="L252">                num = new Integer(lf.number);</span>
<span class="nc" id="L253">                asm.add(where, opc_istore + save.getTypeCodeOffset(), num);</span>
<span class="nc" id="L254">            } else {</span>
                // Pop the return value.
<span class="nc bnc" id="L256" title="All 3 branches missed.">                switch(ctx.field.getType().getReturnType().getTypeCode()) {</span>
                    case TC_VOID:
<span class="nc" id="L258">                        break;</span>
                    case TC_DOUBLE: case TC_LONG:
<span class="nc" id="L260">                        asm.add(where, opc_pop2); break;</span>
                    default:
<span class="nc" id="L262">                        asm.add(where, opc_pop); break;</span>
                }
            }
        }
        // Call each of the cleanup functions, as necessary.
<span class="nc bnc" id="L267" title="All 4 branches missed.">        for (Context c = ctx ; (c != null)  &amp;&amp; (c != stopctx) ; c = c.prev) {</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (c.node == null)</span>
<span class="nc" id="L269">                continue;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            if (c.node.op == SYNCHRONIZED) {</span>
<span class="nc" id="L271">                asm.add(where, opc_jsr, ((CodeContext)c).contLabel);</span>
<span class="nc bnc" id="L272" title="All 4 branches missed.">            } else if (c.node.op == FINALLY</span>
                          &amp;&amp; ((CodeContext)c).contLabel != null) {
<span class="nc" id="L274">                FinallyStatement st = ((FinallyStatement)(c.node));</span>
<span class="nc" id="L275">                Label label = ((CodeContext)c).contLabel;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">                if (st.finallyCanFinish) {</span>
<span class="nc" id="L277">                    asm.add(where, opc_jsr, label);</span>
                } else {
                    // the code never returns, so we're done.
<span class="nc" id="L280">                    asm.add(where, opc_goto, label);</span>
<span class="nc" id="L281">                    break;</span>
                }
            }
        }
        // Move the return value from the register back to the stack.
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (num != null) {</span>
<span class="nc" id="L287">            asm.add(where, opc_iload + save.getTypeCodeOffset(), num);</span>
        }
<span class="nc" id="L289">    }</span>

    /*
     * Return true if the statement has the given label
     */
    public boolean hasLabel (Identifier lbl) {
<span class="nc" id="L295">        Identifier labels[] = this.labels;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (labels != null) {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">            for (int i = labels.length; --i &gt;= 0; ) {</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                if (labels[i].equals(lbl)) {</span>
<span class="nc" id="L299">                    return true;</span>
                }
            }
        }
<span class="nc" id="L303">        return false;</span>
    }

    /**
     * Check if the first thing is a constructor invocation
     */
    public Expression firstConstructor() {
<span class="nc" id="L310">        return null;</span>
    }

    /**
     * Create a copy of the statement for method inlining
     */
    public Statement copyInline(Context ctx, boolean valNeeded) {
<span class="nc" id="L317">        return (Statement)clone();</span>
    }

    public int costInline(int thresh, Environment env, Context ctx) {
<span class="nc" id="L321">        return thresh;</span>
    }


    /**
     * Print
     */
    void printIndent(PrintStream out, int indent) {
<span class="nc bnc" id="L329" title="All 2 branches missed.">        for (int i = 0 ; i &lt; indent ; i++) {</span>
<span class="nc" id="L330">            out.print(&quot;    &quot;);</span>
        }
<span class="nc" id="L332">    }</span>
    public void print(PrintStream out, int indent) {
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (labels != null) {</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            for (int i = labels.length; --i &gt;= 0; )</span>
<span class="nc" id="L336">                out.print(labels[i] + &quot;: &quot;);</span>
        }
<span class="nc" id="L338">    }</span>
    public void print(PrintStream out) {
<span class="nc" id="L340">        print(out, 0);</span>
<span class="nc" id="L341">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>