<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Context.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.tree</a> &gt; <span class="el_source">Context.java</span></div><h1>Context.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.tree;

import sun.tools.java.*;
import sun.tools.asm.Assembler;

/**
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public
class Context implements Constants {
    Context prev;
    Node node;
    int varNumber;
    LocalMember locals;
    LocalMember classes;
    MemberDefinition field;
    int scopeNumber;
    int frameNumber;

    /**
     * Create the initial context for a method
     * The incoming context is inherited from
     */
<span class="nc" id="L51">    public Context(Context ctx, MemberDefinition field) {</span>
<span class="nc" id="L52">        this.field = field;</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">        if (ctx == null) {</span>
<span class="nc" id="L54">            this.frameNumber = 1;</span>
<span class="nc" id="L55">            this.scopeNumber = 2;</span>
<span class="nc" id="L56">            this.varNumber = 0;</span>
        } else {
<span class="nc" id="L58">            this.prev = ctx;</span>
<span class="nc" id="L59">            this.locals = ctx.locals;</span>
<span class="nc" id="L60">            this.classes = ctx.classes;</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">            if (field != null &amp;&amp;</span>
<span class="nc bnc" id="L62" title="All 4 branches missed.">                  (field.isVariable() || field.isInitializer())) {</span>
                // Variables and initializers are inlined into a constructor.
                // Model this by inheriting the frame number of the parent,
                // which will contain a &quot;this&quot; parameter.
<span class="nc" id="L66">                this.frameNumber = ctx.frameNumber;</span>
<span class="nc" id="L67">                this.scopeNumber = ctx.scopeNumber + 1;</span>
            } else {
<span class="nc" id="L69">                this.frameNumber = ctx.scopeNumber + 1;</span>
<span class="nc" id="L70">                this.scopeNumber = this.frameNumber + 1;</span>
            }
<span class="nc" id="L72">            this.varNumber = ctx.varNumber;</span>
        }
<span class="nc" id="L74">    }</span>

    /**
     * Create a new context, for initializing a class.
     */
    public Context(Context ctx, ClassDefinition c) {
<span class="nc" id="L80">        this(ctx, (MemberDefinition)null);</span>
<span class="nc" id="L81">    }</span>

    /**
     * Create a new nested context, for a block statement
     */
<span class="nc" id="L86">    Context(Context ctx, Node node) {</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (ctx == null) {</span>
<span class="nc" id="L88">            this.frameNumber = 1;</span>
<span class="nc" id="L89">            this.scopeNumber = 2;</span>
<span class="nc" id="L90">            this.varNumber = 0;</span>
        } else {
<span class="nc" id="L92">            this.prev = ctx;</span>
<span class="nc" id="L93">            this.locals = ctx.locals;</span>
            // Inherit local classes from surrounding block,
            // just as for local variables.  Fixes 4074421.
<span class="nc" id="L96">            this.classes = ctx.classes;</span>
<span class="nc" id="L97">            this.varNumber = ctx.varNumber;</span>
<span class="nc" id="L98">            this.field = ctx.field;</span>
<span class="nc" id="L99">            this.frameNumber = ctx.frameNumber;</span>
<span class="nc" id="L100">            this.scopeNumber = ctx.scopeNumber + 1;</span>
<span class="nc" id="L101">            this.node = node;</span>
        }
<span class="nc" id="L103">    }</span>

    public Context(Context ctx) {
<span class="nc" id="L106">        this(ctx, (Node)null);</span>
<span class="nc" id="L107">    }</span>

    /**
     * Declare local
     */
    public int declare(Environment env, LocalMember local) {
        //System.out.println(   &quot;DECLARE= &quot; + local.getName() + &quot;=&quot; + varNumber + &quot;, read=&quot; + local.readcount + &quot;, write=&quot; + local.writecount + &quot;, hash=&quot; + local.hashCode());
<span class="nc" id="L114">        local.scopeNumber = scopeNumber;</span>
<span class="nc bnc" id="L115" title="All 4 branches missed.">        if (this.field == null &amp;&amp; idThis.equals(local.getName())) {</span>
<span class="nc" id="L116">            local.scopeNumber += 1; // Anticipate variable or initializer.</span>
        }
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (local.isInnerClass()) {</span>
<span class="nc" id="L119">            local.prev = classes;</span>
<span class="nc" id="L120">            classes = local;</span>
<span class="nc" id="L121">            return 0;</span>
        }

        // Originally the statement:
        //
        //     local.subModifiers(M_INLINEABLE);
        //
        // was here with the comment:
        //
        //     // prevent inlining across call sites
        //
        // This statement prevented constant local variables from
        // inlining. It didn't seem to do anything useful.
        //
        // The statement has been removed and an assertion has been
        // added which mandates that the only members which are marked
        // with M_INLINEABLE are the ones for which isConstant() is true.
        // (Fix for 4106244.)
        //
        // Addition to the above comment: they might also be
        // final variables initialized with 'this', 'super', or other
        // final identifiers.  See VarDeclarationStatement.inline().
        // So I've removed the assertion.  The original subModifiers
        // call appears to have been there to fix nested class translation
        // breakage, which has been fixed in VarDeclarationStatement
        // now instead.  (Fix for 4073244.)

<span class="nc" id="L148">        local.prev = locals;</span>
<span class="nc" id="L149">        locals = local;</span>
<span class="nc" id="L150">        local.number = varNumber;</span>
<span class="nc" id="L151">        varNumber += local.getType().stackSize();</span>
<span class="nc" id="L152">        return local.number;</span>
    }

    /**
     * Get a local variable by name
     */
    public
    LocalMember getLocalField(Identifier name) {
<span class="nc bnc" id="L160" title="All 2 branches missed.">        for (LocalMember f = locals ; f != null ; f = f.prev) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            if (name.equals(f.getName())) {</span>
<span class="nc" id="L162">                return f;</span>
            }
        }
<span class="nc" id="L165">        return null;</span>
    }

    /**
     * Get the scope number for a reference to a member of this class
     * (Larger scope numbers are more deeply nested.)
     * @see LocalMember#scopeNumber
     */
    public
    int getScopeNumber(ClassDefinition c) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        for (Context ctx = this; ctx != null; ctx = ctx.prev) {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">            if (ctx.field == null)  continue;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (ctx.field.getClassDefinition() == c) {</span>
<span class="nc" id="L178">                return ctx.frameNumber;</span>
            }
        }
<span class="nc" id="L181">        return -1;</span>
    }

    private
    MemberDefinition getFieldCommon(Environment env, Identifier name,
                                   boolean apparentOnly) throws AmbiguousMember, ClassNotFound {
        // Note:  This is structured as a pair of parallel lookups.
        // If we were to redesign Context, we might prefer to walk
        // along a single chain of scopes.

<span class="nc" id="L191">        LocalMember lf = getLocalField(name);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        int ls = (lf == null) ? -2 : lf.scopeNumber;</span>

<span class="nc" id="L194">        ClassDefinition thisClass = field.getClassDefinition();</span>

        // Also look for a class member in a shallower scope.
<span class="nc" id="L197">        for (ClassDefinition c = thisClass;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">             c != null;</span>
<span class="nc" id="L199">             c = c.getOuterClass()) {</span>
<span class="nc" id="L200">            MemberDefinition f = c.getVariable(env, name, thisClass);</span>
<span class="nc bnc" id="L201" title="All 4 branches missed.">            if (f != null &amp;&amp; getScopeNumber(c) &gt; ls) {</span>
<span class="nc bnc" id="L202" title="All 4 branches missed.">                if (apparentOnly &amp;&amp; f.getClassDefinition() != c) {</span>
<span class="nc" id="L203">                    continue;</span>
                }
<span class="nc" id="L205">                return f;</span>
            }
        }

<span class="nc" id="L209">        return lf;</span>
    }

    /**
     * Assign a number to a class field.
     * (This is used to track definite assignment of some blank finals.)
     */
    public int declareFieldNumber(MemberDefinition field) {
<span class="nc" id="L217">        return declare(null, new LocalMember(field));</span>
    }

    /**
     * Retrieve a number previously assigned by declareMember().
     * Return -1 if there was no such assignment in this context.
     */
    public int getFieldNumber(MemberDefinition field) {
<span class="nc bnc" id="L225" title="All 2 branches missed.">        for (LocalMember f = locals ; f != null ; f = f.prev) {</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (f.getMember() == field) {</span>
<span class="nc" id="L227">                return f.number;</span>
            }
        }
<span class="nc" id="L230">        return -1;</span>
    }

    /**
     * Return the local field or member field corresponding to a number.
     * Return null if there is no such field.
     */
    public MemberDefinition getElement(int number) {
<span class="nc bnc" id="L238" title="All 2 branches missed.">        for (LocalMember f = locals ; f != null ; f = f.prev) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (f.number == number) {</span>
<span class="nc" id="L240">                MemberDefinition field = f.getMember();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                return (field != null) ? field : f;</span>
            }
        }
<span class="nc" id="L244">        return null;</span>
    }

    /**
     * Get a local class by name
     */
    public
    LocalMember getLocalClass(Identifier name) {
<span class="nc bnc" id="L252" title="All 2 branches missed.">        for (LocalMember f = classes ; f != null ; f = f.prev) {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (name.equals(f.getName())) {</span>
<span class="nc" id="L254">                return f;</span>
            }
        }
<span class="nc" id="L257">        return null;</span>
    }

    private
    MemberDefinition getClassCommon(Environment env, Identifier name,
                                   boolean apparentOnly) throws ClassNotFound {
<span class="nc" id="L263">        LocalMember lf = getLocalClass(name);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">        int ls = (lf == null) ? -2 : lf.scopeNumber;</span>

        // Also look for a class member in a shallower scope.
<span class="nc" id="L267">        for (ClassDefinition c = field.getClassDefinition();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">             c != null;</span>
<span class="nc" id="L269">             c = c.getOuterClass()) {</span>
            // QUERY: We may need to get the inner class from a
            // superclass of 'c'.  This call is prepared to
            // resolve the superclass if necessary.  Can we arrange
            // to assure that it is always previously resolved?
            // This is one of a small number of problematic calls that
            // requires 'getSuperClass' to resolve superclasses on demand.
            // See 'ClassDefinition.getInnerClass(env, nm)'.
<span class="nc" id="L277">            MemberDefinition f = c.getInnerClass(env, name);</span>
<span class="nc bnc" id="L278" title="All 4 branches missed.">            if (f != null &amp;&amp; getScopeNumber(c) &gt; ls) {</span>
<span class="nc bnc" id="L279" title="All 4 branches missed.">                if (apparentOnly &amp;&amp; f.getClassDefinition() != c) {</span>
<span class="nc" id="L280">                    continue;</span>
                }
<span class="nc" id="L282">                return f;</span>
            }
        }

<span class="nc" id="L286">        return lf;</span>
    }

    /**
     * Get either a local variable, or a field in a current class
     */
    public final
    MemberDefinition getField(Environment env, Identifier name) throws AmbiguousMember, ClassNotFound {
<span class="nc" id="L294">        return getFieldCommon(env, name, false);</span>
    }

    /**
     * Like getField, except that it skips over inherited fields.
     * Used for error checking.
     */
    public final
    MemberDefinition getApparentField(Environment env, Identifier name) throws AmbiguousMember, ClassNotFound {
<span class="nc" id="L303">        return getFieldCommon(env, name, true);</span>
    }

    /**
     * Check if the given field is active in this context.
     */
    public boolean isInScope(LocalMember field) {
<span class="nc bnc" id="L310" title="All 2 branches missed.">        for (LocalMember f = locals ; f != null ; f = f.prev) {</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">            if (field == f) {</span>
<span class="nc" id="L312">                return true;</span>
            }
        }
<span class="nc" id="L315">        return false;</span>
    }

    /**
     * Notice a reference (usually an uplevel one).
     * Update the references list of every enclosing class
     * which is enclosed by the scope of the target.
     * Update decisions about which uplevels to make into fields.
     * Return the uplevel reference descriptor, or null if it's local.
     * &lt;p&gt;
     * The target must be in scope in this context.
     * So, call this method only from the check phase.
     * (In other phases, the context may be less complete.)
     * &lt;p&gt;
     * This can and should be called both before and after classes are frozen.
     * It should be a no-op, and will raise a compiler error if not.
     */
    public UplevelReference noteReference(Environment env, LocalMember target) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">        int targetScopeNumber = !isInScope(target) ? -1 : target.scopeNumber;</span>

        // Walk outward visiting each scope.
        // Note each distinct frame (i.e., enclosing method).
        // For each frame in which the variable is uplevel,
        // record the event in the references list of the enclosing class.
<span class="nc" id="L339">        UplevelReference res = null;</span>
<span class="nc" id="L340">        int currentFrameNumber = -1;</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        for (Context refctx = this; refctx != null; refctx = refctx.prev) {</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">            if (currentFrameNumber == refctx.frameNumber) {</span>
<span class="nc" id="L343">                continue;       // we're processing frames, not contexts</span>
            }
<span class="nc" id="L345">            currentFrameNumber = refctx.frameNumber;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if (targetScopeNumber &gt;= currentFrameNumber) {</span>
<span class="nc" id="L347">                break;          // the target is native to this frame</span>
            }

            // process a frame which is using this variable as an uplevel
<span class="nc" id="L351">            ClassDefinition refc = refctx.field.getClassDefinition();</span>
<span class="nc" id="L352">            UplevelReference r = refc.getReference(target);</span>
<span class="nc" id="L353">            r.noteReference(env, refctx);</span>

            // remember the reference pertaining to the innermost frame
<span class="nc bnc" id="L356" title="All 2 branches missed.">            if (res == null) {</span>
<span class="nc" id="L357">                res = r;</span>
            }
        }
<span class="nc" id="L360">        return res;</span>
    }

    /**
     * Implement a reference (usually an uplevel one).
     * Call noteReference() first, to make sure the reference
     * lists are up to date.
     * &lt;p&gt;
     * The resulting expression tree does not need checking;
     * it can be code-generated right away.
     * If the reference is not uplevel, the result is an IDENT or THIS.
     */
    public Expression makeReference(Environment env, LocalMember target) {
<span class="nc" id="L373">        UplevelReference r = noteReference(env, target);</span>

        // Now create a referencing expression.
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (r != null) {</span>
<span class="nc" id="L377">            return r.makeLocalReference(env, this);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        } else if (idThis.equals(target.getName())) {</span>
<span class="nc" id="L379">            return new ThisExpression(0, target);</span>
        } else {
<span class="nc" id="L381">            return new IdentifierExpression(0, target);</span>
        }
    }

    /**
     * Return a local expression which can serve as the base reference
     * for the given field.  If the field is a constructor, return an
     * expression for the implicit enclosing instance argument.
     * &lt;p&gt;
     * Return null if there is no need for such an argument,
     * or if there was an error.
     */
    public Expression findOuterLink(Environment env, long where,
                                    MemberDefinition f) {
        // reqc is the base pointer type required to use f
<span class="nc" id="L396">        ClassDefinition fc = f.getClassDefinition();</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        ClassDefinition reqc = f.isStatic() ? null</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                             : !f.isConstructor() ? fc</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                             : fc.isTopLevel() ? null</span>
<span class="nc" id="L400">                             : fc.getOuterClass();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (reqc == null) {</span>
<span class="nc" id="L402">            return null;</span>
        }
<span class="nc" id="L404">        return findOuterLink(env, where, reqc, f, false);</span>
    }

    private static boolean match(Environment env,
                                 ClassDefinition thisc, ClassDefinition reqc) {
        try {
<span class="nc bnc" id="L410" title="All 2 branches missed.">            return thisc == reqc</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                || reqc.implementedBy(env, thisc.getClassDeclaration());</span>
<span class="nc" id="L412">        } catch (ClassNotFound ee) {</span>
<span class="nc" id="L413">            return false;</span>
        }
    }

    public Expression findOuterLink(Environment env, long where,
                                    ClassDefinition reqc,
                                    MemberDefinition f,
                                    boolean needExactMatch) {
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (field.isStatic()) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (f == null) {</span>
                // say something like: undefined variable A.this
<span class="nc" id="L424">                Identifier nm = reqc.getName().getFlatName().getName();</span>
<span class="nc" id="L425">                env.error(where, &quot;undef.var&quot;, Identifier.lookup(nm,idThis));</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            } else if (f.isConstructor()) {</span>
<span class="nc" id="L427">                env.error(where, &quot;no.outer.arg&quot;, reqc, f.getClassDeclaration());</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            } else if (f.isMethod()) {</span>
<span class="nc" id="L429">                env.error(where, &quot;no.static.meth.access&quot;,</span>
<span class="nc" id="L430">                          f, f.getClassDeclaration());</span>
            } else {
<span class="nc" id="L432">                env.error(where, &quot;no.static.field.access&quot;, f.getName(),</span>
<span class="nc" id="L433">                          f.getClassDeclaration());</span>
            }
            // This is an attempt at error recovery.
            // Unfortunately, the constructor may throw
            // a null pointer exception after failing to resolve
            // 'idThis'.  Since an error message has already been
            // issued previously, this exception is caught and
            // silently ignored.  Ideally, we should avoid throwing
            // the exception.
<span class="nc" id="L442">            Expression e = new ThisExpression(where, this);</span>
<span class="nc" id="L443">            e.type = reqc.getType();</span>
<span class="nc" id="L444">            return e;</span>
        }

        // use lp to scan for current instances (locals named &quot;this&quot;)
<span class="nc" id="L448">        LocalMember lp = locals;</span>

        // thise is a link expression being built up
<span class="nc" id="L451">        Expression thise = null;</span>

        // root is the local variable (idThis) at the far left of thise
<span class="nc" id="L454">        LocalMember root = null;</span>

        // thisc is the class of the link expression thise
<span class="nc" id="L457">        ClassDefinition thisc = null;</span>

        // conCls is the class of the &quot;this&quot;, in a constructor
<span class="nc" id="L460">        ClassDefinition conCls = null;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (field.isConstructor()) {</span>
<span class="nc" id="L462">            conCls = field.getClassDefinition();</span>
        }

<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (!field.isMethod()) {</span>
<span class="nc" id="L466">            thisc = field.getClassDefinition();</span>
<span class="nc" id="L467">            thise = new ThisExpression(where, this);</span>
        }

        while (true) {
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (thise == null) {</span>
                // start fresh from lp
<span class="nc bnc" id="L473" title="All 4 branches missed.">                while (lp != null &amp;&amp; !idThis.equals(lp.getName())) {</span>
<span class="nc" id="L474">                    lp = lp.prev;</span>
                }
<span class="nc bnc" id="L476" title="All 2 branches missed.">                if (lp == null) {</span>
<span class="nc" id="L477">                    break;</span>
                }
<span class="nc" id="L479">                thise = new ThisExpression(where, lp);</span>
<span class="nc" id="L480">                thisc = lp.getClassDefinition();</span>
<span class="nc" id="L481">                root = lp;</span>
<span class="nc" id="L482">                lp = lp.prev;</span>
            }

            // Require exact class identity when called with
            // 'needExactMatch' true.  This is done when checking
            // the '&lt;class&gt;.this' syntax.  Fixes 4102393 and 4133457.
<span class="nc bnc" id="L488" title="All 4 branches missed.">            if (thisc == reqc ||</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">                (!needExactMatch &amp;&amp; match(env, thisc, reqc))) {</span>
<span class="nc" id="L490">                break;</span>
            }

            // move out one step, if the current instance has an outer link

<span class="nc" id="L495">            MemberDefinition outerMember = thisc.findOuterMember();</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            if (outerMember == null) {</span>
<span class="nc" id="L497">                thise = null;</span>
<span class="nc" id="L498">                continue;       // try to find more help in lp</span>
            }
<span class="nc" id="L500">            ClassDefinition prevc = thisc;</span>
<span class="nc" id="L501">            thisc = prevc.getOuterClass();</span>

<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (prevc == conCls) {</span>
                // Must pick up &quot;this$C&quot; from the constructor argument,
                // not from &quot;this.this$C&quot;, since the latter may not be
                // initialized properly.  (This way is cheaper too.)
<span class="nc" id="L507">                Identifier nm = outerMember.getName();</span>
<span class="nc" id="L508">                IdentifierExpression arg = new IdentifierExpression(where, nm);</span>
<span class="nc" id="L509">                arg.bind(env, this);</span>
<span class="nc" id="L510">                thise = arg;</span>
<span class="nc" id="L511">            } else {</span>
<span class="nc" id="L512">                thise = new FieldExpression(where, thise, outerMember);</span>
            }
<span class="nc" id="L514">        }</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (thise != null) {</span>
            // mark crossed scopes
            // ?????
            //ensureAvailable(root);
<span class="nc" id="L519">            return thise;</span>
        }

<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (f == null) {</span>
            // say something like: undefined variable A.this
<span class="nc" id="L524">            Identifier nm = reqc.getName().getFlatName().getName();</span>
<span class="nc" id="L525">            env.error(where, &quot;undef.var&quot;, Identifier.lookup(nm,idThis));</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">        } else if (f.isConstructor()) {</span>
<span class="nc" id="L527">            env.error(where, &quot;no.outer.arg&quot;, reqc, f.getClassDefinition());</span>
        } else {
<span class="nc" id="L529">            env.error(where, &quot;no.static.field.access&quot;, f, field);</span>
        }

        // avoid floodgating:
<span class="nc" id="L533">        Expression e = new ThisExpression(where, this);</span>
<span class="nc" id="L534">        e.type = reqc.getType();</span>
<span class="nc" id="L535">        return e;</span>
    }

    /**
     * Is there a &quot;this&quot; of type reqc in scope?
     */
    public static boolean outerLinkExists(Environment env,
                                          ClassDefinition reqc,
                                          ClassDefinition thisc) {
<span class="nc bnc" id="L544" title="All 2 branches missed.">        while (!match(env, thisc, reqc)) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">            if (thisc.isTopLevel()) {</span>
<span class="nc" id="L546">                return false;</span>
            }
<span class="nc" id="L548">            thisc = thisc.getOuterClass();</span>
        }
<span class="nc" id="L550">        return true;</span>
    }

    /**
     * From which enclosing class do members of this type come?
     */
    public ClassDefinition findScope(Environment env, ClassDefinition reqc) {
<span class="nc" id="L557">        ClassDefinition thisc = field.getClassDefinition();</span>
<span class="nc bnc" id="L558" title="All 4 branches missed.">        while (thisc != null &amp;&amp; !match(env, thisc, reqc)) {</span>
<span class="nc" id="L559">            thisc = thisc.getOuterClass();</span>
        }
<span class="nc" id="L561">        return thisc;</span>
    }

    /**
     * Resolve a type name from within a local scope.
     * @see Environment#resolveName
     */
    Identifier resolveName(Environment env, Identifier name) {
        // This logic is pretty much exactly parallel to that of
        // Environment.resolveName().
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (name.isQualified()) {</span>
            // Try to resolve the first identifier component,
            // because inner class names take precedence over
            // package prefixes.  (Cf. Environment.resolveName.)
<span class="nc" id="L575">            Identifier rhead = resolveName(env, name.getHead());</span>

<span class="nc bnc" id="L577" title="All 2 branches missed.">            if (rhead.hasAmbigPrefix()) {</span>
                // The first identifier component refers to an
                // ambiguous class.  Limp on.  We throw away the
                // rest of the classname as it is irrelevant.
                // (part of solution for 4059855).
<span class="nc" id="L582">                return rhead;</span>
            }

<span class="nc bnc" id="L585" title="All 2 branches missed.">            if (!env.classExists(rhead)) {</span>
<span class="nc" id="L586">                return env.resolvePackageQualifiedName(name);</span>
            }
            try {
<span class="nc" id="L589">                return env.getClassDefinition(rhead).</span>
<span class="nc" id="L590">                    resolveInnerClass(env, name.getTail());</span>
<span class="nc" id="L591">            } catch (ClassNotFound ee) {</span>
                // return partially-resolved name someone else can fail on
<span class="nc" id="L593">                return Identifier.lookupInner(rhead, name.getTail());</span>
            }
        }

        // Look for an unqualified name in enclosing scopes.
        try {
<span class="nc" id="L599">            MemberDefinition f = getClassCommon(env, name, false);</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">            if (f != null) {</span>
<span class="nc" id="L601">                return f.getInnerClass().getName();</span>
            }
<span class="nc" id="L603">        } catch (ClassNotFound ee) {</span>
            // a missing superclass, or something catastrophic
<span class="nc" id="L605">        }</span>

        // look in imports, etc.
<span class="nc" id="L608">        return env.resolveName(name);</span>
    }

    /**
     * Return the name of a lexically apparent type,
     * skipping inherited members, and ignoring
     * the current pacakge and imports.
     * This is used for error checking.
     */
    public
    Identifier getApparentClassName(Environment env, Identifier name) {
<span class="nc bnc" id="L619" title="All 2 branches missed.">        if (name.isQualified()) {</span>
            // Try to resolve the first identifier component,
            // because inner class names take precedence over
            // package prefixes.  (Cf. Environment.resolveName.)
<span class="nc" id="L623">            Identifier rhead = getApparentClassName(env, name.getHead());</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">            return (rhead == null) ? idNull</span>
<span class="nc" id="L625">                : Identifier.lookup(rhead,</span>
<span class="nc" id="L626">                                    name.getTail());</span>
        }

        // Look for an unqualified name in enclosing scopes.
        try {
<span class="nc" id="L631">            MemberDefinition f = getClassCommon(env, name, true);</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (f != null) {</span>
<span class="nc" id="L633">                return f.getInnerClass().getName();</span>
            }
<span class="nc" id="L635">        } catch (ClassNotFound ee) {</span>
            // a missing superclass, or something catastrophic
<span class="nc" id="L637">        }</span>

        // the enclosing class name is the only apparent package member:
<span class="nc" id="L640">        Identifier topnm = field.getClassDefinition().getTopClass().getName();</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">        if (topnm.getName().equals(name)) {</span>
<span class="nc" id="L642">            return topnm;</span>
        }
<span class="nc" id="L644">        return idNull;</span>
    }

    /**
     * Raise an error if a blank final was definitely unassigned
     * on entry to a loop, but has possibly been assigned on the
     * back-branch.  If this is the case, the loop may be assigning
     * it multiple times.
     */
    public void checkBackBranch(Environment env, Statement loop,
                                Vset vsEntry, Vset vsBack) {
<span class="nc bnc" id="L655" title="All 2 branches missed.">        for (LocalMember f = locals ; f != null ; f = f.prev) {</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">            if (f.isBlankFinal()</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">                &amp;&amp; vsEntry.testVarUnassigned(f.number)</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">                &amp;&amp; !vsBack.testVarUnassigned(f.number)) {</span>
<span class="nc" id="L659">                env.error(loop.where, &quot;assign.to.blank.final.in.loop&quot;,</span>
<span class="nc" id="L660">                          f.getName());</span>
            }
        }
<span class="nc" id="L663">    }</span>

    /**
     * Check if a field can reach another field (only considers
     * forward references, not the access modifiers).
     */
    public boolean canReach(Environment env, MemberDefinition f) {
<span class="nc" id="L670">        return field.canReach(env, f);</span>
    }

    /**
     * Get the context that corresponds to a label, return null if
     * not found.
     */
    public
    Context getLabelContext(Identifier lbl) {
<span class="nc bnc" id="L679" title="All 2 branches missed.">        for (Context ctx = this ; ctx != null ; ctx = ctx.prev) {</span>
<span class="nc bnc" id="L680" title="All 4 branches missed.">            if ((ctx.node != null) &amp;&amp; (ctx.node instanceof Statement)) {</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">                if (((Statement)(ctx.node)).hasLabel(lbl))</span>
<span class="nc" id="L682">                    return ctx;</span>
            }
        }
<span class="nc" id="L685">        return null;</span>
    }

    /**
     * Get the destination context of a break
     */
    public
    Context getBreakContext(Identifier lbl) {
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (lbl != null) {</span>
<span class="nc" id="L694">            return getLabelContext(lbl);</span>
        }
<span class="nc bnc" id="L696" title="All 2 branches missed.">        for (Context ctx = this ; ctx != null ; ctx = ctx.prev) {</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">            if (ctx.node != null) {</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">                switch (ctx.node.op) {</span>
                  case SWITCH:
                  case FOR:
                  case DO:
                  case WHILE:
<span class="nc" id="L703">                    return ctx;</span>
                }
            }
        }
<span class="nc" id="L707">        return null;</span>
    }

    /**
     * Get the destination context of a continue
     */
    public
    Context getContinueContext(Identifier lbl) {
<span class="nc bnc" id="L715" title="All 2 branches missed.">        if (lbl != null) {</span>
<span class="nc" id="L716">            return getLabelContext(lbl);</span>
        }
<span class="nc bnc" id="L718" title="All 2 branches missed.">        for (Context ctx = this ; ctx != null ; ctx = ctx.prev) {</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">            if (ctx.node != null) {</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">                switch (ctx.node.op) {</span>
                  case FOR:
                  case DO:
                  case WHILE:
<span class="nc" id="L724">                    return ctx;</span>
                }
            }
        }
<span class="nc" id="L728">        return null;</span>
    }

    /**
     * Get the destination context of a return (the method body)
     */
    public
    CheckContext getReturnContext() {
<span class="nc bnc" id="L736" title="All 2 branches missed.">        for (Context ctx = this ; ctx != null ; ctx = ctx.prev) {</span>
            // The METHOD node is set up by Statement.checkMethod().
<span class="nc bnc" id="L738" title="All 4 branches missed.">            if (ctx.node != null &amp;&amp; ctx.node.op == METHOD) {</span>
<span class="nc" id="L739">                return (CheckContext)ctx;</span>
            }
        }
<span class="nc" id="L742">        return null;</span>
    }

    /**
     * Get the context of the innermost surrounding try-block.
     * Consider only try-blocks contained within the same method.
     * (There could be others when searching from within a method
     * of a local class, but they are irrelevant to our purpose.)
     * This is used for recording DA/DU information preceding
     * all abnormal transfers of control: break, continue, return,
     * and throw.
     */
    public
    CheckContext getTryExitContext() {
<span class="nc" id="L756">        for (Context ctx = this;</span>
<span class="nc bnc" id="L757" title="All 6 branches missed.">             ctx != null &amp;&amp; ctx.node != null &amp;&amp; ctx.node.op != METHOD;</span>
<span class="nc" id="L758">             ctx = ctx.prev) {</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">            if (ctx.node.op == TRY) {</span>
<span class="nc" id="L760">                return (CheckContext)ctx;</span>
            }
        }
<span class="nc" id="L763">        return null;</span>
    }

    /**
     * Get the nearest inlined context
     */
    Context getInlineContext() {
<span class="nc bnc" id="L770" title="All 2 branches missed.">        for (Context ctx = this ; ctx != null ; ctx = ctx.prev) {</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">            if (ctx.node != null) {</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">                switch (ctx.node.op) {</span>
                  case INLINEMETHOD:
                  case INLINENEWINSTANCE:
<span class="nc" id="L775">                    return ctx;</span>
                }
            }
        }
<span class="nc" id="L779">        return null;</span>
    }

    /**
     * Get the context of a field that is being inlined
     */
    Context getInlineMemberContext(MemberDefinition field) {
<span class="nc bnc" id="L786" title="All 2 branches missed.">        for (Context ctx = this ; ctx != null ; ctx = ctx.prev) {</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (ctx.node != null) {</span>
<span class="nc bnc" id="L788" title="All 3 branches missed.">                switch (ctx.node.op) {</span>
                  case INLINEMETHOD:
<span class="nc bnc" id="L790" title="All 2 branches missed.">                    if (((InlineMethodExpression)ctx.node).field.equals(field)) {</span>
<span class="nc" id="L791">                        return ctx;</span>
                    }
                    break;
                  case INLINENEWINSTANCE:
<span class="nc bnc" id="L795" title="All 2 branches missed.">                    if (((InlineNewInstanceExpression)ctx.node).field.equals(field)) {</span>
<span class="nc" id="L796">                        return ctx;</span>
                    }
                }
            }
        }
<span class="nc" id="L801">        return null;</span>
    }

    /**
     * Remove variables from the vset set  that are no longer part of
     * this context.
     */
    public final Vset removeAdditionalVars(Vset vset) {
<span class="nc" id="L809">        return vset.removeAdditionalVars(varNumber);</span>
    }

    public final int getVarNumber() {
<span class="nc" id="L813">        return varNumber;</span>
    }

    /**
     * Return the number of the innermost current instance reference.
     */
    public int getThisNumber() {
<span class="nc" id="L820">        LocalMember thisf = getLocalField(idThis);</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">        if (thisf != null</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">            &amp;&amp; thisf.getClassDefinition() == field.getClassDefinition()) {</span>
<span class="nc" id="L823">            return thisf.number;</span>
        }
        // this is a variable; there is no &quot;this&quot; (should not happen)
<span class="nc" id="L826">        return varNumber;</span>
    }

    /**
     * Return the field containing the present context.
     */
    public final MemberDefinition getField() {
<span class="nc" id="L833">        return field;</span>
    }

    /**
     * Extend an environment with the given context.
     * The resulting environment behaves the same as
     * the given one, except that resolveName() takes
     * into account local class names in this context.
     */
    public static Environment newEnvironment(Environment env, Context ctx) {
<span class="nc" id="L843">        return new ContextEnvironment(env, ctx);</span>
    }
}

final
class ContextEnvironment extends Environment {
    Context ctx;
    Environment innerEnv;

    ContextEnvironment(Environment env, Context ctx) {
<span class="nc" id="L853">        super(env, env.getSource());</span>
<span class="nc" id="L854">        this.ctx = ctx;</span>
<span class="nc" id="L855">        this.innerEnv = env;</span>
<span class="nc" id="L856">    }</span>

    public Identifier resolveName(Identifier name) {
<span class="nc" id="L859">        return ctx.resolveName(innerEnv, name);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>