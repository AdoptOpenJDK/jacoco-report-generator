<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NewInstanceExpression.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.tree</a> &gt; <span class="el_source">NewInstanceExpression.java</span></div><h1>NewInstanceExpression.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.tree;

import sun.tools.java.*;
import sun.tools.asm.Assembler;
import java.util.Hashtable;

/**
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public
class NewInstanceExpression extends NaryExpression {
    MemberDefinition field;
    Expression outerArg;
    ClassDefinition body;

    // Access method for constructor, if needed.
<span class="nc" id="L44">    MemberDefinition implMethod = null;</span>

    /**
     * Constructor
     */
    public NewInstanceExpression(long where, Expression right, Expression args[]) {
<span class="nc" id="L50">        super(NEWINSTANCE, where, Type.tError, right, args);</span>
<span class="nc" id="L51">    }</span>
    public NewInstanceExpression(long where, Expression right,
                                 Expression args[],
                                 Expression outerArg, ClassDefinition body) {
<span class="nc" id="L55">        this(where, right, args);</span>
<span class="nc" id="L56">        this.outerArg = outerArg;</span>
<span class="nc" id="L57">        this.body = body;</span>
<span class="nc" id="L58">    }</span>

    /**
     * From the &quot;new&quot; in an expression of the form outer.new InnerCls(...),
     * return the &quot;outer&quot; expression, or null if there is none.
     */
    public Expression getOuterArg() {
<span class="nc" id="L65">        return outerArg;</span>
    }

    int precedence() {
<span class="nc" id="L69">        return 100;</span>
    }

    public Expression order() {
        // act like a method or field reference expression:
<span class="nc bnc" id="L74" title="All 4 branches missed.">        if (outerArg != null &amp;&amp; opPrecedence[FIELD] &gt; outerArg.precedence()) {</span>
<span class="nc" id="L75">            UnaryExpression e = (UnaryExpression)outerArg;</span>
<span class="nc" id="L76">            outerArg = e.right;</span>
<span class="nc" id="L77">            e.right = order();</span>
<span class="nc" id="L78">            return e;</span>
        }
<span class="nc" id="L80">        return this;</span>
    }

    /**
     * Check expression type
     */
    public Vset checkValue(Environment env, Context ctx, Vset vset, Hashtable exp) {
        // What type?
<span class="nc" id="L88">        ClassDefinition def = null;</span>

<span class="nc" id="L90">        Expression alreadyChecked = null;</span>

        try {
<span class="nc bnc" id="L93" title="All 2 branches missed.">            if (outerArg != null) {</span>
<span class="nc" id="L94">                vset = outerArg.checkValue(env, ctx, vset, exp);</span>

                // Remember the expression that we already checked
                // so that we don't attempt to check it again when
                // it appears as an argument to the constructor.
                // Fix for 4030426.
<span class="nc" id="L100">                alreadyChecked = outerArg;</span>

                // Check outerArg and the type name together.
<span class="nc" id="L103">                Identifier typeName = FieldExpression.toIdentifier(right);</span>

                // According to the inner classes spec, the type name in a
                // qualified 'new' expression must be a single identifier.
<span class="nc bnc" id="L107" title="All 4 branches missed.">                if (typeName != null &amp;&amp; typeName.isQualified()) {</span>
<span class="nc" id="L108">                    env.error(where, &quot;unqualified.name.required&quot;, typeName);</span>
                }

<span class="nc bnc" id="L111" title="All 4 branches missed.">                if (typeName == null || !outerArg.type.isType(TC_CLASS)) {</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">                    if (!outerArg.type.isType(TC_ERROR)) {</span>
<span class="nc" id="L113">                        env.error(where, &quot;invalid.field.reference&quot;,</span>
                                  idNew, outerArg.type);
                    }
<span class="nc" id="L116">                    outerArg = null;</span>
                } else {
                    // Don't perform checks on components of qualified name
                    // ('getQualifiedClassDefinition'), because a qualified
                    // name is illegal in this context, and will have previously
                    // been reported as an error.
<span class="nc" id="L122">                    ClassDefinition oc = env.getClassDefinition(outerArg.type);</span>
<span class="nc" id="L123">                    Identifier nm = oc.resolveInnerClass(env, typeName);</span>
<span class="nc" id="L124">                    right = new TypeExpression(right.where, Type.tClass(nm));</span>
                    // Check access directly, since we're not calling toType().
<span class="nc" id="L126">                    env.resolve(right.where, ctx.field.getClassDefinition(),</span>
                                right.type);
                    // and fall through to env.getClassDefinition() below
                }
            }

<span class="nc bnc" id="L132" title="All 2 branches missed.">            if (!(right instanceof TypeExpression)) {</span>
                // The call to 'toType' should perform component access checks.
<span class="nc" id="L134">                right = new TypeExpression(right.where, right.toType(env, ctx));</span>
            }

<span class="nc bnc" id="L137" title="All 2 branches missed.">            if (right.type.isType(TC_CLASS))</span>
<span class="nc" id="L138">                def = env.getClassDefinition(right.type);</span>
<span class="nc" id="L139">        } catch (AmbiguousClass ee) {</span>
<span class="nc" id="L140">            env.error(where, &quot;ambig.class&quot;, ee.name1, ee.name2);</span>
<span class="nc" id="L141">        } catch (ClassNotFound ee) {</span>
<span class="nc" id="L142">            env.error(where, &quot;class.not.found&quot;, ee.name, ctx.field);</span>
<span class="nc" id="L143">        }</span>

<span class="nc" id="L145">        Type t = right.type;</span>
<span class="nc" id="L146">        boolean hasErrors = t.isType(TC_ERROR);</span>

<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (!t.isType(TC_CLASS)) {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            if (!hasErrors) {</span>
<span class="nc" id="L150">                env.error(where, &quot;invalid.arg.type&quot;, t, opNames[op]);</span>
<span class="nc" id="L151">                hasErrors = true;</span>
            }
        }

        // If we failed to find a class or a class was ambiguous, def
        // may be null.  Bail out.  This allows us to report multiple
        // unfound or ambiguous classes rather than tripping over an
        // internal compiler error.
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (def == null) {</span>
<span class="nc" id="L160">            type = Type.tError;</span>
<span class="nc" id="L161">            return vset;</span>
        }

        // Add an extra argument, maybe.
<span class="nc" id="L165">        Expression args[] = this.args;</span>
<span class="nc" id="L166">        args = NewInstanceExpression.</span>
<span class="nc" id="L167">                insertOuterLink(env, ctx, where, def, outerArg, args);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (args.length &gt; this.args.length)</span>
<span class="nc" id="L169">            outerArg = args[0]; // recopy the checked arg</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        else if (outerArg != null)</span>
            // else set it to void (maybe it has a side-effect)
<span class="nc" id="L172">            outerArg = new CommaExpression(outerArg.where, outerArg, null);</span>

        // Compose a list of argument types
<span class="nc" id="L175">        Type argTypes[] = new Type[args.length];</span>

<span class="nc bnc" id="L177" title="All 2 branches missed.">        for (int i = 0 ; i &lt; args.length ; i++) {</span>
            // Don't check 'outerArg' again. Fix for 4030426.
<span class="nc bnc" id="L179" title="All 2 branches missed.">            if (args[i] != alreadyChecked) {</span>
<span class="nc" id="L180">                vset = args[i].checkValue(env, ctx, vset, exp);</span>
            }
<span class="nc" id="L182">            argTypes[i] = args[i].type;</span>
<span class="nc bnc" id="L183" title="All 4 branches missed.">            hasErrors = hasErrors || argTypes[i].isType(TC_ERROR);</span>
        }

        try {
            // Check if there are any type errors in the arguments
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (hasErrors) {</span>
<span class="nc" id="L189">                type = Type.tError;</span>
<span class="nc" id="L190">                return vset;</span>
            }


            // Get the source class that this declaration appears in.
<span class="nc" id="L195">            ClassDefinition sourceClass = ctx.field.getClassDefinition();</span>

<span class="nc" id="L197">            ClassDeclaration c = env.getClassDeclaration(t);</span>

            // If this is an anonymous class, handle it specially now.
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (body != null) {</span>
                // The current package.
<span class="nc" id="L202">                Identifier packageName = sourceClass.getName().getQualifier();</span>

                // This is an anonymous class.
<span class="nc" id="L205">                ClassDefinition superDef = null;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">                if (def.isInterface()) {</span>
                    // For interfaces, our superclass is java.lang.Object.
                    // We could just assume that java.lang.Object has
                    // one constructor with no arguments in the code
                    // that follows, but we don't.  This way, if Object
                    // grows a new constructor (unlikely) then the
                    // compiler should handle it.
<span class="nc" id="L213">                    superDef = env.getClassDefinition(idJavaLangObject);</span>
                } else {
                    // Otherwise, def is actually our superclass.
<span class="nc" id="L216">                    superDef = def;</span>
                }
                // Try to find a matching constructor in our superclass.
<span class="nc" id="L219">                MemberDefinition constructor =</span>
<span class="nc" id="L220">                    superDef.matchAnonConstructor(env, packageName, argTypes);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">                if (constructor != null) {</span>
                    // We've found one.  Process the body.
                    //
                    // Note that we are passing in the constructors' argument
                    // types, rather than the argument types of the actual
                    // expressions, to checkLocalClass().  Previously,
                    // the expression types were passed in.  This could
                    // lead to trouble when one of the argument types was
                    // the special internal type tNull.  (bug 4054689).
                    if (tracing)
<span class="nc" id="L231">                        env.dtEvent(</span>
                              &quot;NewInstanceExpression.checkValue: ANON CLASS &quot; +
                              body + &quot; SUPER &quot; + def);
<span class="nc" id="L234">                    vset = body.checkLocalClass(env, ctx, vset,</span>
                                                def, args,
<span class="nc" id="L236">                                                constructor.getType()</span>
<span class="nc" id="L237">                                                .getArgumentTypes());</span>

                    // Set t to be the true type of this expression.
                    // (bug 4102056).
<span class="nc" id="L241">                    t = body.getClassDeclaration().getType();</span>

<span class="nc" id="L243">                    def = body;</span>
                }
<span class="nc" id="L245">            } else {</span>
                // Check if it is an interface
<span class="nc bnc" id="L247" title="All 2 branches missed.">                if (def.isInterface()) {</span>
<span class="nc" id="L248">                    env.error(where, &quot;new.intf&quot;, c);</span>
<span class="nc" id="L249">                    return vset;</span>
                }

                // Check for abstract class
<span class="nc bnc" id="L253" title="All 2 branches missed.">                if (def.mustBeAbstract(env)) {</span>
<span class="nc" id="L254">                    env.error(where, &quot;new.abstract&quot;, c);</span>
<span class="nc" id="L255">                    return vset;</span>
                }
            }

            // Get the constructor that the &quot;new&quot; expression should call.
<span class="nc" id="L260">            field = def.matchMethod(env, sourceClass, idInit, argTypes);</span>

            // Report an error if there is no matching constructor.
<span class="nc bnc" id="L263" title="All 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L264">                MemberDefinition anyInit = def.findAnyMethod(env, idInit);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">                if (anyInit != null &amp;&amp;</span>
                    new MethodExpression(where, right, anyInit, args)
<span class="nc bnc" id="L267" title="All 2 branches missed.">                        .diagnoseMismatch(env, args, argTypes))</span>
<span class="nc" id="L268">                    return vset;</span>
<span class="nc" id="L269">                String sig = c.getName().getName().toString();</span>
<span class="nc" id="L270">                sig = Type.tMethod(Type.tError, argTypes).typeString(sig, false, false);</span>
<span class="nc" id="L271">                env.error(where, &quot;unmatched.constr&quot;, sig, c);</span>
<span class="nc" id="L272">                return vset;</span>
            }

<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (field.isPrivate()) {</span>
<span class="nc" id="L276">                ClassDefinition cdef = field.getClassDefinition();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">                if (cdef != sourceClass) {</span>
                    // Use access method.
<span class="nc" id="L279">                    implMethod = cdef.getAccessMember(env, ctx, field, false);</span>
                }
            }

            // Check for abstract anonymous class
<span class="nc bnc" id="L284" title="All 2 branches missed.">            if (def.mustBeAbstract(env)) {</span>
<span class="nc" id="L285">                env.error(where, &quot;new.abstract&quot;, c);</span>
<span class="nc" id="L286">                return vset;</span>
            }

<span class="nc bnc" id="L289" title="All 2 branches missed.">            if (field.reportDeprecated(env)) {</span>
<span class="nc" id="L290">                env.error(where, &quot;warn.constr.is.deprecated&quot;,</span>
<span class="nc" id="L291">                          field, field.getClassDefinition());</span>
            }

            // According to JLS 6.6.2, a protected constructor may be accessed
            // by a class instance creation expression only from within the
            // package in which it is defined.
<span class="nc bnc" id="L297" title="All 2 branches missed.">            if (field.isProtected() &amp;&amp;</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                !(sourceClass.getName().getQualifier().equals(</span>
<span class="nc" id="L299">                   field.getClassDeclaration().getName().getQualifier()))) {</span>
<span class="nc" id="L300">                env.error(where, &quot;invalid.protected.constructor.use&quot;,</span>
                          sourceClass);
            }

<span class="nc" id="L304">        } catch (ClassNotFound ee) {</span>
<span class="nc" id="L305">            env.error(where, &quot;class.not.found&quot;, ee.name, opNames[op]);</span>
<span class="nc" id="L306">            return vset;</span>

<span class="nc" id="L308">        } catch (AmbiguousMember ee) {</span>
<span class="nc" id="L309">            env.error(where, &quot;ambig.constr&quot;, ee.field1, ee.field2);</span>
<span class="nc" id="L310">            return vset;</span>
<span class="nc" id="L311">        }</span>

        // Cast arguments
<span class="nc" id="L314">        argTypes = field.getType().getArgumentTypes();</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">        for (int i = 0 ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L316">            args[i] = convert(env, ctx, argTypes[i], args[i]);</span>
        }
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (args.length &gt; this.args.length) {</span>
<span class="nc" id="L319">            outerArg = args[0]; // recopy the checked arg</span>
            // maintain an accurate tree
<span class="nc bnc" id="L321" title="All 2 branches missed.">            for (int i = 1 ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L322">                this.args[i-1] = args[i];</span>
            }
        }

        // Throw the declared exceptions.
<span class="nc" id="L327">        ClassDeclaration exceptions[] = field.getExceptions(env);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        for (int i = 0 ; i &lt; exceptions.length ; i++) {</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            if (exp.get(exceptions[i]) == null) {</span>
<span class="nc" id="L330">                exp.put(exceptions[i], this);</span>
            }
        }

<span class="nc" id="L334">        type = t;</span>

<span class="nc" id="L336">        return vset;</span>
    }

    /**
     * Given a list of arguments for a constructor,
     * return a possibly modified list which includes the hidden
     * argument which initializes the uplevel self pointer.
     * @arg def the class which perhaps contains an outer link.
     * @arg outerArg if non-null, an explicit location in which to construct.
     */
    public static Expression[] insertOuterLink(Environment env, Context ctx,
                                               long where, ClassDefinition def,
                                               Expression outerArg,
                                               Expression args[]) {
<span class="nc bnc" id="L350" title="All 4 branches missed.">        if (!def.isTopLevel() &amp;&amp; !def.isLocal()) {</span>
<span class="nc" id="L351">            Expression args2[] = new Expression[1+args.length];</span>
<span class="nc" id="L352">            System.arraycopy(args, 0, args2, 1, args.length);</span>
            try {
<span class="nc bnc" id="L354" title="All 2 branches missed.">                if (outerArg == null)</span>
<span class="nc" id="L355">                    outerArg = ctx.findOuterLink(env, where,</span>
<span class="nc" id="L356">                                                 def.findAnyMethod(env, idInit));</span>
<span class="nc" id="L357">            } catch (ClassNotFound e) {</span>
                // die somewhere else
<span class="nc" id="L359">            }</span>
<span class="nc" id="L360">            args2[0] = outerArg;</span>
<span class="nc" id="L361">            args = args2;</span>
        }
<span class="nc" id="L363">        return args;</span>
    }

    /**
     * Check void expression
     */
    public Vset check(Environment env, Context ctx, Vset vset, Hashtable exp) {
<span class="nc" id="L370">        return checkValue(env, ctx, vset, exp);</span>
    }

    /**
     * Inline
     */
<span class="nc" id="L376">    final int MAXINLINECOST = Statement.MAXINLINECOST;</span>

    public Expression copyInline(Context ctx) {
<span class="nc" id="L379">        NewInstanceExpression e = (NewInstanceExpression)super.copyInline(ctx);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (outerArg != null) {</span>
<span class="nc" id="L381">            e.outerArg = outerArg.copyInline(ctx);</span>
        }
<span class="nc" id="L383">        return e;</span>
    }

    Expression inlineNewInstance(Environment env, Context ctx, Statement s) {
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (env.dump()) {</span>
<span class="nc" id="L388">            System.out.println(&quot;INLINE NEW INSTANCE &quot; + field + &quot; in &quot; + ctx.field);</span>
        }
<span class="nc" id="L390">        LocalMember v[] = LocalMember.copyArguments(ctx, field);</span>
<span class="nc" id="L391">        Statement body[] = new Statement[v.length + 2];</span>

<span class="nc" id="L393">        int o = 1;</span>
<span class="nc bnc" id="L394" title="All 4 branches missed.">        if (outerArg != null &amp;&amp; !outerArg.type.isType(TC_VOID)) {</span>
<span class="nc" id="L395">            o = 2;</span>
<span class="nc" id="L396">            body[1] = new VarDeclarationStatement(where, v[1], outerArg);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        } else if (outerArg != null) {</span>
<span class="nc" id="L398">            body[0] = new ExpressionStatement(where, outerArg);</span>
        }
<span class="nc bnc" id="L400" title="All 2 branches missed.">        for (int i = 0 ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L401">            body[i+o] = new VarDeclarationStatement(where, v[i+o], args[i]);</span>
        }
        //System.out.print(&quot;BEFORE:&quot;); s.print(System.out); System.out.println();
<span class="nc bnc" id="L404" title="All 2 branches missed.">        body[body.length - 1] = (s != null) ? s.copyInline(ctx, false) : null;</span>
        //System.out.print(&quot;COPY:&quot;); body[body.length - 1].print(System.out); System.out.println();
        //System.out.print(&quot;AFTER:&quot;); s.print(System.out); System.out.println();
<span class="nc" id="L407">        LocalMember.doneWithArguments(ctx, v);</span>

<span class="nc" id="L409">        return new InlineNewInstanceExpression(where, type, field, new CompoundStatement(where, body)).inline(env, ctx);</span>
    }

    public Expression inline(Environment env, Context ctx) {
<span class="nc" id="L413">        return inlineValue(env, ctx);</span>
    }
    public Expression inlineValue(Environment env, Context ctx) {
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (body != null) {</span>
<span class="nc" id="L417">            body.inlineLocalClass(env);</span>
        }
<span class="nc" id="L419">        ClassDefinition refc = field.getClassDefinition();</span>
<span class="nc" id="L420">        UplevelReference r = refc.getReferencesFrozen();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (r != null) {</span>
<span class="nc" id="L422">            r.willCodeArguments(env, ctx);</span>
        }
        //right = right.inlineValue(env, ctx);

        try {
<span class="nc bnc" id="L427" title="All 2 branches missed.">            if (outerArg != null) {</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                if (outerArg.type.isType(TC_VOID))</span>
<span class="nc" id="L429">                    outerArg = outerArg.inline(env, ctx);</span>
                else
<span class="nc" id="L431">                    outerArg = outerArg.inlineValue(env, ctx);</span>
            }
<span class="nc bnc" id="L433" title="All 2 branches missed.">            for (int i = 0 ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L434">                args[i] = args[i].inlineValue(env, ctx);</span>
            }
            // This 'false' that fy put in is inexplicable to me
            // the decision to not inline new instance expressions
            // should be revisited.  - dps
            if (false &amp;&amp; env.opt() &amp;&amp; field.isInlineable(env, false) &amp;&amp;
                (!ctx.field.isInitializer()) &amp;&amp; ctx.field.isMethod() &amp;&amp;
                (ctx.getInlineMemberContext(field) == null)) {
                Statement s = (Statement)field.getValue(env);
                if ((s == null)
                    || (s.costInline(MAXINLINECOST, env, ctx) &lt; MAXINLINECOST))  {
                    return inlineNewInstance(env, ctx, s);
                }
            }
<span class="nc" id="L448">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L449">            throw new CompilerError(e);</span>
<span class="nc" id="L450">        }</span>
<span class="nc bnc" id="L451" title="All 4 branches missed.">        if (outerArg != null &amp;&amp; outerArg.type.isType(TC_VOID)) {</span>
<span class="nc" id="L452">            Expression e = outerArg;</span>
<span class="nc" id="L453">            outerArg = null;</span>
<span class="nc" id="L454">            return new CommaExpression(where, e, this);</span>
        }
<span class="nc" id="L456">        return this;</span>
    }

    public int costInline(int thresh, Environment env, Context ctx) {
<span class="nc bnc" id="L460" title="All 2 branches missed.">        if (body != null) {</span>
<span class="nc" id="L461">            return thresh;      // don't copy classes...</span>
        }
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (ctx == null) {</span>
<span class="nc" id="L464">            return 2 + super.costInline(thresh, env, ctx);</span>
        }
        // sourceClass is the current class trying to inline this method
<span class="nc" id="L467">        ClassDefinition sourceClass = ctx.field.getClassDefinition();</span>
        try {
            // We only allow the inlining if the current class can access
            // the field and the field's class;
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (    sourceClass.permitInlinedAccess(env, field.getClassDeclaration())</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                 &amp;&amp; sourceClass.permitInlinedAccess(env, field)) {</span>
<span class="nc" id="L473">                return 2 + super.costInline(thresh, env, ctx);</span>
            }
<span class="nc" id="L475">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L476">        }</span>
<span class="nc" id="L477">        return thresh;</span>
    }


    /**
     * Code
     */
    public void code(Environment env, Context ctx, Assembler asm) {
<span class="nc" id="L485">        codeCommon(env, ctx, asm, false);</span>
<span class="nc" id="L486">    }</span>
    public void codeValue(Environment env, Context ctx, Assembler asm) {
<span class="nc" id="L488">        codeCommon(env, ctx, asm, true);</span>
<span class="nc" id="L489">    }</span>
    private void codeCommon(Environment env, Context ctx, Assembler asm,
                            boolean forValue) {
<span class="nc" id="L492">        asm.add(where, opc_new, field.getClassDeclaration());</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (forValue) {</span>
<span class="nc" id="L494">            asm.add(where, opc_dup);</span>
        }

<span class="nc" id="L497">        ClassDefinition refc = field.getClassDefinition();</span>
<span class="nc" id="L498">        UplevelReference r = refc.getReferencesFrozen();</span>

<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (r != null) {</span>
<span class="nc" id="L501">            r.codeArguments(env, ctx, asm, where, field);</span>
        }

<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (outerArg != null) {</span>
<span class="nc" id="L505">            outerArg.codeValue(env, ctx, asm);</span>
<span class="nc bnc" id="L506" title="All 3 branches missed.">            switch (outerArg.op) {</span>
            case THIS:
            case SUPER:
            case NEW:
                // guaranteed non-null
<span class="nc" id="L511">                break;</span>
            case FIELD: {
<span class="nc" id="L513">                MemberDefinition f = ((FieldExpression)outerArg).field;</span>
<span class="nc bnc" id="L514" title="All 4 branches missed.">                if (f != null &amp;&amp; f.isNeverNull()) {</span>
<span class="nc" id="L515">                    break;</span>
                }
                // else fall through:
            }
            default:
                // Test for nullity by invoking some trivial operation
                // that can throw a NullPointerException.
                try {
<span class="nc" id="L523">                    ClassDefinition c = env.getClassDefinition(idJavaLangObject);</span>
<span class="nc" id="L524">                    MemberDefinition getc = c.getFirstMatch(idGetClass);</span>
<span class="nc" id="L525">                    asm.add(where, opc_dup);</span>
<span class="nc" id="L526">                    asm.add(where, opc_invokevirtual, getc);</span>
<span class="nc" id="L527">                    asm.add(where, opc_pop);</span>
<span class="nc" id="L528">                } catch (ClassNotFound e) {</span>
<span class="nc" id="L529">                }</span>
            }
        }

<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (implMethod != null) {</span>
            // Constructor call will be via an access method.
            // Pass 'null' as the value of the dummy argument.
<span class="nc" id="L536">            asm.add(where, opc_aconst_null);</span>
        }

<span class="nc bnc" id="L539" title="All 2 branches missed.">        for (int i = 0 ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L540">            args[i].codeValue(env, ctx, asm);</span>
        }
<span class="nc bnc" id="L542" title="All 2 branches missed.">        asm.add(where, opc_invokespecial,</span>
                ((implMethod != null) ? implMethod : field));
<span class="nc" id="L544">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>