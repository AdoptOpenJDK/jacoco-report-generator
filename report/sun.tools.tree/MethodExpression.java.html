<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MethodExpression.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.tree</a> &gt; <span class="el_source">MethodExpression.java</span></div><h1>MethodExpression.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.tree;

import sun.tools.java.*;
import sun.tools.asm.Assembler;
import java.io.PrintStream;
import java.util.Hashtable;

/**
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public
class MethodExpression extends NaryExpression {
    Identifier id;
    ClassDefinition clazz;   // The class in which the called method is defined
    MemberDefinition field;
    Expression implementation;

    private boolean isSuper;  // Set if qualified by 'super' or '&lt;class&gt;.super'.

    /**
     * constructor
     */
    public MethodExpression(long where, Expression right, Identifier id, Expression args[]) {
<span class="nc" id="L51">        super(METHOD, where, Type.tError, right, args);</span>
<span class="nc" id="L52">        this.id = id;</span>
<span class="nc" id="L53">    }</span>
    public MethodExpression(long where, Expression right, MemberDefinition field, Expression args[]) {
<span class="nc" id="L55">        super(METHOD, where, field.getType().getReturnType(), right, args);</span>
<span class="nc" id="L56">        this.id = field.getName();</span>
<span class="nc" id="L57">        this.field = field;</span>
<span class="nc" id="L58">        this.clazz = field.getClassDefinition();</span>
<span class="nc" id="L59">    }</span>

    // This is a hack used only within certain access methods generated by
    // 'SourceClass.getAccessMember'.  It allows an 'invokespecial' instruction
    // to be forced even though 'super' does not appear within the call.
    // Such access methods are needed for access to protected methods when using
    // the qualified '&lt;class&gt;.super.&lt;method&gt;(...)' notation.
    public MethodExpression(long where, Expression right,
                            MemberDefinition field, Expression args[], boolean forceSuper) {
<span class="nc" id="L68">        this(where, right, field, args);</span>
<span class="nc" id="L69">        this.isSuper = forceSuper;</span>
<span class="nc" id="L70">    }</span>

    public Expression getImplementation() {
<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L74">            return implementation;</span>
<span class="nc" id="L75">        return this;</span>
    }

    /**
     * Check expression type
     */
    public Vset checkValue(Environment env, Context ctx, Vset vset, Hashtable exp) {
<span class="nc" id="L82">        ClassDeclaration c = null;</span>
<span class="nc" id="L83">        boolean isArray = false;</span>
<span class="nc" id="L84">        boolean staticRef = false;</span>

        // Access method to use if required.
<span class="nc" id="L87">        MemberDefinition implMethod = null;</span>

<span class="nc" id="L89">        ClassDefinition ctxClass = ctx.field.getClassDefinition();</span>

        // When calling a constructor, we may need to add an
        // additional argument to transmit the outer instance link.
<span class="nc" id="L93">        Expression args[] = this.args;</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">        if (id.equals(idInit)){</span>
<span class="nc" id="L95">            ClassDefinition conCls = ctxClass;</span>
            try {
<span class="nc" id="L97">                Expression conOuter = null;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                if (right instanceof SuperExpression) {</span>
                    // outer.super(...)
<span class="nc" id="L100">                    conCls = conCls.getSuperClass().getClassDefinition(env);</span>
<span class="nc" id="L101">                    conOuter = ((SuperExpression)right).outerArg;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">                } else if (right instanceof ThisExpression) {</span>
                    // outer.this(...)
<span class="nc" id="L104">                    conOuter = ((ThisExpression)right).outerArg;</span>
                }
<span class="nc" id="L106">                args = NewInstanceExpression.</span>
<span class="nc" id="L107">                    insertOuterLink(env, ctx, where, conCls, conOuter, args);</span>
<span class="nc" id="L108">            } catch (ClassNotFound ee) {</span>
                // the same error is handled elsewhere
<span class="nc" id="L110">            }</span>
        }

<span class="nc" id="L113">        Type argTypes[] = new Type[args.length];</span>

        // The effective accessing class, for access checking.
        // This is normally the immediately enclosing class.
<span class="nc" id="L117">        ClassDefinition sourceClass = ctxClass;</span>

        try {
<span class="nc bnc" id="L120" title="All 2 branches missed.">            if (right == null) {</span>
<span class="nc" id="L121">                staticRef = ctx.field.isStatic();</span>
                // Find the first outer scope that mentions the method.
<span class="nc" id="L123">                ClassDefinition cdef = ctxClass;</span>
<span class="nc" id="L124">                MemberDefinition m = null;</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">                for (; cdef != null; cdef = cdef.getOuterClass()) {</span>
<span class="nc" id="L126">                    m = cdef.findAnyMethod(env, id);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                    if (m != null) {</span>
<span class="nc" id="L128">                        break;</span>
                    }
                }
<span class="nc bnc" id="L131" title="All 2 branches missed.">                if (m == null) {</span>
                    // this is the scope for error diagnosis
<span class="nc" id="L133">                    c = ctx.field.getClassDeclaration();</span>
                } else {
                    // found the innermost scope in which m occurs
<span class="nc" id="L136">                    c = cdef.getClassDeclaration();</span>

                    // Maybe an inherited method hides an apparent method.
                    // Keep looking at enclosing scopes to find out.
<span class="nc bnc" id="L140" title="All 2 branches missed.">                    if (m.getClassDefinition() != cdef) {</span>
<span class="nc" id="L141">                        ClassDefinition cdef2 = cdef;</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                        while ((cdef2 = cdef2.getOuterClass()) != null) {</span>
<span class="nc" id="L143">                            MemberDefinition m2 = cdef2.findAnyMethod(env, id);</span>
<span class="nc bnc" id="L144" title="All 4 branches missed.">                            if (m2 != null &amp;&amp; m2.getClassDefinition() == cdef2) {</span>
<span class="nc" id="L145">                                env.error(where, &quot;inherited.hides.method&quot;,</span>
<span class="nc" id="L146">                                          id, cdef.getClassDeclaration(),</span>
<span class="nc" id="L147">                                          cdef2.getClassDeclaration());</span>
<span class="nc" id="L148">                                break;</span>
                            }
<span class="nc" id="L150">                        }</span>
                    }
                }
<span class="nc" id="L153">            } else {</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                if (id.equals(idInit)) {</span>
<span class="nc" id="L155">                    int thisN = ctx.getThisNumber();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                    if (!ctx.field.isConstructor()) {</span>
<span class="nc" id="L157">                        env.error(where, &quot;invalid.constr.invoke&quot;);</span>
<span class="nc" id="L158">                        return vset.addVar(thisN);</span>
                    }
                    // As a consequence of the DA/DU rules in the JLS (draft of
                    // forthcoming 2e), all variables are both definitely assigned
                    // and definitely unassigned in unreachable code.  Normally, this
                    // correctly suppresses DA/DU-related errors in such code.
                    // The use of the DA status of the 'this' variable for the extra
                    // check below on correct constructor usage, however, does not quite
                    // fit into this DA/DU scheme.  The current representation of
                    // Vsets for unreachable dead-ends, does not allow 'clearVar'
                    // to work, as the DA/DU bits (all on) are implicitly represented
                    // by the fact that the Vset is a dead-end.  The DA/DU status
                    // of the 'this' variable is supposed to be temporarily
                    // cleared at the beginning of a constructor and during the
                    // checking of constructor arguments (see below in this method).
                    // Since 'clearVar' has no effect on dead-ends, we may
                    // find the 'this' variable in an erroneously definitely-assigned state.
                    // As a workaround, we suppress the following error message when
                    // the Vset is a dead-end, i.e., when we are in unreachable code.
                    // Unfortunately, the special-case treatment of reachability for
                    // if-then and if-then-else allows unreachable code in some circumstances,
                    // thus it is possible that no error message will be emitted at all.
                    // While this behavior is strictly incorrect (thus we call this a
                    // workaround), the problematic code is indeed unreachable and will
                    // not be executed.  In fact, it will be entirely omitted from the
                    // translated program, and can cause no harm at runtime.  A correct
                    // solution would require modifying the representation of the DA/DU
                    // analysis to use finite Vsets only, restricting the universe
                    // of variables about which assertions are made (even in unreachable
                    // code) to variables that are actually in scope. Alternatively, the
                    // Vset extension and the dead-end marker (currently a reserved value
                    // of the extension) could be represented orthogonally.  In either case,
                    // 'clearVar' could then be made to work on (non-canonical) dead ends.
                    // See file 'Vset.java'.
<span class="nc bnc" id="L192" title="All 4 branches missed.">                    if (!vset.isReallyDeadEnd() &amp;&amp; vset.testVar(thisN)) {</span>
<span class="nc" id="L193">                        env.error(where, &quot;constr.invoke.not.first&quot;);</span>
<span class="nc" id="L194">                        return vset;</span>
                    }
<span class="nc" id="L196">                    vset = vset.addVar(thisN);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">                    if (right instanceof SuperExpression) {</span>
                        // supers require this specific kind of checking
<span class="nc" id="L199">                        vset = right.checkAmbigName(env, ctx, vset, exp, this);</span>
                    } else {
<span class="nc" id="L201">                        vset = right.checkValue(env, ctx, vset, exp);</span>
                    }
<span class="nc" id="L203">                } else {</span>
<span class="nc" id="L204">                    vset = right.checkAmbigName(env, ctx, vset, exp, this);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                    if (right.type == Type.tPackage) {</span>
<span class="nc" id="L206">                        FieldExpression.reportFailedPackagePrefix(env, right);</span>
<span class="nc" id="L207">                        return vset;</span>
                    }
<span class="nc bnc" id="L209" title="All 2 branches missed.">                    if (right instanceof TypeExpression) {</span>
<span class="nc" id="L210">                        staticRef = true;</span>
                    }
                }
<span class="nc bnc" id="L213" title="All 2 branches missed.">                if (right.type.isType(TC_CLASS)) {</span>
<span class="nc" id="L214">                    c = env.getClassDeclaration(right.type);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                } else if (right.type.isType(TC_ARRAY)) {</span>
<span class="nc" id="L216">                    isArray = true;</span>
<span class="nc" id="L217">                    c = env.getClassDeclaration(Type.tObject);</span>
                } else {
<span class="nc bnc" id="L219" title="All 2 branches missed.">                    if (!right.type.isType(TC_ERROR)) {</span>
<span class="nc" id="L220">                        env.error(where, &quot;invalid.method.invoke&quot;, right.type);</span>
                    }
<span class="nc" id="L222">                    return vset;</span>
                }

                // Normally, the effective accessing class is the innermost
                // class surrounding the current method call, but, for calls
                // of the form '&lt;class&gt;.super.&lt;method&gt;(...)', it is &lt;class&gt;.
                // This allows access to protected members of a superclass
                // from within a class nested within one of its subclasses.
                // Otherwise, for example, the call below to 'matchMethod'
                // may fail due to the rules for visibility of inaccessible
                // members.  For consistency, we treat qualified 'this' in
                // the same manner, as error diagnostics will be affected.
                // QUERY: Are there subtle unexplored language issues here?
<span class="nc bnc" id="L235" title="All 2 branches missed.">                if (right instanceof FieldExpression) {</span>
<span class="nc" id="L236">                    Identifier id = ((FieldExpression)right).id;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                    if (id == idThis) {</span>
<span class="nc" id="L238">                        sourceClass = ((FieldExpression)right).clazz;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                    } else if (id == idSuper) {</span>
<span class="nc" id="L240">                        isSuper = true;</span>
<span class="nc" id="L241">                        sourceClass = ((FieldExpression)right).clazz;</span>
                    }
<span class="nc bnc" id="L243" title="All 2 branches missed.">                } else if (right instanceof SuperExpression) {</span>
<span class="nc" id="L244">                    isSuper = true;</span>
                }

                // Fix for 4158650.  When we extend a protected inner
                // class in a different package, we may not have access
                // to the type of our superclass.  Allow the call to
                // the superclass constructor from within our constructor
                // Note that this check does not apply to constructor
                // calls in new instance expressions -- those are part
                // of NewInstanceExpression#check().
<span class="nc bnc" id="L254" title="All 2 branches missed.">                if (id != idInit) {</span>
                    // Required by JLS 6.6.1.  Fixes 4143715.
                    // (See also 4094658.)
<span class="nc bnc" id="L257" title="All 2 branches missed.">                    if (!FieldExpression.isTypeAccessible(where, env,</span>
                                                          right.type,
                                                          sourceClass)) {
<span class="nc" id="L260">                        ClassDeclaration cdecl =</span>
<span class="nc" id="L261">                            sourceClass.getClassDeclaration();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                        if (staticRef) {</span>
<span class="nc" id="L263">                            env.error(where, &quot;no.type.access&quot;,</span>
<span class="nc" id="L264">                                      id, right.type.toString(), cdecl);</span>
                        } else {
<span class="nc" id="L266">                            env.error(where, &quot;cant.access.member.type&quot;,</span>
<span class="nc" id="L267">                                      id, right.type.toString(), cdecl);</span>
                        }
                    }
                }
            }

            // Compose a list of argument types
<span class="nc" id="L274">            boolean hasErrors = false;</span>

            // &quot;this&quot; is not defined during argument checking
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (id.equals(idInit)) {</span>
<span class="nc" id="L278">                vset = vset.clearVar(ctx.getThisNumber());</span>
            }

<span class="nc bnc" id="L281" title="All 2 branches missed.">            for (int i = 0 ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L282">                vset = args[i].checkValue(env, ctx, vset, exp);</span>
<span class="nc" id="L283">                argTypes[i] = args[i].type;</span>
<span class="nc bnc" id="L284" title="All 4 branches missed.">                hasErrors = hasErrors || argTypes[i].isType(TC_ERROR);</span>
            }

            // &quot;this&quot; is defined after the constructor invocation
<span class="nc bnc" id="L288" title="All 2 branches missed.">            if (id.equals(idInit)) {</span>
<span class="nc" id="L289">                vset = vset.addVar(ctx.getThisNumber());</span>
            }

            // Check if there are any type errors in the arguments
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (hasErrors) {</span>
<span class="nc" id="L294">                return vset;</span>
            }

            // Get the method field, given the argument types
<span class="nc" id="L298">            clazz = c.getClassDefinition(env);</span>

<span class="nc bnc" id="L300" title="All 2 branches missed.">            if (field == null) {</span>

<span class="nc" id="L302">                field = clazz.matchMethod(env, sourceClass, id, argTypes);</span>

<span class="nc bnc" id="L304" title="All 2 branches missed.">                if (field == null) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                    if (id.equals(idInit)) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                        if (diagnoseMismatch(env, args, argTypes))</span>
<span class="nc" id="L307">                            return vset;</span>
<span class="nc" id="L308">                        String sig = clazz.getName().getName().toString();</span>
<span class="nc" id="L309">                        sig = Type.tMethod(Type.tError, argTypes).typeString(sig, false, false);</span>
<span class="nc" id="L310">                        env.error(where, &quot;unmatched.constr&quot;, sig, c);</span>
<span class="nc" id="L311">                        return vset;</span>
                    }
<span class="nc" id="L313">                    String sig = id.toString();</span>
<span class="nc" id="L314">                    sig = Type.tMethod(Type.tError, argTypes).typeString(sig, false, false);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">                    if (clazz.findAnyMethod(env, id) == null) {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                        if (ctx.getField(env, id) != null) {</span>
<span class="nc" id="L317">                            env.error(where, &quot;invalid.method&quot;, id, c);</span>
                        } else {
<span class="nc" id="L319">                            env.error(where, &quot;undef.meth&quot;, sig, c);</span>
                        }
<span class="nc bnc" id="L321" title="All 2 branches missed.">                    } else if (diagnoseMismatch(env, args, argTypes)) {</span>
                    } else {
<span class="nc" id="L323">                        env.error(where, &quot;unmatched.meth&quot;, sig, c);</span>
                    }
<span class="nc" id="L325">                    return vset;</span>
                }

            }

<span class="nc" id="L330">            type = field.getType().getReturnType();</span>

            // Make sure that static references are allowed
<span class="nc bnc" id="L333" title="All 4 branches missed.">            if (staticRef &amp;&amp; !field.isStatic()) {</span>
<span class="nc" id="L334">                env.error(where, &quot;no.static.meth.access&quot;,</span>
<span class="nc" id="L335">                          field, field.getClassDeclaration());</span>
<span class="nc" id="L336">                return vset;</span>
            }

<span class="nc bnc" id="L339" title="All 10 branches missed.">            if (field.isProtected()</span>
                &amp;&amp; !(right == null)
                &amp;&amp; !(right instanceof SuperExpression
                     // Extension of JLS 6.6.2 for qualified 'super'.
                     || (right instanceof FieldExpression &amp;&amp;
                         ((FieldExpression)right).id == idSuper))
<span class="nc bnc" id="L345" title="All 2 branches missed.">                &amp;&amp; !sourceClass.protectedAccess(env, field, right.type)) {</span>
<span class="nc" id="L346">                env.error(where, &quot;invalid.protected.method.use&quot;,</span>
<span class="nc" id="L347">                          field.getName(), field.getClassDeclaration(),</span>
                          right.type);
<span class="nc" id="L349">                return vset;</span>
            }

            // In &lt;class&gt;.super.&lt;method&gt;(), we cannot simply evaluate
            // &lt;class&gt;.super to an object reference (as we would for
            // &lt;class&gt;.super.&lt;field&gt;) and then perform an 'invokespecial'.
            // An 'invokespecial' must be performed from within (a subclass of)
            // the class in which the target method is located.
<span class="nc bnc" id="L357" title="All 4 branches missed.">            if (right instanceof FieldExpression &amp;&amp;</span>
                ((FieldExpression)right).id == idSuper) {
<span class="nc bnc" id="L359" title="All 2 branches missed.">                if (!field.isPrivate()) {</span>
                    // The private case is handled below.
                    // Use an access method unless the effective accessing class
                    // (the class qualifying the 'super') is the same as the
                    // immediately enclosing class, i.e., the qualification was
                    // unnecessary.
<span class="nc bnc" id="L365" title="All 2 branches missed.">                    if (sourceClass != ctxClass) {</span>
<span class="nc" id="L366">                        implMethod = sourceClass.getAccessMember(env, ctx, field, true);</span>
                    }
                }
            }

            // Access method for private field if not in the same class.
<span class="nc bnc" id="L372" title="All 4 branches missed.">            if (implMethod == null &amp;&amp; field.isPrivate()) {</span>
<span class="nc" id="L373">                ClassDefinition cdef = field.getClassDefinition();</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                if (cdef != ctxClass) {</span>
<span class="nc" id="L375">                    implMethod = cdef.getAccessMember(env, ctx, field, false);</span>
                }
            }

            // Make sure that we are not invoking an abstract method
<span class="nc bnc" id="L380" title="All 6 branches missed.">            if (field.isAbstract() &amp;&amp; (right != null) &amp;&amp; (right.op == SUPER)) {</span>
<span class="nc" id="L381">                env.error(where, &quot;invoke.abstract&quot;, field, field.getClassDeclaration());</span>
<span class="nc" id="L382">                return vset;</span>
            }

<span class="nc bnc" id="L385" title="All 2 branches missed.">            if (field.reportDeprecated(env)) {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">                if (field.isConstructor()) {</span>
<span class="nc" id="L387">                    env.error(where, &quot;warn.constr.is.deprecated&quot;, field);</span>
                } else {
<span class="nc" id="L389">                    env.error(where, &quot;warn.meth.is.deprecated&quot;,</span>
<span class="nc" id="L390">                              field, field.getClassDefinition());</span>
                }
            }

            // Check for recursive constructor
<span class="nc bnc" id="L395" title="All 4 branches missed.">            if (field.isConstructor() &amp;&amp; ctx.field.equals(field)) {</span>
<span class="nc" id="L396">                env.error(where, &quot;recursive.constr&quot;, field);</span>
            }

            // When a package-private class defines public or protected
            // members, those members may sometimes be accessed from
            // outside of the package in public subclasses.  In these
            // cases, we need to massage the method call to refer to
            // to an accessible subclass rather than the package-private
            // parent class.  Part of fix for 4135692.

            // Find out if the class which contains this method
            // call has access to the class which declares the
            // public or protected method referent.
            // We don't perform this translation on constructor calls.
<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (sourceClass == ctxClass) {</span>
<span class="nc" id="L411">                ClassDefinition declarer = field.getClassDefinition();</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                if (!field.isConstructor() &amp;&amp;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                    declarer.isPackagePrivate() &amp;&amp;</span>
<span class="nc" id="L414">                    !declarer.getName().getQualifier()</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                    .equals(sourceClass.getName().getQualifier())) {</span>

                    //System.out.println(&quot;The access of member &quot; +
                    //             field + &quot; declared in class &quot; +
                    //             declarer +
                    //             &quot; is not allowed by the VM from class  &quot; +
                    //             accessor +
                    //             &quot;.  Replacing with an access of class &quot; +
                    //             clazz);

                    // We cannot make this access at the VM level.
                    // Construct a member which will stand for this
                    // method in clazz and set `field' to refer to it.
<span class="nc" id="L428">                    field =</span>
<span class="nc" id="L429">                        MemberDefinition.makeProxyMember(field, clazz, env);</span>
                }
            }

<span class="nc" id="L433">            sourceClass.addDependency(field.getClassDeclaration());</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (sourceClass != ctxClass) {</span>
<span class="nc" id="L435">                ctxClass.addDependency(field.getClassDeclaration());</span>
            }

<span class="nc" id="L438">        } catch (ClassNotFound ee) {</span>
<span class="nc" id="L439">            env.error(where, &quot;class.not.found&quot;, ee.name, ctx.field);</span>
<span class="nc" id="L440">            return vset;</span>

<span class="nc" id="L442">        } catch (AmbiguousMember ee) {</span>
<span class="nc" id="L443">            env.error(where, &quot;ambig.field&quot;, id, ee.field1, ee.field2);</span>
<span class="nc" id="L444">            return vset;</span>
<span class="nc" id="L445">        }</span>

        // Make sure it is qualified
<span class="nc bnc" id="L448" title="All 4 branches missed.">        if ((right == null) &amp;&amp; !field.isStatic()) {</span>
<span class="nc" id="L449">            right = ctx.findOuterLink(env, where, field);</span>
<span class="nc" id="L450">            vset = right.checkValue(env, ctx, vset, exp);</span>
        }

        // Cast arguments
<span class="nc" id="L454">        argTypes = field.getType().getArgumentTypes();</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        for (int i = 0 ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L456">            args[i] = convert(env, ctx, argTypes[i], args[i]);</span>
        }

<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (field.isConstructor()) {</span>
<span class="nc" id="L460">            MemberDefinition m = field;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            if (implMethod != null) {</span>
<span class="nc" id="L462">                m = implMethod;</span>
            }
<span class="nc" id="L464">            int nargs = args.length;</span>
<span class="nc" id="L465">            Expression[] newargs = args;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (nargs &gt; this.args.length) {</span>
                // Argument was added above.
                // Maintain the model for hidden outer args in outer.super(...):
                Expression rightI;
<span class="nc bnc" id="L470" title="All 2 branches missed.">                if (right instanceof SuperExpression) {</span>
<span class="nc" id="L471">                    rightI = new SuperExpression(right.where, ctx);</span>
<span class="nc" id="L472">                    ((SuperExpression)right).outerArg = args[0];</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                } else if (right instanceof ThisExpression) {</span>
<span class="nc" id="L474">                    rightI = new ThisExpression(right.where, ctx);</span>
                } else {
<span class="nc" id="L476">                    throw new CompilerError(&quot;this.init&quot;);</span>
                }
<span class="nc bnc" id="L478" title="All 2 branches missed.">                if (implMethod != null) {</span>
                    // Need dummy argument for access method.
                    // Dummy argument follows outer instance link.
                    // Leave 'this.args' equal to 'newargs' but
                    // without the outer instance link.
<span class="nc" id="L483">                    newargs = new Expression[nargs+1];</span>
<span class="nc" id="L484">                    this.args = new Expression[nargs];</span>
<span class="nc" id="L485">                    newargs[0] = args[0]; // outer instance</span>
<span class="nc" id="L486">                    this.args[0] = newargs[1] = new NullExpression(where); // dummy argument</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                    for (int i = 1 ; i &lt; nargs ; i++) {</span>
<span class="nc" id="L488">                        this.args[i] = newargs[i+1] = args[i];</span>
                    }
                } else {
                    // Strip outer instance link from 'this.args'.
                    // ASSERT(this.arg.length == nargs-1);
<span class="nc bnc" id="L493" title="All 2 branches missed.">                    for (int i = 1 ; i &lt; nargs ; i++) {</span>
<span class="nc" id="L494">                        this.args[i-1] = args[i];</span>
                    }
                }
<span class="nc" id="L497">                implementation = new MethodExpression(where, rightI, m, newargs);</span>
<span class="nc" id="L498">                implementation.type = type; // Is this needed?</span>
<span class="nc" id="L499">            } else {</span>
                // No argument was added.
<span class="nc bnc" id="L501" title="All 2 branches missed.">                if (implMethod != null) {</span>
                    // Need dummy argument for access method.
                    // Dummy argument is first, as there is no outer instance link.
<span class="nc" id="L504">                    newargs = new Expression[nargs+1];</span>
<span class="nc" id="L505">                    newargs[0] = new NullExpression(where);</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                    for (int i = 0 ; i &lt; nargs ; i++) {</span>
<span class="nc" id="L507">                        newargs[i+1] = args[i];</span>
                    }
                }
<span class="nc" id="L510">                implementation = new MethodExpression(where, right, m, newargs);</span>
            }
<span class="nc" id="L512">        } else {</span>
            // Have ordinary method.
            // Argument should have been added only for a constructor.
<span class="nc bnc" id="L515" title="All 2 branches missed.">            if (args.length &gt; this.args.length) {</span>
<span class="nc" id="L516">                throw new CompilerError(&quot;method arg&quot;);</span>
            }
<span class="nc bnc" id="L518" title="All 2 branches missed.">            if (implMethod != null) {</span>
                //System.out.println(&quot;Calling &quot; + field + &quot; via &quot; + implMethod);
<span class="nc" id="L520">                Expression oldargs[] = this.args;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                if (field.isStatic()) {</span>
<span class="nc" id="L522">                    Expression call = new MethodExpression(where, null, implMethod, oldargs);</span>
<span class="nc" id="L523">                    implementation = new CommaExpression(where, right, call);</span>
<span class="nc" id="L524">                } else {</span>
                    // Access method needs an explicit 'this' pointer.
<span class="nc" id="L526">                    int nargs = oldargs.length;</span>
<span class="nc" id="L527">                    Expression newargs[] = new Expression[nargs+1];</span>
<span class="nc" id="L528">                    newargs[0] = right;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">                    for (int i = 0; i &lt; nargs; i++) {</span>
<span class="nc" id="L530">                        newargs[i+1] = oldargs[i];</span>
                    }
<span class="nc" id="L532">                    implementation = new MethodExpression(where, null, implMethod, newargs);</span>
                }
            }
        }

        // Follow super() by variable initializations
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (ctx.field.isConstructor() &amp;&amp;</span>
<span class="nc bnc" id="L539" title="All 6 branches missed.">            field.isConstructor() &amp;&amp; (right != null) &amp;&amp; (right.op == SUPER)) {</span>
<span class="nc" id="L540">            Expression e = makeVarInits(env, ctx);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">            if (e != null) {</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">                if (implementation == null)</span>
<span class="nc" id="L543">                    implementation = (Expression)this.clone();</span>
<span class="nc" id="L544">                implementation = new CommaExpression(where, implementation, e);</span>
            }
        }

        // Throw the declared exceptions.
<span class="nc" id="L549">        ClassDeclaration exceptions[] = field.getExceptions(env);</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">        if (isArray &amp;&amp; (field.getName() == idClone) &amp;&amp;</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">               (field.getType().getArgumentTypes().length == 0)) {</span>
            /* Arrays pretend that they have &quot;public Object clone()&quot; that doesn't
             * throw anything, according to the language spec.
             */
<span class="nc" id="L555">            exceptions = new ClassDeclaration[0];</span>
            /* See if there's a bogus catch for it, to issue a warning. */
<span class="nc bnc" id="L557" title="All 2 branches missed.">            for (Context p = ctx; p != null; p = p.prev) {</span>
<span class="nc bnc" id="L558" title="All 4 branches missed.">                if (p.node != null &amp;&amp; p.node.op == TRY) {</span>
<span class="nc" id="L559">                    ((TryStatement) p.node).arrayCloneWhere = where;</span>
                }
            }
        }
<span class="nc bnc" id="L563" title="All 2 branches missed.">        for (int i = 0 ; i &lt; exceptions.length ; i++) {</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">            if (exp.get(exceptions[i]) == null) {</span>
<span class="nc" id="L565">                exp.put(exceptions[i], this);</span>
            }
        }

        // Mark all blank finals as definitely assigned following 'this(...)'.
        // Correctness follows inductively from the requirement that all blank finals
        // be definitely assigned at the completion of every constructor.
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (ctx.field.isConstructor() &amp;&amp;</span>
<span class="nc bnc" id="L573" title="All 6 branches missed.">            field.isConstructor() &amp;&amp; (right != null) &amp;&amp; (right.op == THIS)) {</span>
<span class="nc" id="L574">            ClassDefinition cls = field.getClassDefinition();</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">            for (MemberDefinition f = cls.getFirstMember() ; f != null ; f = f.getNextMember()) {</span>
<span class="nc bnc" id="L576" title="All 6 branches missed.">                if (f.isVariable() &amp;&amp; f.isBlankFinal() &amp;&amp; !f.isStatic()) {</span>
                    // Static variables should also be considered defined as well, but this
                    // is handled in 'SourceClass.checkMembers', and we should not interfere.
<span class="nc" id="L579">                    vset = vset.addVar(ctx.getFieldNumber(f));</span>
                }
            }
        }

<span class="nc" id="L584">        return vset;</span>
    }

    /**
     * Check void expression
     */
    public Vset check(Environment env, Context ctx, Vset vset, Hashtable exp) {
<span class="nc" id="L591">        return checkValue(env, ctx, vset, exp);</span>
    }

    /**
     * We're about to report a &quot;unmatched method&quot; error.
     * Try to issue a better diagnostic by comparing the actual argument types
     * with the method (or methods) available.
     * In particular, if there is an argument which fails to match &lt;em&gt;any&lt;/em&gt;
     * method, we report a type mismatch error against that particular argument.
     * The diagnostic will report a target type taken from one of the methods.
     * &lt;p&gt;
     * Return false if we couldn't think of anything smart to say.
     */
    boolean diagnoseMismatch(Environment env, Expression args[],
                             Type argTypes[]) throws ClassNotFound {
<span class="nc" id="L606">        Type margType[] = new Type[1];</span>
<span class="nc" id="L607">        boolean saidSomething = false;</span>
<span class="nc" id="L608">        int start = 0;</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">        while (start &lt; argTypes.length) {</span>
<span class="nc" id="L610">            int code = clazz.diagnoseMismatch(env, id, argTypes, start, margType);</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">            String opName = (id.equals(idInit)) ? &quot;constructor&quot; : opNames[op];</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (code == -2) {</span>
<span class="nc" id="L613">                env.error(where, &quot;wrong.number.args&quot;, opName);</span>
<span class="nc" id="L614">                saidSomething = true;</span>
            }
<span class="nc bnc" id="L616" title="All 2 branches missed.">            if (code &lt; 0)  break;</span>
<span class="nc" id="L617">            int i = code &gt;&gt; 2;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">            boolean castOK = (code &amp; 2) != 0;</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">            boolean ambig = (code &amp; 1) != 0;</span>
<span class="nc" id="L620">            Type targetType = margType[0];</span>

            // At least one argument is offensive to all overloadings.
            // targetType is one of the argument types it does not match.
<span class="nc" id="L624">            String ttype = &quot;&quot;+targetType;</span>

            // The message might be slightly misleading, if there are other
            // argument types that also would match.  Hint at this:
            //if (ambig)  ttype = &quot;{&quot;+ttype+&quot;;...}&quot;;

<span class="nc bnc" id="L630" title="All 2 branches missed.">            if (castOK)</span>
<span class="nc" id="L631">                env.error(args[i].where, &quot;explicit.cast.needed&quot;, opName, argTypes[i], ttype);</span>
            else
<span class="nc" id="L633">                env.error(args[i].where, &quot;incompatible.type&quot;, opName, argTypes[i], ttype);</span>
<span class="nc" id="L634">            saidSomething = true;</span>
<span class="nc" id="L635">            start = i+1;        // look for other bad arguments, too</span>
<span class="nc" id="L636">        }</span>
<span class="nc" id="L637">        return saidSomething;</span>
    }

    /**
     * Inline
     */
<span class="nc" id="L643">    static final int MAXINLINECOST = Statement.MAXINLINECOST;</span>

    private
    Expression inlineMethod(Environment env, Context ctx, Statement s, boolean valNeeded) {
<span class="nc bnc" id="L647" title="All 2 branches missed.">        if (env.dump()) {</span>
<span class="nc" id="L648">            System.out.println(&quot;INLINE METHOD &quot; + field + &quot; in &quot; + ctx.field);</span>
        }
<span class="nc" id="L650">        LocalMember v[] = LocalMember.copyArguments(ctx, field);</span>
<span class="nc" id="L651">        Statement body[] = new Statement[v.length + 2];</span>

<span class="nc" id="L653">        int n = 0;</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">        if (field.isStatic()) {</span>
<span class="nc" id="L655">            body[0] = new ExpressionStatement(where, right);</span>
        } else {
<span class="nc bnc" id="L657" title="All 4 branches missed.">            if ((right != null) &amp;&amp; (right.op == SUPER)) {</span>
<span class="nc" id="L658">                right = new ThisExpression(right.where, ctx);</span>
            }
<span class="nc" id="L660">            body[0] = new VarDeclarationStatement(where, v[n++], right);</span>
        }
<span class="nc bnc" id="L662" title="All 2 branches missed.">        for (int i = 0 ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L663">            body[i + 1] = new VarDeclarationStatement(where, v[n++], args[i]);</span>
        }
        //System.out.print(&quot;BEFORE:&quot;); s.print(System.out); System.out.println();
        // Note: If !valNeeded, then all returns in the body of the method
        // change to void returns.
<span class="nc bnc" id="L668" title="All 2 branches missed.">        body[body.length - 1] = (s != null) ? s.copyInline(ctx, valNeeded) : null;</span>
        //System.out.print(&quot;COPY:&quot;); body[body.length - 1].print(System.out); System.out.println();
<span class="nc" id="L670">        LocalMember.doneWithArguments(ctx, v);</span>

        // Make sure the type matches what the return statements are returning.
<span class="nc bnc" id="L673" title="All 2 branches missed.">        Type type = valNeeded ? this.type : Type.tVoid;</span>
<span class="nc" id="L674">        Expression e = new InlineMethodExpression(where, type, field, new CompoundStatement(where, body));</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        return valNeeded ? e.inlineValue(env, ctx) : e.inline(env, ctx);</span>
    }

    public Expression inline(Environment env, Context ctx) {
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L680">            return implementation.inline(env, ctx);</span>
        try {
<span class="nc bnc" id="L682" title="All 2 branches missed.">            if (right != null) {</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">                right = field.isStatic() ? right.inline(env, ctx) : right.inlineValue(env, ctx);</span>
            }
<span class="nc bnc" id="L685" title="All 2 branches missed.">            for (int i = 0 ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L686">                args[i] = args[i].inlineValue(env, ctx);</span>
            }

            // ctxClass is the current class trying to inline this method
<span class="nc" id="L690">            ClassDefinition ctxClass = ctx.field.getClassDefinition();</span>

<span class="nc" id="L692">            Expression e = this;</span>
<span class="nc bnc" id="L693" title="All 8 branches missed.">            if (env.opt() &amp;&amp; field.isInlineable(env, clazz.isFinal()) &amp;&amp;</span>

                // Don't inline if a qualified non-static method: the call
                // itself might throw NullPointerException as a side effect
<span class="nc bnc" id="L697" title="All 2 branches missed.">                ((right == null) || (right.op==THIS) || field.isStatic()) &amp;&amp;</span>

                // We only allow the inlining if the current class can access
                // the field, the field's class, and right's declared type.
<span class="nc bnc" id="L701" title="All 2 branches missed.">                ctxClass.permitInlinedAccess(env,</span>
<span class="nc" id="L702">                              field.getClassDeclaration()) &amp;&amp;</span>
<span class="nc bnc" id="L703" title="All 4 branches missed.">                ctxClass.permitInlinedAccess(env, field) &amp;&amp;</span>
<span class="nc bnc" id="L704" title="All 4 branches missed.">                (right==null || ctxClass.permitInlinedAccess(env,</span>
<span class="nc" id="L705">                              env.getClassDeclaration(right.type)))  &amp;&amp;</span>

<span class="nc bnc" id="L707" title="All 2 branches missed.">                ((id == null) || !id.equals(idInit)) &amp;&amp;</span>
<span class="nc bnc" id="L708" title="All 4 branches missed.">                (!ctx.field.isInitializer()) &amp;&amp; ctx.field.isMethod() &amp;&amp;</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">                (ctx.getInlineMemberContext(field) == null)) {</span>
<span class="nc" id="L710">                Statement s = (Statement)field.getValue(env);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">                if ((s == null) ||</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                    (s.costInline(MAXINLINECOST, env, ctx) &lt; MAXINLINECOST))  {</span>
<span class="nc" id="L713">                    e = inlineMethod(env, ctx, s, false);</span>
                }
            }
<span class="nc" id="L716">            return e;</span>

<span class="nc" id="L718">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L719">            throw new CompilerError(e);</span>
        }
    }

    public Expression inlineValue(Environment env, Context ctx) {
<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L725">            return implementation.inlineValue(env, ctx);</span>
        try {
<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (right != null) {</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">                right = field.isStatic() ? right.inline(env, ctx) : right.inlineValue(env, ctx);</span>
            }
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (field.getName().equals(idInit)) {</span>
<span class="nc" id="L731">                ClassDefinition refc = field.getClassDefinition();</span>
<span class="nc" id="L732">                UplevelReference r = refc.getReferencesFrozen();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                if (r != null) {</span>
<span class="nc" id="L734">                    r.willCodeArguments(env, ctx);</span>
                }
            }
<span class="nc bnc" id="L737" title="All 2 branches missed.">            for (int i = 0 ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L738">                args[i] = args[i].inlineValue(env, ctx);</span>
            }

            // ctxClass is the current class trying to inline this method
<span class="nc" id="L742">            ClassDefinition ctxClass = ctx.field.getClassDefinition();</span>

<span class="nc bnc" id="L744" title="All 8 branches missed.">            if (env.opt() &amp;&amp; field.isInlineable(env, clazz.isFinal()) &amp;&amp;</span>

                // Don't inline if a qualified non-static method: the call
                // itself might throw NullPointerException as a side effect
<span class="nc bnc" id="L748" title="All 2 branches missed.">                ((right == null) || (right.op==THIS) || field.isStatic()) &amp;&amp;</span>

                // We only allow the inlining if the current class can access
                // the field, the field's class, and right's declared type.
<span class="nc bnc" id="L752" title="All 2 branches missed.">                ctxClass.permitInlinedAccess(env,</span>
<span class="nc" id="L753">                              field.getClassDeclaration()) &amp;&amp;</span>
<span class="nc bnc" id="L754" title="All 4 branches missed.">                ctxClass.permitInlinedAccess(env, field) &amp;&amp;</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">                (right==null || ctxClass.permitInlinedAccess(env,</span>
<span class="nc" id="L756">                              env.getClassDeclaration(right.type)))  &amp;&amp;</span>

<span class="nc bnc" id="L758" title="All 4 branches missed.">                (!ctx.field.isInitializer()) &amp;&amp; ctx.field.isMethod() &amp;&amp;</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">                (ctx.getInlineMemberContext(field) == null)) {</span>
<span class="nc" id="L760">                Statement s = (Statement)field.getValue(env);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">                if ((s == null) ||</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">                    (s.costInline(MAXINLINECOST, env, ctx) &lt; MAXINLINECOST))  {</span>
<span class="nc" id="L763">                    return inlineMethod(env, ctx, s, true);</span>
                }
            }
<span class="nc" id="L766">            return this;</span>
<span class="nc" id="L767">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L768">            throw new CompilerError(e);</span>
        }
    }

    public Expression copyInline(Context ctx) {
<span class="nc bnc" id="L773" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L774">            return implementation.copyInline(ctx);</span>
<span class="nc" id="L775">        return super.copyInline(ctx);</span>
    }

    public int costInline(int thresh, Environment env, Context ctx) {
<span class="nc bnc" id="L779" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L780">            return implementation.costInline(thresh, env, ctx);</span>

        // for now, don't allow calls to super() to be inlined.  We may fix
        // this later
<span class="nc bnc" id="L784" title="All 4 branches missed.">        if ((right != null) &amp;&amp; (right.op == SUPER)) {</span>
<span class="nc" id="L785">            return thresh;</span>
        }
<span class="nc" id="L787">        return super.costInline(thresh, env, ctx);</span>
    }

    /*
     * Grab all instance initializer code from the class definition,
     * and return as one bolus.  Note that we are assuming the
     * the relevant fields have already been checked.
     * (See the pre-pass in SourceClass.checkMembers which ensures this.)
     */
    private Expression makeVarInits(Environment env, Context ctx) {
        // insert instance initializers
<span class="nc" id="L798">        ClassDefinition clazz = ctx.field.getClassDefinition();</span>
<span class="nc" id="L799">        Expression e = null;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">        for (MemberDefinition f = clazz.getFirstMember() ; f != null ; f = f.getNextMember()) {</span>
<span class="nc bnc" id="L801" title="All 6 branches missed.">            if ((f.isVariable() || f.isInitializer()) &amp;&amp; !f.isStatic()) {</span>
                try {
<span class="nc" id="L803">                    f.check(env);</span>
<span class="nc" id="L804">                } catch (ClassNotFound ee) {</span>
<span class="nc" id="L805">                    env.error(f.getWhere(), &quot;class.not.found&quot;, ee.name,</span>
<span class="nc" id="L806">                              f.getClassDefinition());</span>
<span class="nc" id="L807">                }</span>
<span class="nc" id="L808">                Expression val = null;</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">                if (f.isUplevelValue()) {</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">                    if (f != clazz.findOuterMember()) {</span>
                        // it's too early to accumulate these
<span class="nc" id="L812">                        continue;</span>
                    }
<span class="nc" id="L814">                    IdentifierExpression arg =</span>
<span class="nc" id="L815">                        new IdentifierExpression(where, f.getName());</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">                    if (!arg.bind(env, ctx)) {</span>
<span class="nc" id="L817">                        throw new CompilerError(&quot;bind &quot;+arg.id);</span>
                    }
<span class="nc" id="L819">                    val = arg;</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">                } else if (f.isInitializer()) {</span>
<span class="nc" id="L821">                    Statement s = (Statement)f.getValue();</span>
<span class="nc" id="L822">                    val = new InlineMethodExpression(where, Type.tVoid, f, s);</span>
<span class="nc" id="L823">                } else {</span>
<span class="nc" id="L824">                    val = (Expression)f.getValue();</span>
                }
                // append all initializers to &quot;e&quot;:
                // This section used to check for variables which were
                // initialized to their default values and elide such
                // initialization.  This is specifically disallowed by
                // JLS 12.5 numeral 4, which requires a textual ordering
                // on the execution of initializers.
<span class="nc bnc" id="L832" title="All 2 branches missed.">                if ((val != null)) { //  &amp;&amp; !val.equals(0)) {</span>
<span class="nc" id="L833">                    long p = f.getWhere();</span>
<span class="nc" id="L834">                    val = val.copyInline(ctx);</span>
<span class="nc" id="L835">                    Expression init = val;</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">                    if (f.isVariable()) {</span>
<span class="nc" id="L837">                        Expression v = new ThisExpression(p, ctx);</span>
<span class="nc" id="L838">                    v = new FieldExpression(p, v, f);</span>
<span class="nc" id="L839">                    init = new AssignExpression(p, v, val);</span>
                    }
<span class="nc bnc" id="L841" title="All 2 branches missed.">                    e = (e == null) ? init : new CommaExpression(p, e, init);</span>
                }
            }
        }
<span class="nc" id="L845">        return e;</span>
    }

    /**
     * Code
     */
    public void codeValue(Environment env, Context ctx, Assembler asm) {
<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L853">            throw new CompilerError(&quot;codeValue&quot;);</span>
<span class="nc" id="L854">        int i = 0;              // argument index</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">        if (field.isStatic()) {</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">            if (right != null) {</span>
<span class="nc" id="L857">                right.code(env, ctx, asm);</span>
            }
<span class="nc bnc" id="L859" title="All 2 branches missed.">        } else if (right == null) {</span>
<span class="nc" id="L860">            asm.add(where, opc_aload, new Integer(0));</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">        } else if (right.op == SUPER) {</span>
            // 'super.&lt;method&gt;(...)', 'super(...)', or '&lt;expr&gt;.super(...)'
            /*****
            isSuper = true;
            *****/
<span class="nc" id="L866">            right.codeValue(env, ctx, asm);</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">            if (idInit.equals(id)) {</span>
                // 'super(...)' or '&lt;expr&gt;.super(...)' only
<span class="nc" id="L869">                ClassDefinition refc = field.getClassDefinition();</span>
<span class="nc" id="L870">                UplevelReference r = refc.getReferencesFrozen();</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">                if (r != null) {</span>
                    // When calling a constructor for a class with
                    // embedded uplevel references, add extra arguments.
<span class="nc bnc" id="L874" title="All 2 branches missed.">                    if (r.isClientOuterField()) {</span>
                        // the extra arguments are inserted after this one
<span class="nc" id="L876">                        args[i++].codeValue(env, ctx, asm);</span>
                    }
<span class="nc" id="L878">                    r.codeArguments(env, ctx, asm, where, field);</span>
                }
<span class="nc" id="L880">            }</span>
        } else {
<span class="nc" id="L882">            right.codeValue(env, ctx, asm);</span>
            /*****
            if (right.op == FIELD &amp;&amp;
                ((FieldExpression)right).id == idSuper) {
                // '&lt;class&gt;.super.&lt;method&gt;(...)'
                isSuper = true;
            }
            *****/
        }

<span class="nc bnc" id="L892" title="All 2 branches missed.">        for ( ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L893">            args[i].codeValue(env, ctx, asm);</span>
        }

<span class="nc bnc" id="L896" title="All 2 branches missed.">        if (field.isStatic()) {</span>
<span class="nc" id="L897">            asm.add(where, opc_invokestatic, field);</span>
<span class="nc bnc" id="L898" title="All 6 branches missed.">        } else if (field.isConstructor() || field.isPrivate() || isSuper) {</span>
<span class="nc" id="L899">            asm.add(where, opc_invokespecial, field);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">        } else if (field.getClassDefinition().isInterface()) {</span>
<span class="nc" id="L901">            asm.add(where, opc_invokeinterface, field);</span>
        } else {
<span class="nc" id="L903">            asm.add(where, opc_invokevirtual, field);</span>
        }

<span class="nc bnc" id="L906" title="All 6 branches missed.">        if (right != null &amp;&amp; right.op == SUPER &amp;&amp; idInit.equals(id)) {</span>
            // 'super(...)' or '&lt;expr&gt;.super(...)'
<span class="nc" id="L908">            ClassDefinition refc = ctx.field.getClassDefinition();</span>
<span class="nc" id="L909">            UplevelReference r = refc.getReferencesFrozen();</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (r != null) {</span>
                // After calling a superclass constructor in a class with
                // embedded uplevel references, initialize uplevel fields.
<span class="nc" id="L913">                r.codeInitialization(env, ctx, asm, where, field);</span>
            }
        }
<span class="nc" id="L916">    }</span>

    /**
     * Check if the first thing is a constructor invocation
     */
    public Expression firstConstructor() {
<span class="nc bnc" id="L922" title="All 2 branches missed.">        return id.equals(idInit) ? this : null;</span>
    }

    /**
     * Print
     */
    public void print(PrintStream out) {
<span class="nc" id="L929">        out.print(&quot;(&quot; + opNames[op]);</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if (right != null) {</span>
<span class="nc" id="L931">            out.print(&quot; &quot;);</span>
<span class="nc" id="L932">            right.print(out);</span>
        }
<span class="nc bnc" id="L934" title="All 2 branches missed.">        out.print(&quot; &quot; + ((id == null) ? idInit : id));</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">        for (int i = 0 ; i &lt; args.length ; i++) {</span>
<span class="nc" id="L936">            out.print(&quot; &quot;);</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">            if (args[i] != null) {</span>
<span class="nc" id="L938">                args[i].print(out);</span>
            } else {
<span class="nc" id="L940">                out.print(&quot;&lt;null&gt;&quot;);</span>
            }
        }
<span class="nc" id="L943">        out.print(&quot;)&quot;);</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">        if (implementation != null) {</span>
<span class="nc" id="L945">            out.print(&quot;/IMPL=&quot;);</span>
<span class="nc" id="L946">            implementation.print(out);</span>
        }
<span class="nc" id="L948">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>