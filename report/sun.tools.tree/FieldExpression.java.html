<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FieldExpression.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.tree</a> &gt; <span class="el_source">FieldExpression.java</span></div><h1>FieldExpression.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.tree;

import sun.tools.java.*;
import sun.tools.asm.*;
import java.io.PrintStream;
import java.util.Hashtable;

/**
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public
class FieldExpression extends UnaryExpression {
    Identifier id;
    MemberDefinition field;
    Expression implementation;

    // The class from which the field is select ed.
    ClassDefinition clazz;

    // For an expression of the form '&lt;class&gt;.super', then
    // this is &lt;class&gt;, else null.
    private ClassDefinition superBase;

    /**
     * constructor
     */
    public FieldExpression(long where, Expression right, Identifier id) {
<span class="nc" id="L55">        super(FIELD, where, Type.tError, right);</span>
<span class="nc" id="L56">        this.id = id;</span>
<span class="nc" id="L57">    }</span>
    public FieldExpression(long where, Expression right, MemberDefinition field) {
<span class="nc" id="L59">        super(FIELD, where, field.getType(), right);</span>
<span class="nc" id="L60">        this.id = field.getName();</span>
<span class="nc" id="L61">        this.field = field;</span>
<span class="nc" id="L62">    }</span>

    public Expression getImplementation() {
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L66">            return implementation;</span>
<span class="nc" id="L67">        return this;</span>
    }

    /**
     * Return true if the field is being selected from
     * a qualified 'super'.
     */
    private boolean isQualSuper() {
<span class="nc bnc" id="L75" title="All 2 branches missed.">        return superBase != null;</span>
    }

    /**
     * Convert an '.' expression to a qualified identifier
     */
    static public Identifier toIdentifier(Expression e) {
<span class="nc" id="L82">        StringBuffer buf = new StringBuffer();</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        while (e.op == FIELD) {</span>
<span class="nc" id="L84">            FieldExpression fe = (FieldExpression)e;</span>
<span class="nc bnc" id="L85" title="All 4 branches missed.">            if (fe.id == idThis || fe.id == idClass) {</span>
<span class="nc" id="L86">                return null;</span>
            }
<span class="nc" id="L88">            buf.insert(0, fe.id);</span>
<span class="nc" id="L89">            buf.insert(0, '.');</span>
<span class="nc" id="L90">            e = fe.right;</span>
<span class="nc" id="L91">        }</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (e.op != IDENT) {</span>
<span class="nc" id="L93">            return null;</span>
        }
<span class="nc" id="L95">        buf.insert(0, ((IdentifierExpression)e).id);</span>
<span class="nc" id="L96">        return Identifier.lookup(buf.toString());</span>
    }

    /**
     * Convert a qualified name into a type.
     * Performs a careful check of each inner-class component,
     * including the JLS 6.6.1 access checks that were omitted
     * in 'FieldExpression.toType'.
     * &lt;p&gt;
     * This code is similar to 'checkCommon', which could be cleaned
     * up a bit long the lines we have done here.
     */
    /*-------------------------------------------------------*
    Type toQualifiedType(Environment env, Context ctx) {
        ClassDefinition ctxClass = ctx.field.getClassDefinition();
        Type rty = right.toQualifiedType(env, ctx);
        if (rty == Type.tPackage) {
            // Is this field expression a non-inner type?
            Identifier nm = toIdentifier(this);
            if ((nm != null) &amp;&amp; env.classExists(nm)) {
                Type t = Type.tClass(nm);
                if (env.resolve(where, ctxClass, t)) {
                    return t;
                } else {
                    return null;
                }
            }
            // Not a type.  Must be a package prefix.
            return Type.tPackage;
        }
        if (rty == null) {
            // An error was already reported, so quit.
            return null;
        }

        // Check inner-class qualification while unwinding from recursion.
        try {
            ClassDefinition rightClass = env.getClassDefinition(rty);

            // Local variables, which cannot be inner classes,
            // are ignored here, and thus will not hide inner
            // classes.  Is this correct?
            MemberDefinition field = rightClass.getInnerClass(env, id);
            if (field == null) {
                env.error(where, &quot;inner.class.expected&quot;, id, rightClass);
                return Type.tError;
            }

            ClassDefinition innerClass = field.getInnerClass();
            Type t = innerClass.getType();

            if (!ctxClass.canAccess(env, field)) {
                env.error(where, &quot;no.type.access&quot;, id, rightClass, ctxClass);
                return t;
            }
            if (field.isProtected()
                &amp;&amp; !ctxClass.protectedAccess(env, field, rty)) {
                env.error(where, &quot;invalid.protected.type.use&quot;, id, ctxClass, rty);
                return t;
            }

            // These were omitted earlier in calls to 'toType', but I can't
            // see any reason for that.  I think it was an oversight.  See
            // 'checkCommon' and 'checkInnerClass'.
            innerClass.noteUsedBy(ctxClass, where, env);
            ctxClass.addDependency(field.getClassDeclaration());

            return t;

        } catch (ClassNotFound e) {
            env.error(where, &quot;class.not.found&quot;, e.name, ctx.field);
        }

        // Class not found.
        return null;
    }
    *-------------------------------------------------------*/

    /**
     * Convert an '.' expression to a type
     */

    // This is a rewrite to treat qualified names in a
    // context in which a type name is expected in the
    // same way that they are handled for an ambiguous
    // or expression-expected context in 'checkCommon'
    // below.  The new code is cleaner and allows better
    // localization of errors.  Unfortunately, most
    // qualified names appearing in types are actually
    // handled by 'Environment.resolve'.  There isn't
    // much point, then, in breaking out 'toType' as a
    // special case until the other cases can be cleaned
    // up as well.  For the time being, we will leave this
    // code disabled, thus reducing the testing requirements.
    /*-------------------------------------------------------*
    Type toType(Environment env, Context ctx) {
        Type t = toQualifiedType(env, ctx);
        if (t == null) {
            return Type.tError;
        }
        if (t == Type.tPackage) {
            FieldExpression.reportFailedPackagePrefix(env, right, true);
            return Type.tError;
        }
        return t;
    }
    *-------------------------------------------------------*/

    Type toType(Environment env, Context ctx) {
<span class="nc" id="L205">        Identifier id = toIdentifier(this);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (id == null) {</span>
<span class="nc" id="L207">            env.error(where, &quot;invalid.type.expr&quot;);</span>
<span class="nc" id="L208">            return Type.tError;</span>
        }
<span class="nc" id="L210">        Type t = Type.tClass(ctx.resolveName(env, id));</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (env.resolve(where, ctx.field.getClassDefinition(), t)) {</span>
<span class="nc" id="L212">            return t;</span>
        }
<span class="nc" id="L214">        return Type.tError;</span>
    }

    /**
     * Check if the present name is part of a scoping prefix.
     */

    public Vset checkAmbigName(Environment env, Context ctx,
                               Vset vset, Hashtable exp,
                               UnaryExpression loc) {
<span class="nc bnc" id="L224" title="All 4 branches missed.">        if (id == idThis || id == idClass) {</span>
<span class="nc" id="L225">            loc = null;         // this cannot be a type or package</span>
        }
<span class="nc" id="L227">        return checkCommon(env, ctx, vset, exp, loc, false);</span>
    }

    /**
     * Check the expression
     */

    public Vset checkValue(Environment env, Context ctx,
                           Vset vset, Hashtable exp) {
<span class="nc" id="L236">        vset = checkCommon(env, ctx, vset, exp, null, false);</span>
<span class="nc bnc" id="L237" title="All 4 branches missed.">        if (id == idSuper &amp;&amp; type != Type.tError) {</span>
            // &quot;super&quot; is not allowed in this context.
            // It must always qualify another name.
<span class="nc" id="L240">            env.error(where, &quot;undef.var.super&quot;, idSuper);</span>
        }
<span class="nc" id="L242">        return vset;</span>
    }

    /**
     * If 'checkAmbiguousName' returns 'Package.tPackage', then it was
     * unable to resolve any prefix of the qualified name.  This method
     * attempts to diagnose the problem.
     */

    static void reportFailedPackagePrefix(Environment env, Expression right) {
<span class="nc" id="L252">        reportFailedPackagePrefix(env, right, false);</span>
<span class="nc" id="L253">    }</span>

    static void reportFailedPackagePrefix(Environment env,
                                          Expression right,
                                          boolean mustBeType) {
        // Find the leftmost component, and put the blame on it.
<span class="nc" id="L259">        Expression idp = right;</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        while (idp instanceof UnaryExpression)</span>
<span class="nc" id="L261">            idp = ((UnaryExpression)idp).right;</span>
<span class="nc" id="L262">        IdentifierExpression ie = (IdentifierExpression)idp;</span>

        // It may be that 'ie' refers to an ambiguous class.  Check this
        // with a call to env.resolve(). Part of solution for 4059855.
        try {
<span class="nc" id="L267">            env.resolve(ie.id);</span>
<span class="nc" id="L268">        } catch (AmbiguousClass e) {</span>
<span class="nc" id="L269">            env.error(right.where, &quot;ambig.class&quot;, e.name1, e.name2);</span>
<span class="nc" id="L270">            return;</span>
<span class="nc" id="L271">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L272">        }</span>

<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (idp == right) {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (mustBeType) {</span>
<span class="nc" id="L276">                env.error(ie.where, &quot;undef.class&quot;, ie.id);</span>
            } else {
<span class="nc" id="L278">                env.error(ie.where, &quot;undef.var.or.class&quot;, ie.id);</span>
            }
        } else {
<span class="nc bnc" id="L281" title="All 2 branches missed.">            if (mustBeType) {</span>
<span class="nc" id="L282">                env.error(ie.where, &quot;undef.class.or.package&quot;, ie.id);</span>
            } else {
<span class="nc" id="L284">                env.error(ie.where, &quot;undef.var.class.or.package&quot;, ie.id);</span>
            }
        }
<span class="nc" id="L287">    }</span>

    /**
     * Rewrite accesses to private fields of another class.
     */

    private Expression
    implementFieldAccess(Environment env, Context ctx, Expression base, boolean isLHS) {
<span class="nc" id="L295">        ClassDefinition abase = accessBase(env, ctx);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (abase != null) {</span>

            // If the field is final and its initializer is a constant expression,
            // then just rewrite to the constant expression. This is not just an
            // optimization, but is required for correctness.  If an expression is
            // rewritten to use an access method, then its status as a constant
            // expression is lost.  This was the cause of bug 4098737.  Note that
            // a call to 'getValue(env)' below would not be correct, as it attempts
            // to simplify the initial value expression, which must not occur until
            // after the checking phase, for example, after definite assignment checks.
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (field.isFinal()) {</span>
<span class="nc" id="L307">                Expression e = (Expression)field.getValue();</span>
                // Must not be LHS here.  Test as a precaution,
                // as we may not be careful to avoid this when
                // compiling an erroneous program.
<span class="nc bnc" id="L311" title="All 6 branches missed.">                if ((e != null) &amp;&amp; e.isConstant() &amp;&amp; !isLHS) {</span>
<span class="nc" id="L312">                    return e.copyInline(ctx);</span>
                }
            }

            //System.out.println(&quot;Finding access method for &quot; + field);
<span class="nc" id="L317">            MemberDefinition af = abase.getAccessMember(env, ctx, field, isQualSuper());</span>
            //System.out.println(&quot;Using access method &quot; + af);

<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (!isLHS) {</span>
                //System.out.println(&quot;Reading &quot; + field +
                //                              &quot; via access method &quot; + af);
                // If referencing the value of the field, then replace
                // with a call to the access method.  If assigning to
                // the field, a call to the update method will be
                // generated later. It is important that
                // 'implementation' not be set to non-null if the
                // expression is a valid assignment target.
                // (See 'checkLHS'.)
<span class="nc bnc" id="L330" title="All 2 branches missed.">                if (field.isStatic()) {</span>
<span class="nc" id="L331">                    Expression args[] = { };</span>
<span class="nc" id="L332">                    Expression call =</span>
                        new MethodExpression(where, null, af, args);
<span class="nc" id="L334">                    return new CommaExpression(where, base, call);</span>
                } else {
<span class="nc" id="L336">                    Expression args[] = { base };</span>
<span class="nc" id="L337">                    return new MethodExpression(where, null, af, args);</span>
                }
            }
        }

<span class="nc" id="L342">        return null;</span>
    }

    /**
     * Determine if an access method is required, and, if so, return
     * the class in which it should appear, else return null.
     */
    private ClassDefinition accessBase(Environment env, Context ctx) {
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (field.isPrivate()) {</span>
<span class="nc" id="L351">            ClassDefinition cdef = field.getClassDefinition();</span>
<span class="nc" id="L352">            ClassDefinition ctxClass = ctx.field.getClassDefinition();</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (cdef == ctxClass){</span>
                // If access from same class as field, then no access
                // method is needed.
<span class="nc" id="L356">                return null;</span>
            }
            // An access method is needed in the class containing the field.
<span class="nc" id="L359">            return cdef;</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">        } else if (field.isProtected()) {</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">            if (superBase == null) {</span>
                // If access is not via qualified super, then it is either
                // OK without an access method, or it is an illegal access
                // for which an error message should have been issued.
                // Legal accesses include unqualified 'super.foo'.
<span class="nc" id="L366">                return null;</span>
            }
<span class="nc" id="L368">            ClassDefinition cdef = field.getClassDefinition();</span>
<span class="nc" id="L369">            ClassDefinition ctxClass = ctx.field.getClassDefinition();</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">            if (cdef.inSamePackage(ctxClass)) {</span>
                // Access to protected member in same package always allowed.
<span class="nc" id="L372">                return null;</span>
            }
            // Access via qualified super.
            // An access method is needed in the qualifying class, an
            // immediate subclass of the class containing the selected
            // field.  NOTE: The fact that the returned class is 'superBase'
            // carries the additional bit of information (that a special
            // superclass access method is being created) which is provided
            // to 'getAccessMember' via its 'isSuper' argument.
<span class="nc" id="L381">            return superBase;</span>
        } else {
            // No access method needed.
<span class="nc" id="L384">            return null;</span>
        }
    }

    /**
     * Determine if a type is accessible from a given class.
     */
    static boolean isTypeAccessible(long where,
                                    Environment env,
                                    Type t,
                                    ClassDefinition c) {
<span class="nc bnc" id="L395" title="All 3 branches missed.">        switch (t.getTypeCode()) {</span>
          case TC_CLASS:
            try {
<span class="nc" id="L398">                Identifier nm = t.getClassName();</span>
                // Why not just use 'Environment.getClassDeclaration' here?
                // But 'Environment.getClassDeclation' has special treatment
                // for local classes that is probably necessary.  This code
                // was adapted from 'Environment.resolve'.
<span class="nc" id="L403">                ClassDefinition def = env.getClassDefinition(t);</span>
<span class="nc" id="L404">                return c.canAccess(env, def.getClassDeclaration());</span>
<span class="nc" id="L405">            } catch (ClassNotFound e) {}  // Ignore -- reported elsewhere.</span>
<span class="nc" id="L406">            return true;</span>
          case TC_ARRAY:
<span class="nc" id="L408">            return isTypeAccessible(where, env, t.getElementType(), c);</span>
          default:
<span class="nc" id="L410">            return true;</span>
        }
    }

    /**
     * Common code for checkValue and checkAmbigName
     */

    private Vset checkCommon(Environment env, Context ctx,
                             Vset vset, Hashtable exp,
                             UnaryExpression loc, boolean isLHS) {

        // Handle class literal, e.g., 'x.class'.
<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (id == idClass) {</span>

            // In 'x.class', 'x' must be a type name, possibly qualified.
<span class="nc" id="L426">            Type t = right.toType(env, ctx);</span>

<span class="nc bnc" id="L428" title="All 4 branches missed.">            if (!t.isType(TC_CLASS) &amp;&amp; !t.isType(TC_ARRAY)) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                if (t.isType(TC_ERROR)) {</span>
<span class="nc" id="L430">                    type = Type.tClassDesc;</span>
<span class="nc" id="L431">                    return vset;</span>
                }
<span class="nc" id="L433">                String wrc = null;</span>
<span class="nc bnc" id="L434" title="All 10 branches missed.">                switch (t.getTypeCode()) {</span>
<span class="nc" id="L435">                  case TC_VOID: wrc = &quot;Void&quot;; break;</span>
<span class="nc" id="L436">                  case TC_BOOLEAN: wrc = &quot;Boolean&quot;; break;</span>
<span class="nc" id="L437">                  case TC_BYTE: wrc = &quot;Byte&quot;; break;</span>
<span class="nc" id="L438">                  case TC_CHAR: wrc = &quot;Character&quot;; break;</span>
<span class="nc" id="L439">                  case TC_SHORT: wrc = &quot;Short&quot;; break;</span>
<span class="nc" id="L440">                  case TC_INT: wrc = &quot;Integer&quot;; break;</span>
<span class="nc" id="L441">                  case TC_FLOAT: wrc = &quot;Float&quot;; break;</span>
<span class="nc" id="L442">                  case TC_LONG: wrc = &quot;Long&quot;; break;</span>
<span class="nc" id="L443">                  case TC_DOUBLE: wrc = &quot;Double&quot;; break;</span>
                  default:
<span class="nc" id="L445">                      env.error(right.where, &quot;invalid.type.expr&quot;);</span>
<span class="nc" id="L446">                      return vset;</span>
                }
<span class="nc" id="L448">                Identifier wid = Identifier.lookup(idJavaLang+&quot;.&quot;+wrc);</span>
<span class="nc" id="L449">                Expression wcls = new TypeExpression(where, Type.tClass(wid));</span>
<span class="nc" id="L450">                implementation = new FieldExpression(where, wcls, idTYPE);</span>
<span class="nc" id="L451">                vset = implementation.checkValue(env, ctx, vset, exp);</span>
<span class="nc" id="L452">                type = implementation.type; // java.lang.Class</span>
<span class="nc" id="L453">                return vset;</span>
            }

            // Check for the bogus type `array of void'
<span class="nc bnc" id="L457" title="All 2 branches missed.">            if (t.isVoidArray()) {</span>
<span class="nc" id="L458">                type = Type.tClassDesc;</span>
<span class="nc" id="L459">                env.error(right.where, &quot;void.array&quot;);</span>
<span class="nc" id="L460">                return vset;</span>
            }

            // it is a class or array
<span class="nc" id="L464">            long fwhere = ctx.field.getWhere();</span>
<span class="nc" id="L465">            ClassDefinition fcls = ctx.field.getClassDefinition();</span>
<span class="nc" id="L466">            MemberDefinition lookup = fcls.getClassLiteralLookup(fwhere);</span>

<span class="nc" id="L468">            String sig = t.getTypeSignature();</span>
            String className;
<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (t.isType(TC_CLASS)) {</span>
                // sig is like &quot;Lfoo/bar;&quot;, name is like &quot;foo.bar&quot;.
                // We assume SIG_CLASS and SIG_ENDCLASS are 1 char each.
<span class="nc" id="L473">                className = sig.substring(1, sig.length()-1)</span>
<span class="nc" id="L474">                    .replace(SIGC_PACKAGE, '.');</span>
            } else {
                // sig is like &quot;[Lfoo/bar;&quot; or &quot;[I&quot;;
                // name is like &quot;[Lfoo.bar&quot; or (again) &quot;[I&quot;.
<span class="nc" id="L478">                className = sig.replace(SIGC_PACKAGE, '.');</span>
            }

<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (fcls.isInterface()) {</span>
                // The immediately-enclosing type is an interface.
                // The class literal can only appear in an initialization
                // expression, so don't bother caching it.  (This could
                // lose if many initializations use the same class literal,
                // but saves time and code space otherwise.)
<span class="nc" id="L487">                implementation =</span>
<span class="nc" id="L488">                    makeClassLiteralInlineRef(env, ctx, lookup, className);</span>
            } else {
                // Cache the call to the helper, as it may be executed
                // many times (e.g., if the class literal is inside a loop).
<span class="nc" id="L492">                ClassDefinition inClass = lookup.getClassDefinition();</span>
<span class="nc" id="L493">                MemberDefinition cfld =</span>
<span class="nc" id="L494">                    getClassLiteralCache(env, ctx, className, inClass);</span>
<span class="nc" id="L495">                implementation =</span>
<span class="nc" id="L496">                    makeClassLiteralCacheRef(env, ctx, lookup, cfld, className);</span>
            }

<span class="nc" id="L499">            vset = implementation.checkValue(env, ctx, vset, exp);</span>
<span class="nc" id="L500">            type = implementation.type; // java.lang.Class</span>
<span class="nc" id="L501">            return vset;</span>
        }

        // Arrive here if not a class literal.

<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (field != null) {</span>

            // The field as been pre-set, e.g., as the result of transforming
            // an 'IdentifierExpression'. Most error-checking has already been
            // performed at this point.
            // QUERY: Why don't we further unify checking of identifier
            // expressions and field expressions that denote instance and
            // class variables?

<span class="nc" id="L515">            implementation = implementFieldAccess(env, ctx, right, isLHS);</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">            return (right == null) ?</span>
<span class="nc" id="L517">                vset : right.checkAmbigName(env, ctx, vset, exp, this);</span>
        }

        // Does the qualifier have a meaning of its own?
<span class="nc" id="L521">        vset = right.checkAmbigName(env, ctx, vset, exp, this);</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (right.type == Type.tPackage) {</span>
            // Are we out of options?
<span class="nc bnc" id="L524" title="All 2 branches missed.">            if (loc == null) {</span>
<span class="nc" id="L525">                FieldExpression.reportFailedPackagePrefix(env, right);</span>
<span class="nc" id="L526">                return vset;</span>
            }

            // ASSERT(loc.right == this)

            // Nope.  Is this field expression a type?
<span class="nc" id="L532">            Identifier nm = toIdentifier(this);</span>
<span class="nc bnc" id="L533" title="All 4 branches missed.">            if ((nm != null) &amp;&amp; env.classExists(nm)) {</span>
<span class="nc" id="L534">                loc.right = new TypeExpression(where, Type.tClass(nm));</span>
                // Check access. (Cf. IdentifierExpression.toResolvedType.)
<span class="nc" id="L536">                ClassDefinition ctxClass = ctx.field.getClassDefinition();</span>
<span class="nc" id="L537">                env.resolve(where, ctxClass, loc.right.type);</span>
<span class="nc" id="L538">                return vset;</span>
            }

            // Let the caller make sense of it, then.
<span class="nc" id="L542">            type = Type.tPackage;</span>
<span class="nc" id="L543">            return vset;</span>
        }

        // Good; we have a well-defined qualifier type.

<span class="nc" id="L548">        ClassDefinition ctxClass = ctx.field.getClassDefinition();</span>
<span class="nc" id="L549">        boolean staticRef = (right instanceof TypeExpression);</span>

        try {

            // Handle array 'length' field, e.g., 'x.length'.

<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (!right.type.isType(TC_CLASS)) {</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">                if (right.type.isType(TC_ARRAY) &amp;&amp; id.equals(idLength)) {</span>
                    // Verify that the type of the base expression is accessible.
                    // Required by JLS 6.6.1.  Fixes 4094658.
<span class="nc bnc" id="L559" title="All 2 branches missed.">                    if (!FieldExpression.isTypeAccessible(where, env, right.type, ctxClass)) {</span>
<span class="nc" id="L560">                        ClassDeclaration cdecl = ctxClass.getClassDeclaration();</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">                        if (staticRef) {</span>
<span class="nc" id="L562">                            env.error(where, &quot;no.type.access&quot;,</span>
<span class="nc" id="L563">                                      id, right.type.toString(), cdecl);</span>
                        } else {
<span class="nc" id="L565">                            env.error(where, &quot;cant.access.member.type&quot;,</span>
<span class="nc" id="L566">                                      id, right.type.toString(), cdecl);</span>
                        }
                    }
<span class="nc" id="L569">                    type = Type.tInt;</span>
<span class="nc" id="L570">                    implementation = new LengthExpression(where, right);</span>
<span class="nc" id="L571">                    return vset;</span>
                }
<span class="nc bnc" id="L573" title="All 2 branches missed.">                if (!right.type.isType(TC_ERROR)) {</span>
<span class="nc" id="L574">                    env.error(where, &quot;invalid.field.reference&quot;, id, right.type);</span>
                }
<span class="nc" id="L576">                return vset;</span>
            }

            // At this point, we know that 'right.type' is a class type.

            // Note that '&lt;expr&gt;.super(...)' and '&lt;expr&gt;.this(...)' cases never
            // reach here.  Instead, '&lt;expr&gt;' is stored as the 'outerArg' field
            // of a 'SuperExpression' or 'ThisExpression' node.

            // If our prefix is of the form '&lt;class&gt;.super', then we are
            // about to do a field selection '&lt;class&gt;.super.&lt;field&gt;'.
            // Save the qualifying class in 'superBase', which is non-null
            // only if the current FieldExpression is a qualified 'super' form.
            // Also, set 'sourceClass' to the &quot;effective accessing class&quot; relative
            // to which access checks will be performed.  Normally, this is the
            // immediately enclosing class.  For '&lt;class&gt;.this' and '&lt;class&gt;.super',
            // however, we use &lt;class&gt;.

<span class="nc" id="L594">            ClassDefinition sourceClass = ctxClass;</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">            if (right instanceof FieldExpression) {</span>
<span class="nc" id="L596">                Identifier id = ((FieldExpression)right).id;</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">                if (id == idThis) {</span>
<span class="nc" id="L598">                    sourceClass = ((FieldExpression)right).clazz;</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">                } else if (id == idSuper) {</span>
<span class="nc" id="L600">                    sourceClass = ((FieldExpression)right).clazz;</span>
<span class="nc" id="L601">                    superBase = sourceClass;</span>
                }
            }

            // Handle 'class.this' and 'class.super'.
            //
            // Suppose 'super.name' appears within a class C with immediate
            // superclass S. According to JLS 15.10.2, 'super.name' in this
            // case is equivalent to '((S)this).name'.  Analogously, we interpret
            // 'class.super.name' as '((S)(class.this)).name', where S is the
            // immediate superclass of (enclosing) class 'class'.
            // Note that 'super' may not stand alone as an expression, but must
            // occur as the qualifying expression of a field access or a method
            // invocation.  This is enforced in 'SuperExpression.checkValue' and
            // 'FieldExpression.checkValue', and need not concern us here.

            //ClassDefinition clazz = env.getClassDefinition(right.type);
<span class="nc" id="L618">            clazz = env.getClassDefinition(right.type);</span>
<span class="nc bnc" id="L619" title="All 4 branches missed.">            if (id == idThis || id == idSuper) {</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">                if (!staticRef) {</span>
<span class="nc" id="L621">                    env.error(right.where, &quot;invalid.type.expr&quot;);</span>
                }

                // We used to check that 'right.type' is accessible here,
                // per JLS 6.6.1.  As a result of the fix for 4102393, however,
                // the qualifying class name must exactly match an enclosing
                // outer class, which is necessarily accessible.

                /*** Temporary assertion check ***/
<span class="nc bnc" id="L630" title="All 2 branches missed.">                if (ctx.field.isSynthetic())</span>
<span class="nc" id="L631">                    throw new CompilerError(&quot;synthetic qualified this&quot;);</span>
                /*********************************/

                // A.this means we're inside an A and we want its self ptr.
                // C.this is always the same as this when C is innermost.
                // Another A.this means we skip out to get a &quot;hidden&quot; this,
                // just as ASuper.foo skips out to get a hidden variable.
                // Last argument 'true' means we want an exact class match,
                // not a subclass of the specified class ('clazz').
<span class="nc" id="L640">                implementation = ctx.findOuterLink(env, where, clazz, null, true);</span>
<span class="nc" id="L641">                vset = implementation.checkValue(env, ctx, vset, exp);</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">                if (id == idSuper) {</span>
<span class="nc" id="L643">                    type = clazz.getSuperClass().getType();</span>
                } else {
<span class="nc" id="L645">                    type = clazz.getType();</span>
                }
<span class="nc" id="L647">                return vset;</span>
            }

            // Field should be an instance variable or class variable.
<span class="nc" id="L651">            field = clazz.getVariable(env, id, sourceClass);</span>

<span class="nc bnc" id="L653" title="All 6 branches missed.">            if (field == null &amp;&amp; staticRef &amp;&amp; loc != null) {</span>
                // Is this field expression an inner type?
                // Search the class and its supers (but not its outers).
                // QUERY: We may need to get the inner class from a
                // superclass of 'clazz'.  This call is prepared to
                // resolve the superclass if necessary.  Can we arrange
                // to assure that it is always previously resolved?
                // This is one of a small number of problematic calls that
                // requires 'getSuperClass' to resolve superclasses on demand.
                // See 'ClassDefinition.getInnerClass(env, nm)'.
<span class="nc" id="L663">                field = clazz.getInnerClass(env, id);</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">                if (field != null) {</span>
<span class="nc" id="L665">                    return checkInnerClass(env, ctx, vset, exp, loc);</span>
                }
            }

            // If not a variable reference, diagnose error if name is
            // that of a method.

<span class="nc bnc" id="L672" title="All 2 branches missed.">            if (field == null) {</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                if ((field = clazz.findAnyMethod(env, id)) != null) {</span>
<span class="nc" id="L674">                    env.error(where, &quot;invalid.field&quot;,</span>
<span class="nc" id="L675">                              id, field.getClassDeclaration());</span>
                } else {
<span class="nc" id="L677">                    env.error(where, &quot;no.such.field&quot;, id, clazz);</span>
                }
<span class="nc" id="L679">                return vset;</span>
            }

            // At this point, we have identified a valid field.

            // Required by JLS 6.6.1.  Fixes 4094658.
<span class="nc bnc" id="L685" title="All 2 branches missed.">            if (!FieldExpression.isTypeAccessible(where, env, right.type, sourceClass)) {</span>
<span class="nc" id="L686">                ClassDeclaration cdecl = sourceClass.getClassDeclaration();</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">                if (staticRef) {</span>
<span class="nc" id="L688">                    env.error(where, &quot;no.type.access&quot;,</span>
<span class="nc" id="L689">                              id, right.type.toString(), cdecl);</span>
                } else {
<span class="nc" id="L691">                    env.error(where, &quot;cant.access.member.type&quot;,</span>
<span class="nc" id="L692">                              id, right.type.toString(), cdecl);</span>
                }
            }

<span class="nc" id="L696">            type = field.getType();</span>

<span class="nc bnc" id="L698" title="All 2 branches missed.">            if (!sourceClass.canAccess(env, field)) {</span>
<span class="nc" id="L699">                env.error(where, &quot;no.field.access&quot;,</span>
<span class="nc" id="L700">                          id, clazz, sourceClass.getClassDeclaration());</span>
<span class="nc" id="L701">                return vset;</span>
            }

<span class="nc bnc" id="L704" title="All 4 branches missed.">            if (staticRef &amp;&amp; !field.isStatic()) {</span>
                // 'Class.field' is not legal when field is not static;
                // see JLS 15.13.1.  This case was permitted by javac
                // prior to 1.2; static refs were silently changed to
                // be dynamic access of the form 'this.field'.
<span class="nc" id="L709">                env.error(where, &quot;no.static.field.access&quot;, id, clazz);</span>
<span class="nc" id="L710">                return vset;</span>
            } else {
                // Rewrite access to use an access method if necessary.
<span class="nc" id="L713">                implementation = implementFieldAccess(env, ctx, right, isLHS);</span>
            }

            // Check for invalid access to protected field.
<span class="nc bnc" id="L717" title="All 8 branches missed.">            if (field.isProtected()</span>
                &amp;&amp; !(right instanceof SuperExpression
                     // Extension of JLS 6.6.2 for qualified 'super'.
                     || (right instanceof FieldExpression &amp;&amp;
                         ((FieldExpression)right).id == idSuper))
<span class="nc bnc" id="L722" title="All 2 branches missed.">                &amp;&amp; !sourceClass.protectedAccess(env, field, right.type)) {</span>
<span class="nc" id="L723">                env.error(where, &quot;invalid.protected.field.use&quot;,</span>
<span class="nc" id="L724">                          field.getName(), field.getClassDeclaration(),</span>
                          right.type);
<span class="nc" id="L726">                return vset;</span>
            }

<span class="nc bnc" id="L729" title="All 4 branches missed.">            if ((!field.isStatic()) &amp;&amp;</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">                (right.op == THIS) &amp;&amp; !vset.testVar(ctx.getThisNumber())) {</span>
<span class="nc" id="L731">                env.error(where, &quot;access.inst.before.super&quot;, id);</span>
            }

<span class="nc bnc" id="L734" title="All 2 branches missed.">            if (field.reportDeprecated(env)) {</span>
<span class="nc" id="L735">                env.error(where, &quot;warn.&quot;+&quot;field.is.deprecated&quot;,</span>
<span class="nc" id="L736">                          id, field.getClassDefinition());</span>
            }

            // When a package-private class defines public or protected
            // members, those members may sometimes be accessed from
            // outside of the package in public subclasses.  In these
            // cases, we need to massage the getField to refer to
            // to an accessible subclass rather than the package-private
            // parent class.  Part of fix for 4135692.

            // Find out if the class which contains this field
            // reference has access to the class which declares the
            // public or protected field.
<span class="nc bnc" id="L749" title="All 2 branches missed.">            if (sourceClass == ctxClass) {</span>
<span class="nc" id="L750">                ClassDefinition declarer = field.getClassDefinition();</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">                if (declarer.isPackagePrivate() &amp;&amp;</span>
<span class="nc" id="L752">                    !declarer.getName().getQualifier()</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                    .equals(sourceClass.getName().getQualifier())) {</span>

                    //System.out.println(&quot;The access of member &quot; +
                    //             field + &quot; declared in class &quot; +
                    //             declarer +
                    //             &quot; is not allowed by the VM from class  &quot; +
                    //             ctxClass +
                    //             &quot;.  Replacing with an access of class &quot; +
                    //             clazz);

                    // We cannot make this access at the VM level.
                    // Construct a member which will stand for this
                    // field in ctxClass and set `field' to refer to it.
<span class="nc" id="L766">                    field =</span>
<span class="nc" id="L767">                        MemberDefinition.makeProxyMember(field, clazz, env);</span>
                }
            }

<span class="nc" id="L771">            sourceClass.addDependency(field.getClassDeclaration());</span>

<span class="nc" id="L773">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L774">            env.error(where, &quot;class.not.found&quot;, e.name, ctx.field);</span>

<span class="nc" id="L776">        } catch (AmbiguousMember e) {</span>
<span class="nc" id="L777">            env.error(where, &quot;ambig.field&quot;,</span>
<span class="nc" id="L778">                      id, e.field1.getClassDeclaration(), e.field2.getClassDeclaration());</span>
<span class="nc" id="L779">        }</span>
<span class="nc" id="L780">        return vset;</span>
    }

    /**
     * Return a &lt;code&gt;FieldUpdater&lt;/code&gt; object to be used in updating the
     * value of the location denoted by &lt;code&gt;this&lt;/code&gt;, which must be an
     * expression suitable for the left-hand side of an assignment.
     * This is used for implementing assignments to private fields for which
     * an access method is required.  Returns null if no access method is
     * needed, in which case the assignment is handled in the usual way, by
     * direct access.  Only simple assignment expressions are handled here
     * Assignment operators and pre/post increment/decrement operators are
     * are handled by 'getUpdater' below.
     * &lt;p&gt;
     * Must be called after 'checkValue', else 'right' will be invalid.
     */


    public FieldUpdater getAssigner(Environment env, Context ctx) {
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (field == null) {</span>
            // Field can legitimately be null if the field name was
            // undefined, in which case an error was reported, but
            // no value for 'field' is available.
            //   throw new CompilerError(&quot;getAssigner&quot;);
<span class="nc" id="L804">            return null;</span>
        }
<span class="nc" id="L806">        ClassDefinition abase = accessBase(env, ctx);</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">        if (abase != null) {</span>
<span class="nc" id="L808">            MemberDefinition setter = abase.getUpdateMember(env, ctx, field, isQualSuper());</span>
            // It may not be necessary to copy 'right' here.
<span class="nc bnc" id="L810" title="All 2 branches missed.">            Expression base = (right == null) ? null : right.copyInline(ctx);</span>
            // Created 'FieldUpdater' has no getter method.
<span class="nc" id="L812">            return new FieldUpdater(where, field, base, null, setter);</span>
        }
<span class="nc" id="L814">        return null;</span>
    }

    /**
     * Return a &lt;code&gt;FieldUpdater&lt;/code&gt; object to be used in updating the
     * value of the location denoted by &lt;code&gt;this&lt;/code&gt;, which must be an
     * expression suitable for the left-hand side of an assignment.  This is
     * used for implementing the assignment operators and the increment and
     * decrement operators on private fields that are accessed from another
     * class, e.g, uplevel from an inner class. Returns null if no access
     * method is needed.
     * &lt;p&gt;
     * Must be called after 'checkValue', else 'right' will be invalid.
     */

    public FieldUpdater getUpdater(Environment env, Context ctx) {
<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (field == null) {</span>
            // Field can legitimately be null if the field name was
            // undefined, in which case an error was reported, but
            // no value for 'field' is available.
            //   throw new CompilerError(&quot;getUpdater&quot;);
<span class="nc" id="L835">            return null;</span>
        }
<span class="nc" id="L837">        ClassDefinition abase = accessBase(env, ctx);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">        if (abase != null) {</span>
<span class="nc" id="L839">            MemberDefinition getter = abase.getAccessMember(env, ctx, field, isQualSuper());</span>
<span class="nc" id="L840">            MemberDefinition setter = abase.getUpdateMember(env, ctx, field, isQualSuper());</span>
            // It may not be necessary to copy 'right' here.
<span class="nc bnc" id="L842" title="All 2 branches missed.">            Expression base = (right == null) ? null : right.copyInline(ctx);</span>
<span class="nc" id="L843">            return new FieldUpdater(where, field, base, getter, setter);</span>
        }
<span class="nc" id="L845">        return null;</span>
    }

    /**
     * This field expression is an inner class reference.
     * Finish checking it.
     */
    private Vset checkInnerClass(Environment env, Context ctx,
                                 Vset vset, Hashtable exp,
                                 UnaryExpression loc) {
<span class="nc" id="L855">        ClassDefinition inner = field.getInnerClass();</span>
<span class="nc" id="L856">        type = inner.getType();</span>

<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (!inner.isTopLevel()) {</span>
<span class="nc" id="L859">            env.error(where, &quot;inner.static.ref&quot;, inner.getName());</span>
        }

<span class="nc" id="L862">        Expression te = new TypeExpression(where, type);</span>

        // check access
<span class="nc" id="L865">        ClassDefinition ctxClass = ctx.field.getClassDefinition();</span>
        try {
<span class="nc bnc" id="L867" title="All 2 branches missed.">            if (!ctxClass.canAccess(env, field)) {</span>
<span class="nc" id="L868">                ClassDefinition clazz = env.getClassDefinition(right.type);</span>
                //env.error(where, &quot;no.type.access&quot;,
                //          id, clazz, ctx.field.getClassDeclaration());
<span class="nc" id="L871">                env.error(where, &quot;no.type.access&quot;,</span>
<span class="nc" id="L872">                          id, clazz, ctxClass.getClassDeclaration());</span>
<span class="nc" id="L873">                return vset;</span>
            }

<span class="nc bnc" id="L876" title="All 8 branches missed.">            if (field.isProtected()</span>
                &amp;&amp; !(right instanceof SuperExpression
                     // Extension of JLS 6.6.2 for qualified 'super'.
                     || (right instanceof FieldExpression &amp;&amp;
                         ((FieldExpression)right).id == idSuper))
<span class="nc bnc" id="L881" title="All 2 branches missed.">                &amp;&amp; !ctxClass.protectedAccess(env, field, right.type)){</span>
<span class="nc" id="L882">                env.error(where, &quot;invalid.protected.field.use&quot;,</span>
<span class="nc" id="L883">                          field.getName(), field.getClassDeclaration(),</span>
                          right.type);
<span class="nc" id="L885">                return vset;</span>
            }

<span class="nc" id="L888">            inner.noteUsedBy(ctxClass, where, env);</span>

<span class="nc" id="L890">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L891">            env.error(where, &quot;class.not.found&quot;, e.name, ctx.field);</span>
<span class="nc" id="L892">        }</span>

<span class="nc" id="L894">        ctxClass.addDependency(field.getClassDeclaration());</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">        if (loc == null)</span>
            // Complain about a free-floating type name.
<span class="nc" id="L897">            return te.checkValue(env, ctx, vset, exp);</span>
<span class="nc" id="L898">        loc.right = te;</span>
<span class="nc" id="L899">        return vset;</span>
    }

    /**
     * Check the expression if it appears on the LHS of an assignment
     */
    public Vset checkLHS(Environment env, Context ctx,
                         Vset vset, Hashtable exp) {
<span class="nc bnc" id="L907" title="All 2 branches missed.">        boolean hadField = (field != null);</span>

        //checkValue(env, ctx, vset, exp);
<span class="nc" id="L910">        checkCommon(env, ctx, vset, exp, null, true);</span>

        // If 'implementation' is set to a non-null value, then the
        // field expression does not denote an assignable location,
        // e.g., the 'length' field of an array.
<span class="nc bnc" id="L915" title="All 2 branches missed.">        if (implementation != null) {</span>
            // This just reports an error and recovers.
<span class="nc" id="L917">            return super.checkLHS(env, ctx, vset, exp);</span>
        }

<span class="nc bnc" id="L920" title="All 6 branches missed.">        if (field != null &amp;&amp; field.isFinal() &amp;&amp; !hadField) {</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">            if (field.isBlankFinal()) {</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">                if (field.isStatic()) {</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">                    if (right != null) {</span>
<span class="nc" id="L924">                        env.error(where, &quot;qualified.static.final.assign&quot;);</span>
                    }
                    // Continue with checking anyhow.
                    // In fact, it would be easy to allow this case.
                } else {
<span class="nc bnc" id="L929" title="All 4 branches missed.">                    if ((right != null) &amp;&amp; (right.op != THIS)) {</span>
<span class="nc" id="L930">                        env.error(where, &quot;bad.qualified.final.assign&quot;, field.getName());</span>
                        // The actual instance could be anywhere, so don't
                        // continue with checking the definite assignment status.
<span class="nc" id="L933">                        return vset;</span>
                    }
                }
<span class="nc" id="L936">                vset = checkFinalAssign(env, ctx, vset, where, field);</span>
            } else {
<span class="nc" id="L938">                env.error(where, &quot;assign.to.final&quot;, id);</span>
            }
        }
<span class="nc" id="L941">        return vset;</span>
    }

    /**
     * Check the expression if it appears on the LHS of an op= expression
     */
    public Vset checkAssignOp(Environment env, Context ctx,
                              Vset vset, Hashtable exp, Expression outside) {

        //checkValue(env, ctx, vset, exp);
<span class="nc" id="L951">        checkCommon(env, ctx, vset, exp, null, true);</span>

        // If 'implementation' is set to a non-null value, then the
        // field expression does not denote an assignable location,
        // e.g., the 'length' field of an array.
<span class="nc bnc" id="L956" title="All 2 branches missed.">        if (implementation != null) {</span>
<span class="nc" id="L957">            return super.checkLHS(env, ctx, vset, exp);</span>
        }
<span class="nc bnc" id="L959" title="All 4 branches missed.">        if (field != null &amp;&amp; field.isFinal()) {</span>
<span class="nc" id="L960">            env.error(where, &quot;assign.to.final&quot;, id);</span>
        }
<span class="nc" id="L962">        return vset;</span>
    }

    /**
     * There is a simple assignment being made to the given final field.
     * The field was named either by a simple name or by an almost-simple
     * expression of the form &quot;this.v&quot;.
     * Check if this is a legal assignment.
     * &lt;p&gt;
     * Blank final variables can be set in initializers or constructor
     * bodies.  In all cases there must be definite single assignment.
     * (All instance and instance variable initializers and each
     * constructor body are treated as if concatenated for the purposes
     * of this check.  Assignment to &quot;this.x&quot; is treated as a definite
     * assignment to the simple name &quot;x&quot; which names the instance variable.)
     */

    public static Vset checkFinalAssign(Environment env, Context ctx,
                                        Vset vset, long where,
                                        MemberDefinition field) {
<span class="nc bnc" id="L982" title="All 2 branches missed.">        if (field.isBlankFinal()</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">            &amp;&amp; field.getClassDefinition() == ctx.field.getClassDefinition()) {</span>
<span class="nc" id="L984">            int number = ctx.getFieldNumber(field);</span>
<span class="nc bnc" id="L985" title="All 4 branches missed.">            if (number &gt;= 0 &amp;&amp; vset.testVarUnassigned(number)) {</span>
                // definite single assignment
<span class="nc" id="L987">                vset = vset.addVar(number);</span>
            } else {
                // it is a blank final in this class, but not assignable
<span class="nc" id="L990">                Identifier id = field.getName();</span>
<span class="nc" id="L991">                env.error(where, &quot;assign.to.blank.final&quot;, id);</span>
            }
<span class="nc" id="L993">        } else {</span>
            // give the generic error message
<span class="nc" id="L995">            Identifier id = field.getName();</span>
<span class="nc" id="L996">            env.error(where, &quot;assign.to.final&quot;, id);</span>
        }
<span class="nc" id="L998">        return vset;</span>
    }

    private static MemberDefinition getClassLiteralCache(Environment env,
                                                         Context ctx,
                                                         String className,
                                                         ClassDefinition c) {
        // Given a class name, look for a static field to cache it.
        //      className       lname
        //      pkg.Foo         class$pkg$Foo
        //      [Lpkg.Foo;      array$Lpkg$Foo
        //      [[Lpkg.Foo;     array$$Lpkg$Foo
        //      [I              array$I
        //      [[I             array$$I
        String lname;
<span class="nc bnc" id="L1013" title="All 2 branches missed.">        if (!className.startsWith(SIG_ARRAY)) {</span>
<span class="nc" id="L1014">            lname = prefixClass + className.replace('.', '$');</span>
        } else {
<span class="nc" id="L1016">            lname = prefixArray + className.substring(1);</span>
<span class="nc" id="L1017">            lname = lname.replace(SIGC_ARRAY, '$'); // [[[I =&gt; array$$$I</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            if (className.endsWith(SIG_ENDCLASS)) {</span>
                // [Lpkg.Foo; =&gt; array$Lpkg$Foo
<span class="nc" id="L1020">                lname = lname.substring(0, lname.length() - 1);</span>
<span class="nc" id="L1021">                lname = lname.replace('.', '$');</span>
            }
            // else [I =&gt; array$I or some such; lname is already OK
        }
<span class="nc" id="L1025">        Identifier fname = Identifier.lookup(lname);</span>

        // The class to put the cache in is now given as an argument.
        //
        // ClassDefinition c = ctx.field.getClassDefinition();
        // while (c.isInnerClass()) {
        //     c = c.getOuterClass();

        MemberDefinition cfld;
        try {
<span class="nc" id="L1035">            cfld = c.getVariable(env, fname, c);</span>
<span class="nc" id="L1036">        } catch (ClassNotFound ee) {</span>
<span class="nc" id="L1037">            return null;</span>
<span class="nc" id="L1038">        } catch (AmbiguousMember ee) {</span>
<span class="nc" id="L1039">            return null;</span>
<span class="nc" id="L1040">        }</span>

        // Ignore inherited field.  Each top-level class
        // containing a given class literal must have its own copy,
        // both for reasons of binary compatibility and to prevent
        // access violations should the superclass be in another
        // package.  Part of fix 4106051.
<span class="nc bnc" id="L1047" title="All 4 branches missed.">        if (cfld != null &amp;&amp; cfld.getClassDefinition() == c) {</span>
<span class="nc" id="L1048">            return cfld;</span>
        }

        // Since each class now has its own copy, we might as well
        // tighten up the access to private (previously default).
        // Part of fix for 4106051.
        // ** Temporarily retract this, as it tickles 4098316.
<span class="nc" id="L1055">        return env.makeMemberDefinition(env, c.getWhere(),</span>
                                        c, null,
                                        M_STATIC | M_SYNTHETIC, // M_PRIVATE,
                                        Type.tClassDesc, fname,
                                        null, null, null);
    }

    private Expression makeClassLiteralCacheRef(Environment env, Context ctx,
                                                MemberDefinition lookup,
                                                MemberDefinition cfld,
                                                String className) {
<span class="nc" id="L1066">        Expression ccls = new TypeExpression(where,</span>
<span class="nc" id="L1067">                                             cfld.getClassDefinition()</span>
<span class="nc" id="L1068">                                             .getType());</span>
<span class="nc" id="L1069">        Expression cache = new FieldExpression(where, ccls, cfld);</span>
<span class="nc" id="L1070">        Expression cacheOK =</span>
<span class="nc" id="L1071">            new NotEqualExpression(where, cache.copyInline(ctx),</span>
                                   new NullExpression(where));
<span class="nc" id="L1073">        Expression lcls =</span>
<span class="nc" id="L1074">            new TypeExpression(where, lookup.getClassDefinition() .getType());</span>
<span class="nc" id="L1075">        Expression name = new StringExpression(where, className);</span>
<span class="nc" id="L1076">        Expression namearg[] = { name };</span>
<span class="nc" id="L1077">        Expression setCache = new MethodExpression(where, lcls,</span>
                                                   lookup, namearg);
<span class="nc" id="L1079">        setCache = new AssignExpression(where, cache.copyInline(ctx),</span>
                                        setCache);
<span class="nc" id="L1081">        return new ConditionalExpression(where, cacheOK, cache, setCache);</span>
    }

    private Expression makeClassLiteralInlineRef(Environment env, Context ctx,
                                                 MemberDefinition lookup,
                                                 String className) {
<span class="nc" id="L1087">        Expression lcls =</span>
<span class="nc" id="L1088">            new TypeExpression(where, lookup.getClassDefinition().getType());</span>
<span class="nc" id="L1089">        Expression name = new StringExpression(where, className);</span>
<span class="nc" id="L1090">        Expression namearg[] = { name };</span>
<span class="nc" id="L1091">        Expression getClass = new MethodExpression(where, lcls,</span>
                                                   lookup, namearg);
<span class="nc" id="L1093">        return getClass;</span>
    }


    /**
     * Check if constant:  Will it inline away?
     */
    public boolean isConstant() {
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L1102">            return implementation.isConstant();</span>
<span class="nc bnc" id="L1103" title="All 10 branches missed.">        if ((field != null)</span>
            &amp;&amp; (right == null || right instanceof TypeExpression
                || (right.op == THIS &amp;&amp; right.where == where))) {
<span class="nc" id="L1106">            return field.isConstant();</span>
        }
<span class="nc" id="L1108">        return false;</span>
    }

    /**
     * Inline
     */
    public Expression inline(Environment env, Context ctx) {
<span class="nc bnc" id="L1115" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L1116">            return implementation.inline(env, ctx);</span>
        // A field expression may have the side effect of causing
        // a NullPointerException, so evaluate it even though
        // the value is not needed.  Similarly, static field dereferences
        // may cause class initialization, so they mustn't be omitted
        // either.
        //
        // However, NullPointerException can't happen and initialization must
        // already have occurred if you are dotting into 'this'.  So
        // allow fields of 'this' to be eliminated as a special case.
<span class="nc" id="L1126">        Expression e = inlineValue(env, ctx);</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        if (e instanceof FieldExpression) {</span>
<span class="nc" id="L1128">            FieldExpression fe = (FieldExpression) e;</span>
<span class="nc bnc" id="L1129" title="All 4 branches missed.">            if ((fe.right != null) &amp;&amp; (fe.right.op==THIS))</span>
<span class="nc" id="L1130">                return null;</span>
            // It should be possible to split this into two checks: one using
            // isNonNull() for non-statics and a different check for statics.
            // That would make the inlining slightly less conservative by
            // allowing, for example, dotting into String constants.
            }
<span class="nc" id="L1136">        return e;</span>
    }
    public Expression inlineValue(Environment env, Context ctx) {
<span class="nc bnc" id="L1139" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L1140">            return implementation.inlineValue(env, ctx);</span>
        try {
<span class="nc bnc" id="L1142" title="All 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L1143">                return this;</span>
            }

<span class="nc bnc" id="L1146" title="All 2 branches missed.">            if (field.isFinal()) {</span>
<span class="nc" id="L1147">                Expression e = (Expression)field.getValue(env);</span>
<span class="nc bnc" id="L1148" title="All 4 branches missed.">                if ((e != null) &amp;&amp; e.isConstant()) {</span>
                    // remove bogus line-number info
<span class="nc" id="L1150">                    e = e.copyInline(ctx);</span>
<span class="nc" id="L1151">                    e.where = where;</span>
<span class="nc" id="L1152">                    return new CommaExpression(where, right, e).inlineValue(env, ctx);</span>
                }
            }

<span class="nc bnc" id="L1156" title="All 2 branches missed.">            if (right != null) {</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">                if (field.isStatic()) {</span>
<span class="nc" id="L1158">                    Expression e = right.inline(env, ctx);</span>
<span class="nc" id="L1159">                    right = null;</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">                    if (e != null) {</span>
<span class="nc" id="L1161">                        return new CommaExpression(where, e, this);</span>
                    }
<span class="nc" id="L1163">                } else {</span>
<span class="nc" id="L1164">                    right = right.inlineValue(env, ctx);</span>
                }
            }
<span class="nc" id="L1167">            return this;</span>

<span class="nc" id="L1169">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L1170">            throw new CompilerError(e);</span>
        }
    }
    public Expression inlineLHS(Environment env, Context ctx) {
<span class="nc bnc" id="L1174" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L1175">            return implementation.inlineLHS(env, ctx);</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">        if (right != null) {</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">            if (field.isStatic()) {</span>
<span class="nc" id="L1178">                Expression e = right.inline(env, ctx);</span>
<span class="nc" id="L1179">                right = null;</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">                if (e != null) {</span>
<span class="nc" id="L1181">                    return new CommaExpression(where, e, this);</span>
                }
<span class="nc" id="L1183">            } else {</span>
<span class="nc" id="L1184">                right = right.inlineValue(env, ctx);</span>
            }
        }
<span class="nc" id="L1187">        return this;</span>
    }

    public Expression copyInline(Context ctx) {
<span class="nc bnc" id="L1191" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L1192">            return implementation.copyInline(ctx);</span>
<span class="nc" id="L1193">        return super.copyInline(ctx);</span>
    }

    /**
     * The cost of inlining this expression
     */
    public int costInline(int thresh, Environment env, Context ctx) {
<span class="nc bnc" id="L1200" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L1201">            return implementation.costInline(thresh, env, ctx);</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">        if (ctx == null) {</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">            return 3 + ((right == null) ? 0</span>
<span class="nc" id="L1204">                                        : right.costInline(thresh, env, ctx));</span>
        }
        // ctxClass is the current class trying to inline this method
<span class="nc" id="L1207">        ClassDefinition ctxClass = ctx.field.getClassDefinition();</span>
        try {
            // We only allow the inlining if the current class can access
            // the field, the field's class, and right's declared type.
<span class="nc bnc" id="L1211" title="All 2 branches missed.">            if (    ctxClass.permitInlinedAccess(env, field.getClassDeclaration())</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">                 &amp;&amp; ctxClass.permitInlinedAccess(env, field)) {</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">                if (right == null) {</span>
<span class="nc" id="L1214">                    return 3;</span>
                } else {
<span class="nc" id="L1216">                    ClassDeclaration rt = env.getClassDeclaration(right.type);</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">                    if (ctxClass.permitInlinedAccess(env, rt)) {</span>
<span class="nc" id="L1218">                        return 3 + right.costInline(thresh, env, ctx);</span>
                    }
                }
            }
<span class="nc" id="L1222">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L1223">        }</span>
<span class="nc" id="L1224">        return thresh;</span>
    }

    /**
     * Code
     */
    int codeLValue(Environment env, Context ctx, Assembler asm) {
<span class="nc bnc" id="L1231" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L1232">            throw new CompilerError(&quot;codeLValue&quot;);</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">        if (field.isStatic()) {</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">            if (right != null) {</span>
<span class="nc" id="L1235">                right.code(env, ctx, asm);</span>
<span class="nc" id="L1236">                return 1;</span>
            }
<span class="nc" id="L1238">            return 0;</span>
        }
<span class="nc" id="L1240">        right.codeValue(env, ctx, asm);</span>
<span class="nc" id="L1241">        return 1;</span>
    }
    void codeLoad(Environment env, Context ctx, Assembler asm) {
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L1245">            throw new CompilerError(&quot;should not be null&quot;);</span>
        }
<span class="nc bnc" id="L1247" title="All 2 branches missed.">        if (field.isStatic()) {</span>
<span class="nc" id="L1248">            asm.add(where, opc_getstatic, field);</span>
        } else {
<span class="nc" id="L1250">            asm.add(where, opc_getfield, field);</span>
        }
<span class="nc" id="L1252">    }</span>
    void codeStore(Environment env, Context ctx, Assembler asm) {
<span class="nc bnc" id="L1254" title="All 2 branches missed.">        if (field.isStatic()) {</span>
<span class="nc" id="L1255">            asm.add(where, opc_putstatic, field);</span>
        } else {
<span class="nc" id="L1257">            asm.add(where, opc_putfield, field);</span>
        }
<span class="nc" id="L1259">    }</span>

    public void codeValue(Environment env, Context ctx, Assembler asm) {
<span class="nc" id="L1262">        codeLValue(env, ctx, asm);</span>
<span class="nc" id="L1263">        codeLoad(env, ctx, asm);</span>
<span class="nc" id="L1264">    }</span>

    /**
     * Print
     */
    public void print(PrintStream out) {
<span class="nc" id="L1270">        out.print(&quot;(&quot;);</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">        if (right != null) {</span>
<span class="nc" id="L1272">            right.print(out);</span>
        } else {
<span class="nc" id="L1274">            out.print(&quot;&lt;empty&gt;&quot;);</span>
        }
<span class="nc" id="L1276">        out.print(&quot;.&quot; + id + &quot;)&quot;);</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">        if (implementation != null) {</span>
<span class="nc" id="L1278">            out.print(&quot;/IMPL=&quot;);</span>
<span class="nc" id="L1279">            implementation.print(out);</span>
        }
<span class="nc" id="L1281">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>