<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>VarDeclarationStatement.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.tree</a> &gt; <span class="el_source">VarDeclarationStatement.java</span></div><h1>VarDeclarationStatement.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.tree;

import sun.tools.java.*;
import sun.tools.asm.Assembler;
import sun.tools.asm.LocalVariable;
import java.io.PrintStream;
import java.util.Hashtable;

/**
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public
class VarDeclarationStatement extends Statement {
    LocalMember field;
    Expression expr;

    /**
     * Constructor
     */
    public VarDeclarationStatement(long where, Expression expr) {
<span class="nc" id="L48">        super(VARDECLARATION, where);</span>
<span class="nc" id="L49">        this.expr = expr;</span>
<span class="nc" id="L50">    }</span>
    public VarDeclarationStatement(long where, LocalMember field, Expression expr) {
<span class="nc" id="L52">        super(VARDECLARATION, where);</span>
<span class="nc" id="L53">        this.field = field;</span>
<span class="nc" id="L54">        this.expr = expr;</span>
<span class="nc" id="L55">    }</span>

    /**
     * Check statement
     */
    Vset checkDeclaration(Environment env, Context ctx, Vset vset, int mod, Type t, Hashtable exp) {
<span class="nc bnc" id="L61" title="All 2 branches missed.">        if (labels != null) {</span>
<span class="nc" id="L62">            env.error(where, &quot;declaration.with.label&quot;, labels[0]);</span>
        }
<span class="nc bnc" id="L64" title="All 2 branches missed.">        if (field != null) {</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">            if (ctx.getLocalClass(field.getName()) != null</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">                &amp;&amp; field.isInnerClass()) {</span>
<span class="nc" id="L67">                env.error(where, &quot;local.class.redefined&quot;, field.getName());</span>
            }

<span class="nc" id="L70">            ctx.declare(env, field);</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">            if (field.isInnerClass()) {</span>
<span class="nc" id="L72">                ClassDefinition body = field.getInnerClass();</span>
                try {
<span class="nc" id="L74">                    vset = body.checkLocalClass(env, ctx, vset,</span>
                                                null, null, null);
<span class="nc" id="L76">                } catch (ClassNotFound ee) {</span>
<span class="nc" id="L77">                    env.error(where, &quot;class.not.found&quot;, ee.name, opNames[op]);</span>
<span class="nc" id="L78">                }</span>
<span class="nc" id="L79">                return vset;</span>
            }
<span class="nc" id="L81">            vset.addVar(field.number);</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">            return (expr != null) ? expr.checkValue(env, ctx, vset, exp) : vset;</span>
        }

        // Argument 'expr' is either an IdentifierExpression for a declaration of
        // the form 'type x' or an AssignmentExpression for a declaration of the
        // form 'type x = initvalue'.  Note that these expressions are treated
        // specially in this context, and don't have much connection to their ordinary
        // meaning.

<span class="nc" id="L91">        Expression e = expr;</span>

<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (e.op == ASSIGN) {</span>
<span class="nc" id="L94">            expr = ((AssignExpression)e).right;</span>
<span class="nc" id="L95">            e = ((AssignExpression)e).left;</span>
        } else {
<span class="nc" id="L97">            expr = null;</span>
        }

<span class="nc" id="L100">        boolean declError = t.isType(TC_ERROR);</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        while (e.op == ARRAYACCESS) {</span>
<span class="nc" id="L102">            ArrayAccessExpression array = (ArrayAccessExpression)e;</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            if (array.index != null) {</span>
<span class="nc" id="L104">                env.error(array.index.where, &quot;array.dim.in.type&quot;);</span>
<span class="nc" id="L105">                declError = true;</span>
            }
<span class="nc" id="L107">            e = array.right;</span>
<span class="nc" id="L108">            t = Type.tArray(t);</span>
<span class="nc" id="L109">        }</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (e.op == IDENT) {</span>
<span class="nc" id="L111">            Identifier id = ((IdentifierExpression)e).id;</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">            if (ctx.getLocalField(id) != null) {</span>
<span class="nc" id="L113">                env.error(where, &quot;local.redefined&quot;, id);</span>
            }

<span class="nc" id="L116">            field = new LocalMember(e.where, ctx.field.getClassDefinition(), mod, t, id);</span>
<span class="nc" id="L117">            ctx.declare(env, field);</span>

<span class="nc bnc" id="L119" title="All 2 branches missed.">            if (expr != null) {</span>
<span class="nc" id="L120">                vset = expr.checkInitializer(env, ctx, vset, t, exp);</span>
<span class="nc" id="L121">                expr = convert(env, ctx, t, expr);</span>
<span class="nc" id="L122">                field.setValue(expr); // for the sake of non-blank finals</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                if (field.isConstant()) {</span>
                    // Keep in mind that isConstant() only means expressions
                    // that are constant according to the JLS.  They might
                    // not be either constants or evaluable (eg. 1/0).
<span class="nc" id="L127">                    field.addModifiers(M_INLINEABLE);</span>
                }
<span class="nc" id="L129">                vset.addVar(field.number);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            } else if (declError) {</span>
<span class="nc" id="L131">                vset.addVar(field.number);</span>
            } else {
<span class="nc" id="L133">                vset.addVarUnassigned(field.number);</span>
            }
<span class="nc" id="L135">            return vset;</span>
        }
<span class="nc" id="L137">        env.error(e.where, &quot;invalid.decl&quot;);</span>
<span class="nc" id="L138">        return vset;</span>
    }

    /**
     * Inline
     */
    public Statement inline(Environment env, Context ctx) {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (field.isInnerClass()) {</span>
<span class="nc" id="L146">            ClassDefinition body = field.getInnerClass();</span>
<span class="nc" id="L147">            body.inlineLocalClass(env);</span>
<span class="nc" id="L148">            return null;</span>
        }

        // Don't generate code for variable if unused and
        // optimization is on, whether or not debugging is on
<span class="nc bnc" id="L153" title="All 4 branches missed.">        if (env.opt() &amp;&amp; !field.isUsed()) {</span>
<span class="nc" id="L154">            return new ExpressionStatement(where, expr).inline(env, ctx);</span>
        }

<span class="nc" id="L157">        ctx.declare(env, field);</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (expr != null) {</span>
<span class="nc" id="L160">            expr = expr.inlineValue(env, ctx);</span>
<span class="nc" id="L161">            field.setValue(expr); // for the sake of non-blank finals</span>
<span class="nc bnc" id="L162" title="All 4 branches missed.">            if (env.opt() &amp;&amp; (field.writecount == 0)) {</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">                if (expr.op == IDENT) {</span>

                    // This code looks like it tests whether a final variable
                    // is being initialized by an identifier expression.
                    // Then if the identifier is a local of the same method
                    // it makes the final variable eligible to be inlined.
                    // BUT: why isn't the local also checked to make sure
                    // it is itself final?  Unknown.

<span class="nc" id="L172">                    IdentifierExpression e = (IdentifierExpression)expr;</span>
<span class="nc bnc" id="L173" title="All 6 branches missed.">                    if (e.field.isLocal() &amp;&amp; ((ctx = ctx.getInlineContext()) != null) &amp;&amp;</span>
                        (((LocalMember)e.field).number &lt; ctx.varNumber)) {
                        //System.out.println(&quot;FINAL IDENT = &quot; + field + &quot; in &quot; + ctx.field);
<span class="nc" id="L176">                        field.setValue(expr);</span>
<span class="nc" id="L177">                        field.addModifiers(M_INLINEABLE);</span>

                        // The two lines below used to elide the declaration
                        // of inlineable variables, on the theory that there
                        // wouldn't be any references.  But this breaks the
                        // translation of nested classes, which might refer to
                        // the variable.

                        //expr = null;
                        //return null;
                    }
                }
<span class="nc bnc" id="L189" title="All 6 branches missed.">                if (expr.isConstant() || (expr.op == THIS) || (expr.op == SUPER)) {</span>
                    //System.out.println(&quot;FINAL = &quot; + field + &quot; in &quot; + ctx.field);
<span class="nc" id="L191">                    field.setValue(expr);</span>
<span class="nc" id="L192">                    field.addModifiers(M_INLINEABLE);</span>

                    // The two lines below used to elide the declaration
                    // of inlineable variables, on the theory that there
                    // wouldn't be any references.  But this breaks the
                    // translation of nested classes, which might refer to
                    // the variable.  Fix for 4073244.

                    //expr = null;
                    //return null;
                }
            }
        }
<span class="nc" id="L205">        return this;</span>
    }

    /**
     * Create a copy of the statement for method inlining
     */
    public Statement copyInline(Context ctx, boolean valNeeded) {
<span class="nc" id="L212">        VarDeclarationStatement s = (VarDeclarationStatement)clone();</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (expr != null) {</span>
<span class="nc" id="L214">            s.expr = expr.copyInline(ctx);</span>
        }
<span class="nc" id="L216">        return s;</span>
    }

    /**
     * The cost of inlining this statement
     */
    public int costInline(int thresh, Environment env, Context ctx) {
<span class="nc bnc" id="L223" title="All 4 branches missed.">        if (field != null &amp;&amp; field.isInnerClass()) {</span>
<span class="nc" id="L224">            return thresh;      // don't copy classes...</span>
        }
<span class="nc bnc" id="L226" title="All 2 branches missed.">        return (expr != null) ? expr.costInline(thresh, env, ctx) : 0;</span>
    }

    /**
     * Code
     */
    public void code(Environment env, Context ctx, Assembler asm) {
<span class="nc bnc" id="L233" title="All 4 branches missed.">        if (expr != null &amp;&amp; !expr.type.isType(TC_VOID)) {</span>
            // The two lines of code directly following this comment used
            // to be in the opposite order.  They were switched so that
            // lines like the following:
            //
            //     int j = (j = 4);
            //
            // will compile correctly.  (Constructions like the above are
            // legal.  JLS 14.3.2 says that the scope of a local variable
            // includes its own initializer.)  It is important that we
            // declare `field' before we code `expr', because otherwise
            // situations can arise where `field' thinks it is assigned
            // a local variable slot that is, in actuality, assigned to
            // an entirely different variable.  (Bug id 4076729)
<span class="nc" id="L247">            ctx.declare(env, field);</span>
<span class="nc" id="L248">            expr.codeValue(env, ctx, asm);</span>

<span class="nc" id="L250">            asm.add(where, opc_istore + field.getType().getTypeCodeOffset(),</span>
                    new LocalVariable(field, field.number));
        } else {
<span class="nc" id="L253">            ctx.declare(env, field);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (expr != null) {</span>
                // an initial side effect, rather than an initial value
<span class="nc" id="L256">                expr.code(env, ctx, asm);</span>
            }
        }
<span class="nc" id="L259">    }</span>

    /**
     * Print
     */
    public void print(PrintStream out, int indent) {
<span class="nc" id="L265">        out.print(&quot;local &quot;);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (field != null) {</span>
<span class="nc" id="L267">            out.print(field + &quot;#&quot; + field.hashCode());</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (expr != null) {</span>
<span class="nc" id="L269">                out.print(&quot; = &quot;);</span>
<span class="nc" id="L270">                expr.print(out);</span>
            }
        } else {
<span class="nc" id="L273">            expr.print(out);</span>
<span class="nc" id="L274">            out.print(&quot;;&quot;);</span>
        }
<span class="nc" id="L276">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>