<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>UplevelReference.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.tree</a> &gt; <span class="el_source">UplevelReference.java</span></div><h1>UplevelReference.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.tree;

import sun.tools.java.*;
import sun.tools.tree.*;
import sun.tools.asm.Assembler;

/**
 * A reference from one scope to another.
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 *
 */

public
class UplevelReference implements Constants {
    /**
     * The class in which the reference occurs.
     */
    ClassDefinition client;

    /**
     * The field being referenced.
     * It is always a final argument or a final local variable.
     * (An uplevel reference to a field of a class C is fetched
     * through an implicit uplevel reference to C.this, which is
     * an argument.)
     */
    LocalMember target;

    /**
     * The local variable which bears a copy of the target's value,
     * for all methods of the client class.
     * Its name is &quot;this$C&quot; for &lt;code&gt;this.C&lt;/code&gt; or
     * &quot;val$x&quot; for other target variables &lt;code&gt;x&lt;/code&gt;.
     * &lt;p&gt;
     * This local variable is always a constructor argument,
     * and is therefore usable only in the constructor and in initializers.
     * All other methods use the local field.
     * @see #localField
     */
    LocalMember localArgument;

    /**
     * A private synthetic field of the client class which
     * bears a copy of the target's value.
     * The compiler tries to avoid creating it if possible.
     * The field has the same name and type as the localArgument.
     * @see #localArgument
     */
    MemberDefinition localField;

    /**
     * The next item on the references list of the client.
     */
    UplevelReference next;

    /**
     * constructor
     */
<span class="nc" id="L87">    public UplevelReference(ClassDefinition client, LocalMember target) {</span>
<span class="nc" id="L88">        this.client = client;</span>
<span class="nc" id="L89">        this.target = target;</span>

        // Choose a name and build a variable declaration node.
        Identifier valName;
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (target.getName().equals(idThis)) {</span>
<span class="nc" id="L94">            ClassDefinition tc = target.getClassDefinition();</span>
            // It should always be true that tc.enclosingClassOf(client).
            // If it were false, the numbering scheme would fail
            // to produce unique names, since we'd be trying
            // to number classes which were not in the sequence
            // of enclosing scopes.  The next paragraph of this
            // code robustly deals with that possibility, however,
            // by detecting name collisions and perturbing the names.
<span class="nc" id="L102">            int depth = 0;</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            for (ClassDefinition pd = tc; !pd.isTopLevel(); pd = pd.getOuterClass()) {</span>
                // The inner classes specification states that the name of
                // a private field containing a reference to the outermost
                // enclosing instance is named &quot;this$0&quot;.  That outermost
                // enclosing instance is always the innermost toplevel class.
<span class="nc" id="L108">                depth += 1;</span>
            }
            // In this example, T1,T2,T3 are all top-level (static),
            // while I4,I5,I6,I7 are all inner.  Each of the inner classes
            // will have a single up-level &quot;this$N&quot; reference to the next
            // class out.  Only the outermost &quot;this$0&quot; will refer to a
            // top-level class, T3.
            //
            // class T1 {
            //  static class T2 {
            //   static class T3 {
            //    class I4 {
            //     class I5 {
            //      class I6 {
            //       // at this point we have these fields in various places:
            //       // I4 this$0; I5 this$1; I6 this$2;
            //      }
            //     }
            //     class I7 {
            //       // I4 this$0; I7 this$1;
            //     }
            //    }
            //   }
            //  }
            // }
<span class="nc" id="L133">            valName = Identifier.lookup(prefixThis + depth);</span>
<span class="nc" id="L134">        } else {</span>
<span class="nc" id="L135">            valName = Identifier.lookup(prefixVal + target.getName());</span>
        }

        // Make reasonably certain that valName is unique to this client.
        // (This check can be fooled by malicious naming of explicit
        // constructor arguments, or of inherited fields.)
<span class="nc" id="L141">        Identifier base = valName;</span>
<span class="nc" id="L142">        int tick = 0;</span>
        while (true) {
<span class="nc bnc" id="L144" title="All 2 branches missed.">            boolean failed = (client.getFirstMatch(valName) != null);</span>
<span class="nc" id="L145">            for (UplevelReference r = client.getReferences();</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">                    r != null; r = r.next) {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">                if (r.target.getName().equals(valName)) {</span>
<span class="nc" id="L148">                    failed = true;</span>
                }
            }
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if (!failed) {</span>
<span class="nc" id="L152">                break;</span>
            }
            // try another name
<span class="nc" id="L155">            valName = Identifier.lookup(base + &quot;$&quot; + (++tick));</span>
<span class="nc" id="L156">        }</span>

        // Build the constructor argument.
        // Like &quot;this&quot;, it wil be shared equally by all constructors of client.
<span class="nc" id="L160">        localArgument = new LocalMember(target.getWhere(),</span>
                                       client,
                                       M_FINAL | M_SYNTHETIC,
<span class="nc" id="L163">                                       target.getType(),</span>
                                       valName);
<span class="nc" id="L165">    }</span>

    /**
     * Insert self into a list of references.
     * Maintain &quot;isEarlierThan&quot; as an invariant of the list.
     * This is important (a) to maximize stability of signatures,
     * and (b) to allow uplevel &quot;this&quot; parameters to come at the
     * front of every argument list they appear in.
     */
    public UplevelReference insertInto(UplevelReference references) {
<span class="nc bnc" id="L175" title="All 4 branches missed.">        if (references == null || isEarlierThan(references)) {</span>
<span class="nc" id="L176">            next = references;</span>
<span class="nc" id="L177">            return this;</span>
        } else {
<span class="nc" id="L179">            UplevelReference prev = references;</span>
<span class="nc bnc" id="L180" title="All 4 branches missed.">            while (!(prev.next == null || isEarlierThan(prev.next))) {</span>
<span class="nc" id="L181">                prev = prev.next;</span>
            }
<span class="nc" id="L183">            next = prev.next;</span>
<span class="nc" id="L184">            prev.next = this;</span>
<span class="nc" id="L185">            return references;</span>
        }
    }

    /**
     * Tells if self precedes the other in the canonical ordering.
     */
    public final boolean isEarlierThan(UplevelReference other) {
        // Outer fields always come first.
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (isClientOuterField()) {</span>
<span class="nc" id="L195">            return true;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        } else if (other.isClientOuterField()) {</span>
<span class="nc" id="L197">            return false;</span>
        }

        // Now it doesn't matter what the order is; use string comparison.
<span class="nc" id="L201">        LocalMember target2 = other.target;</span>
<span class="nc" id="L202">        Identifier name = target.getName();</span>
<span class="nc" id="L203">        Identifier name2 = target2.getName();</span>
<span class="nc" id="L204">        int cmp = name.toString().compareTo(name2.toString());</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (cmp != 0) {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            return cmp &lt; 0;</span>
        }
<span class="nc" id="L208">        Identifier cname = target.getClassDefinition().getName();</span>
<span class="nc" id="L209">        Identifier cname2 = target2.getClassDefinition().getName();</span>
<span class="nc" id="L210">        int ccmp = cname.toString().compareTo(cname2.toString());</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        return ccmp &lt; 0;</span>
    }

    /**
     * the target of this reference
     */
    public final LocalMember getTarget() {
<span class="nc" id="L218">        return target;</span>
    }

    /**
     * the local argument for this reference
     */
    public final LocalMember getLocalArgument() {
<span class="nc" id="L225">        return localArgument;</span>
    }

    /**
     * the field allocated in the client for this reference
     */
    public final MemberDefinition getLocalField() {
<span class="nc" id="L232">        return localField;</span>
    }

    /**
     * Get the local field, creating one if necessary.
     * The client class must not be frozen.
     */
    public final MemberDefinition getLocalField(Environment env) {
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (localField == null) {</span>
<span class="nc" id="L241">            makeLocalField(env);</span>
        }
<span class="nc" id="L243">        return localField;</span>
    }

    /**
     * the client class
     */
    public final ClassDefinition getClient() {
<span class="nc" id="L250">        return client;</span>
    }

    /**
     * the next reference in the client's list
     */
    public final UplevelReference getNext() {
<span class="nc" id="L257">        return next;</span>
    }

    /**
     * Tell if this uplevel reference is the up-level &quot;this&quot; pointer
     * of an inner class.  Such references are treated differently
     * than others, because they affect constructor calls across
     * compilation units.
     */
    public boolean isClientOuterField() {
<span class="nc" id="L267">        MemberDefinition outerf = client.findOuterMember();</span>
<span class="nc bnc" id="L268" title="All 4 branches missed.">        return (outerf != null) &amp;&amp; (localField == outerf);</span>
    }

    /**
     * Tell if my local argument is directly available in this context.
     * If not, the uplevel reference will have to be via a class field.
     * &lt;p&gt;
     * This must be called in a context which is local
     * to the client of the uplevel reference.
     */
    public boolean localArgumentAvailable(Environment env, Context ctx) {
<span class="nc" id="L279">        MemberDefinition reff = ctx.field;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (reff.getClassDefinition() != client) {</span>
<span class="nc" id="L281">            throw new CompilerError(&quot;localArgumentAvailable&quot;);</span>
        }
<span class="nc bnc" id="L283" title="All 2 branches missed.">        return (   reff.isConstructor()</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                || reff.isVariable()</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                || reff.isInitializer() );</span>
    }

    /**
     * Process an uplevel reference.
     * The only decision to make at this point is whether
     * to build a &quot;localField&quot; instance variable, which
     * is done (lazily) when localArgumentAvailable() proves false.
     */
    public void noteReference(Environment env, Context ctx) {
<span class="nc bnc" id="L295" title="All 4 branches missed.">        if (localField == null &amp;&amp; !localArgumentAvailable(env, ctx)) {</span>
            // We need an instance variable unless client is a constructor.
<span class="nc" id="L297">            makeLocalField(env);</span>
        }
<span class="nc" id="L299">    }</span>

    private void makeLocalField(Environment env) {
        // Cannot alter decisions like this one at a late date.
<span class="nc" id="L303">        client.referencesMustNotBeFrozen();</span>
<span class="nc" id="L304">        int mod = M_PRIVATE | M_FINAL | M_SYNTHETIC;</span>
<span class="nc" id="L305">        localField = env.makeMemberDefinition(env,</span>
<span class="nc" id="L306">                                             localArgument.getWhere(),</span>
                                             client, null,
                                             mod,
<span class="nc" id="L309">                                             localArgument.getType(),</span>
<span class="nc" id="L310">                                             localArgument.getName(),</span>
                                             null, null, null);
<span class="nc" id="L312">    }</span>

    /**
     * Assuming noteReference() is all taken care of,
     * build an uplevel reference.
     * &lt;p&gt;
     * This must be called in a context which is local
     * to the client of the uplevel reference.
     */
    public Expression makeLocalReference(Environment env, Context ctx) {
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (ctx.field.getClassDefinition() != client) {</span>
<span class="nc" id="L323">            throw new CompilerError(&quot;makeLocalReference&quot;);</span>
        }
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (localArgumentAvailable(env, ctx)) {</span>
<span class="nc" id="L326">            return new IdentifierExpression(0, localArgument);</span>
        } else {
<span class="nc" id="L328">            return makeFieldReference(env, ctx);</span>
        }
    }

    /**
     * As with makeLocalReference(), build a locally-usable reference.
     * Ignore the availability of local arguments; always use a class field.
     */
    public Expression makeFieldReference(Environment env, Context ctx) {
<span class="nc" id="L337">        Expression e = ctx.findOuterLink(env, 0, localField);</span>
<span class="nc" id="L338">        return new FieldExpression(0, e, localField);</span>
    }

    /**
     * During the inline phase, call this on a list of references
     * for which the code phase will later emit arguments.
     * It will make sure that any &quot;double-uplevel&quot; values
     * needed by the callee are also present at the call site.
     * &lt;p&gt;
     * If any reference is a &quot;ClientOuterField&quot;, it is skipped
     * by this method (and by willCodeArguments).  This is because
     */
    public void willCodeArguments(Environment env, Context ctx) {
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if (!isClientOuterField()) {</span>
<span class="nc" id="L352">            ctx.noteReference(env, target);</span>
        }

<span class="nc bnc" id="L355" title="All 2 branches missed.">        if (next != null) {</span>
<span class="nc" id="L356">            next.willCodeArguments(env, ctx);</span>
        }
<span class="nc" id="L358">    }</span>

    /**
     * Code is being generated for a call to a constructor of
     * the client class.  Push an argument for the constructor.
     */
    public void codeArguments(Environment env, Context ctx, Assembler asm,
                              long where, MemberDefinition conField) {
<span class="nc bnc" id="L366" title="All 2 branches missed.">        if (!isClientOuterField()) {</span>
<span class="nc" id="L367">            Expression e = ctx.makeReference(env, target);</span>
<span class="nc" id="L368">            e.codeValue(env, ctx, asm);</span>
        }

<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (next != null) {</span>
<span class="nc" id="L372">            next.codeArguments(env, ctx, asm, where, conField);</span>
        }
<span class="nc" id="L374">    }</span>

    /**
     * Code is being generated for a constructor of the client class.
     * Emit code which initializes the instance.
     */
    public void codeInitialization(Environment env, Context ctx, Assembler asm,
                                   long where, MemberDefinition conField) {
        // If the reference is a clientOuterField, then the initialization
        // code is generated in MethodExpression.makeVarInits().
        // (Fix for bug 4075063.)
<span class="nc bnc" id="L385" title="All 4 branches missed.">        if (localField != null &amp;&amp; !isClientOuterField()) {</span>
<span class="nc" id="L386">            Expression e = ctx.makeReference(env, target);</span>
<span class="nc" id="L387">            Expression f = makeFieldReference(env, ctx);</span>
<span class="nc" id="L388">            e = new AssignExpression(e.getWhere(), f, e);</span>
<span class="nc" id="L389">            e.type = localField.getType();</span>
<span class="nc" id="L390">            e.code(env, ctx, asm);</span>
        }

<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (next != null) {</span>
<span class="nc" id="L394">            next.codeInitialization(env, ctx, asm, where, conField);</span>
        }
<span class="nc" id="L396">    }</span>

    public String toString() {
<span class="nc" id="L399">        return &quot;[&quot; + localArgument + &quot; in &quot; + client + &quot;]&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>