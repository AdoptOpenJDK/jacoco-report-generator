<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>IdentifierExpression.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.tree</a> &gt; <span class="el_source">IdentifierExpression.java</span></div><h1>IdentifierExpression.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.tree;

import sun.tools.java.*;
import sun.tools.asm.Assembler;
import sun.tools.asm.LocalVariable;
import java.io.PrintStream;
import java.util.Hashtable;

/**
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public
class IdentifierExpression extends Expression {
    Identifier id;
    MemberDefinition field;
    Expression implementation;

    /**
     * Constructor
     */
    public IdentifierExpression(long where, Identifier id) {
<span class="nc" id="L49">        super(IDENT, where, Type.tError);</span>
<span class="nc" id="L50">        this.id = id;</span>
<span class="nc" id="L51">    }</span>
    public IdentifierExpression(IdentifierToken id) {
<span class="nc" id="L53">        this(id.getWhere(), id.getName());</span>
<span class="nc" id="L54">    }</span>
    public IdentifierExpression(long where, MemberDefinition field) {
<span class="nc" id="L56">        super(IDENT, where, field.getType());</span>
<span class="nc" id="L57">        this.id = field.getName();</span>
<span class="nc" id="L58">        this.field = field;</span>
<span class="nc" id="L59">    }</span>

    public Expression getImplementation() {
<span class="nc bnc" id="L62" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L63">            return implementation;</span>
<span class="nc" id="L64">        return this;</span>
    }

    /**
     * Check if the expression is equal to a value
     */
    public boolean equals(Identifier id) {
<span class="nc" id="L71">        return this.id.equals(id);</span>
    }


    /**
     * Assign a value to this identifier.  [It must already be &quot;bound&quot;]
     */
    private Vset assign(Environment env, Context ctx, Vset vset) {
<span class="nc bnc" id="L79" title="All 2 branches missed.">        if (field.isLocal()) {</span>
<span class="nc" id="L80">            LocalMember local = (LocalMember)field;</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">            if (local.scopeNumber &lt; ctx.frameNumber) {</span>
<span class="nc" id="L82">                env.error(where, &quot;assign.to.uplevel&quot;, id);</span>
            }
<span class="nc bnc" id="L84" title="All 2 branches missed.">            if (local.isFinal()) {</span>
                // allow definite single assignment of blank finals
<span class="nc bnc" id="L86" title="All 2 branches missed.">                if (!local.isBlankFinal()) {</span>
<span class="nc" id="L87">                    env.error(where, &quot;assign.to.final&quot;, id);</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">                } else if (!vset.testVarUnassigned(local.number)) {</span>
<span class="nc" id="L89">                    env.error(where, &quot;assign.to.blank.final&quot;, id);</span>
                }
            }
<span class="nc" id="L92">            vset.addVar(local.number);</span>
<span class="nc" id="L93">            local.writecount++;</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">        } else if (field.isFinal()) {</span>
<span class="nc" id="L95">            vset = FieldExpression.checkFinalAssign(env, ctx, vset,</span>
                                                    where, field);
        }
<span class="nc" id="L98">        return vset;</span>
    }

    /**
     * Get the value of this identifier.  [ It must already be &quot;bound&quot;]
     */
    private Vset get(Environment env, Context ctx, Vset vset) {
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (field.isLocal()) {</span>
<span class="nc" id="L106">            LocalMember local = (LocalMember)field;</span>
<span class="nc bnc" id="L107" title="All 4 branches missed.">            if (local.scopeNumber &lt; ctx.frameNumber &amp;&amp; !local.isFinal()) {</span>
<span class="nc" id="L108">                env.error(where, &quot;invalid.uplevel&quot;, id);</span>
            }
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (!vset.testVar(local.number)) {</span>
<span class="nc" id="L111">                env.error(where, &quot;var.not.initialized&quot;, id);</span>
<span class="nc" id="L112">                vset.addVar(local.number);</span>
            }
<span class="nc" id="L114">            local.readcount++;</span>
<span class="nc" id="L115">        } else {</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            if (!field.isStatic()) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">                if (!vset.testVar(ctx.getThisNumber())) {</span>
<span class="nc" id="L118">                    env.error(where, &quot;access.inst.before.super&quot;, id);</span>
<span class="nc" id="L119">                    implementation = null;</span>
                }
            }
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (field.isBlankFinal()) {</span>
<span class="nc" id="L123">                int number = ctx.getFieldNumber(field);</span>
<span class="nc bnc" id="L124" title="All 4 branches missed.">                if (number &gt;= 0 &amp;&amp; !vset.testVar(number)) {</span>
<span class="nc" id="L125">                    env.error(where, &quot;var.not.initialized&quot;, id);</span>
                }
            }
        }
<span class="nc" id="L129">        return vset;</span>
    }

    /**
     * Bind to a field
     */
    boolean bind(Environment env, Context ctx) {
        try {
<span class="nc" id="L137">            field = ctx.getField(env, id);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L139">                for (ClassDefinition cdef = ctx.field.getClassDefinition();</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                     cdef != null; cdef = cdef.getOuterClass()) {</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">                    if (cdef.findAnyMethod(env, id) != null) {</span>
<span class="nc" id="L142">                        env.error(where, &quot;invalid.var&quot;, id,</span>
<span class="nc" id="L143">                                  ctx.field.getClassDeclaration());</span>
<span class="nc" id="L144">                        return false;</span>
                    }
                }
<span class="nc" id="L147">                env.error(where, &quot;undef.var&quot;, id);</span>
<span class="nc" id="L148">                return false;</span>
            }

<span class="nc" id="L151">            type = field.getType();</span>

            // Check access permission
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (!ctx.field.getClassDefinition().canAccess(env, field)) {</span>
<span class="nc" id="L155">                env.error(where, &quot;no.field.access&quot;,</span>
<span class="nc" id="L156">                          id, field.getClassDeclaration(),</span>
<span class="nc" id="L157">                          ctx.field.getClassDeclaration());</span>
<span class="nc" id="L158">                return false;</span>
            }

            // Find out how to access this variable.
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (field.isLocal()) {</span>
<span class="nc" id="L163">                LocalMember local = (LocalMember)field;</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">                if (local.scopeNumber &lt; ctx.frameNumber) {</span>
                    // get a &quot;val$x&quot; copy via the current object
<span class="nc" id="L166">                    implementation = ctx.makeReference(env, local);</span>
                }
<span class="nc" id="L168">            } else {</span>
<span class="nc" id="L169">                MemberDefinition f = field;</span>

<span class="nc bnc" id="L171" title="All 2 branches missed.">                if (f.reportDeprecated(env)) {</span>
<span class="nc" id="L172">                    env.error(where, &quot;warn.field.is.deprecated&quot;,</span>
<span class="nc" id="L173">                              id, f.getClassDefinition());</span>
                }

<span class="nc" id="L176">                ClassDefinition fclass = f.getClassDefinition();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                if (fclass != ctx.field.getClassDefinition()) {</span>
                    // Maybe an inherited field hides an apparent variable.
<span class="nc" id="L179">                    MemberDefinition f2 = ctx.getApparentField(env, id);</span>
<span class="nc bnc" id="L180" title="All 4 branches missed.">                    if (f2 != null &amp;&amp; f2 != f) {</span>
<span class="nc" id="L181">                        ClassDefinition c = ctx.findScope(env, fclass);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                        if (c == null)  c = f.getClassDefinition();</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">                        if (f2.isLocal()) {</span>
<span class="nc" id="L184">                            env.error(where, &quot;inherited.hides.local&quot;,</span>
<span class="nc" id="L185">                                      id, c.getClassDeclaration());</span>
                        } else {
<span class="nc" id="L187">                            env.error(where, &quot;inherited.hides.field&quot;,</span>
<span class="nc" id="L188">                                      id, c.getClassDeclaration(),</span>
<span class="nc" id="L189">                                      f2.getClassDeclaration());</span>
                        }
                    }
                }

                // Rewrite as a FieldExpression.
                // Access methods for private fields, if needed, will be added
                // during subsequent processing of the FieldExpression.  See
                // method 'FieldExpression.checkCommon'. This division of labor
                // is somewhat awkward, as most further processing of a
                // FieldExpression during the checking phase is suppressed when
                // the referenced field is pre-set as it is here.

<span class="nc bnc" id="L202" title="All 2 branches missed.">                if (f.isStatic()) {</span>
<span class="nc" id="L203">                    Expression base = new TypeExpression(where,</span>
<span class="nc" id="L204">                                        f.getClassDeclaration().getType());</span>
<span class="nc" id="L205">                    implementation = new FieldExpression(where, null, f);</span>
<span class="nc" id="L206">                } else {</span>
<span class="nc" id="L207">                    Expression base = ctx.findOuterLink(env, where, f);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">                    if (base != null) {</span>
<span class="nc" id="L209">                        implementation = new FieldExpression(where, base, f);</span>
                    }
                }
            }

            // Check forward reference
<span class="nc bnc" id="L215" title="All 2 branches missed.">            if (!ctx.canReach(env, field)) {</span>
<span class="nc" id="L216">                env.error(where, &quot;forward.ref&quot;,</span>
<span class="nc" id="L217">                          id, field.getClassDeclaration());</span>
<span class="nc" id="L218">                return false;</span>
            }
<span class="nc" id="L220">            return true;</span>
<span class="nc" id="L221">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L222">            env.error(where, &quot;class.not.found&quot;, e.name, ctx.field);</span>
<span class="nc" id="L223">        } catch (AmbiguousMember e) {</span>
<span class="nc" id="L224">            env.error(where, &quot;ambig.field&quot;, id,</span>
<span class="nc" id="L225">                      e.field1.getClassDeclaration(),</span>
<span class="nc" id="L226">                      e.field2.getClassDeclaration());</span>
<span class="nc" id="L227">        }</span>
<span class="nc" id="L228">        return false;</span>
    }

    /**
     * Check expression
     */
    public Vset checkValue(Environment env, Context ctx, Vset vset, Hashtable exp) {
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (field != null) {</span>
            // An internally pre-set field, such as an argument copying
            // an uplevel value.  Do not re-check it.
<span class="nc" id="L238">            return vset;</span>
        }
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (bind(env, ctx)) {</span>
<span class="nc" id="L241">            vset = get(env, ctx, vset);</span>
<span class="nc" id="L242">            ctx.field.getClassDefinition().addDependency(field.getClassDeclaration());</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            if (implementation != null)</span>
<span class="nc" id="L244">                vset = implementation.checkValue(env, ctx, vset, exp);</span>
        }
<span class="nc" id="L246">        return vset;</span>
    }

    /**
     * Check the expression if it appears on the LHS of an assignment
     */
    public Vset checkLHS(Environment env, Context ctx,
                         Vset vset, Hashtable exp) {
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (!bind(env, ctx))</span>
<span class="nc" id="L255">            return vset;</span>
<span class="nc" id="L256">        vset = assign(env, ctx, vset);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L258">            vset = implementation.checkValue(env, ctx, vset, exp);</span>
<span class="nc" id="L259">        return vset;</span>
    }

    /**
     * Check the expression if it appears on the LHS of an op= expression
     */
    public Vset checkAssignOp(Environment env, Context ctx,
                              Vset vset, Hashtable exp, Expression outside) {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (!bind(env, ctx))</span>
<span class="nc" id="L268">            return vset;</span>
<span class="nc" id="L269">        vset = assign(env, ctx, get(env, ctx, vset));</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L271">            vset = implementation.checkValue(env, ctx, vset, exp);</span>
<span class="nc" id="L272">        return vset;</span>
    }

    /**
     * Return an accessor if one is needed for assignments to this expression.
     */
    public FieldUpdater getAssigner(Environment env, Context ctx) {
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L280">            return implementation.getAssigner(env, ctx);</span>
<span class="nc" id="L281">        return null;</span>
    }

    /**
     * Return an updater if one is needed for assignments to this expression.
     */
    public FieldUpdater getUpdater(Environment env, Context ctx) {
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L289">            return implementation.getUpdater(env, ctx);</span>
<span class="nc" id="L290">        return null;</span>
    }

    /**
     * Check if the present name is part of a scoping prefix.
     */
    public Vset checkAmbigName(Environment env, Context ctx, Vset vset, Hashtable exp,
                               UnaryExpression loc) {
        try {
<span class="nc bnc" id="L299" title="All 2 branches missed.">            if (ctx.getField(env, id) != null) {</span>
                // if this is a local field, there's nothing more to do.
<span class="nc" id="L301">                return checkValue(env, ctx, vset, exp);</span>
            }
<span class="nc" id="L303">        } catch (ClassNotFound ee) {</span>
<span class="nc" id="L304">        } catch (AmbiguousMember ee) {</span>
<span class="nc" id="L305">        }</span>
        // Can this be interpreted as a type?
<span class="nc" id="L307">        ClassDefinition c = toResolvedType(env, ctx, true);</span>
        // Is it a real type??
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L310">            loc.right = new TypeExpression(where, c.getType());</span>
<span class="nc" id="L311">            return vset;</span>
        }
        // We hope it is a package prefix.  Let the caller decide.
<span class="nc" id="L314">        type = Type.tPackage;</span>
<span class="nc" id="L315">        return vset;</span>
    }

    /**
     * Convert an identifier to a known type, or null.
     */
    private ClassDefinition toResolvedType(Environment env, Context ctx,
                                           boolean pkgOK) {
<span class="nc" id="L323">        Identifier rid = ctx.resolveName(env, id);</span>
<span class="nc" id="L324">        Type t = Type.tClass(rid);</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">        if (pkgOK &amp;&amp; !env.classExists(t)) {</span>
<span class="nc" id="L326">            return null;</span>
        }
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (env.resolve(where, ctx.field.getClassDefinition(), t)) {</span>
            try {
<span class="nc" id="L330">                ClassDefinition c = env.getClassDefinition(t);</span>

                // Maybe an inherited class hides an apparent class.
<span class="nc bnc" id="L333" title="All 2 branches missed.">                if (c.isMember()) {</span>
<span class="nc" id="L334">                    ClassDefinition sc = ctx.findScope(env, c.getOuterClass());</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                    if (sc != c.getOuterClass()) {</span>
<span class="nc" id="L336">                        Identifier rid2 = ctx.getApparentClassName(env, id);</span>
<span class="nc bnc" id="L337" title="All 4 branches missed.">                        if (!rid2.equals(idNull) &amp;&amp; !rid2.equals(rid)) {</span>
<span class="nc" id="L338">                            env.error(where, &quot;inherited.hides.type&quot;,</span>
<span class="nc" id="L339">                                      id, sc.getClassDeclaration());</span>
                        }
                    }
                }

<span class="nc bnc" id="L344" title="All 2 branches missed.">                if (!c.getLocalName().equals(id.getFlatName().getName())) {</span>
<span class="nc" id="L345">                    env.error(where, &quot;illegal.mangled.name&quot;, id, c);</span>
                }

<span class="nc" id="L348">                return c;</span>
<span class="nc" id="L349">            } catch (ClassNotFound ee) {</span>
            }
        }
<span class="nc" id="L352">        return null;</span>
    }

    /**
     * Convert an identifier to a type.
     * If one is not known, use the current package as a qualifier.
     */
    Type toType(Environment env, Context ctx) {
<span class="nc" id="L360">        ClassDefinition c = toResolvedType(env, ctx, false);</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L362">            return c.getType();</span>
        }
<span class="nc" id="L364">        return Type.tError;</span>
    }

    /**
     * Convert an expresion to a type in a context where a qualified
     * type name is expected, e.g., in the prefix of a qualified type
     * name. We do not necessarily know where the package prefix ends,
     * so we operate similarly to 'checkAmbiguousName'.  This is the
     * base case -- the first component of the qualified name.
     */
    /*-------------------------------------------------------*
    Type toQualifiedType(Environment env, Context ctx) {
        // We do not look for non-type fields.  Is this correct?
        ClassDefinition c = toResolvedType(env, ctx, true);
        // Is it a real type?
        if (c != null) {
            return c.getType();
        }
        // We hope it is a package prefix.  Let the caller decide.
        return Type.tPackage;
    }
    *-------------------------------------------------------*/

    /**
     * Check if constant:  Will it inline away?
     */
    public boolean isConstant() {
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L392">            return implementation.isConstant();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (field != null) {</span>
<span class="nc" id="L394">            return field.isConstant();</span>
        }
<span class="nc" id="L396">        return false;</span>
    }

    /**
     * Inline
     */
    public Expression inline(Environment env, Context ctx) {
<span class="nc" id="L403">        return null;</span>
    }
    public Expression inlineValue(Environment env, Context ctx) {
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L407">            return implementation.inlineValue(env, ctx);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L409">            return this;</span>
        }
        try {
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (field.isLocal()) {</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                if (field.isInlineable(env, false)) {</span>
<span class="nc" id="L414">                    Expression e = (Expression)field.getValue(env);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                    return (e == null) ? this : e.inlineValue(env, ctx);</span>
                }
<span class="nc" id="L417">                return this;</span>
            }
<span class="nc" id="L419">            return this;</span>
<span class="nc" id="L420">        } catch (ClassNotFound e) {</span>
<span class="nc" id="L421">            throw new CompilerError(e);</span>
        }
    }
    public Expression inlineLHS(Environment env, Context ctx) {
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L426">            return implementation.inlineLHS(env, ctx);</span>
<span class="nc" id="L427">        return this;</span>
    }

    public Expression copyInline(Context ctx) {
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L432">            return implementation.copyInline(ctx);</span>
<span class="nc" id="L433">        IdentifierExpression e =</span>
<span class="nc" id="L434">            (IdentifierExpression)super.copyInline(ctx);</span>
<span class="nc bnc" id="L435" title="All 4 branches missed.">        if (field != null &amp;&amp; field.isLocal()) {</span>
<span class="nc" id="L436">            e.field = ((LocalMember)field).getCurrentInlineCopy(ctx);</span>
        }
<span class="nc" id="L438">        return e;</span>
    }

    public int costInline(int thresh, Environment env, Context ctx) {
<span class="nc bnc" id="L442" title="All 2 branches missed.">        if (implementation != null)</span>
<span class="nc" id="L443">            return implementation.costInline(thresh, env, ctx);</span>
<span class="nc" id="L444">        return super.costInline(thresh, env, ctx);</span>
    }

    /**
     * Code local vars (object fields have been inlined away)
     */
    int codeLValue(Environment env, Context ctx, Assembler asm) {
<span class="nc" id="L451">        return 0;</span>
    }
    void codeLoad(Environment env, Context ctx, Assembler asm) {
<span class="nc" id="L454">        asm.add(where, opc_iload + type.getTypeCodeOffset(),</span>
                new Integer(((LocalMember)field).number));
<span class="nc" id="L456">    }</span>
    void codeStore(Environment env, Context ctx, Assembler asm) {
<span class="nc" id="L458">        LocalMember local = (LocalMember)field;</span>
<span class="nc" id="L459">        asm.add(where, opc_istore + type.getTypeCodeOffset(),</span>
                new LocalVariable(local, local.number));
<span class="nc" id="L461">    }</span>
    public void codeValue(Environment env, Context ctx, Assembler asm) {
<span class="nc" id="L463">        codeLValue(env, ctx, asm);</span>
<span class="nc" id="L464">        codeLoad(env, ctx, asm);</span>
<span class="nc" id="L465">    }</span>

    /**
     * Print
     */
    public void print(PrintStream out) {
<span class="nc bnc" id="L471" title="All 2 branches missed.">        out.print(id + &quot;#&quot; + ((field != null) ? field.hashCode() : 0));</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (implementation != null) {</span>
<span class="nc" id="L473">            out.print(&quot;/IMPL=&quot;);</span>
<span class="nc" id="L474">            implementation.print(out);</span>
        }
<span class="nc" id="L476">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>