<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>X500Principal.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.security.auth.x500</a> &gt; <span class="el_source">X500Principal.java</span></div><h1>X500Principal.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.security.auth.x500;

import java.io.*;
import java.security.Principal;
import java.util.Collections;
import java.util.Map;
import sun.security.x509.X500Name;
import sun.security.util.*;

/**
 * &lt;p&gt; This class represents an X.500 {@code Principal}.
 * {@code X500Principal}s are represented by distinguished names such as
 * &quot;CN=Duke, OU=JavaSoft, O=Sun Microsystems, C=US&quot;.
 *
 * &lt;p&gt; This class can be instantiated by using a string representation
 * of the distinguished name, or by using the ASN.1 DER encoded byte
 * representation of the distinguished name.  The current specification
 * for the string representation of a distinguished name is defined in
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253: Lightweight
 * Directory Access Protocol (v3): UTF-8 String Representation of
 * Distinguished Names&lt;/a&gt;. This class, however, accepts string formats from
 * both RFC 2253 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc1779.txt&quot;&gt;RFC 1779:
 * A String Representation of Distinguished Names&lt;/a&gt;, and also recognizes
 * attribute type keywords whose OIDs (Object Identifiers) are defined in
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280.txt&quot;&gt;RFC 3280: Internet X.509
 * Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.
 *
 * &lt;p&gt; The string representation for this {@code X500Principal}
 * can be obtained by calling the {@code getName} methods.
 *
 * &lt;p&gt; Note that the {@code getSubjectX500Principal} and
 * {@code getIssuerX500Principal} methods of
 * {@code X509Certificate} return X500Principals representing the
 * issuer and subject fields of the certificate.
 *
 * @see java.security.cert.X509Certificate
 * @since 1.4
 */
public final class X500Principal implements Principal, java.io.Serializable {

    private static final long serialVersionUID = -500463348111345721L;

    /**
     * RFC 1779 String format of Distinguished Names.
     */
    public static final String RFC1779 = &quot;RFC1779&quot;;
    /**
     * RFC 2253 String format of Distinguished Names.
     */
    public static final String RFC2253 = &quot;RFC2253&quot;;
    /**
     * Canonical String format of Distinguished Names.
     */
    public static final String CANONICAL = &quot;CANONICAL&quot;;

    /**
     * The X500Name representing this principal.
     *
     * NOTE: this field is reflectively accessed from within X500Name.
     */
    private transient X500Name thisX500Name;

    /**
     * Creates an X500Principal by wrapping an X500Name.
     *
     * NOTE: The constructor is package private. It is intended to be accessed
     * using privileged reflection from classes in sun.security.*.
     * Currently referenced from sun.security.x509.X500Name.asX500Principal().
     */
<span class="fc" id="L95">    X500Principal(X500Name x500Name) {</span>
<span class="fc" id="L96">        thisX500Name = x500Name;</span>
<span class="fc" id="L97">    }</span>

    /**
     * Creates an {@code X500Principal} from a string representation of
     * an X.500 distinguished name (ex:
     * &quot;CN=Duke, OU=JavaSoft, O=Sun Microsystems, C=US&quot;).
     * The distinguished name must be specified using the grammar defined in
     * RFC 1779 or RFC 2253 (either format is acceptable).
     *
     * &lt;p&gt;This constructor recognizes the attribute type keywords
     * defined in RFC 1779 and RFC 2253
     * (and listed in {@link #getName(String format) getName(String format)}),
     * as well as the T, DNQ or DNQUALIFIER, SURNAME, GIVENNAME, INITIALS,
     * GENERATION, EMAILADDRESS, and SERIALNUMBER keywords whose Object
     * Identifiers (OIDs) are defined in RFC 3280 and its successor.
     * Any other attribute type must be specified as an OID.
     *
     * &lt;p&gt;This implementation enforces a more restrictive OID syntax than
     * defined in RFC 1779 and 2253. It uses the more correct syntax defined in
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc4512.txt&quot;&gt;RFC 4512&lt;/a&gt;, which
     * specifies that OIDs contain at least 2 digits:
     *
     * &lt;p&gt;{@code numericoid = number 1*( DOT number ) }
     *
     * @param name an X.500 distinguished name in RFC 1779 or RFC 2253 format
     * @exception NullPointerException if the {@code name}
     *                  is {@code null}
     * @exception IllegalArgumentException if the {@code name}
     *                  is improperly specified
     */
    public X500Principal(String name) {
<span class="fc" id="L128">        this(name, Collections.&lt;String, String&gt;emptyMap());</span>
<span class="fc" id="L129">    }</span>

    /**
     * Creates an {@code X500Principal} from a string representation of
     * an X.500 distinguished name (ex:
     * &quot;CN=Duke, OU=JavaSoft, O=Sun Microsystems, C=US&quot;).
     * The distinguished name must be specified using the grammar defined in
     * RFC 1779 or RFC 2253 (either format is acceptable).
     *
     * &lt;p&gt; This constructor recognizes the attribute type keywords specified
     * in {@link #X500Principal(String)} and also recognizes additional
     * keywords that have entries in the {@code keywordMap} parameter.
     * Keyword entries in the keywordMap take precedence over the default
     * keywords recognized by {@code X500Principal(String)}. Keywords
     * MUST be specified in all upper-case, otherwise they will be ignored.
     * Improperly specified keywords are ignored; however if a keyword in the
     * name maps to an improperly specified Object Identifier (OID), an
     * {@code IllegalArgumentException} is thrown. It is permissible to
     * have 2 different keywords that map to the same OID.
     *
     * &lt;p&gt;This implementation enforces a more restrictive OID syntax than
     * defined in RFC 1779 and 2253. It uses the more correct syntax defined in
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc4512.txt&quot;&gt;RFC 4512&lt;/a&gt;, which
     * specifies that OIDs contain at least 2 digits:
     *
     * &lt;p&gt;{@code numericoid = number 1*( DOT number ) }
     *
     * @param name an X.500 distinguished name in RFC 1779 or RFC 2253 format
     * @param keywordMap an attribute type keyword map, where each key is a
     *   keyword String that maps to a corresponding object identifier in String
     *   form (a sequence of nonnegative integers separated by periods). The map
     *   may be empty but never {@code null}.
     * @exception NullPointerException if {@code name} or
     *   {@code keywordMap} is {@code null}
     * @exception IllegalArgumentException if the {@code name} is
     *   improperly specified or a keyword in the {@code name} maps to an
     *   OID that is not in the correct form
     * @since 1.6
     */
<span class="fc" id="L168">    public X500Principal(String name, Map&lt;String, String&gt; keywordMap) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (name == null) {</span>
<span class="fc" id="L170">            throw new NullPointerException</span>
                (sun.security.util.ResourcesMgr.getString
<span class="fc" id="L172">                (&quot;provided.null.name&quot;));</span>
        }
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (keywordMap == null) {</span>
<span class="nc" id="L175">            throw new NullPointerException</span>
                (sun.security.util.ResourcesMgr.getString
<span class="nc" id="L177">                (&quot;provided.null.keyword.map&quot;));</span>
        }

        try {
<span class="fc" id="L181">            thisX500Name = new X500Name(name, keywordMap);</span>
<span class="fc" id="L182">        } catch (Exception e) {</span>
<span class="fc" id="L183">            IllegalArgumentException iae = new IllegalArgumentException</span>
                        (&quot;improperly specified input name: &quot; + name);
<span class="fc" id="L185">            iae.initCause(e);</span>
<span class="fc" id="L186">            throw iae;</span>
<span class="fc" id="L187">        }</span>
<span class="fc" id="L188">    }</span>

    /**
     * Creates an {@code X500Principal} from a distinguished name in
     * ASN.1 DER encoded form. The ASN.1 notation for this structure is as
     * follows.
     * &lt;pre&gt;{@code
     * Name ::= CHOICE {
     *   RDNSequence }
     *
     * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
     *
     * RelativeDistinguishedName ::=
     *   SET SIZE (1 .. MAX) OF AttributeTypeAndValue
     *
     * AttributeTypeAndValue ::= SEQUENCE {
     *   type     AttributeType,
     *   value    AttributeValue }
     *
     * AttributeType ::= OBJECT IDENTIFIER
     *
     * AttributeValue ::= ANY DEFINED BY AttributeType
     * ....
     * DirectoryString ::= CHOICE {
     *       teletexString           TeletexString (SIZE (1..MAX)),
     *       printableString         PrintableString (SIZE (1..MAX)),
     *       universalString         UniversalString (SIZE (1..MAX)),
     *       utf8String              UTF8String (SIZE (1.. MAX)),
     *       bmpString               BMPString (SIZE (1..MAX)) }
     * }&lt;/pre&gt;
     *
     * @param name a byte array containing the distinguished name in ASN.1
     * DER encoded form
     * @throws IllegalArgumentException if an encoding error occurs
     *          (incorrect form for DN)
     */
<span class="fc" id="L224">    public X500Principal(byte[] name) {</span>
        try {
<span class="fc" id="L226">            thisX500Name = new X500Name(name);</span>
<span class="nc" id="L227">        } catch (Exception e) {</span>
<span class="nc" id="L228">            IllegalArgumentException iae = new IllegalArgumentException</span>
                        (&quot;improperly specified input name&quot;);
<span class="nc" id="L230">            iae.initCause(e);</span>
<span class="nc" id="L231">            throw iae;</span>
<span class="fc" id="L232">        }</span>
<span class="fc" id="L233">    }</span>

    /**
     * Creates an {@code X500Principal} from an {@code InputStream}
     * containing the distinguished name in ASN.1 DER encoded form.
     * The ASN.1 notation for this structure is supplied in the
     * documentation for
     * {@link #X500Principal(byte[] name) X500Principal(byte[] name)}.
     *
     * &lt;p&gt; The read position of the input stream is positioned
     * to the next available byte after the encoded distinguished name.
     *
     * @param is an {@code InputStream} containing the distinguished
     *          name in ASN.1 DER encoded form
     *
     * @exception NullPointerException if the {@code InputStream}
     *          is {@code null}
     * @exception IllegalArgumentException if an encoding error occurs
     *          (incorrect form for DN)
     */
<span class="fc" id="L253">    public X500Principal(InputStream is) {</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (is == null) {</span>
<span class="nc" id="L255">            throw new NullPointerException(&quot;provided null input stream&quot;);</span>
        }

        try {
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">            if (is.markSupported())</span>
<span class="fc" id="L260">                is.mark(is.available() + 1);</span>
<span class="nc" id="L261">            DerValue der = new DerValue(is);</span>
<span class="nc" id="L262">            thisX500Name = new X500Name(der.data);</span>
<span class="fc" id="L263">        } catch (Exception e) {</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">            if (is.markSupported()) {</span>
                try {
<span class="fc" id="L266">                    is.reset();</span>
<span class="nc" id="L267">                } catch (IOException ioe) {</span>
<span class="nc" id="L268">                    IllegalArgumentException iae = new IllegalArgumentException</span>
                        (&quot;improperly specified input stream &quot; +
                        (&quot;and unable to reset input stream&quot;));
<span class="nc" id="L271">                    iae.initCause(e);</span>
<span class="nc" id="L272">                    throw iae;</span>
<span class="fc" id="L273">                }</span>
            }
<span class="fc" id="L275">            IllegalArgumentException iae = new IllegalArgumentException</span>
                        (&quot;improperly specified input stream&quot;);
<span class="fc" id="L277">            iae.initCause(e);</span>
<span class="fc" id="L278">            throw iae;</span>
<span class="nc" id="L279">        }</span>
<span class="nc" id="L280">    }</span>

    /**
     * Returns a string representation of the X.500 distinguished name using
     * the format defined in RFC 2253.
     *
     * &lt;p&gt;This method is equivalent to calling
     * {@code getName(X500Principal.RFC2253)}.
     *
     * @return the distinguished name of this {@code X500Principal}
     */
    public String getName() {
<span class="fc" id="L292">        return getName(X500Principal.RFC2253);</span>
    }

    /**
     * Returns a string representation of the X.500 distinguished name
     * using the specified format. Valid values for the format are
     * &quot;RFC1779&quot;, &quot;RFC2253&quot;, and &quot;CANONICAL&quot; (case insensitive).
     *
     * &lt;p&gt; If &quot;RFC1779&quot; is specified as the format,
     * this method emits the attribute type keywords defined in
     * RFC 1779 (CN, L, ST, O, OU, C, STREET).
     * Any other attribute type is emitted as an OID.
     *
     * &lt;p&gt; If &quot;RFC2253&quot; is specified as the format,
     * this method emits the attribute type keywords defined in
     * RFC 2253 (CN, L, ST, O, OU, C, STREET, DC, UID).
     * Any other attribute type is emitted as an OID.
     * Under a strict reading, RFC 2253 only specifies a UTF-8 string
     * representation. The String returned by this method is the
     * Unicode string achieved by decoding this UTF-8 representation.
     *
     * &lt;p&gt; If &quot;CANONICAL&quot; is specified as the format,
     * this method returns an RFC 2253 conformant string representation
     * with the following additional canonicalizations:
     *
     * &lt;p&gt;&lt;ol&gt;
     * &lt;li&gt; Leading zeros are removed from attribute types
     *          that are encoded as dotted decimal OIDs
     * &lt;li&gt; DirectoryString attribute values of type
     *          PrintableString and UTF8String are not
     *          output in hexadecimal format
     * &lt;li&gt; DirectoryString attribute values of types
     *          other than PrintableString and UTF8String
     *          are output in hexadecimal format
     * &lt;li&gt; Leading and trailing white space characters
     *          are removed from non-hexadecimal attribute values
     *          (unless the value consists entirely of white space characters)
     * &lt;li&gt; Internal substrings of one or more white space characters are
     *          converted to a single space in non-hexadecimal
     *          attribute values
     * &lt;li&gt; Relative Distinguished Names containing more than one
     *          Attribute Value Assertion (AVA) are output in the
     *          following order: an alphabetical ordering of AVAs
     *          containing standard keywords, followed by a numeric
     *          ordering of AVAs containing OID keywords.
     * &lt;li&gt; The only characters in attribute values that are escaped are
     *          those which section 2.4 of RFC 2253 states must be escaped
     *          (they are escaped using a preceding backslash character)
     * &lt;li&gt; The entire name is converted to upper case
     *          using {@code String.toUpperCase(Locale.US)}
     * &lt;li&gt; The entire name is converted to lower case
     *          using {@code String.toLowerCase(Locale.US)}
     * &lt;li&gt; The name is finally normalized using normalization form KD,
     *          as described in the Unicode Standard and UAX #15
     * &lt;/ol&gt;
     *
     * &lt;p&gt; Additional standard formats may be introduced in the future.
     *
     * @param format the format to use
     *
     * @return a string representation of this {@code X500Principal}
     *          using the specified format
     * @throws IllegalArgumentException if the specified format is invalid
     *          or null
     */
    public String getName(String format) {
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if (format != null) {</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">            if (format.equalsIgnoreCase(RFC1779)) {</span>
<span class="fc" id="L360">                return thisX500Name.getRFC1779Name();</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">            } else if (format.equalsIgnoreCase(RFC2253)) {</span>
<span class="fc" id="L362">                return thisX500Name.getRFC2253Name();</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">            } else if (format.equalsIgnoreCase(CANONICAL)) {</span>
<span class="fc" id="L364">                return thisX500Name.getRFC2253CanonicalName();</span>
            }
        }
<span class="nc" id="L367">        throw new IllegalArgumentException(&quot;invalid format specified&quot;);</span>
    }

    /**
     * Returns a string representation of the X.500 distinguished name
     * using the specified format. Valid values for the format are
     * &quot;RFC1779&quot; and &quot;RFC2253&quot; (case insensitive). &quot;CANONICAL&quot; is not
     * permitted and an {@code IllegalArgumentException} will be thrown.
     *
     * &lt;p&gt;This method returns Strings in the format as specified in
     * {@link #getName(String)} and also emits additional attribute type
     * keywords for OIDs that have entries in the {@code oidMap}
     * parameter. OID entries in the oidMap take precedence over the default
     * OIDs recognized by {@code getName(String)}.
     * Improperly specified OIDs are ignored; however if an OID
     * in the name maps to an improperly specified keyword, an
     * {@code IllegalArgumentException} is thrown.
     *
     * &lt;p&gt; Additional standard formats may be introduced in the future.
     *
     * &lt;p&gt; Warning: additional attribute type keywords may not be recognized
     * by other implementations; therefore do not use this method if
     * you are unsure if these keywords will be recognized by other
     * implementations.
     *
     * @param format the format to use
     * @param oidMap an OID map, where each key is an object identifier in
     *  String form (a sequence of nonnegative integers separated by periods)
     *  that maps to a corresponding attribute type keyword String.
     *  The map may be empty but never {@code null}.
     * @return a string representation of this {@code X500Principal}
     *          using the specified format
     * @throws IllegalArgumentException if the specified format is invalid,
     *  null, or an OID in the name maps to an improperly specified keyword
     * @throws NullPointerException if {@code oidMap} is {@code null}
     * @since 1.6
     */
    public String getName(String format, Map&lt;String, String&gt; oidMap) {
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (oidMap == null) {</span>
<span class="nc" id="L406">            throw new NullPointerException</span>
                (sun.security.util.ResourcesMgr.getString
<span class="nc" id="L408">                (&quot;provided.null.OID.map&quot;));</span>
        }
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (format != null) {</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (format.equalsIgnoreCase(RFC1779)) {</span>
<span class="nc" id="L412">                return thisX500Name.getRFC1779Name(oidMap);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            } else if (format.equalsIgnoreCase(RFC2253)) {</span>
<span class="nc" id="L414">                return thisX500Name.getRFC2253Name(oidMap);</span>
            }
        }
<span class="nc" id="L417">        throw new IllegalArgumentException(&quot;invalid format specified&quot;);</span>
    }

    /**
     * Returns the distinguished name in ASN.1 DER encoded form. The ASN.1
     * notation for this structure is supplied in the documentation for
     * {@link #X500Principal(byte[] name) X500Principal(byte[] name)}.
     *
     * &lt;p&gt;Note that the byte array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return a byte array containing the distinguished name in ASN.1 DER
     * encoded form
     */
    public byte[] getEncoded() {
        try {
<span class="fc" id="L433">            return thisX500Name.getEncoded();</span>
<span class="nc" id="L434">        } catch (IOException e) {</span>
<span class="nc" id="L435">            throw new RuntimeException(&quot;unable to get encoding&quot;, e);</span>
        }
    }

    /**
     * Return a user-friendly string representation of this
     * {@code X500Principal}.
     *
     * @return a string representation of this {@code X500Principal}
     */
    public String toString() {
<span class="fc" id="L446">        return thisX500Name.toString();</span>
    }

    /**
     * Compares the specified {@code Object} with this
     * {@code X500Principal} for equality.
     *
     * &lt;p&gt; Specifically, this method returns {@code true} if
     * the {@code Object} &lt;i&gt;o&lt;/i&gt; is an {@code X500Principal}
     * and if the respective canonical string representations
     * (obtained via the {@code getName(X500Principal.CANONICAL)} method)
     * of this object and &lt;i&gt;o&lt;/i&gt; are equal.
     *
     * &lt;p&gt; This implementation is compliant with the requirements of RFC 3280.
     *
     * @param o Object to be compared for equality with this
     *          {@code X500Principal}
     *
     * @return {@code true} if the specified {@code Object} is equal
     *          to this {@code X500Principal}, {@code false} otherwise
     */
    public boolean equals(Object o) {
<span class="fc bfc" id="L468" title="All 2 branches covered.">        if (this == o) {</span>
<span class="fc" id="L469">            return true;</span>
        }
<span class="fc bfc" id="L471" title="All 2 branches covered.">        if (o instanceof X500Principal == false) {</span>
<span class="fc" id="L472">            return false;</span>
        }
<span class="fc" id="L474">        X500Principal other = (X500Principal)o;</span>
<span class="fc" id="L475">        return this.thisX500Name.equals(other.thisX500Name);</span>
    }

    /**
     * Return a hash code for this {@code X500Principal}.
     *
     * &lt;p&gt; The hash code is calculated via:
     * {@code getName(X500Principal.CANONICAL).hashCode()}
     *
     * @return a hash code for this {@code X500Principal}
     */
    public int hashCode() {
<span class="fc" id="L487">        return thisX500Name.hashCode();</span>
    }

    /**
     * Save the X500Principal object to a stream.
     *
     * @serialData this {@code X500Principal} is serialized
     *          by writing out its DER-encoded form
     *          (the value of {@code getEncoded} is serialized).
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws IOException {
<span class="nc" id="L499">        s.writeObject(thisX500Name.getEncodedInternal());</span>
<span class="nc" id="L500">    }</span>

    /**
     * Reads this object from a stream (i.e., deserializes it).
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException,
               java.io.NotActiveException,
               ClassNotFoundException {

        // re-create thisX500Name
<span class="nc" id="L511">        thisX500Name = new X500Name((byte[])s.readObject());</span>
<span class="nc" id="L512">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>