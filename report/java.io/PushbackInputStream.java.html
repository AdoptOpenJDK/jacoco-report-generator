<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PushbackInputStream.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.io</a> &gt; <span class="el_source">PushbackInputStream.java</span></div><h1>PushbackInputStream.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.io;

/**
 * A &lt;code&gt;PushbackInputStream&lt;/code&gt; adds
 * functionality to another input stream, namely
 * the  ability to &quot;push back&quot; or &quot;unread&quot;
 * one byte. This is useful in situations where
 * it is  convenient for a fragment of code
 * to read an indefinite number of data bytes
 * that  are delimited by a particular byte
 * value; after reading the terminating byte,
 * the  code fragment can &quot;unread&quot; it, so that
 * the next read operation on the input stream
 * will reread the byte that was pushed back.
 * For example, bytes representing the  characters
 * constituting an identifier might be terminated
 * by a byte representing an  operator character;
 * a method whose job is to read just an identifier
 * can read until it  sees the operator and
 * then push the operator back to be re-read.
 *
 * @author  David Connelly
 * @author  Jonathan Payne
 * @since   JDK1.0
 */
public
class PushbackInputStream extends FilterInputStream {
    /**
     * The pushback buffer.
     * @since   JDK1.1
     */
    protected byte[] buf;

    /**
     * The position within the pushback buffer from which the next byte will
     * be read.  When the buffer is empty, &lt;code&gt;pos&lt;/code&gt; is equal to
     * &lt;code&gt;buf.length&lt;/code&gt;; when the buffer is full, &lt;code&gt;pos&lt;/code&gt; is
     * equal to zero.
     *
     * @since   JDK1.1
     */
    protected int pos;

    /**
     * Check to make sure that this stream has not been closed
     */
    private void ensureOpen() throws IOException {
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        if (in == null)</span>
<span class="nc" id="L74">            throw new IOException(&quot;Stream closed&quot;);</span>
<span class="fc" id="L75">    }</span>

    /**
     * Creates a &lt;code&gt;PushbackInputStream&lt;/code&gt;
     * with a pushback buffer of the specified &lt;code&gt;size&lt;/code&gt;,
     * and saves its  argument, the input stream
     * &lt;code&gt;in&lt;/code&gt;, for later use. Initially,
     * there is no pushed-back byte  (the field
     * &lt;code&gt;pushBack&lt;/code&gt; is initialized to
     * &lt;code&gt;-1&lt;/code&gt;).
     *
     * @param  in    the input stream from which bytes will be read.
     * @param  size  the size of the pushback buffer.
     * @exception IllegalArgumentException if {@code size &lt;= 0}
     * @since  JDK1.1
     */
    public PushbackInputStream(InputStream in, int size) {
<span class="fc" id="L92">        super(in);</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (size &lt;= 0) {</span>
<span class="fc" id="L94">            throw new IllegalArgumentException(&quot;size &lt;= 0&quot;);</span>
        }
<span class="fc" id="L96">        this.buf = new byte[size];</span>
<span class="fc" id="L97">        this.pos = size;</span>
<span class="fc" id="L98">    }</span>

    /**
     * Creates a &lt;code&gt;PushbackInputStream&lt;/code&gt;
     * and saves its  argument, the input stream
     * &lt;code&gt;in&lt;/code&gt;, for later use. Initially,
     * there is no pushed-back byte  (the field
     * &lt;code&gt;pushBack&lt;/code&gt; is initialized to
     * &lt;code&gt;-1&lt;/code&gt;).
     *
     * @param   in   the input stream from which bytes will be read.
     */
    public PushbackInputStream(InputStream in) {
<span class="fc" id="L111">        this(in, 1);</span>
<span class="fc" id="L112">    }</span>

    /**
     * Reads the next byte of data from this input stream. The value
     * byte is returned as an &lt;code&gt;int&lt;/code&gt; in the range
     * &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. If no byte is available
     * because the end of the stream has been reached, the value
     * &lt;code&gt;-1&lt;/code&gt; is returned. This method blocks until input data
     * is available, the end of the stream is detected, or an exception
     * is thrown.
     *
     * &lt;p&gt; This method returns the most recently pushed-back byte, if there is
     * one, and otherwise calls the &lt;code&gt;read&lt;/code&gt; method of its underlying
     * input stream and returns whatever value that method returns.
     *
     * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
     *             stream has been reached.
     * @exception  IOException  if this input stream has been closed by
     *             invoking its {@link #close()} method,
     *             or an I/O error occurs.
     * @see        java.io.InputStream#read()
     */
    public int read() throws IOException {
<span class="fc" id="L135">        ensureOpen();</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (pos &lt; buf.length) {</span>
<span class="fc" id="L137">            return buf[pos++] &amp; 0xff;</span>
        }
<span class="fc" id="L139">        return super.read();</span>
    }

    /**
     * Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this input stream into
     * an array of bytes.  This method first reads any pushed-back bytes; after
     * that, if fewer than &lt;code&gt;len&lt;/code&gt; bytes have been read then it
     * reads from the underlying input stream. If &lt;code&gt;len&lt;/code&gt; is not zero, the method
     * blocks until at least 1 byte of input is available; otherwise, no
     * bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.
     *
     * @param      b     the buffer into which the data is read.
     * @param      off   the start offset in the destination array &lt;code&gt;b&lt;/code&gt;
     * @param      len   the maximum number of bytes read.
     * @return     the total number of bytes read into the buffer, or
     *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
     *             the stream has been reached.
     * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
     * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
     * &lt;code&gt;b.length - off&lt;/code&gt;
     * @exception  IOException  if this input stream has been closed by
     *             invoking its {@link #close()} method,
     *             or an I/O error occurs.
     * @see        java.io.InputStream#read(byte[], int, int)
     */
    public int read(byte[] b, int off, int len) throws IOException {
<span class="fc" id="L166">        ensureOpen();</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (b == null) {</span>
<span class="nc" id="L168">            throw new NullPointerException();</span>
<span class="pc bpc" id="L169" title="3 of 6 branches missed.">        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {</span>
<span class="nc" id="L170">            throw new IndexOutOfBoundsException();</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        } else if (len == 0) {</span>
<span class="nc" id="L172">            return 0;</span>
        }

<span class="fc" id="L175">        int avail = buf.length - pos;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (avail &gt; 0) {</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            if (len &lt; avail) {</span>
<span class="fc" id="L178">                avail = len;</span>
            }
<span class="fc" id="L180">            System.arraycopy(buf, pos, b, off, avail);</span>
<span class="fc" id="L181">            pos += avail;</span>
<span class="fc" id="L182">            off += avail;</span>
<span class="fc" id="L183">            len -= avail;</span>
        }
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (len &gt; 0) {</span>
<span class="fc" id="L186">            len = super.read(b, off, len);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">            if (len == -1) {</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                return avail == 0 ? -1 : avail;</span>
            }
<span class="fc" id="L190">            return avail + len;</span>
        }
<span class="fc" id="L192">        return avail;</span>
    }

    /**
     * Pushes back a byte by copying it to the front of the pushback buffer.
     * After this method returns, the next byte to be read will have the value
     * &lt;code&gt;(byte)b&lt;/code&gt;.
     *
     * @param      b   the &lt;code&gt;int&lt;/code&gt; value whose low-order
     *                  byte is to be pushed back.
     * @exception IOException If there is not enough room in the pushback
     *            buffer for the byte, or this input stream has been closed by
     *            invoking its {@link #close()} method.
     */
    public void unread(int b) throws IOException {
<span class="fc" id="L207">        ensureOpen();</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (pos == 0) {</span>
<span class="nc" id="L209">            throw new IOException(&quot;Push back buffer is full&quot;);</span>
        }
<span class="fc" id="L211">        buf[--pos] = (byte)b;</span>
<span class="fc" id="L212">    }</span>

    /**
     * Pushes back a portion of an array of bytes by copying it to the front
     * of the pushback buffer.  After this method returns, the next byte to be
     * read will have the value &lt;code&gt;b[off]&lt;/code&gt;, the byte after that will
     * have the value &lt;code&gt;b[off+1]&lt;/code&gt;, and so forth.
     *
     * @param b the byte array to push back.
     * @param off the start offset of the data.
     * @param len the number of bytes to push back.
     * @exception IOException If there is not enough room in the pushback
     *            buffer for the specified number of bytes,
     *            or this input stream has been closed by
     *            invoking its {@link #close()} method.
     * @since     JDK1.1
     */
    public void unread(byte[] b, int off, int len) throws IOException {
<span class="fc" id="L230">        ensureOpen();</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (len &gt; pos) {</span>
<span class="nc" id="L232">            throw new IOException(&quot;Push back buffer is full&quot;);</span>
        }
<span class="fc" id="L234">        pos -= len;</span>
<span class="fc" id="L235">        System.arraycopy(b, off, buf, pos, len);</span>
<span class="fc" id="L236">    }</span>

    /**
     * Pushes back an array of bytes by copying it to the front of the
     * pushback buffer.  After this method returns, the next byte to be read
     * will have the value &lt;code&gt;b[0]&lt;/code&gt;, the byte after that will have the
     * value &lt;code&gt;b[1]&lt;/code&gt;, and so forth.
     *
     * @param b the byte array to push back
     * @exception IOException If there is not enough room in the pushback
     *            buffer for the specified number of bytes,
     *            or this input stream has been closed by
     *            invoking its {@link #close()} method.
     * @since     JDK1.1
     */
    public void unread(byte[] b) throws IOException {
<span class="nc" id="L252">        unread(b, 0, b.length);</span>
<span class="nc" id="L253">    }</span>

    /**
     * Returns an estimate of the number of bytes that can be read (or
     * skipped over) from this input stream without blocking by the next
     * invocation of a method for this input stream. The next invocation might be
     * the same thread or another thread.  A single read or skip of this
     * many bytes will not block, but may read or skip fewer bytes.
     *
     * &lt;p&gt; The method returns the sum of the number of bytes that have been
     * pushed back and the value returned by {@link
     * java.io.FilterInputStream#available available}.
     *
     * @return     the number of bytes that can be read (or skipped over) from
     *             the input stream without blocking.
     * @exception  IOException  if this input stream has been closed by
     *             invoking its {@link #close()} method,
     *             or an I/O error occurs.
     * @see        java.io.FilterInputStream#in
     * @see        java.io.InputStream#available()
     */
    public int available() throws IOException {
<span class="fc" id="L275">        ensureOpen();</span>
<span class="fc" id="L276">        int n = buf.length - pos;</span>
<span class="fc" id="L277">        int avail = super.available();</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        return n &gt; (Integer.MAX_VALUE - avail)</span>
                    ? Integer.MAX_VALUE
                    : n + avail;
    }

    /**
     * Skips over and discards &lt;code&gt;n&lt;/code&gt; bytes of data from this
     * input stream. The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of
     * reasons, end up skipping over some smaller number of bytes,
     * possibly zero.  If &lt;code&gt;n&lt;/code&gt; is negative, no bytes are skipped.
     *
     * &lt;p&gt; The &lt;code&gt;skip&lt;/code&gt; method of &lt;code&gt;PushbackInputStream&lt;/code&gt;
     * first skips over the bytes in the pushback buffer, if any.  It then
     * calls the &lt;code&gt;skip&lt;/code&gt; method of the underlying input stream if
     * more bytes need to be skipped.  The actual number of bytes skipped
     * is returned.
     *
     * @param      n  {@inheritDoc}
     * @return     {@inheritDoc}
     * @exception  IOException  if the stream does not support seek,
     *            or the stream has been closed by
     *            invoking its {@link #close()} method,
     *            or an I/O error occurs.
     * @see        java.io.FilterInputStream#in
     * @see        java.io.InputStream#skip(long n)
     * @since      1.2
     */
    public long skip(long n) throws IOException {
<span class="fc" id="L306">        ensureOpen();</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (n &lt;= 0) {</span>
<span class="nc" id="L308">            return 0;</span>
        }

<span class="fc" id="L311">        long pskip = buf.length - pos;</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (pskip &gt; 0) {</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">            if (n &lt; pskip) {</span>
<span class="fc" id="L314">                pskip = n;</span>
            }
<span class="fc" id="L316">            pos += pskip;</span>
<span class="fc" id="L317">            n -= pskip;</span>
        }
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (n &gt; 0) {</span>
<span class="fc" id="L320">            pskip += super.skip(n);</span>
        }
<span class="fc" id="L322">        return pskip;</span>
    }

    /**
     * Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt; and
     * &lt;code&gt;reset&lt;/code&gt; methods, which it does not.
     *
     * @return   &lt;code&gt;false&lt;/code&gt;, since this class does not support the
     *           &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; methods.
     * @see     java.io.InputStream#mark(int)
     * @see     java.io.InputStream#reset()
     */
    public boolean markSupported() {
<span class="nc" id="L335">        return false;</span>
    }

    /**
     * Marks the current position in this input stream.
     *
     * &lt;p&gt; The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;PushbackInputStream&lt;/code&gt;
     * does nothing.
     *
     * @param   readlimit   the maximum limit of bytes that can be read before
     *                      the mark position becomes invalid.
     * @see     java.io.InputStream#reset()
     */
    public synchronized void mark(int readlimit) {
<span class="nc" id="L349">    }</span>

    /**
     * Repositions this stream to the position at the time the
     * &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.
     *
     * &lt;p&gt; The method &lt;code&gt;reset&lt;/code&gt; for class
     * &lt;code&gt;PushbackInputStream&lt;/code&gt; does nothing except throw an
     * &lt;code&gt;IOException&lt;/code&gt;.
     *
     * @exception  IOException  if this method is invoked.
     * @see     java.io.InputStream#mark(int)
     * @see     java.io.IOException
     */
    public synchronized void reset() throws IOException {
<span class="nc" id="L364">        throw new IOException(&quot;mark/reset not supported&quot;);</span>
    }

    /**
     * Closes this input stream and releases any system resources
     * associated with the stream.
     * Once the stream has been closed, further read(), unread(),
     * available(), reset(), or skip() invocations will throw an IOException.
     * Closing a previously closed stream has no effect.
     *
     * @exception  IOException  if an I/O error occurs.
     */
    public synchronized void close() throws IOException {
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        if (in == null)</span>
<span class="nc" id="L378">            return;</span>
<span class="fc" id="L379">        in.close();</span>
<span class="fc" id="L380">        in = null;</span>
<span class="fc" id="L381">        buf = null;</span>
<span class="fc" id="L382">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>