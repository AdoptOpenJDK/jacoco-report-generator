<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RandomAccessFile.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.io</a> &gt; <span class="el_source">RandomAccessFile.java</span></div><h1>RandomAccessFile.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.io;

import java.nio.channels.FileChannel;
import sun.nio.ch.FileChannelImpl;


/**
 * Instances of this class support both reading and writing to a
 * random access file. A random access file behaves like a large
 * array of bytes stored in the file system. There is a kind of cursor,
 * or index into the implied array, called the &lt;em&gt;file pointer&lt;/em&gt;;
 * input operations read bytes starting at the file pointer and advance
 * the file pointer past the bytes read. If the random access file is
 * created in read/write mode, then output operations are also available;
 * output operations write bytes starting at the file pointer and advance
 * the file pointer past the bytes written. Output operations that write
 * past the current end of the implied array cause the array to be
 * extended. The file pointer can be read by the
 * {@code getFilePointer} method and set by the {@code seek}
 * method.
 * &lt;p&gt;
 * It is generally true of all the reading routines in this class that
 * if end-of-file is reached before the desired number of bytes has been
 * read, an {@code EOFException} (which is a kind of
 * {@code IOException}) is thrown. If any byte cannot be read for
 * any reason other than end-of-file, an {@code IOException} other
 * than {@code EOFException} is thrown. In particular, an
 * {@code IOException} may be thrown if the stream has been closed.
 *
 * @author  unascribed
 * @since   JDK1.0
 */

public class RandomAccessFile implements DataOutput, DataInput, Closeable {

    private FileDescriptor fd;
<span class="fc" id="L62">    private FileChannel channel = null;</span>
    private boolean rw;

<span class="fc" id="L65">    private Object closeLock = new Object();</span>
<span class="fc" id="L66">    private volatile boolean closed = false;</span>

    private static final int O_RDONLY = 1;
    private static final int O_RDWR =   2;
    private static final int O_SYNC =   4;
    private static final int O_DSYNC =  8;

    /**
     * Creates a random access file stream to read from, and optionally
     * to write to, a file with the specified name. A new
     * {@link FileDescriptor} object is created to represent the
     * connection to the file.
     *
     * &lt;p&gt; The &lt;tt&gt;mode&lt;/tt&gt; argument specifies the access mode with which the
     * file is to be opened.  The permitted values and their meanings are as
     * specified for the &lt;a
     * href=&quot;#mode&quot;&gt;&lt;tt&gt;RandomAccessFile(File,String)&lt;/tt&gt;&lt;/a&gt; constructor.
     *
     * &lt;p&gt;
     * If there is a security manager, its {@code checkRead} method
     * is called with the {@code name} argument
     * as its argument to see if read access to the file is allowed.
     * If the mode allows writing, the security manager's
     * {@code checkWrite} method
     * is also called with the {@code name} argument
     * as its argument to see if write access to the file is allowed.
     *
     * @param      name   the system-dependent filename
     * @param      mode   the access &lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;
     * @exception  IllegalArgumentException  if the mode argument is not equal
     *               to one of &lt;tt&gt;&quot;r&quot;&lt;/tt&gt;, &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt;, &lt;tt&gt;&quot;rws&quot;&lt;/tt&gt;, or
     *               &lt;tt&gt;&quot;rwd&quot;&lt;/tt&gt;
     * @exception FileNotFoundException
     *            if the mode is &lt;tt&gt;&quot;r&quot;&lt;/tt&gt; but the given string does not
     *            denote an existing regular file, or if the mode begins with
     *            &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt; but the given string does not denote an
     *            existing, writable regular file and a new regular file of
     *            that name cannot be created, or if some other error occurs
     *            while opening or creating the file
     * @exception  SecurityException         if a security manager exists and its
     *               {@code checkRead} method denies read access to the file
     *               or the mode is &quot;rw&quot; and the security manager's
     *               {@code checkWrite} method denies write access to the file
     * @see        java.lang.SecurityException
     * @see        java.lang.SecurityManager#checkRead(java.lang.String)
     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
     * @revised 1.4
     * @spec JSR-51
     */
    public RandomAccessFile(String name, String mode)
        throws FileNotFoundException
    {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        this(name != null ? new File(name) : null, mode);</span>
<span class="fc" id="L119">    }</span>

    /**
     * Creates a random access file stream to read from, and optionally to
     * write to, the file specified by the {@link File} argument.  A new {@link
     * FileDescriptor} object is created to represent this file connection.
     *
     * &lt;p&gt;The &lt;a name=&quot;mode&quot;&gt;&lt;tt&gt;mode&lt;/tt&gt;&lt;/a&gt; argument specifies the access mode
     * in which the file is to be opened.  The permitted values and their
     * meanings are:
     *
     * &lt;table summary=&quot;Access mode permitted values and meanings&quot;&gt;
     * &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Value&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;Meaning&lt;/th&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;&quot;r&quot;&lt;/tt&gt;&lt;/td&gt;
     *     &lt;td&gt; Open for reading only.  Invoking any of the &lt;tt&gt;write&lt;/tt&gt;
     *     methods of the resulting object will cause an {@link
     *     java.io.IOException} to be thrown. &lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;&quot;rw&quot;&lt;/tt&gt;&lt;/td&gt;
     *     &lt;td&gt; Open for reading and writing.  If the file does not already
     *     exist then an attempt will be made to create it. &lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;&quot;rws&quot;&lt;/tt&gt;&lt;/td&gt;
     *     &lt;td&gt; Open for reading and writing, as with &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt;, and also
     *     require that every update to the file's content or metadata be
     *     written synchronously to the underlying storage device.  &lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;&quot;rwd&quot;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
     *     &lt;td&gt; Open for reading and writing, as with &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt;, and also
     *     require that every update to the file's content be written
     *     synchronously to the underlying storage device. &lt;/td&gt;&lt;/tr&gt;
     * &lt;/table&gt;
     *
     * The &lt;tt&gt;&quot;rws&quot;&lt;/tt&gt; and &lt;tt&gt;&quot;rwd&quot;&lt;/tt&gt; modes work much like the {@link
     * java.nio.channels.FileChannel#force(boolean) force(boolean)} method of
     * the {@link java.nio.channels.FileChannel} class, passing arguments of
     * &lt;tt&gt;true&lt;/tt&gt; and &lt;tt&gt;false&lt;/tt&gt;, respectively, except that they always
     * apply to every I/O operation and are therefore often more efficient.  If
     * the file resides on a local storage device then when an invocation of a
     * method of this class returns it is guaranteed that all changes made to
     * the file by that invocation will have been written to that device.  This
     * is useful for ensuring that critical information is not lost in the
     * event of a system crash.  If the file does not reside on a local device
     * then no such guarantee is made.
     *
     * &lt;p&gt;The &lt;tt&gt;&quot;rwd&quot;&lt;/tt&gt; mode can be used to reduce the number of I/O
     * operations performed.  Using &lt;tt&gt;&quot;rwd&quot;&lt;/tt&gt; only requires updates to the
     * file's content to be written to storage; using &lt;tt&gt;&quot;rws&quot;&lt;/tt&gt; requires
     * updates to both the file's content and its metadata to be written, which
     * generally requires at least one more low-level I/O operation.
     *
     * &lt;p&gt;If there is a security manager, its {@code checkRead} method is
     * called with the pathname of the {@code file} argument as its
     * argument to see if read access to the file is allowed.  If the mode
     * allows writing, the security manager's {@code checkWrite} method is
     * also called with the path argument to see if write access to the file is
     * allowed.
     *
     * @param      file   the file object
     * @param      mode   the access mode, as described
     *                    &lt;a href=&quot;#mode&quot;&gt;above&lt;/a&gt;
     * @exception  IllegalArgumentException  if the mode argument is not equal
     *               to one of &lt;tt&gt;&quot;r&quot;&lt;/tt&gt;, &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt;, &lt;tt&gt;&quot;rws&quot;&lt;/tt&gt;, or
     *               &lt;tt&gt;&quot;rwd&quot;&lt;/tt&gt;
     * @exception FileNotFoundException
     *            if the mode is &lt;tt&gt;&quot;r&quot;&lt;/tt&gt; but the given file object does
     *            not denote an existing regular file, or if the mode begins
     *            with &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt; but the given file object does not denote
     *            an existing, writable regular file and a new regular file of
     *            that name cannot be created, or if some other error occurs
     *            while opening or creating the file
     * @exception  SecurityException         if a security manager exists and its
     *               {@code checkRead} method denies read access to the file
     *               or the mode is &quot;rw&quot; and the security manager's
     *               {@code checkWrite} method denies write access to the file
     * @see        java.lang.SecurityManager#checkRead(java.lang.String)
     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
     * @see        java.nio.channels.FileChannel#force(boolean)
     * @revised 1.4
     * @spec JSR-51
     */
    public RandomAccessFile(File file, String mode)
        throws FileNotFoundException
<span class="fc" id="L199">    {</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        String name = (file != null ? file.getPath() : null);</span>
<span class="fc" id="L201">        int imode = -1;</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (mode.equals(&quot;r&quot;))</span>
<span class="fc" id="L203">            imode = O_RDONLY;</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        else if (mode.startsWith(&quot;rw&quot;)) {</span>
<span class="fc" id="L205">            imode = O_RDWR;</span>
<span class="fc" id="L206">            rw = true;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (mode.length() &gt; 2) {</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">                if (mode.equals(&quot;rws&quot;))</span>
<span class="nc" id="L209">                    imode |= O_SYNC;</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">                else if (mode.equals(&quot;rwd&quot;))</span>
<span class="fc" id="L211">                    imode |= O_DSYNC;</span>
                else
<span class="nc" id="L213">                    imode = -1;</span>
            }
        }
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (imode &lt; 0)</span>
<span class="nc" id="L217">            throw new IllegalArgumentException(&quot;Illegal mode \&quot;&quot; + mode</span>
                                               + &quot;\&quot; must be one of &quot;
                                               + &quot;\&quot;r\&quot;, \&quot;rw\&quot;, \&quot;rws\&quot;,&quot;
                                               + &quot; or \&quot;rwd\&quot;&quot;);
<span class="fc" id="L221">        SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (security != null) {</span>
<span class="fc" id="L223">            security.checkRead(name);</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">            if (rw) {</span>
<span class="fc" id="L225">                security.checkWrite(name);</span>
            }
        }
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L229">            throw new NullPointerException();</span>
        }
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (file.isInvalid()) {</span>
<span class="nc" id="L232">            throw new FileNotFoundException(&quot;Invalid file path&quot;);</span>
        }
<span class="fc" id="L234">        fd = new FileDescriptor();</span>
<span class="fc" id="L235">        fd.attach(this);</span>
<span class="fc" id="L236">        open(name, imode);</span>
<span class="fc" id="L237">    }</span>

    /**
     * Returns the opaque file descriptor object associated with this
     * stream.
     *
     * @return     the file descriptor object associated with this stream.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.FileDescriptor
     */
    public final FileDescriptor getFD() throws IOException {
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (fd != null) {</span>
<span class="fc" id="L249">            return fd;</span>
        }
<span class="nc" id="L251">        throw new IOException();</span>
    }

    /**
     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
     * object associated with this file.
     *
     * &lt;p&gt; The {@link java.nio.channels.FileChannel#position()
     * position} of the returned channel will always be equal to
     * this object's file-pointer offset as returned by the {@link
     * #getFilePointer getFilePointer} method.  Changing this object's
     * file-pointer offset, whether explicitly or by reading or writing bytes,
     * will change the position of the channel, and vice versa.  Changing the
     * file's length via this object will change the length seen via the file
     * channel, and vice versa.
     *
     * @return  the file channel associated with this file
     *
     * @since 1.4
     * @spec JSR-51
     */
    public final FileChannel getChannel() {
<span class="fc" id="L273">        synchronized (this) {</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">            if (channel == null) {</span>
<span class="fc" id="L275">                channel = FileChannelImpl.open(fd, true, rw, this);</span>
            }
<span class="fc" id="L277">            return channel;</span>
<span class="nc" id="L278">        }</span>
    }

    /**
     * Opens a file and returns the file descriptor.  The file is
     * opened in read-write mode if the O_RDWR bit in {@code mode}
     * is true, else the file is opened as read-only.
     * If the {@code name} refers to a directory, an IOException
     * is thrown.
     *
     * @param name the name of the file
     * @param mode the mode flags, a combination of the O_ constants
     *             defined above
     */
    private native void open(String name, int mode)
        throws FileNotFoundException;

    // 'Read' primitives

    /**
     * Reads a byte of data from this file. The byte is returned as an
     * integer in the range 0 to 255 ({@code 0x00-0x0ff}). This
     * method blocks if no input is yet available.
     * &lt;p&gt;
     * Although {@code RandomAccessFile} is not a subclass of
     * {@code InputStream}, this method behaves in exactly the same
     * way as the {@link InputStream#read()} method of
     * {@code InputStream}.
     *
     * @return     the next byte of data, or {@code -1} if the end of the
     *             file has been reached.
     * @exception  IOException  if an I/O error occurs. Not thrown if
     *                          end-of-file has been reached.
     */
    public native int read() throws IOException;

    /**
     * Reads a sub array as a sequence of bytes.
     * @param b the buffer into which the data is read.
     * @param off the start offset of the data.
     * @param len the number of bytes to read.
     * @exception IOException If an I/O error has occurred.
     */
    private native int readBytes(byte b[], int off, int len) throws IOException;

    /**
     * Reads up to {@code len} bytes of data from this file into an
     * array of bytes. This method blocks until at least one byte of input
     * is available.
     * &lt;p&gt;
     * Although {@code RandomAccessFile} is not a subclass of
     * {@code InputStream}, this method behaves in exactly the
     * same way as the {@link InputStream#read(byte[], int, int)} method of
     * {@code InputStream}.
     *
     * @param      b     the buffer into which the data is read.
     * @param      off   the start offset in array {@code b}
     *                   at which the data is written.
     * @param      len   the maximum number of bytes read.
     * @return     the total number of bytes read into the buffer, or
     *             {@code -1} if there is no more data because the end of
     *             the file has been reached.
     * @exception  IOException If the first byte cannot be read for any reason
     * other than end of file, or if the random access file has been closed, or if
     * some other I/O error occurs.
     * @exception  NullPointerException If {@code b} is {@code null}.
     * @exception  IndexOutOfBoundsException If {@code off} is negative,
     * {@code len} is negative, or {@code len} is greater than
     * {@code b.length - off}
     */
    public int read(byte b[], int off, int len) throws IOException {
<span class="fc" id="L349">        return readBytes(b, off, len);</span>
    }

    /**
     * Reads up to {@code b.length} bytes of data from this file
     * into an array of bytes. This method blocks until at least one byte
     * of input is available.
     * &lt;p&gt;
     * Although {@code RandomAccessFile} is not a subclass of
     * {@code InputStream}, this method behaves in exactly the
     * same way as the {@link InputStream#read(byte[])} method of
     * {@code InputStream}.
     *
     * @param      b   the buffer into which the data is read.
     * @return     the total number of bytes read into the buffer, or
     *             {@code -1} if there is no more data because the end of
     *             this file has been reached.
     * @exception  IOException If the first byte cannot be read for any reason
     * other than end of file, or if the random access file has been closed, or if
     * some other I/O error occurs.
     * @exception  NullPointerException If {@code b} is {@code null}.
     */
    public int read(byte b[]) throws IOException {
<span class="fc" id="L372">        return readBytes(b, 0, b.length);</span>
    }

    /**
     * Reads {@code b.length} bytes from this file into the byte
     * array, starting at the current file pointer. This method reads
     * repeatedly from the file until the requested number of bytes are
     * read. This method blocks until the requested number of bytes are
     * read, the end of the stream is detected, or an exception is thrown.
     *
     * @param      b   the buffer into which the data is read.
     * @exception  EOFException  if this file reaches the end before reading
     *               all the bytes.
     * @exception  IOException   if an I/O error occurs.
     */
    public final void readFully(byte b[]) throws IOException {
<span class="fc" id="L388">        readFully(b, 0, b.length);</span>
<span class="fc" id="L389">    }</span>

    /**
     * Reads exactly {@code len} bytes from this file into the byte
     * array, starting at the current file pointer. This method reads
     * repeatedly from the file until the requested number of bytes are
     * read. This method blocks until the requested number of bytes are
     * read, the end of the stream is detected, or an exception is thrown.
     *
     * @param      b     the buffer into which the data is read.
     * @param      off   the start offset of the data.
     * @param      len   the number of bytes to read.
     * @exception  EOFException  if this file reaches the end before reading
     *               all the bytes.
     * @exception  IOException   if an I/O error occurs.
     */
    public final void readFully(byte b[], int off, int len) throws IOException {
<span class="fc" id="L406">        int n = 0;</span>
        do {
<span class="fc" id="L408">            int count = this.read(b, off + n, len - n);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">            if (count &lt; 0)</span>
<span class="nc" id="L410">                throw new EOFException();</span>
<span class="fc" id="L411">            n += count;</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        } while (n &lt; len);</span>
<span class="fc" id="L413">    }</span>

    /**
     * Attempts to skip over {@code n} bytes of input discarding the
     * skipped bytes.
     * &lt;p&gt;
     *
     * This method may skip over some smaller number of bytes, possibly zero.
     * This may result from any of a number of conditions; reaching end of
     * file before {@code n} bytes have been skipped is only one
     * possibility. This method never throws an {@code EOFException}.
     * The actual number of bytes skipped is returned.  If {@code n}
     * is negative, no bytes are skipped.
     *
     * @param      n   the number of bytes to be skipped.
     * @return     the actual number of bytes skipped.
     * @exception  IOException  if an I/O error occurs.
     */
    public int skipBytes(int n) throws IOException {
        long pos;
        long len;
        long newpos;

<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (n &lt;= 0) {</span>
<span class="nc" id="L437">            return 0;</span>
        }
<span class="fc" id="L439">        pos = getFilePointer();</span>
<span class="fc" id="L440">        len = length();</span>
<span class="fc" id="L441">        newpos = pos + n;</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">        if (newpos &gt; len) {</span>
<span class="nc" id="L443">            newpos = len;</span>
        }
<span class="fc" id="L445">        seek(newpos);</span>

        /* return the actual number of bytes skipped */
<span class="fc" id="L448">        return (int) (newpos - pos);</span>
    }

    // 'Write' primitives

    /**
     * Writes the specified byte to this file. The write starts at
     * the current file pointer.
     *
     * @param      b   the {@code byte} to be written.
     * @exception  IOException  if an I/O error occurs.
     */
    public native void write(int b) throws IOException;

    /**
     * Writes a sub array as a sequence of bytes.
     * @param b the data to be written

     * @param off the start offset in the data
     * @param len the number of bytes that are written
     * @exception IOException If an I/O error has occurred.
     */
    private native void writeBytes(byte b[], int off, int len) throws IOException;

    /**
     * Writes {@code b.length} bytes from the specified byte array
     * to this file, starting at the current file pointer.
     *
     * @param      b   the data.
     * @exception  IOException  if an I/O error occurs.
     */
    public void write(byte b[]) throws IOException {
<span class="fc" id="L480">        writeBytes(b, 0, b.length);</span>
<span class="fc" id="L481">    }</span>

    /**
     * Writes {@code len} bytes from the specified byte array
     * starting at offset {@code off} to this file.
     *
     * @param      b     the data.
     * @param      off   the start offset in the data.
     * @param      len   the number of bytes to write.
     * @exception  IOException  if an I/O error occurs.
     */
    public void write(byte b[], int off, int len) throws IOException {
<span class="fc" id="L493">        writeBytes(b, off, len);</span>
<span class="fc" id="L494">    }</span>

    // 'Random access' stuff

    /**
     * Returns the current offset in this file.
     *
     * @return     the offset from the beginning of the file, in bytes,
     *             at which the next read or write occurs.
     * @exception  IOException  if an I/O error occurs.
     */
    public native long getFilePointer() throws IOException;

    /**
     * Sets the file-pointer offset, measured from the beginning of this
     * file, at which the next read or write occurs.  The offset may be
     * set beyond the end of the file. Setting the offset beyond the end
     * of the file does not change the file length.  The file length will
     * change only by writing after the offset has been set beyond the end
     * of the file.
     *
     * @param      pos   the offset position, measured in bytes from the
     *                   beginning of the file, at which to set the file
     *                   pointer.
     * @exception  IOException  if {@code pos} is less than
     *                          {@code 0} or if an I/O error occurs.
     */
    public void seek(long pos) throws IOException {
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        if (pos &lt; 0) {</span>
<span class="nc" id="L523">            throw new IOException(&quot;Negative seek offset&quot;);</span>
        } else {
<span class="fc" id="L525">            seek0(pos);</span>
        }
<span class="fc" id="L527">    }</span>

    private native void seek0(long pos) throws IOException;

    /**
     * Returns the length of this file.
     *
     * @return     the length of this file, measured in bytes.
     * @exception  IOException  if an I/O error occurs.
     */
    public native long length() throws IOException;

    /**
     * Sets the length of this file.
     *
     * &lt;p&gt; If the present length of the file as returned by the
     * {@code length} method is greater than the {@code newLength}
     * argument then the file will be truncated.  In this case, if the file
     * offset as returned by the {@code getFilePointer} method is greater
     * than {@code newLength} then after this method returns the offset
     * will be equal to {@code newLength}.
     *
     * &lt;p&gt; If the present length of the file as returned by the
     * {@code length} method is smaller than the {@code newLength}
     * argument then the file will be extended.  In this case, the contents of
     * the extended portion of the file are not defined.
     *
     * @param      newLength    The desired length of the file
     * @exception  IOException  If an I/O error occurs
     * @since      1.2
     */
    public native void setLength(long newLength) throws IOException;

    /**
     * Closes this random access file stream and releases any system
     * resources associated with the stream. A closed random access
     * file cannot perform input or output operations and cannot be
     * reopened.
     *
     * &lt;p&gt; If this file has an associated channel then the channel is closed
     * as well.
     *
     * @exception  IOException  if an I/O error occurs.
     *
     * @revised 1.4
     * @spec JSR-51
     */
    public void close() throws IOException {
<span class="fc" id="L575">        synchronized (closeLock) {</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">            if (closed) {</span>
<span class="fc" id="L577">                return;</span>
            }
<span class="fc" id="L579">            closed = true;</span>
<span class="pc" id="L580">        }</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">        if (channel != null) {</span>
<span class="fc" id="L582">            channel.close();</span>
        }

<span class="fc" id="L585">        fd.closeAll(new Closeable() {</span>
            public void close() throws IOException {
<span class="fc" id="L587">               close0();</span>
<span class="fc" id="L588">           }</span>
        });
<span class="fc" id="L590">    }</span>

    //
    //  Some &quot;reading/writing Java data types&quot; methods stolen from
    //  DataInputStream and DataOutputStream.
    //

    /**
     * Reads a {@code boolean} from this file. This method reads a
     * single byte from the file, starting at the current file pointer.
     * A value of {@code 0} represents
     * {@code false}. Any other value represents {@code true}.
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return     the {@code boolean} value read.
     * @exception  EOFException  if this file has reached the end.
     * @exception  IOException   if an I/O error occurs.
     */
    public final boolean readBoolean() throws IOException {
<span class="nc" id="L610">        int ch = this.read();</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">        if (ch &lt; 0)</span>
<span class="nc" id="L612">            throw new EOFException();</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">        return (ch != 0);</span>
    }

    /**
     * Reads a signed eight-bit value from this file. This method reads a
     * byte from the file, starting from the current file pointer.
     * If the byte read is {@code b}, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (byte)(b)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return     the next byte of this file as a signed eight-bit
     *             {@code byte}.
     * @exception  EOFException  if this file has reached the end.
     * @exception  IOException   if an I/O error occurs.
     */
    public final byte readByte() throws IOException {
<span class="nc" id="L635">        int ch = this.read();</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (ch &lt; 0)</span>
<span class="nc" id="L637">            throw new EOFException();</span>
<span class="nc" id="L638">        return (byte)(ch);</span>
    }

    /**
     * Reads an unsigned eight-bit number from this file. This method reads
     * a byte from this file, starting at the current file pointer,
     * and returns that byte.
     * &lt;p&gt;
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return     the next byte of this file, interpreted as an unsigned
     *             eight-bit number.
     * @exception  EOFException  if this file has reached the end.
     * @exception  IOException   if an I/O error occurs.
     */
    public final int readUnsignedByte() throws IOException {
<span class="fc" id="L655">        int ch = this.read();</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        if (ch &lt; 0)</span>
<span class="nc" id="L657">            throw new EOFException();</span>
<span class="fc" id="L658">        return ch;</span>
    }

    /**
     * Reads a signed 16-bit number from this file. The method reads two
     * bytes from this file, starting at the current file pointer.
     * If the two bytes read, in order, are
     * {@code b1} and {@code b2}, where each of the two values is
     * between {@code 0} and {@code 255}, inclusive, then the
     * result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (short)((b1 &amp;lt;&amp;lt; 8) | b2)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next two bytes of this file, interpreted as a signed
     *             16-bit number.
     * @exception  EOFException  if this file reaches the end before reading
     *               two bytes.
     * @exception  IOException   if an I/O error occurs.
     */
    public final short readShort() throws IOException {
<span class="fc" id="L682">        int ch1 = this.read();</span>
<span class="fc" id="L683">        int ch2 = this.read();</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">        if ((ch1 | ch2) &lt; 0)</span>
<span class="nc" id="L685">            throw new EOFException();</span>
<span class="fc" id="L686">        return (short)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));</span>
    }

    /**
     * Reads an unsigned 16-bit number from this file. This method reads
     * two bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * {@code b1} and {@code b2}, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (b1 &amp;lt;&amp;lt; 8) | b2
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next two bytes of this file, interpreted as an unsigned
     *             16-bit integer.
     * @exception  EOFException  if this file reaches the end before reading
     *               two bytes.
     * @exception  IOException   if an I/O error occurs.
     */
    public final int readUnsignedShort() throws IOException {
<span class="nc" id="L710">        int ch1 = this.read();</span>
<span class="nc" id="L711">        int ch2 = this.read();</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if ((ch1 | ch2) &lt; 0)</span>
<span class="nc" id="L713">            throw new EOFException();</span>
<span class="nc" id="L714">        return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0);</span>
    }

    /**
     * Reads a character from this file. This method reads two
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * {@code b1} and {@code b2}, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1,&amp;nbsp;b2&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (char)((b1 &amp;lt;&amp;lt; 8) | b2)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next two bytes of this file, interpreted as a
     *                  {@code char}.
     * @exception  EOFException  if this file reaches the end before reading
     *               two bytes.
     * @exception  IOException   if an I/O error occurs.
     */
    public final char readChar() throws IOException {
<span class="fc" id="L738">        int ch1 = this.read();</span>
<span class="fc" id="L739">        int ch2 = this.read();</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">        if ((ch1 | ch2) &lt; 0)</span>
<span class="nc" id="L741">            throw new EOFException();</span>
<span class="fc" id="L742">        return (char)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));</span>
    }

    /**
     * Reads a signed 32-bit integer from this file. This method reads 4
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are {@code b1},
     * {@code b2}, {@code b3}, and {@code b4}, where
     * &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2, b3, b4&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     (b1 &amp;lt;&amp;lt; 24) | (b2 &amp;lt;&amp;lt; 16) + (b3 &amp;lt;&amp;lt; 8) + b4
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next four bytes of this file, interpreted as an
     *             {@code int}.
     * @exception  EOFException  if this file reaches the end before reading
     *               four bytes.
     * @exception  IOException   if an I/O error occurs.
     */
    public final int readInt() throws IOException {
<span class="fc" id="L766">        int ch1 = this.read();</span>
<span class="fc" id="L767">        int ch2 = this.read();</span>
<span class="fc" id="L768">        int ch3 = this.read();</span>
<span class="fc" id="L769">        int ch4 = this.read();</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">        if ((ch1 | ch2 | ch3 | ch4) &lt; 0)</span>
<span class="nc" id="L771">            throw new EOFException();</span>
<span class="fc" id="L772">        return ((ch1 &lt;&lt; 24) + (ch2 &lt;&lt; 16) + (ch3 &lt;&lt; 8) + (ch4 &lt;&lt; 0));</span>
    }

    /**
     * Reads a signed 64-bit integer from this file. This method reads eight
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * {@code b1}, {@code b2}, {@code b3},
     * {@code b4}, {@code b5}, {@code b6},
     * {@code b7}, and {@code b8,} where:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     0 &amp;lt;= b1, b2, b3, b4, b5, b6, b7, b8 &amp;lt;=255,
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * then the result is equal to:
     * &lt;blockquote&gt;&lt;pre&gt;
     *     ((long)b1 &amp;lt;&amp;lt; 56) + ((long)b2 &amp;lt;&amp;lt; 48)
     *     + ((long)b3 &amp;lt;&amp;lt; 40) + ((long)b4 &amp;lt;&amp;lt; 32)
     *     + ((long)b5 &amp;lt;&amp;lt; 24) + ((long)b6 &amp;lt;&amp;lt; 16)
     *     + ((long)b7 &amp;lt;&amp;lt; 8) + b8
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next eight bytes of this file, interpreted as a
     *             {@code long}.
     * @exception  EOFException  if this file reaches the end before reading
     *               eight bytes.
     * @exception  IOException   if an I/O error occurs.
     */
    public final long readLong() throws IOException {
<span class="fc" id="L804">        return ((long)(readInt()) &lt;&lt; 32) + (readInt() &amp; 0xFFFFFFFFL);</span>
    }

    /**
     * Reads a {@code float} from this file. This method reads an
     * {@code int} value, starting at the current file pointer,
     * as if by the {@code readInt} method
     * and then converts that {@code int} to a {@code float}
     * using the {@code intBitsToFloat} method in class
     * {@code Float}.
     * &lt;p&gt;
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next four bytes of this file, interpreted as a
     *             {@code float}.
     * @exception  EOFException  if this file reaches the end before reading
     *             four bytes.
     * @exception  IOException   if an I/O error occurs.
     * @see        java.io.RandomAccessFile#readInt()
     * @see        java.lang.Float#intBitsToFloat(int)
     */
    public final float readFloat() throws IOException {
<span class="nc" id="L827">        return Float.intBitsToFloat(readInt());</span>
    }

    /**
     * Reads a {@code double} from this file. This method reads a
     * {@code long} value, starting at the current file pointer,
     * as if by the {@code readLong} method
     * and then converts that {@code long} to a {@code double}
     * using the {@code longBitsToDouble} method in
     * class {@code Double}.
     * &lt;p&gt;
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     the next eight bytes of this file, interpreted as a
     *             {@code double}.
     * @exception  EOFException  if this file reaches the end before reading
     *             eight bytes.
     * @exception  IOException   if an I/O error occurs.
     * @see        java.io.RandomAccessFile#readLong()
     * @see        java.lang.Double#longBitsToDouble(long)
     */
    public final double readDouble() throws IOException {
<span class="nc" id="L850">        return Double.longBitsToDouble(readLong());</span>
    }

    /**
     * Reads the next line of text from this file.  This method successively
     * reads bytes from the file, starting at the current file pointer,
     * until it reaches a line terminator or the end
     * of the file.  Each byte is converted into a character by taking the
     * byte's value for the lower eight bits of the character and setting the
     * high eight bits of the character to zero.  This method does not,
     * therefore, support the full Unicode character set.
     *
     * &lt;p&gt; A line of text is terminated by a carriage-return character
     * ({@code '\u005Cr'}), a newline character ({@code '\u005Cn'}), a
     * carriage-return character immediately followed by a newline character,
     * or the end of the file.  Line-terminating characters are discarded and
     * are not included as part of the string returned.
     *
     * &lt;p&gt; This method blocks until a newline character is read, a carriage
     * return and the byte following it are read (to see if it is a newline),
     * the end of the file is reached, or an exception is thrown.
     *
     * @return     the next line of text from this file, or null if end
     *             of file is encountered before even one byte is read.
     * @exception  IOException  if an I/O error occurs.
     */

    public final String readLine() throws IOException {
<span class="nc" id="L878">        StringBuffer input = new StringBuffer();</span>
<span class="nc" id="L879">        int c = -1;</span>
<span class="nc" id="L880">        boolean eol = false;</span>

<span class="nc bnc" id="L882" title="All 2 branches missed.">        while (!eol) {</span>
<span class="nc bnc" id="L883" title="All 3 branches missed.">            switch (c = read()) {</span>
            case -1:
            case '\n':
<span class="nc" id="L886">                eol = true;</span>
<span class="nc" id="L887">                break;</span>
            case '\r':
<span class="nc" id="L889">                eol = true;</span>
<span class="nc" id="L890">                long cur = getFilePointer();</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">                if ((read()) != '\n') {</span>
<span class="nc" id="L892">                    seek(cur);</span>
                }
                break;
            default:
<span class="nc" id="L896">                input.append((char)c);</span>
<span class="nc" id="L897">                break;</span>
            }
        }

<span class="nc bnc" id="L901" title="All 4 branches missed.">        if ((c == -1) &amp;&amp; (input.length() == 0)) {</span>
<span class="nc" id="L902">            return null;</span>
        }
<span class="nc" id="L904">        return input.toString();</span>
    }

    /**
     * Reads in a string from this file. The string has been encoded
     * using a
     * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
     * format.
     * &lt;p&gt;
     * The first two bytes are read, starting from the current file
     * pointer, as if by
     * {@code readUnsignedShort}. This value gives the number of
     * following bytes that are in the encoded string, not
     * the length of the resulting string. The following bytes are then
     * interpreted as bytes encoding characters in the modified UTF-8 format
     * and are converted into characters.
     * &lt;p&gt;
     * This method blocks until all the bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @return     a Unicode string.
     * @exception  EOFException            if this file reaches the end before
     *               reading all the bytes.
     * @exception  IOException             if an I/O error occurs.
     * @exception  UTFDataFormatException  if the bytes do not represent
     *               valid modified UTF-8 encoding of a Unicode string.
     * @see        java.io.RandomAccessFile#readUnsignedShort()
     */
    public final String readUTF() throws IOException {
<span class="nc" id="L933">        return DataInputStream.readUTF(this);</span>
    }

    /**
     * Writes a {@code boolean} to the file as a one-byte value. The
     * value {@code true} is written out as the value
     * {@code (byte)1}; the value {@code false} is written out
     * as the value {@code (byte)0}. The write starts at
     * the current position of the file pointer.
     *
     * @param      v   a {@code boolean} value to be written.
     * @exception  IOException  if an I/O error occurs.
     */
    public final void writeBoolean(boolean v) throws IOException {
<span class="nc bnc" id="L947" title="All 2 branches missed.">        write(v ? 1 : 0);</span>
        //written++;
<span class="nc" id="L949">    }</span>

    /**
     * Writes a {@code byte} to the file as a one-byte value. The
     * write starts at the current position of the file pointer.
     *
     * @param      v   a {@code byte} value to be written.
     * @exception  IOException  if an I/O error occurs.
     */
    public final void writeByte(int v) throws IOException {
<span class="fc" id="L959">        write(v);</span>
        //written++;
<span class="fc" id="L961">    }</span>

    /**
     * Writes a {@code short} to the file as two bytes, high byte first.
     * The write starts at the current position of the file pointer.
     *
     * @param      v   a {@code short} to be written.
     * @exception  IOException  if an I/O error occurs.
     */
    public final void writeShort(int v) throws IOException {
<span class="fc" id="L971">        write((v &gt;&gt;&gt; 8) &amp; 0xFF);</span>
<span class="fc" id="L972">        write((v &gt;&gt;&gt; 0) &amp; 0xFF);</span>
        //written += 2;
<span class="fc" id="L974">    }</span>

    /**
     * Writes a {@code char} to the file as a two-byte value, high
     * byte first. The write starts at the current position of the
     * file pointer.
     *
     * @param      v   a {@code char} value to be written.
     * @exception  IOException  if an I/O error occurs.
     */
    public final void writeChar(int v) throws IOException {
<span class="fc" id="L985">        write((v &gt;&gt;&gt; 8) &amp; 0xFF);</span>
<span class="fc" id="L986">        write((v &gt;&gt;&gt; 0) &amp; 0xFF);</span>
        //written += 2;
<span class="fc" id="L988">    }</span>

    /**
     * Writes an {@code int} to the file as four bytes, high byte first.
     * The write starts at the current position of the file pointer.
     *
     * @param      v   an {@code int} to be written.
     * @exception  IOException  if an I/O error occurs.
     */
    public final void writeInt(int v) throws IOException {
<span class="fc" id="L998">        write((v &gt;&gt;&gt; 24) &amp; 0xFF);</span>
<span class="fc" id="L999">        write((v &gt;&gt;&gt; 16) &amp; 0xFF);</span>
<span class="fc" id="L1000">        write((v &gt;&gt;&gt;  8) &amp; 0xFF);</span>
<span class="fc" id="L1001">        write((v &gt;&gt;&gt;  0) &amp; 0xFF);</span>
        //written += 4;
<span class="fc" id="L1003">    }</span>

    /**
     * Writes a {@code long} to the file as eight bytes, high byte first.
     * The write starts at the current position of the file pointer.
     *
     * @param      v   a {@code long} to be written.
     * @exception  IOException  if an I/O error occurs.
     */
    public final void writeLong(long v) throws IOException {
<span class="fc" id="L1013">        write((int)(v &gt;&gt;&gt; 56) &amp; 0xFF);</span>
<span class="fc" id="L1014">        write((int)(v &gt;&gt;&gt; 48) &amp; 0xFF);</span>
<span class="fc" id="L1015">        write((int)(v &gt;&gt;&gt; 40) &amp; 0xFF);</span>
<span class="fc" id="L1016">        write((int)(v &gt;&gt;&gt; 32) &amp; 0xFF);</span>
<span class="fc" id="L1017">        write((int)(v &gt;&gt;&gt; 24) &amp; 0xFF);</span>
<span class="fc" id="L1018">        write((int)(v &gt;&gt;&gt; 16) &amp; 0xFF);</span>
<span class="fc" id="L1019">        write((int)(v &gt;&gt;&gt;  8) &amp; 0xFF);</span>
<span class="fc" id="L1020">        write((int)(v &gt;&gt;&gt;  0) &amp; 0xFF);</span>
        //written += 8;
<span class="fc" id="L1022">    }</span>

    /**
     * Converts the float argument to an {@code int} using the
     * {@code floatToIntBits} method in class {@code Float},
     * and then writes that {@code int} value to the file as a
     * four-byte quantity, high byte first. The write starts at the
     * current position of the file pointer.
     *
     * @param      v   a {@code float} value to be written.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.lang.Float#floatToIntBits(float)
     */
    public final void writeFloat(float v) throws IOException {
<span class="nc" id="L1036">        writeInt(Float.floatToIntBits(v));</span>
<span class="nc" id="L1037">    }</span>

    /**
     * Converts the double argument to a {@code long} using the
     * {@code doubleToLongBits} method in class {@code Double},
     * and then writes that {@code long} value to the file as an
     * eight-byte quantity, high byte first. The write starts at the current
     * position of the file pointer.
     *
     * @param      v   a {@code double} value to be written.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.lang.Double#doubleToLongBits(double)
     */
    public final void writeDouble(double v) throws IOException {
<span class="nc" id="L1051">        writeLong(Double.doubleToLongBits(v));</span>
<span class="nc" id="L1052">    }</span>

    /**
     * Writes the string to the file as a sequence of bytes. Each
     * character in the string is written out, in sequence, by discarding
     * its high eight bits. The write starts at the current position of
     * the file pointer.
     *
     * @param      s   a string of bytes to be written.
     * @exception  IOException  if an I/O error occurs.
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public final void writeBytes(String s) throws IOException {
<span class="fc" id="L1065">        int len = s.length();</span>
<span class="fc" id="L1066">        byte[] b = new byte[len];</span>
<span class="fc" id="L1067">        s.getBytes(0, len, b, 0);</span>
<span class="fc" id="L1068">        writeBytes(b, 0, len);</span>
<span class="fc" id="L1069">    }</span>

    /**
     * Writes a string to the file as a sequence of characters. Each
     * character is written to the data output stream as if by the
     * {@code writeChar} method. The write starts at the current
     * position of the file pointer.
     *
     * @param      s   a {@code String} value to be written.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.RandomAccessFile#writeChar(int)
     */
    public final void writeChars(String s) throws IOException {
<span class="nc" id="L1082">        int clen = s.length();</span>
<span class="nc" id="L1083">        int blen = 2*clen;</span>
<span class="nc" id="L1084">        byte[] b = new byte[blen];</span>
<span class="nc" id="L1085">        char[] c = new char[clen];</span>
<span class="nc" id="L1086">        s.getChars(0, clen, c, 0);</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">        for (int i = 0, j = 0; i &lt; clen; i++) {</span>
<span class="nc" id="L1088">            b[j++] = (byte)(c[i] &gt;&gt;&gt; 8);</span>
<span class="nc" id="L1089">            b[j++] = (byte)(c[i] &gt;&gt;&gt; 0);</span>
        }
<span class="nc" id="L1091">        writeBytes(b, 0, blen);</span>
<span class="nc" id="L1092">    }</span>

    /**
     * Writes a string to the file using
     * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
     * encoding in a machine-independent manner.
     * &lt;p&gt;
     * First, two bytes are written to the file, starting at the
     * current file pointer, as if by the
     * {@code writeShort} method giving the number of bytes to
     * follow. This value is the number of bytes actually written out,
     * not the length of the string. Following the length, each character
     * of the string is output, in sequence, using the modified UTF-8 encoding
     * for each character.
     *
     * @param      str   a string to be written.
     * @exception  IOException  if an I/O error occurs.
     */
    public final void writeUTF(String str) throws IOException {
<span class="nc" id="L1111">        DataOutputStream.writeUTF(str, this);</span>
<span class="nc" id="L1112">    }</span>

    private static native void initIDs();

    private native void close0() throws IOException;

    static {
<span class="fc" id="L1119">        initIDs();</span>
<span class="fc" id="L1120">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>