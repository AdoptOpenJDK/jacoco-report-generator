<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ObjectInputStream.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.io</a> &gt; <span class="el_source">ObjectInputStream.java</span></div><h1>ObjectInputStream.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.io;

import java.io.ObjectStreamClass.WeakClassKey;
import java.lang.ref.ReferenceQueue;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import java.lang.reflect.Proxy;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicBoolean;
import static java.io.ObjectStreamClass.processQueue;
import sun.reflect.misc.ReflectUtil;

/**
 * An ObjectInputStream deserializes primitive data and objects previously
 * written using an ObjectOutputStream.
 *
 * &lt;p&gt;ObjectOutputStream and ObjectInputStream can provide an application with
 * persistent storage for graphs of objects when used with a FileOutputStream
 * and FileInputStream respectively.  ObjectInputStream is used to recover
 * those objects previously serialized. Other uses include passing objects
 * between hosts using a socket stream or for marshaling and unmarshaling
 * arguments and parameters in a remote communication system.
 *
 * &lt;p&gt;ObjectInputStream ensures that the types of all objects in the graph
 * created from the stream match the classes present in the Java Virtual
 * Machine.  Classes are loaded as required using the standard mechanisms.
 *
 * &lt;p&gt;Only objects that support the java.io.Serializable or
 * java.io.Externalizable interface can be read from streams.
 *
 * &lt;p&gt;The method &lt;code&gt;readObject&lt;/code&gt; is used to read an object from the
 * stream.  Java's safe casting should be used to get the desired type.  In
 * Java, strings and arrays are objects and are treated as objects during
 * serialization. When read they need to be cast to the expected type.
 *
 * &lt;p&gt;Primitive data types can be read from the stream using the appropriate
 * method on DataInput.
 *
 * &lt;p&gt;The default deserialization mechanism for objects restores the contents
 * of each field to the value and type it had when it was written.  Fields
 * declared as transient or static are ignored by the deserialization process.
 * References to other objects cause those objects to be read from the stream
 * as necessary.  Graphs of objects are restored correctly using a reference
 * sharing mechanism.  New objects are always allocated when deserializing,
 * which prevents existing objects from being overwritten.
 *
 * &lt;p&gt;Reading an object is analogous to running the constructors of a new
 * object.  Memory is allocated for the object and initialized to zero (NULL).
 * No-arg constructors are invoked for the non-serializable classes and then
 * the fields of the serializable classes are restored from the stream starting
 * with the serializable class closest to java.lang.object and finishing with
 * the object's most specific class.
 *
 * &lt;p&gt;For example to read from a stream as written by the example in
 * ObjectOutputStream:
 * &lt;br&gt;
 * &lt;pre&gt;
 *      FileInputStream fis = new FileInputStream(&quot;t.tmp&quot;);
 *      ObjectInputStream ois = new ObjectInputStream(fis);
 *
 *      int i = ois.readInt();
 *      String today = (String) ois.readObject();
 *      Date date = (Date) ois.readObject();
 *
 *      ois.close();
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Classes control how they are serialized by implementing either the
 * java.io.Serializable or java.io.Externalizable interfaces.
 *
 * &lt;p&gt;Implementing the Serializable interface allows object serialization to
 * save and restore the entire state of the object and it allows classes to
 * evolve between the time the stream is written and the time it is read.  It
 * automatically traverses references between objects, saving and restoring
 * entire graphs.
 *
 * &lt;p&gt;Serializable classes that require special handling during the
 * serialization and deserialization process should implement the following
 * methods:
 *
 * &lt;pre&gt;
 * private void writeObject(java.io.ObjectOutputStream stream)
 *     throws IOException;
 * private void readObject(java.io.ObjectInputStream stream)
 *     throws IOException, ClassNotFoundException;
 * private void readObjectNoData()
 *     throws ObjectStreamException;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;The readObject method is responsible for reading and restoring the state
 * of the object for its particular class using data written to the stream by
 * the corresponding writeObject method.  The method does not need to concern
 * itself with the state belonging to its superclasses or subclasses.  State is
 * restored by reading data from the ObjectInputStream for the individual
 * fields and making assignments to the appropriate fields of the object.
 * Reading primitive data types is supported by DataInput.
 *
 * &lt;p&gt;Any attempt to read object data which exceeds the boundaries of the
 * custom data written by the corresponding writeObject method will cause an
 * OptionalDataException to be thrown with an eof field value of true.
 * Non-object reads which exceed the end of the allotted data will reflect the
 * end of data in the same way that they would indicate the end of the stream:
 * bytewise reads will return -1 as the byte read or number of bytes read, and
 * primitive reads will throw EOFExceptions.  If there is no corresponding
 * writeObject method, then the end of default serialized data marks the end of
 * the allotted data.
 *
 * &lt;p&gt;Primitive and object read calls issued from within a readExternal method
 * behave in the same manner--if the stream is already positioned at the end of
 * data written by the corresponding writeExternal method, object reads will
 * throw OptionalDataExceptions with eof set to true, bytewise reads will
 * return -1, and primitive reads will throw EOFExceptions.  Note that this
 * behavior does not hold for streams written with the old
 * &lt;code&gt;ObjectStreamConstants.PROTOCOL_VERSION_1&lt;/code&gt; protocol, in which the
 * end of data written by writeExternal methods is not demarcated, and hence
 * cannot be detected.
 *
 * &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
 * the object for its particular class in the event that the serialization
 * stream does not list the given class as a superclass of the object being
 * deserialized.  This may occur in cases where the receiving party uses a
 * different version of the deserialized instance's class than the sending
 * party, and the receiver's version extends classes that are not extended by
 * the sender's version.  This may also occur if the serialization stream has
 * been tampered; hence, readObjectNoData is useful for initializing
 * deserialized objects properly despite a &quot;hostile&quot; or incomplete source
 * stream.
 *
 * &lt;p&gt;Serialization does not read or assign values to the fields of any object
 * that does not implement the java.io.Serializable interface.  Subclasses of
 * Objects that are not serializable can be serializable. In this case the
 * non-serializable class must have a no-arg constructor to allow its fields to
 * be initialized.  In this case it is the responsibility of the subclass to
 * save and restore the state of the non-serializable class. It is frequently
 * the case that the fields of that class are accessible (public, package, or
 * protected) or that there are get and set methods that can be used to restore
 * the state.
 *
 * &lt;p&gt;Any exception that occurs while deserializing an object will be caught by
 * the ObjectInputStream and abort the reading process.
 *
 * &lt;p&gt;Implementing the Externalizable interface allows the object to assume
 * complete control over the contents and format of the object's serialized
 * form.  The methods of the Externalizable interface, writeExternal and
 * readExternal, are called to save and restore the objects state.  When
 * implemented by a class they can write and read their own state using all of
 * the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 * the objects to handle any versioning that occurs.
 *
 * &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
 * externalizable objects.  The serialized form of an enum constant consists
 * solely of its name; field values of the constant are not transmitted.  To
 * deserialize an enum constant, ObjectInputStream reads the constant name from
 * the stream; the deserialized constant is then obtained by calling the static
 * method &lt;code&gt;Enum.valueOf(Class, String)&lt;/code&gt; with the enum constant's
 * base type and the received constant name as arguments.  Like other
 * serializable or externalizable objects, enum constants can function as the
 * targets of back references appearing subsequently in the serialization
 * stream.  The process by which enum constants are deserialized cannot be
 * customized: any class-specific readObject, readObjectNoData, and readResolve
 * methods defined by enum types are ignored during deserialization.
 * Similarly, any serialPersistentFields or serialVersionUID field declarations
 * are also ignored--all enum types have a fixed serialVersionUID of 0L.
 *
 * @author      Mike Warres
 * @author      Roger Riggs
 * @see java.io.DataInput
 * @see java.io.ObjectOutputStream
 * @see java.io.Serializable
 * @see &lt;a href=&quot;../../../platform/serialization/spec/input.html&quot;&gt; Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;
 * @since   JDK1.1
 */
public class ObjectInputStream
    extends InputStream implements ObjectInput, ObjectStreamConstants
{
    /** handle value representing null */
    private static final int NULL_HANDLE = -1;

    /** marker for unshared objects in internal handle table */
<span class="fc" id="L213">    private static final Object unsharedMarker = new Object();</span>

    /** table mapping primitive type names to corresponding class objects */
<span class="fc" id="L216">    private static final HashMap&lt;String, Class&lt;?&gt;&gt; primClasses</span>
        = new HashMap&lt;&gt;(8, 1.0F);
    static {
<span class="fc" id="L219">        primClasses.put(&quot;boolean&quot;, boolean.class);</span>
<span class="fc" id="L220">        primClasses.put(&quot;byte&quot;, byte.class);</span>
<span class="fc" id="L221">        primClasses.put(&quot;char&quot;, char.class);</span>
<span class="fc" id="L222">        primClasses.put(&quot;short&quot;, short.class);</span>
<span class="fc" id="L223">        primClasses.put(&quot;int&quot;, int.class);</span>
<span class="fc" id="L224">        primClasses.put(&quot;long&quot;, long.class);</span>
<span class="fc" id="L225">        primClasses.put(&quot;float&quot;, float.class);</span>
<span class="fc" id="L226">        primClasses.put(&quot;double&quot;, double.class);</span>
<span class="fc" id="L227">        primClasses.put(&quot;void&quot;, void.class);</span>
<span class="fc" id="L228">    }</span>

<span class="nc" id="L230">    private static class Caches {</span>
        /** cache of subclass security audit results */
<span class="fc" id="L232">        static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =</span>
            new ConcurrentHashMap&lt;&gt;();

        /** queue for WeakReferences to audited subclasses */
<span class="fc" id="L236">        static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =</span>
            new ReferenceQueue&lt;&gt;();
    }

    /** filter stream for handling block data conversion */
    private final BlockDataInputStream bin;
    /** validation callback list */
    private final ValidationList vlist;
    /** recursion depth */
    private int depth;
    /** whether stream is closed */
    private boolean closed;

    /** wire handle -&gt; obj/exception map */
    private final HandleTable handles;
    /** scratch field for passing handle values up/down call stack */
<span class="pc" id="L252">    private int passHandle = NULL_HANDLE;</span>
    /** flag set when at end of field value block with no TC_ENDBLOCKDATA */
<span class="pc" id="L254">    private boolean defaultDataEnd = false;</span>

    /** buffer for reading primitive field values */
    private byte[] primVals;

    /** if true, invoke readObjectOverride() instead of readObject() */
    private final boolean enableOverride;
    /** if true, invoke resolveObject() */
    private boolean enableResolve;

    /**
     * Context during upcalls to class-defined readObject methods; holds
     * object currently being deserialized and descriptor for current class.
     * Null when not during readObject upcall.
     */
    private SerialCallbackContext curContext;

    /**
     * Creates an ObjectInputStream that reads from the specified InputStream.
     * A serialization stream header is read from the stream and verified.
     * This constructor will block until the corresponding ObjectOutputStream
     * has written and flushed the header.
     *
     * &lt;p&gt;If a security manager is installed, this constructor will check for
     * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
     * directly or indirectly by the constructor of a subclass which overrides
     * the ObjectInputStream.readFields or ObjectInputStream.readUnshared
     * methods.
     *
     * @param   in input stream to read from
     * @throws  StreamCorruptedException if the stream header is incorrect
     * @throws  IOException if an I/O error occurs while reading stream header
     * @throws  SecurityException if untrusted subclass illegally overrides
     *          security-sensitive methods
     * @throws  NullPointerException if &lt;code&gt;in&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @see     ObjectInputStream#ObjectInputStream()
     * @see     ObjectInputStream#readFields()
     * @see     ObjectOutputStream#ObjectOutputStream(OutputStream)
     */
<span class="fc" id="L293">    public ObjectInputStream(InputStream in) throws IOException {</span>
<span class="fc" id="L294">        verifySubclass();</span>
<span class="fc" id="L295">        bin = new BlockDataInputStream(in);</span>
<span class="fc" id="L296">        handles = new HandleTable(10);</span>
<span class="fc" id="L297">        vlist = new ValidationList();</span>
<span class="fc" id="L298">        enableOverride = false;</span>
<span class="fc" id="L299">        readStreamHeader();</span>
<span class="fc" id="L300">        bin.setBlockDataMode(true);</span>
<span class="fc" id="L301">    }</span>

    /**
     * Provide a way for subclasses that are completely reimplementing
     * ObjectInputStream to not have to allocate private data just used by this
     * implementation of ObjectInputStream.
     *
     * &lt;p&gt;If there is a security manager installed, this method first calls the
     * security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the
     * &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt;
     * permission to ensure it's ok to enable subclassing.
     *
     * @throws  SecurityException if a security manager exists and its
     *          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling
     *          subclassing.
     * @throws  IOException if an I/O error occurs while creating this stream
     * @see SecurityManager#checkPermission
     * @see java.io.SerializablePermission
     */
<span class="nc" id="L320">    protected ObjectInputStream() throws IOException, SecurityException {</span>
<span class="nc" id="L321">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L323">            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span>
        }
<span class="nc" id="L325">        bin = null;</span>
<span class="nc" id="L326">        handles = null;</span>
<span class="nc" id="L327">        vlist = null;</span>
<span class="nc" id="L328">        enableOverride = true;</span>
<span class="nc" id="L329">    }</span>

    /**
     * Read an object from the ObjectInputStream.  The class of the object, the
     * signature of the class, and the values of the non-transient and
     * non-static fields of the class and all of its supertypes are read.
     * Default deserializing for a class can be overriden using the writeObject
     * and readObject methods.  Objects referenced by this object are read
     * transitively so that a complete equivalent graph of objects is
     * reconstructed by readObject.
     *
     * &lt;p&gt;The root object is completely restored when all of its fields and the
     * objects it references are completely restored.  At this point the object
     * validation callbacks are executed in order based on their registered
     * priorities. The callbacks are registered by objects (in the readObject
     * special methods) as they are individually restored.
     *
     * &lt;p&gt;Exceptions are thrown for problems with the InputStream and for
     * classes that should not be deserialized.  All exceptions are fatal to
     * the InputStream and leave it in an indeterminate state; it is up to the
     * caller to ignore or recover the stream state.
     *
     * @throws  ClassNotFoundException Class of a serialized object cannot be
     *          found.
     * @throws  InvalidClassException Something is wrong with a class used by
     *          serialization.
     * @throws  StreamCorruptedException Control information in the
     *          stream is inconsistent.
     * @throws  OptionalDataException Primitive data was found in the
     *          stream instead of objects.
     * @throws  IOException Any of the usual Input/Output related exceptions.
     */
    public final Object readObject()
        throws IOException, ClassNotFoundException
    {
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (enableOverride) {</span>
<span class="nc" id="L365">            return readObjectOverride();</span>
        }

        // if nested read, passHandle contains handle of enclosing object
<span class="fc" id="L369">        int outerHandle = passHandle;</span>
        try {
<span class="fc" id="L371">            Object obj = readObject0(false);</span>
<span class="fc" id="L372">            handles.markDependency(outerHandle, passHandle);</span>
<span class="fc" id="L373">            ClassNotFoundException ex = handles.lookupException(passHandle);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">            if (ex != null) {</span>
<span class="fc" id="L375">                throw ex;</span>
            }
<span class="fc bfc" id="L377" title="All 2 branches covered.">            if (depth == 0) {</span>
<span class="fc" id="L378">                vlist.doCallbacks();</span>
            }
<span class="fc" id="L380">            return obj;</span>
        } finally {
<span class="fc" id="L382">            passHandle = outerHandle;</span>
<span class="pc bpc" id="L383" title="4 of 8 branches missed.">            if (closed &amp;&amp; depth == 0) {</span>
<span class="pc" id="L384">                clear();</span>
            }
        }
    }

    /**
     * This method is called by trusted subclasses of ObjectOutputStream that
     * constructed ObjectOutputStream using the protected no-arg constructor.
     * The subclass is expected to provide an override method with the modifier
     * &quot;final&quot;.
     *
     * @return  the Object read from the stream.
     * @throws  ClassNotFoundException Class definition of a serialized object
     *          cannot be found.
     * @throws  OptionalDataException Primitive data was found in the stream
     *          instead of objects.
     * @throws  IOException if I/O errors occurred while reading from the
     *          underlying stream
     * @see #ObjectInputStream()
     * @see #readObject()
     * @since 1.2
     */
    protected Object readObjectOverride()
        throws IOException, ClassNotFoundException
    {
<span class="nc" id="L409">        return null;</span>
    }

    /**
     * Reads an &quot;unshared&quot; object from the ObjectInputStream.  This method is
     * identical to readObject, except that it prevents subsequent calls to
     * readObject and readUnshared from returning additional references to the
     * deserialized instance obtained via this call.  Specifically:
     * &lt;ul&gt;
     *   &lt;li&gt;If readUnshared is called to deserialize a back-reference (the
     *       stream representation of an object which has been written
     *       previously to the stream), an ObjectStreamException will be
     *       thrown.
     *
     *   &lt;li&gt;If readUnshared returns successfully, then any subsequent attempts
     *       to deserialize back-references to the stream handle deserialized
     *       by readUnshared will cause an ObjectStreamException to be thrown.
     * &lt;/ul&gt;
     * Deserializing an object via readUnshared invalidates the stream handle
     * associated with the returned object.  Note that this in itself does not
     * always guarantee that the reference returned by readUnshared is unique;
     * the deserialized object may define a readResolve method which returns an
     * object visible to other parties, or readUnshared may return a Class
     * object or enum constant obtainable elsewhere in the stream or through
     * external means. If the deserialized object defines a readResolve method
     * and the invocation of that method returns an array, then readUnshared
     * returns a shallow clone of that array; this guarantees that the returned
     * array object is unique and cannot be obtained a second time from an
     * invocation of readObject or readUnshared on the ObjectInputStream,
     * even if the underlying data stream has been manipulated.
     *
     * &lt;p&gt;ObjectInputStream subclasses which override this method can only be
     * constructed in security contexts possessing the
     * &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
     * instantiate such a subclass without this permission will cause a
     * SecurityException to be thrown.
     *
     * @return  reference to deserialized object
     * @throws  ClassNotFoundException if class of an object to deserialize
     *          cannot be found
     * @throws  StreamCorruptedException if control information in the stream
     *          is inconsistent
     * @throws  ObjectStreamException if object to deserialize has already
     *          appeared in stream
     * @throws  OptionalDataException if primitive data is next in stream
     * @throws  IOException if an I/O error occurs during deserialization
     * @since   1.4
     */
    public Object readUnshared() throws IOException, ClassNotFoundException {
        // if nested read, passHandle contains handle of enclosing object
<span class="fc" id="L459">        int outerHandle = passHandle;</span>
        try {
<span class="fc" id="L461">            Object obj = readObject0(true);</span>
<span class="fc" id="L462">            handles.markDependency(outerHandle, passHandle);</span>
<span class="fc" id="L463">            ClassNotFoundException ex = handles.lookupException(passHandle);</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">            if (ex != null) {</span>
<span class="nc" id="L465">                throw ex;</span>
            }
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">            if (depth == 0) {</span>
<span class="fc" id="L468">                vlist.doCallbacks();</span>
            }
<span class="fc" id="L470">            return obj;</span>
        } finally {
<span class="fc" id="L472">            passHandle = outerHandle;</span>
<span class="pc bpc" id="L473" title="6 of 8 branches missed.">            if (closed &amp;&amp; depth == 0) {</span>
<span class="pc" id="L474">                clear();</span>
            }
        }
    }

    /**
     * Read the non-static and non-transient fields of the current class from
     * this stream.  This may only be called from the readObject method of the
     * class being deserialized. It will throw the NotActiveException if it is
     * called otherwise.
     *
     * @throws  ClassNotFoundException if the class of a serialized object
     *          could not be found.
     * @throws  IOException if an I/O error occurs.
     * @throws  NotActiveException if the stream is not currently reading
     *          objects.
     */
    public void defaultReadObject()
        throws IOException, ClassNotFoundException
    {
<span class="fc" id="L494">        SerialCallbackContext ctx = curContext;</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">        if (ctx == null) {</span>
<span class="nc" id="L496">            throw new NotActiveException(&quot;not in call to readObject&quot;);</span>
        }
<span class="fc" id="L498">        Object curObj = ctx.getObj();</span>
<span class="fc" id="L499">        ObjectStreamClass curDesc = ctx.getDesc();</span>
<span class="fc" id="L500">        bin.setBlockDataMode(false);</span>
<span class="fc" id="L501">        defaultReadFields(curObj, curDesc);</span>
<span class="fc" id="L502">        bin.setBlockDataMode(true);</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">        if (!curDesc.hasWriteObjectData()) {</span>
            /*
             * Fix for 4360508: since stream does not contain terminating
             * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
             * knows to simulate end-of-custom-data behavior.
             */
<span class="fc" id="L509">            defaultDataEnd = true;</span>
        }
<span class="fc" id="L511">        ClassNotFoundException ex = handles.lookupException(passHandle);</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">        if (ex != null) {</span>
<span class="fc" id="L513">            throw ex;</span>
        }
<span class="fc" id="L515">    }</span>

    /**
     * Reads the persistent fields from the stream and makes them available by
     * name.
     *
     * @return  the &lt;code&gt;GetField&lt;/code&gt; object representing the persistent
     *          fields of the object being deserialized
     * @throws  ClassNotFoundException if the class of a serialized object
     *          could not be found.
     * @throws  IOException if an I/O error occurs.
     * @throws  NotActiveException if the stream is not currently reading
     *          objects.
     * @since 1.2
     */
    public ObjectInputStream.GetField readFields()
        throws IOException, ClassNotFoundException
    {
<span class="fc" id="L533">        SerialCallbackContext ctx = curContext;</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        if (ctx == null) {</span>
<span class="nc" id="L535">            throw new NotActiveException(&quot;not in call to readObject&quot;);</span>
        }
<span class="fc" id="L537">        Object curObj = ctx.getObj();</span>
<span class="fc" id="L538">        ObjectStreamClass curDesc = ctx.getDesc();</span>
<span class="fc" id="L539">        bin.setBlockDataMode(false);</span>
<span class="fc" id="L540">        GetFieldImpl getField = new GetFieldImpl(curDesc);</span>
<span class="fc" id="L541">        getField.readFields();</span>
<span class="fc" id="L542">        bin.setBlockDataMode(true);</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (!curDesc.hasWriteObjectData()) {</span>
            /*
             * Fix for 4360508: since stream does not contain terminating
             * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
             * knows to simulate end-of-custom-data behavior.
             */
<span class="fc" id="L549">            defaultDataEnd = true;</span>
        }

<span class="fc" id="L552">        return getField;</span>
    }

    /**
     * Register an object to be validated before the graph is returned.  While
     * similar to resolveObject these validations are called after the entire
     * graph has been reconstituted.  Typically, a readObject method will
     * register the object with the stream so that when all of the objects are
     * restored a final set of validations can be performed.
     *
     * @param   obj the object to receive the validation callback.
     * @param   prio controls the order of callbacks;zero is a good default.
     *          Use higher numbers to be called back earlier, lower numbers for
     *          later callbacks. Within a priority, callbacks are processed in
     *          no particular order.
     * @throws  NotActiveException The stream is not currently reading objects
     *          so it is invalid to register a callback.
     * @throws  InvalidObjectException The validation object is null.
     */
    public void registerValidation(ObjectInputValidation obj, int prio)
        throws NotActiveException, InvalidObjectException
    {
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (depth == 0) {</span>
<span class="nc" id="L575">            throw new NotActiveException(&quot;stream inactive&quot;);</span>
        }
<span class="nc" id="L577">        vlist.register(obj, prio);</span>
<span class="nc" id="L578">    }</span>

    /**
     * Load the local class equivalent of the specified stream class
     * description.  Subclasses may implement this method to allow classes to
     * be fetched from an alternate source.
     *
     * &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is
     * &lt;code&gt;annotateClass&lt;/code&gt;.  This method will be invoked only once for
     * each unique class in the stream.  This method can be implemented by
     * subclasses to use an alternate loading mechanism but must return a
     * &lt;code&gt;Class&lt;/code&gt; object. Once returned, if the class is not an array
     * class, its serialVersionUID is compared to the serialVersionUID of the
     * serialized class, and if there is a mismatch, the deserialization fails
     * and an {@link InvalidClassException} is thrown.
     *
     * &lt;p&gt;The default implementation of this method in
     * &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling
     * &lt;pre&gt;
     *     Class.forName(desc.getName(), false, loader)
     * &lt;/pre&gt;
     * where &lt;code&gt;loader&lt;/code&gt; is determined as follows: if there is a
     * method on the current thread's stack whose declaring class was
     * defined by a user-defined class loader (and was not a generated to
     * implement reflective invocations), then &lt;code&gt;loader&lt;/code&gt; is class
     * loader corresponding to the closest such method to the currently
     * executing frame; otherwise, &lt;code&gt;loader&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;. If this call results in a
     * &lt;code&gt;ClassNotFoundException&lt;/code&gt; and the name of the passed
     * &lt;code&gt;ObjectStreamClass&lt;/code&gt; instance is the Java language keyword
     * for a primitive type or void, then the &lt;code&gt;Class&lt;/code&gt; object
     * representing that primitive type or void will be returned
     * (e.g., an &lt;code&gt;ObjectStreamClass&lt;/code&gt; with the name
     * &lt;code&gt;&quot;int&quot;&lt;/code&gt; will be resolved to &lt;code&gt;Integer.TYPE&lt;/code&gt;).
     * Otherwise, the &lt;code&gt;ClassNotFoundException&lt;/code&gt; will be thrown to
     * the caller of this method.
     *
     * @param   desc an instance of class &lt;code&gt;ObjectStreamClass&lt;/code&gt;
     * @return  a &lt;code&gt;Class&lt;/code&gt; object corresponding to &lt;code&gt;desc&lt;/code&gt;
     * @throws  IOException any of the usual Input/Output exceptions.
     * @throws  ClassNotFoundException if class of a serialized object cannot
     *          be found.
     */
    protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
        throws IOException, ClassNotFoundException
    {
<span class="fc" id="L624">        String name = desc.getName();</span>
        try {
<span class="fc" id="L626">            return Class.forName(name, false, latestUserDefinedLoader());</span>
<span class="fc" id="L627">        } catch (ClassNotFoundException ex) {</span>
<span class="fc" id="L628">            Class&lt;?&gt; cl = primClasses.get(name);</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">            if (cl != null) {</span>
<span class="fc" id="L630">                return cl;</span>
            } else {
<span class="fc" id="L632">                throw ex;</span>
            }
        }
    }

    /**
     * Returns a proxy class that implements the interfaces named in a proxy
     * class descriptor; subclasses may implement this method to read custom
     * data from the stream along with the descriptors for dynamic proxy
     * classes, allowing them to use an alternate loading mechanism for the
     * interfaces and the proxy class.
     *
     * &lt;p&gt;This method is called exactly once for each unique proxy class
     * descriptor in the stream.
     *
     * &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is
     * &lt;code&gt;annotateProxyClass&lt;/code&gt;.  For a given subclass of
     * &lt;code&gt;ObjectInputStream&lt;/code&gt; that overrides this method, the
     * &lt;code&gt;annotateProxyClass&lt;/code&gt; method in the corresponding subclass of
     * &lt;code&gt;ObjectOutputStream&lt;/code&gt; must write any data or objects read by
     * this method.
     *
     * &lt;p&gt;The default implementation of this method in
     * &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling
     * &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; with the list of &lt;code&gt;Class&lt;/code&gt;
     * objects for the interfaces that are named in the &lt;code&gt;interfaces&lt;/code&gt;
     * parameter.  The &lt;code&gt;Class&lt;/code&gt; object for each interface name
     * &lt;code&gt;i&lt;/code&gt; is the value returned by calling
     * &lt;pre&gt;
     *     Class.forName(i, false, loader)
     * &lt;/pre&gt;
     * where &lt;code&gt;loader&lt;/code&gt; is that of the first non-&lt;code&gt;null&lt;/code&gt;
     * class loader up the execution stack, or &lt;code&gt;null&lt;/code&gt; if no
     * non-&lt;code&gt;null&lt;/code&gt; class loaders are on the stack (the same class
     * loader choice used by the &lt;code&gt;resolveClass&lt;/code&gt; method).  Unless any
     * of the resolved interfaces are non-public, this same value of
     * &lt;code&gt;loader&lt;/code&gt; is also the class loader passed to
     * &lt;code&gt;Proxy.getProxyClass&lt;/code&gt;; if non-public interfaces are present,
     * their class loader is passed instead (if more than one non-public
     * interface class loader is encountered, an
     * &lt;code&gt;IllegalAccessError&lt;/code&gt; is thrown).
     * If &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; throws an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt;, &lt;code&gt;resolveProxyClass&lt;/code&gt;
     * will throw a &lt;code&gt;ClassNotFoundException&lt;/code&gt; containing the
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt;.
     *
     * @param interfaces the list of interface names that were
     *                deserialized in the proxy class descriptor
     * @return  a proxy class for the specified interfaces
     * @throws        IOException any exception thrown by the underlying
     *                &lt;code&gt;InputStream&lt;/code&gt;
     * @throws        ClassNotFoundException if the proxy class or any of the
     *                named interfaces could not be found
     * @see ObjectOutputStream#annotateProxyClass(Class)
     * @since 1.3
     */
    protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)
        throws IOException, ClassNotFoundException
    {
<span class="fc" id="L691">        ClassLoader latestLoader = latestUserDefinedLoader();</span>
<span class="fc" id="L692">        ClassLoader nonPublicLoader = null;</span>
<span class="fc" id="L693">        boolean hasNonPublicInterface = false;</span>

        // define proxy in class loader of non-public interface(s), if any
<span class="fc" id="L696">        Class&lt;?&gt;[] classObjs = new Class&lt;?&gt;[interfaces.length];</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">        for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="fc" id="L698">            Class&lt;?&gt; cl = Class.forName(interfaces[i], false, latestLoader);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">            if ((cl.getModifiers() &amp; Modifier.PUBLIC) == 0) {</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">                if (hasNonPublicInterface) {</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">                    if (nonPublicLoader != cl.getClassLoader()) {</span>
<span class="nc" id="L702">                        throw new IllegalAccessError(</span>
                            &quot;conflicting non-public interface class loaders&quot;);
                    }
                } else {
<span class="fc" id="L706">                    nonPublicLoader = cl.getClassLoader();</span>
<span class="fc" id="L707">                    hasNonPublicInterface = true;</span>
                }
            }
<span class="fc" id="L710">            classObjs[i] = cl;</span>
        }
        try {
<span class="fc bfc" id="L713" title="All 2 branches covered.">            return Proxy.getProxyClass(</span>
                hasNonPublicInterface ? nonPublicLoader : latestLoader,
                classObjs);
<span class="nc" id="L716">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L717">            throw new ClassNotFoundException(null, e);</span>
        }
    }

    /**
     * This method will allow trusted subclasses of ObjectInputStream to
     * substitute one object for another during deserialization. Replacing
     * objects is disabled until enableResolveObject is called. The
     * enableResolveObject method checks that the stream requesting to resolve
     * object can be trusted. Every reference to serializable objects is passed
     * to resolveObject.  To insure that the private state of objects is not
     * unintentionally exposed only trusted streams may use resolveObject.
     *
     * &lt;p&gt;This method is called after an object has been read but before it is
     * returned from readObject.  The default resolveObject method just returns
     * the same object.
     *
     * &lt;p&gt;When a subclass is replacing objects it must insure that the
     * substituted object is compatible with every field where the reference
     * will be stored.  Objects whose type is not a subclass of the type of the
     * field or array element abort the serialization by raising an exception
     * and the object is not be stored.
     *
     * &lt;p&gt;This method is called only once when each object is first
     * encountered.  All subsequent references to the object will be redirected
     * to the new object.
     *
     * @param   obj object to be substituted
     * @return  the substituted object
     * @throws  IOException Any of the usual Input/Output exceptions.
     */
    protected Object resolveObject(Object obj) throws IOException {
<span class="nc" id="L749">        return obj;</span>
    }

    /**
     * Enable the stream to allow objects read from the stream to be replaced.
     * When enabled, the resolveObject method is called for every object being
     * deserialized.
     *
     * &lt;p&gt;If &lt;i&gt;enable&lt;/i&gt; is true, and there is a security manager installed,
     * this method first calls the security manager's
     * &lt;code&gt;checkPermission&lt;/code&gt; method with the
     * &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to
     * ensure it's ok to enable the stream to allow objects read from the
     * stream to be replaced.
     *
     * @param   enable true for enabling use of &lt;code&gt;resolveObject&lt;/code&gt; for
     *          every object being deserialized
     * @return  the previous setting before this method was invoked
     * @throws  SecurityException if a security manager exists and its
     *          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling the stream
     *          to allow objects read from the stream to be replaced.
     * @see SecurityManager#checkPermission
     * @see java.io.SerializablePermission
     */
    protected boolean enableResolveObject(boolean enable)
        throws SecurityException
    {
<span class="nc bnc" id="L776" title="All 2 branches missed.">        if (enable == enableResolve) {</span>
<span class="nc" id="L777">            return enable;</span>
        }
<span class="nc bnc" id="L779" title="All 2 branches missed.">        if (enable) {</span>
<span class="nc" id="L780">            SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">            if (sm != null) {</span>
<span class="nc" id="L782">                sm.checkPermission(SUBSTITUTION_PERMISSION);</span>
            }
        }
<span class="nc" id="L785">        enableResolve = enable;</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">        return !enableResolve;</span>
    }

    /**
     * The readStreamHeader method is provided to allow subclasses to read and
     * verify their own stream headers. It reads and verifies the magic number
     * and version number.
     *
     * @throws  IOException if there are I/O errors while reading from the
     *          underlying &lt;code&gt;InputStream&lt;/code&gt;
     * @throws  StreamCorruptedException if control information in the stream
     *          is inconsistent
     */
    protected void readStreamHeader()
        throws IOException, StreamCorruptedException
    {
<span class="fc" id="L802">        short s0 = bin.readShort();</span>
<span class="fc" id="L803">        short s1 = bin.readShort();</span>
<span class="pc bpc" id="L804" title="2 of 4 branches missed.">        if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {</span>
<span class="nc" id="L805">            throw new StreamCorruptedException(</span>
<span class="nc" id="L806">                String.format(&quot;invalid stream header: %04X%04X&quot;, s0, s1));</span>
        }
<span class="fc" id="L808">    }</span>

    /**
     * Read a class descriptor from the serialization stream.  This method is
     * called when the ObjectInputStream expects a class descriptor as the next
     * item in the serialization stream.  Subclasses of ObjectInputStream may
     * override this method to read in class descriptors that have been written
     * in non-standard formats (by subclasses of ObjectOutputStream which have
     * overridden the &lt;code&gt;writeClassDescriptor&lt;/code&gt; method).  By default,
     * this method reads class descriptors according to the format defined in
     * the Object Serialization specification.
     *
     * @return  the class descriptor read
     * @throws  IOException If an I/O error has occurred.
     * @throws  ClassNotFoundException If the Class of a serialized object used
     *          in the class descriptor representation cannot be found
     * @see java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)
     * @since 1.3
     */
    protected ObjectStreamClass readClassDescriptor()
        throws IOException, ClassNotFoundException
    {
<span class="fc" id="L830">        ObjectStreamClass desc = new ObjectStreamClass();</span>
<span class="fc" id="L831">        desc.readNonProxy(this);</span>
<span class="fc" id="L832">        return desc;</span>
    }

    /**
     * Reads a byte of data. This method will block if no input is available.
     *
     * @return  the byte read, or -1 if the end of the stream is reached.
     * @throws  IOException If an I/O error has occurred.
     */
    public int read() throws IOException {
<span class="fc" id="L842">        return bin.read();</span>
    }

    /**
     * Reads into an array of bytes.  This method will block until some input
     * is available. Consider using java.io.DataInputStream.readFully to read
     * exactly 'length' bytes.
     *
     * @param   buf the buffer into which the data is read
     * @param   off the start offset of the data
     * @param   len the maximum number of bytes read
     * @return  the actual number of bytes read, -1 is returned when the end of
     *          the stream is reached.
     * @throws  IOException If an I/O error has occurred.
     * @see java.io.DataInputStream#readFully(byte[],int,int)
     */
    public int read(byte[] buf, int off, int len) throws IOException {
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">        if (buf == null) {</span>
<span class="nc" id="L860">            throw new NullPointerException();</span>
        }
<span class="fc" id="L862">        int endoff = off + len;</span>
<span class="pc bpc" id="L863" title="4 of 8 branches missed.">        if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {</span>
<span class="nc" id="L864">            throw new IndexOutOfBoundsException();</span>
        }
<span class="fc" id="L866">        return bin.read(buf, off, len, false);</span>
    }

    /**
     * Returns the number of bytes that can be read without blocking.
     *
     * @return  the number of available bytes.
     * @throws  IOException if there are I/O errors while reading from the
     *          underlying &lt;code&gt;InputStream&lt;/code&gt;
     */
    public int available() throws IOException {
<span class="fc" id="L877">        return bin.available();</span>
    }

    /**
     * Closes the input stream. Must be called to release any resources
     * associated with the stream.
     *
     * @throws  IOException If an I/O error has occurred.
     */
    public void close() throws IOException {
        /*
         * Even if stream already closed, propagate redundant close to
         * underlying stream to stay consistent with previous implementations.
         */
<span class="fc" id="L891">        closed = true;</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">        if (depth == 0) {</span>
<span class="fc" id="L893">            clear();</span>
        }
<span class="fc" id="L895">        bin.close();</span>
<span class="fc" id="L896">    }</span>

    /**
     * Reads in a boolean.
     *
     * @return  the boolean read.
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public boolean readBoolean() throws IOException {
<span class="fc" id="L906">        return bin.readBoolean();</span>
    }

    /**
     * Reads an 8 bit byte.
     *
     * @return  the 8 bit byte read.
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public byte readByte() throws IOException  {
<span class="fc" id="L917">        return bin.readByte();</span>
    }

    /**
     * Reads an unsigned 8 bit byte.
     *
     * @return  the 8 bit byte read.
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public int readUnsignedByte()  throws IOException {
<span class="nc" id="L928">        return bin.readUnsignedByte();</span>
    }

    /**
     * Reads a 16 bit char.
     *
     * @return  the 16 bit char read.
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public char readChar()  throws IOException {
<span class="fc" id="L939">        return bin.readChar();</span>
    }

    /**
     * Reads a 16 bit short.
     *
     * @return  the 16 bit short read.
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public short readShort()  throws IOException {
<span class="fc" id="L950">        return bin.readShort();</span>
    }

    /**
     * Reads an unsigned 16 bit short.
     *
     * @return  the 16 bit short read.
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public int readUnsignedShort() throws IOException {
<span class="nc" id="L961">        return bin.readUnsignedShort();</span>
    }

    /**
     * Reads a 32 bit int.
     *
     * @return  the 32 bit integer read.
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public int readInt()  throws IOException {
<span class="fc" id="L972">        return bin.readInt();</span>
    }

    /**
     * Reads a 64 bit long.
     *
     * @return  the read 64 bit long.
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public long readLong()  throws IOException {
<span class="fc" id="L983">        return bin.readLong();</span>
    }

    /**
     * Reads a 32 bit float.
     *
     * @return  the 32 bit float read.
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public float readFloat() throws IOException {
<span class="fc" id="L994">        return bin.readFloat();</span>
    }

    /**
     * Reads a 64 bit double.
     *
     * @return  the 64 bit double read.
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public double readDouble() throws IOException {
<span class="fc" id="L1005">        return bin.readDouble();</span>
    }

    /**
     * Reads bytes, blocking until all bytes are read.
     *
     * @param   buf the buffer into which the data is read
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public void readFully(byte[] buf) throws IOException {
<span class="nc" id="L1016">        bin.readFully(buf, 0, buf.length, false);</span>
<span class="nc" id="L1017">    }</span>

    /**
     * Reads bytes, blocking until all bytes are read.
     *
     * @param   buf the buffer into which the data is read
     * @param   off the start offset of the data
     * @param   len the maximum number of bytes to read
     * @throws  EOFException If end of file is reached.
     * @throws  IOException If other I/O error has occurred.
     */
    public void readFully(byte[] buf, int off, int len) throws IOException {
<span class="nc" id="L1029">        int endoff = off + len;</span>
<span class="nc bnc" id="L1030" title="All 8 branches missed.">        if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {</span>
<span class="nc" id="L1031">            throw new IndexOutOfBoundsException();</span>
        }
<span class="nc" id="L1033">        bin.readFully(buf, off, len, false);</span>
<span class="nc" id="L1034">    }</span>

    /**
     * Skips bytes.
     *
     * @param   len the number of bytes to be skipped
     * @return  the actual number of bytes skipped.
     * @throws  IOException If an I/O error has occurred.
     */
    public int skipBytes(int len) throws IOException {
<span class="nc" id="L1044">        return bin.skipBytes(len);</span>
    }

    /**
     * Reads in a line that has been terminated by a \n, \r, \r\n or EOF.
     *
     * @return  a String copy of the line.
     * @throws  IOException if there are I/O errors while reading from the
     *          underlying &lt;code&gt;InputStream&lt;/code&gt;
     * @deprecated This method does not properly convert bytes to characters.
     *          see DataInputStream for the details and alternatives.
     */
    @Deprecated
    public String readLine() throws IOException {
<span class="nc" id="L1058">        return bin.readLine();</span>
    }

    /**
     * Reads a String in
     * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
     * format.
     *
     * @return  the String.
     * @throws  IOException if there are I/O errors while reading from the
     *          underlying &lt;code&gt;InputStream&lt;/code&gt;
     * @throws  UTFDataFormatException if read bytes do not represent a valid
     *          modified UTF-8 encoding of a string
     */
    public String readUTF() throws IOException {
<span class="fc" id="L1073">        return bin.readUTF();</span>
    }

    /**
     * Provide access to the persistent fields read from the input stream.
     */
<span class="fc" id="L1079">    public static abstract class GetField {</span>

        /**
         * Get the ObjectStreamClass that describes the fields in the stream.
         *
         * @return  the descriptor class that describes the serializable fields
         */
        public abstract ObjectStreamClass getObjectStreamClass();

        /**
         * Return true if the named field is defaulted and has no value in this
         * stream.
         *
         * @param  name the name of the field
         * @return true, if and only if the named field is defaulted
         * @throws IOException if there are I/O errors while reading from
         *         the underlying &lt;code&gt;InputStream&lt;/code&gt;
         * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         *         correspond to a serializable field
         */
        public abstract boolean defaulted(String name) throws IOException;

        /**
         * Get the value of the named boolean field from the persistent field.
         *
         * @param  name the name of the field
         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         *         have a value
         * @return the value of the named &lt;code&gt;boolean&lt;/code&gt; field
         * @throws IOException if there are I/O errors while reading from the
         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         *         not serializable or if the field type is incorrect
         */
        public abstract boolean get(String name, boolean val)
            throws IOException;

        /**
         * Get the value of the named byte field from the persistent field.
         *
         * @param  name the name of the field
         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         *         have a value
         * @return the value of the named &lt;code&gt;byte&lt;/code&gt; field
         * @throws IOException if there are I/O errors while reading from the
         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         *         not serializable or if the field type is incorrect
         */
        public abstract byte get(String name, byte val) throws IOException;

        /**
         * Get the value of the named char field from the persistent field.
         *
         * @param  name the name of the field
         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         *         have a value
         * @return the value of the named &lt;code&gt;char&lt;/code&gt; field
         * @throws IOException if there are I/O errors while reading from the
         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         *         not serializable or if the field type is incorrect
         */
        public abstract char get(String name, char val) throws IOException;

        /**
         * Get the value of the named short field from the persistent field.
         *
         * @param  name the name of the field
         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         *         have a value
         * @return the value of the named &lt;code&gt;short&lt;/code&gt; field
         * @throws IOException if there are I/O errors while reading from the
         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         *         not serializable or if the field type is incorrect
         */
        public abstract short get(String name, short val) throws IOException;

        /**
         * Get the value of the named int field from the persistent field.
         *
         * @param  name the name of the field
         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         *         have a value
         * @return the value of the named &lt;code&gt;int&lt;/code&gt; field
         * @throws IOException if there are I/O errors while reading from the
         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         *         not serializable or if the field type is incorrect
         */
        public abstract int get(String name, int val) throws IOException;

        /**
         * Get the value of the named long field from the persistent field.
         *
         * @param  name the name of the field
         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         *         have a value
         * @return the value of the named &lt;code&gt;long&lt;/code&gt; field
         * @throws IOException if there are I/O errors while reading from the
         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         *         not serializable or if the field type is incorrect
         */
        public abstract long get(String name, long val) throws IOException;

        /**
         * Get the value of the named float field from the persistent field.
         *
         * @param  name the name of the field
         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         *         have a value
         * @return the value of the named &lt;code&gt;float&lt;/code&gt; field
         * @throws IOException if there are I/O errors while reading from the
         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         *         not serializable or if the field type is incorrect
         */
        public abstract float get(String name, float val) throws IOException;

        /**
         * Get the value of the named double field from the persistent field.
         *
         * @param  name the name of the field
         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         *         have a value
         * @return the value of the named &lt;code&gt;double&lt;/code&gt; field
         * @throws IOException if there are I/O errors while reading from the
         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         *         not serializable or if the field type is incorrect
         */
        public abstract double get(String name, double val) throws IOException;

        /**
         * Get the value of the named Object field from the persistent field.
         *
         * @param  name the name of the field
         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         *         have a value
         * @return the value of the named &lt;code&gt;Object&lt;/code&gt; field
         * @throws IOException if there are I/O errors while reading from the
         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         *         not serializable or if the field type is incorrect
         */
        public abstract Object get(String name, Object val) throws IOException;
    }

    /**
     * Verifies that this (possibly subclass) instance can be constructed
     * without violating security constraints: the subclass must not override
     * security-sensitive non-final methods, or else the
     * &quot;enableSubclassImplementation&quot; SerializablePermission is checked.
     */
    private void verifySubclass() {
<span class="fc" id="L1236">        Class&lt;?&gt; cl = getClass();</span>
<span class="fc bfc" id="L1237" title="All 2 branches covered.">        if (cl == ObjectInputStream.class) {</span>
<span class="fc" id="L1238">            return;</span>
        }
<span class="fc" id="L1240">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L1241" title="All 2 branches covered.">        if (sm == null) {</span>
<span class="fc" id="L1242">            return;</span>
        }
<span class="fc" id="L1244">        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);</span>
<span class="fc" id="L1245">        WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);</span>
<span class="fc" id="L1246">        Boolean result = Caches.subclassAudits.get(key);</span>
<span class="fc bfc" id="L1247" title="All 2 branches covered.">        if (result == null) {</span>
<span class="fc" id="L1248">            result = Boolean.valueOf(auditSubclass(cl));</span>
<span class="fc" id="L1249">            Caches.subclassAudits.putIfAbsent(key, result);</span>
        }
<span class="pc bpc" id="L1251" title="1 of 2 branches missed.">        if (result.booleanValue()) {</span>
<span class="fc" id="L1252">            return;</span>
        }
<span class="nc" id="L1254">        sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span>
<span class="nc" id="L1255">    }</span>

    /**
     * Performs reflective checks on given subclass to verify that it doesn't
     * override security-sensitive non-final methods.  Returns true if subclass
     * is &quot;safe&quot;, false otherwise.
     */
    private static boolean auditSubclass(final Class&lt;?&gt; subcl) {
<span class="fc" id="L1263">        Boolean result = AccessController.doPrivileged(</span>
<span class="fc" id="L1264">            new PrivilegedAction&lt;Boolean&gt;() {</span>
                public Boolean run() {
<span class="fc" id="L1266">                    for (Class&lt;?&gt; cl = subcl;</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">                         cl != ObjectInputStream.class;</span>
<span class="fc" id="L1268">                         cl = cl.getSuperclass())</span>
                    {
                        try {
<span class="fc" id="L1271">                            cl.getDeclaredMethod(</span>
                                &quot;readUnshared&quot;, (Class[]) null);
<span class="fc" id="L1273">                            return Boolean.FALSE;</span>
<span class="fc" id="L1274">                        } catch (NoSuchMethodException ex) {</span>
                        }
                        try {
<span class="fc" id="L1277">                            cl.getDeclaredMethod(&quot;readFields&quot;, (Class[]) null);</span>
<span class="fc" id="L1278">                            return Boolean.FALSE;</span>
<span class="fc" id="L1279">                        } catch (NoSuchMethodException ex) {</span>
                        }
                    }
<span class="fc" id="L1282">                    return Boolean.TRUE;</span>
                }
            }
        );
<span class="fc" id="L1286">        return result.booleanValue();</span>
    }

    /**
     * Clears internal data structures.
     */
    private void clear() {
<span class="fc" id="L1293">        handles.clear();</span>
<span class="fc" id="L1294">        vlist.clear();</span>
<span class="fc" id="L1295">    }</span>

    /**
     * Underlying readObject implementation.
     */
    private Object readObject0(boolean unshared) throws IOException {
<span class="fc" id="L1301">        boolean oldMode = bin.getBlockDataMode();</span>
<span class="fc bfc" id="L1302" title="All 2 branches covered.">        if (oldMode) {</span>
<span class="fc" id="L1303">            int remain = bin.currentBlockRemaining();</span>
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">            if (remain &gt; 0) {</span>
<span class="nc" id="L1305">                throw new OptionalDataException(remain);</span>
<span class="fc bfc" id="L1306" title="All 2 branches covered.">            } else if (defaultDataEnd) {</span>
                /*
                 * Fix for 4360508: stream is currently at the end of a field
                 * value block written via default serialization; since there
                 * is no terminating TC_ENDBLOCKDATA tag, simulate
                 * end-of-custom-data behavior explicitly.
                 */
<span class="fc" id="L1313">                throw new OptionalDataException(true);</span>
            }
<span class="fc" id="L1315">            bin.setBlockDataMode(false);</span>
        }

        byte tc;
<span class="fc bfc" id="L1319" title="All 2 branches covered.">        while ((tc = bin.peekByte()) == TC_RESET) {</span>
<span class="fc" id="L1320">            bin.readByte();</span>
<span class="fc" id="L1321">            handleReset();</span>
        }

<span class="fc" id="L1324">        depth++;</span>
        try {
<span class="pc bpc" id="L1326" title="4 of 12 branches missed.">            switch (tc) {</span>
                case TC_NULL:
<span class="fc" id="L1328">                    return readNull();</span>

                case TC_REFERENCE:
<span class="fc" id="L1331">                    return readHandle(unshared);</span>

                case TC_CLASS:
<span class="fc" id="L1334">                    return readClass(unshared);</span>

                case TC_CLASSDESC:
                case TC_PROXYCLASSDESC:
<span class="fc" id="L1338">                    return readClassDesc(unshared);</span>

                case TC_STRING:
                case TC_LONGSTRING:
<span class="fc" id="L1342">                    return checkResolve(readString(unshared));</span>

                case TC_ARRAY:
<span class="fc" id="L1345">                    return checkResolve(readArray(unshared));</span>

                case TC_ENUM:
<span class="fc" id="L1348">                    return checkResolve(readEnum(unshared));</span>

                case TC_OBJECT:
<span class="fc" id="L1351">                    return checkResolve(readOrdinaryObject(unshared));</span>

                case TC_EXCEPTION:
<span class="nc" id="L1354">                    IOException ex = readFatalException();</span>
<span class="nc" id="L1355">                    throw new WriteAbortedException(&quot;writing aborted&quot;, ex);</span>

                case TC_BLOCKDATA:
                case TC_BLOCKDATALONG:
<span class="nc bnc" id="L1359" title="All 2 branches missed.">                    if (oldMode) {</span>
<span class="nc" id="L1360">                        bin.setBlockDataMode(true);</span>
<span class="nc" id="L1361">                        bin.peek();             // force header read</span>
<span class="nc" id="L1362">                        throw new OptionalDataException(</span>
<span class="nc" id="L1363">                            bin.currentBlockRemaining());</span>
                    } else {
<span class="nc" id="L1365">                        throw new StreamCorruptedException(</span>
                            &quot;unexpected block data&quot;);
                    }

                case TC_ENDBLOCKDATA:
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                    if (oldMode) {</span>
<span class="nc" id="L1371">                        throw new OptionalDataException(true);</span>
                    } else {
<span class="nc" id="L1373">                        throw new StreamCorruptedException(</span>
                            &quot;unexpected end of block data&quot;);
                    }

                default:
<span class="nc" id="L1378">                    throw new StreamCorruptedException(</span>
<span class="nc" id="L1379">                        String.format(&quot;invalid type code: %02X&quot;, tc));</span>
            }
        } finally {
<span class="fc" id="L1382">            depth--;</span>
<span class="fc" id="L1383">            bin.setBlockDataMode(oldMode);</span>
        }
    }

    /**
     * If resolveObject has been enabled and given object does not have an
     * exception associated with it, calls resolveObject to determine
     * replacement for object, and updates handle table accordingly.  Returns
     * replacement object, or echoes provided object if no replacement
     * occurred.  Expects that passHandle is set to given object's handle prior
     * to calling this method.
     */
    private Object checkResolve(Object obj) throws IOException {
<span class="pc bpc" id="L1396" title="3 of 4 branches missed.">        if (!enableResolve || handles.lookupException(passHandle) != null) {</span>
<span class="fc" id="L1397">            return obj;</span>
        }
<span class="nc" id="L1399">        Object rep = resolveObject(obj);</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">        if (rep != obj) {</span>
<span class="nc" id="L1401">            handles.setObject(passHandle, rep);</span>
        }
<span class="nc" id="L1403">        return rep;</span>
    }

    /**
     * Reads string without allowing it to be replaced in stream.  Called from
     * within ObjectStreamClass.read().
     */
    String readTypeString() throws IOException {
<span class="fc" id="L1411">        int oldHandle = passHandle;</span>
        try {
<span class="fc" id="L1413">            byte tc = bin.peekByte();</span>
<span class="pc bpc" id="L1414" title="2 of 4 branches missed.">            switch (tc) {</span>
                case TC_NULL:
<span class="nc" id="L1416">                    return (String) readNull();</span>

                case TC_REFERENCE:
<span class="fc" id="L1419">                    return (String) readHandle(false);</span>

                case TC_STRING:
                case TC_LONGSTRING:
<span class="fc" id="L1423">                    return readString(false);</span>

                default:
<span class="nc" id="L1426">                    throw new StreamCorruptedException(</span>
<span class="nc" id="L1427">                        String.format(&quot;invalid type code: %02X&quot;, tc));</span>
            }
        } finally {
<span class="pc" id="L1430">            passHandle = oldHandle;</span>
        }
    }

    /**
     * Reads in null code, sets passHandle to NULL_HANDLE and returns null.
     */
    private Object readNull() throws IOException {
<span class="pc bpc" id="L1438" title="1 of 2 branches missed.">        if (bin.readByte() != TC_NULL) {</span>
<span class="nc" id="L1439">            throw new InternalError();</span>
        }
<span class="fc" id="L1441">        passHandle = NULL_HANDLE;</span>
<span class="fc" id="L1442">        return null;</span>
    }

    /**
     * Reads in object handle, sets passHandle to the read handle, and returns
     * object associated with the handle.
     */
    private Object readHandle(boolean unshared) throws IOException {
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">        if (bin.readByte() != TC_REFERENCE) {</span>
<span class="nc" id="L1451">            throw new InternalError();</span>
        }
<span class="fc" id="L1453">        passHandle = bin.readInt() - baseWireHandle;</span>
<span class="pc bpc" id="L1454" title="2 of 4 branches missed.">        if (passHandle &lt; 0 || passHandle &gt;= handles.size()) {</span>
<span class="nc" id="L1455">            throw new StreamCorruptedException(</span>
<span class="nc" id="L1456">                String.format(&quot;invalid handle value: %08X&quot;, passHandle +</span>
                baseWireHandle));
        }
<span class="fc bfc" id="L1459" title="All 2 branches covered.">        if (unshared) {</span>
            // REMIND: what type of exception to throw here?
<span class="fc" id="L1461">            throw new InvalidObjectException(</span>
                &quot;cannot read back reference as unshared&quot;);
        }

<span class="fc" id="L1465">        Object obj = handles.lookupObject(passHandle);</span>
<span class="fc bfc" id="L1466" title="All 2 branches covered.">        if (obj == unsharedMarker) {</span>
            // REMIND: what type of exception to throw here?
<span class="fc" id="L1468">            throw new InvalidObjectException(</span>
                &quot;cannot read back reference to unshared object&quot;);
        }
<span class="fc" id="L1471">        return obj;</span>
    }

    /**
     * Reads in and returns class object.  Sets passHandle to class object's
     * assigned handle.  Returns null if class is unresolvable (in which case a
     * ClassNotFoundException will be associated with the class' handle in the
     * handle table).
     */
    private Class&lt;?&gt; readClass(boolean unshared) throws IOException {
<span class="pc bpc" id="L1481" title="1 of 2 branches missed.">        if (bin.readByte() != TC_CLASS) {</span>
<span class="nc" id="L1482">            throw new InternalError();</span>
        }
<span class="fc" id="L1484">        ObjectStreamClass desc = readClassDesc(false);</span>
<span class="fc" id="L1485">        Class&lt;?&gt; cl = desc.forClass();</span>
<span class="pc bpc" id="L1486" title="1 of 2 branches missed.">        passHandle = handles.assign(unshared ? unsharedMarker : cl);</span>

<span class="fc" id="L1488">        ClassNotFoundException resolveEx = desc.getResolveException();</span>
<span class="pc bpc" id="L1489" title="1 of 2 branches missed.">        if (resolveEx != null) {</span>
<span class="nc" id="L1490">            handles.markException(passHandle, resolveEx);</span>
        }

<span class="fc" id="L1493">        handles.finish(passHandle);</span>
<span class="fc" id="L1494">        return cl;</span>
    }

    /**
     * Reads in and returns (possibly null) class descriptor.  Sets passHandle
     * to class descriptor's assigned handle.  If class descriptor cannot be
     * resolved to a class in the local VM, a ClassNotFoundException is
     * associated with the class descriptor's handle.
     */
    private ObjectStreamClass readClassDesc(boolean unshared)
        throws IOException
    {
<span class="fc" id="L1506">        byte tc = bin.peekByte();</span>
<span class="pc bpc" id="L1507" title="1 of 5 branches missed.">        switch (tc) {</span>
            case TC_NULL:
<span class="fc" id="L1509">                return (ObjectStreamClass) readNull();</span>

            case TC_REFERENCE:
<span class="fc" id="L1512">                return (ObjectStreamClass) readHandle(unshared);</span>

            case TC_PROXYCLASSDESC:
<span class="fc" id="L1515">                return readProxyDesc(unshared);</span>

            case TC_CLASSDESC:
<span class="fc" id="L1518">                return readNonProxyDesc(unshared);</span>

            default:
<span class="nc" id="L1521">                throw new StreamCorruptedException(</span>
<span class="nc" id="L1522">                    String.format(&quot;invalid type code: %02X&quot;, tc));</span>
        }
    }

    private boolean isCustomSubclass() {
        // Return true if this class is a custom subclass of ObjectInputStream
<span class="fc" id="L1528">        return getClass().getClassLoader()</span>
<span class="fc bfc" id="L1529" title="All 2 branches covered.">                    != ObjectInputStream.class.getClassLoader();</span>
    }

    /**
     * Reads in and returns class descriptor for a dynamic proxy class.  Sets
     * passHandle to proxy class descriptor's assigned handle.  If proxy class
     * descriptor cannot be resolved to a class in the local VM, a
     * ClassNotFoundException is associated with the descriptor's handle.
     */
    private ObjectStreamClass readProxyDesc(boolean unshared)
        throws IOException
    {
<span class="pc bpc" id="L1541" title="1 of 2 branches missed.">        if (bin.readByte() != TC_PROXYCLASSDESC) {</span>
<span class="nc" id="L1542">            throw new InternalError();</span>
        }

<span class="fc" id="L1545">        ObjectStreamClass desc = new ObjectStreamClass();</span>
<span class="pc bpc" id="L1546" title="1 of 2 branches missed.">        int descHandle = handles.assign(unshared ? unsharedMarker : desc);</span>
<span class="fc" id="L1547">        passHandle = NULL_HANDLE;</span>

<span class="fc" id="L1549">        int numIfaces = bin.readInt();</span>
<span class="fc" id="L1550">        String[] ifaces = new String[numIfaces];</span>
<span class="fc bfc" id="L1551" title="All 2 branches covered.">        for (int i = 0; i &lt; numIfaces; i++) {</span>
<span class="fc" id="L1552">            ifaces[i] = bin.readUTF();</span>
        }

<span class="fc" id="L1555">        Class&lt;?&gt; cl = null;</span>
<span class="fc" id="L1556">        ClassNotFoundException resolveEx = null;</span>
<span class="fc" id="L1557">        bin.setBlockDataMode(true);</span>
        try {
<span class="pc bpc" id="L1559" title="1 of 2 branches missed.">            if ((cl = resolveProxyClass(ifaces)) == null) {</span>
<span class="nc" id="L1560">                resolveEx = new ClassNotFoundException(&quot;null class&quot;);</span>
<span class="pc bpc" id="L1561" title="1 of 2 branches missed.">            } else if (!Proxy.isProxyClass(cl)) {</span>
<span class="nc" id="L1562">                throw new InvalidClassException(&quot;Not a proxy&quot;);</span>
            } else {
                // ReflectUtil.checkProxyPackageAccess makes a test
                // equivalent to isCustomSubclass so there's no need
                // to condition this call to isCustomSubclass == true here.
<span class="fc" id="L1567">                ReflectUtil.checkProxyPackageAccess(</span>
<span class="fc" id="L1568">                        getClass().getClassLoader(),</span>
<span class="fc" id="L1569">                        cl.getInterfaces());</span>
            }
<span class="fc" id="L1571">        } catch (ClassNotFoundException ex) {</span>
<span class="fc" id="L1572">            resolveEx = ex;</span>
<span class="fc" id="L1573">        }</span>
<span class="fc" id="L1574">        skipCustomData();</span>

<span class="fc" id="L1576">        desc.initProxy(cl, resolveEx, readClassDesc(false));</span>

<span class="fc" id="L1578">        handles.finish(descHandle);</span>
<span class="fc" id="L1579">        passHandle = descHandle;</span>
<span class="fc" id="L1580">        return desc;</span>
    }

    /**
     * Reads in and returns class descriptor for a class that is not a dynamic
     * proxy class.  Sets passHandle to class descriptor's assigned handle.  If
     * class descriptor cannot be resolved to a class in the local VM, a
     * ClassNotFoundException is associated with the descriptor's handle.
     */
    private ObjectStreamClass readNonProxyDesc(boolean unshared)
        throws IOException
    {
<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">        if (bin.readByte() != TC_CLASSDESC) {</span>
<span class="nc" id="L1593">            throw new InternalError();</span>
        }

<span class="fc" id="L1596">        ObjectStreamClass desc = new ObjectStreamClass();</span>
<span class="pc bpc" id="L1597" title="1 of 2 branches missed.">        int descHandle = handles.assign(unshared ? unsharedMarker : desc);</span>
<span class="fc" id="L1598">        passHandle = NULL_HANDLE;</span>

<span class="fc" id="L1600">        ObjectStreamClass readDesc = null;</span>
        try {
<span class="fc" id="L1602">            readDesc = readClassDescriptor();</span>
<span class="fc" id="L1603">        } catch (ClassNotFoundException ex) {</span>
<span class="fc" id="L1604">            throw (IOException) new InvalidClassException(</span>
<span class="fc" id="L1605">                &quot;failed to read class descriptor&quot;).initCause(ex);</span>
<span class="fc" id="L1606">        }</span>

<span class="fc" id="L1608">        Class&lt;?&gt; cl = null;</span>
<span class="fc" id="L1609">        ClassNotFoundException resolveEx = null;</span>
<span class="fc" id="L1610">        bin.setBlockDataMode(true);</span>
<span class="fc" id="L1611">        final boolean checksRequired = isCustomSubclass();</span>
        try {
<span class="pc bpc" id="L1613" title="1 of 2 branches missed.">            if ((cl = resolveClass(readDesc)) == null) {</span>
<span class="nc" id="L1614">                resolveEx = new ClassNotFoundException(&quot;null class&quot;);</span>
<span class="fc bfc" id="L1615" title="All 2 branches covered.">            } else if (checksRequired) {</span>
<span class="fc" id="L1616">                ReflectUtil.checkPackageAccess(cl);</span>
            }
<span class="fc" id="L1618">        } catch (ClassNotFoundException ex) {</span>
<span class="fc" id="L1619">            resolveEx = ex;</span>
<span class="fc" id="L1620">        }</span>
<span class="fc" id="L1621">        skipCustomData();</span>

<span class="fc" id="L1623">        desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));</span>

<span class="fc" id="L1625">        handles.finish(descHandle);</span>
<span class="fc" id="L1626">        passHandle = descHandle;</span>
<span class="fc" id="L1627">        return desc;</span>
    }

    /**
     * Reads in and returns new string.  Sets passHandle to new string's
     * assigned handle.
     */
    private String readString(boolean unshared) throws IOException {
        String str;
<span class="fc" id="L1636">        byte tc = bin.readByte();</span>
<span class="pc bpc" id="L1637" title="2 of 3 branches missed.">        switch (tc) {</span>
            case TC_STRING:
<span class="fc" id="L1639">                str = bin.readUTF();</span>
<span class="fc" id="L1640">                break;</span>

            case TC_LONGSTRING:
<span class="nc" id="L1643">                str = bin.readLongUTF();</span>
<span class="nc" id="L1644">                break;</span>

            default:
<span class="nc" id="L1647">                throw new StreamCorruptedException(</span>
<span class="nc" id="L1648">                    String.format(&quot;invalid type code: %02X&quot;, tc));</span>
        }
<span class="fc bfc" id="L1650" title="All 2 branches covered.">        passHandle = handles.assign(unshared ? unsharedMarker : str);</span>
<span class="fc" id="L1651">        handles.finish(passHandle);</span>
<span class="fc" id="L1652">        return str;</span>
    }

    /**
     * Reads in and returns array object, or null if array class is
     * unresolvable.  Sets passHandle to array's assigned handle.
     */
    private Object readArray(boolean unshared) throws IOException {
<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">        if (bin.readByte() != TC_ARRAY) {</span>
<span class="nc" id="L1661">            throw new InternalError();</span>
        }

<span class="fc" id="L1664">        ObjectStreamClass desc = readClassDesc(false);</span>
<span class="fc" id="L1665">        int len = bin.readInt();</span>

<span class="fc" id="L1667">        Object array = null;</span>
<span class="fc" id="L1668">        Class&lt;?&gt; cl, ccl = null;</span>
<span class="pc bpc" id="L1669" title="1 of 2 branches missed.">        if ((cl = desc.forClass()) != null) {</span>
<span class="fc" id="L1670">            ccl = cl.getComponentType();</span>
<span class="fc" id="L1671">            array = Array.newInstance(ccl, len);</span>
        }

<span class="pc bpc" id="L1674" title="1 of 2 branches missed.">        int arrayHandle = handles.assign(unshared ? unsharedMarker : array);</span>
<span class="fc" id="L1675">        ClassNotFoundException resolveEx = desc.getResolveException();</span>
<span class="pc bpc" id="L1676" title="1 of 2 branches missed.">        if (resolveEx != null) {</span>
<span class="nc" id="L1677">            handles.markException(arrayHandle, resolveEx);</span>
        }

<span class="pc bpc" id="L1680" title="1 of 2 branches missed.">        if (ccl == null) {</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L1682">                readObject0(false);</span>
            }
<span class="fc bfc" id="L1684" title="All 2 branches covered.">        } else if (ccl.isPrimitive()) {</span>
<span class="fc bfc" id="L1685" title="All 2 branches covered.">            if (ccl == Integer.TYPE) {</span>
<span class="fc" id="L1686">                bin.readInts((int[]) array, 0, len);</span>
<span class="fc bfc" id="L1687" title="All 2 branches covered.">            } else if (ccl == Byte.TYPE) {</span>
<span class="fc" id="L1688">                bin.readFully((byte[]) array, 0, len, true);</span>
<span class="fc bfc" id="L1689" title="All 2 branches covered.">            } else if (ccl == Long.TYPE) {</span>
<span class="fc" id="L1690">                bin.readLongs((long[]) array, 0, len);</span>
<span class="fc bfc" id="L1691" title="All 2 branches covered.">            } else if (ccl == Float.TYPE) {</span>
<span class="fc" id="L1692">                bin.readFloats((float[]) array, 0, len);</span>
<span class="fc bfc" id="L1693" title="All 2 branches covered.">            } else if (ccl == Double.TYPE) {</span>
<span class="fc" id="L1694">                bin.readDoubles((double[]) array, 0, len);</span>
<span class="fc bfc" id="L1695" title="All 2 branches covered.">            } else if (ccl == Short.TYPE) {</span>
<span class="fc" id="L1696">                bin.readShorts((short[]) array, 0, len);</span>
<span class="fc bfc" id="L1697" title="All 2 branches covered.">            } else if (ccl == Character.TYPE) {</span>
<span class="fc" id="L1698">                bin.readChars((char[]) array, 0, len);</span>
<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">            } else if (ccl == Boolean.TYPE) {</span>
<span class="fc" id="L1700">                bin.readBooleans((boolean[]) array, 0, len);</span>
            } else {
<span class="nc" id="L1702">                throw new InternalError();</span>
            }
        } else {
<span class="fc" id="L1705">            Object[] oa = (Object[]) array;</span>
<span class="fc bfc" id="L1706" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1707">                oa[i] = readObject0(false);</span>
<span class="fc" id="L1708">                handles.markDependency(arrayHandle, passHandle);</span>
            }
        }

<span class="fc" id="L1712">        handles.finish(arrayHandle);</span>
<span class="fc" id="L1713">        passHandle = arrayHandle;</span>
<span class="fc" id="L1714">        return array;</span>
    }

    /**
     * Reads in and returns enum constant, or null if enum type is
     * unresolvable.  Sets passHandle to enum constant's assigned handle.
     */
    private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException {
<span class="pc bpc" id="L1722" title="1 of 2 branches missed.">        if (bin.readByte() != TC_ENUM) {</span>
<span class="nc" id="L1723">            throw new InternalError();</span>
        }

<span class="fc" id="L1726">        ObjectStreamClass desc = readClassDesc(false);</span>
<span class="pc bpc" id="L1727" title="1 of 2 branches missed.">        if (!desc.isEnum()) {</span>
<span class="nc" id="L1728">            throw new InvalidClassException(&quot;non-enum class: &quot; + desc);</span>
        }

<span class="pc bpc" id="L1731" title="1 of 2 branches missed.">        int enumHandle = handles.assign(unshared ? unsharedMarker : null);</span>
<span class="fc" id="L1732">        ClassNotFoundException resolveEx = desc.getResolveException();</span>
<span class="pc bpc" id="L1733" title="1 of 2 branches missed.">        if (resolveEx != null) {</span>
<span class="nc" id="L1734">            handles.markException(enumHandle, resolveEx);</span>
        }

<span class="fc" id="L1737">        String name = readString(false);</span>
<span class="fc" id="L1738">        Enum&lt;?&gt; result = null;</span>
<span class="fc" id="L1739">        Class&lt;?&gt; cl = desc.forClass();</span>
<span class="pc bpc" id="L1740" title="1 of 2 branches missed.">        if (cl != null) {</span>
            try {
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1743">                Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);</span>
<span class="fc" id="L1744">                result = en;</span>
<span class="nc" id="L1745">            } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L1746">                throw (IOException) new InvalidObjectException(</span>
                    &quot;enum constant &quot; + name + &quot; does not exist in &quot; +
<span class="nc" id="L1748">                    cl).initCause(ex);</span>
<span class="fc" id="L1749">            }</span>
<span class="pc bpc" id="L1750" title="1 of 2 branches missed.">            if (!unshared) {</span>
<span class="fc" id="L1751">                handles.setObject(enumHandle, result);</span>
            }
        }

<span class="fc" id="L1755">        handles.finish(enumHandle);</span>
<span class="fc" id="L1756">        passHandle = enumHandle;</span>
<span class="fc" id="L1757">        return result;</span>
    }

    /**
     * Reads and returns &quot;ordinary&quot; (i.e., not a String, Class,
     * ObjectStreamClass, array, or enum constant) object, or null if object's
     * class is unresolvable (in which case a ClassNotFoundException will be
     * associated with object's handle).  Sets passHandle to object's assigned
     * handle.
     */
    private Object readOrdinaryObject(boolean unshared)
        throws IOException
    {
<span class="pc bpc" id="L1770" title="1 of 2 branches missed.">        if (bin.readByte() != TC_OBJECT) {</span>
<span class="nc" id="L1771">            throw new InternalError();</span>
        }

<span class="fc" id="L1774">        ObjectStreamClass desc = readClassDesc(false);</span>
<span class="fc" id="L1775">        desc.checkDeserialize();</span>

<span class="fc" id="L1777">        Class&lt;?&gt; cl = desc.forClass();</span>
<span class="pc bpc" id="L1778" title="3 of 6 branches missed.">        if (cl == String.class || cl == Class.class</span>
                || cl == ObjectStreamClass.class) {
<span class="nc" id="L1780">            throw new InvalidClassException(&quot;invalid class descriptor&quot;);</span>
        }

        Object obj;
        try {
<span class="fc bfc" id="L1785" title="All 2 branches covered.">            obj = desc.isInstantiable() ? desc.newInstance() : null;</span>
<span class="nc" id="L1786">        } catch (Exception ex) {</span>
<span class="nc" id="L1787">            throw (IOException) new InvalidClassException(</span>
<span class="nc" id="L1788">                desc.forClass().getName(),</span>
<span class="nc" id="L1789">                &quot;unable to create instance&quot;).initCause(ex);</span>
<span class="fc" id="L1790">        }</span>

<span class="fc bfc" id="L1792" title="All 2 branches covered.">        passHandle = handles.assign(unshared ? unsharedMarker : obj);</span>
<span class="fc" id="L1793">        ClassNotFoundException resolveEx = desc.getResolveException();</span>
<span class="fc bfc" id="L1794" title="All 2 branches covered.">        if (resolveEx != null) {</span>
<span class="fc" id="L1795">            handles.markException(passHandle, resolveEx);</span>
        }

<span class="fc bfc" id="L1798" title="All 2 branches covered.">        if (desc.isExternalizable()) {</span>
<span class="fc" id="L1799">            readExternalData((Externalizable) obj, desc);</span>
        } else {
<span class="fc" id="L1801">            readSerialData(obj, desc);</span>
        }

<span class="fc" id="L1804">        handles.finish(passHandle);</span>

<span class="fc bfc" id="L1806" title="All 2 branches covered.">        if (obj != null &amp;&amp;</span>
<span class="fc bfc" id="L1807" title="All 2 branches covered.">            handles.lookupException(passHandle) == null &amp;&amp;</span>
<span class="fc bfc" id="L1808" title="All 2 branches covered.">            desc.hasReadResolveMethod())</span>
        {
<span class="fc" id="L1810">            Object rep = desc.invokeReadResolve(obj);</span>
<span class="pc bpc" id="L1811" title="1 of 4 branches missed.">            if (unshared &amp;&amp; rep.getClass().isArray()) {</span>
<span class="fc" id="L1812">                rep = cloneArray(rep);</span>
            }
<span class="pc bpc" id="L1814" title="1 of 2 branches missed.">            if (rep != obj) {</span>
<span class="fc" id="L1815">                handles.setObject(passHandle, obj = rep);</span>
            }
        }

<span class="fc" id="L1819">        return obj;</span>
    }

    /**
     * If obj is non-null, reads externalizable data by invoking readExternal()
     * method of obj; otherwise, attempts to skip over externalizable data.
     * Expects that passHandle is set to obj's handle before this method is
     * called.
     */
    private void readExternalData(Externalizable obj, ObjectStreamClass desc)
        throws IOException
    {
<span class="fc" id="L1831">        SerialCallbackContext oldContext = curContext;</span>
<span class="fc" id="L1832">        curContext = null;</span>
        try {
<span class="fc" id="L1834">            boolean blocked = desc.hasBlockExternalData();</span>
<span class="fc bfc" id="L1835" title="All 2 branches covered.">            if (blocked) {</span>
<span class="fc" id="L1836">                bin.setBlockDataMode(true);</span>
            }
<span class="fc bfc" id="L1838" title="All 2 branches covered.">            if (obj != null) {</span>
                try {
<span class="fc" id="L1840">                    obj.readExternal(this);</span>
<span class="nc" id="L1841">                } catch (ClassNotFoundException ex) {</span>
                    /*
                     * In most cases, the handle table has already propagated
                     * a CNFException to passHandle at this point; this mark
                     * call is included to address cases where the readExternal
                     * method has cons'ed and thrown a new CNFException of its
                     * own.
                     */
<span class="nc" id="L1849">                     handles.markException(passHandle, ex);</span>
<span class="fc" id="L1850">                }</span>
            }
<span class="fc bfc" id="L1852" title="All 2 branches covered.">            if (blocked) {</span>
<span class="fc" id="L1853">                skipCustomData();</span>
            }
        } finally {
<span class="pc" id="L1856">            curContext = oldContext;</span>
<span class="fc" id="L1857">        }</span>
        /*
         * At this point, if the externalizable data was not written in
         * block-data form and either the externalizable class doesn't exist
         * locally (i.e., obj == null) or readExternal() just threw a
         * CNFException, then the stream is probably in an inconsistent state,
         * since some (or all) of the externalizable data may not have been
         * consumed.  Since there's no &quot;correct&quot; action to take in this case,
         * we mimic the behavior of past serialization implementations and
         * blindly hope that the stream is in sync; if it isn't and additional
         * externalizable data remains in the stream, a subsequent read will
         * most likely throw a StreamCorruptedException.
         */
<span class="fc" id="L1870">    }</span>

    /**
     * Reads (or attempts to skip, if obj is null or is tagged with a
     * ClassNotFoundException) instance data for each serializable class of
     * object in stream, from superclass to subclass.  Expects that passHandle
     * is set to obj's handle before this method is called.
     */
    private void readSerialData(Object obj, ObjectStreamClass desc)
        throws IOException
    {
<span class="fc" id="L1881">        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span>
<span class="fc bfc" id="L1882" title="All 2 branches covered.">        for (int i = 0; i &lt; slots.length; i++) {</span>
<span class="fc" id="L1883">            ObjectStreamClass slotDesc = slots[i].desc;</span>

<span class="fc bfc" id="L1885" title="All 2 branches covered.">            if (slots[i].hasData) {</span>
<span class="fc bfc" id="L1886" title="All 2 branches covered.">                if (obj != null &amp;&amp;</span>
<span class="fc bfc" id="L1887" title="All 2 branches covered.">                    slotDesc.hasReadObjectMethod() &amp;&amp;</span>
<span class="fc bfc" id="L1888" title="All 2 branches covered.">                    handles.lookupException(passHandle) == null)</span>
                {
<span class="fc" id="L1890">                    SerialCallbackContext oldContext = curContext;</span>

                    try {
<span class="fc" id="L1893">                        curContext = new SerialCallbackContext(obj, slotDesc);</span>

<span class="fc" id="L1895">                        bin.setBlockDataMode(true);</span>
<span class="fc" id="L1896">                        slotDesc.invokeReadObject(obj, this);</span>
<span class="fc" id="L1897">                    } catch (ClassNotFoundException ex) {</span>
                        /*
                         * In most cases, the handle table has already
                         * propagated a CNFException to passHandle at this
                         * point; this mark call is included to address cases
                         * where the custom readObject method has cons'ed and
                         * thrown a new CNFException of its own.
                         */
<span class="fc" id="L1905">                        handles.markException(passHandle, ex);</span>
                    } finally {
<span class="fc" id="L1907">                        curContext.setUsed();</span>
<span class="fc" id="L1908">                        curContext = oldContext;</span>
<span class="fc" id="L1909">                    }</span>

                    /*
                     * defaultDataEnd may have been set indirectly by custom
                     * readObject() method when calling defaultReadObject() or
                     * readFields(); clear it to restore normal read behavior.
                     */
<span class="fc" id="L1916">                    defaultDataEnd = false;</span>
<span class="fc" id="L1917">                } else {</span>
<span class="fc" id="L1918">                    defaultReadFields(obj, slotDesc);</span>
                }
<span class="fc bfc" id="L1920" title="All 2 branches covered.">                if (slotDesc.hasWriteObjectData()) {</span>
<span class="fc" id="L1921">                    skipCustomData();</span>
                } else {
<span class="fc" id="L1923">                    bin.setBlockDataMode(false);</span>
                }
            } else {
<span class="pc bpc" id="L1926" title="1 of 2 branches missed.">                if (obj != null &amp;&amp;</span>
<span class="fc bfc" id="L1927" title="All 2 branches covered.">                    slotDesc.hasReadObjectNoDataMethod() &amp;&amp;</span>
<span class="pc bpc" id="L1928" title="1 of 2 branches missed.">                    handles.lookupException(passHandle) == null)</span>
                {
<span class="nc" id="L1930">                    slotDesc.invokeReadObjectNoData(obj);</span>
                }
            }
        }
<span class="fc" id="L1934">    }</span>

    /**
     * Skips over all block data and objects until TC_ENDBLOCKDATA is
     * encountered.
     */
    private void skipCustomData() throws IOException {
<span class="fc" id="L1941">        int oldHandle = passHandle;</span>
        for (;;) {
<span class="fc bfc" id="L1943" title="All 2 branches covered.">            if (bin.getBlockDataMode()) {</span>
<span class="fc" id="L1944">                bin.skipBlockData();</span>
<span class="fc" id="L1945">                bin.setBlockDataMode(false);</span>
            }
<span class="pc bpc" id="L1947" title="2 of 3 branches missed.">            switch (bin.peekByte()) {</span>
                case TC_BLOCKDATA:
                case TC_BLOCKDATALONG:
<span class="nc" id="L1950">                    bin.setBlockDataMode(true);</span>
<span class="nc" id="L1951">                    break;</span>

                case TC_ENDBLOCKDATA:
<span class="fc" id="L1954">                    bin.readByte();</span>
<span class="fc" id="L1955">                    passHandle = oldHandle;</span>
<span class="fc" id="L1956">                    return;</span>

                default:
<span class="nc" id="L1959">                    readObject0(false);</span>
<span class="nc" id="L1960">                    break;</span>
            }
        }
    }

    /**
     * Reads in values of serializable fields declared by given class
     * descriptor.  If obj is non-null, sets field values in obj.  Expects that
     * passHandle is set to obj's handle before this method is called.
     */
    private void defaultReadFields(Object obj, ObjectStreamClass desc)
        throws IOException
    {
<span class="fc" id="L1973">        Class&lt;?&gt; cl = desc.forClass();</span>
<span class="pc bpc" id="L1974" title="2 of 6 branches missed.">        if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {</span>
<span class="nc" id="L1975">            throw new ClassCastException();</span>
        }

<span class="fc" id="L1978">        int primDataSize = desc.getPrimDataSize();</span>
<span class="fc bfc" id="L1979" title="All 4 branches covered.">        if (primVals == null || primVals.length &lt; primDataSize) {</span>
<span class="fc" id="L1980">            primVals = new byte[primDataSize];</span>
        }
<span class="fc" id="L1982">        bin.readFully(primVals, 0, primDataSize, false);</span>
<span class="fc bfc" id="L1983" title="All 2 branches covered.">        if (obj != null) {</span>
<span class="fc" id="L1984">            desc.setPrimFieldValues(obj, primVals);</span>
        }

<span class="fc" id="L1987">        int objHandle = passHandle;</span>
<span class="fc" id="L1988">        ObjectStreamField[] fields = desc.getFields(false);</span>
<span class="fc" id="L1989">        Object[] objVals = new Object[desc.getNumObjFields()];</span>
<span class="fc" id="L1990">        int numPrimFields = fields.length - objVals.length;</span>
<span class="fc bfc" id="L1991" title="All 2 branches covered.">        for (int i = 0; i &lt; objVals.length; i++) {</span>
<span class="fc" id="L1992">            ObjectStreamField f = fields[numPrimFields + i];</span>
<span class="fc" id="L1993">            objVals[i] = readObject0(f.isUnshared());</span>
<span class="fc bfc" id="L1994" title="All 2 branches covered.">            if (f.getField() != null) {</span>
<span class="fc" id="L1995">                handles.markDependency(objHandle, passHandle);</span>
            }
        }
<span class="fc bfc" id="L1998" title="All 2 branches covered.">        if (obj != null) {</span>
<span class="fc" id="L1999">            desc.setObjFieldValues(obj, objVals);</span>
        }
<span class="fc" id="L2001">        passHandle = objHandle;</span>
<span class="fc" id="L2002">    }</span>

    /**
     * Reads in and returns IOException that caused serialization to abort.
     * All stream state is discarded prior to reading in fatal exception.  Sets
     * passHandle to fatal exception's handle.
     */
    private IOException readFatalException() throws IOException {
<span class="nc bnc" id="L2010" title="All 2 branches missed.">        if (bin.readByte() != TC_EXCEPTION) {</span>
<span class="nc" id="L2011">            throw new InternalError();</span>
        }
<span class="nc" id="L2013">        clear();</span>
<span class="nc" id="L2014">        return (IOException) readObject0(false);</span>
    }

    /**
     * If recursion depth is 0, clears internal data structures; otherwise,
     * throws a StreamCorruptedException.  This method is called when a
     * TC_RESET typecode is encountered.
     */
    private void handleReset() throws StreamCorruptedException {
<span class="pc bpc" id="L2023" title="1 of 2 branches missed.">        if (depth &gt; 0) {</span>
<span class="nc" id="L2024">            throw new StreamCorruptedException(</span>
                &quot;unexpected reset; recursion depth: &quot; + depth);
        }
<span class="fc" id="L2027">        clear();</span>
<span class="fc" id="L2028">    }</span>

    /**
     * Converts specified span of bytes into float values.
     */
    // REMIND: remove once hotspot inlines Float.intBitsToFloat
    private static native void bytesToFloats(byte[] src, int srcpos,
                                             float[] dst, int dstpos,
                                             int nfloats);

    /**
     * Converts specified span of bytes into double values.
     */
    // REMIND: remove once hotspot inlines Double.longBitsToDouble
    private static native void bytesToDoubles(byte[] src, int srcpos,
                                              double[] dst, int dstpos,
                                              int ndoubles);

    /**
     * Returns the first non-null class loader (not counting class loaders of
     * generated reflection implementation classes) up the execution stack, or
     * null if only code from the null class loader is on the stack.  This
     * method is also called via reflection by the following RMI-IIOP class:
     *
     *     com.sun.corba.se.internal.util.JDKClassLoader
     *
     * This method should not be removed or its signature changed without
     * corresponding modifications to the above class.
     */
    private static ClassLoader latestUserDefinedLoader() {
<span class="fc" id="L2058">        return sun.misc.VM.latestUserDefinedLoader();</span>
    }

    /**
     * Default GetField implementation.
     */
    private class GetFieldImpl extends GetField {

        /** class descriptor describing serializable fields */
        private final ObjectStreamClass desc;
        /** primitive field values */
        private final byte[] primVals;
        /** object field values */
        private final Object[] objVals;
        /** object field value handles */
        private final int[] objHandles;

        /**
         * Creates GetFieldImpl object for reading fields defined in given
         * class descriptor.
         */
<span class="fc" id="L2079">        GetFieldImpl(ObjectStreamClass desc) {</span>
<span class="fc" id="L2080">            this.desc = desc;</span>
<span class="fc" id="L2081">            primVals = new byte[desc.getPrimDataSize()];</span>
<span class="fc" id="L2082">            objVals = new Object[desc.getNumObjFields()];</span>
<span class="fc" id="L2083">            objHandles = new int[objVals.length];</span>
<span class="fc" id="L2084">        }</span>

        public ObjectStreamClass getObjectStreamClass() {
<span class="nc" id="L2087">            return desc;</span>
        }

        public boolean defaulted(String name) throws IOException {
<span class="nc bnc" id="L2091" title="All 2 branches missed.">            return (getFieldOffset(name, null) &lt; 0);</span>
        }

        public boolean get(String name, boolean val) throws IOException {
<span class="fc" id="L2095">            int off = getFieldOffset(name, Boolean.TYPE);</span>
<span class="pc bpc" id="L2096" title="1 of 2 branches missed.">            return (off &gt;= 0) ? Bits.getBoolean(primVals, off) : val;</span>
        }

        public byte get(String name, byte val) throws IOException {
<span class="fc" id="L2100">            int off = getFieldOffset(name, Byte.TYPE);</span>
<span class="pc bpc" id="L2101" title="1 of 2 branches missed.">            return (off &gt;= 0) ? primVals[off] : val;</span>
        }

        public char get(String name, char val) throws IOException {
<span class="fc" id="L2105">            int off = getFieldOffset(name, Character.TYPE);</span>
<span class="pc bpc" id="L2106" title="1 of 2 branches missed.">            return (off &gt;= 0) ? Bits.getChar(primVals, off) : val;</span>
        }

        public short get(String name, short val) throws IOException {
<span class="fc" id="L2110">            int off = getFieldOffset(name, Short.TYPE);</span>
<span class="pc bpc" id="L2111" title="1 of 2 branches missed.">            return (off &gt;= 0) ? Bits.getShort(primVals, off) : val;</span>
        }

        public int get(String name, int val) throws IOException {
<span class="fc" id="L2115">            int off = getFieldOffset(name, Integer.TYPE);</span>
<span class="pc bpc" id="L2116" title="1 of 2 branches missed.">            return (off &gt;= 0) ? Bits.getInt(primVals, off) : val;</span>
        }

        public float get(String name, float val) throws IOException {
<span class="fc" id="L2120">            int off = getFieldOffset(name, Float.TYPE);</span>
<span class="pc bpc" id="L2121" title="1 of 2 branches missed.">            return (off &gt;= 0) ? Bits.getFloat(primVals, off) : val;</span>
        }

        public long get(String name, long val) throws IOException {
<span class="fc" id="L2125">            int off = getFieldOffset(name, Long.TYPE);</span>
<span class="pc bpc" id="L2126" title="1 of 2 branches missed.">            return (off &gt;= 0) ? Bits.getLong(primVals, off) : val;</span>
        }

        public double get(String name, double val) throws IOException {
<span class="fc" id="L2130">            int off = getFieldOffset(name, Double.TYPE);</span>
<span class="pc bpc" id="L2131" title="1 of 2 branches missed.">            return (off &gt;= 0) ? Bits.getDouble(primVals, off) : val;</span>
        }

        public Object get(String name, Object val) throws IOException {
<span class="fc" id="L2135">            int off = getFieldOffset(name, Object.class);</span>
<span class="fc bfc" id="L2136" title="All 2 branches covered.">            if (off &gt;= 0) {</span>
<span class="fc" id="L2137">                int objHandle = objHandles[off];</span>
<span class="fc" id="L2138">                handles.markDependency(passHandle, objHandle);</span>
<span class="pc bpc" id="L2139" title="1 of 2 branches missed.">                return (handles.lookupException(objHandle) == null) ?</span>
                    objVals[off] : null;
            } else {
<span class="fc" id="L2142">                return val;</span>
            }
        }

        /**
         * Reads primitive and object field values from stream.
         */
        void readFields() throws IOException {
<span class="fc" id="L2150">            bin.readFully(primVals, 0, primVals.length, false);</span>

<span class="fc" id="L2152">            int oldHandle = passHandle;</span>
<span class="fc" id="L2153">            ObjectStreamField[] fields = desc.getFields(false);</span>
<span class="fc" id="L2154">            int numPrimFields = fields.length - objVals.length;</span>
<span class="fc bfc" id="L2155" title="All 2 branches covered.">            for (int i = 0; i &lt; objVals.length; i++) {</span>
<span class="fc" id="L2156">                objVals[i] =</span>
<span class="fc" id="L2157">                    readObject0(fields[numPrimFields + i].isUnshared());</span>
<span class="fc" id="L2158">                objHandles[i] = passHandle;</span>
            }
<span class="fc" id="L2160">            passHandle = oldHandle;</span>
<span class="fc" id="L2161">        }</span>

        /**
         * Returns offset of field with given name and type.  A specified type
         * of null matches all types, Object.class matches all non-primitive
         * types, and any other non-null type matches assignable types only.
         * If no matching field is found in the (incoming) class
         * descriptor but a matching field is present in the associated local
         * class descriptor, returns -1.  Throws IllegalArgumentException if
         * neither incoming nor local class descriptor contains a match.
         */
        private int getFieldOffset(String name, Class&lt;?&gt; type) {
<span class="fc" id="L2173">            ObjectStreamField field = desc.getField(name, type);</span>
<span class="fc bfc" id="L2174" title="All 2 branches covered.">            if (field != null) {</span>
<span class="fc" id="L2175">                return field.getOffset();</span>
<span class="fc bfc" id="L2176" title="All 2 branches covered.">            } else if (desc.getLocalDesc().getField(name, type) != null) {</span>
<span class="fc" id="L2177">                return -1;</span>
            } else {
<span class="fc" id="L2179">                throw new IllegalArgumentException(&quot;no such field &quot; + name +</span>
                                                   &quot; with type &quot; + type);
            }
        }
    }

    /**
     * Prioritized list of callbacks to be performed once object graph has been
     * completely deserialized.
     */
    private static class ValidationList {

        private static class Callback {
            final ObjectInputValidation obj;
            final int priority;
            Callback next;
            final AccessControlContext acc;

            Callback(ObjectInputValidation obj, int priority, Callback next,
                AccessControlContext acc)
<span class="nc" id="L2199">            {</span>
<span class="nc" id="L2200">                this.obj = obj;</span>
<span class="nc" id="L2201">                this.priority = priority;</span>
<span class="nc" id="L2202">                this.next = next;</span>
<span class="nc" id="L2203">                this.acc = acc;</span>
<span class="nc" id="L2204">            }</span>
        }

        /** linked list of callbacks */
        private Callback list;

        /**
         * Creates new (empty) ValidationList.
         */
<span class="fc" id="L2213">        ValidationList() {</span>
<span class="fc" id="L2214">        }</span>

        /**
         * Registers callback.  Throws InvalidObjectException if callback
         * object is null.
         */
        void register(ObjectInputValidation obj, int priority)
            throws InvalidObjectException
        {
<span class="nc bnc" id="L2223" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L2224">                throw new InvalidObjectException(&quot;null callback&quot;);</span>
            }

<span class="nc" id="L2227">            Callback prev = null, cur = list;</span>
<span class="nc bnc" id="L2228" title="All 4 branches missed.">            while (cur != null &amp;&amp; priority &lt; cur.priority) {</span>
<span class="nc" id="L2229">                prev = cur;</span>
<span class="nc" id="L2230">                cur = cur.next;</span>
            }
<span class="nc" id="L2232">            AccessControlContext acc = AccessController.getContext();</span>
<span class="nc bnc" id="L2233" title="All 2 branches missed.">            if (prev != null) {</span>
<span class="nc" id="L2234">                prev.next = new Callback(obj, priority, cur, acc);</span>
            } else {
<span class="nc" id="L2236">                list = new Callback(obj, priority, list, acc);</span>
            }
<span class="nc" id="L2238">        }</span>

        /**
         * Invokes all registered callbacks and clears the callback list.
         * Callbacks with higher priorities are called first; those with equal
         * priorities may be called in any order.  If any of the callbacks
         * throws an InvalidObjectException, the callback process is terminated
         * and the exception propagated upwards.
         */
        void doCallbacks() throws InvalidObjectException {
            try {
<span class="pc bpc" id="L2249" title="1 of 2 branches missed.">                while (list != null) {</span>
<span class="nc" id="L2250">                    AccessController.doPrivileged(</span>
                        new PrivilegedExceptionAction&lt;Void&gt;()
<span class="nc" id="L2252">                    {</span>
                        public Void run() throws InvalidObjectException {
<span class="nc" id="L2254">                            list.obj.validateObject();</span>
<span class="nc" id="L2255">                            return null;</span>
                        }
                    }, list.acc);
<span class="nc" id="L2258">                    list = list.next;</span>
                }
<span class="nc" id="L2260">            } catch (PrivilegedActionException ex) {</span>
<span class="nc" id="L2261">                list = null;</span>
<span class="nc" id="L2262">                throw (InvalidObjectException) ex.getException();</span>
<span class="fc" id="L2263">            }</span>
<span class="fc" id="L2264">        }</span>

        /**
         * Resets the callback list to its initial (empty) state.
         */
        public void clear() {
<span class="fc" id="L2270">            list = null;</span>
<span class="fc" id="L2271">        }</span>
    }

    /**
     * Input stream supporting single-byte peek operations.
     */
    private static class PeekInputStream extends InputStream {

        /** underlying stream */
        private final InputStream in;
        /** peeked byte */
<span class="fc" id="L2282">        private int peekb = -1;</span>

        /**
         * Creates new PeekInputStream on top of given underlying stream.
         */
<span class="fc" id="L2287">        PeekInputStream(InputStream in) {</span>
<span class="fc" id="L2288">            this.in = in;</span>
<span class="fc" id="L2289">        }</span>

        /**
         * Peeks at next byte value in stream.  Similar to read(), except
         * that it does not consume the read value.
         */
        int peek() throws IOException {
<span class="fc bfc" id="L2296" title="All 2 branches covered.">            return (peekb &gt;= 0) ? peekb : (peekb = in.read());</span>
        }

        public int read() throws IOException {
<span class="fc bfc" id="L2300" title="All 2 branches covered.">            if (peekb &gt;= 0) {</span>
<span class="fc" id="L2301">                int v = peekb;</span>
<span class="fc" id="L2302">                peekb = -1;</span>
<span class="fc" id="L2303">                return v;</span>
            } else {
<span class="fc" id="L2305">                return in.read();</span>
            }
        }

        public int read(byte[] b, int off, int len) throws IOException {
<span class="pc bpc" id="L2310" title="1 of 2 branches missed.">            if (len == 0) {</span>
<span class="nc" id="L2311">                return 0;</span>
<span class="fc bfc" id="L2312" title="All 2 branches covered.">            } else if (peekb &lt; 0) {</span>
<span class="fc" id="L2313">                return in.read(b, off, len);</span>
            } else {
<span class="fc" id="L2315">                b[off++] = (byte) peekb;</span>
<span class="fc" id="L2316">                len--;</span>
<span class="fc" id="L2317">                peekb = -1;</span>
<span class="fc" id="L2318">                int n = in.read(b, off, len);</span>
<span class="pc bpc" id="L2319" title="1 of 2 branches missed.">                return (n &gt;= 0) ? (n + 1) : 1;</span>
            }
        }

        void readFully(byte[] b, int off, int len) throws IOException {
<span class="fc" id="L2324">            int n = 0;</span>
<span class="fc bfc" id="L2325" title="All 2 branches covered.">            while (n &lt; len) {</span>
<span class="fc" id="L2326">                int count = read(b, off + n, len - n);</span>
<span class="pc bpc" id="L2327" title="1 of 2 branches missed.">                if (count &lt; 0) {</span>
<span class="nc" id="L2328">                    throw new EOFException();</span>
                }
<span class="fc" id="L2330">                n += count;</span>
<span class="fc" id="L2331">            }</span>
<span class="fc" id="L2332">        }</span>

        public long skip(long n) throws IOException {
<span class="nc bnc" id="L2335" title="All 2 branches missed.">            if (n &lt;= 0) {</span>
<span class="nc" id="L2336">                return 0;</span>
            }
<span class="nc" id="L2338">            int skipped = 0;</span>
<span class="nc bnc" id="L2339" title="All 2 branches missed.">            if (peekb &gt;= 0) {</span>
<span class="nc" id="L2340">                peekb = -1;</span>
<span class="nc" id="L2341">                skipped++;</span>
<span class="nc" id="L2342">                n--;</span>
            }
<span class="nc" id="L2344">            return skipped + skip(n);</span>
        }

        public int available() throws IOException {
<span class="pc bpc" id="L2348" title="1 of 2 branches missed.">            return in.available() + ((peekb &gt;= 0) ? 1 : 0);</span>
        }

        public void close() throws IOException {
<span class="fc" id="L2352">            in.close();</span>
<span class="fc" id="L2353">        }</span>
    }

    /**
     * Input stream with two modes: in default mode, inputs data written in the
     * same format as DataOutputStream; in &quot;block data&quot; mode, inputs data
     * bracketed by block data markers (see object serialization specification
     * for details).  Buffering depends on block data mode: when in default
     * mode, no data is buffered in advance; when in block data mode, all data
     * for the current data block is read in at once (and buffered).
     */
    private class BlockDataInputStream
        extends InputStream implements DataInput
    {
        /** maximum data block length */
        private static final int MAX_BLOCK_SIZE = 1024;
        /** maximum data block header length */
        private static final int MAX_HEADER_SIZE = 5;
        /** (tunable) length of char buffer (for reading strings) */
        private static final int CHAR_BUF_SIZE = 256;
        /** readBlockHeader() return value indicating header read may block */
        private static final int HEADER_BLOCKED = -2;

        /** buffer for reading general/block data */
<span class="fc" id="L2377">        private final byte[] buf = new byte[MAX_BLOCK_SIZE];</span>
        /** buffer for reading block data headers */
<span class="fc" id="L2379">        private final byte[] hbuf = new byte[MAX_HEADER_SIZE];</span>
        /** char buffer for fast string reads */
<span class="fc" id="L2381">        private final char[] cbuf = new char[CHAR_BUF_SIZE];</span>

        /** block data mode */
<span class="fc" id="L2384">        private boolean blkmode = false;</span>

        // block data state fields; values meaningful only when blkmode true
        /** current offset into buf */
<span class="fc" id="L2388">        private int pos = 0;</span>
        /** end offset of valid data in buf, or -1 if no more block data */
<span class="fc" id="L2390">        private int end = -1;</span>
        /** number of bytes in current block yet to be read from stream */
<span class="fc" id="L2392">        private int unread = 0;</span>

        /** underlying stream (wrapped in peekable filter stream) */
        private final PeekInputStream in;
        /** loopback stream (for data reads that span data blocks) */
        private final DataInputStream din;

        /**
         * Creates new BlockDataInputStream on top of given underlying stream.
         * Block data mode is turned off by default.
         */
<span class="fc" id="L2403">        BlockDataInputStream(InputStream in) {</span>
<span class="fc" id="L2404">            this.in = new PeekInputStream(in);</span>
<span class="fc" id="L2405">            din = new DataInputStream(this);</span>
<span class="fc" id="L2406">        }</span>

        /**
         * Sets block data mode to the given mode (true == on, false == off)
         * and returns the previous mode value.  If the new mode is the same as
         * the old mode, no action is taken.  Throws IllegalStateException if
         * block data mode is being switched from on to off while unconsumed
         * block data is still present in the stream.
         */
        boolean setBlockDataMode(boolean newmode) throws IOException {
<span class="fc bfc" id="L2416" title="All 2 branches covered.">            if (blkmode == newmode) {</span>
<span class="fc" id="L2417">                return blkmode;</span>
            }
<span class="fc bfc" id="L2419" title="All 2 branches covered.">            if (newmode) {</span>
<span class="fc" id="L2420">                pos = 0;</span>
<span class="fc" id="L2421">                end = 0;</span>
<span class="fc" id="L2422">                unread = 0;</span>
<span class="pc bpc" id="L2423" title="1 of 2 branches missed.">            } else if (pos &lt; end) {</span>
<span class="nc" id="L2424">                throw new IllegalStateException(&quot;unread block data&quot;);</span>
            }
<span class="fc" id="L2426">            blkmode = newmode;</span>
<span class="fc bfc" id="L2427" title="All 2 branches covered.">            return !blkmode;</span>
        }

        /**
         * Returns true if the stream is currently in block data mode, false
         * otherwise.
         */
        boolean getBlockDataMode() {
<span class="fc" id="L2435">            return blkmode;</span>
        }

        /**
         * If in block data mode, skips to the end of the current group of data
         * blocks (but does not unset block data mode).  If not in block data
         * mode, throws an IllegalStateException.
         */
        void skipBlockData() throws IOException {
<span class="pc bpc" id="L2444" title="1 of 2 branches missed.">            if (!blkmode) {</span>
<span class="nc" id="L2445">                throw new IllegalStateException(&quot;not in block data mode&quot;);</span>
            }
<span class="fc bfc" id="L2447" title="All 2 branches covered.">            while (end &gt;= 0) {</span>
<span class="fc" id="L2448">                refill();</span>
            }
<span class="fc" id="L2450">        }</span>

        /**
         * Attempts to read in the next block data header (if any).  If
         * canBlock is false and a full header cannot be read without possibly
         * blocking, returns HEADER_BLOCKED, else if the next element in the
         * stream is a block data header, returns the block data length
         * specified by the header, else returns -1.
         */
        private int readBlockHeader(boolean canBlock) throws IOException {
<span class="fc bfc" id="L2460" title="All 2 branches covered.">            if (defaultDataEnd) {</span>
                /*
                 * Fix for 4360508: stream is currently at the end of a field
                 * value block written via default serialization; since there
                 * is no terminating TC_ENDBLOCKDATA tag, simulate
                 * end-of-custom-data behavior explicitly.
                 */
<span class="fc" id="L2467">                return -1;</span>
            }
            try {
                for (;;) {
<span class="fc bfc" id="L2471" title="All 2 branches covered.">                    int avail = canBlock ? Integer.MAX_VALUE : in.available();</span>
<span class="fc bfc" id="L2472" title="All 2 branches covered.">                    if (avail == 0) {</span>
<span class="fc" id="L2473">                        return HEADER_BLOCKED;</span>
                    }

<span class="fc" id="L2476">                    int tc = in.peek();</span>
<span class="pc bpc" id="L2477" title="1 of 4 branches missed.">                    switch (tc) {</span>
                        case TC_BLOCKDATA:
<span class="fc bfc" id="L2479" title="All 2 branches covered.">                            if (avail &lt; 2) {</span>
<span class="fc" id="L2480">                                return HEADER_BLOCKED;</span>
                            }
<span class="fc" id="L2482">                            in.readFully(hbuf, 0, 2);</span>
<span class="fc" id="L2483">                            return hbuf[1] &amp; 0xFF;</span>

                        case TC_BLOCKDATALONG:
<span class="fc bfc" id="L2486" title="All 2 branches covered.">                            if (avail &lt; 5) {</span>
<span class="fc" id="L2487">                                return HEADER_BLOCKED;</span>
                            }
<span class="fc" id="L2489">                            in.readFully(hbuf, 0, 5);</span>
<span class="fc" id="L2490">                            int len = Bits.getInt(hbuf, 1);</span>
<span class="pc bpc" id="L2491" title="1 of 2 branches missed.">                            if (len &lt; 0) {</span>
<span class="nc" id="L2492">                                throw new StreamCorruptedException(</span>
                                    &quot;illegal block data header length: &quot; +
                                    len);
                            }
<span class="fc" id="L2496">                            return len;</span>

                        /*
                         * TC_RESETs may occur in between data blocks.
                         * Unfortunately, this case must be parsed at a lower
                         * level than other typecodes, since primitive data
                         * reads may span data blocks separated by a TC_RESET.
                         */
                        case TC_RESET:
<span class="nc" id="L2505">                            in.read();</span>
<span class="nc" id="L2506">                            handleReset();</span>
<span class="nc" id="L2507">                            break;</span>

                        default:
<span class="pc bpc" id="L2510" title="3 of 6 branches missed.">                            if (tc &gt;= 0 &amp;&amp; (tc &lt; TC_BASE || tc &gt; TC_MAX)) {</span>
<span class="nc" id="L2511">                                throw new StreamCorruptedException(</span>
<span class="nc" id="L2512">                                    String.format(&quot;invalid type code: %02X&quot;,</span>
<span class="nc" id="L2513">                                    tc));</span>
                            }
<span class="fc" id="L2515">                            return -1;</span>
                    }
<span class="nc" id="L2517">                }</span>
<span class="nc" id="L2518">            } catch (EOFException ex) {</span>
<span class="nc" id="L2519">                throw new StreamCorruptedException(</span>
                    &quot;unexpected EOF while reading block data header&quot;);
            }
        }

        /**
         * Refills internal buffer buf with block data.  Any data in buf at the
         * time of the call is considered consumed.  Sets the pos, end, and
         * unread fields to reflect the new amount of available block data; if
         * the next element in the stream is not a data block, sets pos and
         * unread to 0 and end to -1.
         */
        private void refill() throws IOException {
            try {
                do {
<span class="fc" id="L2534">                    pos = 0;</span>
<span class="fc bfc" id="L2535" title="All 2 branches covered.">                    if (unread &gt; 0) {</span>
<span class="fc" id="L2536">                        int n =</span>
<span class="fc" id="L2537">                            in.read(buf, 0, Math.min(unread, MAX_BLOCK_SIZE));</span>
<span class="pc bpc" id="L2538" title="1 of 2 branches missed.">                        if (n &gt;= 0) {</span>
<span class="fc" id="L2539">                            end = n;</span>
<span class="fc" id="L2540">                            unread -= n;</span>
                        } else {
<span class="nc" id="L2542">                            throw new StreamCorruptedException(</span>
                                &quot;unexpected EOF in middle of data block&quot;);
                        }
<span class="fc" id="L2545">                    } else {</span>
<span class="fc" id="L2546">                        int n = readBlockHeader(true);</span>
<span class="fc bfc" id="L2547" title="All 2 branches covered.">                        if (n &gt;= 0) {</span>
<span class="fc" id="L2548">                            end = 0;</span>
<span class="fc" id="L2549">                            unread = n;</span>
                        } else {
<span class="fc" id="L2551">                            end = -1;</span>
<span class="fc" id="L2552">                            unread = 0;</span>
                        }
                    }
<span class="fc bfc" id="L2555" title="All 2 branches covered.">                } while (pos == end);</span>
<span class="nc" id="L2556">            } catch (IOException ex) {</span>
<span class="nc" id="L2557">                pos = 0;</span>
<span class="nc" id="L2558">                end = -1;</span>
<span class="nc" id="L2559">                unread = 0;</span>
<span class="nc" id="L2560">                throw ex;</span>
<span class="fc" id="L2561">            }</span>
<span class="fc" id="L2562">        }</span>

        /**
         * If in block data mode, returns the number of unconsumed bytes
         * remaining in the current data block.  If not in block data mode,
         * throws an IllegalStateException.
         */
        int currentBlockRemaining() {
<span class="pc bpc" id="L2570" title="1 of 2 branches missed.">            if (blkmode) {</span>
<span class="fc bfc" id="L2571" title="All 2 branches covered.">                return (end &gt;= 0) ? (end - pos) + unread : 0;</span>
            } else {
<span class="nc" id="L2573">                throw new IllegalStateException();</span>
            }
        }

        /**
         * Peeks at (but does not consume) and returns the next byte value in
         * the stream, or -1 if the end of the stream/block data (if in block
         * data mode) has been reached.
         */
        int peek() throws IOException {
<span class="pc bpc" id="L2583" title="1 of 2 branches missed.">            if (blkmode) {</span>
<span class="nc bnc" id="L2584" title="All 2 branches missed.">                if (pos == end) {</span>
<span class="nc" id="L2585">                    refill();</span>
                }
<span class="nc bnc" id="L2587" title="All 2 branches missed.">                return (end &gt;= 0) ? (buf[pos] &amp; 0xFF) : -1;</span>
            } else {
<span class="fc" id="L2589">                return in.peek();</span>
            }
        }

        /**
         * Peeks at (but does not consume) and returns the next byte value in
         * the stream, or throws EOFException if end of stream/block data has
         * been reached.
         */
        byte peekByte() throws IOException {
<span class="fc" id="L2599">            int val = peek();</span>
<span class="fc bfc" id="L2600" title="All 2 branches covered.">            if (val &lt; 0) {</span>
<span class="fc" id="L2601">                throw new EOFException();</span>
            }
<span class="fc" id="L2603">            return (byte) val;</span>
        }


        /* ----------------- generic input stream methods ------------------ */
        /*
         * The following methods are equivalent to their counterparts in
         * InputStream, except that they interpret data block boundaries and
         * read the requested data from within data blocks when in block data
         * mode.
         */

        public int read() throws IOException {
<span class="fc bfc" id="L2616" title="All 2 branches covered.">            if (blkmode) {</span>
<span class="fc bfc" id="L2617" title="All 2 branches covered.">                if (pos == end) {</span>
<span class="fc" id="L2618">                    refill();</span>
                }
<span class="fc bfc" id="L2620" title="All 2 branches covered.">                return (end &gt;= 0) ? (buf[pos++] &amp; 0xFF) : -1;</span>
            } else {
<span class="fc" id="L2622">                return in.read();</span>
            }
        }

        public int read(byte[] b, int off, int len) throws IOException {
<span class="fc" id="L2627">            return read(b, off, len, false);</span>
        }

        public long skip(long len) throws IOException {
<span class="nc" id="L2631">            long remain = len;</span>
<span class="nc bnc" id="L2632" title="All 2 branches missed.">            while (remain &gt; 0) {</span>
<span class="nc bnc" id="L2633" title="All 2 branches missed.">                if (blkmode) {</span>
<span class="nc bnc" id="L2634" title="All 2 branches missed.">                    if (pos == end) {</span>
<span class="nc" id="L2635">                        refill();</span>
                    }
<span class="nc bnc" id="L2637" title="All 2 branches missed.">                    if (end &lt; 0) {</span>
<span class="nc" id="L2638">                        break;</span>
                    }
<span class="nc" id="L2640">                    int nread = (int) Math.min(remain, end - pos);</span>
<span class="nc" id="L2641">                    remain -= nread;</span>
<span class="nc" id="L2642">                    pos += nread;</span>
<span class="nc" id="L2643">                } else {</span>
<span class="nc" id="L2644">                    int nread = (int) Math.min(remain, MAX_BLOCK_SIZE);</span>
<span class="nc bnc" id="L2645" title="All 2 branches missed.">                    if ((nread = in.read(buf, 0, nread)) &lt; 0) {</span>
<span class="nc" id="L2646">                        break;</span>
                    }
<span class="nc" id="L2648">                    remain -= nread;</span>
<span class="nc" id="L2649">                }</span>
            }
<span class="nc" id="L2651">            return len - remain;</span>
        }

        public int available() throws IOException {
<span class="pc bpc" id="L2655" title="1 of 2 branches missed.">            if (blkmode) {</span>
<span class="pc bpc" id="L2656" title="2 of 4 branches missed.">                if ((pos == end) &amp;&amp; (unread == 0)) {</span>
                    int n;
<span class="pc bpc" id="L2658" title="1 of 2 branches missed.">                    while ((n = readBlockHeader(false)) == 0) ;</span>
<span class="pc bpc" id="L2659" title="1 of 3 branches missed.">                    switch (n) {</span>
                        case HEADER_BLOCKED:
<span class="fc" id="L2661">                            break;</span>

                        case -1:
<span class="nc" id="L2664">                            pos = 0;</span>
<span class="nc" id="L2665">                            end = -1;</span>
<span class="nc" id="L2666">                            break;</span>

                        default:
<span class="fc" id="L2669">                            pos = 0;</span>
<span class="fc" id="L2670">                            end = 0;</span>
<span class="fc" id="L2671">                            unread = n;</span>
                            break;
                    }
                }
                // avoid unnecessary call to in.available() if possible
<span class="fc bfc" id="L2676" title="All 2 branches covered.">                int unreadAvail = (unread &gt; 0) ?</span>
<span class="fc" id="L2677">                    Math.min(in.available(), unread) : 0;</span>
<span class="pc bpc" id="L2678" title="1 of 2 branches missed.">                return (end &gt;= 0) ? (end - pos) + unreadAvail : 0;</span>
            } else {
<span class="nc" id="L2680">                return in.available();</span>
            }
        }

        public void close() throws IOException {
<span class="fc bfc" id="L2685" title="All 2 branches covered.">            if (blkmode) {</span>
<span class="fc" id="L2686">                pos = 0;</span>
<span class="fc" id="L2687">                end = -1;</span>
<span class="fc" id="L2688">                unread = 0;</span>
            }
<span class="fc" id="L2690">            in.close();</span>
<span class="fc" id="L2691">        }</span>

        /**
         * Attempts to read len bytes into byte array b at offset off.  Returns
         * the number of bytes read, or -1 if the end of stream/block data has
         * been reached.  If copy is true, reads values into an intermediate
         * buffer before copying them to b (to avoid exposing a reference to
         * b).
         */
        int read(byte[] b, int off, int len, boolean copy) throws IOException {
<span class="pc bpc" id="L2701" title="1 of 2 branches missed.">            if (len == 0) {</span>
<span class="nc" id="L2702">                return 0;</span>
<span class="fc bfc" id="L2703" title="All 2 branches covered.">            } else if (blkmode) {</span>
<span class="fc bfc" id="L2704" title="All 2 branches covered.">                if (pos == end) {</span>
<span class="fc" id="L2705">                    refill();</span>
                }
<span class="pc bpc" id="L2707" title="1 of 2 branches missed.">                if (end &lt; 0) {</span>
<span class="nc" id="L2708">                    return -1;</span>
                }
<span class="fc" id="L2710">                int nread = Math.min(len, end - pos);</span>
<span class="fc" id="L2711">                System.arraycopy(buf, pos, b, off, nread);</span>
<span class="fc" id="L2712">                pos += nread;</span>
<span class="fc" id="L2713">                return nread;</span>
<span class="fc bfc" id="L2714" title="All 2 branches covered.">            } else if (copy) {</span>
<span class="fc" id="L2715">                int nread = in.read(buf, 0, Math.min(len, MAX_BLOCK_SIZE));</span>
<span class="pc bpc" id="L2716" title="1 of 2 branches missed.">                if (nread &gt; 0) {</span>
<span class="fc" id="L2717">                    System.arraycopy(buf, 0, b, off, nread);</span>
                }
<span class="fc" id="L2719">                return nread;</span>
            } else {
<span class="fc" id="L2721">                return in.read(b, off, len);</span>
            }
        }

        /* ----------------- primitive data input methods ------------------ */
        /*
         * The following methods are equivalent to their counterparts in
         * DataInputStream, except that they interpret data block boundaries
         * and read the requested data from within data blocks when in block
         * data mode.
         */

        public void readFully(byte[] b) throws IOException {
<span class="nc" id="L2734">            readFully(b, 0, b.length, false);</span>
<span class="nc" id="L2735">        }</span>

        public void readFully(byte[] b, int off, int len) throws IOException {
<span class="nc" id="L2738">            readFully(b, off, len, false);</span>
<span class="nc" id="L2739">        }</span>

        public void readFully(byte[] b, int off, int len, boolean copy)
            throws IOException
        {
<span class="fc bfc" id="L2744" title="All 2 branches covered.">            while (len &gt; 0) {</span>
<span class="fc" id="L2745">                int n = read(b, off, len, copy);</span>
<span class="pc bpc" id="L2746" title="1 of 2 branches missed.">                if (n &lt; 0) {</span>
<span class="nc" id="L2747">                    throw new EOFException();</span>
                }
<span class="fc" id="L2749">                off += n;</span>
<span class="fc" id="L2750">                len -= n;</span>
<span class="fc" id="L2751">            }</span>
<span class="fc" id="L2752">        }</span>

        public int skipBytes(int n) throws IOException {
<span class="nc" id="L2755">            return din.skipBytes(n);</span>
        }

        public boolean readBoolean() throws IOException {
<span class="fc" id="L2759">            int v = read();</span>
<span class="pc bpc" id="L2760" title="1 of 2 branches missed.">            if (v &lt; 0) {</span>
<span class="nc" id="L2761">                throw new EOFException();</span>
            }
<span class="fc bfc" id="L2763" title="All 2 branches covered.">            return (v != 0);</span>
        }

        public byte readByte() throws IOException {
<span class="fc" id="L2767">            int v = read();</span>
<span class="pc bpc" id="L2768" title="1 of 2 branches missed.">            if (v &lt; 0) {</span>
<span class="nc" id="L2769">                throw new EOFException();</span>
            }
<span class="fc" id="L2771">            return (byte) v;</span>
        }

        public int readUnsignedByte() throws IOException {
<span class="nc" id="L2775">            int v = read();</span>
<span class="nc bnc" id="L2776" title="All 2 branches missed.">            if (v &lt; 0) {</span>
<span class="nc" id="L2777">                throw new EOFException();</span>
            }
<span class="nc" id="L2779">            return v;</span>
        }

        public char readChar() throws IOException {
<span class="pc bpc" id="L2783" title="1 of 2 branches missed.">            if (!blkmode) {</span>
<span class="nc" id="L2784">                pos = 0;</span>
<span class="nc" id="L2785">                in.readFully(buf, 0, 2);</span>
<span class="fc bfc" id="L2786" title="All 2 branches covered.">            } else if (end - pos &lt; 2) {</span>
<span class="fc" id="L2787">                return din.readChar();</span>
            }
<span class="fc" id="L2789">            char v = Bits.getChar(buf, pos);</span>
<span class="fc" id="L2790">            pos += 2;</span>
<span class="fc" id="L2791">            return v;</span>
        }

        public short readShort() throws IOException {
<span class="fc bfc" id="L2795" title="All 2 branches covered.">            if (!blkmode) {</span>
<span class="fc" id="L2796">                pos = 0;</span>
<span class="fc" id="L2797">                in.readFully(buf, 0, 2);</span>
<span class="fc bfc" id="L2798" title="All 2 branches covered.">            } else if (end - pos &lt; 2) {</span>
<span class="fc" id="L2799">                return din.readShort();</span>
            }
<span class="fc" id="L2801">            short v = Bits.getShort(buf, pos);</span>
<span class="fc" id="L2802">            pos += 2;</span>
<span class="fc" id="L2803">            return v;</span>
        }

        public int readUnsignedShort() throws IOException {
<span class="fc bfc" id="L2807" title="All 2 branches covered.">            if (!blkmode) {</span>
<span class="fc" id="L2808">                pos = 0;</span>
<span class="fc" id="L2809">                in.readFully(buf, 0, 2);</span>
<span class="fc bfc" id="L2810" title="All 2 branches covered.">            } else if (end - pos &lt; 2) {</span>
<span class="fc" id="L2811">                return din.readUnsignedShort();</span>
            }
<span class="fc" id="L2813">            int v = Bits.getShort(buf, pos) &amp; 0xFFFF;</span>
<span class="fc" id="L2814">            pos += 2;</span>
<span class="fc" id="L2815">            return v;</span>
        }

        public int readInt() throws IOException {
<span class="fc bfc" id="L2819" title="All 2 branches covered.">            if (!blkmode) {</span>
<span class="fc" id="L2820">                pos = 0;</span>
<span class="fc" id="L2821">                in.readFully(buf, 0, 4);</span>
<span class="fc bfc" id="L2822" title="All 2 branches covered.">            } else if (end - pos &lt; 4) {</span>
<span class="fc" id="L2823">                return din.readInt();</span>
            }
<span class="fc" id="L2825">            int v = Bits.getInt(buf, pos);</span>
<span class="fc" id="L2826">            pos += 4;</span>
<span class="fc" id="L2827">            return v;</span>
        }

        public float readFloat() throws IOException {
<span class="pc bpc" id="L2831" title="1 of 2 branches missed.">            if (!blkmode) {</span>
<span class="nc" id="L2832">                pos = 0;</span>
<span class="nc" id="L2833">                in.readFully(buf, 0, 4);</span>
<span class="fc bfc" id="L2834" title="All 2 branches covered.">            } else if (end - pos &lt; 4) {</span>
<span class="fc" id="L2835">                return din.readFloat();</span>
            }
<span class="fc" id="L2837">            float v = Bits.getFloat(buf, pos);</span>
<span class="fc" id="L2838">            pos += 4;</span>
<span class="fc" id="L2839">            return v;</span>
        }

        public long readLong() throws IOException {
<span class="fc bfc" id="L2843" title="All 2 branches covered.">            if (!blkmode) {</span>
<span class="fc" id="L2844">                pos = 0;</span>
<span class="fc" id="L2845">                in.readFully(buf, 0, 8);</span>
<span class="fc bfc" id="L2846" title="All 2 branches covered.">            } else if (end - pos &lt; 8) {</span>
<span class="fc" id="L2847">                return din.readLong();</span>
            }
<span class="fc" id="L2849">            long v = Bits.getLong(buf, pos);</span>
<span class="fc" id="L2850">            pos += 8;</span>
<span class="fc" id="L2851">            return v;</span>
        }

        public double readDouble() throws IOException {
<span class="pc bpc" id="L2855" title="1 of 2 branches missed.">            if (!blkmode) {</span>
<span class="nc" id="L2856">                pos = 0;</span>
<span class="nc" id="L2857">                in.readFully(buf, 0, 8);</span>
<span class="fc bfc" id="L2858" title="All 2 branches covered.">            } else if (end - pos &lt; 8) {</span>
<span class="fc" id="L2859">                return din.readDouble();</span>
            }
<span class="fc" id="L2861">            double v = Bits.getDouble(buf, pos);</span>
<span class="fc" id="L2862">            pos += 8;</span>
<span class="fc" id="L2863">            return v;</span>
        }

        public String readUTF() throws IOException {
<span class="fc" id="L2867">            return readUTFBody(readUnsignedShort());</span>
        }

        @SuppressWarnings(&quot;deprecation&quot;)
        public String readLine() throws IOException {
<span class="nc" id="L2872">            return din.readLine();      // deprecated, not worth optimizing</span>
        }

        /* -------------- primitive data array input methods --------------- */
        /*
         * The following methods read in spans of primitive data values.
         * Though equivalent to calling the corresponding primitive read
         * methods repeatedly, these methods are optimized for reading groups
         * of primitive data values more efficiently.
         */

        void readBooleans(boolean[] v, int off, int len) throws IOException {
<span class="fc" id="L2884">            int stop, endoff = off + len;</span>
<span class="fc bfc" id="L2885" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="pc bpc" id="L2886" title="1 of 2 branches missed.">                if (!blkmode) {</span>
<span class="fc" id="L2887">                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE);</span>
<span class="fc" id="L2888">                    in.readFully(buf, 0, span);</span>
<span class="fc" id="L2889">                    stop = off + span;</span>
<span class="fc" id="L2890">                    pos = 0;</span>
<span class="pc bnc" id="L2891" title="All 2 branches missed.">                } else if (end - pos &lt; 1) {</span>
<span class="nc" id="L2892">                    v[off++] = din.readBoolean();</span>
<span class="nc" id="L2893">                    continue;</span>
                } else {
<span class="nc" id="L2895">                    stop = Math.min(endoff, off + end - pos);</span>
                }

<span class="fc bfc" id="L2898" title="All 2 branches covered.">                while (off &lt; stop) {</span>
<span class="fc" id="L2899">                    v[off++] = Bits.getBoolean(buf, pos++);</span>
                }
            }
<span class="fc" id="L2902">        }</span>

        void readChars(char[] v, int off, int len) throws IOException {
<span class="fc" id="L2905">            int stop, endoff = off + len;</span>
<span class="fc bfc" id="L2906" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="pc bpc" id="L2907" title="1 of 2 branches missed.">                if (!blkmode) {</span>
<span class="fc" id="L2908">                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);</span>
<span class="fc" id="L2909">                    in.readFully(buf, 0, span &lt;&lt; 1);</span>
<span class="fc" id="L2910">                    stop = off + span;</span>
<span class="fc" id="L2911">                    pos = 0;</span>
<span class="pc bnc" id="L2912" title="All 2 branches missed.">                } else if (end - pos &lt; 2) {</span>
<span class="nc" id="L2913">                    v[off++] = din.readChar();</span>
<span class="nc" id="L2914">                    continue;</span>
                } else {
<span class="nc" id="L2916">                    stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));</span>
                }

<span class="fc bfc" id="L2919" title="All 2 branches covered.">                while (off &lt; stop) {</span>
<span class="fc" id="L2920">                    v[off++] = Bits.getChar(buf, pos);</span>
<span class="fc" id="L2921">                    pos += 2;</span>
                }
            }
<span class="fc" id="L2924">        }</span>

        void readShorts(short[] v, int off, int len) throws IOException {
<span class="fc" id="L2927">            int stop, endoff = off + len;</span>
<span class="fc bfc" id="L2928" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="pc bpc" id="L2929" title="1 of 2 branches missed.">                if (!blkmode) {</span>
<span class="fc" id="L2930">                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);</span>
<span class="fc" id="L2931">                    in.readFully(buf, 0, span &lt;&lt; 1);</span>
<span class="fc" id="L2932">                    stop = off + span;</span>
<span class="fc" id="L2933">                    pos = 0;</span>
<span class="pc bnc" id="L2934" title="All 2 branches missed.">                } else if (end - pos &lt; 2) {</span>
<span class="nc" id="L2935">                    v[off++] = din.readShort();</span>
<span class="nc" id="L2936">                    continue;</span>
                } else {
<span class="nc" id="L2938">                    stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));</span>
                }

<span class="fc bfc" id="L2941" title="All 2 branches covered.">                while (off &lt; stop) {</span>
<span class="fc" id="L2942">                    v[off++] = Bits.getShort(buf, pos);</span>
<span class="fc" id="L2943">                    pos += 2;</span>
                }
            }
<span class="fc" id="L2946">        }</span>

        void readInts(int[] v, int off, int len) throws IOException {
<span class="fc" id="L2949">            int stop, endoff = off + len;</span>
<span class="fc bfc" id="L2950" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="pc bpc" id="L2951" title="1 of 2 branches missed.">                if (!blkmode) {</span>
<span class="fc" id="L2952">                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);</span>
<span class="fc" id="L2953">                    in.readFully(buf, 0, span &lt;&lt; 2);</span>
<span class="fc" id="L2954">                    stop = off + span;</span>
<span class="fc" id="L2955">                    pos = 0;</span>
<span class="pc bnc" id="L2956" title="All 2 branches missed.">                } else if (end - pos &lt; 4) {</span>
<span class="nc" id="L2957">                    v[off++] = din.readInt();</span>
<span class="nc" id="L2958">                    continue;</span>
                } else {
<span class="nc" id="L2960">                    stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 2));</span>
                }

<span class="fc bfc" id="L2963" title="All 2 branches covered.">                while (off &lt; stop) {</span>
<span class="fc" id="L2964">                    v[off++] = Bits.getInt(buf, pos);</span>
<span class="fc" id="L2965">                    pos += 4;</span>
                }
            }
<span class="fc" id="L2968">        }</span>

        void readFloats(float[] v, int off, int len) throws IOException {
<span class="fc" id="L2971">            int span, endoff = off + len;</span>
<span class="fc bfc" id="L2972" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="pc bpc" id="L2973" title="1 of 2 branches missed.">                if (!blkmode) {</span>
<span class="fc" id="L2974">                    span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);</span>
<span class="fc" id="L2975">                    in.readFully(buf, 0, span &lt;&lt; 2);</span>
<span class="fc" id="L2976">                    pos = 0;</span>
<span class="nc bnc" id="L2977" title="All 2 branches missed.">                } else if (end - pos &lt; 4) {</span>
<span class="nc" id="L2978">                    v[off++] = din.readFloat();</span>
<span class="nc" id="L2979">                    continue;</span>
                } else {
<span class="nc" id="L2981">                    span = Math.min(endoff - off, ((end - pos) &gt;&gt; 2));</span>
                }

<span class="fc" id="L2984">                bytesToFloats(buf, pos, v, off, span);</span>
<span class="fc" id="L2985">                off += span;</span>
<span class="fc" id="L2986">                pos += span &lt;&lt; 2;</span>
            }
<span class="fc" id="L2988">        }</span>

        void readLongs(long[] v, int off, int len) throws IOException {
<span class="fc" id="L2991">            int stop, endoff = off + len;</span>
<span class="fc bfc" id="L2992" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="pc bpc" id="L2993" title="1 of 2 branches missed.">                if (!blkmode) {</span>
<span class="fc" id="L2994">                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);</span>
<span class="fc" id="L2995">                    in.readFully(buf, 0, span &lt;&lt; 3);</span>
<span class="fc" id="L2996">                    stop = off + span;</span>
<span class="fc" id="L2997">                    pos = 0;</span>
<span class="pc bnc" id="L2998" title="All 2 branches missed.">                } else if (end - pos &lt; 8) {</span>
<span class="nc" id="L2999">                    v[off++] = din.readLong();</span>
<span class="nc" id="L3000">                    continue;</span>
                } else {
<span class="nc" id="L3002">                    stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 3));</span>
                }

<span class="fc bfc" id="L3005" title="All 2 branches covered.">                while (off &lt; stop) {</span>
<span class="fc" id="L3006">                    v[off++] = Bits.getLong(buf, pos);</span>
<span class="fc" id="L3007">                    pos += 8;</span>
                }
            }
<span class="fc" id="L3010">        }</span>

        void readDoubles(double[] v, int off, int len) throws IOException {
<span class="fc" id="L3013">            int span, endoff = off + len;</span>
<span class="fc bfc" id="L3014" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="pc bpc" id="L3015" title="1 of 2 branches missed.">                if (!blkmode) {</span>
<span class="fc" id="L3016">                    span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);</span>
<span class="fc" id="L3017">                    in.readFully(buf, 0, span &lt;&lt; 3);</span>
<span class="fc" id="L3018">                    pos = 0;</span>
<span class="nc bnc" id="L3019" title="All 2 branches missed.">                } else if (end - pos &lt; 8) {</span>
<span class="nc" id="L3020">                    v[off++] = din.readDouble();</span>
<span class="nc" id="L3021">                    continue;</span>
                } else {
<span class="nc" id="L3023">                    span = Math.min(endoff - off, ((end - pos) &gt;&gt; 3));</span>
                }

<span class="fc" id="L3026">                bytesToDoubles(buf, pos, v, off, span);</span>
<span class="fc" id="L3027">                off += span;</span>
<span class="fc" id="L3028">                pos += span &lt;&lt; 3;</span>
            }
<span class="fc" id="L3030">        }</span>

        /**
         * Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
         * identical to standard UTF, except that it uses an 8 byte header
         * (instead of the standard 2 bytes) to convey the UTF encoding length.
         */
        String readLongUTF() throws IOException {
<span class="nc" id="L3038">            return readUTFBody(readLong());</span>
        }

        /**
         * Reads in the &quot;body&quot; (i.e., the UTF representation minus the 2-byte
         * or 8-byte length header) of a UTF encoding, which occupies the next
         * utflen bytes.
         */
        private String readUTFBody(long utflen) throws IOException {
<span class="fc" id="L3047">            StringBuilder sbuf = new StringBuilder();</span>
<span class="fc bfc" id="L3048" title="All 2 branches covered.">            if (!blkmode) {</span>
<span class="fc" id="L3049">                end = pos = 0;</span>
            }

<span class="fc bfc" id="L3052" title="All 2 branches covered.">            while (utflen &gt; 0) {</span>
<span class="fc" id="L3053">                int avail = end - pos;</span>
<span class="fc bfc" id="L3054" title="All 4 branches covered.">                if (avail &gt;= 3 || (long) avail == utflen) {</span>
<span class="fc" id="L3055">                    utflen -= readUTFSpan(sbuf, utflen);</span>
                } else {
<span class="pc bpc" id="L3057" title="1 of 2 branches missed.">                    if (blkmode) {</span>
                        // near block boundary, read one byte at a time
<span class="nc" id="L3059">                        utflen -= readUTFChar(sbuf, utflen);</span>
                    } else {
                        // shift and refill buffer manually
<span class="pc bpc" id="L3062" title="1 of 2 branches missed.">                        if (avail &gt; 0) {</span>
<span class="nc" id="L3063">                            System.arraycopy(buf, pos, buf, 0, avail);</span>
                        }
<span class="fc" id="L3065">                        pos = 0;</span>
<span class="fc" id="L3066">                        end = (int) Math.min(MAX_BLOCK_SIZE, utflen);</span>
<span class="fc" id="L3067">                        in.readFully(buf, avail, end - avail);</span>
                    }
                }
<span class="fc" id="L3070">            }</span>

<span class="fc" id="L3072">            return sbuf.toString();</span>
        }

        /**
         * Reads span of UTF-encoded characters out of internal buffer
         * (starting at offset pos and ending at or before offset end),
         * consuming no more than utflen bytes.  Appends read characters to
         * sbuf.  Returns the number of bytes consumed.
         */
        private long readUTFSpan(StringBuilder sbuf, long utflen)
            throws IOException
        {
<span class="fc" id="L3084">            int cpos = 0;</span>
<span class="fc" id="L3085">            int start = pos;</span>
<span class="fc" id="L3086">            int avail = Math.min(end - pos, CHAR_BUF_SIZE);</span>
            // stop short of last char unless all of utf bytes in buffer
<span class="fc bfc" id="L3088" title="All 2 branches covered.">            int stop = pos + ((utflen &gt; avail) ? avail - 2 : (int) utflen);</span>
<span class="fc" id="L3089">            boolean outOfBounds = false;</span>

            try {
<span class="fc bfc" id="L3092" title="All 2 branches covered.">                while (pos &lt; stop) {</span>
                    int b1, b2, b3;
<span class="fc" id="L3094">                    b1 = buf[pos++] &amp; 0xFF;</span>
<span class="pc bpc" id="L3095" title="1 of 4 branches missed.">                    switch (b1 &gt;&gt; 4) {</span>
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:   // 1 byte format: 0xxxxxxx
<span class="fc" id="L3104">                            cbuf[cpos++] = (char) b1;</span>
<span class="fc" id="L3105">                            break;</span>

                        case 12:
                        case 13:  // 2 byte format: 110xxxxx 10xxxxxx
<span class="fc" id="L3109">                            b2 = buf[pos++];</span>
<span class="pc bpc" id="L3110" title="1 of 2 branches missed.">                            if ((b2 &amp; 0xC0) != 0x80) {</span>
<span class="nc" id="L3111">                                throw new UTFDataFormatException();</span>
                            }
<span class="fc" id="L3113">                            cbuf[cpos++] = (char) (((b1 &amp; 0x1F) &lt;&lt; 6) |</span>
                                                   ((b2 &amp; 0x3F) &lt;&lt; 0));
<span class="fc" id="L3115">                            break;</span>

                        case 14:  // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
<span class="fc" id="L3118">                            b3 = buf[pos + 1];</span>
<span class="fc" id="L3119">                            b2 = buf[pos + 0];</span>
<span class="fc" id="L3120">                            pos += 2;</span>
<span class="pc bpc" id="L3121" title="2 of 4 branches missed.">                            if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {</span>
<span class="nc" id="L3122">                                throw new UTFDataFormatException();</span>
                            }
<span class="fc" id="L3124">                            cbuf[cpos++] = (char) (((b1 &amp; 0x0F) &lt;&lt; 12) |</span>
                                                   ((b2 &amp; 0x3F) &lt;&lt; 6) |
                                                   ((b3 &amp; 0x3F) &lt;&lt; 0));
<span class="fc" id="L3127">                            break;</span>

                        default:  // 10xx xxxx, 1111 xxxx
<span class="nc" id="L3130">                            throw new UTFDataFormatException();</span>
                    }
<span class="fc" id="L3132">                }</span>
<span class="nc" id="L3133">            } catch (ArrayIndexOutOfBoundsException ex) {</span>
<span class="nc" id="L3134">                outOfBounds = true;</span>
            } finally {
<span class="pc bpc" id="L3136" title="10 of 12 branches missed.">                if (outOfBounds || (pos - start) &gt; utflen) {</span>
                    /*
                     * Fix for 4450867: if a malformed utf char causes the
                     * conversion loop to scan past the expected end of the utf
                     * string, only consume the expected number of utf bytes.
                     */
<span class="nc" id="L3142">                    pos = start + (int) utflen;</span>
<span class="nc" id="L3143">                    throw new UTFDataFormatException();</span>
                }
            }

<span class="fc" id="L3147">            sbuf.append(cbuf, 0, cpos);</span>
<span class="fc" id="L3148">            return pos - start;</span>
        }

        /**
         * Reads in single UTF-encoded character one byte at a time, appends
         * the character to sbuf, and returns the number of bytes consumed.
         * This method is used when reading in UTF strings written in block
         * data mode to handle UTF-encoded characters which (potentially)
         * straddle block-data boundaries.
         */
        private int readUTFChar(StringBuilder sbuf, long utflen)
            throws IOException
        {
            int b1, b2, b3;
<span class="nc" id="L3162">            b1 = readByte() &amp; 0xFF;</span>
<span class="nc bnc" id="L3163" title="All 4 branches missed.">            switch (b1 &gt;&gt; 4) {</span>
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:     // 1 byte format: 0xxxxxxx
<span class="nc" id="L3172">                    sbuf.append((char) b1);</span>
<span class="nc" id="L3173">                    return 1;</span>

                case 12:
                case 13:    // 2 byte format: 110xxxxx 10xxxxxx
<span class="nc bnc" id="L3177" title="All 2 branches missed.">                    if (utflen &lt; 2) {</span>
<span class="nc" id="L3178">                        throw new UTFDataFormatException();</span>
                    }
<span class="nc" id="L3180">                    b2 = readByte();</span>
<span class="nc bnc" id="L3181" title="All 2 branches missed.">                    if ((b2 &amp; 0xC0) != 0x80) {</span>
<span class="nc" id="L3182">                        throw new UTFDataFormatException();</span>
                    }
<span class="nc" id="L3184">                    sbuf.append((char) (((b1 &amp; 0x1F) &lt;&lt; 6) |</span>
                                        ((b2 &amp; 0x3F) &lt;&lt; 0)));
<span class="nc" id="L3186">                    return 2;</span>

                case 14:    // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
<span class="nc bnc" id="L3189" title="All 2 branches missed.">                    if (utflen &lt; 3) {</span>
<span class="nc bnc" id="L3190" title="All 2 branches missed.">                        if (utflen == 2) {</span>
<span class="nc" id="L3191">                            readByte();         // consume remaining byte</span>
                        }
<span class="nc" id="L3193">                        throw new UTFDataFormatException();</span>
                    }
<span class="nc" id="L3195">                    b2 = readByte();</span>
<span class="nc" id="L3196">                    b3 = readByte();</span>
<span class="nc bnc" id="L3197" title="All 4 branches missed.">                    if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {</span>
<span class="nc" id="L3198">                        throw new UTFDataFormatException();</span>
                    }
<span class="nc" id="L3200">                    sbuf.append((char) (((b1 &amp; 0x0F) &lt;&lt; 12) |</span>
                                        ((b2 &amp; 0x3F) &lt;&lt; 6) |
                                        ((b3 &amp; 0x3F) &lt;&lt; 0)));
<span class="nc" id="L3203">                    return 3;</span>

                default:   // 10xx xxxx, 1111 xxxx
<span class="nc" id="L3206">                    throw new UTFDataFormatException();</span>
            }
        }
    }

    /**
     * Unsynchronized table which tracks wire handle to object mappings, as
     * well as ClassNotFoundExceptions associated with deserialized objects.
     * This class implements an exception-propagation algorithm for
     * determining which objects should have ClassNotFoundExceptions associated
     * with them, taking into account cycles and discontinuities (e.g., skipped
     * fields) in the object graph.
     *
     * &lt;p&gt;General use of the table is as follows: during deserialization, a
     * given object is first assigned a handle by calling the assign method.
     * This method leaves the assigned handle in an &quot;open&quot; state, wherein
     * dependencies on the exception status of other handles can be registered
     * by calling the markDependency method, or an exception can be directly
     * associated with the handle by calling markException.  When a handle is
     * tagged with an exception, the HandleTable assumes responsibility for
     * propagating the exception to any other objects which depend
     * (transitively) on the exception-tagged object.
     *
     * &lt;p&gt;Once all exception information/dependencies for the handle have been
     * registered, the handle should be &quot;closed&quot; by calling the finish method
     * on it.  The act of finishing a handle allows the exception propagation
     * algorithm to aggressively prune dependency links, lessening the
     * performance/memory impact of exception tracking.
     *
     * &lt;p&gt;Note that the exception propagation algorithm used depends on handles
     * being assigned/finished in LIFO order; however, for simplicity as well
     * as memory conservation, it does not enforce this constraint.
     */
    // REMIND: add full description of exception propagation algorithm?
    private static class HandleTable {

        /* status codes indicating whether object has associated exception */
        private static final byte STATUS_OK = 1;
        private static final byte STATUS_UNKNOWN = 2;
        private static final byte STATUS_EXCEPTION = 3;

        /** array mapping handle -&gt; object status */
        byte[] status;
        /** array mapping handle -&gt; object/exception (depending on status) */
        Object[] entries;
        /** array mapping handle -&gt; list of dependent handles (if any) */
        HandleList[] deps;
        /** lowest unresolved dependency */
<span class="fc" id="L3254">        int lowDep = -1;</span>
        /** number of handles in table */
<span class="fc" id="L3256">        int size = 0;</span>

        /**
         * Creates handle table with the given initial capacity.
         */
<span class="fc" id="L3261">        HandleTable(int initialCapacity) {</span>
<span class="fc" id="L3262">            status = new byte[initialCapacity];</span>
<span class="fc" id="L3263">            entries = new Object[initialCapacity];</span>
<span class="fc" id="L3264">            deps = new HandleList[initialCapacity];</span>
<span class="fc" id="L3265">        }</span>

        /**
         * Assigns next available handle to given object, and returns assigned
         * handle.  Once object has been completely deserialized (and all
         * dependencies on other objects identified), the handle should be
         * &quot;closed&quot; by passing it to finish().
         */
        int assign(Object obj) {
<span class="fc bfc" id="L3274" title="All 2 branches covered.">            if (size &gt;= entries.length) {</span>
<span class="fc" id="L3275">                grow();</span>
            }
<span class="fc" id="L3277">            status[size] = STATUS_UNKNOWN;</span>
<span class="fc" id="L3278">            entries[size] = obj;</span>
<span class="fc" id="L3279">            return size++;</span>
        }

        /**
         * Registers a dependency (in exception status) of one handle on
         * another.  The dependent handle must be &quot;open&quot; (i.e., assigned, but
         * not finished yet).  No action is taken if either dependent or target
         * handle is NULL_HANDLE.
         */
        void markDependency(int dependent, int target) {
<span class="fc bfc" id="L3289" title="All 4 branches covered.">            if (dependent == NULL_HANDLE || target == NULL_HANDLE) {</span>
<span class="fc" id="L3290">                return;</span>
            }
<span class="pc bpc" id="L3292" title="2 of 3 branches missed.">            switch (status[dependent]) {</span>

                case STATUS_UNKNOWN:
<span class="pc bpc" id="L3295" title="1 of 4 branches missed.">                    switch (status[target]) {</span>
                        case STATUS_OK:
                            // ignore dependencies on objs with no exception
<span class="fc" id="L3298">                            break;</span>

                        case STATUS_EXCEPTION:
                            // eagerly propagate exception
<span class="fc" id="L3302">                            markException(dependent,</span>
                                (ClassNotFoundException) entries[target]);
<span class="fc" id="L3304">                            break;</span>

                        case STATUS_UNKNOWN:
                            // add to dependency list of target
<span class="fc bfc" id="L3308" title="All 2 branches covered.">                            if (deps[target] == null) {</span>
<span class="fc" id="L3309">                                deps[target] = new HandleList();</span>
                            }
<span class="fc" id="L3311">                            deps[target].add(dependent);</span>

                            // remember lowest unresolved target seen
<span class="fc bfc" id="L3314" title="All 4 branches covered.">                            if (lowDep &lt; 0 || lowDep &gt; target) {</span>
<span class="fc" id="L3315">                                lowDep = target;</span>
                            }
                            break;

                        default:
<span class="nc" id="L3320">                            throw new InternalError();</span>
                    }
                    break;

                case STATUS_EXCEPTION:
<span class="nc" id="L3325">                    break;</span>

                default:
<span class="nc" id="L3328">                    throw new InternalError();</span>
            }
<span class="fc" id="L3330">        }</span>

        /**
         * Associates a ClassNotFoundException (if one not already associated)
         * with the currently active handle and propagates it to other
         * referencing objects as appropriate.  The specified handle must be
         * &quot;open&quot; (i.e., assigned, but not finished yet).
         */
        void markException(int handle, ClassNotFoundException ex) {
<span class="pc bpc" id="L3339" title="1 of 3 branches missed.">            switch (status[handle]) {</span>
                case STATUS_UNKNOWN:
<span class="fc" id="L3341">                    status[handle] = STATUS_EXCEPTION;</span>
<span class="fc" id="L3342">                    entries[handle] = ex;</span>

                    // propagate exception to dependents
<span class="fc" id="L3345">                    HandleList dlist = deps[handle];</span>
<span class="pc bpc" id="L3346" title="1 of 2 branches missed.">                    if (dlist != null) {</span>
<span class="nc" id="L3347">                        int ndeps = dlist.size();</span>
<span class="nc bnc" id="L3348" title="All 2 branches missed.">                        for (int i = 0; i &lt; ndeps; i++) {</span>
<span class="nc" id="L3349">                            markException(dlist.get(i), ex);</span>
                        }
<span class="nc" id="L3351">                        deps[handle] = null;</span>
<span class="nc" id="L3352">                    }</span>
                    break;

                case STATUS_EXCEPTION:
<span class="fc" id="L3356">                    break;</span>

                default:
<span class="nc" id="L3359">                    throw new InternalError();</span>
            }
<span class="fc" id="L3361">        }</span>

        /**
         * Marks given handle as finished, meaning that no new dependencies
         * will be marked for handle.  Calls to the assign and finish methods
         * must occur in LIFO order.
         */
        void finish(int handle) {
            int end;
<span class="fc bfc" id="L3370" title="All 2 branches covered.">            if (lowDep &lt; 0) {</span>
                // no pending unknowns, only resolve current handle
<span class="fc" id="L3372">                end = handle + 1;</span>
<span class="fc bfc" id="L3373" title="All 2 branches covered.">            } else if (lowDep &gt;= handle) {</span>
                // pending unknowns now clearable, resolve all upward handles
<span class="fc" id="L3375">                end = size;</span>
<span class="fc" id="L3376">                lowDep = -1;</span>
            } else {
                // unresolved backrefs present, can't resolve anything yet
<span class="fc" id="L3379">                return;</span>
            }

            // change STATUS_UNKNOWN -&gt; STATUS_OK in selected span of handles
<span class="fc bfc" id="L3383" title="All 2 branches covered.">            for (int i = handle; i &lt; end; i++) {</span>
<span class="pc bpc" id="L3384" title="1 of 3 branches missed.">                switch (status[i]) {</span>
                    case STATUS_UNKNOWN:
<span class="fc" id="L3386">                        status[i] = STATUS_OK;</span>
<span class="fc" id="L3387">                        deps[i] = null;</span>
<span class="fc" id="L3388">                        break;</span>

                    case STATUS_OK:
                    case STATUS_EXCEPTION:
<span class="fc" id="L3392">                        break;</span>

                    default:
<span class="nc" id="L3395">                        throw new InternalError();</span>
                }
            }
<span class="fc" id="L3398">        }</span>

        /**
         * Assigns a new object to the given handle.  The object previously
         * associated with the handle is forgotten.  This method has no effect
         * if the given handle already has an exception associated with it.
         * This method may be called at any time after the handle is assigned.
         */
        void setObject(int handle, Object obj) {
<span class="pc bpc" id="L3407" title="2 of 3 branches missed.">            switch (status[handle]) {</span>
                case STATUS_UNKNOWN:
                case STATUS_OK:
<span class="fc" id="L3410">                    entries[handle] = obj;</span>
<span class="fc" id="L3411">                    break;</span>

                case STATUS_EXCEPTION:
<span class="nc" id="L3414">                    break;</span>

                default:
<span class="nc" id="L3417">                    throw new InternalError();</span>
            }
<span class="fc" id="L3419">        }</span>

        /**
         * Looks up and returns object associated with the given handle.
         * Returns null if the given handle is NULL_HANDLE, or if it has an
         * associated ClassNotFoundException.
         */
        Object lookupObject(int handle) {
<span class="pc bpc" id="L3427" title="1 of 4 branches missed.">            return (handle != NULL_HANDLE &amp;&amp;</span>
                    status[handle] != STATUS_EXCEPTION) ?
                entries[handle] : null;
        }

        /**
         * Looks up and returns ClassNotFoundException associated with the
         * given handle.  Returns null if the given handle is NULL_HANDLE, or
         * if there is no ClassNotFoundException associated with the handle.
         */
        ClassNotFoundException lookupException(int handle) {
<span class="fc bfc" id="L3438" title="All 4 branches covered.">            return (handle != NULL_HANDLE &amp;&amp;</span>
                    status[handle] == STATUS_EXCEPTION) ?
                (ClassNotFoundException) entries[handle] : null;
        }

        /**
         * Resets table to its initial state.
         */
        void clear() {
<span class="fc" id="L3447">            Arrays.fill(status, 0, size, (byte) 0);</span>
<span class="fc" id="L3448">            Arrays.fill(entries, 0, size, null);</span>
<span class="fc" id="L3449">            Arrays.fill(deps, 0, size, null);</span>
<span class="fc" id="L3450">            lowDep = -1;</span>
<span class="fc" id="L3451">            size = 0;</span>
<span class="fc" id="L3452">        }</span>

        /**
         * Returns number of handles registered in table.
         */
        int size() {
<span class="fc" id="L3458">            return size;</span>
        }

        /**
         * Expands capacity of internal arrays.
         */
        private void grow() {
<span class="fc" id="L3465">            int newCapacity = (entries.length &lt;&lt; 1) + 1;</span>

<span class="fc" id="L3467">            byte[] newStatus = new byte[newCapacity];</span>
<span class="fc" id="L3468">            Object[] newEntries = new Object[newCapacity];</span>
<span class="fc" id="L3469">            HandleList[] newDeps = new HandleList[newCapacity];</span>

<span class="fc" id="L3471">            System.arraycopy(status, 0, newStatus, 0, size);</span>
<span class="fc" id="L3472">            System.arraycopy(entries, 0, newEntries, 0, size);</span>
<span class="fc" id="L3473">            System.arraycopy(deps, 0, newDeps, 0, size);</span>

<span class="fc" id="L3475">            status = newStatus;</span>
<span class="fc" id="L3476">            entries = newEntries;</span>
<span class="fc" id="L3477">            deps = newDeps;</span>
<span class="fc" id="L3478">        }</span>

        /**
         * Simple growable list of (integer) handles.
         */
        private static class HandleList {
<span class="fc" id="L3484">            private int[] list = new int[4];</span>
<span class="fc" id="L3485">            private int size = 0;</span>

<span class="fc" id="L3487">            public HandleList() {</span>
<span class="fc" id="L3488">            }</span>

            public void add(int handle) {
<span class="fc bfc" id="L3491" title="All 2 branches covered.">                if (size &gt;= list.length) {</span>
<span class="fc" id="L3492">                    int[] newList = new int[list.length &lt;&lt; 1];</span>
<span class="fc" id="L3493">                    System.arraycopy(list, 0, newList, 0, list.length);</span>
<span class="fc" id="L3494">                    list = newList;</span>
                }
<span class="fc" id="L3496">                list[size++] = handle;</span>
<span class="fc" id="L3497">            }</span>

            public int get(int index) {
<span class="nc bnc" id="L3500" title="All 2 branches missed.">                if (index &gt;= size) {</span>
<span class="nc" id="L3501">                    throw new ArrayIndexOutOfBoundsException();</span>
                }
<span class="nc" id="L3503">                return list[index];</span>
            }

            public int size() {
<span class="nc" id="L3507">                return size;</span>
            }
        }
    }

    /**
     * Method for cloning arrays in case of using unsharing reading
     */
    private static Object cloneArray(Object array) {
<span class="fc bfc" id="L3516" title="All 2 branches covered.">        if (array instanceof Object[]) {</span>
<span class="fc" id="L3517">            return ((Object[]) array).clone();</span>
<span class="fc bfc" id="L3518" title="All 2 branches covered.">        } else if (array instanceof boolean[]) {</span>
<span class="fc" id="L3519">            return ((boolean[]) array).clone();</span>
<span class="fc bfc" id="L3520" title="All 2 branches covered.">        } else if (array instanceof byte[]) {</span>
<span class="fc" id="L3521">            return ((byte[]) array).clone();</span>
<span class="fc bfc" id="L3522" title="All 2 branches covered.">        } else if (array instanceof char[]) {</span>
<span class="fc" id="L3523">            return ((char[]) array).clone();</span>
<span class="fc bfc" id="L3524" title="All 2 branches covered.">        } else if (array instanceof double[]) {</span>
<span class="fc" id="L3525">            return ((double[]) array).clone();</span>
<span class="fc bfc" id="L3526" title="All 2 branches covered.">        } else if (array instanceof float[]) {</span>
<span class="fc" id="L3527">            return ((float[]) array).clone();</span>
<span class="fc bfc" id="L3528" title="All 2 branches covered.">        } else if (array instanceof int[]) {</span>
<span class="fc" id="L3529">            return ((int[]) array).clone();</span>
<span class="fc bfc" id="L3530" title="All 2 branches covered.">        } else if (array instanceof long[]) {</span>
<span class="fc" id="L3531">            return ((long[]) array).clone();</span>
<span class="pc bpc" id="L3532" title="1 of 2 branches missed.">        } else if (array instanceof short[]) {</span>
<span class="fc" id="L3533">            return ((short[]) array).clone();</span>
        } else {
<span class="nc" id="L3535">            throw new AssertionError();</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>