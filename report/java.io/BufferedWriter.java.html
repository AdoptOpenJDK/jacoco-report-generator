<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BufferedWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.io</a> &gt; <span class="el_source">BufferedWriter.java</span></div><h1>BufferedWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.io;


/**
 * Writes text to a character-output stream, buffering characters so as to
 * provide for the efficient writing of single characters, arrays, and strings.
 *
 * &lt;p&gt; The buffer size may be specified, or the default size may be accepted.
 * The default is large enough for most purposes.
 *
 * &lt;p&gt; A newLine() method is provided, which uses the platform's own notion of
 * line separator as defined by the system property &lt;tt&gt;line.separator&lt;/tt&gt;.
 * Not all platforms use the newline character ('\n') to terminate lines.
 * Calling this method to terminate each output line is therefore preferred to
 * writing a newline character directly.
 *
 * &lt;p&gt; In general, a Writer sends its output immediately to the underlying
 * character or byte stream.  Unless prompt output is required, it is advisable
 * to wrap a BufferedWriter around any Writer whose write() operations may be
 * costly, such as FileWriters and OutputStreamWriters.  For example,
 *
 * &lt;pre&gt;
 * PrintWriter out
 *   = new PrintWriter(new BufferedWriter(new FileWriter(&quot;foo.out&quot;)));
 * &lt;/pre&gt;
 *
 * will buffer the PrintWriter's output to the file.  Without buffering, each
 * invocation of a print() method would cause characters to be converted into
 * bytes that would then be written immediately to the file, which can be very
 * inefficient.
 *
 * @see PrintWriter
 * @see FileWriter
 * @see OutputStreamWriter
 * @see java.nio.file.Files#newBufferedWriter
 *
 * @author      Mark Reinhold
 * @since       JDK1.1
 */

public class BufferedWriter extends Writer {

    private Writer out;

    private char cb[];
    private int nChars, nextChar;

<span class="fc" id="L73">    private static int defaultCharBufferSize = 8192;</span>

    /**
     * Line separator string.  This is the value of the line.separator
     * property at the moment that the stream was created.
     */
    private String lineSeparator;

    /**
     * Creates a buffered character-output stream that uses a default-sized
     * output buffer.
     *
     * @param  out  A Writer
     */
    public BufferedWriter(Writer out) {
<span class="fc" id="L88">        this(out, defaultCharBufferSize);</span>
<span class="fc" id="L89">    }</span>

    /**
     * Creates a new buffered character-output stream that uses an output
     * buffer of the given size.
     *
     * @param  out  A Writer
     * @param  sz   Output-buffer size, a positive integer
     *
     * @exception  IllegalArgumentException  If {@code sz &lt;= 0}
     */
    public BufferedWriter(Writer out, int sz) {
<span class="fc" id="L101">        super(out);</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if (sz &lt;= 0)</span>
<span class="nc" id="L103">            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);</span>
<span class="fc" id="L104">        this.out = out;</span>
<span class="fc" id="L105">        cb = new char[sz];</span>
<span class="fc" id="L106">        nChars = sz;</span>
<span class="fc" id="L107">        nextChar = 0;</span>

<span class="fc" id="L109">        lineSeparator = java.security.AccessController.doPrivileged(</span>
            new sun.security.action.GetPropertyAction(&quot;line.separator&quot;));
<span class="fc" id="L111">    }</span>

    /** Checks to make sure that the stream has not been closed */
    private void ensureOpen() throws IOException {
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (out == null)</span>
<span class="fc" id="L116">            throw new IOException(&quot;Stream closed&quot;);</span>
<span class="fc" id="L117">    }</span>

    /**
     * Flushes the output buffer to the underlying character stream, without
     * flushing the stream itself.  This method is non-private only so that it
     * may be invoked by PrintStream.
     */
    void flushBuffer() throws IOException {
<span class="fc" id="L125">        synchronized (lock) {</span>
<span class="fc" id="L126">            ensureOpen();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            if (nextChar == 0)</span>
<span class="fc" id="L128">                return;</span>
<span class="fc" id="L129">            out.write(cb, 0, nextChar);</span>
<span class="fc" id="L130">            nextChar = 0;</span>
<span class="fc" id="L131">        }</span>
<span class="fc" id="L132">    }</span>

    /**
     * Writes a single character.
     *
     * @exception  IOException  If an I/O error occurs
     */
    public void write(int c) throws IOException {
<span class="fc" id="L140">        synchronized (lock) {</span>
<span class="nc" id="L141">            ensureOpen();</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (nextChar &gt;= nChars)</span>
<span class="nc" id="L143">                flushBuffer();</span>
<span class="nc" id="L144">            cb[nextChar++] = (char) c;</span>
<span class="pc" id="L145">        }</span>
<span class="nc" id="L146">    }</span>

    /**
     * Our own little min method, to avoid loading java.lang.Math if we've run
     * out of file descriptors and we're trying to print a stack trace.
     */
    private int min(int a, int b) {
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (a &lt; b) return a;</span>
<span class="fc" id="L154">        return b;</span>
    }

    /**
     * Writes a portion of an array of characters.
     *
     * &lt;p&gt; Ordinarily this method stores characters from the given array into
     * this stream's buffer, flushing the buffer to the underlying stream as
     * needed.  If the requested length is at least as large as the buffer,
     * however, then this method will flush the buffer and write the characters
     * directly to the underlying stream.  Thus redundant
     * &lt;code&gt;BufferedWriter&lt;/code&gt;s will not copy data unnecessarily.
     *
     * @param  cbuf  A character array
     * @param  off   Offset from which to start reading characters
     * @param  len   Number of characters to write
     *
     * @exception  IOException  If an I/O error occurs
     */
    public void write(char cbuf[], int off, int len) throws IOException {
<span class="fc" id="L174">        synchronized (lock) {</span>
<span class="fc" id="L175">            ensureOpen();</span>
<span class="pc bpc" id="L176" title="5 of 10 branches missed.">            if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) ||</span>
                ((off + len) &gt; cbuf.length) || ((off + len) &lt; 0)) {
<span class="nc" id="L178">                throw new IndexOutOfBoundsException();</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">            } else if (len == 0) {</span>
<span class="nc" id="L180">                return;</span>
            }

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">            if (len &gt;= nChars) {</span>
                /* If the request length exceeds the size of the output buffer,
                   flush the buffer and then write the data directly.  In this
                   way buffered streams will cascade harmlessly. */
<span class="nc" id="L187">                flushBuffer();</span>
<span class="nc" id="L188">                out.write(cbuf, off, len);</span>
<span class="nc" id="L189">                return;</span>
            }

<span class="fc" id="L192">            int b = off, t = off + len;</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">            while (b &lt; t) {</span>
<span class="fc" id="L194">                int d = min(nChars - nextChar, t - b);</span>
<span class="fc" id="L195">                System.arraycopy(cbuf, b, cb, nextChar, d);</span>
<span class="fc" id="L196">                b += d;</span>
<span class="fc" id="L197">                nextChar += d;</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">                if (nextChar &gt;= nChars)</span>
<span class="nc" id="L199">                    flushBuffer();</span>
<span class="fc" id="L200">            }</span>
<span class="pc" id="L201">        }</span>
<span class="fc" id="L202">    }</span>

    /**
     * Writes a portion of a String.
     *
     * &lt;p&gt; If the value of the &lt;tt&gt;len&lt;/tt&gt; parameter is negative then no
     * characters are written.  This is contrary to the specification of this
     * method in the {@linkplain java.io.Writer#write(java.lang.String,int,int)
     * superclass}, which requires that an {@link IndexOutOfBoundsException} be
     * thrown.
     *
     * @param  s     String to be written
     * @param  off   Offset from which to start reading characters
     * @param  len   Number of characters to be written
     *
     * @exception  IOException  If an I/O error occurs
     */
    public void write(String s, int off, int len) throws IOException {
<span class="fc" id="L220">        synchronized (lock) {</span>
<span class="fc" id="L221">            ensureOpen();</span>

<span class="fc" id="L223">            int b = off, t = off + len;</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">            while (b &lt; t) {</span>
<span class="fc" id="L225">                int d = min(nChars - nextChar, t - b);</span>
<span class="fc" id="L226">                s.getChars(b, b + d, cb, nextChar);</span>
<span class="fc" id="L227">                b += d;</span>
<span class="fc" id="L228">                nextChar += d;</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">                if (nextChar &gt;= nChars)</span>
<span class="fc" id="L230">                    flushBuffer();</span>
<span class="fc" id="L231">            }</span>
<span class="pc" id="L232">        }</span>
<span class="fc" id="L233">    }</span>

    /**
     * Writes a line separator.  The line separator string is defined by the
     * system property &lt;tt&gt;line.separator&lt;/tt&gt;, and is not necessarily a single
     * newline ('\n') character.
     *
     * @exception  IOException  If an I/O error occurs
     */
    public void newLine() throws IOException {
<span class="fc" id="L243">        write(lineSeparator);</span>
<span class="fc" id="L244">    }</span>

    /**
     * Flushes the stream.
     *
     * @exception  IOException  If an I/O error occurs
     */
    public void flush() throws IOException {
<span class="fc" id="L252">        synchronized (lock) {</span>
<span class="fc" id="L253">            flushBuffer();</span>
<span class="fc" id="L254">            out.flush();</span>
<span class="pc" id="L255">        }</span>
<span class="fc" id="L256">    }</span>

    @SuppressWarnings(&quot;try&quot;)
    public void close() throws IOException {
<span class="fc" id="L260">        synchronized (lock) {</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">            if (out == null) {</span>
<span class="nc" id="L262">                return;</span>
            }
<span class="fc" id="L264">            try (Writer w = out) {</span>
<span class="fc" id="L265">                flushBuffer();</span>
<span class="pc bpc" id="L266" title="4 of 8 branches missed.">            } finally {</span>
<span class="fc" id="L267">                out = null;</span>
<span class="fc" id="L268">                cb = null;</span>
<span class="fc" id="L269">            }</span>
<span class="fc" id="L270">        }</span>
<span class="fc" id="L271">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>