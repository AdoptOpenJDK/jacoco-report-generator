<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PrintStream.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.io</a> &gt; <span class="el_source">PrintStream.java</span></div><h1>PrintStream.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.io;

import java.util.Formatter;
import java.util.Locale;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;
import java.nio.charset.UnsupportedCharsetException;

/**
 * A &lt;code&gt;PrintStream&lt;/code&gt; adds functionality to another output stream,
 * namely the ability to print representations of various data values
 * conveniently.  Two other features are provided as well.  Unlike other output
 * streams, a &lt;code&gt;PrintStream&lt;/code&gt; never throws an
 * &lt;code&gt;IOException&lt;/code&gt;; instead, exceptional situations merely set an
 * internal flag that can be tested via the &lt;code&gt;checkError&lt;/code&gt; method.
 * Optionally, a &lt;code&gt;PrintStream&lt;/code&gt; can be created so as to flush
 * automatically; this means that the &lt;code&gt;flush&lt;/code&gt; method is
 * automatically invoked after a byte array is written, one of the
 * &lt;code&gt;println&lt;/code&gt; methods is invoked, or a newline character or byte
 * (&lt;code&gt;'\n'&lt;/code&gt;) is written.
 *
 * &lt;p&gt; All characters printed by a &lt;code&gt;PrintStream&lt;/code&gt; are converted into
 * bytes using the platform's default character encoding.  The &lt;code&gt;{@link
 * PrintWriter}&lt;/code&gt; class should be used in situations that require writing
 * characters rather than bytes.
 *
 * @author     Frank Yellin
 * @author     Mark Reinhold
 * @since      JDK1.0
 */

public class PrintStream extends FilterOutputStream
    implements Appendable, Closeable
{

    private final boolean autoFlush;
<span class="fc" id="L62">    private boolean trouble = false;</span>
    private Formatter formatter;

    /**
     * Track both the text- and character-output streams, so that their buffers
     * can be flushed without flushing the entire stream.
     */
    private BufferedWriter textOut;
    private OutputStreamWriter charOut;

    /**
     * requireNonNull is explicitly declared here so as not to create an extra
     * dependency on java.util.Objects.requireNonNull. PrintStream is loaded
     * early during system initialization.
     */
    private static &lt;T&gt; T requireNonNull(T obj, String message) {
<span class="fc bfc" id="L78" title="All 2 branches covered.">        if (obj == null)</span>
<span class="fc" id="L79">            throw new NullPointerException(message);</span>
<span class="fc" id="L80">        return obj;</span>
    }

    /**
     * Returns a charset object for the given charset name.
     * @throws NullPointerException          is csn is null
     * @throws UnsupportedEncodingException  if the charset is not supported
     */
    private static Charset toCharset(String csn)
        throws UnsupportedEncodingException
    {
<span class="fc" id="L91">        requireNonNull(csn, &quot;charsetName&quot;);</span>
        try {
<span class="fc" id="L93">            return Charset.forName(csn);</span>
<span class="nc" id="L94">        } catch (IllegalCharsetNameException|UnsupportedCharsetException unused) {</span>
            // UnsupportedEncodingException should be thrown
<span class="nc" id="L96">            throw new UnsupportedEncodingException(csn);</span>
        }
    }

    /* Private constructors */
    private PrintStream(boolean autoFlush, OutputStream out) {
<span class="fc" id="L102">        super(out);</span>
<span class="fc" id="L103">        this.autoFlush = autoFlush;</span>
<span class="fc" id="L104">        this.charOut = new OutputStreamWriter(this);</span>
<span class="fc" id="L105">        this.textOut = new BufferedWriter(charOut);</span>
<span class="fc" id="L106">    }</span>

    private PrintStream(boolean autoFlush, OutputStream out, Charset charset) {
<span class="fc" id="L109">        super(out);</span>
<span class="fc" id="L110">        this.autoFlush = autoFlush;</span>
<span class="fc" id="L111">        this.charOut = new OutputStreamWriter(this, charset);</span>
<span class="fc" id="L112">        this.textOut = new BufferedWriter(charOut);</span>
<span class="fc" id="L113">    }</span>

    /* Variant of the private constructor so that the given charset name
     * can be verified before evaluating the OutputStream argument. Used
     * by constructors creating a FileOutputStream that also take a
     * charset name.
     */
    private PrintStream(boolean autoFlush, Charset charset, OutputStream out)
        throws UnsupportedEncodingException
    {
<span class="nc" id="L123">        this(autoFlush, out, charset);</span>
<span class="nc" id="L124">    }</span>

    /**
     * Creates a new print stream.  This stream will not flush automatically.
     *
     * @param  out        The output stream to which values and objects will be
     *                    printed
     *
     * @see java.io.PrintWriter#PrintWriter(java.io.OutputStream)
     */
    public PrintStream(OutputStream out) {
<span class="fc" id="L135">        this(out, false);</span>
<span class="fc" id="L136">    }</span>

    /**
     * Creates a new print stream.
     *
     * @param  out        The output stream to which values and objects will be
     *                    printed
     * @param  autoFlush  A boolean; if true, the output buffer will be flushed
     *                    whenever a byte array is written, one of the
     *                    &lt;code&gt;println&lt;/code&gt; methods is invoked, or a newline
     *                    character or byte (&lt;code&gt;'\n'&lt;/code&gt;) is written
     *
     * @see java.io.PrintWriter#PrintWriter(java.io.OutputStream, boolean)
     */
    public PrintStream(OutputStream out, boolean autoFlush) {
<span class="fc" id="L151">        this(autoFlush, requireNonNull(out, &quot;Null output stream&quot;));</span>
<span class="fc" id="L152">    }</span>

    /**
     * Creates a new print stream.
     *
     * @param  out        The output stream to which values and objects will be
     *                    printed
     * @param  autoFlush  A boolean; if true, the output buffer will be flushed
     *                    whenever a byte array is written, one of the
     *                    &lt;code&gt;println&lt;/code&gt; methods is invoked, or a newline
     *                    character or byte (&lt;code&gt;'\n'&lt;/code&gt;) is written
     * @param  encoding   The name of a supported
     *                    &lt;a href=&quot;../lang/package-summary.html#charenc&quot;&gt;
     *                    character encoding&lt;/a&gt;
     *
     * @throws  UnsupportedEncodingException
     *          If the named encoding is not supported
     *
     * @since  1.4
     */
    public PrintStream(OutputStream out, boolean autoFlush, String encoding)
        throws UnsupportedEncodingException
    {
<span class="fc" id="L175">        this(autoFlush,</span>
<span class="fc" id="L176">             requireNonNull(out, &quot;Null output stream&quot;),</span>
<span class="fc" id="L177">             toCharset(encoding));</span>
<span class="fc" id="L178">    }</span>

    /**
     * Creates a new print stream, without automatic line flushing, with the
     * specified file name.  This convenience constructor creates
     * the necessary intermediate {@link java.io.OutputStreamWriter
     * OutputStreamWriter}, which will encode characters using the
     * {@linkplain java.nio.charset.Charset#defaultCharset() default charset}
     * for this instance of the Java virtual machine.
     *
     * @param  fileName
     *         The name of the file to use as the destination of this print
     *         stream.  If the file exists, then it will be truncated to
     *         zero size; otherwise, a new file will be created.  The output
     *         will be written to the file and is buffered.
     *
     * @throws  FileNotFoundException
     *          If the given file object does not denote an existing, writable
     *          regular file and a new regular file of that name cannot be
     *          created, or if some other error occurs while opening or
     *          creating the file
     *
     * @throws  SecurityException
     *          If a security manager is present and {@link
     *          SecurityManager#checkWrite checkWrite(fileName)} denies write
     *          access to the file
     *
     * @since  1.5
     */
    public PrintStream(String fileName) throws FileNotFoundException {
<span class="fc" id="L208">        this(false, new FileOutputStream(fileName));</span>
<span class="fc" id="L209">    }</span>

    /**
     * Creates a new print stream, without automatic line flushing, with the
     * specified file name and charset.  This convenience constructor creates
     * the necessary intermediate {@link java.io.OutputStreamWriter
     * OutputStreamWriter}, which will encode characters using the provided
     * charset.
     *
     * @param  fileName
     *         The name of the file to use as the destination of this print
     *         stream.  If the file exists, then it will be truncated to
     *         zero size; otherwise, a new file will be created.  The output
     *         will be written to the file and is buffered.
     *
     * @param  csn
     *         The name of a supported {@linkplain java.nio.charset.Charset
     *         charset}
     *
     * @throws  FileNotFoundException
     *          If the given file object does not denote an existing, writable
     *          regular file and a new regular file of that name cannot be
     *          created, or if some other error occurs while opening or
     *          creating the file
     *
     * @throws  SecurityException
     *          If a security manager is present and {@link
     *          SecurityManager#checkWrite checkWrite(fileName)} denies write
     *          access to the file
     *
     * @throws  UnsupportedEncodingException
     *          If the named charset is not supported
     *
     * @since  1.5
     */
    public PrintStream(String fileName, String csn)
        throws FileNotFoundException, UnsupportedEncodingException
    {
        // ensure charset is checked before the file is opened
<span class="nc" id="L248">        this(false, toCharset(csn), new FileOutputStream(fileName));</span>
<span class="nc" id="L249">    }</span>

    /**
     * Creates a new print stream, without automatic line flushing, with the
     * specified file.  This convenience constructor creates the necessary
     * intermediate {@link java.io.OutputStreamWriter OutputStreamWriter},
     * which will encode characters using the {@linkplain
     * java.nio.charset.Charset#defaultCharset() default charset} for this
     * instance of the Java virtual machine.
     *
     * @param  file
     *         The file to use as the destination of this print stream.  If the
     *         file exists, then it will be truncated to zero size; otherwise,
     *         a new file will be created.  The output will be written to the
     *         file and is buffered.
     *
     * @throws  FileNotFoundException
     *          If the given file object does not denote an existing, writable
     *          regular file and a new regular file of that name cannot be
     *          created, or if some other error occurs while opening or
     *          creating the file
     *
     * @throws  SecurityException
     *          If a security manager is present and {@link
     *          SecurityManager#checkWrite checkWrite(file.getPath())}
     *          denies write access to the file
     *
     * @since  1.5
     */
    public PrintStream(File file) throws FileNotFoundException {
<span class="fc" id="L279">        this(false, new FileOutputStream(file));</span>
<span class="fc" id="L280">    }</span>

    /**
     * Creates a new print stream, without automatic line flushing, with the
     * specified file and charset.  This convenience constructor creates
     * the necessary intermediate {@link java.io.OutputStreamWriter
     * OutputStreamWriter}, which will encode characters using the provided
     * charset.
     *
     * @param  file
     *         The file to use as the destination of this print stream.  If the
     *         file exists, then it will be truncated to zero size; otherwise,
     *         a new file will be created.  The output will be written to the
     *         file and is buffered.
     *
     * @param  csn
     *         The name of a supported {@linkplain java.nio.charset.Charset
     *         charset}
     *
     * @throws  FileNotFoundException
     *          If the given file object does not denote an existing, writable
     *          regular file and a new regular file of that name cannot be
     *          created, or if some other error occurs while opening or
     *          creating the file
     *
     * @throws  SecurityException
     *          If a security manager is present and {@link
     *          SecurityManager#checkWrite checkWrite(file.getPath())}
     *          denies write access to the file
     *
     * @throws  UnsupportedEncodingException
     *          If the named charset is not supported
     *
     * @since  1.5
     */
    public PrintStream(File file, String csn)
        throws FileNotFoundException, UnsupportedEncodingException
    {
        // ensure charset is checked before the file is opened
<span class="nc" id="L319">        this(false, toCharset(csn), new FileOutputStream(file));</span>
<span class="nc" id="L320">    }</span>

    /** Check to make sure that the stream has not been closed */
    private void ensureOpen() throws IOException {
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (out == null)</span>
<span class="fc" id="L325">            throw new IOException(&quot;Stream closed&quot;);</span>
<span class="fc" id="L326">    }</span>

    /**
     * Flushes the stream.  This is done by writing any buffered output bytes to
     * the underlying output stream and then flushing that stream.
     *
     * @see        java.io.OutputStream#flush()
     */
    public void flush() {
<span class="fc" id="L335">        synchronized (this) {</span>
            try {
<span class="fc" id="L337">                ensureOpen();</span>
<span class="fc" id="L338">                out.flush();</span>
            }
<span class="fc" id="L340">            catch (IOException x) {</span>
<span class="fc" id="L341">                trouble = true;</span>
<span class="fc" id="L342">            }</span>
<span class="pc" id="L343">        }</span>
<span class="fc" id="L344">    }</span>

<span class="fc" id="L346">    private boolean closing = false; /* To avoid recursive closing */</span>

    /**
     * Closes the stream.  This is done by flushing the stream and then closing
     * the underlying output stream.
     *
     * @see        java.io.OutputStream#close()
     */
    public void close() {
<span class="fc" id="L355">        synchronized (this) {</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">            if (! closing) {</span>
<span class="fc" id="L357">                closing = true;</span>
                try {
<span class="fc" id="L359">                    textOut.close();</span>
<span class="fc" id="L360">                    out.close();</span>
                }
<span class="nc" id="L362">                catch (IOException x) {</span>
<span class="nc" id="L363">                    trouble = true;</span>
<span class="fc" id="L364">                }</span>
<span class="fc" id="L365">                textOut = null;</span>
<span class="fc" id="L366">                charOut = null;</span>
<span class="fc" id="L367">                out = null;</span>
            }
<span class="pc" id="L369">        }</span>
<span class="fc" id="L370">    }</span>

    /**
     * Flushes the stream and checks its error state. The internal error state
     * is set to &lt;code&gt;true&lt;/code&gt; when the underlying output stream throws an
     * &lt;code&gt;IOException&lt;/code&gt; other than &lt;code&gt;InterruptedIOException&lt;/code&gt;,
     * and when the &lt;code&gt;setError&lt;/code&gt; method is invoked.  If an operation
     * on the underlying output stream throws an
     * &lt;code&gt;InterruptedIOException&lt;/code&gt;, then the &lt;code&gt;PrintStream&lt;/code&gt;
     * converts the exception back into an interrupt by doing:
     * &lt;pre&gt;
     *     Thread.currentThread().interrupt();
     * &lt;/pre&gt;
     * or the equivalent.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if and only if this stream has encountered an
     *         &lt;code&gt;IOException&lt;/code&gt; other than
     *         &lt;code&gt;InterruptedIOException&lt;/code&gt;, or the
     *         &lt;code&gt;setError&lt;/code&gt; method has been invoked
     */
    public boolean checkError() {
<span class="fc bfc" id="L391" title="All 2 branches covered.">        if (out != null)</span>
<span class="fc" id="L392">            flush();</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        if (out instanceof java.io.PrintStream) {</span>
<span class="nc" id="L394">            PrintStream ps = (PrintStream) out;</span>
<span class="nc" id="L395">            return ps.checkError();</span>
        }
<span class="fc" id="L397">        return trouble;</span>
    }

    /**
     * Sets the error state of the stream to &lt;code&gt;true&lt;/code&gt;.
     *
     * &lt;p&gt; This method will cause subsequent invocations of {@link
     * #checkError()} to return &lt;tt&gt;true&lt;/tt&gt; until {@link
     * #clearError()} is invoked.
     *
     * @since JDK1.1
     */
    protected void setError() {
<span class="nc" id="L410">        trouble = true;</span>
<span class="nc" id="L411">    }</span>

    /**
     * Clears the internal error state of this stream.
     *
     * &lt;p&gt; This method will cause subsequent invocations of {@link
     * #checkError()} to return &lt;tt&gt;false&lt;/tt&gt; until another write
     * operation fails and invokes {@link #setError()}.
     *
     * @since 1.6
     */
    protected void clearError() {
<span class="fc" id="L423">        trouble = false;</span>
<span class="fc" id="L424">    }</span>

    /*
     * Exception-catching, synchronized output operations,
     * which also implement the write() methods of OutputStream
     */

    /**
     * Writes the specified byte to this stream.  If the byte is a newline and
     * automatic flushing is enabled then the &lt;code&gt;flush&lt;/code&gt; method will be
     * invoked.
     *
     * &lt;p&gt; Note that the byte is written as given; to write a character that
     * will be translated according to the platform's default character
     * encoding, use the &lt;code&gt;print(char)&lt;/code&gt; or &lt;code&gt;println(char)&lt;/code&gt;
     * methods.
     *
     * @param  b  The byte to be written
     * @see #print(char)
     * @see #println(char)
     */
    public void write(int b) {
        try {
<span class="fc" id="L447">            synchronized (this) {</span>
<span class="fc" id="L448">                ensureOpen();</span>
<span class="fc" id="L449">                out.write(b);</span>
<span class="pc bpc" id="L450" title="1 of 4 branches missed.">                if ((b == '\n') &amp;&amp; autoFlush)</span>
<span class="nc" id="L451">                    out.flush();</span>
<span class="pc" id="L452">            }</span>
        }
<span class="nc" id="L454">        catch (InterruptedIOException x) {</span>
<span class="nc" id="L455">            Thread.currentThread().interrupt();</span>
        }
<span class="nc" id="L457">        catch (IOException x) {</span>
<span class="nc" id="L458">            trouble = true;</span>
<span class="pc" id="L459">        }</span>
<span class="fc" id="L460">    }</span>

    /**
     * Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at
     * offset &lt;code&gt;off&lt;/code&gt; to this stream.  If automatic flushing is
     * enabled then the &lt;code&gt;flush&lt;/code&gt; method will be invoked.
     *
     * &lt;p&gt; Note that the bytes will be written as given; to write characters
     * that will be translated according to the platform's default character
     * encoding, use the &lt;code&gt;print(char)&lt;/code&gt; or &lt;code&gt;println(char)&lt;/code&gt;
     * methods.
     *
     * @param  buf   A byte array
     * @param  off   Offset from which to start taking bytes
     * @param  len   Number of bytes to write
     */
    public void write(byte buf[], int off, int len) {
        try {
<span class="fc" id="L478">            synchronized (this) {</span>
<span class="fc" id="L479">                ensureOpen();</span>
<span class="fc" id="L480">                out.write(buf, off, len);</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">                if (autoFlush)</span>
<span class="fc" id="L482">                    out.flush();</span>
<span class="fc" id="L483">            }</span>
        }
<span class="nc" id="L485">        catch (InterruptedIOException x) {</span>
<span class="nc" id="L486">            Thread.currentThread().interrupt();</span>
        }
<span class="fc" id="L488">        catch (IOException x) {</span>
<span class="fc" id="L489">            trouble = true;</span>
<span class="pc" id="L490">        }</span>
<span class="fc" id="L491">    }</span>

    /*
     * The following private methods on the text- and character-output streams
     * always flush the stream buffers, so that writes to the underlying byte
     * stream occur as promptly as with the original PrintStream.
     */

    private void write(char buf[]) {
        try {
<span class="nc" id="L501">            synchronized (this) {</span>
<span class="nc" id="L502">                ensureOpen();</span>
<span class="nc" id="L503">                textOut.write(buf);</span>
<span class="nc" id="L504">                textOut.flushBuffer();</span>
<span class="nc" id="L505">                charOut.flushBuffer();</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                if (autoFlush) {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                    for (int i = 0; i &lt; buf.length; i++)</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                        if (buf[i] == '\n')</span>
<span class="nc" id="L509">                            out.flush();</span>
                }
<span class="nc" id="L511">            }</span>
        }
<span class="nc" id="L513">        catch (InterruptedIOException x) {</span>
<span class="nc" id="L514">            Thread.currentThread().interrupt();</span>
        }
<span class="nc" id="L516">        catch (IOException x) {</span>
<span class="nc" id="L517">            trouble = true;</span>
<span class="nc" id="L518">        }</span>
<span class="nc" id="L519">    }</span>

    private void write(String s) {
        try {
<span class="fc" id="L523">            synchronized (this) {</span>
<span class="fc" id="L524">                ensureOpen();</span>
<span class="fc" id="L525">                textOut.write(s);</span>
<span class="fc" id="L526">                textOut.flushBuffer();</span>
<span class="fc" id="L527">                charOut.flushBuffer();</span>
<span class="fc bfc" id="L528" title="All 4 branches covered.">                if (autoFlush &amp;&amp; (s.indexOf('\n') &gt;= 0))</span>
<span class="fc" id="L529">                    out.flush();</span>
<span class="fc" id="L530">            }</span>
        }
<span class="nc" id="L532">        catch (InterruptedIOException x) {</span>
<span class="nc" id="L533">            Thread.currentThread().interrupt();</span>
        }
<span class="fc" id="L535">        catch (IOException x) {</span>
<span class="fc" id="L536">            trouble = true;</span>
<span class="pc" id="L537">        }</span>
<span class="fc" id="L538">    }</span>

    private void newLine() {
        try {
<span class="fc" id="L542">            synchronized (this) {</span>
<span class="fc" id="L543">                ensureOpen();</span>
<span class="fc" id="L544">                textOut.newLine();</span>
<span class="fc" id="L545">                textOut.flushBuffer();</span>
<span class="fc" id="L546">                charOut.flushBuffer();</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">                if (autoFlush)</span>
<span class="fc" id="L548">                    out.flush();</span>
<span class="fc" id="L549">            }</span>
        }
<span class="nc" id="L551">        catch (InterruptedIOException x) {</span>
<span class="nc" id="L552">            Thread.currentThread().interrupt();</span>
        }
<span class="fc" id="L554">        catch (IOException x) {</span>
<span class="fc" id="L555">            trouble = true;</span>
<span class="pc" id="L556">        }</span>
<span class="fc" id="L557">    }</span>

    /* Methods that do not terminate lines */

    /**
     * Prints a boolean value.  The string produced by &lt;code&gt;{@link
     * java.lang.String#valueOf(boolean)}&lt;/code&gt; is translated into bytes
     * according to the platform's default character encoding, and these bytes
     * are written in exactly the manner of the
     * &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.
     *
     * @param      b   The &lt;code&gt;boolean&lt;/code&gt; to be printed
     */
    public void print(boolean b) {
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">        write(b ? &quot;true&quot; : &quot;false&quot;);</span>
<span class="fc" id="L572">    }</span>

    /**
     * Prints a character.  The character is translated into one or more bytes
     * according to the platform's default character encoding, and these bytes
     * are written in exactly the manner of the
     * &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.
     *
     * @param      c   The &lt;code&gt;char&lt;/code&gt; to be printed
     */
    public void print(char c) {
<span class="fc" id="L583">        write(String.valueOf(c));</span>
<span class="fc" id="L584">    }</span>

    /**
     * Prints an integer.  The string produced by &lt;code&gt;{@link
     * java.lang.String#valueOf(int)}&lt;/code&gt; is translated into bytes
     * according to the platform's default character encoding, and these bytes
     * are written in exactly the manner of the
     * &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.
     *
     * @param      i   The &lt;code&gt;int&lt;/code&gt; to be printed
     * @see        java.lang.Integer#toString(int)
     */
    public void print(int i) {
<span class="fc" id="L597">        write(String.valueOf(i));</span>
<span class="fc" id="L598">    }</span>

    /**
     * Prints a long integer.  The string produced by &lt;code&gt;{@link
     * java.lang.String#valueOf(long)}&lt;/code&gt; is translated into bytes
     * according to the platform's default character encoding, and these bytes
     * are written in exactly the manner of the
     * &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.
     *
     * @param      l   The &lt;code&gt;long&lt;/code&gt; to be printed
     * @see        java.lang.Long#toString(long)
     */
    public void print(long l) {
<span class="nc" id="L611">        write(String.valueOf(l));</span>
<span class="nc" id="L612">    }</span>

    /**
     * Prints a floating-point number.  The string produced by &lt;code&gt;{@link
     * java.lang.String#valueOf(float)}&lt;/code&gt; is translated into bytes
     * according to the platform's default character encoding, and these bytes
     * are written in exactly the manner of the
     * &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.
     *
     * @param      f   The &lt;code&gt;float&lt;/code&gt; to be printed
     * @see        java.lang.Float#toString(float)
     */
    public void print(float f) {
<span class="nc" id="L625">        write(String.valueOf(f));</span>
<span class="nc" id="L626">    }</span>

    /**
     * Prints a double-precision floating-point number.  The string produced by
     * &lt;code&gt;{@link java.lang.String#valueOf(double)}&lt;/code&gt; is translated into
     * bytes according to the platform's default character encoding, and these
     * bytes are written in exactly the manner of the &lt;code&gt;{@link
     * #write(int)}&lt;/code&gt; method.
     *
     * @param      d   The &lt;code&gt;double&lt;/code&gt; to be printed
     * @see        java.lang.Double#toString(double)
     */
    public void print(double d) {
<span class="nc" id="L639">        write(String.valueOf(d));</span>
<span class="nc" id="L640">    }</span>

    /**
     * Prints an array of characters.  The characters are converted into bytes
     * according to the platform's default character encoding, and these bytes
     * are written in exactly the manner of the
     * &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.
     *
     * @param      s   The array of chars to be printed
     *
     * @throws  NullPointerException  If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     */
    public void print(char s[]) {
<span class="nc" id="L653">        write(s);</span>
<span class="nc" id="L654">    }</span>

    /**
     * Prints a string.  If the argument is &lt;code&gt;null&lt;/code&gt; then the string
     * &lt;code&gt;&quot;null&quot;&lt;/code&gt; is printed.  Otherwise, the string's characters are
     * converted into bytes according to the platform's default character
     * encoding, and these bytes are written in exactly the manner of the
     * &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.
     *
     * @param      s   The &lt;code&gt;String&lt;/code&gt; to be printed
     */
    public void print(String s) {
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L667">            s = &quot;null&quot;;</span>
        }
<span class="fc" id="L669">        write(s);</span>
<span class="fc" id="L670">    }</span>

    /**
     * Prints an object.  The string produced by the &lt;code&gt;{@link
     * java.lang.String#valueOf(Object)}&lt;/code&gt; method is translated into bytes
     * according to the platform's default character encoding, and these bytes
     * are written in exactly the manner of the
     * &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.
     *
     * @param      obj   The &lt;code&gt;Object&lt;/code&gt; to be printed
     * @see        java.lang.Object#toString()
     */
    public void print(Object obj) {
<span class="fc" id="L683">        write(String.valueOf(obj));</span>
<span class="fc" id="L684">    }</span>


    /* Methods that do terminate lines */

    /**
     * Terminates the current line by writing the line separator string.  The
     * line separator string is defined by the system property
     * &lt;code&gt;line.separator&lt;/code&gt;, and is not necessarily a single newline
     * character (&lt;code&gt;'\n'&lt;/code&gt;).
     */
    public void println() {
<span class="fc" id="L696">        newLine();</span>
<span class="fc" id="L697">    }</span>

    /**
     * Prints a boolean and then terminate the line.  This method behaves as
     * though it invokes &lt;code&gt;{@link #print(boolean)}&lt;/code&gt; and then
     * &lt;code&gt;{@link #println()}&lt;/code&gt;.
     *
     * @param x  The &lt;code&gt;boolean&lt;/code&gt; to be printed
     */
    public void println(boolean x) {
<span class="fc" id="L707">        synchronized (this) {</span>
<span class="fc" id="L708">            print(x);</span>
<span class="fc" id="L709">            newLine();</span>
<span class="pc" id="L710">        }</span>
<span class="fc" id="L711">    }</span>

    /**
     * Prints a character and then terminate the line.  This method behaves as
     * though it invokes &lt;code&gt;{@link #print(char)}&lt;/code&gt; and then
     * &lt;code&gt;{@link #println()}&lt;/code&gt;.
     *
     * @param x  The &lt;code&gt;char&lt;/code&gt; to be printed.
     */
    public void println(char x) {
<span class="fc" id="L721">        synchronized (this) {</span>
<span class="fc" id="L722">            print(x);</span>
<span class="fc" id="L723">            newLine();</span>
<span class="pc" id="L724">        }</span>
<span class="fc" id="L725">    }</span>

    /**
     * Prints an integer and then terminate the line.  This method behaves as
     * though it invokes &lt;code&gt;{@link #print(int)}&lt;/code&gt; and then
     * &lt;code&gt;{@link #println()}&lt;/code&gt;.
     *
     * @param x  The &lt;code&gt;int&lt;/code&gt; to be printed.
     */
    public void println(int x) {
<span class="fc" id="L735">        synchronized (this) {</span>
<span class="fc" id="L736">            print(x);</span>
<span class="fc" id="L737">            newLine();</span>
<span class="pc" id="L738">        }</span>
<span class="fc" id="L739">    }</span>

    /**
     * Prints a long and then terminate the line.  This method behaves as
     * though it invokes &lt;code&gt;{@link #print(long)}&lt;/code&gt; and then
     * &lt;code&gt;{@link #println()}&lt;/code&gt;.
     *
     * @param x  a The &lt;code&gt;long&lt;/code&gt; to be printed.
     */
    public void println(long x) {
<span class="nc" id="L749">        synchronized (this) {</span>
<span class="nc" id="L750">            print(x);</span>
<span class="nc" id="L751">            newLine();</span>
<span class="nc" id="L752">        }</span>
<span class="nc" id="L753">    }</span>

    /**
     * Prints a float and then terminate the line.  This method behaves as
     * though it invokes &lt;code&gt;{@link #print(float)}&lt;/code&gt; and then
     * &lt;code&gt;{@link #println()}&lt;/code&gt;.
     *
     * @param x  The &lt;code&gt;float&lt;/code&gt; to be printed.
     */
    public void println(float x) {
<span class="nc" id="L763">        synchronized (this) {</span>
<span class="nc" id="L764">            print(x);</span>
<span class="nc" id="L765">            newLine();</span>
<span class="nc" id="L766">        }</span>
<span class="nc" id="L767">    }</span>

    /**
     * Prints a double and then terminate the line.  This method behaves as
     * though it invokes &lt;code&gt;{@link #print(double)}&lt;/code&gt; and then
     * &lt;code&gt;{@link #println()}&lt;/code&gt;.
     *
     * @param x  The &lt;code&gt;double&lt;/code&gt; to be printed.
     */
    public void println(double x) {
<span class="nc" id="L777">        synchronized (this) {</span>
<span class="nc" id="L778">            print(x);</span>
<span class="nc" id="L779">            newLine();</span>
<span class="nc" id="L780">        }</span>
<span class="nc" id="L781">    }</span>

    /**
     * Prints an array of characters and then terminate the line.  This method
     * behaves as though it invokes &lt;code&gt;{@link #print(char[])}&lt;/code&gt; and
     * then &lt;code&gt;{@link #println()}&lt;/code&gt;.
     *
     * @param x  an array of chars to print.
     */
    public void println(char x[]) {
<span class="nc" id="L791">        synchronized (this) {</span>
<span class="nc" id="L792">            print(x);</span>
<span class="nc" id="L793">            newLine();</span>
<span class="nc" id="L794">        }</span>
<span class="nc" id="L795">    }</span>

    /**
     * Prints a String and then terminate the line.  This method behaves as
     * though it invokes &lt;code&gt;{@link #print(String)}&lt;/code&gt; and then
     * &lt;code&gt;{@link #println()}&lt;/code&gt;.
     *
     * @param x  The &lt;code&gt;String&lt;/code&gt; to be printed.
     */
    public void println(String x) {
<span class="fc" id="L805">        synchronized (this) {</span>
<span class="fc" id="L806">            print(x);</span>
<span class="fc" id="L807">            newLine();</span>
<span class="pc" id="L808">        }</span>
<span class="fc" id="L809">    }</span>

    /**
     * Prints an Object and then terminate the line.  This method calls
     * at first String.valueOf(x) to get the printed object's string value,
     * then behaves as
     * though it invokes &lt;code&gt;{@link #print(String)}&lt;/code&gt; and then
     * &lt;code&gt;{@link #println()}&lt;/code&gt;.
     *
     * @param x  The &lt;code&gt;Object&lt;/code&gt; to be printed.
     */
    public void println(Object x) {
<span class="fc" id="L821">        String s = String.valueOf(x);</span>
<span class="fc" id="L822">        synchronized (this) {</span>
<span class="fc" id="L823">            print(s);</span>
<span class="fc" id="L824">            newLine();</span>
<span class="pc" id="L825">        }</span>
<span class="fc" id="L826">    }</span>


    /**
     * A convenience method to write a formatted string to this output stream
     * using the specified format string and arguments.
     *
     * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.printf(format,
     * args)&lt;/tt&gt; behaves in exactly the same way as the invocation
     *
     * &lt;pre&gt;
     *     out.format(format, args) &lt;/pre&gt;
     *
     * @param  format
     *         A format string as described in &lt;a
     *         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;
     *
     * @param  args
     *         Arguments referenced by the format specifiers in the format
     *         string.  If there are more arguments than format specifiers, the
     *         extra arguments are ignored.  The number of arguments is
     *         variable and may be zero.  The maximum number of arguments is
     *         limited by the maximum dimension of a Java array as defined by
     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
     *         The behaviour on a
     *         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
     *         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.
     *
     * @throws  java.util.IllegalFormatException
     *          If a format string contains an illegal syntax, a format
     *          specifier that is incompatible with the given arguments,
     *          insufficient arguments given the format string, or other
     *          illegal conditions.  For specification of all possible
     *          formatting errors, see the &lt;a
     *          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
     *          formatter class specification.
     *
     * @throws  NullPointerException
     *          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
     *
     * @return  This output stream
     *
     * @since  1.5
     */
    public PrintStream printf(String format, Object ... args) {
<span class="fc" id="L871">        return format(format, args);</span>
    }

    /**
     * A convenience method to write a formatted string to this output stream
     * using the specified format string and arguments.
     *
     * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.printf(l, format,
     * args)&lt;/tt&gt; behaves in exactly the same way as the invocation
     *
     * &lt;pre&gt;
     *     out.format(l, format, args) &lt;/pre&gt;
     *
     * @param  l
     *         The {@linkplain java.util.Locale locale} to apply during
     *         formatting.  If &lt;tt&gt;l&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt; then no localization
     *         is applied.
     *
     * @param  format
     *         A format string as described in &lt;a
     *         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;
     *
     * @param  args
     *         Arguments referenced by the format specifiers in the format
     *         string.  If there are more arguments than format specifiers, the
     *         extra arguments are ignored.  The number of arguments is
     *         variable and may be zero.  The maximum number of arguments is
     *         limited by the maximum dimension of a Java array as defined by
     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
     *         The behaviour on a
     *         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
     *         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.
     *
     * @throws  java.util.IllegalFormatException
     *          If a format string contains an illegal syntax, a format
     *          specifier that is incompatible with the given arguments,
     *          insufficient arguments given the format string, or other
     *          illegal conditions.  For specification of all possible
     *          formatting errors, see the &lt;a
     *          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
     *          formatter class specification.
     *
     * @throws  NullPointerException
     *          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
     *
     * @return  This output stream
     *
     * @since  1.5
     */
    public PrintStream printf(Locale l, String format, Object ... args) {
<span class="nc" id="L921">        return format(l, format, args);</span>
    }

    /**
     * Writes a formatted string to this output stream using the specified
     * format string and arguments.
     *
     * &lt;p&gt; The locale always used is the one returned by {@link
     * java.util.Locale#getDefault() Locale.getDefault()}, regardless of any
     * previous invocations of other formatting methods on this object.
     *
     * @param  format
     *         A format string as described in &lt;a
     *         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;
     *
     * @param  args
     *         Arguments referenced by the format specifiers in the format
     *         string.  If there are more arguments than format specifiers, the
     *         extra arguments are ignored.  The number of arguments is
     *         variable and may be zero.  The maximum number of arguments is
     *         limited by the maximum dimension of a Java array as defined by
     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
     *         The behaviour on a
     *         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
     *         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.
     *
     * @throws  java.util.IllegalFormatException
     *          If a format string contains an illegal syntax, a format
     *          specifier that is incompatible with the given arguments,
     *          insufficient arguments given the format string, or other
     *          illegal conditions.  For specification of all possible
     *          formatting errors, see the &lt;a
     *          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
     *          formatter class specification.
     *
     * @throws  NullPointerException
     *          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
     *
     * @return  This output stream
     *
     * @since  1.5
     */
    public PrintStream format(String format, Object ... args) {
        try {
<span class="fc" id="L965">            synchronized (this) {</span>
<span class="fc" id="L966">                ensureOpen();</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">                if ((formatter == null)</span>
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">                    || (formatter.locale() != Locale.getDefault()))</span>
<span class="fc" id="L969">                    formatter = new Formatter((Appendable) this);</span>
<span class="fc" id="L970">                formatter.format(Locale.getDefault(), format, args);</span>
<span class="pc" id="L971">            }</span>
<span class="nc" id="L972">        } catch (InterruptedIOException x) {</span>
<span class="nc" id="L973">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L974">        } catch (IOException x) {</span>
<span class="nc" id="L975">            trouble = true;</span>
<span class="pc" id="L976">        }</span>
<span class="fc" id="L977">        return this;</span>
    }

    /**
     * Writes a formatted string to this output stream using the specified
     * format string and arguments.
     *
     * @param  l
     *         The {@linkplain java.util.Locale locale} to apply during
     *         formatting.  If &lt;tt&gt;l&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt; then no localization
     *         is applied.
     *
     * @param  format
     *         A format string as described in &lt;a
     *         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;
     *
     * @param  args
     *         Arguments referenced by the format specifiers in the format
     *         string.  If there are more arguments than format specifiers, the
     *         extra arguments are ignored.  The number of arguments is
     *         variable and may be zero.  The maximum number of arguments is
     *         limited by the maximum dimension of a Java array as defined by
     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
     *         The behaviour on a
     *         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
     *         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.
     *
     * @throws  java.util.IllegalFormatException
     *          If a format string contains an illegal syntax, a format
     *          specifier that is incompatible with the given arguments,
     *          insufficient arguments given the format string, or other
     *          illegal conditions.  For specification of all possible
     *          formatting errors, see the &lt;a
     *          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
     *          formatter class specification.
     *
     * @throws  NullPointerException
     *          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;
     *
     * @return  This output stream
     *
     * @since  1.5
     */
    public PrintStream format(Locale l, String format, Object ... args) {
        try {
<span class="fc" id="L1022">            synchronized (this) {</span>
<span class="fc" id="L1023">                ensureOpen();</span>
<span class="pc bpc" id="L1024" title="1 of 2 branches missed.">                if ((formatter == null)</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">                    || (formatter.locale() != l))</span>
<span class="fc" id="L1026">                    formatter = new Formatter(this, l);</span>
<span class="fc" id="L1027">                formatter.format(l, format, args);</span>
<span class="pc" id="L1028">            }</span>
<span class="nc" id="L1029">        } catch (InterruptedIOException x) {</span>
<span class="nc" id="L1030">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L1031">        } catch (IOException x) {</span>
<span class="nc" id="L1032">            trouble = true;</span>
<span class="pc" id="L1033">        }</span>
<span class="fc" id="L1034">        return this;</span>
    }

    /**
     * Appends the specified character sequence to this output stream.
     *
     * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq)&lt;/tt&gt;
     * behaves in exactly the same way as the invocation
     *
     * &lt;pre&gt;
     *     out.print(csq.toString()) &lt;/pre&gt;
     *
     * &lt;p&gt; Depending on the specification of &lt;tt&gt;toString&lt;/tt&gt; for the
     * character sequence &lt;tt&gt;csq&lt;/tt&gt;, the entire sequence may not be
     * appended.  For instance, invoking then &lt;tt&gt;toString&lt;/tt&gt; method of a
     * character buffer will return a subsequence whose content depends upon
     * the buffer's position and limit.
     *
     * @param  csq
     *         The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is
     *         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are
     *         appended to this output stream.
     *
     * @return  This output stream
     *
     * @since  1.5
     */
    public PrintStream append(CharSequence csq) {
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">        if (csq == null)</span>
<span class="nc" id="L1063">            print(&quot;null&quot;);</span>
        else
<span class="fc" id="L1065">            print(csq.toString());</span>
<span class="fc" id="L1066">        return this;</span>
    }

    /**
     * Appends a subsequence of the specified character sequence to this output
     * stream.
     *
     * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq, start,
     * end)&lt;/tt&gt; when &lt;tt&gt;csq&lt;/tt&gt; is not &lt;tt&gt;null&lt;/tt&gt;, behaves in
     * exactly the same way as the invocation
     *
     * &lt;pre&gt;
     *     out.print(csq.subSequence(start, end).toString()) &lt;/pre&gt;
     *
     * @param  csq
     *         The character sequence from which a subsequence will be
     *         appended.  If &lt;tt&gt;csq&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, then characters
     *         will be appended as if &lt;tt&gt;csq&lt;/tt&gt; contained the four
     *         characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt;.
     *
     * @param  start
     *         The index of the first character in the subsequence
     *
     * @param  end
     *         The index of the character following the last character in the
     *         subsequence
     *
     * @return  This output stream
     *
     * @throws  IndexOutOfBoundsException
     *          If &lt;tt&gt;start&lt;/tt&gt; or &lt;tt&gt;end&lt;/tt&gt; are negative, &lt;tt&gt;start&lt;/tt&gt;
     *          is greater than &lt;tt&gt;end&lt;/tt&gt;, or &lt;tt&gt;end&lt;/tt&gt; is greater than
     *          &lt;tt&gt;csq.length()&lt;/tt&gt;
     *
     * @since  1.5
     */
    public PrintStream append(CharSequence csq, int start, int end) {
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        CharSequence cs = (csq == null ? &quot;null&quot; : csq);</span>
<span class="nc" id="L1104">        write(cs.subSequence(start, end).toString());</span>
<span class="nc" id="L1105">        return this;</span>
    }

    /**
     * Appends the specified character to this output stream.
     *
     * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;/tt&gt;
     * behaves in exactly the same way as the invocation
     *
     * &lt;pre&gt;
     *     out.print(c) &lt;/pre&gt;
     *
     * @param  c
     *         The 16-bit character to append
     *
     * @return  This output stream
     *
     * @since  1.5
     */
    public PrintStream append(char c) {
<span class="nc" id="L1125">        print(c);</span>
<span class="nc" id="L1126">        return this;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>