<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FilePermission.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.io</a> &gt; <span class="el_source">FilePermission.java</span></div><h1>FilePermission.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.io;

import java.security.*;
import java.util.Enumeration;
import java.util.List;
import java.util.ArrayList;
import java.util.Vector;
import java.util.Collections;
import sun.security.util.SecurityConstants;

/**
 * This class represents access to a file or directory.  A FilePermission consists
 * of a pathname and a set of actions valid for that pathname.
 * &lt;P&gt;
 * Pathname is the pathname of the file or directory granted the specified
 * actions. A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
 * the file separator character, &lt;code&gt;File.separatorChar&lt;/code&gt;) indicates
 * all the files and directories contained in that directory. A pathname
 * that ends with &quot;/-&quot; indicates (recursively) all files
 * and subdirectories contained in that directory. A pathname consisting of
 * the special token &quot;&amp;lt;&amp;lt;ALL FILES&amp;gt;&amp;gt;&quot; matches &lt;b&gt;any&lt;/b&gt; file.
 * &lt;P&gt;
 * Note: A pathname consisting of a single &quot;*&quot; indicates all the files
 * in the current directory, while a pathname consisting of a single &quot;-&quot;
 * indicates all the files in the current directory and
 * (recursively) all files and subdirectories contained in the current
 * directory.
 * &lt;P&gt;
 * The actions to be granted are passed to the constructor in a string containing
 * a list of one or more comma-separated keywords. The possible keywords are
 * &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, &quot;delete&quot;, and &quot;readlink&quot;. Their meaning is
 * defined as follows:
 *
 * &lt;DL&gt;
 *    &lt;DT&gt; read &lt;DD&gt; read permission
 *    &lt;DT&gt; write &lt;DD&gt; write permission
 *    &lt;DT&gt; execute
 *    &lt;DD&gt; execute permission. Allows &lt;code&gt;Runtime.exec&lt;/code&gt; to
 *         be called. Corresponds to &lt;code&gt;SecurityManager.checkExec&lt;/code&gt;.
 *    &lt;DT&gt; delete
 *    &lt;DD&gt; delete permission. Allows &lt;code&gt;File.delete&lt;/code&gt; to
 *         be called. Corresponds to &lt;code&gt;SecurityManager.checkDelete&lt;/code&gt;.
 *    &lt;DT&gt; readlink
 *    &lt;DD&gt; read link permission. Allows the target of a
 *         &lt;a href=&quot;../nio/file/package-summary.html#links&quot;&gt;symbolic link&lt;/a&gt;
 *         to be read by invoking the {@link java.nio.file.Files#readSymbolicLink
 *         readSymbolicLink } method.
 * &lt;/DL&gt;
 * &lt;P&gt;
 * The actions string is converted to lowercase before processing.
 * &lt;P&gt;
 * Be careful when granting FilePermissions. Think about the implications
 * of granting read and especially write access to various files and
 * directories. The &quot;&amp;lt;&amp;lt;ALL FILES&amp;gt;&amp;gt;&quot; permission with write action is
 * especially dangerous. This grants permission to write to the entire
 * file system. One thing this effectively allows is replacement of the
 * system binary, including the JVM runtime environment.
 *
 * &lt;p&gt;Please note: Code can always read a file from the same
 * directory it's in (or a subdirectory of that directory); it does not
 * need explicit permission to do so.
 *
 * @see java.security.Permission
 * @see java.security.Permissions
 * @see java.security.PermissionCollection
 *
 *
 * @author Marianne Mueller
 * @author Roland Schemers
 * @since 1.2
 *
 * @serial exclude
 */

public final class FilePermission extends Permission implements Serializable {

    /**
     * Execute action.
     */
    private final static int EXECUTE = 0x1;
    /**
     * Write action.
     */
    private final static int WRITE   = 0x2;
    /**
     * Read action.
     */
    private final static int READ    = 0x4;
    /**
     * Delete action.
     */
    private final static int DELETE  = 0x8;
    /**
     * Read link action.
     */
    private final static int READLINK    = 0x10;

    /**
     * All actions (read,write,execute,delete,readlink)
     */
    private final static int ALL     = READ|WRITE|EXECUTE|DELETE|READLINK;
    /**
     * No actions.
     */
    private final static int NONE    = 0x0;

    // the actions mask
    private transient int mask;

    // does path indicate a directory? (wildcard or recursive)
    private transient boolean directory;

    // is it a recursive directory specification?
    private transient boolean recursive;

    /**
     * the actions string.
     *
     * @serial
     */
    private String actions; // Left null as long as possible, then
                            // created and re-used in the getAction function.

    // canonicalized dir path. In the case of
    // directories, it is the name &quot;/blah/*&quot; or &quot;/blah/-&quot; without
    // the last character (the &quot;*&quot; or &quot;-&quot;).

    private transient String cpath;

    // static Strings used by init(int mask)
    private static final char RECURSIVE_CHAR = '-';
    private static final char WILD_CHAR = '*';

/*
    public String toString()
    {
        StringBuffer sb = new StringBuffer();
        sb.append(&quot;***\n&quot;);
        sb.append(&quot;cpath = &quot;+cpath+&quot;\n&quot;);
        sb.append(&quot;mask = &quot;+mask+&quot;\n&quot;);
        sb.append(&quot;actions = &quot;+getActions()+&quot;\n&quot;);
        sb.append(&quot;directory = &quot;+directory+&quot;\n&quot;);
        sb.append(&quot;recursive = &quot;+recursive+&quot;\n&quot;);
        sb.append(&quot;***\n&quot;);
        return sb.toString();
    }
*/

    private static final long serialVersionUID = 7930732926638008763L;

    /**
     * initialize a FilePermission object. Common to all constructors.
     * Also called during de-serialization.
     *
     * @param mask the actions mask to use.
     *
     */
    private void init(int mask) {
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if ((mask &amp; ALL) != mask)</span>
<span class="nc" id="L185">                throw new IllegalArgumentException(&quot;invalid actions mask&quot;);</span>

<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (mask == NONE)</span>
<span class="fc" id="L188">                throw new IllegalArgumentException(&quot;invalid actions mask&quot;);</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">        if ((cpath = getName()) == null)</span>
<span class="fc" id="L191">                throw new NullPointerException(&quot;name can't be null&quot;);</span>

<span class="fc" id="L193">        this.mask = mask;</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (cpath.equals(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;)) {</span>
<span class="fc" id="L196">            directory = true;</span>
<span class="fc" id="L197">            recursive = true;</span>
<span class="fc" id="L198">            cpath = &quot;&quot;;</span>
<span class="fc" id="L199">            return;</span>
        }

        // store only the canonical cpath if possible
<span class="fc" id="L203">        cpath = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {</span>
            public String run() {
                try {
<span class="fc" id="L206">                    String path = cpath;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">                    if (cpath.endsWith(&quot;*&quot;)) {</span>
                        // call getCanonicalPath with a path with wildcard character
                        // replaced to avoid calling it with paths that are
                        // intended to match all entries in a directory
<span class="fc" id="L211">                        path = path.substring(0, path.length()-1) + &quot;-&quot;;</span>
<span class="fc" id="L212">                        path = new File(path).getCanonicalPath();</span>
<span class="fc" id="L213">                        return path.substring(0, path.length()-1) + &quot;*&quot;;</span>
                    } else {
<span class="fc" id="L215">                        return new File(path).getCanonicalPath();</span>
                    }
<span class="nc" id="L217">                } catch (IOException ioe) {</span>
<span class="nc" id="L218">                    return cpath;</span>
                }
            }
        });

<span class="fc" id="L223">        int len = cpath.length();</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        char last = ((len &gt; 0) ? cpath.charAt(len - 1) : 0);</span>

<span class="fc bfc" id="L226" title="All 2 branches covered.">        if (last == RECURSIVE_CHAR &amp;&amp;</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">            cpath.charAt(len - 2) == File.separatorChar) {</span>
<span class="fc" id="L228">            directory = true;</span>
<span class="fc" id="L229">            recursive = true;</span>
<span class="fc" id="L230">            cpath = cpath.substring(0, --len);</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        } else if (last == WILD_CHAR &amp;&amp;</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">            cpath.charAt(len - 2) == File.separatorChar) {</span>
<span class="fc" id="L233">            directory = true;</span>
            //recursive = false;
<span class="fc" id="L235">            cpath = cpath.substring(0, --len);</span>
        } else {
            // overkill since they are initialized to false, but
            // commented out here to remind us...
            //directory = false;
            //recursive = false;
        }

        // XXX: at this point the path should be absolute. die if it isn't?
<span class="fc" id="L244">    }</span>

    /**
     * Creates a new FilePermission object with the specified actions.
     * &lt;i&gt;path&lt;/i&gt; is the pathname of a file or directory, and &lt;i&gt;actions&lt;/i&gt;
     * contains a comma-separated list of the desired actions granted on the
     * file or directory. Possible actions are
     * &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, &quot;delete&quot;, and &quot;readlink&quot;.
     *
     * &lt;p&gt;A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
     * the file separator character, &lt;code&gt;File.separatorChar&lt;/code&gt;)
     * indicates all the files and directories contained in that directory.
     * A pathname that ends with &quot;/-&quot; indicates (recursively) all files and
     * subdirectories contained in that directory. The special pathname
     * &quot;&amp;lt;&amp;lt;ALL FILES&amp;gt;&amp;gt;&quot; matches any file.
     *
     * &lt;p&gt;A pathname consisting of a single &quot;*&quot; indicates all the files
     * in the current directory, while a pathname consisting of a single &quot;-&quot;
     * indicates all the files in the current directory and
     * (recursively) all files and subdirectories contained in the current
     * directory.
     *
     * &lt;p&gt;A pathname containing an empty string represents an empty path.
     *
     * @param path the pathname of the file/directory.
     * @param actions the action string.
     *
     * @throws IllegalArgumentException
     *          If actions is &lt;code&gt;null&lt;/code&gt;, empty or contains an action
     *          other than the specified possible actions.
     */
    public FilePermission(String path, String actions) {
<span class="fc" id="L276">        super(path);</span>
<span class="fc" id="L277">        init(getMask(actions));</span>
<span class="fc" id="L278">    }</span>

    /**
     * Creates a new FilePermission object using an action mask.
     * More efficient than the FilePermission(String, String) constructor.
     * Can be used from within
     * code that needs to create a FilePermission object to pass into the
     * &lt;code&gt;implies&lt;/code&gt; method.
     *
     * @param path the pathname of the file/directory.
     * @param mask the action mask to use.
     */

    // package private for use by the FilePermissionCollection add method
    FilePermission(String path, int mask) {
<span class="nc" id="L293">        super(path);</span>
<span class="nc" id="L294">        init(mask);</span>
<span class="nc" id="L295">    }</span>

    /**
     * Checks if this FilePermission object &quot;implies&quot; the specified permission.
     * &lt;P&gt;
     * More specifically, this method returns true if:
     * &lt;ul&gt;
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; is an instanceof FilePermission,
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;'s actions are a proper subset of this
     * object's actions, and
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;'s pathname is implied by this object's
     *      pathname. For example, &quot;/tmp/*&quot; implies &quot;/tmp/foo&quot;, since
     *      &quot;/tmp/*&quot; encompasses all files in the &quot;/tmp&quot; directory,
     *      including the one named &quot;foo&quot;.
     * &lt;/ul&gt;
     *
     * @param p the permission to check against.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the specified permission is not
     *                  &lt;code&gt;null&lt;/code&gt; and is implied by this object,
     *                  &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean implies(Permission p) {
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (!(p instanceof FilePermission))</span>
<span class="nc" id="L319">            return false;</span>

<span class="nc" id="L321">        FilePermission that = (FilePermission) p;</span>

        // we get the effective mask. i.e., the &quot;and&quot; of this and that.
        // They must be equal to that.mask for implies to return true.

<span class="nc bnc" id="L326" title="All 4 branches missed.">        return ((this.mask &amp; that.mask) == that.mask) &amp;&amp; impliesIgnoreMask(that);</span>
    }

    /**
     * Checks if the Permission's actions are a proper subset of the
     * this object's actions. Returns the effective mask iff the
     * this FilePermission's path also implies that FilePermission's path.
     *
     * @param that the FilePermission to check against.
     * @return the effective mask
     */
    boolean impliesIgnoreMask(FilePermission that) {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (this.directory) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (this.recursive) {</span>
                // make sure that.path is longer then path so
                // something like /foo/- does not imply /foo
<span class="fc bfc" id="L342" title="All 2 branches covered.">                if (that.directory) {</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">                    return (that.cpath.length() &gt;= this.cpath.length()) &amp;&amp;</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">                            that.cpath.startsWith(this.cpath);</span>
                }  else {
<span class="fc bfc" id="L346" title="All 2 branches covered.">                    return ((that.cpath.length() &gt; this.cpath.length()) &amp;&amp;</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">                        that.cpath.startsWith(this.cpath));</span>
                }
            } else {
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">                if (that.directory) {</span>
                    // if the permission passed in is a directory
                    // specification, make sure that a non-recursive
                    // permission (i.e., this object) can't imply a recursive
                    // permission.
<span class="nc bnc" id="L355" title="All 2 branches missed.">                    if (that.recursive)</span>
<span class="nc" id="L356">                        return false;</span>
                    else
<span class="nc" id="L358">                        return (this.cpath.equals(that.cpath));</span>
                } else {
<span class="fc" id="L360">                    int last = that.cpath.lastIndexOf(File.separatorChar);</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">                    if (last == -1)</span>
<span class="nc" id="L362">                        return false;</span>
                    else {
                        // this.cpath.equals(that.cpath.substring(0, last+1));
                        // Use regionMatches to avoid creating new string
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">                        return (this.cpath.length() == (last + 1)) &amp;&amp;</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">                            this.cpath.regionMatches(0, that.cpath, 0, last+1);</span>
                    }
                }
            }
<span class="fc bfc" id="L371" title="All 2 branches covered.">        } else if (that.directory) {</span>
            // if this is NOT recursive/wildcarded,
            // do not let it imply a recursive/wildcarded permission
<span class="fc" id="L374">            return false;</span>
        } else {
<span class="fc" id="L376">            return (this.cpath.equals(that.cpath));</span>
        }
    }

    /**
     * Checks two FilePermission objects for equality. Checks that &lt;i&gt;obj&lt;/i&gt; is
     * a FilePermission, and has the same pathname and actions as this object.
     * &lt;P&gt;
     * @param obj the object we are testing for equality with this object.
     * @return &lt;code&gt;true&lt;/code&gt; if obj is a FilePermission, and has the same
     *          pathname and actions as this FilePermission object,
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L391">            return true;</span>

<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        if (! (obj instanceof FilePermission))</span>
<span class="nc" id="L394">            return false;</span>

<span class="fc" id="L396">        FilePermission that = (FilePermission) obj;</span>

<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        return (this.mask == that.mask) &amp;&amp;</span>
<span class="pc bpc" id="L399" title="3 of 6 branches missed.">            this.cpath.equals(that.cpath) &amp;&amp;</span>
            (this.directory == that.directory) &amp;&amp;
            (this.recursive == that.recursive);
    }

    /**
     * Returns the hash code value for this object.
     *
     * @return a hash code value for this object.
     */
    public int hashCode() {
<span class="nc" id="L410">        return 0;</span>
    }

    /**
     * Converts an actions String to an actions mask.
     *
     * @param actions the action string.
     * @return the actions mask.
     */
    private static int getMask(String actions) {
<span class="fc" id="L420">        int mask = NONE;</span>

        // Null action valid?
<span class="fc bfc" id="L423" title="All 2 branches covered.">        if (actions == null) {</span>
<span class="fc" id="L424">            return mask;</span>
        }

        // Use object identity comparison against known-interned strings for
        // performance benefit (these values are used heavily within the JDK).
<span class="fc bfc" id="L429" title="All 2 branches covered.">        if (actions == SecurityConstants.FILE_READ_ACTION) {</span>
<span class="fc" id="L430">            return READ;</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">        } else if (actions == SecurityConstants.FILE_WRITE_ACTION) {</span>
<span class="fc" id="L432">            return WRITE;</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">        } else if (actions == SecurityConstants.FILE_EXECUTE_ACTION) {</span>
<span class="fc" id="L434">            return EXECUTE;</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">        } else if (actions == SecurityConstants.FILE_DELETE_ACTION) {</span>
<span class="fc" id="L436">            return DELETE;</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">        } else if (actions == SecurityConstants.FILE_READLINK_ACTION) {</span>
<span class="fc" id="L438">            return READLINK;</span>
        }

<span class="fc" id="L441">        char[] a = actions.toCharArray();</span>

<span class="fc" id="L443">        int i = a.length - 1;</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">        if (i &lt; 0)</span>
<span class="fc" id="L445">            return mask;</span>

<span class="fc bfc" id="L447" title="All 2 branches covered.">        while (i != -1) {</span>
            char c;

            // skip whitespace
<span class="pc bpc" id="L451" title="6 of 12 branches missed.">            while ((i!=-1) &amp;&amp; ((c = a[i]) == ' ' ||</span>
                               c == '\r' ||
                               c == '\n' ||
                               c == '\f' ||
                               c == '\t'))
<span class="nc" id="L456">                i--;</span>

            // check for the known strings
            int matchlen;

<span class="pc bpc" id="L461" title="9 of 18 branches missed.">            if (i &gt;= 3 &amp;&amp; (a[i-3] == 'r' || a[i-3] == 'R') &amp;&amp;</span>
                          (a[i-2] == 'e' || a[i-2] == 'E') &amp;&amp;
                          (a[i-1] == 'a' || a[i-1] == 'A') &amp;&amp;
                          (a[i] == 'd' || a[i] == 'D'))
            {
<span class="fc" id="L466">                matchlen = 4;</span>
<span class="fc" id="L467">                mask |= READ;</span>

<span class="pc bpc" id="L469" title="13 of 22 branches missed.">            } else if (i &gt;= 4 &amp;&amp; (a[i-4] == 'w' || a[i-4] == 'W') &amp;&amp;</span>
                                 (a[i-3] == 'r' || a[i-3] == 'R') &amp;&amp;
                                 (a[i-2] == 'i' || a[i-2] == 'I') &amp;&amp;
                                 (a[i-1] == 't' || a[i-1] == 'T') &amp;&amp;
                                 (a[i] == 'e' || a[i] == 'E'))
            {
<span class="fc" id="L475">                matchlen = 5;</span>
<span class="fc" id="L476">                mask |= WRITE;</span>

<span class="pc bpc" id="L478" title="19 of 30 branches missed.">            } else if (i &gt;= 6 &amp;&amp; (a[i-6] == 'e' || a[i-6] == 'E') &amp;&amp;</span>
                                 (a[i-5] == 'x' || a[i-5] == 'X') &amp;&amp;
                                 (a[i-4] == 'e' || a[i-4] == 'E') &amp;&amp;
                                 (a[i-3] == 'c' || a[i-3] == 'C') &amp;&amp;
                                 (a[i-2] == 'u' || a[i-2] == 'U') &amp;&amp;
                                 (a[i-1] == 't' || a[i-1] == 'T') &amp;&amp;
                                 (a[i] == 'e' || a[i] == 'E'))
            {
<span class="fc" id="L486">                matchlen = 7;</span>
<span class="fc" id="L487">                mask |= EXECUTE;</span>

<span class="pc bpc" id="L489" title="16 of 26 branches missed.">            } else if (i &gt;= 5 &amp;&amp; (a[i-5] == 'd' || a[i-5] == 'D') &amp;&amp;</span>
                                 (a[i-4] == 'e' || a[i-4] == 'E') &amp;&amp;
                                 (a[i-3] == 'l' || a[i-3] == 'L') &amp;&amp;
                                 (a[i-2] == 'e' || a[i-2] == 'E') &amp;&amp;
                                 (a[i-1] == 't' || a[i-1] == 'T') &amp;&amp;
                                 (a[i] == 'e' || a[i] == 'E'))
            {
<span class="fc" id="L496">                matchlen = 6;</span>
<span class="fc" id="L497">                mask |= DELETE;</span>

<span class="pc bpc" id="L499" title="30 of 34 branches missed.">            } else if (i &gt;= 7 &amp;&amp; (a[i-7] == 'r' || a[i-7] == 'R') &amp;&amp;</span>
                                 (a[i-6] == 'e' || a[i-6] == 'E') &amp;&amp;
                                 (a[i-5] == 'a' || a[i-5] == 'A') &amp;&amp;
                                 (a[i-4] == 'd' || a[i-4] == 'D') &amp;&amp;
                                 (a[i-3] == 'l' || a[i-3] == 'L') &amp;&amp;
                                 (a[i-2] == 'i' || a[i-2] == 'I') &amp;&amp;
                                 (a[i-1] == 'n' || a[i-1] == 'N') &amp;&amp;
                                 (a[i] == 'k' || a[i] == 'K'))
            {
<span class="nc" id="L508">                matchlen = 8;</span>
<span class="nc" id="L509">                mask |= READLINK;</span>

            } else {
                // parse error
<span class="fc" id="L513">                throw new IllegalArgumentException(</span>
                        &quot;invalid permission: &quot; + actions);
            }

            // make sure we didn't just match the tail of a word
            // like &quot;ackbarfaccept&quot;.  Also, skip to the comma.
<span class="fc" id="L519">            boolean seencomma = false;</span>
<span class="fc bfc" id="L520" title="All 4 branches covered.">            while (i &gt;= matchlen &amp;&amp; !seencomma) {</span>
<span class="pc bpc" id="L521" title="1 of 3 branches missed.">                switch(a[i-matchlen]) {</span>
                case ',':
<span class="fc" id="L523">                    seencomma = true;</span>
<span class="fc" id="L524">                    break;</span>
                case ' ': case '\r': case '\n':
                case '\f': case '\t':
<span class="fc" id="L527">                    break;</span>
                default:
<span class="nc" id="L529">                    throw new IllegalArgumentException(</span>
                            &quot;invalid permission: &quot; + actions);
                }
<span class="fc" id="L532">                i--;</span>
            }

            // point i at the location of the comma minus one (or -1).
<span class="fc" id="L536">            i -= matchlen;</span>
<span class="fc" id="L537">        }</span>

<span class="fc" id="L539">        return mask;</span>
    }

    /**
     * Return the current action mask. Used by the FilePermissionCollection.
     *
     * @return the actions mask.
     */
    int getMask() {
<span class="fc" id="L548">        return mask;</span>
    }

    /**
     * Return the canonical string representation of the actions.
     * Always returns present actions in the following order:
     * read, write, execute, delete, readlink.
     *
     * @return the canonical string representation of the actions.
     */
    private static String getActions(int mask) {
<span class="fc" id="L559">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L560">        boolean comma = false;</span>

<span class="fc bfc" id="L562" title="All 2 branches covered.">        if ((mask &amp; READ) == READ) {</span>
<span class="fc" id="L563">            comma = true;</span>
<span class="fc" id="L564">            sb.append(&quot;read&quot;);</span>
        }

<span class="fc bfc" id="L567" title="All 2 branches covered.">        if ((mask &amp; WRITE) == WRITE) {</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">            if (comma) sb.append(',');</span>
<span class="fc" id="L569">            else comma = true;</span>
<span class="fc" id="L570">            sb.append(&quot;write&quot;);</span>
        }

<span class="fc bfc" id="L573" title="All 2 branches covered.">        if ((mask &amp; EXECUTE) == EXECUTE) {</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">            if (comma) sb.append(',');</span>
<span class="fc" id="L575">            else comma = true;</span>
<span class="fc" id="L576">            sb.append(&quot;execute&quot;);</span>
        }

<span class="fc bfc" id="L579" title="All 2 branches covered.">        if ((mask &amp; DELETE) == DELETE) {</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">            if (comma) sb.append(',');</span>
<span class="nc" id="L581">            else comma = true;</span>
<span class="fc" id="L582">            sb.append(&quot;delete&quot;);</span>
        }

<span class="pc bpc" id="L585" title="1 of 2 branches missed.">        if ((mask &amp; READLINK) == READLINK) {</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">            if (comma) sb.append(',');</span>
<span class="nc" id="L587">            else comma = true;</span>
<span class="nc" id="L588">            sb.append(&quot;readlink&quot;);</span>
        }

<span class="fc" id="L591">        return sb.toString();</span>
    }

    /**
     * Returns the &quot;canonical string representation&quot; of the actions.
     * That is, this method always returns present actions in the following order:
     * read, write, execute, delete, readlink. For example, if this FilePermission
     * object allows both write and read actions, a call to &lt;code&gt;getActions&lt;/code&gt;
     * will return the string &quot;read,write&quot;.
     *
     * @return the canonical string representation of the actions.
     */
    public String getActions() {
<span class="fc bfc" id="L604" title="All 2 branches covered.">        if (actions == null)</span>
<span class="fc" id="L605">            actions = getActions(this.mask);</span>

<span class="fc" id="L607">        return actions;</span>
    }

    /**
     * Returns a new PermissionCollection object for storing FilePermission
     * objects.
     * &lt;p&gt;
     * FilePermission objects must be stored in a manner that allows them
     * to be inserted into the collection in any order, but that also enables the
     * PermissionCollection &lt;code&gt;implies&lt;/code&gt;
     * method to be implemented in an efficient (and consistent) manner.
     *
     * &lt;p&gt;For example, if you have two FilePermissions:
     * &lt;OL&gt;
     * &lt;LI&gt;  &lt;code&gt;&quot;/tmp/-&quot;, &quot;read&quot;&lt;/code&gt;
     * &lt;LI&gt;  &lt;code&gt;&quot;/tmp/scratch/foo&quot;, &quot;write&quot;&lt;/code&gt;
     * &lt;/OL&gt;
     *
     * &lt;p&gt;and you are calling the &lt;code&gt;implies&lt;/code&gt; method with the FilePermission:
     *
     * &lt;pre&gt;
     *   &quot;/tmp/scratch/foo&quot;, &quot;read,write&quot;,
     * &lt;/pre&gt;
     *
     * then the &lt;code&gt;implies&lt;/code&gt; function must
     * take into account both the &quot;/tmp/-&quot; and &quot;/tmp/scratch/foo&quot;
     * permissions, so the effective permission is &quot;read,write&quot;,
     * and &lt;code&gt;implies&lt;/code&gt; returns true. The &quot;implies&quot; semantics for
     * FilePermissions are handled properly by the PermissionCollection object
     * returned by this &lt;code&gt;newPermissionCollection&lt;/code&gt; method.
     *
     * @return a new PermissionCollection object suitable for storing
     * FilePermissions.
     */
    public PermissionCollection newPermissionCollection() {
<span class="fc" id="L642">        return new FilePermissionCollection();</span>
    }

    /**
     * WriteObject is called to save the state of the FilePermission
     * to a stream. The actions are serialized, and the superclass
     * takes care of the name.
     */
    private void writeObject(ObjectOutputStream s)
        throws IOException
    {
        // Write out the actions. The superclass takes care of the name
        // call getActions to make sure actions field is initialized
<span class="nc bnc" id="L655" title="All 2 branches missed.">        if (actions == null)</span>
<span class="nc" id="L656">            getActions();</span>
<span class="nc" id="L657">        s.defaultWriteObject();</span>
<span class="nc" id="L658">    }</span>

    /**
     * readObject is called to restore the state of the FilePermission from
     * a stream.
     */
    private void readObject(ObjectInputStream s)
         throws IOException, ClassNotFoundException
    {
        // Read in the actions, then restore everything else by calling init.
<span class="nc" id="L668">        s.defaultReadObject();</span>
<span class="nc" id="L669">        init(getMask(actions));</span>
<span class="nc" id="L670">    }</span>
}

/**
 * A FilePermissionCollection stores a set of FilePermission permissions.
 * FilePermission objects
 * must be stored in a manner that allows them to be inserted in any
 * order, but enable the implies function to evaluate the implies
 * method.
 * For example, if you have two FilePermissions:
 * &lt;OL&gt;
 * &lt;LI&gt; &quot;/tmp/-&quot;, &quot;read&quot;
 * &lt;LI&gt; &quot;/tmp/scratch/foo&quot;, &quot;write&quot;
 * &lt;/OL&gt;
 * And you are calling the implies function with the FilePermission:
 * &quot;/tmp/scratch/foo&quot;, &quot;read,write&quot;, then the implies function must
 * take into account both the /tmp/- and /tmp/scratch/foo
 * permissions, so the effective permission is &quot;read,write&quot;.
 *
 * @see java.security.Permission
 * @see java.security.Permissions
 * @see java.security.PermissionCollection
 *
 *
 * @author Marianne Mueller
 * @author Roland Schemers
 *
 * @serial include
 *
 */

final class FilePermissionCollection extends PermissionCollection
    implements Serializable
{
    // Not serialized; see serialization section at end of class
    private transient List&lt;Permission&gt; perms;

    /**
     * Create an empty FilePermissionCollection object.
     */
<span class="fc" id="L710">    public FilePermissionCollection() {</span>
<span class="fc" id="L711">        perms = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L712">    }</span>

    /**
     * Adds a permission to the FilePermissionCollection. The key for the hash is
     * permission.path.
     *
     * @param permission the Permission object to add.
     *
     * @exception IllegalArgumentException - if the permission is not a
     *                                       FilePermission
     *
     * @exception SecurityException - if this FilePermissionCollection object
     *                                has been marked readonly
     */
    public void add(Permission permission) {
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">        if (! (permission instanceof FilePermission))</span>
<span class="nc" id="L728">            throw new IllegalArgumentException(&quot;invalid permission: &quot;+</span>
                                               permission);
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">        if (isReadOnly())</span>
<span class="nc" id="L731">            throw new SecurityException(</span>
                &quot;attempt to add a Permission to a readonly PermissionCollection&quot;);

<span class="fc" id="L734">        synchronized (this) {</span>
<span class="fc" id="L735">            perms.add(permission);</span>
<span class="pc" id="L736">        }</span>
<span class="fc" id="L737">    }</span>

    /**
     * Check and see if this set of permissions implies the permissions
     * expressed in &quot;permission&quot;.
     *
     * @param permission the Permission object to compare
     *
     * @return true if &quot;permission&quot; is a proper subset of a permission in
     * the set, false if not.
     */
    public boolean implies(Permission permission) {
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">        if (! (permission instanceof FilePermission))</span>
<span class="nc" id="L750">            return false;</span>

<span class="fc" id="L752">        FilePermission fp = (FilePermission) permission;</span>

<span class="fc" id="L754">        int desired = fp.getMask();</span>
<span class="fc" id="L755">        int effective = 0;</span>
<span class="fc" id="L756">        int needed = desired;</span>

<span class="fc" id="L758">        synchronized (this) {</span>
<span class="fc" id="L759">            int len = perms.size();</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L761">                FilePermission x = (FilePermission) perms.get(i);</span>
<span class="fc bfc" id="L762" title="All 4 branches covered.">                if (((needed &amp; x.getMask()) != 0) &amp;&amp; x.impliesIgnoreMask(fp)) {</span>
<span class="fc" id="L763">                    effective |=  x.getMask();</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">                    if ((effective &amp; desired) == desired)</span>
<span class="fc" id="L765">                        return true;</span>
<span class="nc" id="L766">                    needed = (desired ^ effective);</span>
                }
            }
<span class="pc" id="L769">        }</span>
<span class="fc" id="L770">        return false;</span>
    }

    /**
     * Returns an enumeration of all the FilePermission objects in the
     * container.
     *
     * @return an enumeration of all the FilePermission objects.
     */
    public Enumeration&lt;Permission&gt; elements() {
        // Convert Iterator into Enumeration
<span class="fc" id="L781">        synchronized (this) {</span>
<span class="fc" id="L782">            return Collections.enumeration(perms);</span>
<span class="nc" id="L783">        }</span>
    }

    private static final long serialVersionUID = 2202956749081564585L;

    // Need to maintain serialization interoperability with earlier releases,
    // which had the serializable field:
    //    private Vector permissions;

    /**
     * @serialField permissions java.util.Vector
     *     A list of FilePermission objects.
     */
<span class="fc" id="L796">    private static final ObjectStreamField[] serialPersistentFields = {</span>
        new ObjectStreamField(&quot;permissions&quot;, Vector.class),
    };

    /**
     * @serialData &quot;permissions&quot; field (a Vector containing the FilePermissions).
     */
    /*
     * Writes the contents of the perms field out as a Vector for
     * serialization compatibility with earlier releases.
     */
    private void writeObject(ObjectOutputStream out) throws IOException {
        // Don't call out.defaultWriteObject()

        // Write out Vector
<span class="nc" id="L811">        Vector&lt;Permission&gt; permissions = new Vector&lt;&gt;(perms.size());</span>
<span class="nc" id="L812">        synchronized (this) {</span>
<span class="nc" id="L813">            permissions.addAll(perms);</span>
<span class="nc" id="L814">        }</span>

<span class="nc" id="L816">        ObjectOutputStream.PutField pfields = out.putFields();</span>
<span class="nc" id="L817">        pfields.put(&quot;permissions&quot;, permissions);</span>
<span class="nc" id="L818">        out.writeFields();</span>
<span class="nc" id="L819">    }</span>

    /*
     * Reads in a Vector of FilePermissions and saves them in the perms field.
     */
    private void readObject(ObjectInputStream in)
        throws IOException, ClassNotFoundException
    {
        // Don't call defaultReadObject()

        // Read in serialized fields
<span class="nc" id="L830">        ObjectInputStream.GetField gfields = in.readFields();</span>

        // Get the one we want
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L834">        Vector&lt;Permission&gt; permissions = (Vector&lt;Permission&gt;)gfields.get(&quot;permissions&quot;, null);</span>
<span class="nc" id="L835">        perms = new ArrayList&lt;&gt;(permissions.size());</span>
<span class="nc" id="L836">        perms.addAll(permissions);</span>
<span class="nc" id="L837">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>