<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ObjectOutputStream.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.io</a> &gt; <span class="el_source">ObjectOutputStream.java</span></div><h1>ObjectOutputStream.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.io;

import java.io.ObjectStreamClass.WeakClassKey;
import java.lang.ref.ReferenceQueue;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import static java.io.ObjectStreamClass.processQueue;
import java.io.SerialCallbackContext;
import sun.reflect.misc.ReflectUtil;

/**
 * An ObjectOutputStream writes primitive data types and graphs of Java objects
 * to an OutputStream.  The objects can be read (reconstituted) using an
 * ObjectInputStream.  Persistent storage of objects can be accomplished by
 * using a file for the stream.  If the stream is a network socket stream, the
 * objects can be reconstituted on another host or in another process.
 *
 * &lt;p&gt;Only objects that support the java.io.Serializable interface can be
 * written to streams.  The class of each serializable object is encoded
 * including the class name and signature of the class, the values of the
 * object's fields and arrays, and the closure of any other objects referenced
 * from the initial objects.
 *
 * &lt;p&gt;The method writeObject is used to write an object to the stream.  Any
 * object, including Strings and arrays, is written with writeObject. Multiple
 * objects or primitives can be written to the stream.  The objects must be
 * read back from the corresponding ObjectInputstream with the same types and
 * in the same order as they were written.
 *
 * &lt;p&gt;Primitive data types can also be written to the stream using the
 * appropriate methods from DataOutput. Strings can also be written using the
 * writeUTF method.
 *
 * &lt;p&gt;The default serialization mechanism for an object writes the class of the
 * object, the class signature, and the values of all non-transient and
 * non-static fields.  References to other objects (except in transient or
 * static fields) cause those objects to be written also. Multiple references
 * to a single object are encoded using a reference sharing mechanism so that
 * graphs of objects can be restored to the same shape as when the original was
 * written.
 *
 * &lt;p&gt;For example to write an object that can be read by the example in
 * ObjectInputStream:
 * &lt;br&gt;
 * &lt;pre&gt;
 *      FileOutputStream fos = new FileOutputStream(&quot;t.tmp&quot;);
 *      ObjectOutputStream oos = new ObjectOutputStream(fos);
 *
 *      oos.writeInt(12345);
 *      oos.writeObject(&quot;Today&quot;);
 *      oos.writeObject(new Date());
 *
 *      oos.close();
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Classes that require special handling during the serialization and
 * deserialization process must implement special methods with these exact
 * signatures:
 * &lt;br&gt;
 * &lt;pre&gt;
 * private void readObject(java.io.ObjectInputStream stream)
 *     throws IOException, ClassNotFoundException;
 * private void writeObject(java.io.ObjectOutputStream stream)
 *     throws IOException
 * private void readObjectNoData()
 *     throws ObjectStreamException;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;The writeObject method is responsible for writing the state of the object
 * for its particular class so that the corresponding readObject method can
 * restore it.  The method does not need to concern itself with the state
 * belonging to the object's superclasses or subclasses.  State is saved by
 * writing the individual fields to the ObjectOutputStream using the
 * writeObject method or by using the methods for primitive data types
 * supported by DataOutput.
 *
 * &lt;p&gt;Serialization does not write out the fields of any object that does not
 * implement the java.io.Serializable interface.  Subclasses of Objects that
 * are not serializable can be serializable. In this case the non-serializable
 * class must have a no-arg constructor to allow its fields to be initialized.
 * In this case it is the responsibility of the subclass to save and restore
 * the state of the non-serializable class. It is frequently the case that the
 * fields of that class are accessible (public, package, or protected) or that
 * there are get and set methods that can be used to restore the state.
 *
 * &lt;p&gt;Serialization of an object can be prevented by implementing writeObject
 * and readObject methods that throw the NotSerializableException.  The
 * exception will be caught by the ObjectOutputStream and abort the
 * serialization process.
 *
 * &lt;p&gt;Implementing the Externalizable interface allows the object to assume
 * complete control over the contents and format of the object's serialized
 * form.  The methods of the Externalizable interface, writeExternal and
 * readExternal, are called to save and restore the objects state.  When
 * implemented by a class they can write and read their own state using all of
 * the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 * the objects to handle any versioning that occurs.
 *
 * &lt;p&gt;Enum constants are serialized differently than ordinary serializable or
 * externalizable objects.  The serialized form of an enum constant consists
 * solely of its name; field values of the constant are not transmitted.  To
 * serialize an enum constant, ObjectOutputStream writes the string returned by
 * the constant's name method.  Like other serializable or externalizable
 * objects, enum constants can function as the targets of back references
 * appearing subsequently in the serialization stream.  The process by which
 * enum constants are serialized cannot be customized; any class-specific
 * writeObject and writeReplace methods defined by enum types are ignored
 * during serialization.  Similarly, any serialPersistentFields or
 * serialVersionUID field declarations are also ignored--all enum types have a
 * fixed serialVersionUID of 0L.
 *
 * &lt;p&gt;Primitive data, excluding serializable fields and externalizable data, is
 * written to the ObjectOutputStream in block-data records. A block data record
 * is composed of a header and data. The block data header consists of a marker
 * and the number of bytes to follow the header.  Consecutive primitive data
 * writes are merged into one block-data record.  The blocking factor used for
 * a block-data record will be 1024 bytes.  Each block-data record will be
 * filled up to 1024 bytes, or be written whenever there is a termination of
 * block-data mode.  Calls to the ObjectOutputStream methods writeObject,
 * defaultWriteObject and writeFields initially terminate any existing
 * block-data record.
 *
 * @author      Mike Warres
 * @author      Roger Riggs
 * @see java.io.DataOutput
 * @see java.io.ObjectInputStream
 * @see java.io.Serializable
 * @see java.io.Externalizable
 * @see &lt;a href=&quot;../../../platform/serialization/spec/output.html&quot;&gt;Object Serialization Specification, Section 2, Object Output Classes&lt;/a&gt;
 * @since       JDK1.1
 */
public class ObjectOutputStream
    extends OutputStream implements ObjectOutput, ObjectStreamConstants
{

<span class="nc" id="L166">    private static class Caches {</span>
        /** cache of subclass security audit results */
<span class="fc" id="L168">        static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =</span>
            new ConcurrentHashMap&lt;&gt;();

        /** queue for WeakReferences to audited subclasses */
<span class="fc" id="L172">        static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =</span>
            new ReferenceQueue&lt;&gt;();
    }

    /** filter stream for handling block data conversion */
    private final BlockDataOutputStream bout;
    /** obj -&gt; wire handle map */
    private final HandleTable handles;
    /** obj -&gt; replacement obj map */
    private final ReplaceTable subs;
    /** stream protocol version */
<span class="pc" id="L183">    private int protocol = PROTOCOL_VERSION_2;</span>
    /** recursion depth */
    private int depth;

    /** buffer for writing primitive field values */
    private byte[] primVals;

    /** if true, invoke writeObjectOverride() instead of writeObject() */
    private final boolean enableOverride;
    /** if true, invoke replaceObject() */
    private boolean enableReplace;

    // values below valid only during upcalls to writeObject()/writeExternal()
    /**
     * Context during upcalls to class-defined writeObject methods; holds
     * object currently being serialized and descriptor for current class.
     * Null when not during writeObject upcall.
     */
    private SerialCallbackContext curContext;
    /** current PutField object */
    private PutFieldImpl curPut;

    /** custom storage for debug trace info */
    private final DebugTraceInfoStack debugInfoStack;

    /**
     * value of &quot;sun.io.serialization.extendedDebugInfo&quot; property,
     * as true or false for extended information about exception's place
     */
<span class="fc" id="L212">    private static final boolean extendedDebugInfo =</span>
<span class="fc" id="L213">        java.security.AccessController.doPrivileged(</span>
            new sun.security.action.GetBooleanAction(
<span class="fc" id="L215">                &quot;sun.io.serialization.extendedDebugInfo&quot;)).booleanValue();</span>

    /**
     * Creates an ObjectOutputStream that writes to the specified OutputStream.
     * This constructor writes the serialization stream header to the
     * underlying stream; callers may wish to flush the stream immediately to
     * ensure that constructors for receiving ObjectInputStreams will not block
     * when reading the header.
     *
     * &lt;p&gt;If a security manager is installed, this constructor will check for
     * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
     * directly or indirectly by the constructor of a subclass which overrides
     * the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared
     * methods.
     *
     * @param   out output stream to write to
     * @throws  IOException if an I/O error occurs while writing stream header
     * @throws  SecurityException if untrusted subclass illegally overrides
     *          security-sensitive methods
     * @throws  NullPointerException if &lt;code&gt;out&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @since   1.4
     * @see     ObjectOutputStream#ObjectOutputStream()
     * @see     ObjectOutputStream#putFields()
     * @see     ObjectInputStream#ObjectInputStream(InputStream)
     */
<span class="fc" id="L240">    public ObjectOutputStream(OutputStream out) throws IOException {</span>
<span class="fc" id="L241">        verifySubclass();</span>
<span class="fc" id="L242">        bout = new BlockDataOutputStream(out);</span>
<span class="fc" id="L243">        handles = new HandleTable(10, (float) 3.00);</span>
<span class="fc" id="L244">        subs = new ReplaceTable(10, (float) 3.00);</span>
<span class="fc" id="L245">        enableOverride = false;</span>
<span class="fc" id="L246">        writeStreamHeader();</span>
<span class="fc" id="L247">        bout.setBlockDataMode(true);</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (extendedDebugInfo) {</span>
<span class="nc" id="L249">            debugInfoStack = new DebugTraceInfoStack();</span>
        } else {
<span class="fc" id="L251">            debugInfoStack = null;</span>
        }
<span class="fc" id="L253">    }</span>

    /**
     * Provide a way for subclasses that are completely reimplementing
     * ObjectOutputStream to not have to allocate private data just used by
     * this implementation of ObjectOutputStream.
     *
     * &lt;p&gt;If there is a security manager installed, this method first calls the
     * security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a
     * &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt;
     * permission to ensure it's ok to enable subclassing.
     *
     * @throws  SecurityException if a security manager exists and its
     *          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling
     *          subclassing.
     * @throws  IOException if an I/O error occurs while creating this stream
     * @see SecurityManager#checkPermission
     * @see java.io.SerializablePermission
     */
<span class="nc" id="L272">    protected ObjectOutputStream() throws IOException, SecurityException {</span>
<span class="nc" id="L273">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L275">            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span>
        }
<span class="nc" id="L277">        bout = null;</span>
<span class="nc" id="L278">        handles = null;</span>
<span class="nc" id="L279">        subs = null;</span>
<span class="nc" id="L280">        enableOverride = true;</span>
<span class="nc" id="L281">        debugInfoStack = null;</span>
<span class="nc" id="L282">    }</span>

    /**
     * Specify stream protocol version to use when writing the stream.
     *
     * &lt;p&gt;This routine provides a hook to enable the current version of
     * Serialization to write in a format that is backwards compatible to a
     * previous version of the stream format.
     *
     * &lt;p&gt;Every effort will be made to avoid introducing additional
     * backwards incompatibilities; however, sometimes there is no
     * other alternative.
     *
     * @param   version use ProtocolVersion from java.io.ObjectStreamConstants.
     * @throws  IllegalStateException if called after any objects
     *          have been serialized.
     * @throws  IllegalArgumentException if invalid version is passed in.
     * @throws  IOException if I/O errors occur
     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1
     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_2
     * @since   1.2
     */
    public void useProtocolVersion(int version) throws IOException {
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        if (handles.size() != 0) {</span>
            // REMIND: implement better check for pristine stream?
<span class="nc" id="L307">            throw new IllegalStateException(&quot;stream non-empty&quot;);</span>
        }
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        switch (version) {</span>
            case PROTOCOL_VERSION_1:
            case PROTOCOL_VERSION_2:
<span class="fc" id="L312">                protocol = version;</span>
<span class="fc" id="L313">                break;</span>

            default:
<span class="nc" id="L316">                throw new IllegalArgumentException(</span>
                    &quot;unknown version: &quot; + version);
        }
<span class="fc" id="L319">    }</span>

    /**
     * Write the specified object to the ObjectOutputStream.  The class of the
     * object, the signature of the class, and the values of the non-transient
     * and non-static fields of the class and all of its supertypes are
     * written.  Default serialization for a class can be overridden using the
     * writeObject and the readObject methods.  Objects referenced by this
     * object are written transitively so that a complete equivalent graph of
     * objects can be reconstructed by an ObjectInputStream.
     *
     * &lt;p&gt;Exceptions are thrown for problems with the OutputStream and for
     * classes that should not be serialized.  All exceptions are fatal to the
     * OutputStream, which is left in an indeterminate state, and it is up to
     * the caller to ignore or recover the stream state.
     *
     * @throws  InvalidClassException Something is wrong with a class used by
     *          serialization.
     * @throws  NotSerializableException Some object to be serialized does not
     *          implement the java.io.Serializable interface.
     * @throws  IOException Any exception thrown by the underlying
     *          OutputStream.
     */
    public final void writeObject(Object obj) throws IOException {
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        if (enableOverride) {</span>
<span class="nc" id="L344">            writeObjectOverride(obj);</span>
<span class="nc" id="L345">            return;</span>
        }
        try {
<span class="fc" id="L348">            writeObject0(obj, false);</span>
<span class="fc" id="L349">        } catch (IOException ex) {</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if (depth == 0) {</span>
<span class="fc" id="L351">                writeFatalException(ex);</span>
            }
<span class="fc" id="L353">            throw ex;</span>
<span class="fc" id="L354">        }</span>
<span class="fc" id="L355">    }</span>

    /**
     * Method used by subclasses to override the default writeObject method.
     * This method is called by trusted subclasses of ObjectInputStream that
     * constructed ObjectInputStream using the protected no-arg constructor.
     * The subclass is expected to provide an override method with the modifier
     * &quot;final&quot;.
     *
     * @param   obj object to be written to the underlying stream
     * @throws  IOException if there are I/O errors while writing to the
     *          underlying stream
     * @see #ObjectOutputStream()
     * @see #writeObject(Object)
     * @since 1.2
     */
    protected void writeObjectOverride(Object obj) throws IOException {
<span class="nc" id="L372">    }</span>

    /**
     * Writes an &quot;unshared&quot; object to the ObjectOutputStream.  This method is
     * identical to writeObject, except that it always writes the given object
     * as a new, unique object in the stream (as opposed to a back-reference
     * pointing to a previously serialized instance).  Specifically:
     * &lt;ul&gt;
     *   &lt;li&gt;An object written via writeUnshared is always serialized in the
     *       same manner as a newly appearing object (an object that has not
     *       been written to the stream yet), regardless of whether or not the
     *       object has been written previously.
     *
     *   &lt;li&gt;If writeObject is used to write an object that has been previously
     *       written with writeUnshared, the previous writeUnshared operation
     *       is treated as if it were a write of a separate object.  In other
     *       words, ObjectOutputStream will never generate back-references to
     *       object data written by calls to writeUnshared.
     * &lt;/ul&gt;
     * While writing an object via writeUnshared does not in itself guarantee a
     * unique reference to the object when it is deserialized, it allows a
     * single object to be defined multiple times in a stream, so that multiple
     * calls to readUnshared by the receiver will not conflict.  Note that the
     * rules described above only apply to the base-level object written with
     * writeUnshared, and not to any transitively referenced sub-objects in the
     * object graph to be serialized.
     *
     * &lt;p&gt;ObjectOutputStream subclasses which override this method can only be
     * constructed in security contexts possessing the
     * &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
     * instantiate such a subclass without this permission will cause a
     * SecurityException to be thrown.
     *
     * @param   obj object to write to stream
     * @throws  NotSerializableException if an object in the graph to be
     *          serialized does not implement the Serializable interface
     * @throws  InvalidClassException if a problem exists with the class of an
     *          object to be serialized
     * @throws  IOException if an I/O error occurs during serialization
     * @since 1.4
     */
    public void writeUnshared(Object obj) throws IOException {
        try {
<span class="fc" id="L415">            writeObject0(obj, true);</span>
<span class="nc" id="L416">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (depth == 0) {</span>
<span class="nc" id="L418">                writeFatalException(ex);</span>
            }
<span class="nc" id="L420">            throw ex;</span>
<span class="fc" id="L421">        }</span>
<span class="fc" id="L422">    }</span>

    /**
     * Write the non-static and non-transient fields of the current class to
     * this stream.  This may only be called from the writeObject method of the
     * class being serialized. It will throw the NotActiveException if it is
     * called otherwise.
     *
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          &lt;code&gt;OutputStream&lt;/code&gt;
     */
    public void defaultWriteObject() throws IOException {
<span class="fc" id="L434">        SerialCallbackContext ctx = curContext;</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        if (ctx == null) {</span>
<span class="nc" id="L436">            throw new NotActiveException(&quot;not in call to writeObject&quot;);</span>
        }
<span class="fc" id="L438">        Object curObj = ctx.getObj();</span>
<span class="fc" id="L439">        ObjectStreamClass curDesc = ctx.getDesc();</span>
<span class="fc" id="L440">        bout.setBlockDataMode(false);</span>
<span class="fc" id="L441">        defaultWriteFields(curObj, curDesc);</span>
<span class="fc" id="L442">        bout.setBlockDataMode(true);</span>
<span class="fc" id="L443">    }</span>

    /**
     * Retrieve the object used to buffer persistent fields to be written to
     * the stream.  The fields will be written to the stream when writeFields
     * method is called.
     *
     * @return  an instance of the class Putfield that holds the serializable
     *          fields
     * @throws  IOException if I/O errors occur
     * @since 1.2
     */
    public ObjectOutputStream.PutField putFields() throws IOException {
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (curPut == null) {</span>
<span class="fc" id="L457">            SerialCallbackContext ctx = curContext;</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">            if (ctx == null) {</span>
<span class="nc" id="L459">                throw new NotActiveException(&quot;not in call to writeObject&quot;);</span>
            }
<span class="fc" id="L461">            Object curObj = ctx.getObj();</span>
<span class="fc" id="L462">            ObjectStreamClass curDesc = ctx.getDesc();</span>
<span class="fc" id="L463">            curPut = new PutFieldImpl(curDesc);</span>
        }
<span class="fc" id="L465">        return curPut;</span>
    }

    /**
     * Write the buffered fields to the stream.
     *
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     * @throws  NotActiveException Called when a classes writeObject method was
     *          not called to write the state of the object.
     * @since 1.2
     */
    public void writeFields() throws IOException {
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">        if (curPut == null) {</span>
<span class="nc" id="L479">            throw new NotActiveException(&quot;no current PutField object&quot;);</span>
        }
<span class="fc" id="L481">        bout.setBlockDataMode(false);</span>
<span class="fc" id="L482">        curPut.writeFields();</span>
<span class="fc" id="L483">        bout.setBlockDataMode(true);</span>
<span class="fc" id="L484">    }</span>

    /**
     * Reset will disregard the state of any objects already written to the
     * stream.  The state is reset to be the same as a new ObjectOutputStream.
     * The current point in the stream is marked as reset so the corresponding
     * ObjectInputStream will be reset at the same point.  Objects previously
     * written to the stream will not be referred to as already being in the
     * stream.  They will be written to the stream again.
     *
     * @throws  IOException if reset() is invoked while serializing an object.
     */
    public void reset() throws IOException {
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">        if (depth != 0) {</span>
<span class="nc" id="L498">            throw new IOException(&quot;stream active&quot;);</span>
        }
<span class="fc" id="L500">        bout.setBlockDataMode(false);</span>
<span class="fc" id="L501">        bout.writeByte(TC_RESET);</span>
<span class="fc" id="L502">        clear();</span>
<span class="fc" id="L503">        bout.setBlockDataMode(true);</span>
<span class="fc" id="L504">    }</span>

    /**
     * Subclasses may implement this method to allow class data to be stored in
     * the stream. By default this method does nothing.  The corresponding
     * method in ObjectInputStream is resolveClass.  This method is called
     * exactly once for each unique class in the stream.  The class name and
     * signature will have already been written to the stream.  This method may
     * make free use of the ObjectOutputStream to save any representation of
     * the class it deems suitable (for example, the bytes of the class file).
     * The resolveClass method in the corresponding subclass of
     * ObjectInputStream must read and use any data or objects written by
     * annotateClass.
     *
     * @param   cl the class to annotate custom data for
     * @throws  IOException Any exception thrown by the underlying
     *          OutputStream.
     */
    protected void annotateClass(Class&lt;?&gt; cl) throws IOException {
<span class="fc" id="L523">    }</span>

    /**
     * Subclasses may implement this method to store custom data in the stream
     * along with descriptors for dynamic proxy classes.
     *
     * &lt;p&gt;This method is called exactly once for each unique proxy class
     * descriptor in the stream.  The default implementation of this method in
     * &lt;code&gt;ObjectOutputStream&lt;/code&gt; does nothing.
     *
     * &lt;p&gt;The corresponding method in &lt;code&gt;ObjectInputStream&lt;/code&gt; is
     * &lt;code&gt;resolveProxyClass&lt;/code&gt;.  For a given subclass of
     * &lt;code&gt;ObjectOutputStream&lt;/code&gt; that overrides this method, the
     * &lt;code&gt;resolveProxyClass&lt;/code&gt; method in the corresponding subclass of
     * &lt;code&gt;ObjectInputStream&lt;/code&gt; must read any data or objects written by
     * &lt;code&gt;annotateProxyClass&lt;/code&gt;.
     *
     * @param   cl the proxy class to annotate custom data for
     * @throws  IOException any exception thrown by the underlying
     *          &lt;code&gt;OutputStream&lt;/code&gt;
     * @see ObjectInputStream#resolveProxyClass(String[])
     * @since   1.3
     */
    protected void annotateProxyClass(Class&lt;?&gt; cl) throws IOException {
<span class="fc" id="L547">    }</span>

    /**
     * This method will allow trusted subclasses of ObjectOutputStream to
     * substitute one object for another during serialization. Replacing
     * objects is disabled until enableReplaceObject is called. The
     * enableReplaceObject method checks that the stream requesting to do
     * replacement can be trusted.  The first occurrence of each object written
     * into the serialization stream is passed to replaceObject.  Subsequent
     * references to the object are replaced by the object returned by the
     * original call to replaceObject.  To ensure that the private state of
     * objects is not unintentionally exposed, only trusted streams may use
     * replaceObject.
     *
     * &lt;p&gt;The ObjectOutputStream.writeObject method takes a parameter of type
     * Object (as opposed to type Serializable) to allow for cases where
     * non-serializable objects are replaced by serializable ones.
     *
     * &lt;p&gt;When a subclass is replacing objects it must insure that either a
     * complementary substitution must be made during deserialization or that
     * the substituted object is compatible with every field where the
     * reference will be stored.  Objects whose type is not a subclass of the
     * type of the field or array element abort the serialization by raising an
     * exception and the object is not be stored.
     *
     * &lt;p&gt;This method is called only once when each object is first
     * encountered.  All subsequent references to the object will be redirected
     * to the new object. This method should return the object to be
     * substituted or the original object.
     *
     * &lt;p&gt;Null can be returned as the object to be substituted, but may cause
     * NullReferenceException in classes that contain references to the
     * original object since they may be expecting an object instead of
     * null.
     *
     * @param   obj the object to be replaced
     * @return  the alternate object that replaced the specified one
     * @throws  IOException Any exception thrown by the underlying
     *          OutputStream.
     */
    protected Object replaceObject(Object obj) throws IOException {
<span class="nc" id="L588">        return obj;</span>
    }

    /**
     * Enable the stream to do replacement of objects in the stream.  When
     * enabled, the replaceObject method is called for every object being
     * serialized.
     *
     * &lt;p&gt;If &lt;code&gt;enable&lt;/code&gt; is true, and there is a security manager
     * installed, this method first calls the security manager's
     * &lt;code&gt;checkPermission&lt;/code&gt; method with a
     * &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to
     * ensure it's ok to enable the stream to do replacement of objects in the
     * stream.
     *
     * @param   enable boolean parameter to enable replacement of objects
     * @return  the previous setting before this method was invoked
     * @throws  SecurityException if a security manager exists and its
     *          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling the stream
     *          to do replacement of objects in the stream.
     * @see SecurityManager#checkPermission
     * @see java.io.SerializablePermission
     */
    protected boolean enableReplaceObject(boolean enable)
        throws SecurityException
    {
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">        if (enable == enableReplace) {</span>
<span class="nc" id="L615">            return enable;</span>
        }
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">        if (enable) {</span>
<span class="fc" id="L618">            SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">            if (sm != null) {</span>
<span class="fc" id="L620">                sm.checkPermission(SUBSTITUTION_PERMISSION);</span>
            }
        }
<span class="fc" id="L623">        enableReplace = enable;</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">        return !enableReplace;</span>
    }

    /**
     * The writeStreamHeader method is provided so subclasses can append or
     * prepend their own header to the stream.  It writes the magic number and
     * version to the stream.
     *
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    protected void writeStreamHeader() throws IOException {
<span class="fc" id="L636">        bout.writeShort(STREAM_MAGIC);</span>
<span class="fc" id="L637">        bout.writeShort(STREAM_VERSION);</span>
<span class="fc" id="L638">    }</span>

    /**
     * Write the specified class descriptor to the ObjectOutputStream.  Class
     * descriptors are used to identify the classes of objects written to the
     * stream.  Subclasses of ObjectOutputStream may override this method to
     * customize the way in which class descriptors are written to the
     * serialization stream.  The corresponding method in ObjectInputStream,
     * &lt;code&gt;readClassDescriptor&lt;/code&gt;, should then be overridden to
     * reconstitute the class descriptor from its custom stream representation.
     * By default, this method writes class descriptors according to the format
     * defined in the Object Serialization specification.
     *
     * &lt;p&gt;Note that this method will only be called if the ObjectOutputStream
     * is not using the old serialization stream format (set by calling
     * ObjectOutputStream's &lt;code&gt;useProtocolVersion&lt;/code&gt; method).  If this
     * serialization stream is using the old format
     * (&lt;code&gt;PROTOCOL_VERSION_1&lt;/code&gt;), the class descriptor will be written
     * internally in a manner that cannot be overridden or customized.
     *
     * @param   desc class descriptor to write to the stream
     * @throws  IOException If an I/O error has occurred.
     * @see java.io.ObjectInputStream#readClassDescriptor()
     * @see #useProtocolVersion(int)
     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1
     * @since 1.3
     */
    protected void writeClassDescriptor(ObjectStreamClass desc)
        throws IOException
    {
<span class="fc" id="L668">        desc.writeNonProxy(this);</span>
<span class="fc" id="L669">    }</span>

    /**
     * Writes a byte. This method will block until the byte is actually
     * written.
     *
     * @param   val the byte to be written to the stream
     * @throws  IOException If an I/O error has occurred.
     */
    public void write(int val) throws IOException {
<span class="nc" id="L679">        bout.write(val);</span>
<span class="nc" id="L680">    }</span>

    /**
     * Writes an array of bytes. This method will block until the bytes are
     * actually written.
     *
     * @param   buf the data to be written
     * @throws  IOException If an I/O error has occurred.
     */
    public void write(byte[] buf) throws IOException {
<span class="fc" id="L690">        bout.write(buf, 0, buf.length, false);</span>
<span class="fc" id="L691">    }</span>

    /**
     * Writes a sub array of bytes.
     *
     * @param   buf the data to be written
     * @param   off the start offset in the data
     * @param   len the number of bytes that are written
     * @throws  IOException If an I/O error has occurred.
     */
    public void write(byte[] buf, int off, int len) throws IOException {
<span class="fc bfc" id="L702" title="All 2 branches covered.">        if (buf == null) {</span>
<span class="fc" id="L703">            throw new NullPointerException();</span>
        }
<span class="fc" id="L705">        int endoff = off + len;</span>
<span class="fc bfc" id="L706" title="All 8 branches covered.">        if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {</span>
<span class="fc" id="L707">            throw new IndexOutOfBoundsException();</span>
        }
<span class="fc" id="L709">        bout.write(buf, off, len, false);</span>
<span class="fc" id="L710">    }</span>

    /**
     * Flushes the stream. This will write any buffered output bytes and flush
     * through to the underlying stream.
     *
     * @throws  IOException If an I/O error has occurred.
     */
    public void flush() throws IOException {
<span class="fc" id="L719">        bout.flush();</span>
<span class="fc" id="L720">    }</span>

    /**
     * Drain any buffered data in ObjectOutputStream.  Similar to flush but
     * does not propagate the flush to the underlying stream.
     *
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    protected void drain() throws IOException {
<span class="nc" id="L730">        bout.drain();</span>
<span class="nc" id="L731">    }</span>

    /**
     * Closes the stream. This method must be called to release any resources
     * associated with the stream.
     *
     * @throws  IOException If an I/O error has occurred.
     */
    public void close() throws IOException {
<span class="fc" id="L740">        flush();</span>
<span class="fc" id="L741">        clear();</span>
<span class="fc" id="L742">        bout.close();</span>
<span class="fc" id="L743">    }</span>

    /**
     * Writes a boolean.
     *
     * @param   val the boolean to be written
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    public void writeBoolean(boolean val) throws IOException {
<span class="fc" id="L753">        bout.writeBoolean(val);</span>
<span class="fc" id="L754">    }</span>

    /**
     * Writes an 8 bit byte.
     *
     * @param   val the byte value to be written
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    public void writeByte(int val) throws IOException  {
<span class="fc" id="L764">        bout.writeByte(val);</span>
<span class="fc" id="L765">    }</span>

    /**
     * Writes a 16 bit short.
     *
     * @param   val the short value to be written
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    public void writeShort(int val)  throws IOException {
<span class="fc" id="L775">        bout.writeShort(val);</span>
<span class="fc" id="L776">    }</span>

    /**
     * Writes a 16 bit char.
     *
     * @param   val the char value to be written
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    public void writeChar(int val)  throws IOException {
<span class="fc" id="L786">        bout.writeChar(val);</span>
<span class="fc" id="L787">    }</span>

    /**
     * Writes a 32 bit int.
     *
     * @param   val the integer value to be written
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    public void writeInt(int val)  throws IOException {
<span class="fc" id="L797">        bout.writeInt(val);</span>
<span class="fc" id="L798">    }</span>

    /**
     * Writes a 64 bit long.
     *
     * @param   val the long value to be written
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    public void writeLong(long val)  throws IOException {
<span class="fc" id="L808">        bout.writeLong(val);</span>
<span class="fc" id="L809">    }</span>

    /**
     * Writes a 32 bit float.
     *
     * @param   val the float value to be written
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    public void writeFloat(float val) throws IOException {
<span class="fc" id="L819">        bout.writeFloat(val);</span>
<span class="fc" id="L820">    }</span>

    /**
     * Writes a 64 bit double.
     *
     * @param   val the double value to be written
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    public void writeDouble(double val) throws IOException {
<span class="fc" id="L830">        bout.writeDouble(val);</span>
<span class="fc" id="L831">    }</span>

    /**
     * Writes a String as a sequence of bytes.
     *
     * @param   str the String of bytes to be written
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    public void writeBytes(String str) throws IOException {
<span class="nc" id="L841">        bout.writeBytes(str);</span>
<span class="nc" id="L842">    }</span>

    /**
     * Writes a String as a sequence of chars.
     *
     * @param   str the String of chars to be written
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    public void writeChars(String str) throws IOException {
<span class="nc" id="L852">        bout.writeChars(str);</span>
<span class="nc" id="L853">    }</span>

    /**
     * Primitive data write of this String in
     * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
     * format.  Note that there is a
     * significant difference between writing a String into the stream as
     * primitive data or as an Object. A String instance written by writeObject
     * is written into the stream as a String initially. Future writeObject()
     * calls write references to the string into the stream.
     *
     * @param   str the String to be written
     * @throws  IOException if I/O errors occur while writing to the underlying
     *          stream
     */
    public void writeUTF(String str) throws IOException {
<span class="fc" id="L869">        bout.writeUTF(str);</span>
<span class="fc" id="L870">    }</span>

    /**
     * Provide programmatic access to the persistent fields to be written
     * to ObjectOutput.
     *
     * @since 1.2
     */
<span class="fc" id="L878">    public static abstract class PutField {</span>

        /**
         * Put the value of the named boolean field into the persistent field.
         *
         * @param  name the name of the serializable field
         * @param  val the value to assign to the field
         * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         * match the name of a serializable field for the class whose fields
         * are being written, or if the type of the named field is not
         * &lt;code&gt;boolean&lt;/code&gt;
         */
        public abstract void put(String name, boolean val);

        /**
         * Put the value of the named byte field into the persistent field.
         *
         * @param  name the name of the serializable field
         * @param  val the value to assign to the field
         * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         * match the name of a serializable field for the class whose fields
         * are being written, or if the type of the named field is not
         * &lt;code&gt;byte&lt;/code&gt;
         */
        public abstract void put(String name, byte val);

        /**
         * Put the value of the named char field into the persistent field.
         *
         * @param  name the name of the serializable field
         * @param  val the value to assign to the field
         * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         * match the name of a serializable field for the class whose fields
         * are being written, or if the type of the named field is not
         * &lt;code&gt;char&lt;/code&gt;
         */
        public abstract void put(String name, char val);

        /**
         * Put the value of the named short field into the persistent field.
         *
         * @param  name the name of the serializable field
         * @param  val the value to assign to the field
         * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         * match the name of a serializable field for the class whose fields
         * are being written, or if the type of the named field is not
         * &lt;code&gt;short&lt;/code&gt;
         */
        public abstract void put(String name, short val);

        /**
         * Put the value of the named int field into the persistent field.
         *
         * @param  name the name of the serializable field
         * @param  val the value to assign to the field
         * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         * match the name of a serializable field for the class whose fields
         * are being written, or if the type of the named field is not
         * &lt;code&gt;int&lt;/code&gt;
         */
        public abstract void put(String name, int val);

        /**
         * Put the value of the named long field into the persistent field.
         *
         * @param  name the name of the serializable field
         * @param  val the value to assign to the field
         * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         * match the name of a serializable field for the class whose fields
         * are being written, or if the type of the named field is not
         * &lt;code&gt;long&lt;/code&gt;
         */
        public abstract void put(String name, long val);

        /**
         * Put the value of the named float field into the persistent field.
         *
         * @param  name the name of the serializable field
         * @param  val the value to assign to the field
         * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         * match the name of a serializable field for the class whose fields
         * are being written, or if the type of the named field is not
         * &lt;code&gt;float&lt;/code&gt;
         */
        public abstract void put(String name, float val);

        /**
         * Put the value of the named double field into the persistent field.
         *
         * @param  name the name of the serializable field
         * @param  val the value to assign to the field
         * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         * match the name of a serializable field for the class whose fields
         * are being written, or if the type of the named field is not
         * &lt;code&gt;double&lt;/code&gt;
         */
        public abstract void put(String name, double val);

        /**
         * Put the value of the named Object field into the persistent field.
         *
         * @param  name the name of the serializable field
         * @param  val the value to assign to the field
         *         (which may be &lt;code&gt;null&lt;/code&gt;)
         * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         * match the name of a serializable field for the class whose fields
         * are being written, or if the type of the named field is not a
         * reference type
         */
        public abstract void put(String name, Object val);

        /**
         * Write the data and fields to the specified ObjectOutput stream,
         * which must be the same stream that produced this
         * &lt;code&gt;PutField&lt;/code&gt; object.
         *
         * @param  out the stream to write the data and fields to
         * @throws IOException if I/O errors occur while writing to the
         *         underlying stream
         * @throws IllegalArgumentException if the specified stream is not
         *         the same stream that produced this &lt;code&gt;PutField&lt;/code&gt;
         *         object
         * @deprecated This method does not write the values contained by this
         *         &lt;code&gt;PutField&lt;/code&gt; object in a proper format, and may
         *         result in corruption of the serialization stream.  The
         *         correct way to write &lt;code&gt;PutField&lt;/code&gt; data is by
         *         calling the {@link java.io.ObjectOutputStream#writeFields()}
         *         method.
         */
        @Deprecated
        public abstract void write(ObjectOutput out) throws IOException;
    }


    /**
     * Returns protocol version in use.
     */
    int getProtocolVersion() {
<span class="fc" id="L1016">        return protocol;</span>
    }

    /**
     * Writes string without allowing it to be replaced in stream.  Used by
     * ObjectStreamClass to write class descriptor type strings.
     */
    void writeTypeString(String str) throws IOException {
        int handle;
<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L1026">            writeNull();</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">        } else if ((handle = handles.lookup(str)) != -1) {</span>
<span class="fc" id="L1028">            writeHandle(handle);</span>
        } else {
<span class="fc" id="L1030">            writeString(str, false);</span>
        }
<span class="fc" id="L1032">    }</span>

    /**
     * Verifies that this (possibly subclass) instance can be constructed
     * without violating security constraints: the subclass must not override
     * security-sensitive non-final methods, or else the
     * &quot;enableSubclassImplementation&quot; SerializablePermission is checked.
     */
    private void verifySubclass() {
<span class="fc" id="L1041">        Class&lt;?&gt; cl = getClass();</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">        if (cl == ObjectOutputStream.class) {</span>
<span class="fc" id="L1043">            return;</span>
        }
<span class="fc" id="L1045">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L1046" title="All 2 branches covered.">        if (sm == null) {</span>
<span class="fc" id="L1047">            return;</span>
        }
<span class="fc" id="L1049">        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);</span>
<span class="fc" id="L1050">        WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);</span>
<span class="fc" id="L1051">        Boolean result = Caches.subclassAudits.get(key);</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">        if (result == null) {</span>
<span class="fc" id="L1053">            result = Boolean.valueOf(auditSubclass(cl));</span>
<span class="fc" id="L1054">            Caches.subclassAudits.putIfAbsent(key, result);</span>
        }
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">        if (result.booleanValue()) {</span>
<span class="fc" id="L1057">            return;</span>
        }
<span class="nc" id="L1059">        sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span>
<span class="nc" id="L1060">    }</span>

    /**
     * Performs reflective checks on given subclass to verify that it doesn't
     * override security-sensitive non-final methods.  Returns true if subclass
     * is &quot;safe&quot;, false otherwise.
     */
    private static boolean auditSubclass(final Class&lt;?&gt; subcl) {
<span class="fc" id="L1068">        Boolean result = AccessController.doPrivileged(</span>
<span class="fc" id="L1069">            new PrivilegedAction&lt;Boolean&gt;() {</span>
                public Boolean run() {
<span class="fc" id="L1071">                    for (Class&lt;?&gt; cl = subcl;</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">                         cl != ObjectOutputStream.class;</span>
<span class="fc" id="L1073">                         cl = cl.getSuperclass())</span>
                    {
                        try {
<span class="fc" id="L1076">                            cl.getDeclaredMethod(</span>
                                &quot;writeUnshared&quot;, new Class&lt;?&gt;[] { Object.class });
<span class="fc" id="L1078">                            return Boolean.FALSE;</span>
<span class="fc" id="L1079">                        } catch (NoSuchMethodException ex) {</span>
                        }
                        try {
<span class="fc" id="L1082">                            cl.getDeclaredMethod(&quot;putFields&quot;, (Class&lt;?&gt;[]) null);</span>
<span class="fc" id="L1083">                            return Boolean.FALSE;</span>
<span class="fc" id="L1084">                        } catch (NoSuchMethodException ex) {</span>
                        }
                    }
<span class="fc" id="L1087">                    return Boolean.TRUE;</span>
                }
            }
        );
<span class="fc" id="L1091">        return result.booleanValue();</span>
    }

    /**
     * Clears internal data structures.
     */
    private void clear() {
<span class="fc" id="L1098">        subs.clear();</span>
<span class="fc" id="L1099">        handles.clear();</span>
<span class="fc" id="L1100">    }</span>

    /**
     * Underlying writeObject/writeUnshared implementation.
     */
    private void writeObject0(Object obj, boolean unshared)
        throws IOException
    {
<span class="fc" id="L1108">        boolean oldMode = bout.setBlockDataMode(false);</span>
<span class="fc" id="L1109">        depth++;</span>
        try {
            // handle previously written and non-replaceable objects
            int h;
<span class="fc bfc" id="L1113" title="All 2 branches covered.">            if ((obj = subs.lookup(obj)) == null) {</span>
<span class="fc" id="L1114">                writeNull();</span>
<span class="fc" id="L1115">                return;</span>
<span class="fc bfc" id="L1116" title="All 4 branches covered.">            } else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) {</span>
<span class="fc" id="L1117">                writeHandle(h);</span>
<span class="fc" id="L1118">                return;</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">            } else if (obj instanceof Class) {</span>
<span class="fc" id="L1120">                writeClass((Class) obj, unshared);</span>
<span class="fc" id="L1121">                return;</span>
<span class="fc bfc" id="L1122" title="All 2 branches covered.">            } else if (obj instanceof ObjectStreamClass) {</span>
<span class="fc" id="L1123">                writeClassDesc((ObjectStreamClass) obj, unshared);</span>
<span class="fc" id="L1124">                return;</span>
            }

            // check for replacement object
<span class="fc" id="L1128">            Object orig = obj;</span>
<span class="fc" id="L1129">            Class&lt;?&gt; cl = obj.getClass();</span>
            ObjectStreamClass desc;
            for (;;) {
                // REMIND: skip this check for strings/arrays?
                Class&lt;?&gt; repCl;
<span class="fc" id="L1134">                desc = ObjectStreamClass.lookup(cl, true);</span>
<span class="fc bfc" id="L1135" title="All 2 branches covered.">                if (!desc.hasWriteReplaceMethod() ||</span>
<span class="pc bpc" id="L1136" title="1 of 2 branches missed.">                    (obj = desc.invokeWriteReplace(obj)) == null ||</span>
<span class="fc bfc" id="L1137" title="All 2 branches covered.">                    (repCl = obj.getClass()) == cl)</span>
                {
<span class="fc" id="L1139">                    break;</span>
                }
<span class="fc" id="L1141">                cl = repCl;</span>
<span class="fc" id="L1142">            }</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">            if (enableReplace) {</span>
<span class="fc" id="L1144">                Object rep = replaceObject(obj);</span>
<span class="fc bfc" id="L1145" title="All 4 branches covered.">                if (rep != obj &amp;&amp; rep != null) {</span>
<span class="fc" id="L1146">                    cl = rep.getClass();</span>
<span class="fc" id="L1147">                    desc = ObjectStreamClass.lookup(cl, true);</span>
                }
<span class="fc" id="L1149">                obj = rep;</span>
            }

            // if object replaced, run through original checks a second time
<span class="fc bfc" id="L1153" title="All 2 branches covered.">            if (obj != orig) {</span>
<span class="fc" id="L1154">                subs.assign(orig, obj);</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">                if (obj == null) {</span>
<span class="fc" id="L1156">                    writeNull();</span>
<span class="fc" id="L1157">                    return;</span>
<span class="pc bpc" id="L1158" title="2 of 4 branches missed.">                } else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) {</span>
<span class="nc" id="L1159">                    writeHandle(h);</span>
<span class="nc" id="L1160">                    return;</span>
<span class="pc bpc" id="L1161" title="1 of 2 branches missed.">                } else if (obj instanceof Class) {</span>
<span class="nc" id="L1162">                    writeClass((Class) obj, unshared);</span>
<span class="nc" id="L1163">                    return;</span>
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">                } else if (obj instanceof ObjectStreamClass) {</span>
<span class="nc" id="L1165">                    writeClassDesc((ObjectStreamClass) obj, unshared);</span>
<span class="nc" id="L1166">                    return;</span>
                }
            }

            // remaining cases
<span class="fc bfc" id="L1171" title="All 2 branches covered.">            if (obj instanceof String) {</span>
<span class="fc" id="L1172">                writeString((String) obj, unshared);</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">            } else if (cl.isArray()) {</span>
<span class="fc" id="L1174">                writeArray(obj, desc, unshared);</span>
<span class="fc bfc" id="L1175" title="All 2 branches covered.">            } else if (obj instanceof Enum) {</span>
<span class="fc" id="L1176">                writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span>
<span class="fc bfc" id="L1177" title="All 2 branches covered.">            } else if (obj instanceof Serializable) {</span>
<span class="fc" id="L1178">                writeOrdinaryObject(obj, desc, unshared);</span>
            } else {
<span class="pc bpc" id="L1180" title="1 of 2 branches missed.">                if (extendedDebugInfo) {</span>
<span class="nc" id="L1181">                    throw new NotSerializableException(</span>
<span class="nc" id="L1182">                        cl.getName() + &quot;\n&quot; + debugInfoStack.toString());</span>
                } else {
<span class="fc" id="L1184">                    throw new NotSerializableException(cl.getName());</span>
                }
            }
        } finally {
<span class="pc" id="L1188">            depth--;</span>
<span class="pc" id="L1189">            bout.setBlockDataMode(oldMode);</span>
<span class="fc" id="L1190">        }</span>
<span class="fc" id="L1191">    }</span>

    /**
     * Writes null code to stream.
     */
    private void writeNull() throws IOException {
<span class="fc" id="L1197">        bout.writeByte(TC_NULL);</span>
<span class="fc" id="L1198">    }</span>

    /**
     * Writes given object handle to stream.
     */
    private void writeHandle(int handle) throws IOException {
<span class="fc" id="L1204">        bout.writeByte(TC_REFERENCE);</span>
<span class="fc" id="L1205">        bout.writeInt(baseWireHandle + handle);</span>
<span class="fc" id="L1206">    }</span>

    /**
     * Writes representation of given class to stream.
     */
    private void writeClass(Class&lt;?&gt; cl, boolean unshared) throws IOException {
<span class="fc" id="L1212">        bout.writeByte(TC_CLASS);</span>
<span class="fc" id="L1213">        writeClassDesc(ObjectStreamClass.lookup(cl, true), false);</span>
<span class="pc bpc" id="L1214" title="1 of 2 branches missed.">        handles.assign(unshared ? null : cl);</span>
<span class="fc" id="L1215">    }</span>

    /**
     * Writes representation of given class descriptor to stream.
     */
    private void writeClassDesc(ObjectStreamClass desc, boolean unshared)
        throws IOException
    {
        int handle;
<span class="fc bfc" id="L1224" title="All 2 branches covered.">        if (desc == null) {</span>
<span class="fc" id="L1225">            writeNull();</span>
<span class="pc bpc" id="L1226" title="1 of 4 branches missed.">        } else if (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -1) {</span>
<span class="fc" id="L1227">            writeHandle(handle);</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">        } else if (desc.isProxy()) {</span>
<span class="fc" id="L1229">            writeProxyDesc(desc, unshared);</span>
        } else {
<span class="fc" id="L1231">            writeNonProxyDesc(desc, unshared);</span>
        }
<span class="fc" id="L1233">    }</span>

    private boolean isCustomSubclass() {
        // Return true if this class is a custom subclass of ObjectOutputStream
<span class="fc" id="L1237">        return getClass().getClassLoader()</span>
<span class="fc bfc" id="L1238" title="All 2 branches covered.">                   != ObjectOutputStream.class.getClassLoader();</span>
    }

    /**
     * Writes class descriptor representing a dynamic proxy class to stream.
     */
    private void writeProxyDesc(ObjectStreamClass desc, boolean unshared)
        throws IOException
    {
<span class="fc" id="L1247">        bout.writeByte(TC_PROXYCLASSDESC);</span>
<span class="pc bpc" id="L1248" title="1 of 2 branches missed.">        handles.assign(unshared ? null : desc);</span>

<span class="fc" id="L1250">        Class&lt;?&gt; cl = desc.forClass();</span>
<span class="fc" id="L1251">        Class&lt;?&gt;[] ifaces = cl.getInterfaces();</span>
<span class="fc" id="L1252">        bout.writeInt(ifaces.length);</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">        for (int i = 0; i &lt; ifaces.length; i++) {</span>
<span class="fc" id="L1254">            bout.writeUTF(ifaces[i].getName());</span>
        }

<span class="fc" id="L1257">        bout.setBlockDataMode(true);</span>
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">        if (isCustomSubclass()) {</span>
<span class="nc" id="L1259">            ReflectUtil.checkPackageAccess(cl);</span>
        }
<span class="fc" id="L1261">        annotateProxyClass(cl);</span>
<span class="fc" id="L1262">        bout.setBlockDataMode(false);</span>
<span class="fc" id="L1263">        bout.writeByte(TC_ENDBLOCKDATA);</span>

<span class="fc" id="L1265">        writeClassDesc(desc.getSuperDesc(), false);</span>
<span class="fc" id="L1266">    }</span>

    /**
     * Writes class descriptor representing a standard (i.e., not a dynamic
     * proxy) class to stream.
     */
    private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared)
        throws IOException
    {
<span class="fc" id="L1275">        bout.writeByte(TC_CLASSDESC);</span>
<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">        handles.assign(unshared ? null : desc);</span>

<span class="fc bfc" id="L1278" title="All 2 branches covered.">        if (protocol == PROTOCOL_VERSION_1) {</span>
            // do not invoke class descriptor write hook with old protocol
<span class="fc" id="L1280">            desc.writeNonProxy(this);</span>
        } else {
<span class="fc" id="L1282">            writeClassDescriptor(desc);</span>
        }

<span class="fc" id="L1285">        Class&lt;?&gt; cl = desc.forClass();</span>
<span class="fc" id="L1286">        bout.setBlockDataMode(true);</span>
<span class="fc bfc" id="L1287" title="All 2 branches covered.">        if (isCustomSubclass()) {</span>
<span class="fc" id="L1288">            ReflectUtil.checkPackageAccess(cl);</span>
        }
<span class="fc" id="L1290">        annotateClass(cl);</span>
<span class="fc" id="L1291">        bout.setBlockDataMode(false);</span>
<span class="fc" id="L1292">        bout.writeByte(TC_ENDBLOCKDATA);</span>

<span class="fc" id="L1294">        writeClassDesc(desc.getSuperDesc(), false);</span>
<span class="fc" id="L1295">    }</span>

    /**
     * Writes given string to stream, using standard or long UTF format
     * depending on string length.
     */
    private void writeString(String str, boolean unshared) throws IOException {
<span class="fc bfc" id="L1302" title="All 2 branches covered.">        handles.assign(unshared ? null : str);</span>
<span class="fc" id="L1303">        long utflen = bout.getUTFLength(str);</span>
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">        if (utflen &lt;= 0xFFFF) {</span>
<span class="fc" id="L1305">            bout.writeByte(TC_STRING);</span>
<span class="fc" id="L1306">            bout.writeUTF(str, utflen);</span>
        } else {
<span class="nc" id="L1308">            bout.writeByte(TC_LONGSTRING);</span>
<span class="nc" id="L1309">            bout.writeLongUTF(str, utflen);</span>
        }
<span class="fc" id="L1311">    }</span>

    /**
     * Writes given array object to stream.
     */
    private void writeArray(Object array,
                            ObjectStreamClass desc,
                            boolean unshared)
        throws IOException
    {
<span class="fc" id="L1321">        bout.writeByte(TC_ARRAY);</span>
<span class="fc" id="L1322">        writeClassDesc(desc, false);</span>
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">        handles.assign(unshared ? null : array);</span>

<span class="fc" id="L1325">        Class&lt;?&gt; ccl = desc.forClass().getComponentType();</span>
<span class="fc bfc" id="L1326" title="All 2 branches covered.">        if (ccl.isPrimitive()) {</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">            if (ccl == Integer.TYPE) {</span>
<span class="fc" id="L1328">                int[] ia = (int[]) array;</span>
<span class="fc" id="L1329">                bout.writeInt(ia.length);</span>
<span class="fc" id="L1330">                bout.writeInts(ia, 0, ia.length);</span>
<span class="fc bfc" id="L1331" title="All 2 branches covered.">            } else if (ccl == Byte.TYPE) {</span>
<span class="fc" id="L1332">                byte[] ba = (byte[]) array;</span>
<span class="fc" id="L1333">                bout.writeInt(ba.length);</span>
<span class="fc" id="L1334">                bout.write(ba, 0, ba.length, true);</span>
<span class="fc bfc" id="L1335" title="All 2 branches covered.">            } else if (ccl == Long.TYPE) {</span>
<span class="fc" id="L1336">                long[] ja = (long[]) array;</span>
<span class="fc" id="L1337">                bout.writeInt(ja.length);</span>
<span class="fc" id="L1338">                bout.writeLongs(ja, 0, ja.length);</span>
<span class="fc bfc" id="L1339" title="All 2 branches covered.">            } else if (ccl == Float.TYPE) {</span>
<span class="fc" id="L1340">                float[] fa = (float[]) array;</span>
<span class="fc" id="L1341">                bout.writeInt(fa.length);</span>
<span class="fc" id="L1342">                bout.writeFloats(fa, 0, fa.length);</span>
<span class="fc bfc" id="L1343" title="All 2 branches covered.">            } else if (ccl == Double.TYPE) {</span>
<span class="fc" id="L1344">                double[] da = (double[]) array;</span>
<span class="fc" id="L1345">                bout.writeInt(da.length);</span>
<span class="fc" id="L1346">                bout.writeDoubles(da, 0, da.length);</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">            } else if (ccl == Short.TYPE) {</span>
<span class="fc" id="L1348">                short[] sa = (short[]) array;</span>
<span class="fc" id="L1349">                bout.writeInt(sa.length);</span>
<span class="fc" id="L1350">                bout.writeShorts(sa, 0, sa.length);</span>
<span class="fc bfc" id="L1351" title="All 2 branches covered.">            } else if (ccl == Character.TYPE) {</span>
<span class="fc" id="L1352">                char[] ca = (char[]) array;</span>
<span class="fc" id="L1353">                bout.writeInt(ca.length);</span>
<span class="fc" id="L1354">                bout.writeChars(ca, 0, ca.length);</span>
<span class="pc bpc" id="L1355" title="1 of 2 branches missed.">            } else if (ccl == Boolean.TYPE) {</span>
<span class="fc" id="L1356">                boolean[] za = (boolean[]) array;</span>
<span class="fc" id="L1357">                bout.writeInt(za.length);</span>
<span class="fc" id="L1358">                bout.writeBooleans(za, 0, za.length);</span>
<span class="fc" id="L1359">            } else {</span>
<span class="nc" id="L1360">                throw new InternalError();</span>
            }
        } else {
<span class="fc" id="L1363">            Object[] objs = (Object[]) array;</span>
<span class="fc" id="L1364">            int len = objs.length;</span>
<span class="fc" id="L1365">            bout.writeInt(len);</span>
<span class="pc bpc" id="L1366" title="1 of 2 branches missed.">            if (extendedDebugInfo) {</span>
<span class="nc" id="L1367">                debugInfoStack.push(</span>
<span class="nc" id="L1368">                    &quot;array (class \&quot;&quot; + array.getClass().getName() +</span>
                    &quot;\&quot;, size: &quot; + len  + &quot;)&quot;);
            }
            try {
<span class="fc bfc" id="L1372" title="All 2 branches covered.">                for (int i = 0; i &lt; len; i++) {</span>
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">                    if (extendedDebugInfo) {</span>
<span class="nc" id="L1374">                        debugInfoStack.push(</span>
                            &quot;element of array (index: &quot; + i + &quot;)&quot;);
                    }
                    try {
<span class="fc" id="L1378">                        writeObject0(objs[i], false);</span>
                    } finally {
<span class="pc bpc" id="L1380" title="2 of 4 branches missed.">                        if (extendedDebugInfo) {</span>
<span class="pc" id="L1381">                            debugInfoStack.pop();</span>
                        }
                    }
                }
            } finally {
<span class="pc bpc" id="L1386" title="2 of 4 branches missed.">                if (extendedDebugInfo) {</span>
<span class="pc" id="L1387">                    debugInfoStack.pop();</span>
                }
            }
        }
<span class="fc" id="L1391">    }</span>

    /**
     * Writes given enum constant to stream.
     */
    private void writeEnum(Enum&lt;?&gt; en,
                           ObjectStreamClass desc,
                           boolean unshared)
        throws IOException
    {
<span class="fc" id="L1401">        bout.writeByte(TC_ENUM);</span>
<span class="fc" id="L1402">        ObjectStreamClass sdesc = desc.getSuperDesc();</span>
<span class="fc bfc" id="L1403" title="All 2 branches covered.">        writeClassDesc((sdesc.forClass() == Enum.class) ? desc : sdesc, false);</span>
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">        handles.assign(unshared ? null : en);</span>
<span class="fc" id="L1405">        writeString(en.name(), false);</span>
<span class="fc" id="L1406">    }</span>

    /**
     * Writes representation of a &quot;ordinary&quot; (i.e., not a String, Class,
     * ObjectStreamClass, array, or enum constant) serializable object to the
     * stream.
     */
    private void writeOrdinaryObject(Object obj,
                                     ObjectStreamClass desc,
                                     boolean unshared)
        throws IOException
    {
<span class="pc bpc" id="L1418" title="1 of 2 branches missed.">        if (extendedDebugInfo) {</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">            debugInfoStack.push(</span>
                (depth == 1 ? &quot;root &quot; : &quot;&quot;) + &quot;object (class \&quot;&quot; +
<span class="nc" id="L1421">                obj.getClass().getName() + &quot;\&quot;, &quot; + obj.toString() + &quot;)&quot;);</span>
        }
        try {
<span class="fc" id="L1424">            desc.checkSerialize();</span>

<span class="fc" id="L1426">            bout.writeByte(TC_OBJECT);</span>
<span class="fc" id="L1427">            writeClassDesc(desc, false);</span>
<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">            handles.assign(unshared ? null : obj);</span>
<span class="pc bpc" id="L1429" title="1 of 4 branches missed.">            if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) {</span>
<span class="fc" id="L1430">                writeExternalData((Externalizable) obj);</span>
            } else {
<span class="fc" id="L1432">                writeSerialData(obj, desc);</span>
            }
        } finally {
<span class="pc bpc" id="L1435" title="2 of 4 branches missed.">            if (extendedDebugInfo) {</span>
<span class="pc" id="L1436">                debugInfoStack.pop();</span>
            }
        }
<span class="fc" id="L1439">    }</span>

    /**
     * Writes externalizable data of given object by invoking its
     * writeExternal() method.
     */
    private void writeExternalData(Externalizable obj) throws IOException {
<span class="fc" id="L1446">        PutFieldImpl oldPut = curPut;</span>
<span class="fc" id="L1447">        curPut = null;</span>

<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">        if (extendedDebugInfo) {</span>
<span class="nc" id="L1450">            debugInfoStack.push(&quot;writeExternal data&quot;);</span>
        }
<span class="fc" id="L1452">        SerialCallbackContext oldContext = curContext;</span>
        try {
<span class="fc" id="L1454">            curContext = null;</span>
<span class="fc bfc" id="L1455" title="All 2 branches covered.">            if (protocol == PROTOCOL_VERSION_1) {</span>
<span class="fc" id="L1456">                obj.writeExternal(this);</span>
            } else {
<span class="fc" id="L1458">                bout.setBlockDataMode(true);</span>
<span class="fc" id="L1459">                obj.writeExternal(this);</span>
<span class="fc" id="L1460">                bout.setBlockDataMode(false);</span>
<span class="fc" id="L1461">                bout.writeByte(TC_ENDBLOCKDATA);</span>
            }
        } finally {
<span class="pc" id="L1464">            curContext = oldContext;</span>
<span class="pc bpc" id="L1465" title="3 of 4 branches missed.">            if (extendedDebugInfo) {</span>
<span class="nc" id="L1466">                debugInfoStack.pop();</span>
            }
        }

<span class="fc" id="L1470">        curPut = oldPut;</span>
<span class="fc" id="L1471">    }</span>

    /**
     * Writes instance data for each serializable class of given object, from
     * superclass to subclass.
     */
    private void writeSerialData(Object obj, ObjectStreamClass desc)
        throws IOException
    {
<span class="fc" id="L1480">        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span>
<span class="fc bfc" id="L1481" title="All 2 branches covered.">        for (int i = 0; i &lt; slots.length; i++) {</span>
<span class="fc" id="L1482">            ObjectStreamClass slotDesc = slots[i].desc;</span>
<span class="fc bfc" id="L1483" title="All 2 branches covered.">            if (slotDesc.hasWriteObjectMethod()) {</span>
<span class="fc" id="L1484">                PutFieldImpl oldPut = curPut;</span>
<span class="fc" id="L1485">                curPut = null;</span>
<span class="fc" id="L1486">                SerialCallbackContext oldContext = curContext;</span>

<span class="pc bpc" id="L1488" title="1 of 2 branches missed.">                if (extendedDebugInfo) {</span>
<span class="nc" id="L1489">                    debugInfoStack.push(</span>
                        &quot;custom writeObject data (class \&quot;&quot; +
<span class="nc" id="L1491">                        slotDesc.getName() + &quot;\&quot;)&quot;);</span>
                }
                try {
<span class="fc" id="L1494">                    curContext = new SerialCallbackContext(obj, slotDesc);</span>
<span class="fc" id="L1495">                    bout.setBlockDataMode(true);</span>
<span class="fc" id="L1496">                    slotDesc.invokeWriteObject(obj, this);</span>
<span class="fc" id="L1497">                    bout.setBlockDataMode(false);</span>
<span class="fc" id="L1498">                    bout.writeByte(TC_ENDBLOCKDATA);</span>
                } finally {
<span class="fc" id="L1500">                    curContext.setUsed();</span>
<span class="fc" id="L1501">                    curContext = oldContext;</span>
<span class="pc bpc" id="L1502" title="2 of 4 branches missed.">                    if (extendedDebugInfo) {</span>
<span class="pc" id="L1503">                        debugInfoStack.pop();</span>
                    }
                }

<span class="fc" id="L1507">                curPut = oldPut;</span>
<span class="fc" id="L1508">            } else {</span>
<span class="fc" id="L1509">                defaultWriteFields(obj, slotDesc);</span>
            }
        }
<span class="fc" id="L1512">    }</span>

    /**
     * Fetches and writes values of serializable fields of given object to
     * stream.  The given class descriptor specifies which field values to
     * write, and in which order they should be written.
     */
    private void defaultWriteFields(Object obj, ObjectStreamClass desc)
        throws IOException
    {
<span class="fc" id="L1522">        Class&lt;?&gt; cl = desc.forClass();</span>
<span class="pc bpc" id="L1523" title="3 of 6 branches missed.">        if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {</span>
<span class="nc" id="L1524">            throw new ClassCastException();</span>
        }

<span class="fc" id="L1527">        desc.checkDefaultSerialize();</span>

<span class="fc" id="L1529">        int primDataSize = desc.getPrimDataSize();</span>
<span class="fc bfc" id="L1530" title="All 4 branches covered.">        if (primVals == null || primVals.length &lt; primDataSize) {</span>
<span class="fc" id="L1531">            primVals = new byte[primDataSize];</span>
        }
<span class="fc" id="L1533">        desc.getPrimFieldValues(obj, primVals);</span>
<span class="fc" id="L1534">        bout.write(primVals, 0, primDataSize, false);</span>

<span class="fc" id="L1536">        ObjectStreamField[] fields = desc.getFields(false);</span>
<span class="fc" id="L1537">        Object[] objVals = new Object[desc.getNumObjFields()];</span>
<span class="fc" id="L1538">        int numPrimFields = fields.length - objVals.length;</span>
<span class="fc" id="L1539">        desc.getObjFieldValues(obj, objVals);</span>
<span class="fc bfc" id="L1540" title="All 2 branches covered.">        for (int i = 0; i &lt; objVals.length; i++) {</span>
<span class="pc bpc" id="L1541" title="1 of 2 branches missed.">            if (extendedDebugInfo) {</span>
<span class="nc" id="L1542">                debugInfoStack.push(</span>
<span class="nc" id="L1543">                    &quot;field (class \&quot;&quot; + desc.getName() + &quot;\&quot;, name: \&quot;&quot; +</span>
<span class="nc" id="L1544">                    fields[numPrimFields + i].getName() + &quot;\&quot;, type: \&quot;&quot; +</span>
<span class="nc" id="L1545">                    fields[numPrimFields + i].getType() + &quot;\&quot;)&quot;);</span>
            }
            try {
<span class="fc" id="L1548">                writeObject0(objVals[i],</span>
<span class="fc" id="L1549">                             fields[numPrimFields + i].isUnshared());</span>
            } finally {
<span class="pc bpc" id="L1551" title="2 of 4 branches missed.">                if (extendedDebugInfo) {</span>
<span class="pc" id="L1552">                    debugInfoStack.pop();</span>
                }
            }
        }
<span class="fc" id="L1556">    }</span>

    /**
     * Attempts to write to stream fatal IOException that has caused
     * serialization to abort.
     */
    private void writeFatalException(IOException ex) throws IOException {
        /*
         * Note: the serialization specification states that if a second
         * IOException occurs while attempting to serialize the original fatal
         * exception to the stream, then a StreamCorruptedException should be
         * thrown (section 2.1).  However, due to a bug in previous
         * implementations of serialization, StreamCorruptedExceptions were
         * rarely (if ever) actually thrown--the &quot;root&quot; exceptions from
         * underlying streams were thrown instead.  This historical behavior is
         * followed here for consistency.
         */
<span class="fc" id="L1573">        clear();</span>
<span class="fc" id="L1574">        boolean oldMode = bout.setBlockDataMode(false);</span>
        try {
<span class="fc" id="L1576">            bout.writeByte(TC_EXCEPTION);</span>
<span class="fc" id="L1577">            writeObject0(ex, false);</span>
<span class="fc" id="L1578">            clear();</span>
        } finally {
<span class="fc" id="L1580">            bout.setBlockDataMode(oldMode);</span>
<span class="fc" id="L1581">        }</span>
<span class="fc" id="L1582">    }</span>

    /**
     * Converts specified span of float values into byte values.
     */
    // REMIND: remove once hotspot inlines Float.floatToIntBits
    private static native void floatsToBytes(float[] src, int srcpos,
                                             byte[] dst, int dstpos,
                                             int nfloats);

    /**
     * Converts specified span of double values into byte values.
     */
    // REMIND: remove once hotspot inlines Double.doubleToLongBits
    private static native void doublesToBytes(double[] src, int srcpos,
                                              byte[] dst, int dstpos,
                                              int ndoubles);

    /**
     * Default PutField implementation.
     */
    private class PutFieldImpl extends PutField {

        /** class descriptor describing serializable fields */
        private final ObjectStreamClass desc;
        /** primitive field values */
        private final byte[] primVals;
        /** object field values */
        private final Object[] objVals;

        /**
         * Creates PutFieldImpl object for writing fields defined in given
         * class descriptor.
         */
<span class="fc" id="L1616">        PutFieldImpl(ObjectStreamClass desc) {</span>
<span class="fc" id="L1617">            this.desc = desc;</span>
<span class="fc" id="L1618">            primVals = new byte[desc.getPrimDataSize()];</span>
<span class="fc" id="L1619">            objVals = new Object[desc.getNumObjFields()];</span>
<span class="fc" id="L1620">        }</span>

        public void put(String name, boolean val) {
<span class="fc" id="L1623">            Bits.putBoolean(primVals, getFieldOffset(name, Boolean.TYPE), val);</span>
<span class="fc" id="L1624">        }</span>

        public void put(String name, byte val) {
<span class="fc" id="L1627">            primVals[getFieldOffset(name, Byte.TYPE)] = val;</span>
<span class="fc" id="L1628">        }</span>

        public void put(String name, char val) {
<span class="fc" id="L1631">            Bits.putChar(primVals, getFieldOffset(name, Character.TYPE), val);</span>
<span class="fc" id="L1632">        }</span>

        public void put(String name, short val) {
<span class="fc" id="L1635">            Bits.putShort(primVals, getFieldOffset(name, Short.TYPE), val);</span>
<span class="fc" id="L1636">        }</span>

        public void put(String name, int val) {
<span class="fc" id="L1639">            Bits.putInt(primVals, getFieldOffset(name, Integer.TYPE), val);</span>
<span class="fc" id="L1640">        }</span>

        public void put(String name, float val) {
<span class="fc" id="L1643">            Bits.putFloat(primVals, getFieldOffset(name, Float.TYPE), val);</span>
<span class="fc" id="L1644">        }</span>

        public void put(String name, long val) {
<span class="fc" id="L1647">            Bits.putLong(primVals, getFieldOffset(name, Long.TYPE), val);</span>
<span class="fc" id="L1648">        }</span>

        public void put(String name, double val) {
<span class="fc" id="L1651">            Bits.putDouble(primVals, getFieldOffset(name, Double.TYPE), val);</span>
<span class="fc" id="L1652">        }</span>

        public void put(String name, Object val) {
<span class="fc" id="L1655">            objVals[getFieldOffset(name, Object.class)] = val;</span>
<span class="fc" id="L1656">        }</span>

        // deprecated in ObjectOutputStream.PutField
        public void write(ObjectOutput out) throws IOException {
            /*
             * Applications should *not* use this method to write PutField
             * data, as it will lead to stream corruption if the PutField
             * object writes any primitive data (since block data mode is not
             * unset/set properly, as is done in OOS.writeFields()).  This
             * broken implementation is being retained solely for behavioral
             * compatibility, in order to support applications which use
             * OOS.PutField.write() for writing only non-primitive data.
             *
             * Serialization of unshared objects is not implemented here since
             * it is not necessary for backwards compatibility; also, unshared
             * semantics may not be supported by the given ObjectOutput
             * instance.  Applications which write unshared objects using the
             * PutField API must use OOS.writeFields().
             */
<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">            if (ObjectOutputStream.this != out) {</span>
<span class="nc" id="L1676">                throw new IllegalArgumentException(&quot;wrong stream&quot;);</span>
            }
<span class="fc" id="L1678">            out.write(primVals, 0, primVals.length);</span>

<span class="fc" id="L1680">            ObjectStreamField[] fields = desc.getFields(false);</span>
<span class="fc" id="L1681">            int numPrimFields = fields.length - objVals.length;</span>
            // REMIND: warn if numPrimFields &gt; 0?
<span class="fc bfc" id="L1683" title="All 2 branches covered.">            for (int i = 0; i &lt; objVals.length; i++) {</span>
<span class="pc bpc" id="L1684" title="1 of 2 branches missed.">                if (fields[numPrimFields + i].isUnshared()) {</span>
<span class="nc" id="L1685">                    throw new IOException(&quot;cannot write unshared object&quot;);</span>
                }
<span class="fc" id="L1687">                out.writeObject(objVals[i]);</span>
            }
<span class="fc" id="L1689">        }</span>

        /**
         * Writes buffered primitive data and object fields to stream.
         */
        void writeFields() throws IOException {
<span class="fc" id="L1695">            bout.write(primVals, 0, primVals.length, false);</span>

<span class="fc" id="L1697">            ObjectStreamField[] fields = desc.getFields(false);</span>
<span class="fc" id="L1698">            int numPrimFields = fields.length - objVals.length;</span>
<span class="fc bfc" id="L1699" title="All 2 branches covered.">            for (int i = 0; i &lt; objVals.length; i++) {</span>
<span class="pc bpc" id="L1700" title="1 of 2 branches missed.">                if (extendedDebugInfo) {</span>
<span class="nc" id="L1701">                    debugInfoStack.push(</span>
<span class="nc" id="L1702">                        &quot;field (class \&quot;&quot; + desc.getName() + &quot;\&quot;, name: \&quot;&quot; +</span>
<span class="nc" id="L1703">                        fields[numPrimFields + i].getName() + &quot;\&quot;, type: \&quot;&quot; +</span>
<span class="nc" id="L1704">                        fields[numPrimFields + i].getType() + &quot;\&quot;)&quot;);</span>
                }
                try {
<span class="fc" id="L1707">                    writeObject0(objVals[i],</span>
<span class="fc" id="L1708">                                 fields[numPrimFields + i].isUnshared());</span>
                } finally {
<span class="pc bpc" id="L1710" title="3 of 4 branches missed.">                    if (extendedDebugInfo) {</span>
<span class="nc" id="L1711">                        debugInfoStack.pop();</span>
                    }
                }
            }
<span class="fc" id="L1715">        }</span>

        /**
         * Returns offset of field with given name and type.  A specified type
         * of null matches all types, Object.class matches all non-primitive
         * types, and any other non-null type matches assignable types only.
         * Throws IllegalArgumentException if no matching field found.
         */
        private int getFieldOffset(String name, Class&lt;?&gt; type) {
<span class="fc" id="L1724">            ObjectStreamField field = desc.getField(name, type);</span>
<span class="pc bpc" id="L1725" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L1726">                throw new IllegalArgumentException(&quot;no such field &quot; + name +</span>
                                                   &quot; with type &quot; + type);
            }
<span class="fc" id="L1729">            return field.getOffset();</span>
        }
    }

    /**
     * Buffered output stream with two modes: in default mode, outputs data in
     * same format as DataOutputStream; in &quot;block data&quot; mode, outputs data
     * bracketed by block data markers (see object serialization specification
     * for details).
     */
    private static class BlockDataOutputStream
        extends OutputStream implements DataOutput
    {
        /** maximum data block length */
        private static final int MAX_BLOCK_SIZE = 1024;
        /** maximum data block header length */
        private static final int MAX_HEADER_SIZE = 5;
        /** (tunable) length of char buffer (for writing strings) */
        private static final int CHAR_BUF_SIZE = 256;

        /** buffer for writing general/block data */
<span class="fc" id="L1750">        private final byte[] buf = new byte[MAX_BLOCK_SIZE];</span>
        /** buffer for writing block data headers */
<span class="fc" id="L1752">        private final byte[] hbuf = new byte[MAX_HEADER_SIZE];</span>
        /** char buffer for fast string writes */
<span class="fc" id="L1754">        private final char[] cbuf = new char[CHAR_BUF_SIZE];</span>

        /** block data mode */
<span class="fc" id="L1757">        private boolean blkmode = false;</span>
        /** current offset into buf */
<span class="fc" id="L1759">        private int pos = 0;</span>

        /** underlying output stream */
        private final OutputStream out;
        /** loopback stream (for data writes that span data blocks) */
        private final DataOutputStream dout;

        /**
         * Creates new BlockDataOutputStream on top of given underlying stream.
         * Block data mode is turned off by default.
         */
<span class="fc" id="L1770">        BlockDataOutputStream(OutputStream out) {</span>
<span class="fc" id="L1771">            this.out = out;</span>
<span class="fc" id="L1772">            dout = new DataOutputStream(this);</span>
<span class="fc" id="L1773">        }</span>

        /**
         * Sets block data mode to the given mode (true == on, false == off)
         * and returns the previous mode value.  If the new mode is the same as
         * the old mode, no action is taken.  If the new mode differs from the
         * old mode, any buffered data is flushed before switching to the new
         * mode.
         */
        boolean setBlockDataMode(boolean mode) throws IOException {
<span class="fc bfc" id="L1783" title="All 2 branches covered.">            if (blkmode == mode) {</span>
<span class="fc" id="L1784">                return blkmode;</span>
            }
<span class="fc" id="L1786">            drain();</span>
<span class="fc" id="L1787">            blkmode = mode;</span>
<span class="fc bfc" id="L1788" title="All 2 branches covered.">            return !blkmode;</span>
        }

        /**
         * Returns true if the stream is currently in block data mode, false
         * otherwise.
         */
        boolean getBlockDataMode() {
<span class="nc" id="L1796">            return blkmode;</span>
        }

        /* ----------------- generic output stream methods ----------------- */
        /*
         * The following methods are equivalent to their counterparts in
         * OutputStream, except that they partition written data into data
         * blocks when in block data mode.
         */

        public void write(int b) throws IOException {
<span class="fc bfc" id="L1807" title="All 2 branches covered.">            if (pos &gt;= MAX_BLOCK_SIZE) {</span>
<span class="fc" id="L1808">                drain();</span>
            }
<span class="fc" id="L1810">            buf[pos++] = (byte) b;</span>
<span class="fc" id="L1811">        }</span>

        public void write(byte[] b) throws IOException {
<span class="nc" id="L1814">            write(b, 0, b.length, false);</span>
<span class="nc" id="L1815">        }</span>

        public void write(byte[] b, int off, int len) throws IOException {
<span class="fc" id="L1818">            write(b, off, len, false);</span>
<span class="fc" id="L1819">        }</span>

        public void flush() throws IOException {
<span class="fc" id="L1822">            drain();</span>
<span class="fc" id="L1823">            out.flush();</span>
<span class="fc" id="L1824">        }</span>

        public void close() throws IOException {
<span class="fc" id="L1827">            flush();</span>
<span class="fc" id="L1828">            out.close();</span>
<span class="fc" id="L1829">        }</span>

        /**
         * Writes specified span of byte values from given array.  If copy is
         * true, copies the values to an intermediate buffer before writing
         * them to underlying stream (to avoid exposing a reference to the
         * original byte array).
         */
        void write(byte[] b, int off, int len, boolean copy)
            throws IOException
        {
<span class="fc bfc" id="L1840" title="All 4 branches covered.">            if (!(copy || blkmode)) {           // write directly</span>
<span class="fc" id="L1841">                drain();</span>
<span class="fc" id="L1842">                out.write(b, off, len);</span>
<span class="fc" id="L1843">                return;</span>
            }

<span class="fc bfc" id="L1846" title="All 2 branches covered.">            while (len &gt; 0) {</span>
<span class="fc bfc" id="L1847" title="All 2 branches covered.">                if (pos &gt;= MAX_BLOCK_SIZE) {</span>
<span class="fc" id="L1848">                    drain();</span>
                }
<span class="pc bpc" id="L1850" title="5 of 6 branches missed.">                if (len &gt;= MAX_BLOCK_SIZE &amp;&amp; !copy &amp;&amp; pos == 0) {</span>
                    // avoid unnecessary copy
<span class="nc" id="L1852">                    writeBlockHeader(MAX_BLOCK_SIZE);</span>
<span class="nc" id="L1853">                    out.write(b, off, MAX_BLOCK_SIZE);</span>
<span class="nc" id="L1854">                    off += MAX_BLOCK_SIZE;</span>
<span class="nc" id="L1855">                    len -= MAX_BLOCK_SIZE;</span>
                } else {
<span class="fc" id="L1857">                    int wlen = Math.min(len, MAX_BLOCK_SIZE - pos);</span>
<span class="fc" id="L1858">                    System.arraycopy(b, off, buf, pos, wlen);</span>
<span class="fc" id="L1859">                    pos += wlen;</span>
<span class="fc" id="L1860">                    off += wlen;</span>
<span class="fc" id="L1861">                    len -= wlen;</span>
<span class="fc" id="L1862">                }</span>
            }
<span class="fc" id="L1864">        }</span>

        /**
         * Writes all buffered data from this stream to the underlying stream,
         * but does not flush underlying stream.
         */
        void drain() throws IOException {
<span class="fc bfc" id="L1871" title="All 2 branches covered.">            if (pos == 0) {</span>
<span class="fc" id="L1872">                return;</span>
            }
<span class="fc bfc" id="L1874" title="All 2 branches covered.">            if (blkmode) {</span>
<span class="fc" id="L1875">                writeBlockHeader(pos);</span>
            }
<span class="fc" id="L1877">            out.write(buf, 0, pos);</span>
<span class="fc" id="L1878">            pos = 0;</span>
<span class="fc" id="L1879">        }</span>

        /**
         * Writes block data header.  Data blocks shorter than 256 bytes are
         * prefixed with a 2-byte header; all others start with a 5-byte
         * header.
         */
        private void writeBlockHeader(int len) throws IOException {
<span class="fc bfc" id="L1887" title="All 2 branches covered.">            if (len &lt;= 0xFF) {</span>
<span class="fc" id="L1888">                hbuf[0] = TC_BLOCKDATA;</span>
<span class="fc" id="L1889">                hbuf[1] = (byte) len;</span>
<span class="fc" id="L1890">                out.write(hbuf, 0, 2);</span>
            } else {
<span class="fc" id="L1892">                hbuf[0] = TC_BLOCKDATALONG;</span>
<span class="fc" id="L1893">                Bits.putInt(hbuf, 1, len);</span>
<span class="fc" id="L1894">                out.write(hbuf, 0, 5);</span>
            }
<span class="fc" id="L1896">        }</span>


        /* ----------------- primitive data output methods ----------------- */
        /*
         * The following methods are equivalent to their counterparts in
         * DataOutputStream, except that they partition written data into data
         * blocks when in block data mode.
         */

        public void writeBoolean(boolean v) throws IOException {
<span class="fc bfc" id="L1907" title="All 2 branches covered.">            if (pos &gt;= MAX_BLOCK_SIZE) {</span>
<span class="fc" id="L1908">                drain();</span>
            }
<span class="fc" id="L1910">            Bits.putBoolean(buf, pos++, v);</span>
<span class="fc" id="L1911">        }</span>

        public void writeByte(int v) throws IOException {
<span class="fc bfc" id="L1914" title="All 2 branches covered.">            if (pos &gt;= MAX_BLOCK_SIZE) {</span>
<span class="fc" id="L1915">                drain();</span>
            }
<span class="fc" id="L1917">            buf[pos++] = (byte) v;</span>
<span class="fc" id="L1918">        }</span>

        public void writeChar(int v) throws IOException {
<span class="fc bfc" id="L1921" title="All 2 branches covered.">            if (pos + 2 &lt;= MAX_BLOCK_SIZE) {</span>
<span class="fc" id="L1922">                Bits.putChar(buf, pos, (char) v);</span>
<span class="fc" id="L1923">                pos += 2;</span>
            } else {
<span class="fc" id="L1925">                dout.writeChar(v);</span>
            }
<span class="fc" id="L1927">        }</span>

        public void writeShort(int v) throws IOException {
<span class="fc bfc" id="L1930" title="All 2 branches covered.">            if (pos + 2 &lt;= MAX_BLOCK_SIZE) {</span>
<span class="fc" id="L1931">                Bits.putShort(buf, pos, (short) v);</span>
<span class="fc" id="L1932">                pos += 2;</span>
            } else {
<span class="fc" id="L1934">                dout.writeShort(v);</span>
            }
<span class="fc" id="L1936">        }</span>

        public void writeInt(int v) throws IOException {
<span class="fc bfc" id="L1939" title="All 2 branches covered.">            if (pos + 4 &lt;= MAX_BLOCK_SIZE) {</span>
<span class="fc" id="L1940">                Bits.putInt(buf, pos, v);</span>
<span class="fc" id="L1941">                pos += 4;</span>
            } else {
<span class="fc" id="L1943">                dout.writeInt(v);</span>
            }
<span class="fc" id="L1945">        }</span>

        public void writeFloat(float v) throws IOException {
<span class="fc bfc" id="L1948" title="All 2 branches covered.">            if (pos + 4 &lt;= MAX_BLOCK_SIZE) {</span>
<span class="fc" id="L1949">                Bits.putFloat(buf, pos, v);</span>
<span class="fc" id="L1950">                pos += 4;</span>
            } else {
<span class="fc" id="L1952">                dout.writeFloat(v);</span>
            }
<span class="fc" id="L1954">        }</span>

        public void writeLong(long v) throws IOException {
<span class="fc bfc" id="L1957" title="All 2 branches covered.">            if (pos + 8 &lt;= MAX_BLOCK_SIZE) {</span>
<span class="fc" id="L1958">                Bits.putLong(buf, pos, v);</span>
<span class="fc" id="L1959">                pos += 8;</span>
            } else {
<span class="fc" id="L1961">                dout.writeLong(v);</span>
            }
<span class="fc" id="L1963">        }</span>

        public void writeDouble(double v) throws IOException {
<span class="fc bfc" id="L1966" title="All 2 branches covered.">            if (pos + 8 &lt;= MAX_BLOCK_SIZE) {</span>
<span class="fc" id="L1967">                Bits.putDouble(buf, pos, v);</span>
<span class="fc" id="L1968">                pos += 8;</span>
            } else {
<span class="fc" id="L1970">                dout.writeDouble(v);</span>
            }
<span class="fc" id="L1972">        }</span>

        public void writeBytes(String s) throws IOException {
<span class="fc" id="L1975">            int endoff = s.length();</span>
<span class="fc" id="L1976">            int cpos = 0;</span>
<span class="fc" id="L1977">            int csize = 0;</span>
<span class="fc bfc" id="L1978" title="All 2 branches covered.">            for (int off = 0; off &lt; endoff; ) {</span>
<span class="pc bpc" id="L1979" title="1 of 2 branches missed.">                if (cpos &gt;= csize) {</span>
<span class="fc" id="L1980">                    cpos = 0;</span>
<span class="fc" id="L1981">                    csize = Math.min(endoff - off, CHAR_BUF_SIZE);</span>
<span class="fc" id="L1982">                    s.getChars(off, off + csize, cbuf, 0);</span>
                }
<span class="pc bpc" id="L1984" title="1 of 2 branches missed.">                if (pos &gt;= MAX_BLOCK_SIZE) {</span>
<span class="nc" id="L1985">                    drain();</span>
                }
<span class="fc" id="L1987">                int n = Math.min(csize - cpos, MAX_BLOCK_SIZE - pos);</span>
<span class="fc" id="L1988">                int stop = pos + n;</span>
<span class="fc bfc" id="L1989" title="All 2 branches covered.">                while (pos &lt; stop) {</span>
<span class="fc" id="L1990">                    buf[pos++] = (byte) cbuf[cpos++];</span>
                }
<span class="fc" id="L1992">                off += n;</span>
<span class="fc" id="L1993">            }</span>
<span class="fc" id="L1994">        }</span>

        public void writeChars(String s) throws IOException {
<span class="nc" id="L1997">            int endoff = s.length();</span>
<span class="nc bnc" id="L1998" title="All 2 branches missed.">            for (int off = 0; off &lt; endoff; ) {</span>
<span class="nc" id="L1999">                int csize = Math.min(endoff - off, CHAR_BUF_SIZE);</span>
<span class="nc" id="L2000">                s.getChars(off, off + csize, cbuf, 0);</span>
<span class="nc" id="L2001">                writeChars(cbuf, 0, csize);</span>
<span class="nc" id="L2002">                off += csize;</span>
<span class="nc" id="L2003">            }</span>
<span class="nc" id="L2004">        }</span>

        public void writeUTF(String s) throws IOException {
<span class="fc" id="L2007">            writeUTF(s, getUTFLength(s));</span>
<span class="fc" id="L2008">        }</span>


        /* -------------- primitive data array output methods -------------- */
        /*
         * The following methods write out spans of primitive data values.
         * Though equivalent to calling the corresponding primitive write
         * methods repeatedly, these methods are optimized for writing groups
         * of primitive data values more efficiently.
         */

        void writeBooleans(boolean[] v, int off, int len) throws IOException {
<span class="fc" id="L2020">            int endoff = off + len;</span>
<span class="fc bfc" id="L2021" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="pc bpc" id="L2022" title="1 of 2 branches missed.">                if (pos &gt;= MAX_BLOCK_SIZE) {</span>
<span class="nc" id="L2023">                    drain();</span>
                }
<span class="fc" id="L2025">                int stop = Math.min(endoff, off + (MAX_BLOCK_SIZE - pos));</span>
<span class="fc bfc" id="L2026" title="All 2 branches covered.">                while (off &lt; stop) {</span>
<span class="fc" id="L2027">                    Bits.putBoolean(buf, pos++, v[off++]);</span>
                }
<span class="fc" id="L2029">            }</span>
<span class="fc" id="L2030">        }</span>

        void writeChars(char[] v, int off, int len) throws IOException {
<span class="fc" id="L2033">            int limit = MAX_BLOCK_SIZE - 2;</span>
<span class="fc" id="L2034">            int endoff = off + len;</span>
<span class="fc bfc" id="L2035" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="pc bpc" id="L2036" title="1 of 2 branches missed.">                if (pos &lt;= limit) {</span>
<span class="fc" id="L2037">                    int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 1;</span>
<span class="fc" id="L2038">                    int stop = Math.min(endoff, off + avail);</span>
<span class="fc bfc" id="L2039" title="All 2 branches covered.">                    while (off &lt; stop) {</span>
<span class="fc" id="L2040">                        Bits.putChar(buf, pos, v[off++]);</span>
<span class="fc" id="L2041">                        pos += 2;</span>
                    }
<span class="fc" id="L2043">                } else {</span>
<span class="nc" id="L2044">                    dout.writeChar(v[off++]);</span>
                }
            }
<span class="fc" id="L2047">        }</span>

        void writeShorts(short[] v, int off, int len) throws IOException {
<span class="fc" id="L2050">            int limit = MAX_BLOCK_SIZE - 2;</span>
<span class="fc" id="L2051">            int endoff = off + len;</span>
<span class="fc bfc" id="L2052" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="pc bpc" id="L2053" title="1 of 2 branches missed.">                if (pos &lt;= limit) {</span>
<span class="fc" id="L2054">                    int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 1;</span>
<span class="fc" id="L2055">                    int stop = Math.min(endoff, off + avail);</span>
<span class="fc bfc" id="L2056" title="All 2 branches covered.">                    while (off &lt; stop) {</span>
<span class="fc" id="L2057">                        Bits.putShort(buf, pos, v[off++]);</span>
<span class="fc" id="L2058">                        pos += 2;</span>
                    }
<span class="fc" id="L2060">                } else {</span>
<span class="nc" id="L2061">                    dout.writeShort(v[off++]);</span>
                }
            }
<span class="fc" id="L2064">        }</span>

        void writeInts(int[] v, int off, int len) throws IOException {
<span class="fc" id="L2067">            int limit = MAX_BLOCK_SIZE - 4;</span>
<span class="fc" id="L2068">            int endoff = off + len;</span>
<span class="fc bfc" id="L2069" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="fc bfc" id="L2070" title="All 2 branches covered.">                if (pos &lt;= limit) {</span>
<span class="fc" id="L2071">                    int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 2;</span>
<span class="fc" id="L2072">                    int stop = Math.min(endoff, off + avail);</span>
<span class="fc bfc" id="L2073" title="All 2 branches covered.">                    while (off &lt; stop) {</span>
<span class="fc" id="L2074">                        Bits.putInt(buf, pos, v[off++]);</span>
<span class="fc" id="L2075">                        pos += 4;</span>
                    }
<span class="fc" id="L2077">                } else {</span>
<span class="fc" id="L2078">                    dout.writeInt(v[off++]);</span>
                }
            }
<span class="fc" id="L2081">        }</span>

        void writeFloats(float[] v, int off, int len) throws IOException {
<span class="fc" id="L2084">            int limit = MAX_BLOCK_SIZE - 4;</span>
<span class="fc" id="L2085">            int endoff = off + len;</span>
<span class="fc bfc" id="L2086" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="pc bpc" id="L2087" title="1 of 2 branches missed.">                if (pos &lt;= limit) {</span>
<span class="fc" id="L2088">                    int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 2;</span>
<span class="fc" id="L2089">                    int chunklen = Math.min(endoff - off, avail);</span>
<span class="fc" id="L2090">                    floatsToBytes(v, off, buf, pos, chunklen);</span>
<span class="fc" id="L2091">                    off += chunklen;</span>
<span class="fc" id="L2092">                    pos += chunklen &lt;&lt; 2;</span>
<span class="fc" id="L2093">                } else {</span>
<span class="nc" id="L2094">                    dout.writeFloat(v[off++]);</span>
                }
            }
<span class="fc" id="L2097">        }</span>

        void writeLongs(long[] v, int off, int len) throws IOException {
<span class="fc" id="L2100">            int limit = MAX_BLOCK_SIZE - 8;</span>
<span class="fc" id="L2101">            int endoff = off + len;</span>
<span class="fc bfc" id="L2102" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="fc bfc" id="L2103" title="All 2 branches covered.">                if (pos &lt;= limit) {</span>
<span class="fc" id="L2104">                    int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 3;</span>
<span class="fc" id="L2105">                    int stop = Math.min(endoff, off + avail);</span>
<span class="fc bfc" id="L2106" title="All 2 branches covered.">                    while (off &lt; stop) {</span>
<span class="fc" id="L2107">                        Bits.putLong(buf, pos, v[off++]);</span>
<span class="fc" id="L2108">                        pos += 8;</span>
                    }
<span class="fc" id="L2110">                } else {</span>
<span class="fc" id="L2111">                    dout.writeLong(v[off++]);</span>
                }
            }
<span class="fc" id="L2114">        }</span>

        void writeDoubles(double[] v, int off, int len) throws IOException {
<span class="fc" id="L2117">            int limit = MAX_BLOCK_SIZE - 8;</span>
<span class="fc" id="L2118">            int endoff = off + len;</span>
<span class="fc bfc" id="L2119" title="All 2 branches covered.">            while (off &lt; endoff) {</span>
<span class="fc bfc" id="L2120" title="All 2 branches covered.">                if (pos &lt;= limit) {</span>
<span class="fc" id="L2121">                    int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 3;</span>
<span class="fc" id="L2122">                    int chunklen = Math.min(endoff - off, avail);</span>
<span class="fc" id="L2123">                    doublesToBytes(v, off, buf, pos, chunklen);</span>
<span class="fc" id="L2124">                    off += chunklen;</span>
<span class="fc" id="L2125">                    pos += chunklen &lt;&lt; 3;</span>
<span class="fc" id="L2126">                } else {</span>
<span class="fc" id="L2127">                    dout.writeDouble(v[off++]);</span>
                }
            }
<span class="fc" id="L2130">        }</span>

        /**
         * Returns the length in bytes of the UTF encoding of the given string.
         */
        long getUTFLength(String s) {
<span class="fc" id="L2136">            int len = s.length();</span>
<span class="fc" id="L2137">            long utflen = 0;</span>
<span class="fc bfc" id="L2138" title="All 2 branches covered.">            for (int off = 0; off &lt; len; ) {</span>
<span class="fc" id="L2139">                int csize = Math.min(len - off, CHAR_BUF_SIZE);</span>
<span class="fc" id="L2140">                s.getChars(off, off + csize, cbuf, 0);</span>
<span class="fc bfc" id="L2141" title="All 2 branches covered.">                for (int cpos = 0; cpos &lt; csize; cpos++) {</span>
<span class="fc" id="L2142">                    char c = cbuf[cpos];</span>
<span class="fc bfc" id="L2143" title="All 4 branches covered.">                    if (c &gt;= 0x0001 &amp;&amp; c &lt;= 0x007F) {</span>
<span class="fc" id="L2144">                        utflen++;</span>
<span class="fc bfc" id="L2145" title="All 2 branches covered.">                    } else if (c &gt; 0x07FF) {</span>
<span class="fc" id="L2146">                        utflen += 3;</span>
                    } else {
<span class="fc" id="L2148">                        utflen += 2;</span>
                    }
                }
<span class="fc" id="L2151">                off += csize;</span>
<span class="fc" id="L2152">            }</span>
<span class="fc" id="L2153">            return utflen;</span>
        }

        /**
         * Writes the given string in UTF format.  This method is used in
         * situations where the UTF encoding length of the string is already
         * known; specifying it explicitly avoids a prescan of the string to
         * determine its UTF length.
         */
        void writeUTF(String s, long utflen) throws IOException {
<span class="pc bpc" id="L2163" title="1 of 2 branches missed.">            if (utflen &gt; 0xFFFFL) {</span>
<span class="nc" id="L2164">                throw new UTFDataFormatException();</span>
            }
<span class="fc" id="L2166">            writeShort((int) utflen);</span>
<span class="fc bfc" id="L2167" title="All 2 branches covered.">            if (utflen == (long) s.length()) {</span>
<span class="fc" id="L2168">                writeBytes(s);</span>
            } else {
<span class="fc" id="L2170">                writeUTFBody(s);</span>
            }
<span class="fc" id="L2172">        }</span>

        /**
         * Writes given string in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
         * identical to standard UTF, except that it uses an 8 byte header
         * (instead of the standard 2 bytes) to convey the UTF encoding length.
         */
        void writeLongUTF(String s) throws IOException {
<span class="nc" id="L2180">            writeLongUTF(s, getUTFLength(s));</span>
<span class="nc" id="L2181">        }</span>

        /**
         * Writes given string in &quot;long&quot; UTF format, where the UTF encoding
         * length of the string is already known.
         */
        void writeLongUTF(String s, long utflen) throws IOException {
<span class="nc" id="L2188">            writeLong(utflen);</span>
<span class="nc bnc" id="L2189" title="All 2 branches missed.">            if (utflen == (long) s.length()) {</span>
<span class="nc" id="L2190">                writeBytes(s);</span>
            } else {
<span class="nc" id="L2192">                writeUTFBody(s);</span>
            }
<span class="nc" id="L2194">        }</span>

        /**
         * Writes the &quot;body&quot; (i.e., the UTF representation minus the 2-byte or
         * 8-byte length header) of the UTF encoding for the given string.
         */
        private void writeUTFBody(String s) throws IOException {
<span class="fc" id="L2201">            int limit = MAX_BLOCK_SIZE - 3;</span>
<span class="fc" id="L2202">            int len = s.length();</span>
<span class="fc bfc" id="L2203" title="All 2 branches covered.">            for (int off = 0; off &lt; len; ) {</span>
<span class="fc" id="L2204">                int csize = Math.min(len - off, CHAR_BUF_SIZE);</span>
<span class="fc" id="L2205">                s.getChars(off, off + csize, cbuf, 0);</span>
<span class="fc bfc" id="L2206" title="All 2 branches covered.">                for (int cpos = 0; cpos &lt; csize; cpos++) {</span>
<span class="fc" id="L2207">                    char c = cbuf[cpos];</span>
<span class="pc bpc" id="L2208" title="1 of 2 branches missed.">                    if (pos &lt;= limit) {</span>
<span class="fc bfc" id="L2209" title="All 4 branches covered.">                        if (c &lt;= 0x007F &amp;&amp; c != 0) {</span>
<span class="fc" id="L2210">                            buf[pos++] = (byte) c;</span>
<span class="fc bfc" id="L2211" title="All 2 branches covered.">                        } else if (c &gt; 0x07FF) {</span>
<span class="fc" id="L2212">                            buf[pos + 2] = (byte) (0x80 | ((c &gt;&gt; 0) &amp; 0x3F));</span>
<span class="fc" id="L2213">                            buf[pos + 1] = (byte) (0x80 | ((c &gt;&gt; 6) &amp; 0x3F));</span>
<span class="fc" id="L2214">                            buf[pos + 0] = (byte) (0xE0 | ((c &gt;&gt; 12) &amp; 0x0F));</span>
<span class="fc" id="L2215">                            pos += 3;</span>
                        } else {
<span class="fc" id="L2217">                            buf[pos + 1] = (byte) (0x80 | ((c &gt;&gt; 0) &amp; 0x3F));</span>
<span class="fc" id="L2218">                            buf[pos + 0] = (byte) (0xC0 | ((c &gt;&gt; 6) &amp; 0x1F));</span>
<span class="fc" id="L2219">                            pos += 2;</span>
                        }
                    } else {    // write one byte at a time to normalize block
<span class="nc bnc" id="L2222" title="All 4 branches missed.">                        if (c &lt;= 0x007F &amp;&amp; c != 0) {</span>
<span class="nc" id="L2223">                            write(c);</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">                        } else if (c &gt; 0x07FF) {</span>
<span class="nc" id="L2225">                            write(0xE0 | ((c &gt;&gt; 12) &amp; 0x0F));</span>
<span class="nc" id="L2226">                            write(0x80 | ((c &gt;&gt; 6) &amp; 0x3F));</span>
<span class="nc" id="L2227">                            write(0x80 | ((c &gt;&gt; 0) &amp; 0x3F));</span>
                        } else {
<span class="nc" id="L2229">                            write(0xC0 | ((c &gt;&gt; 6) &amp; 0x1F));</span>
<span class="nc" id="L2230">                            write(0x80 | ((c &gt;&gt; 0) &amp; 0x3F));</span>
                        }
                    }
                }
<span class="fc" id="L2234">                off += csize;</span>
<span class="fc" id="L2235">            }</span>
<span class="fc" id="L2236">        }</span>
    }

    /**
     * Lightweight identity hash table which maps objects to integer handles,
     * assigned in ascending order.
     */
    private static class HandleTable {

        /* number of mappings in table/next available handle */
        private int size;
        /* size threshold determining when to expand hash spine */
        private int threshold;
        /* factor for computing size threshold */
        private final float loadFactor;
        /* maps hash value -&gt; candidate handle value */
        private int[] spine;
        /* maps handle value -&gt; next candidate handle value */
        private int[] next;
        /* maps handle value -&gt; associated object */
        private Object[] objs;

        /**
         * Creates new HandleTable with given capacity and load factor.
         */
<span class="fc" id="L2261">        HandleTable(int initialCapacity, float loadFactor) {</span>
<span class="fc" id="L2262">            this.loadFactor = loadFactor;</span>
<span class="fc" id="L2263">            spine = new int[initialCapacity];</span>
<span class="fc" id="L2264">            next = new int[initialCapacity];</span>
<span class="fc" id="L2265">            objs = new Object[initialCapacity];</span>
<span class="fc" id="L2266">            threshold = (int) (initialCapacity * loadFactor);</span>
<span class="fc" id="L2267">            clear();</span>
<span class="fc" id="L2268">        }</span>

        /**
         * Assigns next available handle to given object, and returns handle
         * value.  Handles are assigned in ascending order starting at 0.
         */
        int assign(Object obj) {
<span class="fc bfc" id="L2275" title="All 2 branches covered.">            if (size &gt;= next.length) {</span>
<span class="fc" id="L2276">                growEntries();</span>
            }
<span class="fc bfc" id="L2278" title="All 2 branches covered.">            if (size &gt;= threshold) {</span>
<span class="fc" id="L2279">                growSpine();</span>
            }
<span class="fc" id="L2281">            insert(obj, size);</span>
<span class="fc" id="L2282">            return size++;</span>
        }

        /**
         * Looks up and returns handle associated with given object, or -1 if
         * no mapping found.
         */
        int lookup(Object obj) {
<span class="fc bfc" id="L2290" title="All 2 branches covered.">            if (size == 0) {</span>
<span class="fc" id="L2291">                return -1;</span>
            }
<span class="fc" id="L2293">            int index = hash(obj) % spine.length;</span>
<span class="fc bfc" id="L2294" title="All 2 branches covered.">            for (int i = spine[index]; i &gt;= 0; i = next[i]) {</span>
<span class="fc bfc" id="L2295" title="All 2 branches covered.">                if (objs[i] == obj) {</span>
<span class="fc" id="L2296">                    return i;</span>
                }
            }
<span class="fc" id="L2299">            return -1;</span>
        }

        /**
         * Resets table to its initial (empty) state.
         */
        void clear() {
<span class="fc" id="L2306">            Arrays.fill(spine, -1);</span>
<span class="fc" id="L2307">            Arrays.fill(objs, 0, size, null);</span>
<span class="fc" id="L2308">            size = 0;</span>
<span class="fc" id="L2309">        }</span>

        /**
         * Returns the number of mappings currently in table.
         */
        int size() {
<span class="fc" id="L2315">            return size;</span>
        }

        /**
         * Inserts mapping object -&gt; handle mapping into table.  Assumes table
         * is large enough to accommodate new mapping.
         */
        private void insert(Object obj, int handle) {
<span class="fc" id="L2323">            int index = hash(obj) % spine.length;</span>
<span class="fc" id="L2324">            objs[handle] = obj;</span>
<span class="fc" id="L2325">            next[handle] = spine[index];</span>
<span class="fc" id="L2326">            spine[index] = handle;</span>
<span class="fc" id="L2327">        }</span>

        /**
         * Expands the hash &quot;spine&quot; -- equivalent to increasing the number of
         * buckets in a conventional hash table.
         */
        private void growSpine() {
<span class="fc" id="L2334">            spine = new int[(spine.length &lt;&lt; 1) + 1];</span>
<span class="fc" id="L2335">            threshold = (int) (spine.length * loadFactor);</span>
<span class="fc" id="L2336">            Arrays.fill(spine, -1);</span>
<span class="fc bfc" id="L2337" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L2338">                insert(objs[i], i);</span>
            }
<span class="fc" id="L2340">        }</span>

        /**
         * Increases hash table capacity by lengthening entry arrays.
         */
        private void growEntries() {
<span class="fc" id="L2346">            int newLength = (next.length &lt;&lt; 1) + 1;</span>
<span class="fc" id="L2347">            int[] newNext = new int[newLength];</span>
<span class="fc" id="L2348">            System.arraycopy(next, 0, newNext, 0, size);</span>
<span class="fc" id="L2349">            next = newNext;</span>

<span class="fc" id="L2351">            Object[] newObjs = new Object[newLength];</span>
<span class="fc" id="L2352">            System.arraycopy(objs, 0, newObjs, 0, size);</span>
<span class="fc" id="L2353">            objs = newObjs;</span>
<span class="fc" id="L2354">        }</span>

        /**
         * Returns hash value for given object.
         */
        private int hash(Object obj) {
<span class="fc" id="L2360">            return System.identityHashCode(obj) &amp; 0x7FFFFFFF;</span>
        }
    }

    /**
     * Lightweight identity hash table which maps objects to replacement
     * objects.
     */
    private static class ReplaceTable {

        /* maps object -&gt; index */
        private final HandleTable htab;
        /* maps index -&gt; replacement object */
        private Object[] reps;

        /**
         * Creates new ReplaceTable with given capacity and load factor.
         */
<span class="fc" id="L2378">        ReplaceTable(int initialCapacity, float loadFactor) {</span>
<span class="fc" id="L2379">            htab = new HandleTable(initialCapacity, loadFactor);</span>
<span class="fc" id="L2380">            reps = new Object[initialCapacity];</span>
<span class="fc" id="L2381">        }</span>

        /**
         * Enters mapping from object to replacement object.
         */
        void assign(Object obj, Object rep) {
<span class="fc" id="L2387">            int index = htab.assign(obj);</span>
<span class="fc bfc" id="L2388" title="All 2 branches covered.">            while (index &gt;= reps.length) {</span>
<span class="fc" id="L2389">                grow();</span>
            }
<span class="fc" id="L2391">            reps[index] = rep;</span>
<span class="fc" id="L2392">        }</span>

        /**
         * Looks up and returns replacement for given object.  If no
         * replacement is found, returns the lookup object itself.
         */
        Object lookup(Object obj) {
<span class="fc" id="L2399">            int index = htab.lookup(obj);</span>
<span class="fc bfc" id="L2400" title="All 2 branches covered.">            return (index &gt;= 0) ? reps[index] : obj;</span>
        }

        /**
         * Resets table to its initial (empty) state.
         */
        void clear() {
<span class="fc" id="L2407">            Arrays.fill(reps, 0, htab.size(), null);</span>
<span class="fc" id="L2408">            htab.clear();</span>
<span class="fc" id="L2409">        }</span>

        /**
         * Returns the number of mappings currently in table.
         */
        int size() {
<span class="nc" id="L2415">            return htab.size();</span>
        }

        /**
         * Increases table capacity.
         */
        private void grow() {
<span class="fc" id="L2422">            Object[] newReps = new Object[(reps.length &lt;&lt; 1) + 1];</span>
<span class="fc" id="L2423">            System.arraycopy(reps, 0, newReps, 0, reps.length);</span>
<span class="fc" id="L2424">            reps = newReps;</span>
<span class="fc" id="L2425">        }</span>
    }

    /**
     * Stack to keep debug information about the state of the
     * serialization process, for embedding in exception messages.
     */
    private static class DebugTraceInfoStack {
        private final List&lt;String&gt; stack;

<span class="nc" id="L2435">        DebugTraceInfoStack() {</span>
<span class="nc" id="L2436">            stack = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2437">        }</span>

        /**
         * Removes all of the elements from enclosed list.
         */
        void clear() {
<span class="nc" id="L2443">            stack.clear();</span>
<span class="nc" id="L2444">        }</span>

        /**
         * Removes the object at the top of enclosed list.
         */
        void pop() {
<span class="nc" id="L2450">            stack.remove(stack.size()-1);</span>
<span class="nc" id="L2451">        }</span>

        /**
         * Pushes a String onto the top of enclosed list.
         */
        void push(String entry) {
<span class="nc" id="L2457">            stack.add(&quot;\t- &quot; + entry);</span>
<span class="nc" id="L2458">        }</span>

        /**
         * Returns a string representation of this object
         */
        public String toString() {
<span class="nc" id="L2464">            StringBuilder buffer = new StringBuilder();</span>
<span class="nc bnc" id="L2465" title="All 2 branches missed.">            if (!stack.isEmpty()) {</span>
<span class="nc bnc" id="L2466" title="All 2 branches missed.">                for(int i = stack.size(); i &gt; 0; i-- ) {</span>
<span class="nc bnc" id="L2467" title="All 2 branches missed.">                    buffer.append(stack.get(i-1) + ((i != 1) ? &quot;\n&quot; : &quot;&quot;));</span>
                }
            }
<span class="nc" id="L2470">            return buffer.toString();</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>