<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>InstrumentationImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.instrument</a> &gt; <span class="el_source">InstrumentationImpl.java</span></div><h1>InstrumentationImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package sun.instrument;

import java.lang.reflect.Method;
import java.lang.reflect.AccessibleObject;

import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.ClassDefinition;
import java.lang.instrument.Instrumentation;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.ProtectionDomain;

import java.util.jar.JarFile;

/*
 * Copyright 2003 Wily Technology, Inc.
 */

/**
 * The Java side of the JPLIS implementation. Works in concert with a native JVMTI agent
 * to implement the JPLIS API set. Provides both the Java API implementation of
 * the Instrumentation interface and utility Java routines to support the native code.
 * Keeps a pointer to the native data structure in a scalar field to allow native
 * processing behind native methods.
 */
public class InstrumentationImpl implements Instrumentation {
    private final     TransformerManager      mTransformerManager;
    private           TransformerManager      mRetransfomableTransformerManager;
    // needs to store a native pointer, so use 64 bits
    private final     long                    mNativeAgent;
    private final     boolean                 mEnvironmentSupportsRedefineClasses;
    private volatile  boolean                 mEnvironmentSupportsRetransformClassesKnown;
    private volatile  boolean                 mEnvironmentSupportsRetransformClasses;
    private final     boolean                 mEnvironmentSupportsNativeMethodPrefix;

    private
    InstrumentationImpl(long    nativeAgent,
                        boolean environmentSupportsRedefineClasses,
<span class="nc" id="L66">                        boolean environmentSupportsNativeMethodPrefix) {</span>
<span class="nc" id="L67">        mTransformerManager                    = new TransformerManager(false);</span>
<span class="nc" id="L68">        mRetransfomableTransformerManager      = null;</span>
<span class="nc" id="L69">        mNativeAgent                           = nativeAgent;</span>
<span class="nc" id="L70">        mEnvironmentSupportsRedefineClasses    = environmentSupportsRedefineClasses;</span>
<span class="nc" id="L71">        mEnvironmentSupportsRetransformClassesKnown = false; // false = need to ask</span>
<span class="nc" id="L72">        mEnvironmentSupportsRetransformClasses = false;      // don't know yet</span>
<span class="nc" id="L73">        mEnvironmentSupportsNativeMethodPrefix = environmentSupportsNativeMethodPrefix;</span>
<span class="nc" id="L74">    }</span>

    public void
    addTransformer(ClassFileTransformer transformer) {
<span class="nc" id="L78">        addTransformer(transformer, false);</span>
<span class="nc" id="L79">    }</span>

    public synchronized void
    addTransformer(ClassFileTransformer transformer, boolean canRetransform) {
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (transformer == null) {</span>
<span class="nc" id="L84">            throw new NullPointerException(&quot;null passed as 'transformer' in addTransformer&quot;);</span>
        }
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (canRetransform) {</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">            if (!isRetransformClassesSupported()) {</span>
<span class="nc" id="L88">                throw new UnsupportedOperationException(</span>
                  &quot;adding retransformable transformers is not supported in this environment&quot;);
            }
<span class="nc bnc" id="L91" title="All 2 branches missed.">            if (mRetransfomableTransformerManager == null) {</span>
<span class="nc" id="L92">                mRetransfomableTransformerManager = new TransformerManager(true);</span>
            }
<span class="nc" id="L94">            mRetransfomableTransformerManager.addTransformer(transformer);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (mRetransfomableTransformerManager.getTransformerCount() == 1) {</span>
<span class="nc" id="L96">                setHasRetransformableTransformers(mNativeAgent, true);</span>
            }
        } else {
<span class="nc" id="L99">            mTransformerManager.addTransformer(transformer);</span>
        }
<span class="nc" id="L101">    }</span>

    public synchronized boolean
    removeTransformer(ClassFileTransformer transformer) {
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (transformer == null) {</span>
<span class="nc" id="L106">            throw new NullPointerException(&quot;null passed as 'transformer' in removeTransformer&quot;);</span>
        }
<span class="nc" id="L108">        TransformerManager mgr = findTransformerManager(transformer);</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (mgr != null) {</span>
<span class="nc" id="L110">            mgr.removeTransformer(transformer);</span>
<span class="nc bnc" id="L111" title="All 4 branches missed.">            if (mgr.isRetransformable() &amp;&amp; mgr.getTransformerCount() == 0) {</span>
<span class="nc" id="L112">                setHasRetransformableTransformers(mNativeAgent, false);</span>
            }
<span class="nc" id="L114">            return true;</span>
        }
<span class="nc" id="L116">        return false;</span>
    }

    public boolean
    isModifiableClass(Class&lt;?&gt; theClass) {
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (theClass == null) {</span>
<span class="nc" id="L122">            throw new NullPointerException(</span>
                         &quot;null passed as 'theClass' in isModifiableClass&quot;);
        }
<span class="nc" id="L125">        return isModifiableClass0(mNativeAgent, theClass);</span>
    }

    public boolean
    isRetransformClassesSupported() {
        // ask lazily since there is some overhead
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (!mEnvironmentSupportsRetransformClassesKnown) {</span>
<span class="nc" id="L132">            mEnvironmentSupportsRetransformClasses = isRetransformClassesSupported0(mNativeAgent);</span>
<span class="nc" id="L133">            mEnvironmentSupportsRetransformClassesKnown = true;</span>
        }
<span class="nc" id="L135">        return mEnvironmentSupportsRetransformClasses;</span>
    }

    public void
    retransformClasses(Class&lt;?&gt;... classes) {
<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (!isRetransformClassesSupported()) {</span>
<span class="nc" id="L141">            throw new UnsupportedOperationException(</span>
              &quot;retransformClasses is not supported in this environment&quot;);
        }
<span class="nc" id="L144">        retransformClasses0(mNativeAgent, classes);</span>
<span class="nc" id="L145">    }</span>

    public boolean
    isRedefineClassesSupported() {
<span class="nc" id="L149">        return mEnvironmentSupportsRedefineClasses;</span>
    }

    public void
    redefineClasses(ClassDefinition...  definitions)
            throws  ClassNotFoundException {
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (!isRedefineClassesSupported()) {</span>
<span class="nc" id="L156">            throw new UnsupportedOperationException(&quot;redefineClasses is not supported in this environment&quot;);</span>
        }
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (definitions == null) {</span>
<span class="nc" id="L159">            throw new NullPointerException(&quot;null passed as 'definitions' in redefineClasses&quot;);</span>
        }
<span class="nc bnc" id="L161" title="All 2 branches missed.">        for (int i = 0; i &lt; definitions.length; ++i) {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (definitions[i] == null) {</span>
<span class="nc" id="L163">                throw new NullPointerException(&quot;element of 'definitions' is null in redefineClasses&quot;);</span>
            }
        }
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (definitions.length == 0) {</span>
<span class="nc" id="L167">            return; // short-circuit if there are no changes requested</span>
        }

<span class="nc" id="L170">        redefineClasses0(mNativeAgent, definitions);</span>
<span class="nc" id="L171">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    public Class[]
    getAllLoadedClasses() {
<span class="nc" id="L176">        return getAllLoadedClasses0(mNativeAgent);</span>
    }

    @SuppressWarnings(&quot;rawtypes&quot;)
    public Class[]
    getInitiatedClasses(ClassLoader loader) {
<span class="nc" id="L182">        return getInitiatedClasses0(mNativeAgent, loader);</span>
    }

    public long
    getObjectSize(Object objectToSize) {
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (objectToSize == null) {</span>
<span class="nc" id="L188">            throw new NullPointerException(&quot;null passed as 'objectToSize' in getObjectSize&quot;);</span>
        }
<span class="nc" id="L190">        return getObjectSize0(mNativeAgent, objectToSize);</span>
    }

    public void
    appendToBootstrapClassLoaderSearch(JarFile jarfile) {
<span class="nc" id="L195">        appendToClassLoaderSearch0(mNativeAgent, jarfile.getName(), true);</span>
<span class="nc" id="L196">    }</span>

    public void
    appendToSystemClassLoaderSearch(JarFile jarfile) {
<span class="nc" id="L200">        appendToClassLoaderSearch0(mNativeAgent, jarfile.getName(), false);</span>
<span class="nc" id="L201">    }</span>

    public boolean
    isNativeMethodPrefixSupported() {
<span class="nc" id="L205">        return mEnvironmentSupportsNativeMethodPrefix;</span>
    }

    public synchronized void
    setNativeMethodPrefix(ClassFileTransformer transformer, String prefix) {
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (!isNativeMethodPrefixSupported()) {</span>
<span class="nc" id="L211">            throw new UnsupportedOperationException(</span>
                   &quot;setNativeMethodPrefix is not supported in this environment&quot;);
        }
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (transformer == null) {</span>
<span class="nc" id="L215">            throw new NullPointerException(</span>
                       &quot;null passed as 'transformer' in setNativeMethodPrefix&quot;);
        }
<span class="nc" id="L218">        TransformerManager mgr = findTransformerManager(transformer);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (mgr == null) {</span>
<span class="nc" id="L220">            throw new IllegalArgumentException(</span>
                       &quot;transformer not registered in setNativeMethodPrefix&quot;);
        }
<span class="nc" id="L223">        mgr.setNativeMethodPrefix(transformer, prefix);</span>
<span class="nc" id="L224">        String[] prefixes = mgr.getNativeMethodPrefixes();</span>
<span class="nc" id="L225">        setNativeMethodPrefixes(mNativeAgent, prefixes, mgr.isRetransformable());</span>
<span class="nc" id="L226">    }</span>

    private TransformerManager
    findTransformerManager(ClassFileTransformer transformer) {
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (mTransformerManager.includesTransformer(transformer)) {</span>
<span class="nc" id="L231">            return mTransformerManager;</span>
        }
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (mRetransfomableTransformerManager != null &amp;&amp;</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                mRetransfomableTransformerManager.includesTransformer(transformer)) {</span>
<span class="nc" id="L235">            return mRetransfomableTransformerManager;</span>
        }
<span class="nc" id="L237">        return null;</span>
    }


    /*
     *  Natives
     */
    private native boolean
    isModifiableClass0(long nativeAgent, Class&lt;?&gt; theClass);

    private native boolean
    isRetransformClassesSupported0(long nativeAgent);

    private native void
    setHasRetransformableTransformers(long nativeAgent, boolean has);

    private native void
    retransformClasses0(long nativeAgent, Class&lt;?&gt;[] classes);

    private native void
    redefineClasses0(long nativeAgent, ClassDefinition[]  definitions)
        throws  ClassNotFoundException;

    @SuppressWarnings(&quot;rawtypes&quot;)
    private native Class[]
    getAllLoadedClasses0(long nativeAgent);

    @SuppressWarnings(&quot;rawtypes&quot;)
    private native Class[]
    getInitiatedClasses0(long nativeAgent, ClassLoader loader);

    private native long
    getObjectSize0(long nativeAgent, Object objectToSize);

    private native void
    appendToClassLoaderSearch0(long nativeAgent, String jarfile, boolean bootLoader);

    private native void
    setNativeMethodPrefixes(long nativeAgent, String[] prefixes, boolean isRetransformable);

    static {
<span class="nc" id="L278">        System.loadLibrary(&quot;instrument&quot;);</span>
<span class="nc" id="L279">    }</span>

    /*
     *  Internals
     */


    // Enable or disable Java programming language access checks on a
    // reflected object (for example, a method)
    private static void setAccessible(final AccessibleObject ao, final boolean accessible) {
<span class="nc" id="L289">        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {</span>
                public Object run() {
<span class="nc" id="L291">                    ao.setAccessible(accessible);</span>
<span class="nc" id="L292">                    return null;</span>
                }});
<span class="nc" id="L294">    }</span>

    // Attempt to load and start an agent
    private void
    loadClassAndStartAgent( String  classname,
                            String  methodname,
                            String  optionsString)
            throws Throwable {

<span class="nc" id="L303">        ClassLoader mainAppLoader   = ClassLoader.getSystemClassLoader();</span>
<span class="nc" id="L304">        Class&lt;?&gt;    javaAgentClass  = mainAppLoader.loadClass(classname);</span>

<span class="nc" id="L306">        Method m = null;</span>
<span class="nc" id="L307">        NoSuchMethodException firstExc = null;</span>
<span class="nc" id="L308">        boolean twoArgAgent = false;</span>

        // The agent class must have a premain or agentmain method that
        // has 1 or 2 arguments. We check in the following order:
        //
        // 1) declared with a signature of (String, Instrumentation)
        // 2) declared with a signature of (String)
        // 3) inherited with a signature of (String, Instrumentation)
        // 4) inherited with a signature of (String)
        //
        // So the declared version of either 1-arg or 2-arg always takes
        // primary precedence over an inherited version. After that, the
        // 2-arg version takes precedence over the 1-arg version.
        //
        // If no method is found then we throw the NoSuchMethodException
        // from the first attempt so that the exception text indicates
        // the lookup failed for the 2-arg method (same as JDK5.0).

        try {
<span class="nc" id="L327">            m = javaAgentClass.getDeclaredMethod( methodname,</span>
                                 new Class&lt;?&gt;[] {
                                     String.class,
                                     java.lang.instrument.Instrumentation.class
                                 }
                               );
<span class="nc" id="L333">            twoArgAgent = true;</span>
<span class="nc" id="L334">        } catch (NoSuchMethodException x) {</span>
            // remember the NoSuchMethodException
<span class="nc" id="L336">            firstExc = x;</span>
<span class="nc" id="L337">        }</span>

<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (m == null) {</span>
            // now try the declared 1-arg method
            try {
<span class="nc" id="L342">                m = javaAgentClass.getDeclaredMethod(methodname,</span>
                                                 new Class&lt;?&gt;[] { String.class });
<span class="nc" id="L344">            } catch (NoSuchMethodException x) {</span>
                // ignore this exception because we'll try
                // two arg inheritance next
<span class="nc" id="L347">            }</span>
        }

<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (m == null) {</span>
            // now try the inherited 2-arg method
            try {
<span class="nc" id="L353">                m = javaAgentClass.getMethod( methodname,</span>
                                 new Class&lt;?&gt;[] {
                                     String.class,
                                     java.lang.instrument.Instrumentation.class
                                 }
                               );
<span class="nc" id="L359">                twoArgAgent = true;</span>
<span class="nc" id="L360">            } catch (NoSuchMethodException x) {</span>
                // ignore this exception because we'll try
                // one arg inheritance next
<span class="nc" id="L363">            }</span>
        }

<span class="nc bnc" id="L366" title="All 2 branches missed.">        if (m == null) {</span>
            // finally try the inherited 1-arg method
            try {
<span class="nc" id="L369">                m = javaAgentClass.getMethod(methodname,</span>
                                             new Class&lt;?&gt;[] { String.class });
<span class="nc" id="L371">            } catch (NoSuchMethodException x) {</span>
                // none of the methods exists so we throw the
                // first NoSuchMethodException as per 5.0
<span class="nc" id="L374">                throw firstExc;</span>
<span class="nc" id="L375">            }</span>
        }

        // the premain method should not be required to be public,
        // make it accessible so we can call it
        // Note: The spec says the following:
        //     The agent class must implement a public static premain method...
<span class="nc" id="L382">        setAccessible(m, true);</span>

        // invoke the 1 or 2-arg method
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (twoArgAgent) {</span>
<span class="nc" id="L386">            m.invoke(null, new Object[] { optionsString, this });</span>
        } else {
<span class="nc" id="L388">            m.invoke(null, new Object[] { optionsString });</span>
        }

        // don't let others access a non-public premain method
<span class="nc" id="L392">        setAccessible(m, false);</span>
<span class="nc" id="L393">    }</span>

    // WARNING: the native code knows the name &amp; signature of this method
    private void
    loadClassAndCallPremain(    String  classname,
                                String  optionsString)
            throws Throwable {

<span class="nc" id="L401">        loadClassAndStartAgent( classname, &quot;premain&quot;, optionsString );</span>
<span class="nc" id="L402">    }</span>


    // WARNING: the native code knows the name &amp; signature of this method
    private void
    loadClassAndCallAgentmain(  String  classname,
                                String  optionsString)
            throws Throwable {

<span class="nc" id="L411">        loadClassAndStartAgent( classname, &quot;agentmain&quot;, optionsString );</span>
<span class="nc" id="L412">    }</span>

    // WARNING: the native code knows the name &amp; signature of this method
    private byte[]
    transform(  ClassLoader         loader,
                String              classname,
                Class&lt;?&gt;            classBeingRedefined,
                ProtectionDomain    protectionDomain,
                byte[]              classfileBuffer,
                boolean             isRetransformer) {
<span class="nc bnc" id="L422" title="All 2 branches missed.">        TransformerManager mgr = isRetransformer?</span>
                                        mRetransfomableTransformerManager :
                                        mTransformerManager;
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (mgr == null) {</span>
<span class="nc" id="L426">            return null; // no manager, no transform</span>
        } else {
<span class="nc" id="L428">            return mgr.transform(   loader,</span>
                                    classname,
                                    classBeingRedefined,
                                    protectionDomain,
                                    classfileBuffer);
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>