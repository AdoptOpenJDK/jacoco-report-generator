<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractWatchKey.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.nio.fs</a> &gt; <span class="el_source">AbstractWatchKey.java</span></div><h1>AbstractWatchKey.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.fs;

import java.nio.file.*;
import java.util.*;

/**
 * Base implementation class for watch keys.
 */

<span class="pc bpc" id="L35" title="1 of 2 branches missed.">abstract class AbstractWatchKey implements WatchKey {</span>

    /**
     * Maximum size of event list (in the future this may be tunable)
     */
    static final int MAX_EVENT_LIST_SIZE    = 512;

    /**
     * Special event to signal overflow
     */
<span class="fc" id="L45">    static final Event&lt;Object&gt; OVERFLOW_EVENT =</span>
        new Event&lt;Object&gt;(StandardWatchEventKinds.OVERFLOW, null);

    /**
     * Possible key states
     */
<span class="pc" id="L51">    private static enum State { READY, SIGNALLED };</span>

    // reference to watcher
    private final AbstractWatchService watcher;

    // reference to the original directory
    private final Path dir;

    // key state
    private State state;

    // pending events
    private List&lt;WatchEvent&lt;?&gt;&gt; events;

    // maps a context to the last event for the context (iff the last queued
    // event for the context is an ENTRY_MODIFY event).
    private Map&lt;Object,WatchEvent&lt;?&gt;&gt; lastModifyEvents;

<span class="fc" id="L69">    protected AbstractWatchKey(Path dir, AbstractWatchService watcher) {</span>
<span class="fc" id="L70">        this.watcher = watcher;</span>
<span class="fc" id="L71">        this.dir = dir;</span>
<span class="fc" id="L72">        this.state = State.READY;</span>
<span class="fc" id="L73">        this.events = new ArrayList&lt;WatchEvent&lt;?&gt;&gt;();</span>
<span class="fc" id="L74">        this.lastModifyEvents = new HashMap&lt;Object,WatchEvent&lt;?&gt;&gt;();</span>
<span class="fc" id="L75">    }</span>

    final AbstractWatchService watcher() {
<span class="nc" id="L78">        return watcher;</span>
    }

    /**
     * Return the original watchable (Path)
     */
    @Override
    public Path watchable() {
<span class="nc" id="L86">        return dir;</span>
    }

    /**
     * Enqueues this key to the watch service
     */
    final void signal() {
<span class="fc" id="L93">        synchronized (this) {</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">            if (state == State.READY) {</span>
<span class="fc" id="L95">                state = State.SIGNALLED;</span>
<span class="fc" id="L96">                watcher.enqueueKey(this);</span>
            }
<span class="pc" id="L98">        }</span>
<span class="fc" id="L99">    }</span>

    /**
     * Adds the event to this key and signals it.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    final void signalEvent(WatchEvent.Kind&lt;?&gt; kind, Object context) {
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        boolean isModify = (kind == StandardWatchEventKinds.ENTRY_MODIFY);</span>
<span class="fc" id="L107">        synchronized (this) {</span>
<span class="fc" id="L108">            int size = events.size();</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            if (size &gt; 0) {</span>
                // if the previous event is an OVERFLOW event or this is a
                // repeated event then we simply increment the counter
<span class="fc" id="L112">                WatchEvent&lt;?&gt; prev = events.get(size-1);</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">                if ((prev.kind() == StandardWatchEventKinds.OVERFLOW) ||</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">                    ((kind == prev.kind() &amp;&amp;</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                     Objects.equals(context, prev.context()))))</span>
                {
<span class="fc" id="L117">                    ((Event&lt;?&gt;)prev).increment();</span>
<span class="fc" id="L118">                    return;</span>
                }

                // if this is a modify event and the last entry for the context
                // is a modify event then we simply increment the count
<span class="nc bnc" id="L123" title="All 2 branches missed.">                if (!lastModifyEvents.isEmpty()) {</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                    if (isModify) {</span>
<span class="nc" id="L125">                        WatchEvent&lt;?&gt; ev = lastModifyEvents.get(context);</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">                        if (ev != null) {</span>
<span class="nc bnc" id="L127" title="All 4 branches missed.">                            assert ev.kind() == StandardWatchEventKinds.ENTRY_MODIFY;</span>
<span class="nc" id="L128">                            ((Event&lt;?&gt;)ev).increment();</span>
<span class="nc" id="L129">                            return;</span>
                        }
<span class="nc" id="L131">                    } else {</span>
                        // not a modify event so remove from the map as the
                        // last event will no longer be a modify event.
<span class="nc" id="L134">                        lastModifyEvents.remove(context);</span>
                    }
                }

                // if the list has reached the limit then drop pending events
                // and queue an OVERFLOW event
<span class="nc bnc" id="L140" title="All 2 branches missed.">                if (size &gt;= MAX_EVENT_LIST_SIZE) {</span>
<span class="nc" id="L141">                    kind = StandardWatchEventKinds.OVERFLOW;</span>
<span class="nc" id="L142">                    isModify = false;</span>
<span class="nc" id="L143">                    context = null;</span>
                }
            }

            // non-repeated event
<span class="fc" id="L148">            Event&lt;Object&gt; ev =</span>
                new Event&lt;Object&gt;((WatchEvent.Kind&lt;Object&gt;)kind, context);
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">            if (isModify) {</span>
<span class="fc" id="L151">                lastModifyEvents.put(context, ev);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">            } else if (kind == StandardWatchEventKinds.OVERFLOW) {</span>
                // drop all pending events
<span class="nc" id="L154">                events.clear();</span>
<span class="nc" id="L155">                lastModifyEvents.clear();</span>
            }
<span class="fc" id="L157">            events.add(ev);</span>
<span class="fc" id="L158">            signal();</span>
<span class="pc" id="L159">        }</span>
<span class="fc" id="L160">    }</span>

    @Override
    public final List&lt;WatchEvent&lt;?&gt;&gt; pollEvents() {
<span class="fc" id="L164">        synchronized (this) {</span>
<span class="fc" id="L165">            List&lt;WatchEvent&lt;?&gt;&gt; result = events;</span>
<span class="fc" id="L166">            events = new ArrayList&lt;WatchEvent&lt;?&gt;&gt;();</span>
<span class="fc" id="L167">            lastModifyEvents.clear();</span>
<span class="fc" id="L168">            return result;</span>
<span class="nc" id="L169">        }</span>
    }

    @Override
    public final boolean reset() {
<span class="fc" id="L174">        synchronized (this) {</span>
<span class="pc bpc" id="L175" title="2 of 4 branches missed.">            if (state == State.SIGNALLED &amp;&amp; isValid()) {</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">                if (events.isEmpty()) {</span>
<span class="fc" id="L177">                    state = State.READY;</span>
                } else {
                    // pending events so re-queue key
<span class="nc" id="L180">                    watcher.enqueueKey(this);</span>
                }
            }
<span class="fc" id="L183">            return isValid();</span>
<span class="nc" id="L184">        }</span>
    }

    /**
     * WatchEvent implementation
     */
    private static class Event&lt;T&gt; implements WatchEvent&lt;T&gt; {
        private final WatchEvent.Kind&lt;T&gt; kind;
        private final T context;

        // synchronize on watch key to access/increment count
        private int count;

<span class="fc" id="L197">        Event(WatchEvent.Kind&lt;T&gt; type, T context) {</span>
<span class="fc" id="L198">            this.kind = type;</span>
<span class="fc" id="L199">            this.context = context;</span>
<span class="fc" id="L200">            this.count = 1;</span>
<span class="fc" id="L201">        }</span>

        @Override
        public WatchEvent.Kind&lt;T&gt; kind() {
<span class="fc" id="L205">            return kind;</span>
        }

        @Override
        public T context() {
<span class="fc" id="L210">            return context;</span>
        }

        @Override
        public int count() {
<span class="nc" id="L215">            return count;</span>
        }

        // for repeated events
        void increment() {
<span class="fc" id="L220">            count++;</span>
<span class="fc" id="L221">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>