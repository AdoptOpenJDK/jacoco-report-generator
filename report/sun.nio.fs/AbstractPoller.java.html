<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractPoller.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.nio.fs</a> &gt; <span class="el_source">AbstractPoller.java</span></div><h1>AbstractPoller.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.fs;

import java.nio.file.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.io.IOException;
import java.util.*;

/**
 * Base implementation of background poller thread used in watch service
 * implementations. A poller thread waits on events from the file system and
 * also services &quot;requests&quot; from clients to register for new events or cancel
 * existing registrations.
 */

abstract class AbstractPoller implements Runnable {

    // list of requests pending to the poller thread
    private final LinkedList&lt;Request&gt; requestList;

    // set to true when shutdown
    private boolean shutdown;

<span class="fc" id="L49">    protected AbstractPoller() {</span>
<span class="fc" id="L50">        this.requestList = new LinkedList&lt;Request&gt;();</span>
<span class="fc" id="L51">        this.shutdown = false;</span>
<span class="fc" id="L52">    }</span>

    /**
     * Starts the poller thread
     */
    public void start() {
<span class="fc" id="L58">        final Runnable thisRunnable = this;</span>
<span class="fc" id="L59">        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {</span>
            @Override
            public Object run() {
<span class="fc" id="L62">                Thread thr = new Thread(thisRunnable);</span>
<span class="fc" id="L63">                thr.setDaemon(true);</span>
<span class="fc" id="L64">                thr.start();</span>
<span class="fc" id="L65">                return null;</span>
            }
         });
<span class="fc" id="L68">    }</span>

    /**
     * Wakeup poller thread so that it can service pending requests
     */
    abstract void wakeup() throws IOException;

    /**
     * Executed by poller thread to register directory for changes
     */
    abstract Object implRegister(Path path,
                                 Set&lt;? extends WatchEvent.Kind&lt;?&gt;&gt; events,
                                 WatchEvent.Modifier... modifiers);

    /**
     * Executed by poller thread to cancel key
     */
    abstract void implCancelKey(WatchKey key);

    /**
     * Executed by poller thread to shutdown and cancel all keys
     */
    abstract void implCloseAll();

    /**
     * Requests, and waits on, poller thread to register given file.
     */
    final WatchKey register(Path dir,
                            WatchEvent.Kind&lt;?&gt;[] events,
                            WatchEvent.Modifier... modifiers)
        throws IOException
    {
        // validate arguments before request to poller
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (dir == null)</span>
<span class="nc" id="L102">            throw new NullPointerException();</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        if (events.length == 0)</span>
<span class="nc" id="L104">            throw new IllegalArgumentException(&quot;No events to register&quot;);</span>
<span class="fc" id="L105">        Set&lt;WatchEvent.Kind&lt;?&gt;&gt; eventSet = new HashSet&lt;&gt;(events.length);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (WatchEvent.Kind&lt;?&gt; event: events) {</span>
            // standard events
<span class="pc bpc" id="L108" title="1 of 6 branches missed.">            if (event == StandardWatchEventKinds.ENTRY_CREATE ||</span>
                event == StandardWatchEventKinds.ENTRY_MODIFY ||
                event == StandardWatchEventKinds.ENTRY_DELETE)
            {
<span class="fc" id="L112">                eventSet.add(event);</span>
<span class="fc" id="L113">                continue;</span>
            }

            // OVERFLOW is ignored
<span class="nc bnc" id="L117" title="All 2 branches missed.">            if (event == StandardWatchEventKinds.OVERFLOW) {</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">                if (events.length == 1)</span>
<span class="nc" id="L119">                    throw new IllegalArgumentException(&quot;No events to register&quot;);</span>
                continue;
            }

            // null/unsupported
<span class="nc bnc" id="L124" title="All 2 branches missed.">            if (event == null)</span>
<span class="nc" id="L125">                throw new NullPointerException(&quot;An element in event set is 'null'&quot;);</span>
<span class="nc" id="L126">            throw new UnsupportedOperationException(event.name());</span>
        }
<span class="fc" id="L128">        return (WatchKey)invoke(RequestType.REGISTER, dir, eventSet, modifiers);</span>
    }

    /**
     * Cancels, and waits on, poller thread to cancel given key.
     */
    final void cancel(WatchKey key) {
        try {
<span class="nc" id="L136">            invoke(RequestType.CANCEL, key);</span>
<span class="nc" id="L137">        } catch (IOException x) {</span>
            // should not happen
<span class="nc" id="L139">            throw new AssertionError(x.getMessage());</span>
<span class="nc" id="L140">        }</span>
<span class="nc" id="L141">    }</span>

    /**
     * Shutdown poller thread
     */
    final void close() throws IOException {
<span class="fc" id="L147">        invoke(RequestType.CLOSE);</span>
<span class="fc" id="L148">    }</span>

    /**
     * Types of request that the poller thread must handle
     */
<span class="pc" id="L153">    private static enum RequestType {</span>
<span class="fc" id="L154">        REGISTER,</span>
<span class="fc" id="L155">        CANCEL,</span>
<span class="fc" id="L156">        CLOSE;</span>
    }

    /**
     * Encapsulates a request (command) to the poller thread.
     */
    private static class Request {
        private final RequestType type;
        private final Object[] params;

<span class="fc" id="L166">        private boolean completed = false;</span>
<span class="fc" id="L167">        private Object result = null;</span>

<span class="fc" id="L169">        Request(RequestType type, Object... params) {</span>
<span class="fc" id="L170">            this.type = type;</span>
<span class="fc" id="L171">            this.params = params;</span>
<span class="fc" id="L172">        }</span>

        RequestType type() {
<span class="fc" id="L175">            return type;</span>
        }

        Object[] parameters() {
<span class="fc" id="L179">            return params;</span>
        }

        void release(Object result) {
<span class="fc" id="L183">            synchronized (this) {</span>
<span class="fc" id="L184">                this.completed = true;</span>
<span class="fc" id="L185">                this.result = result;</span>
<span class="fc" id="L186">                notifyAll();</span>
<span class="pc" id="L187">            }</span>
<span class="fc" id="L188">        }</span>

        /**
         * Await completion of the request. The return value is the result of
         * the request.
         */
        Object awaitResult() {
<span class="fc" id="L195">            synchronized (this) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                while (!completed) {</span>
                    try {
<span class="fc" id="L198">                        wait();</span>
<span class="nc" id="L199">                    } catch (InterruptedException x) {</span>
                        // ignore
<span class="pc" id="L201">                    }</span>
                }
<span class="fc" id="L203">                return result;</span>
<span class="nc" id="L204">            }</span>
        }
    }

    /**
     * Enqueues request to poller thread and waits for result
     */
    private Object invoke(RequestType type, Object... params) throws IOException {
        // submit request
<span class="fc" id="L213">        Request req = new Request(type, params);</span>
<span class="fc" id="L214">        synchronized (requestList) {</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">            if (shutdown) {</span>
<span class="nc" id="L216">                throw new ClosedWatchServiceException();</span>
            }
<span class="fc" id="L218">            requestList.add(req);</span>
<span class="pc" id="L219">        }</span>

        // wakeup thread
<span class="fc" id="L222">        wakeup();</span>

        // wait for result
<span class="fc" id="L225">        Object result = req.awaitResult();</span>

<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (result instanceof RuntimeException)</span>
<span class="fc" id="L228">            throw (RuntimeException)result;</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (result instanceof IOException )</span>
<span class="nc" id="L230">            throw (IOException)result;</span>
<span class="fc" id="L231">        return result;</span>
    }

    /**
     * Invoked by poller thread to process all pending requests
     *
     * @return  true if poller thread should shutdown
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    boolean processRequests() {
<span class="fc" id="L241">        synchronized (requestList) {</span>
            Request req;
<span class="fc bfc" id="L243" title="All 2 branches covered.">            while ((req = requestList.poll()) != null) {</span>
                // if in process of shutdown then reject request
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">                if (shutdown) {</span>
<span class="nc" id="L246">                    req.release(new ClosedWatchServiceException());</span>
                }

<span class="pc bpc" id="L249" title="2 of 4 branches missed.">                switch (req.type()) {</span>
                    /**
                     * Register directory
                     */
                    case REGISTER: {
<span class="fc" id="L254">                        Object[] params = req.parameters();</span>
<span class="fc" id="L255">                        Path path = (Path)params[0];</span>
<span class="fc" id="L256">                        Set&lt;? extends WatchEvent.Kind&lt;?&gt;&gt; events =</span>
                            (Set&lt;? extends WatchEvent.Kind&lt;?&gt;&gt;)params[1];
<span class="fc" id="L258">                        WatchEvent.Modifier[] modifiers =</span>
                            (WatchEvent.Modifier[])params[2];
<span class="fc" id="L260">                        req.release(implRegister(path, events, modifiers));</span>
<span class="fc" id="L261">                        break;</span>
                    }
                    /**
                     * Cancel existing key
                     */
                    case CANCEL : {
<span class="nc" id="L267">                        Object[] params = req.parameters();</span>
<span class="nc" id="L268">                        WatchKey key = (WatchKey)params[0];</span>
<span class="nc" id="L269">                        implCancelKey(key);</span>
<span class="nc" id="L270">                        req.release(null);</span>
<span class="nc" id="L271">                        break;</span>
                    }
                    /**
                     * Close watch service
                     */
                    case CLOSE: {
<span class="fc" id="L277">                        implCloseAll();</span>
<span class="fc" id="L278">                        req.release(null);</span>
<span class="fc" id="L279">                        shutdown = true;</span>
<span class="fc" id="L280">                        break;</span>
                    }

                    default:
<span class="nc" id="L284">                        req.release(new IOException(&quot;request not recognized&quot;));</span>
                }
            }
<span class="pc" id="L287">        }</span>
<span class="fc" id="L288">        return shutdown;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>