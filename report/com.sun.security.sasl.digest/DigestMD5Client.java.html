<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DigestMD5Client.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.security.sasl.digest</a> &gt; <span class="el_source">DigestMD5Client.java</span></div><h1>DigestMD5Client.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.security.sasl.digest;

import java.security.NoSuchAlgorithmException;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.StringTokenizer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Arrays;

import java.util.logging.Level;

import javax.security.sasl.*;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.PasswordCallback;
import javax.security.auth.callback.NameCallback;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.UnsupportedCallbackException;

/**
  * An implementation of the DIGEST-MD5
  * (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2831.txt&quot;&gt;RFC 2831&lt;/a&gt;) SASL
  * (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2222.txt&quot;&gt;RFC 2222&lt;/a&gt;) mechanism.
  *
  * The DIGEST-MD5 SASL mechanism specifies two modes of authentication.
  * - Initial Authentication
  * - Subsequent Authentication - optional, (currently unsupported)
  *
  * Required callbacks:
  * - RealmChoiceCallback
  *    shows user list of realms server has offered; handler must choose one
  *    from list
  * - RealmCallback
  *    shows user the only realm server has offered or none; handler must
  *    enter realm to use
  * - NameCallback
  *    handler must enter username to use for authentication
  * - PasswordCallback
  *    handler must enter password for username to use for authentication
  *
  * Environment properties that affect behavior of implementation:
  *
  * javax.security.sasl.qop
  *    quality of protection; list of auth, auth-int, auth-conf; default is &quot;auth&quot;
  * javax.security.sasl.strength
  *    auth-conf strength; list of high, medium, low; default is highest
  *    available on platform [&quot;high,medium,low&quot;].
  *    high means des3 or rc4 (128); medium des or rc4-56; low is rc4-40;
  *    choice of cipher depends on its availablility on platform
  * javax.security.sasl.maxbuf
  *    max receive buffer size; default is 65536
  * javax.security.sasl.sendmaxbuffer
  *    max send buffer size; default is 65536; (min with server max recv size)
  *
  * com.sun.security.sasl.digest.cipher
  *    name a specific cipher to use; setting must be compatible with the
  *    setting of the javax.security.sasl.strength property.
  *
  * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2222.txt&quot;&gt;RFC 2222&lt;/a&gt;
  * - Simple Authentication and Security Layer (SASL)
  * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2831.txt&quot;&gt;RFC 2831&lt;/a&gt;
  * - Using Digest Authentication as a SASL Mechanism
  * @see &lt;a href=&quot;http://java.sun.com/products/jce&quot;&gt;Java(TM)
  * Cryptography Extension 1.2.1 (JCE)&lt;/a&gt;
  * @see &lt;a href=&quot;http://java.sun.com/products/jaas&quot;&gt;Java(TM)
  * Authentication and Authorization Service (JAAS)&lt;/a&gt;
  *
  * @author Jonathan Bruce
  * @author Rosanna Lee
  */
final class DigestMD5Client extends DigestMD5Base implements SaslClient {
<span class="fc" id="L99">    private static final String MY_CLASS_NAME = DigestMD5Client.class.getName();</span>

    // Property for specifying cipher explicitly
    private static final String CIPHER_PROPERTY =
        &quot;com.sun.security.sasl.digest.cipher&quot;;

    /* Directives encountered in challenges sent by the server. */
<span class="fc" id="L106">    private static final String[] DIRECTIVE_KEY = {</span>
        &quot;realm&quot;,      // &gt;= 0 times
        &quot;qop&quot;,        // atmost once; default is &quot;auth&quot;
        &quot;algorithm&quot;,  // exactly once
        &quot;nonce&quot;,      // exactly once
        &quot;maxbuf&quot;,     // atmost once; default is 65536
        &quot;charset&quot;,    // atmost once; default is ISO 8859-1
        &quot;cipher&quot;,     // exactly once if qop is &quot;auth-conf&quot;
        &quot;rspauth&quot;,    // exactly once in 2nd challenge
        &quot;stale&quot;,      // atmost once for in subsequent auth (not supported)
    };

    /* Indices into DIRECTIVE_KEY */
    private static final int REALM = 0;
    private static final int QOP = 1;
    private static final int ALGORITHM = 2;
    private static final int NONCE = 3;
    private static final int MAXBUF = 4;
    private static final int CHARSET = 5;
    private static final int CIPHER = 6;
    private static final int RESPONSE_AUTH = 7;
    private static final int STALE = 8;

    private int nonceCount; // number of times nonce has been used/seen

    /* User-supplied/generated information */
    private String specifiedCipher;  // cipher explicitly requested by user
    private byte[] cnonce;        // client generated nonce
    private String username;
    private char[] passwd;
    private byte[] authzidBytes;  // byte repr of authzid

    /**
      * Constructor for DIGEST-MD5 mechanism.
      *
      * @param authzid A non-null String representing the principal
      * for which authorization is being granted..
      * @param digestURI A non-null String representing detailing the
      * combined protocol and host being used for authentication.
      * @param props The possibly null properties to be used by the SASL
      * mechanism to configure the authentication exchange.
      * @param cbh The non-null CallbackHanlder object for callbacks
      * @throws SaslException if no authentication ID or password is supplied
      */
    DigestMD5Client(String authzid, String protocol, String serverName,
        Map&lt;String, ?&gt; props, CallbackHandler cbh) throws SaslException {

<span class="fc" id="L153">        super(props, MY_CLASS_NAME, 2, protocol + &quot;/&quot; + serverName, cbh);</span>

        // authzID can only be encoded in UTF8 - RFC 2222
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (authzid != null) {</span>
<span class="fc" id="L157">            this.authzid = authzid;</span>
            try {
<span class="fc" id="L159">                authzidBytes = authzid.getBytes(&quot;UTF8&quot;);</span>

<span class="nc" id="L161">            } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L162">                throw new SaslException(</span>
                    &quot;DIGEST-MD5: Error encoding authzid value into UTF-8&quot;, e);
<span class="fc" id="L164">            }</span>
        }

<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (props != null) {</span>
<span class="fc" id="L168">            specifiedCipher = (String)props.get(CIPHER_PROPERTY);</span>

<span class="fc" id="L170">            logger.log(Level.FINE, &quot;DIGEST60:Explicitly specified cipher: {0}&quot;,</span>
                specifiedCipher);
        }
<span class="fc" id="L173">   }</span>

    /**
     * DIGEST-MD5 has no initial response
     *
     * @return false
     */
    public boolean hasInitialResponse() {
<span class="fc" id="L181">        return false;</span>
    }

    /**
     * Process the challenge data.
     *
     * The server sends a digest-challenge which the client must reply to
     * in a digest-response. When the authentication is complete, the
     * completed field is set to true.
     *
     * @param challengeData A non-null byte array containing the challenge
     * data from the server.
     * @return A possibly null byte array containing the response to
     * be sent to the server.
     *
     * @throws SaslException If the platform does not have MD5 digest support
     * or if the server sends an invalid challenge.
     */
    public byte[] evaluateChallenge(byte[] challengeData) throws SaslException {

<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (challengeData.length &gt; MAX_CHALLENGE_LENGTH) {</span>
<span class="nc" id="L202">            throw new SaslException(</span>
                &quot;DIGEST-MD5: Invalid digest-challenge length. Got:  &quot; +
                challengeData.length + &quot; Expected &lt; &quot; + MAX_CHALLENGE_LENGTH);
        }

        /* Extract and process digest-challenge */
        byte[][] challengeVal;

<span class="pc bpc" id="L210" title="1 of 3 branches missed.">        switch (step) {</span>
        case 2:
            /* Process server's first challenge (from Step 1) */
            /* Get realm, qop, maxbuf, charset, algorithm, cipher, nonce
               directives */
<span class="fc" id="L215">            List&lt;byte[]&gt; realmChoices = new ArrayList&lt;byte[]&gt;(3);</span>
<span class="fc" id="L216">            challengeVal = parseDirectives(challengeData, DIRECTIVE_KEY,</span>
                realmChoices, REALM);

            try {
<span class="fc" id="L220">                processChallenge(challengeVal, realmChoices);</span>
<span class="fc" id="L221">                checkQopSupport(challengeVal[QOP], challengeVal[CIPHER]);</span>
<span class="fc" id="L222">                ++step;</span>
<span class="fc" id="L223">                return generateClientResponse(challengeVal[CHARSET]);</span>
<span class="fc" id="L224">            } catch (SaslException e) {</span>
<span class="fc" id="L225">                step = 0;</span>
<span class="fc" id="L226">                clearPassword();</span>
<span class="fc" id="L227">                throw e; // rethrow</span>
<span class="nc" id="L228">            } catch (IOException e) {</span>
<span class="nc" id="L229">                step = 0;</span>
<span class="nc" id="L230">                clearPassword();</span>
<span class="nc" id="L231">                throw new SaslException(&quot;DIGEST-MD5: Error generating &quot; +</span>
                    &quot;digest response-value&quot;, e);
            }

        case 3:
            try {
                /* Process server's step 3 (server response to digest response) */
                /* Get rspauth directive */
<span class="fc" id="L239">                challengeVal = parseDirectives(challengeData, DIRECTIVE_KEY,</span>
                    null, REALM);
<span class="fc" id="L241">                validateResponseValue(challengeVal[RESPONSE_AUTH]);</span>


                /* Initialize SecurityCtx implementation */
<span class="pc bpc" id="L245" title="3 of 4 branches missed.">                if (integrity &amp;&amp; privacy) {</span>
<span class="nc" id="L246">                    secCtx = new DigestPrivacy(true /* client */);</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">                } else if (integrity) {</span>
<span class="nc" id="L248">                    secCtx = new DigestIntegrity(true /* client */);</span>
                }

<span class="fc" id="L251">                return null; // Mechanism has completed.</span>
            } finally {
<span class="pc" id="L253">                clearPassword();</span>
<span class="pc" id="L254">                step = 0;  // Set to invalid state</span>
<span class="pc" id="L255">                completed = true;</span>
            }

        default:
            // No other possible state
<span class="nc" id="L260">            throw new SaslException(&quot;DIGEST-MD5: Client at illegal state&quot;);</span>
        }
    }


   /**
    * Record information from the challengeVal array into variables/fields.
    * Check directive values that are multi-valued and ensure that mandatory
    * directives not missing from the digest-challenge.
    *
    * @throws SaslException if a sasl is a the mechanism cannot
    * correcly handle a callbacks or if a violation in the
    * digest challenge format is detected.
    */
    private void processChallenge(byte[][] challengeVal, List&lt;byte[]&gt; realmChoices)
        throws SaslException, UnsupportedEncodingException {

        /* CHARSET: optional atmost once */
<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (challengeVal[CHARSET] != null) {</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">            if (!&quot;utf-8&quot;.equals(new String(challengeVal[CHARSET], encoding))) {</span>
<span class="nc" id="L280">                throw new SaslException(&quot;DIGEST-MD5: digest-challenge format &quot; +</span>
                    &quot;violation. Unrecognised charset value: &quot; +
                    new String(challengeVal[CHARSET]));
            } else {
<span class="fc" id="L284">                encoding = &quot;UTF8&quot;;</span>
<span class="fc" id="L285">                useUTF8 = true;</span>
            }
        }

        /* ALGORITHM: required exactly once */
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        if (challengeVal[ALGORITHM] == null) {</span>
<span class="nc" id="L291">            throw new SaslException(&quot;DIGEST-MD5: Digest-challenge format &quot; +</span>
                &quot;violation: algorithm directive missing&quot;);
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        } else if (!&quot;md5-sess&quot;.equals(new String(challengeVal[ALGORITHM], encoding))) {</span>
<span class="nc" id="L294">            throw new SaslException(&quot;DIGEST-MD5: Digest-challenge format &quot; +</span>
                &quot;violation. Invalid value for 'algorithm' directive: &quot; +
                challengeVal[ALGORITHM]);
        }

        /* NONCE: required exactly once */
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if (challengeVal[NONCE] == null) {</span>
<span class="nc" id="L301">            throw new SaslException(&quot;DIGEST-MD5: Digest-challenge format &quot; +</span>
                &quot;violation: nonce directive missing&quot;);
        } else {
<span class="fc" id="L304">            nonce = challengeVal[NONCE];</span>
        }

        try {
            /* REALM: optional, if multiple, stored in realmChoices */
<span class="fc" id="L309">            String[] realmTokens = null;</span>

<span class="pc bpc" id="L311" title="1 of 2 branches missed.">            if (challengeVal[REALM] != null) {</span>
<span class="pc bpc" id="L312" title="1 of 4 branches missed.">                if (realmChoices == null || realmChoices.size() &lt;= 1) {</span>
                    // Only one realm specified
<span class="fc" id="L314">                    negotiatedRealm = new String(challengeVal[REALM], encoding);</span>
                } else {
<span class="fc" id="L316">                    realmTokens = new String[realmChoices.size()];</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">                    for (int i = 0; i &lt; realmTokens.length; i++) {</span>
<span class="fc" id="L318">                        realmTokens[i] =</span>
<span class="fc" id="L319">                            new String(realmChoices.get(i), encoding);</span>
                    }
                }
            }

<span class="fc bfc" id="L324" title="All 2 branches covered.">            NameCallback ncb = authzid == null ?</span>
                new NameCallback(&quot;DIGEST-MD5 authentication ID: &quot;) :
                new NameCallback(&quot;DIGEST-MD5 authentication ID: &quot;, authzid);
<span class="fc" id="L327">            PasswordCallback pcb =</span>
                new PasswordCallback(&quot;DIGEST-MD5 password: &quot;, false);

<span class="fc bfc" id="L330" title="All 2 branches covered.">            if (realmTokens == null) {</span>
                // Server specified &lt;= 1 realm
                // If 0, RFC 2831: the client SHOULD solicit a realm from the user.
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">                RealmCallback tcb =</span>
                    (negotiatedRealm == null? new RealmCallback(&quot;DIGEST-MD5 realm: &quot;) :
                        new RealmCallback(&quot;DIGEST-MD5 realm: &quot;, negotiatedRealm));

<span class="fc" id="L337">                cbh.handle(new Callback[] {tcb, ncb, pcb});</span>

                /* Acquire realm from RealmCallback */
<span class="fc" id="L340">                negotiatedRealm = tcb.getText();</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">                if (negotiatedRealm == null) {</span>
<span class="nc" id="L342">                    negotiatedRealm = &quot;&quot;;</span>
                }
<span class="fc" id="L344">            } else {</span>
<span class="fc" id="L345">                RealmChoiceCallback ccb = new RealmChoiceCallback(</span>
                    &quot;DIGEST-MD5 realm: &quot;,
                    realmTokens,
                    0, false);
<span class="fc" id="L349">                cbh.handle(new Callback[] {ccb, ncb, pcb});</span>

                // Acquire realm from RealmChoiceCallback
<span class="fc" id="L352">                int[] selected = ccb.getSelectedIndexes();</span>
<span class="pc bpc" id="L353" title="1 of 6 branches missed.">                if (selected == null</span>
                        || selected[0] &lt; 0
                        || selected[0] &gt;= realmTokens.length) {
<span class="fc" id="L356">                    throw new SaslException(&quot;DIGEST-MD5: Invalid realm chosen&quot;);</span>
                }
<span class="fc" id="L358">                negotiatedRealm = realmTokens[selected[0]];</span>
            }

<span class="fc" id="L361">            passwd = pcb.getPassword();</span>
<span class="fc" id="L362">            pcb.clearPassword();</span>
<span class="fc" id="L363">            username = ncb.getName();</span>

<span class="fc" id="L365">        } catch (SaslException se) {</span>
<span class="fc" id="L366">            throw se;</span>

<span class="nc" id="L368">        } catch (UnsupportedCallbackException e) {</span>
<span class="nc" id="L369">            throw new SaslException(&quot;DIGEST-MD5: Cannot perform callback to &quot; +</span>
                &quot;acquire realm, authentication ID or password&quot;, e);

<span class="nc" id="L372">        } catch (IOException e) {</span>
<span class="nc" id="L373">            throw new SaslException(</span>
                &quot;DIGEST-MD5: Error acquiring realm, authentication ID or password&quot;, e);
<span class="fc" id="L375">        }</span>

<span class="pc bpc" id="L377" title="2 of 4 branches missed.">        if (username == null || passwd == null) {</span>
<span class="nc" id="L378">            throw new SaslException(</span>
                &quot;DIGEST-MD5: authentication ID and password must be specified&quot;);
        }

        /* MAXBUF: optional atmost once */
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        int srvMaxBufSize =</span>
            (challengeVal[MAXBUF] == null) ? DEFAULT_MAXBUF
<span class="pc" id="L385">            : Integer.parseInt(new String(challengeVal[MAXBUF], encoding));</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        sendMaxBufSize =</span>
            (sendMaxBufSize == 0) ? srvMaxBufSize
<span class="pc" id="L388">            : Math.min(sendMaxBufSize, srvMaxBufSize);</span>
<span class="fc" id="L389">    }</span>

    /**
     * Parses the 'qop' directive. If 'auth-conf' is specified by
     * the client and offered as a QOP option by the server, then a check
     * is client-side supported ciphers is performed.
     *
     * @throws IOException
     */
    private void checkQopSupport(byte[] qopInChallenge, byte[] ciphersInChallenge)
        throws IOException {

        /* QOP: optional; if multiple, merged earlier */
        String qopOptions;

<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (qopInChallenge == null) {</span>
<span class="fc" id="L405">            qopOptions = &quot;auth&quot;;</span>
        } else {
<span class="fc" id="L407">            qopOptions = new String(qopInChallenge, encoding);</span>
        }

        // process
<span class="fc" id="L411">        String[] serverQopTokens = new String[3];</span>
<span class="fc" id="L412">        byte[] serverQop = parseQop(qopOptions, serverQopTokens,</span>
            true /* ignore unrecognized tokens */);
<span class="fc" id="L414">        byte serverAllQop = combineMasks(serverQop);</span>

<span class="pc bpc" id="L416" title="4 of 5 branches missed.">        switch (findPreferredMask(serverAllQop, qop)) {</span>
        case 0:
<span class="nc" id="L418">            throw new SaslException(&quot;DIGEST-MD5: No common protection &quot; +</span>
                &quot;layer between client and server&quot;);

        case NO_PROTECTION:
<span class="fc" id="L422">            negotiatedQop = &quot;auth&quot;;</span>
            // buffer sizes not applicable
<span class="fc" id="L424">            break;</span>

        case INTEGRITY_ONLY_PROTECTION:
<span class="nc" id="L427">            negotiatedQop = &quot;auth-int&quot;;</span>
<span class="nc" id="L428">            integrity = true;</span>
<span class="nc" id="L429">            rawSendSize = sendMaxBufSize - 16;</span>
<span class="nc" id="L430">            break;</span>

        case PRIVACY_PROTECTION:
<span class="nc" id="L433">            negotiatedQop = &quot;auth-conf&quot;;</span>
<span class="nc" id="L434">            privacy = integrity = true;</span>
<span class="nc" id="L435">            rawSendSize = sendMaxBufSize - 26;</span>
<span class="nc" id="L436">            checkStrengthSupport(ciphersInChallenge);</span>
            break;
        }

<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        if (logger.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L441">            logger.log(Level.FINE, &quot;DIGEST61:Raw send size: {0}&quot;,</span>
                new Integer(rawSendSize));
        }
<span class="fc" id="L444">     }</span>

    /**
     * Processes the 'cipher' digest-challenge directive. This allows the
     * mechanism to check for client-side support against the list of
     * supported ciphers send by the server. If no match is found,
     * the mechanism aborts.
     *
     * @throws SaslException If an error is encountered in processing
     * the cipher digest-challenge directive or if no client-side
     * support is found.
     */
    private void checkStrengthSupport(byte[] ciphersInChallenge)
        throws IOException {

        /* CIPHER: required exactly once if qop=auth-conf */
<span class="nc bnc" id="L460" title="All 2 branches missed.">        if (ciphersInChallenge == null) {</span>
<span class="nc" id="L461">            throw new SaslException(&quot;DIGEST-MD5: server did not specify &quot; +</span>
                &quot;cipher to use for 'auth-conf'&quot;);
        }

        // First determine ciphers that server supports
<span class="nc" id="L466">        String cipherOptions = new String(ciphersInChallenge, encoding);</span>
<span class="nc" id="L467">        StringTokenizer parser = new StringTokenizer(cipherOptions, &quot;, \t\n&quot;);</span>
<span class="nc" id="L468">        int tokenCount = parser.countTokens();</span>
<span class="nc" id="L469">        String token = null;</span>
<span class="nc" id="L470">        byte[] serverCiphers = { UNSET,</span>
                                 UNSET,
                                 UNSET,
                                 UNSET,
                                 UNSET };
<span class="nc" id="L475">        String[] serverCipherStrs = new String[serverCiphers.length];</span>

        // Parse ciphers in challenge; mark each that server supports
<span class="nc bnc" id="L478" title="All 2 branches missed.">        for (int i = 0; i &lt; tokenCount; i++) {</span>
<span class="nc" id="L479">            token = parser.nextToken();</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">            for (int j = 0; j &lt; CIPHER_TOKENS.length; j++) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">                if (token.equals(CIPHER_TOKENS[j])) {</span>
<span class="nc" id="L482">                    serverCiphers[j] |= CIPHER_MASKS[j];</span>
<span class="nc" id="L483">                    serverCipherStrs[j] = token; // keep for replay to server</span>
<span class="nc" id="L484">                    logger.log(Level.FINE, &quot;DIGEST62:Server supports {0}&quot;, token);</span>
                }
            }
        }

        // Determine which ciphers are available on client
<span class="nc" id="L490">        byte[] clntCiphers = getPlatformCiphers();</span>

        // Take intersection of server and client supported ciphers
<span class="nc" id="L493">        byte inter = 0;</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">        for (int i = 0; i &lt; serverCiphers.length; i++) {</span>
<span class="nc" id="L495">            serverCiphers[i] &amp;= clntCiphers[i];</span>
<span class="nc" id="L496">            inter |= serverCiphers[i];</span>
        }

<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (inter == UNSET) {</span>
<span class="nc" id="L500">            throw new SaslException(</span>
                &quot;DIGEST-MD5: Client supports none of these cipher suites: &quot; +
                cipherOptions);
        }

        // now have a clear picture of user / client; client / server
        // cipher options. Leverage strength array against what is
        // supported to choose a cipher.
<span class="nc" id="L508">        negotiatedCipher = findCipherAndStrength(serverCiphers, serverCipherStrs);</span>

<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (negotiatedCipher == null) {</span>
<span class="nc" id="L511">            throw new SaslException(&quot;DIGEST-MD5: Unable to negotiate &quot; +</span>
                &quot;a strength level for 'auth-conf'&quot;);
        }
<span class="nc" id="L514">        logger.log(Level.FINE, &quot;DIGEST63:Cipher suite: {0}&quot;, negotiatedCipher);</span>
<span class="nc" id="L515">    }</span>

    /**
     * Steps through the ordered 'strength' array, and compares it with
     * the 'supportedCiphers' array. The cipher returned represents
     * the best possible cipher based on the strength preference and the
     * available ciphers on both the server and client environments.
     *
     * @param tokens The array of cipher tokens sent by server
     * @return The agreed cipher.
     */
    private String findCipherAndStrength(byte[] supportedCiphers,
        String[] tokens) {
        byte s;
<span class="nc bnc" id="L529" title="All 2 branches missed.">        for (int i = 0; i &lt; strength.length; i++) {</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">            if ((s=strength[i]) != 0) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                for (int j = 0; j &lt; supportedCiphers.length; j++) {</span>

                    // If user explicitly requested cipher, then it
                    // must be the one we choose

<span class="nc bnc" id="L536" title="All 4 branches missed.">                    if (s == supportedCiphers[j] &amp;&amp;</span>
                        (specifiedCipher == null ||
<span class="nc bnc" id="L538" title="All 2 branches missed.">                            specifiedCipher.equals(tokens[j]))) {</span>
<span class="nc bnc" id="L539" title="All 4 branches missed.">                        switch (s) {</span>
                        case HIGH_STRENGTH:
<span class="nc" id="L541">                            negotiatedStrength = &quot;high&quot;;</span>
<span class="nc" id="L542">                            break;</span>
                        case MEDIUM_STRENGTH:
<span class="nc" id="L544">                            negotiatedStrength = &quot;medium&quot;;</span>
<span class="nc" id="L545">                            break;</span>
                        case LOW_STRENGTH:
<span class="nc" id="L547">                            negotiatedStrength = &quot;low&quot;;</span>
                            break;
                        }

<span class="nc" id="L551">                        return tokens[j];</span>
                    }
                }
            }
        }

<span class="nc" id="L557">        return null;  // none found</span>
    }

    /**
     * Returns digest-response suitable for an initial authentication.
     *
     * The following are qdstr-val (quoted string values) as per RFC 2831,
     * which means that any embedded quotes must be escaped.
     *    realm-value
     *    nonce-value
     *    username-value
     *    cnonce-value
     *    authzid-value
     * @returns &lt;tt&gt;digest-response&lt;/tt&gt; in a byte array
     * @throws SaslException if there is an error generating the
     * response value or the cnonce value.
     */
    private byte[] generateClientResponse(byte[] charset) throws IOException {

<span class="fc" id="L576">        ByteArrayOutputStream digestResp = new ByteArrayOutputStream();</span>

<span class="fc bfc" id="L578" title="All 2 branches covered.">        if (useUTF8) {</span>
<span class="fc" id="L579">            digestResp.write(&quot;charset=&quot;.getBytes(encoding));</span>
<span class="fc" id="L580">            digestResp.write(charset);</span>
<span class="fc" id="L581">            digestResp.write(',');</span>
        }

<span class="fc" id="L584">        digestResp.write((&quot;username=\&quot;&quot; +</span>
<span class="fc" id="L585">            quotedStringValue(username) + &quot;\&quot;,&quot;).getBytes(encoding));</span>

<span class="pc bpc" id="L587" title="1 of 2 branches missed.">        if (negotiatedRealm.length() &gt; 0) {</span>
<span class="fc" id="L588">            digestResp.write((&quot;realm=\&quot;&quot; +</span>
<span class="fc" id="L589">                quotedStringValue(negotiatedRealm) + &quot;\&quot;,&quot;).getBytes(encoding));</span>
        }

<span class="fc" id="L592">        digestResp.write(&quot;nonce=\&quot;&quot;.getBytes(encoding));</span>
<span class="fc" id="L593">        writeQuotedStringValue(digestResp, nonce);</span>
<span class="fc" id="L594">        digestResp.write('&quot;');</span>
<span class="fc" id="L595">        digestResp.write(',');</span>

<span class="fc" id="L597">        nonceCount = getNonceCount(nonce);</span>
<span class="fc" id="L598">        digestResp.write((&quot;nc=&quot; +</span>
<span class="fc" id="L599">            nonceCountToHex(nonceCount) + &quot;,&quot;).getBytes(encoding));</span>

<span class="fc" id="L601">        cnonce = generateNonce();</span>
<span class="fc" id="L602">        digestResp.write(&quot;cnonce=\&quot;&quot;.getBytes(encoding));</span>
<span class="fc" id="L603">        writeQuotedStringValue(digestResp, cnonce);</span>
<span class="fc" id="L604">        digestResp.write(&quot;\&quot;,&quot;.getBytes(encoding));</span>
<span class="fc" id="L605">        digestResp.write((&quot;digest-uri=\&quot;&quot; + digestUri + &quot;\&quot;,&quot;).getBytes(encoding));</span>

<span class="fc" id="L607">        digestResp.write(&quot;maxbuf=&quot;.getBytes(encoding));</span>
<span class="fc" id="L608">        digestResp.write(String.valueOf(recvMaxBufSize).getBytes(encoding));</span>
<span class="fc" id="L609">        digestResp.write(',');</span>

        try {
<span class="fc" id="L612">            digestResp.write(&quot;response=&quot;.getBytes(encoding));</span>
<span class="fc" id="L613">            digestResp.write(generateResponseValue(&quot;AUTHENTICATE&quot;,</span>
                digestUri, negotiatedQop, username,
                negotiatedRealm, passwd, nonce, cnonce,
                nonceCount, authzidBytes));
<span class="fc" id="L617">            digestResp.write(',');</span>
<span class="nc" id="L618">        } catch (Exception e) {</span>
<span class="nc" id="L619">            throw new SaslException(</span>
                &quot;DIGEST-MD5: Error generating response value&quot;, e);
<span class="fc" id="L621">        }</span>

<span class="fc" id="L623">        digestResp.write((&quot;qop=&quot; + negotiatedQop).getBytes(encoding));</span>

<span class="pc bpc" id="L625" title="1 of 2 branches missed.">        if (negotiatedCipher != null) {</span>
<span class="nc" id="L626">            digestResp.write((&quot;,cipher=\&quot;&quot; + negotiatedCipher + &quot;\&quot;&quot;).getBytes(encoding));</span>
        }

<span class="fc bfc" id="L629" title="All 2 branches covered.">        if (authzidBytes != null) {</span>
<span class="fc" id="L630">            digestResp.write(&quot;,authzid=\&quot;&quot;.getBytes(encoding));</span>
<span class="fc" id="L631">            writeQuotedStringValue(digestResp, authzidBytes);</span>
<span class="fc" id="L632">            digestResp.write(&quot;\&quot;&quot;.getBytes(encoding));</span>
        }

<span class="pc bpc" id="L635" title="1 of 2 branches missed.">        if (digestResp.size() &gt; MAX_RESPONSE_LENGTH) {</span>
<span class="nc" id="L636">            throw new SaslException (&quot;DIGEST-MD5: digest-response size too &quot; +</span>
<span class="nc" id="L637">                &quot;large. Length: &quot;  + digestResp.size());</span>
        }
<span class="fc" id="L639">        return digestResp.toByteArray();</span>
     }


    /**
     * From RFC 2831, Section 2.1.3: Step Three
     * [Server] sends a message formatted as follows:
     *     response-auth = &quot;rspauth&quot; &quot;=&quot; response-value
     * where response-value is calculated as above, using the values sent in
     * step two, except that if qop is &quot;auth&quot;, then A2 is
     *
     *  A2 = { &quot;:&quot;, digest-uri-value }
     *
     * And if qop is &quot;auth-int&quot; or &quot;auth-conf&quot; then A2 is
     *
     *  A2 = { &quot;:&quot;, digest-uri-value, &quot;:00000000000000000000000000000000&quot; }
     */
    private void validateResponseValue(byte[] fromServer) throws SaslException {
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">        if (fromServer == null) {</span>
<span class="nc" id="L658">            throw new SaslException(&quot;DIGEST-MD5: Authenication failed. &quot; +</span>
                &quot;Expecting 'rspauth' authentication success message&quot;);
        }

        try {
<span class="fc" id="L663">            byte[] expected = generateResponseValue(&quot;&quot;,</span>
                digestUri, negotiatedQop, username, negotiatedRealm,
                passwd, nonce, cnonce,  nonceCount, authzidBytes);
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">            if (!Arrays.equals(expected, fromServer)) {</span>
                /* Server's rspauth value does not match */
<span class="nc" id="L668">                throw new SaslException(</span>
                    &quot;Server's rspauth value does not match what client expects&quot;);
            }
<span class="nc" id="L671">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L672">            throw new SaslException(</span>
                &quot;Problem generating response value for verification&quot;, e);
<span class="nc" id="L674">        } catch (IOException e) {</span>
<span class="nc" id="L675">            throw new SaslException(</span>
                &quot;Problem generating response value for verification&quot;, e);
<span class="fc" id="L677">        }</span>
<span class="fc" id="L678">    }</span>

    /**
     * Returns the number of requests (including current request)
     * that the client has sent in response to nonceValue.
     * This is 1 the first time nonceValue is seen.
     *
     * We don't cache nonce values seen, and we don't support subsequent
     * authentication, so the value is always 1.
     */
    private static int getNonceCount(byte[] nonceValue) {
<span class="fc" id="L689">        return 1;</span>
    }

    private void clearPassword() {
<span class="fc bfc" id="L693" title="All 2 branches covered.">        if (passwd != null) {</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">            for (int i = 0; i &lt; passwd.length; i++) {</span>
<span class="fc" id="L695">                passwd[i] = 0;</span>
            }
<span class="fc" id="L697">            passwd = null;</span>
        }
<span class="fc" id="L699">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>