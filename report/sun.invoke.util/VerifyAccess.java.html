<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>VerifyAccess.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.invoke.util</a> &gt; <span class="el_source">VerifyAccess.java</span></div><h1>VerifyAccess.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.invoke.util;

import java.lang.reflect.Modifier;
import static java.lang.reflect.Modifier.*;
import sun.reflect.Reflection;

/**
 * This class centralizes information about the JVM's linkage access control.
 * @author jrose
 */
<span class="fc bfc" id="L36" title="All 2 branches covered.">public class VerifyAccess {</span>

<span class="nc" id="L38">    private VerifyAccess() { }  // cannot instantiate</span>

    private static final int PACKAGE_ONLY = 0;
    private static final int PACKAGE_ALLOWED = java.lang.invoke.MethodHandles.Lookup.PACKAGE;
    private static final int PROTECTED_OR_PACKAGE_ALLOWED = (PACKAGE_ALLOWED|PROTECTED);
    private static final int ALL_ACCESS_MODES = (PUBLIC|PRIVATE|PROTECTED|PACKAGE_ONLY);
    private static final boolean ALLOW_NESTMATE_ACCESS = false;

    /**
     * Evaluate the JVM linkage rules for access to the given method
     * on behalf of a caller class which proposes to perform the access.
     * Return true if the caller class has privileges to invoke a method
     * or access a field with the given properties.
     * This requires an accessibility check of the referencing class,
     * plus an accessibility check of the member within the class,
     * which depends on the member's modifier flags.
     * &lt;p&gt;
     * The relevant properties include the defining class ({@code defc})
     * of the member, and its modifier flags ({@code mods}).
     * Also relevant is the class used to make the initial symbolic reference
     * to the member ({@code refc}).  If this latter class is not distinguished,
     * the defining class should be passed for both arguments ({@code defc == refc}).
     * &lt;h3&gt;JVM Specification, 5.4.4 &quot;Access Control&quot;&lt;/h3&gt;
     * A field or method R is accessible to a class or interface D if
     * and only if any of the following conditions is true:&lt;ul&gt;
     * &lt;li&gt;R is public.
     * &lt;li&gt;R is protected and is declared in a class C, and D is either
     *     a subclass of C or C itself.  Furthermore, if R is not
     *     static, then the symbolic reference to R must contain a
     *     symbolic reference to a class T, such that T is either a
     *     subclass of D, a superclass of D or D itself.
     * &lt;li&gt;R is either protected or has default access (that is,
     *     neither public nor protected nor private), and is declared
     *     by a class in the same runtime package as D.
     * &lt;li&gt;R is private and is declared in D.
     * &lt;/ul&gt;
     * This discussion of access control omits a related restriction
     * on the target of a protected field access or method invocation
     * (the target must be of class D or a subtype of D). That
     * requirement is checked as part of the verification process
     * (5.4.1); it is not part of link-time access control.
     * @param refc the class used in the symbolic reference to the proposed member
     * @param defc the class in which the proposed member is actually defined
     * @param mods modifier flags for the proposed member
     * @param lookupClass the class for which the access check is being made
     * @return true iff the the accessing class can access such a member
     */
    public static boolean isMemberAccessible(Class&lt;?&gt; refc,  // symbolic ref class
                                             Class&lt;?&gt; defc,  // actual def class
                                             int      mods,  // actual member mods
                                             Class&lt;?&gt; lookupClass,
                                             int      allowedModes) {
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (allowedModes == 0)  return false;</span>
<span class="pc bpc" id="L91" title="2 of 6 branches missed.">        assert((allowedModes &amp; PUBLIC) != 0 &amp;&amp;</span>
               (allowedModes &amp; ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED)) == 0);
        // Usually refc and defc are the same, but if they differ, verify them both.
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (refc != defc) {</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (!isClassAccessible(refc, lookupClass, allowedModes)) {</span>
                // Note that defc is verified in the switch below.
<span class="nc" id="L97">                return false;</span>
            }
<span class="nc bnc" id="L99" title="All 4 branches missed.">            if ((mods &amp; (ALL_ACCESS_MODES|STATIC)) == (PROTECTED|STATIC) &amp;&amp;</span>
                (allowedModes &amp; PROTECTED_OR_PACKAGE_ALLOWED) != 0) {
                // Apply the special rules for refc here.
<span class="nc bnc" id="L102" title="All 2 branches missed.">                if (!isRelatedClass(refc, lookupClass))</span>
<span class="nc" id="L103">                    return isSamePackage(defc, lookupClass);</span>
                // If refc == defc, the call to isPublicSuperClass will do
                // the whole job, since in that case refc (as defc) will be
                // a superclass of the lookup class.
            }
        }
<span class="pc bpc" id="L109" title="1 of 4 branches missed.">        if (defc == lookupClass &amp;&amp;</span>
            (allowedModes &amp; PRIVATE) != 0)
<span class="fc" id="L111">            return true;        // easy check; all self-access is OK</span>
<span class="pc bpc" id="L112" title="1 of 5 branches missed.">        switch (mods &amp; ALL_ACCESS_MODES) {</span>
        case PUBLIC:
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">            if (refc != defc)  return true;  // already checked above</span>
<span class="fc" id="L115">            return isClassAccessible(refc, lookupClass, allowedModes);</span>
        case PROTECTED:
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">            if ((allowedModes &amp; PROTECTED_OR_PACKAGE_ALLOWED) != 0 &amp;&amp;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">                isSamePackage(defc, lookupClass))</span>
<span class="fc" id="L119">                return true;</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">            if ((allowedModes &amp; PROTECTED) != 0 &amp;&amp;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">                isPublicSuperClass(defc, lookupClass))</span>
<span class="fc" id="L122">                return true;</span>
<span class="fc" id="L123">            return false;</span>
        case PACKAGE_ONLY:  // That is, zero.  Unmarked member is package-only access.
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">            return ((allowedModes &amp; PACKAGE_ALLOWED) != 0 &amp;&amp;</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">                    isSamePackage(defc, lookupClass));</span>
        case PRIVATE:
            // Loosened rules for privates follows access rules for inner classes.
<span class="fc" id="L129">            return (ALLOW_NESTMATE_ACCESS &amp;&amp;</span>
                    (allowedModes &amp; PRIVATE) != 0 &amp;&amp;
                    isSamePackageMember(defc, lookupClass));
        default:
<span class="nc" id="L133">            throw new IllegalArgumentException(&quot;bad modifiers: &quot;+Modifier.toString(mods));</span>
        }
    }

    static boolean isRelatedClass(Class&lt;?&gt; refc, Class&lt;?&gt; lookupClass) {
<span class="nc bnc" id="L138" title="All 2 branches missed.">        return (refc == lookupClass ||</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">                refc.isAssignableFrom(lookupClass) ||</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                lookupClass.isAssignableFrom(refc));</span>
    }

    static boolean isPublicSuperClass(Class&lt;?&gt; defc, Class&lt;?&gt; lookupClass) {
<span class="pc bpc" id="L144" title="1 of 4 branches missed.">        return isPublic(getClassModifiers(defc)) &amp;&amp; defc.isAssignableFrom(lookupClass);</span>
    }

    static int getClassModifiers(Class&lt;?&gt; c) {
        // This would return the mask stored by javac for the source-level modifiers.
        //   return c.getModifiers();
        // But what we need for JVM access checks are the actual bits from the class header.
        // ...But arrays and primitives are synthesized with their own odd flags:
<span class="pc bpc" id="L152" title="1 of 4 branches missed.">        if (c.isArray() || c.isPrimitive())</span>
<span class="fc" id="L153">            return c.getModifiers();</span>
<span class="fc" id="L154">        return Reflection.getClassAccessFlags(c);</span>
    }

    /**
     * Evaluate the JVM linkage rules for access to the given class on behalf of caller.
     * &lt;h3&gt;JVM Specification, 5.4.4 &quot;Access Control&quot;&lt;/h3&gt;
     * A class or interface C is accessible to a class or interface D
     * if and only if either of the following conditions are true:&lt;ul&gt;
     * &lt;li&gt;C is public.
     * &lt;li&gt;C and D are members of the same runtime package.
     * &lt;/ul&gt;
     * @param refc the symbolic reference class to which access is being checked (C)
     * @param lookupClass the class performing the lookup (D)
     */
    public static boolean isClassAccessible(Class&lt;?&gt; refc, Class&lt;?&gt; lookupClass,
                                            int allowedModes) {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (allowedModes == 0)  return false;</span>
<span class="pc bpc" id="L171" title="2 of 6 branches missed.">        assert((allowedModes &amp; PUBLIC) != 0 &amp;&amp;</span>
               (allowedModes &amp; ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED)) == 0);
<span class="fc" id="L173">        int mods = getClassModifiers(refc);</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (isPublic(mods))</span>
<span class="fc" id="L175">            return true;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if ((allowedModes &amp; PACKAGE_ALLOWED) != 0 &amp;&amp;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            isSamePackage(lookupClass, refc))</span>
<span class="fc" id="L178">            return true;</span>
<span class="fc" id="L179">        return false;</span>
    }

    /**
     * Decide if the given method type, attributed to a member or symbolic
     * reference of a given reference class, is really visible to that class.
     * @param type the supposed type of a member or symbolic reference of refc
     * @param refc the class attempting to make the reference
     */
    public static boolean isTypeVisible(Class&lt;?&gt; type, Class&lt;?&gt; refc) {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (type == refc)  return true;  // easy check</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        while (type.isArray())  type = type.getComponentType();</span>
<span class="fc bfc" id="L191" title="All 4 branches covered.">        if (type.isPrimitive() || type == Object.class)  return true;</span>
<span class="fc" id="L192">        ClassLoader parent = type.getClassLoader();</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (parent == null)  return true;</span>
<span class="fc" id="L194">        ClassLoader child  = refc.getClassLoader();</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (child == null)  return false;</span>
<span class="pc bpc" id="L196" title="1 of 4 branches missed.">        if (parent == child || loadersAreRelated(parent, child, true))</span>
<span class="fc" id="L197">            return true;</span>
        // Do it the hard way:  Look up the type name from the refc loader.
        try {
<span class="nc" id="L200">            Class&lt;?&gt; res = child.loadClass(type.getName());</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">            return (type == res);</span>
<span class="nc" id="L202">        } catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L203">            return false;</span>
        }
    }

    /**
     * Decide if the given method type, attributed to a member or symbolic
     * reference of a given reference class, is really visible to that class.
     * @param type the supposed type of a member or symbolic reference of refc
     * @param refc the class attempting to make the reference
     */
    public static boolean isTypeVisible(java.lang.invoke.MethodType type, Class&lt;?&gt; refc) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        for (int n = -1, max = type.parameterCount(); n &lt; max; n++) {</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">            Class&lt;?&gt; ptype = (n &lt; 0 ? type.returnType() : type.parameterType(n));</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            if (!isTypeVisible(ptype, refc))</span>
<span class="nc" id="L217">                return false;</span>
        }
<span class="fc" id="L219">        return true;</span>
    }

    /**
     * Test if two classes have the same class loader and package qualifier.
     * @param class1 a class
     * @param class2 another class
     * @return whether they are in the same package
     */
    public static boolean isSamePackage(Class&lt;?&gt; class1, Class&lt;?&gt; class2) {
<span class="pc bpc" id="L229" title="2 of 6 branches missed.">        assert(!class1.isArray() &amp;&amp; !class2.isArray());</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (class1 == class2)</span>
<span class="fc" id="L231">            return true;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (class1.getClassLoader() != class2.getClassLoader())</span>
<span class="fc" id="L233">            return false;</span>
<span class="fc" id="L234">        String name1 = class1.getName(), name2 = class2.getName();</span>
<span class="fc" id="L235">        int dot = name1.lastIndexOf('.');</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (dot != name2.lastIndexOf('.'))</span>
<span class="fc" id="L237">            return false;</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">        for (int i = 0; i &lt; dot; i++) {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            if (name1.charAt(i) != name2.charAt(i))</span>
<span class="fc" id="L240">                return false;</span>
        }
<span class="fc" id="L242">        return true;</span>
    }

    /** Return the package name for this class.
     */
    public static String getPackageName(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L248" title="All 4 branches missed.">        assert(!cls.isArray());</span>
<span class="nc" id="L249">        String name = cls.getName();</span>
<span class="nc" id="L250">        int dot = name.lastIndexOf('.');</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (dot &lt; 0)  return &quot;&quot;;</span>
<span class="nc" id="L252">        return name.substring(0, dot);</span>
    }

    /**
     * Test if two classes are defined as part of the same package member (top-level class).
     * If this is true, they can share private access with each other.
     * @param class1 a class
     * @param class2 another class
     * @return whether they are identical or nested together
     */
    public static boolean isSamePackageMember(Class&lt;?&gt; class1, Class&lt;?&gt; class2) {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (class1 == class2)</span>
<span class="nc" id="L264">            return true;</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        if (!isSamePackage(class1, class2))</span>
<span class="nc" id="L266">            return false;</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (getOutermostEnclosingClass(class1) != getOutermostEnclosingClass(class2))</span>
<span class="nc" id="L268">            return false;</span>
<span class="fc" id="L269">        return true;</span>
    }

    private static Class&lt;?&gt; getOutermostEnclosingClass(Class&lt;?&gt; c) {
<span class="fc" id="L273">        Class&lt;?&gt; pkgmem = c;</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        for (Class&lt;?&gt; enc = c; (enc = enc.getEnclosingClass()) != null; )</span>
<span class="fc" id="L275">            pkgmem = enc;</span>
<span class="fc" id="L276">        return pkgmem;</span>
    }

    private static boolean loadersAreRelated(ClassLoader loader1, ClassLoader loader2,
                                             boolean loader1MustBeParent) {
<span class="pc bpc" id="L281" title="2 of 8 branches missed.">        if (loader1 == loader2 || loader1 == null</span>
                || (loader2 == null &amp;&amp; !loader1MustBeParent)) {
<span class="fc" id="L283">            return true;</span>
        }
<span class="fc" id="L285">        for (ClassLoader scan2 = loader2;</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">                scan2 != null; scan2 = scan2.getParent()) {</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">            if (scan2 == loader1)  return true;</span>
        }
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">        if (loader1MustBeParent)  return false;</span>
        // see if loader2 is a parent of loader1:
<span class="nc" id="L291">        for (ClassLoader scan1 = loader1;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                scan1 != null; scan1 = scan1.getParent()) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (scan1 == loader2)  return true;</span>
        }
<span class="nc" id="L295">        return false;</span>
    }

    /**
     * Is the class loader of parentClass identical to, or an ancestor of,
     * the class loader of childClass?
     * @param parentClass a class
     * @param childClass another class, which may be a descendent of the first class
     * @return whether parentClass precedes or equals childClass in class loader order
     */
    public static boolean classLoaderIsAncestor(Class&lt;?&gt; parentClass, Class&lt;?&gt; childClass) {
<span class="fc" id="L306">        return loadersAreRelated(parentClass.getClassLoader(), childClass.getClassLoader(), true);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>