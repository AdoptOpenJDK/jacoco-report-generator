<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Wrapper.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.invoke.util</a> &gt; <span class="el_source">Wrapper.java</span></div><h1>Wrapper.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.invoke.util;

<span class="pc bfc" id="L28" title="All 2 branches covered.">public enum Wrapper {</span>
<span class="fc" id="L29">    BOOLEAN(Boolean.class, boolean.class, 'Z', (Boolean)false, new boolean[0], Format.unsigned(1)),</span>
    // These must be in the order defined for widening primitive conversions in JLS 5.1.2
<span class="fc" id="L31">    BYTE(Byte.class, byte.class, 'B', (Byte)(byte)0, new byte[0], Format.signed(8)),</span>
<span class="fc" id="L32">    SHORT(Short.class, short.class, 'S', (Short)(short)0, new short[0], Format.signed(16)),</span>
<span class="fc" id="L33">    CHAR(Character.class, char.class, 'C', (Character)(char)0, new char[0], Format.unsigned(16)),</span>
<span class="fc" id="L34">    INT(Integer.class, int.class, 'I', (Integer)/*(int)*/0, new int[0], Format.signed(32)),</span>
<span class="fc" id="L35">    LONG(Long.class, long.class, 'J', (Long)(long)0, new long[0], Format.signed(64)),</span>
<span class="fc" id="L36">    FLOAT(Float.class, float.class, 'F', (Float)(float)0, new float[0], Format.floating(32)),</span>
<span class="fc" id="L37">    DOUBLE(Double.class, double.class, 'D', (Double)(double)0, new double[0], Format.floating(64)),</span>
    //NULL(Null.class, null.class, 'N', null, null, Format.other(1)),
<span class="fc" id="L39">    OBJECT(Object.class, Object.class, 'L', null, new Object[0], Format.other(1)),</span>
    // VOID must be the last type, since it is &quot;assignable&quot; from any other type:
<span class="fc" id="L41">    VOID(Void.class, void.class, 'V', null, null, Format.other(0)),</span>
    ;

    private final Class&lt;?&gt; wrapperType;
    private final Class&lt;?&gt; primitiveType;
    private final char     basicTypeChar;
    private final Object   zero;
    private final Object   emptyArray;
    private final int      format;
    private final String   wrapperSimpleName;
    private final String   primitiveSimpleName;

<span class="fc" id="L53">    private Wrapper(Class&lt;?&gt; wtype, Class&lt;?&gt; ptype, char tchar, Object zero, Object emptyArray, int format) {</span>
<span class="fc" id="L54">        this.wrapperType = wtype;</span>
<span class="fc" id="L55">        this.primitiveType = ptype;</span>
<span class="fc" id="L56">        this.basicTypeChar = tchar;</span>
<span class="fc" id="L57">        this.zero = zero;</span>
<span class="fc" id="L58">        this.emptyArray = emptyArray;</span>
<span class="fc" id="L59">        this.format = format;</span>
<span class="fc" id="L60">        this.wrapperSimpleName = wtype.getSimpleName();</span>
<span class="fc" id="L61">        this.primitiveSimpleName = ptype.getSimpleName();</span>
<span class="fc" id="L62">    }</span>

    /** For debugging, give the details of this wrapper. */
    public String detailString() {
<span class="nc" id="L66">        return wrapperSimpleName+</span>
<span class="nc" id="L67">                java.util.Arrays.asList(wrapperType, primitiveType,</span>
<span class="nc" id="L68">                basicTypeChar, zero,</span>
<span class="nc" id="L69">                &quot;0x&quot;+Integer.toHexString(format));</span>
    }

<span class="pc bfc" id="L72" title="All 2 branches covered.">    private static abstract class Format {</span>
        static final int SLOT_SHIFT = 0, SIZE_SHIFT = 2, KIND_SHIFT = 12;
        static final int
                SIGNED   = (-1) &lt;&lt; KIND_SHIFT,
                UNSIGNED = 0    &lt;&lt; KIND_SHIFT,
                FLOATING = 1    &lt;&lt; KIND_SHIFT;
        static final int
                SLOT_MASK = ((1&lt;&lt;(SIZE_SHIFT-SLOT_SHIFT))-1),
                SIZE_MASK = ((1&lt;&lt;(KIND_SHIFT-SIZE_SHIFT))-1);
        static int format(int kind, int size, int slots) {
<span class="pc bpc" id="L82" title="1 of 4 branches missed.">            assert(((kind &gt;&gt; KIND_SHIFT) &lt;&lt; KIND_SHIFT) == kind);</span>
<span class="pc bpc" id="L83" title="1 of 4 branches missed.">            assert((size &amp; (size-1)) == 0); // power of two</span>
<span class="pc bpc" id="L84" title="4 of 16 branches missed.">            assert((kind == SIGNED)   ? (size &gt; 0) :</span>
                   (kind == UNSIGNED) ? (size &gt; 0) :
                   (kind == FLOATING) ? (size == 32 || size == 64)  :
                   false);
<span class="pc bpc" id="L88" title="3 of 10 branches missed.">            assert((slots == 2) ? (size == 64) :</span>
                   (slots == 1) ? (size &lt;= 32) :
                   false);
<span class="fc" id="L91">            return kind | (size &lt;&lt; SIZE_SHIFT) | (slots &lt;&lt; SLOT_SHIFT);</span>
        }
        static final int
                INT      = SIGNED   | (32 &lt;&lt; SIZE_SHIFT) | (1 &lt;&lt; SLOT_SHIFT),
                SHORT    = SIGNED   | (16 &lt;&lt; SIZE_SHIFT) | (1 &lt;&lt; SLOT_SHIFT),
                BOOLEAN  = UNSIGNED | (1  &lt;&lt; SIZE_SHIFT) | (1 &lt;&lt; SLOT_SHIFT),
                CHAR     = UNSIGNED | (16 &lt;&lt; SIZE_SHIFT) | (1 &lt;&lt; SLOT_SHIFT),
                FLOAT    = FLOATING | (32 &lt;&lt; SIZE_SHIFT) | (1 &lt;&lt; SLOT_SHIFT),
                VOID     = UNSIGNED | (0  &lt;&lt; SIZE_SHIFT) | (0 &lt;&lt; SLOT_SHIFT),
                NUM_MASK = (-1) &lt;&lt; SIZE_SHIFT;
<span class="fc bfc" id="L101" title="All 2 branches covered.">        static int signed(int size)   { return format(SIGNED,   size, (size &gt; 32 ? 2 : 1)); }</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        static int unsigned(int size) { return format(UNSIGNED, size, (size &gt; 32 ? 2 : 1)); }</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        static int floating(int size) { return format(FLOATING, size, (size &gt; 32 ? 2 : 1)); }</span>
<span class="fc" id="L104">        static int other(int slots)   { return slots &lt;&lt; SLOT_SHIFT; }</span>
    }

    /// format queries:

    /** How many bits are in the wrapped value?  Returns 0 for OBJECT or VOID. */
<span class="fc" id="L110">    public int     bitWidth()      { return (format &gt;&gt; Format.SIZE_SHIFT) &amp; Format.SIZE_MASK; }</span>
    /** How many JVM stack slots occupied by the wrapped value?  Returns 0 for VOID. */
<span class="fc" id="L112">    public int     stackSlots()    { return (format &gt;&gt; Format.SLOT_SHIFT) &amp; Format.SLOT_MASK; }</span>
    /** Does the wrapped value occupy a single JVM stack slot? */
<span class="fc bfc" id="L114" title="All 2 branches covered.">    public boolean isSingleWord()  { return (format &amp; (1 &lt;&lt; Format.SLOT_SHIFT)) != 0; }</span>
    /** Does the wrapped value occupy two JVM stack slots? */
<span class="fc bfc" id="L116" title="All 2 branches covered.">    public boolean isDoubleWord()  { return (format &amp; (2 &lt;&lt; Format.SLOT_SHIFT)) != 0; }</span>
    /** Is the wrapped type numeric (not void or object)? */
<span class="fc bfc" id="L118" title="All 2 branches covered.">    public boolean isNumeric()     { return (format &amp; Format.NUM_MASK) != 0; }</span>
    /** Is the wrapped type a primitive other than float, double, or void? */
<span class="fc bfc" id="L120" title="All 4 branches covered.">    public boolean isIntegral()    { return isNumeric() &amp;&amp; format &lt; Format.FLOAT; }</span>
    /** Is the wrapped type one of int, boolean, byte, char, or short? */
<span class="fc bfc" id="L122" title="All 4 branches covered.">    public boolean isSubwordOrInt() { return isIntegral() &amp;&amp; isSingleWord(); }</span>
    /* Is the wrapped value a signed integral type (one of byte, short, int, or long)? */
<span class="fc bfc" id="L124" title="All 2 branches covered.">    public boolean isSigned()      { return format &lt; Format.VOID; }</span>
    /* Is the wrapped value an unsigned integral type (one of boolean or char)? */
<span class="nc bnc" id="L126" title="All 4 branches missed.">    public boolean isUnsigned()    { return format &gt;= Format.BOOLEAN &amp;&amp; format &lt; Format.FLOAT; }</span>
    /** Is the wrapped type either float or double? */
<span class="fc bfc" id="L128" title="All 2 branches covered.">    public boolean isFloating()    { return format &gt;= Format.FLOAT; }</span>
    /** Is the wrapped type either void or a reference? */
<span class="fc bfc" id="L130" title="All 2 branches covered.">    public boolean isOther()       { return (format &amp; ~Format.SLOT_MASK) == 0; }</span>

    /** Does the JLS 5.1.2 allow a variable of this wrapper's
     *  primitive type to be assigned from a value of the given wrapper's primitive type?
     *  Cases:
     *  &lt;ul&gt;
     *  &lt;li&gt;unboxing followed by widening primitive conversion
     *  &lt;li&gt;any type converted to {@code void} (i.e., dropping a method call's value)
     *  &lt;li&gt;boxing conversion followed by widening reference conversion to {@code Object}
     *  &lt;/ul&gt;
     *  These are the cases allowed by MethodHandle.asType.
     */
    public boolean isConvertibleFrom(Wrapper source) {
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (this == source)  return true;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (this.compareTo(source) &lt; 0) {</span>
            // At best, this is a narrowing conversion.
<span class="fc" id="L146">            return false;</span>
        }
        // All conversions are allowed in the enum order between floats and signed ints.
        // First detect non-signed non-float types (boolean, char, Object, void).
<span class="fc bfc" id="L150" title="All 2 branches covered.">        boolean floatOrSigned = (((this.format &amp; source.format) &amp; Format.SIGNED) != 0);</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (!floatOrSigned) {</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">            if (this.isOther())  return true;</span>
            // can convert char to int or wider, but nothing else
<span class="fc bfc" id="L154" title="All 2 branches covered.">            if (source.format == Format.CHAR)  return true;</span>
            // no other conversions are classified as widening
<span class="fc" id="L156">            return false;</span>
        }
        // All signed and float conversions in the enum order are widening.
<span class="pc bpc" id="L159" title="2 of 6 branches missed.">        assert(this.isFloating() || this.isSigned());</span>
<span class="pc bpc" id="L160" title="2 of 6 branches missed.">        assert(source.isFloating() || source.isSigned());</span>
<span class="fc" id="L161">        return true;</span>
    }

<span class="pc bpc" id="L164" title="1 of 4 branches missed.">    static { assert(checkConvertibleFrom()); }</span>
    private static boolean checkConvertibleFrom() {
        // Check the matrix for correct classification of widening conversions.
<span class="fc bfc" id="L167" title="All 2 branches covered.">        for (Wrapper w : values()) {</span>
<span class="pc bpc" id="L168" title="2 of 4 branches missed.">            assert(w.isConvertibleFrom(w));</span>
<span class="pc bpc" id="L169" title="2 of 4 branches missed.">            assert(VOID.isConvertibleFrom(w));</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (w != VOID) {</span>
<span class="pc bpc" id="L171" title="2 of 4 branches missed.">                assert(OBJECT.isConvertibleFrom(w));</span>
<span class="pc bpc" id="L172" title="2 of 4 branches missed.">                assert(!w.isConvertibleFrom(VOID));</span>
            }
            // check relations with unsigned integral types:
<span class="fc bfc" id="L175" title="All 2 branches covered.">            if (w != CHAR) {</span>
<span class="pc bpc" id="L176" title="2 of 4 branches missed.">                assert(!CHAR.isConvertibleFrom(w));</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">                if (!w.isConvertibleFrom(INT))</span>
<span class="pc bpc" id="L178" title="2 of 4 branches missed.">                    assert(!w.isConvertibleFrom(CHAR));</span>
            }
<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (w != BOOLEAN) {</span>
<span class="pc bpc" id="L181" title="2 of 4 branches missed.">                assert(!BOOLEAN.isConvertibleFrom(w));</span>
<span class="fc bfc" id="L182" title="All 4 branches covered.">                if (w != VOID &amp;&amp; w != OBJECT)</span>
<span class="pc bpc" id="L183" title="2 of 4 branches missed.">                    assert(!w.isConvertibleFrom(BOOLEAN));</span>
            }
            // check relations with signed integral types:
<span class="fc bfc" id="L186" title="All 2 branches covered.">            if (w.isSigned()) {</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">                for (Wrapper x : values()) {</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">                    if (w == x)  continue;</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">                    if (x.isFloating())</span>
<span class="pc bpc" id="L190" title="2 of 4 branches missed.">                        assert(!w.isConvertibleFrom(x));</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">                    else if (x.isSigned()) {</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">                        if (w.compareTo(x) &lt; 0)</span>
<span class="pc bpc" id="L193" title="2 of 4 branches missed.">                            assert(!w.isConvertibleFrom(x));</span>
                        else
<span class="pc bpc" id="L195" title="2 of 4 branches missed.">                            assert(w.isConvertibleFrom(x));</span>
                    }
                }
            }
            // check relations with floating types:
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (w.isFloating()) {</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">                for (Wrapper x : values()) {</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                    if (w == x)  continue;</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">                    if (x.isSigned())</span>
<span class="pc bpc" id="L204" title="2 of 4 branches missed.">                        assert(w.isConvertibleFrom(x));</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">                    else if (x.isFloating()) {</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">                        if (w.compareTo(x) &lt; 0)</span>
<span class="pc bpc" id="L207" title="2 of 4 branches missed.">                            assert(!w.isConvertibleFrom(x));</span>
                        else
<span class="pc bpc" id="L209" title="2 of 4 branches missed.">                            assert(w.isConvertibleFrom(x));</span>
                    }
                }
            }
        }
<span class="fc" id="L214">        return true;  // i.e., assert(true)</span>
    }

    /** Produce a zero value for the given wrapper type.
     *  This will be a numeric zero for a number or character,
     *  false for a boolean, and null for a reference or void.
     *  The common thread is that this is what is contained
     *  in a default-initialized variable of the given primitive
     *  type.  (For void, it is what a reflective method returns
     *  instead of no value at all.)
     */
<span class="fc" id="L225">    public Object zero() { return zero; }</span>

    /** Produce a zero value for the given wrapper type T.
     *  The optional argument must a type compatible with this wrapper.
     *  Equivalent to {@code this.cast(this.zero(), type)}.
     */
<span class="nc" id="L231">    public &lt;T&gt; T zero(Class&lt;T&gt; type) { return convert(zero, type); }</span>

//    /** Produce a wrapper for the given wrapper or primitive type. */
//    public static Wrapper valueOf(Class&lt;?&gt; type) {
//        if (isPrimitiveType(type))
//            return forPrimitiveType(type);
//        else
//            return forWrapperType(type);
//    }

    /** Return the wrapper that wraps values of the given type.
     *  The type may be {@code Object}, meaning the {@code OBJECT} wrapper.
     *  Otherwise, the type must be a primitive.
     *  @throws IllegalArgumentException for unexpected types
     */
    public static Wrapper forPrimitiveType(Class&lt;?&gt; type) {
<span class="fc" id="L247">        Wrapper w = findPrimitiveType(type);</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (w != null)  return w;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (type.isPrimitive())</span>
<span class="nc" id="L250">            throw new InternalError(); // redo hash function</span>
<span class="nc" id="L251">        throw newIllegalArgumentException(&quot;not primitive: &quot;+type);</span>
    }

    static Wrapper findPrimitiveType(Class&lt;?&gt; type) {
<span class="fc" id="L255">        Wrapper w = FROM_PRIM[hashPrim(type)];</span>
<span class="pc bpc" id="L256" title="2 of 4 branches missed.">        if (w != null &amp;&amp; w.primitiveType == type) {</span>
<span class="fc" id="L257">            return w;</span>
        }
<span class="nc" id="L259">        return null;</span>
    }

    /** Return the wrapper that wraps values into the given wrapper type.
     *  If it is {@code Object}, return {@code OBJECT}.
     *  Otherwise, it must be a wrapper type.
     *  The type must not be a primitive type.
     *  @throws IllegalArgumentException for unexpected types
     */
    public static Wrapper forWrapperType(Class&lt;?&gt; type) {
<span class="fc" id="L269">        Wrapper w = findWrapperType(type);</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (w != null)  return w;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        for (Wrapper x : values())</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (x.wrapperType == type)</span>
<span class="nc" id="L273">                throw new InternalError(); // redo hash function</span>
<span class="nc" id="L274">        throw newIllegalArgumentException(&quot;not wrapper: &quot;+type);</span>
    }

    static Wrapper findWrapperType(Class&lt;?&gt; type) {
<span class="fc" id="L278">        Wrapper w = FROM_WRAP[hashWrap(type)];</span>
<span class="fc bfc" id="L279" title="All 4 branches covered.">        if (w != null &amp;&amp; w.wrapperType == type) {</span>
<span class="fc" id="L280">            return w;</span>
        }
<span class="fc" id="L282">        return null;</span>
    }

    /** Return the wrapper that corresponds to the given bytecode
     *  signature character.  Return {@code OBJECT} for the character 'L'.
     *  @throws IllegalArgumentException for any non-signature character or {@code '['}.
     */
    public static Wrapper forBasicType(char type) {
<span class="fc" id="L290">        Wrapper w = FROM_CHAR[hashChar(type)];</span>
<span class="pc bpc" id="L291" title="2 of 4 branches missed.">        if (w != null &amp;&amp; w.basicTypeChar == type) {</span>
<span class="fc" id="L292">            return w;</span>
        }
<span class="nc bnc" id="L294" title="All 2 branches missed.">        for (Wrapper x : values())</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (w.basicTypeChar == type)</span>
<span class="nc" id="L296">                throw new InternalError(); // redo hash function</span>
<span class="nc" id="L297">        throw newIllegalArgumentException(&quot;not basic type char: &quot;+type);</span>
    }

    /** Return the wrapper for the given type, if it is
     *  a primitive type, else return {@code OBJECT}.
     */
    public static Wrapper forBasicType(Class&lt;?&gt; type) {
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (type.isPrimitive())</span>
<span class="fc" id="L305">            return forPrimitiveType(type);</span>
<span class="fc" id="L306">        return OBJECT;  // any reference, including wrappers or arrays</span>
    }

    // Note on perfect hashes:
    //   for signature chars c, do (c + (c &gt;&gt; 1)) % 16
    //   for primitive type names n, do (n[0] + n[2]) % 16
    // The type name hash works for both primitive and wrapper names.
    // You can add &quot;java/lang/Object&quot; to the primitive names.
    // But you add the wrapper name Object, use (n[2] + (3*n[1])) % 16.
<span class="fc" id="L315">    private static final Wrapper[] FROM_PRIM = new Wrapper[16];</span>
<span class="fc" id="L316">    private static final Wrapper[] FROM_WRAP = new Wrapper[16];</span>
<span class="fc" id="L317">    private static final Wrapper[] FROM_CHAR = new Wrapper[16];</span>
    private static int hashPrim(Class&lt;?&gt; x) {
<span class="fc" id="L319">        String xn = x.getName();</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        if (xn.length() &lt; 3)  return 0;</span>
<span class="fc" id="L321">        return (xn.charAt(0) + xn.charAt(2)) % 16;</span>
    }
    private static int hashWrap(Class&lt;?&gt; x) {
<span class="fc" id="L324">        String xn = x.getName();</span>
<span class="pc bpc" id="L325" title="1 of 4 branches missed.">        final int offset = 10; assert(offset == &quot;java.lang.&quot;.length());</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">        if (xn.length() &lt; offset+3)  return 0;</span>
<span class="fc" id="L327">        return (3*xn.charAt(offset+1) + xn.charAt(offset+2)) % 16;</span>
    }
    private static int hashChar(char x) {
<span class="fc" id="L330">        return (x + (x &gt;&gt; 1)) % 16;</span>
    }
    static {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        for (Wrapper w : values()) {</span>
<span class="fc" id="L334">            int pi = hashPrim(w.primitiveType);</span>
<span class="fc" id="L335">            int wi = hashWrap(w.wrapperType);</span>
<span class="fc" id="L336">            int ci = hashChar(w.basicTypeChar);</span>
<span class="pc bpc" id="L337" title="1 of 4 branches missed.">            assert(FROM_PRIM[pi] == null);</span>
<span class="pc bpc" id="L338" title="1 of 4 branches missed.">            assert(FROM_WRAP[wi] == null);</span>
<span class="pc bpc" id="L339" title="1 of 4 branches missed.">            assert(FROM_CHAR[ci] == null);</span>
<span class="fc" id="L340">            FROM_PRIM[pi] = w;</span>
<span class="fc" id="L341">            FROM_WRAP[wi] = w;</span>
<span class="fc" id="L342">            FROM_CHAR[ci] = w;</span>
        }
        //assert(jdk.sun.invoke.util.WrapperTest.test(false));
<span class="fc" id="L345">    }</span>

    /** What is the primitive type wrapped by this wrapper? */
<span class="fc" id="L348">    public Class&lt;?&gt; primitiveType() { return primitiveType; }</span>

    /** What is the wrapper type for this wrapper? */
<span class="fc" id="L351">    public Class&lt;?&gt; wrapperType() { return wrapperType; }</span>

    /** What is the wrapper type for this wrapper?
     * Otherwise, the example type must be the wrapper type,
     * or the corresponding primitive type.
     * (For {@code OBJECT}, the example type can be any non-primitive,
     * and is normalized to {@code Object.class}.)
     * The resulting class type has the same type parameter.
     */
    public &lt;T&gt; Class&lt;T&gt; wrapperType(Class&lt;T&gt; exampleType) {
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if (exampleType == wrapperType) {</span>
<span class="nc" id="L362">            return exampleType;</span>
<span class="pc bpc" id="L363" title="3 of 4 branches missed.">        } else if (exampleType == primitiveType ||</span>
                   wrapperType == Object.class ||
<span class="nc bnc" id="L365" title="All 2 branches missed.">                   exampleType.isInterface()) {</span>
<span class="fc" id="L366">            return forceType(wrapperType, exampleType);</span>
        }
<span class="nc" id="L368">        throw newClassCastException(exampleType, primitiveType);</span>
    }

    private static ClassCastException newClassCastException(Class&lt;?&gt; actual, Class&lt;?&gt; expected) {
<span class="nc" id="L372">        return new ClassCastException(actual + &quot; is not compatible with &quot; + expected);</span>
    }

    /** If {@code type} is a primitive type, return the corresponding
     *  wrapper type, else return {@code type} unchanged.
     */
    public static &lt;T&gt; Class&lt;T&gt; asWrapperType(Class&lt;T&gt; type) {
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        if (type.isPrimitive()) {</span>
<span class="fc" id="L380">            return forPrimitiveType(type).wrapperType(type);</span>
        }
<span class="nc" id="L382">        return type;</span>
    }

    /** If {@code type} is a wrapper type, return the corresponding
     *  primitive type, else return {@code type} unchanged.
     */
    public static &lt;T&gt; Class&lt;T&gt; asPrimitiveType(Class&lt;T&gt; type) {
<span class="nc" id="L389">        Wrapper w = findWrapperType(type);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (w != null) {</span>
<span class="nc" id="L391">            return forceType(w.primitiveType(), type);</span>
        }
<span class="nc" id="L393">        return type;</span>
    }

    /** Query:  Is the given type a wrapper, such as {@code Integer} or {@code Void}? */
    public static boolean isWrapperType(Class&lt;?&gt; type) {
<span class="fc bfc" id="L398" title="All 2 branches covered.">        return findWrapperType(type) != null;</span>
    }

    /** Query:  Is the given type a primitive, such as {@code int} or {@code void}? */
    public static boolean isPrimitiveType(Class&lt;?&gt; type) {
<span class="nc" id="L403">        return type.isPrimitive();</span>
    }

    /** What is the bytecode signature character for this type?
     *  All non-primitives, including array types, report as 'L', the signature character for references.
     */
    public static char basicTypeChar(Class&lt;?&gt; type) {
<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (!type.isPrimitive())</span>
<span class="fc" id="L411">            return 'L';</span>
        else
<span class="fc" id="L413">            return forPrimitiveType(type).basicTypeChar();</span>
    }

    /** What is the bytecode signature character for this wrapper's
     *  primitive type?
     */
<span class="fc" id="L419">    public char basicTypeChar() { return basicTypeChar; }</span>

    /** What is the simple name of the wrapper type?
     */
<span class="fc" id="L423">    public String wrapperSimpleName() { return wrapperSimpleName; }</span>

    /** What is the simple name of the primitive type?
     */
<span class="fc" id="L427">    public String primitiveSimpleName() { return primitiveSimpleName; }</span>

//    /** Wrap a value in the given type, which may be either a primitive or wrapper type.
//     *  Performs standard primitive conversions, including truncation and float conversions.
//     */
//    public static &lt;T&gt; T wrap(Object x, Class&lt;T&gt; type) {
//        return Wrapper.valueOf(type).cast(x, type);
//    }

    /** Cast a wrapped value to the given type, which may be either a primitive or wrapper type.
     *  The given target type must be this wrapper's primitive or wrapper type.
     *  If this wrapper is OBJECT, the target type may also be an interface, perform no runtime check.
     *  Performs standard primitive conversions, including truncation and float conversions.
     *  The given type must be compatible with this wrapper.  That is, it must either
     *  be the wrapper type (or a subtype, in the case of {@code OBJECT}) or else
     *  it must be the wrapper's primitive type.
     *  Primitive conversions are only performed if the given type is itself a primitive.
     *  @throws ClassCastException if the given type is not compatible with this wrapper
     */
    public &lt;T&gt; T cast(Object x, Class&lt;T&gt; type) {
<span class="fc" id="L447">        return convert(x, type, true);</span>
    }

    /** Convert a wrapped value to the given type.
     *  The given target type must be this wrapper's primitive or wrapper type.
     *  This is equivalent to {@link #cast}, except that it refuses to perform
     *  narrowing primitive conversions.
     */
    public &lt;T&gt; T convert(Object x, Class&lt;T&gt; type) {
<span class="fc" id="L456">        return convert(x, type, false);</span>
    }

    private &lt;T&gt; T convert(Object x, Class&lt;T&gt; type, boolean isCast) {
<span class="fc bfc" id="L460" title="All 2 branches covered.">        if (this == OBJECT) {</span>
            // If the target wrapper is OBJECT, just do a reference cast.
            // If the target type is an interface, perform no runtime check.
            // (This loophole is safe, and is allowed by the JVM verifier.)
            // If the target type is a primitive, change it to a wrapper.
<span class="pc bpc" id="L465" title="2 of 4 branches missed.">            assert(!type.isPrimitive());</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">            if (!type.isInterface())</span>
<span class="fc" id="L467">                type.cast(x);</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L469">            T result = (T) x;  // unchecked warning is expected here</span>
<span class="fc" id="L470">            return result;</span>
        }
<span class="fc" id="L472">        Class&lt;T&gt; wtype = wrapperType(type);</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">        if (wtype.isInstance(x)) {</span>
<span class="fc" id="L474">            return wtype.cast(x);</span>
        }
<span class="fc bfc" id="L476" title="All 2 branches covered.">        if (!isCast) {</span>
<span class="fc" id="L477">            Class&lt;?&gt; sourceType = x.getClass();  // throw NPE if x is null</span>
<span class="fc" id="L478">            Wrapper source = findWrapperType(sourceType);</span>
<span class="pc bpc" id="L479" title="2 of 4 branches missed.">            if (source == null || !this.isConvertibleFrom(source)) {</span>
<span class="nc" id="L480">                throw newClassCastException(wtype, sourceType);</span>
            }
<span class="fc bfc" id="L482" title="All 2 branches covered.">        } else if (x == null) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L484">            T z = (T) zero;</span>
<span class="fc" id="L485">            return z;</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L488">        T result = (T) wrap(x);  // unchecked warning is expected here</span>
<span class="pc bpc" id="L489" title="2 of 6 branches missed.">        assert (result == null ? Void.class : result.getClass()) == wtype;</span>
<span class="fc" id="L490">        return result;</span>
    }

    /** Cast a reference type to another reference type.
     * If the target type is an interface, perform no runtime check.
     * (This loophole is safe, and is allowed by the JVM verifier.)
     * If the target type is a primitive, change it to a wrapper.
     */
    static &lt;T&gt; Class&lt;T&gt; forceType(Class&lt;?&gt; type, Class&lt;T&gt; exampleType) {
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        boolean z = (type == exampleType ||</span>
<span class="pc bpc" id="L500" title="3 of 4 branches missed.">               type.isPrimitive() &amp;&amp; forPrimitiveType(type) == findWrapperType(exampleType) ||</span>
<span class="pc bpc" id="L501" title="4 of 6 branches missed.">               exampleType.isPrimitive() &amp;&amp; forPrimitiveType(exampleType) == findWrapperType(type) ||</span>
<span class="pc bnc" id="L502" title="All 2 branches missed.">               type == Object.class &amp;&amp; !exampleType.isPrimitive());</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">        if (!z)</span>
<span class="nc" id="L504">            System.out.println(type+&quot; &lt;= &quot;+exampleType);</span>
<span class="pc bpc" id="L505" title="1 of 4 branches missed.">        assert(type == exampleType ||</span>
<span class="pc bpc" id="L506" title="3 of 4 branches missed.">               type.isPrimitive() &amp;&amp; forPrimitiveType(type) == findWrapperType(exampleType) ||</span>
<span class="pc bpc" id="L507" title="4 of 6 branches missed.">               exampleType.isPrimitive() &amp;&amp; forPrimitiveType(exampleType) == findWrapperType(type) ||</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">               type == Object.class &amp;&amp; !exampleType.isPrimitive());</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L510">        Class&lt;T&gt; result = (Class&lt;T&gt;) type;  // unchecked warning is expected here</span>
<span class="fc" id="L511">        return result;</span>
    }

    /** Wrap a value in this wrapper's type.
     * Performs standard primitive conversions, including truncation and float conversions.
     * Performs returns the unchanged reference for {@code OBJECT}.
     * Returns null for {@code VOID}.
     * Returns a zero value for a null input.
     * @throws ClassCastException if this wrapper is numeric and the operand
     *                            is not a number, character, boolean, or null
     */
    public Object wrap(Object x) {
        // do non-numeric wrappers first
<span class="fc bfc" id="L524" title="All 3 branches covered.">        switch (basicTypeChar) {</span>
<span class="fc" id="L525">            case 'L': return x;</span>
<span class="fc" id="L526">            case 'V': return null;</span>
        }
<span class="fc" id="L528">        Number xn = numberValue(x);</span>
<span class="pc bpc" id="L529" title="1 of 9 branches missed.">        switch (basicTypeChar) {</span>
<span class="fc" id="L530">            case 'I': return Integer.valueOf(xn.intValue());</span>
<span class="fc" id="L531">            case 'J': return Long.valueOf(xn.longValue());</span>
<span class="fc" id="L532">            case 'F': return Float.valueOf(xn.floatValue());</span>
<span class="fc" id="L533">            case 'D': return Double.valueOf(xn.doubleValue());</span>
<span class="fc" id="L534">            case 'S': return Short.valueOf((short) xn.intValue());</span>
<span class="fc" id="L535">            case 'B': return Byte.valueOf((byte) xn.intValue());</span>
<span class="fc" id="L536">            case 'C': return Character.valueOf((char) xn.intValue());</span>
<span class="fc" id="L537">            case 'Z': return Boolean.valueOf(boolValue(xn.byteValue()));</span>
        }
<span class="nc" id="L539">        throw new InternalError(&quot;bad wrapper&quot;);</span>
    }

    /** Wrap a value (an int or smaller value) in this wrapper's type.
     * Performs standard primitive conversions, including truncation and float conversions.
     * Produces an {@code Integer} for {@code OBJECT}, although the exact type
     * of the operand is not known.
     * Returns null for {@code VOID}.
     */
    public Object wrap(int x) {
<span class="fc bfc" id="L549" title="All 2 branches covered.">        if (basicTypeChar == 'L')  return (Integer)x;</span>
<span class="pc bpc" id="L550" title="2 of 11 branches missed.">        switch (basicTypeChar) {</span>
<span class="nc" id="L551">            case 'L': throw newIllegalArgumentException(&quot;cannot wrap to object type&quot;);</span>
<span class="fc" id="L552">            case 'V': return null;</span>
<span class="fc" id="L553">            case 'I': return Integer.valueOf(x);</span>
<span class="fc" id="L554">            case 'J': return Long.valueOf(x);</span>
<span class="fc" id="L555">            case 'F': return Float.valueOf(x);</span>
<span class="fc" id="L556">            case 'D': return Double.valueOf(x);</span>
<span class="fc" id="L557">            case 'S': return Short.valueOf((short) x);</span>
<span class="fc" id="L558">            case 'B': return Byte.valueOf((byte) x);</span>
<span class="fc" id="L559">            case 'C': return Character.valueOf((char) x);</span>
<span class="fc" id="L560">            case 'Z': return Boolean.valueOf(boolValue((byte) x));</span>
        }
<span class="nc" id="L562">        throw new InternalError(&quot;bad wrapper&quot;);</span>
    }

    private static Number numberValue(Object x) {
<span class="fc bfc" id="L566" title="All 2 branches covered.">        if (x instanceof Number)     return (Number)x;</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">        if (x instanceof Character)  return (int)(Character)x;</span>
<span class="pc bpc" id="L568" title="1 of 4 branches missed.">        if (x instanceof Boolean)    return (Boolean)x ? 1 : 0;</span>
        // Remaining allowed case of void:  Must be a null reference.
<span class="nc" id="L570">        return (Number)x;</span>
    }

    // Parameter type of boolValue must be byte, because
    // MethodHandles.explicitCastArguments defines boolean
    // conversion as first converting to byte.
    private static boolean boolValue(byte bits) {
<span class="fc" id="L577">        bits &amp;= 1;  // simple 31-bit zero extension</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">        return (bits != 0);</span>
    }

    private static RuntimeException newIllegalArgumentException(String message, Object x) {
<span class="nc" id="L582">        return newIllegalArgumentException(message + x);</span>
    }
    private static RuntimeException newIllegalArgumentException(String message) {
<span class="nc" id="L585">        return new IllegalArgumentException(message);</span>
    }

    // primitive array support
    public Object makeArray(int len) {
<span class="fc" id="L590">        return java.lang.reflect.Array.newInstance(primitiveType, len);</span>
    }
    public Class&lt;?&gt; arrayType() {
<span class="fc" id="L593">        return emptyArray.getClass();</span>
    }
    public void copyArrayUnboxing(Object[] values, int vpos, Object a, int apos, int length) {
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        if (a.getClass() != arrayType())</span>
<span class="nc" id="L597">            arrayType().cast(a);  // throw NPE or CCE if bad type</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L599">            Object value = values[i+vpos];</span>
<span class="fc" id="L600">            value = convert(value, primitiveType);</span>
<span class="fc" id="L601">            java.lang.reflect.Array.set(a, i+apos, value);</span>
        }
<span class="fc" id="L603">    }</span>
    public void copyArrayBoxing(Object a, int apos, Object[] values, int vpos, int length) {
<span class="nc bnc" id="L605" title="All 2 branches missed.">        if (a.getClass() != arrayType())</span>
<span class="nc" id="L606">            arrayType().cast(a);  // throw NPE or CCE if bad type</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L608">            Object value = java.lang.reflect.Array.get(a, i+apos);</span>
            //Already done: value = convert(value, primitiveType);
<span class="nc bnc" id="L610" title="All 4 branches missed.">            assert(value.getClass() == wrapperType);</span>
<span class="nc" id="L611">            values[i+vpos] = value;</span>
        }
<span class="nc" id="L613">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>