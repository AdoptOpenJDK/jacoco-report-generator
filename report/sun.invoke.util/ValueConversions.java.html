<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ValueConversions.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.invoke.util</a> &gt; <span class="el_source">ValueConversions.java</span></div><h1>ValueConversions.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.invoke.util;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodHandles.Lookup;
import java.lang.invoke.MethodType;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumMap;
import java.util.List;

<span class="pc bfc" id="L40" title="All 2 branches covered.">public class ValueConversions {</span>
<span class="fc" id="L41">    private static final Class&lt;?&gt; THIS_CLASS = ValueConversions.class;</span>
    // Do not adjust this except for special platforms:
    private static final int MAX_ARITY;
    static {
<span class="fc" id="L45">        final Object[] values = { 255 };</span>
<span class="fc" id="L46">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                @Override
                public Void run() {
<span class="fc" id="L49">                    values[0] = Integer.getInteger(THIS_CLASS.getName()+&quot;.MAX_ARITY&quot;, 255);</span>
<span class="fc" id="L50">                    return null;</span>
                }
            });
<span class="fc" id="L53">        MAX_ARITY = (Integer) values[0];</span>
    }

<span class="fc" id="L56">    private static final Lookup IMPL_LOOKUP = MethodHandles.lookup();</span>

    private static EnumMap&lt;Wrapper, MethodHandle&gt;[] newWrapperCaches(int n) {
        @SuppressWarnings(&quot;unchecked&quot;)  // generic array creation
<span class="fc" id="L60">        EnumMap&lt;Wrapper, MethodHandle&gt;[] caches</span>
                = (EnumMap&lt;Wrapper, MethodHandle&gt;[]) new EnumMap&lt;?,?&gt;[n];
<span class="fc bfc" id="L62" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++)</span>
<span class="fc" id="L63">            caches[i] = new EnumMap&lt;&gt;(Wrapper.class);</span>
<span class="fc" id="L64">        return caches;</span>
    }

    /// Converting references to values.

    // There are several levels of this unboxing conversions:
    //   no conversions:  exactly Integer.valueOf, etc.
    //   implicit conversions sanctioned by JLS 5.1.2, etc.
    //   explicit conversions as allowed by explicitCastArguments

    static int unboxInteger(Object x, boolean cast) {
<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (x instanceof Integer)</span>
<span class="fc" id="L76">            return ((Integer) x).intValue();</span>
<span class="fc" id="L77">        return primitiveConversion(Wrapper.INT, x, cast).intValue();</span>
    }

    static byte unboxByte(Object x, boolean cast) {
<span class="fc bfc" id="L81" title="All 2 branches covered.">        if (x instanceof Byte)</span>
<span class="fc" id="L82">            return ((Byte) x).byteValue();</span>
<span class="fc" id="L83">        return primitiveConversion(Wrapper.BYTE, x, cast).byteValue();</span>
    }

    static short unboxShort(Object x, boolean cast) {
<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (x instanceof Short)</span>
<span class="fc" id="L88">            return ((Short) x).shortValue();</span>
<span class="fc" id="L89">        return primitiveConversion(Wrapper.SHORT, x, cast).shortValue();</span>
    }

    static boolean unboxBoolean(Object x, boolean cast) {
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (x instanceof Boolean)</span>
<span class="fc" id="L94">            return ((Boolean) x).booleanValue();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">        return (primitiveConversion(Wrapper.BOOLEAN, x, cast).intValue() &amp; 1) != 0;</span>
    }

    static char unboxCharacter(Object x, boolean cast) {
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (x instanceof Character)</span>
<span class="fc" id="L100">            return ((Character) x).charValue();</span>
<span class="fc" id="L101">        return (char) primitiveConversion(Wrapper.CHAR, x, cast).intValue();</span>
    }

    static long unboxLong(Object x, boolean cast) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (x instanceof Long)</span>
<span class="fc" id="L106">            return ((Long) x).longValue();</span>
<span class="fc" id="L107">        return primitiveConversion(Wrapper.LONG, x, cast).longValue();</span>
    }

    static float unboxFloat(Object x, boolean cast) {
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (x instanceof Float)</span>
<span class="fc" id="L112">            return ((Float) x).floatValue();</span>
<span class="fc" id="L113">        return primitiveConversion(Wrapper.FLOAT, x, cast).floatValue();</span>
    }

    static double unboxDouble(Object x, boolean cast) {
<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (x instanceof Double)</span>
<span class="fc" id="L118">            return ((Double) x).doubleValue();</span>
<span class="fc" id="L119">        return primitiveConversion(Wrapper.DOUBLE, x, cast).doubleValue();</span>
    }

    private static MethodType unboxType(Wrapper wrap) {
<span class="fc" id="L123">        return MethodType.methodType(wrap.primitiveType(), Object.class, boolean.class);</span>
    }

    private static final EnumMap&lt;Wrapper, MethodHandle&gt;[]
<span class="fc" id="L127">            UNBOX_CONVERSIONS = newWrapperCaches(2);</span>

    private static MethodHandle unbox(Wrapper wrap, boolean cast) {
<span class="fc bfc" id="L130" title="All 2 branches covered.">        EnumMap&lt;Wrapper, MethodHandle&gt; cache = UNBOX_CONVERSIONS[(cast?1:0)];</span>
<span class="fc" id="L131">        MethodHandle mh = cache.get(wrap);</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (mh != null) {</span>
<span class="fc" id="L133">            return mh;</span>
        }
        // slow path
<span class="pc bpc" id="L136" title="1 of 3 branches missed.">        switch (wrap) {</span>
            case OBJECT:
<span class="nc" id="L138">                mh = IDENTITY; break;</span>
            case VOID:
<span class="fc" id="L140">                mh = IGNORE; break;</span>
        }
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (mh != null) {</span>
<span class="fc" id="L143">            cache.put(wrap, mh);</span>
<span class="fc" id="L144">            return mh;</span>
        }
        // look up the method
<span class="fc" id="L147">        String name = &quot;unbox&quot; + wrap.wrapperSimpleName();</span>
<span class="fc" id="L148">        MethodType type = unboxType(wrap);</span>
        try {
<span class="fc" id="L150">            mh = IMPL_LOOKUP.findStatic(THIS_CLASS, name, type);</span>
<span class="nc" id="L151">        } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L152">            mh = null;</span>
<span class="fc" id="L153">        }</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if (mh != null) {</span>
<span class="fc" id="L155">            mh = MethodHandles.insertArguments(mh, 1, cast);</span>
<span class="fc" id="L156">            cache.put(wrap, mh);</span>
<span class="fc" id="L157">            return mh;</span>
        }
<span class="nc bnc" id="L159" title="All 2 branches missed.">        throw new IllegalArgumentException(&quot;cannot find unbox adapter for &quot; + wrap</span>
                + (cast ? &quot; (cast)&quot; : &quot;&quot;));
    }

    public static MethodHandle unboxCast(Wrapper type) {
<span class="nc" id="L164">        return unbox(type, true);</span>
    }

    public static MethodHandle unbox(Class&lt;?&gt; type) {
<span class="fc" id="L168">        return unbox(Wrapper.forPrimitiveType(type), false);</span>
    }

    public static MethodHandle unboxCast(Class&lt;?&gt; type) {
<span class="fc" id="L172">        return unbox(Wrapper.forPrimitiveType(type), true);</span>
    }

<span class="fc" id="L175">    static private final Integer ZERO_INT = 0, ONE_INT = 1;</span>

    /// Primitive conversions
    /**
     * Produce a Number which represents the given value {@code x}
     * according to the primitive type of the given wrapper {@code wrap}.
     * Caller must invoke intValue, byteValue, longValue (etc.) on the result
     * to retrieve the desired primitive value.
     */
    public static Number primitiveConversion(Wrapper wrap, Object x, boolean cast) {
        // Maybe merge this code with Wrapper.convert/cast.
        Number res;
<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (x == null) {</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">            if (!cast)  return null;</span>
<span class="fc" id="L189">            return ZERO_INT;</span>
        }
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (x instanceof Number) {</span>
<span class="fc" id="L192">            res = (Number) x;</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        } else if (x instanceof Boolean) {</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">            res = ((boolean)x ? ONE_INT : ZERO_INT);</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        } else if (x instanceof Character) {</span>
<span class="fc" id="L196">            res = (int)(char)x;</span>
        } else {
            // this will fail with the required ClassCastException:
<span class="nc" id="L199">            res = (Number) x;</span>
        }
<span class="fc" id="L201">        Wrapper xwrap = Wrapper.findWrapperType(x.getClass());</span>
<span class="pc bpc" id="L202" title="1 of 6 branches missed.">        if (xwrap == null || !cast &amp;&amp; !wrap.isConvertibleFrom(xwrap))</span>
            // this will fail with the required ClassCastException:
<span class="nc" id="L204">            return (Number) wrap.wrapperType().cast(x);</span>
<span class="fc" id="L205">        return res;</span>
    }

    /**
     * The JVM verifier allows boolean, byte, short, or char to widen to int.
     * Support exactly this conversion, from a boxed value type Boolean,
     * Byte, Short, Character, or Integer.
     */
    public static int widenSubword(Object x) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (x instanceof Integer)</span>
<span class="fc" id="L215">            return (int) x;</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        else if (x instanceof Boolean)</span>
<span class="fc" id="L217">            return fromBoolean((boolean) x);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        else if (x instanceof Character)</span>
<span class="fc" id="L219">            return (char) x;</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        else if (x instanceof Short)</span>
<span class="fc" id="L221">            return (short) x;</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        else if (x instanceof Byte)</span>
<span class="fc" id="L223">            return (byte) x;</span>
        else
            // Fail with a ClassCastException.
<span class="nc" id="L226">            return (int) x;</span>
    }

    /// Converting primitives to references

    static Integer boxInteger(int x) {
<span class="fc" id="L232">        return x;</span>
    }

    static Byte boxByte(byte x) {
<span class="fc" id="L236">        return x;</span>
    }

    static Short boxShort(short x) {
<span class="fc" id="L240">        return x;</span>
    }

    static Boolean boxBoolean(boolean x) {
<span class="fc" id="L244">        return x;</span>
    }

    static Character boxCharacter(char x) {
<span class="fc" id="L248">        return x;</span>
    }

    static Long boxLong(long x) {
<span class="fc" id="L252">        return x;</span>
    }

    static Float boxFloat(float x) {
<span class="fc" id="L256">        return x;</span>
    }

    static Double boxDouble(double x) {
<span class="fc" id="L260">        return x;</span>
    }

    private static MethodType boxType(Wrapper wrap) {
        // be exact, since return casts are hard to compose
<span class="fc" id="L265">        Class&lt;?&gt; boxType = wrap.wrapperType();</span>
<span class="fc" id="L266">        return MethodType.methodType(boxType, wrap.primitiveType());</span>
    }

    private static final EnumMap&lt;Wrapper, MethodHandle&gt;[]
<span class="fc" id="L270">            BOX_CONVERSIONS = newWrapperCaches(2);</span>

    private static MethodHandle box(Wrapper wrap, boolean exact) {
<span class="fc bfc" id="L273" title="All 2 branches covered.">        EnumMap&lt;Wrapper, MethodHandle&gt; cache = BOX_CONVERSIONS[(exact?1:0)];</span>
<span class="fc" id="L274">        MethodHandle mh = cache.get(wrap);</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (mh != null) {</span>
<span class="fc" id="L276">            return mh;</span>
        }
        // slow path
<span class="pc bpc" id="L279" title="1 of 3 branches missed.">        switch (wrap) {</span>
            case OBJECT:
<span class="fc" id="L281">                mh = IDENTITY; break;</span>
            case VOID:
<span class="nc" id="L283">                mh = ZERO_OBJECT;</span>
                break;
        }
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (mh != null) {</span>
<span class="fc" id="L287">            cache.put(wrap, mh);</span>
<span class="fc" id="L288">            return mh;</span>
        }
        // look up the method
<span class="fc" id="L291">        String name = &quot;box&quot; + wrap.wrapperSimpleName();</span>
<span class="fc" id="L292">        MethodType type = boxType(wrap);</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">        if (exact) {</span>
            try {
<span class="fc" id="L295">                mh = IMPL_LOOKUP.findStatic(THIS_CLASS, name, type);</span>
<span class="nc" id="L296">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L297">                mh = null;</span>
<span class="pc" id="L298">            }</span>
        } else {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">            mh = box(wrap, !exact).asType(type.erase());</span>
        }
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if (mh != null) {</span>
<span class="fc" id="L303">            cache.put(wrap, mh);</span>
<span class="fc" id="L304">            return mh;</span>
        }
<span class="nc bnc" id="L306" title="All 2 branches missed.">        throw new IllegalArgumentException(&quot;cannot find box adapter for &quot;</span>
                + wrap + (exact ? &quot; (exact)&quot; : &quot;&quot;));
    }

    public static MethodHandle box(Class&lt;?&gt; type) {
<span class="fc" id="L311">        boolean exact = false;</span>
        // e.g., boxShort(short)Short if exact,
        // e.g., boxShort(short)Object if !exact
<span class="fc" id="L314">        return box(Wrapper.forPrimitiveType(type), exact);</span>
    }

    public static MethodHandle box(Wrapper type) {
<span class="fc" id="L318">        boolean exact = false;</span>
<span class="fc" id="L319">        return box(type, exact);</span>
    }

    /// Constant functions

    static void ignore(Object x) {
        // no value to return; this is an unbox of null
<span class="fc" id="L326">    }</span>

    static void empty() {
<span class="fc" id="L329">    }</span>

    static Object zeroObject() {
<span class="fc" id="L332">        return null;</span>
    }

    static int zeroInteger() {
<span class="fc" id="L336">        return 0;</span>
    }

    static long zeroLong() {
<span class="fc" id="L340">        return 0;</span>
    }

    static float zeroFloat() {
<span class="fc" id="L344">        return 0;</span>
    }

    static double zeroDouble() {
<span class="fc" id="L348">        return 0;</span>
    }

    private static final EnumMap&lt;Wrapper, MethodHandle&gt;[]
<span class="fc" id="L352">            CONSTANT_FUNCTIONS = newWrapperCaches(2);</span>

    public static MethodHandle zeroConstantFunction(Wrapper wrap) {
<span class="fc" id="L355">        EnumMap&lt;Wrapper, MethodHandle&gt; cache = CONSTANT_FUNCTIONS[0];</span>
<span class="fc" id="L356">        MethodHandle mh = cache.get(wrap);</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (mh != null) {</span>
<span class="fc" id="L358">            return mh;</span>
        }
        // slow path
<span class="fc" id="L361">        MethodType type = MethodType.methodType(wrap.primitiveType());</span>
<span class="pc bpc" id="L362" title="1 of 3 branches missed.">        switch (wrap) {</span>
            case VOID:
<span class="nc" id="L364">                mh = EMPTY;</span>
<span class="nc" id="L365">                break;</span>
            case OBJECT:
            case INT: case LONG: case FLOAT: case DOUBLE:
                try {
<span class="fc" id="L369">                    mh = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;zero&quot;+wrap.wrapperSimpleName(), type);</span>
<span class="nc" id="L370">                } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L371">                    mh = null;</span>
<span class="fc" id="L372">                }</span>
                break;
        }
<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (mh != null) {</span>
<span class="fc" id="L376">            cache.put(wrap, mh);</span>
<span class="fc" id="L377">            return mh;</span>
        }

        // use zeroInt and cast the result
<span class="pc bpc" id="L381" title="2 of 4 branches missed.">        if (wrap.isSubwordOrInt() &amp;&amp; wrap != Wrapper.INT) {</span>
<span class="fc" id="L382">            mh = MethodHandles.explicitCastArguments(zeroConstantFunction(Wrapper.INT), type);</span>
<span class="fc" id="L383">            cache.put(wrap, mh);</span>
<span class="fc" id="L384">            return mh;</span>
        }
<span class="nc" id="L386">        throw new IllegalArgumentException(&quot;cannot find zero constant for &quot; + wrap);</span>
    }

    /// Converting references to references.

    /**
     * Identity function.
     * @param x an arbitrary reference value
     * @return the same value x
     */
    static &lt;T&gt; T identity(T x) {
<span class="fc" id="L397">        return x;</span>
    }

    static &lt;T&gt; T[] identity(T[] x) {
<span class="nc" id="L401">        return x;</span>
    }

    /**
     * Identity function on ints.
     * @param x an arbitrary int value
     * @return the same value x
     */
    static int identity(int x) {
<span class="fc" id="L410">        return x;</span>
    }

    static byte identity(byte x) {
<span class="fc" id="L414">        return x;</span>
    }

    static short identity(short x) {
<span class="fc" id="L418">        return x;</span>
    }

    static boolean identity(boolean x) {
<span class="fc" id="L422">        return x;</span>
    }

    static char identity(char x) {
<span class="fc" id="L426">        return x;</span>
    }

    /**
     * Identity function on longs.
     * @param x an arbitrary long value
     * @return the same value x
     */
    static long identity(long x) {
<span class="fc" id="L435">        return x;</span>
    }

    static float identity(float x) {
<span class="fc" id="L439">        return x;</span>
    }

    static double identity(double x) {
<span class="fc" id="L443">        return x;</span>
    }

    /**
     * Identity function, with reference cast.
     * @param t an arbitrary reference type
     * @param x an arbitrary reference value
     * @return the same value x
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T,U&gt; T castReference(Class&lt;? extends T&gt; t, U x) {
        // inlined Class.cast because we can't ForceInline it
<span class="fc bfc" id="L455" title="All 4 branches covered.">        if (x != null &amp;&amp; !t.isInstance(x))</span>
<span class="fc" id="L456">            throw newClassCastException(t, x);</span>
<span class="fc" id="L457">        return (T) x;</span>
    }

    private static ClassCastException newClassCastException(Class&lt;?&gt; t, Object obj) {
<span class="fc" id="L461">        return new ClassCastException(&quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + t.getName());</span>
    }

    private static final MethodHandle IDENTITY, CAST_REFERENCE, ZERO_OBJECT, IGNORE, EMPTY,
            ARRAY_IDENTITY, FILL_NEW_TYPED_ARRAY, FILL_NEW_ARRAY;
    static {
        try {
<span class="fc" id="L468">            MethodType idType = MethodType.genericMethodType(1);</span>
<span class="fc" id="L469">            MethodType castType = idType.insertParameterTypes(0, Class.class);</span>
<span class="fc" id="L470">            MethodType ignoreType = idType.changeReturnType(void.class);</span>
<span class="fc" id="L471">            MethodType zeroObjectType = MethodType.genericMethodType(0);</span>
<span class="fc" id="L472">            IDENTITY = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;identity&quot;, idType);</span>
            //CAST_REFERENCE = IMPL_LOOKUP.findVirtual(Class.class, &quot;cast&quot;, idType);
<span class="fc" id="L474">            CAST_REFERENCE = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;castReference&quot;, castType);</span>
<span class="fc" id="L475">            ZERO_OBJECT = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;zeroObject&quot;, zeroObjectType);</span>
<span class="fc" id="L476">            IGNORE = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;ignore&quot;, ignoreType);</span>
<span class="fc" id="L477">            EMPTY = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;empty&quot;, ignoreType.dropParameterTypes(0, 1));</span>
<span class="fc" id="L478">            ARRAY_IDENTITY = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;identity&quot;, MethodType.methodType(Object[].class, Object[].class));</span>
<span class="fc" id="L479">            FILL_NEW_ARRAY = IMPL_LOOKUP</span>
<span class="fc" id="L480">                    .findStatic(THIS_CLASS, &quot;fillNewArray&quot;,</span>
<span class="fc" id="L481">                          MethodType.methodType(Object[].class, Integer.class, Object[].class));</span>
<span class="fc" id="L482">            FILL_NEW_TYPED_ARRAY = IMPL_LOOKUP</span>
<span class="fc" id="L483">                    .findStatic(THIS_CLASS, &quot;fillNewTypedArray&quot;,</span>
<span class="fc" id="L484">                          MethodType.methodType(Object[].class, Object[].class, Integer.class, Object[].class));</span>
<span class="nc" id="L485">        } catch (NoSuchMethodException | IllegalAccessException ex) {</span>
<span class="nc" id="L486">            throw newInternalError(&quot;uncaught exception&quot;, ex);</span>
<span class="fc" id="L487">        }</span>
    }

    // Varargs methods need to be in a separately initialized class, to avoid bootstrapping problems.
<span class="nc" id="L491">    static class LazyStatics {</span>
        private static final MethodHandle COPY_AS_REFERENCE_ARRAY, COPY_AS_PRIMITIVE_ARRAY, MAKE_LIST;
        static {
            try {
                //MAKE_ARRAY = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;makeArray&quot;, MethodType.methodType(Object[].class, Object[].class));
<span class="fc" id="L496">                COPY_AS_REFERENCE_ARRAY = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;copyAsReferenceArray&quot;, MethodType.methodType(Object[].class, Class.class, Object[].class));</span>
<span class="fc" id="L497">                COPY_AS_PRIMITIVE_ARRAY = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;copyAsPrimitiveArray&quot;, MethodType.methodType(Object.class, Wrapper.class, Object[].class));</span>
<span class="fc" id="L498">                MAKE_LIST = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;makeList&quot;, MethodType.methodType(List.class, Object[].class));</span>
<span class="nc" id="L499">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L500">                throw newInternalError(&quot;uncaught exception&quot;, ex);</span>
<span class="fc" id="L501">            }</span>
<span class="fc" id="L502">        }</span>
    }

<span class="fc" id="L505">    private static final EnumMap&lt;Wrapper, MethodHandle&gt;[] WRAPPER_CASTS</span>
<span class="fc" id="L506">            = newWrapperCaches(1);</span>

    /** Return a method that casts its sole argument (an Object) to the given type
     *  and returns it as the given type.
     */
    public static MethodHandle cast(Class&lt;?&gt; type) {
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        if (type.isPrimitive())  throw new IllegalArgumentException(&quot;cannot cast primitive type &quot;+type);</span>
        MethodHandle mh;
<span class="fc" id="L514">        Wrapper wrap = null;</span>
<span class="fc" id="L515">        EnumMap&lt;Wrapper, MethodHandle&gt; cache = null;</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (Wrapper.isWrapperType(type)) {</span>
<span class="fc" id="L517">            wrap = Wrapper.forWrapperType(type);</span>
<span class="fc" id="L518">            cache = WRAPPER_CASTS[0];</span>
<span class="fc" id="L519">            mh = cache.get(wrap);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">            if (mh != null)  return mh;</span>
        }
<span class="fc" id="L522">        mh = MethodHandles.insertArguments(CAST_REFERENCE, 0, type);</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">        if (cache != null)</span>
<span class="fc" id="L524">            cache.put(wrap, mh);</span>
<span class="fc" id="L525">        return mh;</span>
    }

    public static MethodHandle identity() {
<span class="fc" id="L529">        return IDENTITY;</span>
    }

    public static MethodHandle identity(Class&lt;?&gt; type) {
<span class="fc bfc" id="L533" title="All 2 branches covered.">        if (!type.isPrimitive())</span>
            // Reference identity has been moved into MethodHandles:
<span class="fc" id="L535">            return MethodHandles.identity(type);</span>
<span class="fc" id="L536">        return identity(Wrapper.findPrimitiveType(type));</span>
    }

    public static MethodHandle identity(Wrapper wrap) {
<span class="fc" id="L540">        EnumMap&lt;Wrapper, MethodHandle&gt; cache = CONSTANT_FUNCTIONS[1];</span>
<span class="fc" id="L541">        MethodHandle mh = cache.get(wrap);</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">        if (mh != null) {</span>
<span class="fc" id="L543">            return mh;</span>
        }
        // slow path
<span class="fc" id="L546">        MethodType type = MethodType.methodType(wrap.primitiveType());</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (wrap != Wrapper.VOID)</span>
<span class="fc" id="L548">            type = type.appendParameterTypes(wrap.primitiveType());</span>
        try {
<span class="fc" id="L550">            mh = IMPL_LOOKUP.findStatic(THIS_CLASS, &quot;identity&quot;, type);</span>
<span class="fc" id="L551">        } catch (ReflectiveOperationException ex) {</span>
<span class="fc" id="L552">            mh = null;</span>
<span class="fc" id="L553">        }</span>
<span class="pc bpc" id="L554" title="1 of 4 branches missed.">        if (mh == null &amp;&amp; wrap == Wrapper.VOID) {</span>
<span class="fc" id="L555">            mh = EMPTY;  // #(){} : #()void</span>
        }
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">        if (mh != null) {</span>
<span class="fc" id="L558">            cache.put(wrap, mh);</span>
<span class="fc" id="L559">            return mh;</span>
        }

<span class="nc bnc" id="L562" title="All 2 branches missed.">        if (mh != null) {</span>
<span class="nc" id="L563">            cache.put(wrap, mh);</span>
<span class="nc" id="L564">            return mh;</span>
        }
<span class="nc" id="L566">        throw new IllegalArgumentException(&quot;cannot find identity for &quot; + wrap);</span>
    }

    /// Primitive conversions.
    // These are supported directly by the JVM, usually by a single instruction.
    // In the case of narrowing to a subword, there may be a pair of instructions.
    // In the case of booleans, there may be a helper routine to manage a 1-bit value.
    // This is the full 8x8 matrix (minus the diagonal).

    // narrow double to all other types:
    static float doubleToFloat(double x) {  // bytecode: d2f
<span class="fc" id="L577">        return (float) x;</span>
    }
    static long doubleToLong(double x) {  // bytecode: d2l
<span class="fc" id="L580">        return (long) x;</span>
    }
    static int doubleToInt(double x) {  // bytecode: d2i
<span class="fc" id="L583">        return (int) x;</span>
    }
    static short doubleToShort(double x) {  // bytecodes: d2i, i2s
<span class="fc" id="L586">        return (short) x;</span>
    }
    static char doubleToChar(double x) {  // bytecodes: d2i, i2c
<span class="fc" id="L589">        return (char) x;</span>
    }
    static byte doubleToByte(double x) {  // bytecodes: d2i, i2b
<span class="fc" id="L592">        return (byte) x;</span>
    }
    static boolean doubleToBoolean(double x) {
<span class="fc" id="L595">        return toBoolean((byte) x);</span>
    }

    // widen float:
    static double floatToDouble(float x) {  // bytecode: f2d
<span class="fc" id="L600">        return x;</span>
    }
    // narrow float:
    static long floatToLong(float x) {  // bytecode: f2l
<span class="fc" id="L604">        return (long) x;</span>
    }
    static int floatToInt(float x) {  // bytecode: f2i
<span class="fc" id="L607">        return (int) x;</span>
    }
    static short floatToShort(float x) {  // bytecodes: f2i, i2s
<span class="fc" id="L610">        return (short) x;</span>
    }
    static char floatToChar(float x) {  // bytecodes: f2i, i2c
<span class="fc" id="L613">        return (char) x;</span>
    }
    static byte floatToByte(float x) {  // bytecodes: f2i, i2b
<span class="fc" id="L616">        return (byte) x;</span>
    }
    static boolean floatToBoolean(float x) {
<span class="fc" id="L619">        return toBoolean((byte) x);</span>
    }

    // widen long:
    static double longToDouble(long x) {  // bytecode: l2d
<span class="fc" id="L624">        return x;</span>
    }
    static float longToFloat(long x) {  // bytecode: l2f
<span class="fc" id="L627">        return x;</span>
    }
    // narrow long:
    static int longToInt(long x) {  // bytecode: l2i
<span class="fc" id="L631">        return (int) x;</span>
    }
    static short longToShort(long x) {  // bytecodes: f2i, i2s
<span class="fc" id="L634">        return (short) x;</span>
    }
    static char longToChar(long x) {  // bytecodes: f2i, i2c
<span class="fc" id="L637">        return (char) x;</span>
    }
    static byte longToByte(long x) {  // bytecodes: f2i, i2b
<span class="fc" id="L640">        return (byte) x;</span>
    }
    static boolean longToBoolean(long x) {
<span class="fc" id="L643">        return toBoolean((byte) x);</span>
    }

    // widen int:
    static double intToDouble(int x) {  // bytecode: i2d
<span class="fc" id="L648">        return x;</span>
    }
    static float intToFloat(int x) {  // bytecode: i2f
<span class="fc" id="L651">        return x;</span>
    }
    static long intToLong(int x) {  // bytecode: i2l
<span class="fc" id="L654">        return x;</span>
    }
    // narrow int:
    static short intToShort(int x) {  // bytecode: i2s
<span class="fc" id="L658">        return (short) x;</span>
    }
    static char intToChar(int x) {  // bytecode: i2c
<span class="fc" id="L661">        return (char) x;</span>
    }
    static byte intToByte(int x) {  // bytecode: i2b
<span class="fc" id="L664">        return (byte) x;</span>
    }
    static boolean intToBoolean(int x) {
<span class="fc" id="L667">        return toBoolean((byte) x);</span>
    }

    // widen short:
    static double shortToDouble(short x) {  // bytecode: i2d (implicit 's2i')
<span class="fc" id="L672">        return x;</span>
    }
    static float shortToFloat(short x) {  // bytecode: i2f (implicit 's2i')
<span class="fc" id="L675">        return x;</span>
    }
    static long shortToLong(short x) {  // bytecode: i2l (implicit 's2i')
<span class="fc" id="L678">        return x;</span>
    }
    static int shortToInt(short x) {  // (implicit 's2i')
<span class="fc" id="L681">        return x;</span>
    }
    // narrow short:
    static char shortToChar(short x) {  // bytecode: i2c (implicit 's2i')
<span class="fc" id="L685">        return (char)x;</span>
    }
    static byte shortToByte(short x) {  // bytecode: i2b (implicit 's2i')
<span class="fc" id="L688">        return (byte)x;</span>
    }
    static boolean shortToBoolean(short x) {
<span class="fc" id="L691">        return toBoolean((byte) x);</span>
    }

    // widen char:
    static double charToDouble(char x) {  // bytecode: i2d (implicit 'c2i')
<span class="fc" id="L696">        return x;</span>
    }
    static float charToFloat(char x) {  // bytecode: i2f (implicit 'c2i')
<span class="fc" id="L699">        return x;</span>
    }
    static long charToLong(char x) {  // bytecode: i2l (implicit 'c2i')
<span class="fc" id="L702">        return x;</span>
    }
    static int charToInt(char x) {  // (implicit 'c2i')
<span class="fc" id="L705">        return x;</span>
    }
    // narrow char:
    static short charToShort(char x) {  // bytecode: i2s (implicit 'c2i')
<span class="fc" id="L709">        return (short)x;</span>
    }
    static byte charToByte(char x) {  // bytecode: i2b (implicit 'c2i')
<span class="fc" id="L712">        return (byte)x;</span>
    }
    static boolean charToBoolean(char x) {
<span class="fc" id="L715">        return toBoolean((byte) x);</span>
    }

    // widen byte:
    static double byteToDouble(byte x) {  // bytecode: i2d (implicit 'b2i')
<span class="fc" id="L720">        return x;</span>
    }
    static float byteToFloat(byte x) {  // bytecode: i2f (implicit 'b2i')
<span class="fc" id="L723">        return x;</span>
    }
    static long byteToLong(byte x) {  // bytecode: i2l (implicit 'b2i')
<span class="fc" id="L726">        return x;</span>
    }
    static int byteToInt(byte x) {  // (implicit 'b2i')
<span class="fc" id="L729">        return x;</span>
    }
    static short byteToShort(byte x) {  // bytecode: i2s (implicit 'b2i')
<span class="fc" id="L732">        return (short)x;</span>
    }
    static char byteToChar(byte x) {  // bytecode: i2b (implicit 'b2i')
<span class="fc" id="L735">        return (char)x;</span>
    }
    // narrow byte to boolean:
    static boolean byteToBoolean(byte x) {
<span class="fc" id="L739">        return toBoolean(x);</span>
    }

    // widen boolean to all types:
    static double booleanToDouble(boolean x) {
<span class="fc" id="L744">        return fromBoolean(x);</span>
    }
    static float booleanToFloat(boolean x) {
<span class="fc" id="L747">        return fromBoolean(x);</span>
    }
    static long booleanToLong(boolean x) {
<span class="fc" id="L750">        return fromBoolean(x);</span>
    }
    static int booleanToInt(boolean x) {
<span class="fc" id="L753">        return fromBoolean(x);</span>
    }
    static short booleanToShort(boolean x) {
<span class="fc" id="L756">        return fromBoolean(x);</span>
    }
    static char booleanToChar(boolean x) {
<span class="fc" id="L759">        return (char)fromBoolean(x);</span>
    }
    static byte booleanToByte(boolean x) {
<span class="fc" id="L762">        return fromBoolean(x);</span>
    }

    // helpers to force boolean into the conversion scheme:
    static boolean toBoolean(byte x) {
        // see javadoc for MethodHandles.explicitCastArguments
<span class="fc bfc" id="L768" title="All 2 branches covered.">        return ((x &amp; 1) != 0);</span>
    }
    static byte fromBoolean(boolean x) {
        // see javadoc for MethodHandles.explicitCastArguments
<span class="fc bfc" id="L772" title="All 2 branches covered.">        return (x ? (byte)1 : (byte)0);</span>
    }

    private static final EnumMap&lt;Wrapper, MethodHandle&gt;[]
<span class="fc" id="L776">            CONVERT_PRIMITIVE_FUNCTIONS = newWrapperCaches(Wrapper.values().length);</span>

    public static MethodHandle convertPrimitive(Wrapper wsrc, Wrapper wdst) {
<span class="fc" id="L779">        EnumMap&lt;Wrapper, MethodHandle&gt; cache = CONVERT_PRIMITIVE_FUNCTIONS[wsrc.ordinal()];</span>
<span class="fc" id="L780">        MethodHandle mh = cache.get(wdst);</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">        if (mh != null) {</span>
<span class="fc" id="L782">            return mh;</span>
        }
        // slow path
<span class="fc" id="L785">        Class&lt;?&gt; src = wsrc.primitiveType();</span>
<span class="fc" id="L786">        Class&lt;?&gt; dst = wdst.primitiveType();</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">        MethodType type = src == void.class ? MethodType.methodType(dst) : MethodType.methodType(dst, src);</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">        if (wsrc == wdst) {</span>
<span class="fc" id="L789">            mh = identity(src);</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">        } else if (wsrc == Wrapper.VOID) {</span>
<span class="fc" id="L791">            mh = zeroConstantFunction(wdst);</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">        } else if (wdst == Wrapper.VOID) {</span>
<span class="fc" id="L793">            mh = MethodHandles.dropArguments(EMPTY, 0, src);  // Defer back to MethodHandles.</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">        } else if (wsrc == Wrapper.OBJECT) {</span>
<span class="fc" id="L795">            mh = unboxCast(dst);</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">        } else if (wdst == Wrapper.OBJECT) {</span>
<span class="fc" id="L797">            mh = box(src);</span>
        } else {
<span class="pc bpc" id="L799" title="2 of 6 branches missed.">            assert(src.isPrimitive() &amp;&amp; dst.isPrimitive());</span>
            try {
<span class="fc" id="L801">                mh = IMPL_LOOKUP.findStatic(THIS_CLASS, src.getSimpleName()+&quot;To&quot;+capitalize(dst.getSimpleName()), type);</span>
<span class="nc" id="L802">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L803">                mh = null;</span>
<span class="fc" id="L804">            }</span>
        }
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">        if (mh != null) {</span>
<span class="pc bpc" id="L807" title="1 of 4 branches missed.">            assert(mh.type() == type) : mh;</span>
<span class="fc" id="L808">            cache.put(wdst, mh);</span>
<span class="fc" id="L809">            return mh;</span>
        }

<span class="nc" id="L812">        throw new IllegalArgumentException(&quot;cannot find primitive conversion function for &quot; +</span>
<span class="nc" id="L813">                                           src.getSimpleName()+&quot; -&gt; &quot;+dst.getSimpleName());</span>
    }

    public static MethodHandle convertPrimitive(Class&lt;?&gt; src, Class&lt;?&gt; dst) {
<span class="fc" id="L817">        return convertPrimitive(Wrapper.forPrimitiveType(src), Wrapper.forPrimitiveType(dst));</span>
    }

    private static String capitalize(String x) {
<span class="fc" id="L821">        return Character.toUpperCase(x.charAt(0))+x.substring(1);</span>
    }

    /// Collection of multiple arguments.

    public static Object convertArrayElements(Class&lt;?&gt; arrayType, Object array) {
<span class="nc" id="L827">        Class&lt;?&gt; src = array.getClass().getComponentType();</span>
<span class="nc" id="L828">        Class&lt;?&gt; dst = arrayType.getComponentType();</span>
<span class="nc bnc" id="L829" title="All 4 branches missed.">        if (src == null || dst == null)  throw new IllegalArgumentException(&quot;not array type&quot;);</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">        Wrapper sw = (src.isPrimitive() ? Wrapper.forPrimitiveType(src) : null);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">        Wrapper dw = (dst.isPrimitive() ? Wrapper.forPrimitiveType(dst) : null);</span>
        int length;
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (sw == null) {</span>
<span class="nc" id="L834">            Object[] a = (Object[]) array;</span>
<span class="nc" id="L835">            length = a.length;</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">            if (dw == null)</span>
<span class="nc" id="L837">                return Arrays.copyOf(a, length, arrayType.asSubclass(Object[].class));</span>
<span class="nc" id="L838">            Object res = dw.makeArray(length);</span>
<span class="nc" id="L839">            dw.copyArrayUnboxing(a, 0, res, 0, length);</span>
<span class="nc" id="L840">            return res;</span>
        }
<span class="nc" id="L842">        length = java.lang.reflect.Array.getLength(array);</span>
        Object[] res;
<span class="nc bnc" id="L844" title="All 2 branches missed.">        if (dw == null) {</span>
<span class="nc" id="L845">            res = Arrays.copyOf(NO_ARGS_ARRAY, length, arrayType.asSubclass(Object[].class));</span>
        } else {
<span class="nc" id="L847">            res = new Object[length];</span>
        }
<span class="nc" id="L849">        sw.copyArrayBoxing(array, 0, res, 0, length);</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">        if (dw == null)  return res;</span>
<span class="nc" id="L851">        Object a = dw.makeArray(length);</span>
<span class="nc" id="L852">        dw.copyArrayUnboxing(res, 0, a, 0, length);</span>
<span class="nc" id="L853">        return a;</span>
    }

    private static MethodHandle findCollector(String name, int nargs, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
<span class="fc" id="L857">        MethodType type = MethodType.genericMethodType(nargs)</span>
<span class="fc" id="L858">                .changeReturnType(rtype)</span>
<span class="fc" id="L859">                .insertParameterTypes(0, ptypes);</span>
        try {
<span class="fc" id="L861">            return IMPL_LOOKUP.findStatic(THIS_CLASS, name, type);</span>
<span class="fc" id="L862">        } catch (ReflectiveOperationException ex) {</span>
<span class="fc" id="L863">            return null;</span>
        }
    }

<span class="fc" id="L867">    private static final Object[] NO_ARGS_ARRAY = {};</span>
<span class="fc" id="L868">    private static Object[] makeArray(Object... args) { return args; }</span>
<span class="fc" id="L869">    private static Object[] array() { return NO_ARGS_ARRAY; }</span>
    private static Object[] array(Object a0)
<span class="fc" id="L871">                { return makeArray(a0); }</span>
    private static Object[] array(Object a0, Object a1)
<span class="fc" id="L873">                { return makeArray(a0, a1); }</span>
    private static Object[] array(Object a0, Object a1, Object a2)
<span class="fc" id="L875">                { return makeArray(a0, a1, a2); }</span>
    private static Object[] array(Object a0, Object a1, Object a2, Object a3)
<span class="fc" id="L877">                { return makeArray(a0, a1, a2, a3); }</span>
    private static Object[] array(Object a0, Object a1, Object a2, Object a3,
                                  Object a4)
<span class="fc" id="L880">                { return makeArray(a0, a1, a2, a3, a4); }</span>
    private static Object[] array(Object a0, Object a1, Object a2, Object a3,
                                  Object a4, Object a5)
<span class="fc" id="L883">                { return makeArray(a0, a1, a2, a3, a4, a5); }</span>
    private static Object[] array(Object a0, Object a1, Object a2, Object a3,
                                  Object a4, Object a5, Object a6)
<span class="fc" id="L886">                { return makeArray(a0, a1, a2, a3, a4, a5, a6); }</span>
    private static Object[] array(Object a0, Object a1, Object a2, Object a3,
                                  Object a4, Object a5, Object a6, Object a7)
<span class="fc" id="L889">                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7); }</span>
    private static Object[] array(Object a0, Object a1, Object a2, Object a3,
                                  Object a4, Object a5, Object a6, Object a7,
                                  Object a8)
<span class="fc" id="L893">                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8); }</span>
    private static Object[] array(Object a0, Object a1, Object a2, Object a3,
                                  Object a4, Object a5, Object a6, Object a7,
                                  Object a8, Object a9)
<span class="fc" id="L897">                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }</span>
    private static MethodHandle[] makeArrays() {
<span class="fc" id="L899">        ArrayList&lt;MethodHandle&gt; mhs = new ArrayList&lt;&gt;();</span>
        for (;;) {
<span class="fc" id="L901">            MethodHandle mh = findCollector(&quot;array&quot;, mhs.size(), Object[].class);</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">            if (mh == null)  break;</span>
<span class="fc" id="L903">            mhs.add(mh);</span>
<span class="fc" id="L904">        }</span>
<span class="pc bpc" id="L905" title="1 of 4 branches missed.">        assert(mhs.size() == 11);  // current number of methods</span>
<span class="fc" id="L906">        return mhs.toArray(new MethodHandle[MAX_ARITY+1]);</span>
    }
<span class="fc" id="L908">    private static final MethodHandle[] ARRAYS = makeArrays();</span>

    // filling versions of the above:
    // using Integer len instead of int len and no varargs to avoid bootstrapping problems
    private static Object[] fillNewArray(Integer len, Object[] /*not ...*/ args) {
<span class="fc" id="L913">        Object[] a = new Object[len];</span>
<span class="fc" id="L914">        fillWithArguments(a, 0, args);</span>
<span class="fc" id="L915">        return a;</span>
    }
    private static Object[] fillNewTypedArray(Object[] example, Integer len, Object[] /*not ...*/ args) {
<span class="fc" id="L918">        Object[] a = Arrays.copyOf(example, len);</span>
<span class="fc" id="L919">        fillWithArguments(a, 0, args);</span>
<span class="fc" id="L920">        return a;</span>
    }
    private static void fillWithArguments(Object[] a, int pos, Object... args) {
<span class="fc" id="L923">        System.arraycopy(args, 0, a, pos, args.length);</span>
<span class="fc" id="L924">    }</span>
    // using Integer pos instead of int pos to avoid bootstrapping problems
    private static Object[] fillArray(Integer pos, Object[] a, Object a0)
<span class="fc" id="L927">                { fillWithArguments(a, pos, a0); return a; }</span>
    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1)
<span class="fc" id="L929">                { fillWithArguments(a, pos, a0, a1); return a; }</span>
    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2)
<span class="fc" id="L931">                { fillWithArguments(a, pos, a0, a1, a2); return a; }</span>
    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3)
<span class="fc" id="L933">                { fillWithArguments(a, pos, a0, a1, a2, a3); return a; }</span>
    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
                                  Object a4)
<span class="fc" id="L936">                { fillWithArguments(a, pos, a0, a1, a2, a3, a4); return a; }</span>
    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
                                  Object a4, Object a5)
<span class="fc" id="L939">                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5); return a; }</span>
    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
                                  Object a4, Object a5, Object a6)
<span class="fc" id="L942">                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6); return a; }</span>
    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
                                  Object a4, Object a5, Object a6, Object a7)
<span class="fc" id="L945">                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7); return a; }</span>
    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
                                  Object a4, Object a5, Object a6, Object a7,
                                  Object a8)
<span class="fc" id="L949">                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8); return a; }</span>
    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
                                  Object a4, Object a5, Object a6, Object a7,
                                  Object a8, Object a9)
<span class="fc" id="L953">                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); return a; }</span>
    private static MethodHandle[] makeFillArrays() {
<span class="fc" id="L955">        ArrayList&lt;MethodHandle&gt; mhs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L956">        mhs.add(null);  // there is no empty fill; at least a0 is required</span>
        for (;;) {
<span class="fc" id="L958">            MethodHandle mh = findCollector(&quot;fillArray&quot;, mhs.size(), Object[].class, Integer.class, Object[].class);</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">            if (mh == null)  break;</span>
<span class="fc" id="L960">            mhs.add(mh);</span>
<span class="fc" id="L961">        }</span>
<span class="pc bpc" id="L962" title="1 of 4 branches missed.">        assert(mhs.size() == 11);  // current number of methods</span>
<span class="fc" id="L963">        return mhs.toArray(new MethodHandle[0]);</span>
    }
<span class="fc" id="L965">    private static final MethodHandle[] FILL_ARRAYS = makeFillArrays();</span>

    private static Object[] copyAsReferenceArray(Class&lt;? extends Object[]&gt; arrayType, Object... a) {
<span class="nc" id="L968">        return Arrays.copyOf(a, a.length, arrayType);</span>
    }
    private static Object copyAsPrimitiveArray(Wrapper w, Object... boxes) {
<span class="fc" id="L971">        Object a = w.makeArray(boxes.length);</span>
<span class="fc" id="L972">        w.copyArrayUnboxing(boxes, 0, a, 0, boxes.length);</span>
<span class="fc" id="L973">        return a;</span>
    }

    /** Return a method handle that takes the indicated number of Object
     *  arguments and returns an Object array of them, as if for varargs.
     */
    public static MethodHandle varargsArray(int nargs) {
<span class="fc" id="L980">        MethodHandle mh = ARRAYS[nargs];</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">        if (mh != null)  return mh;</span>
<span class="fc" id="L982">        mh = findCollector(&quot;array&quot;, nargs, Object[].class);</span>
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">        if (mh != null)  return ARRAYS[nargs] = mh;</span>
<span class="fc" id="L984">        mh = buildVarargsArray(FILL_NEW_ARRAY, ARRAY_IDENTITY, nargs);</span>
<span class="pc bpc" id="L985" title="2 of 4 branches missed.">        assert(assertCorrectArity(mh, nargs));</span>
<span class="fc" id="L986">        return ARRAYS[nargs] = mh;</span>
    }

    private static boolean assertCorrectArity(MethodHandle mh, int arity) {
<span class="pc bpc" id="L990" title="2 of 4 branches missed.">        assert(mh.type().parameterCount() == arity) : &quot;arity != &quot;+arity+&quot;: &quot;+mh;</span>
<span class="fc" id="L991">        return true;</span>
    }

    private static MethodHandle buildVarargsArray(MethodHandle newArray, MethodHandle finisher, int nargs) {
        // Build up the result mh as a sequence of fills like this:
        //   finisher(fill(fill(newArrayWA(23,x1..x10),10,x11..x20),20,x21..x23))
        // The various fill(_,10*I,___*[J]) are reusable.
<span class="fc" id="L998">        int leftLen = Math.min(nargs, LEFT_ARGS);  // absorb some arguments immediately</span>
<span class="fc" id="L999">        int rightLen = nargs - leftLen;</span>
<span class="fc" id="L1000">        MethodHandle leftCollector = newArray.bindTo(nargs);</span>
<span class="fc" id="L1001">        leftCollector = leftCollector.asCollector(Object[].class, leftLen);</span>
<span class="fc" id="L1002">        MethodHandle mh = finisher;</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">        if (rightLen &gt; 0) {</span>
<span class="fc" id="L1004">            MethodHandle rightFiller = fillToRight(LEFT_ARGS + rightLen);</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">            if (mh == ARRAY_IDENTITY)</span>
<span class="fc" id="L1006">                mh = rightFiller;</span>
            else
<span class="fc" id="L1008">                mh = MethodHandles.collectArguments(mh, 0, rightFiller);</span>
        }
<span class="fc bfc" id="L1010" title="All 2 branches covered.">        if (mh == ARRAY_IDENTITY)</span>
<span class="fc" id="L1011">            mh = leftCollector;</span>
        else
<span class="fc" id="L1013">            mh = MethodHandles.collectArguments(mh, 0, leftCollector);</span>
<span class="fc" id="L1014">        return mh;</span>
    }

<span class="fc" id="L1017">    private static final int LEFT_ARGS = (FILL_ARRAYS.length - 1);</span>
<span class="fc" id="L1018">    private static final MethodHandle[] FILL_ARRAY_TO_RIGHT = new MethodHandle[MAX_ARITY+1];</span>
    /** fill_array_to_right(N).invoke(a, argL..arg[N-1])
     *  fills a[L]..a[N-1] with corresponding arguments,
     *  and then returns a.  The value L is a global constant (LEFT_ARGS).
     */
    private static MethodHandle fillToRight(int nargs) {
<span class="fc" id="L1024">        MethodHandle filler = FILL_ARRAY_TO_RIGHT[nargs];</span>
<span class="fc bfc" id="L1025" title="All 2 branches covered.">        if (filler != null)  return filler;</span>
<span class="fc" id="L1026">        filler = buildFiller(nargs);</span>
<span class="pc bpc" id="L1027" title="2 of 4 branches missed.">        assert(assertCorrectArity(filler, nargs - LEFT_ARGS + 1));</span>
<span class="fc" id="L1028">        return FILL_ARRAY_TO_RIGHT[nargs] = filler;</span>
    }
    private static MethodHandle buildFiller(int nargs) {
<span class="fc bfc" id="L1031" title="All 2 branches covered.">        if (nargs &lt;= LEFT_ARGS)</span>
<span class="fc" id="L1032">            return ARRAY_IDENTITY;  // no args to fill; return the array unchanged</span>
        // we need room for both mh and a in mh.invoke(a, arg*[nargs])
<span class="fc" id="L1034">        final int CHUNK = LEFT_ARGS;</span>
<span class="fc" id="L1035">        int rightLen = nargs % CHUNK;</span>
<span class="fc" id="L1036">        int midLen = nargs - rightLen;</span>
<span class="fc bfc" id="L1037" title="All 2 branches covered.">        if (rightLen == 0) {</span>
<span class="fc" id="L1038">            midLen = nargs - (rightLen = CHUNK);</span>
<span class="fc bfc" id="L1039" title="All 2 branches covered.">            if (FILL_ARRAY_TO_RIGHT[midLen] == null) {</span>
                // build some precursors from left to right
<span class="fc bfc" id="L1041" title="All 2 branches covered.">                for (int j = LEFT_ARGS % CHUNK; j &lt; midLen; j += CHUNK)</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">                    if (j &gt; LEFT_ARGS)  fillToRight(j);</span>
            }
        }
<span class="pc bpc" id="L1045" title="1 of 2 branches missed.">        if (midLen &lt; LEFT_ARGS) rightLen = nargs - (midLen = LEFT_ARGS);</span>
<span class="pc bpc" id="L1046" title="2 of 4 branches missed.">        assert(rightLen &gt; 0);</span>
<span class="fc" id="L1047">        MethodHandle midFill = fillToRight(midLen);  // recursive fill</span>
<span class="fc" id="L1048">        MethodHandle rightFill = FILL_ARRAYS[rightLen].bindTo(midLen);  // [midLen..nargs-1]</span>
<span class="pc bpc" id="L1049" title="2 of 4 branches missed.">        assert(midFill.type().parameterCount()   == 1 + midLen - LEFT_ARGS);</span>
<span class="pc bpc" id="L1050" title="2 of 4 branches missed.">        assert(rightFill.type().parameterCount() == 1 + rightLen);</span>

        // Combine the two fills:
        //   right(mid(a, x10..x19), x20..x23)
        // The final product will look like this:
        //   right(mid(newArrayLeft(24, x0..x9), x10..x19), x20..x23)
<span class="fc bfc" id="L1056" title="All 2 branches covered.">        if (midLen == LEFT_ARGS)</span>
<span class="fc" id="L1057">            return rightFill;</span>
        else
<span class="fc" id="L1059">            return MethodHandles.collectArguments(rightFill, 0, midFill);</span>
    }

    // Type-polymorphic version of varargs maker.
<span class="fc" id="L1063">    private static final ClassValue&lt;MethodHandle[]&gt; TYPED_COLLECTORS</span>
<span class="fc" id="L1064">        = new ClassValue&lt;MethodHandle[]&gt;() {</span>
            @Override
            protected MethodHandle[] computeValue(Class&lt;?&gt; type) {
<span class="fc" id="L1067">                return new MethodHandle[256];</span>
            }
    };

    static final int MAX_JVM_ARITY = 255;  // limit imposed by the JVM

    /** Return a method handle that takes the indicated number of
     *  typed arguments and returns an array of them.
     *  The type argument is the array type.
     */
    public static MethodHandle varargsArray(Class&lt;?&gt; arrayType, int nargs) {
<span class="fc" id="L1078">        Class&lt;?&gt; elemType = arrayType.getComponentType();</span>
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">        if (elemType == null)  throw new IllegalArgumentException(&quot;not an array: &quot;+arrayType);</span>
        // FIXME: Need more special casing and caching here.
<span class="fc bfc" id="L1081" title="All 2 branches covered.">        if (nargs &gt;= MAX_JVM_ARITY/2 - 1) {</span>
<span class="fc" id="L1082">            int slots = nargs;</span>
            final int MAX_ARRAY_SLOTS = MAX_JVM_ARITY - 1;  // 1 for receiver MH
<span class="fc bfc" id="L1084" title="All 4 branches covered.">            if (arrayType == double[].class || arrayType == long[].class)</span>
<span class="fc" id="L1085">                slots *= 2;</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">            if (slots &gt; MAX_ARRAY_SLOTS)</span>
<span class="fc" id="L1087">                throw new IllegalArgumentException(&quot;too many arguments: &quot;+arrayType.getSimpleName()+&quot;, length &quot;+nargs);</span>
        }
<span class="fc bfc" id="L1089" title="All 2 branches covered.">        if (elemType == Object.class)</span>
<span class="fc" id="L1090">            return varargsArray(nargs);</span>
        // other cases:  primitive arrays, subtypes of Object[]
<span class="fc" id="L1092">        MethodHandle cache[] = TYPED_COLLECTORS.get(elemType);</span>
<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">        MethodHandle mh = nargs &lt; cache.length ? cache[nargs] : null;</span>
<span class="fc bfc" id="L1094" title="All 2 branches covered.">        if (mh != null)  return mh;</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">        if (elemType.isPrimitive()) {</span>
<span class="fc" id="L1096">            MethodHandle builder = FILL_NEW_ARRAY;</span>
<span class="fc" id="L1097">            MethodHandle producer = buildArrayProducer(arrayType);</span>
<span class="fc" id="L1098">            mh = buildVarargsArray(builder, producer, nargs);</span>
<span class="fc" id="L1099">        } else {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1101">            Class&lt;? extends Object[]&gt; objArrayType = (Class&lt;? extends Object[]&gt;) arrayType;</span>
<span class="fc" id="L1102">            Object[] example = Arrays.copyOf(NO_ARGS_ARRAY, 0, objArrayType);</span>
<span class="fc" id="L1103">            MethodHandle builder = FILL_NEW_TYPED_ARRAY.bindTo(example);</span>
<span class="fc" id="L1104">            MethodHandle producer = ARRAY_IDENTITY;</span>
<span class="fc" id="L1105">            mh = buildVarargsArray(builder, producer, nargs);</span>
        }
<span class="fc" id="L1107">        mh = mh.asType(MethodType.methodType(arrayType, Collections.&lt;Class&lt;?&gt;&gt;nCopies(nargs, elemType)));</span>
<span class="pc bpc" id="L1108" title="2 of 4 branches missed.">        assert(assertCorrectArity(mh, nargs));</span>
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">        if (nargs &lt; cache.length)</span>
<span class="fc" id="L1110">            cache[nargs] = mh;</span>
<span class="fc" id="L1111">        return mh;</span>
    }

    private static MethodHandle buildArrayProducer(Class&lt;?&gt; arrayType) {
<span class="fc" id="L1115">        Class&lt;?&gt; elemType = arrayType.getComponentType();</span>
<span class="pc bpc" id="L1116" title="1 of 2 branches missed.">        if (elemType.isPrimitive())</span>
<span class="fc" id="L1117">            return LazyStatics.COPY_AS_PRIMITIVE_ARRAY.bindTo(Wrapper.forPrimitiveType(elemType));</span>
        else
<span class="nc" id="L1119">            return LazyStatics.COPY_AS_REFERENCE_ARRAY.bindTo(arrayType);</span>
    }

    // List version of varargs maker.

<span class="fc" id="L1124">    private static final List&lt;Object&gt; NO_ARGS_LIST = Arrays.asList(NO_ARGS_ARRAY);</span>
<span class="fc" id="L1125">    private static List&lt;Object&gt; makeList(Object... args) { return Arrays.asList(args); }</span>
<span class="fc" id="L1126">    private static List&lt;Object&gt; list() { return NO_ARGS_LIST; }</span>
    private static List&lt;Object&gt; list(Object a0)
<span class="fc" id="L1128">                { return makeList(a0); }</span>
    private static List&lt;Object&gt; list(Object a0, Object a1)
<span class="fc" id="L1130">                { return makeList(a0, a1); }</span>
    private static List&lt;Object&gt; list(Object a0, Object a1, Object a2)
<span class="fc" id="L1132">                { return makeList(a0, a1, a2); }</span>
    private static List&lt;Object&gt; list(Object a0, Object a1, Object a2, Object a3)
<span class="fc" id="L1134">                { return makeList(a0, a1, a2, a3); }</span>
    private static List&lt;Object&gt; list(Object a0, Object a1, Object a2, Object a3,
                                     Object a4)
<span class="fc" id="L1137">                { return makeList(a0, a1, a2, a3, a4); }</span>
    private static List&lt;Object&gt; list(Object a0, Object a1, Object a2, Object a3,
                                     Object a4, Object a5)
<span class="fc" id="L1140">                { return makeList(a0, a1, a2, a3, a4, a5); }</span>
    private static List&lt;Object&gt; list(Object a0, Object a1, Object a2, Object a3,
                                     Object a4, Object a5, Object a6)
<span class="fc" id="L1143">                { return makeList(a0, a1, a2, a3, a4, a5, a6); }</span>
    private static List&lt;Object&gt; list(Object a0, Object a1, Object a2, Object a3,
                                     Object a4, Object a5, Object a6, Object a7)
<span class="fc" id="L1146">                { return makeList(a0, a1, a2, a3, a4, a5, a6, a7); }</span>
    private static List&lt;Object&gt; list(Object a0, Object a1, Object a2, Object a3,
                                     Object a4, Object a5, Object a6, Object a7,
                                     Object a8)
<span class="fc" id="L1150">                { return makeList(a0, a1, a2, a3, a4, a5, a6, a7, a8); }</span>
    private static List&lt;Object&gt; list(Object a0, Object a1, Object a2, Object a3,
                                     Object a4, Object a5, Object a6, Object a7,
                                     Object a8, Object a9)
<span class="fc" id="L1154">                { return makeList(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }</span>
    private static MethodHandle[] makeLists() {
<span class="fc" id="L1156">        ArrayList&lt;MethodHandle&gt; mhs = new ArrayList&lt;&gt;();</span>
        for (;;) {
<span class="fc" id="L1158">            MethodHandle mh = findCollector(&quot;list&quot;, mhs.size(), List.class);</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">            if (mh == null)  break;</span>
<span class="fc" id="L1160">            mhs.add(mh);</span>
<span class="fc" id="L1161">        }</span>
<span class="pc bpc" id="L1162" title="1 of 4 branches missed.">        assert(mhs.size() == 11);  // current number of methods</span>
<span class="fc" id="L1163">        return mhs.toArray(new MethodHandle[MAX_ARITY+1]);</span>
    }
<span class="fc" id="L1165">    private static final MethodHandle[] LISTS = makeLists();</span>

    /** Return a method handle that takes the indicated number of Object
     *  arguments and returns a List.
     */
    public static MethodHandle varargsList(int nargs) {
<span class="fc" id="L1171">        MethodHandle mh = LISTS[nargs];</span>
<span class="fc bfc" id="L1172" title="All 2 branches covered.">        if (mh != null)  return mh;</span>
<span class="fc" id="L1173">        mh = findCollector(&quot;list&quot;, nargs, List.class);</span>
<span class="pc bpc" id="L1174" title="1 of 2 branches missed.">        if (mh != null)  return LISTS[nargs] = mh;</span>
<span class="fc" id="L1175">        return LISTS[nargs] = buildVarargsList(nargs);</span>
    }
    private static MethodHandle buildVarargsList(int nargs) {
<span class="fc" id="L1178">        return MethodHandles.filterReturnValue(varargsArray(nargs), LazyStatics.MAKE_LIST);</span>
    }

    // handy shared exception makers (they simplify the common case code)
    private static InternalError newInternalError(String message, Throwable cause) {
<span class="nc" id="L1183">        return new InternalError(message, cause);</span>
    }
    private static InternalError newInternalError(Throwable cause) {
<span class="nc" id="L1186">        return new InternalError(cause);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>