<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Charset.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.nio.charset</a> &gt; <span class="el_source">Charset.java</span></div><h1>Charset.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.nio.charset;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.spi.CharsetProvider;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.ServiceLoader;
import java.util.ServiceConfigurationError;
import java.util.SortedMap;
import java.util.TreeMap;
import sun.misc.ASCIICaseInsensitiveComparator;
import sun.nio.cs.StandardCharsets;
import sun.nio.cs.ThreadLocalCoders;
import sun.security.action.GetPropertyAction;


/**
 * A named mapping between sequences of sixteen-bit Unicode &lt;a
 * href=&quot;../../lang/Character.html#unicode&quot;&gt;code units&lt;/a&gt; and sequences of
 * bytes.  This class defines methods for creating decoders and encoders and
 * for retrieving the various names associated with a charset.  Instances of
 * this class are immutable.
 *
 * &lt;p&gt; This class also defines static methods for testing whether a particular
 * charset is supported, for locating charset instances by name, and for
 * constructing a map that contains every charset for which support is
 * available in the current Java virtual machine.  Support for new charsets can
 * be added via the service-provider interface defined in the {@link
 * java.nio.charset.spi.CharsetProvider} class.
 *
 * &lt;p&gt; All of the methods defined in this class are safe for use by multiple
 * concurrent threads.
 *
 *
 * &lt;a name=&quot;names&quot;&gt;&lt;/a&gt;&lt;a name=&quot;charenc&quot;&gt;&lt;/a&gt;
 * &lt;h2&gt;Charset names&lt;/h2&gt;
 *
 * &lt;p&gt; Charsets are named by strings composed of the following characters:
 *
 * &lt;ul&gt;
 *
 *   &lt;li&gt; The uppercase letters &lt;tt&gt;'A'&lt;/tt&gt; through &lt;tt&gt;'Z'&lt;/tt&gt;
 *        (&lt;tt&gt;'&amp;#92;u0041'&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;'&amp;#92;u005a'&lt;/tt&gt;),
 *
 *   &lt;li&gt; The lowercase letters &lt;tt&gt;'a'&lt;/tt&gt; through &lt;tt&gt;'z'&lt;/tt&gt;
 *        (&lt;tt&gt;'&amp;#92;u0061'&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;'&amp;#92;u007a'&lt;/tt&gt;),
 *
 *   &lt;li&gt; The digits &lt;tt&gt;'0'&lt;/tt&gt; through &lt;tt&gt;'9'&lt;/tt&gt;
 *        (&lt;tt&gt;'&amp;#92;u0030'&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;'&amp;#92;u0039'&lt;/tt&gt;),
 *
 *   &lt;li&gt; The dash character &lt;tt&gt;'-'&lt;/tt&gt;
 *        (&lt;tt&gt;'&amp;#92;u002d'&lt;/tt&gt;,&amp;nbsp;&lt;small&gt;HYPHEN-MINUS&lt;/small&gt;),
 *
 *   &lt;li&gt; The plus character &lt;tt&gt;'+'&lt;/tt&gt;
 *        (&lt;tt&gt;'&amp;#92;u002b'&lt;/tt&gt;,&amp;nbsp;&lt;small&gt;PLUS SIGN&lt;/small&gt;),
 *
 *   &lt;li&gt; The period character &lt;tt&gt;'.'&lt;/tt&gt;
 *        (&lt;tt&gt;'&amp;#92;u002e'&lt;/tt&gt;,&amp;nbsp;&lt;small&gt;FULL STOP&lt;/small&gt;),
 *
 *   &lt;li&gt; The colon character &lt;tt&gt;':'&lt;/tt&gt;
 *        (&lt;tt&gt;'&amp;#92;u003a'&lt;/tt&gt;,&amp;nbsp;&lt;small&gt;COLON&lt;/small&gt;), and
 *
 *   &lt;li&gt; The underscore character &lt;tt&gt;'_'&lt;/tt&gt;
 *        (&lt;tt&gt;'&amp;#92;u005f'&lt;/tt&gt;,&amp;nbsp;&lt;small&gt;LOW&amp;nbsp;LINE&lt;/small&gt;).
 *
 * &lt;/ul&gt;
 *
 * A charset name must begin with either a letter or a digit.  The empty string
 * is not a legal charset name.  Charset names are not case-sensitive; that is,
 * case is always ignored when comparing charset names.  Charset names
 * generally follow the conventions documented in &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2278:&amp;nbsp;IANA Charset
 * Registration Procedures&lt;/i&gt;&lt;/a&gt;.
 *
 * &lt;p&gt; Every charset has a &lt;i&gt;canonical name&lt;/i&gt; and may also have one or more
 * &lt;i&gt;aliases&lt;/i&gt;.  The canonical name is returned by the {@link #name() name} method
 * of this class.  Canonical names are, by convention, usually in upper case.
 * The aliases of a charset are returned by the {@link #aliases() aliases}
 * method.
 *
 * &lt;p&gt;&lt;a name=&quot;hn&quot;&gt;Some charsets have an &lt;i&gt;historical name&lt;/i&gt; that is defined for
 * compatibility with previous versions of the Java platform.&lt;/a&gt;  A charset's
 * historical name is either its canonical name or one of its aliases.  The
 * historical name is returned by the &lt;tt&gt;getEncoding()&lt;/tt&gt; methods of the
 * {@link java.io.InputStreamReader#getEncoding InputStreamReader} and {@link
 * java.io.OutputStreamWriter#getEncoding OutputStreamWriter} classes.
 *
 * &lt;p&gt;&lt;a name=&quot;iana&quot;&gt;If a charset listed in the &lt;a
 * href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA Charset
 * Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then
 * its canonical name must be the name listed in the registry.&lt;/a&gt;  Many charsets
 * are given more than one name in the registry, in which case the registry
 * identifies one of the names as &lt;i&gt;MIME-preferred&lt;/i&gt;.  If a charset has more
 * than one registry name then its canonical name must be the MIME-preferred
 * name and the other names in the registry must be valid aliases.  If a
 * supported charset is not listed in the IANA registry then its canonical name
 * must begin with one of the strings &lt;tt&gt;&quot;X-&quot;&lt;/tt&gt; or &lt;tt&gt;&quot;x-&quot;&lt;/tt&gt;.
 *
 * &lt;p&gt; The IANA charset registry does change over time, and so the canonical
 * name and the aliases of a particular charset may also change over time.  To
 * ensure compatibility it is recommended that no alias ever be removed from a
 * charset, and that if the canonical name of a charset is changed then its
 * previous canonical name be made into an alias.
 *
 *
 * &lt;h2&gt;Standard charsets&lt;/h2&gt;
 *
 *
 *
 * &lt;p&gt;&lt;a name=&quot;standard&quot;&gt;Every implementation of the Java platform is required to support the
 * following standard charsets.&lt;/a&gt;  Consult the release documentation for your
 * implementation to see if any other charsets are supported.  The behavior
 * of such optional charsets may differ between implementations.
 *
 * &lt;blockquote&gt;&lt;table width=&quot;80%&quot; summary=&quot;Description of standard charsets&quot;&gt;
 * &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Charset&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;US-ASCII&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Seven-bit ASCII, a.k.a. &lt;tt&gt;ISO646-US&lt;/tt&gt;,
 *         a.k.a. the Basic Latin block of the Unicode character set&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;ISO-8859-1&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;ISO Latin Alphabet No. 1, a.k.a. &lt;tt&gt;ISO-LATIN-1&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;UTF-8&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Eight-bit UCS Transformation Format&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;UTF-16BE&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Sixteen-bit UCS Transformation Format,
 *         big-endian byte&amp;nbsp;order&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;UTF-16LE&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Sixteen-bit UCS Transformation Format,
 *         little-endian byte&amp;nbsp;order&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;UTF-16&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Sixteen-bit UCS Transformation Format,
 *         byte&amp;nbsp;order identified by an optional byte-order mark&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; The &lt;tt&gt;UTF-8&lt;/tt&gt; charset is specified by &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2279.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2279&lt;/i&gt;&lt;/a&gt;; the
 * transformation format upon which it is based is specified in
 * Amendment&amp;nbsp;2 of ISO&amp;nbsp;10646-1 and is also described in the &lt;a
 * href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;Unicode
 * Standard&lt;/i&gt;&lt;/a&gt;.
 *
 * &lt;p&gt; The &lt;tt&gt;UTF-16&lt;/tt&gt; charsets are specified by &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2781.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2781&lt;/i&gt;&lt;/a&gt;; the
 * transformation formats upon which they are based are specified in
 * Amendment&amp;nbsp;1 of ISO&amp;nbsp;10646-1 and are also described in the &lt;a
 * href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;Unicode
 * Standard&lt;/i&gt;&lt;/a&gt;.
 *
 * &lt;p&gt; The &lt;tt&gt;UTF-16&lt;/tt&gt; charsets use sixteen-bit quantities and are
 * therefore sensitive to byte order.  In these encodings the byte order of a
 * stream may be indicated by an initial &lt;i&gt;byte-order mark&lt;/i&gt; represented by
 * the Unicode character &lt;tt&gt;'&amp;#92;uFEFF'&lt;/tt&gt;.  Byte-order marks are handled
 * as follows:
 *
 * &lt;ul&gt;
 *
 *   &lt;li&gt;&lt;p&gt; When decoding, the &lt;tt&gt;UTF-16BE&lt;/tt&gt; and &lt;tt&gt;UTF-16LE&lt;/tt&gt;
 *   charsets interpret the initial byte-order marks as a &lt;small&gt;ZERO-WIDTH
 *   NON-BREAKING SPACE&lt;/small&gt;; when encoding, they do not write
 *   byte-order marks. &lt;/p&gt;&lt;/li&gt;

 *
 *   &lt;li&gt;&lt;p&gt; When decoding, the &lt;tt&gt;UTF-16&lt;/tt&gt; charset interprets the
 *   byte-order mark at the beginning of the input stream to indicate the
 *   byte-order of the stream but defaults to big-endian if there is no
 *   byte-order mark; when encoding, it uses big-endian byte order and writes
 *   a big-endian byte-order mark. &lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 * In any case, byte order marks occurring after the first element of an
 * input sequence are not omitted since the same code is used to represent
 * &lt;small&gt;ZERO-WIDTH NON-BREAKING SPACE&lt;/small&gt;.
 *
 * &lt;p&gt; Every instance of the Java virtual machine has a default charset, which
 * may or may not be one of the standard charsets.  The default charset is
 * determined during virtual-machine startup and typically depends upon the
 * locale and charset being used by the underlying operating system. &lt;/p&gt;
 *
 * &lt;p&gt;The {@link StandardCharsets} class defines constants for each of the
 * standard charsets.
 *
 * &lt;h2&gt;Terminology&lt;/h2&gt;
 *
 * &lt;p&gt; The name of this class is taken from the terms used in
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2278&lt;/i&gt;&lt;/a&gt;.
 * In that document a &lt;i&gt;charset&lt;/i&gt; is defined as the combination of
 * one or more coded character sets and a character-encoding scheme.
 * (This definition is confusing; some other software systems define
 * &lt;i&gt;charset&lt;/i&gt; as a synonym for &lt;i&gt;coded character set&lt;/i&gt;.)
 *
 * &lt;p&gt; A &lt;i&gt;coded character set&lt;/i&gt; is a mapping between a set of abstract
 * characters and a set of integers.  US-ASCII, ISO&amp;nbsp;8859-1,
 * JIS&amp;nbsp;X&amp;nbsp;0201, and Unicode are examples of coded character sets.
 *
 * &lt;p&gt; Some standards have defined a &lt;i&gt;character set&lt;/i&gt; to be simply a
 * set of abstract characters without an associated assigned numbering.
 * An alphabet is an example of such a character set.  However, the subtle
 * distinction between &lt;i&gt;character set&lt;/i&gt; and &lt;i&gt;coded character set&lt;/i&gt;
 * is rarely used in practice; the former has become a short form for the
 * latter, including in the Java API specification.
 *
 * &lt;p&gt; A &lt;i&gt;character-encoding scheme&lt;/i&gt; is a mapping between one or more
 * coded character sets and a set of octet (eight-bit byte) sequences.
 * UTF-8, UTF-16, ISO&amp;nbsp;2022, and EUC are examples of
 * character-encoding schemes.  Encoding schemes are often associated with
 * a particular coded character set; UTF-8, for example, is used only to
 * encode Unicode.  Some schemes, however, are associated with multiple
 * coded character sets; EUC, for example, can be used to encode
 * characters in a variety of Asian coded character sets.
 *
 * &lt;p&gt; When a coded character set is used exclusively with a single
 * character-encoding scheme then the corresponding charset is usually
 * named for the coded character set; otherwise a charset is usually named
 * for the encoding scheme and, possibly, the locale of the coded
 * character sets that it supports.  Hence &lt;tt&gt;US-ASCII&lt;/tt&gt; is both the
 * name of a coded character set and of the charset that encodes it, while
 * &lt;tt&gt;EUC-JP&lt;/tt&gt; is the name of the charset that encodes the
 * JIS&amp;nbsp;X&amp;nbsp;0201, JIS&amp;nbsp;X&amp;nbsp;0208, and JIS&amp;nbsp;X&amp;nbsp;0212
 * coded character sets for the Japanese language.
 *
 * &lt;p&gt; The native character encoding of the Java programming language is
 * UTF-16.  A charset in the Java platform therefore defines a mapping
 * between sequences of sixteen-bit UTF-16 code units (that is, sequences
 * of chars) and sequences of bytes. &lt;/p&gt;
 *
 *
 * @author Mark Reinhold
 * @author JSR-51 Expert Group
 * @since 1.4
 *
 * @see CharsetDecoder
 * @see CharsetEncoder
 * @see java.nio.charset.spi.CharsetProvider
 * @see java.lang.Character
 */

public abstract class Charset
    implements Comparable&lt;Charset&gt;
{

    /* -- Static methods -- */

<span class="fc" id="L277">    private static volatile String bugLevel = null;</span>

    static boolean atBugLevel(String bl) {              // package-private
<span class="fc" id="L280">        String level = bugLevel;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (level == null) {</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">            if (!sun.misc.VM.isBooted())</span>
<span class="fc" id="L283">                return false;</span>
<span class="fc" id="L284">            bugLevel = level = AccessController.doPrivileged(</span>
                new GetPropertyAction(&quot;sun.nio.cs.bugLevel&quot;, &quot;&quot;));
        }
<span class="fc" id="L287">        return level.equals(bl);</span>
    }

    /**
     * Checks that the given string is a legal charset name. &lt;/p&gt;
     *
     * @param  s
     *         A purported charset name
     *
     * @throws  IllegalCharsetNameException
     *          If the given name is not a legal charset name
     */
    private static void checkName(String s) {
<span class="fc" id="L300">        int n = s.length();</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (!atBugLevel(&quot;1.4&quot;)) {</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">            if (n == 0)</span>
<span class="fc" id="L303">                throw new IllegalCharsetNameException(s);</span>
        }
<span class="fc bfc" id="L305" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L306">            char c = s.charAt(i);</span>
<span class="fc bfc" id="L307" title="All 4 branches covered.">            if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') continue;</span>
<span class="pc bpc" id="L308" title="1 of 4 branches missed.">            if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') continue;</span>
<span class="fc bfc" id="L309" title="All 4 branches covered.">            if (c &gt;= '0' &amp;&amp; c &lt;= '9') continue;</span>
<span class="pc bpc" id="L310" title="1 of 4 branches missed.">            if (c == '-' &amp;&amp; i != 0) continue;</span>
<span class="pc bpc" id="L311" title="1 of 4 branches missed.">            if (c == '+' &amp;&amp; i != 0) continue;</span>
<span class="pc bpc" id="L312" title="1 of 4 branches missed.">            if (c == ':' &amp;&amp; i != 0) continue;</span>
<span class="pc bpc" id="L313" title="1 of 4 branches missed.">            if (c == '_' &amp;&amp; i != 0) continue;</span>
<span class="pc bpc" id="L314" title="2 of 4 branches missed.">            if (c == '.' &amp;&amp; i != 0) continue;</span>
<span class="nc" id="L315">            throw new IllegalCharsetNameException(s);</span>
        }
<span class="fc" id="L317">    }</span>

    /* The standard set of charsets */
<span class="fc" id="L320">    private static CharsetProvider standardProvider = new StandardCharsets();</span>

    // Cache of the most-recently-returned charsets,
    // along with the names that were used to find them
    //
<span class="fc" id="L325">    private static volatile Object[] cache1 = null; // &quot;Level 1&quot; cache</span>
<span class="fc" id="L326">    private static volatile Object[] cache2 = null; // &quot;Level 2&quot; cache</span>

    private static void cache(String charsetName, Charset cs) {
<span class="fc" id="L329">        cache2 = cache1;</span>
<span class="fc" id="L330">        cache1 = new Object[] { charsetName, cs };</span>
<span class="fc" id="L331">    }</span>

    // Creates an iterator that walks over the available providers, ignoring
    // those whose lookup or instantiation causes a security exception to be
    // thrown.  Should be invoked with full privileges.
    //
    private static Iterator&lt;CharsetProvider&gt; providers() {
<span class="fc" id="L338">        return new Iterator&lt;CharsetProvider&gt;() {</span>

<span class="fc" id="L340">                ClassLoader cl = ClassLoader.getSystemClassLoader();</span>
<span class="fc" id="L341">                ServiceLoader&lt;CharsetProvider&gt; sl =</span>
<span class="fc" id="L342">                    ServiceLoader.load(CharsetProvider.class, cl);</span>
<span class="fc" id="L343">                Iterator&lt;CharsetProvider&gt; i = sl.iterator();</span>

<span class="fc" id="L345">                CharsetProvider next = null;</span>

                private boolean getNext() {
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">                    while (next == null) {</span>
                        try {
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">                            if (!i.hasNext())</span>
<span class="fc" id="L351">                                return false;</span>
<span class="nc" id="L352">                            next = i.next();</span>
<span class="nc" id="L353">                        } catch (ServiceConfigurationError sce) {</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">                            if (sce.getCause() instanceof SecurityException) {</span>
                                // Ignore security exceptions
<span class="nc" id="L356">                                continue;</span>
                            }
<span class="nc" id="L358">                            throw sce;</span>
<span class="nc" id="L359">                        }</span>
                    }
<span class="nc" id="L361">                    return true;</span>
                }

                public boolean hasNext() {
<span class="fc" id="L365">                    return getNext();</span>
                }

                public CharsetProvider next() {
<span class="nc bnc" id="L369" title="All 2 branches missed.">                    if (!getNext())</span>
<span class="nc" id="L370">                        throw new NoSuchElementException();</span>
<span class="nc" id="L371">                    CharsetProvider n = next;</span>
<span class="nc" id="L372">                    next = null;</span>
<span class="nc" id="L373">                    return n;</span>
                }

                public void remove() {
<span class="nc" id="L377">                    throw new UnsupportedOperationException();</span>
                }

            };
    }

    // Thread-local gate to prevent recursive provider lookups
<span class="fc" id="L384">    private static ThreadLocal&lt;ThreadLocal&lt;?&gt;&gt; gate =</span>
            new ThreadLocal&lt;ThreadLocal&lt;?&gt;&gt;();

    private static Charset lookupViaProviders(final String charsetName) {

        // The runtime startup sequence looks up standard charsets as a
        // consequence of the VM's invocation of System.initializeSystemClass
        // in order to, e.g., set system properties and encode filenames.  At
        // that point the application class loader has not been initialized,
        // however, so we can't look for providers because doing so will cause
        // that loader to be prematurely initialized with incomplete
        // information.
        //
<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (!sun.misc.VM.isBooted())</span>
<span class="fc" id="L398">            return null;</span>

<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        if (gate.get() != null)</span>
            // Avoid recursive provider lookups
<span class="nc" id="L402">            return null;</span>
        try {
<span class="fc" id="L404">            gate.set(gate);</span>

<span class="fc" id="L406">            return AccessController.doPrivileged(</span>
<span class="fc" id="L407">                new PrivilegedAction&lt;Charset&gt;() {</span>
                    public Charset run() {
<span class="fc" id="L409">                        for (Iterator&lt;CharsetProvider&gt; i = providers();</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">                             i.hasNext();) {</span>
<span class="nc" id="L411">                            CharsetProvider cp = i.next();</span>
<span class="nc" id="L412">                            Charset cs = cp.charsetForName(charsetName);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                            if (cs != null)</span>
<span class="nc" id="L414">                                return cs;</span>
<span class="nc" id="L415">                        }</span>
<span class="fc" id="L416">                        return null;</span>
                    }
                });

        } finally {
<span class="pc" id="L421">            gate.set(null);</span>
        }
    }

    /* The extended set of charsets */
<span class="nc" id="L426">    private static class ExtendedProviderHolder {</span>
<span class="fc" id="L427">        static final CharsetProvider extendedProvider = extendedProvider();</span>
        // returns ExtendedProvider, if installed
        private static CharsetProvider extendedProvider() {
<span class="fc" id="L430">            return AccessController.doPrivileged(</span>
<span class="fc" id="L431">                       new PrivilegedAction&lt;CharsetProvider&gt;() {</span>
                           public CharsetProvider run() {
                                try {
<span class="fc" id="L434">                                    Class&lt;?&gt; epc</span>
<span class="fc" id="L435">                                        = Class.forName(&quot;sun.nio.cs.ext.ExtendedCharsets&quot;);</span>
<span class="fc" id="L436">                                    return (CharsetProvider)epc.newInstance();</span>
<span class="nc" id="L437">                                } catch (ClassNotFoundException x) {</span>
                                    // Extended charsets not available
                                    // (charsets.jar not present)
<span class="nc" id="L440">                                } catch (InstantiationException |</span>
                                         IllegalAccessException x) {
<span class="nc" id="L442">                                  throw new Error(x);</span>
<span class="nc" id="L443">                                }</span>
<span class="nc" id="L444">                                return null;</span>
                            }
                        });
        }
    }

    private static Charset lookupExtendedCharset(String charsetName) {
<span class="fc" id="L451">        CharsetProvider ecp = ExtendedProviderHolder.extendedProvider;</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        return (ecp != null) ? ecp.charsetForName(charsetName) : null;</span>
    }

    private static Charset lookup(String charsetName) {
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">        if (charsetName == null)</span>
<span class="nc" id="L457">            throw new IllegalArgumentException(&quot;Null charset name&quot;);</span>
        Object[] a;
<span class="fc bfc" id="L459" title="All 4 branches covered.">        if ((a = cache1) != null &amp;&amp; charsetName.equals(a[0]))</span>
<span class="fc" id="L460">            return (Charset)a[1];</span>
        // We expect most programs to use one Charset repeatedly.
        // We convey a hint to this effect to the VM by putting the
        // level 1 cache miss code in a separate method.
<span class="fc" id="L464">        return lookup2(charsetName);</span>
    }

    private static Charset lookup2(String charsetName) {
        Object[] a;
<span class="fc bfc" id="L469" title="All 4 branches covered.">        if ((a = cache2) != null &amp;&amp; charsetName.equals(a[0])) {</span>
<span class="fc" id="L470">            cache2 = cache1;</span>
<span class="fc" id="L471">            cache1 = a;</span>
<span class="fc" id="L472">            return (Charset)a[1];</span>
        }
        Charset cs;
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if ((cs = standardProvider.charsetForName(charsetName)) != null ||</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">            (cs = lookupExtendedCharset(charsetName))           != null ||</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">            (cs = lookupViaProviders(charsetName))              != null)</span>
        {
<span class="fc" id="L479">            cache(charsetName, cs);</span>
<span class="fc" id="L480">            return cs;</span>
        }

        /* Only need to check the name if we didn't find a charset for it */
<span class="fc" id="L484">        checkName(charsetName);</span>
<span class="fc" id="L485">        return null;</span>
    }

    /**
     * Tells whether the named charset is supported.
     *
     * @param  charsetName
     *         The name of the requested charset; may be either
     *         a canonical name or an alias
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, support for the named charset
     *          is available in the current Java virtual machine
     *
     * @throws IllegalCharsetNameException
     *         If the given charset name is illegal
     *
     * @throws  IllegalArgumentException
     *          If the given &lt;tt&gt;charsetName&lt;/tt&gt; is null
     */
    public static boolean isSupported(String charsetName) {
<span class="fc bfc" id="L505" title="All 2 branches covered.">        return (lookup(charsetName) != null);</span>
    }

    /**
     * Returns a charset object for the named charset.
     *
     * @param  charsetName
     *         The name of the requested charset; may be either
     *         a canonical name or an alias
     *
     * @return  A charset object for the named charset
     *
     * @throws  IllegalCharsetNameException
     *          If the given charset name is illegal
     *
     * @throws  IllegalArgumentException
     *          If the given &lt;tt&gt;charsetName&lt;/tt&gt; is null
     *
     * @throws  UnsupportedCharsetException
     *          If no support for the named charset is available
     *          in this instance of the Java virtual machine
     */
    public static Charset forName(String charsetName) {
<span class="fc" id="L528">        Charset cs = lookup(charsetName);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (cs != null)</span>
<span class="fc" id="L530">            return cs;</span>
<span class="fc" id="L531">        throw new UnsupportedCharsetException(charsetName);</span>
    }

    // Fold charsets from the given iterator into the given map, ignoring
    // charsets whose names already have entries in the map.
    //
    private static void put(Iterator&lt;Charset&gt; i, Map&lt;String,Charset&gt; m) {
<span class="fc bfc" id="L538" title="All 2 branches covered.">        while (i.hasNext()) {</span>
<span class="fc" id="L539">            Charset cs = i.next();</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">            if (!m.containsKey(cs.name()))</span>
<span class="fc" id="L541">                m.put(cs.name(), cs);</span>
<span class="fc" id="L542">        }</span>
<span class="fc" id="L543">    }</span>

    /**
     * Constructs a sorted map from canonical charset names to charset objects.
     *
     * &lt;p&gt; The map returned by this method will have one entry for each charset
     * for which support is available in the current Java virtual machine.  If
     * two or more supported charsets have the same canonical name then the
     * resulting map will contain just one of them; which one it will contain
     * is not specified. &lt;/p&gt;
     *
     * &lt;p&gt; The invocation of this method, and the subsequent use of the
     * resulting map, may cause time-consuming disk or network I/O operations
     * to occur.  This method is provided for applications that need to
     * enumerate all of the available charsets, for example to allow user
     * charset selection.  This method is not used by the {@link #forName
     * forName} method, which instead employs an efficient incremental lookup
     * algorithm.
     *
     * &lt;p&gt; This method may return different results at different times if new
     * charset providers are dynamically made available to the current Java
     * virtual machine.  In the absence of such changes, the charsets returned
     * by this method are exactly those that can be retrieved via the {@link
     * #forName forName} method.  &lt;/p&gt;
     *
     * @return An immutable, case-insensitive map from canonical charset names
     *         to charset objects
     */
    public static SortedMap&lt;String,Charset&gt; availableCharsets() {
<span class="nc" id="L572">        return AccessController.doPrivileged(</span>
<span class="fc" id="L573">            new PrivilegedAction&lt;SortedMap&lt;String,Charset&gt;&gt;() {</span>
                public SortedMap&lt;String,Charset&gt; run() {
<span class="nc" id="L575">                    TreeMap&lt;String,Charset&gt; m =</span>
                        new TreeMap&lt;String,Charset&gt;(
                            ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
<span class="nc" id="L578">                    put(standardProvider.charsets(), m);</span>
<span class="nc" id="L579">                    CharsetProvider ecp = ExtendedProviderHolder.extendedProvider;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                    if (ecp != null)</span>
<span class="nc" id="L581">                        put(ecp.charsets(), m);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                    for (Iterator&lt;CharsetProvider&gt; i = providers(); i.hasNext();) {</span>
<span class="nc" id="L583">                        CharsetProvider cp = i.next();</span>
<span class="nc" id="L584">                        put(cp.charsets(), m);</span>
<span class="nc" id="L585">                    }</span>
<span class="nc" id="L586">                    return Collections.unmodifiableSortedMap(m);</span>
                }
            });
    }

    private static volatile Charset defaultCharset;

    /**
     * Returns the default charset of this Java virtual machine.
     *
     * &lt;p&gt; The default charset is determined during virtual-machine startup and
     * typically depends upon the locale and charset of the underlying
     * operating system.
     *
     * @return  A charset object for the default charset
     *
     * @since 1.5
     */
    public static Charset defaultCharset() {
<span class="fc bfc" id="L605" title="All 2 branches covered.">        if (defaultCharset == null) {</span>
<span class="fc" id="L606">            synchronized (Charset.class) {</span>
<span class="fc" id="L607">                String csn = AccessController.doPrivileged(</span>
                    new GetPropertyAction(&quot;file.encoding&quot;));
<span class="fc" id="L609">                Charset cs = lookup(csn);</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">                if (cs != null)</span>
<span class="fc" id="L611">                    defaultCharset = cs;</span>
                else
<span class="fc" id="L613">                    defaultCharset = forName(&quot;UTF-8&quot;);</span>
<span class="pc" id="L614">            }</span>
        }
<span class="fc" id="L616">        return defaultCharset;</span>
    }


    /* -- Instance fields and methods -- */

    private final String name;          // tickles a bug in oldjavac
    private final String[] aliases;     // tickles a bug in oldjavac
<span class="fc" id="L624">    private Set&lt;String&gt; aliasSet = null;</span>

    /**
     * Initializes a new charset with the given canonical name and alias
     * set.
     *
     * @param  canonicalName
     *         The canonical name of this charset
     *
     * @param  aliases
     *         An array of this charset's aliases, or null if it has no aliases
     *
     * @throws IllegalCharsetNameException
     *         If the canonical name or any of the aliases are illegal
     */
<span class="fc" id="L639">    protected Charset(String canonicalName, String[] aliases) {</span>
<span class="fc" id="L640">        checkName(canonicalName);</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">        String[] as = (aliases == null) ? new String[0] : aliases;</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">        for (int i = 0; i &lt; as.length; i++)</span>
<span class="fc" id="L643">            checkName(as[i]);</span>
<span class="fc" id="L644">        this.name = canonicalName;</span>
<span class="fc" id="L645">        this.aliases = as;</span>
<span class="fc" id="L646">    }</span>

    /**
     * Returns this charset's canonical name.
     *
     * @return  The canonical name of this charset
     */
    public final String name() {
<span class="fc" id="L654">        return name;</span>
    }

    /**
     * Returns a set containing this charset's aliases.
     *
     * @return  An immutable set of this charset's aliases
     */
    public final Set&lt;String&gt; aliases() {
<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (aliasSet != null)</span>
<span class="nc" id="L664">            return aliasSet;</span>
<span class="nc" id="L665">        int n = aliases.length;</span>
<span class="nc" id="L666">        HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;(n);</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++)</span>
<span class="nc" id="L668">            hs.add(aliases[i]);</span>
<span class="nc" id="L669">        aliasSet = Collections.unmodifiableSet(hs);</span>
<span class="nc" id="L670">        return aliasSet;</span>
    }

    /**
     * Returns this charset's human-readable name for the default locale.
     *
     * &lt;p&gt; The default implementation of this method simply returns this
     * charset's canonical name.  Concrete subclasses of this class may
     * override this method in order to provide a localized display name. &lt;/p&gt;
     *
     * @return  The display name of this charset in the default locale
     */
    public String displayName() {
<span class="nc" id="L683">        return name;</span>
    }

    /**
     * Tells whether or not this charset is registered in the &lt;a
     * href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA Charset
     * Registry&lt;/a&gt;.
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, this charset is known by its
     *          implementor to be registered with the IANA
     */
    public final boolean isRegistered() {
<span class="nc bnc" id="L695" title="All 4 branches missed.">        return !name.startsWith(&quot;X-&quot;) &amp;&amp; !name.startsWith(&quot;x-&quot;);</span>
    }

    /**
     * Returns this charset's human-readable name for the given locale.
     *
     * &lt;p&gt; The default implementation of this method simply returns this
     * charset's canonical name.  Concrete subclasses of this class may
     * override this method in order to provide a localized display name. &lt;/p&gt;
     *
     * @param  locale
     *         The locale for which the display name is to be retrieved
     *
     * @return  The display name of this charset in the given locale
     */
    public String displayName(Locale locale) {
<span class="nc" id="L711">        return name;</span>
    }

    /**
     * Tells whether or not this charset contains the given charset.
     *
     * &lt;p&gt; A charset &lt;i&gt;C&lt;/i&gt; is said to &lt;i&gt;contain&lt;/i&gt; a charset &lt;i&gt;D&lt;/i&gt; if,
     * and only if, every character representable in &lt;i&gt;D&lt;/i&gt; is also
     * representable in &lt;i&gt;C&lt;/i&gt;.  If this relationship holds then it is
     * guaranteed that every string that can be encoded in &lt;i&gt;D&lt;/i&gt; can also be
     * encoded in &lt;i&gt;C&lt;/i&gt; without performing any replacements.
     *
     * &lt;p&gt; That &lt;i&gt;C&lt;/i&gt; contains &lt;i&gt;D&lt;/i&gt; does not imply that each character
     * representable in &lt;i&gt;C&lt;/i&gt; by a particular byte sequence is represented
     * in &lt;i&gt;D&lt;/i&gt; by the same byte sequence, although sometimes this is the
     * case.
     *
     * &lt;p&gt; Every charset contains itself.
     *
     * &lt;p&gt; This method computes an approximation of the containment relation:
     * If it returns &lt;tt&gt;true&lt;/tt&gt; then the given charset is known to be
     * contained by this charset; if it returns &lt;tt&gt;false&lt;/tt&gt;, however, then
     * it is not necessarily the case that the given charset is not contained
     * in this charset.
     *
     * @param   cs
     *          The given charset
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if the given charset is contained in this charset
     */
    public abstract boolean contains(Charset cs);

    /**
     * Constructs a new decoder for this charset.
     *
     * @return  A new decoder for this charset
     */
    public abstract CharsetDecoder newDecoder();

    /**
     * Constructs a new encoder for this charset.
     *
     * @return  A new encoder for this charset
     *
     * @throws  UnsupportedOperationException
     *          If this charset does not support encoding
     */
    public abstract CharsetEncoder newEncoder();

    /**
     * Tells whether or not this charset supports encoding.
     *
     * &lt;p&gt; Nearly all charsets support encoding.  The primary exceptions are
     * special-purpose &lt;i&gt;auto-detect&lt;/i&gt; charsets whose decoders can determine
     * which of several possible encoding schemes is in use by examining the
     * input byte sequence.  Such charsets do not support encoding because
     * there is no way to determine which encoding should be used on output.
     * Implementations of such charsets should override this method to return
     * &lt;tt&gt;false&lt;/tt&gt;. &lt;/p&gt;
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, this charset supports encoding
     */
    public boolean canEncode() {
<span class="nc" id="L774">        return true;</span>
    }

    /**
     * Convenience method that decodes bytes in this charset into Unicode
     * characters.
     *
     * &lt;p&gt; An invocation of this method upon a charset &lt;tt&gt;cs&lt;/tt&gt; returns the
     * same result as the expression
     *
     * &lt;pre&gt;
     *     cs.newDecoder()
     *       .onMalformedInput(CodingErrorAction.REPLACE)
     *       .onUnmappableCharacter(CodingErrorAction.REPLACE)
     *       .decode(bb); &lt;/pre&gt;
     *
     * except that it is potentially more efficient because it can cache
     * decoders between successive invocations.
     *
     * &lt;p&gt; This method always replaces malformed-input and unmappable-character
     * sequences with this charset's default replacement byte array.  In order
     * to detect such sequences, use the {@link
     * CharsetDecoder#decode(java.nio.ByteBuffer)} method directly.  &lt;/p&gt;
     *
     * @param  bb  The byte buffer to be decoded
     *
     * @return  A char buffer containing the decoded characters
     */
    public final CharBuffer decode(ByteBuffer bb) {
        try {
<span class="fc" id="L804">            return ThreadLocalCoders.decoderFor(this)</span>
<span class="fc" id="L805">                .onMalformedInput(CodingErrorAction.REPLACE)</span>
<span class="fc" id="L806">                .onUnmappableCharacter(CodingErrorAction.REPLACE)</span>
<span class="fc" id="L807">                .decode(bb);</span>
<span class="nc" id="L808">        } catch (CharacterCodingException x) {</span>
<span class="nc" id="L809">            throw new Error(x);         // Can't happen</span>
        }
    }

    /**
     * Convenience method that encodes Unicode characters into bytes in this
     * charset.
     *
     * &lt;p&gt; An invocation of this method upon a charset &lt;tt&gt;cs&lt;/tt&gt; returns the
     * same result as the expression
     *
     * &lt;pre&gt;
     *     cs.newEncoder()
     *       .onMalformedInput(CodingErrorAction.REPLACE)
     *       .onUnmappableCharacter(CodingErrorAction.REPLACE)
     *       .encode(bb); &lt;/pre&gt;
     *
     * except that it is potentially more efficient because it can cache
     * encoders between successive invocations.
     *
     * &lt;p&gt; This method always replaces malformed-input and unmappable-character
     * sequences with this charset's default replacement string.  In order to
     * detect such sequences, use the {@link
     * CharsetEncoder#encode(java.nio.CharBuffer)} method directly.  &lt;/p&gt;
     *
     * @param  cb  The char buffer to be encoded
     *
     * @return  A byte buffer containing the encoded characters
     */
    public final ByteBuffer encode(CharBuffer cb) {
        try {
<span class="fc" id="L840">            return ThreadLocalCoders.encoderFor(this)</span>
<span class="fc" id="L841">                .onMalformedInput(CodingErrorAction.REPLACE)</span>
<span class="fc" id="L842">                .onUnmappableCharacter(CodingErrorAction.REPLACE)</span>
<span class="fc" id="L843">                .encode(cb);</span>
<span class="nc" id="L844">        } catch (CharacterCodingException x) {</span>
<span class="nc" id="L845">            throw new Error(x);         // Can't happen</span>
        }
    }

    /**
     * Convenience method that encodes a string into bytes in this charset.
     *
     * &lt;p&gt; An invocation of this method upon a charset &lt;tt&gt;cs&lt;/tt&gt; returns the
     * same result as the expression
     *
     * &lt;pre&gt;
     *     cs.encode(CharBuffer.wrap(s)); &lt;/pre&gt;
     *
     * @param  str  The string to be encoded
     *
     * @return  A byte buffer containing the encoded characters
     */
    public final ByteBuffer encode(String str) {
<span class="fc" id="L863">        return encode(CharBuffer.wrap(str));</span>
    }

    /**
     * Compares this charset to another.
     *
     * &lt;p&gt; Charsets are ordered by their canonical names, without regard to
     * case. &lt;/p&gt;
     *
     * @param  that
     *         The charset to which this charset is to be compared
     *
     * @return A negative integer, zero, or a positive integer as this charset
     *         is less than, equal to, or greater than the specified charset
     */
    public final int compareTo(Charset that) {
<span class="nc" id="L879">        return (name().compareToIgnoreCase(that.name()));</span>
    }

    /**
     * Computes a hashcode for this charset.
     *
     * @return  An integer hashcode
     */
    public final int hashCode() {
<span class="nc" id="L888">        return name().hashCode();</span>
    }

    /**
     * Tells whether or not this object is equal to another.
     *
     * &lt;p&gt; Two charsets are equal if, and only if, they have the same canonical
     * names.  A charset is never equal to any other type of object.  &lt;/p&gt;
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, this charset is equal to the
     *          given object
     */
    public final boolean equals(Object ob) {
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">        if (!(ob instanceof Charset))</span>
<span class="nc" id="L902">            return false;</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">        if (this == ob)</span>
<span class="fc" id="L904">            return true;</span>
<span class="fc" id="L905">        return name.equals(((Charset)ob).name());</span>
    }

    /**
     * Returns a string describing this charset.
     *
     * @return  A string describing this charset
     */
    public final String toString() {
<span class="fc" id="L914">        return name();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>