<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Pattern.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.regex</a> &gt; <span class="el_source">Pattern.java</span></div><h1>Pattern.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util.regex;

import java.text.Normalizer;
import java.util.Locale;
import java.util.Iterator;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;


/**
 * A compiled representation of a regular expression.
 *
 * &lt;p&gt; A regular expression, specified as a string, must first be compiled into
 * an instance of this class.  The resulting pattern can then be used to create
 * a {@link Matcher} object that can match arbitrary {@linkplain
 * java.lang.CharSequence character sequences} against the regular
 * expression.  All of the state involved in performing a match resides in the
 * matcher, so many matchers can share the same pattern.
 *
 * &lt;p&gt; A typical invocation sequence is thus
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * Pattern p = Pattern.{@link #compile compile}(&quot;a*b&quot;);
 * Matcher m = p.{@link #matcher matcher}(&quot;aaaaab&quot;);
 * boolean b = m.{@link Matcher#matches matches}();&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; A {@link #matches matches} method is defined by this class as a
 * convenience for when a regular expression is used just once.  This method
 * compiles an expression and matches an input sequence against it in a single
 * invocation.  The statement
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * boolean b = Pattern.matches(&quot;a*b&quot;, &quot;aaaaab&quot;);&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * is equivalent to the three statements above, though for repeated matches it
 * is less efficient since it does not allow the compiled pattern to be reused.
 *
 * &lt;p&gt; Instances of this class are immutable and are safe for use by multiple
 * concurrent threads.  Instances of the {@link Matcher} class are not safe for
 * such use.
 *
 *
 * &lt;h3&gt;&lt;a name=&quot;sum&quot;&gt;Summary of regular-expression constructs&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;table border=&quot;0&quot; cellpadding=&quot;1&quot; cellspacing=&quot;0&quot;
 *  summary=&quot;Regular expression constructs, and what they match&quot;&gt;
 *
 * &lt;tr align=&quot;left&quot;&gt;
 * &lt;th align=&quot;left&quot; id=&quot;construct&quot;&gt;Construct&lt;/th&gt;
 * &lt;th align=&quot;left&quot; id=&quot;matches&quot;&gt;Matches&lt;/th&gt;
 * &lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;characters&quot;&gt;Characters&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;i&gt;x&lt;/i&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The character &lt;i&gt;x&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\\&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The backslash character&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\0&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The character with octal value &lt;tt&gt;0&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;
 *         (0&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\0&lt;/tt&gt;&lt;i&gt;nn&lt;/i&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The character with octal value &lt;tt&gt;0&lt;/tt&gt;&lt;i&gt;nn&lt;/i&gt;
 *         (0&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\0&lt;/tt&gt;&lt;i&gt;mnn&lt;/i&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The character with octal value &lt;tt&gt;0&lt;/tt&gt;&lt;i&gt;mnn&lt;/i&gt;
 *         (0&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;&lt;i&gt;m&lt;/i&gt;&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;3,
 *         0&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;&lt;tt&gt;&amp;lt;=&lt;/tt&gt;&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\x&lt;/tt&gt;&lt;i&gt;hh&lt;/i&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The character with hexadecimal&amp;nbsp;value&amp;nbsp;&lt;tt&gt;0x&lt;/tt&gt;&lt;i&gt;hh&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;&amp;#92;u&lt;/tt&gt;&lt;i&gt;hhhh&lt;/i&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The character with hexadecimal&amp;nbsp;value&amp;nbsp;&lt;tt&gt;0x&lt;/tt&gt;&lt;i&gt;hhhh&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;&amp;#92;x&lt;/tt&gt;&lt;i&gt;{h...h}&lt;/i&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The character with hexadecimal&amp;nbsp;value&amp;nbsp;&lt;tt&gt;0x&lt;/tt&gt;&lt;i&gt;h...h&lt;/i&gt;
 *         ({@link java.lang.Character#MIN_CODE_POINT Character.MIN_CODE_POINT}
 *         &amp;nbsp;&amp;lt;=&amp;nbsp;&lt;tt&gt;0x&lt;/tt&gt;&lt;i&gt;h...h&lt;/i&gt;&amp;nbsp;&amp;lt;=&amp;nbsp;
 *          {@link java.lang.Character#MAX_CODE_POINT Character.MAX_CODE_POINT})&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;matches&quot;&gt;&lt;tt&gt;\t&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The tab character (&lt;tt&gt;'&amp;#92;u0009'&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\n&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The newline (line feed) character (&lt;tt&gt;'&amp;#92;u000A'&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\r&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The carriage-return character (&lt;tt&gt;'&amp;#92;u000D'&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\f&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The form-feed character (&lt;tt&gt;'&amp;#92;u000C'&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\a&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The alert (bell) character (&lt;tt&gt;'&amp;#92;u0007'&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\e&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The escape character (&lt;tt&gt;'&amp;#92;u001B'&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct characters&quot;&gt;&lt;tt&gt;\c&lt;/tt&gt;&lt;i&gt;x&lt;/i&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The control character corresponding to &lt;i&gt;x&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;classes&quot;&gt;Character classes&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;{@code [abc]}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;{@code a}, {@code b}, or {@code c} (simple class)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;{@code [^abc]}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;Any character except {@code a}, {@code b}, or {@code c} (negation)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;{@code [a-zA-Z]}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;{@code a} through {@code z}
 *         or {@code A} through {@code Z}, inclusive (range)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;{@code [a-d[m-p]]}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;{@code a} through {@code d},
 *      or {@code m} through {@code p}: {@code [a-dm-p]} (union)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;{@code [a-z&amp;&amp;[def]]}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;{@code d}, {@code e}, or {@code f} (intersection)&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;{@code [a-z&amp;&amp;[^bc]]}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;{@code a} through {@code z},
 *         except for {@code b} and {@code c}: {@code [ad-z]} (subtraction)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct classes&quot;&gt;{@code [a-z&amp;&amp;[^m-p]]}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;{@code a} through {@code z},
 *          and not {@code m} through {@code p}: {@code [a-lq-z]}(subtraction)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;predef&quot;&gt;Predefined character classes&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;.&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;Any character (may or may not match &lt;a href=&quot;#lt&quot;&gt;line terminators&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\d&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A digit: &lt;tt&gt;[0-9]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\D&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A non-digit: &lt;tt&gt;[^0-9]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\h&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A horizontal whitespace character:
 *     &lt;tt&gt;[ \t\xA0&amp;#92;u1680&amp;#92;u180e&amp;#92;u2000-&amp;#92;u200a&amp;#92;u202f&amp;#92;u205f&amp;#92;u3000]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\H&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A non-horizontal whitespace character: &lt;tt&gt;[^\h]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\s&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A whitespace character: &lt;tt&gt;[ \t\n\x0B\f\r]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\S&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A non-whitespace character: &lt;tt&gt;[^\s]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\v&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A vertical whitespace character: &lt;tt&gt;[\n\x0B\f\r\x85&amp;#92;u2028&amp;#92;u2029]&lt;/tt&gt;
 *     &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\V&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A non-vertical whitespace character: &lt;tt&gt;[^\v]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\w&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A word character: &lt;tt&gt;[a-zA-Z_0-9]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct predef&quot;&gt;&lt;tt&gt;\W&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A non-word character: &lt;tt&gt;[^\w]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;posix&quot;&gt;&lt;b&gt;POSIX character classes (US-ASCII only)&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{Lower}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A lower-case alphabetic character: {@code [a-z]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{Upper}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;An upper-case alphabetic character:{@code [A-Z]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{ASCII}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;All ASCII:{@code [\x00-\x7F]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{Alpha}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;An alphabetic character:{@code [\p{Lower}\p{Upper}]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{Digit}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A decimal digit: {@code [0-9]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{Alnum}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;An alphanumeric character:{@code [\p{Alpha}\p{Digit}]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{Punct}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;Punctuation: One of {@code !&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~}&lt;/td&gt;&lt;/tr&gt;
 *     &lt;!-- {@code [\!&quot;#\$%&amp;'\(\)\*\+,\-\./:;\&lt;=\&gt;\?@\[\\\]\^_`\{\|\}~]}
 *          {@code [\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]} --&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{Graph}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A visible character: {@code [\p{Alnum}\p{Punct}]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{Print}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A printable character: {@code [\p{Graph}\x20]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{Blank}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A space or a tab: {@code [ \t]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{Cntrl}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A control character: {@code [\x00-\x1F\x7F]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{XDigit}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A hexadecimal digit: {@code [0-9a-fA-F]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct posix&quot;&gt;{@code \p{Space}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A whitespace character: {@code [ \t\n\x0B\f\r]}&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot;&gt;java.lang.Character classes (simple &lt;a href=&quot;#jcc&quot;&gt;java character type&lt;/a&gt;)&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;\p{javaLowerCase}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Equivalent to java.lang.Character.isLowerCase()&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;\p{javaUpperCase}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Equivalent to java.lang.Character.isUpperCase()&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;\p{javaWhitespace}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Equivalent to java.lang.Character.isWhitespace()&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;\p{javaMirrored}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;Equivalent to java.lang.Character.isMirrored()&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;unicode&quot;&gt;Classes for Unicode scripts, blocks, categories and binary properties&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;{@code \p{IsLatin}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A Latin&amp;nbsp;script character (&lt;a href=&quot;#usc&quot;&gt;script&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;{@code \p{InGreek}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A character in the Greek&amp;nbsp;block (&lt;a href=&quot;#ubc&quot;&gt;block&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;{@code \p{Lu}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;An uppercase letter (&lt;a href=&quot;#ucc&quot;&gt;category&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;{@code \p{IsAlphabetic}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;An alphabetic character (&lt;a href=&quot;#ubpc&quot;&gt;binary property&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;{@code \p{Sc}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A currency symbol&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;{@code \P{InGreek}}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;Any character except one in the Greek block (negation)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct unicode&quot;&gt;{@code [\p{L}&amp;&amp;[^\p{Lu}]]}&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;Any letter except an uppercase letter (subtraction)&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;bounds&quot;&gt;Boundary matchers&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;^&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The beginning of a line&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;$&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The end of a line&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\b&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A word boundary&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\B&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;A non-word boundary&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\A&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The beginning of the input&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\G&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The end of the previous match&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\Z&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The end of the input but for the final
 *         &lt;a href=&quot;#lt&quot;&gt;terminator&lt;/a&gt;, if&amp;nbsp;any&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct bounds&quot;&gt;&lt;tt&gt;\z&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;The end of the input&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;lineending&quot;&gt;Linebreak matcher&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct lineending&quot;&gt;&lt;tt&gt;\R&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;Any Unicode linebreak sequence, is equivalent to
 *     &lt;tt&gt;&amp;#92;u000D&amp;#92;u000A|[&amp;#92;u000A&amp;#92;u000B&amp;#92;u000C&amp;#92;u000D&amp;#92;u0085&amp;#92;u2028&amp;#92;u2029]
 *     &lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;greedy&quot;&gt;Greedy quantifiers&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;?&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;*&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;+&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct greedy&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,&lt;/tt&gt;&lt;i&gt;m&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;reluc&quot;&gt;Reluctant quantifiers&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;??&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;*?&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;+?&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;}?&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,}?&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct reluc&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,&lt;/tt&gt;&lt;i&gt;m&lt;/i&gt;&lt;tt&gt;}?&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;poss&quot;&gt;Possessive quantifiers&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;?+&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;*+&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;++&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;}+&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,}+&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct poss&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;,&lt;/tt&gt;&lt;i&gt;m&lt;/i&gt;&lt;tt&gt;}+&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;logical&quot;&gt;Logical operators&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct logical&quot;&gt;&lt;i&gt;XY&lt;/i&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt; followed by &lt;i&gt;Y&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct logical&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;|&lt;/tt&gt;&lt;i&gt;Y&lt;/i&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;Either &lt;i&gt;X&lt;/i&gt; or &lt;i&gt;Y&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct logical&quot;&gt;&lt;tt&gt;(&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;X, as a &lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;backref&quot;&gt;Back references&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;bottom&quot; headers=&quot;construct backref&quot;&gt;&lt;tt&gt;\&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;/td&gt;
 *     &lt;td valign=&quot;bottom&quot; headers=&quot;matches&quot;&gt;Whatever the &lt;i&gt;n&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt;
 *     &lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt; matched&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;bottom&quot; headers=&quot;construct backref&quot;&gt;&lt;tt&gt;\&lt;/tt&gt;&lt;i&gt;k&lt;/i&gt;&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/td&gt;
 *     &lt;td valign=&quot;bottom&quot; headers=&quot;matches&quot;&gt;Whatever the
 *     &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt; &quot;name&quot; matched&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;quot&quot;&gt;Quotation&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct quot&quot;&gt;&lt;tt&gt;\&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;Nothing, but quotes the following character&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct quot&quot;&gt;&lt;tt&gt;\Q&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;Nothing, but quotes all characters until &lt;tt&gt;\E&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct quot&quot;&gt;&lt;tt&gt;\E&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;Nothing, but ends quoting started by &lt;tt&gt;\Q&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 *     &lt;!-- Metachars: !$()*+.&lt;&gt;?[\]^{|} --&gt;
 *
 * &lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr align=&quot;left&quot;&gt;&lt;th colspan=&quot;2&quot; id=&quot;special&quot;&gt;Special constructs (named-capturing and non-capturing)&lt;/th&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?&amp;lt;&lt;a href=&quot;#groupname&quot;&gt;name&lt;/a&gt;&amp;gt;&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a named-capturing group&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?:&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a non-capturing group&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?idmsuxU-idmsuxU)&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;Nothing, but turns match flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt;
 * &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt; &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt;
 * &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a&gt; &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; &lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt;
 * on - off&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?idmsux-idmsux:&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a &lt;a href=&quot;#cg&quot;&gt;non-capturing group&lt;/a&gt; with the
 *         given flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt; &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt;
 * &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt; &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a &gt;
 * &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; on - off&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?=&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookahead&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?!&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookahead&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?&amp;lt;=&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookbehind&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?&amp;lt;!&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookbehind&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td valign=&quot;top&quot; headers=&quot;construct special&quot;&gt;&lt;tt&gt;(?&amp;gt;&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;matches&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as an independent, non-capturing group&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;/table&gt;
 *
 * &lt;hr&gt;
 *
 *
 * &lt;h3&gt;&lt;a name=&quot;bs&quot;&gt;Backslashes, escapes, and quoting&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;p&gt; The backslash character (&lt;tt&gt;'\'&lt;/tt&gt;) serves to introduce escaped
 * constructs, as defined in the table above, as well as to quote characters
 * that otherwise would be interpreted as unescaped constructs.  Thus the
 * expression &lt;tt&gt;\\&lt;/tt&gt; matches a single backslash and &lt;tt&gt;\{&lt;/tt&gt; matches a
 * left brace.
 *
 * &lt;p&gt; It is an error to use a backslash prior to any alphabetic character that
 * does not denote an escaped construct; these are reserved for future
 * extensions to the regular-expression language.  A backslash may be used
 * prior to a non-alphabetic character regardless of whether that character is
 * part of an unescaped construct.
 *
 * &lt;p&gt; Backslashes within string literals in Java source code are interpreted
 * as required by
 * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;
 * as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6)
 * It is therefore necessary to double backslashes in string
 * literals that represent regular expressions to protect them from
 * interpretation by the Java bytecode compiler.  The string literal
 * &lt;tt&gt;&quot;&amp;#92;b&quot;&lt;/tt&gt;, for example, matches a single backspace character when
 * interpreted as a regular expression, while &lt;tt&gt;&quot;&amp;#92;&amp;#92;b&quot;&lt;/tt&gt; matches a
 * word boundary.  The string literal &lt;tt&gt;&quot;&amp;#92;(hello&amp;#92;)&quot;&lt;/tt&gt; is illegal
 * and leads to a compile-time error; in order to match the string
 * &lt;tt&gt;(hello)&lt;/tt&gt; the string literal &lt;tt&gt;&quot;&amp;#92;&amp;#92;(hello&amp;#92;&amp;#92;)&quot;&lt;/tt&gt;
 * must be used.
 *
 * &lt;h3&gt;&lt;a name=&quot;cc&quot;&gt;Character Classes&lt;/a&gt;&lt;/h3&gt;
 *
 *    &lt;p&gt; Character classes may appear within other character classes, and
 *    may be composed by the union operator (implicit) and the intersection
 *    operator (&lt;tt&gt;&amp;amp;&amp;amp;&lt;/tt&gt;).
 *    The union operator denotes a class that contains every character that is
 *    in at least one of its operand classes.  The intersection operator
 *    denotes a class that contains every character that is in both of its
 *    operand classes.
 *
 *    &lt;p&gt; The precedence of character-class operators is as follows, from
 *    highest to lowest:
 *
 *    &lt;blockquote&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;1&quot; cellspacing=&quot;0&quot;
 *                 summary=&quot;Precedence of character class operators.&quot;&gt;
 *      &lt;tr&gt;&lt;th&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 *        &lt;td&gt;Literal escape&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
 *        &lt;td&gt;&lt;tt&gt;\x&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;th&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 *        &lt;td&gt;Grouping&lt;/td&gt;
 *        &lt;td&gt;&lt;tt&gt;[...]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;th&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 *        &lt;td&gt;Range&lt;/td&gt;
 *        &lt;td&gt;&lt;tt&gt;a-z&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 *      &lt;tr&gt;&lt;th&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 *        &lt;td&gt;Union&lt;/td&gt;
 *        &lt;td&gt;&lt;tt&gt;[a-e][i-u]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 *      &lt;tr&gt;&lt;th&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 *        &lt;td&gt;Intersection&lt;/td&gt;
 *        &lt;td&gt;{@code [a-z&amp;&amp;[aeiou]]}&lt;/td&gt;&lt;/tr&gt;
 *    &lt;/table&gt;&lt;/blockquote&gt;
 *
 *    &lt;p&gt; Note that a different set of metacharacters are in effect inside
 *    a character class than outside a character class. For instance, the
 *    regular expression &lt;tt&gt;.&lt;/tt&gt; loses its special meaning inside a
 *    character class, while the expression &lt;tt&gt;-&lt;/tt&gt; becomes a range
 *    forming metacharacter.
 *
 * &lt;h3&gt;&lt;a name=&quot;lt&quot;&gt;Line terminators&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;p&gt; A &lt;i&gt;line terminator&lt;/i&gt; is a one- or two-character sequence that marks
 * the end of a line of the input character sequence.  The following are
 * recognized as line terminators:
 *
 * &lt;ul&gt;
 *
 *   &lt;li&gt; A newline (line feed) character&amp;nbsp;(&lt;tt&gt;'\n'&lt;/tt&gt;),
 *
 *   &lt;li&gt; A carriage-return character followed immediately by a newline
 *   character&amp;nbsp;(&lt;tt&gt;&quot;\r\n&quot;&lt;/tt&gt;),
 *
 *   &lt;li&gt; A standalone carriage-return character&amp;nbsp;(&lt;tt&gt;'\r'&lt;/tt&gt;),
 *
 *   &lt;li&gt; A next-line character&amp;nbsp;(&lt;tt&gt;'&amp;#92;u0085'&lt;/tt&gt;),
 *
 *   &lt;li&gt; A line-separator character&amp;nbsp;(&lt;tt&gt;'&amp;#92;u2028'&lt;/tt&gt;), or
 *
 *   &lt;li&gt; A paragraph-separator character&amp;nbsp;(&lt;tt&gt;'&amp;#92;u2029&lt;/tt&gt;).
 *
 * &lt;/ul&gt;
 * &lt;p&gt;If {@link #UNIX_LINES} mode is activated, then the only line terminators
 * recognized are newline characters.
 *
 * &lt;p&gt; The regular expression &lt;tt&gt;.&lt;/tt&gt; matches any character except a line
 * terminator unless the {@link #DOTALL} flag is specified.
 *
 * &lt;p&gt; By default, the regular expressions &lt;tt&gt;^&lt;/tt&gt; and &lt;tt&gt;$&lt;/tt&gt; ignore
 * line terminators and only match at the beginning and the end, respectively,
 * of the entire input sequence. If {@link #MULTILINE} mode is activated then
 * &lt;tt&gt;^&lt;/tt&gt; matches at the beginning of input and after any line terminator
 * except at the end of input. When in {@link #MULTILINE} mode &lt;tt&gt;$&lt;/tt&gt;
 * matches just before a line terminator or the end of the input sequence.
 *
 * &lt;h3&gt;&lt;a name=&quot;cg&quot;&gt;Groups and capturing&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;h4&gt;&lt;a name=&quot;gnumber&quot;&gt;Group number&lt;/a&gt;&lt;/h4&gt;
 * &lt;p&gt; Capturing groups are numbered by counting their opening parentheses from
 * left to right.  In the expression &lt;tt&gt;((A)(B(C)))&lt;/tt&gt;, for example, there
 * are four such groups: &lt;/p&gt;
 *
 * &lt;blockquote&gt;&lt;table cellpadding=1 cellspacing=0 summary=&quot;Capturing group numberings&quot;&gt;
 * &lt;tr&gt;&lt;th&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 *     &lt;td&gt;&lt;tt&gt;((A)(B(C)))&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 *     &lt;td&gt;&lt;tt&gt;(A)&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 *     &lt;td&gt;&lt;tt&gt;(B(C))&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 *     &lt;td&gt;&lt;tt&gt;(C)&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; Group zero always stands for the entire expression.
 *
 * &lt;p&gt; Capturing groups are so named because, during a match, each subsequence
 * of the input sequence that matches such a group is saved.  The captured
 * subsequence may be used later in the expression, via a back reference, and
 * may also be retrieved from the matcher once the match operation is complete.
 *
 * &lt;h4&gt;&lt;a name=&quot;groupname&quot;&gt;Group name&lt;/a&gt;&lt;/h4&gt;
 * &lt;p&gt;A capturing group can also be assigned a &quot;name&quot;, a &lt;tt&gt;named-capturing group&lt;/tt&gt;,
 * and then be back-referenced later by the &quot;name&quot;. Group names are composed of
 * the following characters. The first character must be a &lt;tt&gt;letter&lt;/tt&gt;.
 *
 * &lt;ul&gt;
 *   &lt;li&gt; The uppercase letters &lt;tt&gt;'A'&lt;/tt&gt; through &lt;tt&gt;'Z'&lt;/tt&gt;
 *        (&lt;tt&gt;'&amp;#92;u0041'&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;'&amp;#92;u005a'&lt;/tt&gt;),
 *   &lt;li&gt; The lowercase letters &lt;tt&gt;'a'&lt;/tt&gt; through &lt;tt&gt;'z'&lt;/tt&gt;
 *        (&lt;tt&gt;'&amp;#92;u0061'&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;'&amp;#92;u007a'&lt;/tt&gt;),
 *   &lt;li&gt; The digits &lt;tt&gt;'0'&lt;/tt&gt; through &lt;tt&gt;'9'&lt;/tt&gt;
 *        (&lt;tt&gt;'&amp;#92;u0030'&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;'&amp;#92;u0039'&lt;/tt&gt;),
 * &lt;/ul&gt;
 *
 * &lt;p&gt; A &lt;tt&gt;named-capturing group&lt;/tt&gt; is still numbered as described in
 * &lt;a href=&quot;#gnumber&quot;&gt;Group number&lt;/a&gt;.
 *
 * &lt;p&gt; The captured input associated with a group is always the subsequence
 * that the group most recently matched.  If a group is evaluated a second time
 * because of quantification then its previously-captured value, if any, will
 * be retained if the second evaluation fails.  Matching the string
 * &lt;tt&gt;&quot;aba&quot;&lt;/tt&gt; against the expression &lt;tt&gt;(a(b)?)+&lt;/tt&gt;, for example, leaves
 * group two set to &lt;tt&gt;&quot;b&quot;&lt;/tt&gt;.  All captured input is discarded at the
 * beginning of each match.
 *
 * &lt;p&gt; Groups beginning with &lt;tt&gt;(?&lt;/tt&gt; are either pure, &lt;i&gt;non-capturing&lt;/i&gt; groups
 * that do not capture text and do not count towards the group total, or
 * &lt;i&gt;named-capturing&lt;/i&gt; group.
 *
 * &lt;h3&gt; Unicode support &lt;/h3&gt;
 *
 * &lt;p&gt; This class is in conformance with Level 1 of &lt;a
 * href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical
 * Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;, plus RL2.1
 * Canonical Equivalents.
 * &lt;p&gt;
 * &lt;b&gt;Unicode escape sequences&lt;/b&gt; such as &lt;tt&gt;&amp;#92;u2014&lt;/tt&gt; in Java source code
 * are processed as described in section 3.3 of
 * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 * Such escape sequences are also implemented directly by the regular-expression
 * parser so that Unicode escapes can be used in expressions that are read from
 * files or from the keyboard.  Thus the strings &lt;tt&gt;&quot;&amp;#92;u2014&quot;&lt;/tt&gt; and
 * &lt;tt&gt;&quot;\\u2014&quot;&lt;/tt&gt;, while not equal, compile into the same pattern, which
 * matches the character with hexadecimal value &lt;tt&gt;0x2014&lt;/tt&gt;.
 * &lt;p&gt;
 * A Unicode character can also be represented in a regular-expression by
 * using its &lt;b&gt;Hex notation&lt;/b&gt;(hexadecimal code point value) directly as described in construct
 * &lt;tt&gt;&amp;#92;x{...}&lt;/tt&gt;, for example a supplementary character U+2011F
 * can be specified as &lt;tt&gt;&amp;#92;x{2011F}&lt;/tt&gt;, instead of two consecutive
 * Unicode escape sequences of the surrogate pair
 * &lt;tt&gt;&amp;#92;uD840&lt;/tt&gt;&lt;tt&gt;&amp;#92;uDD1F&lt;/tt&gt;.
 * &lt;p&gt;
 * Unicode scripts, blocks, categories and binary properties are written with
 * the &lt;tt&gt;\p&lt;/tt&gt; and &lt;tt&gt;\P&lt;/tt&gt; constructs as in Perl.
 * &lt;tt&gt;\p{&lt;/tt&gt;&lt;i&gt;prop&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt; matches if
 * the input has the property &lt;i&gt;prop&lt;/i&gt;, while &lt;tt&gt;\P{&lt;/tt&gt;&lt;i&gt;prop&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt;
 * does not match if the input has that property.
 * &lt;p&gt;
 * Scripts, blocks, categories and binary properties can be used both inside
 * and outside of a character class.
 *
 * &lt;p&gt;
 * &lt;b&gt;&lt;a name=&quot;usc&quot;&gt;Scripts&lt;/a&gt;&lt;/b&gt; are specified either with the prefix {@code Is}, as in
 * {@code IsHiragana}, or by using  the {@code script} keyword (or its short
 * form {@code sc})as in {@code script=Hiragana} or {@code sc=Hiragana}.
 * &lt;p&gt;
 * The script names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid script names
 * accepted and defined by
 * {@link java.lang.Character.UnicodeScript#forName(String) UnicodeScript.forName}.
 *
 * &lt;p&gt;
 * &lt;b&gt;&lt;a name=&quot;ubc&quot;&gt;Blocks&lt;/a&gt;&lt;/b&gt; are specified with the prefix {@code In}, as in
 * {@code InMongolian}, or by using the keyword {@code block} (or its short
 * form {@code blk}) as in {@code block=Mongolian} or {@code blk=Mongolian}.
 * &lt;p&gt;
 * The block names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid block names
 * accepted and defined by
 * {@link java.lang.Character.UnicodeBlock#forName(String) UnicodeBlock.forName}.
 * &lt;p&gt;
 *
 * &lt;b&gt;&lt;a name=&quot;ucc&quot;&gt;Categories&lt;/a&gt;&lt;/b&gt; may be specified with the optional prefix {@code Is}:
 * Both {@code \p{L}} and {@code \p{IsL}} denote the category of Unicode
 * letters. Same as scripts and blocks, categories can also be specified
 * by using the keyword {@code general_category} (or its short form
 * {@code gc}) as in {@code general_category=Lu} or {@code gc=Lu}.
 * &lt;p&gt;
 * The supported categories are those of
 * &lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;
 * &lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; in the version specified by the
 * {@link java.lang.Character Character} class. The category names are those
 * defined in the Standard, both normative and informative.
 * &lt;p&gt;
 *
 * &lt;b&gt;&lt;a name=&quot;ubpc&quot;&gt;Binary properties&lt;/a&gt;&lt;/b&gt; are specified with the prefix {@code Is}, as in
 * {@code IsAlphabetic}. The supported binary properties by &lt;code&gt;Pattern&lt;/code&gt;
 * are
 * &lt;ul&gt;
 *   &lt;li&gt; Alphabetic
 *   &lt;li&gt; Ideographic
 *   &lt;li&gt; Letter
 *   &lt;li&gt; Lowercase
 *   &lt;li&gt; Uppercase
 *   &lt;li&gt; Titlecase
 *   &lt;li&gt; Punctuation
 *   &lt;Li&gt; Control
 *   &lt;li&gt; White_Space
 *   &lt;li&gt; Digit
 *   &lt;li&gt; Hex_Digit
 *   &lt;li&gt; Join_Control
 *   &lt;li&gt; Noncharacter_Code_Point
 *   &lt;li&gt; Assigned
 * &lt;/ul&gt;
 * &lt;p&gt;
 * The following &lt;b&gt;Predefined Character classes&lt;/b&gt; and &lt;b&gt;POSIX character classes&lt;/b&gt;
 * are in conformance with the recommendation of &lt;i&gt;Annex C: Compatibility Properties&lt;/i&gt;
 * of &lt;a href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Regular Expression
 * &lt;/i&gt;&lt;/a&gt;, when {@link #UNICODE_CHARACTER_CLASS} flag is specified.
 *
 * &lt;table border=&quot;0&quot; cellpadding=&quot;1&quot; cellspacing=&quot;0&quot;
 *  summary=&quot;predefined and posix character classes in Unicode mode&quot;&gt;
 * &lt;tr align=&quot;left&quot;&gt;
 * &lt;th align=&quot;left&quot; id=&quot;predef_classes&quot;&gt;Classes&lt;/th&gt;
 * &lt;th align=&quot;left&quot; id=&quot;predef_matches&quot;&gt;Matches&lt;/th&gt;
 *&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Lower}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A lowercase character:&lt;tt&gt;\p{IsLowercase}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Upper}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;An uppercase character:&lt;tt&gt;\p{IsUppercase}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{ASCII}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;All ASCII:&lt;tt&gt;[\x00-\x7F]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Alpha}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;An alphabetic character:&lt;tt&gt;\p{IsAlphabetic}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Digit}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A decimal digit character:&lt;tt&gt;p{IsDigit}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Alnum}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;An alphanumeric character:&lt;tt&gt;[\p{IsAlphabetic}\p{IsDigit}]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Punct}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A punctuation character:&lt;tt&gt;p{IsPunctuation}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Graph}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A visible character: &lt;tt&gt;[^\p{IsWhite_Space}\p{gc=Cc}\p{gc=Cs}\p{gc=Cn}]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Print}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A printable character: {@code [\p{Graph}\p{Blank}&amp;&amp;[^\p{Cntrl}]]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Blank}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A space or a tab: {@code [\p{IsWhite_Space}&amp;&amp;[^\p{gc=Zl}\p{gc=Zp}\x0a\x0b\x0c\x0d\x85]]}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Cntrl}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A control character: &lt;tt&gt;\p{gc=Cc}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{XDigit}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A hexadecimal digit: &lt;tt&gt;[\p{gc=Nd}\p{IsHex_Digit}]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\p{Space}&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A whitespace character:&lt;tt&gt;\p{IsWhite_Space}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\d&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A digit: &lt;tt&gt;\p{IsDigit}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\D&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A non-digit: &lt;tt&gt;[^\d]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\s&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A whitespace character: &lt;tt&gt;\p{IsWhite_Space}&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\S&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A non-whitespace character: &lt;tt&gt;[^\s]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\w&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A word character: &lt;tt&gt;[\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}\p{IsJoin_Control}]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;tt&gt;\W&lt;/tt&gt;&lt;/td&gt;
 *     &lt;td&gt;A non-word character: &lt;tt&gt;[^\w]&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * &lt;a name=&quot;jcc&quot;&gt;
 * Categories that behave like the java.lang.Character
 * boolean is&lt;i&gt;methodname&lt;/i&gt; methods (except for the deprecated ones) are
 * available through the same &lt;tt&gt;\p{&lt;/tt&gt;&lt;i&gt;prop&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt; syntax where
 * the specified property has the name &lt;tt&gt;java&lt;i&gt;methodname&lt;/i&gt;&lt;/tt&gt;&lt;/a&gt;.
 *
 * &lt;h3&gt; Comparison to Perl 5 &lt;/h3&gt;
 *
 * &lt;p&gt;The &lt;code&gt;Pattern&lt;/code&gt; engine performs traditional NFA-based matching
 * with ordered alternation as occurs in Perl 5.
 *
 * &lt;p&gt; Perl constructs not supported by this class: &lt;/p&gt;
 *
 * &lt;ul&gt;
 *    &lt;li&gt;&lt;p&gt; Predefined character classes (Unicode character)
 *    &lt;p&gt;&lt;tt&gt;\X&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;Match Unicode
 *    &lt;a href=&quot;http://www.unicode.org/reports/tr18/#Default_Grapheme_Clusters&quot;&gt;
 *    &lt;i&gt;extended grapheme cluster&lt;/i&gt;&lt;/a&gt;
 *    &lt;/p&gt;&lt;/li&gt;
 *
 *    &lt;li&gt;&lt;p&gt; The backreference constructs, &lt;tt&gt;\g{&lt;/tt&gt;&lt;i&gt;n&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt; for
 *    the &lt;i&gt;n&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt;&lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt; and
 *    &lt;tt&gt;\g{&lt;/tt&gt;&lt;i&gt;name&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt; for
 *    &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt;.
 *    &lt;/p&gt;&lt;/li&gt;
 *
 *    &lt;li&gt;&lt;p&gt; The named character construct, &lt;tt&gt;\N{&lt;/tt&gt;&lt;i&gt;name&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt;
 *    for a Unicode character by its name.
 *    &lt;/p&gt;&lt;/li&gt;
 *
 *    &lt;li&gt;&lt;p&gt; The conditional constructs
 *    &lt;tt&gt;(?(&lt;/tt&gt;&lt;i&gt;condition&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt; and
 *    &lt;tt&gt;(?(&lt;/tt&gt;&lt;i&gt;condition&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&lt;i&gt;X&lt;/i&gt;&lt;tt&gt;|&lt;/tt&gt;&lt;i&gt;Y&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;,
 *    &lt;/p&gt;&lt;/li&gt;
 *
 *    &lt;li&gt;&lt;p&gt; The embedded code constructs &lt;tt&gt;(?{&lt;/tt&gt;&lt;i&gt;code&lt;/i&gt;&lt;tt&gt;})&lt;/tt&gt;
 *    and &lt;tt&gt;(??{&lt;/tt&gt;&lt;i&gt;code&lt;/i&gt;&lt;tt&gt;})&lt;/tt&gt;,&lt;/p&gt;&lt;/li&gt;
 *
 *    &lt;li&gt;&lt;p&gt; The embedded comment syntax &lt;tt&gt;(?#comment)&lt;/tt&gt;, and &lt;/p&gt;&lt;/li&gt;
 *
 *    &lt;li&gt;&lt;p&gt; The preprocessing operations &lt;tt&gt;\l&lt;/tt&gt; &lt;tt&gt;&amp;#92;u&lt;/tt&gt;,
 *    &lt;tt&gt;\L&lt;/tt&gt;, and &lt;tt&gt;\U&lt;/tt&gt;.  &lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt; Constructs supported by this class but not by Perl: &lt;/p&gt;
 *
 * &lt;ul&gt;
 *
 *    &lt;li&gt;&lt;p&gt; Character-class union and intersection as described
 *    &lt;a href=&quot;#cc&quot;&gt;above&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt; Notable differences from Perl: &lt;/p&gt;
 *
 * &lt;ul&gt;
 *
 *    &lt;li&gt;&lt;p&gt; In Perl, &lt;tt&gt;\1&lt;/tt&gt; through &lt;tt&gt;\9&lt;/tt&gt; are always interpreted
 *    as back references; a backslash-escaped number greater than &lt;tt&gt;9&lt;/tt&gt; is
 *    treated as a back reference if at least that many subexpressions exist,
 *    otherwise it is interpreted, if possible, as an octal escape.  In this
 *    class octal escapes must always begin with a zero. In this class,
 *    &lt;tt&gt;\1&lt;/tt&gt; through &lt;tt&gt;\9&lt;/tt&gt; are always interpreted as back
 *    references, and a larger number is accepted as a back reference if at
 *    least that many subexpressions exist at that point in the regular
 *    expression, otherwise the parser will drop digits until the number is
 *    smaller or equal to the existing number of groups or it is one digit.
 *    &lt;/p&gt;&lt;/li&gt;
 *
 *    &lt;li&gt;&lt;p&gt; Perl uses the &lt;tt&gt;g&lt;/tt&gt; flag to request a match that resumes
 *    where the last match left off.  This functionality is provided implicitly
 *    by the {@link Matcher} class: Repeated invocations of the {@link
 *    Matcher#find find} method will resume where the last match left off,
 *    unless the matcher is reset.  &lt;/p&gt;&lt;/li&gt;
 *
 *    &lt;li&gt;&lt;p&gt; In Perl, embedded flags at the top level of an expression affect
 *    the whole expression.  In this class, embedded flags always take effect
 *    at the point at which they appear, whether they are at the top level or
 *    within a group; in the latter case, flags are restored at the end of the
 *    group just as in Perl.  &lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 *
 * &lt;p&gt; For a more precise description of the behavior of regular expression
 * constructs, please see &lt;a href=&quot;http://www.oreilly.com/catalog/regex3/&quot;&gt;
 * &lt;i&gt;Mastering Regular Expressions, 3nd Edition&lt;/i&gt;, Jeffrey E. F. Friedl,
 * O'Reilly and Associates, 2006.&lt;/a&gt;
 * &lt;/p&gt;
 *
 * @see java.lang.String#split(String, int)
 * @see java.lang.String#split(String)
 *
 * @author      Mike McCloskey
 * @author      Mark Reinhold
 * @author      JSR-51 Expert Group
 * @since       1.4
 * @spec        JSR-51
 */

<span class="fc bfc" id="L769" title="All 2 branches covered.">public final class Pattern</span>
    implements java.io.Serializable
{

    /**
     * Regular expression modifier values.  Instead of being passed as
     * arguments, they can also be passed as inline modifiers.
     * For example, the following statements have the same effect.
     * &lt;pre&gt;
     * RegExp r1 = RegExp.compile(&quot;abc&quot;, Pattern.I|Pattern.M);
     * RegExp r2 = RegExp.compile(&quot;(?im)abc&quot;, 0);
     * &lt;/pre&gt;
     *
     * The flags are duplicated so that the familiar Perl match flag
     * names are available.
     */

    /**
     * Enables Unix lines mode.
     *
     * &lt;p&gt; In this mode, only the &lt;tt&gt;'\n'&lt;/tt&gt; line terminator is recognized
     * in the behavior of &lt;tt&gt;.&lt;/tt&gt;, &lt;tt&gt;^&lt;/tt&gt;, and &lt;tt&gt;$&lt;/tt&gt;.
     *
     * &lt;p&gt; Unix lines mode can also be enabled via the embedded flag
     * expression&amp;nbsp;&lt;tt&gt;(?d)&lt;/tt&gt;.
     */
    public static final int UNIX_LINES = 0x01;

    /**
     * Enables case-insensitive matching.
     *
     * &lt;p&gt; By default, case-insensitive matching assumes that only characters
     * in the US-ASCII charset are being matched.  Unicode-aware
     * case-insensitive matching can be enabled by specifying the {@link
     * #UNICODE_CASE} flag in conjunction with this flag.
     *
     * &lt;p&gt; Case-insensitive matching can also be enabled via the embedded flag
     * expression&amp;nbsp;&lt;tt&gt;(?i)&lt;/tt&gt;.
     *
     * &lt;p&gt; Specifying this flag may impose a slight performance penalty.  &lt;/p&gt;
     */
    public static final int CASE_INSENSITIVE = 0x02;

    /**
     * Permits whitespace and comments in pattern.
     *
     * &lt;p&gt; In this mode, whitespace is ignored, and embedded comments starting
     * with &lt;tt&gt;#&lt;/tt&gt; are ignored until the end of a line.
     *
     * &lt;p&gt; Comments mode can also be enabled via the embedded flag
     * expression&amp;nbsp;&lt;tt&gt;(?x)&lt;/tt&gt;.
     */
    public static final int COMMENTS = 0x04;

    /**
     * Enables multiline mode.
     *
     * &lt;p&gt; In multiline mode the expressions &lt;tt&gt;^&lt;/tt&gt; and &lt;tt&gt;$&lt;/tt&gt; match
     * just after or just before, respectively, a line terminator or the end of
     * the input sequence.  By default these expressions only match at the
     * beginning and the end of the entire input sequence.
     *
     * &lt;p&gt; Multiline mode can also be enabled via the embedded flag
     * expression&amp;nbsp;&lt;tt&gt;(?m)&lt;/tt&gt;.  &lt;/p&gt;
     */
    public static final int MULTILINE = 0x08;

    /**
     * Enables literal parsing of the pattern.
     *
     * &lt;p&gt; When this flag is specified then the input string that specifies
     * the pattern is treated as a sequence of literal characters.
     * Metacharacters or escape sequences in the input sequence will be
     * given no special meaning.
     *
     * &lt;p&gt;The flags CASE_INSENSITIVE and UNICODE_CASE retain their impact on
     * matching when used in conjunction with this flag. The other flags
     * become superfluous.
     *
     * &lt;p&gt; There is no embedded flag character for enabling literal parsing.
     * @since 1.5
     */
    public static final int LITERAL = 0x10;

    /**
     * Enables dotall mode.
     *
     * &lt;p&gt; In dotall mode, the expression &lt;tt&gt;.&lt;/tt&gt; matches any character,
     * including a line terminator.  By default this expression does not match
     * line terminators.
     *
     * &lt;p&gt; Dotall mode can also be enabled via the embedded flag
     * expression&amp;nbsp;&lt;tt&gt;(?s)&lt;/tt&gt;.  (The &lt;tt&gt;s&lt;/tt&gt; is a mnemonic for
     * &quot;single-line&quot; mode, which is what this is called in Perl.)  &lt;/p&gt;
     */
    public static final int DOTALL = 0x20;

    /**
     * Enables Unicode-aware case folding.
     *
     * &lt;p&gt; When this flag is specified then case-insensitive matching, when
     * enabled by the {@link #CASE_INSENSITIVE} flag, is done in a manner
     * consistent with the Unicode Standard.  By default, case-insensitive
     * matching assumes that only characters in the US-ASCII charset are being
     * matched.
     *
     * &lt;p&gt; Unicode-aware case folding can also be enabled via the embedded flag
     * expression&amp;nbsp;&lt;tt&gt;(?u)&lt;/tt&gt;.
     *
     * &lt;p&gt; Specifying this flag may impose a performance penalty.  &lt;/p&gt;
     */
    public static final int UNICODE_CASE = 0x40;

    /**
     * Enables canonical equivalence.
     *
     * &lt;p&gt; When this flag is specified then two characters will be considered
     * to match if, and only if, their full canonical decompositions match.
     * The expression &lt;tt&gt;&quot;a&amp;#92;u030A&quot;&lt;/tt&gt;, for example, will match the
     * string &lt;tt&gt;&quot;&amp;#92;u00E5&quot;&lt;/tt&gt; when this flag is specified.  By default,
     * matching does not take canonical equivalence into account.
     *
     * &lt;p&gt; There is no embedded flag character for enabling canonical
     * equivalence.
     *
     * &lt;p&gt; Specifying this flag may impose a performance penalty.  &lt;/p&gt;
     */
    public static final int CANON_EQ = 0x80;

    /**
     * Enables the Unicode version of &lt;i&gt;Predefined character classes&lt;/i&gt; and
     * &lt;i&gt;POSIX character classes&lt;/i&gt;.
     *
     * &lt;p&gt; When this flag is specified then the (US-ASCII only)
     * &lt;i&gt;Predefined character classes&lt;/i&gt; and &lt;i&gt;POSIX character classes&lt;/i&gt;
     * are in conformance with
     * &lt;a href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical
     * Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;
     * &lt;i&gt;Annex C: Compatibility Properties&lt;/i&gt;.
     * &lt;p&gt;
     * The UNICODE_CHARACTER_CLASS mode can also be enabled via the embedded
     * flag expression&amp;nbsp;&lt;tt&gt;(?U)&lt;/tt&gt;.
     * &lt;p&gt;
     * The flag implies UNICODE_CASE, that is, it enables Unicode-aware case
     * folding.
     * &lt;p&gt;
     * Specifying this flag may impose a performance penalty.  &lt;/p&gt;
     * @since 1.7
     */
    public static final int UNICODE_CHARACTER_CLASS = 0x100;

    /* Pattern has only two serialized components: The pattern string
     * and the flags, which are all that is needed to recompile the pattern
     * when it is deserialized.
     */

    /** use serialVersionUID from Merlin b59 for interoperability */
    private static final long serialVersionUID = 5073258162644648461L;

    /**
     * The original regular-expression pattern string.
     *
     * @serial
     */
    private String pattern;

    /**
     * The original pattern flags.
     *
     * @serial
     */
    private int flags;

    /**
     * Boolean indicating this Pattern is compiled; this is necessary in order
     * to lazily compile deserialized Patterns.
     */
<span class="fc" id="L946">    private transient volatile boolean compiled = false;</span>

    /**
     * The normalized pattern string.
     */
    private transient String normalizedPattern;

    /**
     * The starting point of state machine for the find operation.  This allows
     * a match to start anywhere in the input.
     */
    transient Node root;

    /**
     * The root of object tree for a match operation.  The pattern is matched
     * at the beginning.  This may include a find that uses BnM or a First
     * node.
     */
    transient Node matchRoot;

    /**
     * Temporary storage used by parsing pattern slice.
     */
    transient int[] buffer;

    /**
     * Map the &quot;name&quot; of the &quot;named capturing group&quot; to its group id
     * node.
     */
    transient volatile Map&lt;String, Integer&gt; namedGroups;

    /**
     * Temporary storage used while parsing group references.
     */
    transient GroupHead[] groupNodes;

    /**
     * Temporary null terminated code point array used by pattern compiling.
     */
    private transient int[] temp;

    /**
     * The number of capturing groups in this Pattern. Used by matchers to
     * allocate storage needed to perform a match.
     */
    transient int capturingGroupCount;

    /**
     * The local variable count used by parsing tree. Used by matchers to
     * allocate storage needed to perform a match.
     */
    transient int localCount;

    /**
     * Index into the pattern string that keeps track of how much has been
     * parsed.
     */
    private transient int cursor;

    /**
     * Holds the length of the pattern string.
     */
    private transient int patternLength;

    /**
     * If the Start node might possibly match supplementary characters.
     * It is set to true during compiling if
     * (1) There is supplementary char in pattern, or
     * (2) There is complement node of Category or Block
     */
    private transient boolean hasSupplementary;

    /**
     * Compiles the given regular expression into a pattern.
     *
     * @param  regex
     *         The expression to be compiled
     * @return the given regular expression compiled into a pattern
     * @throws  PatternSyntaxException
     *          If the expression's syntax is invalid
     */
    public static Pattern compile(String regex) {
<span class="fc" id="L1028">        return new Pattern(regex, 0);</span>
    }

    /**
     * Compiles the given regular expression into a pattern with the given
     * flags.
     *
     * @param  regex
     *         The expression to be compiled
     *
     * @param  flags
     *         Match flags, a bit mask that may include
     *         {@link #CASE_INSENSITIVE}, {@link #MULTILINE}, {@link #DOTALL},
     *         {@link #UNICODE_CASE}, {@link #CANON_EQ}, {@link #UNIX_LINES},
     *         {@link #LITERAL}, {@link #UNICODE_CHARACTER_CLASS}
     *         and {@link #COMMENTS}
     *
     * @return the given regular expression compiled into a pattern with the given flags
     * @throws  IllegalArgumentException
     *          If bit values other than those corresponding to the defined
     *          match flags are set in &lt;tt&gt;flags&lt;/tt&gt;
     *
     * @throws  PatternSyntaxException
     *          If the expression's syntax is invalid
     */
    public static Pattern compile(String regex, int flags) {
<span class="fc" id="L1054">        return new Pattern(regex, flags);</span>
    }

    /**
     * Returns the regular expression from which this pattern was compiled.
     *
     * @return  The source of this pattern
     */
    public String pattern() {
<span class="nc" id="L1063">        return pattern;</span>
    }

    /**
     * &lt;p&gt;Returns the string representation of this pattern. This
     * is the regular expression from which this pattern was
     * compiled.&lt;/p&gt;
     *
     * @return  The string representation of this pattern
     * @since 1.5
     */
    public String toString() {
<span class="fc" id="L1075">        return pattern;</span>
    }

    /**
     * Creates a matcher that will match the given input against this pattern.
     *
     * @param  input
     *         The character sequence to be matched
     *
     * @return  A new matcher for this pattern
     */
    public Matcher matcher(CharSequence input) {
<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">        if (!compiled) {</span>
<span class="nc" id="L1088">            synchronized(this) {</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">                if (!compiled)</span>
<span class="nc" id="L1090">                    compile();</span>
<span class="nc" id="L1091">            }</span>
        }
<span class="fc" id="L1093">        Matcher m = new Matcher(this, input);</span>
<span class="fc" id="L1094">        return m;</span>
    }

    /**
     * Returns this pattern's match flags.
     *
     * @return  The match flags specified when this pattern was compiled
     */
    public int flags() {
<span class="fc" id="L1103">        return flags;</span>
    }

    /**
     * Compiles the given regular expression and attempts to match the given
     * input against it.
     *
     * &lt;p&gt; An invocation of this convenience method of the form
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * Pattern.matches(regex, input);&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * behaves in exactly the same way as the expression
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * Pattern.compile(regex).matcher(input).matches()&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt; If a pattern is to be used multiple times, compiling it once and reusing
     * it will be more efficient than invoking this method each time.  &lt;/p&gt;
     *
     * @param  regex
     *         The expression to be compiled
     *
     * @param  input
     *         The character sequence to be matched
     * @return whether or not the regular expression matches on the input
     * @throws  PatternSyntaxException
     *          If the expression's syntax is invalid
     */
    public static boolean matches(String regex, CharSequence input) {
<span class="fc" id="L1133">        Pattern p = Pattern.compile(regex);</span>
<span class="fc" id="L1134">        Matcher m = p.matcher(input);</span>
<span class="fc" id="L1135">        return m.matches();</span>
    }

    /**
     * Splits the given input sequence around matches of this pattern.
     *
     * &lt;p&gt; The array returned by this method contains each substring of the
     * input sequence that is terminated by another subsequence that matches
     * this pattern or is terminated by the end of the input sequence.  The
     * substrings in the array are in the order in which they occur in the
     * input. If this pattern does not match any subsequence of the input then
     * the resulting array has just one element, namely the input sequence in
     * string form.
     *
     * &lt;p&gt; When there is a positive-width match at the beginning of the input
     * sequence then an empty leading substring is included at the beginning
     * of the resulting array. A zero-width match at the beginning however
     * never produces such empty leading substring.
     *
     * &lt;p&gt; The &lt;tt&gt;limit&lt;/tt&gt; parameter controls the number of times the
     * pattern is applied and therefore affects the length of the resulting
     * array.  If the limit &lt;i&gt;n&lt;/i&gt; is greater than zero then the pattern
     * will be applied at most &lt;i&gt;n&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1 times, the array's
     * length will be no greater than &lt;i&gt;n&lt;/i&gt;, and the array's last entry
     * will contain all input beyond the last matched delimiter.  If &lt;i&gt;n&lt;/i&gt;
     * is non-positive then the pattern will be applied as many times as
     * possible and the array can have any length.  If &lt;i&gt;n&lt;/i&gt; is zero then
     * the pattern will be applied as many times as possible, the array can
     * have any length, and trailing empty strings will be discarded.
     *
     * &lt;p&gt; The input &lt;tt&gt;&quot;boo:and:foo&quot;&lt;/tt&gt;, for example, yields the following
     * results with these parameters:
     *
     * &lt;blockquote&gt;&lt;table cellpadding=1 cellspacing=0
     *              summary=&quot;Split examples showing regex, limit, and result&quot;&gt;
     * &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;&lt;i&gt;Regex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/th&gt;
     *     &lt;th align=&quot;left&quot;&gt;&lt;i&gt;Limit&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/th&gt;
     *     &lt;th align=&quot;left&quot;&gt;&lt;i&gt;Result&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/th&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;
     *     &lt;td align=center&gt;2&lt;/td&gt;
     *     &lt;td&gt;&lt;tt&gt;{ &quot;boo&quot;, &quot;and:foo&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;
     *     &lt;td align=center&gt;5&lt;/td&gt;
     *     &lt;td&gt;&lt;tt&gt;{ &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;
     *     &lt;td align=center&gt;-2&lt;/td&gt;
     *     &lt;td&gt;&lt;tt&gt;{ &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;
     *     &lt;td align=center&gt;5&lt;/td&gt;
     *     &lt;td&gt;&lt;tt&gt;{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;
     *     &lt;td align=center&gt;-2&lt;/td&gt;
     *     &lt;td&gt;&lt;tt&gt;{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;
     *     &lt;td align=center&gt;0&lt;/td&gt;
     *     &lt;td&gt;&lt;tt&gt;{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
     * &lt;/table&gt;&lt;/blockquote&gt;
     *
     * @param  input
     *         The character sequence to be split
     *
     * @param  limit
     *         The result threshold, as described above
     *
     * @return  The array of strings computed by splitting the input
     *          around matches of this pattern
     */
    public String[] split(CharSequence input, int limit) {
<span class="fc" id="L1203">        int index = 0;</span>
<span class="pc bpc" id="L1204" title="1 of 2 branches missed.">        boolean matchLimited = limit &gt; 0;</span>
<span class="fc" id="L1205">        ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1206">        Matcher m = matcher(input);</span>

        // Add segments before each match found
<span class="fc bfc" id="L1209" title="All 2 branches covered.">        while(m.find()) {</span>
<span class="pc bpc" id="L1210" title="3 of 4 branches missed.">            if (!matchLimited || matchList.size() &lt; limit - 1) {</span>
<span class="pc bpc" id="L1211" title="1 of 6 branches missed.">                if (index == 0 &amp;&amp; index == m.start() &amp;&amp; m.start() == m.end()) {</span>
                    // no empty leading substring included for zero-width match
                    // at the beginning of the input char sequence.
<span class="nc" id="L1214">                    continue;</span>
                }
<span class="fc" id="L1216">                String match = input.subSequence(index, m.start()).toString();</span>
<span class="fc" id="L1217">                matchList.add(match);</span>
<span class="fc" id="L1218">                index = m.end();</span>
<span class="pc bnc" id="L1219" title="All 2 branches missed.">            } else if (matchList.size() == limit - 1) { // last one</span>
<span class="nc" id="L1220">                String match = input.subSequence(index,</span>
<span class="nc" id="L1221">                                                 input.length()).toString();</span>
<span class="nc" id="L1222">                matchList.add(match);</span>
<span class="nc" id="L1223">                index = m.end();</span>
<span class="nc" id="L1224">            }</span>
        }

        // If no match was found, return this
<span class="fc bfc" id="L1228" title="All 2 branches covered.">        if (index == 0)</span>
<span class="fc" id="L1229">            return new String[] {input.toString()};</span>

        // Add remaining segment
<span class="pc bpc" id="L1232" title="3 of 4 branches missed.">        if (!matchLimited || matchList.size() &lt; limit)</span>
<span class="fc" id="L1233">            matchList.add(input.subSequence(index, input.length()).toString());</span>

        // Construct result
<span class="fc" id="L1236">        int resultSize = matchList.size();</span>
<span class="pc bpc" id="L1237" title="1 of 2 branches missed.">        if (limit == 0)</span>
<span class="pc bpc" id="L1238" title="1 of 4 branches missed.">            while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(&quot;&quot;))</span>
<span class="fc" id="L1239">                resultSize--;</span>
<span class="fc" id="L1240">        String[] result = new String[resultSize];</span>
<span class="fc" id="L1241">        return matchList.subList(0, resultSize).toArray(result);</span>
    }

    /**
     * Splits the given input sequence around matches of this pattern.
     *
     * &lt;p&gt; This method works as if by invoking the two-argument {@link
     * #split(java.lang.CharSequence, int) split} method with the given input
     * sequence and a limit argument of zero.  Trailing empty strings are
     * therefore not included in the resulting array. &lt;/p&gt;
     *
     * &lt;p&gt; The input &lt;tt&gt;&quot;boo:and:foo&quot;&lt;/tt&gt;, for example, yields the following
     * results with these expressions:
     *
     * &lt;blockquote&gt;&lt;table cellpadding=1 cellspacing=0
     *              summary=&quot;Split examples showing regex and result&quot;&gt;
     * &lt;tr&gt;&lt;th align=&quot;left&quot;&gt;&lt;i&gt;Regex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/i&gt;&lt;/th&gt;
     *     &lt;th align=&quot;left&quot;&gt;&lt;i&gt;Result&lt;/i&gt;&lt;/th&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td align=center&gt;:&lt;/td&gt;
     *     &lt;td&gt;&lt;tt&gt;{ &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
     * &lt;tr&gt;&lt;td align=center&gt;o&lt;/td&gt;
     *     &lt;td&gt;&lt;tt&gt;{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
     * &lt;/table&gt;&lt;/blockquote&gt;
     *
     *
     * @param  input
     *         The character sequence to be split
     *
     * @return  The array of strings computed by splitting the input
     *          around matches of this pattern
     */
    public String[] split(CharSequence input) {
<span class="fc" id="L1273">        return split(input, 0);</span>
    }

    /**
     * Returns a literal pattern &lt;code&gt;String&lt;/code&gt; for the specified
     * &lt;code&gt;String&lt;/code&gt;.
     *
     * &lt;p&gt;This method produces a &lt;code&gt;String&lt;/code&gt; that can be used to
     * create a &lt;code&gt;Pattern&lt;/code&gt; that would match the string
     * &lt;code&gt;s&lt;/code&gt; as if it were a literal pattern.&lt;/p&gt; Metacharacters
     * or escape sequences in the input sequence will be given no special
     * meaning.
     *
     * @param  s The string to be literalized
     * @return  A literal string replacement
     * @since 1.5
     */
    public static String quote(String s) {
<span class="nc" id="L1291">        int slashEIndex = s.indexOf(&quot;\\E&quot;);</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">        if (slashEIndex == -1)</span>
<span class="nc" id="L1293">            return &quot;\\Q&quot; + s + &quot;\\E&quot;;</span>

<span class="nc" id="L1295">        StringBuilder sb = new StringBuilder(s.length() * 2);</span>
<span class="nc" id="L1296">        sb.append(&quot;\\Q&quot;);</span>
<span class="nc" id="L1297">        slashEIndex = 0;</span>
<span class="nc" id="L1298">        int current = 0;</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">        while ((slashEIndex = s.indexOf(&quot;\\E&quot;, current)) != -1) {</span>
<span class="nc" id="L1300">            sb.append(s.substring(current, slashEIndex));</span>
<span class="nc" id="L1301">            current = slashEIndex + 2;</span>
<span class="nc" id="L1302">            sb.append(&quot;\\E\\\\E\\Q&quot;);</span>
        }
<span class="nc" id="L1304">        sb.append(s.substring(current, s.length()));</span>
<span class="nc" id="L1305">        sb.append(&quot;\\E&quot;);</span>
<span class="nc" id="L1306">        return sb.toString();</span>
    }

    /**
     * Recompile the Pattern instance from a stream.  The original pattern
     * string is read in and the object tree is recompiled from it.
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {

        // Read in all fields
<span class="nc" id="L1317">        s.defaultReadObject();</span>

        // Initialize counts
<span class="nc" id="L1320">        capturingGroupCount = 1;</span>
<span class="nc" id="L1321">        localCount = 0;</span>

        // if length &gt; 0, the Pattern is lazily compiled
<span class="nc" id="L1324">        compiled = false;</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">        if (pattern.length() == 0) {</span>
<span class="nc" id="L1326">            root = new Start(lastAccept);</span>
<span class="nc" id="L1327">            matchRoot = lastAccept;</span>
<span class="nc" id="L1328">            compiled = true;</span>
        }
<span class="nc" id="L1330">    }</span>

    /**
     * This private constructor is used to create all Patterns. The pattern
     * string and match flags are all that is needed to completely describe
     * a Pattern. An empty pattern string results in an object tree with
     * only a Start node and a LastNode node.
     */
<span class="fc" id="L1338">    private Pattern(String p, int f) {</span>
<span class="fc" id="L1339">        pattern = p;</span>
<span class="fc" id="L1340">        flags = f;</span>

        // to use UNICODE_CASE if UNICODE_CHARACTER_CLASS present
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">        if ((flags &amp; UNICODE_CHARACTER_CLASS) != 0)</span>
<span class="nc" id="L1344">            flags |= UNICODE_CASE;</span>

        // Reset group index count
<span class="fc" id="L1347">        capturingGroupCount = 1;</span>
<span class="fc" id="L1348">        localCount = 0;</span>

<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">        if (pattern.length() &gt; 0) {</span>
<span class="fc" id="L1351">            compile();</span>
        } else {
<span class="nc" id="L1353">            root = new Start(lastAccept);</span>
<span class="nc" id="L1354">            matchRoot = lastAccept;</span>
        }
<span class="fc" id="L1356">    }</span>

    /**
     * The pattern is converted to normalizedD form and then a pure group
     * is constructed to match canonical equivalences of the characters.
     */
    private void normalize() {
<span class="nc" id="L1363">        boolean inCharClass = false;</span>
<span class="nc" id="L1364">        int lastCodePoint = -1;</span>

        // Convert pattern into normalizedD form
<span class="nc" id="L1367">        normalizedPattern = Normalizer.normalize(pattern, Normalizer.Form.NFD);</span>
<span class="nc" id="L1368">        patternLength = normalizedPattern.length();</span>

        // Modify pattern to match canonical equivalences
<span class="nc" id="L1371">        StringBuilder newPattern = new StringBuilder(patternLength);</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">        for(int i=0; i&lt;patternLength; ) {</span>
<span class="nc" id="L1373">            int c = normalizedPattern.codePointAt(i);</span>
            StringBuilder sequenceBuffer;
<span class="nc bnc" id="L1375" title="All 4 branches missed.">            if ((Character.getType(c) == Character.NON_SPACING_MARK)</span>
                &amp;&amp; (lastCodePoint != -1)) {
<span class="nc" id="L1377">                sequenceBuffer = new StringBuilder();</span>
<span class="nc" id="L1378">                sequenceBuffer.appendCodePoint(lastCodePoint);</span>
<span class="nc" id="L1379">                sequenceBuffer.appendCodePoint(c);</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">                while(Character.getType(c) == Character.NON_SPACING_MARK) {</span>
<span class="nc" id="L1381">                    i += Character.charCount(c);</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">                    if (i &gt;= patternLength)</span>
<span class="nc" id="L1383">                        break;</span>
<span class="nc" id="L1384">                    c = normalizedPattern.codePointAt(i);</span>
<span class="nc" id="L1385">                    sequenceBuffer.appendCodePoint(c);</span>
                }
<span class="nc" id="L1387">                String ea = produceEquivalentAlternation(</span>
<span class="nc" id="L1388">                                               sequenceBuffer.toString());</span>
<span class="nc" id="L1389">                newPattern.setLength(newPattern.length()-Character.charCount(lastCodePoint));</span>
<span class="nc" id="L1390">                newPattern.append(&quot;(?:&quot;).append(ea).append(&quot;)&quot;);</span>
<span class="nc bnc" id="L1391" title="All 4 branches missed.">            } else if (c == '[' &amp;&amp; lastCodePoint != '\\') {</span>
<span class="nc" id="L1392">                i = normalizeCharClass(newPattern, i);</span>
            } else {
<span class="nc" id="L1394">                newPattern.appendCodePoint(c);</span>
            }
<span class="nc" id="L1396">            lastCodePoint = c;</span>
<span class="nc" id="L1397">            i += Character.charCount(c);</span>
<span class="nc" id="L1398">        }</span>
<span class="nc" id="L1399">        normalizedPattern = newPattern.toString();</span>
<span class="nc" id="L1400">    }</span>

    /**
     * Complete the character class being parsed and add a set
     * of alternations to it that will match the canonical equivalences
     * of the characters within the class.
     */
    private int normalizeCharClass(StringBuilder newPattern, int i) {
<span class="nc" id="L1408">        StringBuilder charClass = new StringBuilder();</span>
<span class="nc" id="L1409">        StringBuilder eq = null;</span>
<span class="nc" id="L1410">        int lastCodePoint = -1;</span>
        String result;

<span class="nc" id="L1413">        i++;</span>
<span class="nc" id="L1414">        charClass.append(&quot;[&quot;);</span>
        while(true) {
<span class="nc" id="L1416">            int c = normalizedPattern.codePointAt(i);</span>
            StringBuilder sequenceBuffer;

<span class="nc bnc" id="L1419" title="All 4 branches missed.">            if (c == ']' &amp;&amp; lastCodePoint != '\\') {</span>
<span class="nc" id="L1420">                charClass.append((char)c);</span>
<span class="nc" id="L1421">                break;</span>
<span class="nc bnc" id="L1422" title="All 2 branches missed.">            } else if (Character.getType(c) == Character.NON_SPACING_MARK) {</span>
<span class="nc" id="L1423">                sequenceBuffer = new StringBuilder();</span>
<span class="nc" id="L1424">                sequenceBuffer.appendCodePoint(lastCodePoint);</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">                while(Character.getType(c) == Character.NON_SPACING_MARK) {</span>
<span class="nc" id="L1426">                    sequenceBuffer.appendCodePoint(c);</span>
<span class="nc" id="L1427">                    i += Character.charCount(c);</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">                    if (i &gt;= normalizedPattern.length())</span>
<span class="nc" id="L1429">                        break;</span>
<span class="nc" id="L1430">                    c = normalizedPattern.codePointAt(i);</span>
                }
<span class="nc" id="L1432">                String ea = produceEquivalentAlternation(</span>
<span class="nc" id="L1433">                                                  sequenceBuffer.toString());</span>

<span class="nc" id="L1435">                charClass.setLength(charClass.length()-Character.charCount(lastCodePoint));</span>
<span class="nc bnc" id="L1436" title="All 2 branches missed.">                if (eq == null)</span>
<span class="nc" id="L1437">                    eq = new StringBuilder();</span>
<span class="nc" id="L1438">                eq.append('|');</span>
<span class="nc" id="L1439">                eq.append(ea);</span>
<span class="nc" id="L1440">            } else {</span>
<span class="nc" id="L1441">                charClass.appendCodePoint(c);</span>
<span class="nc" id="L1442">                i++;</span>
            }
<span class="nc bnc" id="L1444" title="All 2 branches missed.">            if (i == normalizedPattern.length())</span>
<span class="nc" id="L1445">                throw error(&quot;Unclosed character class&quot;);</span>
<span class="nc" id="L1446">            lastCodePoint = c;</span>
<span class="nc" id="L1447">        }</span>

<span class="nc bnc" id="L1449" title="All 2 branches missed.">        if (eq != null) {</span>
<span class="nc" id="L1450">            result = &quot;(?:&quot;+charClass.toString()+eq.toString()+&quot;)&quot;;</span>
        } else {
<span class="nc" id="L1452">            result = charClass.toString();</span>
        }

<span class="nc" id="L1455">        newPattern.append(result);</span>
<span class="nc" id="L1456">        return i;</span>
    }

    /**
     * Given a specific sequence composed of a regular character and
     * combining marks that follow it, produce the alternation that will
     * match all canonical equivalences of that sequence.
     */
    private String produceEquivalentAlternation(String source) {
<span class="nc" id="L1465">        int len = countChars(source, 0, 1);</span>
<span class="nc bnc" id="L1466" title="All 2 branches missed.">        if (source.length() == len)</span>
            // source has one character.
<span class="nc" id="L1468">            return source;</span>

<span class="nc" id="L1470">        String base = source.substring(0,len);</span>
<span class="nc" id="L1471">        String combiningMarks = source.substring(len);</span>

<span class="nc" id="L1473">        String[] perms = producePermutations(combiningMarks);</span>
<span class="nc" id="L1474">        StringBuilder result = new StringBuilder(source);</span>

        // Add combined permutations
<span class="nc bnc" id="L1477" title="All 2 branches missed.">        for(int x=0; x&lt;perms.length; x++) {</span>
<span class="nc" id="L1478">            String next = base + perms[x];</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">            if (x&gt;0)</span>
<span class="nc" id="L1480">                result.append(&quot;|&quot;+next);</span>
<span class="nc" id="L1481">            next = composeOneStep(next);</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">            if (next != null)</span>
<span class="nc" id="L1483">                result.append(&quot;|&quot;+produceEquivalentAlternation(next));</span>
        }
<span class="nc" id="L1485">        return result.toString();</span>
    }

    /**
     * Returns an array of strings that have all the possible
     * permutations of the characters in the input string.
     * This is used to get a list of all possible orderings
     * of a set of combining marks. Note that some of the permutations
     * are invalid because of combining class collisions, and these
     * possibilities must be removed because they are not canonically
     * equivalent.
     */
    private String[] producePermutations(String input) {
<span class="nc bnc" id="L1498" title="All 2 branches missed.">        if (input.length() == countChars(input, 0, 1))</span>
<span class="nc" id="L1499">            return new String[] {input};</span>

<span class="nc bnc" id="L1501" title="All 2 branches missed.">        if (input.length() == countChars(input, 0, 2)) {</span>
<span class="nc" id="L1502">            int c0 = Character.codePointAt(input, 0);</span>
<span class="nc" id="L1503">            int c1 = Character.codePointAt(input, Character.charCount(c0));</span>
<span class="nc bnc" id="L1504" title="All 2 branches missed.">            if (getClass(c1) == getClass(c0)) {</span>
<span class="nc" id="L1505">                return new String[] {input};</span>
            }
<span class="nc" id="L1507">            String[] result = new String[2];</span>
<span class="nc" id="L1508">            result[0] = input;</span>
<span class="nc" id="L1509">            StringBuilder sb = new StringBuilder(2);</span>
<span class="nc" id="L1510">            sb.appendCodePoint(c1);</span>
<span class="nc" id="L1511">            sb.appendCodePoint(c0);</span>
<span class="nc" id="L1512">            result[1] = sb.toString();</span>
<span class="nc" id="L1513">            return result;</span>
        }

<span class="nc" id="L1516">        int length = 1;</span>
<span class="nc" id="L1517">        int nCodePoints = countCodePoints(input);</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">        for(int x=1; x&lt;nCodePoints; x++)</span>
<span class="nc" id="L1519">            length = length * (x+1);</span>

<span class="nc" id="L1521">        String[] temp = new String[length];</span>

<span class="nc" id="L1523">        int combClass[] = new int[nCodePoints];</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">        for(int x=0, i=0; x&lt;nCodePoints; x++) {</span>
<span class="nc" id="L1525">            int c = Character.codePointAt(input, i);</span>
<span class="nc" id="L1526">            combClass[x] = getClass(c);</span>
<span class="nc" id="L1527">            i +=  Character.charCount(c);</span>
        }

        // For each char, take it out and add the permutations
        // of the remaining chars
<span class="nc" id="L1532">        int index = 0;</span>
        int len;
        // offset maintains the index in code units.
<span class="nc bnc" id="L1535" title="All 2 branches missed.">loop:   for(int x=0, offset=0; x&lt;nCodePoints; x++, offset+=len) {</span>
<span class="nc" id="L1536">            len = countChars(input, offset, 1);</span>
<span class="nc" id="L1537">            boolean skip = false;</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">            for(int y=x-1; y&gt;=0; y--) {</span>
<span class="nc bnc" id="L1539" title="All 2 branches missed.">                if (combClass[y] == combClass[x]) {</span>
<span class="nc" id="L1540">                    continue loop;</span>
                }
            }
<span class="nc" id="L1543">            StringBuilder sb = new StringBuilder(input);</span>
<span class="nc" id="L1544">            String otherChars = sb.delete(offset, offset+len).toString();</span>
<span class="nc" id="L1545">            String[] subResult = producePermutations(otherChars);</span>

<span class="nc" id="L1547">            String prefix = input.substring(offset, offset+len);</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">            for(int y=0; y&lt;subResult.length; y++)</span>
<span class="nc" id="L1549">                temp[index++] =  prefix + subResult[y];</span>
        }
<span class="nc" id="L1551">        String[] result = new String[index];</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">        for (int x=0; x&lt;index; x++)</span>
<span class="nc" id="L1553">            result[x] = temp[x];</span>
<span class="nc" id="L1554">        return result;</span>
    }

    private int getClass(int c) {
<span class="nc" id="L1558">        return sun.text.Normalizer.getCombiningClass(c);</span>
    }

    /**
     * Attempts to compose input by combining the first character
     * with the first combining mark following it. Returns a String
     * that is the composition of the leading character with its first
     * combining mark followed by the remaining combining marks. Returns
     * null if the first two characters cannot be further composed.
     */
    private String composeOneStep(String input) {
<span class="nc" id="L1569">        int len = countChars(input, 0, 2);</span>
<span class="nc" id="L1570">        String firstTwoCharacters = input.substring(0, len);</span>
<span class="nc" id="L1571">        String result = Normalizer.normalize(firstTwoCharacters, Normalizer.Form.NFC);</span>

<span class="nc bnc" id="L1573" title="All 2 branches missed.">        if (result.equals(firstTwoCharacters))</span>
<span class="nc" id="L1574">            return null;</span>
        else {
<span class="nc" id="L1576">            String remainder = input.substring(len);</span>
<span class="nc" id="L1577">            return result + remainder;</span>
        }
    }

    /**
     * Preprocess any \Q...\E sequences in `temp', meta-quoting them.
     * See the description of `quotemeta' in perlfunc(1).
     */
    private void RemoveQEQuoting() {
<span class="fc" id="L1586">        final int pLen = patternLength;</span>
<span class="fc" id="L1587">        int i = 0;</span>
<span class="fc bfc" id="L1588" title="All 2 branches covered.">        while (i &lt; pLen-1) {</span>
<span class="fc bfc" id="L1589" title="All 2 branches covered.">            if (temp[i] != '\\')</span>
<span class="fc" id="L1590">                i += 1;</span>
<span class="fc bfc" id="L1591" title="All 2 branches covered.">            else if (temp[i + 1] != 'Q')</span>
<span class="fc" id="L1592">                i += 2;</span>
            else
                break;
        }
<span class="fc bfc" id="L1596" title="All 2 branches covered.">        if (i &gt;= pLen - 1)    // No \Q sequence found</span>
<span class="fc" id="L1597">            return;</span>
<span class="fc" id="L1598">        int j = i;</span>
<span class="fc" id="L1599">        i += 2;</span>
<span class="fc" id="L1600">        int[] newtemp = new int[j + 3*(pLen-i) + 2];</span>
<span class="fc" id="L1601">        System.arraycopy(temp, 0, newtemp, 0, j);</span>

<span class="fc" id="L1603">        boolean inQuote = true;</span>
<span class="fc" id="L1604">        boolean beginQuote = true;</span>
<span class="fc bfc" id="L1605" title="All 2 branches covered.">        while (i &lt; pLen) {</span>
<span class="fc" id="L1606">            int c = temp[i++];</span>
<span class="pc bpc" id="L1607" title="1 of 4 branches missed.">            if (!ASCII.isAscii(c) || ASCII.isAlpha(c)) {</span>
<span class="fc" id="L1608">                newtemp[j++] = c;</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">            } else if (ASCII.isDigit(c)) {</span>
<span class="pc bpc" id="L1610" title="1 of 2 branches missed.">                if (beginQuote) {</span>
                    /*
                     * A unicode escape \[0xu] could be before this quote,
                     * and we don't want this numeric char to processed as
                     * part of the escape.
                     */
<span class="nc" id="L1616">                    newtemp[j++] = '\\';</span>
<span class="nc" id="L1617">                    newtemp[j++] = 'x';</span>
<span class="nc" id="L1618">                    newtemp[j++] = '3';</span>
                }
<span class="fc" id="L1620">                newtemp[j++] = c;</span>
<span class="fc bfc" id="L1621" title="All 2 branches covered.">            } else if (c != '\\') {</span>
<span class="fc bfc" id="L1622" title="All 2 branches covered.">                if (inQuote) newtemp[j++] = '\\';</span>
<span class="fc" id="L1623">                newtemp[j++] = c;</span>
<span class="pc bpc" id="L1624" title="1 of 2 branches missed.">            } else if (inQuote) {</span>
<span class="pc bpc" id="L1625" title="1 of 2 branches missed.">                if (temp[i] == 'E') {</span>
<span class="fc" id="L1626">                    i++;</span>
<span class="fc" id="L1627">                    inQuote = false;</span>
                } else {
<span class="nc" id="L1629">                    newtemp[j++] = '\\';</span>
<span class="nc" id="L1630">                    newtemp[j++] = '\\';</span>
                }
            } else {
<span class="nc bnc" id="L1633" title="All 2 branches missed.">                if (temp[i] == 'Q') {</span>
<span class="nc" id="L1634">                    i++;</span>
<span class="nc" id="L1635">                    inQuote = true;</span>
<span class="nc" id="L1636">                    beginQuote = true;</span>
<span class="nc" id="L1637">                    continue;</span>
                } else {
<span class="nc" id="L1639">                    newtemp[j++] = c;</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">                    if (i != pLen)</span>
<span class="nc" id="L1641">                        newtemp[j++] = temp[i++];</span>
                }
            }

<span class="fc" id="L1645">            beginQuote = false;</span>
<span class="fc" id="L1646">        }</span>

<span class="fc" id="L1648">        patternLength = j;</span>
<span class="fc" id="L1649">        temp = Arrays.copyOf(newtemp, j + 2); // double zero termination</span>
<span class="fc" id="L1650">    }</span>

    /**
     * Copies regular expression to an int array and invokes the parsing
     * of the expression which will create the object tree.
     */
    private void compile() {
        // Handle canonical equivalences
<span class="pc bpc" id="L1658" title="3 of 4 branches missed.">        if (has(CANON_EQ) &amp;&amp; !has(LITERAL)) {</span>
<span class="nc" id="L1659">            normalize();</span>
        } else {
<span class="fc" id="L1661">            normalizedPattern = pattern;</span>
        }
<span class="fc" id="L1663">        patternLength = normalizedPattern.length();</span>

        // Copy pattern to int array for convenience
        // Use double zero to terminate pattern
<span class="fc" id="L1667">        temp = new int[patternLength + 2];</span>

<span class="fc" id="L1669">        hasSupplementary = false;</span>
<span class="fc" id="L1670">        int c, count = 0;</span>
        // Convert all chars into code points
<span class="fc bfc" id="L1672" title="All 2 branches covered.">        for (int x = 0; x &lt; patternLength; x += Character.charCount(c)) {</span>
<span class="fc" id="L1673">            c = normalizedPattern.codePointAt(x);</span>
<span class="fc bfc" id="L1674" title="All 2 branches covered.">            if (isSupplementary(c)) {</span>
<span class="fc" id="L1675">                hasSupplementary = true;</span>
            }
<span class="fc" id="L1677">            temp[count++] = c;</span>
        }

<span class="fc" id="L1680">        patternLength = count;   // patternLength now in code points</span>

<span class="fc bfc" id="L1682" title="All 2 branches covered.">        if (! has(LITERAL))</span>
<span class="fc" id="L1683">            RemoveQEQuoting();</span>

        // Allocate all temporary objects here.
<span class="fc" id="L1686">        buffer = new int[32];</span>
<span class="fc" id="L1687">        groupNodes = new GroupHead[10];</span>
<span class="fc" id="L1688">        namedGroups = null;</span>

<span class="fc bfc" id="L1690" title="All 2 branches covered.">        if (has(LITERAL)) {</span>
            // Literal pattern handling
<span class="fc" id="L1692">            matchRoot = newSlice(temp, patternLength, hasSupplementary);</span>
<span class="fc" id="L1693">            matchRoot.next = lastAccept;</span>
        } else {
            // Start recursive descent parsing
<span class="fc" id="L1696">            matchRoot = expr(lastAccept);</span>
            // Check extra pattern characters
<span class="pc bpc" id="L1698" title="1 of 2 branches missed.">            if (patternLength != cursor) {</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">                if (peek() == ')') {</span>
<span class="nc" id="L1700">                    throw error(&quot;Unmatched closing ')'&quot;);</span>
                } else {
<span class="nc" id="L1702">                    throw error(&quot;Unexpected internal error&quot;);</span>
                }
            }
        }

        // Peephole optimization
<span class="fc bfc" id="L1708" title="All 2 branches covered.">        if (matchRoot instanceof Slice) {</span>
<span class="fc" id="L1709">            root = BnM.optimize(matchRoot);</span>
<span class="fc bfc" id="L1710" title="All 2 branches covered.">            if (root == matchRoot) {</span>
<span class="pc bpc" id="L1711" title="1 of 2 branches missed.">                root = hasSupplementary ? new StartS(matchRoot) : new Start(matchRoot);</span>
            }
<span class="pc bpc" id="L1713" title="1 of 4 branches missed.">        } else if (matchRoot instanceof Begin || matchRoot instanceof First) {</span>
<span class="fc" id="L1714">            root = matchRoot;</span>
        } else {
<span class="fc bfc" id="L1716" title="All 2 branches covered.">            root = hasSupplementary ? new StartS(matchRoot) : new Start(matchRoot);</span>
        }

        // Release temporary storage
<span class="fc" id="L1720">        temp = null;</span>
<span class="fc" id="L1721">        buffer = null;</span>
<span class="fc" id="L1722">        groupNodes = null;</span>
<span class="fc" id="L1723">        patternLength = 0;</span>
<span class="fc" id="L1724">        compiled = true;</span>
<span class="fc" id="L1725">    }</span>

    Map&lt;String, Integer&gt; namedGroups() {
<span class="nc bnc" id="L1728" title="All 2 branches missed.">        if (namedGroups == null)</span>
<span class="nc" id="L1729">            namedGroups = new HashMap&lt;&gt;(2);</span>
<span class="nc" id="L1730">        return namedGroups;</span>
    }

    /**
     * Used to print out a subtree of the Pattern to help with debugging.
     */
    private static void printObjectTree(Node node) {
<span class="nc bnc" id="L1737" title="All 2 branches missed.">        while(node != null) {</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">            if (node instanceof Prolog) {</span>
<span class="nc" id="L1739">                System.out.println(node);</span>
<span class="nc" id="L1740">                printObjectTree(((Prolog)node).loop);</span>
<span class="nc" id="L1741">                System.out.println(&quot;**** end contents prolog loop&quot;);</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">            } else if (node instanceof Loop) {</span>
<span class="nc" id="L1743">                System.out.println(node);</span>
<span class="nc" id="L1744">                printObjectTree(((Loop)node).body);</span>
<span class="nc" id="L1745">                System.out.println(&quot;**** end contents Loop body&quot;);</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">            } else if (node instanceof Curly) {</span>
<span class="nc" id="L1747">                System.out.println(node);</span>
<span class="nc" id="L1748">                printObjectTree(((Curly)node).atom);</span>
<span class="nc" id="L1749">                System.out.println(&quot;**** end contents Curly body&quot;);</span>
<span class="nc bnc" id="L1750" title="All 2 branches missed.">            } else if (node instanceof GroupCurly) {</span>
<span class="nc" id="L1751">                System.out.println(node);</span>
<span class="nc" id="L1752">                printObjectTree(((GroupCurly)node).atom);</span>
<span class="nc" id="L1753">                System.out.println(&quot;**** end contents GroupCurly body&quot;);</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">            } else if (node instanceof GroupTail) {</span>
<span class="nc" id="L1755">                System.out.println(node);</span>
<span class="nc" id="L1756">                System.out.println(&quot;Tail next is &quot;+node.next);</span>
<span class="nc" id="L1757">                return;</span>
            } else {
<span class="nc" id="L1759">                System.out.println(node);</span>
            }
<span class="nc" id="L1761">            node = node.next;</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">            if (node != null)</span>
<span class="nc" id="L1763">                System.out.println(&quot;-&gt;next:&quot;);</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">            if (node == Pattern.accept) {</span>
<span class="nc" id="L1765">                System.out.println(&quot;Accept Node&quot;);</span>
<span class="nc" id="L1766">                node = null;</span>
            }
       }
<span class="nc" id="L1769">    }</span>

    /**
     * Used to accumulate information about a subtree of the object graph
     * so that optimizations can be applied to the subtree.
     */
    static final class TreeInfo {
        int minLength;
        int maxLength;
        boolean maxValid;
        boolean deterministic;

<span class="fc" id="L1781">        TreeInfo() {</span>
<span class="fc" id="L1782">            reset();</span>
<span class="fc" id="L1783">        }</span>
        void reset() {
<span class="fc" id="L1785">            minLength = 0;</span>
<span class="fc" id="L1786">            maxLength = 0;</span>
<span class="fc" id="L1787">            maxValid = true;</span>
<span class="fc" id="L1788">            deterministic = true;</span>
<span class="fc" id="L1789">        }</span>
    }

    /*
     * The following private methods are mainly used to improve the
     * readability of the code. In order to let the Java compiler easily
     * inline them, we should not put many assertions or error checks in them.
     */

    /**
     * Indicates whether a particular flag is set or not.
     */
    private boolean has(int f) {
<span class="fc bfc" id="L1802" title="All 2 branches covered.">        return (flags &amp; f) != 0;</span>
    }

    /**
     * Match next character, signal error if failed.
     */
    private void accept(int ch, String s) {
<span class="fc" id="L1809">        int testChar = temp[cursor++];</span>
<span class="pc bpc" id="L1810" title="1 of 2 branches missed.">        if (has(COMMENTS))</span>
<span class="nc" id="L1811">            testChar = parsePastWhitespace(testChar);</span>
<span class="pc bpc" id="L1812" title="1 of 2 branches missed.">        if (ch != testChar) {</span>
<span class="nc" id="L1813">            throw error(s);</span>
        }
<span class="fc" id="L1815">    }</span>

    /**
     * Mark the end of pattern with a specific character.
     */
    private void mark(int c) {
<span class="fc" id="L1821">        temp[patternLength] = c;</span>
<span class="fc" id="L1822">    }</span>

    /**
     * Peek the next character, and do not advance the cursor.
     */
    private int peek() {
<span class="fc" id="L1828">        int ch = temp[cursor];</span>
<span class="pc bpc" id="L1829" title="1 of 2 branches missed.">        if (has(COMMENTS))</span>
<span class="nc" id="L1830">            ch = peekPastWhitespace(ch);</span>
<span class="fc" id="L1831">        return ch;</span>
    }

    /**
     * Read the next character, and advance the cursor by one.
     */
    private int read() {
<span class="fc" id="L1838">        int ch = temp[cursor++];</span>
<span class="pc bpc" id="L1839" title="1 of 2 branches missed.">        if (has(COMMENTS))</span>
<span class="nc" id="L1840">            ch = parsePastWhitespace(ch);</span>
<span class="fc" id="L1841">        return ch;</span>
    }

    /**
     * Read the next character, and advance the cursor by one,
     * ignoring the COMMENTS setting
     */
    private int readEscaped() {
<span class="nc" id="L1849">        int ch = temp[cursor++];</span>
<span class="nc" id="L1850">        return ch;</span>
    }

    /**
     * Advance the cursor by one, and peek the next character.
     */
    private int next() {
<span class="fc" id="L1857">        int ch = temp[++cursor];</span>
<span class="pc bpc" id="L1858" title="1 of 2 branches missed.">        if (has(COMMENTS))</span>
<span class="nc" id="L1859">            ch = peekPastWhitespace(ch);</span>
<span class="fc" id="L1860">        return ch;</span>
    }

    /**
     * Advance the cursor by one, and peek the next character,
     * ignoring the COMMENTS setting
     */
    private int nextEscaped() {
<span class="fc" id="L1868">        int ch = temp[++cursor];</span>
<span class="fc" id="L1869">        return ch;</span>
    }

    /**
     * If in xmode peek past whitespace and comments.
     */
    private int peekPastWhitespace(int ch) {
<span class="nc bnc" id="L1876" title="All 4 branches missed.">        while (ASCII.isSpace(ch) || ch == '#') {</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">            while (ASCII.isSpace(ch))</span>
<span class="nc" id="L1878">                ch = temp[++cursor];</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">            if (ch == '#') {</span>
<span class="nc" id="L1880">                ch = peekPastLine();</span>
            }
        }
<span class="nc" id="L1883">        return ch;</span>
    }

    /**
     * If in xmode parse past whitespace and comments.
     */
    private int parsePastWhitespace(int ch) {
<span class="nc bnc" id="L1890" title="All 4 branches missed.">        while (ASCII.isSpace(ch) || ch == '#') {</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">            while (ASCII.isSpace(ch))</span>
<span class="nc" id="L1892">                ch = temp[cursor++];</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">            if (ch == '#')</span>
<span class="nc" id="L1894">                ch = parsePastLine();</span>
        }
<span class="nc" id="L1896">        return ch;</span>
    }

    /**
     * xmode parse past comment to end of line.
     */
    private int parsePastLine() {
<span class="nc" id="L1903">        int ch = temp[cursor++];</span>
<span class="nc bnc" id="L1904" title="All 4 branches missed.">        while (ch != 0 &amp;&amp; !isLineSeparator(ch))</span>
<span class="nc" id="L1905">            ch = temp[cursor++];</span>
<span class="nc" id="L1906">        return ch;</span>
    }

    /**
     * xmode peek past comment to end of line.
     */
    private int peekPastLine() {
<span class="nc" id="L1913">        int ch = temp[++cursor];</span>
<span class="nc bnc" id="L1914" title="All 4 branches missed.">        while (ch != 0 &amp;&amp; !isLineSeparator(ch))</span>
<span class="nc" id="L1915">            ch = temp[++cursor];</span>
<span class="nc" id="L1916">        return ch;</span>
    }

    /**
     * Determines if character is a line separator in the current mode
     */
    private boolean isLineSeparator(int ch) {
<span class="nc bnc" id="L1923" title="All 2 branches missed.">        if (has(UNIX_LINES)) {</span>
<span class="nc bnc" id="L1924" title="All 2 branches missed.">            return ch == '\n';</span>
        } else {
<span class="nc bnc" id="L1926" title="All 8 branches missed.">            return (ch == '\n' ||</span>
                    ch == '\r' ||
                    (ch|1) == '\u2029' ||
                    ch == '\u0085');
        }
    }

    /**
     * Read the character after the next one, and advance the cursor by two.
     */
    private int skip() {
<span class="fc" id="L1937">        int i = cursor;</span>
<span class="fc" id="L1938">        int ch = temp[i+1];</span>
<span class="fc" id="L1939">        cursor = i + 2;</span>
<span class="fc" id="L1940">        return ch;</span>
    }

    /**
     * Unread one next character, and retreat cursor by one.
     */
    private void unread() {
<span class="fc" id="L1947">        cursor--;</span>
<span class="fc" id="L1948">    }</span>

    /**
     * Internal method used for handling all syntax errors. The pattern is
     * displayed with a pointer to aid in locating the syntax error.
     */
    private PatternSyntaxException error(String s) {
<span class="nc" id="L1955">        return new PatternSyntaxException(s, normalizedPattern,  cursor - 1);</span>
    }

    /**
     * Determines if there is any supplementary character or unpaired
     * surrogate in the specified range.
     */
    private boolean findSupplementary(int start, int end) {
<span class="nc bnc" id="L1963" title="All 2 branches missed.">        for (int i = start; i &lt; end; i++) {</span>
<span class="nc bnc" id="L1964" title="All 2 branches missed.">            if (isSupplementary(temp[i]))</span>
<span class="nc" id="L1965">                return true;</span>
        }
<span class="nc" id="L1967">        return false;</span>
    }

    /**
     * Determines if the specified code point is a supplementary
     * character or unpaired surrogate.
     */
    private static final boolean isSupplementary(int ch) {
<span class="fc bfc" id="L1975" title="All 2 branches covered.">        return ch &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT ||</span>
<span class="pc bpc" id="L1976" title="1 of 2 branches missed.">               Character.isSurrogate((char)ch);</span>
    }

    /**
     *  The following methods handle the main parsing. They are sorted
     *  according to their precedence order, the lowest one first.
     */

    /**
     * The expression is parsed with branch nodes added for alternations.
     * This may be called recursively to parse sub expressions that may
     * contain alternations.
     */
    private Node expr(Node end) {
<span class="fc" id="L1990">        Node prev = null;</span>
<span class="fc" id="L1991">        Node firstTail = null;</span>
<span class="fc" id="L1992">        Branch branch = null;</span>
<span class="fc" id="L1993">        Node branchConn = null;</span>

        for (;;) {
<span class="fc" id="L1996">            Node node = sequence(end);</span>
<span class="fc" id="L1997">            Node nodeTail = root;      //double return</span>
<span class="fc bfc" id="L1998" title="All 2 branches covered.">            if (prev == null) {</span>
<span class="fc" id="L1999">                prev = node;</span>
<span class="fc" id="L2000">                firstTail = nodeTail;</span>
            } else {
                // Branch
<span class="fc bfc" id="L2003" title="All 2 branches covered.">                if (branchConn == null) {</span>
<span class="fc" id="L2004">                    branchConn = new BranchConn();</span>
<span class="fc" id="L2005">                    branchConn.next = end;</span>
                }
<span class="pc bpc" id="L2007" title="1 of 2 branches missed.">                if (node == end) {</span>
                    // if the node returned from sequence() is &quot;end&quot;
                    // we have an empty expr, set a null atom into
                    // the branch to indicate to go &quot;next&quot; directly.
<span class="nc" id="L2011">                    node = null;</span>
                } else {
                    // the &quot;tail.next&quot; of each atom goes to branchConn
<span class="fc" id="L2014">                    nodeTail.next = branchConn;</span>
                }
<span class="fc bfc" id="L2016" title="All 2 branches covered.">                if (prev == branch) {</span>
<span class="fc" id="L2017">                    branch.add(node);</span>
                } else {
<span class="pc bpc" id="L2019" title="1 of 2 branches missed.">                    if (prev == end) {</span>
<span class="nc" id="L2020">                        prev = null;</span>
                    } else {
                        // replace the &quot;end&quot; with &quot;branchConn&quot; at its tail.next
                        // when put the &quot;prev&quot; into the branch as the first atom.
<span class="fc" id="L2024">                        firstTail.next = branchConn;</span>
                    }
<span class="fc" id="L2026">                    prev = branch = new Branch(prev, node, branchConn);</span>
                }
            }
<span class="fc bfc" id="L2029" title="All 2 branches covered.">            if (peek() != '|') {</span>
<span class="fc" id="L2030">                return prev;</span>
            }
<span class="fc" id="L2032">            next();</span>
<span class="fc" id="L2033">        }</span>
    }

    @SuppressWarnings(&quot;fallthrough&quot;)
    /**
     * Parsing of sequences between alternations.
     */
    private Node sequence(Node end) {
<span class="fc" id="L2041">        Node head = null;</span>
<span class="fc" id="L2042">        Node tail = null;</span>
<span class="fc" id="L2043">        Node node = null;</span>
    LOOP:
        for (;;) {
<span class="fc" id="L2046">            int ch = peek();</span>
<span class="pc bpc" id="L2047" title="2 of 11 branches missed.">            switch (ch) {</span>
            case '(':
                // Because group handles its own closure,
                // we need to treat it differently
<span class="fc" id="L2051">                node = group0();</span>
                // Check for comment or flag group
<span class="fc bfc" id="L2053" title="All 2 branches covered.">                if (node == null)</span>
<span class="fc" id="L2054">                    continue;</span>
<span class="fc bfc" id="L2055" title="All 2 branches covered.">                if (head == null)</span>
<span class="fc" id="L2056">                    head = node;</span>
                else
<span class="fc" id="L2058">                    tail.next = node;</span>
                // Double return: Tail was returned in root
<span class="fc" id="L2060">                tail = root;</span>
<span class="fc" id="L2061">                continue;</span>
            case '[':
<span class="fc" id="L2063">                node = clazz(true);</span>
<span class="fc" id="L2064">                break;</span>
            case '\\':
<span class="fc" id="L2066">                ch = nextEscaped();</span>
<span class="fc bfc" id="L2067" title="All 4 branches covered.">                if (ch == 'p' || ch == 'P') {</span>
<span class="fc" id="L2068">                    boolean oneLetter = true;</span>
<span class="fc bfc" id="L2069" title="All 2 branches covered.">                    boolean comp = (ch == 'P');</span>
<span class="fc" id="L2070">                    ch = next(); // Consume { if present</span>
<span class="pc bpc" id="L2071" title="1 of 2 branches missed.">                    if (ch != '{') {</span>
<span class="nc" id="L2072">                        unread();</span>
                    } else {
<span class="fc" id="L2074">                        oneLetter = false;</span>
                    }
<span class="fc" id="L2076">                    node = family(oneLetter, comp);</span>
<span class="fc" id="L2077">                } else {</span>
<span class="fc" id="L2078">                    unread();</span>
<span class="fc" id="L2079">                    node = atom();</span>
                }
<span class="fc" id="L2081">                break;</span>
            case '^':
<span class="fc" id="L2083">                next();</span>
<span class="fc bfc" id="L2084" title="All 2 branches covered.">                if (has(MULTILINE)) {</span>
<span class="pc bpc" id="L2085" title="1 of 2 branches missed.">                    if (has(UNIX_LINES))</span>
<span class="nc" id="L2086">                        node = new UnixCaret();</span>
                    else
<span class="fc" id="L2088">                        node = new Caret();</span>
                } else {
<span class="fc" id="L2090">                    node = new Begin();</span>
                }
<span class="fc" id="L2092">                break;</span>
            case '$':
<span class="fc" id="L2094">                next();</span>
<span class="pc bpc" id="L2095" title="1 of 2 branches missed.">                if (has(UNIX_LINES))</span>
<span class="nc" id="L2096">                    node = new UnixDollar(has(MULTILINE));</span>
                else
<span class="fc" id="L2098">                    node = new Dollar(has(MULTILINE));</span>
<span class="fc" id="L2099">                break;</span>
            case '.':
<span class="fc" id="L2101">                next();</span>
<span class="fc bfc" id="L2102" title="All 2 branches covered.">                if (has(DOTALL)) {</span>
<span class="fc" id="L2103">                    node = new All();</span>
                } else {
<span class="pc bpc" id="L2105" title="1 of 2 branches missed.">                    if (has(UNIX_LINES))</span>
<span class="nc" id="L2106">                        node = new UnixDot();</span>
                    else {
<span class="fc" id="L2108">                        node = new Dot();</span>
                    }
                }
<span class="fc" id="L2111">                break;</span>
            case '|':
            case ')':
<span class="fc" id="L2114">                break LOOP;</span>
            case ']': // Now interpreting dangling ] and } as literals
            case '}':
<span class="nc" id="L2117">                node = atom();</span>
<span class="nc" id="L2118">                break;</span>
            case '?':
            case '*':
            case '+':
<span class="nc" id="L2122">                next();</span>
<span class="nc" id="L2123">                throw error(&quot;Dangling meta character '&quot; + ((char)ch) + &quot;'&quot;);</span>
            case 0:
<span class="fc bfc" id="L2125" title="All 2 branches covered.">                if (cursor &gt;= patternLength) {</span>
<span class="fc" id="L2126">                    break LOOP;</span>
                }
                // Fall through
            default:
<span class="fc" id="L2130">                node = atom();</span>
                break;
            }

<span class="fc" id="L2134">            node = closure(node);</span>

<span class="fc bfc" id="L2136" title="All 2 branches covered.">            if (head == null) {</span>
<span class="fc" id="L2137">                head = tail = node;</span>
            } else {
<span class="fc" id="L2139">                tail.next = node;</span>
<span class="fc" id="L2140">                tail = node;</span>
            }
<span class="fc" id="L2142">        }</span>
<span class="pc bpc" id="L2143" title="1 of 2 branches missed.">        if (head == null) {</span>
<span class="nc" id="L2144">            return end;</span>
        }
<span class="fc" id="L2146">        tail.next = end;</span>
<span class="fc" id="L2147">        root = tail;      //double return</span>
<span class="fc" id="L2148">        return head;</span>
    }

    @SuppressWarnings(&quot;fallthrough&quot;)
    /**
     * Parse and add a new Single or Slice.
     */
    private Node atom() {
<span class="fc" id="L2156">        int first = 0;</span>
<span class="fc" id="L2157">        int prev = -1;</span>
<span class="fc" id="L2158">        boolean hasSupplementary = false;</span>
<span class="fc" id="L2159">        int ch = peek();</span>
        for (;;) {
<span class="fc bfc" id="L2161" title="All 5 branches covered.">            switch (ch) {</span>
            case '*':
            case '+':
            case '?':
            case '{':
<span class="fc bfc" id="L2166" title="All 2 branches covered.">                if (first &gt; 1) {</span>
<span class="fc" id="L2167">                    cursor = prev;    // Unwind one character</span>
<span class="fc" id="L2168">                    first--;</span>
                }
                break;
            case '$':
            case '.':
            case '^':
            case '(':
            case '[':
            case '|':
            case ')':
<span class="fc" id="L2178">                break;</span>
            case '\\':
<span class="fc" id="L2180">                ch = nextEscaped();</span>
<span class="pc bpc" id="L2181" title="2 of 4 branches missed.">                if (ch == 'p' || ch == 'P') { // Property</span>
<span class="nc bnc" id="L2182" title="All 2 branches missed.">                    if (first &gt; 0) { // Slice is waiting; handle it first</span>
<span class="nc" id="L2183">                        unread();</span>
<span class="nc" id="L2184">                        break;</span>
                    } else { // No slice; just return the family node
<span class="nc bnc" id="L2186" title="All 2 branches missed.">                        boolean comp = (ch == 'P');</span>
<span class="nc" id="L2187">                        boolean oneLetter = true;</span>
<span class="nc" id="L2188">                        ch = next(); // Consume { if present</span>
<span class="nc bnc" id="L2189" title="All 2 branches missed.">                        if (ch != '{')</span>
<span class="nc" id="L2190">                            unread();</span>
                        else
<span class="nc" id="L2192">                            oneLetter = false;</span>
<span class="nc" id="L2193">                        return family(oneLetter, comp);</span>
                    }
                }
<span class="fc" id="L2196">                unread();</span>
<span class="fc" id="L2197">                prev = cursor;</span>
<span class="fc bfc" id="L2198" title="All 2 branches covered.">                ch = escape(false, first == 0, false);</span>
<span class="fc bfc" id="L2199" title="All 2 branches covered.">                if (ch &gt;= 0) {</span>
<span class="fc" id="L2200">                    append(ch, first);</span>
<span class="fc" id="L2201">                    first++;</span>
<span class="pc bpc" id="L2202" title="1 of 2 branches missed.">                    if (isSupplementary(ch)) {</span>
<span class="nc" id="L2203">                        hasSupplementary = true;</span>
                    }
<span class="fc" id="L2205">                    ch = peek();</span>
<span class="fc" id="L2206">                    continue;</span>
<span class="fc bfc" id="L2207" title="All 2 branches covered.">                } else if (first == 0) {</span>
<span class="fc" id="L2208">                    return root;</span>
                }
                // Unwind meta escape sequence
<span class="fc" id="L2211">                cursor = prev;</span>
<span class="fc" id="L2212">                break;</span>
            case 0:
<span class="fc bfc" id="L2214" title="All 2 branches covered.">                if (cursor &gt;= patternLength) {</span>
<span class="fc" id="L2215">                    break;</span>
                }
                // Fall through
            default:
<span class="fc" id="L2219">                prev = cursor;</span>
<span class="fc" id="L2220">                append(ch, first);</span>
<span class="fc" id="L2221">                first++;</span>
<span class="pc bpc" id="L2222" title="1 of 2 branches missed.">                if (isSupplementary(ch)) {</span>
<span class="nc" id="L2223">                    hasSupplementary = true;</span>
                }
<span class="fc" id="L2225">                ch = next();</span>
<span class="fc" id="L2226">                continue;</span>
            }
            break;
        }
<span class="fc bfc" id="L2230" title="All 2 branches covered.">        if (first == 1) {</span>
<span class="fc" id="L2231">            return newSingle(buffer[0]);</span>
        } else {
<span class="fc" id="L2233">            return newSlice(buffer, first, hasSupplementary);</span>
        }
    }

    private void append(int ch, int len) {
<span class="pc bpc" id="L2238" title="1 of 2 branches missed.">        if (len &gt;= buffer.length) {</span>
<span class="nc" id="L2239">            int[] tmp = new int[len+len];</span>
<span class="nc" id="L2240">            System.arraycopy(buffer, 0, tmp, 0, len);</span>
<span class="nc" id="L2241">            buffer = tmp;</span>
        }
<span class="fc" id="L2243">        buffer[len] = ch;</span>
<span class="fc" id="L2244">    }</span>

    /**
     * Parses a backref greedily, taking as many numbers as it
     * can. The first digit is always treated as a backref, but
     * multi digit numbers are only treated as a backref if at
     * least that many backrefs exist at this point in the regex.
     */
    private Node ref(int refNum) {
<span class="nc" id="L2253">        boolean done = false;</span>
<span class="nc bnc" id="L2254" title="All 2 branches missed.">        while(!done) {</span>
<span class="nc" id="L2255">            int ch = peek();</span>
<span class="nc bnc" id="L2256" title="All 2 branches missed.">            switch(ch) {</span>
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
<span class="nc" id="L2267">                int newRefNum = (refNum * 10) + (ch - '0');</span>
                // Add another number if it doesn't make a group
                // that doesn't exist
<span class="nc bnc" id="L2270" title="All 2 branches missed.">                if (capturingGroupCount - 1 &lt; newRefNum) {</span>
<span class="nc" id="L2271">                    done = true;</span>
<span class="nc" id="L2272">                    break;</span>
                }
<span class="nc" id="L2274">                refNum = newRefNum;</span>
<span class="nc" id="L2275">                read();</span>
<span class="nc" id="L2276">                break;</span>
            default:
<span class="nc" id="L2278">                done = true;</span>
                break;
            }
<span class="nc" id="L2281">        }</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">        if (has(CASE_INSENSITIVE))</span>
<span class="nc" id="L2283">            return new CIBackRef(refNum, has(UNICODE_CASE));</span>
        else
<span class="nc" id="L2285">            return new BackRef(refNum);</span>
    }

    /**
     * Parses an escape sequence to determine the actual value that needs
     * to be matched.
     * If -1 is returned and create was true a new object was added to the tree
     * to handle the escape sequence.
     * If the returned value is greater than zero, it is the value that
     * matches the escape sequence.
     */
    private int escape(boolean inclass, boolean create, boolean isrange) {
<span class="fc" id="L2297">        int ch = skip();</span>
<span class="pc bpc" id="L2298" title="32 of 40 branches missed.">        switch (ch) {</span>
        case '0':
<span class="nc" id="L2300">            return o();</span>
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
<span class="nc bnc" id="L2310" title="All 2 branches missed.">            if (inclass) break;</span>
<span class="nc bnc" id="L2311" title="All 2 branches missed.">            if (create) {</span>
<span class="nc" id="L2312">                root = ref((ch - '0'));</span>
            }
<span class="nc" id="L2314">            return -1;</span>
        case 'A':
<span class="nc bnc" id="L2316" title="All 2 branches missed.">            if (inclass) break;</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">            if (create) root = new Begin();</span>
<span class="nc" id="L2318">            return -1;</span>
        case 'B':
<span class="nc bnc" id="L2320" title="All 2 branches missed.">            if (inclass) break;</span>
<span class="nc bnc" id="L2321" title="All 2 branches missed.">            if (create) root = new Bound(Bound.NONE, has(UNICODE_CHARACTER_CLASS));</span>
<span class="nc" id="L2322">            return -1;</span>
        case 'C':
<span class="nc" id="L2324">            break;</span>
        case 'D':
<span class="pc bpc" id="L2326" title="2 of 4 branches missed.">            if (create) root = has(UNICODE_CHARACTER_CLASS)</span>
<span class="pc" id="L2327">                               ? new Utype(UnicodeProp.DIGIT).complement()</span>
<span class="fc" id="L2328">                               : new Ctype(ASCII.DIGIT).complement();</span>
<span class="fc" id="L2329">            return -1;</span>
        case 'E':
        case 'F':
<span class="nc" id="L2332">            break;</span>
        case 'G':
<span class="nc bnc" id="L2334" title="All 2 branches missed.">            if (inclass) break;</span>
<span class="nc bnc" id="L2335" title="All 2 branches missed.">            if (create) root = new LastMatch();</span>
<span class="nc" id="L2336">            return -1;</span>
        case 'H':
<span class="nc bnc" id="L2338" title="All 2 branches missed.">            if (create) root = new HorizWS().complement();</span>
<span class="nc" id="L2339">            return -1;</span>
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
<span class="nc" id="L2349">            break;</span>
        case 'R':
<span class="nc bnc" id="L2351" title="All 2 branches missed.">            if (inclass) break;</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">            if (create) root = new LineEnding();</span>
<span class="nc" id="L2353">            return -1;</span>
        case 'S':
<span class="pc bpc" id="L2355" title="1 of 4 branches missed.">            if (create) root = has(UNICODE_CHARACTER_CLASS)</span>
<span class="pc" id="L2356">                               ? new Utype(UnicodeProp.WHITE_SPACE).complement()</span>
<span class="fc" id="L2357">                               : new Ctype(ASCII.SPACE).complement();</span>
<span class="fc" id="L2358">            return -1;</span>
        case 'T':
        case 'U':
<span class="nc" id="L2361">            break;</span>
        case 'V':
<span class="nc bnc" id="L2363" title="All 2 branches missed.">            if (create) root = new VertWS().complement();</span>
<span class="nc" id="L2364">            return -1;</span>
        case 'W':
<span class="nc bnc" id="L2366" title="All 4 branches missed.">            if (create) root = has(UNICODE_CHARACTER_CLASS)</span>
<span class="nc" id="L2367">                               ? new Utype(UnicodeProp.WORD).complement()</span>
<span class="nc" id="L2368">                               : new Ctype(ASCII.WORD).complement();</span>
<span class="nc" id="L2369">            return -1;</span>
        case 'X':
        case 'Y':
<span class="nc" id="L2372">            break;</span>
        case 'Z':
<span class="nc bnc" id="L2374" title="All 2 branches missed.">            if (inclass) break;</span>
<span class="nc bnc" id="L2375" title="All 2 branches missed.">            if (create) {</span>
<span class="nc bnc" id="L2376" title="All 2 branches missed.">                if (has(UNIX_LINES))</span>
<span class="nc" id="L2377">                    root = new UnixDollar(false);</span>
                else
<span class="nc" id="L2379">                    root = new Dollar(false);</span>
            }
<span class="nc" id="L2381">            return -1;</span>
        case 'a':
<span class="nc" id="L2383">            return '\007';</span>
        case 'b':
<span class="nc bnc" id="L2385" title="All 2 branches missed.">            if (inclass) break;</span>
<span class="nc bnc" id="L2386" title="All 2 branches missed.">            if (create) root = new Bound(Bound.BOTH, has(UNICODE_CHARACTER_CLASS));</span>
<span class="nc" id="L2387">            return -1;</span>
        case 'c':
<span class="nc" id="L2389">            return c();</span>
        case 'd':
<span class="pc bpc" id="L2391" title="1 of 4 branches missed.">            if (create) root = has(UNICODE_CHARACTER_CLASS)</span>
                               ? new Utype(UnicodeProp.DIGIT)
                               : new Ctype(ASCII.DIGIT);
<span class="fc" id="L2394">            return -1;</span>
        case 'e':
<span class="nc" id="L2396">            return '\033';</span>
        case 'f':
<span class="nc" id="L2398">            return '\f';</span>
        case 'g':
<span class="nc" id="L2400">            break;</span>
        case 'h':
<span class="nc bnc" id="L2402" title="All 2 branches missed.">            if (create) root = new HorizWS();</span>
<span class="nc" id="L2403">            return -1;</span>
        case 'i':
        case 'j':
<span class="nc" id="L2406">            break;</span>
        case 'k':
<span class="nc bnc" id="L2408" title="All 2 branches missed.">            if (inclass)</span>
<span class="nc" id="L2409">                break;</span>
<span class="nc bnc" id="L2410" title="All 2 branches missed.">            if (read() != '&lt;')</span>
<span class="nc" id="L2411">                throw error(&quot;\\k is not followed by '&lt;' for named capturing group&quot;);</span>
<span class="nc" id="L2412">            String name = groupname(read());</span>
<span class="nc bnc" id="L2413" title="All 2 branches missed.">            if (!namedGroups().containsKey(name))</span>
<span class="nc" id="L2414">                throw error(&quot;(named capturing group &lt;&quot;+ name+&quot;&gt; does not exit&quot;);</span>
<span class="nc bnc" id="L2415" title="All 2 branches missed.">            if (create) {</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">                if (has(CASE_INSENSITIVE))</span>
<span class="nc" id="L2417">                    root = new CIBackRef(namedGroups().get(name), has(UNICODE_CASE));</span>
                else
<span class="nc" id="L2419">                    root = new BackRef(namedGroups().get(name));</span>
            }
<span class="nc" id="L2421">            return -1;</span>
        case 'l':
        case 'm':
<span class="nc" id="L2424">            break;</span>
        case 'n':
<span class="nc" id="L2426">            return '\n';</span>
        case 'o':
        case 'p':
        case 'q':
<span class="nc" id="L2430">            break;</span>
        case 'r':
<span class="nc" id="L2432">            return '\r';</span>
        case 's':
<span class="pc bpc" id="L2434" title="1 of 4 branches missed.">            if (create) root = has(UNICODE_CHARACTER_CLASS)</span>
                               ? new Utype(UnicodeProp.WHITE_SPACE)
                               : new Ctype(ASCII.SPACE);
<span class="fc" id="L2437">            return -1;</span>
        case 't':
<span class="nc" id="L2439">            return '\t';</span>
        case 'u':
<span class="fc" id="L2441">            return u();</span>
        case 'v':
            // '\v' was implemented as VT/0x0B in releases &lt; 1.8 (though
            // undocumented). In JDK8 '\v' is specified as a predefined
            // character class for all vertical whitespace characters.
            // So [-1, root=VertWS node] pair is returned (instead of a
            // single 0x0B). This breaks the range if '\v' is used as
            // the start or end value, such as [\v-...] or [...-\v], in
            // which a single definite value (0x0B) is expected. For
            // compatibility concern '\013'/0x0B is returned if isrange.
<span class="nc bnc" id="L2451" title="All 2 branches missed.">            if (isrange)</span>
<span class="nc" id="L2452">                return '\013';</span>
<span class="nc bnc" id="L2453" title="All 2 branches missed.">            if (create) root = new VertWS();</span>
<span class="nc" id="L2454">            return -1;</span>
        case 'w':
<span class="pc bpc" id="L2456" title="2 of 4 branches missed.">            if (create) root = has(UNICODE_CHARACTER_CLASS)</span>
                               ? new Utype(UnicodeProp.WORD)
                               : new Ctype(ASCII.WORD);
<span class="fc" id="L2459">            return -1;</span>
        case 'x':
<span class="fc" id="L2461">            return x();</span>
        case 'y':
<span class="nc" id="L2463">            break;</span>
        case 'z':
<span class="nc bnc" id="L2465" title="All 2 branches missed.">            if (inclass) break;</span>
<span class="nc bnc" id="L2466" title="All 2 branches missed.">            if (create) root = new End();</span>
<span class="nc" id="L2467">            return -1;</span>
        default:
<span class="fc" id="L2469">            return ch;</span>
        }
<span class="nc" id="L2471">        throw error(&quot;Illegal/unsupported escape sequence&quot;);</span>
    }

    /**
     * Parse a character class, and return the node that matches it.
     *
     * Consumes a ] on the way out if consume is true. Usually consume
     * is true except for the case of [abc&amp;&amp;def] where def is a separate
     * right hand node with &quot;understood&quot; brackets.
     */
    private CharProperty clazz(boolean consume) {
<span class="fc" id="L2482">        CharProperty prev = null;</span>
<span class="fc" id="L2483">        CharProperty node = null;</span>
<span class="fc" id="L2484">        BitClass bits = new BitClass();</span>
<span class="fc" id="L2485">        boolean include = true;</span>
<span class="fc" id="L2486">        boolean firstInClass = true;</span>
<span class="fc" id="L2487">        int ch = next();</span>
        for (;;) {
<span class="pc bpc" id="L2489" title="2 of 6 branches missed.">            switch (ch) {</span>
                case '^':
                    // Negates if first char in a class, otherwise literal
<span class="pc bpc" id="L2492" title="1 of 2 branches missed.">                    if (firstInClass) {</span>
<span class="pc bpc" id="L2493" title="1 of 2 branches missed.">                        if (temp[cursor-1] != '[')</span>
<span class="nc" id="L2494">                            break;</span>
<span class="fc" id="L2495">                        ch = next();</span>
<span class="pc bpc" id="L2496" title="1 of 2 branches missed.">                        include = !include;</span>
<span class="fc" id="L2497">                        continue;</span>
                    } else {
                        // ^ not first in class, treat as literal
                        break;
                    }
                case '[':
<span class="nc" id="L2503">                    firstInClass = false;</span>
<span class="nc" id="L2504">                    node = clazz(true);</span>
<span class="nc bnc" id="L2505" title="All 2 branches missed.">                    if (prev == null)</span>
<span class="nc" id="L2506">                        prev = node;</span>
                    else
<span class="nc" id="L2508">                        prev = union(prev, node);</span>
<span class="nc" id="L2509">                    ch = peek();</span>
<span class="nc" id="L2510">                    continue;</span>
                case '&amp;':
<span class="fc" id="L2512">                    firstInClass = false;</span>
<span class="fc" id="L2513">                    ch = next();</span>
<span class="pc bpc" id="L2514" title="1 of 2 branches missed.">                    if (ch == '&amp;') {</span>
<span class="fc" id="L2515">                        ch = next();</span>
<span class="fc" id="L2516">                        CharProperty rightNode = null;</span>
<span class="pc bpc" id="L2517" title="1 of 4 branches missed.">                        while (ch != ']' &amp;&amp; ch != '&amp;') {</span>
<span class="pc bpc" id="L2518" title="1 of 2 branches missed.">                            if (ch == '[') {</span>
<span class="pc bpc" id="L2519" title="1 of 2 branches missed.">                                if (rightNode == null)</span>
<span class="fc" id="L2520">                                    rightNode = clazz(true);</span>
                                else
<span class="nc" id="L2522">                                    rightNode = union(rightNode, clazz(true));</span>
                            } else { // abc&amp;&amp;def
<span class="nc" id="L2524">                                unread();</span>
<span class="nc" id="L2525">                                rightNode = clazz(false);</span>
                            }
<span class="fc" id="L2527">                            ch = peek();</span>
                        }
<span class="pc bpc" id="L2529" title="1 of 2 branches missed.">                        if (rightNode != null)</span>
<span class="fc" id="L2530">                            node = rightNode;</span>
<span class="pc bpc" id="L2531" title="1 of 2 branches missed.">                        if (prev == null) {</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">                            if (rightNode == null)</span>
<span class="nc" id="L2533">                                throw error(&quot;Bad class syntax&quot;);</span>
                            else
<span class="nc" id="L2535">                                prev = rightNode;</span>
                        } else {
<span class="fc" id="L2537">                            prev = intersection(prev, node);</span>
                        }
<span class="fc" id="L2539">                    } else {</span>
                        // treat as a literal &amp;
<span class="nc" id="L2541">                        unread();</span>
<span class="nc" id="L2542">                        break;</span>
                    }
                    continue;
                case 0:
<span class="nc" id="L2546">                    firstInClass = false;</span>
<span class="nc bnc" id="L2547" title="All 2 branches missed.">                    if (cursor &gt;= patternLength)</span>
<span class="nc" id="L2548">                        throw error(&quot;Unclosed character class&quot;);</span>
                    break;
                case ']':
<span class="fc" id="L2551">                    firstInClass = false;</span>
<span class="pc bpc" id="L2552" title="1 of 2 branches missed.">                    if (prev != null) {</span>
<span class="pc bpc" id="L2553" title="1 of 2 branches missed.">                        if (consume)</span>
<span class="fc" id="L2554">                            next();</span>
<span class="fc" id="L2555">                        return prev;</span>
                    }
                    break;
                default:
<span class="fc" id="L2559">                    firstInClass = false;</span>
                    break;
            }
<span class="fc" id="L2562">            node = range(bits);</span>
<span class="fc bfc" id="L2563" title="All 2 branches covered.">            if (include) {</span>
<span class="fc bfc" id="L2564" title="All 2 branches covered.">                if (prev == null) {</span>
<span class="fc" id="L2565">                    prev = node;</span>
                } else {
<span class="fc bfc" id="L2567" title="All 2 branches covered.">                    if (prev != node)</span>
<span class="fc" id="L2568">                        prev = union(prev, node);</span>
                }
            } else {
<span class="fc bfc" id="L2571" title="All 2 branches covered.">                if (prev == null) {</span>
<span class="fc" id="L2572">                    prev = node.complement();</span>
                } else {
<span class="pc bpc" id="L2574" title="1 of 2 branches missed.">                    if (prev != node)</span>
<span class="fc" id="L2575">                        prev = setDifference(prev, node);</span>
                }
            }
<span class="fc" id="L2578">            ch = peek();</span>
        }
    }

    private CharProperty bitsOrSingle(BitClass bits, int ch) {
        /* Bits can only handle codepoints in [u+0000-u+00ff] range.
           Use &quot;single&quot; node instead of bits when dealing with unicode
           case folding for codepoints listed below.
           (1)Uppercase out of range: u+00ff, u+00b5
              toUpperCase(u+00ff) -&gt; u+0178
              toUpperCase(u+00b5) -&gt; u+039c
           (2)LatinSmallLetterLongS u+17f
              toUpperCase(u+017f) -&gt; u+0053
           (3)LatinSmallLetterDotlessI u+131
              toUpperCase(u+0131) -&gt; u+0049
           (4)LatinCapitalLetterIWithDotAbove u+0130
              toLowerCase(u+0130) -&gt; u+0069
           (5)KelvinSign u+212a
              toLowerCase(u+212a) ==&gt; u+006B
           (6)AngstromSign u+212b
              toLowerCase(u+212b) ==&gt; u+00e5
        */
        int d;
<span class="pc bpc" id="L2601" title="1 of 2 branches missed.">        if (ch &lt; 256 &amp;&amp;</span>
<span class="pc bpc" id="L2602" title="21 of 24 branches missed.">            !(has(CASE_INSENSITIVE) &amp;&amp; has(UNICODE_CASE) &amp;&amp;</span>
              (ch == 0xff || ch == 0xb5 ||
               ch == 0x49 || ch == 0x69 ||  //I and i
               ch == 0x53 || ch == 0x73 ||  //S and s
               ch == 0x4b || ch == 0x6b ||  //K and k
               ch == 0xc5 || ch == 0xe5)))  //A+ring
<span class="fc" id="L2608">            return bits.add(ch, flags());</span>
<span class="nc" id="L2609">        return newSingle(ch);</span>
    }

    /**
     * Parse a single character or a character range in a character class
     * and return its representative node.
     */
    private CharProperty range(BitClass bits) {
<span class="fc" id="L2617">        int ch = peek();</span>
<span class="fc bfc" id="L2618" title="All 2 branches covered.">        if (ch == '\\') {</span>
<span class="fc" id="L2619">            ch = nextEscaped();</span>
<span class="pc bpc" id="L2620" title="1 of 4 branches missed.">            if (ch == 'p' || ch == 'P') { // A property</span>
<span class="pc bpc" id="L2621" title="1 of 2 branches missed.">                boolean comp = (ch == 'P');</span>
<span class="fc" id="L2622">                boolean oneLetter = true;</span>
                // Consume { if present
<span class="fc" id="L2624">                ch = next();</span>
<span class="pc bpc" id="L2625" title="1 of 2 branches missed.">                if (ch != '{')</span>
<span class="nc" id="L2626">                    unread();</span>
                else
<span class="fc" id="L2628">                    oneLetter = false;</span>
<span class="fc" id="L2629">                return family(oneLetter, comp);</span>
            } else { // ordinary escape
<span class="pc bpc" id="L2631" title="1 of 2 branches missed.">                boolean isrange = temp[cursor+1] == '-';</span>
<span class="fc" id="L2632">                unread();</span>
<span class="fc" id="L2633">                ch = escape(true, true, isrange);</span>
<span class="fc bfc" id="L2634" title="All 2 branches covered.">                if (ch == -1)</span>
<span class="fc" id="L2635">                    return (CharProperty) root;</span>
<span class="fc" id="L2636">            }</span>
        } else {
<span class="fc" id="L2638">            next();</span>
        }
<span class="pc bpc" id="L2640" title="1 of 2 branches missed.">        if (ch &gt;= 0) {</span>
<span class="fc bfc" id="L2641" title="All 2 branches covered.">            if (peek() == '-') {</span>
<span class="fc" id="L2642">                int endRange = temp[cursor+1];</span>
<span class="pc bpc" id="L2643" title="1 of 2 branches missed.">                if (endRange == '[') {</span>
<span class="nc" id="L2644">                    return bitsOrSingle(bits, ch);</span>
                }
<span class="fc bfc" id="L2646" title="All 2 branches covered.">                if (endRange != ']') {</span>
<span class="fc" id="L2647">                    next();</span>
<span class="fc" id="L2648">                    int m = peek();</span>
<span class="fc bfc" id="L2649" title="All 2 branches covered.">                    if (m == '\\') {</span>
<span class="fc" id="L2650">                        m = escape(true, false, true);</span>
                    } else {
<span class="fc" id="L2652">                        next();</span>
                    }
<span class="pc bpc" id="L2654" title="1 of 2 branches missed.">                    if (m &lt; ch) {</span>
<span class="nc" id="L2655">                        throw error(&quot;Illegal character range&quot;);</span>
                    }
<span class="fc bfc" id="L2657" title="All 2 branches covered.">                    if (has(CASE_INSENSITIVE))</span>
<span class="fc" id="L2658">                        return caseInsensitiveRangeFor(ch, m);</span>
                    else
<span class="fc" id="L2660">                        return rangeFor(ch, m);</span>
                }
            }
<span class="fc" id="L2663">            return bitsOrSingle(bits, ch);</span>
        }
<span class="nc" id="L2665">        throw error(&quot;Unexpected character '&quot;+((char)ch)+&quot;'&quot;);</span>
    }

    /**
     * Parses a Unicode character family and returns its representative node.
     */
    private CharProperty family(boolean singleLetter,
                                boolean maybeComplement)
    {
<span class="fc" id="L2674">        next();</span>
        String name;
<span class="fc" id="L2676">        CharProperty node = null;</span>

<span class="pc bpc" id="L2678" title="1 of 2 branches missed.">        if (singleLetter) {</span>
<span class="nc" id="L2679">            int c = temp[cursor];</span>
<span class="nc bnc" id="L2680" title="All 2 branches missed.">            if (!Character.isSupplementaryCodePoint(c)) {</span>
<span class="nc" id="L2681">                name = String.valueOf((char)c);</span>
            } else {
<span class="nc" id="L2683">                name = new String(temp, cursor, 1);</span>
            }
<span class="nc" id="L2685">            read();</span>
<span class="nc" id="L2686">        } else {</span>
<span class="fc" id="L2687">            int i = cursor;</span>
<span class="fc" id="L2688">            mark('}');</span>
<span class="fc bfc" id="L2689" title="All 2 branches covered.">            while(read() != '}') {</span>
            }
<span class="fc" id="L2691">            mark('\000');</span>
<span class="fc" id="L2692">            int j = cursor;</span>
<span class="pc bpc" id="L2693" title="1 of 2 branches missed.">            if (j &gt; patternLength)</span>
<span class="nc" id="L2694">                throw error(&quot;Unclosed character family&quot;);</span>
<span class="pc bpc" id="L2695" title="1 of 2 branches missed.">            if (i + 1 &gt;= j)</span>
<span class="nc" id="L2696">                throw error(&quot;Empty character family&quot;);</span>
<span class="fc" id="L2697">            name = new String(temp, i, j-i-1);</span>
        }

<span class="fc" id="L2700">        int i = name.indexOf('=');</span>
<span class="pc bpc" id="L2701" title="1 of 2 branches missed.">        if (i != -1) {</span>
            // property construct \p{name=value}
<span class="nc" id="L2703">            String value = name.substring(i + 1);</span>
<span class="nc" id="L2704">            name = name.substring(0, i).toLowerCase(Locale.ENGLISH);</span>
<span class="nc bnc" id="L2705" title="All 4 branches missed.">            if (&quot;sc&quot;.equals(name) || &quot;script&quot;.equals(name)) {</span>
<span class="nc" id="L2706">                node = unicodeScriptPropertyFor(value);</span>
<span class="nc bnc" id="L2707" title="All 4 branches missed.">            } else if (&quot;blk&quot;.equals(name) || &quot;block&quot;.equals(name)) {</span>
<span class="nc" id="L2708">                node = unicodeBlockPropertyFor(value);</span>
<span class="nc bnc" id="L2709" title="All 4 branches missed.">            } else if (&quot;gc&quot;.equals(name) || &quot;general_category&quot;.equals(name)) {</span>
<span class="nc" id="L2710">                node = charPropertyNodeFor(value);</span>
            } else {
<span class="nc" id="L2712">                throw error(&quot;Unknown Unicode property {name=&lt;&quot; + name + &quot;&gt;, &quot;</span>
                             + &quot;value=&lt;&quot; + value + &quot;&gt;}&quot;);
            }
<span class="nc" id="L2715">        } else {</span>
<span class="pc bpc" id="L2716" title="1 of 2 branches missed.">            if (name.startsWith(&quot;In&quot;)) {</span>
                // \p{inBlockName}
<span class="nc" id="L2718">                node = unicodeBlockPropertyFor(name.substring(2));</span>
<span class="pc bpc" id="L2719" title="1 of 2 branches missed.">            } else if (name.startsWith(&quot;Is&quot;)) {</span>
                // \p{isGeneralCategory} and \p{isScriptName}
<span class="nc" id="L2721">                name = name.substring(2);</span>
<span class="nc" id="L2722">                UnicodeProp uprop = UnicodeProp.forName(name);</span>
<span class="nc bnc" id="L2723" title="All 2 branches missed.">                if (uprop != null)</span>
<span class="nc" id="L2724">                    node = new Utype(uprop);</span>
<span class="nc bnc" id="L2725" title="All 2 branches missed.">                if (node == null)</span>
<span class="nc" id="L2726">                    node = CharPropertyNames.charPropertyFor(name);</span>
<span class="nc bnc" id="L2727" title="All 2 branches missed.">                if (node == null)</span>
<span class="nc" id="L2728">                    node = unicodeScriptPropertyFor(name);</span>
<span class="nc" id="L2729">            } else {</span>
<span class="pc bpc" id="L2730" title="1 of 2 branches missed.">                if (has(UNICODE_CHARACTER_CLASS)) {</span>
<span class="nc" id="L2731">                    UnicodeProp uprop = UnicodeProp.forPOSIXName(name);</span>
<span class="nc bnc" id="L2732" title="All 2 branches missed.">                    if (uprop != null)</span>
<span class="nc" id="L2733">                        node = new Utype(uprop);</span>
                }
<span class="pc bpc" id="L2735" title="1 of 2 branches missed.">                if (node == null)</span>
<span class="fc" id="L2736">                    node = charPropertyNodeFor(name);</span>
            }
        }
<span class="fc bfc" id="L2739" title="All 2 branches covered.">        if (maybeComplement) {</span>
<span class="pc bpc" id="L2740" title="2 of 4 branches missed.">            if (node instanceof Category || node instanceof Block)</span>
<span class="nc" id="L2741">                hasSupplementary = true;</span>
<span class="fc" id="L2742">            node = node.complement();</span>
        }
<span class="fc" id="L2744">        return node;</span>
    }


    /**
     * Returns a CharProperty matching all characters belong to
     * a UnicodeScript.
     */
    private CharProperty unicodeScriptPropertyFor(String name) {
        final Character.UnicodeScript script;
        try {
<span class="nc" id="L2755">            script = Character.UnicodeScript.forName(name);</span>
<span class="nc" id="L2756">        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L2757">            throw error(&quot;Unknown character script name {&quot; + name + &quot;}&quot;);</span>
<span class="nc" id="L2758">        }</span>
<span class="nc" id="L2759">        return new Script(script);</span>
    }

    /**
     * Returns a CharProperty matching all characters in a UnicodeBlock.
     */
    private CharProperty unicodeBlockPropertyFor(String name) {
        final Character.UnicodeBlock block;
        try {
<span class="nc" id="L2768">            block = Character.UnicodeBlock.forName(name);</span>
<span class="nc" id="L2769">        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L2770">            throw error(&quot;Unknown character block name {&quot; + name + &quot;}&quot;);</span>
<span class="nc" id="L2771">        }</span>
<span class="nc" id="L2772">        return new Block(block);</span>
    }

    /**
     * Returns a CharProperty matching all characters in a named property.
     */
    private CharProperty charPropertyNodeFor(String name) {
<span class="fc" id="L2779">        CharProperty p = CharPropertyNames.charPropertyFor(name);</span>
<span class="pc bpc" id="L2780" title="1 of 2 branches missed.">        if (p == null)</span>
<span class="nc" id="L2781">            throw error(&quot;Unknown character property name {&quot; + name + &quot;}&quot;);</span>
<span class="fc" id="L2782">        return p;</span>
    }

    /**
     * Parses and returns the name of a &quot;named capturing group&quot;, the trailing
     * &quot;&gt;&quot; is consumed after parsing.
     */
    private String groupname(int ch) {
<span class="nc" id="L2790">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L2791">        sb.append(Character.toChars(ch));</span>
<span class="nc bnc" id="L2792" title="All 4 branches missed.">        while (ASCII.isLower(ch=read()) || ASCII.isUpper(ch) ||</span>
<span class="nc bnc" id="L2793" title="All 2 branches missed.">               ASCII.isDigit(ch)) {</span>
<span class="nc" id="L2794">            sb.append(Character.toChars(ch));</span>
        }
<span class="nc bnc" id="L2796" title="All 2 branches missed.">        if (sb.length() == 0)</span>
<span class="nc" id="L2797">            throw error(&quot;named capturing group has 0 length name&quot;);</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">        if (ch != '&gt;')</span>
<span class="nc" id="L2799">            throw error(&quot;named capturing group is missing trailing '&gt;'&quot;);</span>
<span class="nc" id="L2800">        return sb.toString();</span>
    }

    /**
     * Parses a group and returns the head node of a set of nodes that process
     * the group. Sometimes a double return system is used where the tail is
     * returned in root.
     */
    private Node group0() {
<span class="fc" id="L2809">        boolean capturingGroup = false;</span>
<span class="fc" id="L2810">        Node head = null;</span>
<span class="fc" id="L2811">        Node tail = null;</span>
<span class="fc" id="L2812">        int save = flags;</span>
<span class="fc" id="L2813">        root = null;</span>
<span class="fc" id="L2814">        int ch = next();</span>
<span class="fc bfc" id="L2815" title="All 2 branches covered.">        if (ch == '?') {</span>
<span class="fc" id="L2816">            ch = skip();</span>
<span class="pc bpc" id="L2817" title="4 of 6 branches missed.">            switch (ch) {</span>
            case ':':   //  (?:xxx) pure group
<span class="fc" id="L2819">                head = createGroup(true);</span>
<span class="fc" id="L2820">                tail = root;</span>
<span class="fc" id="L2821">                head.next = expr(tail);</span>
<span class="fc" id="L2822">                break;</span>
            case '=':   // (?=xxx) and (?!xxx) lookahead
            case '!':
<span class="nc" id="L2825">                head = createGroup(true);</span>
<span class="nc" id="L2826">                tail = root;</span>
<span class="nc" id="L2827">                head.next = expr(tail);</span>
<span class="nc bnc" id="L2828" title="All 2 branches missed.">                if (ch == '=') {</span>
<span class="nc" id="L2829">                    head = tail = new Pos(head);</span>
                } else {
<span class="nc" id="L2831">                    head = tail = new Neg(head);</span>
                }
<span class="nc" id="L2833">                break;</span>
            case '&gt;':   // (?&gt;xxx)  independent group
<span class="nc" id="L2835">                head = createGroup(true);</span>
<span class="nc" id="L2836">                tail = root;</span>
<span class="nc" id="L2837">                head.next = expr(tail);</span>
<span class="nc" id="L2838">                head = tail = new Ques(head, INDEPENDENT);</span>
<span class="nc" id="L2839">                break;</span>
            case '&lt;':   // (?&lt;xxx)  look behind
<span class="nc" id="L2841">                ch = read();</span>
<span class="nc bnc" id="L2842" title="All 4 branches missed.">                if (ASCII.isLower(ch) || ASCII.isUpper(ch)) {</span>
                    // named captured group
<span class="nc" id="L2844">                    String name = groupname(ch);</span>
<span class="nc bnc" id="L2845" title="All 2 branches missed.">                    if (namedGroups().containsKey(name))</span>
<span class="nc" id="L2846">                        throw error(&quot;Named capturing group &lt;&quot; + name</span>
                                    + &quot;&gt; is already defined&quot;);
<span class="nc" id="L2848">                    capturingGroup = true;</span>
<span class="nc" id="L2849">                    head = createGroup(false);</span>
<span class="nc" id="L2850">                    tail = root;</span>
<span class="nc" id="L2851">                    namedGroups().put(name, capturingGroupCount-1);</span>
<span class="nc" id="L2852">                    head.next = expr(tail);</span>
<span class="nc" id="L2853">                    break;</span>
                }
<span class="nc" id="L2855">                int start = cursor;</span>
<span class="nc" id="L2856">                head = createGroup(true);</span>
<span class="nc" id="L2857">                tail = root;</span>
<span class="nc" id="L2858">                head.next = expr(tail);</span>
<span class="nc" id="L2859">                tail.next = lookbehindEnd;</span>
<span class="nc" id="L2860">                TreeInfo info = new TreeInfo();</span>
<span class="nc" id="L2861">                head.study(info);</span>
<span class="nc bnc" id="L2862" title="All 2 branches missed.">                if (info.maxValid == false) {</span>
<span class="nc" id="L2863">                    throw error(&quot;Look-behind group does not have &quot;</span>
                                + &quot;an obvious maximum length&quot;);
                }
<span class="nc" id="L2866">                boolean hasSupplementary = findSupplementary(start, patternLength);</span>
<span class="nc bnc" id="L2867" title="All 2 branches missed.">                if (ch == '=') {</span>
<span class="nc bnc" id="L2868" title="All 2 branches missed.">                    head = tail = (hasSupplementary ?</span>
                                   new BehindS(head, info.maxLength,
                                               info.minLength) :
                                   new Behind(head, info.maxLength,
                                              info.minLength));
<span class="nc bnc" id="L2873" title="All 2 branches missed.">                } else if (ch == '!') {</span>
<span class="nc bnc" id="L2874" title="All 2 branches missed.">                    head = tail = (hasSupplementary ?</span>
                                   new NotBehindS(head, info.maxLength,
                                                  info.minLength) :
                                   new NotBehind(head, info.maxLength,
                                                 info.minLength));
                } else {
<span class="nc" id="L2880">                    throw error(&quot;Unknown look-behind group&quot;);</span>
                }
                break;
            case '$':
            case '@':
<span class="nc" id="L2885">                throw error(&quot;Unknown group type&quot;);</span>
            default:    // (?xxx:) inlined match flags
<span class="fc" id="L2887">                unread();</span>
<span class="fc" id="L2888">                addFlag();</span>
<span class="fc" id="L2889">                ch = read();</span>
<span class="pc bpc" id="L2890" title="1 of 2 branches missed.">                if (ch == ')') {</span>
<span class="fc" id="L2891">                    return null;    // Inline modifier only</span>
                }
<span class="nc bnc" id="L2893" title="All 2 branches missed.">                if (ch != ':') {</span>
<span class="nc" id="L2894">                    throw error(&quot;Unknown inline modifier&quot;);</span>
                }
<span class="nc" id="L2896">                head = createGroup(true);</span>
<span class="nc" id="L2897">                tail = root;</span>
<span class="nc" id="L2898">                head.next = expr(tail);</span>
<span class="fc" id="L2899">                break;</span>
            }
        } else { // (xxx) a regular group
<span class="fc" id="L2902">            capturingGroup = true;</span>
<span class="fc" id="L2903">            head = createGroup(false);</span>
<span class="fc" id="L2904">            tail = root;</span>
<span class="fc" id="L2905">            head.next = expr(tail);</span>
        }

<span class="fc" id="L2908">        accept(')', &quot;Unclosed group&quot;);</span>
<span class="fc" id="L2909">        flags = save;</span>

        // Check for quantifiers
<span class="fc" id="L2912">        Node node = closure(head);</span>
<span class="fc bfc" id="L2913" title="All 2 branches covered.">        if (node == head) { // No closure</span>
<span class="fc" id="L2914">            root = tail;</span>
<span class="fc" id="L2915">            return node;    // Dual return</span>
        }
<span class="pc bpc" id="L2917" title="1 of 2 branches missed.">        if (head == tail) { // Zero length assertion</span>
<span class="nc" id="L2918">            root = node;</span>
<span class="nc" id="L2919">            return node;    // Dual return</span>
        }

<span class="fc bfc" id="L2922" title="All 2 branches covered.">        if (node instanceof Ques) {</span>
<span class="fc" id="L2923">            Ques ques = (Ques) node;</span>
<span class="pc bpc" id="L2924" title="1 of 2 branches missed.">            if (ques.type == POSSESSIVE) {</span>
<span class="nc" id="L2925">                root = node;</span>
<span class="nc" id="L2926">                return node;</span>
            }
<span class="fc" id="L2928">            tail.next = new BranchConn();</span>
<span class="fc" id="L2929">            tail = tail.next;</span>
<span class="pc bpc" id="L2930" title="1 of 2 branches missed.">            if (ques.type == GREEDY) {</span>
<span class="fc" id="L2931">                head = new Branch(head, null, tail);</span>
            } else { // Reluctant quantifier
<span class="nc" id="L2933">                head = new Branch(null, head, tail);</span>
            }
<span class="fc" id="L2935">            root = tail;</span>
<span class="fc" id="L2936">            return head;</span>
<span class="pc bpc" id="L2937" title="1 of 2 branches missed.">        } else if (node instanceof Curly) {</span>
<span class="fc" id="L2938">            Curly curly = (Curly) node;</span>
<span class="pc bpc" id="L2939" title="1 of 2 branches missed.">            if (curly.type == POSSESSIVE) {</span>
<span class="nc" id="L2940">                root = node;</span>
<span class="nc" id="L2941">                return node;</span>
            }
            // Discover if the group is deterministic
<span class="fc" id="L2944">            TreeInfo info = new TreeInfo();</span>
<span class="fc bfc" id="L2945" title="All 2 branches covered.">            if (head.study(info)) { // Deterministic</span>
<span class="fc" id="L2946">                GroupTail temp = (GroupTail) tail;</span>
<span class="fc" id="L2947">                head = root = new GroupCurly(head.next, curly.cmin,</span>
                                   curly.cmax, curly.type,
                                   ((GroupTail)tail).localIndex,
                                   ((GroupTail)tail).groupIndex,
                                             capturingGroup);
<span class="fc" id="L2952">                return head;</span>
            } else { // Non-deterministic
<span class="fc" id="L2954">                int temp = ((GroupHead) head).localIndex;</span>
                Loop loop;
<span class="pc bpc" id="L2956" title="1 of 2 branches missed.">                if (curly.type == GREEDY)</span>
<span class="fc" id="L2957">                    loop = new Loop(this.localCount, temp);</span>
                else  // Reluctant Curly
<span class="nc" id="L2959">                    loop = new LazyLoop(this.localCount, temp);</span>
<span class="fc" id="L2960">                Prolog prolog = new Prolog(loop);</span>
<span class="fc" id="L2961">                this.localCount += 1;</span>
<span class="fc" id="L2962">                loop.cmin = curly.cmin;</span>
<span class="fc" id="L2963">                loop.cmax = curly.cmax;</span>
<span class="fc" id="L2964">                loop.body = head;</span>
<span class="fc" id="L2965">                tail.next = loop;</span>
<span class="fc" id="L2966">                root = loop;</span>
<span class="fc" id="L2967">                return prolog; // Dual return</span>
            }
        }
<span class="nc" id="L2970">        throw error(&quot;Internal logic error&quot;);</span>
    }

    /**
     * Create group head and tail nodes using double return. If the group is
     * created with anonymous true then it is a pure group and should not
     * affect group counting.
     */
    private Node createGroup(boolean anonymous) {
<span class="fc" id="L2979">        int localIndex = localCount++;</span>
<span class="fc" id="L2980">        int groupIndex = 0;</span>
<span class="fc bfc" id="L2981" title="All 2 branches covered.">        if (!anonymous)</span>
<span class="fc" id="L2982">            groupIndex = capturingGroupCount++;</span>
<span class="fc" id="L2983">        GroupHead head = new GroupHead(localIndex);</span>
<span class="fc" id="L2984">        root = new GroupTail(localIndex, groupIndex);</span>
<span class="fc bfc" id="L2985" title="All 4 branches covered.">        if (!anonymous &amp;&amp; groupIndex &lt; 10)</span>
<span class="fc" id="L2986">            groupNodes[groupIndex] = head;</span>
<span class="fc" id="L2987">        return head;</span>
    }

    @SuppressWarnings(&quot;fallthrough&quot;)
    /**
     * Parses inlined match flags and set them appropriately.
     */
    private void addFlag() {
<span class="fc" id="L2995">        int ch = peek();</span>
        for (;;) {
<span class="pc bpc" id="L2997" title="7 of 10 branches missed.">            switch (ch) {</span>
            case 'i':
<span class="nc" id="L2999">                flags |= CASE_INSENSITIVE;</span>
<span class="nc" id="L3000">                break;</span>
            case 'm':
<span class="fc" id="L3002">                flags |= MULTILINE;</span>
<span class="fc" id="L3003">                break;</span>
            case 's':
<span class="fc" id="L3005">                flags |= DOTALL;</span>
<span class="fc" id="L3006">                break;</span>
            case 'd':
<span class="nc" id="L3008">                flags |= UNIX_LINES;</span>
<span class="nc" id="L3009">                break;</span>
            case 'u':
<span class="nc" id="L3011">                flags |= UNICODE_CASE;</span>
<span class="nc" id="L3012">                break;</span>
            case 'c':
<span class="nc" id="L3014">                flags |= CANON_EQ;</span>
<span class="nc" id="L3015">                break;</span>
            case 'x':
<span class="nc" id="L3017">                flags |= COMMENTS;</span>
<span class="nc" id="L3018">                break;</span>
            case 'U':
<span class="nc" id="L3020">                flags |= (UNICODE_CHARACTER_CLASS | UNICODE_CASE);</span>
<span class="nc" id="L3021">                break;</span>
            case '-': // subFlag then fall through
<span class="nc" id="L3023">                ch = next();</span>
<span class="nc" id="L3024">                subFlag();</span>
            default:
<span class="fc" id="L3026">                return;</span>
            }
<span class="fc" id="L3028">            ch = next();</span>
        }
    }

    @SuppressWarnings(&quot;fallthrough&quot;)
    /**
     * Parses the second part of inlined match flags and turns off
     * flags appropriately.
     */
    private void subFlag() {
<span class="nc" id="L3038">        int ch = peek();</span>
        for (;;) {
<span class="nc bnc" id="L3040" title="All 9 branches missed.">            switch (ch) {</span>
            case 'i':
<span class="nc" id="L3042">                flags &amp;= ~CASE_INSENSITIVE;</span>
<span class="nc" id="L3043">                break;</span>
            case 'm':
<span class="nc" id="L3045">                flags &amp;= ~MULTILINE;</span>
<span class="nc" id="L3046">                break;</span>
            case 's':
<span class="nc" id="L3048">                flags &amp;= ~DOTALL;</span>
<span class="nc" id="L3049">                break;</span>
            case 'd':
<span class="nc" id="L3051">                flags &amp;= ~UNIX_LINES;</span>
<span class="nc" id="L3052">                break;</span>
            case 'u':
<span class="nc" id="L3054">                flags &amp;= ~UNICODE_CASE;</span>
<span class="nc" id="L3055">                break;</span>
            case 'c':
<span class="nc" id="L3057">                flags &amp;= ~CANON_EQ;</span>
<span class="nc" id="L3058">                break;</span>
            case 'x':
<span class="nc" id="L3060">                flags &amp;= ~COMMENTS;</span>
<span class="nc" id="L3061">                break;</span>
            case 'U':
<span class="nc" id="L3063">                flags &amp;= ~(UNICODE_CHARACTER_CLASS | UNICODE_CASE);</span>
            default:
<span class="nc" id="L3065">                return;</span>
            }
<span class="nc" id="L3067">            ch = next();</span>
        }
    }

    static final int MAX_REPS   = 0x7FFFFFFF;

    static final int GREEDY     = 0;

    static final int LAZY       = 1;

    static final int POSSESSIVE = 2;

    static final int INDEPENDENT = 3;

    /**
     * Processes repetition. If the next character peeked is a quantifier
     * then new nodes must be appended to handle the repetition.
     * Prev could be a single or a group, so it could be a chain of nodes.
     */
    private Node closure(Node prev) {
        Node atom;
<span class="fc" id="L3088">        int ch = peek();</span>
<span class="fc bfc" id="L3089" title="All 5 branches covered.">        switch (ch) {</span>
        case '?':
<span class="fc" id="L3091">            ch = next();</span>
<span class="pc bpc" id="L3092" title="1 of 2 branches missed.">            if (ch == '?') {</span>
<span class="nc" id="L3093">                next();</span>
<span class="nc" id="L3094">                return new Ques(prev, LAZY);</span>
<span class="pc bpc" id="L3095" title="1 of 2 branches missed.">            } else if (ch == '+') {</span>
<span class="nc" id="L3096">                next();</span>
<span class="nc" id="L3097">                return new Ques(prev, POSSESSIVE);</span>
            }
<span class="fc" id="L3099">            return new Ques(prev, GREEDY);</span>
        case '*':
<span class="fc" id="L3101">            ch = next();</span>
<span class="pc bpc" id="L3102" title="1 of 2 branches missed.">            if (ch == '?') {</span>
<span class="nc" id="L3103">                next();</span>
<span class="nc" id="L3104">                return new Curly(prev, 0, MAX_REPS, LAZY);</span>
<span class="pc bpc" id="L3105" title="1 of 2 branches missed.">            } else if (ch == '+') {</span>
<span class="nc" id="L3106">                next();</span>
<span class="nc" id="L3107">                return new Curly(prev, 0, MAX_REPS, POSSESSIVE);</span>
            }
<span class="fc" id="L3109">            return new Curly(prev, 0, MAX_REPS, GREEDY);</span>
        case '+':
<span class="fc" id="L3111">            ch = next();</span>
<span class="pc bpc" id="L3112" title="1 of 2 branches missed.">            if (ch == '?') {</span>
<span class="nc" id="L3113">                next();</span>
<span class="nc" id="L3114">                return new Curly(prev, 1, MAX_REPS, LAZY);</span>
<span class="pc bpc" id="L3115" title="1 of 2 branches missed.">            } else if (ch == '+') {</span>
<span class="nc" id="L3116">                next();</span>
<span class="nc" id="L3117">                return new Curly(prev, 1, MAX_REPS, POSSESSIVE);</span>
            }
<span class="fc" id="L3119">            return new Curly(prev, 1, MAX_REPS, GREEDY);</span>
        case '{':
<span class="fc" id="L3121">            ch = temp[cursor+1];</span>
<span class="pc bpc" id="L3122" title="1 of 2 branches missed.">            if (ASCII.isDigit(ch)) {</span>
<span class="fc" id="L3123">                skip();</span>
<span class="fc" id="L3124">                int cmin = 0;</span>
                do {
<span class="fc" id="L3126">                    cmin = cmin * 10 + (ch - '0');</span>
<span class="pc bpc" id="L3127" title="1 of 2 branches missed.">                } while (ASCII.isDigit(ch = read()));</span>
<span class="fc" id="L3128">                int cmax = cmin;</span>
<span class="fc bfc" id="L3129" title="All 2 branches covered.">                if (ch == ',') {</span>
<span class="fc" id="L3130">                    ch = read();</span>
<span class="fc" id="L3131">                    cmax = MAX_REPS;</span>
<span class="fc bfc" id="L3132" title="All 2 branches covered.">                    if (ch != '}') {</span>
<span class="fc" id="L3133">                        cmax = 0;</span>
<span class="fc bfc" id="L3134" title="All 2 branches covered.">                        while (ASCII.isDigit(ch)) {</span>
<span class="fc" id="L3135">                            cmax = cmax * 10 + (ch - '0');</span>
<span class="fc" id="L3136">                            ch = read();</span>
                        }
                    }
                }
<span class="pc bpc" id="L3140" title="1 of 2 branches missed.">                if (ch != '}')</span>
<span class="nc" id="L3141">                    throw error(&quot;Unclosed counted closure&quot;);</span>
<span class="pc bpc" id="L3142" title="1 of 2 branches missed.">                if (((cmin) | (cmax) | (cmax - cmin)) &lt; 0)</span>
<span class="nc" id="L3143">                    throw error(&quot;Illegal repetition range&quot;);</span>
                Curly curly;
<span class="fc" id="L3145">                ch = peek();</span>
<span class="pc bpc" id="L3146" title="1 of 2 branches missed.">                if (ch == '?') {</span>
<span class="nc" id="L3147">                    next();</span>
<span class="nc" id="L3148">                    curly = new Curly(prev, cmin, cmax, LAZY);</span>
<span class="pc bpc" id="L3149" title="1 of 2 branches missed.">                } else if (ch == '+') {</span>
<span class="nc" id="L3150">                    next();</span>
<span class="nc" id="L3151">                    curly = new Curly(prev, cmin, cmax, POSSESSIVE);</span>
                } else {
<span class="fc" id="L3153">                    curly = new Curly(prev, cmin, cmax, GREEDY);</span>
                }
<span class="fc" id="L3155">                return curly;</span>
            } else {
<span class="nc" id="L3157">                throw error(&quot;Illegal repetition&quot;);</span>
            }
        default:
<span class="fc" id="L3160">            return prev;</span>
        }
    }

    /**
     *  Utility method for parsing control escape sequences.
     */
    private int c() {
<span class="nc bnc" id="L3168" title="All 2 branches missed.">        if (cursor &lt; patternLength) {</span>
<span class="nc" id="L3169">            return read() ^ 64;</span>
        }
<span class="nc" id="L3171">        throw error(&quot;Illegal control escape sequence&quot;);</span>
    }

    /**
     *  Utility method for parsing octal escape sequences.
     */
    private int o() {
<span class="nc" id="L3178">        int n = read();</span>
<span class="nc bnc" id="L3179" title="All 2 branches missed.">        if (((n-'0')|('7'-n)) &gt;= 0) {</span>
<span class="nc" id="L3180">            int m = read();</span>
<span class="nc bnc" id="L3181" title="All 2 branches missed.">            if (((m-'0')|('7'-m)) &gt;= 0) {</span>
<span class="nc" id="L3182">                int o = read();</span>
<span class="nc bnc" id="L3183" title="All 4 branches missed.">                if ((((o-'0')|('7'-o)) &gt;= 0) &amp;&amp; (((n-'0')|('3'-n)) &gt;= 0)) {</span>
<span class="nc" id="L3184">                    return (n - '0') * 64 + (m - '0') * 8 + (o - '0');</span>
                }
<span class="nc" id="L3186">                unread();</span>
<span class="nc" id="L3187">                return (n - '0') * 8 + (m - '0');</span>
            }
<span class="nc" id="L3189">            unread();</span>
<span class="nc" id="L3190">            return (n - '0');</span>
        }
<span class="nc" id="L3192">        throw error(&quot;Illegal octal escape sequence&quot;);</span>
    }

    /**
     *  Utility method for parsing hexadecimal escape sequences.
     */
    private int x() {
<span class="fc" id="L3199">        int n = read();</span>
<span class="pc bpc" id="L3200" title="1 of 2 branches missed.">        if (ASCII.isHexDigit(n)) {</span>
<span class="fc" id="L3201">            int m = read();</span>
<span class="pc bpc" id="L3202" title="1 of 2 branches missed.">            if (ASCII.isHexDigit(m)) {</span>
<span class="fc" id="L3203">                return ASCII.toDigit(n) * 16 + ASCII.toDigit(m);</span>
            }
<span class="nc bnc" id="L3205" title="All 4 branches missed.">        } else if (n == '{' &amp;&amp; ASCII.isHexDigit(peek())) {</span>
<span class="nc" id="L3206">            int ch = 0;</span>
<span class="nc bnc" id="L3207" title="All 2 branches missed.">            while (ASCII.isHexDigit(n = read())) {</span>
<span class="nc" id="L3208">                ch = (ch &lt;&lt; 4) + ASCII.toDigit(n);</span>
<span class="nc bnc" id="L3209" title="All 2 branches missed.">                if (ch &gt; Character.MAX_CODE_POINT)</span>
<span class="nc" id="L3210">                    throw error(&quot;Hexadecimal codepoint is too big&quot;);</span>
            }
<span class="nc bnc" id="L3212" title="All 2 branches missed.">            if (n != '}')</span>
<span class="nc" id="L3213">                throw error(&quot;Unclosed hexadecimal escape sequence&quot;);</span>
<span class="nc" id="L3214">            return ch;</span>
        }
<span class="nc" id="L3216">        throw error(&quot;Illegal hexadecimal escape sequence&quot;);</span>
    }

    /**
     *  Utility method for parsing unicode escape sequences.
     */
    private int cursor() {
<span class="nc" id="L3223">        return cursor;</span>
    }

    private void setcursor(int pos) {
<span class="nc" id="L3227">        cursor = pos;</span>
<span class="nc" id="L3228">    }</span>

    private int uxxxx() {
<span class="fc" id="L3231">        int n = 0;</span>
<span class="fc bfc" id="L3232" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc" id="L3233">            int ch = read();</span>
<span class="pc bpc" id="L3234" title="1 of 2 branches missed.">            if (!ASCII.isHexDigit(ch)) {</span>
<span class="nc" id="L3235">                throw error(&quot;Illegal Unicode escape sequence&quot;);</span>
            }
<span class="fc" id="L3237">            n = n * 16 + ASCII.toDigit(ch);</span>
        }
<span class="fc" id="L3239">        return n;</span>
    }

    private int u() {
<span class="fc" id="L3243">        int n = uxxxx();</span>
<span class="pc bpc" id="L3244" title="1 of 2 branches missed.">        if (Character.isHighSurrogate((char)n)) {</span>
<span class="nc" id="L3245">            int cur = cursor();</span>
<span class="nc bnc" id="L3246" title="All 4 branches missed.">            if (read() == '\\' &amp;&amp; read() == 'u') {</span>
<span class="nc" id="L3247">                int n2 = uxxxx();</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">                if (Character.isLowSurrogate((char)n2))</span>
<span class="nc" id="L3249">                    return Character.toCodePoint((char)n, (char)n2);</span>
            }
<span class="nc" id="L3251">            setcursor(cur);</span>
        }
<span class="fc" id="L3253">        return n;</span>
    }

    //
    // Utility methods for code point support
    //

    private static final int countChars(CharSequence seq, int index,
                                        int lengthInCodePoints) {
        // optimization
<span class="nc bnc" id="L3263" title="All 4 branches missed.">        if (lengthInCodePoints == 1 &amp;&amp; !Character.isHighSurrogate(seq.charAt(index))) {</span>
<span class="nc bnc" id="L3264" title="All 6 branches missed.">            assert (index &gt;= 0 &amp;&amp; index &lt; seq.length());</span>
<span class="nc" id="L3265">            return 1;</span>
        }
<span class="nc" id="L3267">        int length = seq.length();</span>
<span class="nc" id="L3268">        int x = index;</span>
<span class="nc bnc" id="L3269" title="All 2 branches missed.">        if (lengthInCodePoints &gt;= 0) {</span>
<span class="nc bnc" id="L3270" title="All 6 branches missed.">            assert (index &gt;= 0 &amp;&amp; index &lt; length);</span>
<span class="nc bnc" id="L3271" title="All 4 branches missed.">            for (int i = 0; x &lt; length &amp;&amp; i &lt; lengthInCodePoints; i++) {</span>
<span class="nc bnc" id="L3272" title="All 2 branches missed.">                if (Character.isHighSurrogate(seq.charAt(x++))) {</span>
<span class="nc bnc" id="L3273" title="All 4 branches missed.">                    if (x &lt; length &amp;&amp; Character.isLowSurrogate(seq.charAt(x))) {</span>
<span class="nc" id="L3274">                        x++;</span>
                    }
                }
            }
<span class="nc" id="L3278">            return x - index;</span>
        }

<span class="nc bnc" id="L3281" title="All 6 branches missed.">        assert (index &gt;= 0 &amp;&amp; index &lt;= length);</span>
<span class="nc bnc" id="L3282" title="All 2 branches missed.">        if (index == 0) {</span>
<span class="nc" id="L3283">            return 0;</span>
        }
<span class="nc" id="L3285">        int len = -lengthInCodePoints;</span>
<span class="nc bnc" id="L3286" title="All 4 branches missed.">        for (int i = 0; x &gt; 0 &amp;&amp; i &lt; len; i++) {</span>
<span class="nc bnc" id="L3287" title="All 2 branches missed.">            if (Character.isLowSurrogate(seq.charAt(--x))) {</span>
<span class="nc bnc" id="L3288" title="All 4 branches missed.">                if (x &gt; 0 &amp;&amp; Character.isHighSurrogate(seq.charAt(x-1))) {</span>
<span class="nc" id="L3289">                    x--;</span>
                }
            }
        }
<span class="nc" id="L3293">        return index - x;</span>
    }

    private static final int countCodePoints(CharSequence seq) {
<span class="nc" id="L3297">        int length = seq.length();</span>
<span class="nc" id="L3298">        int n = 0;</span>
<span class="nc bnc" id="L3299" title="All 2 branches missed.">        for (int i = 0; i &lt; length; ) {</span>
<span class="nc" id="L3300">            n++;</span>
<span class="nc bnc" id="L3301" title="All 2 branches missed.">            if (Character.isHighSurrogate(seq.charAt(i++))) {</span>
<span class="nc bnc" id="L3302" title="All 4 branches missed.">                if (i &lt; length &amp;&amp; Character.isLowSurrogate(seq.charAt(i))) {</span>
<span class="nc" id="L3303">                    i++;</span>
                }
            }
        }
<span class="nc" id="L3307">        return n;</span>
    }

    /**
     *  Creates a bit vector for matching Latin-1 values. A normal BitClass
     *  never matches values above Latin-1, and a complemented BitClass always
     *  matches values above Latin-1.
     */
<span class="fc bfc" id="L3315" title="All 2 branches covered.">    private static final class BitClass extends BmpCharProperty {</span>
        final boolean[] bits;
<span class="fc" id="L3317">        BitClass() { bits = new boolean[256]; }</span>
<span class="nc" id="L3318">        private BitClass(boolean[] bits) { this.bits = bits; }</span>
        BitClass add(int c, int flags) {
<span class="pc bpc" id="L3320" title="2 of 6 branches missed.">            assert c &gt;= 0 &amp;&amp; c &lt;= 255;</span>
<span class="fc bfc" id="L3321" title="All 2 branches covered.">            if ((flags &amp; CASE_INSENSITIVE) != 0) {</span>
<span class="pc bpc" id="L3322" title="1 of 2 branches missed.">                if (ASCII.isAscii(c)) {</span>
<span class="fc" id="L3323">                    bits[ASCII.toUpper(c)] = true;</span>
<span class="fc" id="L3324">                    bits[ASCII.toLower(c)] = true;</span>
<span class="nc bnc" id="L3325" title="All 2 branches missed.">                } else if ((flags &amp; UNICODE_CASE) != 0) {</span>
<span class="nc" id="L3326">                    bits[Character.toLowerCase(c)] = true;</span>
<span class="nc" id="L3327">                    bits[Character.toUpperCase(c)] = true;</span>
                }
            }
<span class="fc" id="L3330">            bits[c] = true;</span>
<span class="fc" id="L3331">            return this;</span>
        }
        boolean isSatisfiedBy(int ch) {
<span class="fc bfc" id="L3334" title="All 4 branches covered.">            return ch &lt; 256 &amp;&amp; bits[ch];</span>
        }
    }

    /**
     *  Returns a suitably optimized, single character matcher.
     */
    private CharProperty newSingle(final int ch) {
<span class="fc bfc" id="L3342" title="All 2 branches covered.">        if (has(CASE_INSENSITIVE)) {</span>
            int lower, upper;
<span class="pc bpc" id="L3344" title="1 of 2 branches missed.">            if (has(UNICODE_CASE)) {</span>
<span class="nc" id="L3345">                upper = Character.toUpperCase(ch);</span>
<span class="nc" id="L3346">                lower = Character.toLowerCase(upper);</span>
<span class="nc bnc" id="L3347" title="All 2 branches missed.">                if (upper != lower)</span>
<span class="nc" id="L3348">                    return new SingleU(lower);</span>
<span class="pc bpc" id="L3349" title="1 of 2 branches missed.">            } else if (ASCII.isAscii(ch)) {</span>
<span class="fc" id="L3350">                lower = ASCII.toLower(ch);</span>
<span class="fc" id="L3351">                upper = ASCII.toUpper(ch);</span>
<span class="pc bpc" id="L3352" title="1 of 2 branches missed.">                if (lower != upper)</span>
<span class="fc" id="L3353">                    return new SingleI(lower, upper);</span>
            }
        }
<span class="pc bpc" id="L3356" title="1 of 2 branches missed.">        if (isSupplementary(ch))</span>
<span class="nc" id="L3357">            return new SingleS(ch);    // Match a given Unicode character</span>
<span class="fc" id="L3358">        return new Single(ch);         // Match a given BMP character</span>
    }

    /**
     *  Utility method for creating a string slice matcher.
     */
    private Node newSlice(int[] buf, int count, boolean hasSupplementary) {
<span class="fc" id="L3365">        int[] tmp = new int[count];</span>
<span class="fc bfc" id="L3366" title="All 2 branches covered.">        if (has(CASE_INSENSITIVE)) {</span>
<span class="pc bpc" id="L3367" title="1 of 2 branches missed.">            if (has(UNICODE_CASE)) {</span>
<span class="nc bnc" id="L3368" title="All 2 branches missed.">                for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L3369">                    tmp[i] = Character.toLowerCase(</span>
<span class="nc" id="L3370">                                 Character.toUpperCase(buf[i]));</span>
                }
<span class="nc bnc" id="L3372" title="All 2 branches missed.">                return hasSupplementary? new SliceUS(tmp) : new SliceU(tmp);</span>
            }
<span class="fc bfc" id="L3374" title="All 2 branches covered.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L3375">                tmp[i] = ASCII.toLower(buf[i]);</span>
            }
<span class="pc bpc" id="L3377" title="1 of 2 branches missed.">            return hasSupplementary? new SliceIS(tmp) : new SliceI(tmp);</span>
        }
<span class="fc bfc" id="L3379" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L3380">            tmp[i] = buf[i];</span>
        }
<span class="pc bpc" id="L3382" title="1 of 2 branches missed.">        return hasSupplementary ? new SliceS(tmp) : new Slice(tmp);</span>
    }

    /**
     * The following classes are the building components of the object
     * tree that represents a compiled regular expression. The object tree
     * is made of individual elements that handle constructs in the Pattern.
     * Each type of object knows how to match its equivalent construct with
     * the match() method.
     */

    /**
     * Base class for all node classes. Subclasses should override the match()
     * method as appropriate. This class is an accepting node, so its match()
     * always returns true.
     */
    static class Node extends Object {
        Node next;
<span class="fc" id="L3400">        Node() {</span>
<span class="fc" id="L3401">            next = Pattern.accept;</span>
<span class="fc" id="L3402">        }</span>
        /**
         * This method implements the classic accept node.
         */
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc" id="L3407">            matcher.last = i;</span>
<span class="fc" id="L3408">            matcher.groups[0] = matcher.first;</span>
<span class="fc" id="L3409">            matcher.groups[1] = matcher.last;</span>
<span class="fc" id="L3410">            return true;</span>
        }
        /**
         * This method is good for all zero length assertions.
         */
        boolean study(TreeInfo info) {
<span class="fc bfc" id="L3416" title="All 2 branches covered.">            if (next != null) {</span>
<span class="fc" id="L3417">                return next.study(info);</span>
            } else {
<span class="fc" id="L3419">                return info.deterministic;</span>
            }
        }
    }

<span class="fc" id="L3424">    static class LastNode extends Node {</span>
        /**
         * This method implements the classic accept node with
         * the addition of a check to see if the match occurred
         * using all of the input.
         */
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc bfc" id="L3431" title="All 4 branches covered.">            if (matcher.acceptMode == Matcher.ENDANCHOR &amp;&amp; i != matcher.to)</span>
<span class="fc" id="L3432">                return false;</span>
<span class="fc" id="L3433">            matcher.last = i;</span>
<span class="fc" id="L3434">            matcher.groups[0] = matcher.first;</span>
<span class="fc" id="L3435">            matcher.groups[1] = matcher.last;</span>
<span class="fc" id="L3436">            return true;</span>
        }
    }

    /**
     * Used for REs that can start anywhere within the input string.
     * This basically tries to match repeatedly at each spot in the
     * input string, moving forward after each try. An anchored search
     * or a BnM will bypass this node completely.
     */
    static class Start extends Node {
        int minLength;
<span class="fc" id="L3448">        Start(Node node) {</span>
<span class="fc" id="L3449">            this.next = node;</span>
<span class="fc" id="L3450">            TreeInfo info = new TreeInfo();</span>
<span class="fc" id="L3451">            next.study(info);</span>
<span class="fc" id="L3452">            minLength = info.minLength;</span>
<span class="fc" id="L3453">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc bfc" id="L3455" title="All 2 branches covered.">            if (i &gt; matcher.to - minLength) {</span>
<span class="fc" id="L3456">                matcher.hitEnd = true;</span>
<span class="fc" id="L3457">                return false;</span>
            }
<span class="fc" id="L3459">            int guard = matcher.to - minLength;</span>
<span class="fc bfc" id="L3460" title="All 2 branches covered.">            for (; i &lt;= guard; i++) {</span>
<span class="fc bfc" id="L3461" title="All 2 branches covered.">                if (next.match(matcher, i, seq)) {</span>
<span class="fc" id="L3462">                    matcher.first = i;</span>
<span class="fc" id="L3463">                    matcher.groups[0] = matcher.first;</span>
<span class="fc" id="L3464">                    matcher.groups[1] = matcher.last;</span>
<span class="fc" id="L3465">                    return true;</span>
                }
            }
<span class="fc" id="L3468">            matcher.hitEnd = true;</span>
<span class="fc" id="L3469">            return false;</span>
        }
        boolean study(TreeInfo info) {
<span class="nc" id="L3472">            next.study(info);</span>
<span class="nc" id="L3473">            info.maxValid = false;</span>
<span class="nc" id="L3474">            info.deterministic = false;</span>
<span class="nc" id="L3475">            return false;</span>
        }
    }

    /*
     * StartS supports supplementary characters, including unpaired surrogates.
     */
    static final class StartS extends Start {
        StartS(Node node) {
<span class="fc" id="L3484">            super(node);</span>
<span class="fc" id="L3485">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="pc bpc" id="L3487" title="1 of 2 branches missed.">            if (i &gt; matcher.to - minLength) {</span>
<span class="nc" id="L3488">                matcher.hitEnd = true;</span>
<span class="nc" id="L3489">                return false;</span>
            }
<span class="fc" id="L3491">            int guard = matcher.to - minLength;</span>
<span class="pc bpc" id="L3492" title="1 of 2 branches missed.">            while (i &lt;= guard) {</span>
                //if ((ret = next.match(matcher, i, seq)) || i == guard)
<span class="pc bpc" id="L3494" title="1 of 2 branches missed.">                if (next.match(matcher, i, seq)) {</span>
<span class="nc" id="L3495">                    matcher.first = i;</span>
<span class="nc" id="L3496">                    matcher.groups[0] = matcher.first;</span>
<span class="nc" id="L3497">                    matcher.groups[1] = matcher.last;</span>
<span class="nc" id="L3498">                    return true;</span>
                }
<span class="fc bfc" id="L3500" title="All 2 branches covered.">                if (i == guard)</span>
<span class="fc" id="L3501">                    break;</span>
                // Optimization to move to the next character. This is
                // faster than countChars(seq, i, 1).
<span class="pc bpc" id="L3504" title="1 of 2 branches missed.">                if (Character.isHighSurrogate(seq.charAt(i++))) {</span>
<span class="nc bnc" id="L3505" title="All 2 branches missed.">                    if (i &lt; seq.length() &amp;&amp;</span>
<span class="nc bnc" id="L3506" title="All 2 branches missed.">                        Character.isLowSurrogate(seq.charAt(i))) {</span>
<span class="nc" id="L3507">                        i++;</span>
                    }
                }
            }
<span class="fc" id="L3511">            matcher.hitEnd = true;</span>
<span class="fc" id="L3512">            return false;</span>
        }
    }

    /**
     * Node to anchor at the beginning of input. This object implements the
     * match for a \A sequence, and the caret anchor will use this if not in
     * multiline mode.
     */
<span class="fc" id="L3521">    static final class Begin extends Node {</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="pc bpc" id="L3523" title="1 of 2 branches missed.">            int fromIndex = (matcher.anchoringBounds) ?</span>
                matcher.from : 0;
<span class="pc bpc" id="L3525" title="1 of 4 branches missed.">            if (i == fromIndex &amp;&amp; next.match(matcher, i, seq)) {</span>
<span class="fc" id="L3526">                matcher.first = i;</span>
<span class="fc" id="L3527">                matcher.groups[0] = i;</span>
<span class="fc" id="L3528">                matcher.groups[1] = matcher.last;</span>
<span class="fc" id="L3529">                return true;</span>
            } else {
<span class="fc" id="L3531">                return false;</span>
            }
        }
    }

    /**
     * Node to anchor at the end of input. This is the absolute end, so this
     * should not match at the last newline before the end as $ will.
     */
<span class="nc" id="L3540">    static final class End extends Node {</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc bnc" id="L3542" title="All 2 branches missed.">            int endIndex = (matcher.anchoringBounds) ?</span>
<span class="nc" id="L3543">                matcher.to : matcher.getTextLength();</span>
<span class="nc bnc" id="L3544" title="All 2 branches missed.">            if (i == endIndex) {</span>
<span class="nc" id="L3545">                matcher.hitEnd = true;</span>
<span class="nc" id="L3546">                return next.match(matcher, i, seq);</span>
            }
<span class="nc" id="L3548">            return false;</span>
        }
    }

    /**
     * Node to anchor at the beginning of a line. This is essentially the
     * object to match for the multiline ^.
     */
<span class="fc" id="L3556">    static final class Caret extends Node {</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc" id="L3558">            int startIndex = matcher.from;</span>
<span class="fc" id="L3559">            int endIndex = matcher.to;</span>
<span class="pc bpc" id="L3560" title="1 of 2 branches missed.">            if (!matcher.anchoringBounds) {</span>
<span class="nc" id="L3561">                startIndex = 0;</span>
<span class="nc" id="L3562">                endIndex = matcher.getTextLength();</span>
            }
            // Perl does not match ^ at end of input even after newline
<span class="pc bpc" id="L3565" title="1 of 2 branches missed.">            if (i == endIndex) {</span>
<span class="nc" id="L3566">                matcher.hitEnd = true;</span>
<span class="nc" id="L3567">                return false;</span>
            }
<span class="fc bfc" id="L3569" title="All 2 branches covered.">            if (i &gt; startIndex) {</span>
<span class="fc" id="L3570">                char ch = seq.charAt(i-1);</span>
<span class="pc bpc" id="L3571" title="3 of 8 branches missed.">                if (ch != '\n' &amp;&amp; ch != '\r'</span>
                    &amp;&amp; (ch|1) != '\u2029'
                    &amp;&amp; ch != '\u0085' ) {
<span class="fc" id="L3574">                    return false;</span>
                }
                // Should treat /r/n as one newline
<span class="pc bpc" id="L3577" title="3 of 4 branches missed.">                if (ch == '\r' &amp;&amp; seq.charAt(i) == '\n')</span>
<span class="nc" id="L3578">                    return false;</span>
            }
<span class="fc" id="L3580">            return next.match(matcher, i, seq);</span>
        }
    }

    /**
     * Node to anchor at the beginning of a line when in unixdot mode.
     */
<span class="nc" id="L3587">    static final class UnixCaret extends Node {</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L3589">            int startIndex = matcher.from;</span>
<span class="nc" id="L3590">            int endIndex = matcher.to;</span>
<span class="nc bnc" id="L3591" title="All 2 branches missed.">            if (!matcher.anchoringBounds) {</span>
<span class="nc" id="L3592">                startIndex = 0;</span>
<span class="nc" id="L3593">                endIndex = matcher.getTextLength();</span>
            }
            // Perl does not match ^ at end of input even after newline
<span class="nc bnc" id="L3596" title="All 2 branches missed.">            if (i == endIndex) {</span>
<span class="nc" id="L3597">                matcher.hitEnd = true;</span>
<span class="nc" id="L3598">                return false;</span>
            }
<span class="nc bnc" id="L3600" title="All 2 branches missed.">            if (i &gt; startIndex) {</span>
<span class="nc" id="L3601">                char ch = seq.charAt(i-1);</span>
<span class="nc bnc" id="L3602" title="All 2 branches missed.">                if (ch != '\n') {</span>
<span class="nc" id="L3603">                    return false;</span>
                }
            }
<span class="nc" id="L3606">            return next.match(matcher, i, seq);</span>
        }
    }

    /**
     * Node to match the location where the last match ended.
     * This is used for the \G construct.
     */
<span class="nc" id="L3614">    static final class LastMatch extends Node {</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc bnc" id="L3616" title="All 2 branches missed.">            if (i != matcher.oldLast)</span>
<span class="nc" id="L3617">                return false;</span>
<span class="nc" id="L3618">            return next.match(matcher, i, seq);</span>
        }
    }

    /**
     * Node to anchor at the end of a line or the end of input based on the
     * multiline mode.
     *
     * When not in multiline mode, the $ can only match at the very end
     * of the input, unless the input ends in a line terminator in which
     * it matches right before the last line terminator.
     *
     * Note that \r\n is considered an atomic line terminator.
     *
     * Like ^ the $ operator matches at a position, it does not match the
     * line terminators themselves.
     */
    static final class Dollar extends Node {
        boolean multiline;
<span class="fc" id="L3637">        Dollar(boolean mul) {</span>
<span class="fc" id="L3638">            multiline = mul;</span>
<span class="fc" id="L3639">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="pc bpc" id="L3641" title="1 of 2 branches missed.">            int endIndex = (matcher.anchoringBounds) ?</span>
<span class="pc" id="L3642">                matcher.to : matcher.getTextLength();</span>
<span class="fc bfc" id="L3643" title="All 2 branches covered.">            if (!multiline) {</span>
<span class="fc bfc" id="L3644" title="All 2 branches covered.">                if (i &lt; endIndex - 2)</span>
<span class="fc" id="L3645">                    return false;</span>
<span class="fc bfc" id="L3646" title="All 2 branches covered.">                if (i == endIndex - 2) {</span>
<span class="fc" id="L3647">                    char ch = seq.charAt(i);</span>
<span class="pc bpc" id="L3648" title="1 of 2 branches missed.">                    if (ch != '\r')</span>
<span class="fc" id="L3649">                        return false;</span>
<span class="nc" id="L3650">                    ch = seq.charAt(i + 1);</span>
<span class="nc bnc" id="L3651" title="All 2 branches missed.">                    if (ch != '\n')</span>
<span class="nc" id="L3652">                        return false;</span>
                }
            }
            // Matches before any line terminator; also matches at the
            // end of input
            // Before line terminator:
            // If multiline, we match here no matter what
            // If not multiline, fall through so that the end
            // is marked as hit; this must be a /r/n or a /n
            // at the very end so the end was hit; more input
            // could make this not match here
<span class="fc bfc" id="L3663" title="All 2 branches covered.">            if (i &lt; endIndex) {</span>
<span class="fc" id="L3664">                char ch = seq.charAt(i);</span>
<span class="fc bfc" id="L3665" title="All 2 branches covered.">                 if (ch == '\n') {</span>
                     // No match between \r\n
<span class="pc bpc" id="L3667" title="2 of 4 branches missed.">                     if (i &gt; 0 &amp;&amp; seq.charAt(i-1) == '\r')</span>
<span class="nc" id="L3668">                         return false;</span>
<span class="pc bpc" id="L3669" title="1 of 2 branches missed.">                     if (multiline)</span>
<span class="fc" id="L3670">                         return next.match(matcher, i, seq);</span>
<span class="pc bpc" id="L3671" title="3 of 6 branches missed.">                 } else if (ch == '\r' || ch == '\u0085' ||</span>
                            (ch|1) == '\u2029') {
<span class="nc bnc" id="L3673" title="All 2 branches missed.">                     if (multiline)</span>
<span class="nc" id="L3674">                         return next.match(matcher, i, seq);</span>
                 } else { // No line terminator, no match
<span class="fc" id="L3676">                     return false;</span>
                 }
            }
            // Matched at current end so hit end
<span class="fc" id="L3680">            matcher.hitEnd = true;</span>
            // If a $ matches because of end of input, then more input
            // could cause it to fail!
<span class="fc" id="L3683">            matcher.requireEnd = true;</span>
<span class="fc" id="L3684">            return next.match(matcher, i, seq);</span>
        }
        boolean study(TreeInfo info) {
<span class="fc" id="L3687">            next.study(info);</span>
<span class="fc" id="L3688">            return info.deterministic;</span>
        }
    }

    /**
     * Node to anchor at the end of a line or the end of input based on the
     * multiline mode when in unix lines mode.
     */
    static final class UnixDollar extends Node {
        boolean multiline;
<span class="nc" id="L3698">        UnixDollar(boolean mul) {</span>
<span class="nc" id="L3699">            multiline = mul;</span>
<span class="nc" id="L3700">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc bnc" id="L3702" title="All 2 branches missed.">            int endIndex = (matcher.anchoringBounds) ?</span>
<span class="nc" id="L3703">                matcher.to : matcher.getTextLength();</span>
<span class="nc bnc" id="L3704" title="All 2 branches missed.">            if (i &lt; endIndex) {</span>
<span class="nc" id="L3705">                char ch = seq.charAt(i);</span>
<span class="nc bnc" id="L3706" title="All 2 branches missed.">                if (ch == '\n') {</span>
                    // If not multiline, then only possible to
                    // match at very end or one before end
<span class="nc bnc" id="L3709" title="All 4 branches missed.">                    if (multiline == false &amp;&amp; i != endIndex - 1)</span>
<span class="nc" id="L3710">                        return false;</span>
                    // If multiline return next.match without setting
                    // matcher.hitEnd
<span class="nc bnc" id="L3713" title="All 2 branches missed.">                    if (multiline)</span>
<span class="nc" id="L3714">                        return next.match(matcher, i, seq);</span>
                } else {
<span class="nc" id="L3716">                    return false;</span>
                }
            }
            // Matching because at the end or 1 before the end;
            // more input could change this so set hitEnd
<span class="nc" id="L3721">            matcher.hitEnd = true;</span>
            // If a $ matches because of end of input, then more input
            // could cause it to fail!
<span class="nc" id="L3724">            matcher.requireEnd = true;</span>
<span class="nc" id="L3725">            return next.match(matcher, i, seq);</span>
        }
        boolean study(TreeInfo info) {
<span class="nc" id="L3728">            next.study(info);</span>
<span class="nc" id="L3729">            return info.deterministic;</span>
        }
    }

    /**
     * Node class that matches a Unicode line ending '\R'
     */
<span class="nc" id="L3736">    static final class LineEnding extends Node {</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
            // (u+000Du+000A|[u+000Au+000Bu+000Cu+000Du+0085u+2028u+2029])
<span class="nc bnc" id="L3739" title="All 2 branches missed.">            if (i &lt; matcher.to) {</span>
<span class="nc" id="L3740">                int ch = seq.charAt(i);</span>
<span class="nc bnc" id="L3741" title="All 12 branches missed.">                if (ch == 0x0A || ch == 0x0B || ch == 0x0C ||</span>
                    ch == 0x85 || ch == 0x2028 || ch == 0x2029)
<span class="nc" id="L3743">                    return next.match(matcher, i + 1, seq);</span>
<span class="nc bnc" id="L3744" title="All 2 branches missed.">                if (ch == 0x0D) {</span>
<span class="nc" id="L3745">                    i++;</span>
<span class="nc bnc" id="L3746" title="All 4 branches missed.">                    if (i &lt; matcher.to &amp;&amp; seq.charAt(i) == 0x0A)</span>
<span class="nc" id="L3747">                        i++;</span>
<span class="nc" id="L3748">                    return next.match(matcher, i, seq);</span>
                }
<span class="nc" id="L3750">            } else {</span>
<span class="nc" id="L3751">                matcher.hitEnd = true;</span>
            }
<span class="nc" id="L3753">            return false;</span>
        }
        boolean study(TreeInfo info) {
<span class="nc" id="L3756">            info.minLength++;</span>
<span class="nc" id="L3757">            info.maxLength += 2;</span>
<span class="nc" id="L3758">            return next.study(info);</span>
        }
    }

    /**
     * Abstract node class to match one character satisfying some
     * boolean property.
     */
<span class="fc" id="L3766">    private static abstract class CharProperty extends Node {</span>
        abstract boolean isSatisfiedBy(int ch);
        CharProperty complement() {
<span class="fc" id="L3769">            return new CharProperty() {</span>
                    boolean isSatisfiedBy(int ch) {
<span class="fc bfc" id="L3771" title="All 2 branches covered.">                        return ! CharProperty.this.isSatisfiedBy(ch);}};</span>
        }
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc bfc" id="L3774" title="All 2 branches covered.">            if (i &lt; matcher.to) {</span>
<span class="fc" id="L3775">                int ch = Character.codePointAt(seq, i);</span>
<span class="fc bfc" id="L3776" title="All 2 branches covered.">                return isSatisfiedBy(ch)</span>
<span class="fc bfc" id="L3777" title="All 2 branches covered.">                    &amp;&amp; next.match(matcher, i+Character.charCount(ch), seq);</span>
            } else {
<span class="fc" id="L3779">                matcher.hitEnd = true;</span>
<span class="fc" id="L3780">                return false;</span>
            }
        }
        boolean study(TreeInfo info) {
<span class="fc" id="L3784">            info.minLength++;</span>
<span class="fc" id="L3785">            info.maxLength++;</span>
<span class="fc" id="L3786">            return next.study(info);</span>
        }
    }

    /**
     * Optimized version of CharProperty that works only for
     * properties never satisfied by Supplementary characters.
     */
<span class="fc" id="L3794">    private static abstract class BmpCharProperty extends CharProperty {</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc bfc" id="L3796" title="All 2 branches covered.">            if (i &lt; matcher.to) {</span>
<span class="fc bfc" id="L3797" title="All 2 branches covered.">                return isSatisfiedBy(seq.charAt(i))</span>
<span class="fc bfc" id="L3798" title="All 2 branches covered.">                    &amp;&amp; next.match(matcher, i+1, seq);</span>
            } else {
<span class="fc" id="L3800">                matcher.hitEnd = true;</span>
<span class="fc" id="L3801">                return false;</span>
            }
        }
    }

    /**
     * Node class that matches a Supplementary Unicode character
     */
    static final class SingleS extends CharProperty {
        final int c;
<span class="nc" id="L3811">        SingleS(int c) { this.c = c; }</span>
        boolean isSatisfiedBy(int ch) {
<span class="nc bnc" id="L3813" title="All 2 branches missed.">            return ch == c;</span>
        }
    }

    /**
     * Optimization -- matches a given BMP character
     */
    static final class Single extends BmpCharProperty {
        final int c;
<span class="fc" id="L3822">        Single(int c) { this.c = c; }</span>
        boolean isSatisfiedBy(int ch) {
<span class="fc bfc" id="L3824" title="All 2 branches covered.">            return ch == c;</span>
        }
    }

    /**
     * Case insensitive matches a given BMP character
     */
    static final class SingleI extends BmpCharProperty {
        final int lower;
        final int upper;
<span class="fc" id="L3834">        SingleI(int lower, int upper) {</span>
<span class="fc" id="L3835">            this.lower = lower;</span>
<span class="fc" id="L3836">            this.upper = upper;</span>
<span class="fc" id="L3837">        }</span>
        boolean isSatisfiedBy(int ch) {
<span class="nc bnc" id="L3839" title="All 4 branches missed.">            return ch == lower || ch == upper;</span>
        }
    }

    /**
     * Unicode case insensitive matches a given Unicode character
     */
    static final class SingleU extends CharProperty {
        final int lower;
<span class="nc" id="L3848">        SingleU(int lower) {</span>
<span class="nc" id="L3849">            this.lower = lower;</span>
<span class="nc" id="L3850">        }</span>
        boolean isSatisfiedBy(int ch) {
<span class="nc bnc" id="L3852" title="All 2 branches missed.">            return lower == ch ||</span>
<span class="nc bnc" id="L3853" title="All 2 branches missed.">                lower == Character.toLowerCase(Character.toUpperCase(ch));</span>
        }
    }

    /**
     * Node class that matches a Unicode block.
     */
    static final class Block extends CharProperty {
        final Character.UnicodeBlock block;
<span class="nc" id="L3862">        Block(Character.UnicodeBlock block) {</span>
<span class="nc" id="L3863">            this.block = block;</span>
<span class="nc" id="L3864">        }</span>
        boolean isSatisfiedBy(int ch) {
<span class="nc bnc" id="L3866" title="All 2 branches missed.">            return block == Character.UnicodeBlock.of(ch);</span>
        }
    }

    /**
     * Node class that matches a Unicode script
     */
    static final class Script extends CharProperty {
        final Character.UnicodeScript script;
<span class="nc" id="L3875">        Script(Character.UnicodeScript script) {</span>
<span class="nc" id="L3876">            this.script = script;</span>
<span class="nc" id="L3877">        }</span>
        boolean isSatisfiedBy(int ch) {
<span class="nc bnc" id="L3879" title="All 2 branches missed.">            return script == Character.UnicodeScript.of(ch);</span>
        }
    }

    /**
     * Node class that matches a Unicode category.
     */
    static final class Category extends CharProperty {
        final int typeMask;
<span class="nc" id="L3888">        Category(int typeMask) { this.typeMask = typeMask; }</span>
        boolean isSatisfiedBy(int ch) {
<span class="nc bnc" id="L3890" title="All 2 branches missed.">            return (typeMask &amp; (1 &lt;&lt; Character.getType(ch))) != 0;</span>
        }
    }

    /**
     * Node class that matches a Unicode &quot;type&quot;
     */
    static final class Utype extends CharProperty {
        final UnicodeProp uprop;
<span class="nc" id="L3899">        Utype(UnicodeProp uprop) { this.uprop = uprop; }</span>
        boolean isSatisfiedBy(int ch) {
<span class="nc" id="L3901">            return uprop.is(ch);</span>
        }
    }

    /**
     * Node class that matches a POSIX type.
     */
    static final class Ctype extends BmpCharProperty {
        final int ctype;
<span class="fc" id="L3910">        Ctype(int ctype) { this.ctype = ctype; }</span>
        boolean isSatisfiedBy(int ch) {
<span class="pc bpc" id="L3912" title="1 of 4 branches missed.">            return ch &lt; 128 &amp;&amp; ASCII.isType(ch, ctype);</span>
        }
    }

    /**
     * Node class that matches a Perl vertical whitespace
     */
<span class="nc" id="L3919">    static final class VertWS extends BmpCharProperty {</span>
        boolean isSatisfiedBy(int cp) {
<span class="nc bnc" id="L3921" title="All 10 branches missed.">            return (cp &gt;= 0x0A &amp;&amp; cp &lt;= 0x0D) ||</span>
                   cp == 0x85 || cp == 0x2028 || cp == 0x2029;
        }
    }

    /**
     * Node class that matches a Perl horizontal whitespace
     */
<span class="nc" id="L3929">    static final class HorizWS extends BmpCharProperty {</span>
        boolean isSatisfiedBy(int cp) {
<span class="nc bnc" id="L3931" title="All 20 branches missed.">            return cp == 0x09 || cp == 0x20 || cp == 0xa0 ||</span>
                   cp == 0x1680 || cp == 0x180e ||
                   cp &gt;= 0x2000 &amp;&amp; cp &lt;= 0x200a ||
                   cp == 0x202f || cp == 0x205f || cp == 0x3000;
        }
    }

    /**
     * Base class for all Slice nodes
     */
    static class SliceNode extends Node {
        int[] buffer;
<span class="fc" id="L3943">        SliceNode(int[] buf) {</span>
<span class="fc" id="L3944">            buffer = buf;</span>
<span class="fc" id="L3945">        }</span>
        boolean study(TreeInfo info) {
<span class="fc" id="L3947">            info.minLength += buffer.length;</span>
<span class="fc" id="L3948">            info.maxLength += buffer.length;</span>
<span class="fc" id="L3949">            return next.study(info);</span>
        }
    }

    /**
     * Node class for a case sensitive/BMP-only sequence of literal
     * characters.
     */
    static final class Slice extends SliceNode {
        Slice(int[] buf) {
<span class="fc" id="L3959">            super(buf);</span>
<span class="fc" id="L3960">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc" id="L3962">            int[] buf = buffer;</span>
<span class="fc" id="L3963">            int len = buf.length;</span>
<span class="fc bfc" id="L3964" title="All 2 branches covered.">            for (int j=0; j&lt;len; j++) {</span>
<span class="fc bfc" id="L3965" title="All 2 branches covered.">                if ((i+j) &gt;= matcher.to) {</span>
<span class="fc" id="L3966">                    matcher.hitEnd = true;</span>
<span class="fc" id="L3967">                    return false;</span>
                }
<span class="fc bfc" id="L3969" title="All 2 branches covered.">                if (buf[j] != seq.charAt(i+j))</span>
<span class="fc" id="L3970">                    return false;</span>
            }
<span class="fc" id="L3972">            return next.match(matcher, i+len, seq);</span>
        }
    }

    /**
     * Node class for a case_insensitive/BMP-only sequence of literal
     * characters.
     */
    static class SliceI extends SliceNode {
        SliceI(int[] buf) {
<span class="fc" id="L3982">            super(buf);</span>
<span class="fc" id="L3983">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc" id="L3985">            int[] buf = buffer;</span>
<span class="fc" id="L3986">            int len = buf.length;</span>
<span class="fc bfc" id="L3987" title="All 2 branches covered.">            for (int j=0; j&lt;len; j++) {</span>
<span class="fc bfc" id="L3988" title="All 2 branches covered.">                if ((i+j) &gt;= matcher.to) {</span>
<span class="fc" id="L3989">                    matcher.hitEnd = true;</span>
<span class="fc" id="L3990">                    return false;</span>
                }
<span class="fc" id="L3992">                int c = seq.charAt(i+j);</span>
<span class="fc bfc" id="L3993" title="All 2 branches covered.">                if (buf[j] != c &amp;&amp;</span>
<span class="fc bfc" id="L3994" title="All 2 branches covered.">                    buf[j] != ASCII.toLower(c))</span>
<span class="fc" id="L3995">                    return false;</span>
            }
<span class="fc" id="L3997">            return next.match(matcher, i+len, seq);</span>
        }
    }

    /**
     * Node class for a unicode_case_insensitive/BMP-only sequence of
     * literal characters. Uses unicode case folding.
     */
    static final class SliceU extends SliceNode {
        SliceU(int[] buf) {
<span class="nc" id="L4007">            super(buf);</span>
<span class="nc" id="L4008">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L4010">            int[] buf = buffer;</span>
<span class="nc" id="L4011">            int len = buf.length;</span>
<span class="nc bnc" id="L4012" title="All 2 branches missed.">            for (int j=0; j&lt;len; j++) {</span>
<span class="nc bnc" id="L4013" title="All 2 branches missed.">                if ((i+j) &gt;= matcher.to) {</span>
<span class="nc" id="L4014">                    matcher.hitEnd = true;</span>
<span class="nc" id="L4015">                    return false;</span>
                }
<span class="nc" id="L4017">                int c = seq.charAt(i+j);</span>
<span class="nc bnc" id="L4018" title="All 2 branches missed.">                if (buf[j] != c &amp;&amp;</span>
<span class="nc bnc" id="L4019" title="All 2 branches missed.">                    buf[j] != Character.toLowerCase(Character.toUpperCase(c)))</span>
<span class="nc" id="L4020">                    return false;</span>
            }
<span class="nc" id="L4022">            return next.match(matcher, i+len, seq);</span>
        }
    }

    /**
     * Node class for a case sensitive sequence of literal characters
     * including supplementary characters.
     */
    static final class SliceS extends SliceNode {
        SliceS(int[] buf) {
<span class="nc" id="L4032">            super(buf);</span>
<span class="nc" id="L4033">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L4035">            int[] buf = buffer;</span>
<span class="nc" id="L4036">            int x = i;</span>
<span class="nc bnc" id="L4037" title="All 2 branches missed.">            for (int j = 0; j &lt; buf.length; j++) {</span>
<span class="nc bnc" id="L4038" title="All 2 branches missed.">                if (x &gt;= matcher.to) {</span>
<span class="nc" id="L4039">                    matcher.hitEnd = true;</span>
<span class="nc" id="L4040">                    return false;</span>
                }
<span class="nc" id="L4042">                int c = Character.codePointAt(seq, x);</span>
<span class="nc bnc" id="L4043" title="All 2 branches missed.">                if (buf[j] != c)</span>
<span class="nc" id="L4044">                    return false;</span>
<span class="nc" id="L4045">                x += Character.charCount(c);</span>
<span class="nc bnc" id="L4046" title="All 2 branches missed.">                if (x &gt; matcher.to) {</span>
<span class="nc" id="L4047">                    matcher.hitEnd = true;</span>
<span class="nc" id="L4048">                    return false;</span>
                }
            }
<span class="nc" id="L4051">            return next.match(matcher, x, seq);</span>
        }
    }

    /**
     * Node class for a case insensitive sequence of literal characters
     * including supplementary characters.
     */
    static class SliceIS extends SliceNode {
        SliceIS(int[] buf) {
<span class="nc" id="L4061">            super(buf);</span>
<span class="nc" id="L4062">        }</span>
        int toLower(int c) {
<span class="nc" id="L4064">            return ASCII.toLower(c);</span>
        }
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L4067">            int[] buf = buffer;</span>
<span class="nc" id="L4068">            int x = i;</span>
<span class="nc bnc" id="L4069" title="All 2 branches missed.">            for (int j = 0; j &lt; buf.length; j++) {</span>
<span class="nc bnc" id="L4070" title="All 2 branches missed.">                if (x &gt;= matcher.to) {</span>
<span class="nc" id="L4071">                    matcher.hitEnd = true;</span>
<span class="nc" id="L4072">                    return false;</span>
                }
<span class="nc" id="L4074">                int c = Character.codePointAt(seq, x);</span>
<span class="nc bnc" id="L4075" title="All 4 branches missed.">                if (buf[j] != c &amp;&amp; buf[j] != toLower(c))</span>
<span class="nc" id="L4076">                    return false;</span>
<span class="nc" id="L4077">                x += Character.charCount(c);</span>
<span class="nc bnc" id="L4078" title="All 2 branches missed.">                if (x &gt; matcher.to) {</span>
<span class="nc" id="L4079">                    matcher.hitEnd = true;</span>
<span class="nc" id="L4080">                    return false;</span>
                }
            }
<span class="nc" id="L4083">            return next.match(matcher, x, seq);</span>
        }
    }

    /**
     * Node class for a case insensitive sequence of literal characters.
     * Uses unicode case folding.
     */
    static final class SliceUS extends SliceIS {
        SliceUS(int[] buf) {
<span class="nc" id="L4093">            super(buf);</span>
<span class="nc" id="L4094">        }</span>
        int toLower(int c) {
<span class="nc" id="L4096">            return Character.toLowerCase(Character.toUpperCase(c));</span>
        }
    }

    private static boolean inRange(int lower, int ch, int upper) {
<span class="fc bfc" id="L4101" title="All 4 branches covered.">        return lower &lt;= ch &amp;&amp; ch &lt;= upper;</span>
    }

    /**
     * Returns node for matching characters within an explicit value range.
     */
    private static CharProperty rangeFor(final int lower,
                                         final int upper) {
<span class="fc" id="L4109">        return new CharProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="fc" id="L4111">                    return inRange(lower, ch, upper);}};</span>
    }

    /**
     * Returns node for matching characters within an explicit value
     * range in a case insensitive manner.
     */
    private CharProperty caseInsensitiveRangeFor(final int lower,
                                                 final int upper) {
<span class="pc bpc" id="L4120" title="1 of 2 branches missed.">        if (has(UNICODE_CASE))</span>
<span class="nc" id="L4121">            return new CharProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc bnc" id="L4123" title="All 2 branches missed.">                    if (inRange(lower, ch, upper))</span>
<span class="nc" id="L4124">                        return true;</span>
<span class="nc" id="L4125">                    int up = Character.toUpperCase(ch);</span>
<span class="nc bnc" id="L4126" title="All 2 branches missed.">                    return inRange(lower, up, upper) ||</span>
<span class="nc bnc" id="L4127" title="All 2 branches missed.">                           inRange(lower, Character.toLowerCase(up), upper);}};</span>
<span class="fc" id="L4128">        return new CharProperty() {</span>
            boolean isSatisfiedBy(int ch) {
<span class="nc bnc" id="L4130" title="All 2 branches missed.">                return inRange(lower, ch, upper) ||</span>
<span class="nc bnc" id="L4131" title="All 2 branches missed.">                    ASCII.isAscii(ch) &amp;&amp;</span>
<span class="nc bnc" id="L4132" title="All 2 branches missed.">                        (inRange(lower, ASCII.toUpper(ch), upper) ||</span>
<span class="nc bnc" id="L4133" title="All 2 branches missed.">                         inRange(lower, ASCII.toLower(ch), upper));</span>
            }};
    }

    /**
     * Implements the Unicode category ALL and the dot metacharacter when
     * in dotall mode.
     */
<span class="fc" id="L4141">    static final class All extends CharProperty {</span>
        boolean isSatisfiedBy(int ch) {
<span class="fc" id="L4143">            return true;</span>
        }
    }

    /**
     * Node class for the dot metacharacter when dotall is not enabled.
     */
<span class="fc" id="L4150">    static final class Dot extends CharProperty {</span>
        boolean isSatisfiedBy(int ch) {
<span class="pc bpc" id="L4152" title="3 of 8 branches missed.">            return (ch != '\n' &amp;&amp; ch != '\r'</span>
                    &amp;&amp; (ch|1) != '\u2029'
                    &amp;&amp; ch != '\u0085');
        }
    }

    /**
     * Node class for the dot metacharacter when dotall is not enabled
     * but UNIX_LINES is enabled.
     */
<span class="nc" id="L4162">    static final class UnixDot extends CharProperty {</span>
        boolean isSatisfiedBy(int ch) {
<span class="nc bnc" id="L4164" title="All 2 branches missed.">            return ch != '\n';</span>
        }
    }

    /**
     * The 0 or 1 quantifier. This one class implements all three types.
     */
    static final class Ques extends Node {
        Node atom;
        int type;
<span class="fc" id="L4174">        Ques(Node node, int type) {</span>
<span class="fc" id="L4175">            this.atom = node;</span>
<span class="fc" id="L4176">            this.type = type;</span>
<span class="fc" id="L4177">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="pc bpc" id="L4179" title="3 of 4 branches missed.">            switch (type) {</span>
            case GREEDY:
<span class="fc bfc" id="L4181" title="All 4 branches covered.">                return (atom.match(matcher, i, seq) &amp;&amp; next.match(matcher, matcher.last, seq))</span>
<span class="fc bfc" id="L4182" title="All 2 branches covered.">                    || next.match(matcher, i, seq);</span>
            case LAZY:
<span class="nc bnc" id="L4184" title="All 2 branches missed.">                return next.match(matcher, i, seq)</span>
<span class="nc bnc" id="L4185" title="All 4 branches missed.">                    || (atom.match(matcher, i, seq) &amp;&amp; next.match(matcher, matcher.last, seq));</span>
            case POSSESSIVE:
<span class="nc bnc" id="L4187" title="All 2 branches missed.">                if (atom.match(matcher, i, seq)) i = matcher.last;</span>
<span class="nc" id="L4188">                return next.match(matcher, i, seq);</span>
            default:
<span class="nc bnc" id="L4190" title="All 4 branches missed.">                return atom.match(matcher, i, seq) &amp;&amp; next.match(matcher, matcher.last, seq);</span>
            }
        }
        boolean study(TreeInfo info) {
<span class="pc bpc" id="L4194" title="1 of 2 branches missed.">            if (type != INDEPENDENT) {</span>
<span class="fc" id="L4195">                int minL = info.minLength;</span>
<span class="fc" id="L4196">                atom.study(info);</span>
<span class="fc" id="L4197">                info.minLength = minL;</span>
<span class="fc" id="L4198">                info.deterministic = false;</span>
<span class="fc" id="L4199">                return next.study(info);</span>
            } else {
<span class="nc" id="L4201">                atom.study(info);</span>
<span class="nc" id="L4202">                return next.study(info);</span>
            }
        }
    }

    /**
     * Handles the curly-brace style repetition with a specified minimum and
     * maximum occurrences. The * quantifier is handled as a special case.
     * This class handles the three types.
     */
    static final class Curly extends Node {
        Node atom;
        int type;
        int cmin;
        int cmax;

<span class="fc" id="L4218">        Curly(Node node, int cmin, int cmax, int type) {</span>
<span class="fc" id="L4219">            this.atom = node;</span>
<span class="fc" id="L4220">            this.type = type;</span>
<span class="fc" id="L4221">            this.cmin = cmin;</span>
<span class="fc" id="L4222">            this.cmax = cmax;</span>
<span class="fc" id="L4223">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
            int j;
<span class="fc bfc" id="L4226" title="All 2 branches covered.">            for (j = 0; j &lt; cmin; j++) {</span>
<span class="fc bfc" id="L4227" title="All 2 branches covered.">                if (atom.match(matcher, i, seq)) {</span>
<span class="fc" id="L4228">                    i = matcher.last;</span>
<span class="fc" id="L4229">                    continue;</span>
                }
<span class="fc" id="L4231">                return false;</span>
            }
<span class="pc bpc" id="L4233" title="1 of 2 branches missed.">            if (type == GREEDY)</span>
<span class="fc" id="L4234">                return match0(matcher, i, j, seq);</span>
<span class="nc bnc" id="L4235" title="All 2 branches missed.">            else if (type == LAZY)</span>
<span class="nc" id="L4236">                return match1(matcher, i, j, seq);</span>
            else
<span class="nc" id="L4238">                return match2(matcher, i, j, seq);</span>
        }
        // Greedy match.
        // i is the index to start matching at
        // j is the number of atoms that have matched
        boolean match0(Matcher matcher, int i, int j, CharSequence seq) {
<span class="fc bfc" id="L4244" title="All 2 branches covered.">            if (j &gt;= cmax) {</span>
                // We have matched the maximum... continue with the rest of
                // the regular expression
<span class="fc" id="L4247">                return next.match(matcher, i, seq);</span>
            }
<span class="fc" id="L4249">            int backLimit = j;</span>
<span class="fc bfc" id="L4250" title="All 2 branches covered.">            while (atom.match(matcher, i, seq)) {</span>
                // k is the length of this match
<span class="fc" id="L4252">                int k = matcher.last - i;</span>
<span class="pc bpc" id="L4253" title="1 of 2 branches missed.">                if (k == 0) // Zero length match</span>
<span class="nc" id="L4254">                    break;</span>
                // Move up index and number matched
<span class="fc" id="L4256">                i = matcher.last;</span>
<span class="fc" id="L4257">                j++;</span>
                // We are greedy so match as many as we can
<span class="fc bfc" id="L4259" title="All 2 branches covered.">                while (j &lt; cmax) {</span>
<span class="fc bfc" id="L4260" title="All 2 branches covered.">                    if (!atom.match(matcher, i, seq))</span>
<span class="fc" id="L4261">                        break;</span>
<span class="pc bpc" id="L4262" title="1 of 2 branches missed.">                    if (i + k != matcher.last) {</span>
<span class="nc bnc" id="L4263" title="All 2 branches missed.">                        if (match0(matcher, matcher.last, j+1, seq))</span>
<span class="nc" id="L4264">                            return true;</span>
                        break;
                    }
<span class="fc" id="L4267">                    i += k;</span>
<span class="fc" id="L4268">                    j++;</span>
                }
                // Handle backing off if match fails
<span class="fc bfc" id="L4271" title="All 2 branches covered.">                while (j &gt;= backLimit) {</span>
<span class="fc bfc" id="L4272" title="All 2 branches covered.">                   if (next.match(matcher, i, seq))</span>
<span class="fc" id="L4273">                        return true;</span>
<span class="fc" id="L4274">                    i -= k;</span>
<span class="fc" id="L4275">                    j--;</span>
                }
<span class="fc" id="L4277">                return false;</span>
            }
<span class="fc" id="L4279">            return next.match(matcher, i, seq);</span>
        }
        // Reluctant match. At this point, the minimum has been satisfied.
        // i is the index to start matching at
        // j is the number of atoms that have matched
        boolean match1(Matcher matcher, int i, int j, CharSequence seq) {
            for (;;) {
                // Try finishing match without consuming any more
<span class="nc bnc" id="L4287" title="All 2 branches missed.">                if (next.match(matcher, i, seq))</span>
<span class="nc" id="L4288">                    return true;</span>
                // At the maximum, no match found
<span class="nc bnc" id="L4290" title="All 2 branches missed.">                if (j &gt;= cmax)</span>
<span class="nc" id="L4291">                    return false;</span>
                // Okay, must try one more atom
<span class="nc bnc" id="L4293" title="All 2 branches missed.">                if (!atom.match(matcher, i, seq))</span>
<span class="nc" id="L4294">                    return false;</span>
                // If we haven't moved forward then must break out
<span class="nc bnc" id="L4296" title="All 2 branches missed.">                if (i == matcher.last)</span>
<span class="nc" id="L4297">                    return false;</span>
                // Move up index and number matched
<span class="nc" id="L4299">                i = matcher.last;</span>
<span class="nc" id="L4300">                j++;</span>
            }
        }
        boolean match2(Matcher matcher, int i, int j, CharSequence seq) {
<span class="nc bnc" id="L4304" title="All 2 branches missed.">            for (; j &lt; cmax; j++) {</span>
<span class="nc bnc" id="L4305" title="All 2 branches missed.">                if (!atom.match(matcher, i, seq))</span>
<span class="nc" id="L4306">                    break;</span>
<span class="nc bnc" id="L4307" title="All 2 branches missed.">                if (i == matcher.last)</span>
<span class="nc" id="L4308">                    break;</span>
<span class="nc" id="L4309">                i = matcher.last;</span>
            }
<span class="nc" id="L4311">            return next.match(matcher, i, seq);</span>
        }
        boolean study(TreeInfo info) {
            // Save original info
<span class="fc" id="L4315">            int minL = info.minLength;</span>
<span class="fc" id="L4316">            int maxL = info.maxLength;</span>
<span class="fc" id="L4317">            boolean maxV = info.maxValid;</span>
<span class="fc" id="L4318">            boolean detm = info.deterministic;</span>
<span class="fc" id="L4319">            info.reset();</span>

<span class="fc" id="L4321">            atom.study(info);</span>

<span class="fc" id="L4323">            int temp = info.minLength * cmin + minL;</span>
<span class="pc bpc" id="L4324" title="1 of 2 branches missed.">            if (temp &lt; minL) {</span>
<span class="nc" id="L4325">                temp = 0xFFFFFFF; // arbitrary large number</span>
            }
<span class="fc" id="L4327">            info.minLength = temp;</span>

<span class="fc bfc" id="L4329" title="All 2 branches covered.">            if (maxV &amp; info.maxValid) {</span>
<span class="fc" id="L4330">                temp = info.maxLength * cmax + maxL;</span>
<span class="fc" id="L4331">                info.maxLength = temp;</span>
<span class="fc bfc" id="L4332" title="All 2 branches covered.">                if (temp &lt; maxL) {</span>
<span class="fc" id="L4333">                    info.maxValid = false;</span>
                }
            } else {
<span class="fc" id="L4336">                info.maxValid = false;</span>
            }

<span class="pc bpc" id="L4339" title="1 of 4 branches missed.">            if (info.deterministic &amp;&amp; cmin == cmax)</span>
<span class="fc" id="L4340">                info.deterministic = detm;</span>
            else
<span class="fc" id="L4342">                info.deterministic = false;</span>
<span class="fc" id="L4343">            return next.study(info);</span>
        }
    }

    /**
     * Handles the curly-brace style repetition with a specified minimum and
     * maximum occurrences in deterministic cases. This is an iterative
     * optimization over the Prolog and Loop system which would handle this
     * in a recursive way. The * quantifier is handled as a special case.
     * If capture is true then this class saves group settings and ensures
     * that groups are unset when backing off of a group match.
     */
    static final class GroupCurly extends Node {
        Node atom;
        int type;
        int cmin;
        int cmax;
        int localIndex;
        int groupIndex;
        boolean capture;

        GroupCurly(Node node, int cmin, int cmax, int type, int local,
<span class="fc" id="L4365">                   int group, boolean capture) {</span>
<span class="fc" id="L4366">            this.atom = node;</span>
<span class="fc" id="L4367">            this.type = type;</span>
<span class="fc" id="L4368">            this.cmin = cmin;</span>
<span class="fc" id="L4369">            this.cmax = cmax;</span>
<span class="fc" id="L4370">            this.localIndex = local;</span>
<span class="fc" id="L4371">            this.groupIndex = group;</span>
<span class="fc" id="L4372">            this.capture = capture;</span>
<span class="fc" id="L4373">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L4375">            int[] groups = matcher.groups;</span>
<span class="nc" id="L4376">            int[] locals = matcher.locals;</span>
<span class="nc" id="L4377">            int save0 = locals[localIndex];</span>
<span class="nc" id="L4378">            int save1 = 0;</span>
<span class="nc" id="L4379">            int save2 = 0;</span>

<span class="nc bnc" id="L4381" title="All 2 branches missed.">            if (capture) {</span>
<span class="nc" id="L4382">                save1 = groups[groupIndex];</span>
<span class="nc" id="L4383">                save2 = groups[groupIndex+1];</span>
            }

            // Notify GroupTail there is no need to setup group info
            // because it will be set here
<span class="nc" id="L4388">            locals[localIndex] = -1;</span>

<span class="nc" id="L4390">            boolean ret = true;</span>
<span class="nc bnc" id="L4391" title="All 2 branches missed.">            for (int j = 0; j &lt; cmin; j++) {</span>
<span class="nc bnc" id="L4392" title="All 2 branches missed.">                if (atom.match(matcher, i, seq)) {</span>
<span class="nc bnc" id="L4393" title="All 2 branches missed.">                    if (capture) {</span>
<span class="nc" id="L4394">                        groups[groupIndex] = i;</span>
<span class="nc" id="L4395">                        groups[groupIndex+1] = matcher.last;</span>
                    }
<span class="nc" id="L4397">                    i = matcher.last;</span>
                } else {
<span class="nc" id="L4399">                    ret = false;</span>
<span class="nc" id="L4400">                    break;</span>
                }
            }
<span class="nc bnc" id="L4403" title="All 2 branches missed.">            if (ret) {</span>
<span class="nc bnc" id="L4404" title="All 2 branches missed.">                if (type == GREEDY) {</span>
<span class="nc" id="L4405">                    ret = match0(matcher, i, cmin, seq);</span>
<span class="nc bnc" id="L4406" title="All 2 branches missed.">                } else if (type == LAZY) {</span>
<span class="nc" id="L4407">                    ret = match1(matcher, i, cmin, seq);</span>
                } else {
<span class="nc" id="L4409">                    ret = match2(matcher, i, cmin, seq);</span>
                }
            }
<span class="nc bnc" id="L4412" title="All 2 branches missed.">            if (!ret) {</span>
<span class="nc" id="L4413">                locals[localIndex] = save0;</span>
<span class="nc bnc" id="L4414" title="All 2 branches missed.">                if (capture) {</span>
<span class="nc" id="L4415">                    groups[groupIndex] = save1;</span>
<span class="nc" id="L4416">                    groups[groupIndex+1] = save2;</span>
                }
            }
<span class="nc" id="L4419">            return ret;</span>
        }
        // Aggressive group match
        boolean match0(Matcher matcher, int i, int j, CharSequence seq) {
            // don't back off passing the starting &quot;j&quot;
<span class="nc" id="L4424">            int min = j;</span>
<span class="nc" id="L4425">            int[] groups = matcher.groups;</span>
<span class="nc" id="L4426">            int save0 = 0;</span>
<span class="nc" id="L4427">            int save1 = 0;</span>
<span class="nc bnc" id="L4428" title="All 2 branches missed.">            if (capture) {</span>
<span class="nc" id="L4429">                save0 = groups[groupIndex];</span>
<span class="nc" id="L4430">                save1 = groups[groupIndex+1];</span>
            }
            for (;;) {
<span class="nc bnc" id="L4433" title="All 2 branches missed.">                if (j &gt;= cmax)</span>
<span class="nc" id="L4434">                    break;</span>
<span class="nc bnc" id="L4435" title="All 2 branches missed.">                if (!atom.match(matcher, i, seq))</span>
<span class="nc" id="L4436">                    break;</span>
<span class="nc" id="L4437">                int k = matcher.last - i;</span>
<span class="nc bnc" id="L4438" title="All 2 branches missed.">                if (k &lt;= 0) {</span>
<span class="nc bnc" id="L4439" title="All 2 branches missed.">                    if (capture) {</span>
<span class="nc" id="L4440">                        groups[groupIndex] = i;</span>
<span class="nc" id="L4441">                        groups[groupIndex+1] = i + k;</span>
                    }
<span class="nc" id="L4443">                    i = i + k;</span>
<span class="nc" id="L4444">                    break;</span>
                }
                for (;;) {
<span class="nc bnc" id="L4447" title="All 2 branches missed.">                    if (capture) {</span>
<span class="nc" id="L4448">                        groups[groupIndex] = i;</span>
<span class="nc" id="L4449">                        groups[groupIndex+1] = i + k;</span>
                    }
<span class="nc" id="L4451">                    i = i + k;</span>
<span class="nc bnc" id="L4452" title="All 2 branches missed.">                    if (++j &gt;= cmax)</span>
<span class="nc" id="L4453">                        break;</span>
<span class="nc bnc" id="L4454" title="All 2 branches missed.">                    if (!atom.match(matcher, i, seq))</span>
<span class="nc" id="L4455">                        break;</span>
<span class="nc bnc" id="L4456" title="All 2 branches missed.">                    if (i + k != matcher.last) {</span>
<span class="nc bnc" id="L4457" title="All 2 branches missed.">                        if (match0(matcher, i, j, seq))</span>
<span class="nc" id="L4458">                            return true;</span>
                        break;
                    }
                }
<span class="nc bnc" id="L4462" title="All 2 branches missed.">                while (j &gt; min) {</span>
<span class="nc bnc" id="L4463" title="All 2 branches missed.">                    if (next.match(matcher, i, seq)) {</span>
<span class="nc bnc" id="L4464" title="All 2 branches missed.">                        if (capture) {</span>
<span class="nc" id="L4465">                            groups[groupIndex+1] = i;</span>
<span class="nc" id="L4466">                            groups[groupIndex] = i - k;</span>
                        }
<span class="nc" id="L4468">                        return true;</span>
                    }
                    // backing off
<span class="nc" id="L4471">                    i = i - k;</span>
<span class="nc bnc" id="L4472" title="All 2 branches missed.">                    if (capture) {</span>
<span class="nc" id="L4473">                        groups[groupIndex+1] = i;</span>
<span class="nc" id="L4474">                        groups[groupIndex] = i - k;</span>
                    }
<span class="nc" id="L4476">                    j--;</span>

                }
                break;
            }
<span class="nc bnc" id="L4481" title="All 2 branches missed.">            if (capture) {</span>
<span class="nc" id="L4482">                groups[groupIndex] = save0;</span>
<span class="nc" id="L4483">                groups[groupIndex+1] = save1;</span>
            }
<span class="nc" id="L4485">            return next.match(matcher, i, seq);</span>
        }
        // Reluctant matching
        boolean match1(Matcher matcher, int i, int j, CharSequence seq) {
            for (;;) {
<span class="nc bnc" id="L4490" title="All 2 branches missed.">                if (next.match(matcher, i, seq))</span>
<span class="nc" id="L4491">                    return true;</span>
<span class="nc bnc" id="L4492" title="All 2 branches missed.">                if (j &gt;= cmax)</span>
<span class="nc" id="L4493">                    return false;</span>
<span class="nc bnc" id="L4494" title="All 2 branches missed.">                if (!atom.match(matcher, i, seq))</span>
<span class="nc" id="L4495">                    return false;</span>
<span class="nc bnc" id="L4496" title="All 2 branches missed.">                if (i == matcher.last)</span>
<span class="nc" id="L4497">                    return false;</span>
<span class="nc bnc" id="L4498" title="All 2 branches missed.">                if (capture) {</span>
<span class="nc" id="L4499">                    matcher.groups[groupIndex] = i;</span>
<span class="nc" id="L4500">                    matcher.groups[groupIndex+1] = matcher.last;</span>
                }
<span class="nc" id="L4502">                i = matcher.last;</span>
<span class="nc" id="L4503">                j++;</span>
            }
        }
        // Possessive matching
        boolean match2(Matcher matcher, int i, int j, CharSequence seq) {
<span class="nc bnc" id="L4508" title="All 2 branches missed.">            for (; j &lt; cmax; j++) {</span>
<span class="nc bnc" id="L4509" title="All 2 branches missed.">                if (!atom.match(matcher, i, seq)) {</span>
<span class="nc" id="L4510">                    break;</span>
                }
<span class="nc bnc" id="L4512" title="All 2 branches missed.">                if (capture) {</span>
<span class="nc" id="L4513">                    matcher.groups[groupIndex] = i;</span>
<span class="nc" id="L4514">                    matcher.groups[groupIndex+1] = matcher.last;</span>
                }
<span class="nc bnc" id="L4516" title="All 2 branches missed.">                if (i == matcher.last) {</span>
<span class="nc" id="L4517">                    break;</span>
                }
<span class="nc" id="L4519">                i = matcher.last;</span>
            }
<span class="nc" id="L4521">            return next.match(matcher, i, seq);</span>
        }
        boolean study(TreeInfo info) {
            // Save original info
<span class="fc" id="L4525">            int minL = info.minLength;</span>
<span class="fc" id="L4526">            int maxL = info.maxLength;</span>
<span class="fc" id="L4527">            boolean maxV = info.maxValid;</span>
<span class="fc" id="L4528">            boolean detm = info.deterministic;</span>
<span class="fc" id="L4529">            info.reset();</span>

<span class="fc" id="L4531">            atom.study(info);</span>

<span class="fc" id="L4533">            int temp = info.minLength * cmin + minL;</span>
<span class="pc bpc" id="L4534" title="1 of 2 branches missed.">            if (temp &lt; minL) {</span>
<span class="nc" id="L4535">                temp = 0xFFFFFFF; // Arbitrary large number</span>
            }
<span class="fc" id="L4537">            info.minLength = temp;</span>

<span class="pc bpc" id="L4539" title="1 of 2 branches missed.">            if (maxV &amp; info.maxValid) {</span>
<span class="fc" id="L4540">                temp = info.maxLength * cmax + maxL;</span>
<span class="fc" id="L4541">                info.maxLength = temp;</span>
<span class="pc bpc" id="L4542" title="1 of 2 branches missed.">                if (temp &lt; maxL) {</span>
<span class="nc" id="L4543">                    info.maxValid = false;</span>
                }
            } else {
<span class="nc" id="L4546">                info.maxValid = false;</span>
            }

<span class="pc bpc" id="L4549" title="1 of 4 branches missed.">            if (info.deterministic &amp;&amp; cmin == cmax) {</span>
<span class="fc" id="L4550">                info.deterministic = detm;</span>
            } else {
<span class="fc" id="L4552">                info.deterministic = false;</span>
            }
<span class="fc" id="L4554">            return next.study(info);</span>
        }
    }

    /**
     * A Guard node at the end of each atom node in a Branch. It
     * serves the purpose of chaining the &quot;match&quot; operation to
     * &quot;next&quot; but not the &quot;study&quot;, so we can collect the TreeInfo
     * of each atom node without including the TreeInfo of the
     * &quot;next&quot;.
     */
    static final class BranchConn extends Node {
<span class="fc" id="L4566">        BranchConn() {};</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc" id="L4568">            return next.match(matcher, i, seq);</span>
        }
        boolean study(TreeInfo info) {
<span class="fc" id="L4571">            return info.deterministic;</span>
        }
    }

    /**
     * Handles the branching of alternations. Note this is also used for
     * the ? quantifier to branch between the case where it matches once
     * and where it does not occur.
     */
    static final class Branch extends Node {
<span class="fc" id="L4581">        Node[] atoms = new Node[2];</span>
<span class="fc" id="L4582">        int size = 2;</span>
        Node conn;
<span class="fc" id="L4584">        Branch(Node first, Node second, Node branchConn) {</span>
<span class="fc" id="L4585">            conn = branchConn;</span>
<span class="fc" id="L4586">            atoms[0] = first;</span>
<span class="fc" id="L4587">            atoms[1] = second;</span>
<span class="fc" id="L4588">        }</span>

        void add(Node node) {
<span class="fc bfc" id="L4591" title="All 2 branches covered.">            if (size &gt;= atoms.length) {</span>
<span class="fc" id="L4592">                Node[] tmp = new Node[atoms.length*2];</span>
<span class="fc" id="L4593">                System.arraycopy(atoms, 0, tmp, 0, atoms.length);</span>
<span class="fc" id="L4594">                atoms = tmp;</span>
            }
<span class="fc" id="L4596">            atoms[size++] = node;</span>
<span class="fc" id="L4597">        }</span>

        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc bfc" id="L4600" title="All 2 branches covered.">            for (int n = 0; n &lt; size; n++) {</span>
<span class="fc bfc" id="L4601" title="All 2 branches covered.">                if (atoms[n] == null) {</span>
<span class="fc bfc" id="L4602" title="All 2 branches covered.">                    if (conn.next.match(matcher, i, seq))</span>
<span class="fc" id="L4603">                        return true;</span>
<span class="fc bfc" id="L4604" title="All 2 branches covered.">                } else if (atoms[n].match(matcher, i, seq)) {</span>
<span class="fc" id="L4605">                    return true;</span>
                }
            }
<span class="fc" id="L4608">            return false;</span>
        }

        boolean study(TreeInfo info) {
<span class="fc" id="L4612">            int minL = info.minLength;</span>
<span class="fc" id="L4613">            int maxL = info.maxLength;</span>
<span class="fc" id="L4614">            boolean maxV = info.maxValid;</span>

<span class="fc" id="L4616">            int minL2 = Integer.MAX_VALUE; //arbitrary large enough num</span>
<span class="fc" id="L4617">            int maxL2 = -1;</span>
<span class="fc bfc" id="L4618" title="All 2 branches covered.">            for (int n = 0; n &lt; size; n++) {</span>
<span class="fc" id="L4619">                info.reset();</span>
<span class="fc bfc" id="L4620" title="All 2 branches covered.">                if (atoms[n] != null)</span>
<span class="fc" id="L4621">                    atoms[n].study(info);</span>
<span class="fc" id="L4622">                minL2 = Math.min(minL2, info.minLength);</span>
<span class="fc" id="L4623">                maxL2 = Math.max(maxL2, info.maxLength);</span>
<span class="fc" id="L4624">                maxV = (maxV &amp; info.maxValid);</span>
            }

<span class="fc" id="L4627">            minL += minL2;</span>
<span class="fc" id="L4628">            maxL += maxL2;</span>

<span class="fc" id="L4630">            info.reset();</span>
<span class="fc" id="L4631">            conn.next.study(info);</span>

<span class="fc" id="L4633">            info.minLength += minL;</span>
<span class="fc" id="L4634">            info.maxLength += maxL;</span>
<span class="fc" id="L4635">            info.maxValid &amp;= maxV;</span>
<span class="fc" id="L4636">            info.deterministic = false;</span>
<span class="fc" id="L4637">            return false;</span>
        }
    }

    /**
     * The GroupHead saves the location where the group begins in the locals
     * and restores them when the match is done.
     *
     * The matchRef is used when a reference to this group is accessed later
     * in the expression. The locals will have a negative value in them to
     * indicate that we do not want to unset the group if the reference
     * doesn't match.
     */
    static final class GroupHead extends Node {
        int localIndex;
<span class="fc" id="L4652">        GroupHead(int localCount) {</span>
<span class="fc" id="L4653">            localIndex = localCount;</span>
<span class="fc" id="L4654">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc" id="L4656">            int save = matcher.locals[localIndex];</span>
<span class="fc" id="L4657">            matcher.locals[localIndex] = i;</span>
<span class="fc" id="L4658">            boolean ret = next.match(matcher, i, seq);</span>
<span class="fc" id="L4659">            matcher.locals[localIndex] = save;</span>
<span class="fc" id="L4660">            return ret;</span>
        }
        boolean matchRef(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L4663">            int save = matcher.locals[localIndex];</span>
<span class="nc" id="L4664">            matcher.locals[localIndex] = ~i; // HACK</span>
<span class="nc" id="L4665">            boolean ret = next.match(matcher, i, seq);</span>
<span class="nc" id="L4666">            matcher.locals[localIndex] = save;</span>
<span class="nc" id="L4667">            return ret;</span>
        }
    }

    /**
     * Recursive reference to a group in the regular expression. It calls
     * matchRef because if the reference fails to match we would not unset
     * the group.
     */
    static final class GroupRef extends Node {
        GroupHead head;
<span class="nc" id="L4678">        GroupRef(GroupHead head) {</span>
<span class="nc" id="L4679">            this.head = head;</span>
<span class="nc" id="L4680">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc bnc" id="L4682" title="All 2 branches missed.">            return head.matchRef(matcher, i, seq)</span>
<span class="nc bnc" id="L4683" title="All 2 branches missed.">                &amp;&amp; next.match(matcher, matcher.last, seq);</span>
        }
        boolean study(TreeInfo info) {
<span class="nc" id="L4686">            info.maxValid = false;</span>
<span class="nc" id="L4687">            info.deterministic = false;</span>
<span class="nc" id="L4688">            return next.study(info);</span>
        }
    }

    /**
     * The GroupTail handles the setting of group beginning and ending
     * locations when groups are successfully matched. It must also be able to
     * unset groups that have to be backed off of.
     *
     * The GroupTail node is also used when a previous group is referenced,
     * and in that case no group information needs to be set.
     */
    static final class GroupTail extends Node {
        int localIndex;
        int groupIndex;
<span class="fc" id="L4703">        GroupTail(int localCount, int groupCount) {</span>
<span class="fc" id="L4704">            localIndex = localCount;</span>
<span class="fc" id="L4705">            groupIndex = groupCount + groupCount;</span>
<span class="fc" id="L4706">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc" id="L4708">            int tmp = matcher.locals[localIndex];</span>
<span class="pc bpc" id="L4709" title="1 of 2 branches missed.">            if (tmp &gt;= 0) { // This is the normal group case.</span>
                // Save the group so we can unset it if it
                // backs off of a match.
<span class="fc" id="L4712">                int groupStart = matcher.groups[groupIndex];</span>
<span class="fc" id="L4713">                int groupEnd = matcher.groups[groupIndex+1];</span>

<span class="fc" id="L4715">                matcher.groups[groupIndex] = tmp;</span>
<span class="fc" id="L4716">                matcher.groups[groupIndex+1] = i;</span>
<span class="fc bfc" id="L4717" title="All 2 branches covered.">                if (next.match(matcher, i, seq)) {</span>
<span class="fc" id="L4718">                    return true;</span>
                }
<span class="fc" id="L4720">                matcher.groups[groupIndex] = groupStart;</span>
<span class="fc" id="L4721">                matcher.groups[groupIndex+1] = groupEnd;</span>
<span class="fc" id="L4722">                return false;</span>
            } else {
                // This is a group reference case. We don't need to save any
                // group info because it isn't really a group.
<span class="nc" id="L4726">                matcher.last = i;</span>
<span class="nc" id="L4727">                return true;</span>
            }
        }
    }

    /**
     * This sets up a loop to handle a recursive quantifier structure.
     */
    static final class Prolog extends Node {
        Loop loop;
<span class="fc" id="L4737">        Prolog(Loop loop) {</span>
<span class="fc" id="L4738">            this.loop = loop;</span>
<span class="fc" id="L4739">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc" id="L4741">            return loop.matchInit(matcher, i, seq);</span>
        }
        boolean study(TreeInfo info) {
<span class="fc" id="L4744">            return loop.study(info);</span>
        }
    }

    /**
     * Handles the repetition count for a greedy Curly. The matchInit
     * is called from the Prolog to save the index of where the group
     * beginning is stored. A zero length group check occurs in the
     * normal match but is skipped in the matchInit.
     */
    static class Loop extends Node {
        Node body;
        int countIndex; // local count index in matcher locals
        int beginIndex; // group beginning index
        int cmin, cmax;
<span class="fc" id="L4759">        Loop(int countIndex, int beginIndex) {</span>
<span class="fc" id="L4760">            this.countIndex = countIndex;</span>
<span class="fc" id="L4761">            this.beginIndex = beginIndex;</span>
<span class="fc" id="L4762">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
            // Avoid infinite loop in zero-length case.
<span class="pc bpc" id="L4765" title="1 of 2 branches missed.">            if (i &gt; matcher.locals[beginIndex]) {</span>
<span class="fc" id="L4766">                int count = matcher.locals[countIndex];</span>

                // This block is for before we reach the minimum
                // iterations required for the loop to match
<span class="pc bpc" id="L4770" title="1 of 2 branches missed.">                if (count &lt; cmin) {</span>
<span class="nc" id="L4771">                    matcher.locals[countIndex] = count + 1;</span>
<span class="nc" id="L4772">                    boolean b = body.match(matcher, i, seq);</span>
                    // If match failed we must backtrack, so
                    // the loop count should NOT be incremented
<span class="nc bnc" id="L4775" title="All 2 branches missed.">                    if (!b)</span>
<span class="nc" id="L4776">                        matcher.locals[countIndex] = count;</span>
                    // Return success or failure since we are under
                    // minimum
<span class="nc" id="L4779">                    return b;</span>
                }
                // This block is for after we have the minimum
                // iterations required for the loop to match
<span class="pc bpc" id="L4783" title="1 of 2 branches missed.">                if (count &lt; cmax) {</span>
<span class="fc" id="L4784">                    matcher.locals[countIndex] = count + 1;</span>
<span class="fc" id="L4785">                    boolean b = body.match(matcher, i, seq);</span>
                    // If match failed we must backtrack, so
                    // the loop count should NOT be incremented
<span class="pc bpc" id="L4788" title="1 of 2 branches missed.">                    if (!b)</span>
<span class="fc" id="L4789">                        matcher.locals[countIndex] = count;</span>
                    else
<span class="nc" id="L4791">                        return true;</span>
                }
            }
<span class="fc" id="L4794">            return next.match(matcher, i, seq);</span>
        }
        boolean matchInit(Matcher matcher, int i, CharSequence seq) {
<span class="fc" id="L4797">            int save = matcher.locals[countIndex];</span>
<span class="fc" id="L4798">            boolean ret = false;</span>
<span class="pc bpc" id="L4799" title="1 of 2 branches missed.">            if (0 &lt; cmin) {</span>
<span class="fc" id="L4800">                matcher.locals[countIndex] = 1;</span>
<span class="fc" id="L4801">                ret = body.match(matcher, i, seq);</span>
<span class="nc bnc" id="L4802" title="All 2 branches missed.">            } else if (0 &lt; cmax) {</span>
<span class="nc" id="L4803">                matcher.locals[countIndex] = 1;</span>
<span class="nc" id="L4804">                ret = body.match(matcher, i, seq);</span>
<span class="nc bnc" id="L4805" title="All 2 branches missed.">                if (ret == false)</span>
<span class="nc" id="L4806">                    ret = next.match(matcher, i, seq);</span>
            } else {
<span class="nc" id="L4808">                ret = next.match(matcher, i, seq);</span>
            }
<span class="fc" id="L4810">            matcher.locals[countIndex] = save;</span>
<span class="fc" id="L4811">            return ret;</span>
        }
        boolean study(TreeInfo info) {
<span class="fc" id="L4814">            info.maxValid = false;</span>
<span class="fc" id="L4815">            info.deterministic = false;</span>
<span class="fc" id="L4816">            return false;</span>
        }
    }

    /**
     * Handles the repetition count for a reluctant Curly. The matchInit
     * is called from the Prolog to save the index of where the group
     * beginning is stored. A zero length group check occurs in the
     * normal match but is skipped in the matchInit.
     */
    static final class LazyLoop extends Loop {
        LazyLoop(int countIndex, int beginIndex) {
<span class="nc" id="L4828">            super(countIndex, beginIndex);</span>
<span class="nc" id="L4829">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
            // Check for zero length group
<span class="nc bnc" id="L4832" title="All 2 branches missed.">            if (i &gt; matcher.locals[beginIndex]) {</span>
<span class="nc" id="L4833">                int count = matcher.locals[countIndex];</span>
<span class="nc bnc" id="L4834" title="All 2 branches missed.">                if (count &lt; cmin) {</span>
<span class="nc" id="L4835">                    matcher.locals[countIndex] = count + 1;</span>
<span class="nc" id="L4836">                    boolean result = body.match(matcher, i, seq);</span>
                    // If match failed we must backtrack, so
                    // the loop count should NOT be incremented
<span class="nc bnc" id="L4839" title="All 2 branches missed.">                    if (!result)</span>
<span class="nc" id="L4840">                        matcher.locals[countIndex] = count;</span>
<span class="nc" id="L4841">                    return result;</span>
                }
<span class="nc bnc" id="L4843" title="All 2 branches missed.">                if (next.match(matcher, i, seq))</span>
<span class="nc" id="L4844">                    return true;</span>
<span class="nc bnc" id="L4845" title="All 2 branches missed.">                if (count &lt; cmax) {</span>
<span class="nc" id="L4846">                    matcher.locals[countIndex] = count + 1;</span>
<span class="nc" id="L4847">                    boolean result = body.match(matcher, i, seq);</span>
                    // If match failed we must backtrack, so
                    // the loop count should NOT be incremented
<span class="nc bnc" id="L4850" title="All 2 branches missed.">                    if (!result)</span>
<span class="nc" id="L4851">                        matcher.locals[countIndex] = count;</span>
<span class="nc" id="L4852">                    return result;</span>
                }
<span class="nc" id="L4854">                return false;</span>
            }
<span class="nc" id="L4856">            return next.match(matcher, i, seq);</span>
        }
        boolean matchInit(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L4859">            int save = matcher.locals[countIndex];</span>
<span class="nc" id="L4860">            boolean ret = false;</span>
<span class="nc bnc" id="L4861" title="All 2 branches missed.">            if (0 &lt; cmin) {</span>
<span class="nc" id="L4862">                matcher.locals[countIndex] = 1;</span>
<span class="nc" id="L4863">                ret = body.match(matcher, i, seq);</span>
<span class="nc bnc" id="L4864" title="All 2 branches missed.">            } else if (next.match(matcher, i, seq)) {</span>
<span class="nc" id="L4865">                ret = true;</span>
<span class="nc bnc" id="L4866" title="All 2 branches missed.">            } else if (0 &lt; cmax) {</span>
<span class="nc" id="L4867">                matcher.locals[countIndex] = 1;</span>
<span class="nc" id="L4868">                ret = body.match(matcher, i, seq);</span>
            }
<span class="nc" id="L4870">            matcher.locals[countIndex] = save;</span>
<span class="nc" id="L4871">            return ret;</span>
        }
        boolean study(TreeInfo info) {
<span class="nc" id="L4874">            info.maxValid = false;</span>
<span class="nc" id="L4875">            info.deterministic = false;</span>
<span class="nc" id="L4876">            return false;</span>
        }
    }

    /**
     * Refers to a group in the regular expression. Attempts to match
     * whatever the group referred to last matched.
     */
    static class BackRef extends Node {
        int groupIndex;
        BackRef(int groupCount) {
<span class="nc" id="L4887">            super();</span>
<span class="nc" id="L4888">            groupIndex = groupCount + groupCount;</span>
<span class="nc" id="L4889">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L4891">            int j = matcher.groups[groupIndex];</span>
<span class="nc" id="L4892">            int k = matcher.groups[groupIndex+1];</span>

<span class="nc" id="L4894">            int groupSize = k - j;</span>
            // If the referenced group didn't match, neither can this
<span class="nc bnc" id="L4896" title="All 2 branches missed.">            if (j &lt; 0)</span>
<span class="nc" id="L4897">                return false;</span>

            // If there isn't enough input left no match
<span class="nc bnc" id="L4900" title="All 2 branches missed.">            if (i + groupSize &gt; matcher.to) {</span>
<span class="nc" id="L4901">                matcher.hitEnd = true;</span>
<span class="nc" id="L4902">                return false;</span>
            }
            // Check each new char to make sure it matches what the group
            // referenced matched last time around
<span class="nc bnc" id="L4906" title="All 2 branches missed.">            for (int index=0; index&lt;groupSize; index++)</span>
<span class="nc bnc" id="L4907" title="All 2 branches missed.">                if (seq.charAt(i+index) != seq.charAt(j+index))</span>
<span class="nc" id="L4908">                    return false;</span>

<span class="nc" id="L4910">            return next.match(matcher, i+groupSize, seq);</span>
        }
        boolean study(TreeInfo info) {
<span class="nc" id="L4913">            info.maxValid = false;</span>
<span class="nc" id="L4914">            return next.study(info);</span>
        }
    }

    static class CIBackRef extends Node {
        int groupIndex;
        boolean doUnicodeCase;
        CIBackRef(int groupCount, boolean doUnicodeCase) {
<span class="nc" id="L4922">            super();</span>
<span class="nc" id="L4923">            groupIndex = groupCount + groupCount;</span>
<span class="nc" id="L4924">            this.doUnicodeCase = doUnicodeCase;</span>
<span class="nc" id="L4925">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L4927">            int j = matcher.groups[groupIndex];</span>
<span class="nc" id="L4928">            int k = matcher.groups[groupIndex+1];</span>

<span class="nc" id="L4930">            int groupSize = k - j;</span>

            // If the referenced group didn't match, neither can this
<span class="nc bnc" id="L4933" title="All 2 branches missed.">            if (j &lt; 0)</span>
<span class="nc" id="L4934">                return false;</span>

            // If there isn't enough input left no match
<span class="nc bnc" id="L4937" title="All 2 branches missed.">            if (i + groupSize &gt; matcher.to) {</span>
<span class="nc" id="L4938">                matcher.hitEnd = true;</span>
<span class="nc" id="L4939">                return false;</span>
            }

            // Check each new char to make sure it matches what the group
            // referenced matched last time around
<span class="nc" id="L4944">            int x = i;</span>
<span class="nc bnc" id="L4945" title="All 2 branches missed.">            for (int index=0; index&lt;groupSize; index++) {</span>
<span class="nc" id="L4946">                int c1 = Character.codePointAt(seq, x);</span>
<span class="nc" id="L4947">                int c2 = Character.codePointAt(seq, j);</span>
<span class="nc bnc" id="L4948" title="All 2 branches missed.">                if (c1 != c2) {</span>
<span class="nc bnc" id="L4949" title="All 2 branches missed.">                    if (doUnicodeCase) {</span>
<span class="nc" id="L4950">                        int cc1 = Character.toUpperCase(c1);</span>
<span class="nc" id="L4951">                        int cc2 = Character.toUpperCase(c2);</span>
<span class="nc bnc" id="L4952" title="All 2 branches missed.">                        if (cc1 != cc2 &amp;&amp;</span>
<span class="nc" id="L4953">                            Character.toLowerCase(cc1) !=</span>
<span class="nc bnc" id="L4954" title="All 2 branches missed.">                            Character.toLowerCase(cc2))</span>
<span class="nc" id="L4955">                            return false;</span>
<span class="nc" id="L4956">                    } else {</span>
<span class="nc bnc" id="L4957" title="All 2 branches missed.">                        if (ASCII.toLower(c1) != ASCII.toLower(c2))</span>
<span class="nc" id="L4958">                            return false;</span>
                    }
                }
<span class="nc" id="L4961">                x += Character.charCount(c1);</span>
<span class="nc" id="L4962">                j += Character.charCount(c2);</span>
            }

<span class="nc" id="L4965">            return next.match(matcher, i+groupSize, seq);</span>
        }
        boolean study(TreeInfo info) {
<span class="nc" id="L4968">            info.maxValid = false;</span>
<span class="nc" id="L4969">            return next.study(info);</span>
        }
    }

    /**
     * Searches until the next instance of its atom. This is useful for
     * finding the atom efficiently without passing an instance of it
     * (greedy problem) and without a lot of wasted search time (reluctant
     * problem).
     */
    static final class First extends Node {
        Node atom;
<span class="nc" id="L4981">        First(Node node) {</span>
<span class="nc" id="L4982">            this.atom = BnM.optimize(node);</span>
<span class="nc" id="L4983">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc bnc" id="L4985" title="All 2 branches missed.">            if (atom instanceof BnM) {</span>
<span class="nc bnc" id="L4986" title="All 2 branches missed.">                return atom.match(matcher, i, seq)</span>
<span class="nc bnc" id="L4987" title="All 2 branches missed.">                    &amp;&amp; next.match(matcher, matcher.last, seq);</span>
            }
            for (;;) {
<span class="nc bnc" id="L4990" title="All 2 branches missed.">                if (i &gt; matcher.to) {</span>
<span class="nc" id="L4991">                    matcher.hitEnd = true;</span>
<span class="nc" id="L4992">                    return false;</span>
                }
<span class="nc bnc" id="L4994" title="All 2 branches missed.">                if (atom.match(matcher, i, seq)) {</span>
<span class="nc" id="L4995">                    return next.match(matcher, matcher.last, seq);</span>
                }
<span class="nc" id="L4997">                i += countChars(seq, i, 1);</span>
<span class="nc" id="L4998">                matcher.first++;</span>
            }
        }
        boolean study(TreeInfo info) {
<span class="nc" id="L5002">            atom.study(info);</span>
<span class="nc" id="L5003">            info.maxValid = false;</span>
<span class="nc" id="L5004">            info.deterministic = false;</span>
<span class="nc" id="L5005">            return next.study(info);</span>
        }
    }

    static final class Conditional extends Node {
        Node cond, yes, not;
<span class="nc" id="L5011">        Conditional(Node cond, Node yes, Node not) {</span>
<span class="nc" id="L5012">            this.cond = cond;</span>
<span class="nc" id="L5013">            this.yes = yes;</span>
<span class="nc" id="L5014">            this.not = not;</span>
<span class="nc" id="L5015">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc bnc" id="L5017" title="All 2 branches missed.">            if (cond.match(matcher, i, seq)) {</span>
<span class="nc" id="L5018">                return yes.match(matcher, i, seq);</span>
            } else {
<span class="nc" id="L5020">                return not.match(matcher, i, seq);</span>
            }
        }
        boolean study(TreeInfo info) {
<span class="nc" id="L5024">            int minL = info.minLength;</span>
<span class="nc" id="L5025">            int maxL = info.maxLength;</span>
<span class="nc" id="L5026">            boolean maxV = info.maxValid;</span>
<span class="nc" id="L5027">            info.reset();</span>
<span class="nc" id="L5028">            yes.study(info);</span>

<span class="nc" id="L5030">            int minL2 = info.minLength;</span>
<span class="nc" id="L5031">            int maxL2 = info.maxLength;</span>
<span class="nc" id="L5032">            boolean maxV2 = info.maxValid;</span>
<span class="nc" id="L5033">            info.reset();</span>
<span class="nc" id="L5034">            not.study(info);</span>

<span class="nc" id="L5036">            info.minLength = minL + Math.min(minL2, info.minLength);</span>
<span class="nc" id="L5037">            info.maxLength = maxL + Math.max(maxL2, info.maxLength);</span>
<span class="nc" id="L5038">            info.maxValid = (maxV &amp; maxV2 &amp; info.maxValid);</span>
<span class="nc" id="L5039">            info.deterministic = false;</span>
<span class="nc" id="L5040">            return next.study(info);</span>
        }
    }

    /**
     * Zero width positive lookahead.
     */
    static final class Pos extends Node {
        Node cond;
<span class="nc" id="L5049">        Pos(Node cond) {</span>
<span class="nc" id="L5050">            this.cond = cond;</span>
<span class="nc" id="L5051">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L5053">            int savedTo = matcher.to;</span>
<span class="nc" id="L5054">            boolean conditionMatched = false;</span>

            // Relax transparent region boundaries for lookahead
<span class="nc bnc" id="L5057" title="All 2 branches missed.">            if (matcher.transparentBounds)</span>
<span class="nc" id="L5058">                matcher.to = matcher.getTextLength();</span>
            try {
<span class="nc" id="L5060">                conditionMatched = cond.match(matcher, i, seq);</span>
            } finally {
                // Reinstate region boundaries
<span class="nc" id="L5063">                matcher.to = savedTo;</span>
<span class="nc" id="L5064">            }</span>
<span class="nc bnc" id="L5065" title="All 4 branches missed.">            return conditionMatched &amp;&amp; next.match(matcher, i, seq);</span>
        }
    }

    /**
     * Zero width negative lookahead.
     */
    static final class Neg extends Node {
        Node cond;
<span class="nc" id="L5074">        Neg(Node cond) {</span>
<span class="nc" id="L5075">            this.cond = cond;</span>
<span class="nc" id="L5076">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L5078">            int savedTo = matcher.to;</span>
<span class="nc" id="L5079">            boolean conditionMatched = false;</span>

            // Relax transparent region boundaries for lookahead
<span class="nc bnc" id="L5082" title="All 2 branches missed.">            if (matcher.transparentBounds)</span>
<span class="nc" id="L5083">                matcher.to = matcher.getTextLength();</span>
            try {
<span class="nc bnc" id="L5085" title="All 2 branches missed.">                if (i &lt; matcher.to) {</span>
<span class="nc bnc" id="L5086" title="All 2 branches missed.">                    conditionMatched = !cond.match(matcher, i, seq);</span>
                } else {
                    // If a negative lookahead succeeds then more input
                    // could cause it to fail!
<span class="nc" id="L5090">                    matcher.requireEnd = true;</span>
<span class="nc bnc" id="L5091" title="All 2 branches missed.">                    conditionMatched = !cond.match(matcher, i, seq);</span>
                }
            } finally {
                // Reinstate region boundaries
<span class="nc" id="L5095">                matcher.to = savedTo;</span>
<span class="nc" id="L5096">            }</span>
<span class="nc bnc" id="L5097" title="All 4 branches missed.">            return conditionMatched &amp;&amp; next.match(matcher, i, seq);</span>
        }
    }

    /**
     * For use with lookbehinds; matches the position where the lookbehind
     * was encountered.
     */
<span class="fc" id="L5105">    static Node lookbehindEnd = new Node() {</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc bnc" id="L5107" title="All 2 branches missed.">            return i == matcher.lookbehindTo;</span>
        }
    };

    /**
     * Zero width positive lookbehind.
     */
    static class Behind extends Node {
        Node cond;
        int rmax, rmin;
<span class="nc" id="L5117">        Behind(Node cond, int rmax, int rmin) {</span>
<span class="nc" id="L5118">            this.cond = cond;</span>
<span class="nc" id="L5119">            this.rmax = rmax;</span>
<span class="nc" id="L5120">            this.rmin = rmin;</span>
<span class="nc" id="L5121">        }</span>

        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L5124">            int savedFrom = matcher.from;</span>
<span class="nc" id="L5125">            boolean conditionMatched = false;</span>
<span class="nc bnc" id="L5126" title="All 2 branches missed.">            int startIndex = (!matcher.transparentBounds) ?</span>
                             matcher.from : 0;
<span class="nc" id="L5128">            int from = Math.max(i - rmax, startIndex);</span>
            // Set end boundary
<span class="nc" id="L5130">            int savedLBT = matcher.lookbehindTo;</span>
<span class="nc" id="L5131">            matcher.lookbehindTo = i;</span>
            // Relax transparent region boundaries for lookbehind
<span class="nc bnc" id="L5133" title="All 2 branches missed.">            if (matcher.transparentBounds)</span>
<span class="nc" id="L5134">                matcher.from = 0;</span>
<span class="nc bnc" id="L5135" title="All 4 branches missed.">            for (int j = i - rmin; !conditionMatched &amp;&amp; j &gt;= from; j--) {</span>
<span class="nc" id="L5136">                conditionMatched = cond.match(matcher, j, seq);</span>
            }
<span class="nc" id="L5138">            matcher.from = savedFrom;</span>
<span class="nc" id="L5139">            matcher.lookbehindTo = savedLBT;</span>
<span class="nc bnc" id="L5140" title="All 4 branches missed.">            return conditionMatched &amp;&amp; next.match(matcher, i, seq);</span>
        }
    }

    /**
     * Zero width positive lookbehind, including supplementary
     * characters or unpaired surrogates.
     */
    static final class BehindS extends Behind {
        BehindS(Node cond, int rmax, int rmin) {
<span class="nc" id="L5150">            super(cond, rmax, rmin);</span>
<span class="nc" id="L5151">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L5153">            int rmaxChars = countChars(seq, i, -rmax);</span>
<span class="nc" id="L5154">            int rminChars = countChars(seq, i, -rmin);</span>
<span class="nc" id="L5155">            int savedFrom = matcher.from;</span>
<span class="nc bnc" id="L5156" title="All 2 branches missed.">            int startIndex = (!matcher.transparentBounds) ?</span>
                             matcher.from : 0;
<span class="nc" id="L5158">            boolean conditionMatched = false;</span>
<span class="nc" id="L5159">            int from = Math.max(i - rmaxChars, startIndex);</span>
            // Set end boundary
<span class="nc" id="L5161">            int savedLBT = matcher.lookbehindTo;</span>
<span class="nc" id="L5162">            matcher.lookbehindTo = i;</span>
            // Relax transparent region boundaries for lookbehind
<span class="nc bnc" id="L5164" title="All 2 branches missed.">            if (matcher.transparentBounds)</span>
<span class="nc" id="L5165">                matcher.from = 0;</span>

<span class="nc" id="L5167">            for (int j = i - rminChars;</span>
<span class="nc bnc" id="L5168" title="All 4 branches missed.">                 !conditionMatched &amp;&amp; j &gt;= from;</span>
<span class="nc bnc" id="L5169" title="All 2 branches missed.">                 j -= j&gt;from ? countChars(seq, j, -1) : 1) {</span>
<span class="nc" id="L5170">                conditionMatched = cond.match(matcher, j, seq);</span>
            }
<span class="nc" id="L5172">            matcher.from = savedFrom;</span>
<span class="nc" id="L5173">            matcher.lookbehindTo = savedLBT;</span>
<span class="nc bnc" id="L5174" title="All 4 branches missed.">            return conditionMatched &amp;&amp; next.match(matcher, i, seq);</span>
        }
    }

    /**
     * Zero width negative lookbehind.
     */
    static class NotBehind extends Node {
        Node cond;
        int rmax, rmin;
<span class="nc" id="L5184">        NotBehind(Node cond, int rmax, int rmin) {</span>
<span class="nc" id="L5185">            this.cond = cond;</span>
<span class="nc" id="L5186">            this.rmax = rmax;</span>
<span class="nc" id="L5187">            this.rmin = rmin;</span>
<span class="nc" id="L5188">        }</span>

        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L5191">            int savedLBT = matcher.lookbehindTo;</span>
<span class="nc" id="L5192">            int savedFrom = matcher.from;</span>
<span class="nc" id="L5193">            boolean conditionMatched = false;</span>
<span class="nc bnc" id="L5194" title="All 2 branches missed.">            int startIndex = (!matcher.transparentBounds) ?</span>
                             matcher.from : 0;
<span class="nc" id="L5196">            int from = Math.max(i - rmax, startIndex);</span>
<span class="nc" id="L5197">            matcher.lookbehindTo = i;</span>
            // Relax transparent region boundaries for lookbehind
<span class="nc bnc" id="L5199" title="All 2 branches missed.">            if (matcher.transparentBounds)</span>
<span class="nc" id="L5200">                matcher.from = 0;</span>
<span class="nc bnc" id="L5201" title="All 4 branches missed.">            for (int j = i - rmin; !conditionMatched &amp;&amp; j &gt;= from; j--) {</span>
<span class="nc" id="L5202">                conditionMatched = cond.match(matcher, j, seq);</span>
            }
            // Reinstate region boundaries
<span class="nc" id="L5205">            matcher.from = savedFrom;</span>
<span class="nc" id="L5206">            matcher.lookbehindTo = savedLBT;</span>
<span class="nc bnc" id="L5207" title="All 4 branches missed.">            return !conditionMatched &amp;&amp; next.match(matcher, i, seq);</span>
        }
    }

    /**
     * Zero width negative lookbehind, including supplementary
     * characters or unpaired surrogates.
     */
    static final class NotBehindS extends NotBehind {
        NotBehindS(Node cond, int rmax, int rmin) {
<span class="nc" id="L5217">            super(cond, rmax, rmin);</span>
<span class="nc" id="L5218">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L5220">            int rmaxChars = countChars(seq, i, -rmax);</span>
<span class="nc" id="L5221">            int rminChars = countChars(seq, i, -rmin);</span>
<span class="nc" id="L5222">            int savedFrom = matcher.from;</span>
<span class="nc" id="L5223">            int savedLBT = matcher.lookbehindTo;</span>
<span class="nc" id="L5224">            boolean conditionMatched = false;</span>
<span class="nc bnc" id="L5225" title="All 2 branches missed.">            int startIndex = (!matcher.transparentBounds) ?</span>
                             matcher.from : 0;
<span class="nc" id="L5227">            int from = Math.max(i - rmaxChars, startIndex);</span>
<span class="nc" id="L5228">            matcher.lookbehindTo = i;</span>
            // Relax transparent region boundaries for lookbehind
<span class="nc bnc" id="L5230" title="All 2 branches missed.">            if (matcher.transparentBounds)</span>
<span class="nc" id="L5231">                matcher.from = 0;</span>
<span class="nc" id="L5232">            for (int j = i - rminChars;</span>
<span class="nc bnc" id="L5233" title="All 4 branches missed.">                 !conditionMatched &amp;&amp; j &gt;= from;</span>
<span class="nc bnc" id="L5234" title="All 2 branches missed.">                 j -= j&gt;from ? countChars(seq, j, -1) : 1) {</span>
<span class="nc" id="L5235">                conditionMatched = cond.match(matcher, j, seq);</span>
            }
            //Reinstate region boundaries
<span class="nc" id="L5238">            matcher.from = savedFrom;</span>
<span class="nc" id="L5239">            matcher.lookbehindTo = savedLBT;</span>
<span class="nc bnc" id="L5240" title="All 4 branches missed.">            return !conditionMatched &amp;&amp; next.match(matcher, i, seq);</span>
        }
    }

    /**
     * Returns the set union of two CharProperty nodes.
     */
    private static CharProperty union(final CharProperty lhs,
                                      final CharProperty rhs) {
<span class="fc" id="L5249">        return new CharProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="fc bfc" id="L5251" title="All 4 branches covered.">                    return lhs.isSatisfiedBy(ch) || rhs.isSatisfiedBy(ch);}};</span>
    }

    /**
     * Returns the set intersection of two CharProperty nodes.
     */
    private static CharProperty intersection(final CharProperty lhs,
                                             final CharProperty rhs) {
<span class="fc" id="L5259">        return new CharProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="fc bfc" id="L5261" title="All 4 branches covered.">                    return lhs.isSatisfiedBy(ch) &amp;&amp; rhs.isSatisfiedBy(ch);}};</span>
    }

    /**
     * Returns the set difference of two CharProperty nodes.
     */
    private static CharProperty setDifference(final CharProperty lhs,
                                              final CharProperty rhs) {
<span class="fc" id="L5269">        return new CharProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="fc bfc" id="L5271" title="All 4 branches covered.">                    return ! rhs.isSatisfiedBy(ch) &amp;&amp; lhs.isSatisfiedBy(ch);}};</span>
    }

    /**
     * Handles word boundaries. Includes a field to allow this one class to
     * deal with the different types of word boundaries we can match. The word
     * characters include underscores, letters, and digits. Non spacing marks
     * can are also part of a word if they have a base character, otherwise
     * they are ignored for purposes of finding word boundaries.
     */
    static final class Bound extends Node {
<span class="nc" id="L5282">        static int LEFT = 0x1;</span>
<span class="nc" id="L5283">        static int RIGHT= 0x2;</span>
<span class="nc" id="L5284">        static int BOTH = 0x3;</span>
<span class="nc" id="L5285">        static int NONE = 0x4;</span>
        int type;
        boolean useUWORD;
<span class="nc" id="L5288">        Bound(int n, boolean useUWORD) {</span>
<span class="nc" id="L5289">            type = n;</span>
<span class="nc" id="L5290">            this.useUWORD = useUWORD;</span>
<span class="nc" id="L5291">        }</span>

        boolean isWord(int ch) {
<span class="nc bnc" id="L5294" title="All 4 branches missed.">            return useUWORD ? UnicodeProp.WORD.is(ch)</span>
<span class="nc bnc" id="L5295" title="All 2 branches missed.">                            : (ch == '_' || Character.isLetterOrDigit(ch));</span>
        }

        int check(Matcher matcher, int i, CharSequence seq) {
            int ch;
<span class="nc" id="L5300">            boolean left = false;</span>
<span class="nc" id="L5301">            int startIndex = matcher.from;</span>
<span class="nc" id="L5302">            int endIndex = matcher.to;</span>
<span class="nc bnc" id="L5303" title="All 2 branches missed.">            if (matcher.transparentBounds) {</span>
<span class="nc" id="L5304">                startIndex = 0;</span>
<span class="nc" id="L5305">                endIndex = matcher.getTextLength();</span>
            }
<span class="nc bnc" id="L5307" title="All 2 branches missed.">            if (i &gt; startIndex) {</span>
<span class="nc" id="L5308">                ch = Character.codePointBefore(seq, i);</span>
<span class="nc bnc" id="L5309" title="All 2 branches missed.">                left = (isWord(ch) ||</span>
<span class="nc bnc" id="L5310" title="All 2 branches missed.">                    ((Character.getType(ch) == Character.NON_SPACING_MARK)</span>
<span class="nc bnc" id="L5311" title="All 2 branches missed.">                     &amp;&amp; hasBaseCharacter(matcher, i-1, seq)));</span>
            }
<span class="nc" id="L5313">            boolean right = false;</span>
<span class="nc bnc" id="L5314" title="All 2 branches missed.">            if (i &lt; endIndex) {</span>
<span class="nc" id="L5315">                ch = Character.codePointAt(seq, i);</span>
<span class="nc bnc" id="L5316" title="All 2 branches missed.">                right = (isWord(ch) ||</span>
<span class="nc bnc" id="L5317" title="All 2 branches missed.">                    ((Character.getType(ch) == Character.NON_SPACING_MARK)</span>
<span class="nc bnc" id="L5318" title="All 2 branches missed.">                     &amp;&amp; hasBaseCharacter(matcher, i, seq)));</span>
            } else {
                // Tried to access char past the end
<span class="nc" id="L5321">                matcher.hitEnd = true;</span>
                // The addition of another char could wreck a boundary
<span class="nc" id="L5323">                matcher.requireEnd = true;</span>
            }
<span class="nc bnc" id="L5325" title="All 4 branches missed.">            return ((left ^ right) ? (right ? LEFT : RIGHT) : NONE);</span>
        }
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc bnc" id="L5328" title="All 2 branches missed.">            return (check(matcher, i, seq) &amp; type) &gt; 0</span>
<span class="nc bnc" id="L5329" title="All 2 branches missed.">                &amp;&amp; next.match(matcher, i, seq);</span>
        }
    }

    /**
     * Non spacing marks only count as word characters in bounds calculations
     * if they have a base character.
     */
    private static boolean hasBaseCharacter(Matcher matcher, int i,
                                            CharSequence seq)
    {
<span class="nc bnc" id="L5340" title="All 2 branches missed.">        int start = (!matcher.transparentBounds) ?</span>
            matcher.from : 0;
<span class="nc bnc" id="L5342" title="All 2 branches missed.">        for (int x=i; x &gt;= start; x--) {</span>
<span class="nc" id="L5343">            int ch = Character.codePointAt(seq, x);</span>
<span class="nc bnc" id="L5344" title="All 2 branches missed.">            if (Character.isLetterOrDigit(ch))</span>
<span class="nc" id="L5345">                return true;</span>
<span class="nc bnc" id="L5346" title="All 2 branches missed.">            if (Character.getType(ch) == Character.NON_SPACING_MARK)</span>
<span class="nc" id="L5347">                continue;</span>
<span class="nc" id="L5348">            return false;</span>
        }
<span class="nc" id="L5350">        return false;</span>
    }

    /**
     * Attempts to match a slice in the input using the Boyer-Moore string
     * matching algorithm. The algorithm is based on the idea that the
     * pattern can be shifted farther ahead in the search text if it is
     * matched right to left.
     * &lt;p&gt;
     * The pattern is compared to the input one character at a time, from
     * the rightmost character in the pattern to the left. If the characters
     * all match the pattern has been found. If a character does not match,
     * the pattern is shifted right a distance that is the maximum of two
     * functions, the bad character shift and the good suffix shift. This
     * shift moves the attempted match position through the input more
     * quickly than a naive one position at a time check.
     * &lt;p&gt;
     * The bad character shift is based on the character from the text that
     * did not match. If the character does not appear in the pattern, the
     * pattern can be shifted completely beyond the bad character. If the
     * character does occur in the pattern, the pattern can be shifted to
     * line the pattern up with the next occurrence of that character.
     * &lt;p&gt;
     * The good suffix shift is based on the idea that some subset on the right
     * side of the pattern has matched. When a bad character is found, the
     * pattern can be shifted right by the pattern length if the subset does
     * not occur again in pattern, or by the amount of distance to the
     * next occurrence of the subset in the pattern.
     *
     * Boyer-Moore search methods adapted from code by Amy Yu.
     */
    static class BnM extends Node {
        int[] buffer;
        int[] lastOcc;
        int[] optoSft;

        /**
         * Pre calculates arrays needed to generate the bad character
         * shift and the good suffix shift. Only the last seven bits
         * are used to see if chars match; This keeps the tables small
         * and covers the heavily used ASCII range, but occasionally
         * results in an aliased match for the bad character shift.
         */
        static Node optimize(Node node) {
<span class="pc bpc" id="L5394" title="1 of 2 branches missed.">            if (!(node instanceof Slice)) {</span>
<span class="nc" id="L5395">                return node;</span>
            }

<span class="fc" id="L5398">            int[] src = ((Slice) node).buffer;</span>
<span class="fc" id="L5399">            int patternLength = src.length;</span>
            // The BM algorithm requires a bit of overhead;
            // If the pattern is short don't use it, since
            // a shift larger than the pattern length cannot
            // be used anyway.
<span class="fc bfc" id="L5404" title="All 2 branches covered.">            if (patternLength &lt; 4) {</span>
<span class="fc" id="L5405">                return node;</span>
            }
            int i, j, k;
<span class="fc" id="L5408">            int[] lastOcc = new int[128];</span>
<span class="fc" id="L5409">            int[] optoSft = new int[patternLength];</span>
            // Precalculate part of the bad character shift
            // It is a table for where in the pattern each
            // lower 7-bit value occurs
<span class="fc bfc" id="L5413" title="All 2 branches covered.">            for (i = 0; i &lt; patternLength; i++) {</span>
<span class="fc" id="L5414">                lastOcc[src[i]&amp;0x7F] = i + 1;</span>
            }
            // Precalculate the good suffix shift
            // i is the shift amount being considered
<span class="fc bfc" id="L5418" title="All 2 branches covered.">NEXT:       for (i = patternLength; i &gt; 0; i--) {</span>
                // j is the beginning index of suffix being considered
<span class="fc bfc" id="L5420" title="All 2 branches covered.">                for (j = patternLength - 1; j &gt;= i; j--) {</span>
                    // Testing for good suffix
<span class="fc bfc" id="L5422" title="All 2 branches covered.">                    if (src[j] == src[j-i]) {</span>
                        // src[j..len] is a good suffix
<span class="fc" id="L5424">                        optoSft[j-1] = i;</span>
                    } else {
                        // No match. The array has already been
                        // filled up with correct values before.
                        continue NEXT;
                    }
                }
                // This fills up the remaining of optoSft
                // any suffix can not have larger shift amount
                // then its sub-suffix. Why???
<span class="fc bfc" id="L5434" title="All 2 branches covered.">                while (j &gt; 0) {</span>
<span class="fc" id="L5435">                    optoSft[--j] = i;</span>
                }
            }
            // Set the guard value because of unicode compression
<span class="fc" id="L5439">            optoSft[patternLength-1] = 1;</span>
<span class="pc bpc" id="L5440" title="1 of 2 branches missed.">            if (node instanceof SliceS)</span>
<span class="nc" id="L5441">                return new BnMS(src, lastOcc, optoSft, node.next);</span>
<span class="fc" id="L5442">            return new BnM(src, lastOcc, optoSft, node.next);</span>
        }
<span class="fc" id="L5444">        BnM(int[] src, int[] lastOcc, int[] optoSft, Node next) {</span>
<span class="fc" id="L5445">            this.buffer = src;</span>
<span class="fc" id="L5446">            this.lastOcc = lastOcc;</span>
<span class="fc" id="L5447">            this.optoSft = optoSft;</span>
<span class="fc" id="L5448">            this.next = next;</span>
<span class="fc" id="L5449">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="fc" id="L5451">            int[] src = buffer;</span>
<span class="fc" id="L5452">            int patternLength = src.length;</span>
<span class="fc" id="L5453">            int last = matcher.to - patternLength;</span>

            // Loop over all possible match positions in text
<span class="fc bfc" id="L5456" title="All 2 branches covered.">NEXT:       while (i &lt;= last) {</span>
                // Loop over pattern from right to left
<span class="fc bfc" id="L5458" title="All 2 branches covered.">                for (int j = patternLength - 1; j &gt;= 0; j--) {</span>
<span class="fc" id="L5459">                    int ch = seq.charAt(i+j);</span>
<span class="fc bfc" id="L5460" title="All 2 branches covered.">                    if (ch != src[j]) {</span>
                        // Shift search to the right by the maximum of the
                        // bad character shift and the good suffix shift
<span class="fc" id="L5463">                        i += Math.max(j + 1 - lastOcc[ch&amp;0x7F], optoSft[j]);</span>
<span class="fc" id="L5464">                        continue NEXT;</span>
                    }
                }
                // Entire pattern matched starting at i
<span class="fc" id="L5468">                matcher.first = i;</span>
<span class="fc" id="L5469">                boolean ret = next.match(matcher, i + patternLength, seq);</span>
<span class="pc bpc" id="L5470" title="1 of 2 branches missed.">                if (ret) {</span>
<span class="fc" id="L5471">                    matcher.first = i;</span>
<span class="fc" id="L5472">                    matcher.groups[0] = matcher.first;</span>
<span class="fc" id="L5473">                    matcher.groups[1] = matcher.last;</span>
<span class="fc" id="L5474">                    return true;</span>
                }
<span class="nc" id="L5476">                i++;</span>
<span class="nc" id="L5477">            }</span>
            // BnM is only used as the leading node in the unanchored case,
            // and it replaced its Start() which always searches to the end
            // if it doesn't find what it's looking for, so hitEnd is true.
<span class="fc" id="L5481">            matcher.hitEnd = true;</span>
<span class="fc" id="L5482">            return false;</span>
        }
        boolean study(TreeInfo info) {
<span class="nc" id="L5485">            info.minLength += buffer.length;</span>
<span class="nc" id="L5486">            info.maxValid = false;</span>
<span class="nc" id="L5487">            return next.study(info);</span>
        }
    }

    /**
     * Supplementary support version of BnM(). Unpaired surrogates are
     * also handled by this class.
     */
    static final class BnMS extends BnM {
        int lengthInChars;

        BnMS(int[] src, int[] lastOcc, int[] optoSft, Node next) {
<span class="nc" id="L5499">            super(src, lastOcc, optoSft, next);</span>
<span class="nc bnc" id="L5500" title="All 2 branches missed.">            for (int x = 0; x &lt; buffer.length; x++) {</span>
<span class="nc" id="L5501">                lengthInChars += Character.charCount(buffer[x]);</span>
            }
<span class="nc" id="L5503">        }</span>
        boolean match(Matcher matcher, int i, CharSequence seq) {
<span class="nc" id="L5505">            int[] src = buffer;</span>
<span class="nc" id="L5506">            int patternLength = src.length;</span>
<span class="nc" id="L5507">            int last = matcher.to - lengthInChars;</span>

            // Loop over all possible match positions in text
<span class="nc bnc" id="L5510" title="All 2 branches missed.">NEXT:       while (i &lt;= last) {</span>
                // Loop over pattern from right to left
                int ch;
<span class="nc" id="L5513">                for (int j = countChars(seq, i, patternLength), x = patternLength - 1;</span>
<span class="nc bnc" id="L5514" title="All 2 branches missed.">                     j &gt; 0; j -= Character.charCount(ch), x--) {</span>
<span class="nc" id="L5515">                    ch = Character.codePointBefore(seq, i+j);</span>
<span class="nc bnc" id="L5516" title="All 2 branches missed.">                    if (ch != src[x]) {</span>
                        // Shift search to the right by the maximum of the
                        // bad character shift and the good suffix shift
<span class="nc" id="L5519">                        int n = Math.max(x + 1 - lastOcc[ch&amp;0x7F], optoSft[x]);</span>
<span class="nc" id="L5520">                        i += countChars(seq, i, n);</span>
<span class="nc" id="L5521">                        continue NEXT;</span>
                    }
                }
                // Entire pattern matched starting at i
<span class="nc" id="L5525">                matcher.first = i;</span>
<span class="nc" id="L5526">                boolean ret = next.match(matcher, i + lengthInChars, seq);</span>
<span class="nc bnc" id="L5527" title="All 2 branches missed.">                if (ret) {</span>
<span class="nc" id="L5528">                    matcher.first = i;</span>
<span class="nc" id="L5529">                    matcher.groups[0] = matcher.first;</span>
<span class="nc" id="L5530">                    matcher.groups[1] = matcher.last;</span>
<span class="nc" id="L5531">                    return true;</span>
                }
<span class="nc" id="L5533">                i += countChars(seq, i, 1);</span>
<span class="nc" id="L5534">            }</span>
<span class="nc" id="L5535">            matcher.hitEnd = true;</span>
<span class="nc" id="L5536">            return false;</span>
        }
    }

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

    /**
     *  This must be the very first initializer.
     */
<span class="fc" id="L5546">    static Node accept = new Node();</span>

<span class="fc" id="L5548">    static Node lastAccept = new LastNode();</span>

<span class="nc" id="L5550">    private static class CharPropertyNames {</span>

        static CharProperty charPropertyFor(String name) {
<span class="fc" id="L5553">            CharPropertyFactory m = map.get(name);</span>
<span class="pc bpc" id="L5554" title="1 of 2 branches missed.">            return m == null ? null : m.make();</span>
        }

<span class="fc" id="L5557">        private static abstract class CharPropertyFactory {</span>
            abstract CharProperty make();
        }

        private static void defCategory(String name,
                                        final int typeMask) {
<span class="fc" id="L5563">            map.put(name, new CharPropertyFactory() {</span>
<span class="nc" id="L5564">                    CharProperty make() { return new Category(typeMask);}});</span>
<span class="fc" id="L5565">        }</span>

        private static void defRange(String name,
                                     final int lower, final int upper) {
<span class="fc" id="L5569">            map.put(name, new CharPropertyFactory() {</span>
<span class="fc" id="L5570">                    CharProperty make() { return rangeFor(lower, upper);}});</span>
<span class="fc" id="L5571">        }</span>

        private static void defCtype(String name,
                                     final int ctype) {
<span class="fc" id="L5575">            map.put(name, new CharPropertyFactory() {</span>
<span class="fc" id="L5576">                    CharProperty make() { return new Ctype(ctype);}});</span>
<span class="fc" id="L5577">        }</span>

<span class="pc" id="L5579">        private static abstract class CloneableProperty</span>
            extends CharProperty implements Cloneable
        {
            public CloneableProperty clone() {
                try {
<span class="fc" id="L5584">                    return (CloneableProperty) super.clone();</span>
<span class="nc" id="L5585">                } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L5586">                    throw new AssertionError(e);</span>
                }
            }
        }

        private static void defClone(String name,
                                     final CloneableProperty p) {
<span class="fc" id="L5593">            map.put(name, new CharPropertyFactory() {</span>
<span class="fc" id="L5594">                    CharProperty make() { return p.clone();}});</span>
<span class="fc" id="L5595">        }</span>

<span class="fc" id="L5597">        private static final HashMap&lt;String, CharPropertyFactory&gt; map</span>
            = new HashMap&lt;&gt;();

        static {
            // Unicode character property aliases, defined in
            // http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt
<span class="fc" id="L5603">            defCategory(&quot;Cn&quot;, 1&lt;&lt;Character.UNASSIGNED);</span>
<span class="fc" id="L5604">            defCategory(&quot;Lu&quot;, 1&lt;&lt;Character.UPPERCASE_LETTER);</span>
<span class="fc" id="L5605">            defCategory(&quot;Ll&quot;, 1&lt;&lt;Character.LOWERCASE_LETTER);</span>
<span class="fc" id="L5606">            defCategory(&quot;Lt&quot;, 1&lt;&lt;Character.TITLECASE_LETTER);</span>
<span class="fc" id="L5607">            defCategory(&quot;Lm&quot;, 1&lt;&lt;Character.MODIFIER_LETTER);</span>
<span class="fc" id="L5608">            defCategory(&quot;Lo&quot;, 1&lt;&lt;Character.OTHER_LETTER);</span>
<span class="fc" id="L5609">            defCategory(&quot;Mn&quot;, 1&lt;&lt;Character.NON_SPACING_MARK);</span>
<span class="fc" id="L5610">            defCategory(&quot;Me&quot;, 1&lt;&lt;Character.ENCLOSING_MARK);</span>
<span class="fc" id="L5611">            defCategory(&quot;Mc&quot;, 1&lt;&lt;Character.COMBINING_SPACING_MARK);</span>
<span class="fc" id="L5612">            defCategory(&quot;Nd&quot;, 1&lt;&lt;Character.DECIMAL_DIGIT_NUMBER);</span>
<span class="fc" id="L5613">            defCategory(&quot;Nl&quot;, 1&lt;&lt;Character.LETTER_NUMBER);</span>
<span class="fc" id="L5614">            defCategory(&quot;No&quot;, 1&lt;&lt;Character.OTHER_NUMBER);</span>
<span class="fc" id="L5615">            defCategory(&quot;Zs&quot;, 1&lt;&lt;Character.SPACE_SEPARATOR);</span>
<span class="fc" id="L5616">            defCategory(&quot;Zl&quot;, 1&lt;&lt;Character.LINE_SEPARATOR);</span>
<span class="fc" id="L5617">            defCategory(&quot;Zp&quot;, 1&lt;&lt;Character.PARAGRAPH_SEPARATOR);</span>
<span class="fc" id="L5618">            defCategory(&quot;Cc&quot;, 1&lt;&lt;Character.CONTROL);</span>
<span class="fc" id="L5619">            defCategory(&quot;Cf&quot;, 1&lt;&lt;Character.FORMAT);</span>
<span class="fc" id="L5620">            defCategory(&quot;Co&quot;, 1&lt;&lt;Character.PRIVATE_USE);</span>
<span class="fc" id="L5621">            defCategory(&quot;Cs&quot;, 1&lt;&lt;Character.SURROGATE);</span>
<span class="fc" id="L5622">            defCategory(&quot;Pd&quot;, 1&lt;&lt;Character.DASH_PUNCTUATION);</span>
<span class="fc" id="L5623">            defCategory(&quot;Ps&quot;, 1&lt;&lt;Character.START_PUNCTUATION);</span>
<span class="fc" id="L5624">            defCategory(&quot;Pe&quot;, 1&lt;&lt;Character.END_PUNCTUATION);</span>
<span class="fc" id="L5625">            defCategory(&quot;Pc&quot;, 1&lt;&lt;Character.CONNECTOR_PUNCTUATION);</span>
<span class="fc" id="L5626">            defCategory(&quot;Po&quot;, 1&lt;&lt;Character.OTHER_PUNCTUATION);</span>
<span class="fc" id="L5627">            defCategory(&quot;Sm&quot;, 1&lt;&lt;Character.MATH_SYMBOL);</span>
<span class="fc" id="L5628">            defCategory(&quot;Sc&quot;, 1&lt;&lt;Character.CURRENCY_SYMBOL);</span>
<span class="fc" id="L5629">            defCategory(&quot;Sk&quot;, 1&lt;&lt;Character.MODIFIER_SYMBOL);</span>
<span class="fc" id="L5630">            defCategory(&quot;So&quot;, 1&lt;&lt;Character.OTHER_SYMBOL);</span>
<span class="fc" id="L5631">            defCategory(&quot;Pi&quot;, 1&lt;&lt;Character.INITIAL_QUOTE_PUNCTUATION);</span>
<span class="fc" id="L5632">            defCategory(&quot;Pf&quot;, 1&lt;&lt;Character.FINAL_QUOTE_PUNCTUATION);</span>
<span class="fc" id="L5633">            defCategory(&quot;L&quot;, ((1&lt;&lt;Character.UPPERCASE_LETTER) |</span>
                              (1&lt;&lt;Character.LOWERCASE_LETTER) |
                              (1&lt;&lt;Character.TITLECASE_LETTER) |
                              (1&lt;&lt;Character.MODIFIER_LETTER)  |
                              (1&lt;&lt;Character.OTHER_LETTER)));
<span class="fc" id="L5638">            defCategory(&quot;M&quot;, ((1&lt;&lt;Character.NON_SPACING_MARK) |</span>
                              (1&lt;&lt;Character.ENCLOSING_MARK)   |
                              (1&lt;&lt;Character.COMBINING_SPACING_MARK)));
<span class="fc" id="L5641">            defCategory(&quot;N&quot;, ((1&lt;&lt;Character.DECIMAL_DIGIT_NUMBER) |</span>
                              (1&lt;&lt;Character.LETTER_NUMBER)        |
                              (1&lt;&lt;Character.OTHER_NUMBER)));
<span class="fc" id="L5644">            defCategory(&quot;Z&quot;, ((1&lt;&lt;Character.SPACE_SEPARATOR) |</span>
                              (1&lt;&lt;Character.LINE_SEPARATOR)  |
                              (1&lt;&lt;Character.PARAGRAPH_SEPARATOR)));
<span class="fc" id="L5647">            defCategory(&quot;C&quot;, ((1&lt;&lt;Character.CONTROL)     |</span>
                              (1&lt;&lt;Character.FORMAT)      |
                              (1&lt;&lt;Character.PRIVATE_USE) |
                              (1&lt;&lt;Character.SURROGATE))); // Other
<span class="fc" id="L5651">            defCategory(&quot;P&quot;, ((1&lt;&lt;Character.DASH_PUNCTUATION)      |</span>
                              (1&lt;&lt;Character.START_PUNCTUATION)     |
                              (1&lt;&lt;Character.END_PUNCTUATION)       |
                              (1&lt;&lt;Character.CONNECTOR_PUNCTUATION) |
                              (1&lt;&lt;Character.OTHER_PUNCTUATION)     |
                              (1&lt;&lt;Character.INITIAL_QUOTE_PUNCTUATION) |
                              (1&lt;&lt;Character.FINAL_QUOTE_PUNCTUATION)));
<span class="fc" id="L5658">            defCategory(&quot;S&quot;, ((1&lt;&lt;Character.MATH_SYMBOL)     |</span>
                              (1&lt;&lt;Character.CURRENCY_SYMBOL) |
                              (1&lt;&lt;Character.MODIFIER_SYMBOL) |
                              (1&lt;&lt;Character.OTHER_SYMBOL)));
<span class="fc" id="L5662">            defCategory(&quot;LC&quot;, ((1&lt;&lt;Character.UPPERCASE_LETTER) |</span>
                               (1&lt;&lt;Character.LOWERCASE_LETTER) |
                               (1&lt;&lt;Character.TITLECASE_LETTER)));
<span class="fc" id="L5665">            defCategory(&quot;LD&quot;, ((1&lt;&lt;Character.UPPERCASE_LETTER) |</span>
                               (1&lt;&lt;Character.LOWERCASE_LETTER) |
                               (1&lt;&lt;Character.TITLECASE_LETTER) |
                               (1&lt;&lt;Character.MODIFIER_LETTER)  |
                               (1&lt;&lt;Character.OTHER_LETTER)     |
                               (1&lt;&lt;Character.DECIMAL_DIGIT_NUMBER)));
<span class="fc" id="L5671">            defRange(&quot;L1&quot;, 0x00, 0xFF); // Latin-1</span>
<span class="fc" id="L5672">            map.put(&quot;all&quot;, new CharPropertyFactory() {</span>
<span class="fc" id="L5673">                    CharProperty make() { return new All(); }});</span>

            // Posix regular expression character classes, defined in
            // http://www.unix.org/onlinepubs/009695399/basedefs/xbd_chap09.html
<span class="fc" id="L5677">            defRange(&quot;ASCII&quot;, 0x00, 0x7F);   // ASCII</span>
<span class="fc" id="L5678">            defCtype(&quot;Alnum&quot;, ASCII.ALNUM);  // Alphanumeric characters</span>
<span class="fc" id="L5679">            defCtype(&quot;Alpha&quot;, ASCII.ALPHA);  // Alphabetic characters</span>
<span class="fc" id="L5680">            defCtype(&quot;Blank&quot;, ASCII.BLANK);  // Space and tab characters</span>
<span class="fc" id="L5681">            defCtype(&quot;Cntrl&quot;, ASCII.CNTRL);  // Control characters</span>
<span class="fc" id="L5682">            defRange(&quot;Digit&quot;, '0', '9');     // Numeric characters</span>
<span class="fc" id="L5683">            defCtype(&quot;Graph&quot;, ASCII.GRAPH);  // printable and visible</span>
<span class="fc" id="L5684">            defRange(&quot;Lower&quot;, 'a', 'z');     // Lower-case alphabetic</span>
<span class="fc" id="L5685">            defRange(&quot;Print&quot;, 0x20, 0x7E);   // Printable characters</span>
<span class="fc" id="L5686">            defCtype(&quot;Punct&quot;, ASCII.PUNCT);  // Punctuation characters</span>
<span class="fc" id="L5687">            defCtype(&quot;Space&quot;, ASCII.SPACE);  // Space characters</span>
<span class="fc" id="L5688">            defRange(&quot;Upper&quot;, 'A', 'Z');     // Upper-case alphabetic</span>
<span class="fc" id="L5689">            defCtype(&quot;XDigit&quot;,ASCII.XDIGIT); // hexadecimal digits</span>

            // Java character properties, defined by methods in Character.java
<span class="fc" id="L5692">            defClone(&quot;javaLowerCase&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5694">                    return Character.isLowerCase(ch);}});</span>
<span class="fc" id="L5695">            defClone(&quot;javaUpperCase&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5697">                    return Character.isUpperCase(ch);}});</span>
<span class="fc" id="L5698">            defClone(&quot;javaAlphabetic&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5700">                    return Character.isAlphabetic(ch);}});</span>
<span class="fc" id="L5701">            defClone(&quot;javaIdeographic&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5703">                    return Character.isIdeographic(ch);}});</span>
<span class="fc" id="L5704">            defClone(&quot;javaTitleCase&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5706">                    return Character.isTitleCase(ch);}});</span>
<span class="fc" id="L5707">            defClone(&quot;javaDigit&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5709">                    return Character.isDigit(ch);}});</span>
<span class="fc" id="L5710">            defClone(&quot;javaDefined&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5712">                    return Character.isDefined(ch);}});</span>
<span class="fc" id="L5713">            defClone(&quot;javaLetter&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5715">                    return Character.isLetter(ch);}});</span>
<span class="fc" id="L5716">            defClone(&quot;javaLetterOrDigit&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5718">                    return Character.isLetterOrDigit(ch);}});</span>
<span class="fc" id="L5719">            defClone(&quot;javaJavaIdentifierStart&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5721">                    return Character.isJavaIdentifierStart(ch);}});</span>
<span class="fc" id="L5722">            defClone(&quot;javaJavaIdentifierPart&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5724">                    return Character.isJavaIdentifierPart(ch);}});</span>
<span class="fc" id="L5725">            defClone(&quot;javaUnicodeIdentifierStart&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5727">                    return Character.isUnicodeIdentifierStart(ch);}});</span>
<span class="fc" id="L5728">            defClone(&quot;javaUnicodeIdentifierPart&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5730">                    return Character.isUnicodeIdentifierPart(ch);}});</span>
<span class="fc" id="L5731">            defClone(&quot;javaIdentifierIgnorable&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5733">                    return Character.isIdentifierIgnorable(ch);}});</span>
<span class="fc" id="L5734">            defClone(&quot;javaSpaceChar&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5736">                    return Character.isSpaceChar(ch);}});</span>
<span class="fc" id="L5737">            defClone(&quot;javaWhitespace&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="fc" id="L5739">                    return Character.isWhitespace(ch);}});</span>
<span class="fc" id="L5740">            defClone(&quot;javaISOControl&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5742">                    return Character.isISOControl(ch);}});</span>
<span class="fc" id="L5743">            defClone(&quot;javaMirrored&quot;, new CloneableProperty() {</span>
                boolean isSatisfiedBy(int ch) {
<span class="nc" id="L5745">                    return Character.isMirrored(ch);}});</span>
<span class="fc" id="L5746">        }</span>
    }

    /**
     * Creates a predicate which can be used to match a string.
     *
     * @return  The predicate which can be used for matching on a string
     * @since   1.8
     */
    public Predicate&lt;String&gt; asPredicate() {
<span class="nc" id="L5756">        return s -&gt; matcher(s).find();</span>
    }

    /**
     * Creates a stream from the given input sequence around matches of this
     * pattern.
     *
     * &lt;p&gt; The stream returned by this method contains each substring of the
     * input sequence that is terminated by another subsequence that matches
     * this pattern or is terminated by the end of the input sequence.  The
     * substrings in the stream are in the order in which they occur in the
     * input. Trailing empty strings will be discarded and not encountered in
     * the stream.
     *
     * &lt;p&gt; If this pattern does not match any subsequence of the input then
     * the resulting stream has just one element, namely the input sequence in
     * string form.
     *
     * &lt;p&gt; When there is a positive-width match at the beginning of the input
     * sequence then an empty leading substring is included at the beginning
     * of the stream. A zero-width match at the beginning however never produces
     * such empty leading substring.
     *
     * &lt;p&gt; If the input sequence is mutable, it must remain constant during the
     * execution of the terminal stream operation.  Otherwise, the result of the
     * terminal stream operation is undefined.
     *
     * @param   input
     *          The character sequence to be split
     *
     * @return  The stream of strings computed by splitting the input
     *          around matches of this pattern
     * @see     #split(CharSequence)
     * @since   1.8
     */
    public Stream&lt;String&gt; splitAsStream(final CharSequence input) {
        class MatcherIterator implements Iterator&lt;String&gt; {
            private final Matcher matcher;
            // The start position of the next sub-sequence of input
            // when current == input.length there are no more elements
            private int current;
            // null if the next element, if any, needs to obtained
            private String nextElement;
            // &gt; 0 if there are N next empty elements
            private int emptyElementCount;

<span class="fc" id="L5802">            MatcherIterator() {</span>
<span class="fc" id="L5803">                this.matcher = matcher(input);</span>
<span class="fc" id="L5804">            }</span>

            public String next() {
<span class="pc bpc" id="L5807" title="1 of 2 branches missed.">                if (!hasNext())</span>
<span class="nc" id="L5808">                    throw new NoSuchElementException();</span>

<span class="fc bfc" id="L5810" title="All 2 branches covered.">                if (emptyElementCount == 0) {</span>
<span class="fc" id="L5811">                    String n = nextElement;</span>
<span class="fc" id="L5812">                    nextElement = null;</span>
<span class="fc" id="L5813">                    return n;</span>
                } else {
<span class="fc" id="L5815">                    emptyElementCount--;</span>
<span class="fc" id="L5816">                    return &quot;&quot;;</span>
                }
            }

            public boolean hasNext() {
<span class="pc bpc" id="L5821" title="1 of 4 branches missed.">                if (nextElement != null || emptyElementCount &gt; 0)</span>
<span class="fc" id="L5822">                    return true;</span>

<span class="fc bfc" id="L5824" title="All 2 branches covered.">                if (current == input.length())</span>
<span class="fc" id="L5825">                    return false;</span>

                // Consume the next matching element
                // Count sequence of matching empty elements
<span class="fc bfc" id="L5829" title="All 2 branches covered.">                while (matcher.find()) {</span>
<span class="fc" id="L5830">                    nextElement = input.subSequence(current, matcher.start()).toString();</span>
<span class="fc" id="L5831">                    current = matcher.end();</span>
<span class="fc bfc" id="L5832" title="All 2 branches covered.">                    if (!nextElement.isEmpty()) {</span>
<span class="fc" id="L5833">                        return true;</span>
<span class="pc bpc" id="L5834" title="1 of 2 branches missed.">                    } else if (current &gt; 0) { // no empty leading substring for zero-width</span>
                                              // match at the beginning of the input
<span class="fc" id="L5836">                        emptyElementCount++;</span>
                    }
                }

                // Consume last matching element
<span class="fc" id="L5841">                nextElement = input.subSequence(current, input.length()).toString();</span>
<span class="fc" id="L5842">                current = input.length();</span>
<span class="pc bpc" id="L5843" title="1 of 2 branches missed.">                if (!nextElement.isEmpty()) {</span>
<span class="fc" id="L5844">                    return true;</span>
                } else {
                    // Ignore a terminal sequence of matching empty elements
<span class="nc" id="L5847">                    emptyElementCount = 0;</span>
<span class="nc" id="L5848">                    nextElement = null;</span>
<span class="nc" id="L5849">                    return false;</span>
                }
            }
        }
<span class="fc" id="L5853">        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(</span>
                new MatcherIterator(), Spliterator.ORDERED | Spliterator.NONNULL), false);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>