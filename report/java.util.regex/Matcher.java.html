<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Matcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.regex</a> &gt; <span class="el_source">Matcher.java</span></div><h1>Matcher.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util.regex;

import java.util.Objects;

/**
 * An engine that performs match operations on a {@linkplain java.lang.CharSequence
 * character sequence} by interpreting a {@link Pattern}.
 *
 * &lt;p&gt; A matcher is created from a pattern by invoking the pattern's {@link
 * Pattern#matcher matcher} method.  Once created, a matcher can be used to
 * perform three different kinds of match operations:
 *
 * &lt;ul&gt;
 *
 *   &lt;li&gt;&lt;p&gt; The {@link #matches matches} method attempts to match the entire
 *   input sequence against the pattern.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; The {@link #lookingAt lookingAt} method attempts to match the
 *   input sequence, starting at the beginning, against the pattern.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; The {@link #find find} method scans the input sequence looking for
 *   the next subsequence that matches the pattern.  &lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt; Each of these methods returns a boolean indicating success or failure.
 * More information about a successful match can be obtained by querying the
 * state of the matcher.
 *
 * &lt;p&gt; A matcher finds matches in a subset of its input called the
 * &lt;i&gt;region&lt;/i&gt;. By default, the region contains all of the matcher's input.
 * The region can be modified via the{@link #region region} method and queried
 * via the {@link #regionStart regionStart} and {@link #regionEnd regionEnd}
 * methods. The way that the region boundaries interact with some pattern
 * constructs can be changed. See {@link #useAnchoringBounds
 * useAnchoringBounds} and {@link #useTransparentBounds useTransparentBounds}
 * for more details.
 *
 * &lt;p&gt; This class also defines methods for replacing matched subsequences with
 * new strings whose contents can, if desired, be computed from the match
 * result.  The {@link #appendReplacement appendReplacement} and {@link
 * #appendTail appendTail} methods can be used in tandem in order to collect
 * the result into an existing string buffer, or the more convenient {@link
 * #replaceAll replaceAll} method can be used to create a string in which every
 * matching subsequence in the input sequence is replaced.
 *
 * &lt;p&gt; The explicit state of a matcher includes the start and end indices of
 * the most recent successful match.  It also includes the start and end
 * indices of the input subsequence captured by each &lt;a
 * href=&quot;Pattern.html#cg&quot;&gt;capturing group&lt;/a&gt; in the pattern as well as a total
 * count of such subsequences.  As a convenience, methods are also provided for
 * returning these captured subsequences in string form.
 *
 * &lt;p&gt; The explicit state of a matcher is initially undefined; attempting to
 * query any part of it before a successful match will cause an {@link
 * IllegalStateException} to be thrown.  The explicit state of a matcher is
 * recomputed by every match operation.
 *
 * &lt;p&gt; The implicit state of a matcher includes the input character sequence as
 * well as the &lt;i&gt;append position&lt;/i&gt;, which is initially zero and is updated
 * by the {@link #appendReplacement appendReplacement} method.
 *
 * &lt;p&gt; A matcher may be reset explicitly by invoking its {@link #reset()}
 * method or, if a new input sequence is desired, its {@link
 * #reset(java.lang.CharSequence) reset(CharSequence)} method.  Resetting a
 * matcher discards its explicit state information and sets the append position
 * to zero.
 *
 * &lt;p&gt; Instances of this class are not safe for use by multiple concurrent
 * threads. &lt;/p&gt;
 *
 *
 * @author      Mike McCloskey
 * @author      Mark Reinhold
 * @author      JSR-51 Expert Group
 * @since       1.4
 * @spec        JSR-51
 */

public final class Matcher implements MatchResult {

    /**
     * The Pattern object that created this Matcher.
     */
    Pattern parentPattern;

    /**
     * The storage used by groups. They may contain invalid values if
     * a group was skipped during the matching.
     */
    int[] groups;

    /**
     * The range within the sequence that is to be matched. Anchors
     * will match at these &quot;hard&quot; boundaries. Changing the region
     * changes these values.
     */
    int from, to;

    /**
     * Lookbehind uses this value to ensure that the subexpression
     * match ends at the point where the lookbehind was encountered.
     */
    int lookbehindTo;

    /**
     * The original string being matched.
     */
    CharSequence text;

    /**
     * Matcher state used by the last node. NOANCHOR is used when a
     * match does not have to consume all of the input. ENDANCHOR is
     * the mode used for matching all the input.
     */
    static final int ENDANCHOR = 1;
    static final int NOANCHOR = 0;
<span class="pc" id="L143">    int acceptMode = NOANCHOR;</span>

    /**
     * The range of string that last matched the pattern. If the last
     * match failed then first is -1; last initially holds 0 then it
     * holds the index of the end of the last match (which is where the
     * next search starts).
     */
<span class="pc" id="L151">    int first = -1, last = 0;</span>

    /**
     * The end index of what matched in the last match operation.
     */
<span class="pc" id="L156">    int oldLast = -1;</span>

    /**
     * The index of the last position appended in a substitution.
     */
<span class="pc" id="L161">    int lastAppendPosition = 0;</span>

    /**
     * Storage used by nodes to tell what repetition they are on in
     * a pattern, and where groups begin. The nodes themselves are stateless,
     * so they rely on this field to hold state during a match.
     */
    int[] locals;

    /**
     * Boolean indicating whether or not more input could change
     * the results of the last match.
     *
     * If hitEnd is true, and a match was found, then more input
     * might cause a different match to be found.
     * If hitEnd is true and a match was not found, then more
     * input could cause a match to be found.
     * If hitEnd is false and a match was found, then more input
     * will not change the match.
     * If hitEnd is false and a match was not found, then more
     * input will not cause a match to be found.
     */
    boolean hitEnd;

    /**
     * Boolean indicating whether or not more input could change
     * a positive match into a negative one.
     *
     * If requireEnd is true, and a match was found, then more
     * input could cause the match to be lost.
     * If requireEnd is false and a match was found, then more
     * input might change the match but the match won't be lost.
     * If a match was not found, then requireEnd has no meaning.
     */
    boolean requireEnd;

    /**
     * If transparentBounds is true then the boundaries of this
     * matcher's region are transparent to lookahead, lookbehind,
     * and boundary matching constructs that try to see beyond them.
     */
<span class="pc" id="L202">    boolean transparentBounds = false;</span>

    /**
     * If anchoringBounds is true then the boundaries of this
     * matcher's region match anchors such as ^ and $.
     */
<span class="pc" id="L208">    boolean anchoringBounds = true;</span>

    /**
     * No default constructor.
     */
<span class="nc" id="L213">    Matcher() {</span>
<span class="nc" id="L214">    }</span>

    /**
     * All matchers have the state used by Pattern during a match.
     */
<span class="fc" id="L219">    Matcher(Pattern parent, CharSequence text) {</span>
<span class="fc" id="L220">        this.parentPattern = parent;</span>
<span class="fc" id="L221">        this.text = text;</span>

        // Allocate state storage
<span class="fc" id="L224">        int parentGroupCount = Math.max(parent.capturingGroupCount, 10);</span>
<span class="fc" id="L225">        groups = new int[parentGroupCount * 2];</span>
<span class="fc" id="L226">        locals = new int[parent.localCount];</span>

        // Put fields into initial states
<span class="fc" id="L229">        reset();</span>
<span class="fc" id="L230">    }</span>

    /**
     * Returns the pattern that is interpreted by this matcher.
     *
     * @return  The pattern for which this matcher was created
     */
    public Pattern pattern() {
<span class="nc" id="L238">        return parentPattern;</span>
    }

    /**
     * Returns the match state of this matcher as a {@link MatchResult}.
     * The result is unaffected by subsequent operations performed upon this
     * matcher.
     *
     * @return  a &lt;code&gt;MatchResult&lt;/code&gt; with the state of this matcher
     * @since 1.5
     */
    public MatchResult toMatchResult() {
<span class="nc" id="L250">        Matcher result = new Matcher(this.parentPattern, text.toString());</span>
<span class="nc" id="L251">        result.first = this.first;</span>
<span class="nc" id="L252">        result.last = this.last;</span>
<span class="nc" id="L253">        result.groups = this.groups.clone();</span>
<span class="nc" id="L254">        return result;</span>
    }

    /**
      * Changes the &lt;tt&gt;Pattern&lt;/tt&gt; that this &lt;tt&gt;Matcher&lt;/tt&gt; uses to
      * find matches with.
      *
      * &lt;p&gt; This method causes this matcher to lose information
      * about the groups of the last match that occurred. The
      * matcher's position in the input is maintained and its
      * last append position is unaffected.&lt;/p&gt;
      *
      * @param  newPattern
      *         The new pattern used by this matcher
      * @return  This matcher
      * @throws  IllegalArgumentException
      *          If newPattern is &lt;tt&gt;null&lt;/tt&gt;
      * @since 1.5
      */
    public Matcher usePattern(Pattern newPattern) {
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (newPattern == null)</span>
<span class="nc" id="L275">            throw new IllegalArgumentException(&quot;Pattern cannot be null&quot;);</span>
<span class="fc" id="L276">        parentPattern = newPattern;</span>

        // Reallocate state storage
<span class="fc" id="L279">        int parentGroupCount = Math.max(newPattern.capturingGroupCount, 10);</span>
<span class="fc" id="L280">        groups = new int[parentGroupCount * 2];</span>
<span class="fc" id="L281">        locals = new int[newPattern.localCount];</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        for (int i = 0; i &lt; groups.length; i++)</span>
<span class="fc" id="L283">            groups[i] = -1;</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        for (int i = 0; i &lt; locals.length; i++)</span>
<span class="nc" id="L285">            locals[i] = -1;</span>
<span class="fc" id="L286">        return this;</span>
    }

    /**
     * Resets this matcher.
     *
     * &lt;p&gt; Resetting a matcher discards all of its explicit state information
     * and sets its append position to zero. The matcher's region is set to the
     * default region, which is its entire character sequence. The anchoring
     * and transparency of this matcher's region boundaries are unaffected.
     *
     * @return  This matcher
     */
    public Matcher reset() {
<span class="fc" id="L300">        first = -1;</span>
<span class="fc" id="L301">        last = 0;</span>
<span class="fc" id="L302">        oldLast = -1;</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">        for(int i=0; i&lt;groups.length; i++)</span>
<span class="fc" id="L304">            groups[i] = -1;</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        for(int i=0; i&lt;locals.length; i++)</span>
<span class="fc" id="L306">            locals[i] = -1;</span>
<span class="fc" id="L307">        lastAppendPosition = 0;</span>
<span class="fc" id="L308">        from = 0;</span>
<span class="fc" id="L309">        to = getTextLength();</span>
<span class="fc" id="L310">        return this;</span>
    }

    /**
     * Resets this matcher with a new input sequence.
     *
     * &lt;p&gt; Resetting a matcher discards all of its explicit state information
     * and sets its append position to zero.  The matcher's region is set to
     * the default region, which is its entire character sequence.  The
     * anchoring and transparency of this matcher's region boundaries are
     * unaffected.
     *
     * @param  input
     *         The new input character sequence
     *
     * @return  This matcher
     */
    public Matcher reset(CharSequence input) {
<span class="fc" id="L328">        text = input;</span>
<span class="fc" id="L329">        return reset();</span>
    }

    /**
     * Returns the start index of the previous match.
     *
     * @return  The index of the first character matched
     *
     * @throws  IllegalStateException
     *          If no match has yet been attempted,
     *          or if the previous match operation failed
     */
    public int start() {
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        if (first &lt; 0)</span>
<span class="nc" id="L343">            throw new IllegalStateException(&quot;No match available&quot;);</span>
<span class="fc" id="L344">        return first;</span>
    }

    /**
     * Returns the start index of the subsequence captured by the given group
     * during the previous match operation.
     *
     * &lt;p&gt; &lt;a href=&quot;Pattern.html#cg&quot;&gt;Capturing groups&lt;/a&gt; are indexed from left
     * to right, starting at one.  Group zero denotes the entire pattern, so
     * the expression &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;start(0)&lt;/tt&gt; is equivalent to
     * &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;start()&lt;/tt&gt;.  &lt;/p&gt;
     *
     * @param  group
     *         The index of a capturing group in this matcher's pattern
     *
     * @return  The index of the first character captured by the group,
     *          or &lt;tt&gt;-1&lt;/tt&gt; if the match was successful but the group
     *          itself did not match anything
     *
     * @throws  IllegalStateException
     *          If no match has yet been attempted,
     *          or if the previous match operation failed
     *
     * @throws  IndexOutOfBoundsException
     *          If there is no capturing group in the pattern
     *          with the given index
     */
    public int start(int group) {
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">        if (first &lt; 0)</span>
<span class="nc" id="L373">            throw new IllegalStateException(&quot;No match available&quot;);</span>
<span class="pc bpc" id="L374" title="2 of 4 branches missed.">        if (group &lt; 0 || group &gt; groupCount())</span>
<span class="nc" id="L375">            throw new IndexOutOfBoundsException(&quot;No group &quot; + group);</span>
<span class="fc" id="L376">        return groups[group * 2];</span>
    }

    /**
     * Returns the start index of the subsequence captured by the given
     * &lt;a href=&quot;Pattern.html#groupname&quot;&gt;named-capturing group&lt;/a&gt; during the
     * previous match operation.
     *
     * @param  name
     *         The name of a named-capturing group in this matcher's pattern
     *
     * @return  The index of the first character captured by the group,
     *          or {@code -1} if the match was successful but the group
     *          itself did not match anything
     *
     * @throws  IllegalStateException
     *          If no match has yet been attempted,
     *          or if the previous match operation failed
     *
     * @throws  IllegalArgumentException
     *          If there is no capturing group in the pattern
     *          with the given name
     * @since 1.8
     */
    public int start(String name) {
<span class="nc" id="L401">        return groups[getMatchedGroupIndex(name) * 2];</span>
    }

    /**
     * Returns the offset after the last character matched.
     *
     * @return  The offset after the last character matched
     *
     * @throws  IllegalStateException
     *          If no match has yet been attempted,
     *          or if the previous match operation failed
     */
    public int end() {
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (first &lt; 0)</span>
<span class="nc" id="L415">            throw new IllegalStateException(&quot;No match available&quot;);</span>
<span class="fc" id="L416">        return last;</span>
    }

    /**
     * Returns the offset after the last character of the subsequence
     * captured by the given group during the previous match operation.
     *
     * &lt;p&gt; &lt;a href=&quot;Pattern.html#cg&quot;&gt;Capturing groups&lt;/a&gt; are indexed from left
     * to right, starting at one.  Group zero denotes the entire pattern, so
     * the expression &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;end(0)&lt;/tt&gt; is equivalent to
     * &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;end()&lt;/tt&gt;.  &lt;/p&gt;
     *
     * @param  group
     *         The index of a capturing group in this matcher's pattern
     *
     * @return  The offset after the last character captured by the group,
     *          or &lt;tt&gt;-1&lt;/tt&gt; if the match was successful
     *          but the group itself did not match anything
     *
     * @throws  IllegalStateException
     *          If no match has yet been attempted,
     *          or if the previous match operation failed
     *
     * @throws  IndexOutOfBoundsException
     *          If there is no capturing group in the pattern
     *          with the given index
     */
    public int end(int group) {
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if (first &lt; 0)</span>
<span class="nc" id="L445">            throw new IllegalStateException(&quot;No match available&quot;);</span>
<span class="pc bpc" id="L446" title="2 of 4 branches missed.">        if (group &lt; 0 || group &gt; groupCount())</span>
<span class="nc" id="L447">            throw new IndexOutOfBoundsException(&quot;No group &quot; + group);</span>
<span class="fc" id="L448">        return groups[group * 2 + 1];</span>
    }

    /**
     * Returns the offset after the last character of the subsequence
     * captured by the given &lt;a href=&quot;Pattern.html#groupname&quot;&gt;named-capturing
     * group&lt;/a&gt; during the previous match operation.
     *
     * @param  name
     *         The name of a named-capturing group in this matcher's pattern
     *
     * @return  The offset after the last character captured by the group,
     *          or {@code -1} if the match was successful
     *          but the group itself did not match anything
     *
     * @throws  IllegalStateException
     *          If no match has yet been attempted,
     *          or if the previous match operation failed
     *
     * @throws  IllegalArgumentException
     *          If there is no capturing group in the pattern
     *          with the given name
     * @since 1.8
     */
    public int end(String name) {
<span class="nc" id="L473">        return groups[getMatchedGroupIndex(name) * 2 + 1];</span>
    }

    /**
     * Returns the input subsequence matched by the previous match.
     *
     * &lt;p&gt; For a matcher &lt;i&gt;m&lt;/i&gt; with input sequence &lt;i&gt;s&lt;/i&gt;,
     * the expressions &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;group()&lt;/tt&gt; and
     * &lt;i&gt;s.&lt;/i&gt;&lt;tt&gt;substring(&lt;/tt&gt;&lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;start(),&lt;/tt&gt;&amp;nbsp;&lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;end())&lt;/tt&gt;
     * are equivalent.  &lt;/p&gt;
     *
     * &lt;p&gt; Note that some patterns, for example &lt;tt&gt;a*&lt;/tt&gt;, match the empty
     * string.  This method will return the empty string when the pattern
     * successfully matches the empty string in the input.  &lt;/p&gt;
     *
     * @return The (possibly empty) subsequence matched by the previous match,
     *         in string form
     *
     * @throws  IllegalStateException
     *          If no match has yet been attempted,
     *          or if the previous match operation failed
     */
    public String group() {
<span class="fc" id="L496">        return group(0);</span>
    }

    /**
     * Returns the input subsequence captured by the given group during the
     * previous match operation.
     *
     * &lt;p&gt; For a matcher &lt;i&gt;m&lt;/i&gt;, input sequence &lt;i&gt;s&lt;/i&gt;, and group index
     * &lt;i&gt;g&lt;/i&gt;, the expressions &lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;group(&lt;/tt&gt;&lt;i&gt;g&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt; and
     * &lt;i&gt;s.&lt;/i&gt;&lt;tt&gt;substring(&lt;/tt&gt;&lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;start(&lt;/tt&gt;&lt;i&gt;g&lt;/i&gt;&lt;tt&gt;),&lt;/tt&gt;&amp;nbsp;&lt;i&gt;m.&lt;/i&gt;&lt;tt&gt;end(&lt;/tt&gt;&lt;i&gt;g&lt;/i&gt;&lt;tt&gt;))&lt;/tt&gt;
     * are equivalent.  &lt;/p&gt;
     *
     * &lt;p&gt; &lt;a href=&quot;Pattern.html#cg&quot;&gt;Capturing groups&lt;/a&gt; are indexed from left
     * to right, starting at one.  Group zero denotes the entire pattern, so
     * the expression &lt;tt&gt;m.group(0)&lt;/tt&gt; is equivalent to &lt;tt&gt;m.group()&lt;/tt&gt;.
     * &lt;/p&gt;
     *
     * &lt;p&gt; If the match was successful but the group specified failed to match
     * any part of the input sequence, then &lt;tt&gt;null&lt;/tt&gt; is returned. Note
     * that some groups, for example &lt;tt&gt;(a*)&lt;/tt&gt;, match the empty string.
     * This method will return the empty string when such a group successfully
     * matches the empty string in the input.  &lt;/p&gt;
     *
     * @param  group
     *         The index of a capturing group in this matcher's pattern
     *
     * @return  The (possibly empty) subsequence captured by the group
     *          during the previous match, or &lt;tt&gt;null&lt;/tt&gt; if the group
     *          failed to match part of the input
     *
     * @throws  IllegalStateException
     *          If no match has yet been attempted,
     *          or if the previous match operation failed
     *
     * @throws  IndexOutOfBoundsException
     *          If there is no capturing group in the pattern
     *          with the given index
     */
    public String group(int group) {
<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (first &lt; 0)</span>
<span class="fc" id="L536">            throw new IllegalStateException(&quot;No match found&quot;);</span>
<span class="pc bpc" id="L537" title="2 of 4 branches missed.">        if (group &lt; 0 || group &gt; groupCount())</span>
<span class="nc" id="L538">            throw new IndexOutOfBoundsException(&quot;No group &quot; + group);</span>
<span class="pc bpc" id="L539" title="1 of 4 branches missed.">        if ((groups[group*2] == -1) || (groups[group*2+1] == -1))</span>
<span class="fc" id="L540">            return null;</span>
<span class="fc" id="L541">        return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();</span>
    }

    /**
     * Returns the input subsequence captured by the given
     * &lt;a href=&quot;Pattern.html#groupname&quot;&gt;named-capturing group&lt;/a&gt; during the previous
     * match operation.
     *
     * &lt;p&gt; If the match was successful but the group specified failed to match
     * any part of the input sequence, then &lt;tt&gt;null&lt;/tt&gt; is returned. Note
     * that some groups, for example &lt;tt&gt;(a*)&lt;/tt&gt;, match the empty string.
     * This method will return the empty string when such a group successfully
     * matches the empty string in the input.  &lt;/p&gt;
     *
     * @param  name
     *         The name of a named-capturing group in this matcher's pattern
     *
     * @return  The (possibly empty) subsequence captured by the named group
     *          during the previous match, or &lt;tt&gt;null&lt;/tt&gt; if the group
     *          failed to match part of the input
     *
     * @throws  IllegalStateException
     *          If no match has yet been attempted,
     *          or if the previous match operation failed
     *
     * @throws  IllegalArgumentException
     *          If there is no capturing group in the pattern
     *          with the given name
     * @since 1.7
     */
    public String group(String name) {
<span class="nc" id="L572">        int group = getMatchedGroupIndex(name);</span>
<span class="nc bnc" id="L573" title="All 4 branches missed.">        if ((groups[group*2] == -1) || (groups[group*2+1] == -1))</span>
<span class="nc" id="L574">            return null;</span>
<span class="nc" id="L575">        return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();</span>
    }

    /**
     * Returns the number of capturing groups in this matcher's pattern.
     *
     * &lt;p&gt; Group zero denotes the entire pattern by convention. It is not
     * included in this count.
     *
     * &lt;p&gt; Any non-negative integer smaller than or equal to the value
     * returned by this method is guaranteed to be a valid group index for
     * this matcher.  &lt;/p&gt;
     *
     * @return The number of capturing groups in this matcher's pattern
     */
    public int groupCount() {
<span class="fc" id="L591">        return parentPattern.capturingGroupCount - 1;</span>
    }

    /**
     * Attempts to match the entire region against the pattern.
     *
     * &lt;p&gt; If the match succeeds then more information can be obtained via the
     * &lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;end&lt;/tt&gt;, and &lt;tt&gt;group&lt;/tt&gt; methods.  &lt;/p&gt;
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, the entire region sequence
     *          matches this matcher's pattern
     */
    public boolean matches() {
<span class="fc" id="L604">        return match(from, ENDANCHOR);</span>
    }

    /**
     * Attempts to find the next subsequence of the input sequence that matches
     * the pattern.
     *
     * &lt;p&gt; This method starts at the beginning of this matcher's region, or, if
     * a previous invocation of the method was successful and the matcher has
     * not since been reset, at the first character not matched by the previous
     * match.
     *
     * &lt;p&gt; If the match succeeds then more information can be obtained via the
     * &lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;end&lt;/tt&gt;, and &lt;tt&gt;group&lt;/tt&gt; methods.  &lt;/p&gt;
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, a subsequence of the input
     *          sequence matches this matcher's pattern
     */
    public boolean find() {
<span class="fc" id="L623">        int nextSearchIndex = last;</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">        if (nextSearchIndex == first)</span>
<span class="nc" id="L625">            nextSearchIndex++;</span>

        // If next search starts before region, start it at region
<span class="fc bfc" id="L628" title="All 2 branches covered.">        if (nextSearchIndex &lt; from)</span>
<span class="fc" id="L629">            nextSearchIndex = from;</span>

        // If next search starts beyond region then it fails
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">        if (nextSearchIndex &gt; to) {</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">            for (int i = 0; i &lt; groups.length; i++)</span>
<span class="nc" id="L634">                groups[i] = -1;</span>
<span class="nc" id="L635">            return false;</span>
        }
<span class="fc" id="L637">        return search(nextSearchIndex);</span>
    }

    /**
     * Resets this matcher and then attempts to find the next subsequence of
     * the input sequence that matches the pattern, starting at the specified
     * index.
     *
     * &lt;p&gt; If the match succeeds then more information can be obtained via the
     * &lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;end&lt;/tt&gt;, and &lt;tt&gt;group&lt;/tt&gt; methods, and subsequent
     * invocations of the {@link #find()} method will start at the first
     * character not matched by this match.  &lt;/p&gt;
     *
     * @param start the index to start searching for a match
     * @throws  IndexOutOfBoundsException
     *          If start is less than zero or if start is greater than the
     *          length of the input sequence.
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, a subsequence of the input
     *          sequence starting at the given index matches this matcher's
     *          pattern
     */
    public boolean find(int start) {
<span class="fc" id="L660">        int limit = getTextLength();</span>
<span class="pc bpc" id="L661" title="2 of 4 branches missed.">        if ((start &lt; 0) || (start &gt; limit))</span>
<span class="nc" id="L662">            throw new IndexOutOfBoundsException(&quot;Illegal start index&quot;);</span>
<span class="fc" id="L663">        reset();</span>
<span class="fc" id="L664">        return search(start);</span>
    }

    /**
     * Attempts to match the input sequence, starting at the beginning of the
     * region, against the pattern.
     *
     * &lt;p&gt; Like the {@link #matches matches} method, this method always starts
     * at the beginning of the region; unlike that method, it does not
     * require that the entire region be matched.
     *
     * &lt;p&gt; If the match succeeds then more information can be obtained via the
     * &lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;end&lt;/tt&gt;, and &lt;tt&gt;group&lt;/tt&gt; methods.  &lt;/p&gt;
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, a prefix of the input
     *          sequence matches this matcher's pattern
     */
    public boolean lookingAt() {
<span class="fc" id="L682">        return match(from, NOANCHOR);</span>
    }

    /**
     * Returns a literal replacement &lt;code&gt;String&lt;/code&gt; for the specified
     * &lt;code&gt;String&lt;/code&gt;.
     *
     * This method produces a &lt;code&gt;String&lt;/code&gt; that will work
     * as a literal replacement &lt;code&gt;s&lt;/code&gt; in the
     * &lt;code&gt;appendReplacement&lt;/code&gt; method of the {@link Matcher} class.
     * The &lt;code&gt;String&lt;/code&gt; produced will match the sequence of characters
     * in &lt;code&gt;s&lt;/code&gt; treated as a literal sequence. Slashes ('\') and
     * dollar signs ('$') will be given no special meaning.
     *
     * @param  s The string to be literalized
     * @return  A literal string replacement
     * @since 1.5
     */
    public static String quoteReplacement(String s) {
<span class="fc bfc" id="L701" title="All 4 branches covered.">        if ((s.indexOf('\\') == -1) &amp;&amp; (s.indexOf('$') == -1))</span>
<span class="fc" id="L702">            return s;</span>
<span class="fc" id="L703">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">        for (int i=0; i&lt;s.length(); i++) {</span>
<span class="fc" id="L705">            char c = s.charAt(i);</span>
<span class="fc bfc" id="L706" title="All 4 branches covered.">            if (c == '\\' || c == '$') {</span>
<span class="fc" id="L707">                sb.append('\\');</span>
            }
<span class="fc" id="L709">            sb.append(c);</span>
        }
<span class="fc" id="L711">        return sb.toString();</span>
    }

    /**
     * Implements a non-terminal append-and-replace step.
     *
     * &lt;p&gt; This method performs the following actions: &lt;/p&gt;
     *
     * &lt;ol&gt;
     *
     *   &lt;li&gt;&lt;p&gt; It reads characters from the input sequence, starting at the
     *   append position, and appends them to the given string buffer.  It
     *   stops after reading the last character preceding the previous match,
     *   that is, the character at index {@link
     *   #start()}&amp;nbsp;&lt;tt&gt;-&lt;/tt&gt;&amp;nbsp;&lt;tt&gt;1&lt;/tt&gt;.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; It appends the given replacement string to the string buffer.
     *   &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; It sets the append position of this matcher to the index of
     *   the last character matched, plus one, that is, to {@link #end()}.
     *   &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ol&gt;
     *
     * &lt;p&gt; The replacement string may contain references to subsequences
     * captured during the previous match: Each occurrence of
     * &lt;tt&gt;${&lt;/tt&gt;&lt;i&gt;name&lt;/i&gt;&lt;tt&gt;}&lt;/tt&gt; or &lt;tt&gt;$&lt;/tt&gt;&lt;i&gt;g&lt;/i&gt;
     * will be replaced by the result of evaluating the corresponding
     * {@link #group(String) group(name)} or {@link #group(int) group(g)}
     * respectively. For  &lt;tt&gt;$&lt;/tt&gt;&lt;i&gt;g&lt;/i&gt;,
     * the first number after the &lt;tt&gt;$&lt;/tt&gt; is always treated as part of
     * the group reference. Subsequent numbers are incorporated into g if
     * they would form a legal group reference. Only the numerals '0'
     * through '9' are considered as potential components of the group
     * reference. If the second group matched the string &lt;tt&gt;&quot;foo&quot;&lt;/tt&gt;, for
     * example, then passing the replacement string &lt;tt&gt;&quot;$2bar&quot;&lt;/tt&gt; would
     * cause &lt;tt&gt;&quot;foobar&quot;&lt;/tt&gt; to be appended to the string buffer. A dollar
     * sign (&lt;tt&gt;$&lt;/tt&gt;) may be included as a literal in the replacement
     * string by preceding it with a backslash (&lt;tt&gt;\$&lt;/tt&gt;).
     *
     * &lt;p&gt; Note that backslashes (&lt;tt&gt;\&lt;/tt&gt;) and dollar signs (&lt;tt&gt;$&lt;/tt&gt;) in
     * the replacement string may cause the results to be different than if it
     * were being treated as a literal replacement string. Dollar signs may be
     * treated as references to captured subsequences as described above, and
     * backslashes are used to escape literal characters in the replacement
     * string.
     *
     * &lt;p&gt; This method is intended to be used in a loop together with the
     * {@link #appendTail appendTail} and {@link #find find} methods.  The
     * following code, for example, writes &lt;tt&gt;one dog two dogs in the
     * yard&lt;/tt&gt; to the standard-output stream: &lt;/p&gt;
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * Pattern p = Pattern.compile(&quot;cat&quot;);
     * Matcher m = p.matcher(&quot;one cat two cats in the yard&quot;);
     * StringBuffer sb = new StringBuffer();
     * while (m.find()) {
     *     m.appendReplacement(sb, &quot;dog&quot;);
     * }
     * m.appendTail(sb);
     * System.out.println(sb.toString());&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param  sb
     *         The target string buffer
     *
     * @param  replacement
     *         The replacement string
     *
     * @return  This matcher
     *
     * @throws  IllegalStateException
     *          If no match has yet been attempted,
     *          or if the previous match operation failed
     *
     * @throws  IllegalArgumentException
     *          If the replacement string refers to a named-capturing
     *          group that does not exist in the pattern
     *
     * @throws  IndexOutOfBoundsException
     *          If the replacement string refers to a capturing group
     *          that does not exist in the pattern
     */
    public Matcher appendReplacement(StringBuffer sb, String replacement) {

        // If no match, return error
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">        if (first &lt; 0)</span>
<span class="nc" id="L798">            throw new IllegalStateException(&quot;No match available&quot;);</span>

        // Process substitution string to replace group references with groups
<span class="fc" id="L801">        int cursor = 0;</span>
<span class="fc" id="L802">        StringBuilder result = new StringBuilder();</span>

<span class="fc bfc" id="L804" title="All 2 branches covered.">        while (cursor &lt; replacement.length()) {</span>
<span class="fc" id="L805">            char nextChar = replacement.charAt(cursor);</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">            if (nextChar == '\\') {</span>
<span class="fc" id="L807">                cursor++;</span>
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">                if (cursor == replacement.length())</span>
<span class="nc" id="L809">                    throw new IllegalArgumentException(</span>
                        &quot;character to be escaped is missing&quot;);
<span class="fc" id="L811">                nextChar = replacement.charAt(cursor);</span>
<span class="fc" id="L812">                result.append(nextChar);</span>
<span class="fc" id="L813">                cursor++;</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">            } else if (nextChar == '$') {</span>
                // Skip past $
<span class="fc" id="L816">                cursor++;</span>
                // Throw IAE if this &quot;$&quot; is the last character in replacement
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">                if (cursor == replacement.length())</span>
<span class="nc" id="L819">                   throw new IllegalArgumentException(</span>
                        &quot;Illegal group reference: group index is missing&quot;);
<span class="fc" id="L821">                nextChar = replacement.charAt(cursor);</span>
<span class="fc" id="L822">                int refNum = -1;</span>
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">                if (nextChar == '{') {</span>
<span class="nc" id="L824">                    cursor++;</span>
<span class="nc" id="L825">                    StringBuilder gsb = new StringBuilder();</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                    while (cursor &lt; replacement.length()) {</span>
<span class="nc" id="L827">                        nextChar = replacement.charAt(cursor);</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">                        if (ASCII.isLower(nextChar) ||</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">                            ASCII.isUpper(nextChar) ||</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">                            ASCII.isDigit(nextChar)) {</span>
<span class="nc" id="L831">                            gsb.append(nextChar);</span>
<span class="nc" id="L832">                            cursor++;</span>
                        } else {
                            break;
                        }
                    }
<span class="nc bnc" id="L837" title="All 2 branches missed.">                    if (gsb.length() == 0)</span>
<span class="nc" id="L838">                        throw new IllegalArgumentException(</span>
                            &quot;named capturing group has 0 length name&quot;);
<span class="nc bnc" id="L840" title="All 2 branches missed.">                    if (nextChar != '}')</span>
<span class="nc" id="L841">                        throw new IllegalArgumentException(</span>
                            &quot;named capturing group is missing trailing '}'&quot;);
<span class="nc" id="L843">                    String gname = gsb.toString();</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">                    if (ASCII.isDigit(gname.charAt(0)))</span>
<span class="nc" id="L845">                        throw new IllegalArgumentException(</span>
                            &quot;capturing group name {&quot; + gname +
                            &quot;} starts with digit character&quot;);
<span class="nc bnc" id="L848" title="All 2 branches missed.">                    if (!parentPattern.namedGroups().containsKey(gname))</span>
<span class="nc" id="L849">                        throw new IllegalArgumentException(</span>
                            &quot;No group with name {&quot; + gname + &quot;}&quot;);
<span class="nc" id="L851">                    refNum = parentPattern.namedGroups().get(gname);</span>
<span class="nc" id="L852">                    cursor++;</span>
<span class="nc" id="L853">                } else {</span>
                    // The first number is always a group
<span class="fc" id="L855">                    refNum = (int)nextChar - '0';</span>
<span class="pc bpc" id="L856" title="2 of 4 branches missed.">                    if ((refNum &lt; 0)||(refNum &gt; 9))</span>
<span class="nc" id="L857">                        throw new IllegalArgumentException(</span>
                            &quot;Illegal group reference&quot;);
<span class="fc" id="L859">                    cursor++;</span>
                    // Capture the largest legal group string
<span class="fc" id="L861">                    boolean done = false;</span>
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">                    while (!done) {</span>
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">                        if (cursor &gt;= replacement.length()) {</span>
<span class="nc" id="L864">                            break;</span>
                        }
<span class="fc" id="L866">                        int nextDigit = replacement.charAt(cursor) - '0';</span>
<span class="pc bpc" id="L867" title="2 of 4 branches missed.">                        if ((nextDigit &lt; 0)||(nextDigit &gt; 9)) { // not a number</span>
<span class="fc" id="L868">                            break;</span>
                        }
<span class="nc" id="L870">                        int newRefNum = (refNum * 10) + nextDigit;</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">                        if (groupCount() &lt; newRefNum) {</span>
<span class="nc" id="L872">                            done = true;</span>
                        } else {
<span class="nc" id="L874">                            refNum = newRefNum;</span>
<span class="nc" id="L875">                            cursor++;</span>
                        }
<span class="nc" id="L877">                    }</span>
                }
                // Append group
<span class="pc bpc" id="L880" title="2 of 4 branches missed.">                if (start(refNum) != -1 &amp;&amp; end(refNum) != -1)</span>
<span class="fc" id="L881">                    result.append(text, start(refNum), end(refNum));</span>
<span class="fc" id="L882">            } else {</span>
<span class="fc" id="L883">                result.append(nextChar);</span>
<span class="fc" id="L884">                cursor++;</span>
            }
<span class="fc" id="L886">        }</span>
        // Append the intervening text
<span class="fc" id="L888">        sb.append(text, lastAppendPosition, first);</span>
        // Append the match substitution
<span class="fc" id="L890">        sb.append(result);</span>

<span class="fc" id="L892">        lastAppendPosition = last;</span>
<span class="fc" id="L893">        return this;</span>
    }

    /**
     * Implements a terminal append-and-replace step.
     *
     * &lt;p&gt; This method reads characters from the input sequence, starting at
     * the append position, and appends them to the given string buffer.  It is
     * intended to be invoked after one or more invocations of the {@link
     * #appendReplacement appendReplacement} method in order to copy the
     * remainder of the input sequence.  &lt;/p&gt;
     *
     * @param  sb
     *         The target string buffer
     *
     * @return  The target string buffer
     */
    public StringBuffer appendTail(StringBuffer sb) {
<span class="fc" id="L911">        sb.append(text, lastAppendPosition, getTextLength());</span>
<span class="fc" id="L912">        return sb;</span>
    }

    /**
     * Replaces every subsequence of the input sequence that matches the
     * pattern with the given replacement string.
     *
     * &lt;p&gt; This method first resets this matcher.  It then scans the input
     * sequence looking for matches of the pattern.  Characters that are not
     * part of any match are appended directly to the result string; each match
     * is replaced in the result by the replacement string.  The replacement
     * string may contain references to captured subsequences as in the {@link
     * #appendReplacement appendReplacement} method.
     *
     * &lt;p&gt; Note that backslashes (&lt;tt&gt;\&lt;/tt&gt;) and dollar signs (&lt;tt&gt;$&lt;/tt&gt;) in
     * the replacement string may cause the results to be different than if it
     * were being treated as a literal replacement string. Dollar signs may be
     * treated as references to captured subsequences as described above, and
     * backslashes are used to escape literal characters in the replacement
     * string.
     *
     * &lt;p&gt; Given the regular expression &lt;tt&gt;a*b&lt;/tt&gt;, the input
     * &lt;tt&gt;&quot;aabfooaabfooabfoob&quot;&lt;/tt&gt;, and the replacement string
     * &lt;tt&gt;&quot;-&quot;&lt;/tt&gt;, an invocation of this method on a matcher for that
     * expression would yield the string &lt;tt&gt;&quot;-foo-foo-foo-&quot;&lt;/tt&gt;.
     *
     * &lt;p&gt; Invoking this method changes this matcher's state.  If the matcher
     * is to be used in further matching operations then it should first be
     * reset.  &lt;/p&gt;
     *
     * @param  replacement
     *         The replacement string
     *
     * @return  The string constructed by replacing each matching subsequence
     *          by the replacement string, substituting captured subsequences
     *          as needed
     */
    public String replaceAll(String replacement) {
<span class="fc" id="L950">        reset();</span>
<span class="fc" id="L951">        boolean result = find();</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">        if (result) {</span>
<span class="fc" id="L953">            StringBuffer sb = new StringBuffer();</span>
            do {
<span class="fc" id="L955">                appendReplacement(sb, replacement);</span>
<span class="fc" id="L956">                result = find();</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">            } while (result);</span>
<span class="fc" id="L958">            appendTail(sb);</span>
<span class="fc" id="L959">            return sb.toString();</span>
        }
<span class="fc" id="L961">        return text.toString();</span>
    }

    /**
     * Replaces the first subsequence of the input sequence that matches the
     * pattern with the given replacement string.
     *
     * &lt;p&gt; This method first resets this matcher.  It then scans the input
     * sequence looking for a match of the pattern.  Characters that are not
     * part of the match are appended directly to the result string; the match
     * is replaced in the result by the replacement string.  The replacement
     * string may contain references to captured subsequences as in the {@link
     * #appendReplacement appendReplacement} method.
     *
     * &lt;p&gt;Note that backslashes (&lt;tt&gt;\&lt;/tt&gt;) and dollar signs (&lt;tt&gt;$&lt;/tt&gt;) in
     * the replacement string may cause the results to be different than if it
     * were being treated as a literal replacement string. Dollar signs may be
     * treated as references to captured subsequences as described above, and
     * backslashes are used to escape literal characters in the replacement
     * string.
     *
     * &lt;p&gt; Given the regular expression &lt;tt&gt;dog&lt;/tt&gt;, the input
     * &lt;tt&gt;&quot;zzzdogzzzdogzzz&quot;&lt;/tt&gt;, and the replacement string
     * &lt;tt&gt;&quot;cat&quot;&lt;/tt&gt;, an invocation of this method on a matcher for that
     * expression would yield the string &lt;tt&gt;&quot;zzzcatzzzdogzzz&quot;&lt;/tt&gt;.  &lt;/p&gt;
     *
     * &lt;p&gt; Invoking this method changes this matcher's state.  If the matcher
     * is to be used in further matching operations then it should first be
     * reset.  &lt;/p&gt;
     *
     * @param  replacement
     *         The replacement string
     * @return  The string constructed by replacing the first matching
     *          subsequence by the replacement string, substituting captured
     *          subsequences as needed
     */
    public String replaceFirst(String replacement) {
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">        if (replacement == null)</span>
<span class="nc" id="L999">            throw new NullPointerException(&quot;replacement&quot;);</span>
<span class="fc" id="L1000">        reset();</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">        if (!find())</span>
<span class="fc" id="L1002">            return text.toString();</span>
<span class="fc" id="L1003">        StringBuffer sb = new StringBuffer();</span>
<span class="fc" id="L1004">        appendReplacement(sb, replacement);</span>
<span class="fc" id="L1005">        appendTail(sb);</span>
<span class="fc" id="L1006">        return sb.toString();</span>
    }

    /**
     * Sets the limits of this matcher's region. The region is the part of the
     * input sequence that will be searched to find a match. Invoking this
     * method resets the matcher, and then sets the region to start at the
     * index specified by the &lt;code&gt;start&lt;/code&gt; parameter and end at the
     * index specified by the &lt;code&gt;end&lt;/code&gt; parameter.
     *
     * &lt;p&gt;Depending on the transparency and anchoring being used (see
     * {@link #useTransparentBounds useTransparentBounds} and
     * {@link #useAnchoringBounds useAnchoringBounds}), certain constructs such
     * as anchors may behave differently at or around the boundaries of the
     * region.
     *
     * @param  start
     *         The index to start searching at (inclusive)
     * @param  end
     *         The index to end searching at (exclusive)
     * @throws  IndexOutOfBoundsException
     *          If start or end is less than zero, if
     *          start is greater than the length of the input sequence, if
     *          end is greater than the length of the input sequence, or if
     *          start is greater than end.
     * @return  this matcher
     * @since 1.5
     */
    public Matcher region(int start, int end) {
<span class="pc bpc" id="L1035" title="2 of 4 branches missed.">        if ((start &lt; 0) || (start &gt; getTextLength()))</span>
<span class="nc" id="L1036">            throw new IndexOutOfBoundsException(&quot;start&quot;);</span>
<span class="pc bpc" id="L1037" title="2 of 4 branches missed.">        if ((end &lt; 0) || (end &gt; getTextLength()))</span>
<span class="nc" id="L1038">            throw new IndexOutOfBoundsException(&quot;end&quot;);</span>
<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">        if (start &gt; end)</span>
<span class="nc" id="L1040">            throw new IndexOutOfBoundsException(&quot;start &gt; end&quot;);</span>
<span class="fc" id="L1041">        reset();</span>
<span class="fc" id="L1042">        from = start;</span>
<span class="fc" id="L1043">        to = end;</span>
<span class="fc" id="L1044">        return this;</span>
    }

    /**
     * Reports the start index of this matcher's region. The
     * searches this matcher conducts are limited to finding matches
     * within {@link #regionStart regionStart} (inclusive) and
     * {@link #regionEnd regionEnd} (exclusive).
     *
     * @return  The starting point of this matcher's region
     * @since 1.5
     */
    public int regionStart() {
<span class="nc" id="L1057">        return from;</span>
    }

    /**
     * Reports the end index (exclusive) of this matcher's region.
     * The searches this matcher conducts are limited to finding matches
     * within {@link #regionStart regionStart} (inclusive) and
     * {@link #regionEnd regionEnd} (exclusive).
     *
     * @return  the ending point of this matcher's region
     * @since 1.5
     */
    public int regionEnd() {
<span class="nc" id="L1070">        return to;</span>
    }

    /**
     * Queries the transparency of region bounds for this matcher.
     *
     * &lt;p&gt; This method returns &lt;tt&gt;true&lt;/tt&gt; if this matcher uses
     * &lt;i&gt;transparent&lt;/i&gt; bounds, &lt;tt&gt;false&lt;/tt&gt; if it uses &lt;i&gt;opaque&lt;/i&gt;
     * bounds.
     *
     * &lt;p&gt; See {@link #useTransparentBounds useTransparentBounds} for a
     * description of transparent and opaque bounds.
     *
     * &lt;p&gt; By default, a matcher uses opaque region boundaries.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; iff this matcher is using transparent bounds,
     *         &lt;tt&gt;false&lt;/tt&gt; otherwise.
     * @see java.util.regex.Matcher#useTransparentBounds(boolean)
     * @since 1.5
     */
    public boolean hasTransparentBounds() {
<span class="nc" id="L1091">        return transparentBounds;</span>
    }

    /**
     * Sets the transparency of region bounds for this matcher.
     *
     * &lt;p&gt; Invoking this method with an argument of &lt;tt&gt;true&lt;/tt&gt; will set this
     * matcher to use &lt;i&gt;transparent&lt;/i&gt; bounds. If the boolean
     * argument is &lt;tt&gt;false&lt;/tt&gt;, then &lt;i&gt;opaque&lt;/i&gt; bounds will be used.
     *
     * &lt;p&gt; Using transparent bounds, the boundaries of this
     * matcher's region are transparent to lookahead, lookbehind,
     * and boundary matching constructs. Those constructs can see beyond the
     * boundaries of the region to see if a match is appropriate.
     *
     * &lt;p&gt; Using opaque bounds, the boundaries of this matcher's
     * region are opaque to lookahead, lookbehind, and boundary matching
     * constructs that may try to see beyond them. Those constructs cannot
     * look past the boundaries so they will fail to match anything outside
     * of the region.
     *
     * &lt;p&gt; By default, a matcher uses opaque bounds.
     *
     * @param  b a boolean indicating whether to use opaque or transparent
     *         regions
     * @return this matcher
     * @see java.util.regex.Matcher#hasTransparentBounds
     * @since 1.5
     */
    public Matcher useTransparentBounds(boolean b) {
<span class="fc" id="L1121">        transparentBounds = b;</span>
<span class="fc" id="L1122">        return this;</span>
    }

    /**
     * Queries the anchoring of region bounds for this matcher.
     *
     * &lt;p&gt; This method returns &lt;tt&gt;true&lt;/tt&gt; if this matcher uses
     * &lt;i&gt;anchoring&lt;/i&gt; bounds, &lt;tt&gt;false&lt;/tt&gt; otherwise.
     *
     * &lt;p&gt; See {@link #useAnchoringBounds useAnchoringBounds} for a
     * description of anchoring bounds.
     *
     * &lt;p&gt; By default, a matcher uses anchoring region boundaries.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; iff this matcher is using anchoring bounds,
     *         &lt;tt&gt;false&lt;/tt&gt; otherwise.
     * @see java.util.regex.Matcher#useAnchoringBounds(boolean)
     * @since 1.5
     */
    public boolean hasAnchoringBounds() {
<span class="nc" id="L1142">        return anchoringBounds;</span>
    }

    /**
     * Sets the anchoring of region bounds for this matcher.
     *
     * &lt;p&gt; Invoking this method with an argument of &lt;tt&gt;true&lt;/tt&gt; will set this
     * matcher to use &lt;i&gt;anchoring&lt;/i&gt; bounds. If the boolean
     * argument is &lt;tt&gt;false&lt;/tt&gt;, then &lt;i&gt;non-anchoring&lt;/i&gt; bounds will be
     * used.
     *
     * &lt;p&gt; Using anchoring bounds, the boundaries of this
     * matcher's region match anchors such as ^ and $.
     *
     * &lt;p&gt; Without anchoring bounds, the boundaries of this
     * matcher's region will not match anchors such as ^ and $.
     *
     * &lt;p&gt; By default, a matcher uses anchoring region boundaries.
     *
     * @param  b a boolean indicating whether or not to use anchoring bounds.
     * @return this matcher
     * @see java.util.regex.Matcher#hasAnchoringBounds
     * @since 1.5
     */
    public Matcher useAnchoringBounds(boolean b) {
<span class="fc" id="L1167">        anchoringBounds = b;</span>
<span class="fc" id="L1168">        return this;</span>
    }

    /**
     * &lt;p&gt;Returns the string representation of this matcher. The
     * string representation of a &lt;code&gt;Matcher&lt;/code&gt; contains information
     * that may be useful for debugging. The exact format is unspecified.
     *
     * @return  The string representation of this matcher
     * @since 1.5
     */
    public String toString() {
<span class="nc" id="L1180">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1181">        sb.append(&quot;java.util.regex.Matcher&quot;);</span>
<span class="nc" id="L1182">        sb.append(&quot;[pattern=&quot; + pattern());</span>
<span class="nc" id="L1183">        sb.append(&quot; region=&quot;);</span>
<span class="nc" id="L1184">        sb.append(regionStart() + &quot;,&quot; + regionEnd());</span>
<span class="nc" id="L1185">        sb.append(&quot; lastmatch=&quot;);</span>
<span class="nc bnc" id="L1186" title="All 4 branches missed.">        if ((first &gt;= 0) &amp;&amp; (group() != null)) {</span>
<span class="nc" id="L1187">            sb.append(group());</span>
        }
<span class="nc" id="L1189">        sb.append(&quot;]&quot;);</span>
<span class="nc" id="L1190">        return sb.toString();</span>
    }

    /**
     * &lt;p&gt;Returns true if the end of input was hit by the search engine in
     * the last match operation performed by this matcher.
     *
     * &lt;p&gt;When this method returns true, then it is possible that more input
     * would have changed the result of the last search.
     *
     * @return  true iff the end of input was hit in the last match; false
     *          otherwise
     * @since 1.5
     */
    public boolean hitEnd() {
<span class="fc" id="L1205">        return hitEnd;</span>
    }

    /**
     * &lt;p&gt;Returns true if more input could change a positive match into a
     * negative one.
     *
     * &lt;p&gt;If this method returns true, and a match was found, then more
     * input could cause the match to be lost. If this method returns false
     * and a match was found, then more input might change the match but the
     * match won't be lost. If a match was not found, then requireEnd has no
     * meaning.
     *
     * @return  true iff more input could change a positive match into a
     *          negative one.
     * @since 1.5
     */
    public boolean requireEnd() {
<span class="fc" id="L1223">        return requireEnd;</span>
    }

    /**
     * Initiates a search to find a Pattern within the given bounds.
     * The groups are filled with default values and the match of the root
     * of the state machine is called. The state machine will hold the state
     * of the match as it proceeds in this matcher.
     *
     * Matcher.from is not set here, because it is the &quot;hard&quot; boundary
     * of the start of the search which anchors will set to. The from param
     * is the &quot;soft&quot; boundary of the start of the search, meaning that the
     * regex tries to match at that index but ^ won't match there. Subsequent
     * calls to the search methods start at a new &quot;soft&quot; boundary which is
     * the end of the previous match.
     */
    boolean search(int from) {
<span class="fc" id="L1240">        this.hitEnd = false;</span>
<span class="fc" id="L1241">        this.requireEnd = false;</span>
<span class="pc bpc" id="L1242" title="1 of 2 branches missed.">        from        = from &lt; 0 ? 0 : from;</span>
<span class="fc" id="L1243">        this.first  = from;</span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">        this.oldLast = oldLast &lt; 0 ? from : oldLast;</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">        for (int i = 0; i &lt; groups.length; i++)</span>
<span class="fc" id="L1246">            groups[i] = -1;</span>
<span class="fc" id="L1247">        acceptMode = NOANCHOR;</span>
<span class="fc" id="L1248">        boolean result = parentPattern.root.match(this, from, text);</span>
<span class="fc bfc" id="L1249" title="All 2 branches covered.">        if (!result)</span>
<span class="fc" id="L1250">            this.first = -1;</span>
<span class="fc" id="L1251">        this.oldLast = this.last;</span>
<span class="fc" id="L1252">        return result;</span>
    }

    /**
     * Initiates a search for an anchored match to a Pattern within the given
     * bounds. The groups are filled with default values and the match of the
     * root of the state machine is called. The state machine will hold the
     * state of the match as it proceeds in this matcher.
     */
    boolean match(int from, int anchor) {
<span class="fc" id="L1262">        this.hitEnd = false;</span>
<span class="fc" id="L1263">        this.requireEnd = false;</span>
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">        from        = from &lt; 0 ? 0 : from;</span>
<span class="fc" id="L1265">        this.first  = from;</span>
<span class="pc bpc" id="L1266" title="1 of 2 branches missed.">        this.oldLast = oldLast &lt; 0 ? from : oldLast;</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">        for (int i = 0; i &lt; groups.length; i++)</span>
<span class="fc" id="L1268">            groups[i] = -1;</span>
<span class="fc" id="L1269">        acceptMode = anchor;</span>
<span class="fc" id="L1270">        boolean result = parentPattern.matchRoot.match(this, from, text);</span>
<span class="fc bfc" id="L1271" title="All 2 branches covered.">        if (!result)</span>
<span class="fc" id="L1272">            this.first = -1;</span>
<span class="fc" id="L1273">        this.oldLast = this.last;</span>
<span class="fc" id="L1274">        return result;</span>
    }

    /**
     * Returns the end index of the text.
     *
     * @return the index after the last character in the text
     */
    int getTextLength() {
<span class="fc" id="L1283">        return text.length();</span>
    }

    /**
     * Generates a String from this Matcher's input in the specified range.
     *
     * @param  beginIndex   the beginning index, inclusive
     * @param  endIndex     the ending index, exclusive
     * @return A String generated from this Matcher's input
     */
    CharSequence getSubSequence(int beginIndex, int endIndex) {
<span class="fc" id="L1294">        return text.subSequence(beginIndex, endIndex);</span>
    }

    /**
     * Returns this Matcher's input character at index i.
     *
     * @return A char from the specified index
     */
    char charAt(int i) {
<span class="nc" id="L1303">        return text.charAt(i);</span>
    }

    /**
     * Returns the group index of the matched capturing group.
     *
     * @return the index of the named-capturing group
     */
    int getMatchedGroupIndex(String name) {
<span class="nc" id="L1312">        Objects.requireNonNull(name, &quot;Group name&quot;);</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">        if (first &lt; 0)</span>
<span class="nc" id="L1314">            throw new IllegalStateException(&quot;No match found&quot;);</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">        if (!parentPattern.namedGroups().containsKey(name))</span>
<span class="nc" id="L1316">            throw new IllegalArgumentException(&quot;No group with name &lt;&quot; + name + &quot;&gt;&quot;);</span>
<span class="nc" id="L1317">        return parentPattern.namedGroups().get(name);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>