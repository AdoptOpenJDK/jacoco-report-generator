<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PacketStream.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.tools.jdi</a> &gt; <span class="el_source">PacketStream.java</span></div><h1>PacketStream.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import com.sun.jdi.*;
import java.util.*;
import java.io.ByteArrayOutputStream;

class PacketStream {
    final VirtualMachineImpl vm;
<span class="nc" id="L34">    private int inCursor = 0;</span>
    final Packet pkt;
<span class="nc" id="L36">    private ByteArrayOutputStream dataStream = new ByteArrayOutputStream();</span>
<span class="nc" id="L37">    private boolean isCommitted = false;</span>

<span class="nc" id="L39">    PacketStream(VirtualMachineImpl vm, int cmdSet, int cmd) {</span>
<span class="nc" id="L40">        this.vm = vm;</span>
<span class="nc" id="L41">        this.pkt = new Packet();</span>
<span class="nc" id="L42">        pkt.cmdSet = (short)cmdSet;</span>
<span class="nc" id="L43">        pkt.cmd = (short)cmd;</span>
<span class="nc" id="L44">    }</span>

<span class="nc" id="L46">    PacketStream(VirtualMachineImpl vm, Packet pkt) {</span>
<span class="nc" id="L47">        this.vm = vm;</span>
<span class="nc" id="L48">        this.pkt = pkt;</span>
<span class="nc" id="L49">        this.isCommitted = true; /* read only stream */</span>
<span class="nc" id="L50">    }</span>

    int id() {
<span class="nc" id="L53">        return pkt.id;</span>
    }

    void send() {
<span class="nc bnc" id="L57" title="All 2 branches missed.">        if (!isCommitted) {</span>
<span class="nc" id="L58">            pkt.data = dataStream.toByteArray();</span>
<span class="nc" id="L59">            vm.sendToTarget(pkt);</span>
<span class="nc" id="L60">            isCommitted = true;</span>
        }
<span class="nc" id="L62">    }</span>

    void waitForReply() throws JDWPException {
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (!isCommitted) {</span>
<span class="nc" id="L66">            throw new InternalException(&quot;waitForReply without send&quot;);</span>
        }

<span class="nc" id="L69">        vm.waitForTargetReply(pkt);</span>

<span class="nc bnc" id="L71" title="All 2 branches missed.">        if (pkt.errorCode != Packet.ReplyNoError) {</span>
<span class="nc" id="L72">            throw new JDWPException(pkt.errorCode);</span>
        }
<span class="nc" id="L74">    }</span>

    void writeBoolean(boolean data) {
<span class="nc bnc" id="L77" title="All 2 branches missed.">        if(data) {</span>
<span class="nc" id="L78">            dataStream.write( 1 );</span>
        } else {
<span class="nc" id="L80">            dataStream.write( 0 );</span>
        }
<span class="nc" id="L82">    }</span>

    void writeByte(byte data) {
<span class="nc" id="L85">        dataStream.write( data );</span>
<span class="nc" id="L86">    }</span>

    void writeChar(char data) {
<span class="nc" id="L89">        dataStream.write( (byte)((data &gt;&gt;&gt; 8) &amp; 0xFF) );</span>
<span class="nc" id="L90">        dataStream.write( (byte)((data &gt;&gt;&gt; 0) &amp; 0xFF) );</span>
<span class="nc" id="L91">    }</span>

    void writeShort(short data) {
<span class="nc" id="L94">        dataStream.write( (byte)((data &gt;&gt;&gt; 8) &amp; 0xFF) );</span>
<span class="nc" id="L95">        dataStream.write( (byte)((data &gt;&gt;&gt; 0) &amp; 0xFF) );</span>
<span class="nc" id="L96">    }</span>

    void writeInt(int data) {
<span class="nc" id="L99">        dataStream.write( (byte)((data &gt;&gt;&gt; 24) &amp; 0xFF) );</span>
<span class="nc" id="L100">        dataStream.write( (byte)((data &gt;&gt;&gt; 16) &amp; 0xFF) );</span>
<span class="nc" id="L101">        dataStream.write( (byte)((data &gt;&gt;&gt; 8) &amp; 0xFF) );</span>
<span class="nc" id="L102">        dataStream.write( (byte)((data &gt;&gt;&gt; 0) &amp; 0xFF) );</span>
<span class="nc" id="L103">    }</span>

    void writeLong(long data) {
<span class="nc" id="L106">        dataStream.write( (byte)((data &gt;&gt;&gt; 56) &amp; 0xFF) );</span>
<span class="nc" id="L107">        dataStream.write( (byte)((data &gt;&gt;&gt; 48) &amp; 0xFF) );</span>
<span class="nc" id="L108">        dataStream.write( (byte)((data &gt;&gt;&gt; 40) &amp; 0xFF) );</span>
<span class="nc" id="L109">        dataStream.write( (byte)((data &gt;&gt;&gt; 32) &amp; 0xFF) );</span>

<span class="nc" id="L111">        dataStream.write( (byte)((data &gt;&gt;&gt; 24) &amp; 0xFF) );</span>
<span class="nc" id="L112">        dataStream.write( (byte)((data &gt;&gt;&gt; 16) &amp; 0xFF) );</span>
<span class="nc" id="L113">        dataStream.write( (byte)((data &gt;&gt;&gt; 8) &amp; 0xFF) );</span>
<span class="nc" id="L114">        dataStream.write( (byte)((data &gt;&gt;&gt; 0) &amp; 0xFF) );</span>
<span class="nc" id="L115">    }</span>

    void writeFloat(float data) {
<span class="nc" id="L118">        writeInt(Float.floatToIntBits(data));</span>
<span class="nc" id="L119">    }</span>

    void writeDouble(double data) {
<span class="nc" id="L122">        writeLong(Double.doubleToLongBits(data));</span>
<span class="nc" id="L123">    }</span>

    void writeID(int size, long data) {
<span class="nc bnc" id="L126" title="All 4 branches missed.">        switch (size) {</span>
            case 8:
<span class="nc" id="L128">                writeLong(data);</span>
<span class="nc" id="L129">                break;</span>
            case 4:
<span class="nc" id="L131">                writeInt((int)data);</span>
<span class="nc" id="L132">                break;</span>
            case 2:
<span class="nc" id="L134">                writeShort((short)data);</span>
<span class="nc" id="L135">                break;</span>
            default:
<span class="nc" id="L137">                throw new UnsupportedOperationException(&quot;JDWP: ID size not supported: &quot; + size);</span>
        }
<span class="nc" id="L139">    }</span>

    void writeNullObjectRef() {
<span class="nc" id="L142">        writeObjectRef(0);</span>
<span class="nc" id="L143">    }</span>

    void writeObjectRef(long data) {
<span class="nc" id="L146">        writeID(vm.sizeofObjectRef, data);</span>
<span class="nc" id="L147">    }</span>

    void writeClassRef(long data) {
<span class="nc" id="L150">        writeID(vm.sizeofClassRef, data);</span>
<span class="nc" id="L151">    }</span>

    void writeMethodRef(long data) {
<span class="nc" id="L154">        writeID(vm.sizeofMethodRef, data);</span>
<span class="nc" id="L155">    }</span>

    void writeFieldRef(long data) {
<span class="nc" id="L158">        writeID(vm.sizeofFieldRef, data);</span>
<span class="nc" id="L159">    }</span>

    void writeFrameRef(long data) {
<span class="nc" id="L162">        writeID(vm.sizeofFrameRef, data);</span>
<span class="nc" id="L163">    }</span>

    void writeByteArray(byte[] data) {
<span class="nc" id="L166">        dataStream.write(data, 0, data.length);</span>
<span class="nc" id="L167">    }</span>

    void writeString(String string) {
        try {
<span class="nc" id="L171">            byte[] stringBytes = string.getBytes(&quot;UTF8&quot;);</span>
<span class="nc" id="L172">            writeInt(stringBytes.length);</span>
<span class="nc" id="L173">            writeByteArray(stringBytes);</span>
<span class="nc" id="L174">        } catch (java.io.UnsupportedEncodingException e) {</span>
<span class="nc" id="L175">            throw new InternalException(&quot;Cannot convert string to UTF8 bytes&quot;);</span>
<span class="nc" id="L176">        }</span>
<span class="nc" id="L177">    }</span>

    void writeLocation(Location location) {
<span class="nc" id="L180">        ReferenceTypeImpl refType = (ReferenceTypeImpl)location.declaringType();</span>
        byte tag;
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (refType instanceof ClassType) {</span>
<span class="nc" id="L183">            tag = JDWP.TypeTag.CLASS;</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        } else if (refType instanceof InterfaceType) {</span>
            // It's possible to have executable code in an interface
<span class="nc" id="L186">            tag = JDWP.TypeTag.INTERFACE;</span>
        } else {
<span class="nc" id="L188">            throw new InternalException(&quot;Invalid Location&quot;);</span>
        }
<span class="nc" id="L190">        writeByte(tag);</span>
<span class="nc" id="L191">        writeClassRef(refType.ref());</span>
<span class="nc" id="L192">        writeMethodRef(((MethodImpl)location.method()).ref());</span>
<span class="nc" id="L193">        writeLong(location.codeIndex());</span>
<span class="nc" id="L194">    }</span>

    void writeValue(Value val) {
        try {
<span class="nc" id="L198">            writeValueChecked(val);</span>
<span class="nc" id="L199">        } catch (InvalidTypeException exc) {  // should never happen</span>
<span class="nc" id="L200">            throw new RuntimeException(</span>
                &quot;Internal error: Invalid Tag/Type pair&quot;);
<span class="nc" id="L202">        }</span>
<span class="nc" id="L203">    }</span>

    void writeValueChecked(Value val) throws InvalidTypeException {
<span class="nc" id="L206">        writeByte(ValueImpl.typeValueKey(val));</span>
<span class="nc" id="L207">        writeUntaggedValue(val);</span>
<span class="nc" id="L208">    }</span>

    void writeUntaggedValue(Value val) {
        try {
<span class="nc" id="L212">            writeUntaggedValueChecked(val);</span>
<span class="nc" id="L213">        } catch (InvalidTypeException exc) {  // should never happen</span>
<span class="nc" id="L214">            throw new RuntimeException(</span>
                &quot;Internal error: Invalid Tag/Type pair&quot;);
<span class="nc" id="L216">        }</span>
<span class="nc" id="L217">    }</span>

    void writeUntaggedValueChecked(Value val) throws InvalidTypeException {
<span class="nc" id="L220">        byte tag = ValueImpl.typeValueKey(val);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (isObjectTag(tag)) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if (val == null) {</span>
<span class="nc" id="L223">                 writeObjectRef(0);</span>
            } else {
<span class="nc bnc" id="L225" title="All 2 branches missed.">                if (!(val instanceof ObjectReference)) {</span>
<span class="nc" id="L226">                    throw new InvalidTypeException();</span>
                }
<span class="nc" id="L228">                writeObjectRef(((ObjectReferenceImpl)val).ref());</span>
            }
        } else {
<span class="nc bnc" id="L231" title="All 9 branches missed.">            switch (tag) {</span>
                case JDWP.Tag.BYTE:
<span class="nc bnc" id="L233" title="All 2 branches missed.">                    if(!(val instanceof ByteValue))</span>
<span class="nc" id="L234">                        throw new InvalidTypeException();</span>

<span class="nc" id="L236">                    writeByte(((PrimitiveValue)val).byteValue());</span>
<span class="nc" id="L237">                    break;</span>

                case JDWP.Tag.CHAR:
<span class="nc bnc" id="L240" title="All 2 branches missed.">                    if(!(val instanceof CharValue))</span>
<span class="nc" id="L241">                        throw new InvalidTypeException();</span>

<span class="nc" id="L243">                    writeChar(((PrimitiveValue)val).charValue());</span>
<span class="nc" id="L244">                    break;</span>

                case JDWP.Tag.FLOAT:
<span class="nc bnc" id="L247" title="All 2 branches missed.">                    if(!(val instanceof FloatValue))</span>
<span class="nc" id="L248">                        throw new InvalidTypeException();</span>

<span class="nc" id="L250">                    writeFloat(((PrimitiveValue)val).floatValue());</span>
<span class="nc" id="L251">                    break;</span>

                case JDWP.Tag.DOUBLE:
<span class="nc bnc" id="L254" title="All 2 branches missed.">                    if(!(val instanceof DoubleValue))</span>
<span class="nc" id="L255">                        throw new InvalidTypeException();</span>

<span class="nc" id="L257">                    writeDouble(((PrimitiveValue)val).doubleValue());</span>
<span class="nc" id="L258">                    break;</span>

                case JDWP.Tag.INT:
<span class="nc bnc" id="L261" title="All 2 branches missed.">                    if(!(val instanceof IntegerValue))</span>
<span class="nc" id="L262">                        throw new InvalidTypeException();</span>

<span class="nc" id="L264">                    writeInt(((PrimitiveValue)val).intValue());</span>
<span class="nc" id="L265">                    break;</span>

                case JDWP.Tag.LONG:
<span class="nc bnc" id="L268" title="All 2 branches missed.">                    if(!(val instanceof LongValue))</span>
<span class="nc" id="L269">                        throw new InvalidTypeException();</span>

<span class="nc" id="L271">                    writeLong(((PrimitiveValue)val).longValue());</span>
<span class="nc" id="L272">                    break;</span>

                case JDWP.Tag.SHORT:
<span class="nc bnc" id="L275" title="All 2 branches missed.">                    if(!(val instanceof ShortValue))</span>
<span class="nc" id="L276">                        throw new InvalidTypeException();</span>

<span class="nc" id="L278">                    writeShort(((PrimitiveValue)val).shortValue());</span>
<span class="nc" id="L279">                    break;</span>

                case JDWP.Tag.BOOLEAN:
<span class="nc bnc" id="L282" title="All 2 branches missed.">                    if(!(val instanceof BooleanValue))</span>
<span class="nc" id="L283">                        throw new InvalidTypeException();</span>

<span class="nc" id="L285">                    writeBoolean(((PrimitiveValue)val).booleanValue());</span>
                    break;
            }
        }
<span class="nc" id="L289">    }</span>



    /**
     * Read byte represented as one bytes.
     */
    byte readByte() {
<span class="nc" id="L297">        byte ret = pkt.data[inCursor];</span>
<span class="nc" id="L298">        inCursor += 1;</span>
<span class="nc" id="L299">        return ret;</span>
    }

    /**
     * Read boolean represented as one byte.
     */
    boolean readBoolean() {
<span class="nc" id="L306">        byte ret = readByte();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        return (ret != 0);</span>
    }

    /**
     * Read char represented as two bytes.
     */
    char readChar() {
        int b1, b2;

<span class="nc" id="L316">        b1 = pkt.data[inCursor++] &amp; 0xff;</span>
<span class="nc" id="L317">        b2 = pkt.data[inCursor++] &amp; 0xff;</span>

<span class="nc" id="L319">        return (char)((b1 &lt;&lt; 8) + b2);</span>
    }

    /**
     * Read short represented as two bytes.
     */
    short readShort() {
        int b1, b2;

<span class="nc" id="L328">        b1 = pkt.data[inCursor++] &amp; 0xff;</span>
<span class="nc" id="L329">        b2 = pkt.data[inCursor++] &amp; 0xff;</span>

<span class="nc" id="L331">        return (short)((b1 &lt;&lt; 8) + b2);</span>
    }

    /**
     * Read int represented as four bytes.
     */
    int readInt() {
        int b1,b2,b3,b4;

<span class="nc" id="L340">        b1 = pkt.data[inCursor++] &amp; 0xff;</span>
<span class="nc" id="L341">        b2 = pkt.data[inCursor++] &amp; 0xff;</span>
<span class="nc" id="L342">        b3 = pkt.data[inCursor++] &amp; 0xff;</span>
<span class="nc" id="L343">        b4 = pkt.data[inCursor++] &amp; 0xff;</span>

<span class="nc" id="L345">        return ((b1 &lt;&lt; 24) + (b2 &lt;&lt; 16) + (b3 &lt;&lt; 8) + b4);</span>
    }

    /**
     * Read long represented as eight bytes.
     */
    long readLong() {
        long b1,b2,b3,b4;
        long b5,b6,b7,b8;

<span class="nc" id="L355">        b1 = pkt.data[inCursor++] &amp; 0xff;</span>
<span class="nc" id="L356">        b2 = pkt.data[inCursor++] &amp; 0xff;</span>
<span class="nc" id="L357">        b3 = pkt.data[inCursor++] &amp; 0xff;</span>
<span class="nc" id="L358">        b4 = pkt.data[inCursor++] &amp; 0xff;</span>

<span class="nc" id="L360">        b5 = pkt.data[inCursor++] &amp; 0xff;</span>
<span class="nc" id="L361">        b6 = pkt.data[inCursor++] &amp; 0xff;</span>
<span class="nc" id="L362">        b7 = pkt.data[inCursor++] &amp; 0xff;</span>
<span class="nc" id="L363">        b8 = pkt.data[inCursor++] &amp; 0xff;</span>

<span class="nc" id="L365">        return ((b1 &lt;&lt; 56) + (b2 &lt;&lt; 48) + (b3 &lt;&lt; 40) + (b4 &lt;&lt; 32)</span>
                + (b5 &lt;&lt; 24) + (b6 &lt;&lt; 16) + (b7 &lt;&lt; 8) + b8);
    }

    /**
     * Read float represented as four bytes.
     */
    float readFloat() {
<span class="nc" id="L373">        return Float.intBitsToFloat(readInt());</span>
    }

    /**
     * Read double represented as eight bytes.
     */
    double readDouble() {
<span class="nc" id="L380">        return Double.longBitsToDouble(readLong());</span>
    }

    /**
     * Read string represented as four byte length followed by
     * characters of the string.
     */
    String readString() {
        String ret;
<span class="nc" id="L389">        int len = readInt();</span>

        try {
<span class="nc" id="L392">            ret = new String(pkt.data, inCursor, len, &quot;UTF8&quot;);</span>
<span class="nc" id="L393">        } catch(java.io.UnsupportedEncodingException e) {</span>
<span class="nc" id="L394">            System.err.println(e);</span>
<span class="nc" id="L395">            ret = &quot;Conversion error!&quot;;</span>
<span class="nc" id="L396">        }</span>
<span class="nc" id="L397">        inCursor += len;</span>
<span class="nc" id="L398">        return ret;</span>
    }

    private long readID(int size) {
<span class="nc bnc" id="L402" title="All 4 branches missed.">        switch (size) {</span>
          case 8:
<span class="nc" id="L404">              return readLong();</span>
          case 4:
<span class="nc" id="L406">              return (long)readInt();</span>
          case 2:
<span class="nc" id="L408">              return (long)readShort();</span>
          default:
<span class="nc" id="L410">              throw new UnsupportedOperationException(&quot;JDWP: ID size not supported: &quot; + size);</span>
        }
    }

    /**
     * Read object represented as vm specific byte sequence.
     */
    long readObjectRef() {
<span class="nc" id="L418">        return readID(vm.sizeofObjectRef);</span>
    }

    long readClassRef() {
<span class="nc" id="L422">        return readID(vm.sizeofClassRef);</span>
    }

    ObjectReferenceImpl readTaggedObjectReference() {
<span class="nc" id="L426">        byte typeKey = readByte();</span>
<span class="nc" id="L427">        return vm.objectMirror(readObjectRef(), typeKey);</span>
    }

    ObjectReferenceImpl readObjectReference() {
<span class="nc" id="L431">        return vm.objectMirror(readObjectRef());</span>
    }

    StringReferenceImpl readStringReference() {
<span class="nc" id="L435">        long ref = readObjectRef();</span>
<span class="nc" id="L436">        return vm.stringMirror(ref);</span>
    }

    ArrayReferenceImpl readArrayReference() {
<span class="nc" id="L440">        long ref = readObjectRef();</span>
<span class="nc" id="L441">        return vm.arrayMirror(ref);</span>
    }

    ThreadReferenceImpl readThreadReference() {
<span class="nc" id="L445">        long ref = readObjectRef();</span>
<span class="nc" id="L446">        return vm.threadMirror(ref);</span>
    }

    ThreadGroupReferenceImpl readThreadGroupReference() {
<span class="nc" id="L450">        long ref = readObjectRef();</span>
<span class="nc" id="L451">        return vm.threadGroupMirror(ref);</span>
    }

    ClassLoaderReferenceImpl readClassLoaderReference() {
<span class="nc" id="L455">        long ref = readObjectRef();</span>
<span class="nc" id="L456">        return vm.classLoaderMirror(ref);</span>
    }

    ClassObjectReferenceImpl readClassObjectReference() {
<span class="nc" id="L460">        long ref = readObjectRef();</span>
<span class="nc" id="L461">        return vm.classObjectMirror(ref);</span>
    }

    ReferenceTypeImpl readReferenceType() {
<span class="nc" id="L465">        byte tag = readByte();</span>
<span class="nc" id="L466">        long ref = readObjectRef();</span>
<span class="nc" id="L467">        return vm.referenceType(ref, tag);</span>
    }

    /**
     * Read method reference represented as vm specific byte sequence.
     */
    long readMethodRef() {
<span class="nc" id="L474">        return readID(vm.sizeofMethodRef);</span>
    }

    /**
     * Read field reference represented as vm specific byte sequence.
     */
    long readFieldRef() {
<span class="nc" id="L481">        return readID(vm.sizeofFieldRef);</span>
    }

    /**
     * Read field represented as vm specific byte sequence.
     */
    Field readField() {
<span class="nc" id="L488">        ReferenceTypeImpl refType = readReferenceType();</span>
<span class="nc" id="L489">        long fieldRef = readFieldRef();</span>
<span class="nc" id="L490">        return refType.getFieldMirror(fieldRef);</span>
    }

    /**
     * Read frame represented as vm specific byte sequence.
     */
    long readFrameRef() {
<span class="nc" id="L497">        return readID(vm.sizeofFrameRef);</span>
    }

    /**
     * Read a value, first byte describes type of value to read.
     */
    ValueImpl readValue() {
<span class="nc" id="L504">        byte typeKey = readByte();</span>
<span class="nc" id="L505">        return readUntaggedValue(typeKey);</span>
    }

    ValueImpl readUntaggedValue(byte typeKey) {
<span class="nc" id="L509">        ValueImpl val = null;</span>

<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (isObjectTag(typeKey)) {</span>
<span class="nc" id="L512">            val = vm.objectMirror(readObjectRef(), typeKey);</span>
        } else {
<span class="nc bnc" id="L514" title="All 10 branches missed.">            switch(typeKey) {</span>
                case JDWP.Tag.BYTE:
<span class="nc" id="L516">                    val = new ByteValueImpl(vm, readByte());</span>
<span class="nc" id="L517">                    break;</span>

                case JDWP.Tag.CHAR:
<span class="nc" id="L520">                    val = new CharValueImpl(vm, readChar());</span>
<span class="nc" id="L521">                    break;</span>

                case JDWP.Tag.FLOAT:
<span class="nc" id="L524">                    val = new FloatValueImpl(vm, readFloat());</span>
<span class="nc" id="L525">                    break;</span>

                case JDWP.Tag.DOUBLE:
<span class="nc" id="L528">                    val = new DoubleValueImpl(vm, readDouble());</span>
<span class="nc" id="L529">                    break;</span>

                case JDWP.Tag.INT:
<span class="nc" id="L532">                    val = new IntegerValueImpl(vm, readInt());</span>
<span class="nc" id="L533">                    break;</span>

                case JDWP.Tag.LONG:
<span class="nc" id="L536">                    val = new LongValueImpl(vm, readLong());</span>
<span class="nc" id="L537">                    break;</span>

                case JDWP.Tag.SHORT:
<span class="nc" id="L540">                    val = new ShortValueImpl(vm, readShort());</span>
<span class="nc" id="L541">                    break;</span>

                case JDWP.Tag.BOOLEAN:
<span class="nc" id="L544">                    val = new BooleanValueImpl(vm, readBoolean());</span>
<span class="nc" id="L545">                    break;</span>

                case JDWP.Tag.VOID:
<span class="nc" id="L548">                    val = new VoidValueImpl(vm);</span>
                    break;
            }
        }
<span class="nc" id="L552">        return val;</span>
    }

    /**
     * Read location represented as vm specific byte sequence.
     */
    Location readLocation() {
<span class="nc" id="L559">        byte tag = readByte();</span>
<span class="nc" id="L560">        long classRef = readObjectRef();</span>
<span class="nc" id="L561">        long methodRef = readMethodRef();</span>
<span class="nc" id="L562">        long codeIndex = readLong();</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (classRef != 0) {</span>
            /* Valid location */
<span class="nc" id="L565">            ReferenceTypeImpl refType = vm.referenceType(classRef, tag);</span>
<span class="nc" id="L566">            return new LocationImpl(vm, refType, methodRef, codeIndex);</span>
        } else {
            /* Null location (example: uncaught exception) */
<span class="nc" id="L569">           return null;</span>
        }
    }

    byte[] readByteArray(int length) {
<span class="nc" id="L574">        byte[] array = new byte[length];</span>
<span class="nc" id="L575">        System.arraycopy(pkt.data, inCursor, array, 0, length);</span>
<span class="nc" id="L576">        inCursor += length;</span>
<span class="nc" id="L577">        return array;</span>
    }

    List&lt;Value&gt; readArrayRegion() {
<span class="nc" id="L581">        byte typeKey = readByte();</span>
<span class="nc" id="L582">        int length = readInt();</span>
<span class="nc" id="L583">        List&lt;Value&gt; list = new ArrayList&lt;Value&gt;(length);</span>
<span class="nc" id="L584">        boolean gettingObjects = isObjectTag(typeKey);</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
            /*
             * Each object comes back with a type key which might
             * identify a more specific type than the type key we
             * passed in, so we use it in the decodeValue call.
             * (For primitives, we just use the original one)
             */
<span class="nc bnc" id="L592" title="All 2 branches missed.">            if (gettingObjects) {</span>
<span class="nc" id="L593">                typeKey = readByte();</span>
            }
<span class="nc" id="L595">            Value value = readUntaggedValue(typeKey);</span>
<span class="nc" id="L596">            list.add(value);</span>
        }

<span class="nc" id="L599">        return list;</span>
    }

    void writeArrayRegion(List&lt;Value&gt; srcValues) {
<span class="nc" id="L603">        writeInt(srcValues.size());</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">        for (int i = 0; i &lt; srcValues.size(); i++) {</span>
<span class="nc" id="L605">            Value value = srcValues.get(i);</span>
<span class="nc" id="L606">            writeUntaggedValue(value);</span>
        }
<span class="nc" id="L608">    }</span>

    int skipBytes(int n) {
<span class="nc" id="L611">        inCursor += n;</span>
<span class="nc" id="L612">        return n;</span>
    }

    byte command() {
<span class="nc" id="L616">        return (byte)pkt.cmd;</span>
    }

    static boolean isObjectTag(byte tag) {
<span class="nc bnc" id="L620" title="All 14 branches missed.">        return (tag == JDWP.Tag.OBJECT) ||</span>
               (tag == JDWP.Tag.ARRAY) ||
               (tag == JDWP.Tag.STRING) ||
               (tag == JDWP.Tag.THREAD) ||
               (tag == JDWP.Tag.THREAD_GROUP) ||
               (tag == JDWP.Tag.CLASS_LOADER) ||
               (tag == JDWP.Tag.CLASS_OBJECT);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>