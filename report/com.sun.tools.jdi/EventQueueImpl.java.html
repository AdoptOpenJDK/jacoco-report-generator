<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>EventQueueImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.tools.jdi</a> &gt; <span class="el_source">EventQueueImpl.java</span></div><h1>EventQueueImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import com.sun.jdi.*;
import com.sun.jdi.event.EventQueue;
import com.sun.jdi.event.EventSet;

import java.util.*;

public class EventQueueImpl extends MirrorImpl implements EventQueue {

    /*
     * Note this is not a synchronized list. Iteration/update should be
     * protected through the 'this' monitor.
     */
<span class="nc" id="L40">    LinkedList&lt;EventSet&gt; eventSets = new LinkedList&lt;EventSet&gt;();</span>

    TargetVM target;
<span class="nc" id="L43">    boolean closed = false;</span>

    EventQueueImpl(VirtualMachine vm, TargetVM target) {
<span class="nc" id="L46">        super(vm);</span>
<span class="nc" id="L47">        this.target = target;</span>
<span class="nc" id="L48">        target.addEventQueue(this);</span>
<span class="nc" id="L49">    }</span>

    /*
     * Override superclass back to default equality
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L55" title="All 2 branches missed.">        return this == obj;</span>
    }

    public int hashCode() {
<span class="nc" id="L59">        return System.identityHashCode(this);</span>
    }

    synchronized void enqueue(EventSet eventSet) {
<span class="nc" id="L63">        eventSets.add(eventSet);</span>
<span class="nc" id="L64">        notifyAll();</span>
<span class="nc" id="L65">    }</span>

    synchronized int size() {
<span class="nc" id="L68">        return eventSets.size();</span>
    }

    synchronized void close() {
<span class="nc bnc" id="L72" title="All 2 branches missed.">        if (!closed) {</span>
<span class="nc" id="L73">            closed = true; // OK for this the be first since synchronized</span>

            // place VMDisconnectEvent into queue
<span class="nc" id="L76">            enqueue(new EventSetImpl(vm,</span>
                                     (byte)JDWP.EventKind.VM_DISCONNECTED));
        }
<span class="nc" id="L79">    }</span>

    public EventSet remove() throws InterruptedException {
<span class="nc" id="L82">        return remove(0);</span>
    }

    /**
     * Filter out events not for user's eyes.
     * Then filter out empty sets.
     */
    public EventSet remove(long timeout) throws InterruptedException {
<span class="nc bnc" id="L90" title="All 2 branches missed.">        if (timeout &lt; 0) {</span>
<span class="nc" id="L91">            throw new IllegalArgumentException(&quot;Timeout cannot be negative&quot;);</span>
        }

        EventSet eventSet;
        while (true) {
<span class="nc" id="L96">            EventSetImpl fullEventSet = removeUnfiltered(timeout);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            if (fullEventSet == null) {</span>
<span class="nc" id="L98">                eventSet = null;  // timeout</span>
<span class="nc" id="L99">                break;</span>
            }
            /*
             * Remove events from the event set for which
             * there is no corresponding enabled request (
             * this includes our internally requested events.)
             * This never returns null
             */
<span class="nc" id="L107">            eventSet = fullEventSet.userFilter();</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            if (!eventSet.isEmpty()) {</span>
<span class="nc" id="L109">                break;</span>
            }
<span class="nc" id="L111">        }</span>

<span class="nc bnc" id="L113" title="All 4 branches missed.">        if ((eventSet != null) &amp;&amp; (eventSet.suspendPolicy() == JDWP.SuspendPolicy.ALL)) {</span>
<span class="nc" id="L114">            vm.notifySuspend();</span>
        }

<span class="nc" id="L117">        return eventSet;</span>
    }

    EventSet removeInternal() throws InterruptedException {
        EventSet eventSet;
        do {
            // Waiting forever, so removeUnfiltered() is never null
<span class="nc" id="L124">            eventSet = removeUnfiltered(0).internalFilter();</span>
<span class="nc bnc" id="L125" title="All 4 branches missed.">        } while (eventSet == null || eventSet.isEmpty());</span>

        /*
         * Currently, no internal events are requested with a suspend
         * policy other than none, so we don't check for notifySuspend()
         * here. If this changes in the future, there is much
         * infrastructure that needs to be updated.
         */

<span class="nc" id="L134">        return eventSet;</span>
    }

    private TimerThread startTimerThread(long timeout) {
<span class="nc" id="L138">        TimerThread thread = new TimerThread(timeout);</span>
<span class="nc" id="L139">        thread.setDaemon(true);</span>
<span class="nc" id="L140">        thread.start();</span>
<span class="nc" id="L141">        return thread;</span>
    }

    private boolean shouldWait(TimerThread timerThread) {
<span class="nc bnc" id="L145" title="All 6 branches missed.">        return !closed &amp;&amp; eventSets.isEmpty() &amp;&amp;</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">               ((timerThread == null) ? true : !timerThread.timedOut());</span>
    }

    private EventSetImpl removeUnfiltered(long timeout)
                                               throws InterruptedException {
<span class="nc" id="L151">        EventSetImpl eventSet = null;</span>

        /*
         * Make sure the VM has completed initialization before
         * trying to build events.
         */
<span class="nc" id="L157">        vm.waitInitCompletion();</span>

<span class="nc" id="L159">        synchronized(this) {</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">            if (!eventSets.isEmpty()) {</span>
                /*
                 * If there's already something there, no need
                 * for anything elaborate.
                 */
<span class="nc" id="L165">                eventSet = (EventSetImpl)eventSets.removeFirst();</span>
            } else {
                /*
                 * If a timeout was specified, create a thread to
                 * notify this one when a timeout
                 * occurs. We can't use the timed version of wait()
                 * because it is possible for multiple enqueue() calls
                 * before we see something in the eventSet queue
                 * (this is possible when multiple threads call
                 * remove() concurrently -- not a great idea, but
                 * it should be supported). Even if enqueue() did a
                 * notify() instead of notifyAll() we are not able to
                 * use a timed wait because there's no way to distinguish
                 * a timeout from a notify.  That limitation implies a
                 * possible race condition between a timed out thread
                 * and a notified thread.
                 */
<span class="nc" id="L182">                TimerThread timerThread = null;</span>
                try {
<span class="nc bnc" id="L184" title="All 2 branches missed.">                    if (timeout &gt; 0) {</span>
<span class="nc" id="L185">                        timerThread = startTimerThread(timeout);</span>
                    }

<span class="nc bnc" id="L188" title="All 2 branches missed.">                    while (shouldWait(timerThread)) {</span>
<span class="nc" id="L189">                        this.wait();</span>
                    }
                } finally {
<span class="nc bnc" id="L192" title="All 8 branches missed.">                    if ((timerThread != null) &amp;&amp; !timerThread.timedOut()) {</span>
<span class="nc" id="L193">                        timerThread.interrupt();</span>
                    }
                }

<span class="nc bnc" id="L197" title="All 2 branches missed.">                if (eventSets.isEmpty()) {</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">                    if (closed) {</span>
<span class="nc" id="L199">                        throw new VMDisconnectedException();</span>
                    }
                } else {
<span class="nc" id="L202">                    eventSet = (EventSetImpl)eventSets.removeFirst();</span>
                }
            }
<span class="nc" id="L205">        }</span>

        // The build is synchronized on the event set, don't hold
        // the queue lock.
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (eventSet != null) {</span>
<span class="nc" id="L210">            target.notifyDequeueEventSet();</span>
<span class="nc" id="L211">            eventSet.build();</span>
        }
<span class="nc" id="L213">        return eventSet;</span>
    }

    private class TimerThread extends Thread {
<span class="nc" id="L217">        private boolean timedOut = false;</span>
        private long timeout;

<span class="nc" id="L220">        TimerThread(long timeout) {</span>
<span class="nc" id="L221">            super(vm.threadGroupForJDI(), &quot;JDI Event Queue Timer&quot;);</span>
<span class="nc" id="L222">            this.timeout = timeout;</span>
<span class="nc" id="L223">        }</span>

        boolean timedOut() {
<span class="nc" id="L226">            return timedOut;</span>
        }

        public void run() {
            try {
<span class="nc" id="L231">                Thread.sleep(timeout);</span>
<span class="nc" id="L232">                EventQueueImpl queue = EventQueueImpl.this;</span>
<span class="nc" id="L233">                synchronized(queue) {</span>
<span class="nc" id="L234">                    timedOut = true;</span>
<span class="nc" id="L235">                    queue.notifyAll();</span>
<span class="nc" id="L236">                }</span>
<span class="nc" id="L237">            } catch (InterruptedException e) {</span>
                // Exit without notifying
<span class="nc" id="L239">            }</span>
<span class="nc" id="L240">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>