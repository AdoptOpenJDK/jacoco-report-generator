<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SocketTransportService.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.tools.jdi</a> &gt; <span class="el_source">SocketTransportService.java</span></div><h1>SocketTransportService.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import com.sun.jdi.*;
import com.sun.jdi.connect.*;
import com.sun.jdi.connect.spi.*;
import java.net.*;
import java.io.*;
import java.util.Map;
import java.util.ResourceBundle;

/*
 * A transport service based on a TCP connection between the
 * debugger and debugee.
 */

public class SocketTransportService extends TransportService {
<span class="nc" id="L42">    private ResourceBundle messages = null;</span>

    /**
     * The listener returned by startListening encapsulates
     * the ServerSocket.
     */
    static class SocketListenKey extends ListenKey {
        ServerSocket ss;

<span class="nc" id="L51">        SocketListenKey(ServerSocket ss) {</span>
<span class="nc" id="L52">            this.ss = ss;</span>
<span class="nc" id="L53">        }</span>

        ServerSocket socket() {
<span class="nc" id="L56">            return ss;</span>
        }

        /*
         * Returns the string representation of the address that this
         * listen key represents.
         */
        public String address() {
<span class="nc" id="L64">            InetAddress address = ss.getInetAddress();</span>

            /*
             * If bound to the wildcard address then use current local
             * hostname. In the event that we don't know our own hostname
             * then assume that host supports IPv4 and return something to
             * represent the loopback address.
             */
<span class="nc bnc" id="L72" title="All 2 branches missed.">            if (address.isAnyLocalAddress()) {</span>
                try {
<span class="nc" id="L74">                    address = InetAddress.getLocalHost();</span>
<span class="nc" id="L75">                } catch (UnknownHostException uhe) {</span>
<span class="nc" id="L76">                    byte[] loopback = {0x7f,0x00,0x00,0x01};</span>
                    try {
<span class="nc" id="L78">                        address = InetAddress.getByAddress(&quot;127.0.0.1&quot;, loopback);</span>
<span class="nc" id="L79">                    } catch (UnknownHostException x) {</span>
<span class="nc" id="L80">                        throw new InternalError(&quot;unable to get local hostname&quot;);</span>
<span class="nc" id="L81">                    }</span>
<span class="nc" id="L82">                }</span>
            }

            /*
             * Now decide if we return a hostname or IP address. Where possible
             * return a hostname but in the case that we are bound to an
             * address that isn't registered in the name service then we
             * return an address.
             */
            String result;
<span class="nc" id="L92">            String hostname = address.getHostName();</span>
<span class="nc" id="L93">            String hostaddr = address.getHostAddress();</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">            if (hostname.equals(hostaddr)) {</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">                if (address instanceof Inet6Address) {</span>
<span class="nc" id="L96">                    result = &quot;[&quot; + hostaddr + &quot;]&quot;;</span>
                } else {
<span class="nc" id="L98">                    result = hostaddr;</span>
                }
            } else {
<span class="nc" id="L101">                result = hostname;</span>
            }

            /*
             * Finally return &quot;hostname:port&quot;, &quot;ipv4-address:port&quot; or
             * &quot;[ipv6-address]:port&quot;.
             */
<span class="nc" id="L108">            return result + &quot;:&quot; + ss.getLocalPort();</span>
        }

        public String toString() {
<span class="nc" id="L112">            return address();</span>
        }
    }

    /**
     * Handshake with the debuggee
     */
    void handshake(Socket s, long timeout) throws IOException {
<span class="nc" id="L120">        s.setSoTimeout((int)timeout);</span>

<span class="nc" id="L122">        byte[] hello = &quot;JDWP-Handshake&quot;.getBytes(&quot;UTF-8&quot;);</span>
<span class="nc" id="L123">        s.getOutputStream().write(hello);</span>

<span class="nc" id="L125">        byte[] b = new byte[hello.length];</span>
<span class="nc" id="L126">        int received = 0;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        while (received &lt; hello.length) {</span>
            int n;
            try {
<span class="nc" id="L130">                n = s.getInputStream().read(b, received, hello.length-received);</span>
<span class="nc" id="L131">            } catch (SocketTimeoutException x) {</span>
<span class="nc" id="L132">                throw new IOException(&quot;handshake timeout&quot;);</span>
<span class="nc" id="L133">            }</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">            if (n &lt; 0) {</span>
<span class="nc" id="L135">                s.close();</span>
<span class="nc" id="L136">                throw new IOException(&quot;handshake failed - connection prematurally closed&quot;);</span>
            }
<span class="nc" id="L138">            received += n;</span>
<span class="nc" id="L139">        }</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">        for (int i=0; i&lt;hello.length; i++) {</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (b[i] != hello[i]) {</span>
<span class="nc" id="L142">                throw new IOException(&quot;handshake failed - unrecognized message from target VM&quot;);</span>
            }
        }

        // disable read timeout
<span class="nc" id="L147">        s.setSoTimeout(0);</span>
<span class="nc" id="L148">    }</span>

    /**
     * No-arg constructor
     */
<span class="nc" id="L153">    public SocketTransportService() {</span>
<span class="nc" id="L154">    }</span>

    /**
     * The name of this transport service
     */
    public String name() {
<span class="nc" id="L160">        return &quot;Socket&quot;;</span>
    }

    /**
     * Return localized description of this transport service
     */
    public String description() {
<span class="nc" id="L167">        synchronized (this) {</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            if (messages == null) {</span>
<span class="nc" id="L169">                messages = ResourceBundle.getBundle(&quot;com.sun.tools.jdiresources.jdi&quot;);</span>
            }
<span class="nc" id="L171">        }</span>
<span class="nc" id="L172">        return messages.getString(&quot;socket_transportservice.description&quot;);</span>
    }

    /**
     * Return the capabilities of this transport service
     */
    public Capabilities capabilities() {
<span class="nc" id="L179">        return new SocketTransportServiceCapabilities();</span>
    }


    /**
     * Attach to the specified address with optional attach and handshake
     * timeout.
     */
    public Connection attach(String address, long attachTimeout, long handshakeTimeout)
        throws IOException {

<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (address == null) {</span>
<span class="nc" id="L191">            throw new NullPointerException(&quot;address is null&quot;);</span>
        }
<span class="nc bnc" id="L193" title="All 4 branches missed.">        if (attachTimeout &lt; 0 || handshakeTimeout &lt; 0) {</span>
<span class="nc" id="L194">            throw new IllegalArgumentException(&quot;timeout is negative&quot;);</span>
        }

<span class="nc" id="L197">        int splitIndex = address.indexOf(':');</span>
        String host;
        String portStr;
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (splitIndex &lt; 0) {</span>
<span class="nc" id="L201">            host = InetAddress.getLocalHost().getHostName();</span>
<span class="nc" id="L202">            portStr = address;</span>
        } else {
<span class="nc" id="L204">            host = address.substring(0, splitIndex);</span>
<span class="nc" id="L205">            portStr = address.substring(splitIndex+1);</span>
        }

        int port;
        try {
<span class="nc" id="L210">            port = Integer.decode(portStr).intValue();</span>
<span class="nc" id="L211">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L212">            throw new IllegalArgumentException(</span>
                &quot;unable to parse port number in address&quot;);
<span class="nc" id="L214">        }</span>


        // open TCP connection to VM

<span class="nc" id="L219">        InetSocketAddress sa = new InetSocketAddress(host, port);</span>
<span class="nc" id="L220">        Socket s = new Socket();</span>
        try {
<span class="nc" id="L222">            s.connect(sa, (int)attachTimeout);</span>
<span class="nc" id="L223">        } catch (SocketTimeoutException exc) {</span>
            try {
<span class="nc" id="L225">                s.close();</span>
<span class="nc" id="L226">            } catch (IOException x) { }</span>
<span class="nc" id="L227">            throw new TransportTimeoutException(&quot;timed out trying to establish connection&quot;);</span>
<span class="nc" id="L228">        }</span>

        // handshake with the target VM
        try {
<span class="nc" id="L232">            handshake(s, handshakeTimeout);</span>
<span class="nc" id="L233">        } catch (IOException exc) {</span>
            try {
<span class="nc" id="L235">                s.close();</span>
<span class="nc" id="L236">            } catch (IOException x) { }</span>
<span class="nc" id="L237">            throw exc;</span>
<span class="nc" id="L238">        }</span>

<span class="nc" id="L240">        return new SocketConnection(s);</span>
    }

    /*
     * Listen on the specified address and port. Return a listener
     * that encapsulates the ServerSocket.
     */
    ListenKey startListening(String localaddress, int port) throws IOException {
        InetSocketAddress sa;
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (localaddress == null) {</span>
<span class="nc" id="L250">            sa = new InetSocketAddress(port);</span>
        } else {
<span class="nc" id="L252">            sa = new InetSocketAddress(localaddress, port);</span>
        }
<span class="nc" id="L254">        ServerSocket ss = new ServerSocket();</span>
<span class="nc" id="L255">        ss.bind(sa);</span>
<span class="nc" id="L256">        return new SocketListenKey(ss);</span>
    }

    /**
     * Listen on the specified address
     */
    public ListenKey startListening(String address) throws IOException {
        // use ephemeral port if address isn't specified.
<span class="nc bnc" id="L264" title="All 4 branches missed.">        if (address == null || address.length() == 0) {</span>
<span class="nc" id="L265">            address = &quot;0&quot;;</span>
        }

<span class="nc" id="L268">        int splitIndex = address.indexOf(':');</span>
<span class="nc" id="L269">        String localaddr = null;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (splitIndex &gt;= 0) {</span>
<span class="nc" id="L271">            localaddr = address.substring(0, splitIndex);</span>
<span class="nc" id="L272">            address = address.substring(splitIndex+1);</span>
        }

        int port;
        try {
<span class="nc" id="L277">            port = Integer.decode(address).intValue();</span>
<span class="nc" id="L278">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L279">            throw new IllegalArgumentException(</span>
                    &quot;unable to parse port number in address&quot;);
<span class="nc" id="L281">        }</span>

<span class="nc" id="L283">        return startListening(localaddr, port);</span>
    }

    /**
     * Listen on the default address
     */
    public ListenKey startListening() throws IOException {
<span class="nc" id="L290">        return startListening(null, 0);</span>
    }

    /**
     * Stop the listener
     */
    public void stopListening(ListenKey listener) throws IOException {
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (!(listener instanceof SocketListenKey)) {</span>
<span class="nc" id="L298">            throw new IllegalArgumentException(&quot;Invalid listener&quot;);</span>
        }

<span class="nc" id="L301">        synchronized (listener) {</span>
<span class="nc" id="L302">            ServerSocket ss = ((SocketListenKey)listener).socket();</span>

            // if the ServerSocket has been closed it means
            // the listener is invalid
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (ss.isClosed()) {</span>
<span class="nc" id="L307">                throw new IllegalArgumentException(&quot;Invalid listener&quot;);</span>
            }
<span class="nc" id="L309">            ss.close();</span>
<span class="nc" id="L310">        }</span>
<span class="nc" id="L311">    }</span>

    /**
     * Accept a connection from a debuggee and handshake with it.
     */
    public Connection accept(ListenKey listener, long acceptTimeout, long handshakeTimeout) throws IOException {
<span class="nc bnc" id="L317" title="All 4 branches missed.">        if (acceptTimeout &lt; 0 || handshakeTimeout &lt; 0) {</span>
<span class="nc" id="L318">            throw new IllegalArgumentException(&quot;timeout is negative&quot;);</span>
        }
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (!(listener instanceof SocketListenKey)) {</span>
<span class="nc" id="L321">            throw new IllegalArgumentException(&quot;Invalid listener&quot;);</span>
        }
        ServerSocket ss;

        // obtain the ServerSocket from the listener - if the
        // socket is closed it means the listener is invalid
<span class="nc" id="L327">        synchronized (listener) {</span>
<span class="nc" id="L328">            ss = ((SocketListenKey)listener).socket();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            if (ss.isClosed()) {</span>
<span class="nc" id="L330">               throw new IllegalArgumentException(&quot;Invalid listener&quot;);</span>
            }
<span class="nc" id="L332">        }</span>

        // from here onwards it's possible that the ServerSocket
        // may be closed by a call to stopListening - that's okay
        // because the ServerSocket methods will throw an
        // IOException indicating the socket is closed.
        //
        // Additionally, it's possible that another thread calls accept
        // with a different accept timeout - that creates a same race
        // condition between setting the timeout and calling accept.
        // As it is such an unlikely scenario (requires both threads
        // to be using the same listener we've chosen to ignore the issue).

<span class="nc" id="L345">        ss.setSoTimeout((int)acceptTimeout);</span>
        Socket s;
        try {
<span class="nc" id="L348">            s = ss.accept();</span>
<span class="nc" id="L349">        } catch (SocketTimeoutException x) {</span>
<span class="nc" id="L350">            throw new TransportTimeoutException(&quot;timeout waiting for connection&quot;);</span>
<span class="nc" id="L351">        }</span>

        // handshake here
<span class="nc" id="L354">        handshake(s, handshakeTimeout);</span>

<span class="nc" id="L356">        return new SocketConnection(s);</span>
    }

    public String toString() {
<span class="nc" id="L360">       return name();</span>
    }
}


/*
 * The Connection returned by attach and accept is one of these
 */
class SocketConnection extends Connection {
    private Socket socket;
<span class="nc" id="L370">    private boolean closed = false;</span>
    private OutputStream socketOutput;
    private InputStream socketInput;
<span class="nc" id="L373">    private Object receiveLock = new Object();</span>
<span class="nc" id="L374">    private Object sendLock = new Object();</span>
<span class="nc" id="L375">    private Object closeLock = new Object();</span>

<span class="nc" id="L377">    SocketConnection(Socket socket) throws IOException {</span>
<span class="nc" id="L378">        this.socket = socket;</span>
<span class="nc" id="L379">        socket.setTcpNoDelay(true);</span>
<span class="nc" id="L380">        socketInput = socket.getInputStream();</span>
<span class="nc" id="L381">        socketOutput = socket.getOutputStream();</span>
<span class="nc" id="L382">    }</span>

    public void close() throws IOException {
<span class="nc" id="L385">        synchronized (closeLock) {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">           if (closed) {</span>
<span class="nc" id="L387">                return;</span>
           }
<span class="nc" id="L389">           socketOutput.close();</span>
<span class="nc" id="L390">           socketInput.close();</span>
<span class="nc" id="L391">           socket.close();</span>
<span class="nc" id="L392">           closed = true;</span>
<span class="nc" id="L393">        }</span>
<span class="nc" id="L394">    }</span>

    public boolean isOpen() {
<span class="nc" id="L397">        synchronized (closeLock) {</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            return !closed;</span>
<span class="nc" id="L399">        }</span>
    }

    public byte[] readPacket() throws IOException {
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (!isOpen()) {</span>
<span class="nc" id="L404">            throw new ClosedConnectionException(&quot;connection is closed&quot;);</span>
        }
<span class="nc" id="L406">        synchronized (receiveLock) {</span>
            int b1,b2,b3,b4;

            // length
            try {
<span class="nc" id="L411">                b1 = socketInput.read();</span>
<span class="nc" id="L412">                b2 = socketInput.read();</span>
<span class="nc" id="L413">                b3 = socketInput.read();</span>
<span class="nc" id="L414">                b4 = socketInput.read();</span>
<span class="nc" id="L415">            } catch (IOException ioe) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                if (!isOpen()) {</span>
<span class="nc" id="L417">                    throw new ClosedConnectionException(&quot;connection is closed&quot;);</span>
                } else {
<span class="nc" id="L419">                    throw ioe;</span>
                }
<span class="nc" id="L421">            }</span>

            // EOF
<span class="nc bnc" id="L424" title="All 2 branches missed.">            if (b1&lt;0) {</span>
<span class="nc" id="L425">               return new byte[0];</span>
            }

<span class="nc bnc" id="L428" title="All 6 branches missed.">            if (b2&lt;0 || b3&lt;0 || b4&lt;0) {</span>
<span class="nc" id="L429">                throw new IOException(&quot;protocol error - premature EOF&quot;);</span>
            }

<span class="nc" id="L432">            int len = ((b1 &lt;&lt; 24) | (b2 &lt;&lt; 16) | (b3 &lt;&lt; 8) | (b4 &lt;&lt; 0));</span>

<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (len &lt; 0) {</span>
<span class="nc" id="L435">                throw new IOException(&quot;protocol error - invalid length&quot;);</span>
            }

<span class="nc" id="L438">            byte b[] = new byte[len];</span>
<span class="nc" id="L439">            b[0] = (byte)b1;</span>
<span class="nc" id="L440">            b[1] = (byte)b2;</span>
<span class="nc" id="L441">            b[2] = (byte)b3;</span>
<span class="nc" id="L442">            b[3] = (byte)b4;</span>

<span class="nc" id="L444">            int off = 4;</span>
<span class="nc" id="L445">            len -= off;</span>

<span class="nc bnc" id="L447" title="All 2 branches missed.">            while (len &gt; 0) {</span>
                int count;
                try {
<span class="nc" id="L450">                    count = socketInput.read(b, off, len);</span>
<span class="nc" id="L451">                } catch (IOException ioe) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">                    if (!isOpen()) {</span>
<span class="nc" id="L453">                        throw new ClosedConnectionException(&quot;connection is closed&quot;);</span>
                    } else {
<span class="nc" id="L455">                        throw ioe;</span>
                    }
<span class="nc" id="L457">                }</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (count &lt; 0) {</span>
<span class="nc" id="L459">                    throw new IOException(&quot;protocol error - premature EOF&quot;);</span>
                }
<span class="nc" id="L461">                len -= count;</span>
<span class="nc" id="L462">                off += count;</span>
<span class="nc" id="L463">            }</span>

<span class="nc" id="L465">            return b;</span>
<span class="nc" id="L466">        }</span>
    }

    public void writePacket(byte b[]) throws IOException {
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (!isOpen()) {</span>
<span class="nc" id="L471">            throw new ClosedConnectionException(&quot;connection is closed&quot;);</span>
        }

        /*
         * Check the packet size
         */
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (b.length &lt; 11) {</span>
<span class="nc" id="L478">            throw new IllegalArgumentException(&quot;packet is insufficient size&quot;);</span>
        }
<span class="nc" id="L480">        int b0 = b[0] &amp; 0xff;</span>
<span class="nc" id="L481">        int b1 = b[1] &amp; 0xff;</span>
<span class="nc" id="L482">        int b2 = b[2] &amp; 0xff;</span>
<span class="nc" id="L483">        int b3 = b[3] &amp; 0xff;</span>
<span class="nc" id="L484">        int len = ((b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | (b3 &lt;&lt; 0));</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if (len &lt; 11) {</span>
<span class="nc" id="L486">            throw new IllegalArgumentException(&quot;packet is insufficient size&quot;);</span>
        }

        /*
         * Check that the byte array contains the complete packet
         */
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (len &gt; b.length) {</span>
<span class="nc" id="L493">            throw new IllegalArgumentException(&quot;length mis-match&quot;);</span>
        }

<span class="nc" id="L496">        synchronized (sendLock) {</span>
            try {
                /*
                 * Send the packet (ignoring any bytes that follow
                 * the packet in the byte array).
                 */
<span class="nc" id="L502">                socketOutput.write(b, 0, len);</span>
<span class="nc" id="L503">            } catch (IOException ioe) {</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                if (!isOpen()) {</span>
<span class="nc" id="L505">                    throw new ClosedConnectionException(&quot;connection is closed&quot;);</span>
                } else {
<span class="nc" id="L507">                    throw ioe;</span>
                }
<span class="nc" id="L509">            }</span>
<span class="nc" id="L510">        }</span>
<span class="nc" id="L511">    }</span>
}


/*
 * The capabilities of the socket transport service
 */
<span class="nc" id="L518">class SocketTransportServiceCapabilities extends TransportService.Capabilities {</span>

    public boolean supportsMultipleConnections() {
<span class="nc" id="L521">        return true;</span>
    }

    public boolean supportsAttachTimeout() {
<span class="nc" id="L525">        return true;</span>
    }

    public boolean supportsAcceptTimeout() {
<span class="nc" id="L529">        return true;</span>
    }

    public boolean supportsHandshakeTimeout() {
<span class="nc" id="L533">        return true;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>