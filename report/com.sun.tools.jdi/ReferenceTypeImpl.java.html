<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReferenceTypeImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.tools.jdi</a> &gt; <span class="el_source">ReferenceTypeImpl.java</span></div><h1>ReferenceTypeImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import com.sun.jdi.*;

import java.util.*;
import java.lang.ref.SoftReference;

public abstract class ReferenceTypeImpl extends TypeImpl
implements ReferenceType {
    protected long ref;
<span class="nc" id="L36">    private String signature = null;</span>
<span class="nc" id="L37">    private String genericSignature = null;</span>
<span class="nc" id="L38">    private boolean genericSignatureGotten = false;</span>
<span class="nc" id="L39">    private String baseSourceName = null;</span>
<span class="nc" id="L40">    private String baseSourceDir = null;</span>
<span class="nc" id="L41">    private String baseSourcePath = null;</span>
<span class="nc" id="L42">    protected int modifiers = -1;</span>
<span class="nc" id="L43">    private SoftReference&lt;List&lt;Field&gt;&gt; fieldsRef = null;</span>
<span class="nc" id="L44">    private SoftReference&lt;List&lt;Method&gt;&gt; methodsRef = null;</span>
<span class="nc" id="L45">    private SoftReference&lt;SDE&gt; sdeRef = null;</span>

<span class="nc" id="L47">    private boolean isClassLoaderCached = false;</span>
<span class="nc" id="L48">    private ClassLoaderReference classLoader = null;</span>
<span class="nc" id="L49">    private ClassObjectReference classObject = null;</span>

<span class="nc" id="L51">    private int status = 0;</span>
<span class="nc" id="L52">    private boolean isPrepared = false;</span>


<span class="nc" id="L55">    private boolean versionNumberGotten = false;</span>
    private int majorVersion;
    private int minorVersion;

<span class="nc" id="L59">    private boolean constantPoolInfoGotten = false;</span>
    private int constanPoolCount;
    private byte[] constantPoolBytes;
<span class="nc" id="L62">    private SoftReference&lt;byte[]&gt; constantPoolBytesRef = null;</span>

    /* to mark a SourceFile request that returned a genuine JDWP.Error.ABSENT_INFORMATION */
    private static final String ABSENT_BASE_SOURCE_NAME = &quot;**ABSENT_BASE_SOURCE_NAME**&quot;;

    /* to mark when no info available */
<span class="nc" id="L68">    static final SDE NO_SDE_INFO_MARK = new SDE();</span>

    // bits set when initialization was attempted (succeeded or failed)
    private static final int INITIALIZED_OR_FAILED =
        JDWP.ClassStatus.INITIALIZED | JDWP.ClassStatus.ERROR;


    protected ReferenceTypeImpl(VirtualMachine aVm, long aRef) {
<span class="nc" id="L76">        super(aVm);</span>
<span class="nc" id="L77">        ref = aRef;</span>
<span class="nc" id="L78">        genericSignatureGotten = false;</span>
<span class="nc" id="L79">    }</span>

    void noticeRedefineClass() {
        //Invalidate information previously fetched and cached.
        //These will be refreshed later on demand.
<span class="nc" id="L84">        baseSourceName = null;</span>
<span class="nc" id="L85">        baseSourcePath = null;</span>
<span class="nc" id="L86">        modifiers = -1;</span>
<span class="nc" id="L87">        fieldsRef = null;</span>
<span class="nc" id="L88">        methodsRef = null;</span>
<span class="nc" id="L89">        sdeRef = null;</span>
<span class="nc" id="L90">        versionNumberGotten = false;</span>
<span class="nc" id="L91">        constantPoolInfoGotten = false;</span>
<span class="nc" id="L92">    }</span>

    Method getMethodMirror(long ref) {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (ref == 0) {</span>
            // obsolete method
<span class="nc" id="L97">            return new ObsoleteMethodImpl(vm, this);</span>
        }
        // Fetch all methods for the class, check performance impact
        // Needs no synchronization now, since methods() returns
        // unmodifiable local data
<span class="nc" id="L102">        Iterator&lt;Method&gt; it = methods().iterator();</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L104">            MethodImpl method = (MethodImpl)it.next();</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (method.ref() == ref) {</span>
<span class="nc" id="L106">                return method;</span>
            }
<span class="nc" id="L108">        }</span>
<span class="nc" id="L109">        throw new IllegalArgumentException(&quot;Invalid method id: &quot; + ref);</span>
    }

    Field getFieldMirror(long ref) {
        // Fetch all fields for the class, check performance impact
        // Needs no synchronization now, since fields() returns
        // unmodifiable local data
<span class="nc" id="L116">        Iterator&lt;Field&gt;it = fields().iterator();</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L118">            FieldImpl field = (FieldImpl)it.next();</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">            if (field.ref() == ref) {</span>
<span class="nc" id="L120">                return field;</span>
            }
<span class="nc" id="L122">        }</span>
<span class="nc" id="L123">        throw new IllegalArgumentException(&quot;Invalid field id: &quot; + ref);</span>
    }

    public boolean equals(Object obj) {
<span class="nc bnc" id="L127" title="All 4 branches missed.">        if ((obj != null) &amp;&amp; (obj instanceof ReferenceTypeImpl)) {</span>
<span class="nc" id="L128">            ReferenceTypeImpl other = (ReferenceTypeImpl)obj;</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            return (ref() == other.ref()) &amp;&amp;</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">                (vm.equals(other.virtualMachine()));</span>
        } else {
<span class="nc" id="L132">            return false;</span>
        }
    }

    public int hashCode() {
<span class="nc" id="L137">        return(int)ref();</span>
    }

    public int compareTo(ReferenceType object) {
        /*
         * Note that it is critical that compareTo() == 0
         * implies that equals() == true. Otherwise, TreeSet
         * will collapse classes.
         *
         * (Classes of the same name loaded by different class loaders
         * or in different VMs must not return 0).
         */
<span class="nc" id="L149">        ReferenceTypeImpl other = (ReferenceTypeImpl)object;</span>
<span class="nc" id="L150">        int comp = name().compareTo(other.name());</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (comp == 0) {</span>
<span class="nc" id="L152">            long rf1 = ref();</span>
<span class="nc" id="L153">            long rf2 = other.ref();</span>
            // optimize for typical case: refs equal and VMs equal
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (rf1 == rf2) {</span>
                // sequenceNumbers are always positive
<span class="nc" id="L157">                comp = vm.sequenceNumber -</span>
<span class="nc" id="L158">                 ((VirtualMachineImpl)(other.virtualMachine())).sequenceNumber;</span>
            } else {
<span class="nc bnc" id="L160" title="All 2 branches missed.">                comp = (rf1 &lt; rf2)? -1 : 1;</span>
            }
        }
<span class="nc" id="L163">        return comp;</span>
    }

    public String signature() {
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (signature == null) {</span>
            // Does not need synchronization, since worst-case
            // static info is fetched twice
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (vm.canGet1_5LanguageFeatures()) {</span>
                /*
                 * we might as well get both the signature and the
                 * generic signature.
                 */
<span class="nc" id="L175">                genericSignature();</span>
            } else {
                try {
<span class="nc" id="L178">                    signature = JDWP.ReferenceType.Signature.</span>
<span class="nc" id="L179">                        process(vm, this).signature;</span>
<span class="nc" id="L180">                } catch (JDWPException exc) {</span>
<span class="nc" id="L181">                    throw exc.toJDIException();</span>
<span class="nc" id="L182">                }</span>
            }
        }
<span class="nc" id="L185">        return signature;</span>
    }

    public String genericSignature() {
        // This gets both the signature and the generic signature
<span class="nc bnc" id="L190" title="All 4 branches missed.">        if (vm.canGet1_5LanguageFeatures() &amp;&amp; !genericSignatureGotten) {</span>
            // Does not need synchronization, since worst-case
            // static info is fetched twice
            JDWP.ReferenceType.SignatureWithGeneric result;
            try {
<span class="nc" id="L195">                result = JDWP.ReferenceType.SignatureWithGeneric.</span>
<span class="nc" id="L196">                    process(vm, this);</span>
<span class="nc" id="L197">            } catch (JDWPException exc) {</span>
<span class="nc" id="L198">                throw exc.toJDIException();</span>
<span class="nc" id="L199">            }</span>
<span class="nc" id="L200">            signature = result.signature;</span>
<span class="nc" id="L201">            setGenericSignature(result.genericSignature);</span>
        }
<span class="nc" id="L203">        return genericSignature;</span>
    }

    public ClassLoaderReference classLoader() {
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (!isClassLoaderCached) {</span>
            // Does not need synchronization, since worst-case
            // static info is fetched twice
            try {
<span class="nc" id="L211">                classLoader = (ClassLoaderReference)</span>
                    JDWP.ReferenceType.ClassLoader.
<span class="nc" id="L213">                    process(vm, this).classLoader;</span>
<span class="nc" id="L214">                isClassLoaderCached = true;</span>
<span class="nc" id="L215">            } catch (JDWPException exc) {</span>
<span class="nc" id="L216">                throw exc.toJDIException();</span>
<span class="nc" id="L217">            }</span>
        }
<span class="nc" id="L219">        return classLoader;</span>
    }

    public boolean isPublic() {
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (modifiers == -1)</span>
<span class="nc" id="L224">            getModifiers();</span>

<span class="nc bnc" id="L226" title="All 2 branches missed.">        return((modifiers &amp; VMModifiers.PUBLIC) &gt; 0);</span>
    }

    public boolean isProtected() {
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (modifiers == -1)</span>
<span class="nc" id="L231">            getModifiers();</span>

<span class="nc bnc" id="L233" title="All 2 branches missed.">        return((modifiers &amp; VMModifiers.PROTECTED) &gt; 0);</span>
    }

    public boolean isPrivate() {
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (modifiers == -1)</span>
<span class="nc" id="L238">            getModifiers();</span>

<span class="nc bnc" id="L240" title="All 2 branches missed.">        return((modifiers &amp; VMModifiers.PRIVATE) &gt; 0);</span>
    }

    public boolean isPackagePrivate() {
<span class="nc bnc" id="L244" title="All 6 branches missed.">        return !isPublic() &amp;&amp; !isPrivate() &amp;&amp; !isProtected();</span>
    }

    public boolean isAbstract() {
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (modifiers == -1)</span>
<span class="nc" id="L249">            getModifiers();</span>

<span class="nc bnc" id="L251" title="All 2 branches missed.">        return((modifiers &amp; VMModifiers.ABSTRACT) &gt; 0);</span>
    }

    public boolean isFinal() {
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (modifiers == -1)</span>
<span class="nc" id="L256">            getModifiers();</span>

<span class="nc bnc" id="L258" title="All 2 branches missed.">        return((modifiers &amp; VMModifiers.FINAL) &gt; 0);</span>
    }

    public boolean isStatic() {
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (modifiers == -1)</span>
<span class="nc" id="L263">            getModifiers();</span>

<span class="nc bnc" id="L265" title="All 2 branches missed.">        return((modifiers &amp; VMModifiers.STATIC) &gt; 0);</span>
    }

    public boolean isPrepared() {
        // This ref type may have been prepared before we were getting
        // events, so get it once.  After that,
        // this status flag is updated through the ClassPrepareEvent,
        // there is no need for the expense of a JDWP query.
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (status == 0) {</span>
<span class="nc" id="L274">            updateStatus();</span>
        }
<span class="nc" id="L276">        return isPrepared;</span>
    }

    public boolean isVerified() {
        // Once true, it never resets, so we don't need to update
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if ((status &amp; JDWP.ClassStatus.VERIFIED) == 0) {</span>
<span class="nc" id="L282">            updateStatus();</span>
        }
<span class="nc bnc" id="L284" title="All 2 branches missed.">        return (status &amp; JDWP.ClassStatus.VERIFIED) != 0;</span>
    }

    public boolean isInitialized() {
        // Once initialization succeeds or fails, it never resets,
        // so we don't need to update
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if ((status &amp; INITIALIZED_OR_FAILED) == 0) {</span>
<span class="nc" id="L291">            updateStatus();</span>
        }
<span class="nc bnc" id="L293" title="All 2 branches missed.">        return (status &amp; JDWP.ClassStatus.INITIALIZED) != 0;</span>
    }

    public boolean failedToInitialize() {
        // Once initialization succeeds or fails, it never resets,
        // so we don't need to update
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if ((status &amp; INITIALIZED_OR_FAILED) == 0) {</span>
<span class="nc" id="L300">            updateStatus();</span>
        }
<span class="nc bnc" id="L302" title="All 2 branches missed.">        return (status &amp; JDWP.ClassStatus.ERROR) != 0;</span>
    }

    public List&lt;Field&gt; fields() {
<span class="nc bnc" id="L306" title="All 2 branches missed.">        List&lt;Field&gt; fields = (fieldsRef == null) ? null : fieldsRef.get();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (fields == null) {</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (vm.canGet1_5LanguageFeatures()) {</span>
                JDWP.ReferenceType.FieldsWithGeneric.FieldInfo[] jdwpFields;
                try {
<span class="nc" id="L311">                    jdwpFields = JDWP.ReferenceType.FieldsWithGeneric.process(vm, this).declared;</span>
<span class="nc" id="L312">                } catch (JDWPException exc) {</span>
<span class="nc" id="L313">                    throw exc.toJDIException();</span>
<span class="nc" id="L314">                }</span>
<span class="nc" id="L315">                fields = new ArrayList&lt;Field&gt;(jdwpFields.length);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                for (int i=0; i&lt;jdwpFields.length; i++) {</span>
<span class="nc" id="L317">                    JDWP.ReferenceType.FieldsWithGeneric.FieldInfo fi</span>
                        = jdwpFields[i];

<span class="nc" id="L320">                    Field field = new FieldImpl(vm, this, fi.fieldID,</span>
                                                fi.name, fi.signature,
                                                fi.genericSignature,
                                                fi.modBits);
<span class="nc" id="L324">                    fields.add(field);</span>
                }
<span class="nc" id="L326">            } else {</span>
                JDWP.ReferenceType.Fields.FieldInfo[] jdwpFields;
                try {
<span class="nc" id="L329">                    jdwpFields = JDWP.ReferenceType.Fields.</span>
<span class="nc" id="L330">                        process(vm, this).declared;</span>
<span class="nc" id="L331">                } catch (JDWPException exc) {</span>
<span class="nc" id="L332">                    throw exc.toJDIException();</span>
<span class="nc" id="L333">                }</span>
<span class="nc" id="L334">                fields = new ArrayList&lt;Field&gt;(jdwpFields.length);</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                for (int i=0; i&lt;jdwpFields.length; i++) {</span>
<span class="nc" id="L336">                    JDWP.ReferenceType.Fields.FieldInfo fi = jdwpFields[i];</span>

<span class="nc" id="L338">                    Field field = new FieldImpl(vm, this, fi.fieldID,</span>
                                            fi.name, fi.signature,
                                            null,
                                            fi.modBits);
<span class="nc" id="L342">                    fields.add(field);</span>
                }
            }

<span class="nc" id="L346">            fields = Collections.unmodifiableList(fields);</span>
<span class="nc" id="L347">            fieldsRef = new SoftReference&lt;List&lt;Field&gt;&gt;(fields);</span>
        }
<span class="nc" id="L349">        return fields;</span>
    }

    abstract List&lt;? extends ReferenceType&gt; inheritedTypes();

    void addVisibleFields(List&lt;Field&gt; visibleList, Map&lt;String, Field&gt; visibleTable, List&lt;String&gt; ambiguousNames) {
<span class="nc bnc" id="L355" title="All 2 branches missed.">        for (Field field : visibleFields()) {</span>
<span class="nc" id="L356">            String name = field.name();</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">            if (!ambiguousNames.contains(name)) {</span>
<span class="nc" id="L358">                Field duplicate = visibleTable.get(name);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                if (duplicate == null) {</span>
<span class="nc" id="L360">                    visibleList.add(field);</span>
<span class="nc" id="L361">                    visibleTable.put(name, field);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">                } else if (!field.equals(duplicate)) {</span>
<span class="nc" id="L363">                    ambiguousNames.add(name);</span>
<span class="nc" id="L364">                    visibleTable.remove(name);</span>
<span class="nc" id="L365">                    visibleList.remove(duplicate);</span>
                } else {
                    // identical field from two branches; do nothing
                }
            }
<span class="nc" id="L370">        }</span>
<span class="nc" id="L371">    }</span>

    public List&lt;Field&gt; visibleFields() {
        /*
         * Maintain two different collections of visible fields. The
         * list maintains a reasonable order for return. The
         * hash map provides an efficient way to lookup visible fields
         * by name, important for finding hidden or ambiguous fields.
         */
<span class="nc" id="L380">        List&lt;Field&gt; visibleList = new ArrayList&lt;Field&gt;();</span>
<span class="nc" id="L381">        Map&lt;String, Field&gt;  visibleTable = new HashMap&lt;String, Field&gt;();</span>

        /* Track fields removed from above collection due to ambiguity */
<span class="nc" id="L384">        List&lt;String&gt; ambiguousNames = new ArrayList&lt;String&gt;();</span>

        /* Add inherited, visible fields */
<span class="nc" id="L387">        List&lt;? extends ReferenceType&gt; types = inheritedTypes();</span>
<span class="nc" id="L388">        Iterator&lt;? extends ReferenceType&gt; iter = types.iterator();</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
            /*
             * TO DO: Be defensive and check for cyclic interface inheritance
             */
<span class="nc" id="L393">            ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();</span>
<span class="nc" id="L394">            type.addVisibleFields(visibleList, visibleTable, ambiguousNames);</span>
<span class="nc" id="L395">        }</span>

        /*
         * Insert fields from this type, removing any inherited fields they
         * hide.
         */
<span class="nc" id="L401">        List&lt;Field&gt; retList = new ArrayList&lt;Field&gt;(fields());</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">        for (Field field : retList) {</span>
<span class="nc" id="L403">            Field hidden = visibleTable.get(field.name());</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">            if (hidden != null) {</span>
<span class="nc" id="L405">                visibleList.remove(hidden);</span>
            }
<span class="nc" id="L407">        }</span>
<span class="nc" id="L408">        retList.addAll(visibleList);</span>
<span class="nc" id="L409">        return retList;</span>
    }

    void addAllFields(List&lt;Field&gt; fieldList, Set&lt;ReferenceType&gt; typeSet) {
        /* Continue the recursion only if this type is new */
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (!typeSet.contains(this)) {</span>
<span class="nc" id="L415">            typeSet.add((ReferenceType)this);</span>

            /* Add local fields */
<span class="nc" id="L418">            fieldList.addAll(fields());</span>

            /* Add inherited fields */
<span class="nc" id="L421">            List&lt;? extends ReferenceType&gt; types = inheritedTypes();</span>
<span class="nc" id="L422">            Iterator&lt;? extends ReferenceType&gt; iter = types.iterator();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L424">                ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();</span>
<span class="nc" id="L425">                type.addAllFields(fieldList, typeSet);</span>
<span class="nc" id="L426">            }</span>
        }
<span class="nc" id="L428">    }</span>
    public List&lt;Field&gt; allFields() {
<span class="nc" id="L430">        List&lt;Field&gt; fieldList = new ArrayList&lt;Field&gt;();</span>
<span class="nc" id="L431">        Set&lt;ReferenceType&gt; typeSet = new HashSet&lt;ReferenceType&gt;();</span>
<span class="nc" id="L432">        addAllFields(fieldList, typeSet);</span>
<span class="nc" id="L433">        return fieldList;</span>
    }

    public Field fieldByName(String fieldName) {
<span class="nc" id="L437">        List&lt;Field&gt; searchList = visibleFields();</span>

<span class="nc bnc" id="L439" title="All 2 branches missed.">        for (int i=0; i&lt;searchList.size(); i++) {</span>
<span class="nc" id="L440">            Field f = searchList.get(i);</span>

<span class="nc bnc" id="L442" title="All 2 branches missed.">            if (f.name().equals(fieldName)) {</span>
<span class="nc" id="L443">                return f;</span>
            }
        }
        //throw new NoSuchFieldException(&quot;Field '&quot; + fieldName + &quot;' not found in &quot; + name());
<span class="nc" id="L447">        return null;</span>
    }

    public List&lt;Method&gt; methods() {
<span class="nc bnc" id="L451" title="All 2 branches missed.">        List&lt;Method&gt; methods = (methodsRef == null) ? null : methodsRef.get();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (methods == null) {</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">            if (!vm.canGet1_5LanguageFeatures()) {</span>
<span class="nc" id="L454">                methods = methods1_4();</span>
            } else {
                JDWP.ReferenceType.MethodsWithGeneric.MethodInfo[] declared;
                try {
<span class="nc" id="L458">                    declared = JDWP.ReferenceType.MethodsWithGeneric.</span>
<span class="nc" id="L459">                        process(vm, this).declared;</span>
<span class="nc" id="L460">                } catch (JDWPException exc) {</span>
<span class="nc" id="L461">                    throw exc.toJDIException();</span>
<span class="nc" id="L462">                }</span>
<span class="nc" id="L463">                methods = new ArrayList&lt;Method&gt;(declared.length);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                for (int i=0; i&lt;declared.length; i++) {</span>
                    JDWP.ReferenceType.MethodsWithGeneric.MethodInfo
<span class="nc" id="L466">                        mi = declared[i];</span>

<span class="nc" id="L468">                    Method method = MethodImpl.createMethodImpl(vm, this,</span>
                                                         mi.methodID,
                                                         mi.name, mi.signature,
                                                         mi.genericSignature,
                                                         mi.modBits);
<span class="nc" id="L473">                    methods.add(method);</span>
                }
            }
<span class="nc" id="L476">            methods = Collections.unmodifiableList(methods);</span>
<span class="nc" id="L477">            methodsRef = new SoftReference&lt;List&lt;Method&gt;&gt;(methods);</span>
        }
<span class="nc" id="L479">        return methods;</span>
    }

    private List&lt;Method&gt; methods1_4() {
        List&lt;Method&gt; methods;
        JDWP.ReferenceType.Methods.MethodInfo[] declared;
        try {
<span class="nc" id="L486">            declared = JDWP.ReferenceType.Methods.</span>
<span class="nc" id="L487">                process(vm, this).declared;</span>
<span class="nc" id="L488">        } catch (JDWPException exc) {</span>
<span class="nc" id="L489">            throw exc.toJDIException();</span>
<span class="nc" id="L490">        }</span>
<span class="nc" id="L491">        methods = new ArrayList&lt;Method&gt;(declared.length);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        for (int i=0; i&lt;declared.length; i++) {</span>
<span class="nc" id="L493">            JDWP.ReferenceType.Methods.MethodInfo mi = declared[i];</span>

<span class="nc" id="L495">            Method method = MethodImpl.createMethodImpl(vm, this,</span>
                                                        mi.methodID,
                                                        mi.name, mi.signature,
                                                        null,
                                                        mi.modBits);
<span class="nc" id="L500">            methods.add(method);</span>
        }
<span class="nc" id="L502">        return methods;</span>
    }

    /*
     * Utility method used by subclasses to build lists of visible
     * methods.
     */
    void addToMethodMap(Map&lt;String, Method&gt; methodMap, List&lt;Method&gt; methodList) {
<span class="nc bnc" id="L510" title="All 2 branches missed.">        for (Method method : methodList)</span>
<span class="nc" id="L511">            methodMap.put(method.name().concat(method.signature()), method);</span>
<span class="nc" id="L512">        }</span>

    abstract void addVisibleMethods(Map&lt;String, Method&gt; methodMap);

    public List&lt;Method&gt; visibleMethods() {
        /*
         * Build a collection of all visible methods. The hash
         * map allows us to do this efficiently by keying on the
         * concatenation of name and signature.
         */
<span class="nc" id="L522">        Map&lt;String, Method&gt; map = new HashMap&lt;String, Method&gt;();</span>
<span class="nc" id="L523">        addVisibleMethods(map);</span>

        /*
         * ... but the hash map destroys order. Methods should be
         * returned in a sensible order, as they are in allMethods().
         * So, start over with allMethods() and use the hash map
         * to filter that ordered collection.
         */
<span class="nc" id="L531">        List&lt;Method&gt; list = allMethods();</span>
<span class="nc" id="L532">        list.retainAll(map.values());</span>
<span class="nc" id="L533">        return list;</span>
    }

    abstract public List&lt;Method&gt; allMethods();

    public List&lt;Method&gt; methodsByName(String name) {
<span class="nc" id="L539">        List&lt;Method&gt; methods = visibleMethods();</span>
<span class="nc" id="L540">        ArrayList&lt;Method&gt; retList = new ArrayList&lt;Method&gt;(methods.size());</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        for (Method candidate : methods) {</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            if (candidate.name().equals(name)) {</span>
<span class="nc" id="L543">                retList.add(candidate);</span>
            }
<span class="nc" id="L545">        }</span>
<span class="nc" id="L546">        retList.trimToSize();</span>
<span class="nc" id="L547">        return retList;</span>
    }

    public List&lt;Method&gt; methodsByName(String name, String signature) {
<span class="nc" id="L551">        List&lt;Method&gt; methods = visibleMethods();</span>
<span class="nc" id="L552">        ArrayList&lt;Method&gt; retList = new ArrayList&lt;Method&gt;(methods.size());</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        for (Method candidate : methods) {</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">            if (candidate.name().equals(name) &amp;&amp;</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">                candidate.signature().equals(signature)) {</span>
<span class="nc" id="L556">                retList.add(candidate);</span>
            }
<span class="nc" id="L558">        }</span>
<span class="nc" id="L559">        retList.trimToSize();</span>
<span class="nc" id="L560">        return retList;</span>
    }

    List&lt;InterfaceType&gt; getInterfaces() {
        InterfaceTypeImpl[] intfs;
        try {
<span class="nc" id="L566">            intfs = JDWP.ReferenceType.Interfaces.</span>
<span class="nc" id="L567">                                         process(vm, this).interfaces;</span>
<span class="nc" id="L568">        } catch (JDWPException exc) {</span>
<span class="nc" id="L569">            throw exc.toJDIException();</span>
<span class="nc" id="L570">        }</span>
<span class="nc" id="L571">        return Arrays.asList((InterfaceType[])intfs);</span>
    }

    public List&lt;ReferenceType&gt; nestedTypes() {
<span class="nc" id="L575">        List&lt;ReferenceType&gt; all = vm.allClasses();</span>
<span class="nc" id="L576">        List&lt;ReferenceType&gt; nested = new ArrayList&lt;ReferenceType&gt;();</span>
<span class="nc" id="L577">        String outername = name();</span>
<span class="nc" id="L578">        int outerlen = outername.length();</span>
<span class="nc" id="L579">        Iterator&lt;ReferenceType&gt; iter = all.iterator();</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L581">            ReferenceType refType = iter.next();</span>
<span class="nc" id="L582">            String name = refType.name();</span>
<span class="nc" id="L583">            int len = name.length();</span>
            /* The separator is historically '$' but could also be '#' */
<span class="nc bnc" id="L585" title="All 4 branches missed.">            if ( len &gt; outerlen &amp;&amp; name.startsWith(outername) ) {</span>
<span class="nc" id="L586">                char c = name.charAt(outerlen);</span>
<span class="nc bnc" id="L587" title="All 4 branches missed.">                if ( c =='$' || c== '#' ) {</span>
<span class="nc" id="L588">                    nested.add(refType);</span>
                }
            }
<span class="nc" id="L591">        }</span>
<span class="nc" id="L592">        return nested;</span>
    }

    public Value getValue(Field sig) {
<span class="nc" id="L596">        List&lt;Field&gt; list = new ArrayList&lt;Field&gt;(1);</span>
<span class="nc" id="L597">        list.add(sig);</span>
<span class="nc" id="L598">        Map&lt;Field, Value&gt; map = getValues(list);</span>
<span class="nc" id="L599">        return map.get(sig);</span>
    }


    void validateFieldAccess(Field field) {
        /*
         * Field must be in this object's class, a superclass, or
         * implemented interface
         */
<span class="nc" id="L608">        ReferenceTypeImpl declType = (ReferenceTypeImpl)field.declaringType();</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (!declType.isAssignableFrom(this)) {</span>
<span class="nc" id="L610">            throw new IllegalArgumentException(&quot;Invalid field&quot;);</span>
        }
<span class="nc" id="L612">    }</span>

    void validateFieldSet(Field field) {
<span class="nc" id="L615">        validateFieldAccess(field);</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (field.isFinal()) {</span>
<span class="nc" id="L617">            throw new IllegalArgumentException(&quot;Cannot set value of final field&quot;);</span>
        }
<span class="nc" id="L619">    }</span>

    /**
     * Returns a map of field values
     */
    public Map&lt;Field,Value&gt; getValues(List&lt;? extends Field&gt; theFields) {
<span class="nc" id="L625">        validateMirrors(theFields);</span>

<span class="nc" id="L627">        int size = theFields.size();</span>
<span class="nc" id="L628">        JDWP.ReferenceType.GetValues.Field[] queryFields =</span>
                         new JDWP.ReferenceType.GetValues.Field[size];

<span class="nc bnc" id="L631" title="All 2 branches missed.">        for (int i=0; i&lt;size; i++) {</span>
<span class="nc" id="L632">            FieldImpl field = (FieldImpl)theFields.get(i);</span>

<span class="nc" id="L634">            validateFieldAccess(field);</span>

            // Do more validation specific to ReferenceType field getting
<span class="nc bnc" id="L637" title="All 2 branches missed.">            if (!field.isStatic()) {</span>
<span class="nc" id="L638">                throw new IllegalArgumentException(</span>
                     &quot;Attempt to use non-static field with ReferenceType&quot;);
            }
<span class="nc" id="L641">            queryFields[i] = new JDWP.ReferenceType.GetValues.Field(</span>
<span class="nc" id="L642">                                         field.ref());</span>
        }

<span class="nc" id="L645">        Map&lt;Field, Value&gt; map = new HashMap&lt;Field, Value&gt;(size);</span>

        ValueImpl[] values;
        try {
<span class="nc" id="L649">            values = JDWP.ReferenceType.GetValues.</span>
<span class="nc" id="L650">                                     process(vm, this, queryFields).values;</span>
<span class="nc" id="L651">        } catch (JDWPException exc) {</span>
<span class="nc" id="L652">            throw exc.toJDIException();</span>
<span class="nc" id="L653">        }</span>

<span class="nc bnc" id="L655" title="All 2 branches missed.">        if (size != values.length) {</span>
<span class="nc" id="L656">            throw new InternalException(</span>
                         &quot;Wrong number of values returned from target VM&quot;);
        }
<span class="nc bnc" id="L659" title="All 2 branches missed.">        for (int i=0; i&lt;size; i++) {</span>
<span class="nc" id="L660">            FieldImpl field = (FieldImpl)theFields.get(i);</span>
<span class="nc" id="L661">            map.put(field, values[i]);</span>
        }

<span class="nc" id="L664">        return map;</span>
    }

    public ClassObjectReference classObject() {
<span class="nc bnc" id="L668" title="All 2 branches missed.">        if (classObject == null) {</span>
            // Are classObjects unique for an Object, or
            // created each time? Is this spec'ed?
<span class="nc" id="L671">            synchronized(this) {</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">                if (classObject == null) {</span>
                    try {
<span class="nc" id="L674">                        classObject = JDWP.ReferenceType.ClassObject.</span>
<span class="nc" id="L675">                            process(vm, this).classObject;</span>
<span class="nc" id="L676">                    } catch (JDWPException exc) {</span>
<span class="nc" id="L677">                        throw exc.toJDIException();</span>
<span class="nc" id="L678">                    }</span>
                }
<span class="nc" id="L680">            }</span>
        }
<span class="nc" id="L682">        return classObject;</span>
    }

    SDE.Stratum stratum(String stratumID) {
<span class="nc" id="L686">        SDE sde = sourceDebugExtensionInfo();</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">        if (!sde.isValid()) {</span>
<span class="nc" id="L688">            sde = NO_SDE_INFO_MARK;</span>
        }
<span class="nc" id="L690">        return sde.stratum(stratumID);</span>
    }

    public String sourceName() throws AbsentInformationException {
<span class="nc" id="L694">        return sourceNames(vm.getDefaultStratum()).get(0);</span>
    }

    public List&lt;String&gt; sourceNames(String stratumID)
                                throws AbsentInformationException {
<span class="nc" id="L699">        SDE.Stratum stratum = stratum(stratumID);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">        if (stratum.isJava()) {</span>
<span class="nc" id="L701">            List&lt;String&gt; result = new ArrayList&lt;String&gt;(1);</span>
<span class="nc" id="L702">            result.add(baseSourceName());</span>
<span class="nc" id="L703">            return result;</span>
        }
<span class="nc" id="L705">        return stratum.sourceNames(this);</span>
    }

    public List&lt;String&gt; sourcePaths(String stratumID)
                                throws AbsentInformationException {
<span class="nc" id="L710">        SDE.Stratum stratum = stratum(stratumID);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (stratum.isJava()) {</span>
<span class="nc" id="L712">            List&lt;String&gt; result = new ArrayList&lt;String&gt;(1);</span>
<span class="nc" id="L713">            result.add(baseSourceDir() + baseSourceName());</span>
<span class="nc" id="L714">            return result;</span>
        }
<span class="nc" id="L716">        return stratum.sourcePaths(this);</span>
    }

    String baseSourceName() throws AbsentInformationException {
<span class="nc" id="L720">        String bsn = baseSourceName;</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">        if (bsn == null) {</span>
            // Does not need synchronization, since worst-case
            // static info is fetched twice
            try {
<span class="nc" id="L725">                bsn = JDWP.ReferenceType.SourceFile.</span>
<span class="nc" id="L726">                    process(vm, this).sourceFile;</span>
<span class="nc" id="L727">            } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">                if (exc.errorCode() == JDWP.Error.ABSENT_INFORMATION) {</span>
<span class="nc" id="L729">                    bsn = ABSENT_BASE_SOURCE_NAME;</span>
                } else {
<span class="nc" id="L731">                    throw exc.toJDIException();</span>
                }
<span class="nc" id="L733">            }</span>
<span class="nc" id="L734">            baseSourceName = bsn;</span>
        }
<span class="nc bnc" id="L736" title="All 2 branches missed.">        if (bsn == ABSENT_BASE_SOURCE_NAME) {</span>
<span class="nc" id="L737">            throw new AbsentInformationException();</span>
        }
<span class="nc" id="L739">        return bsn;</span>
    }

    String baseSourcePath() throws AbsentInformationException {
<span class="nc" id="L743">        String bsp = baseSourcePath;</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if (bsp == null) {</span>
<span class="nc" id="L745">            bsp = baseSourceDir() + baseSourceName();</span>
<span class="nc" id="L746">            baseSourcePath = bsp;</span>
        }
<span class="nc" id="L748">        return bsp;</span>
    }

    String baseSourceDir() {
<span class="nc bnc" id="L752" title="All 2 branches missed.">        if (baseSourceDir == null) {</span>
<span class="nc" id="L753">            String typeName = name();</span>
<span class="nc" id="L754">            StringBuffer sb = new StringBuffer(typeName.length() + 10);</span>
<span class="nc" id="L755">            int index = 0;</span>
            int nextIndex;

<span class="nc bnc" id="L758" title="All 2 branches missed.">            while ((nextIndex = typeName.indexOf('.', index)) &gt; 0) {</span>
<span class="nc" id="L759">                sb.append(typeName.substring(index, nextIndex));</span>
<span class="nc" id="L760">                sb.append(java.io.File.separatorChar);</span>
<span class="nc" id="L761">                index = nextIndex + 1;</span>
            }
<span class="nc" id="L763">            baseSourceDir = sb.toString();</span>
        }
<span class="nc" id="L765">        return baseSourceDir;</span>
    }

    public String sourceDebugExtension()
                           throws AbsentInformationException {
<span class="nc bnc" id="L770" title="All 2 branches missed.">        if (!vm.canGetSourceDebugExtension()) {</span>
<span class="nc" id="L771">            throw new UnsupportedOperationException();</span>
        }
<span class="nc" id="L773">        SDE sde = sourceDebugExtensionInfo();</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">        if (sde == NO_SDE_INFO_MARK) {</span>
<span class="nc" id="L775">            throw new AbsentInformationException();</span>
        }
<span class="nc" id="L777">        return sde.sourceDebugExtension;</span>
    }

    private SDE sourceDebugExtensionInfo() {
<span class="nc bnc" id="L781" title="All 2 branches missed.">        if (!vm.canGetSourceDebugExtension()) {</span>
<span class="nc" id="L782">            return NO_SDE_INFO_MARK;</span>
        }
<span class="nc bnc" id="L784" title="All 2 branches missed.">        SDE sde = (sdeRef == null) ?  null : sdeRef.get();</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">        if (sde == null) {</span>
<span class="nc" id="L786">            String extension = null;</span>
            try {
<span class="nc" id="L788">                extension = JDWP.ReferenceType.SourceDebugExtension.</span>
<span class="nc" id="L789">                    process(vm, this).extension;</span>
<span class="nc" id="L790">            } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">                if (exc.errorCode() != JDWP.Error.ABSENT_INFORMATION) {</span>
<span class="nc" id="L792">                    sdeRef = new SoftReference&lt;SDE&gt;(NO_SDE_INFO_MARK);</span>
<span class="nc" id="L793">                    throw exc.toJDIException();</span>
                }
<span class="nc" id="L795">            }</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">            if (extension == null) {</span>
<span class="nc" id="L797">                sde = NO_SDE_INFO_MARK;</span>
            } else {
<span class="nc" id="L799">                sde = new SDE(extension);</span>
            }
<span class="nc" id="L801">            sdeRef = new SoftReference&lt;SDE&gt;(sde);</span>
        }
<span class="nc" id="L803">        return sde;</span>
    }

    public List&lt;String&gt; availableStrata() {
<span class="nc" id="L807">        SDE sde = sourceDebugExtensionInfo();</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">        if (sde.isValid()) {</span>
<span class="nc" id="L809">            return sde.availableStrata();</span>
        } else {
<span class="nc" id="L811">            List&lt;String&gt; strata = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L812">            strata.add(SDE.BASE_STRATUM_NAME);</span>
<span class="nc" id="L813">            return strata;</span>
        }
    }

    /**
     * Always returns non-null stratumID
     */
    public String defaultStratum() {
<span class="nc" id="L821">        SDE sdei = sourceDebugExtensionInfo();</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">        if (sdei.isValid()) {</span>
<span class="nc" id="L823">            return sdei.defaultStratumId;</span>
        } else {
<span class="nc" id="L825">            return SDE.BASE_STRATUM_NAME;</span>
        }
    }

    public int modifiers() {
<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (modifiers == -1)</span>
<span class="nc" id="L831">            getModifiers();</span>

<span class="nc" id="L833">        return modifiers;</span>
    }

    public List&lt;Location&gt; allLineLocations()
                            throws AbsentInformationException {
<span class="nc" id="L838">        return allLineLocations(vm.getDefaultStratum(), null);</span>
    }

    public List&lt;Location&gt; allLineLocations(String stratumID, String sourceName)
                            throws AbsentInformationException {
<span class="nc" id="L843">        boolean someAbsent = false; // A method that should have info, didn't</span>
<span class="nc" id="L844">        SDE.Stratum stratum = stratum(stratumID);</span>
<span class="nc" id="L845">        List&lt;Location&gt; list = new ArrayList&lt;Location&gt;();  // location list</span>

<span class="nc bnc" id="L847" title="All 2 branches missed.">        for (Iterator&lt;Method&gt; iter = methods().iterator(); iter.hasNext(); ) {</span>
<span class="nc" id="L848">            MethodImpl method = (MethodImpl)iter.next();</span>
            try {
<span class="nc" id="L850">                list.addAll(</span>
<span class="nc" id="L851">                   method.allLineLocations(stratum, sourceName));</span>
<span class="nc" id="L852">            } catch(AbsentInformationException exc) {</span>
<span class="nc" id="L853">                someAbsent = true;</span>
<span class="nc" id="L854">            }</span>
<span class="nc" id="L855">        }</span>

        // If we retrieved no line info, and at least one of the methods
        // should have had some (as determined by an
        // AbsentInformationException being thrown) then we rethrow
        // the AbsentInformationException.
<span class="nc bnc" id="L861" title="All 4 branches missed.">        if (someAbsent &amp;&amp; list.size() == 0) {</span>
<span class="nc" id="L862">            throw new AbsentInformationException();</span>
        }
<span class="nc" id="L864">        return list;</span>
    }

    public List&lt;Location&gt; locationsOfLine(int lineNumber)
                           throws AbsentInformationException {
<span class="nc" id="L869">        return locationsOfLine(vm.getDefaultStratum(),</span>
                               null,
                               lineNumber);
    }

    public List&lt;Location&gt; locationsOfLine(String stratumID,
                                String sourceName,
                                int lineNumber)
                           throws AbsentInformationException {
        // A method that should have info, didn't
<span class="nc" id="L879">        boolean someAbsent = false;</span>
        // A method that should have info, did
<span class="nc" id="L881">        boolean somePresent = false;</span>
<span class="nc" id="L882">        List&lt;Method&gt; methods = methods();</span>
<span class="nc" id="L883">        SDE.Stratum stratum = stratum(stratumID);</span>

<span class="nc" id="L885">        List&lt;Location&gt; list = new ArrayList&lt;Location&gt;();</span>

<span class="nc" id="L887">        Iterator&lt;Method&gt; iter = methods.iterator();</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">        while(iter.hasNext()) {</span>
<span class="nc" id="L889">            MethodImpl method = (MethodImpl)iter.next();</span>
            // eliminate native and abstract to eliminate
            // false positives
<span class="nc bnc" id="L892" title="All 2 branches missed.">            if (!method.isAbstract() &amp;&amp;</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">                !method.isNative()) {</span>
                try {
<span class="nc" id="L895">                    list.addAll(</span>
<span class="nc" id="L896">                       method.locationsOfLine(stratum,</span>
                                              sourceName,
                                              lineNumber));
<span class="nc" id="L899">                    somePresent = true;</span>
<span class="nc" id="L900">                } catch(AbsentInformationException exc) {</span>
<span class="nc" id="L901">                    someAbsent = true;</span>
<span class="nc" id="L902">                }</span>
            }
<span class="nc" id="L904">        }</span>
<span class="nc bnc" id="L905" title="All 4 branches missed.">        if (someAbsent &amp;&amp; !somePresent) {</span>
<span class="nc" id="L906">            throw new AbsentInformationException();</span>
        }
<span class="nc" id="L908">        return list;</span>
    }

    public List&lt;ObjectReference&gt; instances(long maxInstances) {
<span class="nc bnc" id="L912" title="All 2 branches missed.">        if (!vm.canGetInstanceInfo()) {</span>
<span class="nc" id="L913">            throw new UnsupportedOperationException(</span>
                &quot;target does not support getting instances&quot;);
        }

<span class="nc bnc" id="L917" title="All 2 branches missed.">        if (maxInstances &lt; 0) {</span>
<span class="nc" id="L918">            throw new IllegalArgumentException(&quot;maxInstances is less than zero: &quot;</span>
                                              + maxInstances);
        }
<span class="nc bnc" id="L921" title="All 2 branches missed.">        int intMax = (maxInstances &gt; Integer.MAX_VALUE)?</span>
            Integer.MAX_VALUE: (int)maxInstances;
        // JDWP can't currently handle more than this (in mustang)

        try {
<span class="nc" id="L926">            return Arrays.asList(</span>
                (ObjectReference[])JDWP.ReferenceType.Instances.
<span class="nc" id="L928">                        process(vm, this, intMax).instances);</span>
<span class="nc" id="L929">        } catch (JDWPException exc) {</span>
<span class="nc" id="L930">            throw exc.toJDIException();</span>
        }
    }

    private void getClassFileVersion() {
<span class="nc bnc" id="L935" title="All 2 branches missed.">        if (!vm.canGetClassFileVersion()) {</span>
<span class="nc" id="L936">            throw new UnsupportedOperationException();</span>
        }
        JDWP.ReferenceType.ClassFileVersion classFileVersion;
<span class="nc bnc" id="L939" title="All 2 branches missed.">        if (versionNumberGotten) {</span>
<span class="nc" id="L940">            return;</span>
        } else {
            try {
<span class="nc" id="L943">                classFileVersion = JDWP.ReferenceType.ClassFileVersion.process(vm, this);</span>
<span class="nc" id="L944">            } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">                if (exc.errorCode() == JDWP.Error.ABSENT_INFORMATION) {</span>
<span class="nc" id="L946">                    majorVersion = 0;</span>
<span class="nc" id="L947">                    minorVersion = 0;</span>
<span class="nc" id="L948">                    versionNumberGotten = true;</span>
<span class="nc" id="L949">                    return;</span>
                } else {
<span class="nc" id="L951">                    throw exc.toJDIException();</span>
                }
<span class="nc" id="L953">            }</span>
<span class="nc" id="L954">            majorVersion = classFileVersion.majorVersion;</span>
<span class="nc" id="L955">            minorVersion = classFileVersion.minorVersion;</span>
<span class="nc" id="L956">            versionNumberGotten = true;</span>
        }
<span class="nc" id="L958">    }</span>

    public int majorVersion() {
        try {
<span class="nc" id="L962">            getClassFileVersion();</span>
<span class="nc" id="L963">        } catch (RuntimeException exc) {</span>
<span class="nc" id="L964">            throw exc;</span>
<span class="nc" id="L965">        }</span>
<span class="nc" id="L966">        return majorVersion;</span>
    }

    public int minorVersion() {
        try {
<span class="nc" id="L971">            getClassFileVersion();</span>
<span class="nc" id="L972">        } catch (RuntimeException exc) {</span>
<span class="nc" id="L973">            throw exc;</span>
<span class="nc" id="L974">        }</span>
<span class="nc" id="L975">        return minorVersion;</span>
    }

    private void getConstantPoolInfo() {
        JDWP.ReferenceType.ConstantPool jdwpCPool;
<span class="nc bnc" id="L980" title="All 2 branches missed.">        if (!vm.canGetConstantPool()) {</span>
<span class="nc" id="L981">            throw new UnsupportedOperationException();</span>
        }
<span class="nc bnc" id="L983" title="All 2 branches missed.">        if (constantPoolInfoGotten) {</span>
<span class="nc" id="L984">            return;</span>
        } else {
            try {
<span class="nc" id="L987">                jdwpCPool = JDWP.ReferenceType.ConstantPool.process(vm, this);</span>
<span class="nc" id="L988">            } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">                if (exc.errorCode() == JDWP.Error.ABSENT_INFORMATION) {</span>
<span class="nc" id="L990">                    constanPoolCount = 0;</span>
<span class="nc" id="L991">                    constantPoolBytesRef = null;</span>
<span class="nc" id="L992">                    constantPoolInfoGotten = true;</span>
<span class="nc" id="L993">                    return;</span>
                } else {
<span class="nc" id="L995">                    throw exc.toJDIException();</span>
                }
<span class="nc" id="L997">            }</span>
            byte[] cpbytes;
<span class="nc" id="L999">            constanPoolCount = jdwpCPool.count;</span>
<span class="nc" id="L1000">            cpbytes = jdwpCPool.bytes;</span>
<span class="nc" id="L1001">            constantPoolBytesRef = new SoftReference&lt;byte[]&gt;(cpbytes);</span>
<span class="nc" id="L1002">            constantPoolInfoGotten = true;</span>
        }
<span class="nc" id="L1004">    }</span>

    public int constantPoolCount() {
        try {
<span class="nc" id="L1008">            getConstantPoolInfo();</span>
<span class="nc" id="L1009">        } catch (RuntimeException exc) {</span>
<span class="nc" id="L1010">            throw exc;</span>
<span class="nc" id="L1011">        }</span>
<span class="nc" id="L1012">        return constanPoolCount;</span>
    }

    public byte[] constantPool() {
        try {
<span class="nc" id="L1017">            getConstantPoolInfo();</span>
<span class="nc" id="L1018">        } catch (RuntimeException exc) {</span>
<span class="nc" id="L1019">            throw exc;</span>
<span class="nc" id="L1020">        }</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (constantPoolBytesRef != null) {</span>
<span class="nc" id="L1022">            byte[] cpbytes = constantPoolBytesRef.get();</span>
            /*
             * Arrays are always modifiable, so it is a little unsafe
             * to return the cached bytecodes directly; instead, we
             * make a clone at the cost of using more memory.
             */
<span class="nc" id="L1028">            return cpbytes.clone();</span>
        } else {
<span class="nc" id="L1030">            return null;</span>
        }
    }

    // Does not need synchronization, since worst-case
    // static info is fetched twice
    void getModifiers() {
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        if (modifiers != -1) {</span>
<span class="nc" id="L1038">            return;</span>
        }
        try {
<span class="nc" id="L1041">            modifiers = JDWP.ReferenceType.Modifiers.</span>
<span class="nc" id="L1042">                                  process(vm, this).modBits;</span>
<span class="nc" id="L1043">        } catch (JDWPException exc) {</span>
<span class="nc" id="L1044">            throw exc.toJDIException();</span>
<span class="nc" id="L1045">        }</span>
<span class="nc" id="L1046">    }</span>

    void decodeStatus(int status) {
<span class="nc" id="L1049">        this.status = status;</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">        if ((status &amp; JDWP.ClassStatus.PREPARED) != 0) {</span>
<span class="nc" id="L1051">            isPrepared = true;</span>
        }
<span class="nc" id="L1053">    }</span>

    void updateStatus() {
        try {
<span class="nc" id="L1057">            decodeStatus(JDWP.ReferenceType.Status.process(vm, this).status);</span>
<span class="nc" id="L1058">        } catch (JDWPException exc) {</span>
<span class="nc" id="L1059">            throw exc.toJDIException();</span>
<span class="nc" id="L1060">        }</span>
<span class="nc" id="L1061">    }</span>

    void markPrepared() {
<span class="nc" id="L1064">        isPrepared = true;</span>
<span class="nc" id="L1065">    }</span>

    long ref() {
<span class="nc" id="L1068">        return ref;</span>
    }

    int indexOf(Method method) {
        // Make sure they're all here - the obsolete method
        // won't be found and so will have index -1
<span class="nc" id="L1074">        return methods().indexOf(method);</span>
    }

    int indexOf(Field field) {
        // Make sure they're all here
<span class="nc" id="L1079">        return fields().indexOf(field);</span>
    }

    /*
     * Return true if an instance of this type
     * can be assigned to a variable of the given type
     */
    abstract boolean isAssignableTo(ReferenceType type);

    boolean isAssignableFrom(ReferenceType type) {
<span class="nc" id="L1089">        return ((ReferenceTypeImpl)type).isAssignableTo(this);</span>
    }

    boolean isAssignableFrom(ObjectReference object) {
<span class="nc bnc" id="L1093" title="All 2 branches missed.">        return object == null ||</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">               isAssignableFrom(object.referenceType());</span>
    }

    void setStatus(int status) {
<span class="nc" id="L1098">        decodeStatus(status);</span>
<span class="nc" id="L1099">    }</span>

    void setSignature(String signature) {
<span class="nc" id="L1102">        this.signature = signature;</span>
<span class="nc" id="L1103">    }</span>

    void setGenericSignature(String signature) {
<span class="nc bnc" id="L1106" title="All 4 branches missed.">        if (signature != null &amp;&amp; signature.length() == 0) {</span>
<span class="nc" id="L1107">            this.genericSignature = null;</span>
        } else{
<span class="nc" id="L1109">            this.genericSignature = signature;</span>
        }
<span class="nc" id="L1111">        this.genericSignatureGotten = true;</span>
<span class="nc" id="L1112">    }</span>

    private static boolean isPrimitiveArray(String signature) {
<span class="nc" id="L1115">        int i = signature.lastIndexOf('[');</span>
        /*
         * TO DO: Centralize JNI signature knowledge.
         *
         * Ref:
         *  jdk1.4/doc/guide/jpda/jdi/com/sun/jdi/doc-files/signature.html
         */
        boolean isPA;
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        if (i &lt; 0) {</span>
<span class="nc" id="L1124">            isPA = false;</span>
        } else {
<span class="nc" id="L1126">            char c = signature.charAt(i + 1);</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">            isPA = (c != 'L');</span>
        }
<span class="nc" id="L1129">        return isPA;</span>
    }

    Type findType(String signature) throws ClassNotLoadedException {
        Type type;
<span class="nc bnc" id="L1134" title="All 2 branches missed.">        if (signature.length() == 1) {</span>
            /* OTI FIX: Must be a primitive type or the void type */
<span class="nc" id="L1136">            char sig = signature.charAt(0);</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">            if (sig == 'V') {</span>
<span class="nc" id="L1138">                type = vm.theVoidType();</span>
            } else {
<span class="nc" id="L1140">                type = vm.primitiveTypeMirror((byte)sig);</span>
            }
<span class="nc" id="L1142">        } else {</span>
            // Must be a reference type.
<span class="nc" id="L1144">            ClassLoaderReferenceImpl loader =</span>
<span class="nc" id="L1145">                       (ClassLoaderReferenceImpl)classLoader();</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">            if ((loader == null) ||</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">                (isPrimitiveArray(signature)) //Work around 4450091</span>
                ) {
                // Caller wants type of boot class field
<span class="nc" id="L1150">                type = vm.findBootType(signature);</span>
            } else {
                // Caller wants type of non-boot class field
<span class="nc" id="L1153">                type = loader.findType(signature);</span>
            }
        }
<span class="nc" id="L1156">        return type;</span>
    }

    String loaderString() {
<span class="nc bnc" id="L1160" title="All 2 branches missed.">        if (classLoader() != null) {</span>
<span class="nc" id="L1161">            return &quot;loaded by &quot; + classLoader().toString();</span>
        } else {
<span class="nc" id="L1163">            return &quot;no class loader&quot;;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>