<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ArrayTypeImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.tools.jdi</a> &gt; <span class="el_source">ArrayTypeImpl.java</span></div><h1>ArrayTypeImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import com.sun.jdi.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;

public class ArrayTypeImpl extends ReferenceTypeImpl
    implements ArrayType
{
    protected ArrayTypeImpl(VirtualMachine aVm, long aRef) {
<span class="nc" id="L39">        super(aVm, aRef);</span>
<span class="nc" id="L40">    }</span>

    public ArrayReference newInstance(int length) {
        try {
<span class="nc" id="L44">            return (ArrayReference)JDWP.ArrayType.NewInstance.</span>
<span class="nc" id="L45">                                       process(vm, this, length).newArray;</span>
<span class="nc" id="L46">        } catch (JDWPException exc) {</span>
<span class="nc" id="L47">            throw exc.toJDIException();</span>
        }
    }

    public String componentSignature() {
<span class="nc" id="L52">        return signature().substring(1); // Just skip the leading '['</span>
    }

    public String componentTypeName() {
<span class="nc" id="L56">        JNITypeParser parser = new JNITypeParser(componentSignature());</span>
<span class="nc" id="L57">        return parser.typeName();</span>
    }

    Type type() throws ClassNotLoadedException {
<span class="nc" id="L61">        return findType(componentSignature());</span>
    }

    void addVisibleMethods(Map&lt;String, Method&gt; map) {
        // arrays don't have methods
<span class="nc" id="L66">    }</span>

    public List&lt;Method&gt; allMethods() {
<span class="nc" id="L69">        return new ArrayList&lt;Method&gt;(0);   // arrays don't have methods</span>
    }

    /*
     * Find the type object, if any, of a component type of this array.
     * The component type does not have to be immediate; e.g. this method
     * can be used to find the component JDK of JDK[][]. This method takes
     * advantage of the property that an array and its component must have
     * the same class loader. Since array set operations don't have an
     * implicit enclosing type like field and variable set operations,
     * this method is sometimes needed for proper type checking.
     */
    Type findComponentType(String signature) throws ClassNotLoadedException {
<span class="nc" id="L82">        byte tag = (byte)signature.charAt(0);</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (PacketStream.isObjectTag(tag)) {</span>
            // It's a reference type
<span class="nc" id="L85">            JNITypeParser parser = new JNITypeParser(componentSignature());</span>
<span class="nc" id="L86">            List&lt;ReferenceType&gt; list = vm.classesByName(parser.typeName());</span>
<span class="nc" id="L87">            Iterator&lt;ReferenceType&gt; iter = list.iterator();</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L89">                ReferenceType type = iter.next();</span>
<span class="nc" id="L90">                ClassLoaderReference cl = type.classLoader();</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">                if ((cl == null)?</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">                         (classLoader() == null) :</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">                         (cl.equals(classLoader()))) {</span>
<span class="nc" id="L94">                    return type;</span>
                }
<span class="nc" id="L96">            }</span>
            // Component class has not yet been loaded
<span class="nc" id="L98">            throw new ClassNotLoadedException(componentTypeName());</span>
        } else {
            // It's a primitive type
<span class="nc" id="L101">            return vm.primitiveTypeMirror(tag);</span>
        }
    }

    public Type componentType() throws ClassNotLoadedException {
<span class="nc" id="L106">        return findComponentType(componentSignature());</span>
    }

    static boolean isComponentAssignable(Type destination, Type source) {
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (source instanceof PrimitiveType) {</span>
            // Assignment of primitive arrays requires identical
            // component types.
<span class="nc" id="L113">            return source.equals(destination);</span>
        } else {
<span class="nc bnc" id="L115" title="All 2 branches missed.">            if (destination instanceof PrimitiveType) {</span>
<span class="nc" id="L116">                return false;</span>
            }

<span class="nc" id="L119">            ReferenceTypeImpl refSource = (ReferenceTypeImpl)source;</span>
<span class="nc" id="L120">            ReferenceTypeImpl refDestination = (ReferenceTypeImpl)destination;</span>
            // Assignment of object arrays requires availability
            // of widening conversion of component types
<span class="nc" id="L123">            return refSource.isAssignableTo(refDestination);</span>
        }
    }

    /*
     * Return true if an instance of the  given reference type
     * can be assigned to a variable of this type
     */
    boolean isAssignableTo(ReferenceType destType) {
<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (destType instanceof ArrayType) {</span>
            try {
<span class="nc" id="L134">                Type destComponentType = ((ArrayType)destType).componentType();</span>
<span class="nc" id="L135">                return isComponentAssignable(destComponentType, componentType());</span>
<span class="nc" id="L136">            } catch (ClassNotLoadedException e) {</span>
                // One or both component types has not yet been
                // loaded =&gt; can't assign
<span class="nc" id="L139">                return false;</span>
            }
<span class="nc bnc" id="L141" title="All 2 branches missed.">        } else if (destType instanceof InterfaceType) {</span>
            // Only valid InterfaceType assignee is Cloneable
<span class="nc" id="L143">            return destType.name().equals(&quot;java.lang.Cloneable&quot;);</span>
        } else {
            // Only valid ClassType assignee is Object
<span class="nc" id="L146">            return destType.name().equals(&quot;java.lang.Object&quot;);</span>
        }
    }

    List&lt;ReferenceType&gt; inheritedTypes() {
<span class="nc" id="L151">        return new ArrayList&lt;ReferenceType&gt;(0);</span>
    }

    void getModifiers() {
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (modifiers != -1) {</span>
<span class="nc" id="L156">            return;</span>
        }
        /*
         * For object arrays, the return values for Interface
         * Accessible.isPrivate(), Accessible.isProtected(),
         * etc... are the same as would be returned for the
         * component type.  Fetch the modifier bits from the
         * component type and use those.
         *
         * For primitive arrays, the modifiers are always
         *   VMModifiers.FINAL | VMModifiers.PUBLIC
         *
         * Reference com.sun.jdi.Accessible.java.
         */
        try {
<span class="nc" id="L171">            Type t = componentType();</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">            if (t instanceof PrimitiveType) {</span>
<span class="nc" id="L173">                modifiers = VMModifiers.FINAL | VMModifiers.PUBLIC;</span>
            } else {
<span class="nc" id="L175">                ReferenceType rt = (ReferenceType)t;</span>
<span class="nc" id="L176">                modifiers = rt.modifiers();</span>
            }
<span class="nc" id="L178">        } catch (ClassNotLoadedException cnle) {</span>
<span class="nc" id="L179">            cnle.printStackTrace();</span>
<span class="nc" id="L180">        }</span>
<span class="nc" id="L181">    }</span>

    public String toString() {
<span class="nc" id="L184">       return &quot;array class &quot; + name() + &quot; (&quot; + loaderString() + &quot;)&quot;;</span>
    }

    /*
     * Save a pointless trip over the wire for these methods
     * which have undefined results for arrays.
     */
<span class="nc" id="L191">    public boolean isPrepared() { return true; }</span>
<span class="nc" id="L192">    public boolean isVerified() { return true; }</span>
<span class="nc" id="L193">    public boolean isInitialized() { return true; }</span>
<span class="nc" id="L194">    public boolean failedToInitialize() { return false; }</span>
<span class="nc" id="L195">    public boolean isAbstract() { return false; }</span>

    /*
     * Defined always to be true for arrays
     */
<span class="nc" id="L200">    public boolean isFinal() { return true; }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>