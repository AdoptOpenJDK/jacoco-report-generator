<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MethodImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.tools.jdi</a> &gt; <span class="el_source">MethodImpl.java</span></div><h1>MethodImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import com.sun.jdi.*;

import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.Comparator;

public abstract class MethodImpl extends TypeComponentImpl
    implements Method {
    private JNITypeParser signatureParser;
    abstract int argSlotCount() throws AbsentInformationException;

    abstract List&lt;Location&gt; allLineLocations(SDE.Stratum stratum,
                                   String sourceName)
                           throws AbsentInformationException;

    abstract List&lt;Location&gt; locationsOfLine(SDE.Stratum stratum,
                                  String sourceName,
                                  int lineNumber)
                           throws AbsentInformationException;

    MethodImpl(VirtualMachine vm, ReferenceTypeImpl declaringType,
               long ref,
               String name, String signature,
               String genericSignature, int modifiers) {
<span class="nc" id="L53">        super(vm, declaringType, ref, name, signature,</span>
              genericSignature, modifiers);
<span class="nc" id="L55">        signatureParser = new JNITypeParser(signature);</span>
<span class="nc" id="L56">    }</span>

    static MethodImpl createMethodImpl(VirtualMachine vm,
                                       ReferenceTypeImpl declaringType,
                                       long ref,
                                       String name,
                                       String signature,
                                       String genericSignature,
                                       int modifiers) {
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if ((modifiers &amp;</span>
             (VMModifiers.NATIVE | VMModifiers.ABSTRACT)) != 0) {
<span class="nc" id="L67">            return new NonConcreteMethodImpl(vm, declaringType, ref,</span>
                                             name, signature,
                                             genericSignature,
                                             modifiers);
        } else {
<span class="nc" id="L72">            return new ConcreteMethodImpl(vm, declaringType, ref,</span>
                                          name, signature,
                                          genericSignature,
                                          modifiers);
        }
    }

    public boolean equals(Object obj) {
<span class="nc bnc" id="L80" title="All 4 branches missed.">        if ((obj != null) &amp;&amp; (obj instanceof MethodImpl)) {</span>
<span class="nc" id="L81">            MethodImpl other = (MethodImpl)obj;</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">            return (declaringType().equals(other.declaringType())) &amp;&amp;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">                   (ref() == other.ref()) &amp;&amp;</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">                   super.equals(obj);</span>
        } else {
<span class="nc" id="L86">            return false;</span>
        }
    }

    public int hashCode() {
<span class="nc" id="L91">        return (int)ref();</span>
    }

    public final List&lt;Location&gt; allLineLocations()
                           throws AbsentInformationException {
<span class="nc" id="L96">        return allLineLocations(vm.getDefaultStratum(), null);</span>
    }

    public List&lt;Location&gt; allLineLocations(String stratumID,
                                 String sourceName)
                           throws AbsentInformationException {
<span class="nc" id="L102">        return allLineLocations(declaringType.stratum(stratumID),</span>
                                sourceName);
    }

    public final List&lt;Location&gt; locationsOfLine(int lineNumber)
                           throws AbsentInformationException {
<span class="nc" id="L108">        return locationsOfLine(vm.getDefaultStratum(),</span>
                               null, lineNumber);
    }

    public List&lt;Location&gt; locationsOfLine(String stratumID,
                                String sourceName,
                                int lineNumber)
                           throws AbsentInformationException {
<span class="nc" id="L116">        return locationsOfLine(declaringType.stratum(stratumID),</span>
                               sourceName, lineNumber);
    }

    LineInfo codeIndexToLineInfo(SDE.Stratum stratum,
                                 long codeIndex) {
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (stratum.isJava()) {</span>
<span class="nc" id="L123">            return new BaseLineInfo(-1, declaringType);</span>
        } else {
<span class="nc" id="L125">            return new StratumLineInfo(stratum.id(), -1,</span>
                                       null, null);
        }
    }

    /**
     * @return a text representation of the declared return type
     * of this method.
     */
    public String returnTypeName() {
<span class="nc" id="L135">        return signatureParser.typeName();</span>
    }

    private String returnSignature() {
<span class="nc" id="L139">        return signatureParser.signature();</span>
    }

    public Type returnType() throws ClassNotLoadedException {
<span class="nc" id="L143">        return findType(returnSignature());</span>
    }

    public Type findType(String signature) throws ClassNotLoadedException {
<span class="nc" id="L147">        ReferenceTypeImpl enclosing = (ReferenceTypeImpl)declaringType();</span>
<span class="nc" id="L148">        return enclosing.findType(signature);</span>
    }

    public List&lt;String&gt; argumentTypeNames() {
<span class="nc" id="L152">        return signatureParser.argumentTypeNames();</span>
    }

    public List&lt;String&gt; argumentSignatures() {
<span class="nc" id="L156">        return signatureParser.argumentSignatures();</span>
    }

    Type argumentType(int index) throws ClassNotLoadedException {
<span class="nc" id="L160">        ReferenceTypeImpl enclosing = (ReferenceTypeImpl)declaringType();</span>
<span class="nc" id="L161">        String signature = argumentSignatures().get(index);</span>
<span class="nc" id="L162">        return enclosing.findType(signature);</span>
    }

    public List&lt;Type&gt; argumentTypes() throws ClassNotLoadedException {
<span class="nc" id="L166">        int size = argumentSignatures().size();</span>
<span class="nc" id="L167">        ArrayList&lt;Type&gt; types = new ArrayList&lt;Type&gt;(size);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L169">            Type type = argumentType(i);</span>
<span class="nc" id="L170">            types.add(type);</span>
        }

<span class="nc" id="L173">        return types;</span>
    }

    public int compareTo(Method method) {
<span class="nc" id="L177">        ReferenceTypeImpl declaringType = (ReferenceTypeImpl)declaringType();</span>
<span class="nc" id="L178">        int rc = declaringType.compareTo(method.declaringType());</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (rc == 0) {</span>
<span class="nc" id="L180">            rc = declaringType.indexOf(this) -</span>
<span class="nc" id="L181">                    declaringType.indexOf(method);</span>
        }
<span class="nc" id="L183">        return rc;</span>
    }

    public boolean isAbstract() {
<span class="nc" id="L187">        return isModifierSet(VMModifiers.ABSTRACT);</span>
    }

    public boolean isSynchronized() {
<span class="nc" id="L191">        return isModifierSet(VMModifiers.SYNCHRONIZED);</span>
    }

    public boolean isNative() {
<span class="nc" id="L195">        return isModifierSet(VMModifiers.NATIVE);</span>
    }

    public boolean isVarArgs() {
<span class="nc" id="L199">        return isModifierSet(VMModifiers.VARARGS);</span>
    }

    public boolean isBridge() {
<span class="nc" id="L203">        return isModifierSet(VMModifiers.BRIDGE);</span>
    }

    public boolean isConstructor() {
<span class="nc" id="L207">        return name().equals(&quot;&lt;init&gt;&quot;);</span>
    }

    public boolean isStaticInitializer() {
<span class="nc" id="L211">        return name().equals(&quot;&lt;clinit&gt;&quot;);</span>
    }

    public boolean isObsolete() {
        try {
<span class="nc" id="L216">            return JDWP.Method.IsObsolete.process(vm,</span>
                                    declaringType, ref).isObsolete;
<span class="nc" id="L218">        } catch (JDWPException exc) {</span>
<span class="nc" id="L219">            throw exc.toJDIException();</span>
        }
    }


    /*
     * A container class for the return value to allow
     * proper type-checking.
     */
    class ReturnContainer implements ValueContainer {
<span class="nc" id="L229">        ReturnContainer() {</span>
<span class="nc" id="L230">        }</span>
        public Type type() throws ClassNotLoadedException {
<span class="nc" id="L232">            return returnType();</span>
        }
        public String typeName(){
<span class="nc" id="L235">            return returnTypeName();</span>
        }
        public String signature() {
<span class="nc" id="L238">            return returnSignature(); //type().signature();</span>
        }
        public Type findType(String signature) throws ClassNotLoadedException {
<span class="nc" id="L241">            return MethodImpl.this.findType(signature);</span>
        }
    }
<span class="nc" id="L244">    ReturnContainer retValContainer = null;</span>
    ReturnContainer getReturnValueContainer() {
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (retValContainer == null) {</span>
<span class="nc" id="L247">            retValContainer = new ReturnContainer();</span>
        }
<span class="nc" id="L249">        return retValContainer;</span>
    }

    /*
     * A container class for the argument to allow
     * proper type-checking.
     */
    class ArgumentContainer implements ValueContainer {
        int index;

<span class="nc" id="L259">        ArgumentContainer(int index) {</span>
<span class="nc" id="L260">            this.index = index;</span>
<span class="nc" id="L261">        }</span>
        public Type type() throws ClassNotLoadedException {
<span class="nc" id="L263">            return argumentType(index);</span>
        }
        public String typeName(){
<span class="nc" id="L266">            return argumentTypeNames().get(index);</span>
        }
        public String signature() {
<span class="nc" id="L269">            return argumentSignatures().get(index);</span>
        }
        public Type findType(String signature) throws ClassNotLoadedException {
<span class="nc" id="L272">            return MethodImpl.this.findType(signature);</span>
        }
    }

    /*
     * This is a var args method.  Thus, its last param is an
     * array. If the method has n params, then:
     * 1.  If there are n args and the last is the same type as the type of
     *     the last param, do nothing.  IE, a String[]
     *     can be passed to a String...
     * 2.  If there are &gt;= n arguments and for each arg whose number is &gt;= n,
     *     the arg type is 'compatible' with the component type of
     *     the last param, then do
     *     - create an array of the type of the last param
     *     - put the n, ... args into this array.
     *       We might have to do conversions here.
     *     - put this array into arguments(n)
     *     - delete arguments(n+1), ...
     * NOTE that this might modify the input list.
     */
    void handleVarArgs(List&lt;Value&gt; arguments)
        throws ClassNotLoadedException, InvalidTypeException {
<span class="nc" id="L294">        List&lt;Type&gt; paramTypes = this.argumentTypes();</span>
<span class="nc" id="L295">        ArrayType lastParamType = (ArrayType)paramTypes.get(paramTypes.size() - 1);</span>
<span class="nc" id="L296">        Type componentType = lastParamType.componentType();</span>
<span class="nc" id="L297">        int argCount = arguments.size();</span>
<span class="nc" id="L298">        int paramCount = paramTypes.size();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (argCount &lt; paramCount - 1) {</span>
            // Error; will be caught later.
<span class="nc" id="L301">            return;</span>
        }
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (argCount == paramCount - 1) {</span>
            // It is ok to pass 0 args to the var arg.
            // We have to gen a 0 length array.
<span class="nc" id="L306">            ArrayReference argArray = lastParamType.newInstance(0);</span>
<span class="nc" id="L307">            arguments.add(argArray);</span>
<span class="nc" id="L308">            return;</span>
        }
<span class="nc" id="L310">        Value nthArgValue = arguments.get(paramCount - 1);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (nthArgValue == null) {</span>
<span class="nc" id="L312">            return;</span>
        }
<span class="nc" id="L314">        Type nthArgType = nthArgValue.type();</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">        if (nthArgType instanceof ArrayTypeImpl) {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (argCount == paramCount &amp;&amp;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                ((ArrayTypeImpl)nthArgType).isAssignableTo(lastParamType)) {</span>
                /*
                 * This is case 1.  A compatible array is being passed to the
                 * var args array param.  We don't have to do anything.
                 */
<span class="nc" id="L322">                return;</span>
            }
        }

        /*
         * Case 2.  We have to verify that the n, n+1, ... args are compatible
         * with componentType, and do conversions if necessary and create
         * an array of componentType to hold these possibly converted values.
         */
<span class="nc" id="L331">        int count = argCount - paramCount + 1;</span>
<span class="nc" id="L332">        ArrayReference argArray = lastParamType.newInstance(count);</span>

        /*
         * This will copy arguments(paramCount - 1) ... to argArray(0) ...
         * doing whatever conversions are needed!  It will throw an
         * exception if an incompatible arg is encountered
         */
<span class="nc" id="L339">        argArray.setValues(0, arguments, paramCount - 1, count);</span>
<span class="nc" id="L340">        arguments.set(paramCount - 1, argArray);</span>

        /*
         * Remove the excess args
         */
<span class="nc bnc" id="L345" title="All 2 branches missed.">        for (int ii = paramCount; ii &lt; argCount; ii++) {</span>
<span class="nc" id="L346">            arguments.remove(paramCount);</span>
        }
<span class="nc" id="L348">        return;</span>
    }

    /*
     * The output list will be different than the input list.
     */
    List&lt;Value&gt; validateAndPrepareArgumentsForInvoke(List&lt;? extends Value&gt; origArguments)
                         throws ClassNotLoadedException, InvalidTypeException {

<span class="nc" id="L357">        List&lt;Value&gt; arguments = new ArrayList&lt;Value&gt;(origArguments);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">        if (isVarArgs()) {</span>
<span class="nc" id="L359">            handleVarArgs(arguments);</span>
        }

<span class="nc" id="L362">        int argSize = arguments.size();</span>

<span class="nc" id="L364">        JNITypeParser parser = new JNITypeParser(signature());</span>
<span class="nc" id="L365">        List&lt;String&gt; signatures = parser.argumentSignatures();</span>

<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (signatures.size() != argSize) {</span>
<span class="nc" id="L368">            throw new IllegalArgumentException(&quot;Invalid argument count: expected &quot; +</span>
<span class="nc" id="L369">                                               signatures.size() + &quot;, received &quot; +</span>
<span class="nc" id="L370">                                               arguments.size());</span>
        }

<span class="nc bnc" id="L373" title="All 2 branches missed.">        for (int i = 0; i &lt; argSize; i++) {</span>
<span class="nc" id="L374">            Value value = arguments.get(i);</span>
<span class="nc" id="L375">            value = ValueImpl.prepareForAssignment(value,</span>
                                                   new ArgumentContainer(i));
<span class="nc" id="L377">            arguments.set(i, value);</span>
        }
<span class="nc" id="L379">        return arguments;</span>
    }

    public String toString() {
<span class="nc" id="L383">        StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L384">        sb.append(declaringType().name());</span>
<span class="nc" id="L385">        sb.append(&quot;.&quot;);</span>
<span class="nc" id="L386">        sb.append(name());</span>
<span class="nc" id="L387">        sb.append(&quot;(&quot;);</span>
<span class="nc" id="L388">        boolean first = true;</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        for (String name : argumentTypeNames()) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (!first) {</span>
<span class="nc" id="L391">                sb.append(&quot;, &quot;);</span>
            }
<span class="nc" id="L393">            sb.append(name);</span>
<span class="nc" id="L394">            first = false;</span>
<span class="nc" id="L395">        }</span>
<span class="nc" id="L396">        sb.append(&quot;)&quot;);</span>
<span class="nc" id="L397">        return sb.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>