<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>VMState.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.tools.jdi</a> &gt; <span class="el_source">VMState.java</span></div><h1>VMState.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import com.sun.jdi.*;

import java.lang.ref.WeakReference;
import java.util.*;

class VMState {
    private final VirtualMachineImpl vm;

    // Listeners
<span class="nc" id="L37">    private final List&lt;WeakReference&lt;VMListener&gt;&gt; listeners = new ArrayList&lt;WeakReference&lt;VMListener&gt;&gt;(); // synchronized (this)</span>
<span class="nc" id="L38">    private boolean notifyingListeners = false;  // synchronized (this)</span>

    /*
     * Certain information can be cached only when the entire VM is
     * suspended and there are no pending resumes. The fields below
     * are used to track whether there are pending resumes. (There
     * is an assumption that JDWP command ids are increasing over time.)
     */
<span class="nc" id="L46">    private int lastCompletedCommandId = 0;   // synchronized (this)</span>
<span class="nc" id="L47">    private int lastResumeCommandId = 0;      // synchronized (this)</span>

    // This is cached only while the VM is suspended
<span class="nc" id="L50">    private static class Cache {</span>
<span class="nc" id="L51">        List&lt;ThreadGroupReference&gt; groups = null;  // cached Top Level ThreadGroups</span>
<span class="nc" id="L52">        List&lt;ThreadReference&gt; threads = null; // cached Threads</span>
    }

<span class="nc" id="L55">    private Cache cache = null;               // synchronized (this)</span>
<span class="nc" id="L56">    private static final Cache markerCache = new Cache();</span>

    private void disableCache() {
<span class="nc" id="L59">        synchronized (this) {</span>
<span class="nc" id="L60">            cache = null;</span>
<span class="nc" id="L61">        }</span>
<span class="nc" id="L62">    }</span>

    private void enableCache() {
<span class="nc" id="L65">        synchronized (this) {</span>
<span class="nc" id="L66">            cache = markerCache;</span>
<span class="nc" id="L67">        }</span>
<span class="nc" id="L68">    }</span>

    private Cache getCache() {
<span class="nc" id="L71">        synchronized (this) {</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">            if (cache == markerCache) {</span>
<span class="nc" id="L73">                cache = new Cache();</span>
            }
<span class="nc" id="L75">            return cache;</span>
<span class="nc" id="L76">        }</span>
    }

<span class="nc" id="L79">    VMState(VirtualMachineImpl vm) {</span>
<span class="nc" id="L80">        this.vm = vm;</span>
<span class="nc" id="L81">    }</span>

    /**
     * Is the VM currently suspended, for the purpose of caching?
     * Must be called synchronized on vm.state()
     */
    boolean isSuspended() {
<span class="nc bnc" id="L88" title="All 2 branches missed.">        return cache != null;</span>
    }

    /*
     * A JDWP command has been completed (reply has been received).
     * Update data that tracks pending resume commands.
     */
    synchronized void notifyCommandComplete(int id) {
<span class="nc" id="L96">        lastCompletedCommandId = id;</span>
<span class="nc" id="L97">    }</span>

    synchronized void freeze() {
<span class="nc bnc" id="L100" title="All 4 branches missed.">        if (cache == null &amp;&amp; (lastCompletedCommandId &gt;= lastResumeCommandId)) {</span>
            /*
             * No pending resumes to worry about. The VM is suspended
             * and additional state can be cached. Notify all
             * interested listeners.
             */
<span class="nc" id="L106">            processVMAction(new VMAction(vm, VMAction.VM_SUSPENDED));</span>
<span class="nc" id="L107">            enableCache();</span>
        }
<span class="nc" id="L109">    }</span>

    synchronized PacketStream thawCommand(CommandSender sender) {
<span class="nc" id="L112">        PacketStream stream = sender.send();</span>
<span class="nc" id="L113">        lastResumeCommandId = stream.id();</span>
<span class="nc" id="L114">        thaw();</span>
<span class="nc" id="L115">        return stream;</span>
    }

    /**
     * All threads are resuming
     */
    void thaw() {
<span class="nc" id="L122">        thaw(null);</span>
<span class="nc" id="L123">    }</span>

    /**
     * Tell listeners to invalidate suspend-sensitive caches.
     * If resumingThread != null, then only that thread is being
     * resumed.
     */
    synchronized void thaw(ThreadReference resumingThread) {
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (cache != null) {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">            if ((vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {</span>
<span class="nc" id="L133">                vm.printTrace(&quot;Clearing VM suspended cache&quot;);</span>
            }
<span class="nc" id="L135">            disableCache();</span>
        }
<span class="nc" id="L137">        processVMAction(new VMAction(vm, resumingThread, VMAction.VM_NOT_SUSPENDED));</span>
<span class="nc" id="L138">    }</span>

    private synchronized void processVMAction(VMAction action) {
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if (!notifyingListeners) {</span>
            // Prevent recursion
<span class="nc" id="L143">            notifyingListeners = true;</span>

<span class="nc" id="L145">            Iterator&lt;WeakReference&lt;VMListener&gt;&gt; iter = listeners.iterator();</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L147">                WeakReference&lt;VMListener&gt; ref = iter.next();</span>
<span class="nc" id="L148">                VMListener listener = ref.get();</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">                if (listener != null) {</span>
<span class="nc" id="L150">                    boolean keep = true;</span>
<span class="nc bnc" id="L151" title="All 3 branches missed.">                    switch (action.id()) {</span>
                        case VMAction.VM_SUSPENDED:
<span class="nc" id="L153">                            keep = listener.vmSuspended(action);</span>
<span class="nc" id="L154">                            break;</span>
                        case VMAction.VM_NOT_SUSPENDED:
<span class="nc" id="L156">                            keep = listener.vmNotSuspended(action);</span>
                            break;
                    }
<span class="nc bnc" id="L159" title="All 2 branches missed.">                    if (!keep) {</span>
<span class="nc" id="L160">                        iter.remove();</span>
                    }
<span class="nc" id="L162">                } else {</span>
                    // Listener is unreachable; clean up
<span class="nc" id="L164">                    iter.remove();</span>
                }
<span class="nc" id="L166">            }</span>

<span class="nc" id="L168">            notifyingListeners = false;</span>
        }
<span class="nc" id="L170">    }</span>

    synchronized void addListener(VMListener listener) {
<span class="nc" id="L173">        listeners.add(new WeakReference&lt;VMListener&gt;(listener));</span>
<span class="nc" id="L174">    }</span>

    synchronized boolean hasListener(VMListener listener) {
<span class="nc" id="L177">        return listeners.contains(listener);</span>
    }

    synchronized void removeListener(VMListener listener) {
<span class="nc" id="L181">        Iterator&lt;WeakReference&lt;VMListener&gt;&gt; iter = listeners.iterator();</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L183">            WeakReference&lt;VMListener&gt; ref = iter.next();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (listener.equals(ref.get())) {</span>
<span class="nc" id="L185">                iter.remove();</span>
<span class="nc" id="L186">                break;</span>
            }
<span class="nc" id="L188">        }</span>
<span class="nc" id="L189">    }</span>

    List&lt;ThreadReference&gt; allThreads() {
<span class="nc" id="L192">        List&lt;ThreadReference&gt; threads = null;</span>
        try {
<span class="nc" id="L194">            Cache local = getCache();</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">            if (local != null) {</span>
                // may be stale when returned, but not provably so
<span class="nc" id="L198">                threads = local.threads;</span>
            }
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (threads == null) {</span>
<span class="nc" id="L201">                threads = Arrays.asList((ThreadReference[])JDWP.VirtualMachine.AllThreads.</span>
<span class="nc" id="L202">                                        process(vm).threads);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                if (local != null) {</span>
<span class="nc" id="L204">                    local.threads = threads;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                    if ((vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {</span>
<span class="nc" id="L206">                        vm.printTrace(&quot;Caching all threads (count = &quot; +</span>
<span class="nc" id="L207">                                      threads.size() + &quot;) while VM suspended&quot;);</span>
                    }
                }
            }
<span class="nc" id="L211">        } catch (JDWPException exc) {</span>
<span class="nc" id="L212">            throw exc.toJDIException();</span>
<span class="nc" id="L213">        }</span>
<span class="nc" id="L214">        return threads;</span>
    }


    List&lt;ThreadGroupReference&gt; topLevelThreadGroups() {
<span class="nc" id="L219">        List&lt;ThreadGroupReference&gt; groups = null;</span>
        try {
<span class="nc" id="L221">            Cache local = getCache();</span>

<span class="nc bnc" id="L223" title="All 2 branches missed.">            if (local != null) {</span>
<span class="nc" id="L224">                groups = local.groups;</span>
            }
<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (groups == null) {</span>
<span class="nc" id="L227">                groups = Arrays.asList(</span>
                                (ThreadGroupReference[])JDWP.VirtualMachine.TopLevelThreadGroups.
<span class="nc" id="L229">                                       process(vm).groups);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">                if (local != null) {</span>
<span class="nc" id="L231">                    local.groups = groups;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                    if ((vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {</span>
<span class="nc" id="L233">                        vm.printTrace(</span>
                          &quot;Caching top level thread groups (count = &quot; +
<span class="nc" id="L235">                          groups.size() + &quot;) while VM suspended&quot;);</span>
                    }
                }
            }
<span class="nc" id="L239">        } catch (JDWPException exc) {</span>
<span class="nc" id="L240">            throw exc.toJDIException();</span>
<span class="nc" id="L241">        }</span>
<span class="nc" id="L242">        return groups;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>