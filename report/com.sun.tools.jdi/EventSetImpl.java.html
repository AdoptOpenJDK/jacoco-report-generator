<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>EventSetImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.tools.jdi</a> &gt; <span class="el_source">EventSetImpl.java</span></div><h1>EventSetImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import com.sun.jdi.*;
import com.sun.jdi.event.*;
import com.sun.jdi.request.*;

import java.util.*;
<span class="nc" id="L33">enum EventDestination {UNKNOWN_EVENT, INTERNAL_EVENT, CLIENT_EVENT};</span>

/*
 * An EventSet is normally created by the transport reader thread when
 * it reads a JDWP Composite command.  The constructor doesn't unpack
 * the events contained in the Composite command and create EventImpls
 * for them because that process might involve calling back into the back-end
 * which should not be done by the transport reader thread.  Instead,
 * the raw bytes of the packet are read and stored in the EventSet.
 * The EventSet is then added to each EventQueue. When an EventSet is
 * removed from an EventQueue, the EventSetImpl.build() method is called.
 * This method reads the packet bytes and creates the actual EventImpl objects.
 * build() also filters out events for our internal handler and puts them in
 * their own EventSet.  This means that the EventImpls that are in the EventSet
 * that is on the queues are all for client requests.
 */
public class EventSetImpl extends ArrayList&lt;Event&gt; implements EventSet {
    private static final long serialVersionUID = -4857338819787924570L;
    private VirtualMachineImpl vm; // we implement Mirror
    private Packet pkt;
    private byte suspendPolicy;
    private EventSetImpl internalEventSet;

    public String toString() {
<span class="nc" id="L57">        String string = &quot;event set, policy:&quot; + suspendPolicy +</span>
<span class="nc" id="L58">                        &quot;, count:&quot; + this.size() + &quot; = {&quot;;</span>
<span class="nc" id="L59">        boolean first = true;</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">        for (Event event : this) {</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">            if (!first) {</span>
<span class="nc" id="L62">                string += &quot;, &quot;;</span>
            }
<span class="nc" id="L64">            string += event.toString();</span>
<span class="nc" id="L65">            first = false;</span>
<span class="nc" id="L66">        }</span>
<span class="nc" id="L67">        string += &quot;}&quot;;</span>
<span class="nc" id="L68">        return string;</span>
    }

    abstract class EventImpl extends MirrorImpl implements Event {

        private final byte eventCmd;
        private final int requestID;
        // This is set only for client requests, not internal requests.
        private final EventRequest request;

        /**
         * Constructor for events.
         */
        protected EventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
<span class="nc" id="L82">                            int requestID) {</span>
<span class="nc" id="L83">            super(EventSetImpl.this.vm);</span>
<span class="nc" id="L84">            this.eventCmd = evt.eventKind();</span>
<span class="nc" id="L85">            this.requestID = requestID;</span>
<span class="nc" id="L86">            EventRequestManagerImpl ermi = EventSetImpl.this.</span>
<span class="nc" id="L87">                vm.eventRequestManagerImpl();</span>
<span class="nc" id="L88">            this.request =  ermi.request(eventCmd, requestID);</span>
<span class="nc" id="L89">        }</span>

        /*
         * Override superclass back to default equality
         */
        public boolean equals(Object obj) {
<span class="nc bnc" id="L95" title="All 2 branches missed.">            return this == obj;</span>
        }

        public int hashCode() {
<span class="nc" id="L99">            return System.identityHashCode(this);</span>
        }

        /**
         * Constructor for VM disconnected events.
         */
<span class="nc" id="L105">        protected EventImpl(byte eventCmd) {</span>
<span class="nc" id="L106">            super(EventSetImpl.this.vm);</span>
<span class="nc" id="L107">            this.eventCmd = eventCmd;</span>
<span class="nc" id="L108">            this.requestID = 0;</span>
<span class="nc" id="L109">            this.request = null;</span>
<span class="nc" id="L110">        }</span>

        public EventRequest request() {
<span class="nc" id="L113">            return request;</span>
        }

        int requestID() {
<span class="nc" id="L117">            return requestID;</span>
        }

        EventDestination destination() {
            /*
             * We need to decide if this event is for
             * 1. an internal request
             * 2. a client request that is no longer available, ie
             *    it has been deleted, or disabled and re-enabled
             *    which gives it a new ID.
             * 3. a current client request that is disabled
             * 4. a current enabled client request.
             *
             * We will filter this set into a set
             * that contains only 1s for our internal queue
             * and a set that contains only 4s for our client queue.
             * If we get an EventSet that contains only 2 and 3
             * then we have to resume it if it is not SUSPEND_NONE
             * because no one else will.
             */
<span class="nc bnc" id="L137" title="All 2 branches missed.">            if (requestID == 0) {</span>
                /* An unsolicited event.  These have traditionally
                 * been treated as client events.
                 */
<span class="nc" id="L141">                return EventDestination.CLIENT_EVENT;</span>
            }

            // Is this an event for a current client request?
<span class="nc bnc" id="L145" title="All 2 branches missed.">            if (request == null) {</span>
                // Nope.  Is it an event for an internal request?
<span class="nc" id="L147">                EventRequestManagerImpl ermi = this.vm.getInternalEventRequestManager();</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (ermi.request(eventCmd, requestID) != null) {</span>
                    // Yep
<span class="nc" id="L150">                    return EventDestination.INTERNAL_EVENT;</span>
                }
<span class="nc" id="L152">                return EventDestination.UNKNOWN_EVENT;</span>
            }

            // We found a client request
<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (request.isEnabled()) {</span>
<span class="nc" id="L157">                return EventDestination.CLIENT_EVENT;</span>
            }
<span class="nc" id="L159">            return EventDestination.UNKNOWN_EVENT;</span>
        }

        abstract String eventName();

        public String toString() {
<span class="nc" id="L165">            return eventName();</span>
        }

    }

    abstract class ThreadedEventImpl extends EventImpl {
        private ThreadReference thread;

        ThreadedEventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
<span class="nc" id="L174">                          int requestID, ThreadReference thread) {</span>
<span class="nc" id="L175">            super(evt, requestID);</span>
<span class="nc" id="L176">            this.thread = thread;</span>
<span class="nc" id="L177">        }</span>

        public ThreadReference thread() {
<span class="nc" id="L180">            return thread;</span>
        }

        public String toString() {
<span class="nc" id="L184">            return eventName() + &quot; in thread &quot; + thread.name();</span>
        }
    }

    abstract class LocatableEventImpl extends ThreadedEventImpl
                                            implements Locatable {
        private Location location;

        LocatableEventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
                           int requestID,
<span class="nc" id="L194">                           ThreadReference thread, Location location) {</span>
<span class="nc" id="L195">            super(evt, requestID, thread);</span>
<span class="nc" id="L196">            this.location = location;</span>
<span class="nc" id="L197">        }</span>

        public Location location() {
<span class="nc" id="L200">            return location;</span>
        }

        /**
         * For MethodEntry and MethodExit
         */
        public Method method() {
<span class="nc" id="L207">            return location.method();</span>
        }

        public String toString() {
<span class="nc" id="L211">            return eventName() + &quot;@&quot; +</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">                   ((location() == null) ? &quot; null&quot; : location().toString()) +</span>
<span class="nc" id="L213">                   &quot; in thread &quot; + thread().name();</span>
        }
    }

    class BreakpointEventImpl extends LocatableEventImpl
                            implements BreakpointEvent {
<span class="nc" id="L219">        BreakpointEventImpl(JDWP.Event.Composite.Events.Breakpoint evt) {</span>
<span class="nc" id="L220">            super(evt, evt.requestID, evt.thread, evt.location);</span>
<span class="nc" id="L221">        }</span>

        String eventName() {
<span class="nc" id="L224">            return &quot;BreakpointEvent&quot;;</span>
        }
    }

    class StepEventImpl extends LocatableEventImpl implements StepEvent {
<span class="nc" id="L229">        StepEventImpl(JDWP.Event.Composite.Events.SingleStep evt) {</span>
<span class="nc" id="L230">            super(evt, evt.requestID, evt.thread, evt.location);</span>
<span class="nc" id="L231">        }</span>

        String eventName() {
<span class="nc" id="L234">            return &quot;StepEvent&quot;;</span>
        }
    }

    class MethodEntryEventImpl extends LocatableEventImpl
                            implements MethodEntryEvent {
<span class="nc" id="L240">        MethodEntryEventImpl(JDWP.Event.Composite.Events.MethodEntry evt) {</span>
<span class="nc" id="L241">            super(evt, evt.requestID, evt.thread, evt.location);</span>
<span class="nc" id="L242">        }</span>

        String eventName() {
<span class="nc" id="L245">            return &quot;MethodEntryEvent&quot;;</span>
        }
    }

    class MethodExitEventImpl extends LocatableEventImpl
                            implements MethodExitEvent {
<span class="nc" id="L251">        private Value returnVal = null;</span>

<span class="nc" id="L253">        MethodExitEventImpl(JDWP.Event.Composite.Events.MethodExit evt) {</span>
<span class="nc" id="L254">            super(evt, evt.requestID, evt.thread, evt.location);</span>
<span class="nc" id="L255">        }</span>

<span class="nc" id="L257">        MethodExitEventImpl(JDWP.Event.Composite.Events.MethodExitWithReturnValue evt) {</span>
<span class="nc" id="L258">            super(evt, evt.requestID, evt.thread, evt.location);</span>
<span class="nc" id="L259">            returnVal = evt.value;</span>
<span class="nc" id="L260">        }</span>

        String eventName() {
<span class="nc" id="L263">            return &quot;MethodExitEvent&quot;;</span>
        }

        public Value returnValue() {
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (!this.vm.canGetMethodReturnValues()) {</span>
<span class="nc" id="L268">                throw new UnsupportedOperationException(</span>
                &quot;target does not support return values in MethodExit events&quot;);
            }
<span class="nc" id="L271">            return returnVal;</span>
        }

    }

    class MonitorContendedEnterEventImpl extends LocatableEventImpl
                            implements MonitorContendedEnterEvent {
<span class="nc" id="L278">        private ObjectReference monitor = null;</span>

<span class="nc" id="L280">        MonitorContendedEnterEventImpl(JDWP.Event.Composite.Events.MonitorContendedEnter evt) {</span>
<span class="nc" id="L281">            super(evt, evt.requestID, evt.thread, evt.location);</span>
<span class="nc" id="L282">            this.monitor = evt.object;</span>
<span class="nc" id="L283">        }</span>

        String eventName() {
<span class="nc" id="L286">            return &quot;MonitorContendedEnter&quot;;</span>
        }

        public ObjectReference  monitor() {
<span class="nc" id="L290">            return monitor;</span>
        };

    }

    class MonitorContendedEnteredEventImpl extends LocatableEventImpl
                            implements MonitorContendedEnteredEvent {
<span class="nc" id="L297">        private ObjectReference monitor = null;</span>

<span class="nc" id="L299">        MonitorContendedEnteredEventImpl(JDWP.Event.Composite.Events.MonitorContendedEntered evt) {</span>
<span class="nc" id="L300">            super(evt, evt.requestID, evt.thread, evt.location);</span>
<span class="nc" id="L301">            this.monitor = evt.object;</span>
<span class="nc" id="L302">        }</span>

        String eventName() {
<span class="nc" id="L305">            return &quot;MonitorContendedEntered&quot;;</span>
        }

        public ObjectReference  monitor() {
<span class="nc" id="L309">            return monitor;</span>
        };

    }

    class MonitorWaitEventImpl extends LocatableEventImpl
                            implements MonitorWaitEvent {
<span class="nc" id="L316">        private ObjectReference monitor = null;</span>
        private long timeout;

<span class="nc" id="L319">        MonitorWaitEventImpl(JDWP.Event.Composite.Events.MonitorWait evt) {</span>
<span class="nc" id="L320">            super(evt, evt.requestID, evt.thread, evt.location);</span>
<span class="nc" id="L321">            this.monitor = evt.object;</span>
<span class="nc" id="L322">            this.timeout = evt.timeout;</span>
<span class="nc" id="L323">        }</span>

        String eventName() {
<span class="nc" id="L326">            return &quot;MonitorWait&quot;;</span>
        }

        public ObjectReference  monitor() {
<span class="nc" id="L330">            return monitor;</span>
        };

        public long timeout() {
<span class="nc" id="L334">            return timeout;</span>
        }
    }

    class MonitorWaitedEventImpl extends LocatableEventImpl
                            implements MonitorWaitedEvent {
<span class="nc" id="L340">        private ObjectReference monitor = null;</span>
        private boolean timed_out;

<span class="nc" id="L343">        MonitorWaitedEventImpl(JDWP.Event.Composite.Events.MonitorWaited evt) {</span>
<span class="nc" id="L344">            super(evt, evt.requestID, evt.thread, evt.location);</span>
<span class="nc" id="L345">            this.monitor = evt.object;</span>
<span class="nc" id="L346">            this.timed_out = evt.timed_out;</span>
<span class="nc" id="L347">        }</span>

        String eventName() {
<span class="nc" id="L350">            return &quot;MonitorWaited&quot;;</span>
        }

        public ObjectReference  monitor() {
<span class="nc" id="L354">            return monitor;</span>
        };

        public boolean timedout() {
<span class="nc" id="L358">            return timed_out;</span>
        }
    }

    class ClassPrepareEventImpl extends ThreadedEventImpl
                            implements ClassPrepareEvent {
        private ReferenceType referenceType;

<span class="nc" id="L366">        ClassPrepareEventImpl(JDWP.Event.Composite.Events.ClassPrepare evt) {</span>
<span class="nc" id="L367">            super(evt, evt.requestID, evt.thread);</span>
<span class="nc" id="L368">            referenceType = this.vm.referenceType(evt.typeID, evt.refTypeTag,</span>
                                                  evt.signature);
<span class="nc" id="L370">            ((ReferenceTypeImpl)referenceType).setStatus(evt.status);</span>
<span class="nc" id="L371">        }</span>

        public ReferenceType referenceType() {
<span class="nc" id="L374">            return referenceType;</span>
        }

        String eventName() {
<span class="nc" id="L378">            return &quot;ClassPrepareEvent&quot;;</span>
        }
    }

    class ClassUnloadEventImpl extends EventImpl implements ClassUnloadEvent {
        private String classSignature;

<span class="nc" id="L385">        ClassUnloadEventImpl(JDWP.Event.Composite.Events.ClassUnload evt) {</span>
<span class="nc" id="L386">            super(evt, evt.requestID);</span>
<span class="nc" id="L387">            this.classSignature = evt.signature;</span>
<span class="nc" id="L388">        }</span>

        public String className() {
<span class="nc" id="L391">            return classSignature.substring(1, classSignature.length()-1)</span>
<span class="nc" id="L392">                .replace('/', '.');</span>
        }

        public String classSignature() {
<span class="nc" id="L396">            return classSignature;</span>
        }

        String eventName() {
<span class="nc" id="L400">            return &quot;ClassUnloadEvent&quot;;</span>
        }
    }

    class ExceptionEventImpl extends LocatableEventImpl
                                             implements ExceptionEvent {
        private ObjectReference exception;
        private Location catchLocation;

<span class="nc" id="L409">        ExceptionEventImpl(JDWP.Event.Composite.Events.Exception evt) {</span>
<span class="nc" id="L410">            super(evt, evt.requestID, evt.thread, evt.location);</span>
<span class="nc" id="L411">            this.exception = evt.exception;</span>
<span class="nc" id="L412">            this.catchLocation = evt.catchLocation;</span>
<span class="nc" id="L413">        }</span>

        public ObjectReference exception() {
<span class="nc" id="L416">            return exception;</span>
        }

        public Location catchLocation() {
<span class="nc" id="L420">            return catchLocation;</span>
        }

        String eventName() {
<span class="nc" id="L424">            return &quot;ExceptionEvent&quot;;</span>
        }
    }

    class ThreadDeathEventImpl extends ThreadedEventImpl
                                        implements ThreadDeathEvent {
<span class="nc" id="L430">        ThreadDeathEventImpl(JDWP.Event.Composite.Events.ThreadDeath evt) {</span>
<span class="nc" id="L431">            super(evt, evt.requestID, evt.thread);</span>
<span class="nc" id="L432">        }</span>

        String eventName() {
<span class="nc" id="L435">            return &quot;ThreadDeathEvent&quot;;</span>
        }
    }

    class ThreadStartEventImpl extends ThreadedEventImpl
                                        implements ThreadStartEvent {
<span class="nc" id="L441">        ThreadStartEventImpl(JDWP.Event.Composite.Events.ThreadStart evt) {</span>
<span class="nc" id="L442">            super(evt, evt.requestID, evt.thread);</span>
<span class="nc" id="L443">        }</span>

        String eventName() {
<span class="nc" id="L446">            return &quot;ThreadStartEvent&quot;;</span>
        }
    }

    class VMStartEventImpl extends ThreadedEventImpl
                                        implements VMStartEvent {
<span class="nc" id="L452">        VMStartEventImpl(JDWP.Event.Composite.Events.VMStart evt) {</span>
<span class="nc" id="L453">            super(evt, evt.requestID, evt.thread);</span>
<span class="nc" id="L454">        }</span>

        String eventName() {
<span class="nc" id="L457">            return &quot;VMStartEvent&quot;;</span>
        }
    }

    class VMDeathEventImpl extends EventImpl implements VMDeathEvent {

<span class="nc" id="L463">        VMDeathEventImpl(JDWP.Event.Composite.Events.VMDeath evt) {</span>
<span class="nc" id="L464">            super(evt, evt.requestID);</span>
<span class="nc" id="L465">        }</span>

        String eventName() {
<span class="nc" id="L468">            return &quot;VMDeathEvent&quot;;</span>
        }
    }

    class VMDisconnectEventImpl extends EventImpl
                                         implements VMDisconnectEvent {

<span class="nc" id="L475">        VMDisconnectEventImpl() {</span>
<span class="nc" id="L476">            super((byte)JDWP.EventKind.VM_DISCONNECTED);</span>
<span class="nc" id="L477">        }</span>

        String eventName() {
<span class="nc" id="L480">            return &quot;VMDisconnectEvent&quot;;</span>
        }
    }

    abstract class WatchpointEventImpl extends LocatableEventImpl
                                            implements WatchpointEvent {
        private final ReferenceTypeImpl refType;
        private final long fieldID;
        private final ObjectReference object;
<span class="nc" id="L489">        private Field field = null;</span>

        WatchpointEventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
                            int requestID,
                            ThreadReference thread, Location location,
                            byte refTypeTag, long typeID, long fieldID,
<span class="nc" id="L495">                            ObjectReference object) {</span>
<span class="nc" id="L496">            super(evt, requestID, thread, location);</span>
<span class="nc" id="L497">            this.refType = this.vm.referenceType(typeID, refTypeTag);</span>
<span class="nc" id="L498">            this.fieldID = fieldID;</span>
<span class="nc" id="L499">            this.object = object;</span>
<span class="nc" id="L500">        }</span>

        public Field field() {
<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L504">                field = refType.getFieldMirror(fieldID);</span>
            }
<span class="nc" id="L506">            return field;</span>
        }

        public ObjectReference object() {
<span class="nc" id="L510">            return object;</span>
        }

        public Value valueCurrent() {
<span class="nc bnc" id="L514" title="All 2 branches missed.">            if (object == null) {</span>
<span class="nc" id="L515">                return refType.getValue(field());</span>
            } else {
<span class="nc" id="L517">                return object.getValue(field());</span>
            }
        }
    }

    class AccessWatchpointEventImpl extends WatchpointEventImpl
                                            implements AccessWatchpointEvent {

<span class="nc" id="L525">        AccessWatchpointEventImpl(JDWP.Event.Composite.Events.FieldAccess evt) {</span>
<span class="nc" id="L526">            super(evt, evt.requestID, evt.thread, evt.location,</span>
                  evt.refTypeTag, evt.typeID, evt.fieldID, evt.object);
<span class="nc" id="L528">        }</span>

        String eventName() {
<span class="nc" id="L531">            return &quot;AccessWatchpoint&quot;;</span>
        }
    }

    class ModificationWatchpointEventImpl extends WatchpointEventImpl
                           implements ModificationWatchpointEvent {
        Value newValue;

        ModificationWatchpointEventImpl(
<span class="nc" id="L540">                        JDWP.Event.Composite.Events.FieldModification evt) {</span>
<span class="nc" id="L541">            super(evt, evt.requestID, evt.thread, evt.location,</span>
                  evt.refTypeTag, evt.typeID, evt.fieldID, evt.object);
<span class="nc" id="L543">            this.newValue = evt.valueToBe;</span>
<span class="nc" id="L544">        }</span>

        public Value valueToBe() {
<span class="nc" id="L547">            return newValue;</span>
        }

        String eventName() {
<span class="nc" id="L551">            return &quot;ModificationWatchpoint&quot;;</span>
        }
    }

    /**
     * Events are constructed on the thread which reads all data from the
     * transport. This means that the packet cannot be converted to real
     * JDI objects as that may involve further communications with the
     * back end which would deadlock.
     *
     * Hence the {@link #build()} method below called by EventQueue.
     */
    EventSetImpl(VirtualMachine aVm, Packet pkt) {
<span class="nc" id="L564">        super();</span>

        // From &quot;MirrorImpl&quot;:
        // Yes, its a bit of a hack. But by doing it this
        // way, this is the only place we have to change
        // typing to substitute a new impl.
<span class="nc" id="L570">        vm = (VirtualMachineImpl)aVm;</span>

<span class="nc" id="L572">        this.pkt = pkt;</span>
<span class="nc" id="L573">    }</span>

    /**
     * Constructor for special events like VM disconnected
     */
    EventSetImpl(VirtualMachine aVm, byte eventCmd) {
<span class="nc" id="L579">        this(aVm, null);</span>
<span class="nc" id="L580">        suspendPolicy = JDWP.SuspendPolicy.NONE;</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">        switch (eventCmd) {</span>
            case JDWP.EventKind.VM_DISCONNECTED:
<span class="nc" id="L583">                addEvent(new VMDisconnectEventImpl());</span>
<span class="nc" id="L584">                break;</span>

            default:
<span class="nc" id="L587">                throw new InternalException(&quot;Bad singleton event code&quot;);</span>
        }
<span class="nc" id="L589">    }</span>

    private void addEvent(EventImpl evt) {
        // Note that this class has a public add method that throws
        // an exception so that clients can't modify the EventSet
<span class="nc" id="L594">        super.add(evt);</span>
<span class="nc" id="L595">    }</span>

    /*
     * Complete the construction of an EventSet.  This is called from
     * an event handler thread.  It upacks the JDWP events inside
     * the packet and creates EventImpls for them.  The EventSet is already
     * on EventQueues when this is called, so it has to be synch.
     */
    synchronized void build() {
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if (pkt == null) {</span>
<span class="nc" id="L605">            return;</span>
        }
<span class="nc" id="L607">        PacketStream ps = new PacketStream(vm, pkt);</span>
<span class="nc" id="L608">        JDWP.Event.Composite compEvt = new JDWP.Event.Composite(vm, ps);</span>
<span class="nc" id="L609">        suspendPolicy = compEvt.suspendPolicy;</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if ((vm.traceFlags &amp; VirtualMachine.TRACE_EVENTS) != 0) {</span>
<span class="nc bnc" id="L611" title="All 4 branches missed.">            switch(suspendPolicy) {</span>
                case JDWP.SuspendPolicy.ALL:
<span class="nc" id="L613">                    vm.printTrace(&quot;EventSet: SUSPEND_ALL&quot;);</span>
<span class="nc" id="L614">                    break;</span>

                case JDWP.SuspendPolicy.EVENT_THREAD:
<span class="nc" id="L617">                    vm.printTrace(&quot;EventSet: SUSPEND_EVENT_THREAD&quot;);</span>
<span class="nc" id="L618">                    break;</span>

                case JDWP.SuspendPolicy.NONE:
<span class="nc" id="L621">                    vm.printTrace(&quot;EventSet: SUSPEND_NONE&quot;);</span>
                    break;
            }
        }

<span class="nc" id="L626">        ThreadReference fix6485605 = null;</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">        for (int i = 0; i &lt; compEvt.events.length; i++) {</span>
<span class="nc" id="L628">            EventImpl evt = createEvent(compEvt.events[i]);</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">            if ((vm.traceFlags &amp; VirtualMachine.TRACE_EVENTS) != 0) {</span>
                try {
<span class="nc" id="L631">                    vm.printTrace(&quot;Event: &quot; + evt);</span>
<span class="nc" id="L632">                } catch (VMDisconnectedException ee) {</span>
                    // ignore - see bug 6502716
<span class="nc" id="L634">                }</span>
            }

<span class="nc bnc" id="L637" title="All 4 branches missed.">            switch (evt.destination()) {</span>
                case UNKNOWN_EVENT:
                    // Ignore disabled, deleted, unknown events, but
                    // save the thread if there is one since we might
                    // have to resume it.  Note that events for different
                    // threads can't be in the same event set.
<span class="nc bnc" id="L643" title="All 4 branches missed.">                    if (evt instanceof ThreadedEventImpl &amp;&amp;</span>
                        suspendPolicy == JDWP.SuspendPolicy.EVENT_THREAD) {
<span class="nc" id="L645">                        fix6485605 = ((ThreadedEventImpl)evt).thread();</span>
                    }
                    continue;
                case CLIENT_EVENT:
<span class="nc" id="L649">                    addEvent(evt);</span>
<span class="nc" id="L650">                    break;</span>
                case INTERNAL_EVENT:
<span class="nc bnc" id="L652" title="All 2 branches missed.">                    if (internalEventSet == null) {</span>
<span class="nc" id="L653">                        internalEventSet = new EventSetImpl(this.vm, null);</span>
                    }
<span class="nc" id="L655">                    internalEventSet.addEvent(evt);</span>
<span class="nc" id="L656">                    break;</span>
                default:
<span class="nc" id="L658">                    throw new InternalException(&quot;Invalid event destination&quot;);</span>
            }
        }
<span class="nc" id="L661">        pkt = null; // No longer needed - free it up</span>

        // Avoid hangs described in 6296125, 6293795
<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (super.size() == 0) {</span>
            // This set has no client events.  If we don't do
            // needed resumes, no one else is going to.
<span class="nc bnc" id="L667" title="All 2 branches missed.">            if (suspendPolicy == JDWP.SuspendPolicy.ALL) {</span>
<span class="nc" id="L668">                vm.resume();</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">            } else if (suspendPolicy == JDWP.SuspendPolicy.EVENT_THREAD) {</span>
                // See bug 6485605.
<span class="nc bnc" id="L671" title="All 2 branches missed.">                if (fix6485605 != null) {</span>
<span class="nc" id="L672">                    fix6485605.resume();</span>
                } else {
                    // apparently, there is nothing to resume.
                }
            }
<span class="nc" id="L677">            suspendPolicy = JDWP.SuspendPolicy.NONE;</span>

        }

<span class="nc" id="L681">    }</span>

    /**
     * Filter out internal events
     */
    EventSet userFilter() {
<span class="nc" id="L687">        return this;</span>
    }

    /**
     * Filter out user events.
     */
    EventSet internalFilter() {
<span class="nc" id="L694">        return this.internalEventSet;</span>
    }

    EventImpl createEvent(JDWP.Event.Composite.Events evt) {
<span class="nc" id="L698">        JDWP.Event.Composite.Events.EventsCommon comm = evt.aEventsCommon;</span>
<span class="nc bnc" id="L699" title="All 19 branches missed.">        switch (evt.eventKind) {</span>
            case JDWP.EventKind.THREAD_START:
<span class="nc" id="L701">                return new ThreadStartEventImpl(</span>
                      (JDWP.Event.Composite.Events.ThreadStart)comm);

            case JDWP.EventKind.THREAD_END:
<span class="nc" id="L705">                return new ThreadDeathEventImpl(</span>
                      (JDWP.Event.Composite.Events.ThreadDeath)comm);

            case JDWP.EventKind.EXCEPTION:
<span class="nc" id="L709">                return new ExceptionEventImpl(</span>
                      (JDWP.Event.Composite.Events.Exception)comm);

            case JDWP.EventKind.BREAKPOINT:
<span class="nc" id="L713">                return new BreakpointEventImpl(</span>
                      (JDWP.Event.Composite.Events.Breakpoint)comm);

            case JDWP.EventKind.METHOD_ENTRY:
<span class="nc" id="L717">                return new MethodEntryEventImpl(</span>
                      (JDWP.Event.Composite.Events.MethodEntry)comm);

            case JDWP.EventKind.METHOD_EXIT:
<span class="nc" id="L721">                return new MethodExitEventImpl(</span>
                      (JDWP.Event.Composite.Events.MethodExit)comm);

            case JDWP.EventKind.METHOD_EXIT_WITH_RETURN_VALUE:
<span class="nc" id="L725">                return new MethodExitEventImpl(</span>
                      (JDWP.Event.Composite.Events.MethodExitWithReturnValue)comm);

            case JDWP.EventKind.FIELD_ACCESS:
<span class="nc" id="L729">                return new AccessWatchpointEventImpl(</span>
                      (JDWP.Event.Composite.Events.FieldAccess)comm);

            case JDWP.EventKind.FIELD_MODIFICATION:
<span class="nc" id="L733">                return new ModificationWatchpointEventImpl(</span>
                      (JDWP.Event.Composite.Events.FieldModification)comm);

            case JDWP.EventKind.SINGLE_STEP:
<span class="nc" id="L737">                return new StepEventImpl(</span>
                      (JDWP.Event.Composite.Events.SingleStep)comm);

            case JDWP.EventKind.CLASS_PREPARE:
<span class="nc" id="L741">                return new ClassPrepareEventImpl(</span>
                      (JDWP.Event.Composite.Events.ClassPrepare)comm);

            case JDWP.EventKind.CLASS_UNLOAD:
<span class="nc" id="L745">                return new ClassUnloadEventImpl(</span>
                      (JDWP.Event.Composite.Events.ClassUnload)comm);

            case JDWP.EventKind.MONITOR_CONTENDED_ENTER:
<span class="nc" id="L749">                return new MonitorContendedEnterEventImpl(</span>
                      (JDWP.Event.Composite.Events.MonitorContendedEnter)comm);

            case JDWP.EventKind.MONITOR_CONTENDED_ENTERED:
<span class="nc" id="L753">                return new MonitorContendedEnteredEventImpl(</span>
                      (JDWP.Event.Composite.Events.MonitorContendedEntered)comm);

            case JDWP.EventKind.MONITOR_WAIT:
<span class="nc" id="L757">                return new MonitorWaitEventImpl(</span>
                      (JDWP.Event.Composite.Events.MonitorWait)comm);

            case JDWP.EventKind.MONITOR_WAITED:
<span class="nc" id="L761">                return new MonitorWaitedEventImpl(</span>
                      (JDWP.Event.Composite.Events.MonitorWaited)comm);

            case JDWP.EventKind.VM_START:
<span class="nc" id="L765">                return new VMStartEventImpl(</span>
                      (JDWP.Event.Composite.Events.VMStart)comm);

            case JDWP.EventKind.VM_DEATH:
<span class="nc" id="L769">                return new VMDeathEventImpl(</span>
                      (JDWP.Event.Composite.Events.VMDeath)comm);

            default:
                // Ignore unknown event types
<span class="nc" id="L774">                System.err.println(&quot;Ignoring event cmd &quot; +</span>
                                   evt.eventKind + &quot; from the VM&quot;);
<span class="nc" id="L776">                return null;</span>
        }
    }

    public VirtualMachine virtualMachine() {
<span class="nc" id="L781">        return vm;</span>
    }

    public int suspendPolicy() {
<span class="nc" id="L785">        return EventRequestManagerImpl.JDWPtoJDISuspendPolicy(suspendPolicy);</span>
    }

    private ThreadReference eventThread() {
<span class="nc bnc" id="L789" title="All 2 branches missed.">        for (Event event : this) {</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">            if (event instanceof ThreadedEventImpl) {</span>
<span class="nc" id="L791">                return ((ThreadedEventImpl)event).thread();</span>
            }
<span class="nc" id="L793">        }</span>
<span class="nc" id="L794">        return null;</span>
    }

    public void resume() {
<span class="nc bnc" id="L798" title="All 4 branches missed.">        switch (suspendPolicy()) {</span>
            case EventRequest.SUSPEND_ALL:
<span class="nc" id="L800">                vm.resume();</span>
<span class="nc" id="L801">                break;</span>
            case EventRequest.SUSPEND_EVENT_THREAD:
<span class="nc" id="L803">                ThreadReference thread = eventThread();</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">                if (thread == null) {</span>
<span class="nc" id="L805">                    throw new InternalException(&quot;Inconsistent suspend policy&quot;);</span>
                }
<span class="nc" id="L807">                thread.resume();</span>
<span class="nc" id="L808">                break;</span>
            case EventRequest.SUSPEND_NONE:
                // Do nothing
<span class="nc" id="L811">                break;</span>
            default:
<span class="nc" id="L813">                throw new InternalException(&quot;Invalid suspend policy&quot;);</span>
        }
<span class="nc" id="L815">    }</span>

    public Iterator&lt;Event&gt; iterator() {
<span class="nc" id="L818">        return new Itr();</span>
    }

    public EventIterator eventIterator() {
<span class="nc" id="L822">        return new Itr();</span>
    }

<span class="nc" id="L825">    public class Itr implements EventIterator {</span>
        /**
         * Index of element to be returned by subsequent call to next.
         */
<span class="nc" id="L829">        int cursor = 0;</span>

        public boolean hasNext() {
<span class="nc bnc" id="L832" title="All 2 branches missed.">            return cursor != size();</span>
        }

        public Event next() {
            try {
<span class="nc" id="L837">                Event nxt = get(cursor);</span>
<span class="nc" id="L838">                ++cursor;</span>
<span class="nc" id="L839">                return nxt;</span>
<span class="nc" id="L840">            } catch(IndexOutOfBoundsException e) {</span>
<span class="nc" id="L841">                throw new NoSuchElementException();</span>
            }
        }

        public Event nextEvent() {
<span class="nc" id="L846">            return next();</span>
        }

        public void remove() {
<span class="nc" id="L850">            throw new UnsupportedOperationException();</span>
        }
    }

    @Override
    public Spliterator&lt;Event&gt; spliterator() {
<span class="nc" id="L856">        return Spliterators.spliterator(this, Spliterator.DISTINCT);</span>
    }

    /* below make this unmodifiable */

    public boolean add(Event o){
<span class="nc" id="L862">        throw new UnsupportedOperationException();</span>
    }
    public boolean remove(Object o) {
<span class="nc" id="L865">        throw new UnsupportedOperationException();</span>
    }
    public boolean addAll(Collection&lt;? extends Event&gt; coll) {
<span class="nc" id="L868">        throw new UnsupportedOperationException();</span>
    }
    public boolean removeAll(Collection&lt;?&gt; coll) {
<span class="nc" id="L871">        throw new UnsupportedOperationException();</span>
    }
    public boolean retainAll(Collection&lt;?&gt; coll) {
<span class="nc" id="L874">        throw new UnsupportedOperationException();</span>
    }
    public void clear() {
<span class="nc" id="L877">        throw new UnsupportedOperationException();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>