<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ObjectReferenceImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.tools.jdi</a> &gt; <span class="el_source">ObjectReferenceImpl.java</span></div><h1>ObjectReferenceImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import com.sun.jdi.*;

import java.util.*;
import java.util.ArrayList;

public class ObjectReferenceImpl extends ValueImpl
             implements ObjectReference, VMListener {

    protected long ref;
<span class="nc" id="L37">    private ReferenceType type = null;</span>
<span class="nc" id="L38">    private int gcDisableCount = 0;</span>
<span class="nc" id="L39">    boolean addedListener = false;</span>

    // This is cached only while the VM is suspended
<span class="nc" id="L42">    protected static class Cache {</span>
<span class="nc" id="L43">        JDWP.ObjectReference.MonitorInfo monitorInfo = null;</span>
    }

<span class="nc" id="L46">    private static final Cache noInitCache = new Cache();</span>
<span class="nc" id="L47">    private static final Cache markerCache = new Cache();</span>
<span class="nc" id="L48">    private Cache cache = noInitCache;</span>

    private void disableCache() {
<span class="nc" id="L51">        synchronized (vm.state()) {</span>
<span class="nc" id="L52">            cache = null;</span>
<span class="nc" id="L53">        }</span>
<span class="nc" id="L54">    }</span>

    private void enableCache() {
<span class="nc" id="L57">        synchronized (vm.state()) {</span>
<span class="nc" id="L58">            cache = markerCache;</span>
<span class="nc" id="L59">        }</span>
<span class="nc" id="L60">    }</span>

    // Override in subclasses
    protected Cache newCache() {
<span class="nc" id="L64">        return new Cache();</span>
    }

    protected Cache getCache() {
<span class="nc" id="L68">        synchronized (vm.state()) {</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (cache == noInitCache) {</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">                if (vm.state().isSuspended()) {</span>
                    // Set cache now, otherwise newly created objects are
                    // not cached until resuspend
<span class="nc" id="L73">                    enableCache();</span>
                } else {
<span class="nc" id="L75">                    disableCache();</span>
                }
            }
<span class="nc bnc" id="L78" title="All 2 branches missed.">            if (cache == markerCache) {</span>
<span class="nc" id="L79">                cache = newCache();</span>
            }
<span class="nc" id="L81">            return cache;</span>
<span class="nc" id="L82">        }</span>
    }

    // Return the ClassTypeImpl upon which to invoke a method.
    // By default it is our very own referenceType() but subclasses
    // can override.
    protected ClassTypeImpl invokableReferenceType(Method method) {
<span class="nc" id="L89">        return (ClassTypeImpl)referenceType();</span>
    }

    ObjectReferenceImpl(VirtualMachine aVm,long aRef) {
<span class="nc" id="L93">        super(aVm);</span>

<span class="nc" id="L95">        ref = aRef;</span>
<span class="nc" id="L96">    }</span>

    protected String description() {
<span class="nc" id="L99">        return &quot;ObjectReference &quot; + uniqueID();</span>
    }

    /*
     * VMListener implementation
     */
    public boolean vmSuspended(VMAction action) {
<span class="nc" id="L106">        enableCache();</span>
<span class="nc" id="L107">        return true;</span>
    }

    public boolean vmNotSuspended(VMAction action) {
        // make sure that cache and listener management are synchronized
<span class="nc" id="L112">        synchronized (vm.state()) {</span>
<span class="nc bnc" id="L113" title="All 4 branches missed.">            if (cache != null &amp;&amp; (vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {</span>
<span class="nc" id="L114">                vm.printTrace(&quot;Clearing temporary cache for &quot; + description());</span>
            }
<span class="nc" id="L116">            disableCache();</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">            if (addedListener) {</span>
                /*
                 * If a listener was added (i.e. this is not a
                 * ObjectReference that adds a listener on startup),
                 * remove it here.
                 */
<span class="nc" id="L123">                addedListener = false;</span>
<span class="nc" id="L124">                return false;  // false says remove</span>
            } else {
<span class="nc" id="L126">                return true;</span>
            }
<span class="nc" id="L128">        }</span>
    }

    public boolean equals(Object obj) {
<span class="nc bnc" id="L132" title="All 4 branches missed.">        if ((obj != null) &amp;&amp; (obj instanceof ObjectReferenceImpl)) {</span>
<span class="nc" id="L133">            ObjectReferenceImpl other = (ObjectReferenceImpl)obj;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">            return (ref() == other.ref()) &amp;&amp;</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                   super.equals(obj);</span>
        } else {
<span class="nc" id="L137">            return false;</span>
        }
    }

    public int hashCode() {
<span class="nc" id="L142">        return(int)ref();</span>
    }

    public Type type() {
<span class="nc" id="L146">        return referenceType();</span>
    }

    public ReferenceType referenceType() {
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (type == null) {</span>
            try {
<span class="nc" id="L152">                JDWP.ObjectReference.ReferenceType rtinfo =</span>
<span class="nc" id="L153">                    JDWP.ObjectReference.ReferenceType.process(vm, this);</span>
<span class="nc" id="L154">                type = vm.referenceType(rtinfo.typeID,</span>
                                        rtinfo.refTypeTag);
<span class="nc" id="L156">            } catch (JDWPException exc) {</span>
<span class="nc" id="L157">                throw exc.toJDIException();</span>
<span class="nc" id="L158">            }</span>
        }
<span class="nc" id="L160">        return type;</span>
    }

    public Value getValue(Field sig) {
<span class="nc" id="L164">        List&lt;Field&gt; list = new ArrayList&lt;Field&gt;(1);</span>
<span class="nc" id="L165">        list.add(sig);</span>
<span class="nc" id="L166">        Map&lt;Field, Value&gt; map = getValues(list);</span>
<span class="nc" id="L167">        return map.get(sig);</span>
    }

    public Map&lt;Field,Value&gt; getValues(List&lt;? extends Field&gt; theFields) {
<span class="nc" id="L171">        validateMirrors(theFields);</span>

<span class="nc" id="L173">        List&lt;Field&gt; staticFields = new ArrayList&lt;Field&gt;(0);</span>
<span class="nc" id="L174">        int size = theFields.size();</span>
<span class="nc" id="L175">        List&lt;Field&gt; instanceFields = new ArrayList&lt;Field&gt;(size);</span>

<span class="nc bnc" id="L177" title="All 2 branches missed.">        for (int i=0; i&lt;size; i++) {</span>
<span class="nc" id="L178">            Field field = (Field)theFields.get(i);</span>

            // Make sure the field is valid
<span class="nc" id="L181">            ((ReferenceTypeImpl)referenceType()).validateFieldAccess(field);</span>

            // FIX ME! We need to do some sanity checking
            // here; make sure the field belongs to this
            // object.
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (field.isStatic())</span>
<span class="nc" id="L187">                staticFields.add(field);</span>
            else {
<span class="nc" id="L189">                instanceFields.add(field);</span>
            }
        }

        Map&lt;Field, Value&gt; map;
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (staticFields.size() &gt; 0) {</span>
<span class="nc" id="L195">            map = referenceType().getValues(staticFields);</span>
        } else {
<span class="nc" id="L197">            map = new HashMap&lt;Field, Value&gt;(size);</span>
        }

<span class="nc" id="L200">        size = instanceFields.size();</span>

<span class="nc" id="L202">        JDWP.ObjectReference.GetValues.Field[] queryFields =</span>
                         new JDWP.ObjectReference.GetValues.Field[size];
<span class="nc bnc" id="L204" title="All 2 branches missed.">        for (int i=0; i&lt;size; i++) {</span>
<span class="nc" id="L205">            FieldImpl field = (FieldImpl)instanceFields.get(i);/* thanks OTI */</span>
<span class="nc" id="L206">            queryFields[i] = new JDWP.ObjectReference.GetValues.Field(</span>
<span class="nc" id="L207">                                         field.ref());</span>
        }
        ValueImpl[] values;
        try {
<span class="nc" id="L211">            values = JDWP.ObjectReference.GetValues.</span>
<span class="nc" id="L212">                                     process(vm, this, queryFields).values;</span>
<span class="nc" id="L213">        } catch (JDWPException exc) {</span>
<span class="nc" id="L214">            throw exc.toJDIException();</span>
<span class="nc" id="L215">        }</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (size != values.length) {</span>
<span class="nc" id="L218">            throw new InternalException(</span>
                         &quot;Wrong number of values returned from target VM&quot;);
        }
<span class="nc bnc" id="L221" title="All 2 branches missed.">        for (int i=0; i&lt;size; i++) {</span>
<span class="nc" id="L222">            FieldImpl field = (FieldImpl)instanceFields.get(i);</span>
<span class="nc" id="L223">            map.put(field, values[i]);</span>
        }

<span class="nc" id="L226">        return map;</span>
    }

    public void setValue(Field field, Value value)
                   throws InvalidTypeException, ClassNotLoadedException {

<span class="nc" id="L232">        validateMirror(field);</span>
<span class="nc" id="L233">        validateMirrorOrNull(value);</span>

        // Make sure the field is valid
<span class="nc" id="L236">        ((ReferenceTypeImpl)referenceType()).validateFieldSet(field);</span>

<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (field.isStatic()) {</span>
<span class="nc" id="L239">            ReferenceType type = referenceType();</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            if (type instanceof ClassType) {</span>
<span class="nc" id="L241">                ((ClassType)type).setValue(field, value);</span>
<span class="nc" id="L242">                return;</span>
            } else {
<span class="nc" id="L244">                throw new IllegalArgumentException(</span>
                                    &quot;Invalid type for static field set&quot;);
            }
        }

        try {
<span class="nc" id="L250">            JDWP.ObjectReference.SetValues.FieldValue[] fvals =</span>
                      new JDWP.ObjectReference.SetValues.FieldValue[1];
<span class="nc" id="L252">            fvals[0] = new JDWP.ObjectReference.SetValues.FieldValue(</span>
<span class="nc" id="L253">                           ((FieldImpl)field).ref(),</span>
                           // Validate and convert if necessary
<span class="nc" id="L255">                           ValueImpl.prepareForAssignment(value,</span>
                                                          (FieldImpl)field));
            try {
<span class="nc" id="L258">                JDWP.ObjectReference.SetValues.process(vm, this, fvals);</span>
<span class="nc" id="L259">            } catch (JDWPException exc) {</span>
<span class="nc" id="L260">                throw exc.toJDIException();</span>
<span class="nc" id="L261">            }</span>
<span class="nc" id="L262">        } catch (ClassNotLoadedException e) {</span>
            /*
             * Since we got this exception,
             * the field type must be a reference type. The value
             * we're trying to set is null, but if the field's
             * class has not yet been loaded through the enclosing
             * class loader, then setting to null is essentially a
             * no-op, and we should allow it without an exception.
             */
<span class="nc bnc" id="L271" title="All 2 branches missed.">            if (value != null) {</span>
<span class="nc" id="L272">                throw e;</span>
            }
<span class="nc" id="L274">        }</span>
<span class="nc" id="L275">    }</span>

    void validateMethodInvocation(Method method, int options)
                                         throws InvalidTypeException,
                                         InvocationException {

        /*
         * Method must be in this object's class, a superclass, or
         * implemented interface
         */
<span class="nc" id="L285">        ReferenceTypeImpl declType = (ReferenceTypeImpl)method.declaringType();</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (!declType.isAssignableFrom(this)) {</span>
<span class="nc" id="L287">            throw new IllegalArgumentException(&quot;Invalid method&quot;);</span>
        }

<span class="nc" id="L290">        ClassTypeImpl clazz = invokableReferenceType(method);</span>

        /*
         * Method must be a non-constructor
         */
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (method.isConstructor()) {</span>
<span class="nc" id="L296">            throw new IllegalArgumentException(&quot;Cannot invoke constructor&quot;);</span>
        }

        /*
         * For nonvirtual invokes, method must have a body
         */
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if ((options &amp; INVOKE_NONVIRTUAL) != 0) {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (method.declaringType() instanceof InterfaceType) {</span>
<span class="nc" id="L304">                throw new IllegalArgumentException(&quot;Interface method&quot;);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            } else if (method.isAbstract()) {</span>
<span class="nc" id="L306">                throw new IllegalArgumentException(&quot;Abstract method&quot;);</span>
            }
        }

        /*
         * Get the class containing the method that will be invoked.
         * This class is needed only for proper validation of the
         * method argument types.
         */
        ClassTypeImpl invokedClass;
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if ((options &amp; INVOKE_NONVIRTUAL) != 0) {</span>
            // No overrides in non-virtual invokes
<span class="nc" id="L318">            invokedClass = clazz;</span>
        } else {
            /*
             * For virtual invokes, find any override of the method.
             * Since we are looking for a method with a real body, we
             * don't need to bother with interfaces/abstract methods.
             */
<span class="nc" id="L325">            Method invoker = clazz.concreteMethodByName(method.name(),</span>
<span class="nc" id="L326">                                                        method.signature());</span>
            //  isAssignableFrom check above guarantees non-null
<span class="nc" id="L328">            invokedClass = (ClassTypeImpl)invoker.declaringType();</span>
        }
        /* The above code is left over from previous versions.
         * We haven't had time to divine the intent.  jjh, 7/31/2003
         */
<span class="nc" id="L333">    }</span>

    PacketStream sendInvokeCommand(final ThreadReferenceImpl thread,
                                   final ClassTypeImpl refType,
                                   final MethodImpl method,
                                   final ValueImpl[] args,
                                   final int options) {
<span class="nc" id="L340">        CommandSender sender =</span>
<span class="nc" id="L341">            new CommandSender() {</span>
                public PacketStream send() {
<span class="nc" id="L343">                    return JDWP.ObjectReference.InvokeMethod.enqueueCommand(</span>
                                          vm, ObjectReferenceImpl.this,
                                          thread, refType,
<span class="nc" id="L346">                                          method.ref(), args, options);</span>
                }
        };

        PacketStream stream;
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if ((options &amp; INVOKE_SINGLE_THREADED) != 0) {</span>
<span class="nc" id="L352">            stream = thread.sendResumingCommand(sender);</span>
        } else {
<span class="nc" id="L354">            stream = vm.sendResumingCommand(sender);</span>
        }
<span class="nc" id="L356">        return stream;</span>
    }

    public Value invokeMethod(ThreadReference threadIntf, Method methodIntf,
                              List&lt;? extends Value&gt; origArguments, int options)
                              throws InvalidTypeException,
                                     IncompatibleThreadStateException,
                                     InvocationException,
                                     ClassNotLoadedException {
<span class="nc" id="L365">        validateMirror(threadIntf);</span>
<span class="nc" id="L366">        validateMirror(methodIntf);</span>
<span class="nc" id="L367">        validateMirrorsOrNulls(origArguments);</span>

<span class="nc" id="L369">        MethodImpl method = (MethodImpl)methodIntf;</span>
<span class="nc" id="L370">        ThreadReferenceImpl thread = (ThreadReferenceImpl)threadIntf;</span>

<span class="nc bnc" id="L372" title="All 2 branches missed.">        if (method.isStatic()) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            if (referenceType() instanceof ClassType) {</span>
<span class="nc" id="L374">                ClassType type = (ClassType)referenceType();</span>
<span class="nc" id="L375">                return type.invokeMethod(thread, method, origArguments, options);</span>
            } else {
<span class="nc" id="L377">                throw new IllegalArgumentException(&quot;Invalid type for static method invocation&quot;);</span>
            }
        }

<span class="nc" id="L381">        validateMethodInvocation(method, options);</span>

<span class="nc" id="L383">        List&lt;Value&gt; arguments = method.validateAndPrepareArgumentsForInvoke(</span>
                                                  origArguments);

<span class="nc" id="L386">        ValueImpl[] args = arguments.toArray(new ValueImpl[0]);</span>
        JDWP.ObjectReference.InvokeMethod ret;
        try {
<span class="nc" id="L389">            PacketStream stream =</span>
<span class="nc" id="L390">                sendInvokeCommand(thread, invokableReferenceType(method),</span>
                                  method, args, options);
<span class="nc" id="L392">            ret = JDWP.ObjectReference.InvokeMethod.waitForReply(vm, stream);</span>
<span class="nc" id="L393">        } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (exc.errorCode() == JDWP.Error.INVALID_THREAD) {</span>
<span class="nc" id="L395">                throw new IncompatibleThreadStateException();</span>
            } else {
<span class="nc" id="L397">                throw exc.toJDIException();</span>
            }
<span class="nc" id="L399">        }</span>

        /*
         * There is an implict VM-wide suspend at the conclusion
         * of a normal (non-single-threaded) method invoke
         */
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if ((options &amp; INVOKE_SINGLE_THREADED) == 0) {</span>
<span class="nc" id="L406">            vm.notifySuspend();</span>
        }

<span class="nc bnc" id="L409" title="All 2 branches missed.">        if (ret.exception != null) {</span>
<span class="nc" id="L410">            throw new InvocationException(ret.exception);</span>
        } else {
<span class="nc" id="L412">            return ret.returnValue;</span>
        }
    }

    /* leave synchronized to keep count accurate */
    public synchronized void disableCollection() {
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (gcDisableCount == 0) {</span>
            try {
<span class="nc" id="L420">                JDWP.ObjectReference.DisableCollection.process(vm, this);</span>
<span class="nc" id="L421">            } catch (JDWPException exc) {</span>
<span class="nc" id="L422">                throw exc.toJDIException();</span>
<span class="nc" id="L423">            }</span>
        }
<span class="nc" id="L425">        gcDisableCount++;</span>
<span class="nc" id="L426">    }</span>

    /* leave synchronized to keep count accurate */
    public synchronized void enableCollection() {
<span class="nc" id="L430">        gcDisableCount--;</span>

<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (gcDisableCount == 0) {</span>
            try {
<span class="nc" id="L434">                JDWP.ObjectReference.EnableCollection.process(vm, this);</span>
<span class="nc" id="L435">            } catch (JDWPException exc) {</span>
                // If already collected, no harm done, no exception
<span class="nc bnc" id="L437" title="All 2 branches missed.">                if (exc.errorCode() != JDWP.Error.INVALID_OBJECT) {</span>
<span class="nc" id="L438">                    throw exc.toJDIException();</span>
                }
<span class="nc" id="L440">                return;</span>
<span class="nc" id="L441">            }</span>
        }
<span class="nc" id="L443">    }</span>

    public boolean isCollected() {
        try {
<span class="nc" id="L447">            return JDWP.ObjectReference.IsCollected.process(vm, this).</span>
                                                              isCollected;
<span class="nc" id="L449">        } catch (JDWPException exc) {</span>
<span class="nc" id="L450">            throw exc.toJDIException();</span>
        }
    }

    public long uniqueID() {
<span class="nc" id="L455">        return ref();</span>
    }

    JDWP.ObjectReference.MonitorInfo jdwpMonitorInfo()
                             throws IncompatibleThreadStateException {
<span class="nc" id="L460">        JDWP.ObjectReference.MonitorInfo info = null;</span>
        try {
            Cache local;

            // getCache() and addlistener() must be synchronized
            // so that no events are lost.
<span class="nc" id="L466">            synchronized (vm.state()) {</span>
<span class="nc" id="L467">                local = getCache();</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">                if (local != null) {</span>
<span class="nc" id="L470">                    info = local.monitorInfo;</span>

                    // Check if there will be something to cache
                    // and there is not already a listener
<span class="nc bnc" id="L474" title="All 4 branches missed.">                    if (info == null &amp;&amp; !vm.state().hasListener(this)) {</span>
                        /* For other, less numerous objects, this is done
                         * in the constructor. Since there can be many
                         * ObjectReferences, the VM listener is installed
                         * and removed as needed.
                         * Listener must be installed before process()
                         */
<span class="nc" id="L481">                        vm.state().addListener(this);</span>
<span class="nc" id="L482">                        addedListener = true;</span>
                    }
                }
<span class="nc" id="L485">            }</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            if (info == null) {</span>
<span class="nc" id="L487">                info = JDWP.ObjectReference.MonitorInfo.process(vm, this);</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">                if (local != null) {</span>
<span class="nc" id="L489">                    local.monitorInfo = info;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                    if ((vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {</span>
<span class="nc" id="L491">                        vm.printTrace(&quot;ObjectReference &quot; + uniqueID() +</span>
                                      &quot; temporarily caching monitor info&quot;);
                    }
                }
            }
<span class="nc" id="L496">        } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">             if (exc.errorCode() == JDWP.Error.THREAD_NOT_SUSPENDED) {</span>
<span class="nc" id="L498">                 throw new IncompatibleThreadStateException();</span>
             } else {
<span class="nc" id="L500">                 throw exc.toJDIException();</span>
             }
<span class="nc" id="L502">         }</span>
<span class="nc" id="L503">        return info;</span>
    }

    public List&lt;ThreadReference&gt; waitingThreads() throws IncompatibleThreadStateException {
<span class="nc" id="L507">        return Arrays.asList((ThreadReference[])jdwpMonitorInfo().waiters);</span>
    }

    public ThreadReference owningThread() throws IncompatibleThreadStateException {
<span class="nc" id="L511">        return jdwpMonitorInfo().owner;</span>
    }

    public int entryCount() throws IncompatibleThreadStateException {
<span class="nc" id="L515">        return jdwpMonitorInfo().entryCount;</span>
    }


    public List&lt;ObjectReference&gt; referringObjects(long maxReferrers) {
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (!vm.canGetInstanceInfo()) {</span>
<span class="nc" id="L521">            throw new UnsupportedOperationException(</span>
                &quot;target does not support getting referring objects&quot;);
        }

<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (maxReferrers &lt; 0) {</span>
<span class="nc" id="L526">            throw new IllegalArgumentException(&quot;maxReferrers is less than zero: &quot;</span>
                                              + maxReferrers);
        }

<span class="nc bnc" id="L530" title="All 2 branches missed.">        int intMax = (maxReferrers &gt; Integer.MAX_VALUE)?</span>
            Integer.MAX_VALUE: (int)maxReferrers;
        // JDWP can't currently handle more than this (in mustang)

        try {
<span class="nc" id="L535">            return Arrays.asList((ObjectReference[])JDWP.ObjectReference.ReferringObjects.</span>
<span class="nc" id="L536">                                process(vm, this, intMax).referringObjects);</span>
<span class="nc" id="L537">        } catch (JDWPException exc) {</span>
<span class="nc" id="L538">            throw exc.toJDIException();</span>
        }
    }

    long ref() {
<span class="nc" id="L543">        return ref;</span>
    }

    boolean isClassObject() {
        /*
         * Don't need to worry about subclasses since java.lang.Class is final.
         */
<span class="nc" id="L550">        return referenceType().name().equals(&quot;java.lang.Class&quot;);</span>
    }

    ValueImpl prepareForAssignmentTo(ValueContainer destination)
                                 throws InvalidTypeException,
                                        ClassNotLoadedException {

<span class="nc" id="L557">        validateAssignment(destination);</span>
<span class="nc" id="L558">        return this;            // conversion never necessary</span>
    }

    void validateAssignment(ValueContainer destination)
                            throws InvalidTypeException, ClassNotLoadedException {

        /*
         * Do these simpler checks before attempting a query of the destination's
         * type which might cause a confusing ClassNotLoadedException if
         * the destination is primitive or an array.
         */
        /*
         * TO DO: Centralize JNI signature knowledge
         */
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (destination.signature().length() == 1) {</span>
<span class="nc" id="L573">            throw new InvalidTypeException(&quot;Can't assign object value to primitive&quot;);</span>
        }
<span class="nc bnc" id="L575" title="All 2 branches missed.">        if ((destination.signature().charAt(0) == '[') &amp;&amp;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">            (type().signature().charAt(0) != '[')) {</span>
<span class="nc" id="L577">            throw new InvalidTypeException(&quot;Can't assign non-array value to an array&quot;);</span>
        }
<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (&quot;void&quot;.equals(destination.typeName())) {</span>
<span class="nc" id="L580">            throw new InvalidTypeException(&quot;Can't assign object value to a void&quot;);</span>
        }

        // Validate assignment
<span class="nc" id="L584">        ReferenceType destType = (ReferenceTypeImpl)destination.type();</span>
<span class="nc" id="L585">        ReferenceTypeImpl myType = (ReferenceTypeImpl)referenceType();</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">        if (!myType.isAssignableTo(destType)) {</span>
<span class="nc" id="L587">            JNITypeParser parser = new JNITypeParser(destType.signature());</span>
<span class="nc" id="L588">            String destTypeName = parser.typeName();</span>
<span class="nc" id="L589">            throw new InvalidTypeException(&quot;Can't assign &quot; +</span>
<span class="nc" id="L590">                                           type().name() +</span>
                                           &quot; to &quot; + destTypeName);
        }
<span class="nc" id="L593">    }</span>


    public String toString() {
<span class="nc" id="L597">        return &quot;instance of &quot; + referenceType().name() + &quot;(id=&quot; + uniqueID() + &quot;)&quot;;</span>
    }

    byte typeValueKey() {
<span class="nc" id="L601">        return JDWP.Tag.OBJECT;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>