<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StackFrameImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.tools.jdi</a> &gt; <span class="el_source">StackFrameImpl.java</span></div><h1>StackFrameImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import com.sun.jdi.*;

import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Collections;

public class StackFrameImpl extends MirrorImpl
                            implements StackFrame, ThreadListener
{
    /* Once false, frame should not be used.
     * access synchronized on (vm.state())
     */
<span class="nc" id="L44">    private boolean isValid = true;</span>

    private final ThreadReferenceImpl thread;
    private final long id;
    private final Location location;
<span class="nc" id="L49">    private Map&lt;String, LocalVariable&gt; visibleVariables =  null;</span>
<span class="nc" id="L50">    private ObjectReference thisObject = null;</span>

    StackFrameImpl(VirtualMachine vm, ThreadReferenceImpl thread,
                   long id, Location location) {
<span class="nc" id="L54">        super(vm);</span>
<span class="nc" id="L55">        this.thread = thread;</span>
<span class="nc" id="L56">        this.id = id;</span>
<span class="nc" id="L57">        this.location = location;</span>
<span class="nc" id="L58">        thread.addListener(this);</span>
<span class="nc" id="L59">    }</span>

    /*
     * ThreadListener implementation
     * Must be synchronized since we must protect against
     * sending defunct (isValid == false) stack ids to the back-end.
     */
    public boolean threadResumable(ThreadAction action) {
<span class="nc" id="L67">        synchronized (vm.state()) {</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">            if (isValid) {</span>
<span class="nc" id="L69">                isValid = false;</span>
<span class="nc" id="L70">                return false;   /* remove this stack frame as a listener */</span>
            } else {
<span class="nc" id="L72">                throw new InternalException(</span>
                                  &quot;Invalid stack frame thread listener&quot;);
            }
<span class="nc" id="L75">        }</span>
    }

    void validateStackFrame() {
<span class="nc bnc" id="L79" title="All 2 branches missed.">        if (!isValid) {</span>
<span class="nc" id="L80">            throw new InvalidStackFrameException(&quot;Thread has been resumed&quot;);</span>
        }
<span class="nc" id="L82">    }</span>

    /**
     * Return the frame location.
     * Need not be synchronized since it cannot be provably stale.
     */
    public Location location() {
<span class="nc" id="L89">        validateStackFrame();</span>
<span class="nc" id="L90">        return location;</span>
    }

    /**
     * Return the thread holding the frame.
     * Need not be synchronized since it cannot be provably stale.
     */
    public ThreadReference thread() {
<span class="nc" id="L98">        validateStackFrame();</span>
<span class="nc" id="L99">        return thread;</span>
    }

    public boolean equals(Object obj) {
<span class="nc bnc" id="L103" title="All 4 branches missed.">        if ((obj != null) &amp;&amp; (obj instanceof StackFrameImpl)) {</span>
<span class="nc" id="L104">            StackFrameImpl other = (StackFrameImpl)obj;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">            return (id == other.id) &amp;&amp;</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">                   (thread().equals(other.thread())) &amp;&amp;</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">                   (location().equals(other.location())) &amp;&amp;</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">                    super.equals(obj);</span>
        } else {
<span class="nc" id="L110">            return false;</span>
        }
    }

    public int hashCode() {
<span class="nc" id="L115">        return (thread().hashCode() &lt;&lt; 4) + ((int)id);</span>
    }

    public ObjectReference thisObject() {
<span class="nc" id="L119">        validateStackFrame();</span>
<span class="nc" id="L120">        MethodImpl currentMethod = (MethodImpl)location.method();</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">        if (currentMethod.isStatic() || currentMethod.isNative()) {</span>
<span class="nc" id="L122">            return null;</span>
        } else {
<span class="nc bnc" id="L124" title="All 2 branches missed.">            if (thisObject == null) {</span>
                PacketStream ps;

                /* protect against defunct frame id */
<span class="nc" id="L128">                synchronized (vm.state()) {</span>
<span class="nc" id="L129">                    validateStackFrame();</span>
<span class="nc" id="L130">                    ps = JDWP.StackFrame.ThisObject.</span>
<span class="nc" id="L131">                                      enqueueCommand(vm, thread, id);</span>
<span class="nc" id="L132">                }</span>

                /* actually get it, now that order is guaranteed */
                try {
<span class="nc" id="L136">                    thisObject = JDWP.StackFrame.ThisObject.</span>
<span class="nc" id="L137">                                      waitForReply(vm, ps).objectThis;</span>
<span class="nc" id="L138">                } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">                    switch (exc.errorCode()) {</span>
                    case JDWP.Error.INVALID_FRAMEID:
                    case JDWP.Error.THREAD_NOT_SUSPENDED:
                    case JDWP.Error.INVALID_THREAD:
<span class="nc" id="L143">                        throw new InvalidStackFrameException();</span>
                    default:
<span class="nc" id="L145">                        throw exc.toJDIException();</span>
                    }
<span class="nc" id="L147">                }</span>
            }
        }
<span class="nc" id="L150">        return thisObject;</span>
    }

    /**
     * Build the visible variable map.
     * Need not be synchronized since it cannot be provably stale.
     */
    private void createVisibleVariables() throws AbsentInformationException {
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (visibleVariables == null) {</span>
<span class="nc" id="L159">            List&lt;LocalVariable&gt; allVariables = location.method().variables();</span>
<span class="nc" id="L160">            Map&lt;String, LocalVariable&gt; map = new HashMap&lt;String, LocalVariable&gt;(allVariables.size());</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">            for (LocalVariable variable : allVariables) {</span>
<span class="nc" id="L163">                String name = variable.name();</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">                if (variable.isVisible(this)) {</span>
<span class="nc" id="L165">                    LocalVariable existing = map.get(name);</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">                    if ((existing == null) ||</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">                        ((LocalVariableImpl)variable).hides(existing)) {</span>
<span class="nc" id="L168">                        map.put(name, variable);</span>
                    }
                }
<span class="nc" id="L171">            }</span>
<span class="nc" id="L172">            visibleVariables = map;</span>
        }
<span class="nc" id="L174">    }</span>

    /**
     * Return the list of visible variable in the frame.
     * Need not be synchronized since it cannot be provably stale.
     */
    public List&lt;LocalVariable&gt; visibleVariables() throws AbsentInformationException {
<span class="nc" id="L181">        validateStackFrame();</span>
<span class="nc" id="L182">        createVisibleVariables();</span>
<span class="nc" id="L183">        List&lt;LocalVariable&gt; mapAsList = new ArrayList&lt;LocalVariable&gt;(visibleVariables.values());</span>
<span class="nc" id="L184">        Collections.sort(mapAsList);</span>
<span class="nc" id="L185">        return mapAsList;</span>
    }

    /**
     * Return a particular variable in the frame.
     * Need not be synchronized since it cannot be provably stale.
     */
    public LocalVariable visibleVariableByName(String name) throws AbsentInformationException  {
<span class="nc" id="L193">        validateStackFrame();</span>
<span class="nc" id="L194">        createVisibleVariables();</span>
<span class="nc" id="L195">        return visibleVariables.get(name);</span>
    }

    public Value getValue(LocalVariable variable) {
<span class="nc" id="L199">        List&lt;LocalVariable&gt; list = new ArrayList&lt;LocalVariable&gt;(1);</span>
<span class="nc" id="L200">        list.add(variable);</span>
<span class="nc" id="L201">        return getValues(list).get(variable);</span>
    }

    public Map&lt;LocalVariable, Value&gt; getValues(List&lt;? extends LocalVariable&gt; variables) {
<span class="nc" id="L205">        validateStackFrame();</span>
<span class="nc" id="L206">        validateMirrors(variables);</span>

<span class="nc" id="L208">        int count = variables.size();</span>
<span class="nc" id="L209">        JDWP.StackFrame.GetValues.SlotInfo[] slots =</span>
                           new JDWP.StackFrame.GetValues.SlotInfo[count];

<span class="nc bnc" id="L212" title="All 2 branches missed.">        for (int i=0; i&lt;count; ++i) {</span>
<span class="nc" id="L213">            LocalVariableImpl variable = (LocalVariableImpl)variables.get(i);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if (!variable.isVisible(this)) {</span>
<span class="nc" id="L215">                throw new IllegalArgumentException(variable.name() +</span>
                                 &quot; is not valid at this frame location&quot;);
            }
<span class="nc" id="L218">            slots[i] = new JDWP.StackFrame.GetValues.SlotInfo(variable.slot(),</span>
<span class="nc" id="L219">                                      (byte)variable.signature().charAt(0));</span>
        }

        PacketStream ps;

        /* protect against defunct frame id */
<span class="nc" id="L225">        synchronized (vm.state()) {</span>
<span class="nc" id="L226">            validateStackFrame();</span>
<span class="nc" id="L227">            ps = JDWP.StackFrame.GetValues.enqueueCommand(vm, thread, id, slots);</span>
<span class="nc" id="L228">        }</span>

        /* actually get it, now that order is guaranteed */
        ValueImpl[] values;
        try {
<span class="nc" id="L233">            values = JDWP.StackFrame.GetValues.waitForReply(vm, ps).values;</span>
<span class="nc" id="L234">        } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            switch (exc.errorCode()) {</span>
                case JDWP.Error.INVALID_FRAMEID:
                case JDWP.Error.THREAD_NOT_SUSPENDED:
                case JDWP.Error.INVALID_THREAD:
<span class="nc" id="L239">                    throw new InvalidStackFrameException();</span>
                default:
<span class="nc" id="L241">                    throw exc.toJDIException();</span>
            }
<span class="nc" id="L243">        }</span>

<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (count != values.length) {</span>
<span class="nc" id="L246">            throw new InternalException(</span>
                      &quot;Wrong number of values returned from target VM&quot;);
        }
<span class="nc" id="L249">        Map&lt;LocalVariable, Value&gt; map = new HashMap&lt;LocalVariable, Value&gt;(count);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        for (int i=0; i&lt;count; ++i) {</span>
<span class="nc" id="L251">            LocalVariableImpl variable = (LocalVariableImpl)variables.get(i);</span>
<span class="nc" id="L252">            map.put(variable, values[i]);</span>
        }
<span class="nc" id="L254">        return map;</span>
    }

    public void setValue(LocalVariable variableIntf, Value valueIntf)
        throws InvalidTypeException, ClassNotLoadedException {

<span class="nc" id="L260">        validateStackFrame();</span>
<span class="nc" id="L261">        validateMirror(variableIntf);</span>
<span class="nc" id="L262">        validateMirrorOrNull(valueIntf);</span>

<span class="nc" id="L264">        LocalVariableImpl variable = (LocalVariableImpl)variableIntf;</span>
<span class="nc" id="L265">        ValueImpl value = (ValueImpl)valueIntf;</span>

<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (!variable.isVisible(this)) {</span>
<span class="nc" id="L268">            throw new IllegalArgumentException(variable.name() +</span>
                             &quot; is not valid at this frame location&quot;);
        }

        try {
            // Validate and convert value if necessary
<span class="nc" id="L274">            value = ValueImpl.prepareForAssignment(value, variable);</span>

<span class="nc" id="L276">            JDWP.StackFrame.SetValues.SlotInfo[] slotVals =</span>
                new JDWP.StackFrame.SetValues.SlotInfo[1];
<span class="nc" id="L278">            slotVals[0] = new JDWP.StackFrame.SetValues.</span>
<span class="nc" id="L279">                                       SlotInfo(variable.slot(), value);</span>

            PacketStream ps;

            /* protect against defunct frame id */
<span class="nc" id="L284">            synchronized (vm.state()) {</span>
<span class="nc" id="L285">                validateStackFrame();</span>
<span class="nc" id="L286">                ps = JDWP.StackFrame.SetValues.</span>
<span class="nc" id="L287">                                     enqueueCommand(vm, thread, id, slotVals);</span>
<span class="nc" id="L288">            }</span>

            /* actually set it, now that order is guaranteed */
            try {
<span class="nc" id="L292">                JDWP.StackFrame.SetValues.waitForReply(vm, ps);</span>
<span class="nc" id="L293">            } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">                switch (exc.errorCode()) {</span>
                case JDWP.Error.INVALID_FRAMEID:
                case JDWP.Error.THREAD_NOT_SUSPENDED:
                case JDWP.Error.INVALID_THREAD:
<span class="nc" id="L298">                    throw new InvalidStackFrameException();</span>
                default:
<span class="nc" id="L300">                    throw exc.toJDIException();</span>
                }
<span class="nc" id="L302">            }</span>
<span class="nc" id="L303">        } catch (ClassNotLoadedException e) {</span>
            /*
             * Since we got this exception,
             * the variable type must be a reference type. The value
             * we're trying to set is null, but if the variable's
             * class has not yet been loaded through the enclosing
             * class loader, then setting to null is essentially a
             * no-op, and we should allow it without an exception.
             */
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (value != null) {</span>
<span class="nc" id="L313">                throw e;</span>
            }
<span class="nc" id="L315">        }</span>
<span class="nc" id="L316">    }</span>

    public List&lt;Value&gt; getArgumentValues() {
<span class="nc" id="L319">        validateStackFrame();</span>
<span class="nc" id="L320">        MethodImpl mmm = (MethodImpl)location.method();</span>
<span class="nc" id="L321">        List&lt;String&gt; argSigs = mmm.argumentSignatures();</span>
<span class="nc" id="L322">        int count = argSigs.size();</span>
<span class="nc" id="L323">        JDWP.StackFrame.GetValues.SlotInfo[] slots =</span>
                           new JDWP.StackFrame.GetValues.SlotInfo[count];

        int slot;
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (mmm.isStatic()) {</span>
<span class="nc" id="L328">            slot = 0;</span>
        } else {
<span class="nc" id="L330">            slot = 1;</span>
        }
<span class="nc bnc" id="L332" title="All 2 branches missed.">        for (int ii = 0; ii &lt; count; ++ii) {</span>
<span class="nc" id="L333">            char sigChar = argSigs.get(ii).charAt(0);</span>
<span class="nc" id="L334">            slots[ii] = new JDWP.StackFrame.GetValues.SlotInfo(slot++,(byte)sigChar);</span>
<span class="nc bnc" id="L335" title="All 4 branches missed.">            if (sigChar == 'J' || sigChar == 'D') {</span>
<span class="nc" id="L336">                slot++;</span>
            }
        }

        PacketStream ps;

        /* protect against defunct frame id */
<span class="nc" id="L343">        synchronized (vm.state()) {</span>
<span class="nc" id="L344">            validateStackFrame();</span>
<span class="nc" id="L345">            ps = JDWP.StackFrame.GetValues.enqueueCommand(vm, thread, id, slots);</span>
<span class="nc" id="L346">        }</span>

        ValueImpl[] values;
        try {
<span class="nc" id="L350">            values = JDWP.StackFrame.GetValues.waitForReply(vm, ps).values;</span>
<span class="nc" id="L351">        } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            switch (exc.errorCode()) {</span>
                case JDWP.Error.INVALID_FRAMEID:
                case JDWP.Error.THREAD_NOT_SUSPENDED:
                case JDWP.Error.INVALID_THREAD:
<span class="nc" id="L356">                    throw new InvalidStackFrameException();</span>
                default:
<span class="nc" id="L358">                    throw exc.toJDIException();</span>
            }
<span class="nc" id="L360">        }</span>

<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (count != values.length) {</span>
<span class="nc" id="L363">            throw new InternalException(</span>
                      &quot;Wrong number of values returned from target VM&quot;);
        }
<span class="nc" id="L366">        return Arrays.asList((Value[])values);</span>
    }

    void pop() throws IncompatibleThreadStateException {
<span class="nc" id="L370">        validateStackFrame();</span>
        // flush caches and disable caching until command completion
<span class="nc" id="L372">        CommandSender sender =</span>
<span class="nc" id="L373">            new CommandSender() {</span>
                public PacketStream send() {
<span class="nc" id="L375">                    return JDWP.StackFrame.PopFrames.enqueueCommand(vm,</span>
<span class="nc" id="L376">                                 thread, id);</span>
                }
        };
        try {
<span class="nc" id="L380">            PacketStream stream = thread.sendResumingCommand(sender);</span>
<span class="nc" id="L381">            JDWP.StackFrame.PopFrames.waitForReply(vm, stream);</span>
<span class="nc" id="L382">        } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L383" title="All 4 branches missed.">            switch (exc.errorCode()) {</span>
            case JDWP.Error.THREAD_NOT_SUSPENDED:
<span class="nc" id="L385">                throw new IncompatibleThreadStateException(</span>
                         &quot;Thread not current or suspended&quot;);
            case JDWP.Error.INVALID_THREAD:   /* zombie */
<span class="nc" id="L388">                throw new IncompatibleThreadStateException(&quot;zombie&quot;);</span>
            case JDWP.Error.NO_MORE_FRAMES:
<span class="nc" id="L390">                throw new InvalidStackFrameException(</span>
                         &quot;No more frames on the stack&quot;);
            default:
<span class="nc" id="L393">                throw exc.toJDIException();</span>
            }
<span class="nc" id="L395">        }</span>

        // enable caching - suspended again
<span class="nc" id="L398">        vm.state().freeze();</span>
<span class="nc" id="L399">    }</span>

    public String toString() {
<span class="nc" id="L402">       return location.toString() + &quot; in thread &quot; + thread.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>