<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConcreteMethodImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.tools.jdi</a> &gt; <span class="el_source">ConcreteMethodImpl.java</span></div><h1>ConcreteMethodImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.tools.jdi;

import com.sun.jdi.*;

import java.util.List;
import java.util.Map;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Collections;
import java.lang.ref.SoftReference;

/**
 * Represents methods with method bodies.
 * That is, non-native non-abstract methods.
 * Private to MethodImpl.
 */
public class ConcreteMethodImpl extends MethodImpl {

    /*
     * A subset of the line number info that is softly cached
     */
    static private class SoftLocationXRefs {
        final String stratumID;   // The stratum of this information
        final Map&lt;Integer, List&lt;Location&gt;&gt; lineMapper;     // Maps line number to location(s)
        final List&lt;Location&gt; lineLocations; // List of locations ordered by code index

        /*
         * Note: these do not necessarily correspond to
         * the line numbers of the first and last elements
         * in the lineLocations list. Use these only for bounds
         * checking and with lineMapper.
         */
        final int lowestLine;
        final int highestLine;

        SoftLocationXRefs(String stratumID, Map&lt;Integer, List&lt;Location&gt;&gt; lineMapper, List&lt;Location&gt; lineLocations,
<span class="nc" id="L64">                     int lowestLine, int highestLine) {</span>
<span class="nc" id="L65">            this.stratumID = stratumID;</span>
<span class="nc" id="L66">            this.lineMapper = Collections.unmodifiableMap(lineMapper);</span>
<span class="nc" id="L67">            this.lineLocations =</span>
<span class="nc" id="L68">                Collections.unmodifiableList(lineLocations);</span>
<span class="nc" id="L69">            this.lowestLine = lowestLine;</span>
<span class="nc" id="L70">            this.highestLine = highestLine;</span>
<span class="nc" id="L71">        }</span>
    }

<span class="nc" id="L74">    private Location location = null;</span>
    private SoftReference&lt;SoftLocationXRefs&gt; softBaseLocationXRefsRef;
    private SoftReference&lt;SoftLocationXRefs&gt; softOtherLocationXRefsRef;
<span class="nc" id="L77">    private SoftReference&lt;List&lt;LocalVariable&gt;&gt; variablesRef = null;</span>
<span class="nc" id="L78">    private boolean absentVariableInformation = false;</span>
<span class="nc" id="L79">    private long firstIndex = -1;</span>
<span class="nc" id="L80">    private long lastIndex = -1;</span>
<span class="nc" id="L81">    private SoftReference&lt;byte[]&gt; bytecodesRef = null;</span>
<span class="nc" id="L82">    private int argSlotCount = -1;</span>

    ConcreteMethodImpl(VirtualMachine vm, ReferenceTypeImpl declaringType,
                       long ref,
                       String name, String signature,
                       String genericSignature, int modifiers) {

        // The generic signature is set when this is created
<span class="nc" id="L90">        super(vm, declaringType, ref, name, signature,</span>
              genericSignature, modifiers);
<span class="nc" id="L92">    }</span>

    public Location location() {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (location == null) {</span>
<span class="nc" id="L96">            getBaseLocations();</span>
        }
<span class="nc" id="L98">        return location;</span>
    }

    List&lt;Location&gt; sourceNameFilter(List&lt;Location&gt; list,
                          SDE.Stratum stratum,
                          String sourceName)
                            throws AbsentInformationException {
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (sourceName == null) {</span>
<span class="nc" id="L106">            return list;</span>
        } else {
            /* needs sourceName filteration */
<span class="nc" id="L109">            List&lt;Location&gt; locs = new ArrayList&lt;Location&gt;();</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            for (Location loc : list) {</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">                if (((LocationImpl)loc).sourceName(stratum).equals(sourceName)) {</span>
<span class="nc" id="L112">                    locs.add(loc);</span>
                }
<span class="nc" id="L114">            }</span>
<span class="nc" id="L115">            return locs;</span>
        }
    }

    List&lt;Location&gt; allLineLocations(SDE.Stratum stratum,
                          String sourceName)
                            throws AbsentInformationException {
<span class="nc" id="L122">        List&lt;Location&gt; lineLocations = getLocations(stratum).lineLocations;</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (lineLocations.size() == 0) {</span>
<span class="nc" id="L125">            throw new AbsentInformationException();</span>
        }

<span class="nc" id="L128">        return Collections.unmodifiableList(</span>
<span class="nc" id="L129">          sourceNameFilter(lineLocations, stratum, sourceName));</span>
    }

    List&lt;Location&gt; locationsOfLine(SDE.Stratum stratum,
                         String sourceName,
                         int lineNumber)
                            throws AbsentInformationException {
<span class="nc" id="L136">        SoftLocationXRefs info = getLocations(stratum);</span>

<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (info.lineLocations.size() == 0) {</span>
<span class="nc" id="L139">            throw new AbsentInformationException();</span>
        }

        /*
         * Find the locations which match the line number
         * passed in.
         */
<span class="nc" id="L146">        List&lt;Location&gt; list = info.lineMapper.get(new Integer(lineNumber));</span>

<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (list == null) {</span>
<span class="nc" id="L149">            list = new ArrayList&lt;Location&gt;(0);</span>
        }
<span class="nc" id="L151">        return Collections.unmodifiableList(</span>
<span class="nc" id="L152">          sourceNameFilter(list, stratum, sourceName));</span>
    }


    public Location locationOfCodeIndex(long codeIndex) {
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (firstIndex == -1) {</span>
<span class="nc" id="L158">            getBaseLocations();</span>
        }

        /*
         * Check for invalid code index.
         */
<span class="nc bnc" id="L164" title="All 4 branches missed.">        if (codeIndex &lt; firstIndex || codeIndex &gt; lastIndex) {</span>
<span class="nc" id="L165">            return null;</span>
        }

<span class="nc" id="L168">        return new LocationImpl(virtualMachine(), this, codeIndex);</span>
    }


    LineInfo codeIndexToLineInfo(SDE.Stratum stratum,
                                 long codeIndex) {
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (firstIndex == -1) {</span>
<span class="nc" id="L175">            getBaseLocations();</span>
        }

        /*
         * Check for invalid code index.
         */
<span class="nc bnc" id="L181" title="All 4 branches missed.">        if (codeIndex &lt; firstIndex || codeIndex &gt; lastIndex) {</span>
<span class="nc" id="L182">            throw new InternalError(</span>
                    &quot;Location with invalid code index&quot;);
        }

<span class="nc" id="L186">        List&lt;Location&gt; lineLocations = getLocations(stratum).lineLocations;</span>

        /*
         * Check for absent line numbers.
         */
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (lineLocations.size() == 0) {</span>
<span class="nc" id="L192">            return super.codeIndexToLineInfo(stratum, codeIndex);</span>
        }

<span class="nc" id="L195">        Iterator&lt;Location&gt; iter = lineLocations.iterator();</span>
        /*
         * Treat code before the beginning of the first line table
         * entry as part of the first line.  javac will generate
         * code like this for some local classes. This &quot;prolog&quot;
         * code contains assignments from locals in the enclosing
         * scope to synthetic fields in the local class.  Same for
         * other language prolog code.
         */
<span class="nc" id="L204">        LocationImpl bestMatch = (LocationImpl)iter.next();</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L206">            LocationImpl current = (LocationImpl)iter.next();</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (current.codeIndex() &gt; codeIndex) {</span>
<span class="nc" id="L208">                break;</span>
            }
<span class="nc" id="L210">            bestMatch = current;</span>
<span class="nc" id="L211">        }</span>
<span class="nc" id="L212">        return bestMatch.getLineInfo(stratum);</span>
    }


    public List&lt;LocalVariable&gt; variables() throws AbsentInformationException {
<span class="nc" id="L217">        return getVariables();</span>
    }

    public List&lt;LocalVariable&gt; variablesByName(String name) throws AbsentInformationException {
<span class="nc" id="L221">        List&lt;LocalVariable&gt; variables = getVariables();</span>

<span class="nc" id="L223">        List&lt;LocalVariable&gt; retList = new ArrayList&lt;LocalVariable&gt;(2);</span>
<span class="nc" id="L224">        Iterator&lt;LocalVariable&gt; iter = variables.iterator();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        while(iter.hasNext()) {</span>
<span class="nc" id="L226">            LocalVariable variable = iter.next();</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (variable.name().equals(name)) {</span>
<span class="nc" id="L228">                retList.add(variable);</span>
            }
<span class="nc" id="L230">        }</span>
<span class="nc" id="L231">        return retList;</span>
    }

    public List&lt;LocalVariable&gt; arguments() throws AbsentInformationException {
<span class="nc" id="L235">        List&lt;LocalVariable&gt; variables = getVariables();</span>

<span class="nc" id="L237">        List&lt;LocalVariable&gt; retList = new ArrayList&lt;LocalVariable&gt;(variables.size());</span>
<span class="nc" id="L238">        Iterator&lt;LocalVariable&gt; iter = variables.iterator();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        while(iter.hasNext()) {</span>
<span class="nc" id="L240">            LocalVariable variable = iter.next();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            if (variable.isArgument()) {</span>
<span class="nc" id="L242">                retList.add(variable);</span>
            }
<span class="nc" id="L244">        }</span>
<span class="nc" id="L245">        return retList;</span>
    }

    public byte[] bytecodes() {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        byte[] bytecodes = (bytecodesRef == null) ? null :</span>
<span class="nc" id="L250">                                     bytecodesRef.get();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (bytecodes == null) {</span>
            try {
<span class="nc" id="L253">                bytecodes = JDWP.Method.Bytecodes.</span>
<span class="nc" id="L254">                                 process(vm, declaringType, ref).bytes;</span>
<span class="nc" id="L255">            } catch (JDWPException exc) {</span>
<span class="nc" id="L256">                throw exc.toJDIException();</span>
<span class="nc" id="L257">            }</span>
<span class="nc" id="L258">            bytecodesRef = new SoftReference&lt;byte[]&gt;(bytecodes);</span>
        }
        /*
         * Arrays are always modifiable, so it is a little unsafe
         * to return the cached bytecodes directly; instead, we
         * make a clone at the cost of using more memory.
         */
<span class="nc" id="L265">        return bytecodes.clone();</span>
    }

    int argSlotCount() throws AbsentInformationException {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (argSlotCount == -1) {</span>
<span class="nc" id="L270">            getVariables();</span>
        }
<span class="nc" id="L272">        return argSlotCount;</span>
    }

    private SoftLocationXRefs getLocations(SDE.Stratum stratum) {
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (stratum.isJava()) {</span>
<span class="nc" id="L277">            return getBaseLocations();</span>
        }
<span class="nc" id="L279">        String stratumID = stratum.id();</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        SoftLocationXRefs info =</span>
            (softOtherLocationXRefsRef == null) ? null :
<span class="nc" id="L282">               softOtherLocationXRefsRef.get();</span>
<span class="nc bnc" id="L283" title="All 4 branches missed.">        if (info != null &amp;&amp; info.stratumID.equals(stratumID)) {</span>
<span class="nc" id="L284">            return info;</span>
        }

<span class="nc" id="L287">        List&lt;Location&gt; lineLocations = new ArrayList&lt;Location&gt;();</span>
<span class="nc" id="L288">        Map&lt;Integer, List&lt;Location&gt;&gt; lineMapper = new HashMap&lt;Integer, List&lt;Location&gt;&gt;();</span>
<span class="nc" id="L289">        int lowestLine = -1;</span>
<span class="nc" id="L290">        int highestLine = -1;</span>
<span class="nc" id="L291">        SDE.LineStratum lastLineStratum = null;</span>
<span class="nc" id="L292">        SDE.Stratum baseStratum =</span>
<span class="nc" id="L293">            declaringType.stratum(SDE.BASE_STRATUM_NAME);</span>
<span class="nc" id="L294">        Iterator&lt;Location&gt; it = getBaseLocations().lineLocations.iterator();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        while(it.hasNext()) {</span>
<span class="nc" id="L296">            LocationImpl loc = (LocationImpl)it.next();</span>
<span class="nc" id="L297">            int baseLineNumber = loc.lineNumber(baseStratum);</span>
<span class="nc" id="L298">            SDE.LineStratum lineStratum =</span>
<span class="nc" id="L299">                  stratum.lineStratum(declaringType,</span>
                                      baseLineNumber);

<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (lineStratum == null) {</span>
                // location not mapped in this stratum
<span class="nc" id="L304">                continue;</span>
            }

<span class="nc" id="L307">            int lineNumber = lineStratum.lineNumber();</span>

            // remove unmapped and dup lines
<span class="nc bnc" id="L310" title="All 2 branches missed.">            if ((lineNumber != -1) &amp;&amp;</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                          (!lineStratum.equals(lastLineStratum))) {</span>
<span class="nc" id="L312">                lastLineStratum = lineStratum;</span>

                // Remember the largest/smallest line number
<span class="nc bnc" id="L315" title="All 2 branches missed.">                if (lineNumber &gt; highestLine) {</span>
<span class="nc" id="L316">                    highestLine = lineNumber;</span>
                }
<span class="nc bnc" id="L318" title="All 4 branches missed.">                if ((lineNumber &lt; lowestLine) || (lowestLine == -1)) {</span>
<span class="nc" id="L319">                    lowestLine = lineNumber;</span>
                }

<span class="nc" id="L322">                loc.addStratumLineInfo(</span>
                  new StratumLineInfo(stratumID,
                                      lineNumber,
<span class="nc" id="L325">                                      lineStratum.sourceName(),</span>
<span class="nc" id="L326">                                      lineStratum.sourcePath()));</span>

                // Add to the location list
<span class="nc" id="L329">                lineLocations.add(loc);</span>

                // Add to the line -&gt; locations map
<span class="nc" id="L332">                Integer key = new Integer(lineNumber);</span>
<span class="nc" id="L333">                List&lt;Location&gt; mappedLocs = lineMapper.get(key);</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                if (mappedLocs == null) {</span>
<span class="nc" id="L335">                    mappedLocs = new ArrayList&lt;Location&gt;(1);</span>
<span class="nc" id="L336">                    lineMapper.put(key, mappedLocs);</span>
                }
<span class="nc" id="L338">                mappedLocs.add(loc);</span>
            }
<span class="nc" id="L340">        }</span>

<span class="nc" id="L342">        info = new SoftLocationXRefs(stratumID,</span>
                                lineMapper, lineLocations,
                                lowestLine, highestLine);
<span class="nc" id="L345">        softOtherLocationXRefsRef = new SoftReference&lt;SoftLocationXRefs&gt;(info);</span>
<span class="nc" id="L346">        return info;</span>
    }

    private SoftLocationXRefs getBaseLocations() {
<span class="nc bnc" id="L350" title="All 2 branches missed.">        SoftLocationXRefs info = (softBaseLocationXRefsRef == null) ? null :</span>
<span class="nc" id="L351">                                     softBaseLocationXRefsRef.get();</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (info != null) {</span>
<span class="nc" id="L353">            return info;</span>
        }

<span class="nc" id="L356">        JDWP.Method.LineTable lntab = null;</span>
        try {
<span class="nc" id="L358">            lntab = JDWP.Method.LineTable.process(vm, declaringType, ref);</span>
<span class="nc" id="L359">        } catch (JDWPException exc) {</span>
            /*
             * Note: the absent info error shouldn't happen here
             * because the first and last index are always available.
             */
<span class="nc" id="L364">            throw exc.toJDIException();</span>
<span class="nc" id="L365">        }</span>

<span class="nc" id="L367">        int count  = lntab.lines.length;</span>

<span class="nc" id="L369">        List&lt;Location&gt; lineLocations = new ArrayList&lt;Location&gt;(count);</span>
<span class="nc" id="L370">        Map&lt;Integer, List&lt;Location&gt;&gt;lineMapper = new HashMap&lt;Integer, List&lt;Location&gt;&gt;();</span>
<span class="nc" id="L371">        int lowestLine = -1;</span>
<span class="nc" id="L372">        int highestLine = -1;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L374">            long bci = lntab.lines[i].lineCodeIndex;</span>
<span class="nc" id="L375">            int lineNumber = lntab.lines[i].lineNumber;</span>

            /*
             * Some compilers will point multiple consecutive
             * lines at the same location. We need to choose
             * one of them so that we can consistently map back
             * and forth between line and location. So we choose
             * to record only the last line entry at a particular
             * location.
             */
<span class="nc bnc" id="L385" title="All 4 branches missed.">            if ((i + 1 == count) || (bci != lntab.lines[i+1].lineCodeIndex)) {</span>
                // Remember the largest/smallest line number
<span class="nc bnc" id="L387" title="All 2 branches missed.">                if (lineNumber &gt; highestLine) {</span>
<span class="nc" id="L388">                    highestLine = lineNumber;</span>
                }
<span class="nc bnc" id="L390" title="All 4 branches missed.">                if ((lineNumber &lt; lowestLine) || (lowestLine == -1)) {</span>
<span class="nc" id="L391">                    lowestLine = lineNumber;</span>
                }
<span class="nc" id="L393">                LocationImpl loc =</span>
<span class="nc" id="L394">                    new LocationImpl(virtualMachine(), this, bci);</span>
<span class="nc" id="L395">                loc.addBaseLineInfo(</span>
                    new BaseLineInfo(lineNumber, declaringType));

                // Add to the location list
<span class="nc" id="L399">                lineLocations.add(loc);</span>

                // Add to the line -&gt; locations map
<span class="nc" id="L402">                Integer key = new Integer(lineNumber);</span>
<span class="nc" id="L403">                List&lt;Location&gt; mappedLocs = lineMapper.get(key);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                if (mappedLocs == null) {</span>
<span class="nc" id="L405">                    mappedLocs = new ArrayList&lt;Location&gt;(1);</span>
<span class="nc" id="L406">                    lineMapper.put(key, mappedLocs);</span>
                }
<span class="nc" id="L408">                mappedLocs.add(loc);</span>
            }
        }

        /*
         * firstIndex, lastIndex, and startLocation need to be
         * retrieved only once since they are strongly referenced.
         */
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (location == null) {</span>
<span class="nc" id="L417">            firstIndex = lntab.start;</span>
<span class="nc" id="L418">            lastIndex = lntab.end;</span>
            /*
             * The startLocation is the first one in the
             * location list if we have one;
             * otherwise, we construct a location for a
             * method start with no line info
             */
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (count &gt; 0) {</span>
<span class="nc" id="L426">                location = lineLocations.get(0);</span>
            } else {
<span class="nc" id="L428">                location = new LocationImpl(virtualMachine(), this,</span>
                                            firstIndex);
            }
        }

<span class="nc" id="L433">        info = new SoftLocationXRefs(SDE.BASE_STRATUM_NAME,</span>
                                lineMapper, lineLocations,
                                lowestLine, highestLine);
<span class="nc" id="L436">        softBaseLocationXRefsRef = new SoftReference&lt;SoftLocationXRefs&gt;(info);</span>
<span class="nc" id="L437">        return info;</span>
    }

    private List&lt;LocalVariable&gt; getVariables1_4() throws AbsentInformationException {
<span class="nc" id="L441">        JDWP.Method.VariableTable vartab = null;</span>
        try {
<span class="nc" id="L443">            vartab = JDWP.Method.VariableTable.</span>
<span class="nc" id="L444">                                     process(vm, declaringType, ref);</span>
<span class="nc" id="L445">        } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (exc.errorCode() == JDWP.Error.ABSENT_INFORMATION) {</span>
<span class="nc" id="L447">                absentVariableInformation = true;</span>
<span class="nc" id="L448">                throw new AbsentInformationException();</span>
            } else {
<span class="nc" id="L450">                throw exc.toJDIException();</span>
            }
<span class="nc" id="L452">        }</span>

        // Get the number of slots used by argument variables
<span class="nc" id="L455">        argSlotCount = vartab.argCnt;</span>
<span class="nc" id="L456">        int count = vartab.slots.length;</span>
<span class="nc" id="L457">        List&lt;LocalVariable&gt; variables = new ArrayList&lt;LocalVariable&gt;(count);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        for (int i=0; i&lt;count; i++) {</span>
<span class="nc" id="L459">            JDWP.Method.VariableTable.SlotInfo si = vartab.slots[i];</span>

            /*
             * Skip &quot;this*&quot; entries because they are never real
             * variables from the JLS perspective.
             */
<span class="nc bnc" id="L465" title="All 4 branches missed.">            if (!si.name.startsWith(&quot;this$&quot;) &amp;&amp; !si.name.equals(&quot;this&quot;)) {</span>
<span class="nc" id="L466">                Location scopeStart = new LocationImpl(virtualMachine(),</span>
                                                       this, si.codeIndex);
<span class="nc" id="L468">                Location scopeEnd =</span>
<span class="nc" id="L469">                    new LocationImpl(virtualMachine(), this,</span>
                                     si.codeIndex + si.length - 1);
<span class="nc" id="L471">                LocalVariable variable =</span>
<span class="nc" id="L472">                    new LocalVariableImpl(virtualMachine(), this,</span>
                                          si.slot, scopeStart, scopeEnd,
                                          si.name, si.signature, null);
                // Add to the variable list
<span class="nc" id="L476">                variables.add(variable);</span>
            }
        }
<span class="nc" id="L479">        return variables;</span>
    }

    private List&lt;LocalVariable&gt; getVariables1() throws AbsentInformationException {

<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (!vm.canGet1_5LanguageFeatures()) {</span>
<span class="nc" id="L485">            return getVariables1_4();</span>
        }

<span class="nc" id="L488">        JDWP.Method.VariableTableWithGeneric vartab = null;</span>
        try {
<span class="nc" id="L490">            vartab = JDWP.Method.VariableTableWithGeneric.</span>
<span class="nc" id="L491">                                     process(vm, declaringType, ref);</span>
<span class="nc" id="L492">        } catch (JDWPException exc) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            if (exc.errorCode() == JDWP.Error.ABSENT_INFORMATION) {</span>
<span class="nc" id="L494">                absentVariableInformation = true;</span>
<span class="nc" id="L495">                throw new AbsentInformationException();</span>
            } else {
<span class="nc" id="L497">                throw exc.toJDIException();</span>
            }
<span class="nc" id="L499">        }</span>

        // Get the number of slots used by argument variables
<span class="nc" id="L502">        argSlotCount = vartab.argCnt;</span>
<span class="nc" id="L503">        int count = vartab.slots.length;</span>
<span class="nc" id="L504">        List&lt;LocalVariable&gt; variables = new ArrayList&lt;LocalVariable&gt;(count);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        for (int i=0; i&lt;count; i++) {</span>
<span class="nc" id="L506">            JDWP.Method.VariableTableWithGeneric.SlotInfo si = vartab.slots[i];</span>

            /*
             * Skip &quot;this*&quot; entries because they are never real
             * variables from the JLS perspective.
             */
<span class="nc bnc" id="L512" title="All 4 branches missed.">            if (!si.name.startsWith(&quot;this$&quot;) &amp;&amp; !si.name.equals(&quot;this&quot;)) {</span>
<span class="nc" id="L513">                Location scopeStart = new LocationImpl(virtualMachine(),</span>
                                                       this, si.codeIndex);
<span class="nc" id="L515">                Location scopeEnd =</span>
<span class="nc" id="L516">                    new LocationImpl(virtualMachine(), this,</span>
                                     si.codeIndex + si.length - 1);
<span class="nc" id="L518">                LocalVariable variable =</span>
<span class="nc" id="L519">                    new LocalVariableImpl(virtualMachine(), this,</span>
                                          si.slot, scopeStart, scopeEnd,
                                          si.name, si.signature,
                                          si.genericSignature);
                // Add to the variable list
<span class="nc" id="L524">                variables.add(variable);</span>
            }
        }
<span class="nc" id="L527">        return variables;</span>
    }

    private List&lt;LocalVariable&gt; getVariables() throws AbsentInformationException {
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (absentVariableInformation) {</span>
<span class="nc" id="L532">            throw new AbsentInformationException();</span>
        }

<span class="nc bnc" id="L535" title="All 2 branches missed.">        List&lt;LocalVariable&gt; variables = (variablesRef == null) ? null :</span>
<span class="nc" id="L536">                                        variablesRef.get();</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (variables != null) {</span>
<span class="nc" id="L538">            return variables;</span>
        }
<span class="nc" id="L540">        variables = getVariables1();</span>
<span class="nc" id="L541">        variables = Collections.unmodifiableList(variables);</span>
<span class="nc" id="L542">        variablesRef = new SoftReference&lt;List&lt;LocalVariable&gt;&gt;(variables);</span>
<span class="nc" id="L543">        return variables;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>