<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Main.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.jar</a> &gt; <span class="el_source">Main.java</span></div><h1>Main.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.jar;

import java.io.*;
import java.nio.file.Path;
import java.nio.file.Files;
import java.util.*;
import java.util.zip.*;
import java.util.jar.*;
import java.util.jar.Pack200.*;
import java.util.jar.Manifest;
import java.text.MessageFormat;
import sun.misc.JarIndex;
import static sun.misc.JarIndex.INDEX_NAME;
import static java.util.jar.JarFile.MANIFEST_NAME;
import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;

/**
 * This class implements a simple utility for creating files in the JAR
 * (Java Archive) file format. The JAR format is based on the ZIP file
 * format, with optional meta-information stored in a MANIFEST entry.
 */
<span class="fc bfc" id="L47" title="All 2 branches covered.">public</span>
class Main {
    String program;
    PrintStream out, err;
    String fname, mname, ename;
<span class="fc" id="L52">    String zname = &quot;&quot;;</span>
    String[] files;
<span class="fc" id="L54">    String rootjar = null;</span>

    // An entryName(path)-&gt;File map generated during &quot;expand&quot;, it helps to
    // decide whether or not an existing entry in a jar file needs to be
    // replaced, during the &quot;update&quot; operation.
<span class="fc" id="L59">    Map&lt;String, File&gt; entryMap = new HashMap&lt;String, File&gt;();</span>

    // All files need to be added/updated.
<span class="fc" id="L62">    Set&lt;File&gt; entries = new LinkedHashSet&lt;File&gt;();</span>

    // Directories specified by &quot;-C&quot; operation.
<span class="fc" id="L65">    Set&lt;String&gt; paths = new HashSet&lt;String&gt;();</span>

    /*
     * cflag: create
     * uflag: update
     * xflag: xtract
     * tflag: table
     * vflag: verbose
     * flag0: no zip compression (store only)
     * Mflag: DO NOT generate a manifest file (just ZIP)
     * iflag: generate jar index
     * nflag: Perform jar normalization at the end
     */
    boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, nflag;

    static final String MANIFEST_DIR = &quot;META-INF/&quot;;
    static final String VERSION = &quot;1.0&quot;;

    private static ResourceBundle rsrc;

    /**
     * If true, maintain compatibility with JDK releases prior to 6.0 by
     * timestamping extracted files with the time at which they are extracted.
     * Default is to use the time given in the archive.
     */
<span class="fc" id="L90">    private static final boolean useExtractionTime =</span>
<span class="fc" id="L91">        Boolean.getBoolean(&quot;sun.tools.jar.useExtractionTime&quot;);</span>

    /**
     * Initialize ResourceBundle
     */
    static {
        try {
<span class="fc" id="L98">            rsrc = ResourceBundle.getBundle(&quot;sun.tools.jarresources.jar&quot;);</span>
<span class="nc" id="L99">        } catch (MissingResourceException e) {</span>
<span class="nc" id="L100">            throw new Error(&quot;Fatal: Resource for jar is missing&quot;);</span>
<span class="fc" id="L101">        }</span>
<span class="fc" id="L102">    }</span>

    private String getMsg(String key) {
        try {
<span class="fc" id="L106">            return (rsrc.getString(key));</span>
<span class="nc" id="L107">        } catch (MissingResourceException e) {</span>
<span class="nc" id="L108">            throw new Error(&quot;Error in message file&quot;);</span>
        }
    }

    private String formatMsg(String key, String arg) {
<span class="fc" id="L113">        String msg = getMsg(key);</span>
<span class="fc" id="L114">        String[] args = new String[1];</span>
<span class="fc" id="L115">        args[0] = arg;</span>
<span class="fc" id="L116">        return MessageFormat.format(msg, (Object[]) args);</span>
    }

    private String formatMsg2(String key, String arg, String arg1) {
<span class="fc" id="L120">        String msg = getMsg(key);</span>
<span class="fc" id="L121">        String[] args = new String[2];</span>
<span class="fc" id="L122">        args[0] = arg;</span>
<span class="fc" id="L123">        args[1] = arg1;</span>
<span class="fc" id="L124">        return MessageFormat.format(msg, (Object[]) args);</span>
    }

<span class="fc" id="L127">    public Main(PrintStream out, PrintStream err, String program) {</span>
<span class="fc" id="L128">        this.out = out;</span>
<span class="fc" id="L129">        this.err = err;</span>
<span class="fc" id="L130">        this.program = program;</span>
<span class="fc" id="L131">    }</span>

    /**
     * Creates a new empty temporary file in the same directory as the
     * specified file.  A variant of File.createTempFile.
     */
    private static File createTempFileInSameDirectoryAs(File file)
        throws IOException {
<span class="fc" id="L139">        File dir = file.getParentFile();</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (dir == null)</span>
<span class="fc" id="L141">            dir = new File(&quot;.&quot;);</span>
<span class="fc" id="L142">        return File.createTempFile(&quot;jartmp&quot;, null, dir);</span>
    }

    private boolean ok;

    /**
     * Starts main program with the specified arguments.
     */
    public synchronized boolean run(String args[]) {
<span class="fc" id="L151">        ok = true;</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (!parseArgs(args)) {</span>
<span class="nc" id="L153">            return false;</span>
        }
        try {
<span class="fc bfc" id="L156" title="All 4 branches covered.">            if (cflag || uflag) {</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">                if (fname != null) {</span>
                    // The name of the zip file as it would appear as its own
                    // zip file entry. We use this to make sure that we don't
                    // add the zip file to itself.
<span class="fc" id="L161">                    zname = fname.replace(File.separatorChar, '/');</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">                    if (zname.startsWith(&quot;./&quot;)) {</span>
<span class="nc" id="L163">                        zname = zname.substring(2);</span>
                    }
                }
            }
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (cflag) {</span>
<span class="fc" id="L168">                Manifest manifest = null;</span>
<span class="fc" id="L169">                InputStream in = null;</span>

<span class="fc bfc" id="L171" title="All 2 branches covered.">                if (!Mflag) {</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">                    if (mname != null) {</span>
<span class="fc" id="L173">                        in = new FileInputStream(mname);</span>
<span class="fc" id="L174">                        manifest = new Manifest(new BufferedInputStream(in));</span>
                    } else {
<span class="fc" id="L176">                        manifest = new Manifest();</span>
                    }
<span class="fc" id="L178">                    addVersion(manifest);</span>
<span class="fc" id="L179">                    addCreatedBy(manifest);</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">                    if (isAmbiguousMainClass(manifest)) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                        if (in != null) {</span>
<span class="nc" id="L182">                            in.close();</span>
                        }
<span class="nc" id="L184">                        return false;</span>
                    }
<span class="fc bfc" id="L186" title="All 2 branches covered.">                    if (ename != null) {</span>
<span class="fc" id="L187">                        addMainClass(manifest, ename);</span>
                    }
                }
                OutputStream out;
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">                if (fname != null) {</span>
<span class="fc" id="L192">                    out = new FileOutputStream(fname);</span>
                } else {
<span class="nc" id="L194">                    out = new FileOutputStream(FileDescriptor.out);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">                    if (vflag) {</span>
                        // Disable verbose output so that it does not appear
                        // on stdout along with file data
                        // error(&quot;Warning: -v option ignored&quot;);
<span class="nc" id="L199">                        vflag = false;</span>
                    }
                }
<span class="fc" id="L202">                File tmpfile = null;</span>
<span class="fc" id="L203">                final OutputStream finalout = out;</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                final String tmpbase = (fname == null)</span>
                        ? &quot;tmpjar&quot;
<span class="fc" id="L206">                        : fname.substring(fname.indexOf(File.separatorChar) + 1);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">                if (nflag) {</span>
<span class="fc" id="L208">                    tmpfile = createTemporaryFile(tmpbase, &quot;.jar&quot;);</span>
<span class="fc" id="L209">                    out = new FileOutputStream(tmpfile);</span>
                }
<span class="fc" id="L211">                expand(null, files, false);</span>
<span class="fc" id="L212">                create(new BufferedOutputStream(out, 4096), manifest);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">                if (in != null) {</span>
<span class="fc" id="L214">                    in.close();</span>
                }
<span class="fc" id="L216">                out.close();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                if(nflag) {</span>
<span class="fc" id="L218">                    JarFile jarFile = null;</span>
<span class="fc" id="L219">                    File packFile = null;</span>
<span class="fc" id="L220">                    JarOutputStream jos = null;</span>
                    try {
<span class="nc" id="L222">                        Packer packer = Pack200.newPacker();</span>
<span class="nc" id="L223">                        Map&lt;String, String&gt; p = packer.properties();</span>
<span class="nc" id="L224">                        p.put(Packer.EFFORT, &quot;1&quot;); // Minimal effort to conserve CPU</span>
<span class="nc" id="L225">                        jarFile = new JarFile(tmpfile.getCanonicalPath());</span>
<span class="nc" id="L226">                        packFile = createTemporaryFile(tmpbase, &quot;.pack&quot;);</span>
<span class="nc" id="L227">                        out = new FileOutputStream(packFile);</span>
<span class="nc" id="L228">                        packer.pack(jarFile, out);</span>
<span class="nc" id="L229">                        jos = new JarOutputStream(finalout);</span>
<span class="nc" id="L230">                        Unpacker unpacker = Pack200.newUnpacker();</span>
<span class="nc" id="L231">                        unpacker.unpack(packFile, jos);</span>
<span class="nc" id="L232">                    } catch (IOException ioe) {</span>
<span class="nc" id="L233">                        fatalError(ioe);</span>
                    } finally {
<span class="pc bpc" id="L235" title="5 of 6 branches missed.">                        if (jarFile != null) {</span>
<span class="nc" id="L236">                            jarFile.close();</span>
                        }
<span class="pc bpc" id="L238" title="5 of 6 branches missed.">                        if (out != null) {</span>
<span class="pc" id="L239">                            out.close();</span>
                        }
<span class="pc bpc" id="L241" title="5 of 6 branches missed.">                        if (jos != null) {</span>
<span class="nc" id="L242">                            jos.close();</span>
                        }
<span class="pc bpc" id="L244" title="10 of 12 branches missed.">                        if (tmpfile != null &amp;&amp; tmpfile.exists()) {</span>
<span class="pc" id="L245">                            tmpfile.delete();</span>
                        }
<span class="pc bpc" id="L247" title="11 of 12 branches missed.">                        if (packFile != null &amp;&amp; packFile.exists()) {</span>
<span class="pc" id="L248">                            packFile.delete();</span>
                        }
                    }
                }
<span class="fc bfc" id="L252" title="All 2 branches covered.">            } else if (uflag) {</span>
<span class="fc" id="L253">                File inputFile = null, tmpFile = null;</span>
                FileInputStream in;
                FileOutputStream out;
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">                if (fname != null) {</span>
<span class="fc" id="L257">                    inputFile = new File(fname);</span>
<span class="fc" id="L258">                    tmpFile = createTempFileInSameDirectoryAs(inputFile);</span>
<span class="fc" id="L259">                    in = new FileInputStream(inputFile);</span>
<span class="fc" id="L260">                    out = new FileOutputStream(tmpFile);</span>
                } else {
<span class="nc" id="L262">                    in = new FileInputStream(FileDescriptor.in);</span>
<span class="nc" id="L263">                    out = new FileOutputStream(FileDescriptor.out);</span>
<span class="nc" id="L264">                    vflag = false;</span>
                }
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">                InputStream manifest = (!Mflag &amp;&amp; (mname != null)) ?</span>
                    (new FileInputStream(mname)) : null;
<span class="fc" id="L268">                expand(null, files, true);</span>
<span class="fc" id="L269">                boolean updateOk = update(in, new BufferedOutputStream(out),</span>
                                          manifest, null);
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">                if (ok) {</span>
<span class="fc" id="L272">                    ok = updateOk;</span>
                }
<span class="fc" id="L274">                in.close();</span>
<span class="fc" id="L275">                out.close();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">                if (manifest != null) {</span>
<span class="fc" id="L277">                    manifest.close();</span>
                }
<span class="pc bpc" id="L279" title="2 of 4 branches missed.">                if (ok &amp;&amp; fname != null) {</span>
                    // on Win32, we need this delete
<span class="fc" id="L281">                    inputFile.delete();</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">                    if (!tmpFile.renameTo(inputFile)) {</span>
<span class="nc" id="L283">                        tmpFile.delete();</span>
<span class="nc" id="L284">                        throw new IOException(getMsg(&quot;error.write.file&quot;));</span>
                    }
<span class="fc" id="L286">                    tmpFile.delete();</span>
                }
<span class="fc bfc" id="L288" title="All 2 branches covered.">            } else if (tflag) {</span>
<span class="fc" id="L289">                replaceFSC(files);</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">                if (fname != null) {</span>
<span class="fc" id="L291">                    list(fname, files);</span>
                } else {
<span class="nc" id="L293">                    InputStream in = new FileInputStream(FileDescriptor.in);</span>
                    try{
<span class="nc" id="L295">                        list(new BufferedInputStream(in), files);</span>
                    } finally {
<span class="nc" id="L297">                        in.close();</span>
<span class="nc" id="L298">                    }</span>
<span class="nc" id="L299">                }</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">            } else if (xflag) {</span>
<span class="fc" id="L301">                replaceFSC(files);</span>
<span class="pc bpc" id="L302" title="2 of 4 branches missed.">                if (fname != null &amp;&amp; files != null) {</span>
<span class="nc" id="L303">                    extract(fname, files);</span>
                } else {
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">                    InputStream in = (fname == null)</span>
                        ? new FileInputStream(FileDescriptor.in)
                        : new FileInputStream(fname);
                    try {
<span class="fc" id="L309">                        extract(new BufferedInputStream(in), files);</span>
                    } finally {
<span class="pc" id="L311">                        in.close();</span>
<span class="fc" id="L312">                    }</span>
<span class="fc" id="L313">                }</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">            } else if (iflag) {</span>
<span class="fc" id="L315">                genIndex(rootjar, files);</span>
            }
<span class="nc" id="L317">        } catch (IOException e) {</span>
<span class="nc" id="L318">            fatalError(e);</span>
<span class="nc" id="L319">            ok = false;</span>
<span class="fc" id="L320">        } catch (Error ee) {</span>
<span class="fc" id="L321">            ee.printStackTrace();</span>
<span class="fc" id="L322">            ok = false;</span>
<span class="nc" id="L323">        } catch (Throwable t) {</span>
<span class="nc" id="L324">            t.printStackTrace();</span>
<span class="nc" id="L325">            ok = false;</span>
<span class="pc" id="L326">        }</span>
<span class="fc" id="L327">        out.flush();</span>
<span class="fc" id="L328">        err.flush();</span>
<span class="fc" id="L329">        return ok;</span>
    }

    /**
     * Parses command line arguments.
     */
    boolean parseArgs(String args[]) {
        /* Preprocess and expand @file arguments */
        try {
<span class="fc" id="L338">            args = CommandLine.parse(args);</span>
<span class="nc" id="L339">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L340">            fatalError(formatMsg(&quot;error.cant.open&quot;, e.getMessage()));</span>
<span class="nc" id="L341">            return false;</span>
<span class="nc" id="L342">        } catch (IOException e) {</span>
<span class="nc" id="L343">            fatalError(e);</span>
<span class="nc" id="L344">            return false;</span>
<span class="fc" id="L345">        }</span>
        /* parse flags */
<span class="fc" id="L347">        int count = 1;</span>
        try {
<span class="fc" id="L349">            String flags = args[0];</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            if (flags.startsWith(&quot;-&quot;)) {</span>
<span class="fc" id="L351">                flags = flags.substring(1);</span>
            }
<span class="fc bfc" id="L353" title="All 2 branches covered.">            for (int i = 0; i &lt; flags.length(); i++) {</span>
<span class="pc bpc" id="L354" title="1 of 13 branches missed.">                switch (flags.charAt(i)) {</span>
                case 'c':
<span class="pc bpc" id="L356" title="4 of 8 branches missed.">                    if (xflag || tflag || uflag || iflag) {</span>
<span class="nc" id="L357">                        usageError();</span>
<span class="nc" id="L358">                        return false;</span>
                    }
<span class="fc" id="L360">                    cflag = true;</span>
<span class="fc" id="L361">                    break;</span>
                case 'u':
<span class="pc bpc" id="L363" title="4 of 8 branches missed.">                    if (cflag || xflag || tflag || iflag) {</span>
<span class="nc" id="L364">                        usageError();</span>
<span class="nc" id="L365">                        return false;</span>
                    }
<span class="fc" id="L367">                    uflag = true;</span>
<span class="fc" id="L368">                    break;</span>
                case 'x':
<span class="pc bpc" id="L370" title="4 of 8 branches missed.">                    if (cflag || uflag || tflag || iflag) {</span>
<span class="nc" id="L371">                        usageError();</span>
<span class="nc" id="L372">                        return false;</span>
                    }
<span class="fc" id="L374">                    xflag = true;</span>
<span class="fc" id="L375">                    break;</span>
                case 't':
<span class="pc bpc" id="L377" title="4 of 8 branches missed.">                    if (cflag || uflag || xflag || iflag) {</span>
<span class="nc" id="L378">                        usageError();</span>
<span class="nc" id="L379">                        return false;</span>
                    }
<span class="fc" id="L381">                    tflag = true;</span>
<span class="fc" id="L382">                    break;</span>
                case 'M':
<span class="fc" id="L384">                    Mflag = true;</span>
<span class="fc" id="L385">                    break;</span>
                case 'v':
<span class="fc" id="L387">                    vflag = true;</span>
<span class="fc" id="L388">                    break;</span>
                case 'f':
<span class="fc" id="L390">                    fname = args[count++];</span>
<span class="fc" id="L391">                    break;</span>
                case 'm':
<span class="fc" id="L393">                    mname = args[count++];</span>
<span class="fc" id="L394">                    break;</span>
                case '0':
<span class="fc" id="L396">                    flag0 = true;</span>
<span class="fc" id="L397">                    break;</span>
                case 'i':
<span class="pc bpc" id="L399" title="4 of 8 branches missed.">                    if (cflag || uflag || xflag || tflag) {</span>
<span class="nc" id="L400">                        usageError();</span>
<span class="nc" id="L401">                        return false;</span>
                    }
                    // do not increase the counter, files will contain rootjar
<span class="fc" id="L404">                    rootjar = args[count++];</span>
<span class="fc" id="L405">                    iflag = true;</span>
<span class="fc" id="L406">                    break;</span>
                case 'n':
<span class="fc" id="L408">                    nflag = true;</span>
<span class="fc" id="L409">                    break;</span>
                case 'e':
<span class="fc" id="L411">                     ename = args[count++];</span>
<span class="fc" id="L412">                     break;</span>
                default:
<span class="nc" id="L414">                    error(formatMsg(&quot;error.illegal.option&quot;,</span>
<span class="nc" id="L415">                                String.valueOf(flags.charAt(i))));</span>
<span class="nc" id="L416">                    usageError();</span>
<span class="nc" id="L417">                    return false;</span>
                }
            }
<span class="nc" id="L420">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L421">            usageError();</span>
<span class="nc" id="L422">            return false;</span>
<span class="fc" id="L423">        }</span>
<span class="pc bpc" id="L424" title="1 of 10 branches missed.">        if (!cflag &amp;&amp; !tflag &amp;&amp; !xflag &amp;&amp; !uflag &amp;&amp; !iflag) {</span>
<span class="nc" id="L425">            error(getMsg(&quot;error.bad.option&quot;));</span>
<span class="nc" id="L426">            usageError();</span>
<span class="nc" id="L427">            return false;</span>
        }
        /* parse file arguments */
<span class="fc" id="L430">        int n = args.length - count;</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">        if (n &gt; 0) {</span>
<span class="fc" id="L432">            int k = 0;</span>
<span class="fc" id="L433">            String[] nameBuf = new String[n];</span>
            try {
<span class="fc bfc" id="L435" title="All 2 branches covered.">                for (int i = count; i &lt; args.length; i++) {</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">                    if (args[i].equals(&quot;-C&quot;)) {</span>
                        /* change the directory */
<span class="fc" id="L438">                        String dir = args[++i];</span>
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">                        dir = (dir.endsWith(File.separator) ?</span>
                               dir : (dir + File.separator));
<span class="fc" id="L441">                        dir = dir.replace(File.separatorChar, '/');</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">                        while (dir.indexOf(&quot;//&quot;) &gt; -1) {</span>
<span class="nc" id="L443">                            dir = dir.replace(&quot;//&quot;, &quot;/&quot;);</span>
                        }
<span class="fc" id="L445">                        paths.add(dir.replace(File.separatorChar, '/'));</span>
<span class="fc" id="L446">                        nameBuf[k++] = dir + args[++i];</span>
<span class="fc" id="L447">                    } else {</span>
<span class="fc" id="L448">                        nameBuf[k++] = args[i];</span>
                    }
                }
<span class="nc" id="L451">            } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L452">                usageError();</span>
<span class="nc" id="L453">                return false;</span>
<span class="fc" id="L454">            }</span>
<span class="fc" id="L455">            files = new String[k];</span>
<span class="fc" id="L456">            System.arraycopy(nameBuf, 0, files, 0, k);</span>
<span class="pc bpc" id="L457" title="1 of 4 branches missed.">        } else if (cflag &amp;&amp; (mname == null)) {</span>
<span class="nc" id="L458">            error(getMsg(&quot;error.bad.cflag&quot;));</span>
<span class="nc" id="L459">            usageError();</span>
<span class="nc" id="L460">            return false;</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">        } else if (uflag) {</span>
<span class="pc bpc" id="L462" title="3 of 4 branches missed.">            if ((mname != null) || (ename != null)) {</span>
                /* just want to update the manifest */
<span class="fc" id="L464">                return true;</span>
            } else {
<span class="nc" id="L466">                error(getMsg(&quot;error.bad.uflag&quot;));</span>
<span class="nc" id="L467">                usageError();</span>
<span class="nc" id="L468">                return false;</span>
            }
        }
<span class="fc" id="L471">        return true;</span>
    }

    /**
     * Expands list of files to process into full list of all files that
     * can be found by recursively descending directories.
     */
    void expand(File dir, String[] files, boolean isUpdate) {
<span class="fc bfc" id="L479" title="All 2 branches covered.">        if (files == null) {</span>
<span class="fc" id="L480">            return;</span>
        }
<span class="fc bfc" id="L482" title="All 2 branches covered.">        for (int i = 0; i &lt; files.length; i++) {</span>
            File f;
<span class="fc bfc" id="L484" title="All 2 branches covered.">            if (dir == null) {</span>
<span class="fc" id="L485">                f = new File(files[i]);</span>
            } else {
<span class="fc" id="L487">                f = new File(dir, files[i]);</span>
            }
<span class="fc bfc" id="L489" title="All 2 branches covered.">            if (f.isFile()) {</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">                if (entries.add(f)) {</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">                    if (isUpdate)</span>
<span class="fc" id="L492">                        entryMap.put(entryName(f.getPath()), f);</span>
                }
<span class="fc bfc" id="L494" title="All 2 branches covered.">            } else if (f.isDirectory()) {</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">                if (entries.add(f)) {</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">                    if (isUpdate) {</span>
<span class="nc" id="L497">                        String dirPath = f.getPath();</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                        dirPath = (dirPath.endsWith(File.separator)) ? dirPath :</span>
                            (dirPath + File.separator);
<span class="nc" id="L500">                        entryMap.put(entryName(dirPath), f);</span>
                    }
<span class="fc" id="L502">                    expand(f, f.list(), isUpdate);</span>
                }
            } else {
<span class="fc" id="L505">                error(formatMsg(&quot;error.nosuch.fileordir&quot;, String.valueOf(f)));</span>
<span class="fc" id="L506">                ok = false;</span>
            }
        }
<span class="fc" id="L509">    }</span>

    /**
     * Creates a new JAR file.
     */
    void create(OutputStream out, Manifest manifest)
        throws IOException
    {
<span class="fc" id="L517">        ZipOutputStream zos = new JarOutputStream(out);</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">        if (flag0) {</span>
<span class="fc" id="L519">            zos.setMethod(ZipOutputStream.STORED);</span>
        }
<span class="fc bfc" id="L521" title="All 2 branches covered.">        if (manifest != null) {</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">            if (vflag) {</span>
<span class="fc" id="L523">                output(getMsg(&quot;out.added.manifest&quot;));</span>
            }
<span class="fc" id="L525">            ZipEntry e = new ZipEntry(MANIFEST_DIR);</span>
<span class="fc" id="L526">            e.setTime(System.currentTimeMillis());</span>
<span class="fc" id="L527">            e.setSize(0);</span>
<span class="fc" id="L528">            e.setCrc(0);</span>
<span class="fc" id="L529">            zos.putNextEntry(e);</span>
<span class="fc" id="L530">            e = new ZipEntry(MANIFEST_NAME);</span>
<span class="fc" id="L531">            e.setTime(System.currentTimeMillis());</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">            if (flag0) {</span>
<span class="fc" id="L533">                crc32Manifest(e, manifest);</span>
            }
<span class="fc" id="L535">            zos.putNextEntry(e);</span>
<span class="fc" id="L536">            manifest.write(zos);</span>
<span class="fc" id="L537">            zos.closeEntry();</span>
        }
<span class="fc bfc" id="L539" title="All 2 branches covered.">        for (File file: entries) {</span>
<span class="fc" id="L540">            addFile(zos, file);</span>
<span class="fc" id="L541">        }</span>
<span class="fc" id="L542">        zos.close();</span>
<span class="fc" id="L543">    }</span>

    private char toUpperCaseASCII(char c) {
<span class="nc bnc" id="L546" title="All 4 branches missed.">        return (c &lt; 'a' || c &gt; 'z') ? c : (char) (c + 'A' - 'a');</span>
    }

    /**
     * Compares two strings for equality, ignoring case.  The second
     * argument must contain only upper-case ASCII characters.
     * We don't want case comparison to be locale-dependent (else we
     * have the notorious &quot;turkish i bug&quot;).
     */
    private boolean equalsIgnoreCase(String s, String upper) {
<span class="pc bpc" id="L556" title="1 of 4 branches missed.">        assert upper.toUpperCase(java.util.Locale.ENGLISH).equals(upper);</span>
        int len;
<span class="fc bfc" id="L558" title="All 2 branches covered.">        if ((len = s.length()) != upper.length())</span>
<span class="fc" id="L559">            return false;</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L561">            char c1 = s.charAt(i);</span>
<span class="fc" id="L562">            char c2 = upper.charAt(i);</span>
<span class="pc bpc" id="L563" title="3 of 4 branches missed.">            if (c1 != c2 &amp;&amp; toUpperCaseASCII(c1) != c2)</span>
<span class="nc" id="L564">                return false;</span>
        }
<span class="fc" id="L566">        return true;</span>
    }

    /**
     * Updates an existing jar file.
     */
    boolean update(InputStream in, OutputStream out,
                   InputStream newManifest,
                   JarIndex jarIndex) throws IOException
    {
<span class="fc" id="L576">        ZipInputStream zis = new ZipInputStream(in);</span>
<span class="fc" id="L577">        ZipOutputStream zos = new JarOutputStream(out);</span>
<span class="fc" id="L578">        ZipEntry e = null;</span>
<span class="fc" id="L579">        boolean foundManifest = false;</span>
<span class="fc" id="L580">        boolean updateOk = true;</span>

<span class="fc bfc" id="L582" title="All 2 branches covered.">        if (jarIndex != null) {</span>
<span class="fc" id="L583">            addIndex(jarIndex, zos);</span>
        }

        // put the old entries first, replace if necessary
<span class="fc bfc" id="L587" title="All 2 branches covered.">        while ((e = zis.getNextEntry()) != null) {</span>
<span class="fc" id="L588">            String name = e.getName();</span>

<span class="fc" id="L590">            boolean isManifestEntry = equalsIgnoreCase(name, MANIFEST_NAME);</span>

<span class="pc bpc" id="L592" title="4 of 8 branches missed.">            if ((jarIndex != null &amp;&amp; equalsIgnoreCase(name, INDEX_NAME))</span>
                || (Mflag &amp;&amp; isManifestEntry)) {
<span class="nc" id="L594">                continue;</span>
<span class="pc bpc" id="L595" title="2 of 6 branches missed.">            } else if (isManifestEntry &amp;&amp; ((newManifest != null) ||</span>
                        (ename != null))) {
<span class="nc" id="L597">                foundManifest = true;</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">                if (newManifest != null) {</span>
                    // Don't read from the newManifest InputStream, as we
                    // might need it below, and we can't re-read the same data
                    // twice.
<span class="nc" id="L602">                    FileInputStream fis = new FileInputStream(mname);</span>
<span class="nc" id="L603">                    boolean ambiguous = isAmbiguousMainClass(new Manifest(fis));</span>
<span class="nc" id="L604">                    fis.close();</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                    if (ambiguous) {</span>
<span class="nc" id="L606">                        return false;</span>
                    }
                }

                // Update the manifest.
<span class="nc" id="L611">                Manifest old = new Manifest(zis);</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                if (newManifest != null) {</span>
<span class="nc" id="L613">                    old.read(newManifest);</span>
                }
<span class="nc bnc" id="L615" title="All 2 branches missed.">                if (!updateManifest(old, zos)) {</span>
<span class="nc" id="L616">                    return false;</span>
                }
<span class="nc" id="L618">            } else {</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">                if (!entryMap.containsKey(name)) { // copy the old stuff</span>
                    // do our own compression
<span class="fc" id="L621">                    ZipEntry e2 = new ZipEntry(name);</span>
<span class="fc" id="L622">                    e2.setMethod(e.getMethod());</span>
<span class="fc" id="L623">                    e2.setTime(e.getTime());</span>
<span class="fc" id="L624">                    e2.setComment(e.getComment());</span>
<span class="fc" id="L625">                    e2.setExtra(e.getExtra());</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">                    if (e.getMethod() == ZipEntry.STORED) {</span>
<span class="fc" id="L627">                        e2.setSize(e.getSize());</span>
<span class="fc" id="L628">                        e2.setCrc(e.getCrc());</span>
                    }
<span class="fc" id="L630">                    zos.putNextEntry(e2);</span>
<span class="fc" id="L631">                    copy(zis, zos);</span>
<span class="fc" id="L632">                } else { // replace with the new files</span>
<span class="nc" id="L633">                    File f = entryMap.get(name);</span>
<span class="nc" id="L634">                    addFile(zos, f);</span>
<span class="nc" id="L635">                    entryMap.remove(name);</span>
<span class="nc" id="L636">                    entries.remove(f);</span>
                }
            }
<span class="fc" id="L639">        }</span>

        // add the remaining new files
<span class="fc bfc" id="L642" title="All 2 branches covered.">        for (File f: entries) {</span>
<span class="fc" id="L643">            addFile(zos, f);</span>
<span class="fc" id="L644">        }</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">        if (!foundManifest) {</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">            if (newManifest != null) {</span>
<span class="fc" id="L647">                Manifest m = new Manifest(newManifest);</span>
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">                updateOk = !isAmbiguousMainClass(m);</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">                if (updateOk) {</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                    if (!updateManifest(m, zos)) {</span>
<span class="nc" id="L651">                        updateOk = false;</span>
                    }
                }
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">            } else if (ename != null) {</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">                if (!updateManifest(new Manifest(), zos)) {</span>
<span class="nc" id="L656">                    updateOk = false;</span>
                }
            }
        }
<span class="fc" id="L660">        zis.close();</span>
<span class="fc" id="L661">        zos.close();</span>
<span class="fc" id="L662">        return updateOk;</span>
    }


    private void addIndex(JarIndex index, ZipOutputStream zos)
        throws IOException
    {
<span class="fc" id="L669">        ZipEntry e = new ZipEntry(INDEX_NAME);</span>
<span class="fc" id="L670">        e.setTime(System.currentTimeMillis());</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        if (flag0) {</span>
<span class="nc" id="L672">            CRC32OutputStream os = new CRC32OutputStream();</span>
<span class="nc" id="L673">            index.write(os);</span>
<span class="nc" id="L674">            os.updateEntry(e);</span>
        }
<span class="fc" id="L676">        zos.putNextEntry(e);</span>
<span class="fc" id="L677">        index.write(zos);</span>
<span class="fc" id="L678">        zos.closeEntry();</span>
<span class="fc" id="L679">    }</span>

    private boolean updateManifest(Manifest m, ZipOutputStream zos)
        throws IOException
    {
<span class="fc" id="L684">        addVersion(m);</span>
<span class="fc" id="L685">        addCreatedBy(m);</span>
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        if (ename != null) {</span>
<span class="nc" id="L687">            addMainClass(m, ename);</span>
        }
<span class="fc" id="L689">        ZipEntry e = new ZipEntry(MANIFEST_NAME);</span>
<span class="fc" id="L690">        e.setTime(System.currentTimeMillis());</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">        if (flag0) {</span>
<span class="nc" id="L692">            crc32Manifest(e, m);</span>
        }
<span class="fc" id="L694">        zos.putNextEntry(e);</span>
<span class="fc" id="L695">        m.write(zos);</span>
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">        if (vflag) {</span>
<span class="nc" id="L697">            output(getMsg(&quot;out.update.manifest&quot;));</span>
        }
<span class="fc" id="L699">        return true;</span>
    }


    private String entryName(String name) {
<span class="fc" id="L704">        name = name.replace(File.separatorChar, '/');</span>
<span class="fc" id="L705">        String matchPath = &quot;&quot;;</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">        for (String path : paths) {</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">            if (name.startsWith(path)</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">                &amp;&amp; (path.length() &gt; matchPath.length())) {</span>
<span class="fc" id="L709">                matchPath = path;</span>
            }
<span class="fc" id="L711">        }</span>
<span class="fc" id="L712">        name = name.substring(matchPath.length());</span>

<span class="pc bpc" id="L714" title="1 of 2 branches missed.">        if (name.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L715">            name = name.substring(1);</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">        } else if (name.startsWith(&quot;./&quot;)) {</span>
<span class="fc" id="L717">            name = name.substring(2);</span>
        }
<span class="fc" id="L719">        return name;</span>
    }

    private void addVersion(Manifest m) {
<span class="fc" id="L723">        Attributes global = m.getMainAttributes();</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">        if (global.getValue(Attributes.Name.MANIFEST_VERSION) == null) {</span>
<span class="fc" id="L725">            global.put(Attributes.Name.MANIFEST_VERSION, VERSION);</span>
        }
<span class="fc" id="L727">    }</span>

    private void addCreatedBy(Manifest m) {
<span class="fc" id="L730">        Attributes global = m.getMainAttributes();</span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (global.getValue(new Attributes.Name(&quot;Created-By&quot;)) == null) {</span>
<span class="fc" id="L732">            String javaVendor = System.getProperty(&quot;java.vendor&quot;);</span>
<span class="fc" id="L733">            String jdkVersion = System.getProperty(&quot;java.version&quot;);</span>
<span class="fc" id="L734">            global.put(new Attributes.Name(&quot;Created-By&quot;), jdkVersion + &quot; (&quot; +</span>
                        javaVendor + &quot;)&quot;);
        }
<span class="fc" id="L737">    }</span>

    private void addMainClass(Manifest m, String mainApp) {
<span class="fc" id="L740">        Attributes global = m.getMainAttributes();</span>

        // overrides any existing Main-Class attribute
<span class="fc" id="L743">        global.put(Attributes.Name.MAIN_CLASS, mainApp);</span>
<span class="fc" id="L744">    }</span>

    private boolean isAmbiguousMainClass(Manifest m) {
<span class="fc bfc" id="L747" title="All 2 branches covered.">        if (ename != null) {</span>
<span class="fc" id="L748">            Attributes global = m.getMainAttributes();</span>
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">            if ((global.get(Attributes.Name.MAIN_CLASS) != null)) {</span>
<span class="nc" id="L750">                error(getMsg(&quot;error.bad.eflag&quot;));</span>
<span class="nc" id="L751">                usageError();</span>
<span class="nc" id="L752">                return true;</span>
            }
        }
<span class="fc" id="L755">        return false;</span>
    }

    /**
     * Adds a new file entry to the ZIP output stream.
     */
    void addFile(ZipOutputStream zos, File file) throws IOException {
<span class="fc" id="L762">        String name = file.getPath();</span>
<span class="fc" id="L763">        boolean isDir = file.isDirectory();</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">        if (isDir) {</span>
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">            name = name.endsWith(File.separator) ? name :</span>
                (name + File.separator);
        }
<span class="fc" id="L768">        name = entryName(name);</span>

<span class="pc bpc" id="L770" title="2 of 6 branches missed.">        if (name.equals(&quot;&quot;) || name.equals(&quot;.&quot;) || name.equals(zname)) {</span>
<span class="fc" id="L771">            return;</span>
<span class="pc bpc" id="L772" title="1 of 6 branches missed.">        } else if ((name.equals(MANIFEST_DIR) || name.equals(MANIFEST_NAME))</span>
                   &amp;&amp; !Mflag) {
<span class="fc bfc" id="L774" title="All 2 branches covered.">            if (vflag) {</span>
<span class="fc" id="L775">                output(formatMsg(&quot;out.ignore.entry&quot;, name));</span>
            }
<span class="fc" id="L777">            return;</span>
        }

<span class="fc bfc" id="L780" title="All 2 branches covered.">        long size = isDir ? 0 : file.length();</span>

<span class="fc bfc" id="L782" title="All 2 branches covered.">        if (vflag) {</span>
<span class="fc" id="L783">            out.print(formatMsg(&quot;out.adding&quot;, name));</span>
        }
<span class="fc" id="L785">        ZipEntry e = new ZipEntry(name);</span>
<span class="fc" id="L786">        e.setTime(file.lastModified());</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">        if (size == 0) {</span>
<span class="fc" id="L788">            e.setMethod(ZipEntry.STORED);</span>
<span class="fc" id="L789">            e.setSize(0);</span>
<span class="fc" id="L790">            e.setCrc(0);</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">        } else if (flag0) {</span>
<span class="fc" id="L792">            crc32File(e, file);</span>
        }
<span class="fc" id="L794">        zos.putNextEntry(e);</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">        if (!isDir) {</span>
<span class="fc" id="L796">            copy(file, zos);</span>
        }
<span class="fc" id="L798">        zos.closeEntry();</span>
        /* report how much compression occurred. */
<span class="fc bfc" id="L800" title="All 2 branches covered.">        if (vflag) {</span>
<span class="fc" id="L801">            size = e.getSize();</span>
<span class="fc" id="L802">            long csize = e.getCompressedSize();</span>
<span class="fc" id="L803">            out.print(formatMsg2(&quot;out.size&quot;, String.valueOf(size),</span>
<span class="fc" id="L804">                        String.valueOf(csize)));</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">            if (e.getMethod() == ZipEntry.DEFLATED) {</span>
<span class="fc" id="L806">                long ratio = 0;</span>
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">                if (size != 0) {</span>
<span class="fc" id="L808">                    ratio = ((size - csize) * 100) / size;</span>
                }
<span class="fc" id="L810">                output(formatMsg(&quot;out.deflated&quot;, String.valueOf(ratio)));</span>
<span class="fc" id="L811">            } else {</span>
<span class="fc" id="L812">                output(getMsg(&quot;out.stored&quot;));</span>
            }
        }
<span class="fc" id="L815">    }</span>

    /**
     * A buffer for use only by copy(InputStream, OutputStream).
     * Not as clean as allocating a new buffer as needed by copy,
     * but significantly more efficient.
     */
<span class="fc" id="L822">    private byte[] copyBuf = new byte[8192];</span>

    /**
     * Copies all bytes from the input stream to the output stream.
     * Does not close or flush either stream.
     *
     * @param from the input stream to read from
     * @param to the output stream to write to
     * @throws IOException if an I/O error occurs
     */
    private void copy(InputStream from, OutputStream to) throws IOException {
        int n;
<span class="fc bfc" id="L834" title="All 2 branches covered.">        while ((n = from.read(copyBuf)) != -1)</span>
<span class="fc" id="L835">            to.write(copyBuf, 0, n);</span>
<span class="fc" id="L836">    }</span>

    /**
     * Copies all bytes from the input file to the output stream.
     * Does not close or flush the output stream.
     *
     * @param from the input file to read from
     * @param to the output stream to write to
     * @throws IOException if an I/O error occurs
     */
    private void copy(File from, OutputStream to) throws IOException {
<span class="fc" id="L847">        InputStream in = new FileInputStream(from);</span>
        try {
<span class="fc" id="L849">            copy(in, to);</span>
        } finally {
<span class="pc" id="L851">            in.close();</span>
<span class="fc" id="L852">        }</span>
<span class="fc" id="L853">    }</span>

    /**
     * Copies all bytes from the input stream to the output file.
     * Does not close the input stream.
     *
     * @param from the input stream to read from
     * @param to the output file to write to
     * @throws IOException if an I/O error occurs
     */
    private void copy(InputStream from, File to) throws IOException {
<span class="fc" id="L864">        OutputStream out = new FileOutputStream(to);</span>
        try {
<span class="fc" id="L866">            copy(from, out);</span>
        } finally {
<span class="pc" id="L868">            out.close();</span>
<span class="fc" id="L869">        }</span>
<span class="fc" id="L870">    }</span>

    /**
     * Computes the crc32 of a Manifest.  This is necessary when the
     * ZipOutputStream is in STORED mode.
     */
    private void crc32Manifest(ZipEntry e, Manifest m) throws IOException {
<span class="fc" id="L877">        CRC32OutputStream os = new CRC32OutputStream();</span>
<span class="fc" id="L878">        m.write(os);</span>
<span class="fc" id="L879">        os.updateEntry(e);</span>
<span class="fc" id="L880">    }</span>

    /**
     * Computes the crc32 of a File.  This is necessary when the
     * ZipOutputStream is in STORED mode.
     */
    private void crc32File(ZipEntry e, File f) throws IOException {
<span class="fc" id="L887">        CRC32OutputStream os = new CRC32OutputStream();</span>
<span class="fc" id="L888">        copy(f, os);</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">        if (os.n != f.length()) {</span>
<span class="nc" id="L890">            throw new JarException(formatMsg(</span>
<span class="nc" id="L891">                        &quot;error.incorrect.length&quot;, f.getPath()));</span>
        }
<span class="fc" id="L893">        os.updateEntry(e);</span>
<span class="fc" id="L894">    }</span>

    void replaceFSC(String files[]) {
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">        if (files != null) {</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">            for (int i = 0; i &lt; files.length; i++) {</span>
<span class="nc" id="L899">                files[i] = files[i].replace(File.separatorChar, '/');</span>
            }
        }
<span class="fc" id="L902">    }</span>

    @SuppressWarnings(&quot;serial&quot;)
    Set&lt;ZipEntry&gt; newDirSet() {
<span class="fc" id="L906">        return new HashSet&lt;ZipEntry&gt;() {</span>
            public boolean add(ZipEntry e) {
<span class="fc bfc" id="L908" title="All 4 branches covered.">                return ((e == null || useExtractionTime) ? false : super.add(e));</span>
            }};
    }

    void updateLastModifiedTime(Set&lt;ZipEntry&gt; zes) throws IOException {
<span class="fc bfc" id="L913" title="All 2 branches covered.">        for (ZipEntry ze : zes) {</span>
<span class="fc" id="L914">            long lastModified = ze.getTime();</span>
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">            if (lastModified != -1) {</span>
<span class="fc" id="L916">                File f = new File(ze.getName().replace('/', File.separatorChar));</span>
<span class="fc" id="L917">                f.setLastModified(lastModified);</span>
            }
<span class="fc" id="L919">        }</span>
<span class="fc" id="L920">    }</span>

    /**
     * Extracts specified entries from JAR file.
     */
    void extract(InputStream in, String files[]) throws IOException {
<span class="fc" id="L926">        ZipInputStream zis = new ZipInputStream(in);</span>
        ZipEntry e;
        // Set of all directory entries specified in archive.  Disallows
        // null entries.  Disallows all entries if using pre-6.0 behavior.
<span class="fc" id="L930">        Set&lt;ZipEntry&gt; dirs = newDirSet();</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">        while ((e = zis.getNextEntry()) != null) {</span>
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">            if (files == null) {</span>
<span class="fc" id="L933">                dirs.add(extractFile(zis, e));</span>
            } else {
<span class="nc" id="L935">                String name = e.getName();</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">                for (String file : files) {</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">                    if (name.startsWith(file)) {</span>
<span class="nc" id="L938">                        dirs.add(extractFile(zis, e));</span>
<span class="nc" id="L939">                        break;</span>
                    }
                }
<span class="nc" id="L942">            }</span>
        }

        // Update timestamps of directories specified in archive with their
        // timestamps as given in the archive.  We do this after extraction,
        // instead of during, because creating a file in a directory changes
        // that directory's timestamp.
<span class="fc" id="L949">        updateLastModifiedTime(dirs);</span>
<span class="fc" id="L950">    }</span>

    /**
     * Extracts specified entries from JAR file, via ZipFile.
     */
    void extract(String fname, String files[]) throws IOException {
<span class="nc" id="L956">        ZipFile zf = new ZipFile(fname);</span>
<span class="nc" id="L957">        Set&lt;ZipEntry&gt; dirs = newDirSet();</span>
<span class="nc" id="L958">        Enumeration&lt;? extends ZipEntry&gt; zes = zf.entries();</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">        while (zes.hasMoreElements()) {</span>
<span class="nc" id="L960">            ZipEntry e = zes.nextElement();</span>
            InputStream is;
<span class="nc bnc" id="L962" title="All 2 branches missed.">            if (files == null) {</span>
<span class="nc" id="L963">                dirs.add(extractFile(zf.getInputStream(e), e));</span>
            } else {
<span class="nc" id="L965">                String name = e.getName();</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">                for (String file : files) {</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">                    if (name.startsWith(file)) {</span>
<span class="nc" id="L968">                        dirs.add(extractFile(zf.getInputStream(e), e));</span>
<span class="nc" id="L969">                        break;</span>
                    }
                }
            }
<span class="nc" id="L973">        }</span>
<span class="nc" id="L974">        zf.close();</span>
<span class="nc" id="L975">        updateLastModifiedTime(dirs);</span>
<span class="nc" id="L976">    }</span>

    /**
     * Extracts next entry from JAR file, creating directories as needed.  If
     * the entry is for a directory which doesn't exist prior to this
     * invocation, returns that entry, otherwise returns null.
     */
    ZipEntry extractFile(InputStream is, ZipEntry e) throws IOException {
<span class="fc" id="L984">        ZipEntry rc = null;</span>
<span class="fc" id="L985">        String name = e.getName();</span>
<span class="fc" id="L986">        File f = new File(e.getName().replace('/', File.separatorChar));</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">        if (e.isDirectory()) {</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">            if (f.exists()) {</span>
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">                if (!f.isDirectory()) {</span>
<span class="nc" id="L990">                    throw new IOException(formatMsg(&quot;error.create.dir&quot;,</span>
<span class="nc" id="L991">                        f.getPath()));</span>
                }
            } else {
<span class="pc bpc" id="L994" title="1 of 2 branches missed.">                if (!f.mkdirs()) {</span>
<span class="nc" id="L995">                    throw new IOException(formatMsg(&quot;error.create.dir&quot;,</span>
<span class="nc" id="L996">                        f.getPath()));</span>
                } else {
<span class="fc" id="L998">                    rc = e;</span>
                }
            }

<span class="fc bfc" id="L1002" title="All 2 branches covered.">            if (vflag) {</span>
<span class="fc" id="L1003">                output(formatMsg(&quot;out.create&quot;, name));</span>
            }
        } else {
<span class="fc bfc" id="L1006" title="All 2 branches covered.">            if (f.getParent() != null) {</span>
<span class="fc" id="L1007">                File d = new File(f.getParent());</span>
<span class="pc bpc" id="L1008" title="4 of 6 branches missed.">                if (!d.exists() &amp;&amp; !d.mkdirs() || !d.isDirectory()) {</span>
<span class="nc" id="L1009">                    throw new IOException(formatMsg(</span>
<span class="nc" id="L1010">                        &quot;error.create.dir&quot;, d.getPath()));</span>
                }
            }
            try {
<span class="fc" id="L1014">                copy(is, f);</span>
            } finally {
<span class="pc bpc" id="L1016" title="3 of 4 branches missed.">                if (is instanceof ZipInputStream)</span>
<span class="pc" id="L1017">                    ((ZipInputStream)is).closeEntry();</span>
                else
<span class="nc" id="L1019">                    is.close();</span>
<span class="nc" id="L1020">            }</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">            if (vflag) {</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">                if (e.getMethod() == ZipEntry.DEFLATED) {</span>
<span class="fc" id="L1023">                    output(formatMsg(&quot;out.inflated&quot;, name));</span>
                } else {
<span class="fc" id="L1025">                    output(formatMsg(&quot;out.extracted&quot;, name));</span>
                }
            }
        }
<span class="fc bfc" id="L1029" title="All 2 branches covered.">        if (!useExtractionTime) {</span>
<span class="fc" id="L1030">            long lastModified = e.getTime();</span>
<span class="pc bpc" id="L1031" title="1 of 2 branches missed.">            if (lastModified != -1) {</span>
<span class="fc" id="L1032">                f.setLastModified(lastModified);</span>
            }
        }
<span class="fc" id="L1035">        return rc;</span>
    }

    /**
     * Lists contents of JAR file.
     */
    void list(InputStream in, String files[]) throws IOException {
<span class="nc" id="L1042">        ZipInputStream zis = new ZipInputStream(in);</span>
        ZipEntry e;
<span class="nc bnc" id="L1044" title="All 2 branches missed.">        while ((e = zis.getNextEntry()) != null) {</span>
            /*
             * In the case of a compressed (deflated) entry, the entry size
             * is stored immediately following the entry data and cannot be
             * determined until the entry is fully read. Therefore, we close
             * the entry first before printing out its attributes.
             */
<span class="nc" id="L1051">            zis.closeEntry();</span>
<span class="nc" id="L1052">            printEntry(e, files);</span>
        }
<span class="nc" id="L1054">    }</span>

    /**
     * Lists contents of JAR file, via ZipFile.
     */
    void list(String fname, String files[]) throws IOException {
<span class="fc" id="L1060">        ZipFile zf = new ZipFile(fname);</span>
<span class="fc" id="L1061">        Enumeration&lt;? extends ZipEntry&gt; zes = zf.entries();</span>
<span class="fc bfc" id="L1062" title="All 2 branches covered.">        while (zes.hasMoreElements()) {</span>
<span class="fc" id="L1063">            printEntry(zes.nextElement(), files);</span>
        }
<span class="fc" id="L1065">        zf.close();</span>
<span class="fc" id="L1066">    }</span>

    /**
     * Outputs the class index table to the INDEX.LIST file of the
     * root jar file.
     */
    void dumpIndex(String rootjar, JarIndex index) throws IOException {
<span class="fc" id="L1073">        File jarFile = new File(rootjar);</span>
<span class="fc" id="L1074">        Path jarPath = jarFile.toPath();</span>
<span class="fc" id="L1075">        Path tmpPath = createTempFileInSameDirectoryAs(jarFile).toPath();</span>
        try {
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">            if (update(Files.newInputStream(jarPath),</span>
<span class="fc" id="L1078">                       Files.newOutputStream(tmpPath),</span>
                       null, index)) {
                try {
<span class="fc" id="L1081">                    Files.move(tmpPath, jarPath, REPLACE_EXISTING);</span>
<span class="nc" id="L1082">                } catch (IOException e) {</span>
<span class="nc" id="L1083">                    throw new IOException(getMsg(&quot;error.write.file&quot;), e);</span>
<span class="fc" id="L1084">                }</span>
            }
        } finally {
<span class="pc" id="L1087">            Files.deleteIfExists(tmpPath);</span>
<span class="fc" id="L1088">        }</span>
<span class="fc" id="L1089">    }</span>

<span class="fc" id="L1091">    private HashSet&lt;String&gt; jarPaths = new HashSet&lt;String&gt;();</span>

    /**
     * Generates the transitive closure of the Class-Path attribute for
     * the specified jar file.
     */
    List&lt;String&gt; getJarPath(String jar) throws IOException {
<span class="fc" id="L1098">        List&lt;String&gt; files = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L1099">        files.add(jar);</span>
<span class="fc" id="L1100">        jarPaths.add(jar);</span>

        // take out the current path
<span class="fc" id="L1103">        String path = jar.substring(0, Math.max(0, jar.lastIndexOf('/') + 1));</span>

        // class path attribute will give us jar file name with
        // '/' as separators, so we need to change them to the
        // appropriate one before we open the jar file.
<span class="fc" id="L1108">        JarFile rf = new JarFile(jar.replace('/', File.separatorChar));</span>

<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">        if (rf != null) {</span>
<span class="fc" id="L1111">            Manifest man = rf.getManifest();</span>
<span class="fc bfc" id="L1112" title="All 2 branches covered.">            if (man != null) {</span>
<span class="fc" id="L1113">                Attributes attr = man.getMainAttributes();</span>
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">                if (attr != null) {</span>
<span class="fc" id="L1115">                    String value = attr.getValue(Attributes.Name.CLASS_PATH);</span>
<span class="pc bpc" id="L1116" title="1 of 2 branches missed.">                    if (value != null) {</span>
<span class="nc" id="L1117">                        StringTokenizer st = new StringTokenizer(value);</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                        while (st.hasMoreTokens()) {</span>
<span class="nc" id="L1119">                            String ajar = st.nextToken();</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                            if (!ajar.endsWith(&quot;/&quot;)) {  // it is a jar file</span>
<span class="nc" id="L1121">                                ajar = path.concat(ajar);</span>
                                /* check on cyclic dependency */
<span class="nc bnc" id="L1123" title="All 2 branches missed.">                                if (! jarPaths.contains(ajar)) {</span>
<span class="nc" id="L1124">                                    files.addAll(getJarPath(ajar));</span>
                                }
                            }
<span class="nc" id="L1127">                        }</span>
                    }
                }
            }
        }
<span class="fc" id="L1132">        rf.close();</span>
<span class="fc" id="L1133">        return files;</span>
    }

    /**
     * Generates class index file for the specified root jar file.
     */
    void genIndex(String rootjar, String[] files) throws IOException {
<span class="fc" id="L1140">        List&lt;String&gt; jars = getJarPath(rootjar);</span>
<span class="fc" id="L1141">        int njars = jars.size();</span>
        String[] jarfiles;

<span class="pc bpc" id="L1144" title="1 of 4 branches missed.">        if (njars == 1 &amp;&amp; files != null) {</span>
            // no class-path attribute defined in rootjar, will
            // use command line specified list of jars
<span class="fc bfc" id="L1147" title="All 2 branches covered.">            for (int i = 0; i &lt; files.length; i++) {</span>
<span class="fc" id="L1148">                jars.addAll(getJarPath(files[i]));</span>
            }
<span class="fc" id="L1150">            njars = jars.size();</span>
        }
<span class="fc" id="L1152">        jarfiles = jars.toArray(new String[njars]);</span>
<span class="fc" id="L1153">        JarIndex index = new JarIndex(jarfiles);</span>
<span class="fc" id="L1154">        dumpIndex(rootjar, index);</span>
<span class="fc" id="L1155">    }</span>

    /**
     * Prints entry information, if requested.
     */
    void printEntry(ZipEntry e, String[] files) throws IOException {
<span class="pc bpc" id="L1161" title="1 of 2 branches missed.">        if (files == null) {</span>
<span class="fc" id="L1162">            printEntry(e);</span>
        } else {
<span class="nc" id="L1164">            String name = e.getName();</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">            for (String file : files) {</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                if (name.startsWith(file)) {</span>
<span class="nc" id="L1167">                    printEntry(e);</span>
<span class="nc" id="L1168">                    return;</span>
                }
            }
        }
<span class="fc" id="L1172">    }</span>

    /**
     * Prints entry information.
     */
    void printEntry(ZipEntry e) throws IOException {
<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">        if (vflag) {</span>
<span class="nc" id="L1179">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1180">            String s = Long.toString(e.getSize());</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">            for (int i = 6 - s.length(); i &gt; 0; --i) {</span>
<span class="nc" id="L1182">                sb.append(' ');</span>
            }
<span class="nc" id="L1184">            sb.append(s).append(' ').append(new Date(e.getTime()).toString());</span>
<span class="nc" id="L1185">            sb.append(' ').append(e.getName());</span>
<span class="nc" id="L1186">            output(sb.toString());</span>
<span class="nc" id="L1187">        } else {</span>
<span class="fc" id="L1188">            output(e.getName());</span>
        }
<span class="fc" id="L1190">    }</span>

    /**
     * Prints usage message.
     */
    void usageError() {
<span class="nc" id="L1196">        error(getMsg(&quot;usage&quot;));</span>
<span class="nc" id="L1197">    }</span>

    /**
     * A fatal exception has been caught.  No recovery possible
     */
    void fatalError(Exception e) {
<span class="nc" id="L1203">        e.printStackTrace();</span>
<span class="nc" id="L1204">    }</span>

    /**
     * A fatal condition has been detected; message is &quot;s&quot;.
     * No recovery possible
     */
    void fatalError(String s) {
<span class="nc" id="L1211">        error(program + &quot;: &quot; + s);</span>
<span class="nc" id="L1212">    }</span>

    /**
     * Print an output message; like verbose output and the like
     */
    protected void output(String s) {
<span class="fc" id="L1218">        out.println(s);</span>
<span class="fc" id="L1219">    }</span>

    /**
     * Print an error message; like something is broken
     */
    protected void error(String s) {
<span class="fc" id="L1225">        err.println(s);</span>
<span class="fc" id="L1226">    }</span>

    /**
     * Main routine to start program.
     */
    public static void main(String args[]) {
<span class="fc" id="L1232">        Main jartool = new Main(System.out, System.err, &quot;jar&quot;);</span>
<span class="pc bfc" id="L1233" title="All 2 branches covered.">        System.exit(jartool.run(args) ? 0 : 1);</span>
<span class="nc" id="L1234">    }</span>

    /**
     * An OutputStream that doesn't send its output anywhere, (but could).
     * It's here to find the CRC32 of an input file, necessary for STORED
     * mode in ZIP.
     */
    private static class CRC32OutputStream extends java.io.OutputStream {
<span class="fc" id="L1242">        final CRC32 crc = new CRC32();</span>
<span class="fc" id="L1243">        long n = 0;</span>

<span class="fc" id="L1245">        CRC32OutputStream() {}</span>

        public void write(int r) throws IOException {
<span class="fc" id="L1248">            crc.update(r);</span>
<span class="fc" id="L1249">            n++;</span>
<span class="fc" id="L1250">        }</span>

        public void write(byte[] b, int off, int len) throws IOException {
<span class="fc" id="L1253">            crc.update(b, off, len);</span>
<span class="fc" id="L1254">            n += len;</span>
<span class="fc" id="L1255">        }</span>

        /**
         * Updates a ZipEntry which describes the data read by this
         * output stream, in STORED mode.
         */
        public void updateEntry(ZipEntry e) {
<span class="fc" id="L1262">            e.setMethod(ZipEntry.STORED);</span>
<span class="fc" id="L1263">            e.setSize(n);</span>
<span class="fc" id="L1264">            e.setCrc(crc.getValue());</span>
<span class="fc" id="L1265">        }</span>
    }

    /**
     * Attempt to create temporary file in the system-provided temporary folder, if failed attempts
     * to create it in the same folder as the file in parameter (if any)
     */
    private File createTemporaryFile(String tmpbase, String suffix) {
<span class="fc" id="L1273">        File tmpfile = null;</span>

        try {
<span class="fc" id="L1276">            tmpfile = File.createTempFile(tmpbase, suffix);</span>
<span class="nc" id="L1277">        } catch (IOException | SecurityException e) {</span>
            // Unable to create file due to permission violation or security exception
<span class="fc" id="L1279">        }</span>
<span class="pc bpc" id="L1280" title="1 of 2 branches missed.">        if (tmpfile == null) {</span>
            // Were unable to create temporary file, fall back to temporary file in the same folder
<span class="nc bnc" id="L1282" title="All 2 branches missed.">            if (fname != null) {</span>
                try {
<span class="nc" id="L1284">                    File tmpfolder = new File(fname).getAbsoluteFile().getParentFile();</span>
<span class="nc" id="L1285">                    tmpfile = File.createTempFile(fname, &quot;.tmp&quot; + suffix, tmpfolder);</span>
<span class="nc" id="L1286">                } catch (IOException ioe) {</span>
                    // Last option failed - fall gracefully
<span class="nc" id="L1288">                    fatalError(ioe);</span>
<span class="nc" id="L1289">                }</span>
            } else {
                // No options left - we can not compress to stdout without access to the temporary folder
<span class="nc" id="L1292">                fatalError(new IOException(getMsg(&quot;error.create.tempfile&quot;)));</span>
            }
        }
<span class="fc" id="L1295">        return tmpfile;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>