<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DefaultPersistenceDelegate.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.beans</a> &gt; <span class="el_source">DefaultPersistenceDelegate.java</span></div><h1>DefaultPersistenceDelegate.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.beans;

import java.util.*;
import java.lang.reflect.*;
import java.util.Objects;
import sun.reflect.misc.*;


/**
 * The &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt; is a concrete implementation of
 * the abstract &lt;code&gt;PersistenceDelegate&lt;/code&gt; class and
 * is the delegate used by default for classes about
 * which no information is available. The &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt;
 * provides, version resilient, public API-based persistence for
 * classes that follow the JavaBeans&amp;trade; conventions without any class specific
 * configuration.
 * &lt;p&gt;
 * The key assumptions are that the class has a nullary constructor
 * and that its state is accurately represented by matching pairs
 * of &quot;setter&quot; and &quot;getter&quot; methods in the order they are returned
 * by the Introspector.
 * In addition to providing code-free persistence for JavaBeans,
 * the &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt; provides a convenient means
 * to effect persistent storage for classes that have a constructor
 * that, while not nullary, simply requires some property values
 * as arguments.
 *
 * @see #DefaultPersistenceDelegate(String[])
 * @see java.beans.Introspector
 *
 * @since 1.4
 *
 * @author Philip Milne
 */

public class DefaultPersistenceDelegate extends PersistenceDelegate {
<span class="nc" id="L61">    private static final String[] EMPTY = {};</span>
    private final String[] constructor;
    private Boolean definesEquals;

    /**
     * Creates a persistence delegate for a class with a nullary constructor.
     *
     * @see #DefaultPersistenceDelegate(java.lang.String[])
     */
<span class="nc" id="L70">    public DefaultPersistenceDelegate() {</span>
<span class="nc" id="L71">        this.constructor = EMPTY;</span>
<span class="nc" id="L72">    }</span>

    /**
     * Creates a default persistence delegate for a class with a
     * constructor whose arguments are the values of the property
     * names as specified by &lt;code&gt;constructorPropertyNames&lt;/code&gt;.
     * The constructor arguments are created by
     * evaluating the property names in the order they are supplied.
     * To use this class to specify a single preferred constructor for use
     * in the serialization of a particular type, we state the
     * names of the properties that make up the constructor's
     * arguments. For example, the &lt;code&gt;Font&lt;/code&gt; class which
     * does not define a nullary constructor can be handled
     * with the following persistence delegate:
     *
     * &lt;pre&gt;
     *     new DefaultPersistenceDelegate(new String[]{&quot;name&quot;, &quot;style&quot;, &quot;size&quot;});
     * &lt;/pre&gt;
     *
     * @param  constructorPropertyNames The property names for the arguments of this constructor.
     *
     * @see #instantiate
     */
<span class="nc" id="L95">    public DefaultPersistenceDelegate(String[] constructorPropertyNames) {</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        this.constructor = (constructorPropertyNames == null) ? EMPTY : constructorPropertyNames.clone();</span>
<span class="nc" id="L97">    }</span>

    private static boolean definesEquals(Class&lt;?&gt; type) {
        try {
<span class="nc bnc" id="L101" title="All 2 branches missed.">            return type == type.getMethod(&quot;equals&quot;, Object.class).getDeclaringClass();</span>
        }
<span class="nc" id="L103">        catch(NoSuchMethodException e) {</span>
<span class="nc" id="L104">            return false;</span>
        }
    }

    private boolean definesEquals(Object instance) {
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (definesEquals != null) {</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            return (definesEquals == Boolean.TRUE);</span>
        }
        else {
<span class="nc" id="L113">            boolean result = definesEquals(instance.getClass());</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">            definesEquals = result ? Boolean.TRUE : Boolean.FALSE;</span>
<span class="nc" id="L115">            return result;</span>
        }
    }

    /**
     * If the number of arguments in the specified constructor is non-zero and
     * the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method
     * this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt;.
     * Otherwise, this method uses the superclass's definition which returns true if the
     * classes of the two instances are equal.
     *
     * @param oldInstance The instance to be copied.
     * @param newInstance The instance that is to be modified.
     * @return True if an equivalent copy of &lt;code&gt;newInstance&lt;/code&gt; may be
     *         created by applying a series of mutations to &lt;code&gt;oldInstance&lt;/code&gt;.
     *
     * @see #DefaultPersistenceDelegate(String[])
     */
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
        // Assume the instance is either mutable or a singleton
        // if it has a nullary constructor.
<span class="nc bnc" id="L136" title="All 4 branches missed.">        return (constructor.length == 0) || !definesEquals(oldInstance) ?</span>
<span class="nc" id="L137">            super.mutatesTo(oldInstance, newInstance) :</span>
<span class="nc" id="L138">            oldInstance.equals(newInstance);</span>
    }

    /**
     * This default implementation of the &lt;code&gt;instantiate&lt;/code&gt; method returns
     * an expression containing the predefined method name &quot;new&quot; which denotes a
     * call to a constructor with the arguments as specified in
     * the &lt;code&gt;DefaultPersistenceDelegate&lt;/code&gt;'s constructor.
     *
     * @param  oldInstance The instance to be instantiated.
     * @param  out The code output stream.
     * @return An expression whose value is &lt;code&gt;oldInstance&lt;/code&gt;.
     *
     * @throws NullPointerException if {@code out} is {@code null}
     *                              and this value is used in the method
     *
     * @see #DefaultPersistenceDelegate(String[])
     */
    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L157">        int nArgs = constructor.length;</span>
<span class="nc" id="L158">        Class&lt;?&gt; type = oldInstance.getClass();</span>
<span class="nc" id="L159">        Object[] constructorArgs = new Object[nArgs];</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        for(int i = 0; i &lt; nArgs; i++) {</span>
            try {
<span class="nc" id="L162">                Method method = findMethod(type, this.constructor[i]);</span>
<span class="nc" id="L163">                constructorArgs[i] = MethodUtil.invoke(method, oldInstance, new Object[0]);</span>
            }
<span class="nc" id="L165">            catch (Exception e) {</span>
<span class="nc" id="L166">                out.getExceptionListener().exceptionThrown(e);</span>
<span class="nc" id="L167">            }</span>
        }
<span class="nc" id="L169">        return new Expression(oldInstance, oldInstance.getClass(), &quot;new&quot;, constructorArgs);</span>
    }

    private Method findMethod(Class&lt;?&gt; type, String property) {
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (property == null) {</span>
<span class="nc" id="L174">            throw new IllegalArgumentException(&quot;Property name is null&quot;);</span>
        }
<span class="nc" id="L176">        PropertyDescriptor pd = getPropertyDescriptor(type, property);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (pd == null) {</span>
<span class="nc" id="L178">            throw new IllegalStateException(&quot;Could not find property by the name &quot; + property);</span>
        }
<span class="nc" id="L180">        Method method = pd.getReadMethod();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (method == null) {</span>
<span class="nc" id="L182">            throw new IllegalStateException(&quot;Could not find getter for the property &quot; + property);</span>
        }
<span class="nc" id="L184">        return method;</span>
    }

    private void doProperty(Class&lt;?&gt; type, PropertyDescriptor pd, Object oldInstance, Object newInstance, Encoder out) throws Exception {
<span class="nc" id="L188">        Method getter = pd.getReadMethod();</span>
<span class="nc" id="L189">        Method setter = pd.getWriteMethod();</span>

<span class="nc bnc" id="L191" title="All 4 branches missed.">        if (getter != null &amp;&amp; setter != null) {</span>
<span class="nc" id="L192">            Expression oldGetExp = new Expression(oldInstance, getter.getName(), new Object[]{});</span>
<span class="nc" id="L193">            Expression newGetExp = new Expression(newInstance, getter.getName(), new Object[]{});</span>
<span class="nc" id="L194">            Object oldValue = oldGetExp.getValue();</span>
<span class="nc" id="L195">            Object newValue = newGetExp.getValue();</span>
<span class="nc" id="L196">            out.writeExpression(oldGetExp);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (!Objects.equals(newValue, out.get(oldValue))) {</span>
                // Search for a static constant with this value;
<span class="nc" id="L199">                Object e = (Object[])pd.getValue(&quot;enumerationValues&quot;);</span>
<span class="nc bnc" id="L200" title="All 4 branches missed.">                if (e instanceof Object[] &amp;&amp; Array.getLength(e) % 3 == 0) {</span>
<span class="nc" id="L201">                    Object[] a = (Object[])e;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">                    for(int i = 0; i &lt; a.length; i = i + 3) {</span>
                        try {
<span class="nc" id="L204">                           Field f = type.getField((String)a[i]);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                           if (f.get(null).equals(oldValue)) {</span>
<span class="nc" id="L206">                               out.remove(oldValue);</span>
<span class="nc" id="L207">                               out.writeExpression(new Expression(oldValue, f, &quot;get&quot;, new Object[]{null}));</span>
                           }
                        }
<span class="nc" id="L210">                        catch (Exception ex) {}</span>
                    }
                }
<span class="nc" id="L213">                invokeStatement(oldInstance, setter.getName(), new Object[]{oldValue}, out);</span>
            }
        }
<span class="nc" id="L216">    }</span>

    static void invokeStatement(Object instance, String methodName, Object[] args, Encoder out) {
<span class="nc" id="L219">        out.writeStatement(new Statement(instance, methodName, args));</span>
<span class="nc" id="L220">    }</span>

    // Write out the properties of this instance.
    private void initBean(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        for (Field field : type.getFields()) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (!ReflectUtil.isPackageAccessible(field.getDeclaringClass())) {</span>
<span class="nc" id="L226">                continue;</span>
            }
<span class="nc" id="L228">            int mod = field.getModifiers();</span>
<span class="nc bnc" id="L229" title="All 6 branches missed.">            if (Modifier.isFinal(mod) || Modifier.isStatic(mod) || Modifier.isTransient(mod)) {</span>
<span class="nc" id="L230">                continue;</span>
            }
            try {
<span class="nc" id="L233">                Expression oldGetExp = new Expression(field, &quot;get&quot;, new Object[] { oldInstance });</span>
<span class="nc" id="L234">                Expression newGetExp = new Expression(field, &quot;get&quot;, new Object[] { newInstance });</span>
<span class="nc" id="L235">                Object oldValue = oldGetExp.getValue();</span>
<span class="nc" id="L236">                Object newValue = newGetExp.getValue();</span>
<span class="nc" id="L237">                out.writeExpression(oldGetExp);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                if (!Objects.equals(newValue, out.get(oldValue))) {</span>
<span class="nc" id="L239">                    out.writeStatement(new Statement(field, &quot;set&quot;, new Object[] { oldInstance, oldValue }));</span>
                }
            }
<span class="nc" id="L242">            catch (Exception exception) {</span>
<span class="nc" id="L243">                out.getExceptionListener().exceptionThrown(exception);</span>
<span class="nc" id="L244">            }</span>
        }
        BeanInfo info;
        try {
<span class="nc" id="L248">            info = Introspector.getBeanInfo(type);</span>
<span class="nc" id="L249">        } catch (IntrospectionException exception) {</span>
<span class="nc" id="L250">            return;</span>
<span class="nc" id="L251">        }</span>
        // Properties
<span class="nc bnc" id="L253" title="All 2 branches missed.">        for (PropertyDescriptor d : info.getPropertyDescriptors()) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (d.isTransient()) {</span>
<span class="nc" id="L255">                continue;</span>
            }
            try {
<span class="nc" id="L258">                doProperty(type, d, oldInstance, newInstance, out);</span>
            }
<span class="nc" id="L260">            catch (Exception e) {</span>
<span class="nc" id="L261">                out.getExceptionListener().exceptionThrown(e);</span>
<span class="nc" id="L262">            }</span>
        }

        // Listeners
        /*
        Pending(milne). There is a general problem with the archival of
        listeners which is unresolved as of 1.4. Many of the methods
        which install one object inside another (typically &quot;add&quot; methods
        or setters) automatically install a listener on the &quot;child&quot; object
        so that its &quot;parent&quot; may respond to changes that are made to it.
        For example the JTable:setModel() method automatically adds a
        TableModelListener (the JTable itself in this case) to the supplied
        table model.

        We do not need to explicitly add these listeners to the model in an
        archive as they will be added automatically by, in the above case,
        the JTable's &quot;setModel&quot; method. In some cases, we must specifically
        avoid trying to do this since the listener may be an inner class
        that cannot be instantiated using public API.

        No general mechanism currently
        exists for differentiating between these kind of listeners and
        those which were added explicitly by the user. A mechanism must
        be created to provide a general means to differentiate these
        special cases so as to provide reliable persistence of listeners
        for the general case.
        */
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (!java.awt.Component.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L290">            return; // Just handle the listeners of Components for now.</span>
        }
<span class="nc bnc" id="L292" title="All 2 branches missed.">        for (EventSetDescriptor d : info.getEventSetDescriptors()) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (d.isTransient()) {</span>
<span class="nc" id="L294">                continue;</span>
            }
<span class="nc" id="L296">            Class&lt;?&gt; listenerType = d.getListenerType();</span>


            // The ComponentListener is added automatically, when
            // Contatiner:add is called on the parent.
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (listenerType == java.awt.event.ComponentListener.class) {</span>
<span class="nc" id="L302">                continue;</span>
            }

            // JMenuItems have a change listener added to them in
            // their &quot;add&quot; methods to enable accessibility support -
            // see the add method in JMenuItem for details. We cannot
            // instantiate this instance as it is a private inner class
            // and do not need to do this anyway since it will be created
            // and installed by the &quot;add&quot; method. Special case this for now,
            // ignoring all change listeners on JMenuItems.
<span class="nc bnc" id="L312" title="All 4 branches missed.">            if (listenerType == javax.swing.event.ChangeListener.class &amp;&amp;</span>
                type == javax.swing.JMenuItem.class) {
<span class="nc" id="L314">                continue;</span>
            }

<span class="nc" id="L317">            EventListener[] oldL = new EventListener[0];</span>
<span class="nc" id="L318">            EventListener[] newL = new EventListener[0];</span>
            try {
<span class="nc" id="L320">                Method m = d.getGetListenerMethod();</span>
<span class="nc" id="L321">                oldL = (EventListener[])MethodUtil.invoke(m, oldInstance, new Object[]{});</span>
<span class="nc" id="L322">                newL = (EventListener[])MethodUtil.invoke(m, newInstance, new Object[]{});</span>
            }
<span class="nc" id="L324">            catch (Exception e2) {</span>
                try {
<span class="nc" id="L326">                    Method m = type.getMethod(&quot;getListeners&quot;, new Class&lt;?&gt;[]{Class.class});</span>
<span class="nc" id="L327">                    oldL = (EventListener[])MethodUtil.invoke(m, oldInstance, new Object[]{listenerType});</span>
<span class="nc" id="L328">                    newL = (EventListener[])MethodUtil.invoke(m, newInstance, new Object[]{listenerType});</span>
                }
<span class="nc" id="L330">                catch (Exception e3) {</span>
<span class="nc" id="L331">                    return;</span>
<span class="nc" id="L332">                }</span>
<span class="nc" id="L333">            }</span>

            // Asssume the listeners are in the same order and that there are no gaps.
            // Eventually, this may need to do true differencing.
<span class="nc" id="L337">            String addListenerMethodName = d.getAddListenerMethod().getName();</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            for (int i = newL.length; i &lt; oldL.length; i++) {</span>
                // System.out.println(&quot;Adding listener: &quot; + addListenerMethodName + oldL[i]);
<span class="nc" id="L340">                invokeStatement(oldInstance, addListenerMethodName, new Object[]{oldL[i]}, out);</span>
            }

<span class="nc" id="L343">            String removeListenerMethodName = d.getRemoveListenerMethod().getName();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            for (int i = oldL.length; i &lt; newL.length; i++) {</span>
<span class="nc" id="L345">                invokeStatement(oldInstance, removeListenerMethodName, new Object[]{newL[i]}, out);</span>
            }
        }
<span class="nc" id="L348">    }</span>

    /**
     * This default implementation of the &lt;code&gt;initialize&lt;/code&gt; method assumes
     * all state held in objects of this type is exposed via the
     * matching pairs of &quot;setter&quot; and &quot;getter&quot; methods in the order
     * they are returned by the Introspector. If a property descriptor
     * defines a &quot;transient&quot; attribute with a value equal to
     * &lt;code&gt;Boolean.TRUE&lt;/code&gt; the property is ignored by this
     * default implementation. Note that this use of the word
     * &quot;transient&quot; is quite independent of the field modifier
     * that is used by the &lt;code&gt;ObjectOutputStream&lt;/code&gt;.
     * &lt;p&gt;
     * For each non-transient property, an expression is created
     * in which the nullary &quot;getter&quot; method is applied
     * to the &lt;code&gt;oldInstance&lt;/code&gt;. The value of this
     * expression is the value of the property in the instance that is
     * being serialized. If the value of this expression
     * in the cloned environment &lt;code&gt;mutatesTo&lt;/code&gt; the
     * target value, the new value is initialized to make it
     * equivalent to the old value. In this case, because
     * the property value has not changed there is no need to
     * call the corresponding &quot;setter&quot; method and no statement
     * is emitted. If not however, the expression for this value
     * is replaced with another expression (normally a constructor)
     * and the corresponding &quot;setter&quot; method is called to install
     * the new property value in the object. This scheme removes
     * default information from the output produced by streams
     * using this delegate.
     * &lt;p&gt;
     * In passing these statements to the output stream, where they
     * will be executed, side effects are made to the &lt;code&gt;newInstance&lt;/code&gt;.
     * In most cases this allows the problem of properties
     * whose values depend on each other to actually help the
     * serialization process by making the number of statements
     * that need to be written to the output smaller. In general,
     * the problem of handling interdependent properties is reduced to
     * that of finding an order for the properties in
     * a class such that no property value depends on the value of
     * a subsequent property.
     *
     * @param type the type of the instances
     * @param oldInstance The instance to be copied.
     * @param newInstance The instance that is to be modified.
     * @param out The stream to which any initialization statements should be written.
     *
     * @throws NullPointerException if {@code out} is {@code null}
     *
     * @see java.beans.Introspector#getBeanInfo
     * @see java.beans.PropertyDescriptor
     */
    protected void initialize(Class&lt;?&gt; type,
                              Object oldInstance, Object newInstance,
                              Encoder out)
    {
        // System.out.println(&quot;DefulatPD:initialize&quot; + type);
<span class="nc" id="L404">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (oldInstance.getClass() == type) { // !type.isInterface()) {</span>
<span class="nc" id="L406">            initBean(type, oldInstance, newInstance, out);</span>
        }
<span class="nc" id="L408">    }</span>

    private static PropertyDescriptor getPropertyDescriptor(Class&lt;?&gt; type, String property) {
        try {
<span class="nc bnc" id="L412" title="All 2 branches missed.">            for (PropertyDescriptor pd : Introspector.getBeanInfo(type).getPropertyDescriptors()) {</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                if (property.equals(pd.getName()))</span>
<span class="nc" id="L414">                    return pd;</span>
            }
<span class="nc" id="L416">        } catch (IntrospectionException exception) {</span>
<span class="nc" id="L417">        }</span>
<span class="nc" id="L418">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>