<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MetaData.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.beans</a> &gt; <span class="el_source">MetaData.java</span></div><h1>MetaData.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.beans;

import com.sun.beans.finder.PrimitiveWrapperMap;

import java.awt.AWTKeyStroke;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.KeyEvent;
import java.awt.font.TextAttribute;

import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.InvocationTargetException;

import java.security.AccessController;
import java.security.PrivilegedAction;

import java.util.*;

import javax.swing.Box;
import javax.swing.JLayeredPane;
import javax.swing.border.MatteBorder;
import javax.swing.plaf.ColorUIResource;

import sun.swing.PrintColorUIResource;

import static sun.reflect.misc.ReflectUtil.isPackageAccessible;

/*
 * Like the &lt;code&gt;Intropector&lt;/code&gt;, the &lt;code&gt;MetaData&lt;/code&gt; class
 * contains &lt;em&gt;meta&lt;/em&gt; objects that describe the way
 * classes should express their state in terms of their
 * own public APIs.
 *
 * @see java.beans.Intropector
 *
 * @author Philip Milne
 * @author Steve Langley
 */
<span class="nc" id="L73">class MetaData {</span>

<span class="nc" id="L75">static final class NullPersistenceDelegate extends PersistenceDelegate {</span>
    // Note this will be called by all classes when they reach the
    // top of their superclass chain.
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L79">    }</span>
<span class="nc" id="L80">    protected Expression instantiate(Object oldInstance, Encoder out) { return null; }</span>

    public void writeObject(Object oldInstance, Encoder out) {
    // System.out.println(&quot;NullPersistenceDelegate:writeObject &quot; + oldInstance);
<span class="nc" id="L84">    }</span>
}

/**
 * The persistence delegate for &lt;CODE&gt;enum&lt;/CODE&gt; classes.
 *
 * @author Sergey A. Malenkov
 */
<span class="nc" id="L92">static final class EnumPersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc bnc" id="L94" title="All 2 branches missed.">        return oldInstance == newInstance;</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L98">        Enum&lt;?&gt; e = (Enum&lt;?&gt;) oldInstance;</span>
<span class="nc" id="L99">        return new Expression(e, Enum.class, &quot;valueOf&quot;, new Object[]{e.getDeclaringClass(), e.name()});</span>
    }
}

<span class="nc" id="L103">static final class PrimitivePersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc" id="L105">        return oldInstance.equals(newInstance);</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L109">        return new Expression(oldInstance, oldInstance.getClass(),</span>
<span class="nc" id="L110">                  &quot;new&quot;, new Object[]{oldInstance.toString()});</span>
    }
}

<span class="nc" id="L114">static final class ArrayPersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        return (newInstance != null &amp;&amp;</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">                oldInstance.getClass() == newInstance.getClass() &amp;&amp; // Also ensures the subtype is correct.</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">                Array.getLength(oldInstance) == Array.getLength(newInstance));</span>
        }

    protected Expression instantiate(Object oldInstance, Encoder out) {
        // System.out.println(&quot;instantiate: &quot; + type + &quot; &quot; + oldInstance);
<span class="nc" id="L123">        Class&lt;?&gt; oldClass = oldInstance.getClass();</span>
<span class="nc" id="L124">        return new Expression(oldInstance, Array.class, &quot;newInstance&quot;,</span>
<span class="nc" id="L125">                   new Object[]{oldClass.getComponentType(),</span>
<span class="nc" id="L126">                                new Integer(Array.getLength(oldInstance))});</span>
        }

    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L130">        int n = Array.getLength(oldInstance);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L132">            Object index = new Integer(i);</span>
            // Expression oldGetExp = new Expression(Array.class, &quot;get&quot;, new Object[]{oldInstance, index});
            // Expression newGetExp = new Expression(Array.class, &quot;get&quot;, new Object[]{newInstance, index});
<span class="nc" id="L135">            Expression oldGetExp = new Expression(oldInstance, &quot;get&quot;, new Object[]{index});</span>
<span class="nc" id="L136">            Expression newGetExp = new Expression(newInstance, &quot;get&quot;, new Object[]{index});</span>
            try {
<span class="nc" id="L138">                Object oldValue = oldGetExp.getValue();</span>
<span class="nc" id="L139">                Object newValue = newGetExp.getValue();</span>
<span class="nc" id="L140">                out.writeExpression(oldGetExp);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">                if (!Objects.equals(newValue, out.get(oldValue))) {</span>
                    // System.out.println(&quot;Not equal: &quot; + newGetExp + &quot; != &quot; + actualGetExp);
                    // invokeStatement(Array.class, &quot;set&quot;, new Object[]{oldInstance, index, oldValue}, out);
<span class="nc" id="L144">                    DefaultPersistenceDelegate.invokeStatement(oldInstance, &quot;set&quot;, new Object[]{index, oldValue}, out);</span>
                }
            }
<span class="nc" id="L147">            catch (Exception e) {</span>
                // System.err.println(&quot;Warning:: failed to write: &quot; + oldGetExp);
<span class="nc" id="L149">                out.getExceptionListener().exceptionThrown(e);</span>
<span class="nc" id="L150">            }</span>
        }
<span class="nc" id="L152">    }</span>
}

<span class="nc" id="L155">static final class ProxyPersistenceDelegate extends PersistenceDelegate {</span>
    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L157">        Class&lt;?&gt; type = oldInstance.getClass();</span>
<span class="nc" id="L158">        java.lang.reflect.Proxy p = (java.lang.reflect.Proxy)oldInstance;</span>
        // This unappealing hack is not required but makes the
        // representation of EventHandlers much more concise.
<span class="nc" id="L161">        java.lang.reflect.InvocationHandler ih = java.lang.reflect.Proxy.getInvocationHandler(p);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (ih instanceof EventHandler) {</span>
<span class="nc" id="L163">            EventHandler eh = (EventHandler)ih;</span>
<span class="nc" id="L164">            Vector&lt;Object&gt; args = new Vector&lt;&gt;();</span>
<span class="nc" id="L165">            args.add(type.getInterfaces()[0]);</span>
<span class="nc" id="L166">            args.add(eh.getTarget());</span>
<span class="nc" id="L167">            args.add(eh.getAction());</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            if (eh.getEventPropertyName() != null) {</span>
<span class="nc" id="L169">                args.add(eh.getEventPropertyName());</span>
            }
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (eh.getListenerMethodName() != null) {</span>
<span class="nc" id="L172">                args.setSize(4);</span>
<span class="nc" id="L173">                args.add(eh.getListenerMethodName());</span>
            }
<span class="nc" id="L175">            return new Expression(oldInstance,</span>
                                  EventHandler.class,
                                  &quot;create&quot;,
<span class="nc" id="L178">                                  args.toArray());</span>
        }
<span class="nc" id="L180">        return new Expression(oldInstance,</span>
                              java.lang.reflect.Proxy.class,
                              &quot;newProxyInstance&quot;,
<span class="nc" id="L183">                              new Object[]{type.getClassLoader(),</span>
<span class="nc" id="L184">                                           type.getInterfaces(),</span>
                                           ih});
    }
}

// Strings
<span class="nc" id="L190">static final class java_lang_String_PersistenceDelegate extends PersistenceDelegate {</span>
<span class="nc" id="L191">    protected Expression instantiate(Object oldInstance, Encoder out) { return null; }</span>

    public void writeObject(Object oldInstance, Encoder out) {
        // System.out.println(&quot;NullPersistenceDelegate:writeObject &quot; + oldInstance);
<span class="nc" id="L195">    }</span>
}

// Classes
<span class="nc" id="L199">static final class java_lang_Class_PersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc" id="L201">        return oldInstance.equals(newInstance);</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L205">        Class&lt;?&gt; c = (Class)oldInstance;</span>
        // As of 1.3 it is not possible to call Class.forName(&quot;int&quot;),
        // so we have to generate different code for primitive types.
        // This is needed for arrays whose subtype may be primitive.
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (c.isPrimitive()) {</span>
<span class="nc" id="L210">            Field field = null;</span>
            try {
<span class="nc" id="L212">                field = PrimitiveWrapperMap.getType(c.getName()).getDeclaredField(&quot;TYPE&quot;);</span>
<span class="nc" id="L213">            } catch (NoSuchFieldException ex) {</span>
<span class="nc" id="L214">                System.err.println(&quot;Unknown primitive type: &quot; + c);</span>
<span class="nc" id="L215">            }</span>
<span class="nc" id="L216">            return new Expression(oldInstance, field, &quot;get&quot;, new Object[]{null});</span>
        }
<span class="nc bnc" id="L218" title="All 2 branches missed.">        else if (oldInstance == String.class) {</span>
<span class="nc" id="L219">            return new Expression(oldInstance, &quot;&quot;, &quot;getClass&quot;, new Object[]{});</span>
        }
<span class="nc bnc" id="L221" title="All 2 branches missed.">        else if (oldInstance == Class.class) {</span>
<span class="nc" id="L222">            return new Expression(oldInstance, String.class, &quot;getClass&quot;, new Object[]{});</span>
        }
        else {
<span class="nc" id="L225">            Expression newInstance = new Expression(oldInstance, Class.class, &quot;forName&quot;, new Object[] { c.getName() });</span>
<span class="nc" id="L226">            newInstance.loader = c.getClassLoader();</span>
<span class="nc" id="L227">            return newInstance;</span>
        }
    }
}

// Fields
<span class="nc" id="L233">static final class java_lang_reflect_Field_PersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc" id="L235">        return oldInstance.equals(newInstance);</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L239">        Field f = (Field)oldInstance;</span>
<span class="nc" id="L240">        return new Expression(oldInstance,</span>
<span class="nc" id="L241">                f.getDeclaringClass(),</span>
                &quot;getField&quot;,
<span class="nc" id="L243">                new Object[]{f.getName()});</span>
    }
}

// Methods
<span class="nc" id="L248">static final class java_lang_reflect_Method_PersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc" id="L250">        return oldInstance.equals(newInstance);</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L254">        Method m = (Method)oldInstance;</span>
<span class="nc" id="L255">        return new Expression(oldInstance,</span>
<span class="nc" id="L256">                m.getDeclaringClass(),</span>
                &quot;getMethod&quot;,
<span class="nc" id="L258">                new Object[]{m.getName(), m.getParameterTypes()});</span>
    }
}

// Dates

/**
 * The persistence delegate for &lt;CODE&gt;java.util.Date&lt;/CODE&gt; classes.
 * Do not extend DefaultPersistenceDelegate to improve performance and
 * to avoid problems with &lt;CODE&gt;java.sql.Date&lt;/CODE&gt;,
 * &lt;CODE&gt;java.sql.Time&lt;/CODE&gt; and &lt;CODE&gt;java.sql.Timestamp&lt;/CODE&gt;.
 *
 * @author Sergey A. Malenkov
 */
<span class="nc" id="L272">static class java_util_Date_PersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (!super.mutatesTo(oldInstance, newInstance)) {</span>
<span class="nc" id="L275">            return false;</span>
        }
<span class="nc" id="L277">        Date oldDate = (Date)oldInstance;</span>
<span class="nc" id="L278">        Date newDate = (Date)newInstance;</span>

<span class="nc bnc" id="L280" title="All 2 branches missed.">        return oldDate.getTime() == newDate.getTime();</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L284">        Date date = (Date)oldInstance;</span>
<span class="nc" id="L285">        return new Expression(date, date.getClass(), &quot;new&quot;, new Object[] {date.getTime()});</span>
    }
}

/**
 * The persistence delegate for &lt;CODE&gt;java.sql.Timestamp&lt;/CODE&gt; classes.
 * It supports nanoseconds.
 *
 * @author Sergey A. Malenkov
 */
<span class="nc" id="L295">static final class java_sql_Timestamp_PersistenceDelegate extends java_util_Date_PersistenceDelegate {</span>
<span class="nc" id="L296">    private static final Method getNanosMethod = getNanosMethod();</span>

    private static Method getNanosMethod() {
        try {
<span class="nc" id="L300">            Class&lt;?&gt; c = Class.forName(&quot;java.sql.Timestamp&quot;, true, null);</span>
<span class="nc" id="L301">            return c.getMethod(&quot;getNanos&quot;);</span>
<span class="nc" id="L302">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L303">            return null;</span>
<span class="nc" id="L304">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L305">            throw new AssertionError(e);</span>
        }
    }

    /**
     * Invoke Timstamp getNanos.
     */
    private static int getNanos(Object obj) {
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (getNanosMethod == null)</span>
<span class="nc" id="L314">            throw new AssertionError(&quot;Should not get here&quot;);</span>
        try {
<span class="nc" id="L316">            return (Integer)getNanosMethod.invoke(obj);</span>
<span class="nc" id="L317">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L318">            Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (cause instanceof RuntimeException)</span>
<span class="nc" id="L320">                throw (RuntimeException)cause;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            if (cause instanceof Error)</span>
<span class="nc" id="L322">                throw (Error)cause;</span>
<span class="nc" id="L323">            throw new AssertionError(e);</span>
<span class="nc" id="L324">        } catch (IllegalAccessException iae) {</span>
<span class="nc" id="L325">            throw new AssertionError(iae);</span>
        }
    }

    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
        // assumes oldInstance and newInstance are Timestamps
<span class="nc" id="L331">        int nanos = getNanos(oldInstance);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (nanos != getNanos(newInstance)) {</span>
<span class="nc" id="L333">            out.writeStatement(new Statement(oldInstance, &quot;setNanos&quot;, new Object[] {nanos}));</span>
        }
<span class="nc" id="L335">    }</span>
}

// Collections

/*
The Hashtable and AbstractMap classes have no common ancestor yet may
be handled with a single persistence delegate: one which uses the methods
of the Map insterface exclusively. Attatching the persistence delegates
to the interfaces themselves is fraught however since, in the case of
the Map, both the AbstractMap and HashMap classes are declared to
implement the Map interface, leaving the obvious implementation prone
to repeating their initialization. These issues and questions around
the ordering of delegates attached to interfaces have lead us to
ignore any delegates attached to interfaces and force all persistence
delegates to be registered with concrete classes.
*/

/**
 * The base class for persistence delegates for inner classes
 * that can be created using {@link Collections}.
 *
 * @author Sergey A. Malenkov
 */
<span class="nc" id="L359">private static abstract class java_util_Collections extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (!super.mutatesTo(oldInstance, newInstance)) {</span>
<span class="nc" id="L362">            return false;</span>
        }
<span class="nc bnc" id="L364" title="All 6 branches missed.">        if ((oldInstance instanceof List) || (oldInstance instanceof Set) || (oldInstance instanceof Map)) {</span>
<span class="nc" id="L365">            return oldInstance.equals(newInstance);</span>
        }
<span class="nc" id="L367">        Collection&lt;?&gt; oldC = (Collection&lt;?&gt;) oldInstance;</span>
<span class="nc" id="L368">        Collection&lt;?&gt; newC = (Collection&lt;?&gt;) newInstance;</span>
<span class="nc bnc" id="L369" title="All 4 branches missed.">        return (oldC.size() == newC.size()) &amp;&amp; oldC.containsAll(newC);</span>
    }

    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
        // do not initialize these custom collections in default way
<span class="nc" id="L374">    }</span>

<span class="nc" id="L376">    static final class EmptyList_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L378">            return new Expression(oldInstance, Collections.class, &quot;emptyList&quot;, null);</span>
        }
    }

<span class="nc" id="L382">    static final class EmptySet_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L384">            return new Expression(oldInstance, Collections.class, &quot;emptySet&quot;, null);</span>
        }
    }

<span class="nc" id="L388">    static final class EmptyMap_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L390">            return new Expression(oldInstance, Collections.class, &quot;emptyMap&quot;, null);</span>
        }
    }

<span class="nc" id="L394">    static final class SingletonList_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L396">            List&lt;?&gt; list = (List&lt;?&gt;) oldInstance;</span>
<span class="nc" id="L397">            return new Expression(oldInstance, Collections.class, &quot;singletonList&quot;, new Object[]{list.get(0)});</span>
        }
    }

<span class="nc" id="L401">    static final class SingletonSet_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L403">            Set&lt;?&gt; set = (Set&lt;?&gt;) oldInstance;</span>
<span class="nc" id="L404">            return new Expression(oldInstance, Collections.class, &quot;singleton&quot;, new Object[]{set.iterator().next()});</span>
        }
    }

<span class="nc" id="L408">    static final class SingletonMap_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L410">            Map&lt;?,?&gt; map = (Map&lt;?,?&gt;) oldInstance;</span>
<span class="nc" id="L411">            Object key = map.keySet().iterator().next();</span>
<span class="nc" id="L412">            return new Expression(oldInstance, Collections.class, &quot;singletonMap&quot;, new Object[]{key, map.get(key)});</span>
        }
    }

<span class="nc" id="L416">    static final class UnmodifiableCollection_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L418">            List&lt;?&gt; list = new ArrayList&lt;&gt;((Collection&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L419">            return new Expression(oldInstance, Collections.class, &quot;unmodifiableCollection&quot;, new Object[]{list});</span>
        }
    }

<span class="nc" id="L423">    static final class UnmodifiableList_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L425">            List&lt;?&gt; list = new LinkedList&lt;&gt;((Collection&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L426">            return new Expression(oldInstance, Collections.class, &quot;unmodifiableList&quot;, new Object[]{list});</span>
        }
    }

<span class="nc" id="L430">    static final class UnmodifiableRandomAccessList_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L432">            List&lt;?&gt; list = new ArrayList&lt;&gt;((Collection&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L433">            return new Expression(oldInstance, Collections.class, &quot;unmodifiableList&quot;, new Object[]{list});</span>
        }
    }

<span class="nc" id="L437">    static final class UnmodifiableSet_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L439">            Set&lt;?&gt; set = new HashSet&lt;&gt;((Set&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L440">            return new Expression(oldInstance, Collections.class, &quot;unmodifiableSet&quot;, new Object[]{set});</span>
        }
    }

<span class="nc" id="L444">    static final class UnmodifiableSortedSet_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L446">            SortedSet&lt;?&gt; set = new TreeSet&lt;&gt;((SortedSet&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L447">            return new Expression(oldInstance, Collections.class, &quot;unmodifiableSortedSet&quot;, new Object[]{set});</span>
        }
    }

<span class="nc" id="L451">    static final class UnmodifiableMap_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L453">            Map&lt;?,?&gt; map = new HashMap&lt;&gt;((Map&lt;?,?&gt;) oldInstance);</span>
<span class="nc" id="L454">            return new Expression(oldInstance, Collections.class, &quot;unmodifiableMap&quot;, new Object[]{map});</span>
        }
    }

<span class="nc" id="L458">    static final class UnmodifiableSortedMap_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L460">            SortedMap&lt;?,?&gt; map = new TreeMap&lt;&gt;((SortedMap&lt;?,?&gt;) oldInstance);</span>
<span class="nc" id="L461">            return new Expression(oldInstance, Collections.class, &quot;unmodifiableSortedMap&quot;, new Object[]{map});</span>
        }
    }

<span class="nc" id="L465">    static final class SynchronizedCollection_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L467">            List&lt;?&gt; list = new ArrayList&lt;&gt;((Collection&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L468">            return new Expression(oldInstance, Collections.class, &quot;synchronizedCollection&quot;, new Object[]{list});</span>
        }
    }

<span class="nc" id="L472">    static final class SynchronizedList_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L474">            List&lt;?&gt; list = new LinkedList&lt;&gt;((Collection&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L475">            return new Expression(oldInstance, Collections.class, &quot;synchronizedList&quot;, new Object[]{list});</span>
        }
    }

<span class="nc" id="L479">    static final class SynchronizedRandomAccessList_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L481">            List&lt;?&gt; list = new ArrayList&lt;&gt;((Collection&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L482">            return new Expression(oldInstance, Collections.class, &quot;synchronizedList&quot;, new Object[]{list});</span>
        }
    }

<span class="nc" id="L486">    static final class SynchronizedSet_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L488">            Set&lt;?&gt; set = new HashSet&lt;&gt;((Set&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L489">            return new Expression(oldInstance, Collections.class, &quot;synchronizedSet&quot;, new Object[]{set});</span>
        }
    }

<span class="nc" id="L493">    static final class SynchronizedSortedSet_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L495">            SortedSet&lt;?&gt; set = new TreeSet&lt;&gt;((SortedSet&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L496">            return new Expression(oldInstance, Collections.class, &quot;synchronizedSortedSet&quot;, new Object[]{set});</span>
        }
    }

<span class="nc" id="L500">    static final class SynchronizedMap_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L502">            Map&lt;?,?&gt; map = new HashMap&lt;&gt;((Map&lt;?,?&gt;) oldInstance);</span>
<span class="nc" id="L503">            return new Expression(oldInstance, Collections.class, &quot;synchronizedMap&quot;, new Object[]{map});</span>
        }
    }

<span class="nc" id="L507">    static final class SynchronizedSortedMap_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L509">            SortedMap&lt;?,?&gt; map = new TreeMap&lt;&gt;((SortedMap&lt;?,?&gt;) oldInstance);</span>
<span class="nc" id="L510">            return new Expression(oldInstance, Collections.class, &quot;synchronizedSortedMap&quot;, new Object[]{map});</span>
        }
    }

<span class="nc" id="L514">    static final class CheckedCollection_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L516">            Object type = MetaData.getPrivateFieldValue(oldInstance, &quot;java.util.Collections$CheckedCollection.type&quot;);</span>
<span class="nc" id="L517">            List&lt;?&gt; list = new ArrayList&lt;&gt;((Collection&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L518">            return new Expression(oldInstance, Collections.class, &quot;checkedCollection&quot;, new Object[]{list, type});</span>
        }
    }

<span class="nc" id="L522">    static final class CheckedList_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L524">            Object type = MetaData.getPrivateFieldValue(oldInstance, &quot;java.util.Collections$CheckedCollection.type&quot;);</span>
<span class="nc" id="L525">            List&lt;?&gt; list = new LinkedList&lt;&gt;((Collection&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L526">            return new Expression(oldInstance, Collections.class, &quot;checkedList&quot;, new Object[]{list, type});</span>
        }
    }

<span class="nc" id="L530">    static final class CheckedRandomAccessList_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L532">            Object type = MetaData.getPrivateFieldValue(oldInstance, &quot;java.util.Collections$CheckedCollection.type&quot;);</span>
<span class="nc" id="L533">            List&lt;?&gt; list = new ArrayList&lt;&gt;((Collection&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L534">            return new Expression(oldInstance, Collections.class, &quot;checkedList&quot;, new Object[]{list, type});</span>
        }
    }

<span class="nc" id="L538">    static final class CheckedSet_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L540">            Object type = MetaData.getPrivateFieldValue(oldInstance, &quot;java.util.Collections$CheckedCollection.type&quot;);</span>
<span class="nc" id="L541">            Set&lt;?&gt; set = new HashSet&lt;&gt;((Set&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L542">            return new Expression(oldInstance, Collections.class, &quot;checkedSet&quot;, new Object[]{set, type});</span>
        }
    }

<span class="nc" id="L546">    static final class CheckedSortedSet_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L548">            Object type = MetaData.getPrivateFieldValue(oldInstance, &quot;java.util.Collections$CheckedCollection.type&quot;);</span>
<span class="nc" id="L549">            SortedSet&lt;?&gt; set = new TreeSet&lt;&gt;((SortedSet&lt;?&gt;) oldInstance);</span>
<span class="nc" id="L550">            return new Expression(oldInstance, Collections.class, &quot;checkedSortedSet&quot;, new Object[]{set, type});</span>
        }
    }

<span class="nc" id="L554">    static final class CheckedMap_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L556">            Object keyType   = MetaData.getPrivateFieldValue(oldInstance, &quot;java.util.Collections$CheckedMap.keyType&quot;);</span>
<span class="nc" id="L557">            Object valueType = MetaData.getPrivateFieldValue(oldInstance, &quot;java.util.Collections$CheckedMap.valueType&quot;);</span>
<span class="nc" id="L558">            Map&lt;?,?&gt; map = new HashMap&lt;&gt;((Map&lt;?,?&gt;) oldInstance);</span>
<span class="nc" id="L559">            return new Expression(oldInstance, Collections.class, &quot;checkedMap&quot;, new Object[]{map, keyType, valueType});</span>
        }
    }

<span class="nc" id="L563">    static final class CheckedSortedMap_PersistenceDelegate extends java_util_Collections {</span>
        protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L565">            Object keyType   = MetaData.getPrivateFieldValue(oldInstance, &quot;java.util.Collections$CheckedMap.keyType&quot;);</span>
<span class="nc" id="L566">            Object valueType = MetaData.getPrivateFieldValue(oldInstance, &quot;java.util.Collections$CheckedMap.valueType&quot;);</span>
<span class="nc" id="L567">            SortedMap&lt;?,?&gt; map = new TreeMap&lt;&gt;((SortedMap&lt;?,?&gt;) oldInstance);</span>
<span class="nc" id="L568">            return new Expression(oldInstance, Collections.class, &quot;checkedSortedMap&quot;, new Object[]{map, keyType, valueType});</span>
        }
    }
}

/**
 * The persistence delegate for &lt;CODE&gt;java.util.EnumMap&lt;/CODE&gt; classes.
 *
 * @author Sergey A. Malenkov
 */
<span class="nc" id="L578">static final class java_util_EnumMap_PersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc bnc" id="L580" title="All 4 branches missed.">        return super.mutatesTo(oldInstance, newInstance) &amp;&amp; (getType(oldInstance) == getType(newInstance));</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L584">        return new Expression(oldInstance, EnumMap.class, &quot;new&quot;, new Object[] {getType(oldInstance)});</span>
    }

    private static Object getType(Object instance) {
<span class="nc" id="L588">        return MetaData.getPrivateFieldValue(instance, &quot;java.util.EnumMap.keyType&quot;);</span>
    }
}

/**
 * The persistence delegate for &lt;CODE&gt;java.util.EnumSet&lt;/CODE&gt; classes.
 *
 * @author Sergey A. Malenkov
 */
<span class="nc" id="L597">static final class java_util_EnumSet_PersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc bnc" id="L599" title="All 4 branches missed.">        return super.mutatesTo(oldInstance, newInstance) &amp;&amp; (getType(oldInstance) == getType(newInstance));</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L603">        return new Expression(oldInstance, EnumSet.class, &quot;noneOf&quot;, new Object[] {getType(oldInstance)});</span>
    }

    private static Object getType(Object instance) {
<span class="nc" id="L607">        return MetaData.getPrivateFieldValue(instance, &quot;java.util.EnumSet.elementType&quot;);</span>
    }
}

// Collection
<span class="nc" id="L612">static class java_util_Collection_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L614">        java.util.Collection&lt;?&gt; oldO = (java.util.Collection)oldInstance;</span>
<span class="nc" id="L615">        java.util.Collection&lt;?&gt; newO = (java.util.Collection)newInstance;</span>

<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (newO.size() != 0) {</span>
<span class="nc" id="L618">            invokeStatement(oldInstance, &quot;clear&quot;, new Object[]{}, out);</span>
        }
<span class="nc bnc" id="L620" title="All 2 branches missed.">        for (Iterator&lt;?&gt; i = oldO.iterator(); i.hasNext();) {</span>
<span class="nc" id="L621">            invokeStatement(oldInstance, &quot;add&quot;, new Object[]{i.next()}, out);</span>
        }
<span class="nc" id="L623">    }</span>
}

// List
<span class="nc" id="L627">static class java_util_List_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L629">        java.util.List&lt;?&gt; oldO = (java.util.List&lt;?&gt;)oldInstance;</span>
<span class="nc" id="L630">        java.util.List&lt;?&gt; newO = (java.util.List&lt;?&gt;)newInstance;</span>
<span class="nc" id="L631">        int oldSize = oldO.size();</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        int newSize = (newO == null) ? 0 : newO.size();</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">        if (oldSize &lt; newSize) {</span>
<span class="nc" id="L634">            invokeStatement(oldInstance, &quot;clear&quot;, new Object[]{}, out);</span>
<span class="nc" id="L635">            newSize = 0;</span>
        }
<span class="nc bnc" id="L637" title="All 2 branches missed.">        for (int i = 0; i &lt; newSize; i++) {</span>
<span class="nc" id="L638">            Object index = new Integer(i);</span>

<span class="nc" id="L640">            Expression oldGetExp = new Expression(oldInstance, &quot;get&quot;, new Object[]{index});</span>
<span class="nc" id="L641">            Expression newGetExp = new Expression(newInstance, &quot;get&quot;, new Object[]{index});</span>
            try {
<span class="nc" id="L643">                Object oldValue = oldGetExp.getValue();</span>
<span class="nc" id="L644">                Object newValue = newGetExp.getValue();</span>
<span class="nc" id="L645">                out.writeExpression(oldGetExp);</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">                if (!Objects.equals(newValue, out.get(oldValue))) {</span>
<span class="nc" id="L647">                    invokeStatement(oldInstance, &quot;set&quot;, new Object[]{index, oldValue}, out);</span>
                }
            }
<span class="nc" id="L650">            catch (Exception e) {</span>
<span class="nc" id="L651">                out.getExceptionListener().exceptionThrown(e);</span>
<span class="nc" id="L652">            }</span>
        }
<span class="nc bnc" id="L654" title="All 2 branches missed.">        for (int i = newSize; i &lt; oldSize; i++) {</span>
<span class="nc" id="L655">            invokeStatement(oldInstance, &quot;add&quot;, new Object[]{oldO.get(i)}, out);</span>
        }
<span class="nc" id="L657">    }</span>
}


// Map
<span class="nc" id="L662">static class java_util_Map_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
        // System.out.println(&quot;Initializing: &quot; + newInstance);
<span class="nc" id="L665">        java.util.Map&lt;?,?&gt; oldMap = (java.util.Map)oldInstance;</span>
<span class="nc" id="L666">        java.util.Map&lt;?,?&gt; newMap = (java.util.Map)newInstance;</span>
        // Remove the new elements.
        // Do this first otherwise we undo the adding work.
<span class="nc bnc" id="L669" title="All 2 branches missed.">        if (newMap != null) {</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            for (Object newKey : newMap.keySet().toArray()) {</span>
               // PENDING: This &quot;key&quot; is not in the right environment.
<span class="nc bnc" id="L672" title="All 2 branches missed.">                if (!oldMap.containsKey(newKey)) {</span>
<span class="nc" id="L673">                    invokeStatement(oldInstance, &quot;remove&quot;, new Object[]{newKey}, out);</span>
                }
            }
        }
        // Add the new elements.
<span class="nc bnc" id="L678" title="All 2 branches missed.">        for ( Object oldKey : oldMap.keySet() ) {</span>
<span class="nc" id="L679">            Expression oldGetExp = new Expression(oldInstance, &quot;get&quot;, new Object[]{oldKey});</span>
            // Pending: should use newKey.
<span class="nc" id="L681">            Expression newGetExp = new Expression(newInstance, &quot;get&quot;, new Object[]{oldKey});</span>
            try {
<span class="nc" id="L683">                Object oldValue = oldGetExp.getValue();</span>
<span class="nc" id="L684">                Object newValue = newGetExp.getValue();</span>
<span class="nc" id="L685">                out.writeExpression(oldGetExp);</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">                if (!Objects.equals(newValue, out.get(oldValue))) {</span>
<span class="nc" id="L687">                    invokeStatement(oldInstance, &quot;put&quot;, new Object[]{oldKey, oldValue}, out);</span>
<span class="nc bnc" id="L688" title="All 4 branches missed.">                } else if ((newValue == null) &amp;&amp; !newMap.containsKey(oldKey)) {</span>
                    // put oldValue(=null?) if oldKey is absent in newMap
<span class="nc" id="L690">                    invokeStatement(oldInstance, &quot;put&quot;, new Object[]{oldKey, oldValue}, out);</span>
                }
            }
<span class="nc" id="L693">            catch (Exception e) {</span>
<span class="nc" id="L694">                out.getExceptionListener().exceptionThrown(e);</span>
<span class="nc" id="L695">            }</span>
<span class="nc" id="L696">        }</span>
<span class="nc" id="L697">    }</span>
}

<span class="nc" id="L700">static final class java_util_AbstractCollection_PersistenceDelegate extends java_util_Collection_PersistenceDelegate {}</span>
<span class="nc" id="L701">static final class java_util_AbstractList_PersistenceDelegate extends java_util_List_PersistenceDelegate {}</span>
<span class="nc" id="L702">static final class java_util_AbstractMap_PersistenceDelegate extends java_util_Map_PersistenceDelegate {}</span>
<span class="nc" id="L703">static final class java_util_Hashtable_PersistenceDelegate extends java_util_Map_PersistenceDelegate {}</span>


// Beans
<span class="nc" id="L707">static final class java_beans_beancontext_BeanContextSupport_PersistenceDelegate extends java_util_Collection_PersistenceDelegate {}</span>

// AWT

/**
 * The persistence delegate for {@link Insets}.
 * It is impossible to use {@link DefaultPersistenceDelegate}
 * because this class does not have any properties.
 *
 * @author Sergey A. Malenkov
 */
<span class="nc" id="L718">static final class java_awt_Insets_PersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc" id="L720">        return oldInstance.equals(newInstance);</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L724">        Insets insets = (Insets) oldInstance;</span>
<span class="nc" id="L725">        Object[] args = new Object[] {</span>
<span class="nc" id="L726">                insets.top,</span>
<span class="nc" id="L727">                insets.left,</span>
<span class="nc" id="L728">                insets.bottom,</span>
<span class="nc" id="L729">                insets.right,</span>
        };
<span class="nc" id="L731">        return new Expression(insets, insets.getClass(), &quot;new&quot;, args);</span>
    }
}

/**
 * The persistence delegate for {@link Font}.
 * It is impossible to use {@link DefaultPersistenceDelegate}
 * because size of the font can be float value.
 *
 * @author Sergey A. Malenkov
 */
<span class="nc" id="L742">static final class java_awt_Font_PersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc" id="L744">        return oldInstance.equals(newInstance);</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L748">        Font font = (Font) oldInstance;</span>

<span class="nc" id="L750">        int count = 0;</span>
<span class="nc" id="L751">        String family = null;</span>
<span class="nc" id="L752">        int style = Font.PLAIN;</span>
<span class="nc" id="L753">        int size = 12;</span>

<span class="nc" id="L755">        Map&lt;TextAttribute, ?&gt; basic = font.getAttributes();</span>
<span class="nc" id="L756">        Map&lt;TextAttribute, Object&gt; clone = new HashMap&lt;&gt;(basic.size());</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">        for (TextAttribute key : basic.keySet()) {</span>
<span class="nc" id="L758">            Object value = basic.get(key);</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">            if (value != null) {</span>
<span class="nc" id="L760">                clone.put(key, value);</span>
            }
<span class="nc bnc" id="L762" title="All 2 branches missed.">            if (key == TextAttribute.FAMILY) {</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">                if (value instanceof String) {</span>
<span class="nc" id="L764">                    count++;</span>
<span class="nc" id="L765">                    family = (String) value;</span>
                }
            }
<span class="nc bnc" id="L768" title="All 2 branches missed.">            else if (key == TextAttribute.WEIGHT) {</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                if (TextAttribute.WEIGHT_REGULAR.equals(value)) {</span>
<span class="nc" id="L770">                    count++;</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">                } else if (TextAttribute.WEIGHT_BOLD.equals(value)) {</span>
<span class="nc" id="L772">                    count++;</span>
<span class="nc" id="L773">                    style |= Font.BOLD;</span>
                }
            }
<span class="nc bnc" id="L776" title="All 2 branches missed.">            else if (key == TextAttribute.POSTURE) {</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">                if (TextAttribute.POSTURE_REGULAR.equals(value)) {</span>
<span class="nc" id="L778">                    count++;</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                } else if (TextAttribute.POSTURE_OBLIQUE.equals(value)) {</span>
<span class="nc" id="L780">                    count++;</span>
<span class="nc" id="L781">                    style |= Font.ITALIC;</span>
                }
<span class="nc bnc" id="L783" title="All 2 branches missed.">            } else if (key == TextAttribute.SIZE) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">                if (value instanceof Number) {</span>
<span class="nc" id="L785">                    Number number = (Number) value;</span>
<span class="nc" id="L786">                    size = number.intValue();</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">                    if (size == number.floatValue()) {</span>
<span class="nc" id="L788">                        count++;</span>
                    }
                }
            }
<span class="nc" id="L792">        }</span>
<span class="nc" id="L793">        Class&lt;?&gt; type = font.getClass();</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (count == clone.size()) {</span>
<span class="nc" id="L795">            return new Expression(font, type, &quot;new&quot;, new Object[]{family, style, size});</span>
        }
<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (type == Font.class) {</span>
<span class="nc" id="L798">            return new Expression(font, type, &quot;getFont&quot;, new Object[]{clone});</span>
        }
<span class="nc" id="L800">        return new Expression(font, type, &quot;new&quot;, new Object[]{Font.getFont(clone)});</span>
    }
}

/**
 * The persistence delegate for {@link AWTKeyStroke}.
 * It is impossible to use {@link DefaultPersistenceDelegate}
 * because this class have no public constructor.
 *
 * @author Sergey A. Malenkov
 */
<span class="nc" id="L811">static final class java_awt_AWTKeyStroke_PersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc" id="L813">        return oldInstance.equals(newInstance);</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L817">        AWTKeyStroke key = (AWTKeyStroke) oldInstance;</span>

<span class="nc" id="L819">        char ch = key.getKeyChar();</span>
<span class="nc" id="L820">        int code = key.getKeyCode();</span>
<span class="nc" id="L821">        int mask = key.getModifiers();</span>
<span class="nc" id="L822">        boolean onKeyRelease = key.isOnKeyRelease();</span>

<span class="nc" id="L824">        Object[] args = null;</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (ch == KeyEvent.CHAR_UNDEFINED) {</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">            args = !onKeyRelease</span>
<span class="nc" id="L827">                    ? new Object[]{code, mask}</span>
<span class="nc" id="L828">                    : new Object[]{code, mask, onKeyRelease};</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">        } else if (code == KeyEvent.VK_UNDEFINED) {</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">            if (!onKeyRelease) {</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">                args = (mask == 0)</span>
<span class="nc" id="L832">                        ? new Object[]{ch}</span>
<span class="nc" id="L833">                        : new Object[]{ch, mask};</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">            } else if (mask == 0) {</span>
<span class="nc" id="L835">                args = new Object[]{ch, onKeyRelease};</span>
            }
        }
<span class="nc bnc" id="L838" title="All 2 branches missed.">        if (args == null) {</span>
<span class="nc" id="L839">            throw new IllegalStateException(&quot;Unsupported KeyStroke: &quot; + key);</span>
        }
<span class="nc" id="L841">        Class&lt;?&gt; type = key.getClass();</span>
<span class="nc" id="L842">        String name = type.getName();</span>
        // get short name of the class
<span class="nc" id="L844">        int index = name.lastIndexOf('.') + 1;</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">        if (index &gt; 0) {</span>
<span class="nc" id="L846">            name = name.substring(index);</span>
        }
<span class="nc" id="L848">        return new Expression( key, type, &quot;get&quot; + name, args );</span>
    }
}

<span class="nc" id="L852">static class StaticFieldsPersistenceDelegate extends PersistenceDelegate {</span>
    protected void installFields(Encoder out, Class&lt;?&gt; cls) {
<span class="nc bnc" id="L854" title="All 4 branches missed.">        if (Modifier.isPublic(cls.getModifiers()) &amp;&amp; isPackageAccessible(cls)) {</span>
<span class="nc" id="L855">            Field fields[] = cls.getFields();</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">            for(int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc" id="L857">                Field field = fields[i];</span>
                // Don't install primitives, their identity will not be preserved
                // by wrapping.
<span class="nc bnc" id="L860" title="All 2 branches missed.">                if (Object.class.isAssignableFrom(field.getType())) {</span>
<span class="nc" id="L861">                    out.writeExpression(new Expression(field, &quot;get&quot;, new Object[]{null}));</span>
                }
            }
        }
<span class="nc" id="L865">    }</span>

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L868">        throw new RuntimeException(&quot;Unrecognized instance: &quot; + oldInstance);</span>
    }

    public void writeObject(Object oldInstance, Encoder out) {
<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (out.getAttribute(this) == null) {</span>
<span class="nc" id="L873">            out.setAttribute(this, Boolean.TRUE);</span>
<span class="nc" id="L874">            installFields(out, oldInstance.getClass());</span>
        }
<span class="nc" id="L876">        super.writeObject(oldInstance, out);</span>
<span class="nc" id="L877">    }</span>
}

// SystemColor
<span class="nc" id="L881">static final class java_awt_SystemColor_PersistenceDelegate extends StaticFieldsPersistenceDelegate {}</span>

// TextAttribute
<span class="nc" id="L884">static final class java_awt_font_TextAttribute_PersistenceDelegate extends StaticFieldsPersistenceDelegate {}</span>

// MenuShortcut
<span class="nc" id="L887">static final class java_awt_MenuShortcut_PersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc" id="L889">        return oldInstance.equals(newInstance);</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L893">        java.awt.MenuShortcut m = (java.awt.MenuShortcut)oldInstance;</span>
<span class="nc" id="L894">        return new Expression(oldInstance, m.getClass(), &quot;new&quot;,</span>
<span class="nc" id="L895">                   new Object[]{new Integer(m.getKey()), Boolean.valueOf(m.usesShiftModifier())});</span>
    }
}

// Component
<span class="nc" id="L900">static final class java_awt_Component_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L902">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L903">        java.awt.Component c = (java.awt.Component)oldInstance;</span>
<span class="nc" id="L904">        java.awt.Component c2 = (java.awt.Component)newInstance;</span>
        // The &quot;background&quot;, &quot;foreground&quot; and &quot;font&quot; properties.
        // The foreground and font properties of Windows change from
        // null to defined values after the Windows are made visible -
        // special case them for now.
<span class="nc bnc" id="L909" title="All 2 branches missed.">        if (!(oldInstance instanceof java.awt.Window)) {</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">            Object oldBackground = c.isBackgroundSet() ? c.getBackground() : null;</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">            Object newBackground = c2.isBackgroundSet() ? c2.getBackground() : null;</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">            if (!Objects.equals(oldBackground, newBackground)) {</span>
<span class="nc" id="L913">                invokeStatement(oldInstance, &quot;setBackground&quot;, new Object[] { oldBackground }, out);</span>
            }
<span class="nc bnc" id="L915" title="All 2 branches missed.">            Object oldForeground = c.isForegroundSet() ? c.getForeground() : null;</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">            Object newForeground = c2.isForegroundSet() ? c2.getForeground() : null;</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">            if (!Objects.equals(oldForeground, newForeground)) {</span>
<span class="nc" id="L918">                invokeStatement(oldInstance, &quot;setForeground&quot;, new Object[] { oldForeground }, out);</span>
            }
<span class="nc bnc" id="L920" title="All 2 branches missed.">            Object oldFont = c.isFontSet() ? c.getFont() : null;</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">            Object newFont = c2.isFontSet() ? c2.getFont() : null;</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">            if (!Objects.equals(oldFont, newFont)) {</span>
<span class="nc" id="L923">                invokeStatement(oldInstance, &quot;setFont&quot;, new Object[] { oldFont }, out);</span>
            }
        }

        // Bounds
<span class="nc" id="L928">        java.awt.Container p = c.getParent();</span>
<span class="nc bnc" id="L929" title="All 4 branches missed.">        if (p == null || p.getLayout() == null) {</span>
            // Use the most concise construct.
<span class="nc" id="L931">            boolean locationCorrect = c.getLocation().equals(c2.getLocation());</span>
<span class="nc" id="L932">            boolean sizeCorrect = c.getSize().equals(c2.getSize());</span>
<span class="nc bnc" id="L933" title="All 4 branches missed.">            if (!locationCorrect &amp;&amp; !sizeCorrect) {</span>
<span class="nc" id="L934">                invokeStatement(oldInstance, &quot;setBounds&quot;, new Object[]{c.getBounds()}, out);</span>
            }
<span class="nc bnc" id="L936" title="All 2 branches missed.">            else if (!locationCorrect) {</span>
<span class="nc" id="L937">                invokeStatement(oldInstance, &quot;setLocation&quot;, new Object[]{c.getLocation()}, out);</span>
            }
<span class="nc bnc" id="L939" title="All 2 branches missed.">            else if (!sizeCorrect) {</span>
<span class="nc" id="L940">                invokeStatement(oldInstance, &quot;setSize&quot;, new Object[]{c.getSize()}, out);</span>
            }
        }
<span class="nc" id="L943">    }</span>
}

// Container
<span class="nc" id="L947">static final class java_awt_Container_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L949">        super.initialize(type, oldInstance, newInstance, out);</span>
        // Ignore the children of a JScrollPane.
        // Pending(milne) find a better way to do this.
<span class="nc bnc" id="L952" title="All 2 branches missed.">        if (oldInstance instanceof javax.swing.JScrollPane) {</span>
<span class="nc" id="L953">            return;</span>
        }
<span class="nc" id="L955">        java.awt.Container oldC = (java.awt.Container)oldInstance;</span>
<span class="nc" id="L956">        java.awt.Component[] oldChildren = oldC.getComponents();</span>
<span class="nc" id="L957">        java.awt.Container newC = (java.awt.Container)newInstance;</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">        java.awt.Component[] newChildren = (newC == null) ? new java.awt.Component[0] : newC.getComponents();</span>

<span class="nc bnc" id="L960" title="All 2 branches missed.">        BorderLayout layout = ( oldC.getLayout() instanceof BorderLayout )</span>
<span class="nc" id="L961">                ? ( BorderLayout )oldC.getLayout()</span>
                : null;

<span class="nc bnc" id="L964" title="All 2 branches missed.">        JLayeredPane oldLayeredPane = (oldInstance instanceof JLayeredPane)</span>
                ? (JLayeredPane) oldInstance
                : null;

        // Pending. Assume all the new children are unaltered.
<span class="nc bnc" id="L969" title="All 2 branches missed.">        for(int i = newChildren.length; i &lt; oldChildren.length; i++) {</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">            Object[] args = ( layout != null )</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">                    ? new Object[] {oldChildren[i], layout.getConstraints( oldChildren[i] )}</span>
                    : (oldLayeredPane != null)
<span class="nc" id="L973">                            ? new Object[] {oldChildren[i], oldLayeredPane.getLayer(oldChildren[i]), Integer.valueOf(-1)}</span>
                            : new Object[] {oldChildren[i]};

<span class="nc" id="L976">            invokeStatement(oldInstance, &quot;add&quot;, args, out);</span>
        }
<span class="nc" id="L978">    }</span>
}

// Choice
<span class="nc" id="L982">static final class java_awt_Choice_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L984">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L985">        java.awt.Choice m = (java.awt.Choice)oldInstance;</span>
<span class="nc" id="L986">        java.awt.Choice n = (java.awt.Choice)newInstance;</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">        for (int i = n.getItemCount(); i &lt; m.getItemCount(); i++) {</span>
<span class="nc" id="L988">            invokeStatement(oldInstance, &quot;add&quot;, new Object[]{m.getItem(i)}, out);</span>
        }
<span class="nc" id="L990">    }</span>
}

// Menu
<span class="nc" id="L994">static final class java_awt_Menu_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L996">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L997">        java.awt.Menu m = (java.awt.Menu)oldInstance;</span>
<span class="nc" id="L998">        java.awt.Menu n = (java.awt.Menu)newInstance;</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">        for (int i = n.getItemCount(); i &lt; m.getItemCount(); i++) {</span>
<span class="nc" id="L1000">            invokeStatement(oldInstance, &quot;add&quot;, new Object[]{m.getItem(i)}, out);</span>
        }
<span class="nc" id="L1002">    }</span>
}

// MenuBar
<span class="nc" id="L1006">static final class java_awt_MenuBar_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L1008">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L1009">        java.awt.MenuBar m = (java.awt.MenuBar)oldInstance;</span>
<span class="nc" id="L1010">        java.awt.MenuBar n = (java.awt.MenuBar)newInstance;</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">        for (int i = n.getMenuCount(); i &lt; m.getMenuCount(); i++) {</span>
<span class="nc" id="L1012">            invokeStatement(oldInstance, &quot;add&quot;, new Object[]{m.getMenu(i)}, out);</span>
        }
<span class="nc" id="L1014">    }</span>
}

// List
<span class="nc" id="L1018">static final class java_awt_List_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L1020">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L1021">        java.awt.List m = (java.awt.List)oldInstance;</span>
<span class="nc" id="L1022">        java.awt.List n = (java.awt.List)newInstance;</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">        for (int i = n.getItemCount(); i &lt; m.getItemCount(); i++) {</span>
<span class="nc" id="L1024">            invokeStatement(oldInstance, &quot;add&quot;, new Object[]{m.getItem(i)}, out);</span>
        }
<span class="nc" id="L1026">    }</span>
}


// LayoutManagers

// BorderLayout
<span class="nc" id="L1033">static final class java_awt_BorderLayout_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
<span class="nc" id="L1034">    private static final String[] CONSTRAINTS = {</span>
            BorderLayout.NORTH,
            BorderLayout.SOUTH,
            BorderLayout.EAST,
            BorderLayout.WEST,
            BorderLayout.CENTER,
            BorderLayout.PAGE_START,
            BorderLayout.PAGE_END,
            BorderLayout.LINE_START,
            BorderLayout.LINE_END,
    };
    @Override
    protected void initialize(Class&lt;?&gt; type, Object oldInstance,
                              Object newInstance, Encoder out) {
<span class="nc" id="L1048">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L1049">        BorderLayout oldLayout = (BorderLayout) oldInstance;</span>
<span class="nc" id="L1050">        BorderLayout newLayout = (BorderLayout) newInstance;</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">        for (String constraints : CONSTRAINTS) {</span>
<span class="nc" id="L1052">            Object oldC = oldLayout.getLayoutComponent(constraints);</span>
<span class="nc" id="L1053">            Object newC = newLayout.getLayoutComponent(constraints);</span>
            // Pending, assume any existing elements are OK.
<span class="nc bnc" id="L1055" title="All 4 branches missed.">            if (oldC != null &amp;&amp; newC == null) {</span>
<span class="nc" id="L1056">                invokeStatement(oldInstance, &quot;addLayoutComponent&quot;,</span>
                                new Object[] { oldC, constraints }, out);
            }
        }
<span class="nc" id="L1060">    }</span>
}

// CardLayout
<span class="nc" id="L1064">static final class java_awt_CardLayout_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance,
                              Object newInstance, Encoder out) {
<span class="nc" id="L1067">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">        if (getVector(newInstance).isEmpty()) {</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">            for (Object card : getVector(oldInstance)) {</span>
<span class="nc" id="L1070">                Object[] args = {MetaData.getPrivateFieldValue(card, &quot;java.awt.CardLayout$Card.name&quot;),</span>
<span class="nc" id="L1071">                                 MetaData.getPrivateFieldValue(card, &quot;java.awt.CardLayout$Card.comp&quot;)};</span>
<span class="nc" id="L1072">                invokeStatement(oldInstance, &quot;addLayoutComponent&quot;, args, out);</span>
<span class="nc" id="L1073">            }</span>
        }
<span class="nc" id="L1075">    }</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc bnc" id="L1077" title="All 4 branches missed.">        return super.mutatesTo(oldInstance, newInstance) &amp;&amp; getVector(newInstance).isEmpty();</span>
    }
    private static Vector&lt;?&gt; getVector(Object instance) {
<span class="nc" id="L1080">        return (Vector&lt;?&gt;) MetaData.getPrivateFieldValue(instance, &quot;java.awt.CardLayout.vector&quot;);</span>
    }
}

// GridBagLayout
<span class="nc" id="L1085">static final class java_awt_GridBagLayout_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance,
                              Object newInstance, Encoder out) {
<span class="nc" id="L1088">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (getHashtable(newInstance).isEmpty()) {</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            for (Map.Entry&lt;?,?&gt; entry : getHashtable(oldInstance).entrySet()) {</span>
<span class="nc" id="L1091">                Object[] args = {entry.getKey(), entry.getValue()};</span>
<span class="nc" id="L1092">                invokeStatement(oldInstance, &quot;addLayoutComponent&quot;, args, out);</span>
<span class="nc" id="L1093">            }</span>
        }
<span class="nc" id="L1095">    }</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc bnc" id="L1097" title="All 4 branches missed.">        return super.mutatesTo(oldInstance, newInstance) &amp;&amp; getHashtable(newInstance).isEmpty();</span>
    }
    private static Hashtable&lt;?,?&gt; getHashtable(Object instance) {
<span class="nc" id="L1100">        return (Hashtable&lt;?,?&gt;) MetaData.getPrivateFieldValue(instance, &quot;java.awt.GridBagLayout.comptable&quot;);</span>
    }
}

// Swing

// JFrame (If we do this for Window instead of JFrame, the setVisible call
// will be issued before we have added all the children to the JFrame and
// will appear blank).
<span class="nc" id="L1109">static final class javax_swing_JFrame_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L1111">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L1112">        java.awt.Window oldC = (java.awt.Window)oldInstance;</span>
<span class="nc" id="L1113">        java.awt.Window newC = (java.awt.Window)newInstance;</span>
<span class="nc" id="L1114">        boolean oldV = oldC.isVisible();</span>
<span class="nc" id="L1115">        boolean newV = newC.isVisible();</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">        if (newV != oldV) {</span>
            // false means: don't execute this statement at write time.
<span class="nc" id="L1118">            boolean executeStatements = out.executeStatements;</span>
<span class="nc" id="L1119">            out.executeStatements = false;</span>
<span class="nc" id="L1120">            invokeStatement(oldInstance, &quot;setVisible&quot;, new Object[]{Boolean.valueOf(oldV)}, out);</span>
<span class="nc" id="L1121">            out.executeStatements = executeStatements;</span>
        }
<span class="nc" id="L1123">    }</span>
}

// Models

// DefaultListModel
<span class="nc" id="L1129">static final class javax_swing_DefaultListModel_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
        // Note, the &quot;size&quot; property will be set here.
<span class="nc" id="L1132">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L1133">        javax.swing.DefaultListModel&lt;?&gt; m = (javax.swing.DefaultListModel&lt;?&gt;)oldInstance;</span>
<span class="nc" id="L1134">        javax.swing.DefaultListModel&lt;?&gt; n = (javax.swing.DefaultListModel&lt;?&gt;)newInstance;</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        for (int i = n.getSize(); i &lt; m.getSize(); i++) {</span>
<span class="nc" id="L1136">            invokeStatement(oldInstance, &quot;add&quot;, // Can also use &quot;addElement&quot;.</span>
<span class="nc" id="L1137">                    new Object[]{m.getElementAt(i)}, out);</span>
        }
<span class="nc" id="L1139">    }</span>
}

// DefaultComboBoxModel
<span class="nc" id="L1143">static final class javax_swing_DefaultComboBoxModel_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L1145">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L1146">        javax.swing.DefaultComboBoxModel&lt;?&gt; m = (javax.swing.DefaultComboBoxModel&lt;?&gt;)oldInstance;</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        for (int i = 0; i &lt; m.getSize(); i++) {</span>
<span class="nc" id="L1148">            invokeStatement(oldInstance, &quot;addElement&quot;, new Object[]{m.getElementAt(i)}, out);</span>
        }
<span class="nc" id="L1150">    }</span>
}


// DefaultMutableTreeNode
<span class="nc" id="L1155">static final class javax_swing_tree_DefaultMutableTreeNode_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object
                              newInstance, Encoder out) {
<span class="nc" id="L1158">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L1159">        javax.swing.tree.DefaultMutableTreeNode m =</span>
            (javax.swing.tree.DefaultMutableTreeNode)oldInstance;
<span class="nc" id="L1161">        javax.swing.tree.DefaultMutableTreeNode n =</span>
            (javax.swing.tree.DefaultMutableTreeNode)newInstance;
<span class="nc bnc" id="L1163" title="All 2 branches missed.">        for (int i = n.getChildCount(); i &lt; m.getChildCount(); i++) {</span>
<span class="nc" id="L1164">            invokeStatement(oldInstance, &quot;add&quot;, new</span>
<span class="nc" id="L1165">                Object[]{m.getChildAt(i)}, out);</span>
        }
<span class="nc" id="L1167">    }</span>
}

// ToolTipManager
<span class="nc" id="L1171">static final class javax_swing_ToolTipManager_PersistenceDelegate extends PersistenceDelegate {</span>
    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L1173">        return new Expression(oldInstance, javax.swing.ToolTipManager.class,</span>
                              &quot;sharedInstance&quot;, new Object[]{});
    }
}

// JTabbedPane
<span class="nc" id="L1179">static final class javax_swing_JTabbedPane_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L1181">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L1182">        javax.swing.JTabbedPane p = (javax.swing.JTabbedPane)oldInstance;</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">        for (int i = 0; i &lt; p.getTabCount(); i++) {</span>
<span class="nc" id="L1184">            invokeStatement(oldInstance, &quot;addTab&quot;,</span>
                                          new Object[]{
<span class="nc" id="L1186">                                              p.getTitleAt(i),</span>
<span class="nc" id="L1187">                                              p.getIconAt(i),</span>
<span class="nc" id="L1188">                                              p.getComponentAt(i)}, out);</span>
        }
<span class="nc" id="L1190">    }</span>
}

// Box
<span class="nc" id="L1194">static final class javax_swing_Box_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc bnc" id="L1196" title="All 4 branches missed.">        return super.mutatesTo(oldInstance, newInstance) &amp;&amp; getAxis(oldInstance).equals(getAxis(newInstance));</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L1200">        return new Expression(oldInstance, oldInstance.getClass(), &quot;new&quot;, new Object[] {getAxis(oldInstance)});</span>
    }

    private Integer getAxis(Object object) {
<span class="nc" id="L1204">        Box box = (Box) object;</span>
<span class="nc" id="L1205">        return (Integer) MetaData.getPrivateFieldValue(box.getLayout(), &quot;javax.swing.BoxLayout.axis&quot;);</span>
    }
}

// JMenu
// Note that we do not need to state the initialiser for
// JMenuItems since the getComponents() method defined in
// Container will return all of the sub menu items that
// need to be added to the menu item.
// Not so for JMenu apparently.
<span class="nc" id="L1215">static final class javax_swing_JMenu_PersistenceDelegate extends DefaultPersistenceDelegate {</span>
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
<span class="nc" id="L1217">        super.initialize(type, oldInstance, newInstance, out);</span>
<span class="nc" id="L1218">        javax.swing.JMenu m = (javax.swing.JMenu)oldInstance;</span>
<span class="nc" id="L1219">        java.awt.Component[] c = m.getMenuComponents();</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        for (int i = 0; i &lt; c.length; i++) {</span>
<span class="nc" id="L1221">            invokeStatement(oldInstance, &quot;add&quot;, new Object[]{c[i]}, out);</span>
        }
<span class="nc" id="L1223">    }</span>
}

/**
 * The persistence delegate for {@link MatteBorder}.
 * It is impossible to use {@link DefaultPersistenceDelegate}
 * because this class does not have writable properties.
 *
 * @author Sergey A. Malenkov
 */
<span class="nc" id="L1233">static final class javax_swing_border_MatteBorder_PersistenceDelegate extends PersistenceDelegate {</span>
    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L1235">        MatteBorder border = (MatteBorder) oldInstance;</span>
<span class="nc" id="L1236">        Insets insets = border.getBorderInsets();</span>
<span class="nc" id="L1237">        Object object = border.getTileIcon();</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">        if (object == null) {</span>
<span class="nc" id="L1239">            object = border.getMatteColor();</span>
        }
<span class="nc" id="L1241">        Object[] args = new Object[] {</span>
<span class="nc" id="L1242">                insets.top,</span>
<span class="nc" id="L1243">                insets.left,</span>
<span class="nc" id="L1244">                insets.bottom,</span>
<span class="nc" id="L1245">                insets.right,</span>
                object,
        };
<span class="nc" id="L1248">        return new Expression(border, border.getClass(), &quot;new&quot;, args);</span>
    }
}

/* XXX - doens't seem to work. Debug later.
static final class javax_swing_JMenu_PersistenceDelegate extends DefaultPersistenceDelegate {
    protected void initialize(Class&lt;?&gt; type, Object oldInstance, Object newInstance, Encoder out) {
        super.initialize(type, oldInstance, newInstance, out);
        javax.swing.JMenu m = (javax.swing.JMenu)oldInstance;
        javax.swing.JMenu n = (javax.swing.JMenu)newInstance;
        for (int i = n.getItemCount(); i &lt; m.getItemCount(); i++) {
            invokeStatement(oldInstance, &quot;add&quot;, new Object[]{m.getItem(i)}, out);
        }
    }
}
*/

/**
 * The persistence delegate for {@link PrintColorUIResource}.
 * It is impossible to use {@link DefaultPersistenceDelegate}
 * because this class has special rule for serialization:
 * it should be converted to {@link ColorUIResource}.
 *
 * @see PrintColorUIResource#writeReplace
 *
 * @author Sergey A. Malenkov
 */
<span class="nc" id="L1275">static final class sun_swing_PrintColorUIResource_PersistenceDelegate extends PersistenceDelegate {</span>
    protected boolean mutatesTo(Object oldInstance, Object newInstance) {
<span class="nc" id="L1277">        return oldInstance.equals(newInstance);</span>
    }

    protected Expression instantiate(Object oldInstance, Encoder out) {
<span class="nc" id="L1281">        Color color = (Color) oldInstance;</span>
<span class="nc" id="L1282">        Object[] args = new Object[] {color.getRGB()};</span>
<span class="nc" id="L1283">        return new Expression(color, ColorUIResource.class, &quot;new&quot;, args);</span>
    }
}

<span class="nc" id="L1287">    private static final Map&lt;String,Field&gt; fields = Collections.synchronizedMap(new WeakHashMap&lt;String, Field&gt;());</span>
<span class="nc" id="L1288">    private static Hashtable&lt;String, PersistenceDelegate&gt; internalPersistenceDelegates = new Hashtable&lt;&gt;();</span>

<span class="nc" id="L1290">    private static PersistenceDelegate nullPersistenceDelegate = new NullPersistenceDelegate();</span>
<span class="nc" id="L1291">    private static PersistenceDelegate enumPersistenceDelegate = new EnumPersistenceDelegate();</span>
<span class="nc" id="L1292">    private static PersistenceDelegate primitivePersistenceDelegate = new PrimitivePersistenceDelegate();</span>
<span class="nc" id="L1293">    private static PersistenceDelegate defaultPersistenceDelegate = new DefaultPersistenceDelegate();</span>
    private static PersistenceDelegate arrayPersistenceDelegate;
    private static PersistenceDelegate proxyPersistenceDelegate;

    static {

<span class="nc" id="L1299">        internalPersistenceDelegates.put(&quot;java.net.URI&quot;,</span>
                                         new PrimitivePersistenceDelegate());

        // it is possible because MatteBorder is assignable from MatteBorderUIResource
<span class="nc" id="L1303">        internalPersistenceDelegates.put(&quot;javax.swing.plaf.BorderUIResource$MatteBorderUIResource&quot;,</span>
                                         new javax_swing_border_MatteBorder_PersistenceDelegate());

        // it is possible because FontUIResource is supported by java_awt_Font_PersistenceDelegate
<span class="nc" id="L1307">        internalPersistenceDelegates.put(&quot;javax.swing.plaf.FontUIResource&quot;,</span>
                                         new java_awt_Font_PersistenceDelegate());

        // it is possible because KeyStroke is supported by java_awt_AWTKeyStroke_PersistenceDelegate
<span class="nc" id="L1311">        internalPersistenceDelegates.put(&quot;javax.swing.KeyStroke&quot;,</span>
                                         new java_awt_AWTKeyStroke_PersistenceDelegate());

<span class="nc" id="L1314">        internalPersistenceDelegates.put(&quot;java.sql.Date&quot;, new java_util_Date_PersistenceDelegate());</span>
<span class="nc" id="L1315">        internalPersistenceDelegates.put(&quot;java.sql.Time&quot;, new java_util_Date_PersistenceDelegate());</span>

<span class="nc" id="L1317">        internalPersistenceDelegates.put(&quot;java.util.JumboEnumSet&quot;, new java_util_EnumSet_PersistenceDelegate());</span>
<span class="nc" id="L1318">        internalPersistenceDelegates.put(&quot;java.util.RegularEnumSet&quot;, new java_util_EnumSet_PersistenceDelegate());</span>
<span class="nc" id="L1319">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    public synchronized static PersistenceDelegate getPersistenceDelegate(Class type) {
<span class="nc bnc" id="L1323" title="All 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L1324">            return nullPersistenceDelegate;</span>
        }
<span class="nc bnc" id="L1326" title="All 2 branches missed.">        if (Enum.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L1327">            return enumPersistenceDelegate;</span>
        }
<span class="nc bnc" id="L1329" title="All 2 branches missed.">        if (null != XMLEncoder.primitiveTypeFor(type)) {</span>
<span class="nc" id="L1330">            return primitivePersistenceDelegate;</span>
        }
        // The persistence delegate for arrays is non-trivial; instantiate it lazily.
<span class="nc bnc" id="L1333" title="All 2 branches missed.">        if (type.isArray()) {</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">            if (arrayPersistenceDelegate == null) {</span>
<span class="nc" id="L1335">                arrayPersistenceDelegate = new ArrayPersistenceDelegate();</span>
            }
<span class="nc" id="L1337">            return arrayPersistenceDelegate;</span>
        }
        // Handle proxies lazily for backward compatibility with 1.2.
        try {
<span class="nc bnc" id="L1341" title="All 2 branches missed.">            if (java.lang.reflect.Proxy.isProxyClass(type)) {</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">                if (proxyPersistenceDelegate == null) {</span>
<span class="nc" id="L1343">                    proxyPersistenceDelegate = new ProxyPersistenceDelegate();</span>
                }
<span class="nc" id="L1345">                return proxyPersistenceDelegate;</span>
            }
        }
<span class="nc" id="L1348">        catch(Exception e) {}</span>
        // else if (type.getDeclaringClass() != null) {
        //     return new DefaultPersistenceDelegate(new String[]{&quot;this$0&quot;});
        // }

<span class="nc" id="L1353">        String typeName = type.getName();</span>
<span class="nc" id="L1354">        PersistenceDelegate pd = (PersistenceDelegate)getBeanAttribute(type, &quot;persistenceDelegate&quot;);</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">        if (pd == null) {</span>
<span class="nc" id="L1356">            pd = internalPersistenceDelegates.get(typeName);</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">            if (pd != null) {</span>
<span class="nc" id="L1358">                return pd;</span>
            }
<span class="nc" id="L1360">            internalPersistenceDelegates.put(typeName, defaultPersistenceDelegate);</span>
            try {
<span class="nc" id="L1362">                String name =  type.getName();</span>
<span class="nc" id="L1363">                Class c = Class.forName(&quot;java.beans.MetaData$&quot; + name.replace('.', '_')</span>
                                        + &quot;_PersistenceDelegate&quot;);
<span class="nc" id="L1365">                pd = (PersistenceDelegate)c.newInstance();</span>
<span class="nc" id="L1366">                internalPersistenceDelegates.put(typeName, pd);</span>
            }
<span class="nc" id="L1368">            catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1369">                String[] properties = getConstructorProperties(type);</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                if (properties != null) {</span>
<span class="nc" id="L1371">                    pd = new DefaultPersistenceDelegate(properties);</span>
<span class="nc" id="L1372">                    internalPersistenceDelegates.put(typeName, pd);</span>
                }
            }
<span class="nc" id="L1375">            catch (Exception e) {</span>
<span class="nc" id="L1376">                System.err.println(&quot;Internal error: &quot; + e);</span>
<span class="nc" id="L1377">            }</span>
        }

<span class="nc bnc" id="L1380" title="All 2 branches missed.">        return (pd != null) ? pd : defaultPersistenceDelegate;</span>
    }

    private static String[] getConstructorProperties(Class&lt;?&gt; type) {
<span class="nc" id="L1384">        String[] names = null;</span>
<span class="nc" id="L1385">        int length = 0;</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">        for (Constructor&lt;?&gt; constructor : type.getConstructors()) {</span>
<span class="nc" id="L1387">            String[] value = getAnnotationValue(constructor);</span>
<span class="nc bnc" id="L1388" title="All 6 branches missed.">            if ((value != null) &amp;&amp; (length &lt; value.length) &amp;&amp; isValid(constructor, value)) {</span>
<span class="nc" id="L1389">                names = value;</span>
<span class="nc" id="L1390">                length = value.length;</span>
            }
        }
<span class="nc" id="L1393">        return names;</span>
    }

    private static String[] getAnnotationValue(Constructor&lt;?&gt; constructor) {
<span class="nc" id="L1397">        ConstructorProperties annotation = constructor.getAnnotation(ConstructorProperties.class);</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">        return (annotation != null)</span>
<span class="nc" id="L1399">                ? annotation.value()</span>
                : null;
    }

    private static boolean isValid(Constructor&lt;?&gt; constructor, String[] names) {
<span class="nc" id="L1404">        Class[] parameters = constructor.getParameterTypes();</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">        if (names.length != parameters.length) {</span>
<span class="nc" id="L1406">            return false;</span>
        }
<span class="nc bnc" id="L1408" title="All 2 branches missed.">        for (String name : names) {</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">            if (name == null) {</span>
<span class="nc" id="L1410">                return false;</span>
            }
        }
<span class="nc" id="L1413">        return true;</span>
    }

    private static Object getBeanAttribute(Class&lt;?&gt; type, String attribute) {
        try {
<span class="nc" id="L1418">            return Introspector.getBeanInfo(type).getBeanDescriptor().getValue(attribute);</span>
<span class="nc" id="L1419">        } catch (IntrospectionException exception) {</span>
<span class="nc" id="L1420">            return null;</span>
        }
    }

    static Object getPrivateFieldValue(Object instance, String name) {
<span class="nc" id="L1425">        Field field = fields.get(name);</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L1427">            int index = name.lastIndexOf('.');</span>
<span class="nc" id="L1428">            final String className = name.substring(0, index);</span>
<span class="nc" id="L1429">            final String fieldName = name.substring(1 + index);</span>
<span class="nc" id="L1430">            field = AccessController.doPrivileged(new PrivilegedAction&lt;Field&gt;() {</span>
                public Field run() {
                    try {
<span class="nc" id="L1433">                        Field field = Class.forName(className).getDeclaredField(fieldName);</span>
<span class="nc" id="L1434">                        field.setAccessible(true);</span>
<span class="nc" id="L1435">                        return field;</span>
                    }
<span class="nc" id="L1437">                    catch (ClassNotFoundException exception) {</span>
<span class="nc" id="L1438">                        throw new IllegalStateException(&quot;Could not find class&quot;, exception);</span>
                    }
<span class="nc" id="L1440">                    catch (NoSuchFieldException exception) {</span>
<span class="nc" id="L1441">                        throw new IllegalStateException(&quot;Could not find field&quot;, exception);</span>
                    }
                }
            });
<span class="nc" id="L1445">            fields.put(name, field);</span>
        }
        try {
<span class="nc" id="L1448">            return field.get(instance);</span>
        }
<span class="nc" id="L1450">        catch (IllegalAccessException exception) {</span>
<span class="nc" id="L1451">            throw new IllegalStateException(&quot;Could not get value of the field&quot;, exception);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>