<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Statement.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.beans</a> &gt; <span class="el_source">Statement.java</span></div><h1>Statement.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.beans;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;

import com.sun.beans.finder.ClassFinder;
import com.sun.beans.finder.ConstructorFinder;
import com.sun.beans.finder.MethodFinder;
import sun.reflect.misc.MethodUtil;

/**
 * A &lt;code&gt;Statement&lt;/code&gt; object represents a primitive statement
 * in which a single method is applied to a target and
 * a set of arguments - as in &lt;code&gt;&quot;a.setJDK(b)&quot;&lt;/code&gt;.
 * Note that where this example uses names
 * to denote the target and its argument, a statement
 * object does not require a name space and is constructed with
 * the values themselves.
 * The statement object associates the named method
 * with its environment as a simple set of values:
 * the target and an array of argument values.
 *
 * @since 1.4
 *
 * @author Philip Milne
 */
public class Statement {

<span class="nc" id="L60">    private static Object[] emptyArray = new Object[]{};</span>

<span class="nc" id="L62">    static ExceptionListener defaultExceptionListener = new ExceptionListener() {</span>
        public void exceptionThrown(Exception e) {
<span class="nc" id="L64">            System.err.println(e);</span>
            // e.printStackTrace();
<span class="nc" id="L66">            System.err.println(&quot;Continuing ...&quot;);</span>
<span class="nc" id="L67">        }</span>
    };

<span class="nc" id="L70">    private final AccessControlContext acc = AccessController.getContext();</span>
    private final Object target;
    private final String methodName;
    private final Object[] arguments;
    ClassLoader loader;

    /**
     * Creates a new {@link Statement} object
     * for the specified target object to invoke the method
     * specified by the name and by the array of arguments.
     * &lt;p&gt;
     * The {@code target} and the {@code methodName} values should not be {@code null}.
     * Otherwise an attempt to execute this {@code Expression}
     * will result in a {@code NullPointerException}.
     * If the {@code arguments} value is {@code null},
     * an empty array is used as the value of the {@code arguments} property.
     *
     * @param target  the target object of this statement
     * @param methodName  the name of the method to invoke on the specified target
     * @param arguments  the array of arguments to invoke the specified method
     */
    @ConstructorProperties({&quot;target&quot;, &quot;methodName&quot;, &quot;arguments&quot;})
<span class="nc" id="L92">    public Statement(Object target, String methodName, Object[] arguments) {</span>
<span class="nc" id="L93">        this.target = target;</span>
<span class="nc" id="L94">        this.methodName = methodName;</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        this.arguments = (arguments == null) ? emptyArray : arguments.clone();</span>
<span class="nc" id="L96">    }</span>

    /**
     * Returns the target object of this statement.
     * If this method returns {@code null},
     * the {@link #execute} method
     * throws a {@code NullPointerException}.
     *
     * @return the target object of this statement
     */
    public Object getTarget() {
<span class="nc" id="L107">        return target;</span>
    }

    /**
     * Returns the name of the method to invoke.
     * If this method returns {@code null},
     * the {@link #execute} method
     * throws a {@code NullPointerException}.
     *
     * @return the name of the method
     */
    public String getMethodName() {
<span class="nc" id="L119">        return methodName;</span>
    }

    /**
     * Returns the arguments for the method to invoke.
     * The number of arguments and their types
     * must match the method being  called.
     * {@code null} can be used as a synonym of an empty array.
     *
     * @return the array of arguments
     */
    public Object[] getArguments() {
<span class="nc" id="L131">        return this.arguments.clone();</span>
    }

    /**
     * The {@code execute} method finds a method whose name is the same
     * as the {@code methodName} property, and invokes the method on
     * the target.
     *
     * When the target's class defines many methods with the given name
     * the implementation should choose the most specific method using
     * the algorithm specified in the Java Language Specification
     * (15.11). The dynamic class of the target and arguments are used
     * in place of the compile-time type information and, like the
     * {@link java.lang.reflect.Method} class itself, conversion between
     * primitive values and their associated wrapper classes is handled
     * internally.
     * &lt;p&gt;
     * The following method types are handled as special cases:
     * &lt;ul&gt;
     * &lt;li&gt;
     * Static methods may be called by using a class object as the target.
     * &lt;li&gt;
     * The reserved method name &quot;new&quot; may be used to call a class's constructor
     * as if all classes defined static &quot;new&quot; methods. Constructor invocations
     * are typically considered {@code Expression}s rather than {@code Statement}s
     * as they return a value.
     * &lt;li&gt;
     * The method names &quot;get&quot; and &quot;set&quot; defined in the {@link java.util.List}
     * interface may also be applied to array instances, mapping to
     * the static methods of the same name in the {@code Array} class.
     * &lt;/ul&gt;
     *
     * @throws NullPointerException if the value of the {@code target} or
     *                              {@code methodName} property is {@code null}
     * @throws NoSuchMethodException if a matching method is not found
     * @throws SecurityException if a security manager exists and
     *                           it denies the method invocation
     * @throws Exception that is thrown by the invoked method
     *
     * @see java.lang.reflect.Method
     */
    public void execute() throws Exception {
<span class="nc" id="L173">        invoke();</span>
<span class="nc" id="L174">    }</span>

    Object invoke() throws Exception {
<span class="nc" id="L177">        AccessControlContext acc = this.acc;</span>
<span class="nc bnc" id="L178" title="All 4 branches missed.">        if ((acc == null) &amp;&amp; (System.getSecurityManager() != null)) {</span>
<span class="nc" id="L179">            throw new SecurityException(&quot;AccessControlContext is not set&quot;);</span>
        }
        try {
<span class="nc" id="L182">            return AccessController.doPrivileged(</span>
<span class="nc" id="L183">                    new PrivilegedExceptionAction&lt;Object&gt;() {</span>
                        public Object run() throws Exception {
<span class="nc" id="L185">                            return invokeInternal();</span>
                        }
                    },
                    acc
            );
        }
<span class="nc" id="L191">        catch (PrivilegedActionException exception) {</span>
<span class="nc" id="L192">            throw exception.getException();</span>
        }
    }

    private Object invokeInternal() throws Exception {
<span class="nc" id="L197">        Object target = getTarget();</span>
<span class="nc" id="L198">        String methodName = getMethodName();</span>

<span class="nc bnc" id="L200" title="All 4 branches missed.">        if (target == null || methodName == null) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">            throw new NullPointerException((target == null ? &quot;target&quot; :</span>
                                            &quot;methodName&quot;) + &quot; should not be null&quot;);
        }

<span class="nc" id="L205">        Object[] arguments = getArguments();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (arguments == null) {</span>
<span class="nc" id="L207">            arguments = emptyArray;</span>
        }
        // Class.forName() won't load classes outside
        // of core from a class inside core. Special
        // case this method.
<span class="nc bnc" id="L212" title="All 4 branches missed.">        if (target == Class.class &amp;&amp; methodName.equals(&quot;forName&quot;)) {</span>
<span class="nc" id="L213">            return ClassFinder.resolveClass((String)arguments[0], this.loader);</span>
        }
<span class="nc" id="L215">        Class&lt;?&gt;[] argClasses = new Class&lt;?&gt;[arguments.length];</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        for(int i = 0; i &lt; arguments.length; i++) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">            argClasses[i] = (arguments[i] == null) ? null : arguments[i].getClass();</span>
        }

<span class="nc" id="L220">        AccessibleObject m = null;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (target instanceof Class) {</span>
            /*
            For class methods, simluate the effect of a meta class
            by taking the union of the static methods of the
            actual class, with the instance methods of &quot;Class.class&quot;
            and the overloaded &quot;newInstance&quot; methods defined by the
            constructors.
            This way &quot;System.class&quot;, for example, will perform both
            the static method getProperties() and the instance method
            getSuperclass() defined in &quot;Class.class&quot;.
            */
<span class="nc bnc" id="L232" title="All 2 branches missed.">            if (methodName.equals(&quot;new&quot;)) {</span>
<span class="nc" id="L233">                methodName = &quot;newInstance&quot;;</span>
            }
            // Provide a short form for array instantiation by faking an nary-constructor.
<span class="nc bnc" id="L236" title="All 4 branches missed.">            if (methodName.equals(&quot;newInstance&quot;) &amp;&amp; ((Class)target).isArray()) {</span>
<span class="nc" id="L237">                Object result = Array.newInstance(((Class)target).getComponentType(), arguments.length);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                for(int i = 0; i &lt; arguments.length; i++) {</span>
<span class="nc" id="L239">                    Array.set(result, i, arguments[i]);</span>
                }
<span class="nc" id="L241">                return result;</span>
            }
<span class="nc bnc" id="L243" title="All 4 branches missed.">            if (methodName.equals(&quot;newInstance&quot;) &amp;&amp; arguments.length != 0) {</span>
                // The Character class, as of 1.4, does not have a constructor
                // which takes a String. All of the other &quot;wrapper&quot; classes
                // for Java's primitive types have a String constructor so we
                // fake such a constructor here so that this special case can be
                // ignored elsewhere.
<span class="nc bnc" id="L249" title="All 6 branches missed.">                if (target == Character.class &amp;&amp; arguments.length == 1 &amp;&amp;</span>
                    argClasses[0] == String.class) {
<span class="nc" id="L251">                    return new Character(((String)arguments[0]).charAt(0));</span>
                }
                try {
<span class="nc" id="L254">                    m = ConstructorFinder.findConstructor((Class)target, argClasses);</span>
                }
<span class="nc" id="L256">                catch (NoSuchMethodException exception) {</span>
<span class="nc" id="L257">                    m = null;</span>
<span class="nc" id="L258">                }</span>
            }
<span class="nc bnc" id="L260" title="All 4 branches missed.">            if (m == null &amp;&amp; target != Class.class) {</span>
<span class="nc" id="L261">                m = getMethod((Class)target, methodName, argClasses);</span>
            }
<span class="nc bnc" id="L263" title="All 2 branches missed.">            if (m == null) {</span>
<span class="nc" id="L264">                m = getMethod(Class.class, methodName, argClasses);</span>
            }
        }
        else {
            /*
            This special casing of arrays is not necessary, but makes files
            involving arrays much shorter and simplifies the archiving infrastrcure.
            The Array.set() method introduces an unusual idea - that of a static method
            changing the state of an instance. Normally statements with side
            effects on objects are instance methods of the objects themselves
            and we reinstate this rule (perhaps temporarily) by special-casing arrays.
            */
<span class="nc bnc" id="L276" title="All 2 branches missed.">            if (target.getClass().isArray() &amp;&amp;</span>
<span class="nc bnc" id="L277" title="All 4 branches missed.">                (methodName.equals(&quot;set&quot;) || methodName.equals(&quot;get&quot;))) {</span>
<span class="nc" id="L278">                int index = ((Integer)arguments[0]).intValue();</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                if (methodName.equals(&quot;get&quot;)) {</span>
<span class="nc" id="L280">                    return Array.get(target, index);</span>
                }
                else {
<span class="nc" id="L283">                    Array.set(target, index, arguments[1]);</span>
<span class="nc" id="L284">                    return null;</span>
                }
            }
<span class="nc" id="L287">            m = getMethod(target.getClass(), methodName, argClasses);</span>
        }
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (m != null) {</span>
            try {
<span class="nc bnc" id="L291" title="All 2 branches missed.">                if (m instanceof Method) {</span>
<span class="nc" id="L292">                    return MethodUtil.invoke((Method)m, target, arguments);</span>
                }
                else {
<span class="nc" id="L295">                    return ((Constructor)m).newInstance(arguments);</span>
                }
            }
<span class="nc" id="L298">            catch (IllegalAccessException iae) {</span>
<span class="nc" id="L299">                throw new Exception(&quot;Statement cannot invoke: &quot; +</span>
<span class="nc" id="L300">                                    methodName + &quot; on &quot; + target.getClass(),</span>
                                    iae);
            }
<span class="nc" id="L303">            catch (InvocationTargetException ite) {</span>
<span class="nc" id="L304">                Throwable te = ite.getTargetException();</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                if (te instanceof Exception) {</span>
<span class="nc" id="L306">                    throw (Exception)te;</span>
                }
                else {
<span class="nc" id="L309">                    throw ite;</span>
                }
            }
        }
<span class="nc" id="L313">        throw new NoSuchMethodException(toString());</span>
    }

    String instanceName(Object instance) {
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (instance == null) {</span>
<span class="nc" id="L318">            return &quot;null&quot;;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        } else if (instance.getClass() == String.class) {</span>
<span class="nc" id="L320">            return &quot;\&quot;&quot;+(String)instance + &quot;\&quot;&quot;;</span>
        } else {
            // Note: there is a minor problem with using the non-caching
            // NameGenerator method. The return value will not have
            // specific information about the inner class name. For example,
            // In 1.4.2 an inner class would be represented as JList$1 now
            // would be named Class.

<span class="nc" id="L328">            return NameGenerator.unqualifiedClassName(instance.getClass());</span>
        }
    }

    /**
     * Prints the value of this statement using a Java-style syntax.
     */
    public String toString() {
        // Respect a subclass's implementation here.
<span class="nc" id="L337">        Object target = getTarget();</span>
<span class="nc" id="L338">        String methodName = getMethodName();</span>
<span class="nc" id="L339">        Object[] arguments = getArguments();</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (arguments == null) {</span>
<span class="nc" id="L341">            arguments = emptyArray;</span>
        }
<span class="nc" id="L343">        StringBuffer result = new StringBuffer(instanceName(target) + &quot;.&quot; + methodName + &quot;(&quot;);</span>
<span class="nc" id="L344">        int n = arguments.length;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">        for(int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L346">            result.append(instanceName(arguments[i]));</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (i != n -1) {</span>
<span class="nc" id="L348">                result.append(&quot;, &quot;);</span>
            }
        }
<span class="nc" id="L351">        result.append(&quot;);&quot;);</span>
<span class="nc" id="L352">        return result.toString();</span>
    }

    static Method getMethod(Class&lt;?&gt; type, String name, Class&lt;?&gt;... args) {
        try {
<span class="nc" id="L357">            return MethodFinder.findMethod(type, name, args);</span>
        }
<span class="nc" id="L359">        catch (NoSuchMethodException exception) {</span>
<span class="nc" id="L360">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>