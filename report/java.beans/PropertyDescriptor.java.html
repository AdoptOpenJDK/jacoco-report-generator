<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PropertyDescriptor.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.beans</a> &gt; <span class="el_source">PropertyDescriptor.java</span></div><h1>PropertyDescriptor.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.beans;

import java.lang.ref.Reference;
import java.lang.reflect.Method;
import java.lang.reflect.Constructor;

/**
 * A PropertyDescriptor describes one property that a Java Bean
 * exports via a pair of accessor methods.
 */
public class PropertyDescriptor extends FeatureDescriptor {

    private Reference&lt;? extends Class&lt;?&gt;&gt; propertyTypeRef;
<span class="nc" id="L39">    private final MethodRef readMethodRef = new MethodRef();</span>
<span class="nc" id="L40">    private final MethodRef writeMethodRef = new MethodRef();</span>
    private Reference&lt;? extends Class&lt;?&gt;&gt; propertyEditorClassRef;

    private boolean bound;
    private boolean constrained;

    // The base name of the method name which will be prefixed with the
    // read and write method. If name == &quot;foo&quot; then the baseName is &quot;JDK&quot;
    private String baseName;

    private String writeMethodName;
    private String readMethodName;

    /**
     * Constructs a PropertyDescriptor for a property that follows
     * the standard Java convention by having getJDK and setJDK
     * accessor methods.  Thus if the argument name is &quot;fred&quot;, it will
     * assume that the writer method is &quot;setFred&quot; and the reader method
     * is &quot;getFred&quot; (or &quot;isFred&quot; for a boolean property).  Note that the
     * property name should start with a lower case character, which will
     * be capitalized in the method names.
     *
     * @param propertyName The programmatic name of the property.
     * @param beanClass The Class object for the target bean.  For
     *          example sun.beans.OurButton.class.
     * @exception IntrospectionException if an exception occurs during
     *              introspection.
     */
    public PropertyDescriptor(String propertyName, Class&lt;?&gt; beanClass)
                throws IntrospectionException {
<span class="nc" id="L70">        this(propertyName, beanClass,</span>
<span class="nc" id="L71">                Introspector.IS_PREFIX + NameGenerator.capitalize(propertyName),</span>
<span class="nc" id="L72">                Introspector.SET_PREFIX + NameGenerator.capitalize(propertyName));</span>
<span class="nc" id="L73">    }</span>

    /**
     * This constructor takes the name of a simple property, and method
     * names for reading and writing the property.
     *
     * @param propertyName The programmatic name of the property.
     * @param beanClass The Class object for the target bean.  For
     *          example sun.beans.OurButton.class.
     * @param readMethodName The name of the method used for reading the property
     *           value.  May be null if the property is write-only.
     * @param writeMethodName The name of the method used for writing the property
     *           value.  May be null if the property is read-only.
     * @exception IntrospectionException if an exception occurs during
     *              introspection.
     */
    public PropertyDescriptor(String propertyName, Class&lt;?&gt; beanClass,
                String readMethodName, String writeMethodName)
<span class="nc" id="L91">                throws IntrospectionException {</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (beanClass == null) {</span>
<span class="nc" id="L93">            throw new IntrospectionException(&quot;Target Bean class is null&quot;);</span>
        }
<span class="nc bnc" id="L95" title="All 4 branches missed.">        if (propertyName == null || propertyName.length() == 0) {</span>
<span class="nc" id="L96">            throw new IntrospectionException(&quot;bad property name&quot;);</span>
        }
<span class="nc bnc" id="L98" title="All 4 branches missed.">        if (&quot;&quot;.equals(readMethodName) || &quot;&quot;.equals(writeMethodName)) {</span>
<span class="nc" id="L99">            throw new IntrospectionException(&quot;read or write method name should not be the empty string&quot;);</span>
        }
<span class="nc" id="L101">        setName(propertyName);</span>
<span class="nc" id="L102">        setClass0(beanClass);</span>

<span class="nc" id="L104">        this.readMethodName = readMethodName;</span>
<span class="nc bnc" id="L105" title="All 4 branches missed.">        if (readMethodName != null &amp;&amp; getReadMethod() == null) {</span>
<span class="nc" id="L106">            throw new IntrospectionException(&quot;Method not found: &quot; + readMethodName);</span>
        }
<span class="nc" id="L108">        this.writeMethodName = writeMethodName;</span>
<span class="nc bnc" id="L109" title="All 4 branches missed.">        if (writeMethodName != null &amp;&amp; getWriteMethod() == null) {</span>
<span class="nc" id="L110">            throw new IntrospectionException(&quot;Method not found: &quot; + writeMethodName);</span>
        }
        // If this class or one of its base classes allow PropertyChangeListener,
        // then we assume that any properties we discover are &quot;bound&quot;.
        // See Introspector.getTargetPropertyInfo() method.
<span class="nc" id="L115">        Class[] args = { PropertyChangeListener.class };</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        this.bound = null != Introspector.findMethod(beanClass, &quot;addPropertyChangeListener&quot;, args.length, args);</span>
<span class="nc" id="L117">    }</span>

    /**
     * This constructor takes the name of a simple property, and Method
     * objects for reading and writing the property.
     *
     * @param propertyName The programmatic name of the property.
     * @param readMethod The method used for reading the property value.
     *          May be null if the property is write-only.
     * @param writeMethod The method used for writing the property value.
     *          May be null if the property is read-only.
     * @exception IntrospectionException if an exception occurs during
     *              introspection.
     */
    public PropertyDescriptor(String propertyName, Method readMethod, Method writeMethod)
<span class="nc" id="L132">                throws IntrospectionException {</span>
<span class="nc bnc" id="L133" title="All 4 branches missed.">        if (propertyName == null || propertyName.length() == 0) {</span>
<span class="nc" id="L134">            throw new IntrospectionException(&quot;bad property name&quot;);</span>
        }
<span class="nc" id="L136">        setName(propertyName);</span>
<span class="nc" id="L137">        setReadMethod(readMethod);</span>
<span class="nc" id="L138">        setWriteMethod(writeMethod);</span>
<span class="nc" id="L139">    }</span>

    /**
     * Creates &lt;code&gt;PropertyDescriptor&lt;/code&gt; for the specified bean
     * with the specified name and methods to read/write the property value.
     *
     * @param bean   the type of the target bean
     * @param base   the base name of the property (the rest of the method name)
     * @param read   the method used for reading the property value
     * @param write  the method used for writing the property value
     * @exception IntrospectionException if an exception occurs during introspection
     *
     * @since 1.7
     */
<span class="nc" id="L153">    PropertyDescriptor(Class&lt;?&gt; bean, String base, Method read, Method write) throws IntrospectionException {</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (bean == null) {</span>
<span class="nc" id="L155">            throw new IntrospectionException(&quot;Target Bean class is null&quot;);</span>
        }
<span class="nc" id="L157">        setClass0(bean);</span>
<span class="nc" id="L158">        setName(Introspector.decapitalize(base));</span>
<span class="nc" id="L159">        setReadMethod(read);</span>
<span class="nc" id="L160">        setWriteMethod(write);</span>
<span class="nc" id="L161">        this.baseName = base;</span>
<span class="nc" id="L162">    }</span>

    /**
     * Returns the Java type info for the property.
     * Note that the {@code Class} object may describe
     * primitive Java types such as {@code int}.
     * This type is returned by the read method
     * or is used as the parameter type of the write method.
     * Returns {@code null} if the type is an indexed property
     * that does not support non-indexed access.
     *
     * @return the {@code Class} object that represents the Java type info,
     *         or {@code null} if the type cannot be determined
     */
    public synchronized Class&lt;?&gt; getPropertyType() {
<span class="nc" id="L177">        Class&lt;?&gt; type = getPropertyType0();</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (type  == null) {</span>
            try {
<span class="nc" id="L180">                type = findPropertyType(getReadMethod(), getWriteMethod());</span>
<span class="nc" id="L181">                setPropertyType(type);</span>
<span class="nc" id="L182">            } catch (IntrospectionException ex) {</span>
                // Fall
<span class="nc" id="L184">            }</span>
        }
<span class="nc" id="L186">        return type;</span>
    }

    private void setPropertyType(Class&lt;?&gt; type) {
<span class="nc" id="L190">        this.propertyTypeRef = getWeakReference(type);</span>
<span class="nc" id="L191">    }</span>

    private Class&lt;?&gt; getPropertyType0() {
<span class="nc bnc" id="L194" title="All 2 branches missed.">        return (this.propertyTypeRef != null)</span>
<span class="nc" id="L195">                ? this.propertyTypeRef.get()</span>
                : null;
    }

    /**
     * Gets the method that should be used to read the property value.
     *
     * @return The method that should be used to read the property value.
     * May return null if the property can't be read.
     */
    public synchronized Method getReadMethod() {
<span class="nc" id="L206">        Method readMethod = this.readMethodRef.get();</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (readMethod == null) {</span>
<span class="nc" id="L208">            Class&lt;?&gt; cls = getClass0();</span>
<span class="nc bnc" id="L209" title="All 6 branches missed.">            if (cls == null || (readMethodName == null &amp;&amp; !this.readMethodRef.isSet())) {</span>
                // The read method was explicitly set to null.
<span class="nc" id="L211">                return null;</span>
            }
<span class="nc" id="L213">            String nextMethodName = Introspector.GET_PREFIX + getBaseName();</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if (readMethodName == null) {</span>
<span class="nc" id="L215">                Class&lt;?&gt; type = getPropertyType0();</span>
<span class="nc bnc" id="L216" title="All 4 branches missed.">                if (type == boolean.class || type == null) {</span>
<span class="nc" id="L217">                    readMethodName = Introspector.IS_PREFIX + getBaseName();</span>
                } else {
<span class="nc" id="L219">                    readMethodName = nextMethodName;</span>
                }
            }

            // Since there can be multiple write methods but only one getter
            // method, find the getter method first so that you know what the
            // property type is.  For booleans, there can be &quot;is&quot; and &quot;get&quot;
            // methods.  If an &quot;is&quot; method exists, this is the official
            // reader method so look for this one first.
<span class="nc" id="L228">            readMethod = Introspector.findMethod(cls, readMethodName, 0);</span>
<span class="nc bnc" id="L229" title="All 4 branches missed.">            if ((readMethod == null) &amp;&amp; !readMethodName.equals(nextMethodName)) {</span>
<span class="nc" id="L230">                readMethodName = nextMethodName;</span>
<span class="nc" id="L231">                readMethod = Introspector.findMethod(cls, readMethodName, 0);</span>
            }
            try {
<span class="nc" id="L234">                setReadMethod(readMethod);</span>
<span class="nc" id="L235">            } catch (IntrospectionException ex) {</span>
                // fall
<span class="nc" id="L237">            }</span>
        }
<span class="nc" id="L239">        return readMethod;</span>
    }

    /**
     * Sets the method that should be used to read the property value.
     *
     * @param readMethod The new read method.
     * @throws IntrospectionException if the read method is invalid
     */
    public synchronized void setReadMethod(Method readMethod)
                                throws IntrospectionException {
<span class="nc" id="L250">        this.readMethodRef.set(readMethod);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (readMethod == null) {</span>
<span class="nc" id="L252">            readMethodName = null;</span>
<span class="nc" id="L253">            return;</span>
        }
        // The property type is determined by the read method.
<span class="nc" id="L256">        setPropertyType(findPropertyType(readMethod, this.writeMethodRef.get()));</span>
<span class="nc" id="L257">        setClass0(readMethod.getDeclaringClass());</span>

<span class="nc" id="L259">        readMethodName = readMethod.getName();</span>
<span class="nc" id="L260">        setTransient(readMethod.getAnnotation(Transient.class));</span>
<span class="nc" id="L261">    }</span>

    /**
     * Gets the method that should be used to write the property value.
     *
     * @return The method that should be used to write the property value.
     * May return null if the property can't be written.
     */
    public synchronized Method getWriteMethod() {
<span class="nc" id="L270">        Method writeMethod = this.writeMethodRef.get();</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (writeMethod == null) {</span>
<span class="nc" id="L272">            Class&lt;?&gt; cls = getClass0();</span>
<span class="nc bnc" id="L273" title="All 6 branches missed.">            if (cls == null || (writeMethodName == null &amp;&amp; !this.writeMethodRef.isSet())) {</span>
                // The write method was explicitly set to null.
<span class="nc" id="L275">                return null;</span>
            }

            // We need the type to fetch the correct method.
<span class="nc" id="L279">            Class&lt;?&gt; type = getPropertyType0();</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            if (type == null) {</span>
                try {
                    // Can't use getPropertyType since it will lead to recursive loop.
<span class="nc" id="L283">                    type = findPropertyType(getReadMethod(), null);</span>
<span class="nc" id="L284">                    setPropertyType(type);</span>
<span class="nc" id="L285">                } catch (IntrospectionException ex) {</span>
                    // Without the correct property type we can't be guaranteed
                    // to find the correct method.
<span class="nc" id="L288">                    return null;</span>
<span class="nc" id="L289">                }</span>
            }

<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (writeMethodName == null) {</span>
<span class="nc" id="L293">                writeMethodName = Introspector.SET_PREFIX + getBaseName();</span>
            }

<span class="nc bnc" id="L296" title="All 2 branches missed.">            Class&lt;?&gt;[] args = (type == null) ? null : new Class&lt;?&gt;[] { type };</span>
<span class="nc" id="L297">            writeMethod = Introspector.findMethod(cls, writeMethodName, 1, args);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (writeMethod != null) {</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                if (!writeMethod.getReturnType().equals(void.class)) {</span>
<span class="nc" id="L300">                    writeMethod = null;</span>
                }
            }
            try {
<span class="nc" id="L304">                setWriteMethod(writeMethod);</span>
<span class="nc" id="L305">            } catch (IntrospectionException ex) {</span>
                // fall through
<span class="nc" id="L307">            }</span>
        }
<span class="nc" id="L309">        return writeMethod;</span>
    }

    /**
     * Sets the method that should be used to write the property value.
     *
     * @param writeMethod The new write method.
     * @throws IntrospectionException if the write method is invalid
     */
    public synchronized void setWriteMethod(Method writeMethod)
                                throws IntrospectionException {
<span class="nc" id="L320">        this.writeMethodRef.set(writeMethod);</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (writeMethod == null) {</span>
<span class="nc" id="L322">            writeMethodName = null;</span>
<span class="nc" id="L323">            return;</span>
        }
        // Set the property type - which validates the method
<span class="nc" id="L326">        setPropertyType(findPropertyType(getReadMethod(), writeMethod));</span>
<span class="nc" id="L327">        setClass0(writeMethod.getDeclaringClass());</span>

<span class="nc" id="L329">        writeMethodName = writeMethod.getName();</span>
<span class="nc" id="L330">        setTransient(writeMethod.getAnnotation(Transient.class));</span>
<span class="nc" id="L331">    }</span>

    /**
     * Overridden to ensure that a super class doesn't take precedent
     */
    void setClass0(Class&lt;?&gt; clz) {
<span class="nc bnc" id="L337" title="All 4 branches missed.">        if (getClass0() != null &amp;&amp; clz.isAssignableFrom(getClass0())) {</span>
            // don't replace a subclass with a superclass
<span class="nc" id="L339">            return;</span>
        }
<span class="nc" id="L341">        super.setClass0(clz);</span>
<span class="nc" id="L342">    }</span>

    /**
     * Updates to &quot;bound&quot; properties will cause a &quot;PropertyChange&quot; event to
     * get fired when the property is changed.
     *
     * @return True if this is a bound property.
     */
    public boolean isBound() {
<span class="nc" id="L351">        return bound;</span>
    }

    /**
     * Updates to &quot;bound&quot; properties will cause a &quot;PropertyChange&quot; event to
     * get fired when the property is changed.
     *
     * @param bound True if this is a bound property.
     */
    public void setBound(boolean bound) {
<span class="nc" id="L361">        this.bound = bound;</span>
<span class="nc" id="L362">    }</span>

    /**
     * Attempted updates to &quot;Constrained&quot; properties will cause a &quot;VetoableChange&quot;
     * event to get fired when the property is changed.
     *
     * @return True if this is a constrained property.
     */
    public boolean isConstrained() {
<span class="nc" id="L371">        return constrained;</span>
    }

    /**
     * Attempted updates to &quot;Constrained&quot; properties will cause a &quot;VetoableChange&quot;
     * event to get fired when the property is changed.
     *
     * @param constrained True if this is a constrained property.
     */
    public void setConstrained(boolean constrained) {
<span class="nc" id="L381">        this.constrained = constrained;</span>
<span class="nc" id="L382">    }</span>


    /**
     * Normally PropertyEditors will be found using the PropertyEditorManager.
     * However if for some reason you want to associate a particular
     * PropertyEditor with a given property, then you can do it with
     * this method.
     *
     * @param propertyEditorClass  The Class for the desired PropertyEditor.
     */
    public void setPropertyEditorClass(Class&lt;?&gt; propertyEditorClass) {
<span class="nc" id="L394">        this.propertyEditorClassRef = getWeakReference(propertyEditorClass);</span>
<span class="nc" id="L395">    }</span>

    /**
     * Gets any explicit PropertyEditor Class that has been registered
     * for this property.
     *
     * @return Any explicit PropertyEditor Class that has been registered
     *          for this property.  Normally this will return &quot;null&quot;,
     *          indicating that no special editor has been registered,
     *          so the PropertyEditorManager should be used to locate
     *          a suitable PropertyEditor.
     */
    public Class&lt;?&gt; getPropertyEditorClass() {
<span class="nc bnc" id="L408" title="All 2 branches missed.">        return (this.propertyEditorClassRef != null)</span>
<span class="nc" id="L409">                ? this.propertyEditorClassRef.get()</span>
                : null;
    }

    /**
     * Constructs an instance of a property editor using the current
     * property editor class.
     * &lt;p&gt;
     * If the property editor class has a public constructor that takes an
     * Object argument then it will be invoked using the bean parameter
     * as the argument. Otherwise, the default constructor will be invoked.
     *
     * @param bean the source object
     * @return a property editor instance or null if a property editor has
     *         not been defined or cannot be created
     * @since 1.5
     */
    public PropertyEditor createPropertyEditor(Object bean) {
<span class="nc" id="L427">        Object editor = null;</span>

<span class="nc" id="L429">        Class&lt;?&gt; cls = getPropertyEditorClass();</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (cls != null) {</span>
<span class="nc" id="L431">            Constructor&lt;?&gt; ctor = null;</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">            if (bean != null) {</span>
                try {
<span class="nc" id="L434">                    ctor = cls.getConstructor(new Class&lt;?&gt;[] { Object.class });</span>
<span class="nc" id="L435">                } catch (Exception ex) {</span>
                    // Fall through
<span class="nc" id="L437">                }</span>
            }
            try {
<span class="nc bnc" id="L440" title="All 2 branches missed.">                if (ctor == null) {</span>
<span class="nc" id="L441">                    editor = cls.newInstance();</span>
                } else {
<span class="nc" id="L443">                    editor = ctor.newInstance(new Object[] { bean });</span>
                }
<span class="nc" id="L445">            } catch (Exception ex) {</span>
                // Fall through
<span class="nc" id="L447">            }</span>
        }
<span class="nc" id="L449">        return (PropertyEditor)editor;</span>
    }


    /**
     * Compares this &lt;code&gt;PropertyDescriptor&lt;/code&gt; against the specified object.
     * Returns true if the objects are the same. Two &lt;code&gt;PropertyDescriptor&lt;/code&gt;s
     * are the same if the read, write, property types, property editor and
     * flags  are equivalent.
     *
     * @since 1.4
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L463">            return true;</span>
        }
<span class="nc bnc" id="L465" title="All 4 branches missed.">        if (obj != null &amp;&amp; obj instanceof PropertyDescriptor) {</span>
<span class="nc" id="L466">            PropertyDescriptor other = (PropertyDescriptor)obj;</span>
<span class="nc" id="L467">            Method otherReadMethod = other.getReadMethod();</span>
<span class="nc" id="L468">            Method otherWriteMethod = other.getWriteMethod();</span>

<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (!compareMethods(getReadMethod(), otherReadMethod)) {</span>
<span class="nc" id="L471">                return false;</span>
            }

<span class="nc bnc" id="L474" title="All 2 branches missed.">            if (!compareMethods(getWriteMethod(), otherWriteMethod)) {</span>
<span class="nc" id="L475">                return false;</span>
            }

<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (getPropertyType() == other.getPropertyType() &amp;&amp;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">                getPropertyEditorClass() == other.getPropertyEditorClass() &amp;&amp;</span>
<span class="nc bnc" id="L480" title="All 8 branches missed.">                bound == other.isBound() &amp;&amp; constrained == other.isConstrained() &amp;&amp;</span>
                writeMethodName == other.writeMethodName &amp;&amp;
                readMethodName == other.readMethodName) {
<span class="nc" id="L483">                return true;</span>
            }
        }
<span class="nc" id="L486">        return false;</span>
    }

    /**
     * Package private helper method for Descriptor .equals methods.
     *
     * @param a first method to compare
     * @param b second method to compare
     * @return boolean to indicate that the methods are equivalent
     */
    boolean compareMethods(Method a, Method b) {
        // Note: perhaps this should be a protected method in FeatureDescriptor
<span class="nc bnc" id="L498" title="All 6 branches missed.">        if ((a == null) != (b == null)) {</span>
<span class="nc" id="L499">            return false;</span>
        }

<span class="nc bnc" id="L502" title="All 4 branches missed.">        if (a != null &amp;&amp; b != null) {</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (!a.equals(b)) {</span>
<span class="nc" id="L504">                return false;</span>
            }
        }
<span class="nc" id="L507">        return true;</span>
    }

    /**
     * Package-private constructor.
     * Merge two property descriptors.  Where they conflict, give the
     * second argument (y) priority over the first argument (x).
     *
     * @param x  The first (lower priority) PropertyDescriptor
     * @param y  The second (higher priority) PropertyDescriptor
     */
    PropertyDescriptor(PropertyDescriptor x, PropertyDescriptor y) {
<span class="nc" id="L519">        super(x,y);</span>

<span class="nc bnc" id="L521" title="All 2 branches missed.">        if (y.baseName != null) {</span>
<span class="nc" id="L522">            baseName = y.baseName;</span>
        } else {
<span class="nc" id="L524">            baseName = x.baseName;</span>
        }

<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (y.readMethodName != null) {</span>
<span class="nc" id="L528">            readMethodName = y.readMethodName;</span>
        } else {
<span class="nc" id="L530">            readMethodName = x.readMethodName;</span>
        }

<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (y.writeMethodName != null) {</span>
<span class="nc" id="L534">            writeMethodName = y.writeMethodName;</span>
        } else {
<span class="nc" id="L536">            writeMethodName = x.writeMethodName;</span>
        }

<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (y.propertyTypeRef != null) {</span>
<span class="nc" id="L540">            propertyTypeRef = y.propertyTypeRef;</span>
        } else {
<span class="nc" id="L542">            propertyTypeRef = x.propertyTypeRef;</span>
        }

        // Figure out the merged read method.
<span class="nc" id="L546">        Method xr = x.getReadMethod();</span>
<span class="nc" id="L547">        Method yr = y.getReadMethod();</span>

        // Normally give priority to y's readMethod.
        try {
<span class="nc bnc" id="L551" title="All 2 branches missed.">            if (isAssignable(xr, yr)) {</span>
<span class="nc" id="L552">                setReadMethod(yr);</span>
            } else {
<span class="nc" id="L554">                setReadMethod(xr);</span>
            }
<span class="nc" id="L556">        } catch (IntrospectionException ex) {</span>
            // fall through
<span class="nc" id="L558">        }</span>

        // However, if both x and y reference read methods in the same class,
        // give priority to a boolean &quot;is&quot; method over a boolean &quot;get&quot; method.
<span class="nc bnc" id="L562" title="All 4 branches missed.">        if (xr != null &amp;&amp; yr != null &amp;&amp;</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">                   xr.getDeclaringClass() == yr.getDeclaringClass() &amp;&amp;</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                   getReturnType(getClass0(), xr) == boolean.class &amp;&amp;</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">                   getReturnType(getClass0(), yr) == boolean.class &amp;&amp;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">                   xr.getName().indexOf(Introspector.IS_PREFIX) == 0 &amp;&amp;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                   yr.getName().indexOf(Introspector.GET_PREFIX) == 0) {</span>
            try {
<span class="nc" id="L569">                setReadMethod(xr);</span>
<span class="nc" id="L570">            } catch (IntrospectionException ex) {</span>
                // fall through
<span class="nc" id="L572">            }</span>
        }

<span class="nc" id="L575">        Method xw = x.getWriteMethod();</span>
<span class="nc" id="L576">        Method yw = y.getWriteMethod();</span>

        try {
<span class="nc bnc" id="L579" title="All 2 branches missed.">            if (yw != null) {</span>
<span class="nc" id="L580">                setWriteMethod(yw);</span>
            } else {
<span class="nc" id="L582">                setWriteMethod(xw);</span>
            }
<span class="nc" id="L584">        } catch (IntrospectionException ex) {</span>
            // Fall through
<span class="nc" id="L586">        }</span>

<span class="nc bnc" id="L588" title="All 2 branches missed.">        if (y.getPropertyEditorClass() != null) {</span>
<span class="nc" id="L589">            setPropertyEditorClass(y.getPropertyEditorClass());</span>
        } else {
<span class="nc" id="L591">            setPropertyEditorClass(x.getPropertyEditorClass());</span>
        }


<span class="nc" id="L595">        bound = x.bound | y.bound;</span>
<span class="nc" id="L596">        constrained = x.constrained | y.constrained;</span>
<span class="nc" id="L597">    }</span>

    /*
     * Package-private dup constructor.
     * This must isolate the new object from any changes to the old object.
     */
    PropertyDescriptor(PropertyDescriptor old) {
<span class="nc" id="L604">        super(old);</span>
<span class="nc" id="L605">        propertyTypeRef = old.propertyTypeRef;</span>
<span class="nc" id="L606">        this.readMethodRef.set(old.readMethodRef.get());</span>
<span class="nc" id="L607">        this.writeMethodRef.set(old.writeMethodRef.get());</span>
<span class="nc" id="L608">        propertyEditorClassRef = old.propertyEditorClassRef;</span>

<span class="nc" id="L610">        writeMethodName = old.writeMethodName;</span>
<span class="nc" id="L611">        readMethodName = old.readMethodName;</span>
<span class="nc" id="L612">        baseName = old.baseName;</span>

<span class="nc" id="L614">        bound = old.bound;</span>
<span class="nc" id="L615">        constrained = old.constrained;</span>
<span class="nc" id="L616">    }</span>

    void updateGenericsFor(Class&lt;?&gt; type) {
<span class="nc" id="L619">        setClass0(type);</span>
        try {
<span class="nc" id="L621">            setPropertyType(findPropertyType(this.readMethodRef.get(), this.writeMethodRef.get()));</span>
        }
<span class="nc" id="L623">        catch (IntrospectionException exception) {</span>
<span class="nc" id="L624">            setPropertyType(null);</span>
<span class="nc" id="L625">        }</span>
<span class="nc" id="L626">    }</span>

    /**
     * Returns the property type that corresponds to the read and write method.
     * The type precedence is given to the readMethod.
     *
     * @return the type of the property descriptor or null if both
     *         read and write methods are null.
     * @throws IntrospectionException if the read or write method is invalid
     */
    private Class&lt;?&gt; findPropertyType(Method readMethod, Method writeMethod)
        throws IntrospectionException {
<span class="nc" id="L638">        Class&lt;?&gt; propertyType = null;</span>
        try {
<span class="nc bnc" id="L640" title="All 2 branches missed.">            if (readMethod != null) {</span>
<span class="nc" id="L641">                Class&lt;?&gt;[] params = getParameterTypes(getClass0(), readMethod);</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">                if (params.length != 0) {</span>
<span class="nc" id="L643">                    throw new IntrospectionException(&quot;bad read method arg count: &quot;</span>
                                                     + readMethod);
                }
<span class="nc" id="L646">                propertyType = getReturnType(getClass0(), readMethod);</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">                if (propertyType == Void.TYPE) {</span>
<span class="nc" id="L648">                    throw new IntrospectionException(&quot;read method &quot; +</span>
<span class="nc" id="L649">                                        readMethod.getName() + &quot; returns void&quot;);</span>
                }
            }
<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (writeMethod != null) {</span>
<span class="nc" id="L653">                Class&lt;?&gt;[] params = getParameterTypes(getClass0(), writeMethod);</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">                if (params.length != 1) {</span>
<span class="nc" id="L655">                    throw new IntrospectionException(&quot;bad write method arg count: &quot;</span>
                                                     + writeMethod);
                }
<span class="nc bnc" id="L658" title="All 4 branches missed.">                if (propertyType != null &amp;&amp; !params[0].isAssignableFrom(propertyType)) {</span>
<span class="nc" id="L659">                    throw new IntrospectionException(&quot;type mismatch between read and write methods&quot;);</span>
                }
<span class="nc" id="L661">                propertyType = params[0];</span>
            }
<span class="nc" id="L663">        } catch (IntrospectionException ex) {</span>
<span class="nc" id="L664">            throw ex;</span>
<span class="nc" id="L665">        }</span>
<span class="nc" id="L666">        return propertyType;</span>
    }


    /**
     * Returns a hash code value for the object.
     * See {@link java.lang.Object#hashCode} for a complete description.
     *
     * @return a hash code value for this object.
     * @since 1.5
     */
    public int hashCode() {
<span class="nc" id="L678">        int result = 7;</span>

<span class="nc bnc" id="L680" title="All 2 branches missed.">        result = 37 * result + ((getPropertyType() == null) ? 0 :</span>
<span class="nc" id="L681">                                getPropertyType().hashCode());</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">        result = 37 * result + ((getReadMethod() == null) ? 0 :</span>
<span class="nc" id="L683">                                getReadMethod().hashCode());</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">        result = 37 * result + ((getWriteMethod() == null) ? 0 :</span>
<span class="nc" id="L685">                                getWriteMethod().hashCode());</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">        result = 37 * result + ((getPropertyEditorClass() == null) ? 0 :</span>
<span class="nc" id="L687">                                getPropertyEditorClass().hashCode());</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        result = 37 * result + ((writeMethodName == null) ? 0 :</span>
<span class="nc" id="L689">                                writeMethodName.hashCode());</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        result = 37 * result + ((readMethodName == null) ? 0 :</span>
<span class="nc" id="L691">                                readMethodName.hashCode());</span>
<span class="nc" id="L692">        result = 37 * result + getName().hashCode();</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">        result = 37 * result + ((bound == false) ? 0 : 1);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        result = 37 * result + ((constrained == false) ? 0 : 1);</span>

<span class="nc" id="L696">        return result;</span>
    }

    // Calculate once since capitalize() is expensive.
    String getBaseName() {
<span class="nc bnc" id="L701" title="All 2 branches missed.">        if (baseName == null) {</span>
<span class="nc" id="L702">            baseName = NameGenerator.capitalize(getName());</span>
        }
<span class="nc" id="L704">        return baseName;</span>
    }

    void appendTo(StringBuilder sb) {
<span class="nc" id="L708">        appendTo(sb, &quot;bound&quot;, this.bound);</span>
<span class="nc" id="L709">        appendTo(sb, &quot;constrained&quot;, this.constrained);</span>
<span class="nc" id="L710">        appendTo(sb, &quot;propertyEditorClass&quot;, this.propertyEditorClassRef);</span>
<span class="nc" id="L711">        appendTo(sb, &quot;propertyType&quot;, this.propertyTypeRef);</span>
<span class="nc" id="L712">        appendTo(sb, &quot;readMethod&quot;, this.readMethodRef.get());</span>
<span class="nc" id="L713">        appendTo(sb, &quot;writeMethod&quot;, this.writeMethodRef.get());</span>
<span class="nc" id="L714">    }</span>

    private boolean isAssignable(Method m1, Method m2) {
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (m1 == null) {</span>
<span class="nc" id="L718">            return true; // choose second method</span>
        }
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (m2 == null) {</span>
<span class="nc" id="L721">            return false; // choose first method</span>
        }
<span class="nc bnc" id="L723" title="All 2 branches missed.">        if (!m1.getName().equals(m2.getName())) {</span>
<span class="nc" id="L724">            return true; // choose second method by default</span>
        }
<span class="nc" id="L726">        Class&lt;?&gt; type1 = m1.getDeclaringClass();</span>
<span class="nc" id="L727">        Class&lt;?&gt; type2 = m2.getDeclaringClass();</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (!type1.isAssignableFrom(type2)) {</span>
<span class="nc" id="L729">            return false; // choose first method: it declared later</span>
        }
<span class="nc" id="L731">        type1 = getReturnType(getClass0(), m1);</span>
<span class="nc" id="L732">        type2 = getReturnType(getClass0(), m2);</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">        if (!type1.isAssignableFrom(type2)) {</span>
<span class="nc" id="L734">            return false; // choose first method: it overrides return type</span>
        }
<span class="nc" id="L736">        Class&lt;?&gt;[] args1 = getParameterTypes(getClass0(), m1);</span>
<span class="nc" id="L737">        Class&lt;?&gt;[] args2 = getParameterTypes(getClass0(), m2);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (args1.length != args2.length) {</span>
<span class="nc" id="L739">            return true; // choose second method by default</span>
        }
<span class="nc bnc" id="L741" title="All 2 branches missed.">        for (int i = 0; i &lt; args1.length; i++) {</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            if (!args1[i].isAssignableFrom(args2[i])) {</span>
<span class="nc" id="L743">                return false; // choose first method: it overrides parameter</span>
            }
        }
<span class="nc" id="L746">        return true; // choose second method</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>