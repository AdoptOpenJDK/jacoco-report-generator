<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>XMLEncoder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.beans</a> &gt; <span class="el_source">XMLEncoder.java</span></div><h1>XMLEncoder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.beans;

import java.io.*;
import java.util.*;
import java.lang.reflect.*;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.IllegalCharsetNameException;
import java.nio.charset.UnsupportedCharsetException;

/**
 * The &lt;code&gt;XMLEncoder&lt;/code&gt; class is a complementary alternative to
 * the &lt;code&gt;ObjectOutputStream&lt;/code&gt; and can used to generate
 * a textual representation of a &lt;em&gt;JavaBean&lt;/em&gt; in the same
 * way that the &lt;code&gt;ObjectOutputStream&lt;/code&gt; can
 * be used to create binary representation of &lt;code&gt;Serializable&lt;/code&gt;
 * objects. For example, the following fragment can be used to create
 * a textual representation the supplied &lt;em&gt;JavaBean&lt;/em&gt;
 * and all its properties:
 * &lt;pre&gt;
 *       XMLEncoder e = new XMLEncoder(
 *                          new BufferedOutputStream(
 *                              new FileOutputStream(&quot;Test.xml&quot;)));
 *       e.writeObject(new JButton(&quot;Hello, world&quot;));
 *       e.close();
 * &lt;/pre&gt;
 * Despite the similarity of their APIs, the &lt;code&gt;XMLEncoder&lt;/code&gt;
 * class is exclusively designed for the purpose of archiving graphs
 * of &lt;em&gt;JavaBean&lt;/em&gt;s as textual representations of their public
 * properties. Like Java source files, documents written this way
 * have a natural immunity to changes in the implementations of the classes
 * involved. The &lt;code&gt;ObjectOutputStream&lt;/code&gt; continues to be recommended
 * for interprocess communication and general purpose serialization.
 * &lt;p&gt;
 * The &lt;code&gt;XMLEncoder&lt;/code&gt; class provides a default denotation for
 * &lt;em&gt;JavaBean&lt;/em&gt;s in which they are represented as XML documents
 * complying with version 1.0 of the XML specification and the
 * UTF-8 character encoding of the Unicode/ISO 10646 character set.
 * The XML documents produced by the &lt;code&gt;XMLEncoder&lt;/code&gt; class are:
 * &lt;ul&gt;
 * &lt;li&gt;
 * &lt;em&gt;Portable and version resilient&lt;/em&gt;: they have no dependencies
 * on the private implementation of any class and so, like Java source
 * files, they may be exchanged between environments which may have
 * different versions of some of the classes and between VMs from
 * different vendors.
 * &lt;li&gt;
 * &lt;em&gt;Structurally compact&lt;/em&gt;: The &lt;code&gt;XMLEncoder&lt;/code&gt; class
 * uses a &lt;em&gt;redundancy elimination&lt;/em&gt; algorithm internally so that the
 * default values of a Bean's properties are not written to the stream.
 * &lt;li&gt;
 * &lt;em&gt;Fault tolerant&lt;/em&gt;: Non-structural errors in the file,
 * caused either by damage to the file or by API changes
 * made to classes in an archive remain localized
 * so that a reader can report the error and continue to load the parts
 * of the document which were not affected by the error.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Below is an example of an XML archive containing
 * some user interface components from the &lt;em&gt;swing&lt;/em&gt; toolkit:
 * &lt;pre&gt;
 * &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
 * &amp;lt;java version=&quot;1.0&quot; class=&quot;java.beans.XMLDecoder&quot;&amp;gt;
 * &amp;lt;object class=&quot;javax.swing.JFrame&quot;&amp;gt;
 *   &amp;lt;void property=&quot;name&quot;&amp;gt;
 *     &amp;lt;string&amp;gt;frame1&amp;lt;/string&amp;gt;
 *   &amp;lt;/void&amp;gt;
 *   &amp;lt;void property=&quot;bounds&quot;&amp;gt;
 *     &amp;lt;object class=&quot;java.awt.Rectangle&quot;&amp;gt;
 *       &amp;lt;int&amp;gt;0&amp;lt;/int&amp;gt;
 *       &amp;lt;int&amp;gt;0&amp;lt;/int&amp;gt;
 *       &amp;lt;int&amp;gt;200&amp;lt;/int&amp;gt;
 *       &amp;lt;int&amp;gt;200&amp;lt;/int&amp;gt;
 *     &amp;lt;/object&amp;gt;
 *   &amp;lt;/void&amp;gt;
 *   &amp;lt;void property=&quot;contentPane&quot;&amp;gt;
 *     &amp;lt;void method=&quot;add&quot;&amp;gt;
 *       &amp;lt;object class=&quot;javax.swing.JButton&quot;&amp;gt;
 *         &amp;lt;void property=&quot;label&quot;&amp;gt;
 *           &amp;lt;string&amp;gt;Hello&amp;lt;/string&amp;gt;
 *         &amp;lt;/void&amp;gt;
 *       &amp;lt;/object&amp;gt;
 *     &amp;lt;/void&amp;gt;
 *   &amp;lt;/void&amp;gt;
 *   &amp;lt;void property=&quot;visible&quot;&amp;gt;
 *     &amp;lt;boolean&amp;gt;true&amp;lt;/boolean&amp;gt;
 *   &amp;lt;/void&amp;gt;
 * &amp;lt;/object&amp;gt;
 * &amp;lt;/java&amp;gt;
 * &lt;/pre&gt;
 * The XML syntax uses the following conventions:
 * &lt;ul&gt;
 * &lt;li&gt;
 * Each element represents a method call.
 * &lt;li&gt;
 * The &quot;object&quot; tag denotes an &lt;em&gt;expression&lt;/em&gt; whose value is
 * to be used as the argument to the enclosing element.
 * &lt;li&gt;
 * The &quot;void&quot; tag denotes a &lt;em&gt;statement&lt;/em&gt; which will
 * be executed, but whose result will not be used as an
 * argument to the enclosing method.
 * &lt;li&gt;
 * Elements which contain elements use those elements as arguments,
 * unless they have the tag: &quot;void&quot;.
 * &lt;li&gt;
 * The name of the method is denoted by the &quot;method&quot; attribute.
 * &lt;li&gt;
 * XML's standard &quot;id&quot; and &quot;idref&quot; attributes are used to make
 * references to previous expressions - so as to deal with
 * circularities in the object graph.
 * &lt;li&gt;
 * The &quot;class&quot; attribute is used to specify the target of a static
 * method or constructor explicitly; its value being the fully
 * qualified name of the class.
 * &lt;li&gt;
 * Elements with the &quot;void&quot; tag are executed using
 * the outer context as the target if no target is defined
 * by a &quot;class&quot; attribute.
 * &lt;li&gt;
 * Java's String class is treated specially and is
 * written &amp;lt;string&amp;gt;Hello, world&amp;lt;/string&amp;gt; where
 * the characters of the string are converted to bytes
 * using the UTF-8 character encoding.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Although all object graphs may be written using just these three
 * tags, the following definitions are included so that common
 * data structures can be expressed more concisely:
 * &lt;p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * The default method name is &quot;new&quot;.
 * &lt;li&gt;
 * A reference to a java class is written in the form
 *  &amp;lt;class&amp;gt;javax.swing.JButton&amp;lt;/class&amp;gt;.
 * &lt;li&gt;
 * Instances of the wrapper classes for Java's primitive types are written
 * using the name of the primitive type as the tag. For example, an
 * instance of the &lt;code&gt;Integer&lt;/code&gt; class could be written:
 * &amp;lt;int&amp;gt;123&amp;lt;/int&amp;gt;. Note that the &lt;code&gt;XMLEncoder&lt;/code&gt; class
 * uses Java's reflection package in which the conversion between
 * Java's primitive types and their associated &quot;wrapper classes&quot;
 * is handled internally. The API for the &lt;code&gt;XMLEncoder&lt;/code&gt; class
 * itself deals only with &lt;code&gt;Object&lt;/code&gt;s.
 * &lt;li&gt;
 * In an element representing a nullary method whose name
 * starts with &quot;get&quot;, the &quot;method&quot; attribute is replaced
 * with a &quot;property&quot; attribute whose value is given by removing
 * the &quot;get&quot; prefix and decapitalizing the result.
 * &lt;li&gt;
 * In an element representing a monadic method whose name
 * starts with &quot;set&quot;, the &quot;method&quot; attribute is replaced
 * with a &quot;property&quot; attribute whose value is given by removing
 * the &quot;set&quot; prefix and decapitalizing the result.
 * &lt;li&gt;
 * In an element representing a method named &quot;get&quot; taking one
 * integer argument, the &quot;method&quot; attribute is replaced
 * with an &quot;index&quot; attribute whose value the value of the
 * first argument.
 * &lt;li&gt;
 * In an element representing a method named &quot;set&quot; taking two arguments,
 * the first of which is an integer, the &quot;method&quot; attribute is replaced
 * with an &quot;index&quot; attribute whose value the value of the
 * first argument.
 * &lt;li&gt;
 * A reference to an array is written using the &quot;array&quot;
 * tag. The &quot;class&quot; and &quot;length&quot; attributes specify the
 * sub-type of the array and its length respectively.
 * &lt;/ul&gt;
 *
 *&lt;p&gt;
 * For more information you might also want to check out
 * &lt;a
 href=&quot;http://java.sun.com/products/jfc/tsc/articles/persistence4&quot;&gt;Using XMLEncoder&lt;/a&gt;,
 * an article in &lt;em&gt;The Swing Connection.&lt;/em&gt;
 * @see XMLDecoder
 * @see java.io.ObjectOutputStream
 *
 * @since 1.4
 *
 * @author Philip Milne
 */
public class XMLEncoder extends Encoder implements AutoCloseable {

    private final CharsetEncoder encoder;
    private final String charset;
    private final boolean declaration;

    private OutputStreamWriter out;
    private Object owner;
<span class="nc" id="L215">    private int indentation = 0;</span>
<span class="nc" id="L216">    private boolean internal = false;</span>
    private Map&lt;Object, ValueData&gt; valueToExpression;
    private Map&lt;Object, List&lt;Statement&gt;&gt; targetToStatementList;
<span class="nc" id="L219">    private boolean preambleWritten = false;</span>
    private NameGenerator nameGenerator;

<span class="nc" id="L222">    private class ValueData {</span>
<span class="nc" id="L223">        public int refs = 0;</span>
<span class="nc" id="L224">        public boolean marked = false; // Marked -&gt; refs &gt; 0 unless ref was a target.</span>
<span class="nc" id="L225">        public String name = null;</span>
<span class="nc" id="L226">        public Expression exp = null;</span>
    }

    /**
     * Creates a new XML encoder to write out &lt;em&gt;JavaBeans&lt;/em&gt;
     * to the stream &lt;code&gt;out&lt;/code&gt; using an XML encoding.
     *
     * @param out  the stream to which the XML representation of
     *             the objects will be written
     *
     * @throws  IllegalArgumentException
     *          if &lt;code&gt;out&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     *
     * @see XMLDecoder#XMLDecoder(InputStream)
     */
    public XMLEncoder(OutputStream out) {
<span class="nc" id="L242">        this(out, &quot;UTF-8&quot;, true, 0);</span>
<span class="nc" id="L243">    }</span>

    /**
     * Creates a new XML encoder to write out &lt;em&gt;JavaBeans&lt;/em&gt;
     * to the stream &lt;code&gt;out&lt;/code&gt; using the given &lt;code&gt;charset&lt;/code&gt;
     * starting from the given &lt;code&gt;indentation&lt;/code&gt;.
     *
     * @param out          the stream to which the XML representation of
     *                     the objects will be written
     * @param charset      the name of the requested charset;
     *                     may be either a canonical name or an alias
     * @param declaration  whether the XML declaration should be generated;
     *                     set this to &lt;code&gt;false&lt;/code&gt;
     *                     when embedding the contents in another XML document
     * @param indentation  the number of space characters to indent the entire XML document by
     *
     * @throws  IllegalArgumentException
     *          if &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;charset&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     *          or if &lt;code&gt;indentation&lt;/code&gt; is less than 0
     *
     * @throws  IllegalCharsetNameException
     *          if &lt;code&gt;charset&lt;/code&gt; name is illegal
     *
     * @throws  UnsupportedCharsetException
     *          if no support for the named charset is available
     *          in this instance of the Java virtual machine
     *
     * @throws  UnsupportedOperationException
     *          if loaded charset does not support encoding
     *
     * @see Charset#forName(String)
     *
     * @since 1.7
     */
<span class="nc" id="L277">    public XMLEncoder(OutputStream out, String charset, boolean declaration, int indentation) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (out == null) {</span>
<span class="nc" id="L279">            throw new IllegalArgumentException(&quot;the output stream cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (indentation &lt; 0) {</span>
<span class="nc" id="L282">            throw new IllegalArgumentException(&quot;the indentation must be &gt;= 0&quot;);</span>
        }
<span class="nc" id="L284">        Charset cs = Charset.forName(charset);</span>
<span class="nc" id="L285">        this.encoder = cs.newEncoder();</span>
<span class="nc" id="L286">        this.charset = charset;</span>
<span class="nc" id="L287">        this.declaration = declaration;</span>
<span class="nc" id="L288">        this.indentation = indentation;</span>
<span class="nc" id="L289">        this.out = new OutputStreamWriter(out, cs.newEncoder());</span>
<span class="nc" id="L290">        valueToExpression = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L291">        targetToStatementList = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L292">        nameGenerator = new NameGenerator();</span>
<span class="nc" id="L293">    }</span>

    /**
     * Sets the owner of this encoder to &lt;code&gt;owner&lt;/code&gt;.
     *
     * @param owner The owner of this encoder.
     *
     * @see #getOwner
     */
    public void setOwner(Object owner) {
<span class="nc" id="L303">        this.owner = owner;</span>
<span class="nc" id="L304">        writeExpression(new Expression(this, &quot;getOwner&quot;, new Object[0]));</span>
<span class="nc" id="L305">    }</span>

    /**
     * Gets the owner of this encoder.
     *
     * @return The owner of this encoder.
     *
     * @see #setOwner
     */
    public Object getOwner() {
<span class="nc" id="L315">        return owner;</span>
    }

    /**
     * Write an XML representation of the specified object to the output.
     *
     * @param o The object to be written to the stream.
     *
     * @see XMLDecoder#readObject
     */
    public void writeObject(Object o) {
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (internal) {</span>
<span class="nc" id="L327">            super.writeObject(o);</span>
        }
        else {
<span class="nc" id="L330">            writeStatement(new Statement(this, &quot;writeObject&quot;, new Object[]{o}));</span>
        }
<span class="nc" id="L332">    }</span>

    private List&lt;Statement&gt; statementList(Object target) {
<span class="nc" id="L335">        List&lt;Statement&gt; list = targetToStatementList.get(target);</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (list == null) {</span>
<span class="nc" id="L337">            list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L338">            targetToStatementList.put(target, list);</span>
        }
<span class="nc" id="L340">        return list;</span>
    }


    private void mark(Object o, boolean isArgument) {
<span class="nc bnc" id="L345" title="All 4 branches missed.">        if (o == null || o == this) {</span>
<span class="nc" id="L346">            return;</span>
        }
<span class="nc" id="L348">        ValueData d = getValueData(o);</span>
<span class="nc" id="L349">        Expression exp = d.exp;</span>
        // Do not mark liternal strings. Other strings, which might,
        // for example, come from resource bundles should still be marked.
<span class="nc bnc" id="L352" title="All 4 branches missed.">        if (o.getClass() == String.class &amp;&amp; exp == null) {</span>
<span class="nc" id="L353">            return;</span>
        }

        // Bump the reference counts of all arguments
<span class="nc bnc" id="L357" title="All 2 branches missed.">        if (isArgument) {</span>
<span class="nc" id="L358">            d.refs++;</span>
        }
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (d.marked) {</span>
<span class="nc" id="L361">            return;</span>
        }
<span class="nc" id="L363">        d.marked = true;</span>
<span class="nc" id="L364">        Object target = exp.getTarget();</span>
<span class="nc" id="L365">        mark(exp);</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">        if (!(target instanceof Class)) {</span>
<span class="nc" id="L367">            statementList(target).add(exp);</span>
            // Pending: Why does the reference count need to
            // be incremented here?
<span class="nc" id="L370">            d.refs++;</span>
        }
<span class="nc" id="L372">    }</span>

    private void mark(Statement stm) {
<span class="nc" id="L375">        Object[] args = stm.getArguments();</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="nc" id="L377">            Object arg = args[i];</span>
<span class="nc" id="L378">            mark(arg, true);</span>
        }
<span class="nc" id="L380">        mark(stm.getTarget(), stm instanceof Expression);</span>
<span class="nc" id="L381">    }</span>


    /**
     * Records the Statement so that the Encoder will
     * produce the actual output when the stream is flushed.
     * &lt;P&gt;
     * This method should only be invoked within the context
     * of initializing a persistence delegate.
     *
     * @param oldStm The statement that will be written
     *               to the stream.
     * @see java.beans.PersistenceDelegate#initialize
     */
    public void writeStatement(Statement oldStm) {
        // System.out.println(&quot;XMLEncoder::writeStatement: &quot; + oldStm);
<span class="nc" id="L397">        boolean internal = this.internal;</span>
<span class="nc" id="L398">        this.internal = true;</span>
        try {
<span class="nc" id="L400">            super.writeStatement(oldStm);</span>
            /*
               Note we must do the mark first as we may
               require the results of previous values in
               this context for this statement.
               Test case is:
                   os.setOwner(this);
                   os.writeObject(this);
            */
<span class="nc" id="L409">            mark(oldStm);</span>
<span class="nc" id="L410">            Object target = oldStm.getTarget();</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (target instanceof Field) {</span>
<span class="nc" id="L412">                String method = oldStm.getMethodName();</span>
<span class="nc" id="L413">                Object[] args = oldStm.getArguments();</span>
<span class="nc bnc" id="L414" title="All 4 branches missed.">                if ((method == null) || (args == null)) {</span>
                }
<span class="nc bnc" id="L416" title="All 4 branches missed.">                else if (method.equals(&quot;get&quot;) &amp;&amp; (args.length == 1)) {</span>
<span class="nc" id="L417">                    target = args[0];</span>
                }
<span class="nc bnc" id="L419" title="All 4 branches missed.">                else if (method.equals(&quot;set&quot;) &amp;&amp; (args.length == 2)) {</span>
<span class="nc" id="L420">                    target = args[0];</span>
                }
            }
<span class="nc" id="L423">            statementList(target).add(oldStm);</span>
        }
<span class="nc" id="L425">        catch (Exception e) {</span>
<span class="nc" id="L426">            getExceptionListener().exceptionThrown(new Exception(&quot;XMLEncoder: discarding statement &quot; + oldStm, e));</span>
<span class="nc" id="L427">        }</span>
<span class="nc" id="L428">        this.internal = internal;</span>
<span class="nc" id="L429">    }</span>


    /**
     * Records the Expression so that the Encoder will
     * produce the actual output when the stream is flushed.
     * &lt;P&gt;
     * This method should only be invoked within the context of
     * initializing a persistence delegate or setting up an encoder to
     * read from a resource bundle.
     * &lt;P&gt;
     * For more information about using resource bundles with the
     * XMLEncoder, see
     * http://java.sun.com/products/jfc/tsc/articles/persistence4/#i18n
     *
     * @param oldExp The expression that will be written
     *               to the stream.
     * @see java.beans.PersistenceDelegate#initialize
     */
    public void writeExpression(Expression oldExp) {
<span class="nc" id="L449">        boolean internal = this.internal;</span>
<span class="nc" id="L450">        this.internal = true;</span>
<span class="nc" id="L451">        Object oldValue = getValue(oldExp);</span>
<span class="nc bnc" id="L452" title="All 6 branches missed.">        if (get(oldValue) == null || (oldValue instanceof String &amp;&amp; !internal)) {</span>
<span class="nc" id="L453">            getValueData(oldValue).exp = oldExp;</span>
<span class="nc" id="L454">            super.writeExpression(oldExp);</span>
        }
<span class="nc" id="L456">        this.internal = internal;</span>
<span class="nc" id="L457">    }</span>

    /**
     * This method writes out the preamble associated with the
     * XML encoding if it has not been written already and
     * then writes out all of the values that been
     * written to the stream since the last time &lt;code&gt;flush&lt;/code&gt;
     * was called. After flushing, all internal references to the
     * values that were written to this stream are cleared.
     */
    public void flush() {
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (!preambleWritten) { // Don't do this in constructor - it throws ... pending.</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">            if (this.declaration) {</span>
<span class="nc" id="L470">                writeln(&quot;&lt;?xml version=&quot; + quote(&quot;1.0&quot;) +</span>
<span class="nc" id="L471">                            &quot; encoding=&quot; + quote(this.charset) + &quot;?&gt;&quot;);</span>
            }
<span class="nc" id="L473">            writeln(&quot;&lt;java version=&quot; + quote(System.getProperty(&quot;java.version&quot;)) +</span>
<span class="nc" id="L474">                           &quot; class=&quot; + quote(XMLDecoder.class.getName()) + &quot;&gt;&quot;);</span>
<span class="nc" id="L475">            preambleWritten = true;</span>
        }
<span class="nc" id="L477">        indentation++;</span>
<span class="nc" id="L478">        List&lt;Statement&gt; statements = statementList(this);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">        while (!statements.isEmpty()) {</span>
<span class="nc" id="L480">            Statement s = statements.remove(0);</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (&quot;writeObject&quot;.equals(s.getMethodName())) {</span>
<span class="nc" id="L482">                outputValue(s.getArguments()[0], this, true);</span>
            }
            else {
<span class="nc" id="L485">                outputStatement(s, this, false);</span>
            }
<span class="nc" id="L487">        }</span>
<span class="nc" id="L488">        indentation--;</span>

<span class="nc" id="L490">        Statement statement = getMissedStatement();</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">        while (statement != null) {</span>
<span class="nc" id="L492">            outputStatement(statement, this, false);</span>
<span class="nc" id="L493">            statement = getMissedStatement();</span>
        }

        try {
<span class="nc" id="L497">            out.flush();</span>
        }
<span class="nc" id="L499">        catch (IOException e) {</span>
<span class="nc" id="L500">            getExceptionListener().exceptionThrown(e);</span>
<span class="nc" id="L501">        }</span>
<span class="nc" id="L502">        clear();</span>
<span class="nc" id="L503">    }</span>

    void clear() {
<span class="nc" id="L506">        super.clear();</span>
<span class="nc" id="L507">        nameGenerator.clear();</span>
<span class="nc" id="L508">        valueToExpression.clear();</span>
<span class="nc" id="L509">        targetToStatementList.clear();</span>
<span class="nc" id="L510">    }</span>

    Statement getMissedStatement() {
<span class="nc bnc" id="L513" title="All 2 branches missed.">        for (List&lt;Statement&gt; statements : this.targetToStatementList.values()) {</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">            for (int i = 0; i &lt; statements.size(); i++) {</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                if (Statement.class == statements.get(i).getClass()) {</span>
<span class="nc" id="L516">                    return statements.remove(i);</span>
                }
            }
<span class="nc" id="L519">        }</span>
<span class="nc" id="L520">        return null;</span>
    }


    /**
     * This method calls &lt;code&gt;flush&lt;/code&gt;, writes the closing
     * postamble and then closes the output stream associated
     * with this stream.
     */
    public void close() {
<span class="nc" id="L530">        flush();</span>
<span class="nc" id="L531">        writeln(&quot;&lt;/java&gt;&quot;);</span>
        try {
<span class="nc" id="L533">            out.close();</span>
        }
<span class="nc" id="L535">        catch (IOException e) {</span>
<span class="nc" id="L536">            getExceptionListener().exceptionThrown(e);</span>
<span class="nc" id="L537">        }</span>
<span class="nc" id="L538">    }</span>

    private String quote(String s) {
<span class="nc" id="L541">        return &quot;\&quot;&quot; + s + &quot;\&quot;&quot;;</span>
    }

    private ValueData getValueData(Object o) {
<span class="nc" id="L545">        ValueData d = valueToExpression.get(o);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (d == null) {</span>
<span class="nc" id="L547">            d = new ValueData();</span>
<span class="nc" id="L548">            valueToExpression.put(o, d);</span>
        }
<span class="nc" id="L550">        return d;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the argument,
     * a Unicode code point, is valid in XML documents.
     * Unicode characters fit into the low sixteen bits of a Unicode code point,
     * and pairs of Unicode &lt;em&gt;surrogate characters&lt;/em&gt; can be combined
     * to encode Unicode code point in documents containing only Unicode.
     * (The &lt;code&gt;char&lt;/code&gt; datatype in the Java Programming Language
     * represents Unicode characters, including unpaired surrogates.)
     * &lt;par&gt;
     * [2] Char ::= #x0009 | #x000A | #x000D
     *            | [#x0020-#xD7FF]
     *            | [#xE000-#xFFFD]
     *            | [#x10000-#x10ffff]
     * &lt;/par&gt;
     *
     * @param code  the 32-bit Unicode code point being tested
     * @return  &lt;code&gt;true&lt;/code&gt; if the Unicode code point is valid,
     *          &lt;code&gt;false&lt;/code&gt; otherwise
     */
    private static boolean isValidCharCode(int code) {
<span class="nc bnc" id="L573" title="All 18 branches missed.">        return (0x0020 &lt;= code &amp;&amp; code &lt;= 0xD7FF)</span>
            || (0x000A == code)
            || (0x0009 == code)
            || (0x000D == code)
            || (0xE000 &lt;= code &amp;&amp; code &lt;= 0xFFFD)
            || (0x10000 &lt;= code &amp;&amp; code &lt;= 0x10ffff);
    }

    private void writeln(String exp) {
        try {
<span class="nc" id="L583">            StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">            for(int i = 0; i &lt; indentation; i++) {</span>
<span class="nc" id="L585">                sb.append(' ');</span>
            }
<span class="nc" id="L587">            sb.append(exp);</span>
<span class="nc" id="L588">            sb.append('\n');</span>
<span class="nc" id="L589">            this.out.write(sb.toString());</span>
        }
<span class="nc" id="L591">        catch (IOException e) {</span>
<span class="nc" id="L592">            getExceptionListener().exceptionThrown(e);</span>
<span class="nc" id="L593">        }</span>
<span class="nc" id="L594">    }</span>

    private void outputValue(Object value, Object outer, boolean isArgument) {
<span class="nc bnc" id="L597" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L598">            writeln(&quot;&lt;null/&gt;&quot;);</span>
<span class="nc" id="L599">            return;</span>
        }

<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (value instanceof Class) {</span>
<span class="nc" id="L603">            writeln(&quot;&lt;class&gt;&quot; + ((Class)value).getName() + &quot;&lt;/class&gt;&quot;);</span>
<span class="nc" id="L604">            return;</span>
        }

<span class="nc" id="L607">        ValueData d = getValueData(value);</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (d.exp != null) {</span>
<span class="nc" id="L609">            Object target = d.exp.getTarget();</span>
<span class="nc" id="L610">            String methodName = d.exp.getMethodName();</span>

<span class="nc bnc" id="L612" title="All 4 branches missed.">            if (target == null || methodName == null) {</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                throw new NullPointerException((target == null ? &quot;target&quot; :</span>
                                                &quot;methodName&quot;) + &quot; should not be null&quot;);
            }

<span class="nc bnc" id="L617" title="All 6 branches missed.">            if (isArgument &amp;&amp; target instanceof Field &amp;&amp; methodName.equals(&quot;get&quot;)) {</span>
<span class="nc" id="L618">                Field f = (Field)target;</span>
<span class="nc" id="L619">                writeln(&quot;&lt;object class=&quot; + quote(f.getDeclaringClass().getName()) +</span>
<span class="nc" id="L620">                        &quot; field=&quot; + quote(f.getName()) + &quot;/&gt;&quot;);</span>
<span class="nc" id="L621">                return;</span>
            }

<span class="nc" id="L624">            Class&lt;?&gt; primitiveType = primitiveTypeFor(value.getClass());</span>
<span class="nc bnc" id="L625" title="All 4 branches missed.">            if (primitiveType != null &amp;&amp; target == value.getClass() &amp;&amp;</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                methodName.equals(&quot;new&quot;)) {</span>
<span class="nc" id="L627">                String primitiveTypeName = primitiveType.getName();</span>
                // Make sure that character types are quoted correctly.
<span class="nc bnc" id="L629" title="All 2 branches missed.">                if (primitiveType == Character.TYPE) {</span>
<span class="nc" id="L630">                    char code = ((Character) value).charValue();</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                    if (!isValidCharCode(code)) {</span>
<span class="nc" id="L632">                        writeln(createString(code));</span>
<span class="nc" id="L633">                        return;</span>
                    }
<span class="nc" id="L635">                    value = quoteCharCode(code);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">                    if (value == null) {</span>
<span class="nc" id="L637">                        value = Character.valueOf(code);</span>
                    }
                }
<span class="nc" id="L640">                writeln(&quot;&lt;&quot; + primitiveTypeName + &quot;&gt;&quot; + value + &quot;&lt;/&quot; +</span>
                        primitiveTypeName + &quot;&gt;&quot;);
<span class="nc" id="L642">                return;</span>
            }

<span class="nc bnc" id="L645" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L646">            writeln(createString((String) value));</span>
<span class="nc" id="L647">            return;</span>
        }

<span class="nc bnc" id="L650" title="All 2 branches missed.">        if (d.name != null) {</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">            if (isArgument) {</span>
<span class="nc" id="L652">                writeln(&quot;&lt;object idref=&quot; + quote(d.name) + &quot;/&gt;&quot;);</span>
            }
            else {
<span class="nc" id="L655">                outputXML(&quot;void&quot;, &quot; idref=&quot; + quote(d.name), value);</span>
            }
        }
<span class="nc bnc" id="L658" title="All 2 branches missed.">        else if (d.exp != null) {</span>
<span class="nc" id="L659">            outputStatement(d.exp, outer, isArgument);</span>
        }
<span class="nc" id="L661">    }</span>

    private static String quoteCharCode(int code) {
<span class="nc bnc" id="L664" title="All 7 branches missed.">        switch(code) {</span>
<span class="nc" id="L665">          case '&amp;':  return &quot;&amp;amp;&quot;;</span>
<span class="nc" id="L666">          case '&lt;':  return &quot;&amp;lt;&quot;;</span>
<span class="nc" id="L667">          case '&gt;':  return &quot;&amp;gt;&quot;;</span>
<span class="nc" id="L668">          case '&quot;':  return &quot;&amp;quot;&quot;;</span>
<span class="nc" id="L669">          case '\'': return &quot;&amp;apos;&quot;;</span>
<span class="nc" id="L670">          case '\r': return &quot;&amp;#13;&quot;;</span>
<span class="nc" id="L671">          default:   return null;</span>
        }
    }

    private static String createString(int code) {
<span class="nc" id="L676">        return &quot;&lt;char code=\&quot;#&quot; + Integer.toString(code, 16) + &quot;\&quot;/&gt;&quot;;</span>
    }

    private String createString(String string) {
<span class="nc" id="L680">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L681">        sb.append(&quot;&lt;string&gt;&quot;);</span>
<span class="nc" id="L682">        int index = 0;</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">        while (index &lt; string.length()) {</span>
<span class="nc" id="L684">            int point = string.codePointAt(index);</span>
<span class="nc" id="L685">            int count = Character.charCount(point);</span>

<span class="nc bnc" id="L687" title="All 4 branches missed.">            if (isValidCharCode(point) &amp;&amp; this.encoder.canEncode(string.substring(index, index + count))) {</span>
<span class="nc" id="L688">                String value = quoteCharCode(point);</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">                if (value != null) {</span>
<span class="nc" id="L690">                    sb.append(value);</span>
                } else {
<span class="nc" id="L692">                    sb.appendCodePoint(point);</span>
                }
<span class="nc" id="L694">                index += count;</span>
<span class="nc" id="L695">            } else {</span>
<span class="nc" id="L696">                sb.append(createString(string.charAt(index)));</span>
<span class="nc" id="L697">                index++;</span>
            }
<span class="nc" id="L699">        }</span>
<span class="nc" id="L700">        sb.append(&quot;&lt;/string&gt;&quot;);</span>
<span class="nc" id="L701">        return sb.toString();</span>
    }

    private void outputStatement(Statement exp, Object outer, boolean isArgument) {
<span class="nc" id="L705">        Object target = exp.getTarget();</span>
<span class="nc" id="L706">        String methodName = exp.getMethodName();</span>

<span class="nc bnc" id="L708" title="All 4 branches missed.">        if (target == null || methodName == null) {</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">            throw new NullPointerException((target == null ? &quot;target&quot; :</span>
                                            &quot;methodName&quot;) + &quot; should not be null&quot;);
        }

<span class="nc" id="L713">        Object[] args = exp.getArguments();</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">        boolean expression = exp.getClass() == Expression.class;</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">        Object value = (expression) ? getValue((Expression)exp) : null;</span>

<span class="nc bnc" id="L717" title="All 4 branches missed.">        String tag = (expression &amp;&amp; isArgument) ? &quot;object&quot; : &quot;void&quot;;</span>
<span class="nc" id="L718">        String attributes = &quot;&quot;;</span>
<span class="nc" id="L719">        ValueData d = getValueData(value);</span>

        // Special cases for targets.
<span class="nc bnc" id="L722" title="All 2 branches missed.">        if (target == outer) {</span>
        }
<span class="nc bnc" id="L724" title="All 4 branches missed.">        else if (target == Array.class &amp;&amp; methodName.equals(&quot;newInstance&quot;)) {</span>
<span class="nc" id="L725">            tag = &quot;array&quot;;</span>
<span class="nc" id="L726">            attributes = attributes + &quot; class=&quot; + quote(((Class)args[0]).getName());</span>
<span class="nc" id="L727">            attributes = attributes + &quot; length=&quot; + quote(args[1].toString());</span>
<span class="nc" id="L728">            args = new Object[]{};</span>
        }
<span class="nc bnc" id="L730" title="All 2 branches missed.">        else if (target.getClass() == Class.class) {</span>
<span class="nc" id="L731">            attributes = attributes + &quot; class=&quot; + quote(((Class)target).getName());</span>
        }
        else {
<span class="nc" id="L734">            d.refs = 2;</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">            if (d.name == null) {</span>
<span class="nc" id="L736">                getValueData(target).refs++;</span>
<span class="nc" id="L737">                List&lt;Statement&gt; statements = statementList(target);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">                if (!statements.contains(exp)) {</span>
<span class="nc" id="L739">                    statements.add(exp);</span>
                }
<span class="nc" id="L741">                outputValue(target, outer, false);</span>
            }
<span class="nc bnc" id="L743" title="All 2 branches missed.">            if (expression) {</span>
<span class="nc" id="L744">                outputValue(value, outer, isArgument);</span>
            }
<span class="nc" id="L746">            return;</span>
        }
<span class="nc bnc" id="L748" title="All 4 branches missed.">        if (expression &amp;&amp; (d.refs &gt; 1)) {</span>
<span class="nc" id="L749">            String instanceName = nameGenerator.instanceName(value);</span>
<span class="nc" id="L750">            d.name = instanceName;</span>
<span class="nc" id="L751">            attributes = attributes + &quot; id=&quot; + quote(instanceName);</span>
        }

        // Special cases for methods.
<span class="nc bnc" id="L755" title="All 10 branches missed.">        if ((!expression &amp;&amp; methodName.equals(&quot;set&quot;) &amp;&amp; args.length == 2 &amp;&amp;</span>
             args[0] instanceof Integer) ||
<span class="nc bnc" id="L757" title="All 6 branches missed.">             (expression &amp;&amp; methodName.equals(&quot;get&quot;) &amp;&amp; args.length == 1 &amp;&amp;</span>
              args[0] instanceof Integer)) {
<span class="nc" id="L759">            attributes = attributes + &quot; index=&quot; + quote(args[0].toString());</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">            args = (args.length == 1) ? new Object[]{} : new Object[]{args[1]};</span>
        }
<span class="nc bnc" id="L762" title="All 8 branches missed.">        else if ((!expression &amp;&amp; methodName.startsWith(&quot;set&quot;) &amp;&amp; args.length == 1) ||</span>
<span class="nc bnc" id="L763" title="All 4 branches missed.">                 (expression &amp;&amp; methodName.startsWith(&quot;get&quot;) &amp;&amp; args.length == 0)) {</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">            if (3 &lt; methodName.length()) {</span>
<span class="nc" id="L765">                attributes = attributes + &quot; property=&quot; +</span>
<span class="nc" id="L766">                    quote(Introspector.decapitalize(methodName.substring(3)));</span>
            }
        }
<span class="nc bnc" id="L769" title="All 4 branches missed.">        else if (!methodName.equals(&quot;new&quot;) &amp;&amp; !methodName.equals(&quot;newInstance&quot;)) {</span>
<span class="nc" id="L770">            attributes = attributes + &quot; method=&quot; + quote(methodName);</span>
        }
<span class="nc" id="L772">        outputXML(tag, attributes, value, args);</span>
<span class="nc" id="L773">    }</span>

    private void outputXML(String tag, String attributes, Object value, Object... args) {
<span class="nc" id="L776">        List&lt;Statement&gt; statements = statementList(value);</span>
        // Use XML's short form when there is no body.
<span class="nc bnc" id="L778" title="All 4 branches missed.">        if (args.length == 0 &amp;&amp; statements.size() == 0) {</span>
<span class="nc" id="L779">            writeln(&quot;&lt;&quot; + tag + attributes + &quot;/&gt;&quot;);</span>
<span class="nc" id="L780">            return;</span>
        }

<span class="nc" id="L783">        writeln(&quot;&lt;&quot; + tag + attributes + &quot;&gt;&quot;);</span>
<span class="nc" id="L784">        indentation++;</span>

<span class="nc bnc" id="L786" title="All 2 branches missed.">        for(int i = 0; i &lt; args.length; i++) {</span>
<span class="nc" id="L787">            outputValue(args[i], null, true);</span>
        }

<span class="nc bnc" id="L790" title="All 2 branches missed.">        while (!statements.isEmpty()) {</span>
<span class="nc" id="L791">            Statement s = statements.remove(0);</span>
<span class="nc" id="L792">            outputStatement(s, value, false);</span>
<span class="nc" id="L793">        }</span>

<span class="nc" id="L795">        indentation--;</span>
<span class="nc" id="L796">        writeln(&quot;&lt;/&quot; + tag + &quot;&gt;&quot;);</span>
<span class="nc" id="L797">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    static Class primitiveTypeFor(Class wrapper) {
<span class="nc bnc" id="L801" title="All 2 branches missed.">        if (wrapper == Boolean.class) return Boolean.TYPE;</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">        if (wrapper == Byte.class) return Byte.TYPE;</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">        if (wrapper == Character.class) return Character.TYPE;</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">        if (wrapper == Short.class) return Short.TYPE;</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">        if (wrapper == Integer.class) return Integer.TYPE;</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">        if (wrapper == Long.class) return Long.TYPE;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">        if (wrapper == Float.class) return Float.TYPE;</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">        if (wrapper == Double.class) return Double.TYPE;</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">        if (wrapper == Void.class) return Void.TYPE;</span>
<span class="nc" id="L810">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>