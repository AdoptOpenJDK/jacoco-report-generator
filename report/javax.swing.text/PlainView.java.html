<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PlainView.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">PlainView.java</span></div><h1>PlainView.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.util.Vector;
import java.util.Properties;
import java.awt.*;
import javax.swing.event.*;

/**
 * Implements View interface for a simple multi-line text view
 * that has text in one font and color.  The view represents each
 * child element as a line of text.
 *
 * @author  Timothy Prinzing
 * @see     View
 */
public class PlainView extends View implements TabExpander {

    /**
     * Constructs a new PlainView wrapped on an element.
     *
     * @param elem the element
     */
    public PlainView(Element elem) {
<span class="nc" id="L48">        super(elem);</span>
<span class="nc" id="L49">    }</span>

    /**
     * Returns the tab size set for the document, defaulting to 8.
     *
     * @return the tab size
     */
    protected int getTabSize() {
<span class="nc" id="L57">        Integer i = (Integer) getDocument().getProperty(PlainDocument.tabSizeAttribute);</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        int size = (i != null) ? i.intValue() : 8;</span>
<span class="nc" id="L59">        return size;</span>
    }

    /**
     * Renders a line of text, suppressing whitespace at the end
     * and expanding any tabs.  This is implemented to make calls
     * to the methods &lt;code&gt;drawUnselectedText&lt;/code&gt; and
     * &lt;code&gt;drawSelectedText&lt;/code&gt; so that the way selected and
     * unselected text are rendered can be customized.
     *
     * @param lineIndex the line to draw &amp;gt;= 0
     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context
     * @param x the starting X position &amp;gt;= 0
     * @param y the starting Y position &amp;gt;= 0
     * @see #drawUnselectedText
     * @see #drawSelectedText
     */
    protected void drawLine(int lineIndex, Graphics g, int x, int y) {
<span class="nc" id="L77">        Element line = getElement().getElement(lineIndex);</span>
        Element elem;

        try {
<span class="nc bnc" id="L81" title="All 2 branches missed.">            if (line.isLeaf()) {</span>
<span class="nc" id="L82">                drawElement(lineIndex, line, g, x, y);</span>
            } else {
                // this line contains the composed text.
<span class="nc" id="L85">                int count = line.getElementCount();</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">                for(int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L87">                    elem = line.getElement(i);</span>
<span class="nc" id="L88">                    x = drawElement(lineIndex, elem, g, x, y);</span>
                }
            }
<span class="nc" id="L91">        } catch (BadLocationException e) {</span>
<span class="nc" id="L92">            throw new StateInvariantError(&quot;Can't render line: &quot; + lineIndex);</span>
<span class="nc" id="L93">        }</span>
<span class="nc" id="L94">    }</span>

    private int drawElement(int lineIndex, Element elem, Graphics g, int x, int y) throws BadLocationException {
<span class="nc" id="L97">        int p0 = elem.getStartOffset();</span>
<span class="nc" id="L98">        int p1 = elem.getEndOffset();</span>
<span class="nc" id="L99">        p1 = Math.min(getDocument().getLength(), p1);</span>

<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (lineIndex == 0) {</span>
<span class="nc" id="L102">            x += firstLineOffset;</span>
        }
<span class="nc" id="L104">        AttributeSet attr = elem.getAttributes();</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (Utilities.isComposedTextAttributeDefined(attr)) {</span>
<span class="nc" id="L106">            g.setColor(unselected);</span>
<span class="nc" id="L107">            x = Utilities.drawComposedText(this, attr, g, x, y,</span>
<span class="nc" id="L108">                                        p0-elem.getStartOffset(),</span>
<span class="nc" id="L109">                                        p1-elem.getStartOffset());</span>
        } else {
<span class="nc bnc" id="L111" title="All 4 branches missed.">            if (sel0 == sel1 || selected == unselected) {</span>
                // no selection, or it is invisible
<span class="nc" id="L113">                x = drawUnselectedText(g, x, y, p0, p1);</span>
<span class="nc bnc" id="L114" title="All 8 branches missed.">            } else if ((p0 &gt;= sel0 &amp;&amp; p0 &lt;= sel1) &amp;&amp; (p1 &gt;= sel0 &amp;&amp; p1 &lt;= sel1)) {</span>
<span class="nc" id="L115">                x = drawSelectedText(g, x, y, p0, p1);</span>
<span class="nc bnc" id="L116" title="All 4 branches missed.">            } else if (sel0 &gt;= p0 &amp;&amp; sel0 &lt;= p1) {</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">                if (sel1 &gt;= p0 &amp;&amp; sel1 &lt;= p1) {</span>
<span class="nc" id="L118">                    x = drawUnselectedText(g, x, y, p0, sel0);</span>
<span class="nc" id="L119">                    x = drawSelectedText(g, x, y, sel0, sel1);</span>
<span class="nc" id="L120">                    x = drawUnselectedText(g, x, y, sel1, p1);</span>
                } else {
<span class="nc" id="L122">                    x = drawUnselectedText(g, x, y, p0, sel0);</span>
<span class="nc" id="L123">                    x = drawSelectedText(g, x, y, sel0, p1);</span>
                }
<span class="nc bnc" id="L125" title="All 4 branches missed.">            } else if (sel1 &gt;= p0 &amp;&amp; sel1 &lt;= p1) {</span>
<span class="nc" id="L126">                x = drawSelectedText(g, x, y, p0, sel1);</span>
<span class="nc" id="L127">                x = drawUnselectedText(g, x, y, sel1, p1);</span>
            } else {
<span class="nc" id="L129">                x = drawUnselectedText(g, x, y, p0, p1);</span>
            }
        }

<span class="nc" id="L133">        return x;</span>
    }

    /**
     * Renders the given range in the model as normal unselected
     * text.  Uses the foreground or disabled color to render the text.
     *
     * @param g the graphics context
     * @param x the starting X coordinate &amp;gt;= 0
     * @param y the starting Y coordinate &amp;gt;= 0
     * @param p0 the beginning position in the model &amp;gt;= 0
     * @param p1 the ending position in the model &amp;gt;= 0
     * @return the X location of the end of the range &amp;gt;= 0
     * @exception BadLocationException if the range is invalid
     */
    protected int drawUnselectedText(Graphics g, int x, int y,
                                     int p0, int p1) throws BadLocationException {
<span class="nc" id="L150">        g.setColor(unselected);</span>
<span class="nc" id="L151">        Document doc = getDocument();</span>
<span class="nc" id="L152">        Segment s = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L153">        doc.getText(p0, p1 - p0, s);</span>
<span class="nc" id="L154">        int ret = Utilities.drawTabbedText(this, s, x, y, g, this, p0);</span>
<span class="nc" id="L155">        SegmentCache.releaseSharedSegment(s);</span>
<span class="nc" id="L156">        return ret;</span>
    }

    /**
     * Renders the given range in the model as selected text.  This
     * is implemented to render the text in the color specified in
     * the hosting component.  It assumes the highlighter will render
     * the selected background.
     *
     * @param g the graphics context
     * @param x the starting X coordinate &amp;gt;= 0
     * @param y the starting Y coordinate &amp;gt;= 0
     * @param p0 the beginning position in the model &amp;gt;= 0
     * @param p1 the ending position in the model &amp;gt;= 0
     * @return the location of the end of the range
     * @exception BadLocationException if the range is invalid
     */
    protected int drawSelectedText(Graphics g, int x,
                                   int y, int p0, int p1) throws BadLocationException {
<span class="nc" id="L175">        g.setColor(selected);</span>
<span class="nc" id="L176">        Document doc = getDocument();</span>
<span class="nc" id="L177">        Segment s = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L178">        doc.getText(p0, p1 - p0, s);</span>
<span class="nc" id="L179">        int ret = Utilities.drawTabbedText(this, s, x, y, g, this, p0);</span>
<span class="nc" id="L180">        SegmentCache.releaseSharedSegment(s);</span>
<span class="nc" id="L181">        return ret;</span>
    }

    /**
     * Gives access to a buffer that can be used to fetch
     * text from the associated document.
     *
     * @return the buffer
     */
    protected final Segment getLineBuffer() {
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (lineBuffer == null) {</span>
<span class="nc" id="L192">            lineBuffer = new Segment();</span>
        }
<span class="nc" id="L194">        return lineBuffer;</span>
    }

    /**
     * Checks to see if the font metrics and longest line
     * are up-to-date.
     *
     * @since 1.4
     */
    protected void updateMetrics() {
<span class="nc" id="L204">        Component host = getContainer();</span>
<span class="nc" id="L205">        Font f = host.getFont();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (font != f) {</span>
            // The font changed, we need to recalculate the
            // longest line.
<span class="nc" id="L209">            calculateLongestLine();</span>
<span class="nc" id="L210">            tabSize = getTabSize() * metrics.charWidth('m');</span>
        }
<span class="nc" id="L212">    }</span>

    // ---- View methods ----------------------------------------------------

    /**
     * Determines the preferred span for this view along an
     * axis.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return   the span the view would like to be rendered into &amp;gt;= 0.
     *           Typically the view is told to render into the span
     *           that is returned, although there is no guarantee.
     *           The parent may choose to resize or break the view.
     * @exception IllegalArgumentException for an invalid axis
     */
    public float getPreferredSpan(int axis) {
<span class="nc" id="L228">        updateMetrics();</span>
<span class="nc bnc" id="L229" title="All 3 branches missed.">        switch (axis) {</span>
        case View.X_AXIS:
<span class="nc" id="L231">            return getLineWidth(longLine);</span>
        case View.Y_AXIS:
<span class="nc" id="L233">            return getElement().getElementCount() * metrics.getHeight();</span>
        default:
<span class="nc" id="L235">            throw new IllegalArgumentException(&quot;Invalid axis: &quot; + axis);</span>
        }
    }

    /**
     * Renders using the given rendering surface and area on that surface.
     * The view may need to do layout and create child views to enable
     * itself to render into the given allocation.
     *
     * @param g the rendering surface to use
     * @param a the allocated region to render into
     *
     * @see View#paint
     */
    public void paint(Graphics g, Shape a) {
<span class="nc" id="L250">        Shape originalA = a;</span>
<span class="nc" id="L251">        a = adjustPaintRegion(a);</span>
<span class="nc" id="L252">        Rectangle alloc = (Rectangle) a;</span>
<span class="nc" id="L253">        tabBase = alloc.x;</span>
<span class="nc" id="L254">        JTextComponent host = (JTextComponent) getContainer();</span>
<span class="nc" id="L255">        Highlighter h = host.getHighlighter();</span>
<span class="nc" id="L256">        g.setFont(host.getFont());</span>
<span class="nc" id="L257">        sel0 = host.getSelectionStart();</span>
<span class="nc" id="L258">        sel1 = host.getSelectionEnd();</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">        unselected = (host.isEnabled()) ?</span>
<span class="nc" id="L260">            host.getForeground() : host.getDisabledTextColor();</span>
<span class="nc" id="L261">        Caret c = host.getCaret();</span>
<span class="nc bnc" id="L262" title="All 4 branches missed.">        selected = c.isSelectionVisible() &amp;&amp; h != null ?</span>
<span class="nc" id="L263">                       host.getSelectedTextColor() : unselected;</span>
<span class="nc" id="L264">        updateMetrics();</span>

        // If the lines are clipped then we don't expend the effort to
        // try and paint them.  Since all of the lines are the same height
        // with this object, determination of what lines need to be repainted
        // is quick.
<span class="nc" id="L270">        Rectangle clip = g.getClipBounds();</span>
<span class="nc" id="L271">        int fontHeight = metrics.getHeight();</span>
<span class="nc" id="L272">        int heightBelow = (alloc.y + alloc.height) - (clip.y + clip.height);</span>
<span class="nc" id="L273">        int heightAbove = clip.y - alloc.y;</span>
        int linesBelow, linesAbove, linesTotal;

<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (fontHeight &gt; 0) {</span>
<span class="nc" id="L277">            linesBelow = Math.max(0, heightBelow / fontHeight);</span>
<span class="nc" id="L278">            linesAbove = Math.max(0, heightAbove / fontHeight);</span>
<span class="nc" id="L279">            linesTotal = alloc.height / fontHeight;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            if (alloc.height % fontHeight != 0) {</span>
<span class="nc" id="L281">                linesTotal++;</span>
            }
        } else {
<span class="nc" id="L284">            linesBelow = linesAbove = linesTotal = 0;</span>
        }

        // update the visible lines
<span class="nc" id="L288">        Rectangle lineArea = lineToRect(a, linesAbove);</span>
<span class="nc" id="L289">        int y = lineArea.y + metrics.getAscent();</span>
<span class="nc" id="L290">        int x = lineArea.x;</span>
<span class="nc" id="L291">        Element map = getElement();</span>
<span class="nc" id="L292">        int lineCount = map.getElementCount();</span>
<span class="nc" id="L293">        int endLine = Math.min(lineCount, linesTotal - linesBelow);</span>
<span class="nc" id="L294">        lineCount--;</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        LayeredHighlighter dh = (h instanceof LayeredHighlighter) ?</span>
                           (LayeredHighlighter)h : null;
<span class="nc bnc" id="L297" title="All 2 branches missed.">        for (int line = linesAbove; line &lt; endLine; line++) {</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (dh != null) {</span>
<span class="nc" id="L299">                Element lineElement = map.getElement(line);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">                if (line == lineCount) {</span>
<span class="nc" id="L301">                    dh.paintLayeredHighlights(g, lineElement.getStartOffset(),</span>
<span class="nc" id="L302">                                              lineElement.getEndOffset(),</span>
                                              originalA, host, this);
                }
                else {
<span class="nc" id="L306">                    dh.paintLayeredHighlights(g, lineElement.getStartOffset(),</span>
<span class="nc" id="L307">                                              lineElement.getEndOffset() - 1,</span>
                                              originalA, host, this);
                }
            }
<span class="nc" id="L311">            drawLine(line, g, x, y);</span>
<span class="nc" id="L312">            y += fontHeight;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">            if (line == 0) {</span>
                // This should never really happen, in so far as if
                // firstLineOffset is non 0, there should only be one
                // line of text.
<span class="nc" id="L317">                x -= firstLineOffset;</span>
            }
        }
<span class="nc" id="L320">    }</span>

    /**
     * Should return a shape ideal for painting based on the passed in
     * Shape &lt;code&gt;a&lt;/code&gt;. This is useful if painting in a different
     * region. The default implementation returns &lt;code&gt;a&lt;/code&gt;.
     */
    Shape adjustPaintRegion(Shape a) {
<span class="nc" id="L328">        return a;</span>
    }

    /**
     * Provides a mapping from the document model coordinate space
     * to the coordinate space of the view mapped to it.
     *
     * @param pos the position to convert &amp;gt;= 0
     * @param a the allocated region to render into
     * @return the bounding box of the given position
     * @exception BadLocationException  if the given position does not
     *   represent a valid location in the associated document
     * @see View#modelToView
     */
    public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
        // line coordinates
<span class="nc" id="L344">        Document doc = getDocument();</span>
<span class="nc" id="L345">        Element map = getElement();</span>
<span class="nc" id="L346">        int lineIndex = map.getElementIndex(pos);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (lineIndex &lt; 0) {</span>
<span class="nc" id="L348">            return lineToRect(a, 0);</span>
        }
<span class="nc" id="L350">        Rectangle lineArea = lineToRect(a, lineIndex);</span>

        // determine span from the start of the line
<span class="nc" id="L353">        tabBase = lineArea.x;</span>
<span class="nc" id="L354">        Element line = map.getElement(lineIndex);</span>
<span class="nc" id="L355">        int p0 = line.getStartOffset();</span>
<span class="nc" id="L356">        Segment s = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L357">        doc.getText(p0, pos - p0, s);</span>
<span class="nc" id="L358">        int xOffs = Utilities.getTabbedTextWidth(s, metrics, tabBase, this,p0);</span>
<span class="nc" id="L359">        SegmentCache.releaseSharedSegment(s);</span>

        // fill in the results and return
<span class="nc" id="L362">        lineArea.x += xOffs;</span>
<span class="nc" id="L363">        lineArea.width = 1;</span>
<span class="nc" id="L364">        lineArea.height = metrics.getHeight();</span>
<span class="nc" id="L365">        return lineArea;</span>
    }

    /**
     * Provides a mapping from the view coordinate space to the logical
     * coordinate space of the model.
     *
     * @param fx the X coordinate &amp;gt;= 0
     * @param fy the Y coordinate &amp;gt;= 0
     * @param a the allocated region to render into
     * @return the location within the model that best represents the
     *  given point in the view &amp;gt;= 0
     * @see View#viewToModel
     */
    public int viewToModel(float fx, float fy, Shape a, Position.Bias[] bias) {
        // PENDING(prinz) properly calculate bias
<span class="nc" id="L381">        bias[0] = Position.Bias.Forward;</span>

<span class="nc" id="L383">        Rectangle alloc = a.getBounds();</span>
<span class="nc" id="L384">        Document doc = getDocument();</span>
<span class="nc" id="L385">        int x = (int) fx;</span>
<span class="nc" id="L386">        int y = (int) fy;</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (y &lt; alloc.y) {</span>
            // above the area covered by this icon, so the the position
            // is assumed to be the start of the coverage for this view.
<span class="nc" id="L390">            return getStartOffset();</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        } else if (y &gt; alloc.y + alloc.height) {</span>
            // below the area covered by this icon, so the the position
            // is assumed to be the end of the coverage for this view.
<span class="nc" id="L394">            return getEndOffset() - 1;</span>
        } else {
            // positioned within the coverage of this view vertically,
            // so we figure out which line the point corresponds to.
            // if the line is greater than the number of lines contained, then
            // simply use the last line as it represents the last possible place
            // we can position to.
<span class="nc" id="L401">            Element map = doc.getDefaultRootElement();</span>
<span class="nc" id="L402">            int fontHeight = metrics.getHeight();</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            int lineIndex = (fontHeight &gt; 0 ?</span>
<span class="nc" id="L404">                                Math.abs((y - alloc.y) / fontHeight) :</span>
<span class="nc" id="L405">                                map.getElementCount() - 1);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            if (lineIndex &gt;= map.getElementCount()) {</span>
<span class="nc" id="L407">                return getEndOffset() - 1;</span>
            }
<span class="nc" id="L409">            Element line = map.getElement(lineIndex);</span>
<span class="nc" id="L410">            int dx = 0;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (lineIndex == 0) {</span>
<span class="nc" id="L412">                alloc.x += firstLineOffset;</span>
<span class="nc" id="L413">                alloc.width -= firstLineOffset;</span>
            }
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (x &lt; alloc.x) {</span>
                // point is to the left of the line
<span class="nc" id="L417">                return line.getStartOffset();</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">            } else if (x &gt; alloc.x + alloc.width) {</span>
                // point is to the right of the line
<span class="nc" id="L420">                return line.getEndOffset() - 1;</span>
            } else {
                // Determine the offset into the text
                try {
<span class="nc" id="L424">                    int p0 = line.getStartOffset();</span>
<span class="nc" id="L425">                    int p1 = line.getEndOffset() - 1;</span>
<span class="nc" id="L426">                    Segment s = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L427">                    doc.getText(p0, p1 - p0, s);</span>
<span class="nc" id="L428">                    tabBase = alloc.x;</span>
<span class="nc" id="L429">                    int offs = p0 + Utilities.getTabbedTextOffset(s, metrics,</span>
                                                                  tabBase, x, this, p0);
<span class="nc" id="L431">                    SegmentCache.releaseSharedSegment(s);</span>
<span class="nc" id="L432">                    return offs;</span>
<span class="nc" id="L433">                } catch (BadLocationException e) {</span>
                    // should not happen
<span class="nc" id="L435">                    return -1;</span>
                }
            }
        }
    }

    /**
     * Gives notification that something was inserted into the document
     * in a location that this view is responsible for.
     *
     * @param changes the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#insertUpdate
     */
    public void insertUpdate(DocumentEvent changes, Shape a, ViewFactory f) {
<span class="nc" id="L451">        updateDamage(changes, a, f);</span>
<span class="nc" id="L452">    }</span>

    /**
     * Gives notification that something was removed from the document
     * in a location that this view is responsible for.
     *
     * @param changes the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#removeUpdate
     */
    public void removeUpdate(DocumentEvent changes, Shape a, ViewFactory f) {
<span class="nc" id="L464">        updateDamage(changes, a, f);</span>
<span class="nc" id="L465">    }</span>

    /**
     * Gives notification from the document that attributes were changed
     * in a location that this view is responsible for.
     *
     * @param changes the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#changedUpdate
     */
    public void changedUpdate(DocumentEvent changes, Shape a, ViewFactory f) {
<span class="nc" id="L477">        updateDamage(changes, a, f);</span>
<span class="nc" id="L478">    }</span>

    /**
     * Sets the size of the view.  This should cause
     * layout of the view along the given axis, if it
     * has any layout duties.
     *
     * @param width the width &amp;gt;= 0
     * @param height the height &amp;gt;= 0
     */
    public void setSize(float width, float height) {
<span class="nc" id="L489">        super.setSize(width, height);</span>
<span class="nc" id="L490">        updateMetrics();</span>
<span class="nc" id="L491">    }</span>

    // --- TabExpander methods ------------------------------------------

    /**
     * Returns the next tab stop position after a given reference position.
     * This implementation does not support things like centering so it
     * ignores the tabOffset argument.
     *
     * @param x the current position &amp;gt;= 0
     * @param tabOffset the position within the text stream
     *   that the tab occurred at &amp;gt;= 0.
     * @return the tab stop, measured in points &amp;gt;= 0
     */
    public float nextTabStop(float x, int tabOffset) {
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (tabSize == 0) {</span>
<span class="nc" id="L507">            return x;</span>
        }
<span class="nc" id="L509">        int ntabs = (((int) x) - tabBase) / tabSize;</span>
<span class="nc" id="L510">        return tabBase + ((ntabs + 1) * tabSize);</span>
    }

    // --- local methods ------------------------------------------------

    /**
     * Repaint the region of change covered by the given document
     * event.  Damages the line that begins the range to cover
     * the case when the insert/remove is only on one line.
     * If lines are added or removed, damages the whole
     * view.  The longest line is checked to see if it has
     * changed.
     *
     * @since 1.4
     */
    protected void updateDamage(DocumentEvent changes, Shape a, ViewFactory f) {
<span class="nc" id="L526">        Component host = getContainer();</span>
<span class="nc" id="L527">        updateMetrics();</span>
<span class="nc" id="L528">        Element elem = getElement();</span>
<span class="nc" id="L529">        DocumentEvent.ElementChange ec = changes.getChange(elem);</span>

<span class="nc bnc" id="L531" title="All 2 branches missed.">        Element[] added = (ec != null) ? ec.getChildrenAdded() : null;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">        Element[] removed = (ec != null) ? ec.getChildrenRemoved() : null;</span>
<span class="nc bnc" id="L533" title="All 8 branches missed.">        if (((added != null) &amp;&amp; (added.length &gt; 0)) ||</span>
            ((removed != null) &amp;&amp; (removed.length &gt; 0))) {
            // lines were added or removed...
<span class="nc bnc" id="L536" title="All 2 branches missed.">            if (added != null) {</span>
<span class="nc" id="L537">                int currWide = getLineWidth(longLine);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">                for (int i = 0; i &lt; added.length; i++) {</span>
<span class="nc" id="L539">                    int w = getLineWidth(added[i]);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">                    if (w &gt; currWide) {</span>
<span class="nc" id="L541">                        currWide = w;</span>
<span class="nc" id="L542">                        longLine = added[i];</span>
                    }
                }
            }
<span class="nc bnc" id="L546" title="All 2 branches missed.">            if (removed != null) {</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">                for (int i = 0; i &lt; removed.length; i++) {</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                    if (removed[i] == longLine) {</span>
<span class="nc" id="L549">                        calculateLongestLine();</span>
<span class="nc" id="L550">                        break;</span>
                    }
                }
            }
<span class="nc" id="L554">            preferenceChanged(null, true, true);</span>
<span class="nc" id="L555">            host.repaint();</span>
        } else {
<span class="nc" id="L557">            Element map = getElement();</span>
<span class="nc" id="L558">            int line = map.getElementIndex(changes.getOffset());</span>
<span class="nc" id="L559">            damageLineRange(line, line, a, host);</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">            if (changes.getType() == DocumentEvent.EventType.INSERT) {</span>
                // check to see if the line is longer than current
                // longest line.
<span class="nc" id="L563">                int w = getLineWidth(longLine);</span>
<span class="nc" id="L564">                Element e = map.getElement(line);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">                if (e == longLine) {</span>
<span class="nc" id="L566">                    preferenceChanged(null, true, false);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                } else if (getLineWidth(e) &gt; w) {</span>
<span class="nc" id="L568">                    longLine = e;</span>
<span class="nc" id="L569">                    preferenceChanged(null, true, false);</span>
                }
<span class="nc bnc" id="L571" title="All 2 branches missed.">            } else if (changes.getType() == DocumentEvent.EventType.REMOVE) {</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">                if (map.getElement(line) == longLine) {</span>
                    // removed from longest line... recalc
<span class="nc" id="L574">                    calculateLongestLine();</span>
<span class="nc" id="L575">                    preferenceChanged(null, true, false);</span>
                }
            }
        }
<span class="nc" id="L579">    }</span>

    /**
     * Repaint the given line range.
     *
     * @param host the component hosting the view (used to call repaint)
     * @param a  the region allocated for the view to render into
     * @param line0 the starting line number to repaint.  This must
     *   be a valid line number in the model.
     * @param line1 the ending line number to repaint.  This must
     *   be a valid line number in the model.
     * @since 1.4
     */
    protected void damageLineRange(int line0, int line1, Shape a, Component host) {
<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (a != null) {</span>
<span class="nc" id="L594">            Rectangle area0 = lineToRect(a, line0);</span>
<span class="nc" id="L595">            Rectangle area1 = lineToRect(a, line1);</span>
<span class="nc bnc" id="L596" title="All 4 branches missed.">            if ((area0 != null) &amp;&amp; (area1 != null)) {</span>
<span class="nc" id="L597">                Rectangle damage = area0.union(area1);</span>
<span class="nc" id="L598">                host.repaint(damage.x, damage.y, damage.width, damage.height);</span>
<span class="nc" id="L599">            } else {</span>
<span class="nc" id="L600">                host.repaint();</span>
            }
        }
<span class="nc" id="L603">    }</span>

    /**
     * Determine the rectangle that represents the given line.
     *
     * @param a  the region allocated for the view to render into
     * @param line the line number to find the region of.  This must
     *   be a valid line number in the model.
     * @since 1.4
     */
    protected Rectangle lineToRect(Shape a, int line) {
<span class="nc" id="L614">        Rectangle r = null;</span>
<span class="nc" id="L615">        updateMetrics();</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (metrics != null) {</span>
<span class="nc" id="L617">            Rectangle alloc = a.getBounds();</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if (line == 0) {</span>
<span class="nc" id="L619">                alloc.x += firstLineOffset;</span>
<span class="nc" id="L620">                alloc.width -= firstLineOffset;</span>
            }
<span class="nc" id="L622">            r = new Rectangle(alloc.x, alloc.y + (line * metrics.getHeight()),</span>
<span class="nc" id="L623">                              alloc.width, metrics.getHeight());</span>
        }
<span class="nc" id="L625">        return r;</span>
    }

    /**
     * Iterate over the lines represented by the child elements
     * of the element this view represents, looking for the line
     * that is the longest.  The &lt;em&gt;longLine&lt;/em&gt; variable is updated to
     * represent the longest line contained.  The &lt;em&gt;font&lt;/em&gt; variable
     * is updated to indicate the font used to calculate the
     * longest line.
     */
    private void calculateLongestLine() {
<span class="nc" id="L637">        Component c = getContainer();</span>
<span class="nc" id="L638">        font = c.getFont();</span>
<span class="nc" id="L639">        metrics = c.getFontMetrics(font);</span>
<span class="nc" id="L640">        Document doc = getDocument();</span>
<span class="nc" id="L641">        Element lines = getElement();</span>
<span class="nc" id="L642">        int n = lines.getElementCount();</span>
<span class="nc" id="L643">        int maxWidth = -1;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L645">            Element line = lines.getElement(i);</span>
<span class="nc" id="L646">            int w = getLineWidth(line);</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">            if (w &gt; maxWidth) {</span>
<span class="nc" id="L648">                maxWidth = w;</span>
<span class="nc" id="L649">                longLine = line;</span>
            }
        }
<span class="nc" id="L652">    }</span>

    /**
     * Calculate the width of the line represented by
     * the given element.  It is assumed that the font
     * and font metrics are up-to-date.
     */
    private int getLineWidth(Element line) {
<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (line == null) {</span>
<span class="nc" id="L661">            return 0;</span>
        }
<span class="nc" id="L663">        int p0 = line.getStartOffset();</span>
<span class="nc" id="L664">        int p1 = line.getEndOffset();</span>
        int w;
<span class="nc" id="L666">        Segment s = SegmentCache.getSharedSegment();</span>
        try {
<span class="nc" id="L668">            line.getDocument().getText(p0, p1 - p0, s);</span>
<span class="nc" id="L669">            w = Utilities.getTabbedTextWidth(s, metrics, tabBase, this, p0);</span>
<span class="nc" id="L670">        } catch (BadLocationException ble) {</span>
<span class="nc" id="L671">            w = 0;</span>
<span class="nc" id="L672">        }</span>
<span class="nc" id="L673">        SegmentCache.releaseSharedSegment(s);</span>
<span class="nc" id="L674">        return w;</span>
    }

    // --- member variables -----------------------------------------------

    /**
     * Font metrics for the current font.
     */
    protected FontMetrics metrics;

    /**
     * The current longest line.  This is used to calculate
     * the preferred width of the view.  Since the calculation
     * is potentially expensive we try to avoid it by stashing
     * which line is currently the longest.
     */
    Element longLine;

    /**
     * Font used to calculate the longest line... if this
     * changes we need to recalculate the longest line
     */
    Font font;

    Segment lineBuffer;
    int tabSize;
    int tabBase;

    int sel0;
    int sel1;
    Color unselected;
    Color selected;

    /**
     * Offset of where to draw the first character on the first line.
     * This is a hack and temporary until we can better address the problem
     * of text measuring. This field is actually never set directly in
     * PlainView, but by FieldView.
     */
    int firstLineOffset;

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>