<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ZoneView.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">ZoneView.java</span></div><h1>ZoneView.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.util.Vector;
import java.awt.*;
import javax.swing.event.*;

/**
 * ZoneView is a View implementation that creates zones for which
 * the child views are not created or stored until they are needed
 * for display or model/view translations.  This enables a substantial
 * reduction in memory consumption for situations where the model
 * being represented is very large, by building view objects only for
 * the region being actively viewed/edited.  The size of the children
 * can be estimated in some way, or calculated asynchronously with
 * only the result being saved.
 * &lt;p&gt;
 * ZoneView extends BoxView to provide a box that implements
 * zones for its children.  The zones are special View implementations
 * (the children of an instance of this class) that represent only a
 * portion of the model that an instance of ZoneView is responsible
 * for.  The zones don't create child views until an attempt is made
 * to display them. A box shaped view is well suited to this because:
 *   &lt;ul&gt;
 *   &lt;li&gt;
 *   Boxes are a heavily used view, and having a box that
 *   provides this behavior gives substantial opportunity
 *   to plug the behavior into a view hierarchy from the
 *   view factory.
 *   &lt;li&gt;
 *   Boxes are tiled in one direction, so it is easy to
 *   divide them into zones in a reliable way.
 *   &lt;li&gt;
 *   Boxes typically have a simple relationship to the model (i.e. they
 *   create child views that directly represent the child elements).
 *   &lt;li&gt;
 *   Boxes are easier to estimate the size of than some other shapes.
 *   &lt;/ul&gt;
 * &lt;p&gt;
 * The default behavior is controlled by two properties, maxZoneSize
 * and maxZonesLoaded.  Setting maxZoneSize to Integer.MAX_VALUE would
 * have the effect of causing only one zone to be created.  This would
 * effectively turn the view into an implementation of the decorator
 * pattern.  Setting maxZonesLoaded to a value of Integer.MAX_VALUE would
 * cause zones to never be unloaded.  For simplicity, zones are created on
 * boundaries represented by the child elements of the element the view is
 * responsible for.  The zones can be any View implementation, but the
 * default implementation is based upon AsyncBoxView which supports fairly
 * large zones efficiently.
 *
 * @author  Timothy Prinzing
 * @see     View
 * @since   1.3
 */
public class ZoneView extends BoxView {

<span class="nc" id="L80">    int maxZoneSize = 8 * 1024;</span>
<span class="nc" id="L81">    int maxZonesLoaded = 3;</span>
    Vector&lt;View&gt; loadedZones;

    /**
     * Constructs a ZoneView.
     *
     * @param elem the element this view is responsible for
     * @param axis either View.X_AXIS or View.Y_AXIS
     */
    public ZoneView(Element elem, int axis) {
<span class="nc" id="L91">        super(elem, axis);</span>
<span class="nc" id="L92">        loadedZones = new Vector&lt;View&gt;();</span>
<span class="nc" id="L93">    }</span>

    /**
     * Get the current maximum zone size.
     */
    public int getMaximumZoneSize() {
<span class="nc" id="L99">        return maxZoneSize;</span>
    }

    /**
     * Set the desired maximum zone size.  A
     * zone may get larger than this size if
     * a single child view is larger than this
     * size since zones are formed on child view
     * boundaries.
     *
     * @param size the number of characters the zone
     * may represent before attempting to break
     * the zone into a smaller size.
     */
    public void setMaximumZoneSize(int size) {
<span class="nc" id="L114">        maxZoneSize = size;</span>
<span class="nc" id="L115">    }</span>

    /**
     * Get the current setting of the number of zones
     * allowed to be loaded at the same time.
     */
    public int getMaxZonesLoaded() {
<span class="nc" id="L122">        return maxZonesLoaded;</span>
    }

    /**
     * Sets the current setting of the number of zones
     * allowed to be loaded at the same time. This will throw an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; if &lt;code&gt;mzl&lt;/code&gt; is less
     * than 1.
     *
     * @param mzl the desired maximum number of zones
     *  to be actively loaded, must be greater than 0
     * @exception IllegalArgumentException if &lt;code&gt;mzl&lt;/code&gt; is &amp;lt; 1
     */
    public void setMaxZonesLoaded(int mzl) {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (mzl &lt; 1) {</span>
<span class="nc" id="L137">            throw new IllegalArgumentException(&quot;ZoneView.setMaxZonesLoaded must be greater than 0.&quot;);</span>
        }
<span class="nc" id="L139">        maxZonesLoaded = mzl;</span>
<span class="nc" id="L140">        unloadOldZones();</span>
<span class="nc" id="L141">    }</span>

    /**
     * Called by a zone when it gets loaded.  This happens when
     * an attempt is made to display or perform a model/view
     * translation on a zone that was in an unloaded state.
     * This is implemented to check if the maximum number of
     * zones was reached and to unload the oldest zone if so.
     *
     * @param zone the child view that was just loaded.
     */
    protected void zoneWasLoaded(View zone) {
        //System.out.println(&quot;loading: &quot; + zone.getStartOffset() + &quot;,&quot; + zone.getEndOffset());
<span class="nc" id="L154">        loadedZones.addElement(zone);</span>
<span class="nc" id="L155">        unloadOldZones();</span>
<span class="nc" id="L156">    }</span>

    void unloadOldZones() {
<span class="nc bnc" id="L159" title="All 2 branches missed.">        while (loadedZones.size() &gt; getMaxZonesLoaded()) {</span>
<span class="nc" id="L160">            View zone = loadedZones.elementAt(0);</span>
<span class="nc" id="L161">            loadedZones.removeElementAt(0);</span>
<span class="nc" id="L162">            unloadZone(zone);</span>
<span class="nc" id="L163">        }</span>
<span class="nc" id="L164">    }</span>

    /**
     * Unload a zone (Convert the zone to its memory saving state).
     * The zones are expected to represent a subset of the
     * child elements of the element this view is responsible for.
     * Therefore, the default implementation is to simple remove
     * all the children.
     *
     * @param zone the child view desired to be set to an
     *  unloaded state.
     */
    protected void unloadZone(View zone) {
        //System.out.println(&quot;unloading: &quot; + zone.getStartOffset() + &quot;,&quot; + zone.getEndOffset());
<span class="nc" id="L178">        zone.removeAll();</span>
<span class="nc" id="L179">    }</span>

    /**
     * Determine if a zone is in the loaded state.
     * The zones are expected to represent a subset of the
     * child elements of the element this view is responsible for.
     * Therefore, the default implementation is to return
     * true if the view has children.
     */
    protected boolean isZoneLoaded(View zone) {
<span class="nc bnc" id="L189" title="All 2 branches missed.">        return (zone.getViewCount() &gt; 0);</span>
    }

    /**
     * Create a view to represent a zone for the given
     * range within the model (which should be within
     * the range of this objects responsibility).  This
     * is called by the zone management logic to create
     * new zones.  Subclasses can provide a different
     * implementation for a zone by changing this method.
     *
     * @param p0 the start of the desired zone.  This should
     *  be &amp;gt;= getStartOffset() and &amp;lt; getEndOffset().  This
     *  value should also be &amp;lt; p1.
     * @param p1 the end of the desired zone.  This should
     *  be &amp;gt; getStartOffset() and &amp;lt;= getEndOffset().  This
     *  value should also be &amp;gt; p0.
     */
    protected View createZone(int p0, int p1) {
<span class="nc" id="L208">        Document doc = getDocument();</span>
        View zone;
        try {
<span class="nc" id="L211">            zone = new Zone(getElement(),</span>
<span class="nc" id="L212">                            doc.createPosition(p0),</span>
<span class="nc" id="L213">                            doc.createPosition(p1));</span>
<span class="nc" id="L214">        } catch (BadLocationException ble) {</span>
            // this should puke in some way.
<span class="nc" id="L216">            throw new StateInvariantError(ble.getMessage());</span>
<span class="nc" id="L217">        }</span>
<span class="nc" id="L218">        return zone;</span>
    }

    /**
     * Loads all of the children to initialize the view.
     * This is called by the &lt;code&gt;setParent&lt;/code&gt; method.
     * This is reimplemented to not load any children directly
     * (as they are created by the zones).  This method creates
     * the initial set of zones.  Zones don't actually get
     * populated however until an attempt is made to display
     * them or to do model/view coordinate translation.
     *
     * @param f the view factory
     */
    protected void loadChildren(ViewFactory f) {
        // build the first zone.
<span class="nc" id="L234">        Document doc = getDocument();</span>
<span class="nc" id="L235">        int offs0 = getStartOffset();</span>
<span class="nc" id="L236">        int offs1 = getEndOffset();</span>
<span class="nc" id="L237">        append(createZone(offs0, offs1));</span>
<span class="nc" id="L238">        handleInsert(offs0, offs1 - offs0);</span>
<span class="nc" id="L239">    }</span>

    /**
     * Returns the child view index representing the given position in
     * the model.
     *
     * @param pos the position &amp;gt;= 0
     * @return  index of the view representing the given position, or
     *   -1 if no view represents that position
     */
    protected int getViewIndexAtPosition(int pos) {
        // PENDING(prinz) this could be done as a binary
        // search, and probably should be.
<span class="nc" id="L252">        int n = getViewCount();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (pos == getEndOffset()) {</span>
<span class="nc" id="L254">            return n - 1;</span>
        }
<span class="nc bnc" id="L256" title="All 2 branches missed.">        for(int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L257">            View v = getView(i);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">            if(pos &gt;= v.getStartOffset() &amp;&amp;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">               pos &lt; v.getEndOffset()) {</span>
<span class="nc" id="L260">                return i;</span>
            }
        }
<span class="nc" id="L263">        return -1;</span>
    }

    void handleInsert(int pos, int length) {
<span class="nc" id="L267">        int index = getViewIndex(pos, Position.Bias.Forward);</span>
<span class="nc" id="L268">        View v = getView(index);</span>
<span class="nc" id="L269">        int offs0 = v.getStartOffset();</span>
<span class="nc" id="L270">        int offs1 = v.getEndOffset();</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if ((offs1 - offs0) &gt; maxZoneSize) {</span>
<span class="nc" id="L272">            splitZone(index, offs0, offs1);</span>
        }
<span class="nc" id="L274">    }</span>

    void handleRemove(int pos, int length) {
        // IMPLEMENT
<span class="nc" id="L278">    }</span>

    /**
     * Break up the zone at the given index into pieces
     * of an acceptable size.
     */
    void splitZone(int index, int offs0, int offs1) {
        // divide the old zone into a new set of bins
<span class="nc" id="L286">        Element elem = getElement();</span>
<span class="nc" id="L287">        Document doc = elem.getDocument();</span>
<span class="nc" id="L288">        Vector&lt;View&gt; zones = new Vector&lt;View&gt;();</span>
<span class="nc" id="L289">        int offs = offs0;</span>
        do {
<span class="nc" id="L291">            offs0 = offs;</span>
<span class="nc" id="L292">            offs = Math.min(getDesiredZoneEnd(offs0), offs1);</span>
<span class="nc" id="L293">            zones.addElement(createZone(offs0, offs));</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">        } while (offs &lt; offs1);</span>
<span class="nc" id="L295">        View oldZone = getView(index);</span>
<span class="nc" id="L296">        View[] newZones = new View[zones.size()];</span>
<span class="nc" id="L297">        zones.copyInto(newZones);</span>
<span class="nc" id="L298">        replace(index, 1, newZones);</span>
<span class="nc" id="L299">    }</span>

    /**
     * Returns the zone position to use for the
     * end of a zone that starts at the given
     * position.  By default this returns something
     * close to half the max zone size.
     */
    int getDesiredZoneEnd(int pos) {
<span class="nc" id="L308">        Element elem = getElement();</span>
<span class="nc" id="L309">        int index = elem.getElementIndex(pos + (maxZoneSize / 2));</span>
<span class="nc" id="L310">        Element child = elem.getElement(index);</span>
<span class="nc" id="L311">        int offs0 = child.getStartOffset();</span>
<span class="nc" id="L312">        int offs1 = child.getEndOffset();</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if ((offs1 - pos) &gt; maxZoneSize) {</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">            if (offs0 &gt; pos) {</span>
<span class="nc" id="L315">                return offs0;</span>
            }
        }
<span class="nc" id="L318">        return offs1;</span>
    }

    // ---- View methods ----------------------------------------------------

    /**
     * The superclass behavior will try to update the child views
     * which is not desired in this case, since the children are
     * zones and not directly effected by the changes to the
     * associated element.  This is reimplemented to do nothing
     * and return false.
     */
    protected boolean updateChildren(DocumentEvent.ElementChange ec,
                                     DocumentEvent e, ViewFactory f) {
<span class="nc" id="L332">        return false;</span>
    }

    /**
     * Gives notification that something was inserted into the document
     * in a location that this view is responsible for.  This is largely
     * delegated to the superclass, but is reimplemented to update the
     * relevant zone (i.e. determine if a zone needs to be split into a
     * set of 2 or more zones).
     *
     * @param changes the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#insertUpdate
     */
    public void insertUpdate(DocumentEvent changes, Shape a, ViewFactory f) {
<span class="nc" id="L348">        handleInsert(changes.getOffset(), changes.getLength());</span>
<span class="nc" id="L349">        super.insertUpdate(changes, a, f);</span>
<span class="nc" id="L350">    }</span>

    /**
     * Gives notification that something was removed from the document
     * in a location that this view is responsible for.  This is largely
     * delegated to the superclass, but is reimplemented to update the
     * relevant zones (i.e. determine if zones need to be removed or
     * joined with another zone).
     *
     * @param changes the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#removeUpdate
     */
    public void removeUpdate(DocumentEvent changes, Shape a, ViewFactory f) {
<span class="nc" id="L365">        handleRemove(changes.getOffset(), changes.getLength());</span>
<span class="nc" id="L366">        super.removeUpdate(changes, a, f);</span>
<span class="nc" id="L367">    }</span>

    /**
     * Internally created view that has the purpose of holding
     * the views that represent the children of the ZoneView
     * that have been arranged in a zone.
     */
    class Zone extends AsyncBoxView {

        private Position start;
        private Position end;

<span class="nc" id="L379">        public Zone(Element elem, Position start, Position end) {</span>
<span class="nc" id="L380">            super(elem, ZoneView.this.getAxis());</span>
<span class="nc" id="L381">            this.start = start;</span>
<span class="nc" id="L382">            this.end = end;</span>
<span class="nc" id="L383">        }</span>

        /**
         * Creates the child views and populates the
         * zone with them.  This is done by translating
         * the positions to child element index locations
         * and building views to those elements.  If the
         * zone is already loaded, this does nothing.
         */
        public void load() {
<span class="nc bnc" id="L393" title="All 2 branches missed.">            if (! isLoaded()) {</span>
<span class="nc" id="L394">                setEstimatedMajorSpan(true);</span>
<span class="nc" id="L395">                Element e = getElement();</span>
<span class="nc" id="L396">                ViewFactory f = getViewFactory();</span>
<span class="nc" id="L397">                int index0 = e.getElementIndex(getStartOffset());</span>
<span class="nc" id="L398">                int index1 = e.getElementIndex(getEndOffset());</span>
<span class="nc" id="L399">                View[] added = new View[index1 - index0 + 1];</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">                for (int i = index0; i &lt;= index1; i++) {</span>
<span class="nc" id="L401">                    added[i - index0] = f.create(e.getElement(i));</span>
                }
<span class="nc" id="L403">                replace(0, 0, added);</span>

<span class="nc" id="L405">                zoneWasLoaded(this);</span>
            }
<span class="nc" id="L407">        }</span>

        /**
         * Removes the child views and returns to a
         * state of unloaded.
         */
        public void unload() {
<span class="nc" id="L414">            setEstimatedMajorSpan(true);</span>
<span class="nc" id="L415">            removeAll();</span>
<span class="nc" id="L416">        }</span>

        /**
         * Determines if the zone is in the loaded state
         * or not.
         */
        public boolean isLoaded() {
<span class="nc bnc" id="L423" title="All 2 branches missed.">            return (getViewCount() != 0);</span>
        }

        /**
         * This method is reimplemented to not build the children
         * since the children are created when the zone is loaded
         * rather then when it is placed in the view hierarchy.
         * The major span is estimated at this point by building
         * the first child (but not storing it), and calling
         * setEstimatedMajorSpan(true) followed by setSpan for
         * the major axis with the estimated span.
         */
        protected void loadChildren(ViewFactory f) {
            // mark the major span as estimated
<span class="nc" id="L437">            setEstimatedMajorSpan(true);</span>

            // estimate the span
<span class="nc" id="L440">            Element elem = getElement();</span>
<span class="nc" id="L441">            int index0 = elem.getElementIndex(getStartOffset());</span>
<span class="nc" id="L442">            int index1 = elem.getElementIndex(getEndOffset());</span>
<span class="nc" id="L443">            int nChildren = index1 - index0;</span>

            // replace this with something real
            //setSpan(getMajorAxis(), nChildren * 10);

<span class="nc" id="L448">            View first = f.create(elem.getElement(index0));</span>
<span class="nc" id="L449">            first.setParent(this);</span>
<span class="nc" id="L450">            float w = first.getPreferredSpan(X_AXIS);</span>
<span class="nc" id="L451">            float h = first.getPreferredSpan(Y_AXIS);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (getMajorAxis() == X_AXIS) {</span>
<span class="nc" id="L453">                w *= nChildren;</span>
            } else {
<span class="nc" id="L455">                h += nChildren;</span>
            }

<span class="nc" id="L458">            setSize(w, h);</span>
<span class="nc" id="L459">        }</span>

        /**
         * Publish the changes in preferences upward to the parent
         * view.
         * &lt;p&gt;
         * This is reimplemented to stop the superclass behavior
         * if the zone has not yet been loaded.  If the zone is
         * unloaded for example, the last seen major span is the
         * best estimate and a calculated span for no children
         * is undesirable.
         */
        protected void flushRequirementChanges() {
<span class="nc bnc" id="L472" title="All 2 branches missed.">            if (isLoaded()) {</span>
<span class="nc" id="L473">                super.flushRequirementChanges();</span>
            }
<span class="nc" id="L475">        }</span>

        /**
         * Returns the child view index representing the given position in
         * the model.  Since the zone contains a cluster of the overall
         * set of child elements, we can determine the index fairly
         * quickly from the model by subtracting the index of the
         * start offset from the index of the position given.
         *
         * @param pos the position &gt;= 0
         * @return  index of the view representing the given position, or
         *   -1 if no view represents that position
         * @since 1.3
         */
        public int getViewIndex(int pos, Position.Bias b) {
<span class="nc bnc" id="L490" title="All 2 branches missed.">            boolean isBackward = (b == Position.Bias.Backward);</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">            pos = (isBackward) ? Math.max(0, pos - 1) : pos;</span>
<span class="nc" id="L492">            Element elem = getElement();</span>
<span class="nc" id="L493">            int index1 = elem.getElementIndex(pos);</span>
<span class="nc" id="L494">            int index0 = elem.getElementIndex(getStartOffset());</span>
<span class="nc" id="L495">            return index1 - index0;</span>
        }

        protected boolean updateChildren(DocumentEvent.ElementChange ec,
                                         DocumentEvent e, ViewFactory f) {
            // the structure of this element changed.
<span class="nc" id="L501">            Element[] removedElems = ec.getChildrenRemoved();</span>
<span class="nc" id="L502">            Element[] addedElems = ec.getChildrenAdded();</span>
<span class="nc" id="L503">            Element elem = getElement();</span>
<span class="nc" id="L504">            int index0 = elem.getElementIndex(getStartOffset());</span>
<span class="nc" id="L505">            int index1 = elem.getElementIndex(getEndOffset()-1);</span>
<span class="nc" id="L506">            int index = ec.getIndex();</span>
<span class="nc bnc" id="L507" title="All 4 branches missed.">            if ((index &gt;= index0) &amp;&amp; (index &lt;= index1)) {</span>
                // The change is in this zone
<span class="nc" id="L509">                int replaceIndex = index - index0;</span>
<span class="nc" id="L510">                int nadd = Math.min(index1 - index0 + 1, addedElems.length);</span>
<span class="nc" id="L511">                int nremove = Math.min(index1 - index0 + 1, removedElems.length);</span>
<span class="nc" id="L512">                View[] added = new View[nadd];</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                for (int i = 0; i &lt; nadd; i++) {</span>
<span class="nc" id="L514">                    added[i] = f.create(addedElems[i]);</span>
                }
<span class="nc" id="L516">                replace(replaceIndex, nremove, added);</span>
            }
<span class="nc" id="L518">            return true;</span>
        }

        // --- View methods ----------------------------------

        /**
         * Fetches the attributes to use when rendering.  This view
         * isn't directly responsible for an element so it returns
         * the outer classes attributes.
         */
        public AttributeSet getAttributes() {
<span class="nc" id="L529">            return ZoneView.this.getAttributes();</span>
        }

        /**
         * Renders using the given rendering surface and area on that
         * surface.  This is implemented to load the zone if its not
         * already loaded, and then perform the superclass behavior.
         *
         * @param g the rendering surface to use
         * @param a the allocated region to render into
         * @see View#paint
         */
        public void paint(Graphics g, Shape a) {
<span class="nc" id="L542">            load();</span>
<span class="nc" id="L543">            super.paint(g, a);</span>
<span class="nc" id="L544">        }</span>

        /**
         * Provides a mapping from the view coordinate space to the logical
         * coordinate space of the model.  This is implemented to first
         * make sure the zone is loaded before providing the superclass
         * behavior.
         *
         * @param x   x coordinate of the view location to convert &gt;= 0
         * @param y   y coordinate of the view location to convert &gt;= 0
         * @param a the allocated region to render into
         * @return the location within the model that best represents the
         *  given point in the view &gt;= 0
         * @see View#viewToModel
         */
        public int viewToModel(float x, float y, Shape a, Position.Bias[] bias) {
<span class="nc" id="L560">            load();</span>
<span class="nc" id="L561">            return super.viewToModel(x, y, a, bias);</span>
        }

        /**
         * Provides a mapping from the document model coordinate space
         * to the coordinate space of the view mapped to it.  This is
         * implemented to provide the superclass behavior after first
         * making sure the zone is loaded (The zone must be loaded to
         * make this calculation).
         *
         * @param pos the position to convert
         * @param a the allocated region to render into
         * @return the bounding box of the given position
         * @exception BadLocationException  if the given position does not represent a
         *   valid location in the associated document
         * @see View#modelToView
         */
        public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
<span class="nc" id="L579">            load();</span>
<span class="nc" id="L580">            return super.modelToView(pos, a, b);</span>
        }

        /**
         * Start of the zones range.
         *
         * @see View#getStartOffset
         */
        public int getStartOffset() {
<span class="nc" id="L589">            return start.getOffset();</span>
        }

        /**
         * End of the zones range.
         */
        public int getEndOffset() {
<span class="nc" id="L596">            return end.getOffset();</span>
        }

        /**
         * Gives notification that something was inserted into
         * the document in a location that this view is responsible for.
         * If the zone has been loaded, the superclass behavior is
         * invoked, otherwise this does nothing.
         *
         * @param e the change information from the associated document
         * @param a the current allocation of the view
         * @param f the factory to use to rebuild if the view has children
         * @see View#insertUpdate
         */
        public void insertUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc bnc" id="L611" title="All 2 branches missed.">            if (isLoaded()) {</span>
<span class="nc" id="L612">                super.insertUpdate(e, a, f);</span>
            }
<span class="nc" id="L614">        }</span>

        /**
         * Gives notification that something was removed from the document
         * in a location that this view is responsible for.
         * If the zone has been loaded, the superclass behavior is
         * invoked, otherwise this does nothing.
         *
         * @param e the change information from the associated document
         * @param a the current allocation of the view
         * @param f the factory to use to rebuild if the view has children
         * @see View#removeUpdate
         */
        public void removeUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc bnc" id="L628" title="All 2 branches missed.">            if (isLoaded()) {</span>
<span class="nc" id="L629">                super.removeUpdate(e, a, f);</span>
            }
<span class="nc" id="L631">        }</span>

        /**
         * Gives notification from the document that attributes were changed
         * in a location that this view is responsible for.
         * If the zone has been loaded, the superclass behavior is
         * invoked, otherwise this does nothing.
         *
         * @param e the change information from the associated document
         * @param a the current allocation of the view
         * @param f the factory to use to rebuild if the view has children
         * @see View#removeUpdate
         */
        public void changedUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc bnc" id="L645" title="All 2 branches missed.">            if (isLoaded()) {</span>
<span class="nc" id="L646">                super.changedUpdate(e, a, f);</span>
            }
<span class="nc" id="L648">        }</span>

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>