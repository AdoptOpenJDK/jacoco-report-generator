<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StringContent.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">StringContent.java</span></div><h1>StringContent.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.util.Vector;
import java.io.Serializable;
import javax.swing.undo.*;
import javax.swing.SwingUtilities;

/**
 * An implementation of the AbstractDocument.Content interface that is
 * a brute force implementation that is useful for relatively small
 * documents and/or debugging.  It manages the character content
 * as a simple character array.  It is also quite inefficient.
 * &lt;p&gt;
 * It is generally recommended that the gap buffer or piece table
 * implementations be used instead.  This buffer does not scale up
 * to large sizes.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author  Timothy Prinzing
 */
public final class StringContent implements AbstractDocument.Content, Serializable {

    /**
     * Creates a new StringContent object.  Initial size defaults to 10.
     */
    public StringContent() {
<span class="nc" id="L59">        this(10);</span>
<span class="nc" id="L60">    }</span>

    /**
     * Creates a new StringContent object, with the initial
     * size specified.  If the length is &amp;lt; 1, a size of 1 is used.
     *
     * @param initialLength the initial size
     */
<span class="nc" id="L68">    public StringContent(int initialLength) {</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">        if (initialLength &lt; 1) {</span>
<span class="nc" id="L70">            initialLength = 1;</span>
        }
<span class="nc" id="L72">        data = new char[initialLength];</span>
<span class="nc" id="L73">        data[0] = '\n';</span>
<span class="nc" id="L74">        count = 1;</span>
<span class="nc" id="L75">    }</span>

    /**
     * Returns the length of the content.
     *
     * @return the length &amp;gt;= 1
     * @see AbstractDocument.Content#length
     */
    public int length() {
<span class="nc" id="L84">        return count;</span>
    }

    /**
     * Inserts a string into the content.
     *
     * @param where the starting position &amp;gt;= 0 &amp;amp;&amp;amp; &amp;lt; length()
     * @param str the non-null string to insert
     * @return an UndoableEdit object for undoing
     * @exception BadLocationException if the specified position is invalid
     * @see AbstractDocument.Content#insertString
     */
    public UndoableEdit insertString(int where, String str) throws BadLocationException {
<span class="nc bnc" id="L97" title="All 4 branches missed.">        if (where &gt;= count || where &lt; 0) {</span>
<span class="nc" id="L98">            throw new BadLocationException(&quot;Invalid location&quot;, count);</span>
        }
<span class="nc" id="L100">        char[] chars = str.toCharArray();</span>
<span class="nc" id="L101">        replace(where, 0, chars, 0, chars.length);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (marks != null) {</span>
<span class="nc" id="L103">            updateMarksForInsert(where, str.length());</span>
        }
<span class="nc" id="L105">        return new InsertUndo(where, str.length());</span>
    }

    /**
     * Removes part of the content.  where + nitems must be &amp;lt; length().
     *
     * @param where the starting position &amp;gt;= 0
     * @param nitems the number of characters to remove &amp;gt;= 0
     * @return an UndoableEdit object for undoing
     * @exception BadLocationException if the specified position is invalid
     * @see AbstractDocument.Content#remove
     */
    public UndoableEdit remove(int where, int nitems) throws BadLocationException {
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (where + nitems &gt;= count) {</span>
<span class="nc" id="L119">            throw new BadLocationException(&quot;Invalid range&quot;, count);</span>
        }
<span class="nc" id="L121">        String removedString = getString(where, nitems);</span>
<span class="nc" id="L122">        UndoableEdit edit = new RemoveUndo(where, removedString);</span>
<span class="nc" id="L123">        replace(where, nitems, empty, 0, 0);</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (marks != null) {</span>
<span class="nc" id="L125">            updateMarksForRemove(where, nitems);</span>
        }
<span class="nc" id="L127">        return edit;</span>

    }

    /**
     * Retrieves a portion of the content.  where + len must be &amp;lt;= length().
     *
     * @param where the starting position &amp;gt;= 0
     * @param len the length to retrieve &amp;gt;= 0
     * @return a string representing the content; may be empty
     * @exception BadLocationException if the specified position is invalid
     * @see AbstractDocument.Content#getString
     */
    public String getString(int where, int len) throws BadLocationException {
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if (where + len &gt; count) {</span>
<span class="nc" id="L142">            throw new BadLocationException(&quot;Invalid range&quot;, count);</span>
        }
<span class="nc" id="L144">        return new String(data, where, len);</span>
    }

    /**
     * Retrieves a portion of the content.  where + len must be &amp;lt;= length()
     *
     * @param where the starting position &amp;gt;= 0
     * @param len the number of characters to retrieve &amp;gt;= 0
     * @param chars the Segment object to return the characters in
     * @exception BadLocationException if the specified position is invalid
     * @see AbstractDocument.Content#getChars
     */
    public void getChars(int where, int len, Segment chars) throws BadLocationException {
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (where + len &gt; count) {</span>
<span class="nc" id="L158">            throw new BadLocationException(&quot;Invalid location&quot;, count);</span>
        }
<span class="nc" id="L160">        chars.array = data;</span>
<span class="nc" id="L161">        chars.offset = where;</span>
<span class="nc" id="L162">        chars.count = len;</span>
<span class="nc" id="L163">    }</span>

    /**
     * Creates a position within the content that will
     * track change as the content is mutated.
     *
     * @param offset the offset to create a position for &amp;gt;= 0
     * @return the position
     * @exception BadLocationException if the specified position is invalid
     */
    public Position createPosition(int offset) throws BadLocationException {
        // some small documents won't have any sticky positions
        // at all, so the buffer is created lazily.
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (marks == null) {</span>
<span class="nc" id="L177">            marks = new Vector&lt;PosRec&gt;();</span>
        }
<span class="nc" id="L179">        return new StickyPosition(offset);</span>
    }

    // --- local methods ---------------------------------------

    /**
     * Replaces some of the characters in the array
     * @param offset  offset into the array to start the replace
     * @param length  number of characters to remove
     * @param replArray replacement array
     * @param replOffset offset into the replacement array
     * @param replLength number of character to use from the
     *   replacement array.
     */
    void replace(int offset, int length,
                 char[] replArray, int replOffset, int replLength) {
<span class="nc" id="L195">        int delta = replLength - length;</span>
<span class="nc" id="L196">        int src = offset + length;</span>
<span class="nc" id="L197">        int nmove = count - src;</span>
<span class="nc" id="L198">        int dest = src + delta;</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if ((count + delta) &gt;= data.length) {</span>
            // need to grow the array
<span class="nc" id="L201">            int newLength = Math.max(2*data.length, count + delta);</span>
<span class="nc" id="L202">            char[] newData = new char[newLength];</span>
<span class="nc" id="L203">            System.arraycopy(data, 0, newData, 0, offset);</span>
<span class="nc" id="L204">            System.arraycopy(replArray, replOffset, newData, offset, replLength);</span>
<span class="nc" id="L205">            System.arraycopy(data, src, newData, dest, nmove);</span>
<span class="nc" id="L206">            data = newData;</span>
<span class="nc" id="L207">        } else {</span>
            // patch the existing array
<span class="nc" id="L209">            System.arraycopy(data, src, data, dest, nmove);</span>
<span class="nc" id="L210">            System.arraycopy(replArray, replOffset, data, offset, replLength);</span>
        }
<span class="nc" id="L212">        count = count + delta;</span>
<span class="nc" id="L213">    }</span>

    void resize(int ncount) {
<span class="nc" id="L216">        char[] ndata = new char[ncount];</span>
<span class="nc" id="L217">        System.arraycopy(data, 0, ndata, 0, Math.min(ncount, count));</span>
<span class="nc" id="L218">        data = ndata;</span>
<span class="nc" id="L219">    }</span>

    synchronized void updateMarksForInsert(int offset, int length) {
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (offset == 0) {</span>
            // zero is a special case where we update only
            // marks after it.
<span class="nc" id="L225">            offset = 1;</span>
        }
<span class="nc" id="L227">        int n = marks.size();</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L229">            PosRec mark = marks.elementAt(i);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (mark.unused) {</span>
                // this record is no longer used, get rid of it
<span class="nc" id="L232">                marks.removeElementAt(i);</span>
<span class="nc" id="L233">                i -= 1;</span>
<span class="nc" id="L234">                n -= 1;</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            } else if (mark.offset &gt;= offset) {</span>
<span class="nc" id="L236">                mark.offset += length;</span>
            }
        }
<span class="nc" id="L239">    }</span>

    synchronized void updateMarksForRemove(int offset, int length) {
<span class="nc" id="L242">        int n = marks.size();</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L244">            PosRec mark = marks.elementAt(i);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">            if (mark.unused) {</span>
                // this record is no longer used, get rid of it
<span class="nc" id="L247">                marks.removeElementAt(i);</span>
<span class="nc" id="L248">                i -= 1;</span>
<span class="nc" id="L249">                n -= 1;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            } else if (mark.offset &gt;= (offset + length)) {</span>
<span class="nc" id="L251">                mark.offset -= length;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">            } else if (mark.offset &gt;= offset) {</span>
<span class="nc" id="L253">                mark.offset = offset;</span>
            }
        }
<span class="nc" id="L256">    }</span>

    /**
     * Returns a Vector containing instances of UndoPosRef for the
     * Positions in the range
     * &lt;code&gt;offset&lt;/code&gt; to &lt;code&gt;offset&lt;/code&gt; + &lt;code&gt;length&lt;/code&gt;.
     * If &lt;code&gt;v&lt;/code&gt; is not null the matching Positions are placed in
     * there. The vector with the resulting Positions are returned.
     * &lt;p&gt;
     * This is meant for internal usage, and is generally not of interest
     * to subclasses.
     *
     * @param v the Vector to use, with a new one created on null
     * @param offset the starting offset &amp;gt;= 0
     * @param length the length &amp;gt;= 0
     * @return the set of instances
     */
    protected Vector getPositionsInRange(Vector v, int offset,
                                                      int length) {
<span class="nc" id="L275">        int n = marks.size();</span>
<span class="nc" id="L276">        int end = offset + length;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        Vector placeIn = (v == null) ? new Vector() : v;</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L279">            PosRec mark = marks.elementAt(i);</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            if (mark.unused) {</span>
                // this record is no longer used, get rid of it
<span class="nc" id="L282">                marks.removeElementAt(i);</span>
<span class="nc" id="L283">                i -= 1;</span>
<span class="nc" id="L284">                n -= 1;</span>
<span class="nc bnc" id="L285" title="All 4 branches missed.">            } else if(mark.offset &gt;= offset &amp;&amp; mark.offset &lt;= end)</span>
<span class="nc" id="L286">                placeIn.addElement(new UndoPosRef(mark));</span>
        }
<span class="nc" id="L288">        return placeIn;</span>
    }

    /**
     * Resets the location for all the UndoPosRef instances
     * in &lt;code&gt;positions&lt;/code&gt;.
     * &lt;p&gt;
     * This is meant for internal usage, and is generally not of interest
     * to subclasses.
     *
     * @param positions the positions of the instances
     */
    protected void updateUndoPositions(Vector positions) {
<span class="nc bnc" id="L301" title="All 2 branches missed.">        for(int counter = positions.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L302">            UndoPosRef ref = (UndoPosRef)positions.elementAt(counter);</span>
            // Check if the Position is still valid.
<span class="nc bnc" id="L304" title="All 2 branches missed.">            if(ref.rec.unused) {</span>
<span class="nc" id="L305">                positions.removeElementAt(counter);</span>
            }
            else
<span class="nc" id="L308">                ref.resetLocation();</span>
        }
<span class="nc" id="L310">    }</span>

<span class="nc" id="L312">    private static final char[] empty = new char[0];</span>
    private char[] data;
    private int count;
    transient Vector&lt;PosRec&gt; marks;

    /**
     * holds the data for a mark... separately from
     * the real mark so that the real mark can be
     * collected if there are no more references to
     * it.... the update table holds only a reference
     * to this grungy thing.
     */
    final class PosRec {

<span class="nc" id="L326">        PosRec(int offset) {</span>
<span class="nc" id="L327">            this.offset = offset;</span>
<span class="nc" id="L328">        }</span>

        int offset;
        boolean unused;
    }

    /**
     * This really wants to be a weak reference but
     * in 1.1 we don't have a 100% pure solution for
     * this... so this class trys to hack a solution
     * to causing the marks to be collected.
     */
    final class StickyPosition implements Position {

<span class="nc" id="L342">        StickyPosition(int offset) {</span>
<span class="nc" id="L343">            rec = new PosRec(offset);</span>
<span class="nc" id="L344">            marks.addElement(rec);</span>
<span class="nc" id="L345">        }</span>

        public int getOffset() {
<span class="nc" id="L348">            return rec.offset;</span>
        }

        protected void finalize() throws Throwable {
            // schedule the record to be removed later
            // on another thread.
<span class="nc" id="L354">            rec.unused = true;</span>
<span class="nc" id="L355">        }</span>

        public String toString() {
<span class="nc" id="L358">            return Integer.toString(getOffset());</span>
        }

        PosRec rec;
    }

    /**
     * Used to hold a reference to a Position that is being reset as the
     * result of removing from the content.
     */
    final class UndoPosRef {
<span class="nc" id="L369">        UndoPosRef(PosRec rec) {</span>
<span class="nc" id="L370">            this.rec = rec;</span>
<span class="nc" id="L371">            this.undoLocation = rec.offset;</span>
<span class="nc" id="L372">        }</span>

        /**
         * Resets the location of the Position to the offset when the
         * receiver was instantiated.
         */
        protected void resetLocation() {
<span class="nc" id="L379">            rec.offset = undoLocation;</span>
<span class="nc" id="L380">        }</span>

        /** Location to reset to when resetLocatino is invoked. */
        protected int undoLocation;
        /** Position to reset offset. */
        protected PosRec rec;
    }

    /**
     * UnoableEdit created for inserts.
     */
    class InsertUndo extends AbstractUndoableEdit {
<span class="nc" id="L392">        protected InsertUndo(int offset, int length) {</span>
<span class="nc" id="L393">            super();</span>
<span class="nc" id="L394">            this.offset = offset;</span>
<span class="nc" id="L395">            this.length = length;</span>
<span class="nc" id="L396">        }</span>

        public void undo() throws CannotUndoException {
<span class="nc" id="L399">            super.undo();</span>
            try {
<span class="nc" id="L401">                synchronized(StringContent.this) {</span>
                    // Get the Positions in the range being removed.
<span class="nc bnc" id="L403" title="All 2 branches missed.">                    if(marks != null)</span>
<span class="nc" id="L404">                        posRefs = getPositionsInRange(null, offset, length);</span>
<span class="nc" id="L405">                    string = getString(offset, length);</span>
<span class="nc" id="L406">                    remove(offset, length);</span>
<span class="nc" id="L407">                }</span>
<span class="nc" id="L408">            } catch (BadLocationException bl) {</span>
<span class="nc" id="L409">              throw new CannotUndoException();</span>
<span class="nc" id="L410">            }</span>
<span class="nc" id="L411">        }</span>

        public void redo() throws CannotRedoException {
<span class="nc" id="L414">            super.redo();</span>
            try {
<span class="nc" id="L416">                synchronized(StringContent.this) {</span>
<span class="nc" id="L417">                    insertString(offset, string);</span>
<span class="nc" id="L418">                    string = null;</span>
                    // Update the Positions that were in the range removed.
<span class="nc bnc" id="L420" title="All 2 branches missed.">                    if(posRefs != null) {</span>
<span class="nc" id="L421">                        updateUndoPositions(posRefs);</span>
<span class="nc" id="L422">                        posRefs = null;</span>
                    }
<span class="nc" id="L424">              }</span>
<span class="nc" id="L425">            } catch (BadLocationException bl) {</span>
<span class="nc" id="L426">              throw new CannotRedoException();</span>
<span class="nc" id="L427">            }</span>
<span class="nc" id="L428">        }</span>

        // Where the string goes.
        protected int offset;
        // Length of the string.
        protected int length;
        // The string that was inserted. To cut down on space needed this
        // will only be valid after an undo.
        protected String string;
        // An array of instances of UndoPosRef for the Positions in the
        // range that was removed, valid after undo.
        protected Vector posRefs;
    }


    /**
     * UndoableEdit created for removes.
     */
    class RemoveUndo extends AbstractUndoableEdit {
<span class="nc" id="L447">        protected RemoveUndo(int offset, String string) {</span>
<span class="nc" id="L448">            super();</span>
<span class="nc" id="L449">            this.offset = offset;</span>
<span class="nc" id="L450">            this.string = string;</span>
<span class="nc" id="L451">            this.length = string.length();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if(marks != null)</span>
<span class="nc" id="L453">                posRefs = getPositionsInRange(null, offset, length);</span>
<span class="nc" id="L454">        }</span>

        public void undo() throws CannotUndoException {
<span class="nc" id="L457">            super.undo();</span>
            try {
<span class="nc" id="L459">                synchronized(StringContent.this) {</span>
<span class="nc" id="L460">                    insertString(offset, string);</span>
                    // Update the Positions that were in the range removed.
<span class="nc bnc" id="L462" title="All 2 branches missed.">                    if(posRefs != null) {</span>
<span class="nc" id="L463">                        updateUndoPositions(posRefs);</span>
<span class="nc" id="L464">                        posRefs = null;</span>
                    }
<span class="nc" id="L466">                    string = null;</span>
<span class="nc" id="L467">                }</span>
<span class="nc" id="L468">            } catch (BadLocationException bl) {</span>
<span class="nc" id="L469">              throw new CannotUndoException();</span>
<span class="nc" id="L470">            }</span>
<span class="nc" id="L471">        }</span>

        public void redo() throws CannotRedoException {
<span class="nc" id="L474">            super.redo();</span>
            try {
<span class="nc" id="L476">                synchronized(StringContent.this) {</span>
<span class="nc" id="L477">                    string = getString(offset, length);</span>
                    // Get the Positions in the range being removed.
<span class="nc bnc" id="L479" title="All 2 branches missed.">                    if(marks != null)</span>
<span class="nc" id="L480">                        posRefs = getPositionsInRange(null, offset, length);</span>
<span class="nc" id="L481">                    remove(offset, length);</span>
<span class="nc" id="L482">                }</span>
<span class="nc" id="L483">            } catch (BadLocationException bl) {</span>
<span class="nc" id="L484">              throw new CannotRedoException();</span>
<span class="nc" id="L485">            }</span>
<span class="nc" id="L486">        }</span>

        // Where the string goes.
        protected int offset;
        // Length of the string.
        protected int length;
        // The string that was inserted. This will be null after an undo.
        protected String string;
        // An array of instances of UndoPosRef for the Positions in the
        // range that was removed, valid before undo.
        protected Vector posRefs;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>