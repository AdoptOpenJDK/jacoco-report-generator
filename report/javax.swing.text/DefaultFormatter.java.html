<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultFormatter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">DefaultFormatter.java</span></div><h1>DefaultFormatter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import sun.reflect.misc.ReflectUtil;
import sun.swing.SwingUtilities2;

import java.io.Serializable;
import java.lang.reflect.*;
import java.text.ParseException;
import javax.swing.*;
import javax.swing.text.*;

/**
 * &lt;code&gt;DefaultFormatter&lt;/code&gt; formats arbitrary objects. Formatting is done
 * by invoking the &lt;code&gt;toString&lt;/code&gt; method. In order to convert the
 * value back to a String, your class must provide a constructor that
 * takes a String argument. If no single argument constructor that takes a
 * String is found, the returned value will be the String passed into
 * &lt;code&gt;stringToValue&lt;/code&gt;.
 * &lt;p&gt;
 * Instances of &lt;code&gt;DefaultFormatter&lt;/code&gt; can not be used in multiple
 * instances of &lt;code&gt;JFormattedTextField&lt;/code&gt;. To obtain a copy of
 * an already configured &lt;code&gt;DefaultFormatter&lt;/code&gt;, use the
 * &lt;code&gt;clone&lt;/code&gt; method.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @see javax.swing.JFormattedTextField.AbstractFormatter
 *
 * @since 1.4
 */
public class DefaultFormatter extends JFormattedTextField.AbstractFormatter
                    implements Cloneable, Serializable {
    /** Indicates if the value being edited must match the mask. */
    private boolean allowsInvalid;

    /** If true, editing mode is in overwrite (or strikethough). */
    private boolean overwriteMode;

    /** If true, any time a valid edit happens commitEdit is invoked. */
    private boolean commitOnEdit;

    /** Class used to create new instances. */
    private Class&lt;?&gt; valueClass;

    /** NavigationFilter that forwards calls back to DefaultFormatter. */
    private NavigationFilter navigationFilter;

    /** DocumentFilter that forwards calls back to DefaultFormatter. */
    private DocumentFilter documentFilter;

    /** Used during replace to track the region to replace. */
    transient ReplaceHolder replaceHolder;


    /**
     * Creates a DefaultFormatter.
     */
<span class="nc" id="L89">    public DefaultFormatter() {</span>
<span class="nc" id="L90">        overwriteMode = true;</span>
<span class="nc" id="L91">        allowsInvalid = true;</span>
<span class="nc" id="L92">    }</span>

    /**
     * Installs the &lt;code&gt;DefaultFormatter&lt;/code&gt; onto a particular
     * &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     * This will invoke &lt;code&gt;valueToString&lt;/code&gt; to convert the
     * current value from the &lt;code&gt;JFormattedTextField&lt;/code&gt; to
     * a String. This will then install the &lt;code&gt;Action&lt;/code&gt;s from
     * &lt;code&gt;getActions&lt;/code&gt;, the &lt;code&gt;DocumentFilter&lt;/code&gt;
     * returned from &lt;code&gt;getDocumentFilter&lt;/code&gt; and the
     * &lt;code&gt;NavigationFilter&lt;/code&gt; returned from
     * &lt;code&gt;getNavigationFilter&lt;/code&gt; onto the
     * &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     * &lt;p&gt;
     * Subclasses will typically only need to override this if they
     * wish to install additional listeners on the
     * &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     * &lt;p&gt;
     * If there is a &lt;code&gt;ParseException&lt;/code&gt; in converting the
     * current value to a String, this will set the text to an empty
     * String, and mark the &lt;code&gt;JFormattedTextField&lt;/code&gt; as being
     * in an invalid state.
     * &lt;p&gt;
     * While this is a public method, this is typically only useful
     * for subclassers of &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     * &lt;code&gt;JFormattedTextField&lt;/code&gt; will invoke this method at
     * the appropriate times when the value changes, or its internal
     * state changes.
     *
     * @param ftf JFormattedTextField to format for, may be null indicating
     *            uninstall from current JFormattedTextField.
     */
    public void install(JFormattedTextField ftf) {
<span class="nc" id="L125">        super.install(ftf);</span>
<span class="nc" id="L126">        positionCursorAtInitialLocation();</span>
<span class="nc" id="L127">    }</span>

    /**
     * Sets when edits are published back to the
     * &lt;code&gt;JFormattedTextField&lt;/code&gt;. If true, &lt;code&gt;commitEdit&lt;/code&gt;
     * is invoked after every valid edit (any time the text is edited). On
     * the other hand, if this is false than the &lt;code&gt;DefaultFormatter&lt;/code&gt;
     * does not publish edits back to the &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     * As such, the only time the value of the &lt;code&gt;JFormattedTextField&lt;/code&gt;
     * will change is when &lt;code&gt;commitEdit&lt;/code&gt; is invoked on
     * &lt;code&gt;JFormattedTextField&lt;/code&gt;, typically when enter is pressed
     * or focus leaves the &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     *
     * @param commit Used to indicate when edits are committed back to the
     *               JTextComponent
     */
    public void setCommitsOnValidEdit(boolean commit) {
<span class="nc" id="L144">        commitOnEdit = commit;</span>
<span class="nc" id="L145">    }</span>

    /**
     * Returns when edits are published back to the
     * &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     *
     * @return true if edits are committed after every valid edit
     */
    public boolean getCommitsOnValidEdit() {
<span class="nc" id="L154">        return commitOnEdit;</span>
    }

    /**
     * Configures the behavior when inserting characters. If
     * &lt;code&gt;overwriteMode&lt;/code&gt; is true (the default), new characters
     * overwrite existing characters in the model.
     *
     * @param overwriteMode Indicates if overwrite or overstrike mode is used
     */
    public void setOverwriteMode(boolean overwriteMode) {
<span class="nc" id="L165">        this.overwriteMode = overwriteMode;</span>
<span class="nc" id="L166">    }</span>

    /**
     * Returns the behavior when inserting characters.
     *
     * @return true if newly inserted characters overwrite existing characters
     */
    public boolean getOverwriteMode() {
<span class="nc" id="L174">        return overwriteMode;</span>
    }

    /**
     * Sets whether or not the value being edited is allowed to be invalid
     * for a length of time (that is, &lt;code&gt;stringToValue&lt;/code&gt; throws
     * a &lt;code&gt;ParseException&lt;/code&gt;).
     * It is often convenient to allow the user to temporarily input an
     * invalid value.
     *
     * @param allowsInvalid Used to indicate if the edited value must always
     *        be valid
     */
    public void setAllowsInvalid(boolean allowsInvalid) {
<span class="nc" id="L188">        this.allowsInvalid = allowsInvalid;</span>
<span class="nc" id="L189">    }</span>

    /**
     * Returns whether or not the value being edited is allowed to be invalid
     * for a length of time.
     *
     * @return false if the edited value must always be valid
     */
    public boolean getAllowsInvalid() {
<span class="nc" id="L198">        return allowsInvalid;</span>
    }

    /**
     * Sets that class that is used to create new Objects. If the
     * passed in class does not have a single argument constructor that
     * takes a String, String values will be used.
     *
     * @param valueClass Class used to construct return value from
     *        stringToValue
     */
    public void setValueClass(Class&lt;?&gt; valueClass) {
<span class="nc" id="L210">        this.valueClass = valueClass;</span>
<span class="nc" id="L211">    }</span>

    /**
     * Returns that class that is used to create new Objects.
     *
     * @return Class used to construct return value from stringToValue
     */
    public Class&lt;?&gt; getValueClass() {
<span class="nc" id="L219">        return valueClass;</span>
    }

    /**
     * Converts the passed in String into an instance of
     * &lt;code&gt;getValueClass&lt;/code&gt; by way of the constructor that
     * takes a String argument. If &lt;code&gt;getValueClass&lt;/code&gt;
     * returns null, the Class of the current value in the
     * &lt;code&gt;JFormattedTextField&lt;/code&gt; will be used. If this is null, a
     * String will be returned. If the constructor throws an exception, a
     * &lt;code&gt;ParseException&lt;/code&gt; will be thrown. If there is no single
     * argument String constructor, &lt;code&gt;string&lt;/code&gt; will be returned.
     *
     * @throws ParseException if there is an error in the conversion
     * @param string String to convert
     * @return Object representation of text
     */
    public Object stringToValue(String string) throws ParseException {
<span class="nc" id="L237">        Class&lt;?&gt; vc = getValueClass();</span>
<span class="nc" id="L238">        JFormattedTextField ftf = getFormattedTextField();</span>

<span class="nc bnc" id="L240" title="All 4 branches missed.">        if (vc == null &amp;&amp; ftf != null) {</span>
<span class="nc" id="L241">            Object value = ftf.getValue();</span>

<span class="nc bnc" id="L243" title="All 2 branches missed.">            if (value != null) {</span>
<span class="nc" id="L244">                vc = value.getClass();</span>
            }
        }
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (vc != null) {</span>
            Constructor cons;

            try {
<span class="nc" id="L251">                ReflectUtil.checkPackageAccess(vc);</span>
<span class="nc" id="L252">                SwingUtilities2.checkAccess(vc.getModifiers());</span>
<span class="nc" id="L253">                cons = vc.getConstructor(new Class[]{String.class});</span>

<span class="nc" id="L255">            } catch (NoSuchMethodException nsme) {</span>
<span class="nc" id="L256">                cons = null;</span>
<span class="nc" id="L257">            }</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (cons != null) {</span>
                try {
<span class="nc" id="L261">                    SwingUtilities2.checkAccess(cons.getModifiers());</span>
<span class="nc" id="L262">                    return cons.newInstance(new Object[] { string });</span>
<span class="nc" id="L263">                } catch (Throwable ex) {</span>
<span class="nc" id="L264">                    throw new ParseException(&quot;Error creating instance&quot;, 0);</span>
                }
            }
        }
<span class="nc" id="L268">        return string;</span>
    }

    /**
     * Converts the passed in Object into a String by way of the
     * &lt;code&gt;toString&lt;/code&gt; method.
     *
     * @throws ParseException if there is an error in the conversion
     * @param value Value to convert
     * @return String representation of value
     */
    public String valueToString(Object value) throws ParseException {
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L281">            return &quot;&quot;;</span>
        }
<span class="nc" id="L283">        return value.toString();</span>
    }

    /**
     * Returns the &lt;code&gt;DocumentFilter&lt;/code&gt; used to restrict the characters
     * that can be input into the &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     *
     * @return DocumentFilter to restrict edits
     */
    protected DocumentFilter getDocumentFilter() {
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (documentFilter == null) {</span>
<span class="nc" id="L294">            documentFilter = new DefaultDocumentFilter();</span>
        }
<span class="nc" id="L296">        return documentFilter;</span>
    }

    /**
     * Returns the &lt;code&gt;NavigationFilter&lt;/code&gt; used to restrict where the
     * cursor can be placed.
     *
     * @return NavigationFilter to restrict navigation
     */
    protected NavigationFilter getNavigationFilter() {
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (navigationFilter == null) {</span>
<span class="nc" id="L307">            navigationFilter = new DefaultNavigationFilter();</span>
        }
<span class="nc" id="L309">        return navigationFilter;</span>
    }

    /**
     * Creates a copy of the DefaultFormatter.
     *
     * @return copy of the DefaultFormatter
     */
    public Object clone() throws CloneNotSupportedException {
<span class="nc" id="L318">        DefaultFormatter formatter = (DefaultFormatter)super.clone();</span>

<span class="nc" id="L320">        formatter.navigationFilter = null;</span>
<span class="nc" id="L321">        formatter.documentFilter = null;</span>
<span class="nc" id="L322">        formatter.replaceHolder = null;</span>
<span class="nc" id="L323">        return formatter;</span>
    }


    /**
     * Positions the cursor at the initial location.
     */
    void positionCursorAtInitialLocation() {
<span class="nc" id="L331">        JFormattedTextField ftf = getFormattedTextField();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (ftf != null) {</span>
<span class="nc" id="L333">            ftf.setCaretPosition(getInitialVisualPosition());</span>
        }
<span class="nc" id="L335">    }</span>

    /**
     * Returns the initial location to position the cursor at. This forwards
     * the call to &lt;code&gt;getNextNavigatableChar&lt;/code&gt;.
     */
    int getInitialVisualPosition() {
<span class="nc" id="L342">        return getNextNavigatableChar(0, 1);</span>
    }

    /**
     * Subclasses should override this if they want cursor navigation
     * to skip certain characters. A return value of false indicates
     * the character at &lt;code&gt;offset&lt;/code&gt; should be skipped when
     * navigating throught the field.
     */
    boolean isNavigatable(int offset) {
<span class="nc" id="L352">        return true;</span>
    }

    /**
     * Returns true if the text in &lt;code&gt;text&lt;/code&gt; can be inserted.  This
     * does not mean the text will ultimately be inserted, it is used if
     * text can trivially reject certain characters.
     */
    boolean isLegalInsertText(String text) {
<span class="nc" id="L361">        return true;</span>
    }

    /**
     * Returns the next editable character starting at offset incrementing
     * the offset by &lt;code&gt;direction&lt;/code&gt;.
     */
    private int getNextNavigatableChar(int offset, int direction) {
<span class="nc" id="L369">        int max = getFormattedTextField().getDocument().getLength();</span>

<span class="nc bnc" id="L371" title="All 4 branches missed.">        while (offset &gt;= 0 &amp;&amp; offset &lt; max) {</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (isNavigatable(offset)) {</span>
<span class="nc" id="L373">                return offset;</span>
            }
<span class="nc" id="L375">            offset += direction;</span>
        }
<span class="nc" id="L377">        return offset;</span>
    }

    /**
     * A convenience methods to return the result of deleting
     * &lt;code&gt;deleteLength&lt;/code&gt; characters at &lt;code&gt;offset&lt;/code&gt;
     * and inserting &lt;code&gt;replaceString&lt;/code&gt; at &lt;code&gt;offset&lt;/code&gt;
     * in the current text field.
     */
    String getReplaceString(int offset, int deleteLength,
                            String replaceString) {
<span class="nc" id="L388">        String string = getFormattedTextField().getText();</span>
        String result;

<span class="nc" id="L391">        result = string.substring(0, offset);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (replaceString != null) {</span>
<span class="nc" id="L393">            result += replaceString;</span>
        }
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (offset + deleteLength &lt; string.length()) {</span>
<span class="nc" id="L396">            result += string.substring(offset + deleteLength);</span>
        }
<span class="nc" id="L398">        return result;</span>
    }

    /*
     * Returns true if the operation described by &lt;code&gt;rh&lt;/code&gt; will
     * result in a legal edit.  This may set the &lt;code&gt;value&lt;/code&gt;
     * field of &lt;code&gt;rh&lt;/code&gt;.
     */
    boolean isValidEdit(ReplaceHolder rh) {
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (!getAllowsInvalid()) {</span>
<span class="nc" id="L408">            String newString = getReplaceString(rh.offset, rh.length, rh.text);</span>

            try {
<span class="nc" id="L411">                rh.value = stringToValue(newString);</span>

<span class="nc" id="L413">                return true;</span>
<span class="nc" id="L414">            } catch (ParseException pe) {</span>
<span class="nc" id="L415">                return false;</span>
            }
        }
<span class="nc" id="L418">        return true;</span>
    }

    /**
     * Invokes &lt;code&gt;commitEdit&lt;/code&gt; on the JFormattedTextField.
     */
    void commitEdit() throws ParseException {
<span class="nc" id="L425">        JFormattedTextField ftf = getFormattedTextField();</span>

<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (ftf != null) {</span>
<span class="nc" id="L428">            ftf.commitEdit();</span>
        }
<span class="nc" id="L430">    }</span>

    /**
     * Pushes the value to the JFormattedTextField if the current value
     * is valid and invokes &lt;code&gt;setEditValid&lt;/code&gt; based on the
     * validity of the value.
     */
    void updateValue() {
<span class="nc" id="L438">        updateValue(null);</span>
<span class="nc" id="L439">    }</span>

    /**
     * Pushes the &lt;code&gt;value&lt;/code&gt; to the editor if we are to
     * commit on edits. If &lt;code&gt;value&lt;/code&gt; is null, the current value
     * will be obtained from the text component.
     */
    void updateValue(Object value) {
        try {
<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L449">                String string = getFormattedTextField().getText();</span>

<span class="nc" id="L451">                value = stringToValue(string);</span>
            }

<span class="nc bnc" id="L454" title="All 2 branches missed.">            if (getCommitsOnValidEdit()) {</span>
<span class="nc" id="L455">                commitEdit();</span>
            }
<span class="nc" id="L457">            setEditValid(true);</span>
<span class="nc" id="L458">        } catch (ParseException pe) {</span>
<span class="nc" id="L459">            setEditValid(false);</span>
<span class="nc" id="L460">        }</span>
<span class="nc" id="L461">    }</span>

    /**
     * Returns the next cursor position from offset by incrementing
     * &lt;code&gt;direction&lt;/code&gt;. This uses
     * &lt;code&gt;getNextNavigatableChar&lt;/code&gt;
     * as well as constraining the location to the max position.
     */
    int getNextCursorPosition(int offset, int direction) {
<span class="nc" id="L470">        int newOffset = getNextNavigatableChar(offset, direction);</span>
<span class="nc" id="L471">        int max = getFormattedTextField().getDocument().getLength();</span>

<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (!getAllowsInvalid()) {</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">            if (direction == -1 &amp;&amp; offset == newOffset) {</span>
                // Case where hit backspace and only characters before
                // offset are fixed.
<span class="nc" id="L477">                newOffset = getNextNavigatableChar(newOffset, 1);</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">                if (newOffset &gt;= max) {</span>
<span class="nc" id="L479">                    newOffset = offset;</span>
                }
            }
<span class="nc bnc" id="L482" title="All 4 branches missed.">            else if (direction == 1 &amp;&amp; newOffset &gt;= max) {</span>
                // Don't go beyond last editable character.
<span class="nc" id="L484">                newOffset = getNextNavigatableChar(max - 1, -1);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">                if (newOffset &lt; max) {</span>
<span class="nc" id="L486">                    newOffset++;</span>
                }
            }
        }
<span class="nc" id="L490">        return newOffset;</span>
    }

    /**
     * Resets the cursor by using getNextCursorPosition.
     */
    void repositionCursor(int offset, int direction) {
<span class="nc" id="L497">        getFormattedTextField().getCaret().setDot(getNextCursorPosition</span>
<span class="nc" id="L498">                                                  (offset, direction));</span>
<span class="nc" id="L499">    }</span>


    /**
     * Finds the next navigable character.
     */
    int getNextVisualPositionFrom(JTextComponent text, int pos,
                                  Position.Bias bias, int direction,
                                  Position.Bias[] biasRet)
                                           throws BadLocationException {
<span class="nc" id="L509">        int value = text.getUI().getNextVisualPositionFrom(text, pos, bias,</span>
                                                           direction, biasRet);

<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (value == -1) {</span>
<span class="nc" id="L513">            return -1;</span>
        }
<span class="nc bnc" id="L515" title="All 6 branches missed.">        if (!getAllowsInvalid() &amp;&amp; (direction == SwingConstants.EAST ||</span>
                                    direction == SwingConstants.WEST)) {
<span class="nc" id="L517">            int last = -1;</span>

<span class="nc bnc" id="L519" title="All 4 branches missed.">            while (!isNavigatable(value) &amp;&amp; value != last) {</span>
<span class="nc" id="L520">                last = value;</span>
<span class="nc" id="L521">                value = text.getUI().getNextVisualPositionFrom(</span>
                              text, value, bias, direction,biasRet);
            }
<span class="nc" id="L524">            int max = getFormattedTextField().getDocument().getLength();</span>
<span class="nc bnc" id="L525" title="All 4 branches missed.">            if (last == value || value == max) {</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">                if (value == 0) {</span>
<span class="nc" id="L527">                    biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L528">                    value = getInitialVisualPosition();</span>
                }
<span class="nc bnc" id="L530" title="All 4 branches missed.">                if (value &gt;= max &amp;&amp; max &gt; 0) {</span>
                    // Pending: should not assume forward!
<span class="nc" id="L532">                    biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L533">                    value = getNextNavigatableChar(max - 1, -1) + 1;</span>
                }
            }
        }
<span class="nc" id="L537">        return value;</span>
    }

    /**
     * Returns true if the edit described by &lt;code&gt;rh&lt;/code&gt; will result
     * in a legal value.
     */
    boolean canReplace(ReplaceHolder rh) {
<span class="nc" id="L545">        return isValidEdit(rh);</span>
    }

    /**
     * DocumentFilter method, funnels into &lt;code&gt;replace&lt;/code&gt;.
     */
    void replace(DocumentFilter.FilterBypass fb, int offset,
                     int length, String text,
                     AttributeSet attrs) throws BadLocationException {
<span class="nc" id="L554">        ReplaceHolder rh = getReplaceHolder(fb, offset, length, text, attrs);</span>

<span class="nc" id="L556">        replace(rh);</span>
<span class="nc" id="L557">    }</span>

    /**
     * If the edit described by &lt;code&gt;rh&lt;/code&gt; is legal, this will
     * return true, commit the edit (if necessary) and update the cursor
     * position.  This forwards to &lt;code&gt;canReplace&lt;/code&gt; and
     * &lt;code&gt;isLegalInsertText&lt;/code&gt; as necessary to determine if
     * the edit is in fact legal.
     * &lt;p&gt;
     * All of the DocumentFilter methods funnel into here, you should
     * generally only have to override this.
     */
    boolean replace(ReplaceHolder rh) throws BadLocationException {
<span class="nc" id="L570">        boolean valid = true;</span>
<span class="nc" id="L571">        int direction = 1;</span>

<span class="nc bnc" id="L573" title="All 6 branches missed.">        if (rh.length &gt; 0 &amp;&amp; (rh.text == null || rh.text.length() == 0) &amp;&amp;</span>
<span class="nc bnc" id="L574" title="All 4 branches missed.">               (getFormattedTextField().getSelectionStart() != rh.offset ||</span>
                   rh.length &gt; 1)) {
<span class="nc" id="L576">            direction = -1;</span>
        }

<span class="nc bnc" id="L579" title="All 4 branches missed.">        if (getOverwriteMode() &amp;&amp; rh.text != null &amp;&amp;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">            getFormattedTextField().getSelectedText() == null)</span>
        {
<span class="nc" id="L582">            rh.length = Math.min(Math.max(rh.length, rh.text.length()),</span>
<span class="nc" id="L583">                                 rh.fb.getDocument().getLength() - rh.offset);</span>
        }
<span class="nc bnc" id="L585" title="All 4 branches missed.">        if ((rh.text != null &amp;&amp; !isLegalInsertText(rh.text)) ||</span>
<span class="nc bnc" id="L586" title="All 6 branches missed.">            !canReplace(rh) ||</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">            (rh.length == 0 &amp;&amp; (rh.text == null || rh.text.length() == 0))) {</span>
<span class="nc" id="L588">            valid = false;</span>
        }
<span class="nc bnc" id="L590" title="All 2 branches missed.">        if (valid) {</span>
<span class="nc" id="L591">            int cursor = rh.cursorPosition;</span>

<span class="nc" id="L593">            rh.fb.replace(rh.offset, rh.length, rh.text, rh.attrs);</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (cursor == -1) {</span>
<span class="nc" id="L595">                cursor = rh.offset;</span>
<span class="nc bnc" id="L596" title="All 4 branches missed.">                if (direction == 1 &amp;&amp; rh.text != null) {</span>
<span class="nc" id="L597">                    cursor = rh.offset + rh.text.length();</span>
                }
            }
<span class="nc" id="L600">            updateValue(rh.value);</span>
<span class="nc" id="L601">            repositionCursor(cursor, direction);</span>
<span class="nc" id="L602">            return true;</span>
        }
        else {
<span class="nc" id="L605">            invalidEdit();</span>
        }
<span class="nc" id="L607">        return false;</span>
    }

    /**
     * NavigationFilter method, subclasses that wish finer control should
     * override this.
     */
    void setDot(NavigationFilter.FilterBypass fb, int dot, Position.Bias bias){
<span class="nc" id="L615">        fb.setDot(dot, bias);</span>
<span class="nc" id="L616">    }</span>

    /**
     * NavigationFilter method, subclasses that wish finer control should
     * override this.
     */
    void moveDot(NavigationFilter.FilterBypass fb, int dot,
                 Position.Bias bias) {
<span class="nc" id="L624">        fb.moveDot(dot, bias);</span>
<span class="nc" id="L625">    }</span>


    /**
     * Returns the ReplaceHolder to track the replace of the specified
     * text.
     */
    ReplaceHolder getReplaceHolder(DocumentFilter.FilterBypass fb, int offset,
                                   int length, String text,
                                   AttributeSet attrs) {
<span class="nc bnc" id="L635" title="All 2 branches missed.">        if (replaceHolder == null) {</span>
<span class="nc" id="L636">            replaceHolder = new ReplaceHolder();</span>
        }
<span class="nc" id="L638">        replaceHolder.reset(fb, offset, length, text, attrs);</span>
<span class="nc" id="L639">        return replaceHolder;</span>
    }


    /**
     * ReplaceHolder is used to track where insert/remove/replace is
     * going to happen.
     */
<span class="nc" id="L647">    static class ReplaceHolder {</span>
        /** The FilterBypass that was passed to the DocumentFilter method. */
        DocumentFilter.FilterBypass fb;
        /** Offset where the remove/insert is going to occur. */
        int offset;
        /** Length of text to remove. */
        int length;
        /** The text to insert, may be null. */
        String text;
        /** AttributeSet to attach to text, may be null. */
        AttributeSet attrs;
        /** The resulting value, this may never be set. */
        Object value;
        /** Position the cursor should be adjusted from.  If this is -1
         * the cursor position will be adjusted based on the direction of
         * the replace (-1: offset, 1: offset + text.length()), otherwise
         * the cursor position is adusted from this position.
         */
        int cursorPosition;

        void reset(DocumentFilter.FilterBypass fb, int offset, int length,
                   String text, AttributeSet attrs) {
<span class="nc" id="L669">            this.fb = fb;</span>
<span class="nc" id="L670">            this.offset = offset;</span>
<span class="nc" id="L671">            this.length = length;</span>
<span class="nc" id="L672">            this.text = text;</span>
<span class="nc" id="L673">            this.attrs = attrs;</span>
<span class="nc" id="L674">            this.value = null;</span>
<span class="nc" id="L675">            cursorPosition = -1;</span>
<span class="nc" id="L676">        }</span>
    }


    /**
     * NavigationFilter implementation that calls back to methods with
     * same name in DefaultFormatter.
     */
<span class="nc" id="L684">    private class DefaultNavigationFilter extends NavigationFilter</span>
                             implements Serializable {
        public void setDot(FilterBypass fb, int dot, Position.Bias bias) {
<span class="nc" id="L687">            JTextComponent tc = DefaultFormatter.this.getFormattedTextField();</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">            if (tc.composedTextExists()) {</span>
                // bypass the filter
<span class="nc" id="L690">                fb.setDot(dot, bias);</span>
            } else {
<span class="nc" id="L692">                DefaultFormatter.this.setDot(fb, dot, bias);</span>
            }
<span class="nc" id="L694">        }</span>

        public void moveDot(FilterBypass fb, int dot, Position.Bias bias) {
<span class="nc" id="L697">            JTextComponent tc = DefaultFormatter.this.getFormattedTextField();</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">            if (tc.composedTextExists()) {</span>
                // bypass the filter
<span class="nc" id="L700">                fb.moveDot(dot, bias);</span>
            } else {
<span class="nc" id="L702">                DefaultFormatter.this.moveDot(fb, dot, bias);</span>
            }
<span class="nc" id="L704">        }</span>

        public int getNextVisualPositionFrom(JTextComponent text, int pos,
                                             Position.Bias bias,
                                             int direction,
                                             Position.Bias[] biasRet)
                                           throws BadLocationException {
<span class="nc bnc" id="L711" title="All 2 branches missed.">            if (text.composedTextExists()) {</span>
                // forward the call to the UI directly
<span class="nc" id="L713">                return text.getUI().getNextVisualPositionFrom(</span>
                        text, pos, bias, direction, biasRet);
            } else {
<span class="nc" id="L716">                return DefaultFormatter.this.getNextVisualPositionFrom(</span>
                        text, pos, bias, direction, biasRet);
            }
        }
    }


    /**
     * DocumentFilter implementation that calls back to the replace
     * method of DefaultFormatter.
     */
<span class="nc" id="L727">    private class DefaultDocumentFilter extends DocumentFilter implements</span>
                             Serializable {
        public void remove(FilterBypass fb, int offset, int length) throws
                              BadLocationException {
<span class="nc" id="L731">            JTextComponent tc = DefaultFormatter.this.getFormattedTextField();</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">            if (tc.composedTextExists()) {</span>
                // bypass the filter
<span class="nc" id="L734">                fb.remove(offset, length);</span>
            } else {
<span class="nc" id="L736">                DefaultFormatter.this.replace(fb, offset, length, null, null);</span>
            }
<span class="nc" id="L738">        }</span>

        public void insertString(FilterBypass fb, int offset,
                                 String string, AttributeSet attr) throws
                              BadLocationException {
<span class="nc" id="L743">            JTextComponent tc = DefaultFormatter.this.getFormattedTextField();</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (tc.composedTextExists() ||</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">                Utilities.isComposedTextAttributeDefined(attr)) {</span>
                // bypass the filter
<span class="nc" id="L747">                fb.insertString(offset, string, attr);</span>
            } else {
<span class="nc" id="L749">                DefaultFormatter.this.replace(fb, offset, 0, string, attr);</span>
            }
<span class="nc" id="L751">        }</span>

        public void replace(FilterBypass fb, int offset, int length,
                                 String text, AttributeSet attr) throws
                              BadLocationException {
<span class="nc" id="L756">            JTextComponent tc = DefaultFormatter.this.getFormattedTextField();</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            if (tc.composedTextExists() ||</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">                Utilities.isComposedTextAttributeDefined(attr)) {</span>
                // bypass the filter
<span class="nc" id="L760">                fb.replace(offset, length, text, attr);</span>
            } else {
<span class="nc" id="L762">                DefaultFormatter.this.replace(fb, offset, length, text, attr);</span>
            }
<span class="nc" id="L764">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>