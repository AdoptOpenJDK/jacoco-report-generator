<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JTextComponent.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">JTextComponent.java</span></div><h1>JTextComponent.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.lang.reflect.Method;

import java.security.AccessController;
import java.security.PrivilegedAction;

import java.beans.Transient;
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Enumeration;
import java.util.Vector;
import java.util.Map;

import java.util.concurrent.*;

import java.io.*;

import java.awt.*;
import java.awt.event.*;
import java.awt.print.*;
import java.awt.datatransfer.*;
import java.awt.im.InputContext;
import java.awt.im.InputMethodRequests;
import java.awt.font.TextHitInfo;
import java.awt.font.TextAttribute;

import java.awt.print.Printable;
import java.awt.print.PrinterException;

import javax.print.PrintService;
import javax.print.attribute.PrintRequestAttributeSet;

import java.text.*;
import java.text.AttributedCharacterIterator.Attribute;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.plaf.*;

import javax.accessibility.*;

import javax.print.attribute.*;

import sun.awt.AppContext;


import sun.swing.PrintingStatus;
import sun.swing.SwingUtilities2;
import sun.swing.text.TextComponentPrintable;
import sun.swing.SwingAccessor;

/**
 * &lt;code&gt;JTextComponent&lt;/code&gt; is the base class for swing text
 * components.  It tries to be compatible with the
 * &lt;code&gt;java.awt.TextComponent&lt;/code&gt; class
 * where it can reasonably do so.  Also provided are other services
 * for additional flexibility (beyond the pluggable UI and bean
 * support).
 * You can find information on how to use the functionality
 * this class provides in
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/generaltext.html&quot;&gt;General Rules for Using Text Components&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 *
 * &lt;p&gt;
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Caret Changes&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * The caret is a pluggable object in swing text components.
 * Notification of changes to the caret position and the selection
 * are sent to implementations of the &lt;code&gt;CaretListener&lt;/code&gt;
 * interface that have been registered with the text component.
 * The UI will install a default caret unless a customized caret
 * has been set. &lt;br&gt;
 * By default the caret tracks all the document changes
 * performed on the Event Dispatching Thread and updates it's position
 * accordingly if an insertion occurs before or at the caret position
 * or a removal occurs before the caret position. &lt;code&gt;DefaultCaret&lt;/code&gt;
 * tries to make itself visible which may lead to scrolling
 * of a text component within &lt;code&gt;JScrollPane&lt;/code&gt;. The default caret
 * behavior can be changed by the {@link DefaultCaret#setUpdatePolicy} method.
 * &lt;br&gt;
 * &lt;b&gt;Note&lt;/b&gt;: Non-editable text components also have a caret though
 * it may not be painted.
 *
 * &lt;p&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Commands&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * Text components provide a number of commands that can be used
 * to manipulate the component.  This is essentially the way that
 * the component expresses its capabilities.  These are expressed
 * in terms of the swing &lt;code&gt;Action&lt;/code&gt; interface,
 * using the &lt;code&gt;TextAction&lt;/code&gt; implementation.
 * The set of commands supported by the text component can be
 * found with the {@link #getActions} method.  These actions
 * can be bound to key events, fired from buttons, etc.
 *
 * &lt;p&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Text Input&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * The text components support flexible and internationalized text input, using
 * keymaps and the input method framework, while maintaining compatibility with
 * the AWT listener model.
 * &lt;p&gt;
 * A {@link javax.swing.text.Keymap} lets an application bind key
 * strokes to actions.
 * In order to allow keymaps to be shared across multiple text components, they
 * can use actions that extend &lt;code&gt;TextAction&lt;/code&gt;.
 * &lt;code&gt;TextAction&lt;/code&gt; can determine which &lt;code&gt;JTextComponent&lt;/code&gt;
 * most recently has or had focus and therefore is the subject of
 * the action (In the case that the &lt;code&gt;ActionEvent&lt;/code&gt;
 * sent to the action doesn't contain the target text component as its source).
 * &lt;p&gt;
 * The &lt;a href=&quot;../../../../technotes/guides/imf/spec.html&quot;&gt;input method framework&lt;/a&gt;
 * lets text components interact with input methods, separate software
 * components that preprocess events to let users enter thousands of
 * different characters using keyboards with far fewer keys.
 * &lt;code&gt;JTextComponent&lt;/code&gt; is an &lt;em&gt;active client&lt;/em&gt; of
 * the framework, so it implements the preferred user interface for interacting
 * with input methods. As a consequence, some key events do not reach the text
 * component because they are handled by an input method, and some text input
 * reaches the text component as committed text within an {@link
 * java.awt.event.InputMethodEvent} instead of as a key event.
 * The complete text input is the combination of the characters in
 * &lt;code&gt;keyTyped&lt;/code&gt; key events and committed text in input method events.
 * &lt;p&gt;
 * The AWT listener model lets applications attach event listeners to
 * components in order to bind events to actions. Swing encourages the
 * use of keymaps instead of listeners, but maintains compatibility
 * with listeners by giving the listeners a chance to steal an event
 * by consuming it.
 * &lt;p&gt;
 * Keyboard event and input method events are handled in the following stages,
 * with each stage capable of consuming the event:
 *
 * &lt;table border=1 summary=&quot;Stages of keyboard and input method event handling&quot;&gt;
 * &lt;tr&gt;
 * &lt;th id=&quot;stage&quot;&gt;&lt;p style=&quot;text-align:left&quot;&gt;Stage&lt;/p&gt;&lt;/th&gt;
 * &lt;th id=&quot;ke&quot;&gt;&lt;p style=&quot;text-align:left&quot;&gt;KeyEvent&lt;/p&gt;&lt;/th&gt;
 * &lt;th id=&quot;ime&quot;&gt;&lt;p style=&quot;text-align:left&quot;&gt;InputMethodEvent&lt;/p&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td headers=&quot;stage&quot;&gt;1.   &lt;/td&gt;
 *     &lt;td headers=&quot;ke&quot;&gt;input methods &lt;/td&gt;
 *     &lt;td headers=&quot;ime&quot;&gt;(generated here)&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td headers=&quot;stage&quot;&gt;2.   &lt;/td&gt;
 *     &lt;td headers=&quot;ke&quot;&gt;focus manager &lt;/td&gt;
 *     &lt;td headers=&quot;ime&quot;&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td headers=&quot;stage&quot;&gt;3.   &lt;/td&gt;
 *     &lt;td headers=&quot;ke&quot;&gt;registered key listeners&lt;/td&gt;
 *     &lt;td headers=&quot;ime&quot;&gt;registered input method listeners&lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td headers=&quot;stage&quot;&gt;4.   &lt;/td&gt;
 *     &lt;td headers=&quot;ke&quot;&gt;&lt;/td&gt;
 *     &lt;td headers=&quot;ime&quot;&gt;input method handling in JTextComponent&lt;/tr&gt;
 * &lt;tr&gt;
 *     &lt;td headers=&quot;stage&quot;&gt;5.   &lt;/td&gt;&lt;td headers=&quot;ke ime&quot; colspan=2&gt;keymap handling using the current keymap&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td headers=&quot;stage&quot;&gt;6.   &lt;/td&gt;&lt;td headers=&quot;ke&quot;&gt;keyboard handling in JComponent (e.g. accelerators, component navigation, etc.)&lt;/td&gt;
 *     &lt;td headers=&quot;ime&quot;&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;
 * To maintain compatibility with applications that listen to key
 * events but are not aware of input method events, the input
 * method handling in stage 4 provides a compatibility mode for
 * components that do not process input method events. For these
 * components, the committed text is converted to keyTyped key events
 * and processed in the key event pipeline starting at stage 3
 * instead of in the input method event pipeline.
 * &lt;p&gt;
 * By default the component will create a keymap (named &lt;b&gt;DEFAULT_KEYMAP&lt;/b&gt;)
 * that is shared by all JTextComponent instances as the default keymap.
 * Typically a look-and-feel implementation will install a different keymap
 * that resolves to the default keymap for those bindings not found in the
 * different keymap. The minimal bindings include:
 * &lt;ul&gt;
 * &lt;li&gt;inserting content into the editor for the
 *  printable keys.
 * &lt;li&gt;removing content with the backspace and del
 *  keys.
 * &lt;li&gt;caret movement forward and backward
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Model/View Split&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * The text components have a model-view split.  A text component pulls
 * together the objects used to represent the model, view, and controller.
 * The text document model may be shared by other views which act as observers
 * of the model (e.g. a document may be shared by multiple components).
 *
 * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/editor.gif&quot; alt=&quot;Diagram showing interaction between Controller, Document, events, and ViewFactory&quot;
 *                  HEIGHT=358 WIDTH=587&gt;&lt;/p&gt;
 *
 * &lt;p&gt;
 * The model is defined by the {@link Document} interface.
 * This is intended to provide a flexible text storage mechanism
 * that tracks change during edits and can be extended to more sophisticated
 * models.  The model interfaces are meant to capture the capabilities of
 * expression given by SGML, a system used to express a wide variety of
 * content.
 * Each modification to the document causes notification of the
 * details of the change to be sent to all observers in the form of a
 * {@link DocumentEvent} which allows the views to stay up to date with the model.
 * This event is sent to observers that have implemented the
 * {@link DocumentListener}
 * interface and registered interest with the model being observed.
 *
 * &lt;p&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Location Information&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * The capability of determining the location of text in
 * the view is provided.  There are two methods, {@link #modelToView}
 * and {@link #viewToModel} for determining this information.
 *
 * &lt;p&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Undo/Redo support&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * Support for an edit history mechanism is provided to allow
 * undo/redo operations.  The text component does not itself
 * provide the history buffer by default, but does provide
 * the &lt;code&gt;UndoableEdit&lt;/code&gt; records that can be used in conjunction
 * with a history buffer to provide the undo/redo support.
 * The support is provided by the Document model, which allows
 * one to attach UndoableEditListener implementations.
 *
 * &lt;p&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Thread Safety&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * The swing text components provide some support of thread
 * safe operations.  Because of the high level of configurability
 * of the text components, it is possible to circumvent the
 * protection provided.  The protection primarily comes from
 * the model, so the documentation of &lt;code&gt;AbstractDocument&lt;/code&gt;
 * describes the assumptions of the protection provided.
 * The methods that are safe to call asynchronously are marked
 * with comments.
 *
 * &lt;p&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Newlines&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * For a discussion on how newlines are handled, see
 * &lt;a href=&quot;DefaultEditorKit.html&quot;&gt;DefaultEditorKit&lt;/a&gt;.
 *
 * &lt;p&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Printing support&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * Several {@link #print print} methods are provided for basic
 * document printing.  If more advanced printing is needed, use the
 * {@link #getPrintable} method.
 * &lt;/dl&gt;
 *
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @beaninfo
 *     attribute: isContainer false
 *
 * @author  Timothy Prinzing
 * @author Igor Kushnirskiy (printing support)
 * @see Document
 * @see DocumentEvent
 * @see DocumentListener
 * @see Caret
 * @see CaretEvent
 * @see CaretListener
 * @see TextUI
 * @see View
 * @see ViewFactory
 */
public abstract class JTextComponent extends JComponent implements Scrollable, Accessible
{
    /**
     * Creates a new &lt;code&gt;JTextComponent&lt;/code&gt;.
     * Listeners for caret events are established, and the pluggable
     * UI installed.  The component is marked as editable.  No layout manager
     * is used, because layout is managed by the view subsystem of text.
     * The document model is set to &lt;code&gt;null&lt;/code&gt;.
     */
    public JTextComponent() {
<span class="nc" id="L313">        super();</span>
        // enable InputMethodEvent for on-the-spot pre-editing
<span class="nc" id="L315">        enableEvents(AWTEvent.KEY_EVENT_MASK | AWTEvent.INPUT_METHOD_EVENT_MASK);</span>
<span class="nc" id="L316">        caretEvent = new MutableCaretEvent(this);</span>
<span class="nc" id="L317">        addMouseListener(caretEvent);</span>
<span class="nc" id="L318">        addFocusListener(caretEvent);</span>
<span class="nc" id="L319">        setEditable(true);</span>
<span class="nc" id="L320">        setDragEnabled(false);</span>
<span class="nc" id="L321">        setLayout(null); // layout is managed by View hierarchy</span>
<span class="nc" id="L322">        updateUI();</span>
<span class="nc" id="L323">    }</span>

    /**
     * Fetches the user-interface factory for this text-oriented editor.
     *
     * @return the factory
     */
<span class="nc" id="L330">    public TextUI getUI() { return (TextUI)ui; }</span>

    /**
     * Sets the user-interface factory for this text-oriented editor.
     *
     * @param ui the factory
     */
    public void setUI(TextUI ui) {
<span class="nc" id="L338">        super.setUI(ui);</span>
<span class="nc" id="L339">    }</span>

    /**
     * Reloads the pluggable UI.  The key used to fetch the
     * new interface is &lt;code&gt;getUIClassID()&lt;/code&gt;.  The type of
     * the UI is &lt;code&gt;TextUI&lt;/code&gt;.  &lt;code&gt;invalidate&lt;/code&gt;
     * is called after setting the UI.
     */
    public void updateUI() {
<span class="nc" id="L348">        setUI((TextUI)UIManager.getUI(this));</span>
<span class="nc" id="L349">        invalidate();</span>
<span class="nc" id="L350">    }</span>

    /**
     * Adds a caret listener for notification of any changes
     * to the caret.
     *
     * @param listener the listener to be added
     * @see javax.swing.event.CaretEvent
     */
    public void addCaretListener(CaretListener listener) {
<span class="nc" id="L360">        listenerList.add(CaretListener.class, listener);</span>
<span class="nc" id="L361">    }</span>

    /**
     * Removes a caret listener.
     *
     * @param listener the listener to be removed
     * @see javax.swing.event.CaretEvent
     */
    public void removeCaretListener(CaretListener listener) {
<span class="nc" id="L370">        listenerList.remove(CaretListener.class, listener);</span>
<span class="nc" id="L371">    }</span>

    /**
     * Returns an array of all the caret listeners
     * registered on this text component.
     *
     * @return all of this component's &lt;code&gt;CaretListener&lt;/code&gt;s
     *         or an empty
     *         array if no caret listeners are currently registered
     *
     * @see #addCaretListener
     * @see #removeCaretListener
     *
     * @since 1.4
     */
    public CaretListener[] getCaretListeners() {
<span class="nc" id="L387">        return listenerList.getListeners(CaretListener.class);</span>
    }

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.  The listener list is processed in a
     * last-to-first manner.
     *
     * @param e the event
     * @see EventListenerList
     */
    protected void fireCaretUpdate(CaretEvent e) {
        // Guaranteed to return a non-null array
<span class="nc" id="L402">        Object[] listeners = listenerList.getListenerList();</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L405" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            if (listeners[i]==CaretListener.class) {</span>
<span class="nc" id="L407">                ((CaretListener)listeners[i+1]).caretUpdate(e);</span>
            }
        }
<span class="nc" id="L410">    }</span>

    /**
     * Associates the editor with a text document.
     * The currently registered factory is used to build a view for
     * the document, which gets displayed by the editor after revalidation.
     * A PropertyChange event (&quot;document&quot;) is propagated to each listener.
     *
     * @param doc  the document to display/edit
     * @see #getDocument
     * @beaninfo
     *  description: the text document model
     *        bound: true
     *       expert: true
     */
    public void setDocument(Document doc) {
<span class="nc" id="L426">        Document old = model;</span>

        /*
         * acquire a read lock on the old model to prevent notification of
         * mutations while we disconnecting the old model.
         */
        try {
<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (old instanceof AbstractDocument) {</span>
<span class="nc" id="L434">                ((AbstractDocument)old).readLock();</span>
            }
<span class="nc bnc" id="L436" title="All 2 branches missed.">            if (accessibleContext != null) {</span>
<span class="nc" id="L437">                model.removeDocumentListener(</span>
                    ((AccessibleJTextComponent)accessibleContext));
            }
<span class="nc bnc" id="L440" title="All 2 branches missed.">            if (inputMethodRequestsHandler != null) {</span>
<span class="nc" id="L441">                model.removeDocumentListener((DocumentListener)inputMethodRequestsHandler);</span>
            }
<span class="nc" id="L443">            model = doc;</span>

            // Set the document's run direction property to match the
            // component's ComponentOrientation property.
<span class="nc bnc" id="L447" title="All 2 branches missed.">            Boolean runDir = getComponentOrientation().isLeftToRight()</span>
                             ? TextAttribute.RUN_DIRECTION_LTR
                             : TextAttribute.RUN_DIRECTION_RTL;
<span class="nc bnc" id="L450" title="All 2 branches missed.">            if (runDir != doc.getProperty(TextAttribute.RUN_DIRECTION)) {</span>
<span class="nc" id="L451">                doc.putProperty(TextAttribute.RUN_DIRECTION, runDir );</span>
            }
<span class="nc" id="L453">            firePropertyChange(&quot;document&quot;, old, doc);</span>
        } finally {
<span class="nc bnc" id="L455" title="All 4 branches missed.">            if (old instanceof AbstractDocument) {</span>
<span class="nc" id="L456">                ((AbstractDocument)old).readUnlock();</span>
            }
        }

<span class="nc" id="L460">        revalidate();</span>
<span class="nc" id="L461">        repaint();</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (accessibleContext != null) {</span>
<span class="nc" id="L463">            model.addDocumentListener(</span>
                ((AccessibleJTextComponent)accessibleContext));
        }
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (inputMethodRequestsHandler != null) {</span>
<span class="nc" id="L467">            model.addDocumentListener((DocumentListener)inputMethodRequestsHandler);</span>
        }
<span class="nc" id="L469">    }</span>

    /**
     * Fetches the model associated with the editor.  This is
     * primarily for the UI to get at the minimal amount of
     * state required to be a text editor.  Subclasses will
     * return the actual type of the model which will typically
     * be something that extends Document.
     *
     * @return the model
     */
    public Document getDocument() {
<span class="nc" id="L481">        return model;</span>
    }

    // Override of Component.setComponentOrientation
    public void setComponentOrientation( ComponentOrientation o ) {
        // Set the document's run direction property to match the
        // ComponentOrientation property.
<span class="nc" id="L488">        Document doc = getDocument();</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">        if( doc !=  null ) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">            Boolean runDir = o.isLeftToRight()</span>
                             ? TextAttribute.RUN_DIRECTION_LTR
                             : TextAttribute.RUN_DIRECTION_RTL;
<span class="nc" id="L493">            doc.putProperty( TextAttribute.RUN_DIRECTION, runDir );</span>
        }
<span class="nc" id="L495">        super.setComponentOrientation( o );</span>
<span class="nc" id="L496">    }</span>

    /**
     * Fetches the command list for the editor.  This is
     * the list of commands supported by the plugged-in UI
     * augmented by the collection of commands that the
     * editor itself supports.  These are useful for binding
     * to events, such as in a keymap.
     *
     * @return the command list
     */
    public Action[] getActions() {
<span class="nc" id="L508">        return getUI().getEditorKit(this).getActions();</span>
    }

    /**
     * Sets margin space between the text component's border
     * and its text.  The text component's default &lt;code&gt;Border&lt;/code&gt;
     * object will use this value to create the proper margin.
     * However, if a non-default border is set on the text component,
     * it is that &lt;code&gt;Border&lt;/code&gt; object's responsibility to create the
     * appropriate margin space (else this property will effectively
     * be ignored).  This causes a redraw of the component.
     * A PropertyChange event (&quot;margin&quot;) is sent to all listeners.
     *
     * @param m the space between the border and the text
     * @beaninfo
     *  description: desired space between the border and text area
     *        bound: true
     */
    public void setMargin(Insets m) {
<span class="nc" id="L527">        Insets old = margin;</span>
<span class="nc" id="L528">        margin = m;</span>
<span class="nc" id="L529">        firePropertyChange(&quot;margin&quot;, old, m);</span>
<span class="nc" id="L530">        invalidate();</span>
<span class="nc" id="L531">    }</span>

    /**
     * Returns the margin between the text component's border and
     * its text.
     *
     * @return the margin
     */
    public Insets getMargin() {
<span class="nc" id="L540">        return margin;</span>
    }

    /**
     * Sets the &lt;code&gt;NavigationFilter&lt;/code&gt;. &lt;code&gt;NavigationFilter&lt;/code&gt;
     * is used by &lt;code&gt;DefaultCaret&lt;/code&gt; and the default cursor movement
     * actions as a way to restrict the cursor movement.
     *
     * @since 1.4
     */
    public void setNavigationFilter(NavigationFilter filter) {
<span class="nc" id="L551">        navigationFilter = filter;</span>
<span class="nc" id="L552">    }</span>

    /**
     * Returns the &lt;code&gt;NavigationFilter&lt;/code&gt;. &lt;code&gt;NavigationFilter&lt;/code&gt;
     * is used by &lt;code&gt;DefaultCaret&lt;/code&gt; and the default cursor movement
     * actions as a way to restrict the cursor movement. A null return value
     * implies the cursor movement and selection should not be restricted.
     *
     * @since 1.4
     * @return the NavigationFilter
     */
    public NavigationFilter getNavigationFilter() {
<span class="nc" id="L564">        return navigationFilter;</span>
    }

    /**
     * Fetches the caret that allows text-oriented navigation over
     * the view.
     *
     * @return the caret
     */
    @Transient
    public Caret getCaret() {
<span class="nc" id="L575">        return caret;</span>
    }

    /**
     * Sets the caret to be used.  By default this will be set
     * by the UI that gets installed.  This can be changed to
     * a custom caret if desired.  Setting the caret results in a
     * PropertyChange event (&quot;caret&quot;) being fired.
     *
     * @param c the caret
     * @see #getCaret
     * @beaninfo
     *  description: the caret used to select/navigate
     *        bound: true
     *       expert: true
     */
    public void setCaret(Caret c) {
<span class="nc bnc" id="L592" title="All 2 branches missed.">        if (caret != null) {</span>
<span class="nc" id="L593">            caret.removeChangeListener(caretEvent);</span>
<span class="nc" id="L594">            caret.deinstall(this);</span>
        }
<span class="nc" id="L596">        Caret old = caret;</span>
<span class="nc" id="L597">        caret = c;</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">        if (caret != null) {</span>
<span class="nc" id="L599">            caret.install(this);</span>
<span class="nc" id="L600">            caret.addChangeListener(caretEvent);</span>
        }
<span class="nc" id="L602">        firePropertyChange(&quot;caret&quot;, old, caret);</span>
<span class="nc" id="L603">    }</span>

    /**
     * Fetches the object responsible for making highlights.
     *
     * @return the highlighter
     */
    public Highlighter getHighlighter() {
<span class="nc" id="L611">        return highlighter;</span>
    }

    /**
     * Sets the highlighter to be used.  By default this will be set
     * by the UI that gets installed.  This can be changed to
     * a custom highlighter if desired.  The highlighter can be set to
     * &lt;code&gt;null&lt;/code&gt; to disable it.
     * A PropertyChange event (&quot;highlighter&quot;) is fired
     * when a new highlighter is installed.
     *
     * @param h the highlighter
     * @see #getHighlighter
     * @beaninfo
     *  description: object responsible for background highlights
     *        bound: true
     *       expert: true
     */
    public void setHighlighter(Highlighter h) {
<span class="nc bnc" id="L630" title="All 2 branches missed.">        if (highlighter != null) {</span>
<span class="nc" id="L631">            highlighter.deinstall(this);</span>
        }
<span class="nc" id="L633">        Highlighter old = highlighter;</span>
<span class="nc" id="L634">        highlighter = h;</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">        if (highlighter != null) {</span>
<span class="nc" id="L636">            highlighter.install(this);</span>
        }
<span class="nc" id="L638">        firePropertyChange(&quot;highlighter&quot;, old, h);</span>
<span class="nc" id="L639">    }</span>

    /**
     * Sets the keymap to use for binding events to
     * actions.  Setting to &lt;code&gt;null&lt;/code&gt; effectively disables
     * keyboard input.
     * A PropertyChange event (&quot;keymap&quot;) is fired when a new keymap
     * is installed.
     *
     * @param map the keymap
     * @see #getKeymap
     * @beaninfo
     *  description: set of key event to action bindings to use
     *        bound: true
     */
    public void setKeymap(Keymap map) {
<span class="nc" id="L655">        Keymap old = keymap;</span>
<span class="nc" id="L656">        keymap = map;</span>
<span class="nc" id="L657">        firePropertyChange(&quot;keymap&quot;, old, keymap);</span>
<span class="nc" id="L658">        updateInputMap(old, map);</span>
<span class="nc" id="L659">    }</span>

    /**
     * Turns on or off automatic drag handling. In order to enable automatic
     * drag handling, this property should be set to {@code true}, and the
     * component's {@code TransferHandler} needs to be {@code non-null}.
     * The default value of the {@code dragEnabled} property is {@code false}.
     * &lt;p&gt;
     * The job of honoring this property, and recognizing a user drag gesture,
     * lies with the look and feel implementation, and in particular, the component's
     * {@code TextUI}. When automatic drag handling is enabled, most look and
     * feels (including those that subclass {@code BasicLookAndFeel}) begin a
     * drag and drop operation whenever the user presses the mouse button over
     * a selection and then moves the mouse a few pixels. Setting this property to
     * {@code true} can therefore have a subtle effect on how selections behave.
     * &lt;p&gt;
     * If a look and feel is used that ignores this property, you can still
     * begin a drag and drop operation by calling {@code exportAsDrag} on the
     * component's {@code TransferHandler}.
     *
     * @param b whether or not to enable automatic drag handling
     * @exception HeadlessException if
     *            &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and
     *            &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt;
     *            returns &lt;code&gt;true&lt;/code&gt;
     * @see java.awt.GraphicsEnvironment#isHeadless
     * @see #getDragEnabled
     * @see #setTransferHandler
     * @see TransferHandler
     * @since 1.4
     *
     * @beaninfo
     *  description: determines whether automatic drag handling is enabled
     *        bound: false
     */
    public void setDragEnabled(boolean b) {
<span class="nc bnc" id="L695" title="All 4 branches missed.">        if (b &amp;&amp; GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L696">            throw new HeadlessException();</span>
        }
<span class="nc" id="L698">        dragEnabled = b;</span>
<span class="nc" id="L699">    }</span>

    /**
     * Returns whether or not automatic drag handling is enabled.
     *
     * @return the value of the {@code dragEnabled} property
     * @see #setDragEnabled
     * @since 1.4
     */
    public boolean getDragEnabled() {
<span class="nc" id="L709">        return dragEnabled;</span>
    }

    /**
     * Sets the drop mode for this component. For backward compatibility,
     * the default for this property is &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;.
     * Usage of &lt;code&gt;DropMode.INSERT&lt;/code&gt; is recommended, however,
     * for an improved user experience. It offers similar behavior of dropping
     * between text locations, but does so without affecting the actual text
     * selection and caret location.
     * &lt;p&gt;
     * &lt;code&gt;JTextComponents&lt;/code&gt; support the following drop modes:
     * &lt;ul&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.INSERT&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The drop mode is only meaningful if this component has a
     * &lt;code&gt;TransferHandler&lt;/code&gt; that accepts drops.
     *
     * @param dropMode the drop mode to use
     * @throws IllegalArgumentException if the drop mode is unsupported
     *         or &lt;code&gt;null&lt;/code&gt;
     * @see #getDropMode
     * @see #getDropLocation
     * @see #setTransferHandler
     * @see javax.swing.TransferHandler
     * @since 1.6
     */
    public final void setDropMode(DropMode dropMode) {
<span class="nc bnc" id="L739" title="All 2 branches missed.">        if (dropMode != null) {</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">            switch (dropMode) {</span>
                case USE_SELECTION:
                case INSERT:
<span class="nc" id="L743">                    this.dropMode = dropMode;</span>
<span class="nc" id="L744">                    return;</span>
            }
        }

<span class="nc" id="L748">        throw new IllegalArgumentException(dropMode + &quot;: Unsupported drop mode for text&quot;);</span>
    }

    /**
     * Returns the drop mode for this component.
     *
     * @return the drop mode for this component
     * @see #setDropMode
     * @since 1.6
     */
    public final DropMode getDropMode() {
<span class="nc" id="L759">        return dropMode;</span>
    }

    static {
<span class="nc" id="L763">        SwingAccessor.setJTextComponentAccessor(</span>
<span class="nc" id="L764">            new SwingAccessor.JTextComponentAccessor() {</span>
                public TransferHandler.DropLocation dropLocationForPoint(JTextComponent textComp,
                                                                         Point p)
                {
<span class="nc" id="L768">                    return textComp.dropLocationForPoint(p);</span>
                }
                public Object setDropLocation(JTextComponent textComp,
                                              TransferHandler.DropLocation location,
                                              Object state, boolean forDrop)
                {
<span class="nc" id="L774">                    return textComp.setDropLocation(location, state, forDrop);</span>
                }
            });
    }


    /**
     * Calculates a drop location in this component, representing where a
     * drop at the given point should insert data.
     * &lt;p&gt;
     * Note: This method is meant to override
     * &lt;code&gt;JComponent.dropLocationForPoint()&lt;/code&gt;, which is package-private
     * in javax.swing. &lt;code&gt;TransferHandler&lt;/code&gt; will detect text components
     * and call this method instead via reflection. It's name should therefore
     * not be changed.
     *
     * @param p the point to calculate a drop location for
     * @return the drop location, or &lt;code&gt;null&lt;/code&gt;
     */
    DropLocation dropLocationForPoint(Point p) {
<span class="nc" id="L794">        Position.Bias[] bias = new Position.Bias[1];</span>
<span class="nc" id="L795">        int index = getUI().viewToModel(this, p, bias);</span>

        // viewToModel currently returns null for some HTML content
        // when the point is within the component's top inset
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (bias[0] == null) {</span>
<span class="nc" id="L800">            bias[0] = Position.Bias.Forward;</span>
        }

<span class="nc" id="L803">        return new DropLocation(p, index, bias[0]);</span>
    }

    /**
     * Called to set or clear the drop location during a DnD operation.
     * In some cases, the component may need to use it's internal selection
     * temporarily to indicate the drop location. To help facilitate this,
     * this method returns and accepts as a parameter a state object.
     * This state object can be used to store, and later restore, the selection
     * state. Whatever this method returns will be passed back to it in
     * future calls, as the state parameter. If it wants the DnD system to
     * continue storing the same state, it must pass it back every time.
     * Here's how this is used:
     * &lt;p&gt;
     * Let's say that on the first call to this method the component decides
     * to save some state (because it is about to use the selection to show
     * a drop index). It can return a state object to the caller encapsulating
     * any saved selection state. On a second call, let's say the drop location
     * is being changed to something else. The component doesn't need to
     * restore anything yet, so it simply passes back the same state object
     * to have the DnD system continue storing it. Finally, let's say this
     * method is messaged with &lt;code&gt;null&lt;/code&gt;. This means DnD
     * is finished with this component for now, meaning it should restore
     * state. At this point, it can use the state parameter to restore
     * said state, and of course return &lt;code&gt;null&lt;/code&gt; since there's
     * no longer anything to store.
     * &lt;p&gt;
     * Note: This method is meant to override
     * &lt;code&gt;JComponent.setDropLocation()&lt;/code&gt;, which is package-private
     * in javax.swing. &lt;code&gt;TransferHandler&lt;/code&gt; will detect text components
     * and call this method instead via reflection. It's name should therefore
     * not be changed.
     *
     * @param location the drop location (as calculated by
     *        &lt;code&gt;dropLocationForPoint&lt;/code&gt;) or &lt;code&gt;null&lt;/code&gt;
     *        if there's no longer a valid drop location
     * @param state the state object saved earlier for this component,
     *        or &lt;code&gt;null&lt;/code&gt;
     * @param forDrop whether or not the method is being called because an
     *        actual drop occurred
     * @return any saved state for this component, or &lt;code&gt;null&lt;/code&gt; if none
     */
    Object setDropLocation(TransferHandler.DropLocation location,
                           Object state,
                           boolean forDrop) {

<span class="nc" id="L849">        Object retVal = null;</span>
<span class="nc" id="L850">        DropLocation textLocation = (DropLocation)location;</span>

<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (dropMode == DropMode.USE_SELECTION) {</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">            if (textLocation == null) {</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">                if (state != null) {</span>
                    /*
                     * This object represents the state saved earlier.
                     *     If the caret is a DefaultCaret it will be
                     *     an Object array containing, in order:
                     *         - the saved caret mark (Integer)
                     *         - the saved caret dot (Integer)
                     *         - the saved caret visibility (Boolean)
                     *         - the saved mark bias (Position.Bias)
                     *         - the saved dot bias (Position.Bias)
                     *     If the caret is not a DefaultCaret it will
                     *     be similar, but will not contain the dot
                     *     or mark bias.
                     */
<span class="nc" id="L868">                    Object[] vals = (Object[])state;</span>

<span class="nc bnc" id="L870" title="All 2 branches missed.">                    if (!forDrop) {</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">                        if (caret instanceof DefaultCaret) {</span>
<span class="nc" id="L872">                            ((DefaultCaret)caret).setDot(((Integer)vals[0]).intValue(),</span>
                                                         (Position.Bias)vals[3]);
<span class="nc" id="L874">                            ((DefaultCaret)caret).moveDot(((Integer)vals[1]).intValue(),</span>
                                                         (Position.Bias)vals[4]);
                        } else {
<span class="nc" id="L877">                            caret.setDot(((Integer)vals[0]).intValue());</span>
<span class="nc" id="L878">                            caret.moveDot(((Integer)vals[1]).intValue());</span>
                        }
                    }

<span class="nc" id="L882">                    caret.setVisible(((Boolean)vals[2]).booleanValue());</span>
<span class="nc" id="L883">                }</span>
            } else {
<span class="nc bnc" id="L885" title="All 2 branches missed.">                if (dropLocation == null) {</span>
                    boolean visible;

<span class="nc bnc" id="L888" title="All 2 branches missed.">                    if (caret instanceof DefaultCaret) {</span>
<span class="nc" id="L889">                        DefaultCaret dc = (DefaultCaret)caret;</span>
<span class="nc" id="L890">                        visible = dc.isActive();</span>
<span class="nc" id="L891">                        retVal = new Object[] {Integer.valueOf(dc.getMark()),</span>
<span class="nc" id="L892">                                               Integer.valueOf(dc.getDot()),</span>
<span class="nc" id="L893">                                               Boolean.valueOf(visible),</span>
<span class="nc" id="L894">                                               dc.getMarkBias(),</span>
<span class="nc" id="L895">                                               dc.getDotBias()};</span>
<span class="nc" id="L896">                    } else {</span>
<span class="nc" id="L897">                        visible = caret.isVisible();</span>
<span class="nc" id="L898">                        retVal = new Object[] {Integer.valueOf(caret.getMark()),</span>
<span class="nc" id="L899">                                               Integer.valueOf(caret.getDot()),</span>
<span class="nc" id="L900">                                               Boolean.valueOf(visible)};</span>
                    }

<span class="nc" id="L903">                    caret.setVisible(true);</span>
<span class="nc" id="L904">                } else {</span>
<span class="nc" id="L905">                    retVal = state;</span>
                }

<span class="nc bnc" id="L908" title="All 2 branches missed.">                if (caret instanceof DefaultCaret) {</span>
<span class="nc" id="L909">                    ((DefaultCaret)caret).setDot(textLocation.getIndex(), textLocation.getBias());</span>
                } else {
<span class="nc" id="L911">                    caret.setDot(textLocation.getIndex());</span>
                }
            }
        } else {
<span class="nc bnc" id="L915" title="All 2 branches missed.">            if (textLocation == null) {</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">                if (state != null) {</span>
<span class="nc" id="L917">                    caret.setVisible(((Boolean)state).booleanValue());</span>
                }
            } else {
<span class="nc bnc" id="L920" title="All 2 branches missed.">                if (dropLocation == null) {</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">                    boolean visible = caret instanceof DefaultCaret</span>
<span class="nc" id="L922">                                      ? ((DefaultCaret)caret).isActive()</span>
<span class="nc" id="L923">                                      : caret.isVisible();</span>
<span class="nc" id="L924">                    retVal = Boolean.valueOf(visible);</span>
<span class="nc" id="L925">                    caret.setVisible(false);</span>
<span class="nc" id="L926">                } else {</span>
<span class="nc" id="L927">                    retVal = state;</span>
                }
            }
        }

<span class="nc" id="L932">        DropLocation old = dropLocation;</span>
<span class="nc" id="L933">        dropLocation = textLocation;</span>
<span class="nc" id="L934">        firePropertyChange(&quot;dropLocation&quot;, old, dropLocation);</span>

<span class="nc" id="L936">        return retVal;</span>
    }

    /**
     * Returns the location that this component should visually indicate
     * as the drop location during a DnD operation over the component,
     * or {@code null} if no location is to currently be shown.
     * &lt;p&gt;
     * This method is not meant for querying the drop location
     * from a {@code TransferHandler}, as the drop location is only
     * set after the {@code TransferHandler}'s &lt;code&gt;canImport&lt;/code&gt;
     * has returned and has allowed for the location to be shown.
     * &lt;p&gt;
     * When this property changes, a property change event with
     * name &quot;dropLocation&quot; is fired by the component.
     *
     * @return the drop location
     * @see #setDropMode
     * @see TransferHandler#canImport(TransferHandler.TransferSupport)
     * @since 1.6
     */
    public final DropLocation getDropLocation() {
<span class="nc" id="L958">        return dropLocation;</span>
    }


    /**
     * Updates the &lt;code&gt;InputMap&lt;/code&gt;s in response to a
     * &lt;code&gt;Keymap&lt;/code&gt; change.
     * @param oldKm  the old &lt;code&gt;Keymap&lt;/code&gt;
     * @param newKm  the new &lt;code&gt;Keymap&lt;/code&gt;
     */
    void updateInputMap(Keymap oldKm, Keymap newKm) {
        // Locate the current KeymapWrapper.
<span class="nc" id="L970">        InputMap km = getInputMap(JComponent.WHEN_FOCUSED);</span>
<span class="nc" id="L971">        InputMap last = km;</span>
<span class="nc bnc" id="L972" title="All 4 branches missed.">        while (km != null &amp;&amp; !(km instanceof KeymapWrapper)) {</span>
<span class="nc" id="L973">            last = km;</span>
<span class="nc" id="L974">            km = km.getParent();</span>
        }
<span class="nc bnc" id="L976" title="All 2 branches missed.">        if (km != null) {</span>
            // Found it, tweak the InputMap that points to it, as well
            // as anything it points to.
<span class="nc bnc" id="L979" title="All 2 branches missed.">            if (newKm == null) {</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">                if (last != km) {</span>
<span class="nc" id="L981">                    last.setParent(km.getParent());</span>
                }
                else {
<span class="nc" id="L984">                    last.setParent(null);</span>
                }
            }
            else {
<span class="nc" id="L988">                InputMap newKM = new KeymapWrapper(newKm);</span>
<span class="nc" id="L989">                last.setParent(newKM);</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">                if (last != km) {</span>
<span class="nc" id="L991">                    newKM.setParent(km.getParent());</span>
                }
<span class="nc" id="L993">            }</span>
        }
<span class="nc bnc" id="L995" title="All 2 branches missed.">        else if (newKm != null) {</span>
<span class="nc" id="L996">            km = getInputMap(JComponent.WHEN_FOCUSED);</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">            if (km != null) {</span>
                // Couldn't find it.
                // Set the parent of WHEN_FOCUSED InputMap to be the new one.
<span class="nc" id="L1000">                InputMap newKM = new KeymapWrapper(newKm);</span>
<span class="nc" id="L1001">                newKM.setParent(km.getParent());</span>
<span class="nc" id="L1002">                km.setParent(newKM);</span>
            }
        }

        // Do the same thing with the ActionMap
<span class="nc" id="L1007">        ActionMap am = getActionMap();</span>
<span class="nc" id="L1008">        ActionMap lastAM = am;</span>
<span class="nc bnc" id="L1009" title="All 4 branches missed.">        while (am != null &amp;&amp; !(am instanceof KeymapActionMap)) {</span>
<span class="nc" id="L1010">            lastAM = am;</span>
<span class="nc" id="L1011">            am = am.getParent();</span>
        }
<span class="nc bnc" id="L1013" title="All 2 branches missed.">        if (am != null) {</span>
            // Found it, tweak the Actionap that points to it, as well
            // as anything it points to.
<span class="nc bnc" id="L1016" title="All 2 branches missed.">            if (newKm == null) {</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">                if (lastAM != am) {</span>
<span class="nc" id="L1018">                    lastAM.setParent(am.getParent());</span>
                }
                else {
<span class="nc" id="L1021">                    lastAM.setParent(null);</span>
                }
            }
            else {
<span class="nc" id="L1025">                ActionMap newAM = new KeymapActionMap(newKm);</span>
<span class="nc" id="L1026">                lastAM.setParent(newAM);</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">                if (lastAM != am) {</span>
<span class="nc" id="L1028">                    newAM.setParent(am.getParent());</span>
                }
<span class="nc" id="L1030">            }</span>
        }
<span class="nc bnc" id="L1032" title="All 2 branches missed.">        else if (newKm != null) {</span>
<span class="nc" id="L1033">            am = getActionMap();</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">            if (am != null) {</span>
                // Couldn't find it.
                // Set the parent of ActionMap to be the new one.
<span class="nc" id="L1037">                ActionMap newAM = new KeymapActionMap(newKm);</span>
<span class="nc" id="L1038">                newAM.setParent(am.getParent());</span>
<span class="nc" id="L1039">                am.setParent(newAM);</span>
            }
        }
<span class="nc" id="L1042">    }</span>

    /**
     * Fetches the keymap currently active in this text
     * component.
     *
     * @return the keymap
     */
    public Keymap getKeymap() {
<span class="nc" id="L1051">        return keymap;</span>
    }

    /**
     * Adds a new keymap into the keymap hierarchy.  Keymap bindings
     * resolve from bottom up so an attribute specified in a child
     * will override an attribute specified in the parent.
     *
     * @param nm   the name of the keymap (must be unique within the
     *   collection of named keymaps in the document); the name may
     *   be &lt;code&gt;null&lt;/code&gt; if the keymap is unnamed,
     *   but the caller is responsible for managing the reference
     *   returned as an unnamed keymap can't
     *   be fetched by name
     * @param parent the parent keymap; this may be &lt;code&gt;null&lt;/code&gt; if
     *   unspecified bindings need not be resolved in some other keymap
     * @return the keymap
     */
    public static Keymap addKeymap(String nm, Keymap parent) {
<span class="nc" id="L1070">        Keymap map = new DefaultKeymap(nm, parent);</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        if (nm != null) {</span>
            // add a named keymap, a class of bindings
<span class="nc" id="L1073">            getKeymapTable().put(nm, map);</span>
        }
<span class="nc" id="L1075">        return map;</span>
    }

    /**
     * Removes a named keymap previously added to the document.  Keymaps
     * with &lt;code&gt;null&lt;/code&gt; names may not be removed in this way.
     *
     * @param nm  the name of the keymap to remove
     * @return the keymap that was removed
     */
    public static Keymap removeKeymap(String nm) {
<span class="nc" id="L1086">        return getKeymapTable().remove(nm);</span>
    }

    /**
     * Fetches a named keymap previously added to the document.
     * This does not work with &lt;code&gt;null&lt;/code&gt;-named keymaps.
     *
     * @param nm  the name of the keymap
     * @return the keymap
     */
    public static Keymap getKeymap(String nm) {
<span class="nc" id="L1097">        return getKeymapTable().get(nm);</span>
    }

    private static HashMap&lt;String,Keymap&gt; getKeymapTable() {
<span class="nc" id="L1101">        synchronized (KEYMAP_TABLE) {</span>
<span class="nc" id="L1102">            AppContext appContext = AppContext.getAppContext();</span>
<span class="nc" id="L1103">            HashMap&lt;String,Keymap&gt; keymapTable =</span>
<span class="nc" id="L1104">                (HashMap&lt;String,Keymap&gt;)appContext.get(KEYMAP_TABLE);</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">            if (keymapTable == null) {</span>
<span class="nc" id="L1106">                keymapTable = new HashMap&lt;String,Keymap&gt;(17);</span>
<span class="nc" id="L1107">                appContext.put(KEYMAP_TABLE, keymapTable);</span>
                //initialize default keymap
<span class="nc" id="L1109">                Keymap binding = addKeymap(DEFAULT_KEYMAP, null);</span>
<span class="nc" id="L1110">                binding.setDefaultAction(new</span>
                                         DefaultEditorKit.DefaultKeyTypedAction());
            }
<span class="nc" id="L1113">            return keymapTable;</span>
<span class="nc" id="L1114">        }</span>
    }

    /**
     * Binding record for creating key bindings.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    public static class KeyBinding {

        /**
         * The key.
         */
        public KeyStroke key;

        /**
         * The name of the action for the key.
         */
        public String actionName;

        /**
         * Creates a new key binding.
         *
         * @param key the key
         * @param actionName the name of the action for the key
         */
<span class="nc" id="L1147">        public KeyBinding(KeyStroke key, String actionName) {</span>
<span class="nc" id="L1148">            this.key = key;</span>
<span class="nc" id="L1149">            this.actionName = actionName;</span>
<span class="nc" id="L1150">        }</span>
    }

    /**
     * &lt;p&gt;
     * Loads a keymap with a bunch of
     * bindings.  This can be used to take a static table of
     * definitions and load them into some keymap.  The following
     * example illustrates an example of binding some keys to
     * the cut, copy, and paste actions associated with a
     * JTextComponent.  A code fragment to accomplish
     * this might look as follows:
     * &lt;pre&gt;&lt;code&gt;
     *
     *   static final JTextComponent.KeyBinding[] defaultBindings = {
     *     new JTextComponent.KeyBinding(
     *       KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_MASK),
     *       DefaultEditorKit.copyAction),
     *     new JTextComponent.KeyBinding(
     *       KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_MASK),
     *       DefaultEditorKit.pasteAction),
     *     new JTextComponent.KeyBinding(
     *       KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.CTRL_MASK),
     *       DefaultEditorKit.cutAction),
     *   };
     *
     *   JTextComponent c = new JTextPane();
     *   Keymap k = c.getKeymap();
     *   JTextComponent.loadKeymap(k, defaultBindings, c.getActions());
     *
     * &lt;/code&gt;&lt;/pre&gt;
     * The sets of bindings and actions may be empty but must be
     * non-&lt;code&gt;null&lt;/code&gt;.
     *
     * @param map the keymap
     * @param bindings the bindings
     * @param actions the set of actions
     */
    public static void loadKeymap(Keymap map, KeyBinding[] bindings, Action[] actions) {
<span class="nc" id="L1189">        Hashtable&lt;String, Action&gt; h = new Hashtable&lt;String, Action&gt;();</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">        for (Action a : actions) {</span>
<span class="nc" id="L1191">            String value = (String)a.getValue(Action.NAME);</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">            h.put((value!=null ? value:&quot;&quot;), a);</span>
        }
<span class="nc bnc" id="L1194" title="All 2 branches missed.">        for (KeyBinding binding : bindings) {</span>
<span class="nc" id="L1195">            Action a = h.get(binding.actionName);</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">            if (a != null) {</span>
<span class="nc" id="L1197">                map.addActionForKeyStroke(binding.key, a);</span>
            }
        }
<span class="nc" id="L1200">    }</span>

    /**
     * Returns true if &lt;code&gt;klass&lt;/code&gt; is NOT a JTextComponent and it or
     * one of its superclasses (stoping at JTextComponent) overrides
     * &lt;code&gt;processInputMethodEvent&lt;/code&gt;. It is assumed this will be
     * invoked from within a &lt;code&gt;doPrivileged&lt;/code&gt;, and it is also
     * assumed &lt;code&gt;klass&lt;/code&gt; extends &lt;code&gt;JTextComponent&lt;/code&gt;.
     */
    private static Boolean isProcessInputMethodEventOverridden(Class&lt;?&gt; klass) {
<span class="nc bnc" id="L1210" title="All 2 branches missed.">        if (klass == JTextComponent.class) {</span>
<span class="nc" id="L1211">            return Boolean.FALSE;</span>
        }
<span class="nc" id="L1213">        Boolean retValue = overrideMap.get(klass.getName());</span>

<span class="nc bnc" id="L1215" title="All 2 branches missed.">        if (retValue != null) {</span>
<span class="nc" id="L1216">            return retValue;</span>
        }
<span class="nc" id="L1218">        Boolean sOverriden = isProcessInputMethodEventOverridden(</span>
<span class="nc" id="L1219">                                       klass.getSuperclass());</span>

<span class="nc bnc" id="L1221" title="All 2 branches missed.">        if (sOverriden.booleanValue()) {</span>
            // If our superclass has overriden it, then by definition klass
            // overrides it.
<span class="nc" id="L1224">            overrideMap.put(klass.getName(), sOverriden);</span>
<span class="nc" id="L1225">            return sOverriden;</span>
        }
        // klass's superclass didn't override it, check for an override in
        // klass.
        try {
<span class="nc" id="L1230">            Class[] classes = new Class[1];</span>
<span class="nc" id="L1231">            classes[0] = InputMethodEvent.class;</span>

<span class="nc" id="L1233">            Method m = klass.getDeclaredMethod(&quot;processInputMethodEvent&quot;,</span>
                                               classes);
<span class="nc" id="L1235">            retValue = Boolean.TRUE;</span>
<span class="nc" id="L1236">        } catch (NoSuchMethodException nsme) {</span>
<span class="nc" id="L1237">            retValue = Boolean.FALSE;</span>
<span class="nc" id="L1238">        }</span>
<span class="nc" id="L1239">        overrideMap.put(klass.getName(), retValue);</span>
<span class="nc" id="L1240">        return retValue;</span>
    }

    /**
     * Fetches the current color used to render the
     * caret.
     *
     * @return the color
     */
    public Color getCaretColor() {
<span class="nc" id="L1250">        return caretColor;</span>
    }

    /**
     * Sets the current color used to render the caret.
     * Setting to &lt;code&gt;null&lt;/code&gt; effectively restores the default color.
     * Setting the color results in a PropertyChange event (&quot;caretColor&quot;)
     * being fired.
     *
     * @param c the color
     * @see #getCaretColor
     * @beaninfo
     *  description: the color used to render the caret
     *        bound: true
     *    preferred: true
     */
    public void setCaretColor(Color c) {
<span class="nc" id="L1267">        Color old = caretColor;</span>
<span class="nc" id="L1268">        caretColor = c;</span>
<span class="nc" id="L1269">        firePropertyChange(&quot;caretColor&quot;, old, caretColor);</span>
<span class="nc" id="L1270">    }</span>

    /**
     * Fetches the current color used to render the
     * selection.
     *
     * @return the color
     */
    public Color getSelectionColor() {
<span class="nc" id="L1279">        return selectionColor;</span>
    }

    /**
     * Sets the current color used to render the selection.
     * Setting the color to &lt;code&gt;null&lt;/code&gt; is the same as setting
     * &lt;code&gt;Color.white&lt;/code&gt;.  Setting the color results in a
     * PropertyChange event (&quot;selectionColor&quot;).
     *
     * @param c the color
     * @see #getSelectionColor
     * @beaninfo
     *  description: color used to render selection background
     *        bound: true
     *    preferred: true
     */
    public void setSelectionColor(Color c) {
<span class="nc" id="L1296">        Color old = selectionColor;</span>
<span class="nc" id="L1297">        selectionColor = c;</span>
<span class="nc" id="L1298">        firePropertyChange(&quot;selectionColor&quot;, old, selectionColor);</span>
<span class="nc" id="L1299">    }</span>

    /**
     * Fetches the current color used to render the
     * selected text.
     *
     * @return the color
     */
    public Color getSelectedTextColor() {
<span class="nc" id="L1308">        return selectedTextColor;</span>
    }

    /**
     * Sets the current color used to render the selected text.
     * Setting the color to &lt;code&gt;null&lt;/code&gt; is the same as
     * &lt;code&gt;Color.black&lt;/code&gt;. Setting the color results in a
     * PropertyChange event (&quot;selectedTextColor&quot;) being fired.
     *
     * @param c the color
     * @see #getSelectedTextColor
     * @beaninfo
     *  description: color used to render selected text
     *        bound: true
     *    preferred: true
     */
    public void setSelectedTextColor(Color c) {
<span class="nc" id="L1325">        Color old = selectedTextColor;</span>
<span class="nc" id="L1326">        selectedTextColor = c;</span>
<span class="nc" id="L1327">        firePropertyChange(&quot;selectedTextColor&quot;, old, selectedTextColor);</span>
<span class="nc" id="L1328">    }</span>

    /**
     * Fetches the current color used to render the
     * disabled text.
     *
     * @return the color
     */
    public Color getDisabledTextColor() {
<span class="nc" id="L1337">        return disabledTextColor;</span>
    }

    /**
     * Sets the current color used to render the
     * disabled text.  Setting the color fires off a
     * PropertyChange event (&quot;disabledTextColor&quot;).
     *
     * @param c the color
     * @see #getDisabledTextColor
     * @beaninfo
     *  description: color used to render disabled text
     *        bound: true
     *    preferred: true
     */
    public void setDisabledTextColor(Color c) {
<span class="nc" id="L1353">        Color old = disabledTextColor;</span>
<span class="nc" id="L1354">        disabledTextColor = c;</span>
<span class="nc" id="L1355">        firePropertyChange(&quot;disabledTextColor&quot;, old, disabledTextColor);</span>
<span class="nc" id="L1356">    }</span>

    /**
     * Replaces the currently selected content with new content
     * represented by the given string.  If there is no selection
     * this amounts to an insert of the given text.  If there
     * is no replacement text this amounts to a removal of the
     * current selection.
     * &lt;p&gt;
     * This is the method that is used by the default implementation
     * of the action for inserting content that gets bound to the
     * keymap actions.
     *
     * @param content  the content to replace the selection with
     */
    public void replaceSelection(String content) {
<span class="nc" id="L1372">        Document doc = getDocument();</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">        if (doc != null) {</span>
            try {
<span class="nc" id="L1375">                boolean composedTextSaved = saveComposedText(caret.getDot());</span>
<span class="nc" id="L1376">                int p0 = Math.min(caret.getDot(), caret.getMark());</span>
<span class="nc" id="L1377">                int p1 = Math.max(caret.getDot(), caret.getMark());</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">                if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1379">                    ((AbstractDocument)doc).replace(p0, p1 - p0, content,null);</span>
                }
                else {
<span class="nc bnc" id="L1382" title="All 2 branches missed.">                    if (p0 != p1) {</span>
<span class="nc" id="L1383">                        doc.remove(p0, p1 - p0);</span>
                    }
<span class="nc bnc" id="L1385" title="All 4 branches missed.">                    if (content != null &amp;&amp; content.length() &gt; 0) {</span>
<span class="nc" id="L1386">                        doc.insertString(p0, content, null);</span>
                    }
                }
<span class="nc bnc" id="L1389" title="All 2 branches missed.">                if (composedTextSaved) {</span>
<span class="nc" id="L1390">                    restoreComposedText();</span>
                }
<span class="nc" id="L1392">            } catch (BadLocationException e) {</span>
<span class="nc" id="L1393">                UIManager.getLookAndFeel().provideErrorFeedback(JTextComponent.this);</span>
<span class="nc" id="L1394">            }</span>
        }
<span class="nc" id="L1396">    }</span>

    /**
     * Fetches a portion of the text represented by the
     * component.  Returns an empty string if length is 0.
     *
     * @param offs the offset &amp;ge; 0
     * @param len the length &amp;ge; 0
     * @return the text
     * @exception BadLocationException if the offset or length are invalid
     */
    public String getText(int offs, int len) throws BadLocationException {
<span class="nc" id="L1408">        return getDocument().getText(offs, len);</span>
    }

    /**
     * Converts the given location in the model to a place in
     * the view coordinate system.
     * The component must have a positive size for
     * this translation to be computed (i.e. layout cannot
     * be computed until the component has been sized).  The
     * component does not have to be visible or painted.
     *
     * @param pos the position &amp;ge; 0
     * @return the coordinates as a rectangle, with (r.x, r.y) as the location
     *   in the coordinate system, or null if the component does
     *   not yet have a positive size.
     * @exception BadLocationException if the given position does not
     *   represent a valid location in the associated document
     * @see TextUI#modelToView
     */
    public Rectangle modelToView(int pos) throws BadLocationException {
<span class="nc" id="L1428">        return getUI().modelToView(this, pos);</span>
    }

    /**
     * Converts the given place in the view coordinate system
     * to the nearest representative location in the model.
     * The component must have a positive size for
     * this translation to be computed (i.e. layout cannot
     * be computed until the component has been sized).  The
     * component does not have to be visible or painted.
     *
     * @param pt the location in the view to translate
     * @return the offset &amp;ge; 0 from the start of the document,
     *   or -1 if the component does not yet have a positive
     *   size.
     * @see TextUI#viewToModel
     */
    public int viewToModel(Point pt) {
<span class="nc" id="L1446">        return getUI().viewToModel(this, pt);</span>
    }

    /**
     * Transfers the currently selected range in the associated
     * text model to the system clipboard, removing the contents
     * from the model.  The current selection is reset.  Does nothing
     * for &lt;code&gt;null&lt;/code&gt; selections.
     *
     * @see java.awt.Toolkit#getSystemClipboard
     * @see java.awt.datatransfer.Clipboard
     */
    public void cut() {
<span class="nc bnc" id="L1459" title="All 4 branches missed.">        if (isEditable() &amp;&amp; isEnabled()) {</span>
<span class="nc" id="L1460">            invokeAction(&quot;cut&quot;, TransferHandler.getCutAction());</span>
        }
<span class="nc" id="L1462">    }</span>

    /**
     * Transfers the currently selected range in the associated
     * text model to the system clipboard, leaving the contents
     * in the text model.  The current selection remains intact.
     * Does nothing for &lt;code&gt;null&lt;/code&gt; selections.
     *
     * @see java.awt.Toolkit#getSystemClipboard
     * @see java.awt.datatransfer.Clipboard
     */
    public void copy() {
<span class="nc" id="L1474">        invokeAction(&quot;copy&quot;, TransferHandler.getCopyAction());</span>
<span class="nc" id="L1475">    }</span>

    /**
     * Transfers the contents of the system clipboard into the
     * associated text model.  If there is a selection in the
     * associated view, it is replaced with the contents of the
     * clipboard.  If there is no selection, the clipboard contents
     * are inserted in front of the current insert position in
     * the associated view.  If the clipboard is empty, does nothing.
     *
     * @see #replaceSelection
     * @see java.awt.Toolkit#getSystemClipboard
     * @see java.awt.datatransfer.Clipboard
     */
    public void paste() {
<span class="nc bnc" id="L1490" title="All 4 branches missed.">        if (isEditable() &amp;&amp; isEnabled()) {</span>
<span class="nc" id="L1491">            invokeAction(&quot;paste&quot;, TransferHandler.getPasteAction());</span>
        }
<span class="nc" id="L1493">    }</span>

    /**
     * This is a convenience method that is only useful for
     * &lt;code&gt;cut&lt;/code&gt;, &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;paste&lt;/code&gt;.  If
     * an &lt;code&gt;Action&lt;/code&gt; with the name &lt;code&gt;name&lt;/code&gt; does not
     * exist in the &lt;code&gt;ActionMap&lt;/code&gt;, this will attempt to install a
     * &lt;code&gt;TransferHandler&lt;/code&gt; and then use &lt;code&gt;altAction&lt;/code&gt;.
     */
    private void invokeAction(String name, Action altAction) {
<span class="nc" id="L1503">        ActionMap map = getActionMap();</span>
<span class="nc" id="L1504">        Action action = null;</span>

<span class="nc bnc" id="L1506" title="All 2 branches missed.">        if (map != null) {</span>
<span class="nc" id="L1507">            action = map.get(name);</span>
        }
<span class="nc bnc" id="L1509" title="All 2 branches missed.">        if (action == null) {</span>
<span class="nc" id="L1510">            installDefaultTransferHandlerIfNecessary();</span>
<span class="nc" id="L1511">            action = altAction;</span>
        }
<span class="nc" id="L1513">        action.actionPerformed(new ActionEvent(this,</span>
                               ActionEvent.ACTION_PERFORMED, (String)action.
<span class="nc" id="L1515">                               getValue(Action.NAME),</span>
<span class="nc" id="L1516">                               EventQueue.getMostRecentEventTime(),</span>
<span class="nc" id="L1517">                               getCurrentEventModifiers()));</span>
<span class="nc" id="L1518">    }</span>

    /**
     * If the current &lt;code&gt;TransferHandler&lt;/code&gt; is null, this will
     * install a new one.
     */
    private void installDefaultTransferHandlerIfNecessary() {
<span class="nc bnc" id="L1525" title="All 2 branches missed.">        if (getTransferHandler() == null) {</span>
<span class="nc bnc" id="L1526" title="All 2 branches missed.">            if (defaultTransferHandler == null) {</span>
<span class="nc" id="L1527">                defaultTransferHandler = new DefaultTransferHandler();</span>
            }
<span class="nc" id="L1529">            setTransferHandler(defaultTransferHandler);</span>
        }
<span class="nc" id="L1531">    }</span>

    /**
     * Moves the caret to a new position, leaving behind a mark
     * defined by the last time &lt;code&gt;setCaretPosition&lt;/code&gt; was
     * called.  This forms a selection.
     * If the document is &lt;code&gt;null&lt;/code&gt;, does nothing. The position
     * must be between 0 and the length of the component's text or else
     * an exception is thrown.
     *
     * @param pos the position
     * @exception    IllegalArgumentException if the value supplied
     *               for &lt;code&gt;position&lt;/code&gt; is less than zero or greater
     *               than the component's text length
     * @see #setCaretPosition
     */
    public void moveCaretPosition(int pos) {
<span class="nc" id="L1548">        Document doc = getDocument();</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">        if (doc != null) {</span>
<span class="nc bnc" id="L1550" title="All 4 branches missed.">            if (pos &gt; doc.getLength() || pos &lt; 0) {</span>
<span class="nc" id="L1551">                throw new IllegalArgumentException(&quot;bad position: &quot; + pos);</span>
            }
<span class="nc" id="L1553">            caret.moveDot(pos);</span>
        }
<span class="nc" id="L1555">    }</span>

    /**
     * The bound property name for the focus accelerator.
     */
    public static final String FOCUS_ACCELERATOR_KEY = &quot;focusAcceleratorKey&quot;;

    /**
     * Sets the key accelerator that will cause the receiving text
     * component to get the focus.  The accelerator will be the
     * key combination of the platform-specific modifier key and
     * the character given (converted to upper case).  For example,
     * the ALT key is used as a modifier on Windows and the CTRL+ALT
     * combination is used on Mac.  By default, there is no focus
     * accelerator key.  Any previous key accelerator setting will be
     * superseded.  A '\0' key setting will be registered, and has the
     * effect of turning off the focus accelerator.  When the new key
     * is set, a PropertyChange event (FOCUS_ACCELERATOR_KEY) will be fired.
     *
     * @param aKey the key
     * @see #getFocusAccelerator
     * @beaninfo
     *  description: accelerator character used to grab focus
     *        bound: true
     */
    public void setFocusAccelerator(char aKey) {
<span class="nc" id="L1581">        aKey = Character.toUpperCase(aKey);</span>
<span class="nc" id="L1582">        char old = focusAccelerator;</span>
<span class="nc" id="L1583">        focusAccelerator = aKey;</span>
        // Fix for 4341002: value of FOCUS_ACCELERATOR_KEY is wrong.
        // So we fire both FOCUS_ACCELERATOR_KEY, for compatibility,
        // and the correct event here.
<span class="nc" id="L1587">        firePropertyChange(FOCUS_ACCELERATOR_KEY, old, focusAccelerator);</span>
<span class="nc" id="L1588">        firePropertyChange(&quot;focusAccelerator&quot;, old, focusAccelerator);</span>
<span class="nc" id="L1589">    }</span>

    /**
     * Returns the key accelerator that will cause the receiving
     * text component to get the focus.  Return '\0' if no focus
     * accelerator has been set.
     *
     * @return the key
     */
    public char getFocusAccelerator() {
<span class="nc" id="L1599">        return focusAccelerator;</span>
    }

    /**
     * Initializes from a stream.  This creates a
     * model of the type appropriate for the component
     * and initializes the model from the stream.
     * By default this will load the model as plain
     * text.  Previous contents of the model are discarded.
     *
     * @param in the stream to read from
     * @param desc an object describing the stream; this
     *   might be a string, a File, a URL, etc.  Some kinds
     *   of documents (such as html for example) might be
     *   able to make use of this information; if non-&lt;code&gt;null&lt;/code&gt;,
     *   it is added as a property of the document
     * @exception IOException as thrown by the stream being
     *  used to initialize
     * @see EditorKit#createDefaultDocument
     * @see #setDocument
     * @see PlainDocument
     */
    public void read(Reader in, Object desc) throws IOException {
<span class="nc" id="L1622">        EditorKit kit = getUI().getEditorKit(this);</span>
<span class="nc" id="L1623">        Document doc = kit.createDefaultDocument();</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">        if (desc != null) {</span>
<span class="nc" id="L1625">            doc.putProperty(Document.StreamDescriptionProperty, desc);</span>
        }
        try {
<span class="nc" id="L1628">            kit.read(in, doc, 0);</span>
<span class="nc" id="L1629">            setDocument(doc);</span>
<span class="nc" id="L1630">        } catch (BadLocationException e) {</span>
<span class="nc" id="L1631">            throw new IOException(e.getMessage());</span>
<span class="nc" id="L1632">        }</span>
<span class="nc" id="L1633">    }</span>

    /**
     * Stores the contents of the model into the given
     * stream.  By default this will store the model as plain
     * text.
     *
     * @param out the output stream
     * @exception IOException on any I/O error
     */
    public void write(Writer out) throws IOException {
<span class="nc" id="L1644">        Document doc = getDocument();</span>
        try {
<span class="nc" id="L1646">            getUI().getEditorKit(this).write(out, doc, 0, doc.getLength());</span>
<span class="nc" id="L1647">        } catch (BadLocationException e) {</span>
<span class="nc" id="L1648">            throw new IOException(e.getMessage());</span>
<span class="nc" id="L1649">        }</span>
<span class="nc" id="L1650">    }</span>

    public void removeNotify() {
<span class="nc" id="L1653">        super.removeNotify();</span>
<span class="nc bnc" id="L1654" title="All 2 branches missed.">        if (getFocusedComponent() == this) {</span>
<span class="nc" id="L1655">            AppContext.getAppContext().remove(FOCUSED_COMPONENT);</span>
        }
<span class="nc" id="L1657">    }</span>

    // --- java.awt.TextComponent methods ------------------------

    /**
     * Sets the position of the text insertion caret for the
     * &lt;code&gt;TextComponent&lt;/code&gt;.  Note that the caret tracks change,
     * so this may move if the underlying text of the component is changed.
     * If the document is &lt;code&gt;null&lt;/code&gt;, does nothing. The position
     * must be between 0 and the length of the component's text or else
     * an exception is thrown.
     *
     * @param position the position
     * @exception    IllegalArgumentException if the value supplied
     *               for &lt;code&gt;position&lt;/code&gt; is less than zero or greater
     *               than the component's text length
     * @beaninfo
     * description: the caret position
     */
    public void setCaretPosition(int position) {
<span class="nc" id="L1677">        Document doc = getDocument();</span>
<span class="nc bnc" id="L1678" title="All 2 branches missed.">        if (doc != null) {</span>
<span class="nc bnc" id="L1679" title="All 4 branches missed.">            if (position &gt; doc.getLength() || position &lt; 0) {</span>
<span class="nc" id="L1680">                throw new IllegalArgumentException(&quot;bad position: &quot; + position);</span>
            }
<span class="nc" id="L1682">            caret.setDot(position);</span>
        }
<span class="nc" id="L1684">    }</span>

    /**
     * Returns the position of the text insertion caret for the
     * text component.
     *
     * @return the position of the text insertion caret for the
     *  text component &amp;ge; 0
     */
    @Transient
    public int getCaretPosition() {
<span class="nc" id="L1695">        return caret.getDot();</span>
    }

    /**
     * Sets the text of this &lt;code&gt;TextComponent&lt;/code&gt;
     * to the specified text.  If the text is &lt;code&gt;null&lt;/code&gt;
     * or empty, has the effect of simply deleting the old text.
     * When text has been inserted, the resulting caret location
     * is determined by the implementation of the caret class.
     *
     * &lt;p&gt;
     * Note that text is not a bound property, so no &lt;code&gt;PropertyChangeEvent
     * &lt;/code&gt; is fired when it changes. To listen for changes to the text,
     * use &lt;code&gt;DocumentListener&lt;/code&gt;.
     *
     * @param t the new text to be set
     * @see #getText
     * @see DefaultCaret
     * @beaninfo
     * description: the text of this component
     */
    public void setText(String t) {
        try {
<span class="nc" id="L1718">            Document doc = getDocument();</span>
<span class="nc bnc" id="L1719" title="All 2 branches missed.">            if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1720">                ((AbstractDocument)doc).replace(0, doc.getLength(), t,null);</span>
            }
            else {
<span class="nc" id="L1723">                doc.remove(0, doc.getLength());</span>
<span class="nc" id="L1724">                doc.insertString(0, t, null);</span>
            }
<span class="nc" id="L1726">        } catch (BadLocationException e) {</span>
<span class="nc" id="L1727">            UIManager.getLookAndFeel().provideErrorFeedback(JTextComponent.this);</span>
<span class="nc" id="L1728">        }</span>
<span class="nc" id="L1729">    }</span>

    /**
     * Returns the text contained in this &lt;code&gt;TextComponent&lt;/code&gt;.
     * If the underlying document is &lt;code&gt;null&lt;/code&gt;,
     * will give a &lt;code&gt;NullPointerException&lt;/code&gt;.
     *
     * Note that text is not a bound property, so no &lt;code&gt;PropertyChangeEvent
     * &lt;/code&gt; is fired when it changes. To listen for changes to the text,
     * use &lt;code&gt;DocumentListener&lt;/code&gt;.
     *
     * @return the text
     * @exception NullPointerException if the document is &lt;code&gt;null&lt;/code&gt;
     * @see #setText
     */
    public String getText() {
<span class="nc" id="L1745">        Document doc = getDocument();</span>
        String txt;
        try {
<span class="nc" id="L1748">            txt = doc.getText(0, doc.getLength());</span>
<span class="nc" id="L1749">        } catch (BadLocationException e) {</span>
<span class="nc" id="L1750">            txt = null;</span>
<span class="nc" id="L1751">        }</span>
<span class="nc" id="L1752">        return txt;</span>
    }

    /**
     * Returns the selected text contained in this
     * &lt;code&gt;TextComponent&lt;/code&gt;.  If the selection is
     * &lt;code&gt;null&lt;/code&gt; or the document empty, returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return the text
     * @exception IllegalArgumentException if the selection doesn't
     *  have a valid mapping into the document for some reason
     * @see #setText
     */
    public String getSelectedText() {
<span class="nc" id="L1766">        String txt = null;</span>
<span class="nc" id="L1767">        int p0 = Math.min(caret.getDot(), caret.getMark());</span>
<span class="nc" id="L1768">        int p1 = Math.max(caret.getDot(), caret.getMark());</span>
<span class="nc bnc" id="L1769" title="All 2 branches missed.">        if (p0 != p1) {</span>
            try {
<span class="nc" id="L1771">                Document doc = getDocument();</span>
<span class="nc" id="L1772">                txt = doc.getText(p0, p1 - p0);</span>
<span class="nc" id="L1773">            } catch (BadLocationException e) {</span>
<span class="nc" id="L1774">                throw new IllegalArgumentException(e.getMessage());</span>
<span class="nc" id="L1775">            }</span>
        }
<span class="nc" id="L1777">        return txt;</span>
    }

    /**
     * Returns the boolean indicating whether this
     * &lt;code&gt;TextComponent&lt;/code&gt; is editable or not.
     *
     * @return the boolean value
     * @see #setEditable
     */
    public boolean isEditable() {
<span class="nc" id="L1788">        return editable;</span>
    }

    /**
     * Sets the specified boolean to indicate whether or not this
     * &lt;code&gt;TextComponent&lt;/code&gt; should be editable.
     * A PropertyChange event (&quot;editable&quot;) is fired when the
     * state is changed.
     *
     * @param b the boolean to be set
     * @see #isEditable
     * @beaninfo
     * description: specifies if the text can be edited
     *       bound: true
     */
    public void setEditable(boolean b) {
<span class="nc bnc" id="L1804" title="All 2 branches missed.">        if (b != editable) {</span>
<span class="nc" id="L1805">            boolean oldVal = editable;</span>
<span class="nc" id="L1806">            editable = b;</span>
<span class="nc" id="L1807">            enableInputMethods(editable);</span>
<span class="nc" id="L1808">            firePropertyChange(&quot;editable&quot;, Boolean.valueOf(oldVal), Boolean.valueOf(editable));</span>
<span class="nc" id="L1809">            repaint();</span>
        }
<span class="nc" id="L1811">    }</span>

    /**
     * Returns the selected text's start position.  Return 0 for an
     * empty document, or the value of dot if no selection.
     *
     * @return the start position &amp;ge; 0
     */
    @Transient
    public int getSelectionStart() {
<span class="nc" id="L1821">        int start = Math.min(caret.getDot(), caret.getMark());</span>
<span class="nc" id="L1822">        return start;</span>
    }

    /**
     * Sets the selection start to the specified position.  The new
     * starting point is constrained to be before or at the current
     * selection end.
     * &lt;p&gt;
     * This is available for backward compatibility to code
     * that called this method on &lt;code&gt;java.awt.TextComponent&lt;/code&gt;.
     * This is implemented to forward to the &lt;code&gt;Caret&lt;/code&gt;
     * implementation which is where the actual selection is maintained.
     *
     * @param selectionStart the start position of the text &amp;ge; 0
     * @beaninfo
     * description: starting location of the selection.
     */
    public void setSelectionStart(int selectionStart) {
        /* Route through select method to enforce consistent policy
         * between selectionStart and selectionEnd.
         */
<span class="nc" id="L1843">        select(selectionStart, getSelectionEnd());</span>
<span class="nc" id="L1844">    }</span>

    /**
     * Returns the selected text's end position.  Return 0 if the document
     * is empty, or the value of dot if there is no selection.
     *
     * @return the end position &amp;ge; 0
     */
    @Transient
    public int getSelectionEnd() {
<span class="nc" id="L1854">        int end = Math.max(caret.getDot(), caret.getMark());</span>
<span class="nc" id="L1855">        return end;</span>
    }

    /**
     * Sets the selection end to the specified position.  The new
     * end point is constrained to be at or after the current
     * selection start.
     * &lt;p&gt;
     * This is available for backward compatibility to code
     * that called this method on &lt;code&gt;java.awt.TextComponent&lt;/code&gt;.
     * This is implemented to forward to the &lt;code&gt;Caret&lt;/code&gt;
     * implementation which is where the actual selection is maintained.
     *
     * @param selectionEnd the end position of the text &amp;ge; 0
     * @beaninfo
     * description: ending location of the selection.
     */
    public void setSelectionEnd(int selectionEnd) {
        /* Route through select method to enforce consistent policy
         * between selectionStart and selectionEnd.
         */
<span class="nc" id="L1876">        select(getSelectionStart(), selectionEnd);</span>
<span class="nc" id="L1877">    }</span>

    /**
     * Selects the text between the specified start and end positions.
     * &lt;p&gt;
     * This method sets the start and end positions of the
     * selected text, enforcing the restriction that the start position
     * must be greater than or equal to zero.  The end position must be
     * greater than or equal to the start position, and less than or
     * equal to the length of the text component's text.
     * &lt;p&gt;
     * If the caller supplies values that are inconsistent or out of
     * bounds, the method enforces these constraints silently, and
     * without failure. Specifically, if the start position or end
     * position is greater than the length of the text, it is reset to
     * equal the text length. If the start position is less than zero,
     * it is reset to zero, and if the end position is less than the
     * start position, it is reset to the start position.
     * &lt;p&gt;
     * This call is provided for backward compatibility.
     * It is routed to a call to &lt;code&gt;setCaretPosition&lt;/code&gt;
     * followed by a call to &lt;code&gt;moveCaretPosition&lt;/code&gt;.
     * The preferred way to manage selection is by calling
     * those methods directly.
     *
     * @param selectionStart the start position of the text
     * @param selectionEnd the end position of the text
     * @see #setCaretPosition
     * @see #moveCaretPosition
     */
    public void select(int selectionStart, int selectionEnd) {
        // argument adjustment done by java.awt.TextComponent
<span class="nc" id="L1909">        int docLength = getDocument().getLength();</span>

<span class="nc bnc" id="L1911" title="All 2 branches missed.">        if (selectionStart &lt; 0) {</span>
<span class="nc" id="L1912">            selectionStart = 0;</span>
        }
<span class="nc bnc" id="L1914" title="All 2 branches missed.">        if (selectionStart &gt; docLength) {</span>
<span class="nc" id="L1915">            selectionStart = docLength;</span>
        }
<span class="nc bnc" id="L1917" title="All 2 branches missed.">        if (selectionEnd &gt; docLength) {</span>
<span class="nc" id="L1918">            selectionEnd = docLength;</span>
        }
<span class="nc bnc" id="L1920" title="All 2 branches missed.">        if (selectionEnd &lt; selectionStart) {</span>
<span class="nc" id="L1921">            selectionEnd = selectionStart;</span>
        }

<span class="nc" id="L1924">        setCaretPosition(selectionStart);</span>
<span class="nc" id="L1925">        moveCaretPosition(selectionEnd);</span>
<span class="nc" id="L1926">    }</span>

    /**
     * Selects all the text in the &lt;code&gt;TextComponent&lt;/code&gt;.
     * Does nothing on a &lt;code&gt;null&lt;/code&gt; or empty document.
     */
    public void selectAll() {
<span class="nc" id="L1933">        Document doc = getDocument();</span>
<span class="nc bnc" id="L1934" title="All 2 branches missed.">        if (doc != null) {</span>
<span class="nc" id="L1935">            setCaretPosition(0);</span>
<span class="nc" id="L1936">            moveCaretPosition(doc.getLength());</span>
        }
<span class="nc" id="L1938">    }</span>

    // --- Tooltip Methods ---------------------------------------------

    /**
     * Returns the string to be used as the tooltip for &lt;code&gt;event&lt;/code&gt;.
     * This will return one of:
     * &lt;ol&gt;
     *  &lt;li&gt;If &lt;code&gt;setToolTipText&lt;/code&gt; has been invoked with a
     *      non-&lt;code&gt;null&lt;/code&gt;
     *      value, it will be returned, otherwise
     *  &lt;li&gt;The value from invoking &lt;code&gt;getToolTipText&lt;/code&gt; on
     *      the UI will be returned.
     * &lt;/ol&gt;
     * By default &lt;code&gt;JTextComponent&lt;/code&gt; does not register
     * itself with the &lt;code&gt;ToolTipManager&lt;/code&gt;.
     * This means that tooltips will NOT be shown from the
     * &lt;code&gt;TextUI&lt;/code&gt; unless &lt;code&gt;registerComponent&lt;/code&gt; has
     * been invoked on the &lt;code&gt;ToolTipManager&lt;/code&gt;.
     *
     * @param event the event in question
     * @return the string to be used as the tooltip for &lt;code&gt;event&lt;/code&gt;
     * @see javax.swing.JComponent#setToolTipText
     * @see javax.swing.plaf.TextUI#getToolTipText
     * @see javax.swing.ToolTipManager#registerComponent
     */
    public String getToolTipText(MouseEvent event) {
<span class="nc" id="L1965">        String retValue = super.getToolTipText(event);</span>

<span class="nc bnc" id="L1967" title="All 2 branches missed.">        if (retValue == null) {</span>
<span class="nc" id="L1968">            TextUI ui = getUI();</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">            if (ui != null) {</span>
<span class="nc" id="L1970">                retValue = ui.getToolTipText(this, new Point(event.getX(),</span>
<span class="nc" id="L1971">                                                             event.getY()));</span>
            }
        }
<span class="nc" id="L1974">        return retValue;</span>
    }

    // --- Scrollable methods ---------------------------------------------

    /**
     * Returns the preferred size of the viewport for a view component.
     * This is implemented to do the default behavior of returning
     * the preferred size of the component.
     *
     * @return the &lt;code&gt;preferredSize&lt;/code&gt; of a &lt;code&gt;JViewport&lt;/code&gt;
     * whose view is this &lt;code&gt;Scrollable&lt;/code&gt;
     */
    public Dimension getPreferredScrollableViewportSize() {
<span class="nc" id="L1988">        return getPreferredSize();</span>
    }


    /**
     * Components that display logical rows or columns should compute
     * the scroll increment that will completely expose one new row
     * or column, depending on the value of orientation.  Ideally,
     * components should handle a partially exposed row or column by
     * returning the distance required to completely expose the item.
     * &lt;p&gt;
     * The default implementation of this is to simply return 10% of
     * the visible area.  Subclasses are likely to be able to provide
     * a much more reasonable value.
     *
     * @param visibleRect the view area visible within the viewport
     * @param orientation either &lt;code&gt;SwingConstants.VERTICAL&lt;/code&gt; or
     *   &lt;code&gt;SwingConstants.HORIZONTAL&lt;/code&gt;
     * @param direction less than zero to scroll up/left, greater than
     *   zero for down/right
     * @return the &quot;unit&quot; increment for scrolling in the specified direction
     * @exception IllegalArgumentException for an invalid orientation
     * @see JScrollBar#setUnitIncrement
     */
    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
<span class="nc bnc" id="L2013" title="All 3 branches missed.">        switch(orientation) {</span>
        case SwingConstants.VERTICAL:
<span class="nc" id="L2015">            return visibleRect.height / 10;</span>
        case SwingConstants.HORIZONTAL:
<span class="nc" id="L2017">            return visibleRect.width / 10;</span>
        default:
<span class="nc" id="L2019">            throw new IllegalArgumentException(&quot;Invalid orientation: &quot; + orientation);</span>
        }
    }


    /**
     * Components that display logical rows or columns should compute
     * the scroll increment that will completely expose one block
     * of rows or columns, depending on the value of orientation.
     * &lt;p&gt;
     * The default implementation of this is to simply return the visible
     * area.  Subclasses will likely be able to provide a much more
     * reasonable value.
     *
     * @param visibleRect the view area visible within the viewport
     * @param orientation either &lt;code&gt;SwingConstants.VERTICAL&lt;/code&gt; or
     *   &lt;code&gt;SwingConstants.HORIZONTAL&lt;/code&gt;
     * @param direction less than zero to scroll up/left, greater than zero
     *  for down/right
     * @return the &quot;block&quot; increment for scrolling in the specified direction
     * @exception IllegalArgumentException for an invalid orientation
     * @see JScrollBar#setBlockIncrement
     */
    public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
<span class="nc bnc" id="L2043" title="All 3 branches missed.">        switch(orientation) {</span>
        case SwingConstants.VERTICAL:
<span class="nc" id="L2045">            return visibleRect.height;</span>
        case SwingConstants.HORIZONTAL:
<span class="nc" id="L2047">            return visibleRect.width;</span>
        default:
<span class="nc" id="L2049">            throw new IllegalArgumentException(&quot;Invalid orientation: &quot; + orientation);</span>
        }
    }


    /**
     * Returns true if a viewport should always force the width of this
     * &lt;code&gt;Scrollable&lt;/code&gt; to match the width of the viewport.
     * For example a normal text view that supported line wrapping
     * would return true here, since it would be undesirable for
     * wrapped lines to disappear beyond the right
     * edge of the viewport.  Note that returning true for a
     * &lt;code&gt;Scrollable&lt;/code&gt; whose ancestor is a &lt;code&gt;JScrollPane&lt;/code&gt;
     * effectively disables horizontal scrolling.
     * &lt;p&gt;
     * Scrolling containers, like &lt;code&gt;JViewport&lt;/code&gt;,
     * will use this method each time they are validated.
     *
     * @return true if a viewport should force the &lt;code&gt;Scrollable&lt;/code&gt;s
     *   width to match its own
     */
    public boolean getScrollableTracksViewportWidth() {
<span class="nc" id="L2071">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc bnc" id="L2073" title="All 2 branches missed.">            return parent.getWidth() &gt; getPreferredSize().width;</span>
        }
<span class="nc" id="L2075">        return false;</span>
    }

    /**
     * Returns true if a viewport should always force the height of this
     * &lt;code&gt;Scrollable&lt;/code&gt; to match the height of the viewport.
     * For example a columnar text view that flowed text in left to
     * right columns could effectively disable vertical scrolling by
     * returning true here.
     * &lt;p&gt;
     * Scrolling containers, like &lt;code&gt;JViewport&lt;/code&gt;,
     * will use this method each time they are validated.
     *
     * @return true if a viewport should force the Scrollables height
     *   to match its own
     */
    public boolean getScrollableTracksViewportHeight() {
<span class="nc" id="L2092">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L2093" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc bnc" id="L2094" title="All 2 branches missed.">            return parent.getHeight() &gt; getPreferredSize().height;</span>
        }
<span class="nc" id="L2096">        return false;</span>
    }


//////////////////
// Printing Support
//////////////////

    /**
     * A convenience print method that displays a print dialog, and then
     * prints this {@code JTextComponent} in &lt;i&gt;interactive&lt;/i&gt; mode with no
     * header or footer text. Note: this method
     * blocks until printing is done.
     * &lt;p&gt;
     * Note: In &lt;i&gt;headless&lt;/i&gt; mode, no dialogs will be shown.
     *
     * &lt;p&gt; This method calls the full featured
     * {@link #print(MessageFormat, MessageFormat, boolean, PrintService, PrintRequestAttributeSet, boolean)
     * print} method to perform printing.
     * @return {@code true}, unless printing is canceled by the user
     * @throws PrinterException if an error in the print system causes the job
     *         to be aborted
     * @throws SecurityException if this thread is not allowed to
     *                           initiate a print job request
     *
     * @see #print(MessageFormat, MessageFormat, boolean, PrintService, PrintRequestAttributeSet, boolean)
     *
     * @since 1.6
     */

    public boolean print() throws PrinterException {
<span class="nc" id="L2127">        return print(null, null, true, null, null, true);</span>
    }

    /**
     * A convenience print method that displays a print dialog, and then
     * prints this {@code JTextComponent} in &lt;i&gt;interactive&lt;/i&gt; mode with
     * the specified header and footer text. Note: this method
     * blocks until printing is done.
     * &lt;p&gt;
     * Note: In &lt;i&gt;headless&lt;/i&gt; mode, no dialogs will be shown.
     *
     * &lt;p&gt; This method calls the full featured
     * {@link #print(MessageFormat, MessageFormat, boolean, PrintService, PrintRequestAttributeSet, boolean)
     * print} method to perform printing.
     * @param headerFormat the text, in {@code MessageFormat}, to be
     *        used as the header, or {@code null} for no header
     * @param footerFormat the text, in {@code MessageFormat}, to be
     *        used as the footer, or {@code null} for no footer
     * @return {@code true}, unless printing is canceled by the user
     * @throws PrinterException if an error in the print system causes the job
     *         to be aborted
     * @throws SecurityException if this thread is not allowed to
     *                           initiate a print job request
     *
     * @see #print(MessageFormat, MessageFormat, boolean, PrintService, PrintRequestAttributeSet, boolean)
     * @see java.text.MessageFormat
     * @since 1.6
     */
    public boolean print(final MessageFormat headerFormat,
            final MessageFormat footerFormat) throws PrinterException {
<span class="nc" id="L2157">        return print(headerFormat, footerFormat, true, null, null, true);</span>
    }

    /**
     * Prints the content of this {@code JTextComponent}. Note: this method
     * blocks until printing is done.
     *
     * &lt;p&gt;
     * Page header and footer text can be added to the output by providing
     * {@code MessageFormat} arguments. The printing code requests
     * {@code Strings} from the formats, providing a single item which may be
     * included in the formatted string: an {@code Integer} representing the
     * current page number.
     *
     * &lt;p&gt;
     * {@code showPrintDialog boolean} parameter allows you to specify whether
     * a print dialog is displayed to the user. When it is, the user
     * may use the dialog to change printing attributes or even cancel the
     * print.
     *
     * &lt;p&gt;
     * {@code service} allows you to provide the initial
     * {@code PrintService} for the print dialog, or to specify
     * {@code PrintService} to print to when the dialog is not shown.
     *
     * &lt;p&gt;
     * {@code attributes} can be used to provide the
     * initial values for the print dialog, or to supply any needed
     * attributes when the dialog is not shown. {@code attributes} can
     * be used to control how the job will print, for example
     * &lt;i&gt;duplex&lt;/i&gt; or &lt;i&gt;single-sided&lt;/i&gt;.
     *
     * &lt;p&gt;
     * {@code interactive boolean} parameter allows you to specify
     * whether to perform printing in &lt;i&gt;interactive&lt;/i&gt;
     * mode. If {@code true}, a progress dialog, with an abort option,
     * is displayed for the duration of printing.  This dialog is
     * &lt;i&gt;modal&lt;/i&gt; when {@code print} is invoked on the &lt;i&gt;Event Dispatch
     * Thread&lt;/i&gt; and &lt;i&gt;non-modal&lt;/i&gt; otherwise. &lt;b&gt;Warning&lt;/b&gt;:
     * calling this method on the &lt;i&gt;Event Dispatch Thread&lt;/i&gt; with {@code
     * interactive false} blocks &lt;i&gt;all&lt;/i&gt; events, including repaints, from
     * being processed until printing is complete. It is only
     * recommended when printing from an application with no
     * visible GUI.
     *
     * &lt;p&gt;
     * Note: In &lt;i&gt;headless&lt;/i&gt; mode, {@code showPrintDialog} and
     * {@code interactive} parameters are ignored and no dialogs are
     * shown.
     *
     * &lt;p&gt;
     * This method ensures the {@code document} is not mutated during printing.
     * To indicate it visually, {@code setEnabled(false)} is set for the
     * duration of printing.
     *
     * &lt;p&gt;
     * This method uses {@link #getPrintable} to render document content.
     *
     * &lt;p&gt;
     * This method is thread-safe, although most Swing methods are not. Please
     * see &lt;A
     * HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;
     * Concurrency in Swing&lt;/A&gt; for more information.
     *
     * &lt;p&gt;
     * &lt;b&gt;Sample Usage&lt;/b&gt;. This code snippet shows a cross-platform print
     * dialog and then prints the {@code JTextComponent} in &lt;i&gt;interactive&lt;/i&gt; mode
     * unless the user cancels the dialog:
     *
     * &lt;pre&gt;
     * textComponent.print(new MessageFormat(&amp;quot;My text component header&amp;quot;),
     *     new MessageFormat(&amp;quot;JDKter. Page - {0}&amp;quot;), true, null, null, true);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Executing this code off the &lt;i&gt;Event Dispatch Thread&lt;/i&gt;
     * performs printing on the &lt;i&gt;background&lt;/i&gt;.
     * The following pattern might be used for &lt;i&gt;background&lt;/i&gt;
     * printing:
     * &lt;pre&gt;
     *     FutureTask&amp;lt;Boolean&amp;gt; future =
     *         new FutureTask&amp;lt;Boolean&amp;gt;(
     *             new Callable&amp;lt;Boolean&amp;gt;() {
     *                 public Boolean call() {
     *                     return textComponent.print(.....);
     *                 }
     *             });
     *     executor.execute(future);
     * &lt;/pre&gt;
     *
     * @param headerFormat the text, in {@code MessageFormat}, to be
     *        used as the header, or {@code null} for no header
     * @param footerFormat the text, in {@code MessageFormat}, to be
     *        used as the footer, or {@code null} for no footer
     * @param showPrintDialog {@code true} to display a print dialog,
     *        {@code false} otherwise
     * @param service initial {@code PrintService}, or {@code null} for the
     *        default
     * @param attributes the job attributes to be applied to the print job, or
     *        {@code null} for none
     * @param interactive whether to print in an interactive mode
     * @return {@code true}, unless printing is canceled by the user
     * @throws PrinterException if an error in the print system causes the job
     *         to be aborted
     * @throws SecurityException if this thread is not allowed to
     *                           initiate a print job request
     *
     * @see #getPrintable
     * @see java.text.MessageFormat
     * @see java.awt.GraphicsEnvironment#isHeadless
     * @see java.util.concurrent.FutureTask
     *
     * @since 1.6
     */
    public boolean print(final MessageFormat headerFormat,
            final MessageFormat footerFormat,
            final boolean showPrintDialog,
            final PrintService service,
            final PrintRequestAttributeSet attributes,
            final boolean interactive)
            throws PrinterException {

<span class="nc" id="L2278">        final PrinterJob job = PrinterJob.getPrinterJob();</span>
        final Printable printable;
        final PrintingStatus printingStatus;
<span class="nc" id="L2281">        final boolean isHeadless = GraphicsEnvironment.isHeadless();</span>
        final boolean isEventDispatchThread =
<span class="nc" id="L2283">            SwingUtilities.isEventDispatchThread();</span>
<span class="nc" id="L2284">        final Printable textPrintable = getPrintable(headerFormat, footerFormat);</span>
<span class="nc bnc" id="L2285" title="All 4 branches missed.">        if (interactive &amp;&amp; ! isHeadless) {</span>
<span class="nc" id="L2286">            printingStatus =</span>
<span class="nc" id="L2287">                PrintingStatus.createPrintingStatus(this, job);</span>
<span class="nc" id="L2288">            printable =</span>
<span class="nc" id="L2289">                printingStatus.createNotificationPrintable(textPrintable);</span>
        } else {
<span class="nc" id="L2291">            printingStatus = null;</span>
<span class="nc" id="L2292">            printable = textPrintable;</span>
        }

<span class="nc bnc" id="L2295" title="All 2 branches missed.">        if (service != null) {</span>
<span class="nc" id="L2296">            job.setPrintService(service);</span>
        }

<span class="nc" id="L2299">        job.setPrintable(printable);</span>

<span class="nc bnc" id="L2301" title="All 2 branches missed.">        final PrintRequestAttributeSet attr = (attributes == null)</span>
            ? new HashPrintRequestAttributeSet()
            : attributes;

<span class="nc bnc" id="L2305" title="All 6 branches missed.">        if (showPrintDialog &amp;&amp; ! isHeadless &amp;&amp; ! job.printDialog(attr)) {</span>
<span class="nc" id="L2306">            return false;</span>
        }

        /*
         * there are three cases for printing:
         * 1. print non interactively (! interactive || isHeadless)
         * 2. print interactively off EDT
         * 3. print interactively on EDT
         *
         * 1 and 2 prints on the current thread (3 prints on another thread)
         * 2 and 3 deal with PrintingStatusDialog
         */
<span class="nc" id="L2318">        final Callable&lt;Object&gt; doPrint =</span>
<span class="nc" id="L2319">            new Callable&lt;Object&gt;() {</span>
                public Object call() throws Exception {
                    try {
<span class="nc" id="L2322">                        job.print(attr);</span>
                    } finally {
<span class="nc bnc" id="L2324" title="All 4 branches missed.">                        if (printingStatus != null) {</span>
<span class="nc" id="L2325">                            printingStatus.dispose();</span>
                        }
                    }
<span class="nc" id="L2328">                    return null;</span>
                }
            };

<span class="nc" id="L2332">        final FutureTask&lt;Object&gt; futurePrinting =</span>
            new FutureTask&lt;Object&gt;(doPrint);

<span class="nc" id="L2335">        final Runnable runnablePrinting =</span>
<span class="nc" id="L2336">            new Runnable() {</span>
                public void run() {
                    //disable component
<span class="nc" id="L2339">                    boolean wasEnabled = false;</span>
<span class="nc bnc" id="L2340" title="All 2 branches missed.">                    if (isEventDispatchThread) {</span>
<span class="nc bnc" id="L2341" title="All 2 branches missed.">                        if (isEnabled()) {</span>
<span class="nc" id="L2342">                            wasEnabled = true;</span>
<span class="nc" id="L2343">                            setEnabled(false);</span>
                        }
                    } else {
                        try {
<span class="nc" id="L2347">                            wasEnabled = SwingUtilities2.submit(</span>
<span class="nc" id="L2348">                                new Callable&lt;Boolean&gt;() {</span>
                                    public Boolean call() throws Exception {
<span class="nc" id="L2350">                                        boolean rv = isEnabled();</span>
<span class="nc bnc" id="L2351" title="All 2 branches missed.">                                        if (rv) {</span>
<span class="nc" id="L2352">                                            setEnabled(false);</span>
                                        }
<span class="nc" id="L2354">                                        return rv;</span>
                                    }
<span class="nc" id="L2356">                                }).get();</span>
<span class="nc" id="L2357">                        } catch (InterruptedException e) {</span>
<span class="nc" id="L2358">                            throw new RuntimeException(e);</span>
<span class="nc" id="L2359">                        } catch (ExecutionException e) {</span>
<span class="nc" id="L2360">                            Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L2361" title="All 2 branches missed.">                            if (cause instanceof Error) {</span>
<span class="nc" id="L2362">                                throw (Error) cause;</span>
                            }
<span class="nc bnc" id="L2364" title="All 2 branches missed.">                            if (cause instanceof RuntimeException) {</span>
<span class="nc" id="L2365">                                throw (RuntimeException) cause;</span>
                            }
<span class="nc" id="L2367">                            throw new AssertionError(cause);</span>
<span class="nc" id="L2368">                        }</span>
                    }

<span class="nc" id="L2371">                    getDocument().render(futurePrinting);</span>

                    //enable component
<span class="nc bnc" id="L2374" title="All 2 branches missed.">                    if (wasEnabled) {</span>
<span class="nc bnc" id="L2375" title="All 2 branches missed.">                        if (isEventDispatchThread) {</span>
<span class="nc" id="L2376">                            setEnabled(true);</span>
                        } else {
                            try {
<span class="nc" id="L2379">                                SwingUtilities2.submit(</span>
<span class="nc" id="L2380">                                    new Runnable() {</span>
                                        public void run() {
<span class="nc" id="L2382">                                            setEnabled(true);</span>
<span class="nc" id="L2383">                                        }</span>
<span class="nc" id="L2384">                                    }, null).get();</span>
<span class="nc" id="L2385">                            } catch (InterruptedException e) {</span>
<span class="nc" id="L2386">                                throw new RuntimeException(e);</span>
<span class="nc" id="L2387">                            } catch (ExecutionException e) {</span>
<span class="nc" id="L2388">                                Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L2389" title="All 2 branches missed.">                                if (cause instanceof Error) {</span>
<span class="nc" id="L2390">                                    throw (Error) cause;</span>
                                }
<span class="nc bnc" id="L2392" title="All 2 branches missed.">                                if (cause instanceof RuntimeException) {</span>
<span class="nc" id="L2393">                                    throw (RuntimeException) cause;</span>
                                }
<span class="nc" id="L2395">                                throw new AssertionError(cause);</span>
<span class="nc" id="L2396">                            }</span>
                        }
                    }
<span class="nc" id="L2399">                }</span>
            };

<span class="nc bnc" id="L2402" title="All 4 branches missed.">        if (! interactive || isHeadless) {</span>
<span class="nc" id="L2403">            runnablePrinting.run();</span>
        } else {
<span class="nc bnc" id="L2405" title="All 2 branches missed.">            if (isEventDispatchThread) {</span>
<span class="nc" id="L2406">                (new Thread(runnablePrinting)).start();</span>
<span class="nc" id="L2407">                printingStatus.showModal(true);</span>
            } else {
<span class="nc" id="L2409">                printingStatus.showModal(false);</span>
<span class="nc" id="L2410">                runnablePrinting.run();</span>
            }
        }

        //the printing is done successfully or otherwise.
        //dialog is hidden if needed.
        try {
<span class="nc" id="L2417">            futurePrinting.get();</span>
<span class="nc" id="L2418">        } catch (InterruptedException e) {</span>
<span class="nc" id="L2419">            throw new RuntimeException(e);</span>
<span class="nc" id="L2420">        } catch (ExecutionException e) {</span>
<span class="nc" id="L2421">            Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L2422" title="All 2 branches missed.">            if (cause instanceof PrinterAbortException) {</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">                if (printingStatus != null</span>
<span class="nc bnc" id="L2424" title="All 2 branches missed.">                    &amp;&amp; printingStatus.isAborted()) {</span>
<span class="nc" id="L2425">                    return false;</span>
                } else {
<span class="nc" id="L2427">                    throw (PrinterAbortException) cause;</span>
                }
<span class="nc bnc" id="L2429" title="All 2 branches missed.">            } else if (cause instanceof PrinterException) {</span>
<span class="nc" id="L2430">                throw (PrinterException) cause;</span>
<span class="nc bnc" id="L2431" title="All 2 branches missed.">            } else if (cause instanceof RuntimeException) {</span>
<span class="nc" id="L2432">                throw (RuntimeException) cause;</span>
<span class="nc bnc" id="L2433" title="All 2 branches missed.">            } else if (cause instanceof Error) {</span>
<span class="nc" id="L2434">                throw (Error) cause;</span>
            } else {
<span class="nc" id="L2436">                throw new AssertionError(cause);</span>
            }
<span class="nc" id="L2438">        }</span>
<span class="nc" id="L2439">        return true;</span>
    }


    /**
     * Returns a {@code Printable} to use for printing the content of this
     * {@code JTextComponent}. The returned {@code Printable} prints
     * the document as it looks on the screen except being reformatted
     * to fit the paper.
     * The returned {@code Printable} can be wrapped inside another
     * {@code Printable} in order to create complex reports and
     * documents.
     *
     *
     * &lt;p&gt;
     * The returned {@code Printable} shares the {@code document} with this
     * {@code JTextComponent}. It is the responsibility of the developer to
     * ensure that the {@code document} is not mutated while this {@code Printable}
     * is used. Printing behavior is undefined when the {@code document} is
     * mutated during printing.
     *
     * &lt;p&gt;
     * Page header and footer text can be added to the output by providing
     * {@code MessageFormat} arguments. The printing code requests
     * {@code Strings} from the formats, providing a single item which may be
     * included in the formatted string: an {@code Integer} representing the
     * current page number.
     *
     * &lt;p&gt;
     * The returned {@code Printable} when printed, formats the
     * document content appropriately for the page size. For correct
     * line wrapping the {@code imageable width} of all pages must be the
     * same. See {@link java.awt.print.PageFormat#getImageableWidth}.
     *
     * &lt;p&gt;
     * This method is thread-safe, although most Swing methods are not. Please
     * see &lt;A
     * HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;
     * Concurrency in Swing&lt;/A&gt; for more information.
     *
     * &lt;p&gt;
     * The returned {@code Printable} can be printed on any thread.
     *
     * &lt;p&gt;
     * This implementation returned {@code Printable} performs all painting on
     * the &lt;i&gt;Event Dispatch Thread&lt;/i&gt;, regardless of what thread it is
     * used on.
     *
     * @param headerFormat the text, in {@code MessageFormat}, to be
     *        used as the header, or {@code null} for no header
     * @param footerFormat the text, in {@code MessageFormat}, to be
     *        used as the footer, or {@code null} for no footer
     * @return a {@code Printable} for use in printing content of this
     *         {@code JTextComponent}
     *
     *
     * @see java.awt.print.Printable
     * @see java.awt.print.PageFormat
     * @see javax.swing.text.Document#render(java.lang.Runnable)
     *
     * @since 1.6
     */
    public Printable getPrintable(final MessageFormat headerFormat,
                                  final MessageFormat footerFormat) {
<span class="nc" id="L2503">        return TextComponentPrintable.getPrintable(</span>
                   this, headerFormat, footerFormat);
    }


/////////////////
// Accessibility support
////////////////


    /**
     * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
     * &lt;code&gt;JTextComponent&lt;/code&gt;. For text components,
     * the &lt;code&gt;AccessibleContext&lt;/code&gt; takes the form of an
     * &lt;code&gt;AccessibleJTextComponent&lt;/code&gt;.
     * A new &lt;code&gt;AccessibleJTextComponent&lt;/code&gt; instance
     * is created if necessary.
     *
     * @return an &lt;code&gt;AccessibleJTextComponent&lt;/code&gt; that serves as the
     *         &lt;code&gt;AccessibleContext&lt;/code&gt; of this
     *         &lt;code&gt;JTextComponent&lt;/code&gt;
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L2526" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L2527">            accessibleContext = new AccessibleJTextComponent();</span>
        }
<span class="nc" id="L2529">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JTextComponent&lt;/code&gt; class.  It provides an implementation of
     * the Java Accessibility API appropriate to menu user-interface elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    public class AccessibleJTextComponent extends AccessibleJComponent
    implements AccessibleText, CaretListener, DocumentListener,
               AccessibleAction, AccessibleEditableText,
               AccessibleExtendedText {

        int caretPos;
        Point oldLocationOnScreen;

        /**
         * Constructs an AccessibleJTextComponent.  Adds a listener to track
         * caret change.
         */
<span class="nc" id="L2558">        public AccessibleJTextComponent() {</span>
<span class="nc" id="L2559">            Document doc = JTextComponent.this.getDocument();</span>
<span class="nc bnc" id="L2560" title="All 2 branches missed.">            if (doc != null) {</span>
<span class="nc" id="L2561">                doc.addDocumentListener(this);</span>
            }
<span class="nc" id="L2563">            JTextComponent.this.addCaretListener(this);</span>
<span class="nc" id="L2564">            caretPos = getCaretPosition();</span>

            try {
<span class="nc" id="L2567">                oldLocationOnScreen = getLocationOnScreen();</span>
<span class="nc" id="L2568">            } catch (IllegalComponentStateException iae) {</span>
<span class="nc" id="L2569">            }</span>

            // Fire a ACCESSIBLE_VISIBLE_DATA_PROPERTY PropertyChangeEvent
            // when the text component moves (e.g., when scrolling).
            // Using an anonymous class since making AccessibleJTextComponent
            // implement ComponentListener would be an API change.
<span class="nc" id="L2575">            JTextComponent.this.addComponentListener(new ComponentAdapter() {</span>

                public void componentMoved(ComponentEvent e) {
                    try {
<span class="nc" id="L2579">                        Point newLocationOnScreen = getLocationOnScreen();</span>
<span class="nc" id="L2580">                        firePropertyChange(ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
                                           oldLocationOnScreen,
                                           newLocationOnScreen);

<span class="nc" id="L2584">                        oldLocationOnScreen = newLocationOnScreen;</span>
<span class="nc" id="L2585">                    } catch (IllegalComponentStateException iae) {</span>
<span class="nc" id="L2586">                    }</span>
<span class="nc" id="L2587">                }</span>
            });
<span class="nc" id="L2589">        }</span>

        /**
         * Handles caret updates (fire appropriate property change event,
         * which are AccessibleContext.ACCESSIBLE_CARET_PROPERTY and
         * AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY).
         * This keeps track of the dot position internally.  When the caret
         * moves, the internal position is updated after firing the event.
         *
         * @param e the CaretEvent
         */
        public void caretUpdate(CaretEvent e) {
<span class="nc" id="L2601">            int dot = e.getDot();</span>
<span class="nc" id="L2602">            int mark = e.getMark();</span>
<span class="nc bnc" id="L2603" title="All 2 branches missed.">            if (caretPos != dot) {</span>
                // the caret moved
<span class="nc" id="L2605">                firePropertyChange(ACCESSIBLE_CARET_PROPERTY,</span>
                    new Integer(caretPos), new Integer(dot));
<span class="nc" id="L2607">                caretPos = dot;</span>

                try {
<span class="nc" id="L2610">                    oldLocationOnScreen = getLocationOnScreen();</span>
<span class="nc" id="L2611">                } catch (IllegalComponentStateException iae) {</span>
<span class="nc" id="L2612">                }</span>
            }
<span class="nc bnc" id="L2614" title="All 2 branches missed.">            if (mark != dot) {</span>
                // there is a selection
<span class="nc" id="L2616">                firePropertyChange(ACCESSIBLE_SELECTION_PROPERTY, null,</span>
<span class="nc" id="L2617">                    getSelectedText());</span>
            }
<span class="nc" id="L2619">        }</span>

        // DocumentListener methods

        /**
         * Handles document insert (fire appropriate property change event
         * which is AccessibleContext.ACCESSIBLE_TEXT_PROPERTY).
         * This tracks the changed offset via the event.
         *
         * @param e the DocumentEvent
         */
        public void insertUpdate(DocumentEvent e) {
<span class="nc" id="L2631">            final Integer pos = new Integer (e.getOffset());</span>
<span class="nc bnc" id="L2632" title="All 2 branches missed.">            if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L2633">                firePropertyChange(ACCESSIBLE_TEXT_PROPERTY, null, pos);</span>
            } else {
<span class="nc" id="L2635">                Runnable doFire = new Runnable() {</span>
                    public void run() {
<span class="nc" id="L2637">                        firePropertyChange(ACCESSIBLE_TEXT_PROPERTY,</span>
                                           null, pos);
<span class="nc" id="L2639">                    }</span>
                };
<span class="nc" id="L2641">                SwingUtilities.invokeLater(doFire);</span>
            }
<span class="nc" id="L2643">        }</span>

        /**
         * Handles document remove (fire appropriate property change event,
         * which is AccessibleContext.ACCESSIBLE_TEXT_PROPERTY).
         * This tracks the changed offset via the event.
         *
         * @param e the DocumentEvent
         */
        public void removeUpdate(DocumentEvent e) {
<span class="nc" id="L2653">            final Integer pos = new Integer (e.getOffset());</span>
<span class="nc bnc" id="L2654" title="All 2 branches missed.">            if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L2655">                firePropertyChange(ACCESSIBLE_TEXT_PROPERTY, null, pos);</span>
            } else {
<span class="nc" id="L2657">                Runnable doFire = new Runnable() {</span>
                    public void run() {
<span class="nc" id="L2659">                        firePropertyChange(ACCESSIBLE_TEXT_PROPERTY,</span>
                                           null, pos);
<span class="nc" id="L2661">                    }</span>
                };
<span class="nc" id="L2663">                SwingUtilities.invokeLater(doFire);</span>
            }
<span class="nc" id="L2665">        }</span>

        /**
         * Handles document remove (fire appropriate property change event,
         * which is AccessibleContext.ACCESSIBLE_TEXT_PROPERTY).
         * This tracks the changed offset via the event.
         *
         * @param e the DocumentEvent
         */
        public void changedUpdate(DocumentEvent e) {
<span class="nc" id="L2675">            final Integer pos = new Integer (e.getOffset());</span>
<span class="nc bnc" id="L2676" title="All 2 branches missed.">            if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L2677">                firePropertyChange(ACCESSIBLE_TEXT_PROPERTY, null, pos);</span>
            } else {
<span class="nc" id="L2679">                Runnable doFire = new Runnable() {</span>
                    public void run() {
<span class="nc" id="L2681">                        firePropertyChange(ACCESSIBLE_TEXT_PROPERTY,</span>
                                           null, pos);
<span class="nc" id="L2683">                    }</span>
                };
<span class="nc" id="L2685">                SwingUtilities.invokeLater(doFire);</span>
            }
<span class="nc" id="L2687">        }</span>

        /**
         * Gets the state set of the JTextComponent.
         * The AccessibleStateSet of an object is composed of a set of
         * unique AccessibleState's.  A change in the AccessibleStateSet
         * of an object will cause a PropertyChangeEvent to be fired
         * for the AccessibleContext.ACCESSIBLE_STATE_PROPERTY property.
         *
         * @return an instance of AccessibleStateSet containing the
         * current state set of the object
         * @see AccessibleStateSet
         * @see AccessibleState
         * @see #addPropertyChangeListener
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L2703">            AccessibleStateSet states = super.getAccessibleStateSet();</span>
<span class="nc bnc" id="L2704" title="All 2 branches missed.">            if (JTextComponent.this.isEditable()) {</span>
<span class="nc" id="L2705">                states.add(AccessibleState.EDITABLE);</span>
            }
<span class="nc" id="L2707">            return states;</span>
        }


        /**
         * Gets the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of the
         * object (AccessibleRole.TEXT)
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L2719">            return AccessibleRole.TEXT;</span>
        }

        /**
         * Get the AccessibleText associated with this object.  In the
         * implementation of the Java Accessibility API for this class,
         * return this object, which is responsible for implementing the
         * AccessibleText interface on behalf of itself.
         *
         * @return this object
         */
        public AccessibleText getAccessibleText() {
<span class="nc" id="L2731">            return this;</span>
        }


        // --- interface AccessibleText methods ------------------------

        /**
         * Many of these methods are just convenience methods; they
         * just call the equivalent on the parent
         */

        /**
         * Given a point in local coordinates, return the zero-based index
         * of the character under that Point.  If the point is invalid,
         * this method returns -1.
         *
         * @param p the Point in local coordinates
         * @return the zero-based index of the character under Point p.
         */
        public int getIndexAtPoint(Point p) {
<span class="nc bnc" id="L2751" title="All 2 branches missed.">            if (p == null) {</span>
<span class="nc" id="L2752">                return -1;</span>
            }
<span class="nc" id="L2754">            return JTextComponent.this.viewToModel(p);</span>
        }

            /**
             * Gets the editor's drawing rectangle.  Stolen
             * from the unfortunately named
             * BasicTextUI.getVisibleEditorRect()
             *
             * @return the bounding box for the root view
             */
            Rectangle getRootEditorRect() {
<span class="nc" id="L2765">                Rectangle alloc = JTextComponent.this.getBounds();</span>
<span class="nc bnc" id="L2766" title="All 4 branches missed.">                if ((alloc.width &gt; 0) &amp;&amp; (alloc.height &gt; 0)) {</span>
<span class="nc" id="L2767">                        alloc.x = alloc.y = 0;</span>
<span class="nc" id="L2768">                        Insets insets = JTextComponent.this.getInsets();</span>
<span class="nc" id="L2769">                        alloc.x += insets.left;</span>
<span class="nc" id="L2770">                        alloc.y += insets.top;</span>
<span class="nc" id="L2771">                        alloc.width -= insets.left + insets.right;</span>
<span class="nc" id="L2772">                        alloc.height -= insets.top + insets.bottom;</span>
<span class="nc" id="L2773">                        return alloc;</span>
                }
<span class="nc" id="L2775">                return null;</span>
            }

        /**
         * Determines the bounding box of the character at the given
         * index into the string.  The bounds are returned in local
         * coordinates.  If the index is invalid a null rectangle
         * is returned.
         *
         * The screen coordinates returned are &quot;unscrolled coordinates&quot;
         * if the JTextComponent is contained in a JScrollPane in which
         * case the resulting rectangle should be composed with the parent
         * coordinates.  A good algorithm to use is:
         * &lt;pre&gt;
         * Accessible a:
         * AccessibleText at = a.getAccessibleText();
         * AccessibleComponent ac = a.getAccessibleComponent();
         * Rectangle r = at.getCharacterBounds();
         * Point p = ac.getLocation();
         * r.x += p.x;
         * r.y += p.y;
         * &lt;/pre&gt;
         *
         * Note: the JTextComponent must have a valid size (e.g. have
         * been added to a parent container whose ancestor container
         * is a valid top-level window) for this method to be able
         * to return a meaningful (non-null) value.
         *
         * @param i the index into the String &amp;ge; 0
         * @return the screen coordinates of the character's bounding box
         */
        public Rectangle getCharacterBounds(int i) {
<span class="nc bnc" id="L2807" title="All 4 branches missed.">            if (i &lt; 0 || i &gt; model.getLength()-1) {</span>
<span class="nc" id="L2808">                return null;</span>
            }
<span class="nc" id="L2810">            TextUI ui = getUI();</span>
<span class="nc bnc" id="L2811" title="All 2 branches missed.">            if (ui == null) {</span>
<span class="nc" id="L2812">                return null;</span>
            }
<span class="nc" id="L2814">            Rectangle rect = null;</span>
<span class="nc" id="L2815">            Rectangle alloc = getRootEditorRect();</span>
<span class="nc bnc" id="L2816" title="All 2 branches missed.">            if (alloc == null) {</span>
<span class="nc" id="L2817">                return null;</span>
            }
<span class="nc bnc" id="L2819" title="All 2 branches missed.">            if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L2820">                ((AbstractDocument)model).readLock();</span>
            }
            try {
<span class="nc" id="L2823">                View rootView = ui.getRootView(JTextComponent.this);</span>
<span class="nc bnc" id="L2824" title="All 2 branches missed.">                if (rootView != null) {</span>
<span class="nc" id="L2825">                    rootView.setSize(alloc.width, alloc.height);</span>

<span class="nc" id="L2827">                    Shape bounds = rootView.modelToView(i,</span>
                                    Position.Bias.Forward, i+1,
                                    Position.Bias.Backward, alloc);

<span class="nc bnc" id="L2831" title="All 2 branches missed.">                    rect = (bounds instanceof Rectangle) ?</span>
<span class="nc" id="L2832">                     (Rectangle)bounds : bounds.getBounds();</span>

                }
<span class="nc" id="L2835">            } catch (BadLocationException e) {</span>
            } finally {
<span class="nc bnc" id="L2837" title="All 6 branches missed.">                if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L2838">                    ((AbstractDocument)model).readUnlock();</span>
                }
            }
<span class="nc" id="L2841">            return rect;</span>
        }

        /**
         * Returns the number of characters (valid indices)
         *
         * @return the number of characters &amp;ge; 0
         */
        public int getCharCount() {
<span class="nc" id="L2850">            return model.getLength();</span>
        }

        /**
         * Returns the zero-based offset of the caret.
         *
         * Note: The character to the right of the caret will have the
         * same index value as the offset (the caret is between
         * two characters).
         *
         * @return the zero-based offset of the caret.
         */
        public int getCaretPosition() {
<span class="nc" id="L2863">            return JTextComponent.this.getCaretPosition();</span>
        }

        /**
         * Returns the AttributeSet for a given character (at a given index).
         *
         * @param i the zero-based index into the text
         * @return the AttributeSet of the character
         */
        public AttributeSet getCharacterAttribute(int i) {
<span class="nc" id="L2873">            Element e = null;</span>
<span class="nc bnc" id="L2874" title="All 2 branches missed.">            if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L2875">                ((AbstractDocument)model).readLock();</span>
            }
            try {
<span class="nc bnc" id="L2878" title="All 2 branches missed.">                for (e = model.getDefaultRootElement(); ! e.isLeaf(); ) {</span>
<span class="nc" id="L2879">                    int index = e.getElementIndex(i);</span>
<span class="nc" id="L2880">                    e = e.getElement(index);</span>
<span class="nc" id="L2881">                }</span>
            } finally {
<span class="nc bnc" id="L2883" title="All 4 branches missed.">                if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L2884">                    ((AbstractDocument)model).readUnlock();</span>
                }
            }
<span class="nc" id="L2887">            return e.getAttributes();</span>
        }


        /**
         * Returns the start offset within the selected text.
         * If there is no selection, but there is
         * a caret, the start and end offsets will be the same.
         * Return 0 if the text is empty, or the caret position
         * if no selection.
         *
         * @return the index into the text of the start of the selection &amp;ge; 0
         */
        public int getSelectionStart() {
<span class="nc" id="L2901">            return JTextComponent.this.getSelectionStart();</span>
        }

        /**
         * Returns the end offset within the selected text.
         * If there is no selection, but there is
         * a caret, the start and end offsets will be the same.
         * Return 0 if the text is empty, or the caret position
         * if no selection.
         *
         * @return the index into the text of the end of the selection &amp;ge; 0
         */
        public int getSelectionEnd() {
<span class="nc" id="L2914">            return JTextComponent.this.getSelectionEnd();</span>
        }

        /**
         * Returns the portion of the text that is selected.
         *
         * @return the text, null if no selection
         */
        public String getSelectedText() {
<span class="nc" id="L2923">            return JTextComponent.this.getSelectedText();</span>
        }

       /**
         * IndexedSegment extends Segment adding the offset into the
         * the model the &lt;code&gt;Segment&lt;/code&gt; was asked for.
         */
<span class="nc" id="L2930">        private class IndexedSegment extends Segment {</span>
            /**
             * Offset into the model that the position represents.
             */
            public int modelOffset;
        }


        // TIGER - 4170173
        /**
         * Returns the String at a given index. Whitespace
         * between words is treated as a word.
         *
         * @param part the CHARACTER, WORD, or SENTENCE to retrieve
         * @param index an index within the text
         * @return the letter, word, or sentence.
         *
         */
        public String getAtIndex(int part, int index) {
<span class="nc" id="L2949">            return getAtIndex(part, index, 0);</span>
        }


        /**
         * Returns the String after a given index. Whitespace
         * between words is treated as a word.
         *
         * @param part the CHARACTER, WORD, or SENTENCE to retrieve
         * @param index an index within the text
         * @return the letter, word, or sentence.
         */
        public String getAfterIndex(int part, int index) {
<span class="nc" id="L2962">            return getAtIndex(part, index, 1);</span>
        }


        /**
         * Returns the String before a given index. Whitespace
         * between words is treated a word.
         *
         * @param part the CHARACTER, WORD, or SENTENCE to retrieve
         * @param index an index within the text
         * @return the letter, word, or sentence.
         */
        public String getBeforeIndex(int part, int index) {
<span class="nc" id="L2975">            return getAtIndex(part, index, -1);</span>
        }


        /**
         * Gets the word, sentence, or character at &lt;code&gt;index&lt;/code&gt;.
         * If &lt;code&gt;direction&lt;/code&gt; is non-null this will find the
         * next/previous word/sentence/character.
         */
        private String getAtIndex(int part, int index, int direction) {
<span class="nc bnc" id="L2985" title="All 2 branches missed.">            if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L2986">                ((AbstractDocument)model).readLock();</span>
            }
            try {
<span class="nc bnc" id="L2989" title="All 4 branches missed.">                if (index &lt; 0 || index &gt;= model.getLength()) {</span>
<span class="nc" id="L2990">                    return null;</span>
                }
<span class="nc bnc" id="L2992" title="All 3 branches missed.">                switch (part) {</span>
                case AccessibleText.CHARACTER:
<span class="nc bnc" id="L2994" title="All 4 branches missed.">                    if (index + direction &lt; model.getLength() &amp;&amp;</span>
                        index + direction &gt;= 0) {
<span class="nc" id="L2996">                        return model.getText(index + direction, 1);</span>
                    }
                    break;


                case AccessibleText.WORD:
                case AccessibleText.SENTENCE:
<span class="nc" id="L3003">                    IndexedSegment seg = getSegmentAt(part, index);</span>
<span class="nc bnc" id="L3004" title="All 2 branches missed.">                    if (seg != null) {</span>
<span class="nc bnc" id="L3005" title="All 2 branches missed.">                        if (direction != 0) {</span>
                            int next;


<span class="nc bnc" id="L3009" title="All 2 branches missed.">                            if (direction &lt; 0) {</span>
<span class="nc" id="L3010">                                next = seg.modelOffset - 1;</span>
                            }
                            else {
<span class="nc" id="L3013">                                next = seg.modelOffset + direction * seg.count;</span>
                            }
<span class="nc bnc" id="L3015" title="All 4 branches missed.">                            if (next &gt;= 0 &amp;&amp; next &lt;= model.getLength()) {</span>
<span class="nc" id="L3016">                                seg = getSegmentAt(part, next);</span>
                            }
                            else {
<span class="nc" id="L3019">                                seg = null;</span>
                            }
                        }
<span class="nc bnc" id="L3022" title="All 2 branches missed.">                        if (seg != null) {</span>
<span class="nc" id="L3023">                            return new String(seg.array, seg.offset,</span>
                                                  seg.count);
                        }
                    }
                    break;


                default:
                    break;
                }
<span class="nc" id="L3033">            } catch (BadLocationException e) {</span>
            } finally {
<span class="nc bnc" id="L3035" title="All 12 branches missed.">                if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L3036">                    ((AbstractDocument)model).readUnlock();</span>
                }
            }
<span class="nc" id="L3039">            return null;</span>
        }


        /*
         * Returns the paragraph element for the specified index.
         */
        private Element getParagraphElement(int index) {
<span class="nc bnc" id="L3047" title="All 2 branches missed.">            if (model instanceof PlainDocument ) {</span>
<span class="nc" id="L3048">                PlainDocument sdoc = (PlainDocument)model;</span>
<span class="nc" id="L3049">                return sdoc.getParagraphElement(index);</span>
<span class="nc bnc" id="L3050" title="All 2 branches missed.">            } else if (model instanceof StyledDocument) {</span>
<span class="nc" id="L3051">                StyledDocument sdoc = (StyledDocument)model;</span>
<span class="nc" id="L3052">                return sdoc.getParagraphElement(index);</span>
            } else {
                Element para;
<span class="nc bnc" id="L3055" title="All 2 branches missed.">                for (para = model.getDefaultRootElement(); ! para.isLeaf(); ) {</span>
<span class="nc" id="L3056">                    int pos = para.getElementIndex(index);</span>
<span class="nc" id="L3057">                    para = para.getElement(pos);</span>
<span class="nc" id="L3058">                }</span>
<span class="nc bnc" id="L3059" title="All 2 branches missed.">                if (para == null) {</span>
<span class="nc" id="L3060">                    return null;</span>
                }
<span class="nc" id="L3062">                return para.getParentElement();</span>
            }
        }

        /*
         * Returns a &lt;code&gt;Segment&lt;/code&gt; containing the paragraph text
         * at &lt;code&gt;index&lt;/code&gt;, or null if &lt;code&gt;index&lt;/code&gt; isn't
         * valid.
         */
        private IndexedSegment getParagraphElementText(int index)
                                  throws BadLocationException {
<span class="nc" id="L3073">            Element para = getParagraphElement(index);</span>


<span class="nc bnc" id="L3076" title="All 2 branches missed.">            if (para != null) {</span>
<span class="nc" id="L3077">                IndexedSegment segment = new IndexedSegment();</span>
                try {
<span class="nc" id="L3079">                    int length = para.getEndOffset() - para.getStartOffset();</span>
<span class="nc" id="L3080">                    model.getText(para.getStartOffset(), length, segment);</span>
<span class="nc" id="L3081">                } catch (BadLocationException e) {</span>
<span class="nc" id="L3082">                    return null;</span>
<span class="nc" id="L3083">                }</span>
<span class="nc" id="L3084">                segment.modelOffset = para.getStartOffset();</span>
<span class="nc" id="L3085">                return segment;</span>
            }
<span class="nc" id="L3087">            return null;</span>
        }


        /**
         * Returns the Segment at &lt;code&gt;index&lt;/code&gt; representing either
         * the paragraph or sentence as identified by &lt;code&gt;part&lt;/code&gt;, or
         * null if a valid paragraph/sentence can't be found. The offset
         * will point to the start of the word/sentence in the array, and
         * the modelOffset will point to the location of the word/sentence
         * in the model.
         */
        private IndexedSegment getSegmentAt(int part, int index) throws
                                  BadLocationException {
<span class="nc" id="L3101">            IndexedSegment seg = getParagraphElementText(index);</span>
<span class="nc bnc" id="L3102" title="All 2 branches missed.">            if (seg == null) {</span>
<span class="nc" id="L3103">                return null;</span>
            }
            BreakIterator iterator;
<span class="nc bnc" id="L3106" title="All 3 branches missed.">            switch (part) {</span>
            case AccessibleText.WORD:
<span class="nc" id="L3108">                iterator = BreakIterator.getWordInstance(getLocale());</span>
<span class="nc" id="L3109">                break;</span>
            case AccessibleText.SENTENCE:
<span class="nc" id="L3111">                iterator = BreakIterator.getSentenceInstance(getLocale());</span>
<span class="nc" id="L3112">                break;</span>
            default:
<span class="nc" id="L3114">                return null;</span>
            }
<span class="nc" id="L3116">            seg.first();</span>
<span class="nc" id="L3117">            iterator.setText(seg);</span>
<span class="nc" id="L3118">            int end = iterator.following(index - seg.modelOffset + seg.offset);</span>
<span class="nc bnc" id="L3119" title="All 2 branches missed.">            if (end == BreakIterator.DONE) {</span>
<span class="nc" id="L3120">                return null;</span>
            }
<span class="nc bnc" id="L3122" title="All 2 branches missed.">            if (end &gt; seg.offset + seg.count) {</span>
<span class="nc" id="L3123">                return null;</span>
            }
<span class="nc" id="L3125">            int begin = iterator.previous();</span>
<span class="nc bnc" id="L3126" title="All 4 branches missed.">            if (begin == BreakIterator.DONE ||</span>
                         begin &gt;= seg.offset + seg.count) {
<span class="nc" id="L3128">                return null;</span>
            }
<span class="nc" id="L3130">            seg.modelOffset = seg.modelOffset + begin - seg.offset;</span>
<span class="nc" id="L3131">            seg.offset = begin;</span>
<span class="nc" id="L3132">            seg.count = end - begin;</span>
<span class="nc" id="L3133">            return seg;</span>
        }

        // begin AccessibleEditableText methods -----

        /**
         * Returns the AccessibleEditableText interface for
         * this text component.
         *
         * @return the AccessibleEditableText interface
         * @since 1.4
         */
        public AccessibleEditableText getAccessibleEditableText() {
<span class="nc" id="L3146">            return this;</span>
        }

        /**
         * Sets the text contents to the specified string.
         *
         * @param s the string to set the text contents
         * @since 1.4
         */
        public void setTextContents(String s) {
<span class="nc" id="L3156">            JTextComponent.this.setText(s);</span>
<span class="nc" id="L3157">        }</span>

        /**
         * Inserts the specified string at the given index
         *
         * @param index the index in the text where the string will
         * be inserted
         * @param s the string to insert in the text
         * @since 1.4
         */
        public void insertTextAtIndex(int index, String s) {
<span class="nc" id="L3168">            Document doc = JTextComponent.this.getDocument();</span>
<span class="nc bnc" id="L3169" title="All 2 branches missed.">            if (doc != null) {</span>
                try {
<span class="nc bnc" id="L3171" title="All 4 branches missed.">                    if (s != null &amp;&amp; s.length() &gt; 0) {</span>
<span class="nc" id="L3172">                        boolean composedTextSaved = saveComposedText(index);</span>
<span class="nc" id="L3173">                        doc.insertString(index, s, null);</span>
<span class="nc bnc" id="L3174" title="All 2 branches missed.">                        if (composedTextSaved) {</span>
<span class="nc" id="L3175">                            restoreComposedText();</span>
                        }
                    }
<span class="nc" id="L3178">                } catch (BadLocationException e) {</span>
<span class="nc" id="L3179">                    UIManager.getLookAndFeel().provideErrorFeedback(JTextComponent.this);</span>
<span class="nc" id="L3180">                }</span>
            }
<span class="nc" id="L3182">        }</span>

        /**
         * Returns the text string between two indices.
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         * @return the text string between the indices
         * @since 1.4
         */
        public String getTextRange(int startIndex, int endIndex) {
<span class="nc" id="L3193">            String txt = null;</span>
<span class="nc" id="L3194">            int p0 = Math.min(startIndex, endIndex);</span>
<span class="nc" id="L3195">            int p1 = Math.max(startIndex, endIndex);</span>
<span class="nc bnc" id="L3196" title="All 2 branches missed.">            if (p0 != p1) {</span>
                try {
<span class="nc" id="L3198">                    Document doc = JTextComponent.this.getDocument();</span>
<span class="nc" id="L3199">                    txt = doc.getText(p0, p1 - p0);</span>
<span class="nc" id="L3200">                } catch (BadLocationException e) {</span>
<span class="nc" id="L3201">                    throw new IllegalArgumentException(e.getMessage());</span>
<span class="nc" id="L3202">                }</span>
            }
<span class="nc" id="L3204">            return txt;</span>
        }

        /**
         * Deletes the text between two indices
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         * @since 1.4
         */
        public void delete(int startIndex, int endIndex) {
<span class="nc bnc" id="L3215" title="All 4 branches missed.">            if (isEditable() &amp;&amp; isEnabled()) {</span>
                try {
<span class="nc" id="L3217">                    int p0 = Math.min(startIndex, endIndex);</span>
<span class="nc" id="L3218">                    int p1 = Math.max(startIndex, endIndex);</span>
<span class="nc bnc" id="L3219" title="All 2 branches missed.">                    if (p0 != p1) {</span>
<span class="nc" id="L3220">                        Document doc = getDocument();</span>
<span class="nc" id="L3221">                        doc.remove(p0, p1 - p0);</span>
                    }
<span class="nc" id="L3223">                } catch (BadLocationException e) {</span>
<span class="nc" id="L3224">                }</span>
            } else {
<span class="nc" id="L3226">                UIManager.getLookAndFeel().provideErrorFeedback(JTextComponent.this);</span>
            }
<span class="nc" id="L3228">        }</span>

        /**
         * Cuts the text between two indices into the system clipboard.
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         * @since 1.4
         */
        public void cut(int startIndex, int endIndex) {
<span class="nc" id="L3238">            selectText(startIndex, endIndex);</span>
<span class="nc" id="L3239">            JTextComponent.this.cut();</span>
<span class="nc" id="L3240">        }</span>

        /**
         * Pastes the text from the system clipboard into the text
         * starting at the specified index.
         *
         * @param startIndex the starting index in the text
         * @since 1.4
         */
        public void paste(int startIndex) {
<span class="nc" id="L3250">            setCaretPosition(startIndex);</span>
<span class="nc" id="L3251">            JTextComponent.this.paste();</span>
<span class="nc" id="L3252">        }</span>

        /**
         * Replaces the text between two indices with the specified
         * string.
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         * @param s the string to replace the text between two indices
         * @since 1.4
         */
        public void replaceText(int startIndex, int endIndex, String s) {
<span class="nc" id="L3264">            selectText(startIndex, endIndex);</span>
<span class="nc" id="L3265">            JTextComponent.this.replaceSelection(s);</span>
<span class="nc" id="L3266">        }</span>

        /**
         * Selects the text between two indices.
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         * @since 1.4
         */
        public void selectText(int startIndex, int endIndex) {
<span class="nc" id="L3276">            JTextComponent.this.select(startIndex, endIndex);</span>
<span class="nc" id="L3277">        }</span>

        /**
         * Sets attributes for the text between two indices.
         *
         * @param startIndex the starting index in the text
         * @param endIndex the ending index in the text
         * @param as the attribute set
         * @see AttributeSet
         * @since 1.4
         */
        public void setAttributes(int startIndex, int endIndex,
            AttributeSet as) {

            // Fixes bug 4487492
<span class="nc" id="L3292">            Document doc = JTextComponent.this.getDocument();</span>
<span class="nc bnc" id="L3293" title="All 4 branches missed.">            if (doc != null &amp;&amp; doc instanceof StyledDocument) {</span>
<span class="nc" id="L3294">                StyledDocument sDoc = (StyledDocument)doc;</span>
<span class="nc" id="L3295">                int offset = startIndex;</span>
<span class="nc" id="L3296">                int length = endIndex - startIndex;</span>
<span class="nc" id="L3297">                sDoc.setCharacterAttributes(offset, length, as, true);</span>
            }
<span class="nc" id="L3299">        }</span>

        // ----- end AccessibleEditableText methods


        // ----- begin AccessibleExtendedText methods

// Probably should replace the helper method getAtIndex() to return
// instead an AccessibleTextSequence also for LINE &amp; ATTRIBUTE_RUN
// and then make the AccessibleText methods get[At|After|Before]Point
// call this new method instead and return only the string portion

        /**
         * Returns the AccessibleTextSequence at a given &lt;code&gt;index&lt;/code&gt;.
         * If &lt;code&gt;direction&lt;/code&gt; is non-null this will find the
         * next/previous word/sentence/character.
         *
         * @param part the &lt;code&gt;CHARACTER&lt;/code&gt;, &lt;code&gt;WORD&lt;/code&gt;,
         * &lt;code&gt;SENTENCE&lt;/code&gt;, &lt;code&gt;LINE&lt;/code&gt; or
         * &lt;code&gt;ATTRIBUTE_RUN&lt;/code&gt; to retrieve
         * @param index an index within the text
         * @param direction is either -1, 0, or 1
         * @return an &lt;code&gt;AccessibleTextSequence&lt;/code&gt; specifying the text
         * if &lt;code&gt;part&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; are valid.  Otherwise,
         * &lt;code&gt;null&lt;/code&gt; is returned.
         *
         * @see javax.accessibility.AccessibleText#CHARACTER
         * @see javax.accessibility.AccessibleText#WORD
         * @see javax.accessibility.AccessibleText#SENTENCE
         * @see javax.accessibility.AccessibleExtendedText#LINE
         * @see javax.accessibility.AccessibleExtendedText#ATTRIBUTE_RUN
         *
         * @since 1.6
         */
        private AccessibleTextSequence getSequenceAtIndex(int part,
            int index, int direction) {
<span class="nc bnc" id="L3335" title="All 4 branches missed.">            if (index &lt; 0 || index &gt;= model.getLength()) {</span>
<span class="nc" id="L3336">                return null;</span>
            }
<span class="nc bnc" id="L3338" title="All 4 branches missed.">            if (direction &lt; -1 || direction &gt; 1) {</span>
<span class="nc" id="L3339">                return null;    // direction must be 1, 0, or -1</span>
            }

<span class="nc bnc" id="L3342" title="All 5 branches missed.">            switch (part) {</span>
            case AccessibleText.CHARACTER:
<span class="nc bnc" id="L3344" title="All 2 branches missed.">                if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L3345">                    ((AbstractDocument)model).readLock();</span>
                }
<span class="nc" id="L3347">                AccessibleTextSequence charSequence = null;</span>
                try {
<span class="nc bnc" id="L3349" title="All 4 branches missed.">                    if (index + direction &lt; model.getLength() &amp;&amp;</span>
                        index + direction &gt;= 0) {
<span class="nc" id="L3351">                        charSequence =</span>
                            new AccessibleTextSequence(index + direction,
                            index + direction + 1,
<span class="nc" id="L3354">                            model.getText(index + direction, 1));</span>
                    }

<span class="nc" id="L3357">                } catch (BadLocationException e) {</span>
                    // we are intentionally silent; our contract says we return
                    // null if there is any failure in this method
                } finally {
<span class="nc bnc" id="L3361" title="All 6 branches missed.">                    if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L3362">                        ((AbstractDocument)model).readUnlock();</span>
                    }
                }
<span class="nc" id="L3365">                return charSequence;</span>

            case AccessibleText.WORD:
            case AccessibleText.SENTENCE:
<span class="nc bnc" id="L3369" title="All 2 branches missed.">                if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L3370">                    ((AbstractDocument)model).readLock();</span>
                }
<span class="nc" id="L3372">                AccessibleTextSequence rangeSequence = null;</span>
                try {
<span class="nc" id="L3374">                    IndexedSegment seg = getSegmentAt(part, index);</span>
<span class="nc bnc" id="L3375" title="All 2 branches missed.">                    if (seg != null) {</span>
<span class="nc bnc" id="L3376" title="All 2 branches missed.">                        if (direction != 0) {</span>
                            int next;

<span class="nc bnc" id="L3379" title="All 2 branches missed.">                            if (direction &lt; 0) {</span>
<span class="nc" id="L3380">                                next = seg.modelOffset - 1;</span>
                            }
                            else {
<span class="nc" id="L3383">                                next = seg.modelOffset + seg.count;</span>
                            }
<span class="nc bnc" id="L3385" title="All 4 branches missed.">                            if (next &gt;= 0 &amp;&amp; next &lt;= model.getLength()) {</span>
<span class="nc" id="L3386">                                seg = getSegmentAt(part, next);</span>
                            }
                            else {
<span class="nc" id="L3389">                                seg = null;</span>
                            }
                        }
<span class="nc bnc" id="L3392" title="All 2 branches missed.">                        if (seg != null &amp;&amp;</span>
<span class="nc bnc" id="L3393" title="All 2 branches missed.">                            (seg.offset + seg.count) &lt;= model.getLength()) {</span>
<span class="nc" id="L3394">                            rangeSequence =</span>
                                new AccessibleTextSequence (seg.offset,
                                seg.offset + seg.count,
                                new String(seg.array, seg.offset, seg.count));
                        } // else we leave rangeSequence set to null
                    }
<span class="nc" id="L3400">                } catch(BadLocationException e) {</span>
                    // we are intentionally silent; our contract says we return
                    // null if there is any failure in this method
                } finally {
<span class="nc bnc" id="L3404" title="All 6 branches missed.">                    if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L3405">                        ((AbstractDocument)model).readUnlock();</span>
                    }
                }
<span class="nc" id="L3408">                return rangeSequence;</span>

            case AccessibleExtendedText.LINE:
<span class="nc" id="L3411">                AccessibleTextSequence lineSequence = null;</span>
<span class="nc bnc" id="L3412" title="All 2 branches missed.">                if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L3413">                    ((AbstractDocument)model).readLock();</span>
                }
                try {
<span class="nc" id="L3416">                    int startIndex =</span>
<span class="nc" id="L3417">                        Utilities.getRowStart(JTextComponent.this, index);</span>
<span class="nc" id="L3418">                    int endIndex =</span>
<span class="nc" id="L3419">                        Utilities.getRowEnd(JTextComponent.this, index);</span>
<span class="nc bnc" id="L3420" title="All 4 branches missed.">                    if (startIndex &gt;= 0 &amp;&amp; endIndex &gt;= startIndex) {</span>
<span class="nc bnc" id="L3421" title="All 2 branches missed.">                        if (direction == 0) {</span>
<span class="nc" id="L3422">                            lineSequence =</span>
                                new AccessibleTextSequence(startIndex, endIndex,
<span class="nc" id="L3424">                                    model.getText(startIndex,</span>
                                        endIndex - startIndex + 1));
<span class="nc bnc" id="L3426" title="All 4 branches missed.">                        } else if (direction == -1 &amp;&amp; startIndex &gt; 0) {</span>
<span class="nc" id="L3427">                            endIndex =</span>
<span class="nc" id="L3428">                                Utilities.getRowEnd(JTextComponent.this,</span>
                                    startIndex - 1);
<span class="nc" id="L3430">                            startIndex =</span>
<span class="nc" id="L3431">                                Utilities.getRowStart(JTextComponent.this,</span>
                                    startIndex - 1);
<span class="nc bnc" id="L3433" title="All 4 branches missed.">                            if (startIndex &gt;= 0 &amp;&amp; endIndex &gt;= startIndex) {</span>
<span class="nc" id="L3434">                                lineSequence =</span>
                                    new AccessibleTextSequence(startIndex,
                                        endIndex,
<span class="nc" id="L3437">                                        model.getText(startIndex,</span>
                                            endIndex - startIndex + 1));
                            }
<span class="nc bnc" id="L3440" title="All 2 branches missed.">                        } else if (direction == 1 &amp;&amp;</span>
<span class="nc bnc" id="L3441" title="All 2 branches missed.">                         endIndex &lt; model.getLength()) {</span>
<span class="nc" id="L3442">                            startIndex =</span>
<span class="nc" id="L3443">                                Utilities.getRowStart(JTextComponent.this,</span>
                                    endIndex + 1);
<span class="nc" id="L3445">                            endIndex =</span>
<span class="nc" id="L3446">                                Utilities.getRowEnd(JTextComponent.this,</span>
                                    endIndex + 1);
<span class="nc bnc" id="L3448" title="All 4 branches missed.">                            if (startIndex &gt;= 0 &amp;&amp; endIndex &gt;= startIndex) {</span>
<span class="nc" id="L3449">                                lineSequence =</span>
                                    new AccessibleTextSequence(startIndex,
<span class="nc" id="L3451">                                        endIndex, model.getText(startIndex,</span>
                                            endIndex - startIndex + 1));
                            }
                        }
                        // already validated 'direction' above...
                    }
<span class="nc" id="L3457">                } catch(BadLocationException e) {</span>
                    // we are intentionally silent; our contract says we return
                    // null if there is any failure in this method
                } finally {
<span class="nc bnc" id="L3461" title="All 6 branches missed.">                    if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L3462">                        ((AbstractDocument)model).readUnlock();</span>
                    }
                }
<span class="nc" id="L3465">                return lineSequence;</span>

            case AccessibleExtendedText.ATTRIBUTE_RUN:
                // assumptions: (1) that all characters in a single element
                // share the same attribute set; (2) that adjacent elements
                // *may* share the same attribute set

                int attributeRunStartIndex, attributeRunEndIndex;
<span class="nc" id="L3473">                String runText = null;</span>
<span class="nc bnc" id="L3474" title="All 2 branches missed.">                if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L3475">                    ((AbstractDocument)model).readLock();</span>
                }

                try {
<span class="nc" id="L3479">                    attributeRunStartIndex = attributeRunEndIndex =</span>
                     Integer.MIN_VALUE;
<span class="nc" id="L3481">                    int tempIndex = index;</span>
<span class="nc bnc" id="L3482" title="All 4 branches missed.">                    switch (direction) {</span>
                    case -1:
                        // going backwards, so find left edge of this run -
                        // that'll be the end of the previous run
                        // (off-by-one counting)
<span class="nc" id="L3487">                        attributeRunEndIndex = getRunEdge(index, direction);</span>
                        // now set ourselves up to find the left edge of the
                        // prev. run
<span class="nc" id="L3490">                        tempIndex = attributeRunEndIndex - 1;</span>
<span class="nc" id="L3491">                        break;</span>
                    case 1:
                        // going forward, so find right edge of this run -
                        // that'll be the start of the next run
                        // (off-by-one counting)
<span class="nc" id="L3496">                        attributeRunStartIndex = getRunEdge(index, direction);</span>
                        // now set ourselves up to find the right edge of the
                        // next run
<span class="nc" id="L3499">                        tempIndex = attributeRunStartIndex;</span>
<span class="nc" id="L3500">                        break;</span>
                    case 0:
                        // interested in the current run, so nothing special to
                        // set up in advance...
<span class="nc" id="L3504">                        break;</span>
                    default:
                        // only those three values of direction allowed...
<span class="nc" id="L3507">                        throw new AssertionError(direction);</span>
                    }

                    // set the unset edge; if neither set then we're getting
                    // both edges of the current run around our 'index'
<span class="nc bnc" id="L3512" title="All 2 branches missed.">                    attributeRunStartIndex =</span>
                        (attributeRunStartIndex != Integer.MIN_VALUE) ?
<span class="nc" id="L3514">                        attributeRunStartIndex : getRunEdge(tempIndex, -1);</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">                    attributeRunEndIndex =</span>
                        (attributeRunEndIndex != Integer.MIN_VALUE) ?
<span class="nc" id="L3517">                        attributeRunEndIndex : getRunEdge(tempIndex, 1);</span>

<span class="nc" id="L3519">                    runText = model.getText(attributeRunStartIndex,</span>
                                            attributeRunEndIndex -
                                            attributeRunStartIndex);
<span class="nc" id="L3522">                } catch (BadLocationException e) {</span>
                    // we are intentionally silent; our contract says we return
                    // null if there is any failure in this method
<span class="nc" id="L3525">                    return null;</span>
                } finally {
<span class="nc bnc" id="L3527" title="All 6 branches missed.">                    if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L3528">                        ((AbstractDocument)model).readUnlock();</span>
                    }
                }
<span class="nc" id="L3531">                return new AccessibleTextSequence(attributeRunStartIndex,</span>
                                                  attributeRunEndIndex,
                                                  runText);

            default:
                break;
            }
<span class="nc" id="L3538">            return null;</span>
        }


        /**
         * Starting at text position &lt;code&gt;index&lt;/code&gt;, and going in
         * &lt;code&gt;direction&lt;/code&gt;, return the edge of run that shares the
         * same &lt;code&gt;AttributeSet&lt;/code&gt; and parent element as those at
         * &lt;code&gt;index&lt;/code&gt;.
         *
         * Note: we assume the document is already locked...
         */
        private int getRunEdge(int index, int direction) throws
         BadLocationException {
<span class="nc bnc" id="L3552" title="All 4 branches missed.">            if (index &lt; 0 || index &gt;= model.getLength()) {</span>
<span class="nc" id="L3553">                throw new BadLocationException(&quot;Location out of bounds&quot;, index);</span>
            }
            // locate the Element at index
            Element indexElement;
            // locate the Element at our index/offset
<span class="nc" id="L3558">            int elementIndex = -1;        // test for initialization</span>
<span class="nc" id="L3559">            for (indexElement = model.getDefaultRootElement();</span>
<span class="nc bnc" id="L3560" title="All 2 branches missed.">                 ! indexElement.isLeaf(); ) {</span>
<span class="nc" id="L3561">                elementIndex = indexElement.getElementIndex(index);</span>
<span class="nc" id="L3562">                indexElement = indexElement.getElement(elementIndex);</span>
            }
<span class="nc bnc" id="L3564" title="All 2 branches missed.">            if (elementIndex == -1) {</span>
<span class="nc" id="L3565">                throw new AssertionError(index);</span>
            }
            // cache the AttributeSet and parentElement atindex
<span class="nc" id="L3568">            AttributeSet indexAS = indexElement.getAttributes();</span>
<span class="nc" id="L3569">            Element parent = indexElement.getParentElement();</span>

            // find the first Element before/after ours w/the same AttributeSet
            // if we are already at edge of the first element in our parent
            // then return that edge
            Element edgeElement;
<span class="nc bnc" id="L3575" title="All 2 branches missed.">            switch (direction) {</span>
            case -1:
            case 1:
<span class="nc" id="L3578">                int edgeElementIndex = elementIndex;</span>
<span class="nc" id="L3579">                int elementCount = parent.getElementCount();</span>
<span class="nc bnc" id="L3580" title="All 4 branches missed.">                while ((edgeElementIndex + direction) &gt; 0 &amp;&amp;</span>
                       ((edgeElementIndex + direction) &lt; elementCount) &amp;&amp;
<span class="nc" id="L3582">                       parent.getElement(edgeElementIndex</span>
<span class="nc bnc" id="L3583" title="All 2 branches missed.">                       + direction).getAttributes().isEqual(indexAS)) {</span>
<span class="nc" id="L3584">                    edgeElementIndex += direction;</span>
                }
<span class="nc" id="L3586">                edgeElement = parent.getElement(edgeElementIndex);</span>
<span class="nc" id="L3587">                break;</span>
            default:
<span class="nc" id="L3589">                throw new AssertionError(direction);</span>
            }
<span class="nc bnc" id="L3591" title="All 3 branches missed.">            switch (direction) {</span>
            case -1:
<span class="nc" id="L3593">                return edgeElement.getStartOffset();</span>
            case 1:
<span class="nc" id="L3595">                return edgeElement.getEndOffset();</span>
            default:
                // we already caught this case earlier; this is to satisfy
                // the compiler...
<span class="nc" id="L3599">                return Integer.MIN_VALUE;</span>
            }
        }

        // getTextRange() not needed; defined in AccessibleEditableText

        /**
         * Returns the &lt;code&gt;AccessibleTextSequence&lt;/code&gt; at a given
         * &lt;code&gt;index&lt;/code&gt;.
         *
         * @param part the &lt;code&gt;CHARACTER&lt;/code&gt;, &lt;code&gt;WORD&lt;/code&gt;,
         * &lt;code&gt;SENTENCE&lt;/code&gt;, &lt;code&gt;LINE&lt;/code&gt; or
         * &lt;code&gt;ATTRIBUTE_RUN&lt;/code&gt; to retrieve
         * @param index an index within the text
         * @return an &lt;code&gt;AccessibleTextSequence&lt;/code&gt; specifying the text if
         * &lt;code&gt;part&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; are valid.  Otherwise,
         * &lt;code&gt;null&lt;/code&gt; is returned
         *
         * @see javax.accessibility.AccessibleText#CHARACTER
         * @see javax.accessibility.AccessibleText#WORD
         * @see javax.accessibility.AccessibleText#SENTENCE
         * @see javax.accessibility.AccessibleExtendedText#LINE
         * @see javax.accessibility.AccessibleExtendedText#ATTRIBUTE_RUN
         *
         * @since 1.6
         */
        public AccessibleTextSequence getTextSequenceAt(int part, int index) {
<span class="nc" id="L3626">            return getSequenceAtIndex(part, index, 0);</span>
        }

        /**
         * Returns the &lt;code&gt;AccessibleTextSequence&lt;/code&gt; after a given
         * &lt;code&gt;index&lt;/code&gt;.
         *
         * @param part the &lt;code&gt;CHARACTER&lt;/code&gt;, &lt;code&gt;WORD&lt;/code&gt;,
         * &lt;code&gt;SENTENCE&lt;/code&gt;, &lt;code&gt;LINE&lt;/code&gt; or
         * &lt;code&gt;ATTRIBUTE_RUN&lt;/code&gt; to retrieve
         * @param index an index within the text
         * @return an &lt;code&gt;AccessibleTextSequence&lt;/code&gt; specifying the text
         * if &lt;code&gt;part&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; are valid.  Otherwise,
         * &lt;code&gt;null&lt;/code&gt; is returned
         *
         * @see javax.accessibility.AccessibleText#CHARACTER
         * @see javax.accessibility.AccessibleText#WORD
         * @see javax.accessibility.AccessibleText#SENTENCE
         * @see javax.accessibility.AccessibleExtendedText#LINE
         * @see javax.accessibility.AccessibleExtendedText#ATTRIBUTE_RUN
         *
         * @since 1.6
         */
        public AccessibleTextSequence getTextSequenceAfter(int part, int index) {
<span class="nc" id="L3650">            return getSequenceAtIndex(part, index, 1);</span>
        }

        /**
         * Returns the &lt;code&gt;AccessibleTextSequence&lt;/code&gt; before a given
         * &lt;code&gt;index&lt;/code&gt;.
         *
         * @param part the &lt;code&gt;CHARACTER&lt;/code&gt;, &lt;code&gt;WORD&lt;/code&gt;,
         * &lt;code&gt;SENTENCE&lt;/code&gt;, &lt;code&gt;LINE&lt;/code&gt; or
         * &lt;code&gt;ATTRIBUTE_RUN&lt;/code&gt; to retrieve
         * @param index an index within the text
         * @return an &lt;code&gt;AccessibleTextSequence&lt;/code&gt; specifying the text
         * if &lt;code&gt;part&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; are valid.  Otherwise,
         * &lt;code&gt;null&lt;/code&gt; is returned
         *
         * @see javax.accessibility.AccessibleText#CHARACTER
         * @see javax.accessibility.AccessibleText#WORD
         * @see javax.accessibility.AccessibleText#SENTENCE
         * @see javax.accessibility.AccessibleExtendedText#LINE
         * @see javax.accessibility.AccessibleExtendedText#ATTRIBUTE_RUN
         *
         * @since 1.6
         */
        public AccessibleTextSequence getTextSequenceBefore(int part, int index) {
<span class="nc" id="L3674">            return getSequenceAtIndex(part, index, -1);</span>
        }

        /**
         * Returns the &lt;code&gt;Rectangle&lt;/code&gt; enclosing the text between
         * two indicies.
         *
         * @param startIndex the start index in the text
         * @param endIndex the end index in the text
         * @return the bounding rectangle of the text if the indices are valid.
         * Otherwise, &lt;code&gt;null&lt;/code&gt; is returned
         *
         * @since 1.6
         */
        public Rectangle getTextBounds(int startIndex, int endIndex) {
<span class="nc bnc" id="L3689" title="All 6 branches missed.">            if (startIndex &lt; 0 || startIndex &gt; model.getLength()-1 ||</span>
<span class="nc bnc" id="L3690" title="All 4 branches missed.">                endIndex &lt; 0 || endIndex &gt; model.getLength()-1 ||</span>
                startIndex &gt; endIndex) {
<span class="nc" id="L3692">                return null;</span>
            }
<span class="nc" id="L3694">            TextUI ui = getUI();</span>
<span class="nc bnc" id="L3695" title="All 2 branches missed.">            if (ui == null) {</span>
<span class="nc" id="L3696">                return null;</span>
            }
<span class="nc" id="L3698">            Rectangle rect = null;</span>
<span class="nc" id="L3699">            Rectangle alloc = getRootEditorRect();</span>
<span class="nc bnc" id="L3700" title="All 2 branches missed.">            if (alloc == null) {</span>
<span class="nc" id="L3701">                return null;</span>
            }
<span class="nc bnc" id="L3703" title="All 2 branches missed.">            if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L3704">                ((AbstractDocument)model).readLock();</span>
            }
            try {
<span class="nc" id="L3707">                View rootView = ui.getRootView(JTextComponent.this);</span>
<span class="nc bnc" id="L3708" title="All 2 branches missed.">                if (rootView != null) {</span>
<span class="nc" id="L3709">                    Shape bounds = rootView.modelToView(startIndex,</span>
                                    Position.Bias.Forward, endIndex,
                                    Position.Bias.Backward, alloc);

<span class="nc bnc" id="L3713" title="All 2 branches missed.">                    rect = (bounds instanceof Rectangle) ?</span>
<span class="nc" id="L3714">                     (Rectangle)bounds : bounds.getBounds();</span>

                }
<span class="nc" id="L3717">            } catch (BadLocationException e) {</span>
            } finally {
<span class="nc bnc" id="L3719" title="All 6 branches missed.">                if (model instanceof AbstractDocument) {</span>
<span class="nc" id="L3720">                    ((AbstractDocument)model).readUnlock();</span>
                }
            }
<span class="nc" id="L3723">            return rect;</span>
        }

        // ----- end AccessibleExtendedText methods


        // --- interface AccessibleAction methods ------------------------

        public AccessibleAction getAccessibleAction() {
<span class="nc" id="L3732">            return this;</span>
        }

        /**
         * Returns the number of accessible actions available in this object
         * If there are more than one, the first one is considered the
         * &quot;default&quot; action of the object.
         *
         * @return the zero-based number of Actions in this object
         * @since 1.4
         */
        public int getAccessibleActionCount() {
<span class="nc" id="L3744">            Action [] actions = JTextComponent.this.getActions();</span>
<span class="nc" id="L3745">            return actions.length;</span>
        }

        /**
         * Returns a description of the specified action of the object.
         *
         * @param i zero-based index of the actions
         * @return a String description of the action
         * @see #getAccessibleActionCount
         * @since 1.4
         */
        public String getAccessibleActionDescription(int i) {
<span class="nc" id="L3757">            Action [] actions = JTextComponent.this.getActions();</span>
<span class="nc bnc" id="L3758" title="All 4 branches missed.">            if (i &lt; 0 || i &gt;= actions.length) {</span>
<span class="nc" id="L3759">                return null;</span>
            }
<span class="nc" id="L3761">            return (String)actions[i].getValue(Action.NAME);</span>
        }

        /**
         * Performs the specified Action on the object
         *
         * @param i zero-based index of actions
         * @return true if the action was performed; otherwise false.
         * @see #getAccessibleActionCount
         * @since 1.4
         */
        public boolean doAccessibleAction(int i) {
<span class="nc" id="L3773">            Action [] actions = JTextComponent.this.getActions();</span>
<span class="nc bnc" id="L3774" title="All 4 branches missed.">            if (i &lt; 0 || i &gt;= actions.length) {</span>
<span class="nc" id="L3775">                return false;</span>
            }
<span class="nc" id="L3777">            ActionEvent ae =</span>
                new ActionEvent(JTextComponent.this,
                                ActionEvent.ACTION_PERFORMED, null,
<span class="nc" id="L3780">                                EventQueue.getMostRecentEventTime(),</span>
<span class="nc" id="L3781">                                getCurrentEventModifiers());</span>
<span class="nc" id="L3782">            actions[i].actionPerformed(ae);</span>
<span class="nc" id="L3783">            return true;</span>
        }

        // ----- end AccessibleAction methods


    }


    // --- serialization ---------------------------------------------

    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException
    {
<span class="nc" id="L3797">        s.defaultReadObject();</span>
<span class="nc" id="L3798">        caretEvent = new MutableCaretEvent(this);</span>
<span class="nc" id="L3799">        addMouseListener(caretEvent);</span>
<span class="nc" id="L3800">        addFocusListener(caretEvent);</span>
<span class="nc" id="L3801">    }</span>

    // --- member variables ----------------------------------

    /**
     * The document model.
     */
    private Document model;

    /**
     * The caret used to display the insert position
     * and navigate throughout the document.
     *
     * PENDING(prinz)
     * This should be serializable, default installed
     * by UI.
     */
    private transient Caret caret;

    /**
     * Object responsible for restricting the cursor navigation.
     */
    private NavigationFilter navigationFilter;

    /**
     * The object responsible for managing highlights.
     *
     * PENDING(prinz)
     * This should be serializable, default installed
     * by UI.
     */
    private transient Highlighter highlighter;

    /**
     * The current key bindings in effect.
     *
     * PENDING(prinz)
     * This should be serializable, default installed
     * by UI.
     */
    private transient Keymap keymap;

    private transient MutableCaretEvent caretEvent;
    private Color caretColor;
    private Color selectionColor;
    private Color selectedTextColor;
    private Color disabledTextColor;
    private boolean editable;
    private Insets margin;
    private char focusAccelerator;
    private boolean dragEnabled;

    /**
     * The drop mode for this component.
     */
<span class="nc" id="L3856">    private DropMode dropMode = DropMode.USE_SELECTION;</span>

    /**
     * The drop location.
     */
    private transient DropLocation dropLocation;

    /**
     * Represents a drop location for &lt;code&gt;JTextComponent&lt;/code&gt;s.
     *
     * @see #getDropLocation
     * @since 1.6
     */
    public static final class DropLocation extends TransferHandler.DropLocation {
        private final int index;
        private final Position.Bias bias;

        private DropLocation(Point p, int index, Position.Bias bias) {
<span class="nc" id="L3874">            super(p);</span>
<span class="nc" id="L3875">            this.index = index;</span>
<span class="nc" id="L3876">            this.bias = bias;</span>
<span class="nc" id="L3877">        }</span>

        /**
         * Returns the index where dropped data should be inserted into the
         * associated component. This index represents a position between
         * characters, as would be interpreted by a caret.
         *
         * @return the drop index
         */
        public int getIndex() {
<span class="nc" id="L3887">            return index;</span>
        }

        /**
         * Returns the bias for the drop index.
         *
         * @return the drop bias
         */
        public Position.Bias getBias() {
<span class="nc" id="L3896">            return bias;</span>
        }

        /**
         * Returns a string representation of this drop location.
         * This method is intended to be used for debugging purposes,
         * and the content and format of the returned string may vary
         * between implementations.
         *
         * @return a string representation of this drop location
         */
        public String toString() {
<span class="nc" id="L3908">            return getClass().getName()</span>
<span class="nc" id="L3909">                   + &quot;[dropPoint=&quot; + getDropPoint() + &quot;,&quot;</span>
                   + &quot;index=&quot; + index + &quot;,&quot;
                   + &quot;bias=&quot; + bias + &quot;]&quot;;
        }
    }

    /**
     * TransferHandler used if one hasn't been supplied by the UI.
     */
    private static DefaultTransferHandler defaultTransferHandler;

    /**
     * Maps from class name to Boolean indicating if
     * &lt;code&gt;processInputMethodEvent&lt;/code&gt; has been overriden.
     */
    private static Map&lt;String, Boolean&gt; overrideMap;

    /**
     * Returns a string representation of this &lt;code&gt;JTextComponent&lt;/code&gt;.
     * This method is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     * &lt;P&gt;
     * Overriding &lt;code&gt;paramString&lt;/code&gt; to provide information about the
     * specific new aspects of the JFC components.
     *
     * @return  a string representation of this &lt;code&gt;JTextComponent&lt;/code&gt;
     */
    protected String paramString() {
<span class="nc bnc" id="L3939" title="All 2 branches missed.">        String editableString = (editable ?</span>
                                 &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L3941" title="All 2 branches missed.">        String caretColorString = (caretColor != null ?</span>
<span class="nc" id="L3942">                                   caretColor.toString() : &quot;&quot;);</span>
<span class="nc bnc" id="L3943" title="All 2 branches missed.">        String selectionColorString = (selectionColor != null ?</span>
<span class="nc" id="L3944">                                       selectionColor.toString() : &quot;&quot;);</span>
<span class="nc bnc" id="L3945" title="All 2 branches missed.">        String selectedTextColorString = (selectedTextColor != null ?</span>
<span class="nc" id="L3946">                                          selectedTextColor.toString() : &quot;&quot;);</span>
<span class="nc bnc" id="L3947" title="All 2 branches missed.">        String disabledTextColorString = (disabledTextColor != null ?</span>
<span class="nc" id="L3948">                                          disabledTextColor.toString() : &quot;&quot;);</span>
<span class="nc bnc" id="L3949" title="All 2 branches missed.">        String marginString = (margin != null ?</span>
<span class="nc" id="L3950">                               margin.toString() : &quot;&quot;);</span>

<span class="nc" id="L3952">        return super.paramString() +</span>
        &quot;,caretColor=&quot; + caretColorString +
        &quot;,disabledTextColor=&quot; + disabledTextColorString +
        &quot;,editable=&quot; + editableString +
        &quot;,margin=&quot; + marginString +
        &quot;,selectedTextColor=&quot; + selectedTextColorString +
        &quot;,selectionColor=&quot; + selectionColorString;
    }


    /**
     * A Simple TransferHandler that exports the data as a String, and
     * imports the data from the String clipboard.  This is only used
     * if the UI hasn't supplied one, which would only happen if someone
     * hasn't subclassed Basic.
     */
<span class="nc" id="L3968">    static class DefaultTransferHandler extends TransferHandler implements</span>
                                        UIResource {
        public void exportToClipboard(JComponent comp, Clipboard clipboard,
                                      int action) throws IllegalStateException {
<span class="nc bnc" id="L3972" title="All 2 branches missed.">            if (comp instanceof JTextComponent) {</span>
<span class="nc" id="L3973">                JTextComponent text = (JTextComponent)comp;</span>
<span class="nc" id="L3974">                int p0 = text.getSelectionStart();</span>
<span class="nc" id="L3975">                int p1 = text.getSelectionEnd();</span>
<span class="nc bnc" id="L3976" title="All 2 branches missed.">                if (p0 != p1) {</span>
                    try {
<span class="nc" id="L3978">                        Document doc = text.getDocument();</span>
<span class="nc" id="L3979">                        String srcData = doc.getText(p0, p1 - p0);</span>
<span class="nc" id="L3980">                        StringSelection contents =new StringSelection(srcData);</span>

                        // this may throw an IllegalStateException,
                        // but it will be caught and handled in the
                        // action that invoked this method
<span class="nc" id="L3985">                        clipboard.setContents(contents, null);</span>

<span class="nc bnc" id="L3987" title="All 2 branches missed.">                        if (action == TransferHandler.MOVE) {</span>
<span class="nc" id="L3988">                            doc.remove(p0, p1 - p0);</span>
                        }
<span class="nc" id="L3990">                    } catch (BadLocationException ble) {}</span>
                }
            }
<span class="nc" id="L3993">        }</span>
        public boolean importData(JComponent comp, Transferable t) {
<span class="nc bnc" id="L3995" title="All 2 branches missed.">            if (comp instanceof JTextComponent) {</span>
<span class="nc" id="L3996">                DataFlavor flavor = getFlavor(t.getTransferDataFlavors());</span>

<span class="nc bnc" id="L3998" title="All 2 branches missed.">                if (flavor != null) {</span>
<span class="nc" id="L3999">                    InputContext ic = comp.getInputContext();</span>
<span class="nc bnc" id="L4000" title="All 2 branches missed.">                    if (ic != null) {</span>
<span class="nc" id="L4001">                        ic.endComposition();</span>
                    }
                    try {
<span class="nc" id="L4004">                        String data = (String)t.getTransferData(flavor);</span>

<span class="nc" id="L4006">                        ((JTextComponent)comp).replaceSelection(data);</span>
<span class="nc" id="L4007">                        return true;</span>
<span class="nc" id="L4008">                    } catch (UnsupportedFlavorException ufe) {</span>
<span class="nc" id="L4009">                    } catch (IOException ioe) {</span>
<span class="nc" id="L4010">                    }</span>
                }
            }
<span class="nc" id="L4013">            return false;</span>
        }
        public boolean canImport(JComponent comp,
                                 DataFlavor[] transferFlavors) {
<span class="nc" id="L4017">            JTextComponent c = (JTextComponent)comp;</span>
<span class="nc bnc" id="L4018" title="All 4 branches missed.">            if (!(c.isEditable() &amp;&amp; c.isEnabled())) {</span>
<span class="nc" id="L4019">                return false;</span>
            }
<span class="nc bnc" id="L4021" title="All 2 branches missed.">            return (getFlavor(transferFlavors) != null);</span>
        }
        public int getSourceActions(JComponent c) {
<span class="nc" id="L4024">            return NONE;</span>
        }
        private DataFlavor getFlavor(DataFlavor[] flavors) {
<span class="nc bnc" id="L4027" title="All 2 branches missed.">            if (flavors != null) {</span>
<span class="nc bnc" id="L4028" title="All 2 branches missed.">                for (DataFlavor flavor : flavors) {</span>
<span class="nc bnc" id="L4029" title="All 2 branches missed.">                    if (flavor.equals(DataFlavor.stringFlavor)) {</span>
<span class="nc" id="L4030">                        return flavor;</span>
                    }
                }
            }
<span class="nc" id="L4034">            return null;</span>
        }
    }

    /**
     * Returns the JTextComponent that most recently had focus. The returned
     * value may currently have focus.
     */
    static final JTextComponent getFocusedComponent() {
<span class="nc" id="L4043">        return (JTextComponent)AppContext.getAppContext().</span>
<span class="nc" id="L4044">            get(FOCUSED_COMPONENT);</span>
    }

    private int getCurrentEventModifiers() {
<span class="nc" id="L4048">        int modifiers = 0;</span>
<span class="nc" id="L4049">        AWTEvent currentEvent = EventQueue.getCurrentEvent();</span>
<span class="nc bnc" id="L4050" title="All 2 branches missed.">        if (currentEvent instanceof InputEvent) {</span>
<span class="nc" id="L4051">            modifiers = ((InputEvent)currentEvent).getModifiers();</span>
<span class="nc bnc" id="L4052" title="All 2 branches missed.">        } else if (currentEvent instanceof ActionEvent) {</span>
<span class="nc" id="L4053">            modifiers = ((ActionEvent)currentEvent).getModifiers();</span>
        }
<span class="nc" id="L4055">        return modifiers;</span>
    }

<span class="nc" id="L4058">    private static final Object KEYMAP_TABLE =</span>
        new StringBuilder(&quot;JTextComponent_KeymapTable&quot;);

    //
    // member variables used for on-the-spot input method
    // editing style support
    //
    private transient InputMethodRequests inputMethodRequestsHandler;
    private SimpleAttributeSet composedTextAttribute;
    private String composedTextContent;
    private Position composedTextStart;
    private Position composedTextEnd;
    private Position latestCommittedTextStart;
    private Position latestCommittedTextEnd;
    private ComposedTextCaret composedTextCaret;
    private transient Caret originalCaret;
    /**
     * Set to true after the check for the override of processInputMethodEvent
     * has been checked.
     */
    private boolean checkedInputOverride;
    private boolean needToSendKeyTypedEvent;

    static class DefaultKeymap implements Keymap {

<span class="nc" id="L4083">        DefaultKeymap(String nm, Keymap parent) {</span>
<span class="nc" id="L4084">            this.nm = nm;</span>
<span class="nc" id="L4085">            this.parent = parent;</span>
<span class="nc" id="L4086">            bindings = new Hashtable&lt;KeyStroke, Action&gt;();</span>
<span class="nc" id="L4087">        }</span>

        /**
         * Fetch the default action to fire if a
         * key is typed (ie a KEY_TYPED KeyEvent is received)
         * and there is no binding for it.  Typically this
         * would be some action that inserts text so that
         * the keymap doesn't require an action for each
         * possible key.
         */
        public Action getDefaultAction() {
<span class="nc bnc" id="L4098" title="All 2 branches missed.">            if (defaultAction != null) {</span>
<span class="nc" id="L4099">                return defaultAction;</span>
            }
<span class="nc bnc" id="L4101" title="All 2 branches missed.">            return (parent != null) ? parent.getDefaultAction() : null;</span>
        }

        /**
         * Set the default action to fire if a key is typed.
         */
        public void setDefaultAction(Action a) {
<span class="nc" id="L4108">            defaultAction = a;</span>
<span class="nc" id="L4109">        }</span>

        public String getName() {
<span class="nc" id="L4112">            return nm;</span>
        }

        public Action getAction(KeyStroke key) {
<span class="nc" id="L4116">            Action a = bindings.get(key);</span>
<span class="nc bnc" id="L4117" title="All 4 branches missed.">            if ((a == null) &amp;&amp; (parent != null)) {</span>
<span class="nc" id="L4118">                a = parent.getAction(key);</span>
            }
<span class="nc" id="L4120">            return a;</span>
        }

        public KeyStroke[] getBoundKeyStrokes() {
<span class="nc" id="L4124">            KeyStroke[] keys = new KeyStroke[bindings.size()];</span>
<span class="nc" id="L4125">            int i = 0;</span>
<span class="nc bnc" id="L4126" title="All 2 branches missed.">            for (Enumeration&lt;KeyStroke&gt; e = bindings.keys() ; e.hasMoreElements() ;) {</span>
<span class="nc" id="L4127">                keys[i++] = e.nextElement();</span>
            }
<span class="nc" id="L4129">            return keys;</span>
        }

        public Action[] getBoundActions() {
<span class="nc" id="L4133">            Action[] actions = new Action[bindings.size()];</span>
<span class="nc" id="L4134">            int i = 0;</span>
<span class="nc bnc" id="L4135" title="All 2 branches missed.">            for (Enumeration&lt;Action&gt; e = bindings.elements() ; e.hasMoreElements() ;) {</span>
<span class="nc" id="L4136">                actions[i++] = e.nextElement();</span>
            }
<span class="nc" id="L4138">            return actions;</span>
        }

        public KeyStroke[] getKeyStrokesForAction(Action a) {
<span class="nc bnc" id="L4142" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc" id="L4143">                return null;</span>
            }
<span class="nc" id="L4145">            KeyStroke[] retValue = null;</span>
            // Determine local bindings first.
<span class="nc" id="L4147">            Vector&lt;KeyStroke&gt; keyStrokes = null;</span>
<span class="nc bnc" id="L4148" title="All 2 branches missed.">            for (Enumeration&lt;KeyStroke&gt; keys = bindings.keys(); keys.hasMoreElements();) {</span>
<span class="nc" id="L4149">                KeyStroke key = keys.nextElement();</span>
<span class="nc bnc" id="L4150" title="All 2 branches missed.">                if (bindings.get(key) == a) {</span>
<span class="nc bnc" id="L4151" title="All 2 branches missed.">                    if (keyStrokes == null) {</span>
<span class="nc" id="L4152">                        keyStrokes = new Vector&lt;KeyStroke&gt;();</span>
                    }
<span class="nc" id="L4154">                    keyStrokes.addElement(key);</span>
                }
<span class="nc" id="L4156">            }</span>
            // See if the parent has any.
<span class="nc bnc" id="L4158" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L4159">                KeyStroke[] pStrokes = parent.getKeyStrokesForAction(a);</span>
<span class="nc bnc" id="L4160" title="All 2 branches missed.">                if (pStrokes != null) {</span>
                    // Remove any bindings defined in the parent that
                    // are locally defined.
<span class="nc" id="L4163">                    int rCount = 0;</span>
<span class="nc bnc" id="L4164" title="All 2 branches missed.">                    for (int counter = pStrokes.length - 1; counter &gt;= 0;</span>
<span class="nc" id="L4165">                         counter--) {</span>
<span class="nc bnc" id="L4166" title="All 2 branches missed.">                        if (isLocallyDefined(pStrokes[counter])) {</span>
<span class="nc" id="L4167">                            pStrokes[counter] = null;</span>
<span class="nc" id="L4168">                            rCount++;</span>
                        }
                    }
<span class="nc bnc" id="L4171" title="All 4 branches missed.">                    if (rCount &gt; 0 &amp;&amp; rCount &lt; pStrokes.length) {</span>
<span class="nc bnc" id="L4172" title="All 2 branches missed.">                        if (keyStrokes == null) {</span>
<span class="nc" id="L4173">                            keyStrokes = new Vector&lt;KeyStroke&gt;();</span>
                        }
<span class="nc bnc" id="L4175" title="All 2 branches missed.">                        for (int counter = pStrokes.length - 1; counter &gt;= 0;</span>
<span class="nc" id="L4176">                             counter--) {</span>
<span class="nc bnc" id="L4177" title="All 2 branches missed.">                            if (pStrokes[counter] != null) {</span>
<span class="nc" id="L4178">                                keyStrokes.addElement(pStrokes[counter]);</span>
                            }
                        }
                    }
<span class="nc bnc" id="L4182" title="All 2 branches missed.">                    else if (rCount == 0) {</span>
<span class="nc bnc" id="L4183" title="All 2 branches missed.">                        if (keyStrokes == null) {</span>
<span class="nc" id="L4184">                            retValue = pStrokes;</span>
                        }
                        else {
<span class="nc" id="L4187">                            retValue = new KeyStroke[keyStrokes.size() +</span>
                                                    pStrokes.length];
<span class="nc" id="L4189">                            keyStrokes.copyInto(retValue);</span>
<span class="nc" id="L4190">                            System.arraycopy(pStrokes, 0, retValue,</span>
<span class="nc" id="L4191">                                        keyStrokes.size(), pStrokes.length);</span>
<span class="nc" id="L4192">                            keyStrokes = null;</span>
                        }
                    }
                }
            }
<span class="nc bnc" id="L4197" title="All 2 branches missed.">            if (keyStrokes != null) {</span>
<span class="nc" id="L4198">                retValue = new KeyStroke[keyStrokes.size()];</span>
<span class="nc" id="L4199">                keyStrokes.copyInto(retValue);</span>
            }
<span class="nc" id="L4201">            return retValue;</span>
        }

        public boolean isLocallyDefined(KeyStroke key) {
<span class="nc" id="L4205">            return bindings.containsKey(key);</span>
        }

        public void addActionForKeyStroke(KeyStroke key, Action a) {
<span class="nc" id="L4209">            bindings.put(key, a);</span>
<span class="nc" id="L4210">        }</span>

        public void removeKeyStrokeBinding(KeyStroke key) {
<span class="nc" id="L4213">            bindings.remove(key);</span>
<span class="nc" id="L4214">        }</span>

        public void removeBindings() {
<span class="nc" id="L4217">            bindings.clear();</span>
<span class="nc" id="L4218">        }</span>

        public Keymap getResolveParent() {
<span class="nc" id="L4221">            return parent;</span>
        }

        public void setResolveParent(Keymap parent) {
<span class="nc" id="L4225">            this.parent = parent;</span>
<span class="nc" id="L4226">        }</span>

        /**
         * String representation of the keymap... potentially
         * a very long string.
         */
        public String toString() {
<span class="nc" id="L4233">            return &quot;Keymap[&quot; + nm + &quot;]&quot; + bindings;</span>
        }

        String nm;
        Keymap parent;
        Hashtable&lt;KeyStroke, Action&gt; bindings;
        Action defaultAction;
    }


    /**
     * KeymapWrapper wraps a Keymap inside an InputMap. For KeymapWrapper
     * to be useful it must be used with a KeymapActionMap.
     * KeymapWrapper for the most part, is an InputMap with two parents.
     * The first parent visited is ALWAYS the Keymap, with the second
     * parent being the parent inherited from InputMap. If
     * &lt;code&gt;keymap.getAction&lt;/code&gt; returns null, implying the Keymap
     * does not have a binding for the KeyStroke,
     * the parent is then visited. If the Keymap has a binding, the
     * Action is returned, if not and the KeyStroke represents a
     * KeyTyped event and the Keymap has a defaultAction,
     * &lt;code&gt;DefaultActionKey&lt;/code&gt; is returned.
     * &lt;p&gt;KeymapActionMap is then able to transate the object passed in
     * to either message the Keymap, or message its default implementation.
     */
    static class KeymapWrapper extends InputMap {
<span class="nc" id="L4259">        static final Object DefaultActionKey = new Object();</span>

        private Keymap keymap;

<span class="nc" id="L4263">        KeymapWrapper(Keymap keymap) {</span>
<span class="nc" id="L4264">            this.keymap = keymap;</span>
<span class="nc" id="L4265">        }</span>

        public KeyStroke[] keys() {
<span class="nc" id="L4268">            KeyStroke[] sKeys = super.keys();</span>
<span class="nc" id="L4269">            KeyStroke[] keymapKeys = keymap.getBoundKeyStrokes();</span>
<span class="nc bnc" id="L4270" title="All 2 branches missed.">            int sCount = (sKeys == null) ? 0 : sKeys.length;</span>
<span class="nc bnc" id="L4271" title="All 2 branches missed.">            int keymapCount = (keymapKeys == null) ? 0 : keymapKeys.length;</span>
<span class="nc bnc" id="L4272" title="All 2 branches missed.">            if (sCount == 0) {</span>
<span class="nc" id="L4273">                return keymapKeys;</span>
            }
<span class="nc bnc" id="L4275" title="All 2 branches missed.">            if (keymapCount == 0) {</span>
<span class="nc" id="L4276">                return sKeys;</span>
            }
<span class="nc" id="L4278">            KeyStroke[] retValue = new KeyStroke[sCount + keymapCount];</span>
            // There may be some duplication here...
<span class="nc" id="L4280">            System.arraycopy(sKeys, 0, retValue, 0, sCount);</span>
<span class="nc" id="L4281">            System.arraycopy(keymapKeys, 0, retValue, sCount, keymapCount);</span>
<span class="nc" id="L4282">            return retValue;</span>
        }

        public int size() {
            // There may be some duplication here...
<span class="nc" id="L4287">            KeyStroke[] keymapStrokes = keymap.getBoundKeyStrokes();</span>
<span class="nc bnc" id="L4288" title="All 2 branches missed.">            int keymapCount = (keymapStrokes == null) ? 0:</span>
                               keymapStrokes.length;
<span class="nc" id="L4290">            return super.size() + keymapCount;</span>
        }

        public Object get(KeyStroke keyStroke) {
<span class="nc" id="L4294">            Object retValue = keymap.getAction(keyStroke);</span>
<span class="nc bnc" id="L4295" title="All 2 branches missed.">            if (retValue == null) {</span>
<span class="nc" id="L4296">                retValue = super.get(keyStroke);</span>
<span class="nc bnc" id="L4297" title="All 2 branches missed.">                if (retValue == null &amp;&amp;</span>
<span class="nc bnc" id="L4298" title="All 2 branches missed.">                    keyStroke.getKeyChar() != KeyEvent.CHAR_UNDEFINED &amp;&amp;</span>
<span class="nc bnc" id="L4299" title="All 2 branches missed.">                    keymap.getDefaultAction() != null) {</span>
                    // Implies this is a KeyTyped event, use the default
                    // action.
<span class="nc" id="L4302">                    retValue = DefaultActionKey;</span>
                }
            }
<span class="nc" id="L4305">            return retValue;</span>
        }
    }


    /**
     * Wraps a Keymap inside an ActionMap. This is used with
     * a KeymapWrapper. If &lt;code&gt;get&lt;/code&gt; is passed in
     * &lt;code&gt;KeymapWrapper.DefaultActionKey&lt;/code&gt;, the default action is
     * returned, otherwise if the key is an Action, it is returned.
     */
    static class KeymapActionMap extends ActionMap {
        private Keymap keymap;

<span class="nc" id="L4319">        KeymapActionMap(Keymap keymap) {</span>
<span class="nc" id="L4320">            this.keymap = keymap;</span>
<span class="nc" id="L4321">        }</span>

        public Object[] keys() {
<span class="nc" id="L4324">            Object[] sKeys = super.keys();</span>
<span class="nc" id="L4325">            Object[] keymapKeys = keymap.getBoundActions();</span>
<span class="nc bnc" id="L4326" title="All 2 branches missed.">            int sCount = (sKeys == null) ? 0 : sKeys.length;</span>
<span class="nc bnc" id="L4327" title="All 2 branches missed.">            int keymapCount = (keymapKeys == null) ? 0 : keymapKeys.length;</span>
<span class="nc bnc" id="L4328" title="All 2 branches missed.">            boolean hasDefault = (keymap.getDefaultAction() != null);</span>
<span class="nc bnc" id="L4329" title="All 2 branches missed.">            if (hasDefault) {</span>
<span class="nc" id="L4330">                keymapCount++;</span>
            }
<span class="nc bnc" id="L4332" title="All 2 branches missed.">            if (sCount == 0) {</span>
<span class="nc bnc" id="L4333" title="All 2 branches missed.">                if (hasDefault) {</span>
<span class="nc" id="L4334">                    Object[] retValue = new Object[keymapCount];</span>
<span class="nc bnc" id="L4335" title="All 2 branches missed.">                    if (keymapCount &gt; 1) {</span>
<span class="nc" id="L4336">                        System.arraycopy(keymapKeys, 0, retValue, 0,</span>
                                         keymapCount - 1);
                    }
<span class="nc" id="L4339">                    retValue[keymapCount - 1] = KeymapWrapper.DefaultActionKey;</span>
<span class="nc" id="L4340">                    return retValue;</span>
                }
<span class="nc" id="L4342">                return keymapKeys;</span>
            }
<span class="nc bnc" id="L4344" title="All 2 branches missed.">            if (keymapCount == 0) {</span>
<span class="nc" id="L4345">                return sKeys;</span>
            }
<span class="nc" id="L4347">            Object[] retValue = new Object[sCount + keymapCount];</span>
            // There may be some duplication here...
<span class="nc" id="L4349">            System.arraycopy(sKeys, 0, retValue, 0, sCount);</span>
<span class="nc bnc" id="L4350" title="All 2 branches missed.">            if (hasDefault) {</span>
<span class="nc bnc" id="L4351" title="All 2 branches missed.">                if (keymapCount &gt; 1) {</span>
<span class="nc" id="L4352">                    System.arraycopy(keymapKeys, 0, retValue, sCount,</span>
                                     keymapCount - 1);
                }
<span class="nc" id="L4355">                retValue[sCount + keymapCount - 1] = KeymapWrapper.</span>
                                                 DefaultActionKey;
            }
            else {
<span class="nc" id="L4359">                System.arraycopy(keymapKeys, 0, retValue, sCount, keymapCount);</span>
            }
<span class="nc" id="L4361">            return retValue;</span>
        }

        public int size() {
            // There may be some duplication here...
<span class="nc" id="L4366">            Object[] actions = keymap.getBoundActions();</span>
<span class="nc bnc" id="L4367" title="All 2 branches missed.">            int keymapCount = (actions == null) ? 0 : actions.length;</span>
<span class="nc bnc" id="L4368" title="All 2 branches missed.">            if (keymap.getDefaultAction() != null) {</span>
<span class="nc" id="L4369">                keymapCount++;</span>
            }
<span class="nc" id="L4371">            return super.size() + keymapCount;</span>
        }

        public Action get(Object key) {
<span class="nc" id="L4375">            Action retValue = super.get(key);</span>
<span class="nc bnc" id="L4376" title="All 2 branches missed.">            if (retValue == null) {</span>
                // Try the Keymap.
<span class="nc bnc" id="L4378" title="All 2 branches missed.">                if (key == KeymapWrapper.DefaultActionKey) {</span>
<span class="nc" id="L4379">                    retValue = keymap.getDefaultAction();</span>
                }
<span class="nc bnc" id="L4381" title="All 2 branches missed.">                else if (key instanceof Action) {</span>
                    // This is a little iffy, technically an Action is
                    // a valid Key. We're assuming the Action came from
                    // the InputMap though.
<span class="nc" id="L4385">                    retValue = (Action)key;</span>
                }
            }
<span class="nc" id="L4388">            return retValue;</span>
        }
    }

<span class="nc" id="L4392">    private static final Object FOCUSED_COMPONENT =</span>
        new StringBuilder(&quot;JTextComponent_FocusedComponent&quot;);

    /**
     * The default keymap that will be shared by all
     * &lt;code&gt;JTextComponent&lt;/code&gt; instances unless they
     * have had a different keymap set.
     */
    public static final String DEFAULT_KEYMAP = &quot;default&quot;;

    /**
     * Event to use when firing a notification of change to caret
     * position.  This is mutable so that the event can be reused
     * since caret events can be fairly high in bandwidth.
     */
    static class MutableCaretEvent extends CaretEvent implements ChangeListener, FocusListener, MouseListener {

        MutableCaretEvent(JTextComponent c) {
<span class="nc" id="L4410">            super(c);</span>
<span class="nc" id="L4411">        }</span>

        final void fire() {
<span class="nc" id="L4414">            JTextComponent c = (JTextComponent) getSource();</span>
<span class="nc bnc" id="L4415" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L4416">                Caret caret = c.getCaret();</span>
<span class="nc" id="L4417">                dot = caret.getDot();</span>
<span class="nc" id="L4418">                mark = caret.getMark();</span>
<span class="nc" id="L4419">                c.fireCaretUpdate(this);</span>
            }
<span class="nc" id="L4421">        }</span>

        public final String toString() {
<span class="nc" id="L4424">            return &quot;dot=&quot; + dot + &quot;,&quot; + &quot;mark=&quot; + mark;</span>
        }

        // --- CaretEvent methods -----------------------

        public final int getDot() {
<span class="nc" id="L4430">            return dot;</span>
        }

        public final int getMark() {
<span class="nc" id="L4434">            return mark;</span>
        }

        // --- ChangeListener methods -------------------

        public final void stateChanged(ChangeEvent e) {
<span class="nc bnc" id="L4440" title="All 2 branches missed.">            if (! dragActive) {</span>
<span class="nc" id="L4441">                fire();</span>
            }
<span class="nc" id="L4443">        }</span>

        // --- FocusListener methods -----------------------------------
        public void focusGained(FocusEvent fe) {
<span class="nc" id="L4447">            AppContext.getAppContext().put(FOCUSED_COMPONENT,</span>
<span class="nc" id="L4448">                                           fe.getSource());</span>
<span class="nc" id="L4449">        }</span>

        public void focusLost(FocusEvent fe) {
<span class="nc" id="L4452">        }</span>

        // --- MouseListener methods -----------------------------------

        /**
         * Requests focus on the associated
         * text component, and try to set the cursor position.
         *
         * @param e the mouse event
         * @see MouseListener#mousePressed
         */
        public final void mousePressed(MouseEvent e) {
<span class="nc" id="L4464">            dragActive = true;</span>
<span class="nc" id="L4465">        }</span>

        /**
         * Called when the mouse is released.
         *
         * @param e the mouse event
         * @see MouseListener#mouseReleased
         */
        public final void mouseReleased(MouseEvent e) {
<span class="nc" id="L4474">            dragActive = false;</span>
<span class="nc" id="L4475">            fire();</span>
<span class="nc" id="L4476">        }</span>

        public final void mouseClicked(MouseEvent e) {
<span class="nc" id="L4479">        }</span>

        public final void mouseEntered(MouseEvent e) {
<span class="nc" id="L4482">        }</span>

        public final void mouseExited(MouseEvent e) {
<span class="nc" id="L4485">        }</span>

        private boolean dragActive;
        private int dot;
        private int mark;
    }

    //
    // Process any input method events that the component itself
    // recognizes. The default on-the-spot handling for input method
    // composed(uncommitted) text is done here after all input
    // method listeners get called for stealing the events.
    //
    protected void processInputMethodEvent(InputMethodEvent e) {
        // let listeners handle the events
<span class="nc" id="L4500">        super.processInputMethodEvent(e);</span>

<span class="nc bnc" id="L4502" title="All 2 branches missed.">        if (!e.isConsumed()) {</span>
<span class="nc bnc" id="L4503" title="All 2 branches missed.">            if (! isEditable()) {</span>
<span class="nc" id="L4504">                return;</span>
            } else {
<span class="nc bnc" id="L4506" title="All 3 branches missed.">                switch (e.getID()) {</span>
                case InputMethodEvent.INPUT_METHOD_TEXT_CHANGED:
<span class="nc" id="L4508">                    replaceInputMethodText(e);</span>

                    // fall through

                case InputMethodEvent.CARET_POSITION_CHANGED:
<span class="nc" id="L4513">                    setInputMethodCaretPosition(e);</span>
                    break;
                }
            }

<span class="nc" id="L4518">            e.consume();</span>
        }
<span class="nc" id="L4520">    }</span>

    //
    // Overrides this method to become an active input method client.
    //
    public InputMethodRequests getInputMethodRequests() {
<span class="nc bnc" id="L4526" title="All 2 branches missed.">        if (inputMethodRequestsHandler == null) {</span>
<span class="nc" id="L4527">            inputMethodRequestsHandler = new InputMethodRequestsHandler();</span>
<span class="nc" id="L4528">            Document doc = getDocument();</span>
<span class="nc bnc" id="L4529" title="All 2 branches missed.">            if (doc != null) {</span>
<span class="nc" id="L4530">                doc.addDocumentListener((DocumentListener)inputMethodRequestsHandler);</span>
            }
        }

<span class="nc" id="L4534">        return inputMethodRequestsHandler;</span>
    }

    //
    // Overrides this method to watch the listener installed.
    //
    public void addInputMethodListener(InputMethodListener l) {
<span class="nc" id="L4541">        super.addInputMethodListener(l);</span>
<span class="nc bnc" id="L4542" title="All 2 branches missed.">        if (l != null) {</span>
<span class="nc" id="L4543">            needToSendKeyTypedEvent = false;</span>
<span class="nc" id="L4544">            checkedInputOverride = true;</span>
        }
<span class="nc" id="L4546">    }</span>


    //
    // Default implementation of the InputMethodRequests interface.
    //
<span class="nc" id="L4552">    class InputMethodRequestsHandler implements InputMethodRequests, DocumentListener {</span>

        // --- InputMethodRequests methods ---

        public AttributedCharacterIterator cancelLatestCommittedText(
                                                Attribute[] attributes) {
<span class="nc" id="L4558">            Document doc = getDocument();</span>
<span class="nc bnc" id="L4559" title="All 4 branches missed.">            if ((doc != null) &amp;&amp; (latestCommittedTextStart != null)</span>
<span class="nc bnc" id="L4560" title="All 2 branches missed.">                &amp;&amp; (!latestCommittedTextStart.equals(latestCommittedTextEnd))) {</span>
                try {
<span class="nc" id="L4562">                    int startIndex = latestCommittedTextStart.getOffset();</span>
<span class="nc" id="L4563">                    int endIndex = latestCommittedTextEnd.getOffset();</span>
<span class="nc" id="L4564">                    String latestCommittedText =</span>
<span class="nc" id="L4565">                        doc.getText(startIndex, endIndex - startIndex);</span>
<span class="nc" id="L4566">                    doc.remove(startIndex, endIndex - startIndex);</span>
<span class="nc" id="L4567">                    return new AttributedString(latestCommittedText).getIterator();</span>
<span class="nc" id="L4568">                } catch (BadLocationException ble) {}</span>
            }
<span class="nc" id="L4570">            return null;</span>
        }

        public AttributedCharacterIterator getCommittedText(int beginIndex,
                                        int endIndex, Attribute[] attributes) {
<span class="nc" id="L4575">            int composedStartIndex = 0;</span>
<span class="nc" id="L4576">            int composedEndIndex = 0;</span>
<span class="nc bnc" id="L4577" title="All 2 branches missed.">            if (composedTextExists()) {</span>
<span class="nc" id="L4578">                composedStartIndex = composedTextStart.getOffset();</span>
<span class="nc" id="L4579">                composedEndIndex = composedTextEnd.getOffset();</span>
            }

            String committed;
            try {
<span class="nc bnc" id="L4584" title="All 2 branches missed.">                if (beginIndex &lt; composedStartIndex) {</span>
<span class="nc bnc" id="L4585" title="All 2 branches missed.">                    if (endIndex &lt;= composedStartIndex) {</span>
<span class="nc" id="L4586">                        committed = getText(beginIndex, endIndex - beginIndex);</span>
                    } else {
<span class="nc" id="L4588">                        int firstPartLength = composedStartIndex - beginIndex;</span>
<span class="nc" id="L4589">                        committed = getText(beginIndex, firstPartLength) +</span>
<span class="nc" id="L4590">                            getText(composedEndIndex, endIndex - beginIndex - firstPartLength);</span>
<span class="nc" id="L4591">                    }</span>
                } else {
<span class="nc" id="L4593">                    committed = getText(beginIndex + (composedEndIndex - composedStartIndex),</span>
                                        endIndex - beginIndex);
                }
<span class="nc" id="L4596">            } catch (BadLocationException ble) {</span>
<span class="nc" id="L4597">                throw new IllegalArgumentException(&quot;Invalid range&quot;);</span>
<span class="nc" id="L4598">            }</span>
<span class="nc" id="L4599">            return new AttributedString(committed).getIterator();</span>
        }

        public int getCommittedTextLength() {
<span class="nc" id="L4603">            Document doc = getDocument();</span>
<span class="nc" id="L4604">            int length = 0;</span>
<span class="nc bnc" id="L4605" title="All 2 branches missed.">            if (doc != null) {</span>
<span class="nc" id="L4606">                length = doc.getLength();</span>
<span class="nc bnc" id="L4607" title="All 2 branches missed.">                if (composedTextContent != null) {</span>
<span class="nc bnc" id="L4608" title="All 2 branches missed.">                    if (composedTextEnd == null</span>
<span class="nc bnc" id="L4609" title="All 2 branches missed.">                          || composedTextStart == null) {</span>
                        /*
                         * fix for : 6355666
                         * this is the case when this method is invoked
                         * from DocumentListener. At this point
                         * composedTextEnd and composedTextStart are
                         * not defined yet.
                         */
<span class="nc" id="L4617">                        length -= composedTextContent.length();</span>
                    } else {
<span class="nc" id="L4619">                        length -= composedTextEnd.getOffset() -</span>
<span class="nc" id="L4620">                            composedTextStart.getOffset();</span>
                    }
                }
            }
<span class="nc" id="L4624">            return length;</span>
        }

        public int getInsertPositionOffset() {
<span class="nc" id="L4628">            int composedStartIndex = 0;</span>
<span class="nc" id="L4629">            int composedEndIndex = 0;</span>
<span class="nc bnc" id="L4630" title="All 2 branches missed.">            if (composedTextExists()) {</span>
<span class="nc" id="L4631">                composedStartIndex = composedTextStart.getOffset();</span>
<span class="nc" id="L4632">                composedEndIndex = composedTextEnd.getOffset();</span>
            }
<span class="nc" id="L4634">            int caretIndex = getCaretPosition();</span>

<span class="nc bnc" id="L4636" title="All 2 branches missed.">            if (caretIndex &lt; composedStartIndex) {</span>
<span class="nc" id="L4637">                return caretIndex;</span>
<span class="nc bnc" id="L4638" title="All 2 branches missed.">            } else if (caretIndex &lt; composedEndIndex) {</span>
<span class="nc" id="L4639">                return composedStartIndex;</span>
            } else {
<span class="nc" id="L4641">                return caretIndex - (composedEndIndex - composedStartIndex);</span>
            }
        }

        public TextHitInfo getLocationOffset(int x, int y) {
<span class="nc bnc" id="L4646" title="All 2 branches missed.">            if (composedTextAttribute == null) {</span>
<span class="nc" id="L4647">                return null;</span>
            } else {
<span class="nc" id="L4649">                Point p = getLocationOnScreen();</span>
<span class="nc" id="L4650">                p.x = x - p.x;</span>
<span class="nc" id="L4651">                p.y = y - p.y;</span>
<span class="nc" id="L4652">                int pos = viewToModel(p);</span>
<span class="nc bnc" id="L4653" title="All 2 branches missed.">                if ((pos &gt;= composedTextStart.getOffset()) &amp;&amp;</span>
<span class="nc bnc" id="L4654" title="All 2 branches missed.">                    (pos &lt;= composedTextEnd.getOffset())) {</span>
<span class="nc" id="L4655">                    return TextHitInfo.leading(pos - composedTextStart.getOffset());</span>
                } else {
<span class="nc" id="L4657">                    return null;</span>
                }
            }
        }

        public Rectangle getTextLocation(TextHitInfo offset) {
            Rectangle r;

            try {
<span class="nc" id="L4666">                r = modelToView(getCaretPosition());</span>
<span class="nc bnc" id="L4667" title="All 2 branches missed.">                if (r != null) {</span>
<span class="nc" id="L4668">                    Point p = getLocationOnScreen();</span>
<span class="nc" id="L4669">                    r.translate(p.x, p.y);</span>
                }
<span class="nc" id="L4671">            } catch (BadLocationException ble) {</span>
<span class="nc" id="L4672">                r = null;</span>
<span class="nc" id="L4673">            }</span>

<span class="nc bnc" id="L4675" title="All 2 branches missed.">            if (r == null)</span>
<span class="nc" id="L4676">                r = new Rectangle();</span>

<span class="nc" id="L4678">            return r;</span>
        }

        public AttributedCharacterIterator getSelectedText(
                                                Attribute[] attributes) {
<span class="nc" id="L4683">            String selection = JTextComponent.this.getSelectedText();</span>
<span class="nc bnc" id="L4684" title="All 2 branches missed.">            if (selection != null) {</span>
<span class="nc" id="L4685">                return new AttributedString(selection).getIterator();</span>
            } else {
<span class="nc" id="L4687">                return null;</span>
            }
        }

        // --- DocumentListener methods ---

        public void changedUpdate(DocumentEvent e) {
<span class="nc" id="L4694">            latestCommittedTextStart = latestCommittedTextEnd = null;</span>
<span class="nc" id="L4695">        }</span>

        public void insertUpdate(DocumentEvent e) {
<span class="nc" id="L4698">            latestCommittedTextStart = latestCommittedTextEnd = null;</span>
<span class="nc" id="L4699">        }</span>

        public void removeUpdate(DocumentEvent e) {
<span class="nc" id="L4702">            latestCommittedTextStart = latestCommittedTextEnd = null;</span>
<span class="nc" id="L4703">        }</span>
    }

    //
    // Replaces the current input method (composed) text according to
    // the passed input method event. This method also inserts the
    // committed text into the document.
    //
    private void replaceInputMethodText(InputMethodEvent e) {
<span class="nc" id="L4712">        int commitCount = e.getCommittedCharacterCount();</span>
<span class="nc" id="L4713">        AttributedCharacterIterator text = e.getText();</span>
        int composedTextIndex;

        // old composed text deletion
<span class="nc" id="L4717">        Document doc = getDocument();</span>
<span class="nc bnc" id="L4718" title="All 2 branches missed.">        if (composedTextExists()) {</span>
            try {
<span class="nc" id="L4720">                doc.remove(composedTextStart.getOffset(),</span>
<span class="nc" id="L4721">                           composedTextEnd.getOffset() -</span>
<span class="nc" id="L4722">                           composedTextStart.getOffset());</span>
<span class="nc" id="L4723">            } catch (BadLocationException ble) {}</span>
<span class="nc" id="L4724">            composedTextStart = composedTextEnd = null;</span>
<span class="nc" id="L4725">            composedTextAttribute = null;</span>
<span class="nc" id="L4726">            composedTextContent = null;</span>
        }

<span class="nc bnc" id="L4729" title="All 2 branches missed.">        if (text != null) {</span>
<span class="nc" id="L4730">            text.first();</span>
<span class="nc" id="L4731">            int committedTextStartIndex = 0;</span>
<span class="nc" id="L4732">            int committedTextEndIndex = 0;</span>

            // committed text insertion
<span class="nc bnc" id="L4735" title="All 2 branches missed.">            if (commitCount &gt; 0) {</span>
                // Remember latest committed text start index
<span class="nc" id="L4737">                committedTextStartIndex = caret.getDot();</span>

                // Need to generate KeyTyped events for the committed text for components
                // that are not aware they are active input method clients.
<span class="nc bnc" id="L4741" title="All 2 branches missed.">                if (shouldSynthensizeKeyEvents()) {</span>
<span class="nc bnc" id="L4742" title="All 2 branches missed.">                    for (char c = text.current(); commitCount &gt; 0;</span>
<span class="nc" id="L4743">                         c = text.next(), commitCount--) {</span>
<span class="nc" id="L4744">                        KeyEvent ke = new KeyEvent(this, KeyEvent.KEY_TYPED,</span>
<span class="nc" id="L4745">                                                   EventQueue.getMostRecentEventTime(),</span>
                                                   0, KeyEvent.VK_UNDEFINED, c);
<span class="nc" id="L4747">                        processKeyEvent(ke);</span>
                    }
                } else {
<span class="nc" id="L4750">                    StringBuilder strBuf = new StringBuilder();</span>
<span class="nc bnc" id="L4751" title="All 2 branches missed.">                    for (char c = text.current(); commitCount &gt; 0;</span>
<span class="nc" id="L4752">                         c = text.next(), commitCount--) {</span>
<span class="nc" id="L4753">                        strBuf.append(c);</span>
                    }

                    // map it to an ActionEvent
<span class="nc" id="L4757">                    mapCommittedTextToAction(strBuf.toString());</span>
                }

                // Remember latest committed text end index
<span class="nc" id="L4761">                committedTextEndIndex = caret.getDot();</span>
            }

            // new composed text insertion
<span class="nc" id="L4765">            composedTextIndex = text.getIndex();</span>
<span class="nc bnc" id="L4766" title="All 2 branches missed.">            if (composedTextIndex &lt; text.getEndIndex()) {</span>
<span class="nc" id="L4767">                createComposedTextAttribute(composedTextIndex, text);</span>
                try {
<span class="nc" id="L4769">                    replaceSelection(null);</span>
<span class="nc" id="L4770">                    doc.insertString(caret.getDot(), composedTextContent,</span>
                                        composedTextAttribute);
<span class="nc" id="L4772">                    composedTextStart = doc.createPosition(caret.getDot() -</span>
<span class="nc" id="L4773">                                                composedTextContent.length());</span>
<span class="nc" id="L4774">                    composedTextEnd = doc.createPosition(caret.getDot());</span>
<span class="nc" id="L4775">                } catch (BadLocationException ble) {</span>
<span class="nc" id="L4776">                    composedTextStart = composedTextEnd = null;</span>
<span class="nc" id="L4777">                    composedTextAttribute = null;</span>
<span class="nc" id="L4778">                    composedTextContent = null;</span>
<span class="nc" id="L4779">                }</span>
            }

            // Save the latest committed text information
<span class="nc bnc" id="L4783" title="All 2 branches missed.">            if (committedTextStartIndex != committedTextEndIndex) {</span>
                try {
<span class="nc" id="L4785">                    latestCommittedTextStart = doc.</span>
<span class="nc" id="L4786">                        createPosition(committedTextStartIndex);</span>
<span class="nc" id="L4787">                    latestCommittedTextEnd = doc.</span>
<span class="nc" id="L4788">                        createPosition(committedTextEndIndex);</span>
<span class="nc" id="L4789">                } catch (BadLocationException ble) {</span>
<span class="nc" id="L4790">                    latestCommittedTextStart =</span>
                        latestCommittedTextEnd = null;
<span class="nc" id="L4792">                }</span>
            } else {
<span class="nc" id="L4794">                latestCommittedTextStart =</span>
                    latestCommittedTextEnd = null;
            }
        }
<span class="nc" id="L4798">    }</span>

    private void createComposedTextAttribute(int composedIndex,
                                        AttributedCharacterIterator text) {
<span class="nc" id="L4802">        Document doc = getDocument();</span>
<span class="nc" id="L4803">        StringBuilder strBuf = new StringBuilder();</span>

        // create attributed string with no attributes
<span class="nc" id="L4806">        for (char c = text.setIndex(composedIndex);</span>
<span class="nc bnc" id="L4807" title="All 2 branches missed.">             c != CharacterIterator.DONE; c = text.next()) {</span>
<span class="nc" id="L4808">            strBuf.append(c);</span>
        }

<span class="nc" id="L4811">        composedTextContent = strBuf.toString();</span>
<span class="nc" id="L4812">        composedTextAttribute = new SimpleAttributeSet();</span>
<span class="nc" id="L4813">        composedTextAttribute.addAttribute(StyleConstants.ComposedTextAttribute,</span>
<span class="nc" id="L4814">                new AttributedString(text, composedIndex, text.getEndIndex()));</span>
<span class="nc" id="L4815">    }</span>

    /**
     * Saves composed text around the specified position.
     *
     * The composed text (if any) around the specified position is saved
     * in a backing store and removed from the document.
     *
     * @param pos  document position to identify the composed text location
     * @return  {@code true} if the composed text exists and is saved,
     *          {@code false} otherwise
     * @see #restoreComposedText
     * @since 1.7
     */
    protected boolean saveComposedText(int pos) {
<span class="nc bnc" id="L4830" title="All 2 branches missed.">        if (composedTextExists()) {</span>
<span class="nc" id="L4831">            int start = composedTextStart.getOffset();</span>
<span class="nc" id="L4832">            int len = composedTextEnd.getOffset() -</span>
<span class="nc" id="L4833">                composedTextStart.getOffset();</span>
<span class="nc bnc" id="L4834" title="All 4 branches missed.">            if (pos &gt;= start &amp;&amp; pos &lt;= start + len) {</span>
                try {
<span class="nc" id="L4836">                    getDocument().remove(start, len);</span>
<span class="nc" id="L4837">                    return true;</span>
<span class="nc" id="L4838">                } catch (BadLocationException ble) {}</span>
            }
        }
<span class="nc" id="L4841">        return false;</span>
    }

    /**
     * Restores composed text previously saved by {@code saveComposedText}.
     *
     * The saved composed text is inserted back into the document. This method
     * should be invoked only if {@code saveComposedText} returns {@code true}.
     *
     * @see #saveComposedText
     * @since 1.7
     */
    protected void restoreComposedText() {
<span class="nc" id="L4854">        Document doc = getDocument();</span>
        try {
<span class="nc" id="L4856">            doc.insertString(caret.getDot(),</span>
                             composedTextContent,
                             composedTextAttribute);
<span class="nc" id="L4859">            composedTextStart = doc.createPosition(caret.getDot() -</span>
<span class="nc" id="L4860">                                composedTextContent.length());</span>
<span class="nc" id="L4861">            composedTextEnd = doc.createPosition(caret.getDot());</span>
<span class="nc" id="L4862">        } catch (BadLocationException ble) {}</span>
<span class="nc" id="L4863">    }</span>

    //
    // Map committed text to an ActionEvent. If the committed text length is 1,
    // treat it as a KeyStroke, otherwise or there is no KeyStroke defined,
    // treat it just as a default action.
    //
    private void mapCommittedTextToAction(String committedText) {
<span class="nc" id="L4871">        Keymap binding = getKeymap();</span>
<span class="nc bnc" id="L4872" title="All 2 branches missed.">        if (binding != null) {</span>
<span class="nc" id="L4873">            Action a = null;</span>
<span class="nc bnc" id="L4874" title="All 2 branches missed.">            if (committedText.length() == 1) {</span>
<span class="nc" id="L4875">                KeyStroke k = KeyStroke.getKeyStroke(committedText.charAt(0));</span>
<span class="nc" id="L4876">                a = binding.getAction(k);</span>
            }

<span class="nc bnc" id="L4879" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc" id="L4880">                a = binding.getDefaultAction();</span>
            }

<span class="nc bnc" id="L4883" title="All 2 branches missed.">            if (a != null) {</span>
<span class="nc" id="L4884">                ActionEvent ae =</span>
                    new ActionEvent(this, ActionEvent.ACTION_PERFORMED,
                                    committedText,
<span class="nc" id="L4887">                                    EventQueue.getMostRecentEventTime(),</span>
<span class="nc" id="L4888">                                    getCurrentEventModifiers());</span>
<span class="nc" id="L4889">                a.actionPerformed(ae);</span>
            }
        }
<span class="nc" id="L4892">    }</span>

    //
    // Sets the caret position according to the passed input method
    // event. Also, sets/resets composed text caret appropriately.
    //
    private void setInputMethodCaretPosition(InputMethodEvent e) {
        int dot;

<span class="nc bnc" id="L4901" title="All 2 branches missed.">        if (composedTextExists()) {</span>
<span class="nc" id="L4902">            dot = composedTextStart.getOffset();</span>
<span class="nc bnc" id="L4903" title="All 2 branches missed.">            if (!(caret instanceof ComposedTextCaret)) {</span>
<span class="nc bnc" id="L4904" title="All 2 branches missed.">                if (composedTextCaret == null) {</span>
<span class="nc" id="L4905">                    composedTextCaret = new ComposedTextCaret();</span>
                }
<span class="nc" id="L4907">                originalCaret = caret;</span>
                // Sets composed text caret
<span class="nc" id="L4909">                exchangeCaret(originalCaret, composedTextCaret);</span>
            }

<span class="nc" id="L4912">            TextHitInfo caretPos = e.getCaret();</span>
<span class="nc bnc" id="L4913" title="All 2 branches missed.">            if (caretPos != null) {</span>
<span class="nc" id="L4914">                int index = caretPos.getInsertionIndex();</span>
<span class="nc" id="L4915">                dot += index;</span>
<span class="nc bnc" id="L4916" title="All 2 branches missed.">                if (index == 0) {</span>
                    // Scroll the component if needed so that the composed text
                    // becomes visible.
                    try {
<span class="nc" id="L4920">                        Rectangle d = modelToView(dot);</span>
<span class="nc" id="L4921">                        Rectangle end = modelToView(composedTextEnd.getOffset());</span>
<span class="nc" id="L4922">                        Rectangle b = getBounds();</span>
<span class="nc" id="L4923">                        d.x += Math.min(end.x - d.x, b.width);</span>
<span class="nc" id="L4924">                        scrollRectToVisible(d);</span>
<span class="nc" id="L4925">                    } catch (BadLocationException ble) {}</span>
                }
            }
<span class="nc" id="L4928">            caret.setDot(dot);</span>
<span class="nc bnc" id="L4929" title="All 2 branches missed.">        } else if (caret instanceof ComposedTextCaret) {</span>
<span class="nc" id="L4930">            dot = caret.getDot();</span>
            // Restores original caret
<span class="nc" id="L4932">            exchangeCaret(caret, originalCaret);</span>
<span class="nc" id="L4933">            caret.setDot(dot);</span>
        }
<span class="nc" id="L4935">    }</span>

    private void exchangeCaret(Caret oldCaret, Caret newCaret) {
<span class="nc" id="L4938">        int blinkRate = oldCaret.getBlinkRate();</span>
<span class="nc" id="L4939">        setCaret(newCaret);</span>
<span class="nc" id="L4940">        caret.setBlinkRate(blinkRate);</span>
<span class="nc" id="L4941">        caret.setVisible(hasFocus());</span>
<span class="nc" id="L4942">    }</span>

    /**
     * Returns true if KeyEvents should be synthesized from an InputEvent.
     */
    private boolean shouldSynthensizeKeyEvents() {
<span class="nc bnc" id="L4948" title="All 2 branches missed.">        if (!checkedInputOverride) {</span>
<span class="nc" id="L4949">            checkedInputOverride = true;</span>
<span class="nc" id="L4950">            needToSendKeyTypedEvent =</span>
<span class="nc bnc" id="L4951" title="All 2 branches missed.">                             !isProcessInputMethodEventOverridden();</span>
        }
<span class="nc" id="L4953">        return needToSendKeyTypedEvent;</span>
    }

    //
    // Checks whether the client code overrides processInputMethodEvent.  If it is overridden,
    // need not to generate KeyTyped events for committed text. If it's not, behave as an
    // passive input method client.
    //
    private boolean isProcessInputMethodEventOverridden() {
<span class="nc bnc" id="L4962" title="All 2 branches missed.">        if (overrideMap == null) {</span>
<span class="nc" id="L4963">            overrideMap = Collections.synchronizedMap(new HashMap&lt;String, Boolean&gt;());</span>
        }
<span class="nc" id="L4965">        Boolean retValue = overrideMap.get(getClass().getName());</span>

<span class="nc bnc" id="L4967" title="All 2 branches missed.">        if (retValue != null) {</span>
<span class="nc" id="L4968">            return retValue.booleanValue();</span>
        }
<span class="nc" id="L4970">        Boolean ret = AccessController.doPrivileged(new</span>
<span class="nc" id="L4971">                       PrivilegedAction&lt;Boolean&gt;() {</span>
            public Boolean run() {
<span class="nc" id="L4973">                return isProcessInputMethodEventOverridden(</span>
<span class="nc" id="L4974">                                JTextComponent.this.getClass());</span>
            }
        });

<span class="nc" id="L4978">        return ret.booleanValue();</span>
    }

    //
    // Checks whether a composed text in this text component
    //
    boolean composedTextExists() {
<span class="nc bnc" id="L4985" title="All 2 branches missed.">        return (composedTextStart != null);</span>
    }

    //
    // Caret implementation for editing the composed text.
    //
<span class="nc" id="L4991">    class ComposedTextCaret extends DefaultCaret implements Serializable {</span>
        Color bg;

        //
        // Get the background color of the component
        //
        public void install(JTextComponent c) {
<span class="nc" id="L4998">            super.install(c);</span>

<span class="nc" id="L5000">            Document doc = c.getDocument();</span>
<span class="nc bnc" id="L5001" title="All 2 branches missed.">            if (doc instanceof StyledDocument) {</span>
<span class="nc" id="L5002">                StyledDocument sDoc = (StyledDocument)doc;</span>
<span class="nc" id="L5003">                Element elem = sDoc.getCharacterElement(c.composedTextStart.getOffset());</span>
<span class="nc" id="L5004">                AttributeSet attr = elem.getAttributes();</span>
<span class="nc" id="L5005">                bg = sDoc.getBackground(attr);</span>
            }

<span class="nc bnc" id="L5008" title="All 2 branches missed.">            if (bg == null) {</span>
<span class="nc" id="L5009">                bg = c.getBackground();</span>
            }
<span class="nc" id="L5011">        }</span>

        //
        // Draw caret in XOR mode.
        //
        public void paint(Graphics g) {
<span class="nc bnc" id="L5017" title="All 2 branches missed.">            if(isVisible()) {</span>
                try {
<span class="nc" id="L5019">                    Rectangle r = component.modelToView(getDot());</span>
<span class="nc" id="L5020">                    g.setXORMode(bg);</span>
<span class="nc" id="L5021">                    g.drawLine(r.x, r.y, r.x, r.y + r.height - 1);</span>
<span class="nc" id="L5022">                    g.setPaintMode();</span>
<span class="nc" id="L5023">                } catch (BadLocationException e) {</span>
                    // can't render I guess
                    //System.err.println(&quot;Can't render cursor&quot;);
<span class="nc" id="L5026">                }</span>
            }
<span class="nc" id="L5028">        }</span>

        //
        // If some area other than the composed text is clicked by mouse,
        // issue endComposition() to force commit the composed text.
        //
        protected void positionCaret(MouseEvent me) {
<span class="nc" id="L5035">            JTextComponent host = component;</span>
<span class="nc" id="L5036">            Point pt = new Point(me.getX(), me.getY());</span>
<span class="nc" id="L5037">            int offset = host.viewToModel(pt);</span>
<span class="nc" id="L5038">            int composedStartIndex = host.composedTextStart.getOffset();</span>
<span class="nc bnc" id="L5039" title="All 2 branches missed.">            if ((offset &lt; composedStartIndex) ||</span>
<span class="nc bnc" id="L5040" title="All 2 branches missed.">                (offset &gt; composedTextEnd.getOffset())) {</span>
                try {
                    // Issue endComposition
<span class="nc" id="L5043">                    Position newPos = host.getDocument().createPosition(offset);</span>
<span class="nc" id="L5044">                    host.getInputContext().endComposition();</span>

                    // Post a caret positioning runnable to assure that the positioning
                    // occurs *after* committing the composed text.
<span class="nc" id="L5048">                    EventQueue.invokeLater(new DoSetCaretPosition(host, newPos));</span>
<span class="nc" id="L5049">                } catch (BadLocationException ble) {</span>
<span class="nc" id="L5050">                    System.err.println(ble);</span>
<span class="nc" id="L5051">                }</span>
            } else {
                // Normal processing
<span class="nc" id="L5054">                super.positionCaret(me);</span>
            }
<span class="nc" id="L5056">        }</span>
    }

    //
    // Runnable class for invokeLater() to set caret position later.
    //
    private class DoSetCaretPosition implements Runnable {
        JTextComponent host;
        Position newPos;

<span class="nc" id="L5066">        DoSetCaretPosition(JTextComponent host, Position newPos) {</span>
<span class="nc" id="L5067">            this.host = host;</span>
<span class="nc" id="L5068">            this.newPos = newPos;</span>
<span class="nc" id="L5069">        }</span>

        public void run() {
<span class="nc" id="L5072">            host.setCaretPosition(newPos.getOffset());</span>
<span class="nc" id="L5073">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>