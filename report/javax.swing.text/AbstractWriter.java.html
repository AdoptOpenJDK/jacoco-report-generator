<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AbstractWriter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">AbstractWriter.java</span></div><h1>AbstractWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.text;

import java.io.Writer;
import java.io.IOException;
import java.util.Enumeration;

/**
 * AbstractWriter is an abstract class that actually
 * does the work of writing out the element tree
 * including the attributes.  In terms of how much is
 * written out per line, the writer defaults to 100.
 * But this value can be set by subclasses.
 *
 * @author Sunita Mani
 */

public abstract class AbstractWriter {

    private ElementIterator it;
    private Writer out;
<span class="nc" id="L46">    private int indentLevel = 0;</span>
<span class="nc" id="L47">    private int indentSpace = 2;</span>
<span class="nc" id="L48">    private Document doc = null;</span>
<span class="nc" id="L49">    private int maxLineLength = 100;</span>
<span class="nc" id="L50">    private int currLength = 0;</span>
<span class="nc" id="L51">    private int startOffset = 0;</span>
<span class="nc" id="L52">    private int endOffset = 0;</span>
    // If (indentLevel * indentSpace) becomes &gt;= maxLineLength, this will
    // get incremened instead of indentLevel to avoid indenting going greater
    // than line length.
<span class="nc" id="L56">    private int offsetIndent = 0;</span>

    /**
     * String used for end of line. If the Document has the property
     * EndOfLineStringProperty, it will be used for newlines. Otherwise
     * the System property line.separator will be used. The line separator
     * can also be set.
     */
    private String lineSeparator;

    /**
     * True indicates that when writing, the line can be split, false
     * indicates that even if the line is &gt; than max line length it should
     * not be split.
     */
    private boolean canWrapLines;

    /**
     * True while the current line is empty. This will remain true after
     * indenting.
     */
    private boolean isLineEmpty;

    /**
     * Used when indenting. Will contain the spaces.
     */
    private char[] indentChars;

    /**
     * Used when writing out a string.
     */
    private char[] tempChars;

    /**
     * This is used in &lt;code&gt;writeLineSeparator&lt;/code&gt; instead of
     * tempChars. If tempChars were used it would mean write couldn't invoke
     * &lt;code&gt;writeLineSeparator&lt;/code&gt; as it might have been passed
     * tempChars.
     */
    private char[] newlineChars;

    /**
     * Used for writing text.
     */
    private Segment segment;

    /**
     * How the text packages models newlines.
     * @see #getLineSeparator
     */
    protected static final char NEWLINE = '\n';


    /**
     * Creates a new AbstractWriter.
     * Initializes the ElementIterator with the default
     * root of the document.
     *
     * @param w a Writer.
     * @param doc a Document
     */
    protected AbstractWriter(Writer w, Document doc) {
<span class="nc" id="L118">        this(w, doc, 0, doc.getLength());</span>
<span class="nc" id="L119">    }</span>

    /**
     * Creates a new AbstractWriter.
     * Initializes the ElementIterator with the
     * element passed in.
     *
     * @param w a Writer
     * @param doc an Element
     * @param pos The location in the document to fetch the
     *   content.
     * @param len The amount to write out.
     */
<span class="nc" id="L132">    protected AbstractWriter(Writer w, Document doc, int pos, int len) {</span>
<span class="nc" id="L133">        this.doc = doc;</span>
<span class="nc" id="L134">        it = new ElementIterator(doc.getDefaultRootElement());</span>
<span class="nc" id="L135">        out = w;</span>
<span class="nc" id="L136">        startOffset = pos;</span>
<span class="nc" id="L137">        endOffset = pos + len;</span>
<span class="nc" id="L138">        Object docNewline = doc.getProperty(DefaultEditorKit.</span>
                                       EndOfLineStringProperty);
<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (docNewline instanceof String) {</span>
<span class="nc" id="L141">            setLineSeparator((String)docNewline);</span>
        }
        else {
<span class="nc" id="L144">            String newline = null;</span>
            try {
<span class="nc" id="L146">                newline = System.getProperty(&quot;line.separator&quot;);</span>
<span class="nc" id="L147">            } catch (SecurityException se) {}</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (newline == null) {</span>
                // Should not get here, but if we do it means we could not
                // find a newline string, use \n in this case.
<span class="nc" id="L151">                newline = &quot;\n&quot;;</span>
            }
<span class="nc" id="L153">            setLineSeparator(newline);</span>
        }
<span class="nc" id="L155">        canWrapLines = true;</span>
<span class="nc" id="L156">    }</span>

    /**
     * Creates a new AbstractWriter.
     * Initializes the ElementIterator with the
     * element passed in.
     *
     * @param w a Writer
     * @param root an Element
     */
    protected AbstractWriter(Writer w, Element root) {
<span class="nc" id="L167">        this(w, root, 0, root.getEndOffset());</span>
<span class="nc" id="L168">    }</span>

    /**
     * Creates a new AbstractWriter.
     * Initializes the ElementIterator with the
     * element passed in.
     *
     * @param w a Writer
     * @param root an Element
     * @param pos The location in the document to fetch the
     *   content.
     * @param len The amount to write out.
     */
<span class="nc" id="L181">    protected AbstractWriter(Writer w, Element root, int pos, int len) {</span>
<span class="nc" id="L182">        this.doc = root.getDocument();</span>
<span class="nc" id="L183">        it = new ElementIterator(root);</span>
<span class="nc" id="L184">        out = w;</span>
<span class="nc" id="L185">        startOffset = pos;</span>
<span class="nc" id="L186">        endOffset = pos + len;</span>
<span class="nc" id="L187">        canWrapLines = true;</span>
<span class="nc" id="L188">    }</span>

    /**
     * Returns the first offset to be output.
     *
     * @since 1.3
     */
    public int getStartOffset() {
<span class="nc" id="L196">        return startOffset;</span>
    }

    /**
     * Returns the last offset to be output.
     *
     * @since 1.3
     */
    public int getEndOffset() {
<span class="nc" id="L205">        return endOffset;</span>
    }

    /**
     * Fetches the ElementIterator.
     *
     * @return the ElementIterator.
     */
    protected ElementIterator getElementIterator() {
<span class="nc" id="L214">        return it;</span>
    }

    /**
     * Returns the Writer that is used to output the content.
     *
     * @since 1.3
     */
    protected Writer getWriter() {
<span class="nc" id="L223">        return out;</span>
    }

    /**
     * Fetches the document.
     *
     * @return the Document.
     */
    protected Document getDocument() {
<span class="nc" id="L232">        return doc;</span>
    }

    /**
     * This method determines whether the current element
     * is in the range specified.  When no range is specified,
     * the range is initialized to be the entire document.
     * inRange() returns true if the range specified intersects
     * with the element's range.
     *
     * @param  next an Element.
     * @return boolean that indicates whether the element
     *         is in the range.
     */
    protected boolean inRange(Element next) {
<span class="nc" id="L247">        int startOffset = getStartOffset();</span>
<span class="nc" id="L248">        int endOffset = getEndOffset();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if ((next.getStartOffset() &gt;= startOffset &amp;&amp;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">             next.getStartOffset()  &lt; endOffset) ||</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            (startOffset &gt;= next.getStartOffset() &amp;&amp;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">             startOffset &lt; next.getEndOffset())) {</span>
<span class="nc" id="L253">            return true;</span>
        }
<span class="nc" id="L255">        return false;</span>
    }

    /**
     * This abstract method needs to be implemented
     * by subclasses.  Its responsibility is to
     * iterate over the elements and use the write()
     * methods to generate output in the desired format.
     */
    abstract protected void write() throws IOException, BadLocationException;

    /**
     * Returns the text associated with the element.
     * The assumption here is that the element is a
     * leaf element.  Throws a BadLocationException
     * when encountered.
     *
     * @param     elem an &lt;code&gt;Element&lt;/code&gt;
     * @exception BadLocationException if pos represents an invalid
     *            location within the document
     * @return    the text as a &lt;code&gt;String&lt;/code&gt;
     */
    protected String getText(Element elem) throws BadLocationException {
<span class="nc" id="L278">        return doc.getText(elem.getStartOffset(),</span>
<span class="nc" id="L279">                           elem.getEndOffset() - elem.getStartOffset());</span>
    }


    /**
     * Writes out text.  If a range is specified when the constructor
     * is invoked, then only the appropriate range of text is written
     * out.
     *
     * @param     elem an Element.
     * @exception IOException on any I/O error
     * @exception BadLocationException if pos represents an invalid
     *            location within the document.
     */
    protected void text(Element elem) throws BadLocationException,
                                             IOException {
<span class="nc" id="L295">        int start = Math.max(getStartOffset(), elem.getStartOffset());</span>
<span class="nc" id="L296">        int end = Math.min(getEndOffset(), elem.getEndOffset());</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (start &lt; end) {</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (segment == null) {</span>
<span class="nc" id="L299">                segment = new Segment();</span>
            }
<span class="nc" id="L301">            getDocument().getText(start, end - start, segment);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (segment.count &gt; 0) {</span>
<span class="nc" id="L303">                write(segment.array, segment.offset, segment.count);</span>
            }
        }
<span class="nc" id="L306">    }</span>

    /**
     * Enables subclasses to set the number of characters they
     * want written per line.   The default is 100.
     *
     * @param l the maximum line length.
     */
    protected void setLineLength(int l) {
<span class="nc" id="L315">        maxLineLength = l;</span>
<span class="nc" id="L316">    }</span>

    /**
     * Returns the maximum line length.
     *
     * @since 1.3
     */
    protected int getLineLength() {
<span class="nc" id="L324">        return maxLineLength;</span>
    }

    /**
     * Sets the current line length.
     *
     * @since 1.3
     */
    protected void setCurrentLineLength(int length) {
<span class="nc" id="L333">        currLength = length;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">        isLineEmpty = (currLength == 0);</span>
<span class="nc" id="L335">    }</span>

    /**
     * Returns the current line length.
     *
     * @since 1.3
     */
    protected int getCurrentLineLength() {
<span class="nc" id="L343">        return currLength;</span>
    }

    /**
     * Returns true if the current line should be considered empty. This
     * is true when &lt;code&gt;getCurrentLineLength&lt;/code&gt; == 0 ||
     * &lt;code&gt;indent&lt;/code&gt; has been invoked on an empty line.
     *
     * @since 1.3
     */
    protected boolean isLineEmpty() {
<span class="nc" id="L354">        return isLineEmpty;</span>
    }

    /**
     * Sets whether or not lines can be wrapped. This can be toggled
     * during the writing of lines. For example, outputting HTML might
     * set this to false when outputting a quoted string.
     *
     * @since 1.3
     */
    protected void setCanWrapLines(boolean newValue) {
<span class="nc" id="L365">        canWrapLines = newValue;</span>
<span class="nc" id="L366">    }</span>

    /**
     * Returns whether or not the lines can be wrapped. If this is false
     * no lineSeparator's will be output.
     *
     * @since 1.3
     */
    protected boolean getCanWrapLines() {
<span class="nc" id="L375">        return canWrapLines;</span>
    }

    /**
     * Enables subclasses to specify how many spaces an indent
     * maps to. When indentation takes place, the indent level
     * is multiplied by this mapping.  The default is 2.
     *
     * @param space an int representing the space to indent mapping.
     */
    protected void setIndentSpace(int space) {
<span class="nc" id="L386">        indentSpace = space;</span>
<span class="nc" id="L387">    }</span>

    /**
     * Returns the amount of space to indent.
     *
     * @since 1.3
     */
    protected int getIndentSpace() {
<span class="nc" id="L395">        return indentSpace;</span>
    }

    /**
     * Sets the String used to represent newlines. This is initialized
     * in the constructor from either the Document, or the System property
     * line.separator.
     *
     * @since 1.3
     */
    public void setLineSeparator(String value) {
<span class="nc" id="L406">        lineSeparator = value;</span>
<span class="nc" id="L407">    }</span>

    /**
     * Returns the string used to represent newlines.
     *
     * @since 1.3
     */
    public String getLineSeparator() {
<span class="nc" id="L415">        return lineSeparator;</span>
    }

    /**
     * Increments the indent level. If indenting would cause
     * &lt;code&gt;getIndentSpace()&lt;/code&gt; *&lt;code&gt;getIndentLevel()&lt;/code&gt; to be &amp;gt;
     * than &lt;code&gt;getLineLength()&lt;/code&gt; this will not cause an indent.
     */
    protected void incrIndent() {
        // Only increment to a certain point.
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (offsetIndent &gt; 0) {</span>
<span class="nc" id="L426">            offsetIndent++;</span>
        }
        else {
<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (++indentLevel * getIndentSpace() &gt;= getLineLength()) {</span>
<span class="nc" id="L430">                offsetIndent++;</span>
<span class="nc" id="L431">                --indentLevel;</span>
            }
        }
<span class="nc" id="L434">    }</span>

    /**
     * Decrements the indent level.
     */
    protected void decrIndent() {
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (offsetIndent &gt; 0) {</span>
<span class="nc" id="L441">            --offsetIndent;</span>
        }
        else {
<span class="nc" id="L444">            indentLevel--;</span>
        }
<span class="nc" id="L446">    }</span>

    /**
     * Returns the current indentation level. That is, the number of times
     * &lt;code&gt;incrIndent&lt;/code&gt; has been invoked minus the number of times
     * &lt;code&gt;decrIndent&lt;/code&gt; has been invoked.
     *
     * @since 1.3
     */
    protected int getIndentLevel() {
<span class="nc" id="L456">        return indentLevel;</span>
    }

    /**
     * Does indentation. The number of spaces written
     * out is indent level times the space to map mapping. If the current
     * line is empty, this will not make it so that the current line is
     * still considered empty.
     *
     * @exception IOException on any I/O error
     */
    protected void indent() throws IOException {
<span class="nc" id="L468">        int max = getIndentLevel() * getIndentSpace();</span>
<span class="nc bnc" id="L469" title="All 4 branches missed.">        if (indentChars == null || max &gt; indentChars.length) {</span>
<span class="nc" id="L470">            indentChars = new char[max];</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">            for (int counter = 0; counter &lt; max; counter++) {</span>
<span class="nc" id="L472">                indentChars[counter] = ' ';</span>
            }
        }
<span class="nc" id="L475">        int length = getCurrentLineLength();</span>
<span class="nc" id="L476">        boolean wasEmpty = isLineEmpty();</span>
<span class="nc" id="L477">        output(indentChars, 0, max);</span>
<span class="nc bnc" id="L478" title="All 4 branches missed.">        if (wasEmpty &amp;&amp; length == 0) {</span>
<span class="nc" id="L479">            isLineEmpty = true;</span>
        }
<span class="nc" id="L481">    }</span>

    /**
     * Writes out a character. This is implemented to invoke
     * the &lt;code&gt;write&lt;/code&gt; method that takes a char[].
     *
     * @param     ch a char.
     * @exception IOException on any I/O error
     */
    protected void write(char ch) throws IOException {
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (tempChars == null) {</span>
<span class="nc" id="L492">            tempChars = new char[128];</span>
        }
<span class="nc" id="L494">        tempChars[0] = ch;</span>
<span class="nc" id="L495">        write(tempChars, 0, 1);</span>
<span class="nc" id="L496">    }</span>

    /**
     * Writes out a string. This is implemented to invoke the
     * &lt;code&gt;write&lt;/code&gt; method that takes a char[].
     *
     * @param     content a String.
     * @exception IOException on any I/O error
     */
    protected void write(String content) throws IOException {
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (content == null) {</span>
<span class="nc" id="L507">            return;</span>
        }
<span class="nc" id="L509">        int size = content.length();</span>
<span class="nc bnc" id="L510" title="All 4 branches missed.">        if (tempChars == null || tempChars.length &lt; size) {</span>
<span class="nc" id="L511">            tempChars = new char[size];</span>
        }
<span class="nc" id="L513">        content.getChars(0, size, tempChars, 0);</span>
<span class="nc" id="L514">        write(tempChars, 0, size);</span>
<span class="nc" id="L515">    }</span>

    /**
     * Writes the line separator. This invokes &lt;code&gt;output&lt;/code&gt; directly
     * as well as setting the &lt;code&gt;lineLength&lt;/code&gt; to 0.
     *
     * @since 1.3
     */
    protected void writeLineSeparator() throws IOException {
<span class="nc" id="L524">        String newline = getLineSeparator();</span>
<span class="nc" id="L525">        int length = newline.length();</span>
<span class="nc bnc" id="L526" title="All 4 branches missed.">        if (newlineChars == null || newlineChars.length &lt; length) {</span>
<span class="nc" id="L527">            newlineChars = new char[length];</span>
        }
<span class="nc" id="L529">        newline.getChars(0, length, newlineChars, 0);</span>
<span class="nc" id="L530">        output(newlineChars, 0, length);</span>
<span class="nc" id="L531">        setCurrentLineLength(0);</span>
<span class="nc" id="L532">    }</span>

    /**
     * All write methods call into this one. If &lt;code&gt;getCanWrapLines()&lt;/code&gt;
     * returns false, this will call &lt;code&gt;output&lt;/code&gt; with each sequence
     * of &lt;code&gt;chars&lt;/code&gt; that doesn't contain a NEWLINE, followed
     * by a call to &lt;code&gt;writeLineSeparator&lt;/code&gt;. On the other hand,
     * if &lt;code&gt;getCanWrapLines()&lt;/code&gt; returns true, this will split the
     * string, as necessary, so &lt;code&gt;getLineLength&lt;/code&gt; is honored.
     * The only exception is if the current string contains no whitespace,
     * and won't fit in which case the line length will exceed
     * &lt;code&gt;getLineLength&lt;/code&gt;.
     *
     * @since 1.3
     */
    protected void write(char[] chars, int startIndex, int length)
                   throws IOException {
<span class="nc bnc" id="L549" title="All 2 branches missed.">        if (!getCanWrapLines()) {</span>
            // We can not break string, just track if a newline
            // is in it.
<span class="nc" id="L552">            int lastIndex = startIndex;</span>
<span class="nc" id="L553">            int endIndex = startIndex + length;</span>
<span class="nc" id="L554">            int newlineIndex = indexOf(chars, NEWLINE, startIndex, endIndex);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            while (newlineIndex != -1) {</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                if (newlineIndex &gt; lastIndex) {</span>
<span class="nc" id="L557">                    output(chars, lastIndex, newlineIndex - lastIndex);</span>
                }
<span class="nc" id="L559">                writeLineSeparator();</span>
<span class="nc" id="L560">                lastIndex = newlineIndex + 1;</span>
<span class="nc" id="L561">                newlineIndex = indexOf(chars, '\n', lastIndex, endIndex);</span>
            }
<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (lastIndex &lt; endIndex) {</span>
<span class="nc" id="L564">                output(chars, lastIndex, endIndex - lastIndex);</span>
            }
<span class="nc" id="L566">        }</span>
        else {
            // We can break chars if the length exceeds maxLength.
<span class="nc" id="L569">            int lastIndex = startIndex;</span>
<span class="nc" id="L570">            int endIndex = startIndex + length;</span>
<span class="nc" id="L571">            int lineLength = getCurrentLineLength();</span>
<span class="nc" id="L572">            int maxLength = getLineLength();</span>

<span class="nc bnc" id="L574" title="All 2 branches missed.">            while (lastIndex &lt; endIndex) {</span>
<span class="nc" id="L575">                int newlineIndex = indexOf(chars, NEWLINE, lastIndex,</span>
                                           endIndex);
<span class="nc" id="L577">                boolean needsNewline = false;</span>
<span class="nc" id="L578">                boolean forceNewLine = false;</span>

<span class="nc" id="L580">                lineLength = getCurrentLineLength();</span>
<span class="nc bnc" id="L581" title="All 4 branches missed.">                if (newlineIndex != -1 &amp;&amp; (lineLength +</span>
                              (newlineIndex - lastIndex)) &lt; maxLength) {
<span class="nc bnc" id="L583" title="All 2 branches missed.">                    if (newlineIndex &gt; lastIndex) {</span>
<span class="nc" id="L584">                        output(chars, lastIndex, newlineIndex - lastIndex);</span>
                    }
<span class="nc" id="L586">                    lastIndex = newlineIndex + 1;</span>
<span class="nc" id="L587">                    forceNewLine = true;</span>
                }
<span class="nc bnc" id="L589" title="All 4 branches missed.">                else if (newlineIndex == -1 &amp;&amp; (lineLength +</span>
                                (endIndex - lastIndex)) &lt; maxLength) {
<span class="nc bnc" id="L591" title="All 2 branches missed.">                    if (endIndex &gt; lastIndex) {</span>
<span class="nc" id="L592">                        output(chars, lastIndex, endIndex - lastIndex);</span>
                    }
<span class="nc" id="L594">                    lastIndex = endIndex;</span>
                }
                else {
                    // Need to break chars, find a place to split chars at,
                    // from lastIndex to endIndex,
                    // or maxLength - lineLength whichever is smaller
<span class="nc" id="L600">                    int breakPoint = -1;</span>
<span class="nc" id="L601">                    int maxBreak = Math.min(endIndex - lastIndex,</span>
                                            maxLength - lineLength - 1);
<span class="nc" id="L603">                    int counter = 0;</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">                    while (counter &lt; maxBreak) {</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                        if (Character.isWhitespace(chars[counter +</span>
                                                        lastIndex])) {
<span class="nc" id="L607">                            breakPoint = counter;</span>
                        }
<span class="nc" id="L609">                        counter++;</span>
                    }
<span class="nc bnc" id="L611" title="All 2 branches missed.">                    if (breakPoint != -1) {</span>
                        // Found a place to break at.
<span class="nc" id="L613">                        breakPoint += lastIndex + 1;</span>
<span class="nc" id="L614">                        output(chars, lastIndex, breakPoint - lastIndex);</span>
<span class="nc" id="L615">                        lastIndex = breakPoint;</span>
<span class="nc" id="L616">                        needsNewline = true;</span>
                    }
                    else {
                        // No where good to break.

                        // find the next whitespace, or write out the
                        // whole string.
                            // maxBreak will be negative if current line too
                            // long.
<span class="nc" id="L625">                            counter = Math.max(0, maxBreak);</span>
<span class="nc" id="L626">                            maxBreak = endIndex - lastIndex;</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">                            while (counter &lt; maxBreak) {</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">                                if (Character.isWhitespace(chars[counter +</span>
                                                                lastIndex])) {
<span class="nc" id="L630">                                    breakPoint = counter;</span>
<span class="nc" id="L631">                                    break;</span>
                                }
<span class="nc" id="L633">                                counter++;</span>
                            }
<span class="nc bnc" id="L635" title="All 2 branches missed.">                            if (breakPoint == -1) {</span>
<span class="nc" id="L636">                                output(chars, lastIndex, endIndex - lastIndex);</span>
<span class="nc" id="L637">                                breakPoint = endIndex;</span>
                            }
                            else {
<span class="nc" id="L640">                                breakPoint += lastIndex;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">                                if (chars[breakPoint] == NEWLINE) {</span>
<span class="nc" id="L642">                                    output(chars, lastIndex, breakPoint++ -</span>
                                           lastIndex);
<span class="nc" id="L644">                                forceNewLine = true;</span>
                                }
                                else {
<span class="nc" id="L647">                                    output(chars, lastIndex, ++breakPoint -</span>
                                              lastIndex);
<span class="nc" id="L649">                                needsNewline = true;</span>
                                }
                            }
<span class="nc" id="L652">                            lastIndex = breakPoint;</span>
                        }
                    }
<span class="nc bnc" id="L655" title="All 6 branches missed.">                if (forceNewLine || needsNewline || lastIndex &lt; endIndex) {</span>
<span class="nc" id="L656">                    writeLineSeparator();</span>
<span class="nc bnc" id="L657" title="All 4 branches missed.">                    if (lastIndex &lt; endIndex || !forceNewLine) {</span>
<span class="nc" id="L658">                        indent();</span>
                    }
                }
<span class="nc" id="L661">            }</span>
        }
<span class="nc" id="L663">    }</span>

    /**
     * Writes out the set of attributes as &quot; &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;&quot;
     * pairs. It throws an IOException when encountered.
     *
     * @param     attr an AttributeSet.
     * @exception IOException on any I/O error
     */
    protected void writeAttributes(AttributeSet attr) throws IOException {

<span class="nc" id="L674">        Enumeration names = attr.getAttributeNames();</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        while (names.hasMoreElements()) {</span>
<span class="nc" id="L676">            Object name = names.nextElement();</span>
<span class="nc" id="L677">            write(&quot; &quot; + name + &quot;=&quot; + attr.getAttribute(name));</span>
<span class="nc" id="L678">        }</span>
<span class="nc" id="L679">    }</span>

    /**
     * The last stop in writing out content. All the write methods eventually
     * make it to this method, which invokes &lt;code&gt;write&lt;/code&gt; on the
     * Writer.
     * &lt;p&gt;This method also updates the line length based on
     * &lt;code&gt;length&lt;/code&gt;. If this is invoked to output a newline, the
     * current line length will need to be reset as will no longer be
     * valid. If it is up to the caller to do this. Use
     * &lt;code&gt;writeLineSeparator&lt;/code&gt; to write out a newline, which will
     * property update the current line length.
     *
     * @since 1.3
     */
    protected void output(char[] content, int start, int length)
                   throws IOException {
<span class="nc" id="L696">        getWriter().write(content, start, length);</span>
<span class="nc" id="L697">        setCurrentLineLength(getCurrentLineLength() + length);</span>
<span class="nc" id="L698">    }</span>

    /**
     * Support method to locate an occurrence of a particular character.
     */
    private int indexOf(char[] chars, char sChar, int startIndex,
                        int endIndex) {
<span class="nc bnc" id="L705" title="All 2 branches missed.">        while(startIndex &lt; endIndex) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">            if (chars[startIndex] == sChar) {</span>
<span class="nc" id="L707">                return startIndex;</span>
            }
<span class="nc" id="L709">            startIndex++;</span>
        }
<span class="nc" id="L711">        return -1;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>