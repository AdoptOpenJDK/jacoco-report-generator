<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ParagraphView.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">ParagraphView.java</span></div><h1>ParagraphView.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.util.Arrays;
import java.awt.*;
import java.awt.font.TextAttribute;
import javax.swing.event.*;
import javax.swing.SizeRequirements;

/**
 * View of a simple line-wrapping paragraph that supports
 * multiple fonts, colors, components, icons, etc.  It is
 * basically a vertical box with a margin around it.  The
 * contents of the box are a bunch of rows which are special
 * horizontal boxes.  This view creates a collection of
 * views that represent the child elements of the paragraph
 * element.  Each of these views are placed into a row
 * directly if they will fit, otherwise the &lt;code&gt;breakView&lt;/code&gt;
 * method is called to try and carve the view into pieces
 * that fit.
 *
 * @author  Timothy Prinzing
 * @author  Scott Violet
 * @author  Igor Kushnirskiy
 * @see     View
 */
public class ParagraphView extends FlowView implements TabExpander {

    /**
     * Constructs a &lt;code&gt;ParagraphView&lt;/code&gt; for the given element.
     *
     * @param elem the element that this view is responsible for
     */
    public ParagraphView(Element elem) {
<span class="nc" id="L58">        super(elem, View.Y_AXIS);</span>
<span class="nc" id="L59">        setPropertiesFromAttributes();</span>
<span class="nc" id="L60">        Document doc = elem.getDocument();</span>
<span class="nc" id="L61">        Object i18nFlag = doc.getProperty(AbstractDocument.I18NProperty);</span>
<span class="nc bnc" id="L62" title="All 4 branches missed.">        if ((i18nFlag != null) &amp;&amp; i18nFlag.equals(Boolean.TRUE)) {</span>
            try {
<span class="nc bnc" id="L64" title="All 2 branches missed.">                if (i18nStrategy == null) {</span>
                    // the classname should probably come from a property file.
<span class="nc" id="L66">                    String classname = &quot;javax.swing.text.TextLayoutStrategy&quot;;</span>
<span class="nc" id="L67">                    ClassLoader loader = getClass().getClassLoader();</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">                    if (loader != null) {</span>
<span class="nc" id="L69">                        i18nStrategy = loader.loadClass(classname);</span>
                    } else {
<span class="nc" id="L71">                        i18nStrategy = Class.forName(classname);</span>
                    }
                }
<span class="nc" id="L74">                Object o = i18nStrategy.newInstance();</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">                if (o instanceof FlowStrategy) {</span>
<span class="nc" id="L76">                    strategy = (FlowStrategy) o;</span>
                }
<span class="nc" id="L78">            } catch (Throwable e) {</span>
<span class="nc" id="L79">                throw new StateInvariantError(&quot;ParagraphView: Can't create i18n strategy: &quot;</span>
<span class="nc" id="L80">                                              + e.getMessage());</span>
<span class="nc" id="L81">            }</span>
        }
<span class="nc" id="L83">    }</span>

    /**
     * Sets the type of justification.
     *
     * @param j one of the following values:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;StyleConstants.ALIGN_LEFT&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;StyleConstants.ALIGN_CENTER&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;StyleConstants.ALIGN_RIGHT&lt;/code&gt;
     * &lt;/ul&gt;
     */
    protected void setJustification(int j) {
<span class="nc" id="L96">        justification = j;</span>
<span class="nc" id="L97">    }</span>

    /**
     * Sets the line spacing.
     *
     * @param ls the value is a factor of the line hight
     */
    protected void setLineSpacing(float ls) {
<span class="nc" id="L105">        lineSpacing = ls;</span>
<span class="nc" id="L106">    }</span>

    /**
     * Sets the indent on the first line.
     *
     * @param fi the value in points
     */
    protected void setFirstLineIndent(float fi) {
<span class="nc" id="L114">        firstLineIndent = (int) fi;</span>
<span class="nc" id="L115">    }</span>

    /**
     * Set the cached properties from the attributes.
     */
    protected void setPropertiesFromAttributes() {
<span class="nc" id="L121">        AttributeSet attr = getAttributes();</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L123">            setParagraphInsets(attr);</span>
<span class="nc" id="L124">            Integer a = (Integer)attr.getAttribute(StyleConstants.Alignment);</span>
            int alignment;
<span class="nc bnc" id="L126" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc" id="L127">                Document doc = getElement().getDocument();</span>
<span class="nc" id="L128">                Object o = doc.getProperty(TextAttribute.RUN_DIRECTION);</span>
<span class="nc bnc" id="L129" title="All 4 branches missed.">                if ((o != null) &amp;&amp; o.equals(TextAttribute.RUN_DIRECTION_RTL)) {</span>
<span class="nc" id="L130">                    alignment = StyleConstants.ALIGN_RIGHT;</span>
                } else {
<span class="nc" id="L132">                    alignment = StyleConstants.ALIGN_LEFT;</span>
                }
<span class="nc" id="L134">            } else {</span>
<span class="nc" id="L135">                alignment = a.intValue();</span>
            }
<span class="nc" id="L137">            setJustification(alignment);</span>
<span class="nc" id="L138">            setLineSpacing(StyleConstants.getLineSpacing(attr));</span>
<span class="nc" id="L139">            setFirstLineIndent(StyleConstants.getFirstLineIndent(attr));</span>
        }
<span class="nc" id="L141">    }</span>

    /**
     * Returns the number of views that this view is
     * responsible for.
     * The child views of the paragraph are rows which
     * have been used to arrange pieces of the &lt;code&gt;View&lt;/code&gt;s
     * that represent the child elements.  This is the number
     * of views that have been tiled in two dimensions,
     * and should be equivalent to the number of child elements
     * to the element this view is responsible for.
     *
     * @return the number of views that this &lt;code&gt;ParagraphView&lt;/code&gt;
     *          is responsible for
     */
    protected int getLayoutViewCount() {
<span class="nc" id="L157">        return layoutPool.getViewCount();</span>
    }

    /**
     * Returns the view at a given &lt;code&gt;index&lt;/code&gt;.
     * The child views of the paragraph are rows which
     * have been used to arrange pieces of the &lt;code&gt;Views&lt;/code&gt;
     * that represent the child elements.  This methods returns
     * the view responsible for the child element index
     * (prior to breaking).  These are the Views that were
     * produced from a factory (to represent the child
     * elements) and used for layout.
     *
     * @param index the &lt;code&gt;index&lt;/code&gt; of the desired view
     * @return the view at &lt;code&gt;index&lt;/code&gt;
     */
    protected View getLayoutView(int index) {
<span class="nc" id="L174">        return layoutPool.getView(index);</span>
    }

    /**
     * Returns the next visual position for the cursor, in
     * either the east or west direction.
     * Overridden from &lt;code&gt;CompositeView&lt;/code&gt;.
     * @param pos position into the model
     * @param b either &lt;code&gt;Position.Bias.Forward&lt;/code&gt; or
     *          &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
     * @param a the allocated region to render into
     * @param direction either &lt;code&gt;SwingConstants.NORTH&lt;/code&gt;
     *          or &lt;code&gt;SwingConstants.SOUTH&lt;/code&gt;
     * @param biasRet an array containing the bias that were checked
     *  in this method
     * @return the location in the model that represents the
     *  next location visual position
     */
    protected int getNextNorthSouthVisualPositionFrom(int pos, Position.Bias b,
                                                      Shape a, int direction,
                                                      Position.Bias[] biasRet)
                                                throws BadLocationException {
        int vIndex;
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if(pos == -1) {</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">            vIndex = (direction == NORTH) ?</span>
<span class="nc" id="L199">                     getViewCount() - 1 : 0;</span>
        }
        else {
<span class="nc bnc" id="L202" title="All 4 branches missed.">            if(b == Position.Bias.Backward &amp;&amp; pos &gt; 0) {</span>
<span class="nc" id="L203">                vIndex = getViewIndexAtPosition(pos - 1);</span>
            }
            else {
<span class="nc" id="L206">                vIndex = getViewIndexAtPosition(pos);</span>
            }
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if(direction == NORTH) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                if(vIndex == 0) {</span>
<span class="nc" id="L210">                    return -1;</span>
                }
<span class="nc" id="L212">                vIndex--;</span>
            }
<span class="nc bnc" id="L214" title="All 2 branches missed.">            else if(++vIndex &gt;= getViewCount()) {</span>
<span class="nc" id="L215">                return -1;</span>
            }
        }
        // vIndex gives index of row to look in.
<span class="nc" id="L219">        JTextComponent text = (JTextComponent)getContainer();</span>
<span class="nc" id="L220">        Caret c = text.getCaret();</span>
        Point magicPoint;
<span class="nc bnc" id="L222" title="All 2 branches missed.">        magicPoint = (c != null) ? c.getMagicCaretPosition() : null;</span>
        int x;
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if(magicPoint == null) {</span>
            Shape posBounds;
            try {
<span class="nc" id="L227">                posBounds = text.getUI().modelToView(text, pos, b);</span>
<span class="nc" id="L228">            } catch (BadLocationException exc) {</span>
<span class="nc" id="L229">                posBounds = null;</span>
<span class="nc" id="L230">            }</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if(posBounds == null) {</span>
<span class="nc" id="L232">                x = 0;</span>
            }
            else {
<span class="nc" id="L235">                x = posBounds.getBounds().x;</span>
            }
<span class="nc" id="L237">        }</span>
        else {
<span class="nc" id="L239">            x = magicPoint.x;</span>
        }
<span class="nc" id="L241">        return getClosestPositionTo(pos, b, a, direction, biasRet, vIndex, x);</span>
    }

    /**
     * Returns the closest model position to &lt;code&gt;x&lt;/code&gt;.
     * &lt;code&gt;rowIndex&lt;/code&gt; gives the index of the view that corresponds
     * that should be looked in.
     * @param pos  position into the model
     * @param a the allocated region to render into
     * @param direction one of the following values:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;SwingConstants.NORTH&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;SwingConstants.SOUTH&lt;/code&gt;
     * &lt;/ul&gt;
     * @param biasRet an array containing the bias that were checked
     *  in this method
     * @param rowIndex the index of the view
     * @param x the x coordinate of interest
     * @return the closest model position to &lt;code&gt;x&lt;/code&gt;
     */
    // NOTE: This will not properly work if ParagraphView contains
    // other ParagraphViews. It won't raise, but this does not message
    // the children views with getNextVisualPositionFrom.
    protected int getClosestPositionTo(int pos, Position.Bias b, Shape a,
                                       int direction, Position.Bias[] biasRet,
                                       int rowIndex, int x)
              throws BadLocationException {
<span class="nc" id="L268">        JTextComponent text = (JTextComponent)getContainer();</span>
<span class="nc" id="L269">        Document doc = getDocument();</span>
<span class="nc" id="L270">        View row = getView(rowIndex);</span>
<span class="nc" id="L271">        int lastPos = -1;</span>
        // This could be made better to check backward positions too.
<span class="nc" id="L273">        biasRet[0] = Position.Bias.Forward;</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        for(int vc = 0, numViews = row.getViewCount(); vc &lt; numViews; vc++) {</span>
<span class="nc" id="L275">            View v = row.getView(vc);</span>
<span class="nc" id="L276">            int start = v.getStartOffset();</span>
<span class="nc" id="L277">            boolean ltr = AbstractDocument.isLeftToRight(doc, start, start + 1);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if(ltr) {</span>
<span class="nc" id="L279">                lastPos = start;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">                for(int end = v.getEndOffset(); lastPos &lt; end; lastPos++) {</span>
<span class="nc" id="L281">                    float xx = text.modelToView(lastPos).getBounds().x;</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                    if(xx &gt;= x) {</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                        while (++lastPos &lt; end &amp;&amp;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                               text.modelToView(lastPos).getBounds().x == xx) {</span>
                        }
<span class="nc" id="L286">                        return --lastPos;</span>
                    }
                }
<span class="nc" id="L289">                lastPos--;</span>
            }
            else {
<span class="nc bnc" id="L292" title="All 2 branches missed.">                for(lastPos = v.getEndOffset() - 1; lastPos &gt;= start;</span>
<span class="nc" id="L293">                    lastPos--) {</span>
<span class="nc" id="L294">                    float xx = text.modelToView(lastPos).getBounds().x;</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">                    if(xx &gt;= x) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                        while (--lastPos &gt;= start &amp;&amp;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">                               text.modelToView(lastPos).getBounds().x == xx) {</span>
                        }
<span class="nc" id="L299">                        return ++lastPos;</span>
                    }
                }
<span class="nc" id="L302">                lastPos++;</span>
            }
        }
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if(lastPos == -1) {</span>
<span class="nc" id="L306">            return getStartOffset();</span>
        }
<span class="nc" id="L308">        return lastPos;</span>
    }

    /**
     * Determines in which direction the next view lays.
     * Consider the &lt;code&gt;View&lt;/code&gt; at index n.
     * Typically the &lt;code&gt;View&lt;/code&gt;s are layed out
     * from left to right, so that the &lt;code&gt;View&lt;/code&gt;
     * to the EAST will be at index n + 1, and the
     * &lt;code&gt;View&lt;/code&gt; to the WEST will be at index n - 1.
     * In certain situations, such as with bidirectional text,
     * it is possible that the &lt;code&gt;View&lt;/code&gt; to EAST is not
     * at index n + 1, but rather at index n - 1,
     * or that the &lt;code&gt;View&lt;/code&gt; to the WEST is not at
     * index n - 1, but index n + 1.  In this case this method
     * would return true, indicating the &lt;code&gt;View&lt;/code&gt;s are
     * layed out in descending order.
     * &lt;p&gt;
     * This will return true if the text is layed out right
     * to left at position, otherwise false.
     *
     * @param position position into the model
     * @param bias either &lt;code&gt;Position.Bias.Forward&lt;/code&gt; or
     *          &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
     * @return true if the text is layed out right to left at
     *         position, otherwise false.
     */
    protected boolean flipEastAndWestAtEnds(int position,
                                            Position.Bias bias) {
<span class="nc" id="L337">        Document doc = getDocument();</span>
<span class="nc" id="L338">        position = getStartOffset();</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        return !AbstractDocument.isLeftToRight(doc, position, position + 1);</span>
    }

    // --- FlowView methods ---------------------------------------------

    /**
     * Fetches the constraining span to flow against for
     * the given child index.
     * @param index the index of the view being queried
     * @return the constraining span for the given view at
     *  &lt;code&gt;index&lt;/code&gt;
     * @since 1.3
     */
    public int getFlowSpan(int index) {
<span class="nc" id="L353">        View child = getView(index);</span>
<span class="nc" id="L354">        int adjust = 0;</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">        if (child instanceof Row) {</span>
<span class="nc" id="L356">            Row row = (Row) child;</span>
<span class="nc" id="L357">            adjust = row.getLeftInset() + row.getRightInset();</span>
        }
<span class="nc bnc" id="L359" title="All 2 branches missed.">        return (layoutSpan == Integer.MAX_VALUE) ? layoutSpan</span>
                                                 : (layoutSpan - adjust);
    }

    /**
     * Fetches the location along the flow axis that the
     * flow span will start at.
     * @param index the index of the view being queried
     * @return the location for the given view at
     *  &lt;code&gt;index&lt;/code&gt;
     * @since 1.3
     */
    public int getFlowStart(int index) {
<span class="nc" id="L372">        View child = getView(index);</span>
<span class="nc" id="L373">        int adjust = 0;</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (child instanceof Row) {</span>
<span class="nc" id="L375">            Row row = (Row) child;</span>
<span class="nc" id="L376">            adjust = row.getLeftInset();</span>
        }
<span class="nc" id="L378">        return tabBase + adjust;</span>
    }

    /**
     * Create a &lt;code&gt;View&lt;/code&gt; that should be used to hold a
     * a row's worth of children in a flow.
     * @return the new &lt;code&gt;View&lt;/code&gt;
     * @since 1.3
     */
    protected View createRow() {
<span class="nc" id="L388">        return new Row(getElement());</span>
    }

    // --- TabExpander methods ------------------------------------------

    /**
     * Returns the next tab stop position given a reference position.
     * This view implements the tab coordinate system, and calls
     * &lt;code&gt;getTabbedSpan&lt;/code&gt; on the logical children in the process
     * of layout to determine the desired span of the children.  The
     * logical children can delegate their tab expansion upward to
     * the paragraph which knows how to expand tabs.
     * &lt;code&gt;LabelView&lt;/code&gt; is an example of a view that delegates
     * its tab expansion needs upward to the paragraph.
     * &lt;p&gt;
     * This is implemented to try and locate a &lt;code&gt;TabSet&lt;/code&gt;
     * in the paragraph element's attribute set.  If one can be
     * found, its settings will be used, otherwise a default expansion
     * will be provided.  The base location for for tab expansion
     * is the left inset from the paragraphs most recent allocation
     * (which is what the layout of the children is based upon).
     *
     * @param x the X reference position
     * @param tabOffset the position within the text stream
     *   that the tab occurred at &amp;gt;= 0
     * @return the trailing end of the tab expansion &amp;gt;= 0
     * @see TabSet
     * @see TabStop
     * @see LabelView
     */
    public float nextTabStop(float x, int tabOffset) {
        // If the text isn't left justified, offset by 10 pixels!
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if(justification != StyleConstants.ALIGN_LEFT)</span>
<span class="nc" id="L421">            return x + 10.0f;</span>
<span class="nc" id="L422">        x -= tabBase;</span>
<span class="nc" id="L423">        TabSet tabs = getTabSet();</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if(tabs == null) {</span>
            // a tab every 72 pixels.
<span class="nc" id="L426">            return (float)(tabBase + (((int)x / 72 + 1) * 72));</span>
        }
<span class="nc" id="L428">        TabStop tab = tabs.getTabAfter(x + .01f);</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if(tab == null) {</span>
            // no tab, do a default of 5 pixels.
            // Should this cause a wrapping of the line?
<span class="nc" id="L432">            return tabBase + x + 5.0f;</span>
        }
<span class="nc" id="L434">        int alignment = tab.getAlignment();</span>
        int offset;
<span class="nc bnc" id="L436" title="All 4 branches missed.">        switch(alignment) {</span>
        default:
        case TabStop.ALIGN_LEFT:
            // Simple case, left tab.
<span class="nc" id="L440">            return tabBase + tab.getPosition();</span>
        case TabStop.ALIGN_BAR:
            // PENDING: what does this mean?
<span class="nc" id="L443">            return tabBase + tab.getPosition();</span>
        case TabStop.ALIGN_RIGHT:
        case TabStop.ALIGN_CENTER:
<span class="nc" id="L446">            offset = findOffsetToCharactersInString(tabChars,</span>
                                                    tabOffset + 1);
<span class="nc" id="L448">            break;</span>
        case TabStop.ALIGN_DECIMAL:
<span class="nc" id="L450">            offset = findOffsetToCharactersInString(tabDecimalChars,</span>
                                                    tabOffset + 1);
            break;
        }
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (offset == -1) {</span>
<span class="nc" id="L455">            offset = getEndOffset();</span>
        }
<span class="nc" id="L457">        float charsSize = getPartialSize(tabOffset + 1, offset);</span>
<span class="nc bnc" id="L458" title="All 3 branches missed.">        switch(alignment) {</span>
        case TabStop.ALIGN_RIGHT:
        case TabStop.ALIGN_DECIMAL:
            // right and decimal are treated the same way, the new
            // position will be the location of the tab less the
            // partialSize.
<span class="nc" id="L464">            return tabBase + Math.max(x, tab.getPosition() - charsSize);</span>
        case TabStop.ALIGN_CENTER:
            // Similar to right, but half the partialSize.
<span class="nc" id="L467">            return tabBase + Math.max(x, tab.getPosition() - charsSize / 2.0f);</span>
        }
        // will never get here!
<span class="nc" id="L470">        return x;</span>
    }

    /**
     * Gets the &lt;code&gt;Tabset&lt;/code&gt; to be used in calculating tabs.
     *
     * @return the &lt;code&gt;TabSet&lt;/code&gt;
     */
    protected TabSet getTabSet() {
<span class="nc" id="L479">        return StyleConstants.getTabSet(getElement().getAttributes());</span>
    }

    /**
     * Returns the size used by the views between
     * &lt;code&gt;startOffset&lt;/code&gt; and &lt;code&gt;endOffset&lt;/code&gt;.
     * This uses &lt;code&gt;getPartialView&lt;/code&gt; to calculate the
     * size if the child view implements the
     * &lt;code&gt;TabableView&lt;/code&gt; interface. If a
     * size is needed and a &lt;code&gt;View&lt;/code&gt; does not implement
     * the &lt;code&gt;TabableView&lt;/code&gt; interface,
     * the &lt;code&gt;preferredSpan&lt;/code&gt; will be used.
     *
     * @param startOffset the starting document offset &amp;gt;= 0
     * @param endOffset the ending document offset &amp;gt;= startOffset
     * @return the size &amp;gt;= 0
     */
    protected float getPartialSize(int startOffset, int endOffset) {
<span class="nc" id="L497">        float size = 0.0f;</span>
        int viewIndex;
<span class="nc" id="L499">        int numViews = getViewCount();</span>
        View view;
        int viewEnd;
        int tempEnd;

        // Have to search layoutPool!
        // PENDING: when ParagraphView supports breaking location
        // into layoutPool will have to change!
<span class="nc" id="L507">        viewIndex = getElement().getElementIndex(startOffset);</span>
<span class="nc" id="L508">        numViews = layoutPool.getViewCount();</span>
<span class="nc bnc" id="L509" title="All 4 branches missed.">        while(startOffset &lt; endOffset &amp;&amp; viewIndex &lt; numViews) {</span>
<span class="nc" id="L510">            view = layoutPool.getView(viewIndex++);</span>
<span class="nc" id="L511">            viewEnd = view.getEndOffset();</span>
<span class="nc" id="L512">            tempEnd = Math.min(endOffset, viewEnd);</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">            if(view instanceof TabableView)</span>
<span class="nc" id="L514">                size += ((TabableView)view).getPartialSpan(startOffset, tempEnd);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            else if(startOffset == view.getStartOffset() &amp;&amp;</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">                    tempEnd == view.getEndOffset())</span>
<span class="nc" id="L517">                size += view.getPreferredSpan(View.X_AXIS);</span>
            else
                // PENDING: should we handle this better?
<span class="nc" id="L520">                return 0.0f;</span>
<span class="nc" id="L521">            startOffset = viewEnd;</span>
        }
<span class="nc" id="L523">        return size;</span>
    }

    /**
     * Finds the next character in the document with a character in
     * &lt;code&gt;string&lt;/code&gt;, starting at offset &lt;code&gt;start&lt;/code&gt;. If
     * there are no characters found, -1 will be returned.
     *
     * @param string the string of characters
     * @param start where to start in the model &amp;gt;= 0
     * @return the document offset, or -1 if no characters found
     */
    protected int findOffsetToCharactersInString(char[] string,
                                                 int start) {
<span class="nc" id="L537">        int stringLength = string.length;</span>
<span class="nc" id="L538">        int end = getEndOffset();</span>
<span class="nc" id="L539">        Segment seg = new Segment();</span>
        try {
<span class="nc" id="L541">            getDocument().getText(start, end - start, seg);</span>
<span class="nc" id="L542">        } catch (BadLocationException ble) {</span>
<span class="nc" id="L543">            return -1;</span>
<span class="nc" id="L544">        }</span>
<span class="nc" id="L545">        for(int counter = seg.offset, maxCounter = seg.offset + seg.count;</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L547">            char currentChar = seg.array[counter];</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">            for(int subCounter = 0; subCounter &lt; stringLength;</span>
<span class="nc" id="L549">                subCounter++) {</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">                if(currentChar == string[subCounter])</span>
<span class="nc" id="L551">                    return counter - seg.offset + start;</span>
            }
        }
        // No match.
<span class="nc" id="L555">        return -1;</span>
    }

    /**
     * Returns where the tabs are calculated from.
     * @return where tabs are calculated from
     */
    protected float getTabBase() {
<span class="nc" id="L563">        return (float)tabBase;</span>
    }

    // ---- View methods ----------------------------------------------------

    /**
     * Renders using the given rendering surface and area on that
     * surface.  This is implemented to delegate to the superclass
     * after stashing the base coordinate for tab calculations.
     *
     * @param g the rendering surface to use
     * @param a the allocated region to render into
     * @see View#paint
     */
    public void paint(Graphics g, Shape a) {
<span class="nc bnc" id="L578" title="All 2 branches missed.">        Rectangle alloc = (a instanceof Rectangle) ? (Rectangle)a : a.getBounds();</span>
<span class="nc" id="L579">        tabBase = alloc.x + getLeftInset();</span>
<span class="nc" id="L580">        super.paint(g, a);</span>

        // line with the negative firstLineIndent value needs
        // special handling
<span class="nc bnc" id="L584" title="All 2 branches missed.">        if (firstLineIndent &lt; 0) {</span>
<span class="nc" id="L585">            Shape sh = getChildAllocation(0, a);</span>
<span class="nc bnc" id="L586" title="All 4 branches missed.">            if ((sh != null) &amp;&amp;  sh.intersects(alloc)) {</span>
<span class="nc" id="L587">                int x = alloc.x + getLeftInset() + firstLineIndent;</span>
<span class="nc" id="L588">                int y = alloc.y + getTopInset();</span>

<span class="nc" id="L590">                Rectangle clip = g.getClipBounds();</span>
<span class="nc" id="L591">                tempRect.x = x + getOffset(X_AXIS, 0);</span>
<span class="nc" id="L592">                tempRect.y = y + getOffset(Y_AXIS, 0);</span>
<span class="nc" id="L593">                tempRect.width = getSpan(X_AXIS, 0) - firstLineIndent;</span>
<span class="nc" id="L594">                tempRect.height = getSpan(Y_AXIS, 0);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                if (tempRect.intersects(clip)) {</span>
<span class="nc" id="L596">                    tempRect.x = tempRect.x - firstLineIndent;</span>
<span class="nc" id="L597">                    paintChild(g, tempRect, 0);</span>
                }
            }
        }
<span class="nc" id="L601">    }</span>

    /**
     * Determines the desired alignment for this view along an
     * axis.  This is implemented to give the alignment to the
     * center of the first row along the y axis, and the default
     * along the x axis.
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt; or
     *   &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @return the desired alignment.  This should be a value
     *   between 0.0 and 1.0 inclusive, where 0 indicates alignment at the
     *   origin and 1.0 indicates alignment to the full span
     *   away from the origin.  An alignment of 0.5 would be the
     *   center of the view.
     */
    public float getAlignment(int axis) {
<span class="nc bnc" id="L618" title="All 3 branches missed.">        switch (axis) {</span>
        case Y_AXIS:
<span class="nc" id="L620">            float a = 0.5f;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">            if (getViewCount() != 0) {</span>
<span class="nc" id="L622">                int paragraphSpan = (int) getPreferredSpan(View.Y_AXIS);</span>
<span class="nc" id="L623">                View v = getView(0);</span>
<span class="nc" id="L624">                int rowSpan = (int) v.getPreferredSpan(View.Y_AXIS);</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">                a = (paragraphSpan != 0) ? ((float)(rowSpan / 2)) / paragraphSpan : 0;</span>
            }
<span class="nc" id="L627">            return a;</span>
        case X_AXIS:
<span class="nc" id="L629">            return 0.5f;</span>
        default:
<span class="nc" id="L631">            throw new IllegalArgumentException(&quot;Invalid axis: &quot; + axis);</span>
        }
    }

    /**
     * Breaks this view on the given axis at the given length.
     * &lt;p&gt;
     * &lt;code&gt;ParagraphView&lt;/code&gt; instances are breakable
     * along the &lt;code&gt;Y_AXIS&lt;/code&gt; only, and only if
     * &lt;code&gt;len&lt;/code&gt; is after the first line.
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt;
     *  or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @param len specifies where a potential break is desired
     *  along the given axis &amp;gt;= 0
     * @param a the current allocation of the view
     * @return the fragment of the view that represents the
     *  given span, if the view can be broken; if the view
     *  doesn't support breaking behavior, the view itself is
     *  returned
     * @see View#breakView
     */
    public View breakView(int axis, float len, Shape a) {
<span class="nc bnc" id="L654" title="All 2 branches missed.">        if(axis == View.Y_AXIS) {</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">            if(a != null) {</span>
<span class="nc" id="L656">                Rectangle alloc = a.getBounds();</span>
<span class="nc" id="L657">                setSize(alloc.width, alloc.height);</span>
            }
            // Determine what row to break on.

            // PENDING(prinz) add break support
<span class="nc" id="L662">            return this;</span>
        }
<span class="nc" id="L664">        return this;</span>
    }

    /**
     * Gets the break weight for a given location.
     * &lt;p&gt;
     * &lt;code&gt;ParagraphView&lt;/code&gt; instances are breakable
     * along the &lt;code&gt;Y_AXIS&lt;/code&gt; only, and only if
     * &lt;code&gt;len&lt;/code&gt; is after the first row.  If the length
     * is less than one row, a value of &lt;code&gt;BadBreakWeight&lt;/code&gt;
     * is returned.
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt;
     *  or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @param len specifies where a potential break is desired &amp;gt;= 0
     * @return a value indicating the attractiveness of breaking here;
     *  either &lt;code&gt;GoodBreakWeight&lt;/code&gt; or &lt;code&gt;BadBreakWeight&lt;/code&gt;
     * @see View#getBreakWeight
     */
    public int getBreakWeight(int axis, float len) {
<span class="nc bnc" id="L684" title="All 2 branches missed.">        if(axis == View.Y_AXIS) {</span>
            // PENDING(prinz) make this return a reasonable value
            // when paragraph breaking support is re-implemented.
            // If less than one row, bad weight value should be
            // returned.
            //return GoodBreakWeight;
<span class="nc" id="L690">            return BadBreakWeight;</span>
        }
<span class="nc" id="L692">        return BadBreakWeight;</span>
    }

    /**
     * Calculate the needs for the paragraph along the minor axis.
     *
     * &lt;p&gt;This uses size requirements of the superclass, modified to take into
     * account the non-breakable areas at the adjacent views edges.  The minimal
     * size requirements for such views should be no less than the sum of all
     * adjacent fragments.&lt;/p&gt;
     *
     * &lt;p&gt;If the {@code axis} parameter is neither {@code View.X_AXIS} nor
     * {@code View.Y_AXIS}, {@link IllegalArgumentException} is thrown.  If the
     * {@code r} parameter is {@code null,} a new {@code SizeRequirements}
     * object is created, otherwise the supplied {@code SizeRequirements}
     * object is returned.&lt;/p&gt;
     *
     * @param axis  the minor axis
     * @param r     the input {@code SizeRequirements} object
     * @return      the new or adjusted {@code SizeRequirements} object
     * @throws IllegalArgumentException  if the {@code axis} parameter is invalid
     */
    @Override
    protected SizeRequirements calculateMinorAxisRequirements(int axis,
                                                        SizeRequirements r) {
<span class="nc" id="L717">        r = super.calculateMinorAxisRequirements(axis, r);</span>

<span class="nc" id="L719">        float min = 0;</span>
<span class="nc" id="L720">        float glue = 0;</span>
<span class="nc" id="L721">        int n = getLayoutViewCount();</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L723">            View v = getLayoutView(i);</span>
<span class="nc" id="L724">            float span = v.getMinimumSpan(axis);</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">            if (v.getBreakWeight(axis, 0, v.getMaximumSpan(axis)) &gt; View.BadBreakWeight) {</span>
                // find the longest non-breakable fragments at the view edges
<span class="nc" id="L727">                int p0 = v.getStartOffset();</span>
<span class="nc" id="L728">                int p1 = v.getEndOffset();</span>
<span class="nc" id="L729">                float start = findEdgeSpan(v, axis, p0, p0, p1);</span>
<span class="nc" id="L730">                float end = findEdgeSpan(v, axis, p1, p0, p1);</span>
<span class="nc" id="L731">                glue += start;</span>
<span class="nc" id="L732">                min = Math.max(min, Math.max(span, glue));</span>
<span class="nc" id="L733">                glue = end;</span>
<span class="nc" id="L734">            } else {</span>
                // non-breakable view
<span class="nc" id="L736">                glue += span;</span>
<span class="nc" id="L737">                min = Math.max(min, glue);</span>
            }
        }
<span class="nc" id="L740">        r.minimum = Math.max(r.minimum, (int) min);</span>
<span class="nc" id="L741">        r.preferred = Math.max(r.minimum, r.preferred);</span>
<span class="nc" id="L742">        r.maximum = Math.max(r.preferred, r.maximum);</span>

<span class="nc" id="L744">        return r;</span>
    }

    /**
     * Binary search for the longest non-breakable fragment at the view edge.
     */
    private float findEdgeSpan(View v, int axis, int fp, int p0, int p1) {
<span class="nc" id="L751">        int len = p1 - p0;</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">        if (len &lt;= 1) {</span>
            // further fragmentation is not possible
<span class="nc" id="L754">            return v.getMinimumSpan(axis);</span>
        } else {
<span class="nc" id="L756">            int mid = p0 + len / 2;</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            boolean startEdge = mid &gt; fp;</span>
            // initial view is breakable hence must support fragmentation
<span class="nc bnc" id="L759" title="All 2 branches missed.">            View f = startEdge ?</span>
<span class="nc" id="L760">                v.createFragment(fp, mid) : v.createFragment(mid, fp);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">            boolean breakable = f.getBreakWeight(</span>
<span class="nc" id="L762">                    axis, 0, f.getMaximumSpan(axis)) &gt; View.BadBreakWeight;</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">            if (breakable == startEdge) {</span>
<span class="nc" id="L764">                p1 = mid;</span>
            } else {
<span class="nc" id="L766">                p0 = mid;</span>
            }
<span class="nc" id="L768">            return findEdgeSpan(f, axis, fp, p0, p1);</span>
        }
    }

    /**
     * Gives notification from the document that attributes were changed
     * in a location that this view is responsible for.
     *
     * @param changes the change information from the
     *  associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#changedUpdate
     */
    public void changedUpdate(DocumentEvent changes, Shape a, ViewFactory f) {
        // update any property settings stored, and layout should be
        // recomputed
<span class="nc" id="L785">        setPropertiesFromAttributes();</span>
<span class="nc" id="L786">        layoutChanged(X_AXIS);</span>
<span class="nc" id="L787">        layoutChanged(Y_AXIS);</span>
<span class="nc" id="L788">        super.changedUpdate(changes, a, f);</span>
<span class="nc" id="L789">    }</span>


    // --- variables -----------------------------------------------

    private int justification;
    private float lineSpacing;
    /** Indentation for the first line, from the left inset. */
<span class="nc" id="L797">    protected int firstLineIndent = 0;</span>

    /**
     * Used by the TabExpander functionality to determine
     * where to base the tab calculations.  This is basically
     * the location of the left side of the paragraph.
     */
    private int tabBase;

    /**
     * Used to create an i18n-based layout strategy
     */
    static Class i18nStrategy;

    /** Used for searching for a tab. */
    static char[] tabChars;
    /** Used for searching for a tab or decimal character. */
    static char[] tabDecimalChars;

    static {
<span class="nc" id="L817">        tabChars = new char[1];</span>
<span class="nc" id="L818">        tabChars[0] = '\t';</span>
<span class="nc" id="L819">        tabDecimalChars = new char[2];</span>
<span class="nc" id="L820">        tabDecimalChars[0] = '\t';</span>
<span class="nc" id="L821">        tabDecimalChars[1] = '.';</span>
<span class="nc" id="L822">    }</span>

    /**
     * Internally created view that has the purpose of holding
     * the views that represent the children of the paragraph
     * that have been arranged in rows.
     */
    class Row extends BoxView {

<span class="nc" id="L831">        Row(Element elem) {</span>
<span class="nc" id="L832">            super(elem, View.X_AXIS);</span>
<span class="nc" id="L833">        }</span>

        /**
         * This is reimplemented to do nothing since the
         * paragraph fills in the row with its needed
         * children.
         */
        protected void loadChildren(ViewFactory f) {
<span class="nc" id="L841">        }</span>

        /**
         * Fetches the attributes to use when rendering.  This view
         * isn't directly responsible for an element so it returns
         * the outer classes attributes.
         */
        public AttributeSet getAttributes() {
<span class="nc" id="L849">            View p = getParent();</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">            return (p != null) ? p.getAttributes() : null;</span>
        }

        public float getAlignment(int axis) {
<span class="nc bnc" id="L854" title="All 2 branches missed.">            if (axis == View.X_AXIS) {</span>
<span class="nc bnc" id="L855" title="All 5 branches missed.">                switch (justification) {</span>
                case StyleConstants.ALIGN_LEFT:
<span class="nc" id="L857">                    return 0;</span>
                case StyleConstants.ALIGN_RIGHT:
<span class="nc" id="L859">                    return 1;</span>
                case StyleConstants.ALIGN_CENTER:
<span class="nc" id="L861">                    return 0.5f;</span>
                case StyleConstants.ALIGN_JUSTIFIED:
<span class="nc" id="L863">                    float rv = 0.5f;</span>
                    //if we can justifiy the content always align to
                    //the left.
<span class="nc bnc" id="L866" title="All 2 branches missed.">                    if (isJustifiableDocument()) {</span>
<span class="nc" id="L867">                        rv = 0f;</span>
                    }
<span class="nc" id="L869">                    return rv;</span>
                }
            }
<span class="nc" id="L872">            return super.getAlignment(axis);</span>
        }

        /**
         * Provides a mapping from the document model coordinate space
         * to the coordinate space of the view mapped to it.  This is
         * implemented to let the superclass find the position along
         * the major axis and the allocation of the row is used
         * along the minor axis, so that even though the children
         * are different heights they all get the same caret height.
         *
         * @param pos the position to convert
         * @param a the allocated region to render into
         * @return the bounding box of the given position
         * @exception BadLocationException  if the given position does not represent a
         *   valid location in the associated document
         * @see View#modelToView
         */
        public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
<span class="nc" id="L891">            Rectangle r = a.getBounds();</span>
<span class="nc" id="L892">            View v = getViewAtPosition(pos, r);</span>
<span class="nc bnc" id="L893" title="All 4 branches missed.">            if ((v != null) &amp;&amp; (!v.getElement().isLeaf())) {</span>
                // Don't adjust the height if the view represents a branch.
<span class="nc" id="L895">                return super.modelToView(pos, a, b);</span>
            }
<span class="nc" id="L897">            r = a.getBounds();</span>
<span class="nc" id="L898">            int height = r.height;</span>
<span class="nc" id="L899">            int y = r.y;</span>
<span class="nc" id="L900">            Shape loc = super.modelToView(pos, a, b);</span>
<span class="nc" id="L901">            r = loc.getBounds();</span>
<span class="nc" id="L902">            r.height = height;</span>
<span class="nc" id="L903">            r.y = y;</span>
<span class="nc" id="L904">            return r;</span>
        }

        /**
         * Range represented by a row in the paragraph is only
         * a subset of the total range of the paragraph element.
         * @see View#getRange
         */
        public int getStartOffset() {
<span class="nc" id="L913">            int offs = Integer.MAX_VALUE;</span>
<span class="nc" id="L914">            int n = getViewCount();</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L916">                View v = getView(i);</span>
<span class="nc" id="L917">                offs = Math.min(offs, v.getStartOffset());</span>
            }
<span class="nc" id="L919">            return offs;</span>
        }

        public int getEndOffset() {
<span class="nc" id="L923">            int offs = 0;</span>
<span class="nc" id="L924">            int n = getViewCount();</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L926">                View v = getView(i);</span>
<span class="nc" id="L927">                offs = Math.max(offs, v.getEndOffset());</span>
            }
<span class="nc" id="L929">            return offs;</span>
        }

        /**
         * Perform layout for the minor axis of the box (i.e. the
         * axis orthogonal to the axis that it represents).  The results
         * of the layout should be placed in the given arrays which represent
         * the allocations to the children along the minor axis.
         * &lt;p&gt;
         * This is implemented to do a baseline layout of the children
         * by calling BoxView.baselineLayout.
         *
         * @param targetSpan the total span given to the view, which
         *  would be used to layout the children.
         * @param axis the axis being layed out.
         * @param offsets the offsets from the origin of the view for
         *  each of the child views.  This is a return value and is
         *  filled in by the implementation of this method.
         * @param spans the span of each child view.  This is a return
         *  value and is filled in by the implementation of this method.
         * @return the offset and span for each child view in the
         *  offsets and spans parameters
         */
        protected void layoutMinorAxis(int targetSpan, int axis, int[] offsets, int[] spans) {
<span class="nc" id="L953">            baselineLayout(targetSpan, axis, offsets, spans);</span>
<span class="nc" id="L954">        }</span>

        protected SizeRequirements calculateMinorAxisRequirements(int axis,
                                                                  SizeRequirements r) {
<span class="nc" id="L958">            return baselineRequirements(axis, r);</span>
        }


        private boolean isLastRow() {
            View parent;
<span class="nc bnc" id="L964" title="All 2 branches missed.">            return ((parent = getParent()) == null</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">                    || this == parent.getView(parent.getViewCount() - 1));</span>
        }

        private boolean isBrokenRow() {
<span class="nc" id="L969">            boolean rv = false;</span>
<span class="nc" id="L970">            int viewsCount = getViewCount();</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">            if (viewsCount &gt; 0) {</span>
<span class="nc" id="L972">                View lastView = getView(viewsCount - 1);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">                if (lastView.getBreakWeight(X_AXIS, 0, 0) &gt;=</span>
                      ForcedBreakWeight) {
<span class="nc" id="L975">                    rv = true;</span>
                }
            }
<span class="nc" id="L978">            return rv;</span>
        }

        private boolean isJustifiableDocument() {
<span class="nc bnc" id="L982" title="All 2 branches missed.">            return (! Boolean.TRUE.equals(getDocument().getProperty(</span>
                          AbstractDocument.I18NProperty)));
        }

        /**
         * Whether we need to justify this {@code Row}.
         * At this time (jdk1.6) we support justification on for non
         * 18n text.
         *
         * @return {@code true} if this {@code Row} should be justified.
         */
        private boolean isJustifyEnabled() {
<span class="nc bnc" id="L994" title="All 2 branches missed.">            boolean ret = (justification == StyleConstants.ALIGN_JUSTIFIED);</span>

            //no justification for i18n documents
<span class="nc bnc" id="L997" title="All 4 branches missed.">            ret = ret &amp;&amp; isJustifiableDocument();</span>

            //no justification for the last row
<span class="nc bnc" id="L1000" title="All 4 branches missed.">            ret = ret &amp;&amp; ! isLastRow();</span>

            //no justification for the broken rows
<span class="nc bnc" id="L1003" title="All 4 branches missed.">            ret = ret &amp;&amp; ! isBrokenRow();</span>

<span class="nc" id="L1005">            return ret;</span>
        }


        //Calls super method after setting spaceAddon to 0.
        //Justification should not affect MajorAxisRequirements
        @Override
        protected SizeRequirements calculateMajorAxisRequirements(int axis,
                SizeRequirements r) {
<span class="nc" id="L1014">            int oldJustficationData[] = justificationData;</span>
<span class="nc" id="L1015">            justificationData = null;</span>
<span class="nc" id="L1016">            SizeRequirements ret = super.calculateMajorAxisRequirements(axis, r);</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">            if (isJustifyEnabled()) {</span>
<span class="nc" id="L1018">                justificationData = oldJustficationData;</span>
            }
<span class="nc" id="L1020">            return ret;</span>
        }

        @Override
        protected void layoutMajorAxis(int targetSpan, int axis,
                                       int[] offsets, int[] spans) {
<span class="nc" id="L1026">            int oldJustficationData[] = justificationData;</span>
<span class="nc" id="L1027">            justificationData = null;</span>
<span class="nc" id="L1028">            super.layoutMajorAxis(targetSpan, axis, offsets, spans);</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">            if (! isJustifyEnabled()) {</span>
<span class="nc" id="L1030">                return;</span>
            }

<span class="nc" id="L1033">            int currentSpan = 0;</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">            for (int span : spans) {</span>
<span class="nc" id="L1035">                currentSpan += span;</span>
            }
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (currentSpan == targetSpan) {</span>
                //no need to justify
<span class="nc" id="L1039">                return;</span>
            }

            // we justify text by enlarging spaces by the {@code spaceAddon}.
            // justification is started to the right of the rightmost TAB.
            // leading and trailing spaces are not extendable.
            //
            // GlyphPainter1 uses
            // justificationData
            // for all painting and measurement.

<span class="nc" id="L1050">            int extendableSpaces = 0;</span>
<span class="nc" id="L1051">            int startJustifiableContent = -1;</span>
<span class="nc" id="L1052">            int endJustifiableContent = -1;</span>
<span class="nc" id="L1053">            int lastLeadingSpaces = 0;</span>

<span class="nc" id="L1055">            int rowStartOffset = getStartOffset();</span>
<span class="nc" id="L1056">            int rowEndOffset = getEndOffset();</span>
<span class="nc" id="L1057">            int spaceMap[] = new int[rowEndOffset - rowStartOffset];</span>
<span class="nc" id="L1058">            Arrays.fill(spaceMap, 0);</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">            for (int i = getViewCount() - 1; i &gt;= 0 ; i--) {</span>
<span class="nc" id="L1060">                View view = getView(i);</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">                if (view instanceof GlyphView) {</span>
<span class="nc" id="L1062">                    GlyphView.JustificationInfo justificationInfo =</span>
<span class="nc" id="L1063">                        ((GlyphView) view).getJustificationInfo(rowStartOffset);</span>
<span class="nc" id="L1064">                    final int viewStartOffset = view.getStartOffset();</span>
<span class="nc" id="L1065">                    final int offset = viewStartOffset - rowStartOffset;</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                    for (int j = 0; j &lt; justificationInfo.spaceMap.length(); j++) {</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                        if (justificationInfo.spaceMap.get(j)) {</span>
<span class="nc" id="L1068">                            spaceMap[j + offset] = 1;</span>
                        }
                    }
<span class="nc bnc" id="L1071" title="All 2 branches missed.">                    if (startJustifiableContent &gt; 0) {</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                        if (justificationInfo.end &gt;= 0) {</span>
<span class="nc" id="L1073">                            extendableSpaces += justificationInfo.trailingSpaces;</span>
                        } else {
<span class="nc" id="L1075">                            lastLeadingSpaces += justificationInfo.trailingSpaces;</span>
                        }
                    }
<span class="nc bnc" id="L1078" title="All 2 branches missed.">                    if (justificationInfo.start &gt;= 0) {</span>
<span class="nc" id="L1079">                        startJustifiableContent =</span>
                            justificationInfo.start + viewStartOffset;
<span class="nc" id="L1081">                        extendableSpaces += lastLeadingSpaces;</span>
                    }
<span class="nc bnc" id="L1083" title="All 4 branches missed.">                    if (justificationInfo.end &gt;= 0</span>
                          &amp;&amp; endJustifiableContent &lt; 0) {
<span class="nc" id="L1085">                        endJustifiableContent =</span>
                            justificationInfo.end + viewStartOffset;
                    }
<span class="nc" id="L1088">                    extendableSpaces += justificationInfo.contentSpaces;</span>
<span class="nc" id="L1089">                    lastLeadingSpaces = justificationInfo.leadingSpaces;</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">                    if (justificationInfo.hasTab) {</span>
<span class="nc" id="L1091">                        break;</span>
                    }
                }
            }
<span class="nc bnc" id="L1095" title="All 2 branches missed.">            if (extendableSpaces &lt;= 0) {</span>
                //there is nothing we can do to justify
<span class="nc" id="L1097">                return;</span>
            }
<span class="nc" id="L1099">            int adjustment = (targetSpan - currentSpan);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">            int spaceAddon = (extendableSpaces &gt; 0)</span>
                ?  adjustment / extendableSpaces
                : 0;
<span class="nc" id="L1103">            int spaceAddonLeftoverEnd = -1;</span>
<span class="nc" id="L1104">            for (int i = startJustifiableContent - rowStartOffset,</span>
<span class="nc" id="L1105">                     leftover = adjustment - spaceAddon * extendableSpaces;</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">                     leftover &gt; 0;</span>
<span class="nc" id="L1107">                     leftover -= spaceMap[i],</span>
<span class="nc" id="L1108">                     i++) {</span>
<span class="nc" id="L1109">                spaceAddonLeftoverEnd = i;</span>
            }
<span class="nc bnc" id="L1111" title="All 4 branches missed.">            if (spaceAddon &gt; 0 || spaceAddonLeftoverEnd &gt;= 0) {</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">                justificationData = (oldJustficationData != null)</span>
                    ? oldJustficationData
                    : new int[END_JUSTIFIABLE + 1];
<span class="nc" id="L1115">                justificationData[SPACE_ADDON] = spaceAddon;</span>
<span class="nc" id="L1116">                justificationData[SPACE_ADDON_LEFTOVER_END] =</span>
                    spaceAddonLeftoverEnd;
<span class="nc" id="L1118">                justificationData[START_JUSTIFIABLE] =</span>
                    startJustifiableContent - rowStartOffset;
<span class="nc" id="L1120">                justificationData[END_JUSTIFIABLE] =</span>
                    endJustifiableContent - rowStartOffset;
<span class="nc" id="L1122">                super.layoutMajorAxis(targetSpan, axis, offsets, spans);</span>
            }
<span class="nc" id="L1124">        }</span>

        //for justified row we assume the maximum horizontal span
        //is MAX_VALUE.
        @Override
        public float getMaximumSpan(int axis) {
            float ret;
<span class="nc bnc" id="L1131" title="All 2 branches missed.">            if (View.X_AXIS == axis</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">                  &amp;&amp; isJustifyEnabled()) {</span>
<span class="nc" id="L1133">                ret = Float.MAX_VALUE;</span>
            } else {
<span class="nc" id="L1135">              ret = super.getMaximumSpan(axis);</span>
            }
<span class="nc" id="L1137">            return ret;</span>
        }

        /**
         * Fetches the child view index representing the given position in
         * the model.
         *
         * @param pos the position &amp;gt;= 0
         * @return  index of the view representing the given position, or
         *   -1 if no view represents that position
         */
        protected int getViewIndexAtPosition(int pos) {
            // This is expensive, but are views are not necessarily layed
            // out in model order.
<span class="nc bnc" id="L1151" title="All 4 branches missed.">            if(pos &lt; getStartOffset() || pos &gt;= getEndOffset())</span>
<span class="nc" id="L1152">                return -1;</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">            for(int counter = getViewCount() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L1154">                View v = getView(counter);</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">                if(pos &gt;= v.getStartOffset() &amp;&amp;</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">                   pos &lt; v.getEndOffset()) {</span>
<span class="nc" id="L1157">                    return counter;</span>
                }
            }
<span class="nc" id="L1160">            return -1;</span>
        }

        /**
         * Gets the left inset.
         *
         * @return the inset
         */
        protected short getLeftInset() {
            View parentView;
<span class="nc" id="L1170">            int adjustment = 0;</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">            if ((parentView = getParent()) != null) { //use firstLineIdent for the first row</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">                if (this == parentView.getView(0)) {</span>
<span class="nc" id="L1173">                    adjustment = firstLineIndent;</span>
                }
            }
<span class="nc" id="L1176">            return (short)(super.getLeftInset() + adjustment);</span>
        }

        protected short getBottomInset() {
<span class="nc bnc" id="L1180" title="All 2 branches missed.">            return (short)(super.getBottomInset() +</span>
                           ((minorRequest != null) ? minorRequest.preferred : 0) *
<span class="nc" id="L1182">                           lineSpacing);</span>
        }

        final static int SPACE_ADDON = 0;
        final static int SPACE_ADDON_LEFTOVER_END = 1;
        final static int START_JUSTIFIABLE = 2;
        //this should be the last index in justificationData
        final static int END_JUSTIFIABLE = 3;

<span class="nc" id="L1191">        int justificationData[] = null;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>