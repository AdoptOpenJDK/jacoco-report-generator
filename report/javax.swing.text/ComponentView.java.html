<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ComponentView.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">ComponentView.java</span></div><h1>ComponentView.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.awt.*;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.Set;
import javax.swing.SwingUtilities;
import javax.swing.event.*;

/**
 * Component decorator that implements the view interface.  The
 * entire element is used to represent the component.  This acts
 * as a gateway from the display-only View implementations to
 * interactive lightweight components (ie it allows components
 * to be embedded into the View hierarchy).
 * &lt;p&gt;
 * The component is placed relative to the text baseline
 * according to the value returned by
 * &lt;code&gt;Component.getAlignmentY&lt;/code&gt;.  For Swing components
 * this value can be conveniently set using the method
 * &lt;code&gt;JComponent.setAlignmentY&lt;/code&gt;.  For example, setting
 * a value of &lt;code&gt;0.75&lt;/code&gt; will cause 75 percent of the
 * component to be above the baseline, and 25 percent of the
 * component to be below the baseline.
 * &lt;p&gt;
 * This class is implemented to do the extra work necessary to
 * work properly in the presence of multiple threads (i.e. from
 * asynchronous notification of model changes for example) by
 * ensuring that all component access is done on the event thread.
 * &lt;p&gt;
 * The component used is determined by the return value of the
 * createComponent method.  The default implementation of this
 * method is to return the component held as an attribute of
 * the element (by calling StyleConstants.getComponent).  A
 * limitation of this behavior is that the component cannot
 * be used by more than one text component (i.e. with a shared
 * model).  Subclasses can remove this constraint by implementing
 * the createComponent to actually create a component based upon
 * some kind of specification contained in the attributes.  The
 * ObjectView class in the html package is an example of a
 * ComponentView implementation that supports multiple component
 * views of a shared model.
 *
 * @author Timothy Prinzing
 */
public class ComponentView extends View  {

    /**
     * Creates a new ComponentView object.
     *
     * @param elem the element to decorate
     */
    public ComponentView(Element elem) {
<span class="nc" id="L78">        super(elem);</span>
<span class="nc" id="L79">    }</span>

    /**
     * Create the component that is associated with
     * this view.  This will be called when it has
     * been determined that a new component is needed.
     * This would result from a call to setParent or
     * as a result of being notified that attributes
     * have changed.
     */
    protected Component createComponent() {
<span class="nc" id="L90">        AttributeSet attr = getElement().getAttributes();</span>
<span class="nc" id="L91">        Component comp = StyleConstants.getComponent(attr);</span>
<span class="nc" id="L92">        return comp;</span>
    }

    /**
     * Fetch the component associated with the view.
     */
    public final Component getComponent() {
<span class="nc" id="L99">        return createdC;</span>
    }

    // --- View methods ---------------------------------------------

    /**
     * The real paint behavior occurs naturally from the association
     * that the component has with its parent container (the same
     * container hosting this view).  This is implemented to do nothing.
     *
     * @param g the graphics context
     * @param a the shape
     * @see View#paint
     */
    public void paint(Graphics g, Shape a) {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">            Rectangle alloc = (a instanceof Rectangle) ?</span>
<span class="nc" id="L116">                (Rectangle) a : a.getBounds();</span>
<span class="nc" id="L117">            c.setBounds(alloc.x, alloc.y, alloc.width, alloc.height);</span>
        }
<span class="nc" id="L119">    }</span>

    /**
     * Determines the preferred span for this view along an
     * axis.  This is implemented to return the value
     * returned by Component.getPreferredSize along the
     * axis of interest.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return   the span the view would like to be rendered into &amp;gt;=0.
     *           Typically the view is told to render into the span
     *           that is returned, although there is no guarantee.
     *           The parent may choose to resize or break the view.
     * @exception IllegalArgumentException for an invalid axis
     */
    public float getPreferredSpan(int axis) {
<span class="nc bnc" id="L135" title="All 4 branches missed.">        if ((axis != X_AXIS) &amp;&amp; (axis != Y_AXIS)) {</span>
<span class="nc" id="L136">            throw new IllegalArgumentException(&quot;Invalid axis: &quot; + axis);</span>
        }
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L139">            Dimension size = c.getPreferredSize();</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (axis == View.X_AXIS) {</span>
<span class="nc" id="L141">                return size.width;</span>
            } else {
<span class="nc" id="L143">                return size.height;</span>
            }
        }
<span class="nc" id="L146">        return 0;</span>
    }

    /**
     * Determines the minimum span for this view along an
     * axis.  This is implemented to return the value
     * returned by Component.getMinimumSize along the
     * axis of interest.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return   the span the view would like to be rendered into &amp;gt;=0.
     *           Typically the view is told to render into the span
     *           that is returned, although there is no guarantee.
     *           The parent may choose to resize or break the view.
     * @exception IllegalArgumentException for an invalid axis
     */
    public float getMinimumSpan(int axis) {
<span class="nc bnc" id="L163" title="All 4 branches missed.">        if ((axis != X_AXIS) &amp;&amp; (axis != Y_AXIS)) {</span>
<span class="nc" id="L164">            throw new IllegalArgumentException(&quot;Invalid axis: &quot; + axis);</span>
        }
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L167">            Dimension size = c.getMinimumSize();</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            if (axis == View.X_AXIS) {</span>
<span class="nc" id="L169">                return size.width;</span>
            } else {
<span class="nc" id="L171">                return size.height;</span>
            }
        }
<span class="nc" id="L174">        return 0;</span>
    }

    /**
     * Determines the maximum span for this view along an
     * axis.  This is implemented to return the value
     * returned by Component.getMaximumSize along the
     * axis of interest.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return   the span the view would like to be rendered into &amp;gt;=0.
     *           Typically the view is told to render into the span
     *           that is returned, although there is no guarantee.
     *           The parent may choose to resize or break the view.
     * @exception IllegalArgumentException for an invalid axis
     */
    public float getMaximumSpan(int axis) {
<span class="nc bnc" id="L191" title="All 4 branches missed.">        if ((axis != X_AXIS) &amp;&amp; (axis != Y_AXIS)) {</span>
<span class="nc" id="L192">            throw new IllegalArgumentException(&quot;Invalid axis: &quot; + axis);</span>
        }
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L195">            Dimension size = c.getMaximumSize();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">            if (axis == View.X_AXIS) {</span>
<span class="nc" id="L197">                return size.width;</span>
            } else {
<span class="nc" id="L199">                return size.height;</span>
            }
        }
<span class="nc" id="L202">        return 0;</span>
    }

    /**
     * Determines the desired alignment for this view along an
     * axis.  This is implemented to give the alignment of the
     * embedded component.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return the desired alignment.  This should be a value
     *   between 0.0 and 1.0 where 0 indicates alignment at the
     *   origin and 1.0 indicates alignment to the full span
     *   away from the origin.  An alignment of 0.5 would be the
     *   center of the view.
     */
    public float getAlignment(int axis) {
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc bnc" id="L219" title="All 3 branches missed.">            switch (axis) {</span>
            case View.X_AXIS:
<span class="nc" id="L221">                return c.getAlignmentX();</span>
            case View.Y_AXIS:
<span class="nc" id="L223">                return c.getAlignmentY();</span>
            }
        }
<span class="nc" id="L226">        return super.getAlignment(axis);</span>
    }

    /**
     * Sets the parent for a child view.
     * The parent calls this on the child to tell it who its
     * parent is, giving the view access to things like
     * the hosting Container.  The superclass behavior is
     * executed, followed by a call to createComponent if
     * the parent view parameter is non-null and a component
     * has not yet been created. The embedded components parent
     * is then set to the value returned by &lt;code&gt;getContainer&lt;/code&gt;.
     * If the parent view parameter is null, this view is being
     * cleaned up, thus the component is removed from its parent.
     * &lt;p&gt;
     * The changing of the component hierarchy will
     * touch the component lock, which is the one thing
     * that is not safe from the View hierarchy.  Therefore,
     * this functionality is executed immediately if on the
     * event thread, or is queued on the event queue if
     * called from another thread (notification of change
     * from an asynchronous update).
     *
     * @param p the parent
     */
    public void setParent(View p) {
<span class="nc" id="L252">        super.setParent(p);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L254">            setComponentParent();</span>
        } else {
<span class="nc" id="L256">            Runnable callSetComponentParent = new Runnable() {</span>
                public void run() {
<span class="nc" id="L258">                    Document doc = getDocument();</span>
                    try {
<span class="nc bnc" id="L260" title="All 2 branches missed.">                        if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L261">                            ((AbstractDocument)doc).readLock();</span>
                        }
<span class="nc" id="L263">                        setComponentParent();</span>
<span class="nc" id="L264">                        Container host = getContainer();</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">                        if (host != null) {</span>
<span class="nc" id="L266">                            preferenceChanged(null, true, true);</span>
<span class="nc" id="L267">                            host.repaint();</span>
                        }
                    } finally {
<span class="nc bnc" id="L270" title="All 4 branches missed.">                        if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L271">                            ((AbstractDocument)doc).readUnlock();</span>
                        }
                    }
<span class="nc" id="L274">                }</span>
            };
<span class="nc" id="L276">            SwingUtilities.invokeLater(callSetComponentParent);</span>
        }
<span class="nc" id="L278">    }</span>

    /**
     * Set the parent of the embedded component
     * with assurance that it is thread-safe.
     */
    void setComponentParent() {
<span class="nc" id="L285">        View p = getParent();</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (p != null) {</span>
<span class="nc" id="L287">            Container parent = getContainer();</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                if (c == null) {</span>
                    // try to build a component
<span class="nc" id="L291">                    Component comp = createComponent();</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                    if (comp != null) {</span>
<span class="nc" id="L293">                        createdC = comp;</span>
<span class="nc" id="L294">                        c = new Invalidator(comp);</span>
                    }
                }
<span class="nc bnc" id="L297" title="All 2 branches missed.">                if (c != null) {</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                    if (c.getParent() == null) {</span>
                        // components associated with the View tree are added
                        // to the hosting container with the View as a constraint.
<span class="nc" id="L301">                        parent.add(c, this);</span>
<span class="nc" id="L302">                        parent.addPropertyChangeListener(&quot;enabled&quot;, c);</span>
                    }
                }
            }
<span class="nc" id="L306">        } else {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L308">                Container parent = c.getParent();</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">                if (parent != null) {</span>
                    // remove the component from its hosting container
<span class="nc" id="L311">                    parent.remove(c);</span>
<span class="nc" id="L312">                    parent.removePropertyChangeListener(&quot;enabled&quot;, c);</span>
                }
            }
        }
<span class="nc" id="L316">    }</span>

    /**
     * Provides a mapping from the coordinate space of the model to
     * that of the view.
     *
     * @param pos the position to convert &amp;gt;=0
     * @param a the allocated region to render into
     * @return the bounding box of the given position is returned
     * @exception BadLocationException  if the given position does not
     *   represent a valid location in the associated document
     * @see View#modelToView
     */
    public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
<span class="nc" id="L330">        int p0 = getStartOffset();</span>
<span class="nc" id="L331">        int p1 = getEndOffset();</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">        if ((pos &gt;= p0) &amp;&amp; (pos &lt;= p1)) {</span>
<span class="nc" id="L333">            Rectangle r = a.getBounds();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            if (pos == p1) {</span>
<span class="nc" id="L335">                r.x += r.width;</span>
            }
<span class="nc" id="L337">            r.width = 0;</span>
<span class="nc" id="L338">            return r;</span>
        }
<span class="nc" id="L340">        throw new BadLocationException(pos + &quot; not in range &quot; + p0 + &quot;,&quot; + p1, pos);</span>
    }

    /**
     * Provides a mapping from the view coordinate space to the logical
     * coordinate space of the model.
     *
     * @param x the X coordinate &amp;gt;=0
     * @param y the Y coordinate &amp;gt;=0
     * @param a the allocated region to render into
     * @return the location within the model that best represents
     *    the given point in the view
     * @see View#viewToModel
     */
    public int viewToModel(float x, float y, Shape a, Position.Bias[] bias) {
<span class="nc" id="L355">        Rectangle alloc = (Rectangle) a;</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (x &lt; alloc.x + (alloc.width / 2)) {</span>
<span class="nc" id="L357">            bias[0] = Position.Bias.Forward;</span>
<span class="nc" id="L358">            return getStartOffset();</span>
        }
<span class="nc" id="L360">        bias[0] = Position.Bias.Backward;</span>
<span class="nc" id="L361">        return getEndOffset();</span>
    }

    // --- member variables ------------------------------------------------

    private Component createdC;
    private Invalidator c;

    /**
     * This class feeds the invalidate back to the
     * hosting View.  This is needed to get the View
     * hierarchy to consider giving the component
     * a different size (i.e. layout may have been
     * cached between the associated view and the
     * container hosting this component).
     */
    class Invalidator extends Container implements PropertyChangeListener {

        // NOTE: When we remove this class we are going to have to some
        // how enforce setting of the focus traversal keys on the children
        // so that they don't inherit them from the JEditorPane. We need
        // to do this as JEditorPane has abnormal bindings (it is a focus cycle
        // root) and the children typically don't want these bindings as well.

<span class="nc" id="L385">        Invalidator(Component child) {</span>
<span class="nc" id="L386">            setLayout(null);</span>
<span class="nc" id="L387">            add(child);</span>
<span class="nc" id="L388">            cacheChildSizes();</span>
<span class="nc" id="L389">        }</span>

        /**
         * The components invalid layout needs
         * to be propagated through the view hierarchy
         * so the views (which position the component)
         * can have their layout recomputed.
         */
        public void invalidate() {
<span class="nc" id="L398">            super.invalidate();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if (getParent() != null) {</span>
<span class="nc" id="L400">                preferenceChanged(null, true, true);</span>
            }
<span class="nc" id="L402">        }</span>

        public void doLayout() {
<span class="nc" id="L405">            cacheChildSizes();</span>
<span class="nc" id="L406">        }</span>

        public void setBounds(int x, int y, int w, int h) {
<span class="nc" id="L409">            super.setBounds(x, y, w, h);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (getComponentCount() &gt; 0) {</span>
<span class="nc" id="L411">                getComponent(0).setSize(w, h);</span>
            }
<span class="nc" id="L413">            cacheChildSizes();</span>
<span class="nc" id="L414">        }</span>

        public void validateIfNecessary() {
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (!isValid()) {</span>
<span class="nc" id="L418">                validate();</span>
             }
<span class="nc" id="L420">        }</span>

        private void cacheChildSizes() {
<span class="nc bnc" id="L423" title="All 2 branches missed.">            if (getComponentCount() &gt; 0) {</span>
<span class="nc" id="L424">                Component child = getComponent(0);</span>
<span class="nc" id="L425">                min = child.getMinimumSize();</span>
<span class="nc" id="L426">                pref = child.getPreferredSize();</span>
<span class="nc" id="L427">                max = child.getMaximumSize();</span>
<span class="nc" id="L428">                yalign = child.getAlignmentY();</span>
<span class="nc" id="L429">                xalign = child.getAlignmentX();</span>
<span class="nc" id="L430">            } else {</span>
<span class="nc" id="L431">                min = pref = max = new Dimension(0, 0);</span>
            }
<span class="nc" id="L433">        }</span>

        /**
         * Shows or hides this component depending on the value of parameter
         * &lt;code&gt;b&lt;/code&gt;.
         * @param b If &lt;code&gt;true&lt;/code&gt;, shows this component;
         * otherwise, hides this component.
         * @see #isVisible
         * @since JDK1.1
         */
        public void setVisible(boolean b) {
<span class="nc" id="L444">            super.setVisible(b);</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            if (getComponentCount() &gt; 0) {</span>
<span class="nc" id="L446">                getComponent(0).setVisible(b);</span>
            }
<span class="nc" id="L448">        }</span>

        /**
         * Overridden to fix 4759054. Must return true so that content
         * is painted when inside a CellRendererPane which is normally
         * invisible.
         */
        public boolean isShowing() {
<span class="nc" id="L456">            return true;</span>
        }

        public Dimension getMinimumSize() {
<span class="nc" id="L460">            validateIfNecessary();</span>
<span class="nc" id="L461">            return min;</span>
        }

        public Dimension getPreferredSize() {
<span class="nc" id="L465">            validateIfNecessary();</span>
<span class="nc" id="L466">            return pref;</span>
        }

        public Dimension getMaximumSize() {
<span class="nc" id="L470">            validateIfNecessary();</span>
<span class="nc" id="L471">            return max;</span>
        }

        public float getAlignmentX() {
<span class="nc" id="L475">            validateIfNecessary();</span>
<span class="nc" id="L476">            return xalign;</span>
        }

        public float getAlignmentY() {
<span class="nc" id="L480">            validateIfNecessary();</span>
<span class="nc" id="L481">            return yalign;</span>
        }

        public Set&lt;AWTKeyStroke&gt; getFocusTraversalKeys(int id) {
<span class="nc" id="L485">            return KeyboardFocusManager.getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L486">                    getDefaultFocusTraversalKeys(id);</span>
        }

        public void propertyChange(PropertyChangeEvent ev) {
<span class="nc" id="L490">            Boolean enable = (Boolean) ev.getNewValue();</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">            if (getComponentCount() &gt; 0) {</span>
<span class="nc" id="L492">                getComponent(0).setEnabled(enable);</span>
            }
<span class="nc" id="L494">        }</span>

        Dimension min;
        Dimension pref;
        Dimension max;
        float yalign;
        float xalign;

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>