<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>NumberFormatter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">NumberFormatter.java</span></div><h1>NumberFormatter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.lang.reflect.*;
import java.text.*;
import java.util.*;
import sun.reflect.misc.ReflectUtil;
import sun.swing.SwingUtilities2;

/**
 * &lt;code&gt;NumberFormatter&lt;/code&gt; subclasses &lt;code&gt;InternationalFormatter&lt;/code&gt;
 * adding special behavior for numbers. Among the specializations are
 * (these are only used if the &lt;code&gt;NumberFormatter&lt;/code&gt; does not display
 * invalid numbers, for example, &lt;code&gt;setAllowsInvalid(false)&lt;/code&gt;):
 * &lt;ul&gt;
 *   &lt;li&gt;Pressing +/- (- is determined from the
 *       &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; associated with the
 *       &lt;code&gt;DecimalFormat&lt;/code&gt;) in any field but the exponent
 *       field will attempt to change the sign of the number to
 *       positive/negative.
 *   &lt;li&gt;Pressing +/- (- is determined from the
 *       &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; associated with the
 *       &lt;code&gt;DecimalFormat&lt;/code&gt;) in the exponent field will
 *       attempt to change the sign of the exponent to positive/negative.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * If you are displaying scientific numbers, you may wish to turn on
 * overwrite mode, &lt;code&gt;setOverwriteMode(true)&lt;/code&gt;. For example:
 * &lt;pre&gt;
 * DecimalFormat decimalFormat = new DecimalFormat(&quot;0.000E0&quot;);
 * NumberFormatter textFormatter = new NumberFormatter(decimalFormat);
 * textFormatter.setOverwriteMode(true);
 * textFormatter.setAllowsInvalid(false);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * If you are going to allow the user to enter decimal
 * values, you should either force the DecimalFormat to contain at least
 * one decimal (&lt;code&gt;#.0###&lt;/code&gt;), or allow the value to be invalid
 * &lt;code&gt;setAllowsInvalid(true)&lt;/code&gt;. Otherwise users may not be able to
 * input decimal values.
 * &lt;p&gt;
 * &lt;code&gt;NumberFormatter&lt;/code&gt; provides slightly different behavior to
 * &lt;code&gt;stringToValue&lt;/code&gt; than that of its superclass. If you have
 * specified a Class for values, {@link #setValueClass}, that is one of
 * of &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;,
 * &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Byte&lt;/code&gt; or &lt;code&gt;Short&lt;/code&gt; and
 * the Format's &lt;code&gt;parseObject&lt;/code&gt; returns an instance of
 * &lt;code&gt;Number&lt;/code&gt;, the corresponding instance of the value class
 * will be created using the constructor appropriate for the primitive
 * type the value class represents. For example:
 * &lt;code&gt;setValueClass(Integer.class)&lt;/code&gt; will cause the resulting
 * value to be created via
 * &lt;code&gt;new Integer(((Number)formatter.parseObject(string)).intValue())&lt;/code&gt;.
 * This is typically useful if you
 * wish to set a min/max value as the various &lt;code&gt;Number&lt;/code&gt;
 * implementations are generally not comparable to each other. This is also
 * useful if for some reason you need a specific &lt;code&gt;Number&lt;/code&gt;
 * implementation for your values.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @since 1.4
 */
public class NumberFormatter extends InternationalFormatter {
    /** The special characters from the Format instance. */
    private String specialChars;

    /**
     * Creates a &lt;code&gt;NumberFormatter&lt;/code&gt; with the a default
     * &lt;code&gt;NumberFormat&lt;/code&gt; instance obtained from
     * &lt;code&gt;NumberFormat.getNumberInstance()&lt;/code&gt;.
     */
    public NumberFormatter() {
<span class="nc" id="L104">        this(NumberFormat.getNumberInstance());</span>
<span class="nc" id="L105">    }</span>

    /**
     * Creates a NumberFormatter with the specified Format instance.
     *
     * @param format Format used to dictate legal values
     */
    public NumberFormatter(NumberFormat format) {
<span class="nc" id="L113">        super(format);</span>
<span class="nc" id="L114">        setFormat(format);</span>
<span class="nc" id="L115">        setAllowsInvalid(true);</span>
<span class="nc" id="L116">        setCommitsOnValidEdit(false);</span>
<span class="nc" id="L117">        setOverwriteMode(false);</span>
<span class="nc" id="L118">    }</span>

    /**
     * Sets the format that dictates the legal values that can be edited
     * and displayed.
     * &lt;p&gt;
     * If you have used the nullary constructor the value of this property
     * will be determined for the current locale by way of the
     * &lt;code&gt;NumberFormat.getNumberInstance()&lt;/code&gt; method.
     *
     * @param format NumberFormat instance used to dictate legal values
     */
    public void setFormat(Format format) {
<span class="nc" id="L131">        super.setFormat(format);</span>

<span class="nc" id="L133">        DecimalFormatSymbols dfs = getDecimalFormatSymbols();</span>

<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (dfs != null) {</span>
<span class="nc" id="L136">            StringBuilder sb = new StringBuilder();</span>

<span class="nc" id="L138">            sb.append(dfs.getCurrencySymbol());</span>
<span class="nc" id="L139">            sb.append(dfs.getDecimalSeparator());</span>
<span class="nc" id="L140">            sb.append(dfs.getGroupingSeparator());</span>
<span class="nc" id="L141">            sb.append(dfs.getInfinity());</span>
<span class="nc" id="L142">            sb.append(dfs.getInternationalCurrencySymbol());</span>
<span class="nc" id="L143">            sb.append(dfs.getMinusSign());</span>
<span class="nc" id="L144">            sb.append(dfs.getMonetaryDecimalSeparator());</span>
<span class="nc" id="L145">            sb.append(dfs.getNaN());</span>
<span class="nc" id="L146">            sb.append(dfs.getPercent());</span>
<span class="nc" id="L147">            sb.append('+');</span>
<span class="nc" id="L148">            specialChars = sb.toString();</span>
<span class="nc" id="L149">        }</span>
        else {
<span class="nc" id="L151">            specialChars = &quot;&quot;;</span>
        }
<span class="nc" id="L153">    }</span>

    /**
     * Invokes &lt;code&gt;parseObject&lt;/code&gt; on &lt;code&gt;f&lt;/code&gt;, returning
     * its value.
     */
    Object stringToValue(String text, Format f) throws ParseException {
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (f == null) {</span>
<span class="nc" id="L161">            return text;</span>
        }
<span class="nc" id="L163">        Object value = f.parseObject(text);</span>

<span class="nc" id="L165">        return convertValueToValueClass(value, getValueClass());</span>
    }

    /**
     * Converts the passed in value to the passed in class. This only
     * works if &lt;code&gt;valueClass&lt;/code&gt; is one of &lt;code&gt;Integer&lt;/code&gt;,
     * &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;,
     * &lt;code&gt;Byte&lt;/code&gt; or &lt;code&gt;Short&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;
     * is an instanceof &lt;code&gt;Number&lt;/code&gt;.
     */
    private Object convertValueToValueClass(Object value, Class valueClass) {
<span class="nc bnc" id="L176" title="All 4 branches missed.">        if (valueClass != null &amp;&amp; (value instanceof Number)) {</span>
<span class="nc" id="L177">            Number numberValue = (Number)value;</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            if (valueClass == Integer.class) {</span>
<span class="nc" id="L179">                return Integer.valueOf(numberValue.intValue());</span>
            }
<span class="nc bnc" id="L181" title="All 2 branches missed.">            else if (valueClass == Long.class) {</span>
<span class="nc" id="L182">                return Long.valueOf(numberValue.longValue());</span>
            }
<span class="nc bnc" id="L184" title="All 2 branches missed.">            else if (valueClass == Float.class) {</span>
<span class="nc" id="L185">                return Float.valueOf(numberValue.floatValue());</span>
            }
<span class="nc bnc" id="L187" title="All 2 branches missed.">            else if (valueClass == Double.class) {</span>
<span class="nc" id="L188">                return Double.valueOf(numberValue.doubleValue());</span>
            }
<span class="nc bnc" id="L190" title="All 2 branches missed.">            else if (valueClass == Byte.class) {</span>
<span class="nc" id="L191">                return Byte.valueOf(numberValue.byteValue());</span>
            }
<span class="nc bnc" id="L193" title="All 2 branches missed.">            else if (valueClass == Short.class) {</span>
<span class="nc" id="L194">                return Short.valueOf(numberValue.shortValue());</span>
            }
        }
<span class="nc" id="L197">        return value;</span>
    }

    /**
     * Returns the character that is used to toggle to positive values.
     */
    private char getPositiveSign() {
<span class="nc" id="L204">        return '+';</span>
    }

    /**
     * Returns the character that is used to toggle to negative values.
     */
    private char getMinusSign() {
<span class="nc" id="L211">        DecimalFormatSymbols dfs = getDecimalFormatSymbols();</span>

<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (dfs != null) {</span>
<span class="nc" id="L214">            return dfs.getMinusSign();</span>
        }
<span class="nc" id="L216">        return '-';</span>
    }

    /**
     * Returns the character that is used to toggle to negative values.
     */
    private char getDecimalSeparator() {
<span class="nc" id="L223">        DecimalFormatSymbols dfs = getDecimalFormatSymbols();</span>

<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (dfs != null) {</span>
<span class="nc" id="L226">            return dfs.getDecimalSeparator();</span>
        }
<span class="nc" id="L228">        return '.';</span>
    }

    /**
     * Returns the DecimalFormatSymbols from the Format instance.
     */
    private DecimalFormatSymbols getDecimalFormatSymbols() {
<span class="nc" id="L235">        Format f = getFormat();</span>

<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (f instanceof DecimalFormat) {</span>
<span class="nc" id="L238">            return ((DecimalFormat)f).getDecimalFormatSymbols();</span>
        }
<span class="nc" id="L240">        return null;</span>
    }

    /**
     * Subclassed to return false if &lt;code&gt;text&lt;/code&gt; contains in an invalid
     * character to insert, that is, it is not a digit
     * (&lt;code&gt;Character.isDigit()&lt;/code&gt;) and
     * not one of the characters defined by the DecimalFormatSymbols.
     */
    boolean isLegalInsertText(String text) {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (getAllowsInvalid()) {</span>
<span class="nc" id="L251">            return true;</span>
        }
<span class="nc bnc" id="L253" title="All 2 branches missed.">        for (int counter = text.length() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L254">            char aChar = text.charAt(counter);</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (!Character.isDigit(aChar) &amp;&amp;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">                           specialChars.indexOf(aChar) == -1){</span>
<span class="nc" id="L258">                return false;</span>
            }
        }
<span class="nc" id="L261">        return true;</span>
    }

    /**
     * Subclassed to treat the decimal separator, grouping separator,
     * exponent symbol, percent, permille, currency and sign as literals.
     */
    boolean isLiteral(Map attrs) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (!super.isLiteral(attrs)) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            if (attrs == null) {</span>
<span class="nc" id="L271">                return false;</span>
            }
<span class="nc" id="L273">            int size = attrs.size();</span>

<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (attrs.get(NumberFormat.Field.GROUPING_SEPARATOR) != null) {</span>
<span class="nc" id="L276">                size--;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">                if (attrs.get(NumberFormat.Field.INTEGER) != null) {</span>
<span class="nc" id="L278">                    size--;</span>
                }
            }
<span class="nc bnc" id="L281" title="All 2 branches missed.">            if (attrs.get(NumberFormat.Field.EXPONENT_SYMBOL) != null) {</span>
<span class="nc" id="L282">                size--;</span>
            }
<span class="nc bnc" id="L284" title="All 2 branches missed.">            if (attrs.get(NumberFormat.Field.PERCENT) != null) {</span>
<span class="nc" id="L285">                size--;</span>
            }
<span class="nc bnc" id="L287" title="All 2 branches missed.">            if (attrs.get(NumberFormat.Field.PERMILLE) != null) {</span>
<span class="nc" id="L288">                size--;</span>
            }
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (attrs.get(NumberFormat.Field.CURRENCY) != null) {</span>
<span class="nc" id="L291">                size--;</span>
            }
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (attrs.get(NumberFormat.Field.SIGN) != null) {</span>
<span class="nc" id="L294">                size--;</span>
            }
<span class="nc bnc" id="L296" title="All 2 branches missed.">            return size == 0;</span>
        }
<span class="nc" id="L298">        return true;</span>
    }

    /**
     * Subclassed to make the decimal separator navigable, as well
     * as making the character between the integer field and the next
     * field navigable.
     */
    boolean isNavigatable(int index) {
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (!super.isNavigatable(index)) {</span>
            // Don't skip the decimal, it causes wierd behavior
<span class="nc bnc" id="L309" title="All 2 branches missed.">            return getBufferedChar(index) == getDecimalSeparator();</span>
        }
<span class="nc" id="L311">        return true;</span>
    }

    /**
     * Returns the first &lt;code&gt;NumberFormat.Field&lt;/code&gt; starting
     * &lt;code&gt;index&lt;/code&gt; incrementing by &lt;code&gt;direction&lt;/code&gt;.
     */
    private NumberFormat.Field getFieldFrom(int index, int direction) {
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (isValidMask()) {</span>
<span class="nc" id="L320">            int max = getFormattedTextField().getDocument().getLength();</span>
<span class="nc" id="L321">            AttributedCharacterIterator iterator = getIterator();</span>

<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (index &gt;= max) {</span>
<span class="nc" id="L324">                index += direction;</span>
            }
<span class="nc bnc" id="L326" title="All 4 branches missed.">            while (index &gt;= 0 &amp;&amp; index &lt; max) {</span>
<span class="nc" id="L327">                iterator.setIndex(index);</span>

<span class="nc" id="L329">                Map attrs = iterator.getAttributes();</span>

<span class="nc bnc" id="L331" title="All 4 branches missed.">                if (attrs != null &amp;&amp; attrs.size() &gt; 0) {</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                    for (Object key : attrs.keySet()) {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                        if (key instanceof NumberFormat.Field) {</span>
<span class="nc" id="L334">                            return (NumberFormat.Field)key;</span>
                        }
<span class="nc" id="L336">                    }</span>
                }
<span class="nc" id="L338">                index += direction;</span>
<span class="nc" id="L339">            }</span>
        }
<span class="nc" id="L341">        return null;</span>
    }

    /**
     * Overriden to toggle the value if the positive/minus sign
     * is inserted.
     */
    void replace(DocumentFilter.FilterBypass fb, int offset, int length,
                String string, AttributeSet attr) throws BadLocationException {
<span class="nc bnc" id="L350" title="All 6 branches missed.">        if (!getAllowsInvalid() &amp;&amp; length == 0 &amp;&amp; string != null &amp;&amp;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">            string.length() == 1 &amp;&amp;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            toggleSignIfNecessary(fb, offset, string.charAt(0))) {</span>
<span class="nc" id="L353">            return;</span>
        }
<span class="nc" id="L355">        super.replace(fb, offset, length, string, attr);</span>
<span class="nc" id="L356">    }</span>

    /**
     * Will change the sign of the integer or exponent field if
     * &lt;code&gt;aChar&lt;/code&gt; is the positive or minus sign. Returns
     * true if a sign change was attempted.
     */
    private boolean toggleSignIfNecessary(DocumentFilter.FilterBypass fb,
                                              int offset, char aChar) throws
                              BadLocationException {
<span class="nc bnc" id="L366" title="All 4 branches missed.">        if (aChar == getMinusSign() || aChar == getPositiveSign()) {</span>
<span class="nc" id="L367">            NumberFormat.Field field = getFieldFrom(offset, -1);</span>
            Object newValue;

            try {
<span class="nc bnc" id="L371" title="All 8 branches missed.">                if (field == null ||</span>
                    (field != NumberFormat.Field.EXPONENT &amp;&amp;
                     field != NumberFormat.Field.EXPONENT_SYMBOL &amp;&amp;
                     field != NumberFormat.Field.EXPONENT_SIGN)) {
<span class="nc bnc" id="L375" title="All 2 branches missed.">                    newValue = toggleSign((aChar == getPositiveSign()));</span>
                }
                else {
                    // exponent
<span class="nc" id="L379">                    newValue = toggleExponentSign(offset, aChar);</span>
                }
<span class="nc bnc" id="L381" title="All 4 branches missed.">                if (newValue != null &amp;&amp; isValidValue(newValue, false)) {</span>
<span class="nc" id="L382">                    int lc = getLiteralCountTo(offset);</span>
<span class="nc" id="L383">                    String string = valueToString(newValue);</span>

<span class="nc" id="L385">                    fb.remove(0, fb.getDocument().getLength());</span>
<span class="nc" id="L386">                    fb.insertString(0, string, null);</span>
<span class="nc" id="L387">                    updateValue(newValue);</span>
<span class="nc" id="L388">                    repositionCursor(getLiteralCountTo(offset) -</span>
                                     lc + offset, 1);
<span class="nc" id="L390">                    return true;</span>
                }
<span class="nc" id="L392">            } catch (ParseException pe) {</span>
<span class="nc" id="L393">                invalidEdit();</span>
<span class="nc" id="L394">            }</span>
        }
<span class="nc" id="L396">        return false;</span>
    }

    /**
     * Invoked to toggle the sign. For this to work the value class
     * must have a single arg constructor that takes a String.
     */
    private Object toggleSign(boolean positive) throws ParseException {
<span class="nc" id="L404">        Object value = stringToValue(getFormattedTextField().getText());</span>

<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (value != null) {</span>
            // toString isn't localized, so that using +/- should work
            // correctly.
<span class="nc" id="L409">            String string = value.toString();</span>

<span class="nc bnc" id="L411" title="All 4 branches missed.">            if (string != null &amp;&amp; string.length() &gt; 0) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                if (positive) {</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                    if (string.charAt(0) == '-') {</span>
<span class="nc" id="L414">                        string = string.substring(1);</span>
                    }
                }
                else {
<span class="nc bnc" id="L418" title="All 2 branches missed.">                    if (string.charAt(0) == '+') {</span>
<span class="nc" id="L419">                        string = string.substring(1);</span>
                    }
<span class="nc bnc" id="L421" title="All 4 branches missed.">                    if (string.length() &gt; 0 &amp;&amp; string.charAt(0) != '-') {</span>
<span class="nc" id="L422">                        string = &quot;-&quot; + string;</span>
                    }
                }
<span class="nc bnc" id="L425" title="All 2 branches missed.">                if (string != null) {</span>
<span class="nc" id="L426">                    Class&lt;?&gt; valueClass = getValueClass();</span>

<span class="nc bnc" id="L428" title="All 2 branches missed.">                    if (valueClass == null) {</span>
<span class="nc" id="L429">                        valueClass = value.getClass();</span>
                    }
                    try {
<span class="nc" id="L432">                        ReflectUtil.checkPackageAccess(valueClass);</span>
<span class="nc" id="L433">                        SwingUtilities2.checkAccess(valueClass.getModifiers());</span>
<span class="nc" id="L434">                        Constructor cons = valueClass.getConstructor(</span>
                                              new Class[] { String.class });
<span class="nc bnc" id="L436" title="All 2 branches missed.">                        if (cons != null) {</span>
<span class="nc" id="L437">                            SwingUtilities2.checkAccess(cons.getModifiers());</span>
<span class="nc" id="L438">                            return cons.newInstance(new Object[]{string});</span>
                        }
<span class="nc" id="L440">                    } catch (Throwable ex) { }</span>
                }
            }
        }
<span class="nc" id="L444">        return null;</span>
    }

    /**
     * Invoked to toggle the sign of the exponent (for scientific
     * numbers).
     */
    private Object toggleExponentSign(int offset, char aChar) throws
                             BadLocationException, ParseException {
<span class="nc" id="L453">        String string = getFormattedTextField().getText();</span>
<span class="nc" id="L454">        int replaceLength = 0;</span>
<span class="nc" id="L455">        int loc = getAttributeStart(NumberFormat.Field.EXPONENT_SIGN);</span>

<span class="nc bnc" id="L457" title="All 2 branches missed.">        if (loc &gt;= 0) {</span>
<span class="nc" id="L458">            replaceLength = 1;</span>
<span class="nc" id="L459">            offset = loc;</span>
        }
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (aChar == getPositiveSign()) {</span>
<span class="nc" id="L462">            string = getReplaceString(offset, replaceLength, null);</span>
        }
        else {
<span class="nc" id="L465">            string = getReplaceString(offset, replaceLength,</span>
                                      new String(new char[] { aChar }));
        }
<span class="nc" id="L468">        return stringToValue(string);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>