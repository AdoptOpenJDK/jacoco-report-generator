<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StyleContext.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">StyleContext.java</span></div><h1>StyleContext.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.awt.*;
import java.util.*;
import java.io.*;

import javax.swing.SwingUtilities;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ChangeEvent;
import java.lang.ref.WeakReference;
import java.util.WeakHashMap;

import sun.font.FontUtilities;

/**
 * A pool of styles and their associated resources.  This class determines
 * the lifetime of a group of resources by being a container that holds
 * caches for various resources such as font and color that get reused
 * by the various style definitions.  This can be shared by multiple
 * documents if desired to maximize the sharing of related resources.
 * &lt;p&gt;
 * This class also provides efficient support for small sets of attributes
 * and compresses them by sharing across uses and taking advantage of
 * their immutable nature.  Since many styles are replicated, the potential
 * for sharing is significant, and copies can be extremely cheap.
 * Larger sets reduce the possibility of sharing, and therefore revert
 * automatically to a less space-efficient implementation.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author  Timothy Prinzing
 */
public class StyleContext implements Serializable, AbstractDocument.AttributeContext {

    /**
     * Returns default AttributeContext shared by all documents that
     * don't bother to define/supply their own context.
     *
     * @return the context
     */
    public static final StyleContext getDefaultStyleContext() {
<span class="nc bnc" id="L74" title="All 2 branches missed.">        if (defaultContext == null) {</span>
<span class="nc" id="L75">            defaultContext = new StyleContext();</span>
        }
<span class="nc" id="L77">        return defaultContext;</span>
    }

    private static StyleContext defaultContext;

    /**
     * Creates a new StyleContext object.
     */
<span class="nc" id="L85">    public StyleContext() {</span>
<span class="nc" id="L86">        styles = new NamedStyle(null);</span>
<span class="nc" id="L87">        addStyle(DEFAULT_STYLE, null);</span>
<span class="nc" id="L88">    }</span>

    /**
     * Adds a new style into the style hierarchy.  Style attributes
     * resolve from bottom up so an attribute specified in a child
     * will override an attribute specified in the parent.
     *
     * @param nm   the name of the style (must be unique within the
     *   collection of named styles in the document).  The name may
     *   be null if the style is unnamed, but the caller is responsible
     *   for managing the reference returned as an unnamed style can't
     *   be fetched by name.  An unnamed style may be useful for things
     *   like character attribute overrides such as found in a style
     *   run.
     * @param parent the parent style.  This may be null if unspecified
     *   attributes need not be resolved in some other style.
     * @return the created style
     */
    public Style addStyle(String nm, Style parent) {
<span class="nc" id="L107">        Style style = new NamedStyle(nm, parent);</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (nm != null) {</span>
            // add a named style, a class of attributes
<span class="nc" id="L110">            styles.addAttribute(nm, style);</span>
        }
<span class="nc" id="L112">        return style;</span>
    }

    /**
     * Removes a named style previously added to the document.
     *
     * @param nm  the name of the style to remove
     */
    public void removeStyle(String nm) {
<span class="nc" id="L121">        styles.removeAttribute(nm);</span>
<span class="nc" id="L122">    }</span>

    /**
     * Fetches a named style previously added to the document
     *
     * @param nm  the name of the style
     * @return the style
     */
    public Style getStyle(String nm) {
<span class="nc" id="L131">        return (Style) styles.getAttribute(nm);</span>
    }

    /**
     * Fetches the names of the styles defined.
     *
     * @return the list of names as an enumeration
     */
    public Enumeration&lt;?&gt; getStyleNames() {
<span class="nc" id="L140">        return styles.getAttributeNames();</span>
    }

    /**
     * Adds a listener to track when styles are added
     * or removed.
     *
     * @param l the change listener
     */
    public void addChangeListener(ChangeListener l) {
<span class="nc" id="L150">        styles.addChangeListener(l);</span>
<span class="nc" id="L151">    }</span>

    /**
     * Removes a listener that was tracking styles being
     * added or removed.
     *
     * @param l the change listener
     */
    public void removeChangeListener(ChangeListener l) {
<span class="nc" id="L160">        styles.removeChangeListener(l);</span>
<span class="nc" id="L161">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;ChangeListener&lt;/code&gt;s added
     * to this StyleContext with addChangeListener().
     *
     * @return all of the &lt;code&gt;ChangeListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public ChangeListener[] getChangeListeners() {
<span class="nc" id="L172">        return ((NamedStyle)styles).getChangeListeners();</span>
    }

    /**
     * Gets the font from an attribute set.  This is
     * implemented to try and fetch a cached font
     * for the given AttributeSet, and if that fails
     * the font features are resolved and the
     * font is fetched from the low-level font cache.
     *
     * @param attr the attribute set
     * @return the font
     */
    public Font getFont(AttributeSet attr) {
        // PENDING(prinz) add cache behavior
<span class="nc" id="L187">        int style = Font.PLAIN;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (StyleConstants.isBold(attr)) {</span>
<span class="nc" id="L189">            style |= Font.BOLD;</span>
        }
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (StyleConstants.isItalic(attr)) {</span>
<span class="nc" id="L192">            style |= Font.ITALIC;</span>
        }
<span class="nc" id="L194">        String family = StyleConstants.getFontFamily(attr);</span>
<span class="nc" id="L195">        int size = StyleConstants.getFontSize(attr);</span>

        /**
         * if either superscript or subscript is
         * is set, we need to reduce the font size
         * by 2.
         */
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (StyleConstants.isSuperscript(attr) ||</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            StyleConstants.isSubscript(attr)) {</span>
<span class="nc" id="L204">            size -= 2;</span>
        }

<span class="nc" id="L207">        return getFont(family, style, size);</span>
    }

    /**
     * Takes a set of attributes and turn it into a foreground color
     * specification.  This might be used to specify things
     * like brighter, more hue, etc.  By default it simply returns
     * the value specified by the StyleConstants.Foreground attribute.
     *
     * @param attr the set of attributes
     * @return the color
     */
    public Color getForeground(AttributeSet attr) {
<span class="nc" id="L220">        return StyleConstants.getForeground(attr);</span>
    }

    /**
     * Takes a set of attributes and turn it into a background color
     * specification.  This might be used to specify things
     * like brighter, more hue, etc.  By default it simply returns
     * the value specified by the StyleConstants.Background attribute.
     *
     * @param attr the set of attributes
     * @return the color
     */
    public Color getBackground(AttributeSet attr) {
<span class="nc" id="L233">        return StyleConstants.getBackground(attr);</span>
    }

    /**
     * Gets a new font.  This returns a Font from a cache
     * if a cached font exists.  If not, a Font is added to
     * the cache.  This is basically a low-level cache for
     * 1.1 font features.
     *
     * @param family the font family (such as &quot;Monospaced&quot;)
     * @param style the style of the font (such as Font.PLAIN)
     * @param size the point size &amp;gt;= 1
     * @return the new font
     */
    public Font getFont(String family, int style, int size) {
<span class="nc" id="L248">        fontSearch.setValue(family, style, size);</span>
<span class="nc" id="L249">        Font f = fontTable.get(fontSearch);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (f == null) {</span>
            // haven't seen this one yet.
<span class="nc" id="L252">            Style defaultStyle =</span>
<span class="nc" id="L253">                getStyle(StyleContext.DEFAULT_STYLE);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (defaultStyle != null) {</span>
                final String FONT_ATTRIBUTE_KEY = &quot;FONT_ATTRIBUTE_KEY&quot;;
<span class="nc" id="L256">                Font defaultFont =</span>
<span class="nc" id="L257">                    (Font) defaultStyle.getAttribute(FONT_ATTRIBUTE_KEY);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">                if (defaultFont != null</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">                      &amp;&amp; defaultFont.getFamily().equalsIgnoreCase(family)) {</span>
<span class="nc" id="L260">                    f = defaultFont.deriveFont(style, size);</span>
                }
            }
<span class="nc bnc" id="L263" title="All 2 branches missed.">            if (f == null) {</span>
<span class="nc" id="L264">                f = new Font(family, style, size);</span>
            }
<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (! FontUtilities.fontSupportsDefaultEncoding(f)) {</span>
<span class="nc" id="L267">                f = FontUtilities.getCompositeFontUIResource(f);</span>
            }
<span class="nc" id="L269">            FontKey key = new FontKey(family, style, size);</span>
<span class="nc" id="L270">            fontTable.put(key, f);</span>
        }
<span class="nc" id="L272">        return f;</span>
    }

    /**
     * Returns font metrics for a font.
     *
     * @param f the font
     * @return the metrics
     */
    public FontMetrics getFontMetrics(Font f) {
        // The Toolkit implementations cache, so we just forward
        // to the default toolkit.
<span class="nc" id="L284">        return Toolkit.getDefaultToolkit().getFontMetrics(f);</span>
    }

    // --- AttributeContext methods --------------------

    /**
     * Adds an attribute to the given set, and returns
     * the new representative set.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param old the old attribute set
     * @param name the non-null attribute name
     * @param value the attribute value
     * @return the updated attribute set
     * @see MutableAttributeSet#addAttribute
     */
    public synchronized AttributeSet addAttribute(AttributeSet old, Object name, Object value) {
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if ((old.getAttributeCount() + 1) &lt;= getCompressionThreshold()) {</span>
            // build a search key and find/create an immutable and unique
            // set.
<span class="nc" id="L308">            search.removeAttributes(search);</span>
<span class="nc" id="L309">            search.addAttributes(old);</span>
<span class="nc" id="L310">            search.addAttribute(name, value);</span>
<span class="nc" id="L311">            reclaim(old);</span>
<span class="nc" id="L312">            return getImmutableUniqueSet();</span>
        }
<span class="nc" id="L314">        MutableAttributeSet ma = getMutableAttributeSet(old);</span>
<span class="nc" id="L315">        ma.addAttribute(name, value);</span>
<span class="nc" id="L316">        return ma;</span>
    }

    /**
     * Adds a set of attributes to the element.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param old the old attribute set
     * @param attr the attributes to add
     * @return the updated attribute set
     * @see MutableAttributeSet#addAttribute
     */
    public synchronized AttributeSet addAttributes(AttributeSet old, AttributeSet attr) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if ((old.getAttributeCount() + attr.getAttributeCount()) &lt;= getCompressionThreshold()) {</span>
            // build a search key and find/create an immutable and unique
            // set.
<span class="nc" id="L336">            search.removeAttributes(search);</span>
<span class="nc" id="L337">            search.addAttributes(old);</span>
<span class="nc" id="L338">            search.addAttributes(attr);</span>
<span class="nc" id="L339">            reclaim(old);</span>
<span class="nc" id="L340">            return getImmutableUniqueSet();</span>
        }
<span class="nc" id="L342">        MutableAttributeSet ma = getMutableAttributeSet(old);</span>
<span class="nc" id="L343">        ma.addAttributes(attr);</span>
<span class="nc" id="L344">        return ma;</span>
    }

    /**
     * Removes an attribute from the set.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param old the old set of attributes
     * @param name the non-null attribute name
     * @return the updated attribute set
     * @see MutableAttributeSet#removeAttribute
     */
    public synchronized AttributeSet removeAttribute(AttributeSet old, Object name) {
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if ((old.getAttributeCount() - 1) &lt;= getCompressionThreshold()) {</span>
            // build a search key and find/create an immutable and unique
            // set.
<span class="nc" id="L364">            search.removeAttributes(search);</span>
<span class="nc" id="L365">            search.addAttributes(old);</span>
<span class="nc" id="L366">            search.removeAttribute(name);</span>
<span class="nc" id="L367">            reclaim(old);</span>
<span class="nc" id="L368">            return getImmutableUniqueSet();</span>
        }
<span class="nc" id="L370">        MutableAttributeSet ma = getMutableAttributeSet(old);</span>
<span class="nc" id="L371">        ma.removeAttribute(name);</span>
<span class="nc" id="L372">        return ma;</span>
    }

    /**
     * Removes a set of attributes for the element.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param old the old attribute set
     * @param names the attribute names
     * @return the updated attribute set
     * @see MutableAttributeSet#removeAttributes
     */
    public synchronized AttributeSet removeAttributes(AttributeSet old, Enumeration&lt;?&gt; names) {
<span class="nc bnc" id="L389" title="All 2 branches missed.">        if (old.getAttributeCount() &lt;= getCompressionThreshold()) {</span>
            // build a search key and find/create an immutable and unique
            // set.
<span class="nc" id="L392">            search.removeAttributes(search);</span>
<span class="nc" id="L393">            search.addAttributes(old);</span>
<span class="nc" id="L394">            search.removeAttributes(names);</span>
<span class="nc" id="L395">            reclaim(old);</span>
<span class="nc" id="L396">            return getImmutableUniqueSet();</span>
        }
<span class="nc" id="L398">        MutableAttributeSet ma = getMutableAttributeSet(old);</span>
<span class="nc" id="L399">        ma.removeAttributes(names);</span>
<span class="nc" id="L400">        return ma;</span>
    }

    /**
     * Removes a set of attributes for the element.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param old the old attribute set
     * @param attrs the attributes
     * @return the updated attribute set
     * @see MutableAttributeSet#removeAttributes
     */
    public synchronized AttributeSet removeAttributes(AttributeSet old, AttributeSet attrs) {
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (old.getAttributeCount() &lt;= getCompressionThreshold()) {</span>
            // build a search key and find/create an immutable and unique
            // set.
<span class="nc" id="L420">            search.removeAttributes(search);</span>
<span class="nc" id="L421">            search.addAttributes(old);</span>
<span class="nc" id="L422">            search.removeAttributes(attrs);</span>
<span class="nc" id="L423">            reclaim(old);</span>
<span class="nc" id="L424">            return getImmutableUniqueSet();</span>
        }
<span class="nc" id="L426">        MutableAttributeSet ma = getMutableAttributeSet(old);</span>
<span class="nc" id="L427">        ma.removeAttributes(attrs);</span>
<span class="nc" id="L428">        return ma;</span>
    }

    /**
     * Fetches an empty AttributeSet.
     *
     * @return the set
     */
    public AttributeSet getEmptySet() {
<span class="nc" id="L437">        return SimpleAttributeSet.EMPTY;</span>
    }

    /**
     * Returns a set no longer needed by the MutableAttributeSet implementation.
     * This is useful for operation under 1.1 where there are no weak
     * references.  This would typically be called by the finalize method
     * of the MutableAttributeSet implementation.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param a the set to reclaim
     */
    public void reclaim(AttributeSet a) {
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L455">            attributesPool.size(); // force WeakHashMap to expunge stale entries</span>
        }
        // if current thread is not event dispatching thread
        // do not bother with expunging stale entries.
<span class="nc" id="L459">    }</span>

    // --- local methods -----------------------------------------------

    /**
     * Returns the maximum number of key/value pairs to try and
     * compress into unique/immutable sets.  Any sets above this
     * limit will use hashtables and be a MutableAttributeSet.
     *
     * @return the threshold
     */
    protected int getCompressionThreshold() {
<span class="nc" id="L471">        return THRESHOLD;</span>
    }

    /**
     * Create a compact set of attributes that might be shared.
     * This is a hook for subclasses that want to alter the
     * behavior of SmallAttributeSet.  This can be reimplemented
     * to return an AttributeSet that provides some sort of
     * attribute conversion.
     *
     * @param a The set of attributes to be represented in the
     *  the compact form.
     */
    protected SmallAttributeSet createSmallAttributeSet(AttributeSet a) {
<span class="nc" id="L485">        return new SmallAttributeSet(a);</span>
    }

    /**
     * Create a large set of attributes that should trade off
     * space for time.  This set will not be shared.  This is
     * a hook for subclasses that want to alter the behavior
     * of the larger attribute storage format (which is
     * SimpleAttributeSet by default).   This can be reimplemented
     * to return a MutableAttributeSet that provides some sort of
     * attribute conversion.
     *
     * @param a The set of attributes to be represented in the
     *  the larger form.
     */
    protected MutableAttributeSet createLargeAttributeSet(AttributeSet a) {
<span class="nc" id="L501">        return new SimpleAttributeSet(a);</span>
    }

    /**
     * Clean the unused immutable sets out of the hashtable.
     */
    synchronized void removeUnusedSets() {
<span class="nc" id="L508">        attributesPool.size(); // force WeakHashMap to expunge stale entries</span>
<span class="nc" id="L509">    }</span>

    /**
     * Search for an existing attribute set using the current search
     * parameters.  If a matching set is found, return it.  If a match
     * is not found, we create a new set and add it to the pool.
     */
    AttributeSet getImmutableUniqueSet() {
        // PENDING(prinz) should consider finding a alternative to
        // generating extra garbage on search key.
<span class="nc" id="L519">        SmallAttributeSet key = createSmallAttributeSet(search);</span>
<span class="nc" id="L520">        WeakReference&lt;SmallAttributeSet&gt; reference = attributesPool.get(key);</span>
        SmallAttributeSet a;
<span class="nc bnc" id="L522" title="All 4 branches missed.">        if (reference == null || (a = reference.get()) == null) {</span>
<span class="nc" id="L523">            a = key;</span>
<span class="nc" id="L524">            attributesPool.put(a, new WeakReference&lt;SmallAttributeSet&gt;(a));</span>
        }
<span class="nc" id="L526">        return a;</span>
    }

    /**
     * Creates a mutable attribute set to hand out because the current
     * needs are too big to try and use a shared version.
     */
    MutableAttributeSet getMutableAttributeSet(AttributeSet a) {
<span class="nc bnc" id="L534" title="All 4 branches missed.">        if (a instanceof MutableAttributeSet &amp;&amp;</span>
            a != SimpleAttributeSet.EMPTY) {
<span class="nc" id="L536">            return (MutableAttributeSet) a;</span>
        }
<span class="nc" id="L538">        return createLargeAttributeSet(a);</span>
    }

    /**
     * Converts a StyleContext to a String.
     *
     * @return the string
     */
    public String toString() {
<span class="nc" id="L547">        removeUnusedSets();</span>
<span class="nc" id="L548">        String s = &quot;&quot;;</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">        for (SmallAttributeSet set : attributesPool.keySet()) {</span>
<span class="nc" id="L550">            s = s + set + &quot;\n&quot;;</span>
<span class="nc" id="L551">        }</span>
<span class="nc" id="L552">        return s;</span>
    }

    // --- serialization ---------------------------------------------

    /**
     * Context-specific handling of writing out attributes
     */
    public void writeAttributes(ObjectOutputStream out,
                                  AttributeSet a) throws IOException {
<span class="nc" id="L562">        writeAttributeSet(out, a);</span>
<span class="nc" id="L563">    }</span>

    /**
     * Context-specific handling of reading in attributes
     */
    public void readAttributes(ObjectInputStream in,
                               MutableAttributeSet a) throws ClassNotFoundException, IOException {
<span class="nc" id="L570">        readAttributeSet(in, a);</span>
<span class="nc" id="L571">    }</span>

    /**
     * Writes a set of attributes to the given object stream
     * for the purpose of serialization.  This will take
     * special care to deal with static attribute keys that
     * have been registered wit the
     * &lt;code&gt;registerStaticAttributeKey&lt;/code&gt; method.
     * Any attribute key not registered as a static key
     * will be serialized directly.  All values are expected
     * to be serializable.
     *
     * @param out the output stream
     * @param a the attribute set
     * @exception IOException on any I/O error
     */
    public static void writeAttributeSet(ObjectOutputStream out,
                                         AttributeSet a) throws IOException {
<span class="nc" id="L589">        int n = a.getAttributeCount();</span>
<span class="nc" id="L590">        out.writeInt(n);</span>
<span class="nc" id="L591">        Enumeration keys = a.getAttributeNames();</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">        while (keys.hasMoreElements()) {</span>
<span class="nc" id="L593">            Object key = keys.nextElement();</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (key instanceof Serializable) {</span>
<span class="nc" id="L595">                out.writeObject(key);</span>
            } else {
<span class="nc" id="L597">                Object ioFmt = freezeKeyMap.get(key);</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">                if (ioFmt == null) {</span>
<span class="nc" id="L599">                    throw new NotSerializableException(key.getClass().</span>
<span class="nc" id="L600">                                 getName() + &quot; is not serializable as a key in an AttributeSet&quot;);</span>
                }
<span class="nc" id="L602">                out.writeObject(ioFmt);</span>
            }
<span class="nc" id="L604">            Object value = a.getAttribute(key);</span>
<span class="nc" id="L605">            Object ioFmt = freezeKeyMap.get(value);</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">            if (value instanceof Serializable) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">                out.writeObject((ioFmt != null) ? ioFmt : value);</span>
            } else {
<span class="nc bnc" id="L609" title="All 2 branches missed.">                if (ioFmt == null) {</span>
<span class="nc" id="L610">                    throw new NotSerializableException(value.getClass().</span>
<span class="nc" id="L611">                                 getName() + &quot; is not serializable as a value in an AttributeSet&quot;);</span>
                }
<span class="nc" id="L613">                out.writeObject(ioFmt);</span>
            }
<span class="nc" id="L615">        }</span>
<span class="nc" id="L616">    }</span>

    /**
     * Reads a set of attributes from the given object input
     * stream that have been previously written out with
     * &lt;code&gt;writeAttributeSet&lt;/code&gt;.  This will try to restore
     * keys that were static objects to the static objects in
     * the current virtual machine considering only those keys
     * that have been registered with the
     * &lt;code&gt;registerStaticAttributeKey&lt;/code&gt; method.
     * The attributes retrieved from the stream will be placed
     * into the given mutable set.
     *
     * @param in the object stream to read the attribute data from.
     * @param a  the attribute set to place the attribute
     *   definitions in.
     * @exception ClassNotFoundException passed upward if encountered
     *  when reading the object stream.
     * @exception IOException passed upward if encountered when
     *  reading the object stream.
     */
    public static void readAttributeSet(ObjectInputStream in,
        MutableAttributeSet a) throws ClassNotFoundException, IOException {

<span class="nc" id="L640">        int n = in.readInt();</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L642">            Object key = in.readObject();</span>
<span class="nc" id="L643">            Object value = in.readObject();</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">            if (thawKeyMap != null) {</span>
<span class="nc" id="L645">                Object staticKey = thawKeyMap.get(key);</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">                if (staticKey != null) {</span>
<span class="nc" id="L647">                    key = staticKey;</span>
                }
<span class="nc" id="L649">                Object staticValue = thawKeyMap.get(value);</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">                if (staticValue != null) {</span>
<span class="nc" id="L651">                    value = staticValue;</span>
                }
            }
<span class="nc" id="L654">            a.addAttribute(key, value);</span>
        }
<span class="nc" id="L656">    }</span>

    /**
     * Registers an object as a static object that is being
     * used as a key in attribute sets.  This allows the key
     * to be treated specially for serialization.
     * &lt;p&gt;
     * For operation under a 1.1 virtual machine, this
     * uses the value returned by &lt;code&gt;toString&lt;/code&gt;
     * concatenated to the classname.  The value returned
     * by toString should not have the class reference
     * in it (ie it should be reimplemented from the
     * definition in Object) in order to be the same when
     * recomputed later.
     *
     * @param key the non-null object key
     */
    public static void registerStaticAttributeKey(Object key) {
<span class="nc" id="L674">        String ioFmt = key.getClass().getName() + &quot;.&quot; + key.toString();</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (freezeKeyMap == null) {</span>
<span class="nc" id="L676">            freezeKeyMap = new Hashtable&lt;Object, String&gt;();</span>
<span class="nc" id="L677">            thawKeyMap = new Hashtable&lt;String, Object&gt;();</span>
        }
<span class="nc" id="L679">        freezeKeyMap.put(key, ioFmt);</span>
<span class="nc" id="L680">        thawKeyMap.put(ioFmt, key);</span>
<span class="nc" id="L681">    }</span>

    /**
     * Returns the object previously registered with
     * &lt;code&gt;registerStaticAttributeKey&lt;/code&gt;.
     */
    public static Object getStaticAttribute(Object key) {
<span class="nc bnc" id="L688" title="All 4 branches missed.">        if (thawKeyMap == null || key == null) {</span>
<span class="nc" id="L689">            return null;</span>
        }
<span class="nc" id="L691">        return thawKeyMap.get(key);</span>
    }

    /**
     * Returns the String that &lt;code&gt;key&lt;/code&gt; will be registered with
     * @see #getStaticAttribute
     * @see #registerStaticAttributeKey
     */
    public static Object getStaticAttributeKey(Object key) {
<span class="nc" id="L700">        return key.getClass().getName() + &quot;.&quot; + key.toString();</span>
    }

    private void writeObject(java.io.ObjectOutputStream s)
        throws IOException
    {
        // clean out unused sets before saving
<span class="nc" id="L707">        removeUnusedSets();</span>

<span class="nc" id="L709">        s.defaultWriteObject();</span>
<span class="nc" id="L710">    }</span>

    private void readObject(ObjectInputStream s)
      throws ClassNotFoundException, IOException
    {
<span class="nc" id="L715">        fontSearch = new FontKey(null, 0, 0);</span>
<span class="nc" id="L716">        fontTable = new Hashtable&lt;FontKey, Font&gt;();</span>
<span class="nc" id="L717">        search = new SimpleAttributeSet();</span>
<span class="nc" id="L718">        attributesPool = Collections.</span>
<span class="nc" id="L719">                synchronizedMap(new WeakHashMap&lt;SmallAttributeSet, WeakReference&lt;SmallAttributeSet&gt;&gt;());</span>
<span class="nc" id="L720">        s.defaultReadObject();</span>
<span class="nc" id="L721">    }</span>

    // --- variables ---------------------------------------------------

    /**
     * The name given to the default logical style attached
     * to paragraphs.
     */
    public static final String DEFAULT_STYLE = &quot;default&quot;;

    private static Hashtable&lt;Object, String&gt; freezeKeyMap;
    private static Hashtable&lt;String, Object&gt; thawKeyMap;

    private Style styles;
<span class="nc" id="L735">    private transient FontKey fontSearch = new FontKey(null, 0, 0);</span>
<span class="nc" id="L736">    private transient Hashtable&lt;FontKey, Font&gt; fontTable = new Hashtable&lt;FontKey, Font&gt;();</span>

<span class="nc" id="L738">    private transient Map&lt;SmallAttributeSet, WeakReference&lt;SmallAttributeSet&gt;&gt; attributesPool = Collections.</span>
<span class="nc" id="L739">            synchronizedMap(new WeakHashMap&lt;SmallAttributeSet, WeakReference&lt;SmallAttributeSet&gt;&gt;());</span>
<span class="nc" id="L740">    private transient MutableAttributeSet search = new SimpleAttributeSet();</span>

    /**
     * Number of immutable sets that are not currently
     * being used.  This helps indicate when the sets need
     * to be cleaned out of the hashtable they are stored
     * in.
     */
    private int unusedSets;

    /**
     * The threshold for no longer sharing the set of attributes
     * in an immutable table.
     */
    static final int THRESHOLD = 9;

    /**
     * This class holds a small number of attributes in an array.
     * The storage format is key, value, key, value, etc.  The size
     * of the set is the length of the array divided by two.  By
     * default, this is the class that will be used to store attributes
     * when held in the compact sharable form.
     */
    public class SmallAttributeSet implements AttributeSet {

<span class="nc" id="L765">        public SmallAttributeSet(Object[] attributes) {</span>
<span class="nc" id="L766">            this.attributes = attributes;</span>
<span class="nc" id="L767">            updateResolveParent();</span>
<span class="nc" id="L768">        }</span>

<span class="nc" id="L770">        public SmallAttributeSet(AttributeSet attrs) {</span>
<span class="nc" id="L771">            int n = attrs.getAttributeCount();</span>
<span class="nc" id="L772">            Object[] tbl = new Object[2 * n];</span>
<span class="nc" id="L773">            Enumeration names = attrs.getAttributeNames();</span>
<span class="nc" id="L774">            int i = 0;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">            while (names.hasMoreElements()) {</span>
<span class="nc" id="L776">                tbl[i] = names.nextElement();</span>
<span class="nc" id="L777">                tbl[i+1] = attrs.getAttribute(tbl[i]);</span>
<span class="nc" id="L778">                i += 2;</span>
            }
<span class="nc" id="L780">            attributes = tbl;</span>
<span class="nc" id="L781">            updateResolveParent();</span>
<span class="nc" id="L782">        }</span>

        private void updateResolveParent() {
<span class="nc" id="L785">            resolveParent = null;</span>
<span class="nc" id="L786">            Object[] tbl = attributes;</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            for (int i = 0; i &lt; tbl.length; i += 2) {</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">                if (tbl[i] == StyleConstants.ResolveAttribute) {</span>
<span class="nc" id="L789">                    resolveParent = (AttributeSet)tbl[i + 1];</span>
<span class="nc" id="L790">                    break;</span>
                }
            }
<span class="nc" id="L793">        }</span>

        Object getLocalAttribute(Object nm) {
<span class="nc bnc" id="L796" title="All 2 branches missed.">            if (nm == StyleConstants.ResolveAttribute) {</span>
<span class="nc" id="L797">                return resolveParent;</span>
            }
<span class="nc" id="L799">            Object[] tbl = attributes;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">            for (int i = 0; i &lt; tbl.length; i += 2) {</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">                if (nm.equals(tbl[i])) {</span>
<span class="nc" id="L802">                    return tbl[i+1];</span>
                }
            }
<span class="nc" id="L805">            return null;</span>
        }

        // --- Object methods -------------------------

        /**
         * Returns a string showing the key/value pairs
         */
        public String toString() {
<span class="nc" id="L814">            String s = &quot;{&quot;;</span>
<span class="nc" id="L815">            Object[] tbl = attributes;</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">            for (int i = 0; i &lt; tbl.length; i += 2) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">                if (tbl[i+1] instanceof AttributeSet) {</span>
                    // don't recurse
<span class="nc" id="L819">                    s = s + tbl[i] + &quot;=&quot; + &quot;AttributeSet&quot; + &quot;,&quot;;</span>
                } else {
<span class="nc" id="L821">                    s = s + tbl[i] + &quot;=&quot; + tbl[i+1] + &quot;,&quot;;</span>
                }
            }
<span class="nc" id="L824">            s = s + &quot;}&quot;;</span>
<span class="nc" id="L825">            return s;</span>
        }

        /**
         * Returns a hashcode for this set of attributes.
         * @return     a hashcode value for this set of attributes.
         */
        public int hashCode() {
<span class="nc" id="L833">            int code = 0;</span>
<span class="nc" id="L834">            Object[] tbl = attributes;</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">            for (int i = 1; i &lt; tbl.length; i += 2) {</span>
<span class="nc" id="L836">                code ^= tbl[i].hashCode();</span>
            }
<span class="nc" id="L838">            return code;</span>
        }

        /**
         * Compares this object to the specified object.
         * The result is &lt;code&gt;true&lt;/code&gt; if the object is an equivalent
         * set of attributes.
         * @param     obj   the object to compare with.
         * @return    &lt;code&gt;true&lt;/code&gt; if the objects are equal;
         *            &lt;code&gt;false&lt;/code&gt; otherwise.
         */
        public boolean equals(Object obj) {
<span class="nc bnc" id="L850" title="All 2 branches missed.">            if (obj instanceof AttributeSet) {</span>
<span class="nc" id="L851">                AttributeSet attrs = (AttributeSet) obj;</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">                return ((getAttributeCount() == attrs.getAttributeCount()) &amp;&amp;</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">                        containsAttributes(attrs));</span>
            }
<span class="nc" id="L855">            return false;</span>
        }

        /**
         * Clones a set of attributes.  Since the set is immutable, a
         * clone is basically the same set.
         *
         * @return the set of attributes
         */
        public Object clone() {
<span class="nc" id="L865">            return this;</span>
        }

        //  --- AttributeSet methods ----------------------------

        /**
         * Gets the number of attributes that are defined.
         *
         * @return the number of attributes
         * @see AttributeSet#getAttributeCount
         */
        public int getAttributeCount() {
<span class="nc" id="L877">            return attributes.length / 2;</span>
        }

        /**
         * Checks whether a given attribute is defined.
         *
         * @param key the attribute key
         * @return true if the attribute is defined
         * @see AttributeSet#isDefined
         */
        public boolean isDefined(Object key) {
<span class="nc" id="L888">            Object[] a = attributes;</span>
<span class="nc" id="L889">            int n = a.length;</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i += 2) {</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">                if (key.equals(a[i])) {</span>
<span class="nc" id="L892">                    return true;</span>
                }
            }
<span class="nc" id="L895">            return false;</span>
        }

        /**
         * Checks whether two attribute sets are equal.
         *
         * @param attr the attribute set to check against
         * @return true if the same
         * @see AttributeSet#isEqual
         */
        public boolean isEqual(AttributeSet attr) {
<span class="nc bnc" id="L906" title="All 2 branches missed.">            if (attr instanceof SmallAttributeSet) {</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">                return attr == this;</span>
            }
<span class="nc bnc" id="L909" title="All 2 branches missed.">            return ((getAttributeCount() == attr.getAttributeCount()) &amp;&amp;</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">                    containsAttributes(attr));</span>
        }

        /**
         * Copies a set of attributes.
         *
         * @return the copy
         * @see AttributeSet#copyAttributes
         */
        public AttributeSet copyAttributes() {
<span class="nc" id="L920">            return this;</span>
        }

        /**
         * Gets the value of an attribute.
         *
         * @param key the attribute name
         * @return the attribute value
         * @see AttributeSet#getAttribute
         */
        public Object getAttribute(Object key) {
<span class="nc" id="L931">            Object value = getLocalAttribute(key);</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L933">                AttributeSet parent = getResolveParent();</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">                if (parent != null)</span>
<span class="nc" id="L935">                    value = parent.getAttribute(key);</span>
            }
<span class="nc" id="L937">            return value;</span>
        }

        /**
         * Gets the names of all attributes.
         *
         * @return the attribute names
         * @see AttributeSet#getAttributeNames
         */
        public Enumeration&lt;?&gt; getAttributeNames() {
<span class="nc" id="L947">            return new KeyEnumeration(attributes);</span>
        }

        /**
         * Checks whether a given attribute name/value is defined.
         *
         * @param name the attribute name
         * @param value the attribute value
         * @return true if the name/value is defined
         * @see AttributeSet#containsAttribute
         */
        public boolean containsAttribute(Object name, Object value) {
<span class="nc" id="L959">            return value.equals(getAttribute(name));</span>
        }

        /**
         * Checks whether the attribute set contains all of
         * the given attributes.
         *
         * @param attrs the attributes to check
         * @return true if the element contains all the attributes
         * @see AttributeSet#containsAttributes
         */
        public boolean containsAttributes(AttributeSet attrs) {
<span class="nc" id="L971">            boolean result = true;</span>

<span class="nc" id="L973">            Enumeration names = attrs.getAttributeNames();</span>
<span class="nc bnc" id="L974" title="All 4 branches missed.">            while (result &amp;&amp; names.hasMoreElements()) {</span>
<span class="nc" id="L975">                Object name = names.nextElement();</span>
<span class="nc" id="L976">                result = attrs.getAttribute(name).equals(getAttribute(name));</span>
<span class="nc" id="L977">            }</span>

<span class="nc" id="L979">            return result;</span>
        }

        /**
         * If not overriden, the resolving parent defaults to
         * the parent element.
         *
         * @return the attributes from the parent
         * @see AttributeSet#getResolveParent
         */
        public AttributeSet getResolveParent() {
<span class="nc" id="L990">            return resolveParent;</span>
        }

        // --- variables -----------------------------------------

        Object[] attributes;
        // This is also stored in attributes
        AttributeSet resolveParent;
    }

    /**
     * An enumeration of the keys in a SmallAttributeSet.
     */
    class KeyEnumeration implements Enumeration&lt;Object&gt; {

<span class="nc" id="L1005">        KeyEnumeration(Object[] attr) {</span>
<span class="nc" id="L1006">            this.attr = attr;</span>
<span class="nc" id="L1007">            i = 0;</span>
<span class="nc" id="L1008">        }</span>

        /**
         * Tests if this enumeration contains more elements.
         *
         * @return  &lt;code&gt;true&lt;/code&gt; if this enumeration contains more elements;
         *          &lt;code&gt;false&lt;/code&gt; otherwise.
         * @since   JDK1.0
         */
        public boolean hasMoreElements() {
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            return i &lt; attr.length;</span>
        }

        /**
         * Returns the next element of this enumeration.
         *
         * @return     the next element of this enumeration.
         * @exception  NoSuchElementException  if no more elements exist.
         * @since      JDK1.0
         */
        public Object nextElement() {
<span class="nc bnc" id="L1029" title="All 2 branches missed.">            if (i &lt; attr.length) {</span>
<span class="nc" id="L1030">                Object o = attr[i];</span>
<span class="nc" id="L1031">                i += 2;</span>
<span class="nc" id="L1032">                return o;</span>
            }
<span class="nc" id="L1034">            throw new NoSuchElementException();</span>
        }

        Object[] attr;
        int i;
    }

    /**
     * Sorts the key strings so that they can be very quickly compared
     * in the attribute set searches.
     */
<span class="nc" id="L1045">    class KeyBuilder {</span>

        public void initialize(AttributeSet a) {
<span class="nc bnc" id="L1048" title="All 2 branches missed.">            if (a instanceof SmallAttributeSet) {</span>
<span class="nc" id="L1049">                initialize(((SmallAttributeSet)a).attributes);</span>
            } else {
<span class="nc" id="L1051">                keys.removeAllElements();</span>
<span class="nc" id="L1052">                data.removeAllElements();</span>
<span class="nc" id="L1053">                Enumeration names = a.getAttributeNames();</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                while (names.hasMoreElements()) {</span>
<span class="nc" id="L1055">                    Object name = names.nextElement();</span>
<span class="nc" id="L1056">                    addAttribute(name, a.getAttribute(name));</span>
<span class="nc" id="L1057">                }</span>
            }
<span class="nc" id="L1059">        }</span>

        /**
         * Initialize with a set of already sorted
         * keys (data from an existing SmallAttributeSet).
         */
        private void initialize(Object[] sorted) {
<span class="nc" id="L1066">            keys.removeAllElements();</span>
<span class="nc" id="L1067">            data.removeAllElements();</span>
<span class="nc" id="L1068">            int n = sorted.length;</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i += 2) {</span>
<span class="nc" id="L1070">                keys.addElement(sorted[i]);</span>
<span class="nc" id="L1071">                data.addElement(sorted[i+1]);</span>
            }
<span class="nc" id="L1073">        }</span>

        /**
         * Creates a table of sorted key/value entries
         * suitable for creation of an instance of
         * SmallAttributeSet.
         */
        public Object[] createTable() {
<span class="nc" id="L1081">            int n = keys.size();</span>
<span class="nc" id="L1082">            Object[] tbl = new Object[2 * n];</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i ++) {</span>
<span class="nc" id="L1084">                int offs = 2 * i;</span>
<span class="nc" id="L1085">                tbl[offs] = keys.elementAt(i);</span>
<span class="nc" id="L1086">                tbl[offs + 1] = data.elementAt(i);</span>
            }
<span class="nc" id="L1088">            return tbl;</span>
        }

        /**
         * The number of key/value pairs contained
         * in the current key being forged.
         */
        int getCount() {
<span class="nc" id="L1096">            return keys.size();</span>
        }

        /**
         * Adds a key/value to the set.
         */
        public void addAttribute(Object key, Object value) {
<span class="nc" id="L1103">            keys.addElement(key);</span>
<span class="nc" id="L1104">            data.addElement(value);</span>
<span class="nc" id="L1105">        }</span>

        /**
         * Adds a set of key/value pairs to the set.
         */
        public void addAttributes(AttributeSet attr) {
<span class="nc bnc" id="L1111" title="All 2 branches missed.">            if (attr instanceof SmallAttributeSet) {</span>
                // avoid searching the keys, they are already interned.
<span class="nc" id="L1113">                Object[] tbl = ((SmallAttributeSet)attr).attributes;</span>
<span class="nc" id="L1114">                int n = tbl.length;</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">                for (int i = 0; i &lt; n; i += 2) {</span>
<span class="nc" id="L1116">                    addAttribute(tbl[i], tbl[i+1]);</span>
                }
<span class="nc" id="L1118">            } else {</span>
<span class="nc" id="L1119">                Enumeration names = attr.getAttributeNames();</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                while (names.hasMoreElements()) {</span>
<span class="nc" id="L1121">                    Object name = names.nextElement();</span>
<span class="nc" id="L1122">                    addAttribute(name, attr.getAttribute(name));</span>
<span class="nc" id="L1123">                }</span>
            }
<span class="nc" id="L1125">        }</span>

        /**
         * Removes the given name from the set.
         */
        public void removeAttribute(Object key) {
<span class="nc" id="L1131">            int n = keys.size();</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                if (keys.elementAt(i).equals(key)) {</span>
<span class="nc" id="L1134">                    keys.removeElementAt(i);</span>
<span class="nc" id="L1135">                    data.removeElementAt(i);</span>
<span class="nc" id="L1136">                    return;</span>
                }
            }
<span class="nc" id="L1139">        }</span>

        /**
         * Removes the set of keys from the set.
         */
        public void removeAttributes(Enumeration names) {
<span class="nc bnc" id="L1145" title="All 2 branches missed.">            while (names.hasMoreElements()) {</span>
<span class="nc" id="L1146">                Object name = names.nextElement();</span>
<span class="nc" id="L1147">                removeAttribute(name);</span>
<span class="nc" id="L1148">            }</span>
<span class="nc" id="L1149">        }</span>

        /**
         * Removes the set of matching attributes from the set.
         */
        public void removeAttributes(AttributeSet attr) {
<span class="nc" id="L1155">            Enumeration names = attr.getAttributeNames();</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">            while (names.hasMoreElements()) {</span>
<span class="nc" id="L1157">                Object name = names.nextElement();</span>
<span class="nc" id="L1158">                Object value = attr.getAttribute(name);</span>
<span class="nc" id="L1159">                removeSearchAttribute(name, value);</span>
<span class="nc" id="L1160">            }</span>
<span class="nc" id="L1161">        }</span>

        private void removeSearchAttribute(Object ikey, Object value) {
<span class="nc" id="L1164">            int n = keys.size();</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                if (keys.elementAt(i).equals(ikey)) {</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">                    if (data.elementAt(i).equals(value)) {</span>
<span class="nc" id="L1168">                        keys.removeElementAt(i);</span>
<span class="nc" id="L1169">                        data.removeElementAt(i);</span>
                    }
<span class="nc" id="L1171">                    return;</span>
                }
            }
<span class="nc" id="L1174">        }</span>

<span class="nc" id="L1176">        private Vector&lt;Object&gt; keys = new Vector&lt;Object&gt;();</span>
<span class="nc" id="L1177">        private Vector&lt;Object&gt; data = new Vector&lt;Object&gt;();</span>
    }

    /**
     * key for a font table
     */
    static class FontKey {

        private String family;
        private int style;
        private int size;

        /**
         * Constructs a font key.
         */
<span class="nc" id="L1192">        public FontKey(String family, int style, int size) {</span>
<span class="nc" id="L1193">            setValue(family, style, size);</span>
<span class="nc" id="L1194">        }</span>

        public void setValue(String family, int style, int size) {
<span class="nc bnc" id="L1197" title="All 2 branches missed.">            this.family = (family != null) ? family.intern() : null;</span>
<span class="nc" id="L1198">            this.style = style;</span>
<span class="nc" id="L1199">            this.size = size;</span>
<span class="nc" id="L1200">        }</span>

        /**
         * Returns a hashcode for this font.
         * @return     a hashcode value for this font.
         */
        public int hashCode() {
<span class="nc bnc" id="L1207" title="All 2 branches missed.">            int fhash = (family != null) ? family.hashCode() : 0;</span>
<span class="nc" id="L1208">            return fhash ^ style ^ size;</span>
        }

        /**
         * Compares this object to the specified object.
         * The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is not
         * &lt;code&gt;null&lt;/code&gt; and is a &lt;code&gt;Font&lt;/code&gt; object with the same
         * name, style, and point size as this font.
         * @param     obj   the object to compare this font with.
         * @return    &lt;code&gt;true&lt;/code&gt; if the objects are equal;
         *            &lt;code&gt;false&lt;/code&gt; otherwise.
         */
        public boolean equals(Object obj) {
<span class="nc bnc" id="L1221" title="All 2 branches missed.">            if (obj instanceof FontKey) {</span>
<span class="nc" id="L1222">                FontKey font = (FontKey)obj;</span>
<span class="nc bnc" id="L1223" title="All 6 branches missed.">                return (size == font.size) &amp;&amp; (style == font.style) &amp;&amp; (family == font.family);</span>
            }
<span class="nc" id="L1225">            return false;</span>
        }

    }

    /**
     * A collection of attributes, typically used to represent
     * character and paragraph styles.  This is an implementation
     * of MutableAttributeSet that can be observed if desired.
     * These styles will take advantage of immutability while
     * the sets are small enough, and may be substantially more
     * efficient than something like SimpleAttributeSet.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    public class NamedStyle implements Style, Serializable {

        /**
         * Creates a new named style.
         *
         * @param name the style name, null for unnamed
         * @param parent the parent style, null if none
         * @since 1.4
         */
<span class="nc" id="L1256">        public NamedStyle(String name, Style parent) {</span>
<span class="nc" id="L1257">            attributes = getEmptySet();</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">            if (name != null) {</span>
<span class="nc" id="L1259">                setName(name);</span>
            }
<span class="nc bnc" id="L1261" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L1262">                setResolveParent(parent);</span>
            }
<span class="nc" id="L1264">        }</span>

        /**
         * Creates a new named style.
         *
         * @param parent the parent style, null if none
         * @since 1.4
         */
        public NamedStyle(Style parent) {
<span class="nc" id="L1273">            this(null, parent);</span>
<span class="nc" id="L1274">        }</span>

        /**
         * Creates a new named style, with a null name and parent.
         */
<span class="nc" id="L1279">        public NamedStyle() {</span>
<span class="nc" id="L1280">            attributes = getEmptySet();</span>
<span class="nc" id="L1281">        }</span>

        /**
         * Converts the style to a string.
         *
         * @return the string
         */
        public String toString() {
<span class="nc" id="L1289">            return &quot;NamedStyle:&quot; + getName() + &quot; &quot; + attributes;</span>
        }

        /**
         * Fetches the name of the style.   A style is not required to be named,
         * so null is returned if there is no name associated with the style.
         *
         * @return the name
         */
        public String getName() {
<span class="nc bnc" id="L1299" title="All 2 branches missed.">            if (isDefined(StyleConstants.NameAttribute)) {</span>
<span class="nc" id="L1300">                return getAttribute(StyleConstants.NameAttribute).toString();</span>
            }
<span class="nc" id="L1302">            return null;</span>
        }

        /**
         * Changes the name of the style.  Does nothing with a null name.
         *
         * @param name the new name
         */
        public void setName(String name) {
<span class="nc bnc" id="L1311" title="All 2 branches missed.">            if (name != null) {</span>
<span class="nc" id="L1312">                this.addAttribute(StyleConstants.NameAttribute, name);</span>
            }
<span class="nc" id="L1314">        }</span>

        /**
         * Adds a change listener.
         *
         * @param l the change listener
         */
        public void addChangeListener(ChangeListener l) {
<span class="nc" id="L1322">            listenerList.add(ChangeListener.class, l);</span>
<span class="nc" id="L1323">        }</span>

        /**
         * Removes a change listener.
         *
         * @param l the change listener
         */
        public void removeChangeListener(ChangeListener l) {
<span class="nc" id="L1331">            listenerList.remove(ChangeListener.class, l);</span>
<span class="nc" id="L1332">        }</span>


        /**
         * Returns an array of all the &lt;code&gt;ChangeListener&lt;/code&gt;s added
         * to this NamedStyle with addChangeListener().
         *
         * @return all of the &lt;code&gt;ChangeListener&lt;/code&gt;s added or an empty
         *         array if no listeners have been added
         * @since 1.4
         */
        public ChangeListener[] getChangeListeners() {
<span class="nc" id="L1344">            return listenerList.getListeners(ChangeListener.class);</span>
        }


        /**
         * Notifies all listeners that have registered interest for
         * notification on this event type.  The event instance
         * is lazily created using the parameters passed into
         * the fire method.
         *
         * @see EventListenerList
         */
        protected void fireStateChanged() {
            // Guaranteed to return a non-null array
<span class="nc" id="L1358">            Object[] listeners = listenerList.getListenerList();</span>
            // Process the listeners last to first, notifying
            // those that are interested in this event
<span class="nc bnc" id="L1361" title="All 2 branches missed.">            for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">                if (listeners[i]==ChangeListener.class) {</span>
                    // Lazily create the event:
<span class="nc bnc" id="L1364" title="All 2 branches missed.">                    if (changeEvent == null)</span>
<span class="nc" id="L1365">                        changeEvent = new ChangeEvent(this);</span>
<span class="nc" id="L1366">                    ((ChangeListener)listeners[i+1]).stateChanged(changeEvent);</span>
                }
            }
<span class="nc" id="L1369">        }</span>

        /**
         * Return an array of all the listeners of the given type that
         * were added to this model.
         *
         * @return all of the objects receiving &lt;em&gt;listenerType&lt;/em&gt; notifications
         *          from this model
         *
         * @since 1.3
         */
        public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<span class="nc" id="L1381">            return listenerList.getListeners(listenerType);</span>
        }

        // --- AttributeSet ----------------------------
        // delegated to the immutable field &quot;attributes&quot;

        /**
         * Gets the number of attributes that are defined.
         *
         * @return the number of attributes &amp;gt;= 0
         * @see AttributeSet#getAttributeCount
         */
        public int getAttributeCount() {
<span class="nc" id="L1394">            return attributes.getAttributeCount();</span>
        }

        /**
         * Checks whether a given attribute is defined.
         *
         * @param attrName the non-null attribute name
         * @return true if the attribute is defined
         * @see AttributeSet#isDefined
         */
        public boolean isDefined(Object attrName) {
<span class="nc" id="L1405">            return attributes.isDefined(attrName);</span>
        }

        /**
         * Checks whether two attribute sets are equal.
         *
         * @param attr the attribute set to check against
         * @return true if the same
         * @see AttributeSet#isEqual
         */
        public boolean isEqual(AttributeSet attr) {
<span class="nc" id="L1416">            return attributes.isEqual(attr);</span>
        }

        /**
         * Copies a set of attributes.
         *
         * @return the copy
         * @see AttributeSet#copyAttributes
         */
        public AttributeSet copyAttributes() {
<span class="nc" id="L1426">            NamedStyle a = new NamedStyle();</span>
<span class="nc" id="L1427">            a.attributes = attributes.copyAttributes();</span>
<span class="nc" id="L1428">            return a;</span>
        }

        /**
         * Gets the value of an attribute.
         *
         * @param attrName the non-null attribute name
         * @return the attribute value
         * @see AttributeSet#getAttribute
         */
        public Object getAttribute(Object attrName) {
<span class="nc" id="L1439">            return attributes.getAttribute(attrName);</span>
        }

        /**
         * Gets the names of all attributes.
         *
         * @return the attribute names as an enumeration
         * @see AttributeSet#getAttributeNames
         */
        public Enumeration&lt;?&gt; getAttributeNames() {
<span class="nc" id="L1449">            return attributes.getAttributeNames();</span>
        }

        /**
         * Checks whether a given attribute name/value is defined.
         *
         * @param name the non-null attribute name
         * @param value the attribute value
         * @return true if the name/value is defined
         * @see AttributeSet#containsAttribute
         */
        public boolean containsAttribute(Object name, Object value) {
<span class="nc" id="L1461">            return attributes.containsAttribute(name, value);</span>
        }


        /**
         * Checks whether the element contains all the attributes.
         *
         * @param attrs the attributes to check
         * @return true if the element contains all the attributes
         * @see AttributeSet#containsAttributes
         */
        public boolean containsAttributes(AttributeSet attrs) {
<span class="nc" id="L1473">            return attributes.containsAttributes(attrs);</span>
        }

        /**
         * Gets attributes from the parent.
         * If not overriden, the resolving parent defaults to
         * the parent element.
         *
         * @return the attributes from the parent
         * @see AttributeSet#getResolveParent
         */
        public AttributeSet getResolveParent() {
<span class="nc" id="L1485">            return attributes.getResolveParent();</span>
        }

        // --- MutableAttributeSet ----------------------------------
        // should fetch a new immutable record for the field
        // &quot;attributes&quot;.

        /**
         * Adds an attribute.
         *
         * @param name the non-null attribute name
         * @param value the attribute value
         * @see MutableAttributeSet#addAttribute
         */
        public void addAttribute(Object name, Object value) {
<span class="nc" id="L1500">            StyleContext context = StyleContext.this;</span>
<span class="nc" id="L1501">            attributes = context.addAttribute(attributes, name, value);</span>
<span class="nc" id="L1502">            fireStateChanged();</span>
<span class="nc" id="L1503">        }</span>

        /**
         * Adds a set of attributes to the element.
         *
         * @param attr the attributes to add
         * @see MutableAttributeSet#addAttribute
         */
        public void addAttributes(AttributeSet attr) {
<span class="nc" id="L1512">            StyleContext context = StyleContext.this;</span>
<span class="nc" id="L1513">            attributes = context.addAttributes(attributes, attr);</span>
<span class="nc" id="L1514">            fireStateChanged();</span>
<span class="nc" id="L1515">        }</span>

        /**
         * Removes an attribute from the set.
         *
         * @param name the non-null attribute name
         * @see MutableAttributeSet#removeAttribute
         */
        public void removeAttribute(Object name) {
<span class="nc" id="L1524">            StyleContext context = StyleContext.this;</span>
<span class="nc" id="L1525">            attributes = context.removeAttribute(attributes, name);</span>
<span class="nc" id="L1526">            fireStateChanged();</span>
<span class="nc" id="L1527">        }</span>

        /**
         * Removes a set of attributes for the element.
         *
         * @param names the attribute names
         * @see MutableAttributeSet#removeAttributes
         */
        public void removeAttributes(Enumeration&lt;?&gt; names) {
<span class="nc" id="L1536">            StyleContext context = StyleContext.this;</span>
<span class="nc" id="L1537">            attributes = context.removeAttributes(attributes, names);</span>
<span class="nc" id="L1538">            fireStateChanged();</span>
<span class="nc" id="L1539">        }</span>

        /**
         * Removes a set of attributes for the element.
         *
         * @param attrs the attributes
         * @see MutableAttributeSet#removeAttributes
         */
        public void removeAttributes(AttributeSet attrs) {
<span class="nc" id="L1548">            StyleContext context = StyleContext.this;</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">            if (attrs == this) {</span>
<span class="nc" id="L1550">                attributes = context.getEmptySet();</span>
            } else {
<span class="nc" id="L1552">                attributes = context.removeAttributes(attributes, attrs);</span>
            }
<span class="nc" id="L1554">            fireStateChanged();</span>
<span class="nc" id="L1555">        }</span>

        /**
         * Sets the resolving parent.
         *
         * @param parent the parent, null if none
         * @see MutableAttributeSet#setResolveParent
         */
        public void setResolveParent(AttributeSet parent) {
<span class="nc bnc" id="L1564" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L1565">                addAttribute(StyleConstants.ResolveAttribute, parent);</span>
            } else {
<span class="nc" id="L1567">                removeAttribute(StyleConstants.ResolveAttribute);</span>
            }
<span class="nc" id="L1569">        }</span>

        // --- serialization ---------------------------------------------

        private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L1574">            s.defaultWriteObject();</span>
<span class="nc" id="L1575">            writeAttributeSet(s, attributes);</span>
<span class="nc" id="L1576">        }</span>

        private void readObject(ObjectInputStream s)
            throws ClassNotFoundException, IOException
        {
<span class="nc" id="L1581">            s.defaultReadObject();</span>
<span class="nc" id="L1582">            attributes = SimpleAttributeSet.EMPTY;</span>
<span class="nc" id="L1583">            readAttributeSet(s, this);</span>
<span class="nc" id="L1584">        }</span>

        // --- member variables -----------------------------------------------

        /**
         * The change listeners for the model.
         */
<span class="nc" id="L1591">        protected EventListenerList listenerList = new EventListenerList();</span>

        /**
         * Only one ChangeEvent is needed per model instance since the
         * event's only (read-only) state is the source property.  The source
         * of events generated here is always &quot;this&quot;.
         */
<span class="nc" id="L1598">        protected transient ChangeEvent changeEvent = null;</span>

        /**
         * Inner AttributeSet implementation, which may be an
         * immutable unique set being shared.
         */
        private transient AttributeSet attributes;

    }

    static {
        // initialize the static key registry with the StyleConstants keys
        try {
<span class="nc" id="L1611">            int n = StyleConstants.keys.length;</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L1613">                StyleContext.registerStaticAttributeKey(StyleConstants.keys[i]);</span>
            }
<span class="nc" id="L1615">        } catch (Throwable e) {</span>
<span class="nc" id="L1616">            e.printStackTrace();</span>
<span class="nc" id="L1617">        }</span>
<span class="nc" id="L1618">    }</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>