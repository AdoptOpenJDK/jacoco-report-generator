<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ElementIterator.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">ElementIterator.java</span></div><h1>ElementIterator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.text;

import java.util.Stack;
import java.util.Enumeration;

/**
 * &lt;p&gt;
 * ElementIterator, as the name suggests, iterates over the Element
 * tree.  The constructor can be invoked with either Document or an Element
 * as an argument.  If the constructor is invoked with a Document as an
 * argument then the root of the iteration is the return value of
 * document.getDefaultRootElement().
 *
 * The iteration happens in a depth-first manner.  In terms of how
 * boundary conditions are handled:
 * a) if next() is called before first() or current(), the
 *    root will be returned.
 * b) next() returns null to indicate the end of the list.
 * c) previous() returns null when the current element is the root
 *    or next() has returned null.
 *
 * The ElementIterator does no locking of the Element tree. This means
 * that it does not track any changes.  It is the responsibility of the
 * user of this class, to ensure that no changes happen during element
 * iteration.
 *
 * Simple usage example:
 *
 *    public void iterate() {
 *        ElementIterator it = new ElementIterator(root);
 *        Element elem;
 *        while (true) {
 *           if ((elem = next()) != null) {
 *               // process element
 *               System.out.println(&quot;elem: &quot; + elem.getName());
 *           } else {
 *               break;
 *           }
 *        }
 *    }
 *
 * @author Sunita Mani
 *
 */

public class ElementIterator implements Cloneable {


    private Element root;
<span class="nc" id="L75">    private Stack&lt;StackItem&gt; elementStack = null;</span>

    /**
     * The StackItem class stores the element
     * as well as a child index.  If the
     * index is -1, then the element represented
     * on the stack is the element itself.
     * Otherwise, the index functions as as index
     * into the vector of children of the element.
     * In this case, the item on the stack
     * represents the &quot;index&quot;th child of the element
     *
     */
    private class StackItem implements Cloneable {
        Element item;
        int childIndex;

<span class="nc" id="L92">        private StackItem(Element elem) {</span>
            /**
             * -1 index implies a self reference,
             * as opposed to an index into its
             * list of children.
             */
<span class="nc" id="L98">            this.item = elem;</span>
<span class="nc" id="L99">            this.childIndex = -1;</span>
<span class="nc" id="L100">        }</span>

        private void incrementIndex() {
<span class="nc" id="L103">            childIndex++;</span>
<span class="nc" id="L104">        }</span>

        private Element getElement() {
<span class="nc" id="L107">            return item;</span>
        }

        private int getIndex() {
<span class="nc" id="L111">            return childIndex;</span>
        }

        protected Object clone() throws java.lang.CloneNotSupportedException {
<span class="nc" id="L115">            return super.clone();</span>
        }
    }

    /**
     * Creates a new ElementIterator. The
     * root element is taken to get the
     * default root element of the document.
     *
     * @param document a Document.
     */
<span class="nc" id="L126">    public ElementIterator(Document document) {</span>
<span class="nc" id="L127">        root = document.getDefaultRootElement();</span>
<span class="nc" id="L128">    }</span>


    /**
     * Creates a new ElementIterator.
     *
     * @param root the root Element.
     */
<span class="nc" id="L136">    public ElementIterator(Element root) {</span>
<span class="nc" id="L137">        this.root = root;</span>
<span class="nc" id="L138">    }</span>


    /**
     * Clones the ElementIterator.
     *
     * @return a cloned ElementIterator Object.
     */
    public synchronized Object clone() {

        try {
<span class="nc" id="L149">            ElementIterator it = new ElementIterator(root);</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">            if (elementStack != null) {</span>
<span class="nc" id="L151">                it.elementStack = new Stack&lt;StackItem&gt;();</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">                for (int i = 0; i &lt; elementStack.size(); i++) {</span>
<span class="nc" id="L153">                    StackItem item = elementStack.elementAt(i);</span>
<span class="nc" id="L154">                    StackItem clonee = (StackItem)item.clone();</span>
<span class="nc" id="L155">                    it.elementStack.push(clonee);</span>
                }
            }
<span class="nc" id="L158">            return it;</span>
<span class="nc" id="L159">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L160">            throw new InternalError(e);</span>
        }
    }


    /**
     * Fetches the first element.
     *
     * @return an Element.
     */
    public Element first() {
        // just in case...
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (root == null) {</span>
<span class="nc" id="L173">            return null;</span>
        }

<span class="nc" id="L176">        elementStack = new Stack&lt;StackItem&gt;();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (root.getElementCount() != 0) {</span>
<span class="nc" id="L178">            elementStack.push(new StackItem(root));</span>
        }
<span class="nc" id="L180">        return root;</span>
    }

    /**
     * Fetches the current depth of element tree.
     *
     * @return the depth.
     */
    public int depth() {
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (elementStack == null) {</span>
<span class="nc" id="L190">            return 0;</span>
        }
<span class="nc" id="L192">        return elementStack.size();</span>
    }


    /**
     * Fetches the current Element.
     *
     * @return element on top of the stack or
     *          &lt;code&gt;null&lt;/code&gt; if the root element is &lt;code&gt;null&lt;/code&gt;
     */
    public Element current() {

<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (elementStack == null) {</span>
<span class="nc" id="L205">            return first();</span>
        }

        /*
          get a handle to the element on top of the stack.
        */
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (! elementStack.empty()) {</span>
<span class="nc" id="L212">            StackItem item = elementStack.peek();</span>
<span class="nc" id="L213">            Element elem = item.getElement();</span>
<span class="nc" id="L214">            int index = item.getIndex();</span>
            // self reference
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if (index == -1) {</span>
<span class="nc" id="L217">                return elem;</span>
            }
            // return the child at location &quot;index&quot;.
<span class="nc" id="L220">            return elem.getElement(index);</span>
        }
<span class="nc" id="L222">        return null;</span>
    }


    /**
     * Fetches the next Element. The strategy
     * used to locate the next element is
     * a depth-first search.
     *
     * @return the next element or &lt;code&gt;null&lt;/code&gt;
     *          at the end of the list.
     */
    public Element next() {

        /* if current() has not been invoked
           and next is invoked, the very first
           element will be returned. */
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (elementStack == null) {</span>
<span class="nc" id="L240">            return first();</span>
        }

        // no more elements
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (elementStack.isEmpty()) {</span>
<span class="nc" id="L245">            return null;</span>
        }

        // get a handle to the element on top of the stack

<span class="nc" id="L250">        StackItem item = elementStack.peek();</span>
<span class="nc" id="L251">        Element elem = item.getElement();</span>
<span class="nc" id="L252">        int index = item.getIndex();</span>

<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (index+1 &lt; elem.getElementCount()) {</span>
<span class="nc" id="L255">            Element child = elem.getElement(index+1);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (child.isLeaf()) {</span>
                /* In this case we merely want to increment
                   the child index of the item on top of the
                   stack.*/
<span class="nc" id="L260">                item.incrementIndex();</span>
            } else {
                /* In this case we need to push the child(branch)
                   on the stack so that we can iterate over its
                   children. */
<span class="nc" id="L265">                elementStack.push(new StackItem(child));</span>
            }
<span class="nc" id="L267">            return child;</span>
        } else {
            /* No more children for the item on top of the
               stack therefore pop the stack. */
<span class="nc" id="L271">            elementStack.pop();</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (!elementStack.isEmpty()) {</span>
                /* Increment the child index for the item that
                   is now on top of the stack. */
<span class="nc" id="L275">                StackItem top = elementStack.peek();</span>
<span class="nc" id="L276">                top.incrementIndex();</span>
                /* We now want to return its next child, therefore
                   call next() recursively. */
<span class="nc" id="L279">                return next();</span>
            }
        }
<span class="nc" id="L282">        return null;</span>
    }


    /**
     * Fetches the previous Element. If however the current
     * element is the last element, or the current element
     * is null, then null is returned.
     *
     * @return previous &lt;code&gt;Element&lt;/code&gt; if available
     *
     */
    public Element previous() {

        int stackSize;
<span class="nc bnc" id="L297" title="All 4 branches missed.">        if (elementStack == null || (stackSize = elementStack.size()) == 0) {</span>
<span class="nc" id="L298">            return null;</span>
        }

        // get a handle to the element on top of the stack
        //
<span class="nc" id="L303">        StackItem item = elementStack.peek();</span>
<span class="nc" id="L304">        Element elem = item.getElement();</span>
<span class="nc" id="L305">        int index = item.getIndex();</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (index &gt; 0) {</span>
            /* return child at previous index. */
<span class="nc" id="L309">            return getDeepestLeaf(elem.getElement(--index));</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        } else if (index == 0) {</span>
            /* this implies that current is the element's
               first child, therefore previous is the
               element itself. */
<span class="nc" id="L314">            return elem;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">        } else if (index == -1) {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (stackSize == 1) {</span>
                // current is the root, nothing before it.
<span class="nc" id="L318">                return null;</span>
            }
            /* We need to return either the item
               below the top item or one of the
               former's children. */
<span class="nc" id="L323">            StackItem top = elementStack.pop();</span>
<span class="nc" id="L324">            item = elementStack.peek();</span>

            // restore the top item.
<span class="nc" id="L327">            elementStack.push(top);</span>
<span class="nc" id="L328">            elem = item.getElement();</span>
<span class="nc" id="L329">            index = item.getIndex();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            return ((index == -1) ? elem : getDeepestLeaf(elem.getElement</span>
<span class="nc" id="L331">                                                          (index)));</span>
        }
        // should never get here.
<span class="nc" id="L334">        return null;</span>
    }

    /**
     * Returns the last child of &lt;code&gt;parent&lt;/code&gt; that is a leaf. If the
     * last child is a not a leaf, this method is called with the last child.
     */
    private Element getDeepestLeaf(Element parent) {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (parent.isLeaf()) {</span>
<span class="nc" id="L343">            return parent;</span>
        }
<span class="nc" id="L345">        int childCount = parent.getElementCount();</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (childCount == 0) {</span>
<span class="nc" id="L347">            return parent;</span>
        }
<span class="nc" id="L349">        return getDeepestLeaf(parent.getElement(childCount - 1));</span>
    }

    /*
      Iterates through the element tree and prints
      out each element and its attributes.
    */
    private void dumpTree() {

        Element elem;
        while (true) {
<span class="nc bnc" id="L360" title="All 2 branches missed.">            if ((elem = next()) != null) {</span>
<span class="nc" id="L361">                System.out.println(&quot;elem: &quot; + elem.getName());</span>
<span class="nc" id="L362">                AttributeSet attr = elem.getAttributes();</span>
<span class="nc" id="L363">                String s = &quot;&quot;;</span>
<span class="nc" id="L364">                Enumeration names = attr.getAttributeNames();</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                while (names.hasMoreElements()) {</span>
<span class="nc" id="L366">                    Object key = names.nextElement();</span>
<span class="nc" id="L367">                    Object value = attr.getAttribute(key);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                    if (value instanceof AttributeSet) {</span>
                        // don't go recursive
<span class="nc" id="L370">                        s = s + key + &quot;=**AttributeSet** &quot;;</span>
                    } else {
<span class="nc" id="L372">                        s = s + key + &quot;=&quot; + value + &quot; &quot;;</span>
                    }
<span class="nc" id="L374">                }</span>
<span class="nc" id="L375">                System.out.println(&quot;attributes: &quot; + s);</span>
<span class="nc" id="L376">            } else {</span>
                break;
            }
        }
<span class="nc" id="L380">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>