<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Utilities.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">Utilities.java</span></div><h1>Utilities.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.lang.reflect.Method;

import java.awt.Component;
import java.awt.Rectangle;
import java.awt.Graphics;
import java.awt.FontMetrics;
import java.awt.Shape;
import java.awt.Toolkit;
import java.awt.Graphics2D;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.awt.font.TextAttribute;

import java.text.*;
import javax.swing.JComponent;
import javax.swing.SwingConstants;
import javax.swing.text.ParagraphView.Row;
import sun.swing.SwingUtilities2;

/**
 * A collection of methods to deal with various text
 * related activities.
 *
 * @author  Timothy Prinzing
 */
<span class="nc" id="L52">public class Utilities {</span>
    /**
     * If &lt;code&gt;view&lt;/code&gt;'s container is a &lt;code&gt;JComponent&lt;/code&gt; it
     * is returned, after casting.
     */
    static JComponent getJComponent(View view) {
<span class="nc bnc" id="L58" title="All 2 branches missed.">        if (view != null) {</span>
<span class="nc" id="L59">            Component component = view.getContainer();</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">            if (component instanceof JComponent) {</span>
<span class="nc" id="L61">                return (JComponent)component;</span>
            }
        }
<span class="nc" id="L64">        return null;</span>
    }

    /**
     * Draws the given text, expanding any tabs that are contained
     * using the given tab expansion technique.  This particular
     * implementation renders in a 1.1 style coordinate system
     * where ints are used and 72dpi is assumed.
     *
     * @param s  the source of the text
     * @param x  the X origin &amp;gt;= 0
     * @param y  the Y origin &amp;gt;= 0
     * @param g  the graphics context
     * @param e  how to expand the tabs.  If this value is null,
     *   tabs will be expanded as a space character.
     * @param startOffset starting offset of the text in the document &amp;gt;= 0
     * @return  the X location at the end of the rendered text
     */
    public static final int drawTabbedText(Segment s, int x, int y, Graphics g,
                                           TabExpander e, int startOffset) {
<span class="nc" id="L84">        return drawTabbedText(null, s, x, y, g, e, startOffset);</span>
    }

    /**
     * Draws the given text, expanding any tabs that are contained
     * using the given tab expansion technique.  This particular
     * implementation renders in a 1.1 style coordinate system
     * where ints are used and 72dpi is assumed.
     *
     * @param view View requesting rendering, may be null.
     * @param s  the source of the text
     * @param x  the X origin &amp;gt;= 0
     * @param y  the Y origin &amp;gt;= 0
     * @param g  the graphics context
     * @param e  how to expand the tabs.  If this value is null,
     *   tabs will be expanded as a space character.
     * @param startOffset starting offset of the text in the document &amp;gt;= 0
     * @return  the X location at the end of the rendered text
     */
    static final int drawTabbedText(View view,
                                Segment s, int x, int y, Graphics g,
                                TabExpander e, int startOffset) {
<span class="nc" id="L106">        return drawTabbedText(view, s, x, y, g, e, startOffset, null);</span>
    }

    // In addition to the previous method it can extend spaces for
    // justification.
    //
    // all params are the same as in the preious method except the last
    // one:
    // @param justificationData justificationData for the row.
    // if null not justification is needed
    static final int drawTabbedText(View view,
                                Segment s, int x, int y, Graphics g,
                                TabExpander e, int startOffset,
                                int [] justificationData) {
<span class="nc" id="L120">        JComponent component = getJComponent(view);</span>
<span class="nc" id="L121">        FontMetrics metrics = SwingUtilities2.getFontMetrics(component, g);</span>
<span class="nc" id="L122">        int nextX = x;</span>
<span class="nc" id="L123">        char[] txt = s.array;</span>
<span class="nc" id="L124">        int txtOffset = s.offset;</span>
<span class="nc" id="L125">        int flushLen = 0;</span>
<span class="nc" id="L126">        int flushIndex = s.offset;</span>
<span class="nc" id="L127">        int spaceAddon = 0;</span>
<span class="nc" id="L128">        int spaceAddonLeftoverEnd = -1;</span>
<span class="nc" id="L129">        int startJustifiableContent = 0;</span>
<span class="nc" id="L130">        int endJustifiableContent = 0;</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (justificationData != null) {</span>
<span class="nc" id="L132">            int offset = - startOffset + txtOffset;</span>
<span class="nc" id="L133">            View parent = null;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">            if (view != null</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                  &amp;&amp; (parent = view.getParent()) != null) {</span>
<span class="nc" id="L136">                offset += parent.getStartOffset();</span>
            }
<span class="nc" id="L138">            spaceAddon =</span>
                justificationData[Row.SPACE_ADDON];
<span class="nc" id="L140">            spaceAddonLeftoverEnd =</span>
                justificationData[Row.SPACE_ADDON_LEFTOVER_END] + offset;
<span class="nc" id="L142">            startJustifiableContent =</span>
                justificationData[Row.START_JUSTIFIABLE] + offset;
<span class="nc" id="L144">            endJustifiableContent =</span>
                justificationData[Row.END_JUSTIFIABLE] + offset;
        }
<span class="nc" id="L147">        int n = s.offset + s.count;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        for (int i = txtOffset; i &lt; n; i++) {</span>
<span class="nc bnc" id="L149" title="All 12 branches missed.">            if (txt[i] == '\t'</span>
                || ((spaceAddon != 0 || i &lt;= spaceAddonLeftoverEnd)
                    &amp;&amp; (txt[i] == ' ')
                    &amp;&amp; startJustifiableContent &lt;= i
                    &amp;&amp; i &lt;= endJustifiableContent
                    )) {
<span class="nc bnc" id="L155" title="All 2 branches missed.">                if (flushLen &gt; 0) {</span>
<span class="nc" id="L156">                    nextX = SwingUtilities2.drawChars(component, g, txt,</span>
                                                flushIndex, flushLen, x, y);
<span class="nc" id="L158">                    flushLen = 0;</span>
                }
<span class="nc" id="L160">                flushIndex = i + 1;</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                if (txt[i] == '\t') {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                    if (e != null) {</span>
<span class="nc" id="L163">                        nextX = (int) e.nextTabStop((float) nextX, startOffset + i - txtOffset);</span>
                    } else {
<span class="nc" id="L165">                        nextX += metrics.charWidth(' ');</span>
                    }
<span class="nc bnc" id="L167" title="All 2 branches missed.">                } else if (txt[i] == ' ') {</span>
<span class="nc" id="L168">                    nextX += metrics.charWidth(' ') + spaceAddon;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">                    if (i &lt;= spaceAddonLeftoverEnd) {</span>
<span class="nc" id="L170">                        nextX++;</span>
                    }
                }
<span class="nc" id="L173">                x = nextX;</span>
<span class="nc bnc" id="L174" title="All 4 branches missed.">            } else if ((txt[i] == '\n') || (txt[i] == '\r')) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                if (flushLen &gt; 0) {</span>
<span class="nc" id="L176">                    nextX = SwingUtilities2.drawChars(component, g, txt,</span>
                                                flushIndex, flushLen, x, y);
<span class="nc" id="L178">                    flushLen = 0;</span>
                }
<span class="nc" id="L180">                flushIndex = i + 1;</span>
<span class="nc" id="L181">                x = nextX;</span>
            } else {
<span class="nc" id="L183">                flushLen += 1;</span>
            }
        }
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (flushLen &gt; 0) {</span>
<span class="nc" id="L187">            nextX = SwingUtilities2.drawChars(component, g,txt, flushIndex,</span>
                                              flushLen, x, y);
        }
<span class="nc" id="L190">        return nextX;</span>
    }

    /**
     * Determines the width of the given segment of text taking tabs
     * into consideration.  This is implemented in a 1.1 style coordinate
     * system where ints are used and 72dpi is assumed.
     *
     * @param s  the source of the text
     * @param metrics the font metrics to use for the calculation
     * @param x  the X origin &amp;gt;= 0
     * @param e  how to expand the tabs.  If this value is null,
     *   tabs will be expanded as a space character.
     * @param startOffset starting offset of the text in the document &amp;gt;= 0
     * @return  the width of the text
     */
    public static final int getTabbedTextWidth(Segment s, FontMetrics metrics, int x,
                                               TabExpander e, int startOffset) {
<span class="nc" id="L208">        return getTabbedTextWidth(null, s, metrics, x, e, startOffset, null);</span>
    }


    // In addition to the previous method it can extend spaces for
    // justification.
    //
    // all params are the same as in the preious method except the last
    // one:
    // @param justificationData justificationData for the row.
    // if null not justification is needed
    static final int getTabbedTextWidth(View view, Segment s, FontMetrics metrics, int x,
                                        TabExpander e, int startOffset,
                                        int[] justificationData) {
<span class="nc" id="L222">        int nextX = x;</span>
<span class="nc" id="L223">        char[] txt = s.array;</span>
<span class="nc" id="L224">        int txtOffset = s.offset;</span>
<span class="nc" id="L225">        int n = s.offset + s.count;</span>
<span class="nc" id="L226">        int charCount = 0;</span>
<span class="nc" id="L227">        int spaceAddon = 0;</span>
<span class="nc" id="L228">        int spaceAddonLeftoverEnd = -1;</span>
<span class="nc" id="L229">        int startJustifiableContent = 0;</span>
<span class="nc" id="L230">        int endJustifiableContent = 0;</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (justificationData != null) {</span>
<span class="nc" id="L232">            int offset = - startOffset + txtOffset;</span>
<span class="nc" id="L233">            View parent = null;</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (view != null</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                  &amp;&amp; (parent = view.getParent()) != null) {</span>
<span class="nc" id="L236">                offset += parent.getStartOffset();</span>
            }
<span class="nc" id="L238">            spaceAddon =</span>
                justificationData[Row.SPACE_ADDON];
<span class="nc" id="L240">            spaceAddonLeftoverEnd =</span>
                justificationData[Row.SPACE_ADDON_LEFTOVER_END] + offset;
<span class="nc" id="L242">            startJustifiableContent =</span>
                justificationData[Row.START_JUSTIFIABLE] + offset;
<span class="nc" id="L244">            endJustifiableContent =</span>
                justificationData[Row.END_JUSTIFIABLE] + offset;
        }

<span class="nc bnc" id="L248" title="All 2 branches missed.">        for (int i = txtOffset; i &lt; n; i++) {</span>
<span class="nc bnc" id="L249" title="All 12 branches missed.">            if (txt[i] == '\t'</span>
                || ((spaceAddon != 0 || i &lt;= spaceAddonLeftoverEnd)
                    &amp;&amp; (txt[i] == ' ')
                    &amp;&amp; startJustifiableContent &lt;= i
                    &amp;&amp; i &lt;= endJustifiableContent
                    )) {
<span class="nc" id="L255">                nextX += metrics.charsWidth(txt, i-charCount, charCount);</span>
<span class="nc" id="L256">                charCount = 0;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">                if (txt[i] == '\t') {</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">                    if (e != null) {</span>
<span class="nc" id="L259">                        nextX = (int) e.nextTabStop((float) nextX,</span>
                                                    startOffset + i - txtOffset);
                    } else {
<span class="nc" id="L262">                        nextX += metrics.charWidth(' ');</span>
                    }
<span class="nc bnc" id="L264" title="All 2 branches missed.">                } else if (txt[i] == ' ') {</span>
<span class="nc" id="L265">                    nextX += metrics.charWidth(' ') + spaceAddon;</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">                    if (i &lt;= spaceAddonLeftoverEnd) {</span>
<span class="nc" id="L267">                        nextX++;</span>
                    }
                }
<span class="nc bnc" id="L270" title="All 2 branches missed.">            } else if(txt[i] == '\n') {</span>
            // Ignore newlines, they take up space and we shouldn't be
            // counting them.
<span class="nc" id="L273">                nextX += metrics.charsWidth(txt, i - charCount, charCount);</span>
<span class="nc" id="L274">                charCount = 0;</span>
            } else {
<span class="nc" id="L276">                charCount++;</span>
        }
        }
<span class="nc" id="L279">        nextX += metrics.charsWidth(txt, n - charCount, charCount);</span>
<span class="nc" id="L280">        return nextX - x;</span>
    }

    /**
     * Determines the relative offset into the given text that
     * best represents the given span in the view coordinate
     * system.  This is implemented in a 1.1 style coordinate
     * system where ints are used and 72dpi is assumed.
     *
     * @param s  the source of the text
     * @param metrics the font metrics to use for the calculation
     * @param x0 the starting view location representing the start
     *   of the given text &amp;gt;= 0.
     * @param x  the target view location to translate to an
     *   offset into the text &amp;gt;= 0.
     * @param e  how to expand the tabs.  If this value is null,
     *   tabs will be expanded as a space character.
     * @param startOffset starting offset of the text in the document &amp;gt;= 0
     * @return  the offset into the text &amp;gt;= 0
     */
    public static final int getTabbedTextOffset(Segment s, FontMetrics metrics,
                                             int x0, int x, TabExpander e,
                                             int startOffset) {
<span class="nc" id="L303">        return getTabbedTextOffset(s, metrics, x0, x, e, startOffset, true);</span>
    }

    static final int getTabbedTextOffset(View view, Segment s, FontMetrics metrics,
                                         int x0, int x, TabExpander e,
                                         int startOffset,
                                         int[] justificationData) {
<span class="nc" id="L310">        return getTabbedTextOffset(view, s, metrics, x0, x, e, startOffset, true,</span>
                                   justificationData);
    }

    public static final int getTabbedTextOffset(Segment s,
                                                FontMetrics metrics,
                                                int x0, int x, TabExpander e,
                                                int startOffset,
                                                boolean round) {
<span class="nc" id="L319">        return getTabbedTextOffset(null, s, metrics, x0, x, e, startOffset, round, null);</span>
    }

    // In addition to the previous method it can extend spaces for
    // justification.
    //
    // all params are the same as in the preious method except the last
    // one:
    // @param justificationData justificationData for the row.
    // if null not justification is needed
    static final int getTabbedTextOffset(View view,
                                         Segment s,
                                         FontMetrics metrics,
                                         int x0, int x, TabExpander e,
                                         int startOffset,
                                         boolean round,
                                         int[] justificationData) {
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (x0 &gt;= x) {</span>
            // x before x0, return.
<span class="nc" id="L338">            return 0;</span>
        }
<span class="nc" id="L340">        int nextX = x0;</span>
        // s may be a shared segment, so it is copied prior to calling
        // the tab expander
<span class="nc" id="L343">        char[] txt = s.array;</span>
<span class="nc" id="L344">        int txtOffset = s.offset;</span>
<span class="nc" id="L345">        int txtCount = s.count;</span>
<span class="nc" id="L346">        int spaceAddon = 0 ;</span>
<span class="nc" id="L347">        int spaceAddonLeftoverEnd = -1;</span>
<span class="nc" id="L348">        int startJustifiableContent = 0 ;</span>
<span class="nc" id="L349">        int endJustifiableContent = 0;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (justificationData != null) {</span>
<span class="nc" id="L351">            int offset = - startOffset + txtOffset;</span>
<span class="nc" id="L352">            View parent = null;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (view != null</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">                  &amp;&amp; (parent = view.getParent()) != null) {</span>
<span class="nc" id="L355">                offset += parent.getStartOffset();</span>
            }
<span class="nc" id="L357">            spaceAddon =</span>
                justificationData[Row.SPACE_ADDON];
<span class="nc" id="L359">            spaceAddonLeftoverEnd =</span>
                justificationData[Row.SPACE_ADDON_LEFTOVER_END] + offset;
<span class="nc" id="L361">            startJustifiableContent =</span>
                justificationData[Row.START_JUSTIFIABLE] + offset;
<span class="nc" id="L363">            endJustifiableContent =</span>
                justificationData[Row.END_JUSTIFIABLE] + offset;
        }
<span class="nc" id="L366">        int n = s.offset + s.count;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        for (int i = s.offset; i &lt; n; i++) {</span>
<span class="nc bnc" id="L368" title="All 12 branches missed.">            if (txt[i] == '\t'</span>
                || ((spaceAddon != 0 || i &lt;= spaceAddonLeftoverEnd)
                    &amp;&amp; (txt[i] == ' ')
                    &amp;&amp; startJustifiableContent &lt;= i
                    &amp;&amp; i &lt;= endJustifiableContent
                    )){
<span class="nc bnc" id="L374" title="All 2 branches missed.">                if (txt[i] == '\t') {</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                    if (e != null) {</span>
<span class="nc" id="L376">                        nextX = (int) e.nextTabStop((float) nextX,</span>
                                                    startOffset + i - txtOffset);
                    } else {
<span class="nc" id="L379">                        nextX += metrics.charWidth(' ');</span>
                    }
<span class="nc bnc" id="L381" title="All 2 branches missed.">                } else if (txt[i] == ' ') {</span>
<span class="nc" id="L382">                    nextX += metrics.charWidth(' ') + spaceAddon;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">                    if (i &lt;= spaceAddonLeftoverEnd) {</span>
<span class="nc" id="L384">                        nextX++;</span>
                    }
                }
            } else {
<span class="nc" id="L388">                nextX += metrics.charWidth(txt[i]);</span>
            }
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (x &lt; nextX) {</span>
                // found the hit position... return the appropriate side
                int offset;

                // the length of the string measured as a whole may differ from
                // the sum of individual character lengths, for example if
                // fractional metrics are enabled; and we must guard from this.
<span class="nc bnc" id="L397" title="All 2 branches missed.">                if (round) {</span>
<span class="nc" id="L398">                    offset = i + 1 - txtOffset;</span>

<span class="nc" id="L400">                    int width = metrics.charsWidth(txt, txtOffset, offset);</span>
<span class="nc" id="L401">                    int span = x - x0;</span>

<span class="nc bnc" id="L403" title="All 2 branches missed.">                    if (span &lt; width) {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                        while (offset &gt; 0) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                            int nextWidth = offset &gt; 1 ? metrics.charsWidth(txt, txtOffset, offset - 1) : 0;</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">                            if (span &gt;= nextWidth) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">                                if (span - nextWidth &lt; width - span) {</span>
<span class="nc" id="L409">                                    offset--;</span>
                                }

                                break;
                            }

<span class="nc" id="L415">                            width = nextWidth;</span>
<span class="nc" id="L416">                            offset--;</span>
<span class="nc" id="L417">                        }</span>
                    }
<span class="nc" id="L419">                } else {</span>
<span class="nc" id="L420">                    offset = i - txtOffset;</span>

<span class="nc bnc" id="L422" title="All 4 branches missed.">                    while (offset &gt; 0 &amp;&amp; metrics.charsWidth(txt, txtOffset, offset) &gt; (x - x0)) {</span>
<span class="nc" id="L423">                        offset--;</span>
                    }
                }

<span class="nc" id="L427">                return offset;</span>
            }
        }

        // didn't find, return end offset
<span class="nc" id="L432">        return txtCount;</span>
    }

    /**
     * Determine where to break the given text to fit
     * within the given span. This tries to find a word boundary.
     * @param s  the source of the text
     * @param metrics the font metrics to use for the calculation
     * @param x0 the starting view location representing the start
     *   of the given text.
     * @param x  the target view location to translate to an
     *   offset into the text.
     * @param e  how to expand the tabs.  If this value is null,
     *   tabs will be expanded as a space character.
     * @param startOffset starting offset in the document of the text
     * @return  the offset into the given text
     */
    public static final int getBreakLocation(Segment s, FontMetrics metrics,
                                             int x0, int x, TabExpander e,
                                             int startOffset) {
<span class="nc" id="L452">        char[] txt = s.array;</span>
<span class="nc" id="L453">        int txtOffset = s.offset;</span>
<span class="nc" id="L454">        int txtCount = s.count;</span>
<span class="nc" id="L455">        int index = Utilities.getTabbedTextOffset(s, metrics, x0, x,</span>
                                                  e, startOffset, false);

<span class="nc bnc" id="L458" title="All 2 branches missed.">        if (index &gt;= txtCount - 1) {</span>
<span class="nc" id="L459">            return txtCount;</span>
        }

<span class="nc bnc" id="L462" title="All 2 branches missed.">        for (int i = txtOffset + index; i &gt;= txtOffset; i--) {</span>
<span class="nc" id="L463">            char ch = txt[i];</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">            if (ch &lt; 256) {</span>
                // break on whitespace
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if (Character.isWhitespace(ch)) {</span>
<span class="nc" id="L467">                    index = i - txtOffset + 1;</span>
<span class="nc" id="L468">                    break;</span>
                }
            } else {
                // a multibyte char found; use BreakIterator to find line break
<span class="nc" id="L472">                BreakIterator bit = BreakIterator.getLineInstance();</span>
<span class="nc" id="L473">                bit.setText(s);</span>
<span class="nc" id="L474">                int breakPos = bit.preceding(i + 1);</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">                if (breakPos &gt; txtOffset) {</span>
<span class="nc" id="L476">                    index = breakPos - txtOffset;</span>
                }
                break;
            }
        }
<span class="nc" id="L481">        return index;</span>
    }

    /**
     * Determines the starting row model position of the row that contains
     * the specified model position.  The component given must have a
     * size to compute the result.  If the component doesn't have a size
     * a value of -1 will be returned.
     *
     * @param c the editor
     * @param offs the offset in the document &amp;gt;= 0
     * @return the position &amp;gt;= 0 if the request can be computed, otherwise
     *  a value of -1 will be returned.
     * @exception BadLocationException if the offset is out of range
     */
    public static final int getRowStart(JTextComponent c, int offs) throws BadLocationException {
<span class="nc" id="L497">        Rectangle r = c.modelToView(offs);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (r == null) {</span>
<span class="nc" id="L499">            return -1;</span>
        }
<span class="nc" id="L501">        int lastOffs = offs;</span>
<span class="nc" id="L502">        int y = r.y;</span>
<span class="nc bnc" id="L503" title="All 4 branches missed.">        while ((r != null) &amp;&amp; (y == r.y)) {</span>
            // Skip invisible elements
<span class="nc bnc" id="L505" title="All 2 branches missed.">            if(r.height !=0) {</span>
<span class="nc" id="L506">                offs = lastOffs;</span>
            }
<span class="nc" id="L508">            lastOffs -= 1;</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">            r = (lastOffs &gt;= 0) ? c.modelToView(lastOffs) : null;</span>
        }
<span class="nc" id="L511">        return offs;</span>
    }

    /**
     * Determines the ending row model position of the row that contains
     * the specified model position.  The component given must have a
     * size to compute the result.  If the component doesn't have a size
     * a value of -1 will be returned.
     *
     * @param c the editor
     * @param offs the offset in the document &amp;gt;= 0
     * @return the position &amp;gt;= 0 if the request can be computed, otherwise
     *  a value of -1 will be returned.
     * @exception BadLocationException if the offset is out of range
     */
    public static final int getRowEnd(JTextComponent c, int offs) throws BadLocationException {
<span class="nc" id="L527">        Rectangle r = c.modelToView(offs);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (r == null) {</span>
<span class="nc" id="L529">            return -1;</span>
        }
<span class="nc" id="L531">        int n = c.getDocument().getLength();</span>
<span class="nc" id="L532">        int lastOffs = offs;</span>
<span class="nc" id="L533">        int y = r.y;</span>
<span class="nc bnc" id="L534" title="All 4 branches missed.">        while ((r != null) &amp;&amp; (y == r.y)) {</span>
            // Skip invisible elements
<span class="nc bnc" id="L536" title="All 2 branches missed.">            if (r.height !=0) {</span>
<span class="nc" id="L537">                offs = lastOffs;</span>
            }
<span class="nc" id="L539">            lastOffs += 1;</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            r = (lastOffs &lt;= n) ? c.modelToView(lastOffs) : null;</span>
        }
<span class="nc" id="L542">        return offs;</span>
    }

    /**
     * Determines the position in the model that is closest to the given
     * view location in the row above.  The component given must have a
     * size to compute the result.  If the component doesn't have a size
     * a value of -1 will be returned.
     *
     * @param c the editor
     * @param offs the offset in the document &amp;gt;= 0
     * @param x the X coordinate &amp;gt;= 0
     * @return the position &amp;gt;= 0 if the request can be computed, otherwise
     *  a value of -1 will be returned.
     * @exception BadLocationException if the offset is out of range
     */
    public static final int getPositionAbove(JTextComponent c, int offs, int x) throws BadLocationException {
<span class="nc" id="L559">        int lastOffs = getRowStart(c, offs) - 1;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (lastOffs &lt; 0) {</span>
<span class="nc" id="L561">            return -1;</span>
        }
<span class="nc" id="L563">        int bestSpan = Integer.MAX_VALUE;</span>
<span class="nc" id="L564">        int y = 0;</span>
<span class="nc" id="L565">        Rectangle r = null;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">        if (lastOffs &gt;= 0) {</span>
<span class="nc" id="L567">            r = c.modelToView(lastOffs);</span>
<span class="nc" id="L568">            y = r.y;</span>
        }
<span class="nc bnc" id="L570" title="All 4 branches missed.">        while ((r != null) &amp;&amp; (y == r.y)) {</span>
<span class="nc" id="L571">            int span = Math.abs(r.x - x);</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">            if (span &lt; bestSpan) {</span>
<span class="nc" id="L573">                offs = lastOffs;</span>
<span class="nc" id="L574">                bestSpan = span;</span>
            }
<span class="nc" id="L576">            lastOffs -= 1;</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">            r = (lastOffs &gt;= 0) ? c.modelToView(lastOffs) : null;</span>
<span class="nc" id="L578">        }</span>
<span class="nc" id="L579">        return offs;</span>
    }

    /**
     * Determines the position in the model that is closest to the given
     * view location in the row below.  The component given must have a
     * size to compute the result.  If the component doesn't have a size
     * a value of -1 will be returned.
     *
     * @param c the editor
     * @param offs the offset in the document &amp;gt;= 0
     * @param x the X coordinate &amp;gt;= 0
     * @return the position &amp;gt;= 0 if the request can be computed, otherwise
     *  a value of -1 will be returned.
     * @exception BadLocationException if the offset is out of range
     */
    public static final int getPositionBelow(JTextComponent c, int offs, int x) throws BadLocationException {
<span class="nc" id="L596">        int lastOffs = getRowEnd(c, offs) + 1;</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">        if (lastOffs &lt;= 0) {</span>
<span class="nc" id="L598">            return -1;</span>
        }
<span class="nc" id="L600">        int bestSpan = Integer.MAX_VALUE;</span>
<span class="nc" id="L601">        int n = c.getDocument().getLength();</span>
<span class="nc" id="L602">        int y = 0;</span>
<span class="nc" id="L603">        Rectangle r = null;</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if (lastOffs &lt;= n) {</span>
<span class="nc" id="L605">            r = c.modelToView(lastOffs);</span>
<span class="nc" id="L606">            y = r.y;</span>
        }
<span class="nc bnc" id="L608" title="All 4 branches missed.">        while ((r != null) &amp;&amp; (y == r.y)) {</span>
<span class="nc" id="L609">            int span = Math.abs(x - r.x);</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (span &lt; bestSpan) {</span>
<span class="nc" id="L611">                offs = lastOffs;</span>
<span class="nc" id="L612">                bestSpan = span;</span>
            }
<span class="nc" id="L614">            lastOffs += 1;</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">            r = (lastOffs &lt;= n) ? c.modelToView(lastOffs) : null;</span>
<span class="nc" id="L616">        }</span>
<span class="nc" id="L617">        return offs;</span>
    }

    /**
     * Determines the start of a word for the given model location.
     * Uses BreakIterator.getWordInstance() to actually get the words.
     *
     * @param c the editor
     * @param offs the offset in the document &amp;gt;= 0
     * @return the location in the model of the word start &amp;gt;= 0
     * @exception BadLocationException if the offset is out of range
     */
    public static final int getWordStart(JTextComponent c, int offs) throws BadLocationException {
<span class="nc" id="L630">        Document doc = c.getDocument();</span>
<span class="nc" id="L631">        Element line = getParagraphElement(c, offs);</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (line == null) {</span>
<span class="nc" id="L633">            throw new BadLocationException(&quot;No word at &quot; + offs, offs);</span>
        }
<span class="nc" id="L635">        int lineStart = line.getStartOffset();</span>
<span class="nc" id="L636">        int lineEnd = Math.min(line.getEndOffset(), doc.getLength());</span>

<span class="nc" id="L638">        Segment seg = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L639">        doc.getText(lineStart, lineEnd - lineStart, seg);</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if(seg.count &gt; 0) {</span>
<span class="nc" id="L641">            BreakIterator words = BreakIterator.getWordInstance(c.getLocale());</span>
<span class="nc" id="L642">            words.setText(seg);</span>
<span class="nc" id="L643">            int wordPosition = seg.offset + offs - lineStart;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">            if(wordPosition &gt;= words.last()) {</span>
<span class="nc" id="L645">                wordPosition = words.last() - 1;</span>
            }
<span class="nc" id="L647">            words.following(wordPosition);</span>
<span class="nc" id="L648">            offs = lineStart + words.previous() - seg.offset;</span>
        }
<span class="nc" id="L650">        SegmentCache.releaseSharedSegment(seg);</span>
<span class="nc" id="L651">        return offs;</span>
    }

    /**
     * Determines the end of a word for the given location.
     * Uses BreakIterator.getWordInstance() to actually get the words.
     *
     * @param c the editor
     * @param offs the offset in the document &amp;gt;= 0
     * @return the location in the model of the word end &amp;gt;= 0
     * @exception BadLocationException if the offset is out of range
     */
    public static final int getWordEnd(JTextComponent c, int offs) throws BadLocationException {
<span class="nc" id="L664">        Document doc = c.getDocument();</span>
<span class="nc" id="L665">        Element line = getParagraphElement(c, offs);</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (line == null) {</span>
<span class="nc" id="L667">            throw new BadLocationException(&quot;No word at &quot; + offs, offs);</span>
        }
<span class="nc" id="L669">        int lineStart = line.getStartOffset();</span>
<span class="nc" id="L670">        int lineEnd = Math.min(line.getEndOffset(), doc.getLength());</span>

<span class="nc" id="L672">        Segment seg = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L673">        doc.getText(lineStart, lineEnd - lineStart, seg);</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">        if(seg.count &gt; 0) {</span>
<span class="nc" id="L675">            BreakIterator words = BreakIterator.getWordInstance(c.getLocale());</span>
<span class="nc" id="L676">            words.setText(seg);</span>
<span class="nc" id="L677">            int wordPosition = offs - lineStart + seg.offset;</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">            if(wordPosition &gt;= words.last()) {</span>
<span class="nc" id="L679">                wordPosition = words.last() - 1;</span>
            }
<span class="nc" id="L681">            offs = lineStart + words.following(wordPosition) - seg.offset;</span>
        }
<span class="nc" id="L683">        SegmentCache.releaseSharedSegment(seg);</span>
<span class="nc" id="L684">        return offs;</span>
    }

    /**
     * Determines the start of the next word for the given location.
     * Uses BreakIterator.getWordInstance() to actually get the words.
     *
     * @param c the editor
     * @param offs the offset in the document &amp;gt;= 0
     * @return the location in the model of the word start &amp;gt;= 0
     * @exception BadLocationException if the offset is out of range
     */
    public static final int getNextWord(JTextComponent c, int offs) throws BadLocationException {
        int nextWord;
<span class="nc" id="L698">        Element line = getParagraphElement(c, offs);</span>
<span class="nc" id="L699">        for (nextWord = getNextWordInParagraph(c, line, offs, false);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">             nextWord == BreakIterator.DONE;</span>
<span class="nc" id="L701">             nextWord = getNextWordInParagraph(c, line, offs, true)) {</span>

            // didn't find in this line, try the next line
<span class="nc" id="L704">            offs = line.getEndOffset();</span>
<span class="nc" id="L705">            line = getParagraphElement(c, offs);</span>
        }
<span class="nc" id="L707">        return nextWord;</span>
    }

    /**
     * Finds the next word in the given elements text.  The first
     * parameter allows searching multiple paragraphs where even
     * the first offset is desired.
     * Returns the offset of the next word, or BreakIterator.DONE
     * if there are no more words in the element.
     */
    static int getNextWordInParagraph(JTextComponent c, Element line, int offs, boolean first) throws BadLocationException {
<span class="nc bnc" id="L718" title="All 2 branches missed.">        if (line == null) {</span>
<span class="nc" id="L719">            throw new BadLocationException(&quot;No more words&quot;, offs);</span>
        }
<span class="nc" id="L721">        Document doc = line.getDocument();</span>
<span class="nc" id="L722">        int lineStart = line.getStartOffset();</span>
<span class="nc" id="L723">        int lineEnd = Math.min(line.getEndOffset(), doc.getLength());</span>
<span class="nc bnc" id="L724" title="All 4 branches missed.">        if ((offs &gt;= lineEnd) || (offs &lt; lineStart)) {</span>
<span class="nc" id="L725">            throw new BadLocationException(&quot;No more words&quot;, offs);</span>
        }
<span class="nc" id="L727">        Segment seg = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L728">        doc.getText(lineStart, lineEnd - lineStart, seg);</span>
<span class="nc" id="L729">        BreakIterator words = BreakIterator.getWordInstance(c.getLocale());</span>
<span class="nc" id="L730">        words.setText(seg);</span>
<span class="nc bnc" id="L731" title="All 4 branches missed.">        if ((first &amp;&amp; (words.first() == (seg.offset + offs - lineStart))) &amp;&amp;</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">            (! Character.isWhitespace(seg.array[words.first()]))) {</span>

<span class="nc" id="L734">            return offs;</span>
        }
<span class="nc" id="L736">        int wordPosition = words.following(seg.offset + offs - lineStart);</span>
<span class="nc bnc" id="L737" title="All 4 branches missed.">        if ((wordPosition == BreakIterator.DONE) ||</span>
            (wordPosition &gt;= seg.offset + seg.count)) {
                // there are no more words on this line.
<span class="nc" id="L740">                return BreakIterator.DONE;</span>
        }
        // if we haven't shot past the end... check to
        // see if the current boundary represents whitespace.
        // if so, we need to try again
<span class="nc" id="L745">        char ch = seg.array[wordPosition];</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">        if (! Character.isWhitespace(ch)) {</span>
<span class="nc" id="L747">            return lineStart + wordPosition - seg.offset;</span>
        }

        // it was whitespace, try again.  The assumption
        // is that it must be a word start if the last
        // one had whitespace following it.
<span class="nc" id="L753">        wordPosition = words.next();</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (wordPosition != BreakIterator.DONE) {</span>
<span class="nc" id="L755">            offs = lineStart + wordPosition - seg.offset;</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">            if (offs != lineEnd) {</span>
<span class="nc" id="L757">                return offs;</span>
            }
        }
<span class="nc" id="L760">        SegmentCache.releaseSharedSegment(seg);</span>
<span class="nc" id="L761">        return BreakIterator.DONE;</span>
    }


    /**
     * Determine the start of the prev word for the given location.
     * Uses BreakIterator.getWordInstance() to actually get the words.
     *
     * @param c the editor
     * @param offs the offset in the document &amp;gt;= 0
     * @return the location in the model of the word start &amp;gt;= 0
     * @exception BadLocationException if the offset is out of range
     */
    public static final int getPreviousWord(JTextComponent c, int offs) throws BadLocationException {
        int prevWord;
<span class="nc" id="L776">        Element line = getParagraphElement(c, offs);</span>
<span class="nc" id="L777">        for (prevWord = getPrevWordInParagraph(c, line, offs);</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">             prevWord == BreakIterator.DONE;</span>
<span class="nc" id="L779">             prevWord = getPrevWordInParagraph(c, line, offs)) {</span>

            // didn't find in this line, try the prev line
<span class="nc" id="L782">            offs = line.getStartOffset() - 1;</span>
<span class="nc" id="L783">            line = getParagraphElement(c, offs);</span>
        }
<span class="nc" id="L785">        return prevWord;</span>
    }

    /**
     * Finds the previous word in the given elements text.  The first
     * parameter allows searching multiple paragraphs where even
     * the first offset is desired.
     * Returns the offset of the next word, or BreakIterator.DONE
     * if there are no more words in the element.
     */
    static int getPrevWordInParagraph(JTextComponent c, Element line, int offs) throws BadLocationException {
<span class="nc bnc" id="L796" title="All 2 branches missed.">        if (line == null) {</span>
<span class="nc" id="L797">            throw new BadLocationException(&quot;No more words&quot;, offs);</span>
        }
<span class="nc" id="L799">        Document doc = line.getDocument();</span>
<span class="nc" id="L800">        int lineStart = line.getStartOffset();</span>
<span class="nc" id="L801">        int lineEnd = line.getEndOffset();</span>
<span class="nc bnc" id="L802" title="All 4 branches missed.">        if ((offs &gt; lineEnd) || (offs &lt; lineStart)) {</span>
<span class="nc" id="L803">            throw new BadLocationException(&quot;No more words&quot;, offs);</span>
        }
<span class="nc" id="L805">        Segment seg = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L806">        doc.getText(lineStart, lineEnd - lineStart, seg);</span>
<span class="nc" id="L807">        BreakIterator words = BreakIterator.getWordInstance(c.getLocale());</span>
<span class="nc" id="L808">        words.setText(seg);</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">        if (words.following(seg.offset + offs - lineStart) == BreakIterator.DONE) {</span>
<span class="nc" id="L810">            words.last();</span>
        }
<span class="nc" id="L812">        int wordPosition = words.previous();</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">        if (wordPosition == (seg.offset + offs - lineStart)) {</span>
<span class="nc" id="L814">            wordPosition = words.previous();</span>
        }

<span class="nc bnc" id="L817" title="All 2 branches missed.">        if (wordPosition == BreakIterator.DONE) {</span>
            // there are no more words on this line.
<span class="nc" id="L819">            return BreakIterator.DONE;</span>
        }
        // if we haven't shot past the end... check to
        // see if the current boundary represents whitespace.
        // if so, we need to try again
<span class="nc" id="L824">        char ch = seg.array[wordPosition];</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (! Character.isWhitespace(ch)) {</span>
<span class="nc" id="L826">            return lineStart + wordPosition - seg.offset;</span>
        }

        // it was whitespace, try again.  The assumption
        // is that it must be a word start if the last
        // one had whitespace following it.
<span class="nc" id="L832">        wordPosition = words.previous();</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (wordPosition != BreakIterator.DONE) {</span>
<span class="nc" id="L834">            return lineStart + wordPosition - seg.offset;</span>
        }
<span class="nc" id="L836">        SegmentCache.releaseSharedSegment(seg);</span>
<span class="nc" id="L837">        return BreakIterator.DONE;</span>
    }

    /**
     * Determines the element to use for a paragraph/line.
     *
     * @param c the editor
     * @param offs the starting offset in the document &amp;gt;= 0
     * @return the element
     */
    public static final Element getParagraphElement(JTextComponent c, int offs) {
<span class="nc" id="L848">        Document doc = c.getDocument();</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">        if (doc instanceof StyledDocument) {</span>
<span class="nc" id="L850">            return ((StyledDocument)doc).getParagraphElement(offs);</span>
        }
<span class="nc" id="L852">        Element map = doc.getDefaultRootElement();</span>
<span class="nc" id="L853">        int index = map.getElementIndex(offs);</span>
<span class="nc" id="L854">        Element paragraph = map.getElement(index);</span>
<span class="nc bnc" id="L855" title="All 4 branches missed.">        if ((offs &gt;= paragraph.getStartOffset()) &amp;&amp; (offs &lt; paragraph.getEndOffset())) {</span>
<span class="nc" id="L856">            return paragraph;</span>
        }
<span class="nc" id="L858">        return null;</span>
    }

    static boolean isComposedTextElement(Document doc, int offset) {
<span class="nc" id="L862">        Element elem = doc.getDefaultRootElement();</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">        while (!elem.isLeaf()) {</span>
<span class="nc" id="L864">            elem = elem.getElement(elem.getElementIndex(offset));</span>
        }
<span class="nc" id="L866">        return isComposedTextElement(elem);</span>
    }

    static boolean isComposedTextElement(Element elem) {
<span class="nc" id="L870">        AttributeSet as = elem.getAttributes();</span>
<span class="nc" id="L871">        return isComposedTextAttributeDefined(as);</span>
    }

    static boolean isComposedTextAttributeDefined(AttributeSet as) {
<span class="nc bnc" id="L875" title="All 2 branches missed.">        return ((as != null) &amp;&amp;</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">                (as.isDefined(StyleConstants.ComposedTextAttribute)));</span>
    }

    /**
     * Draws the given composed text passed from an input method.
     *
     * @param view View hosting text
     * @param attr the attributes containing the composed text
     * @param g  the graphics context
     * @param x  the X origin
     * @param y  the Y origin
     * @param p0 starting offset in the composed text to be rendered
     * @param p1 ending offset in the composed text to be rendered
     * @return  the new insertion position
     */
    static int drawComposedText(View view, AttributeSet attr, Graphics g,
                                int x, int y, int p0, int p1)
                                     throws BadLocationException {
<span class="nc" id="L894">        Graphics2D g2d = (Graphics2D)g;</span>
<span class="nc" id="L895">        AttributedString as = (AttributedString)attr.getAttribute(</span>
            StyleConstants.ComposedTextAttribute);
<span class="nc" id="L897">        as.addAttribute(TextAttribute.FONT, g.getFont());</span>

<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (p0 &gt;= p1)</span>
<span class="nc" id="L900">            return x;</span>

<span class="nc" id="L902">        AttributedCharacterIterator aci = as.getIterator(null, p0, p1);</span>
<span class="nc" id="L903">        return x + (int)SwingUtilities2.drawString(</span>
<span class="nc" id="L904">                             getJComponent(view), g2d,aci,x,y);</span>
    }

    /**
     * Paints the composed text in a GlyphView
     */
    static void paintComposedText(Graphics g, Rectangle alloc, GlyphView v) {
<span class="nc bnc" id="L911" title="All 2 branches missed.">        if (g instanceof Graphics2D) {</span>
<span class="nc" id="L912">            Graphics2D g2d = (Graphics2D) g;</span>
<span class="nc" id="L913">            int p0 = v.getStartOffset();</span>
<span class="nc" id="L914">            int p1 = v.getEndOffset();</span>
<span class="nc" id="L915">            AttributeSet attrSet = v.getElement().getAttributes();</span>
<span class="nc" id="L916">            AttributedString as =</span>
<span class="nc" id="L917">                (AttributedString)attrSet.getAttribute(StyleConstants.ComposedTextAttribute);</span>
<span class="nc" id="L918">            int start = v.getElement().getStartOffset();</span>
<span class="nc" id="L919">            int y = alloc.y + alloc.height - (int)v.getGlyphPainter().getDescent(v);</span>
<span class="nc" id="L920">            int x = alloc.x;</span>

            //Add text attributes
<span class="nc" id="L923">            as.addAttribute(TextAttribute.FONT, v.getFont());</span>
<span class="nc" id="L924">            as.addAttribute(TextAttribute.FOREGROUND, v.getForeground());</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">            if (StyleConstants.isBold(v.getAttributes())) {</span>
<span class="nc" id="L926">                as.addAttribute(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);</span>
            }
<span class="nc bnc" id="L928" title="All 2 branches missed.">            if (StyleConstants.isItalic(v.getAttributes())) {</span>
<span class="nc" id="L929">                as.addAttribute(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE);</span>
            }
<span class="nc bnc" id="L931" title="All 2 branches missed.">            if (v.isUnderline()) {</span>
<span class="nc" id="L932">                as.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);</span>
            }
<span class="nc bnc" id="L934" title="All 2 branches missed.">            if (v.isStrikeThrough()) {</span>
<span class="nc" id="L935">                as.addAttribute(TextAttribute.STRIKETHROUGH, TextAttribute.STRIKETHROUGH_ON);</span>
            }
<span class="nc bnc" id="L937" title="All 2 branches missed.">            if (v.isSuperscript()) {</span>
<span class="nc" id="L938">                as.addAttribute(TextAttribute.SUPERSCRIPT, TextAttribute.SUPERSCRIPT_SUPER);</span>
            }
<span class="nc bnc" id="L940" title="All 2 branches missed.">            if (v.isSubscript()) {</span>
<span class="nc" id="L941">                as.addAttribute(TextAttribute.SUPERSCRIPT, TextAttribute.SUPERSCRIPT_SUB);</span>
            }

            // draw
<span class="nc" id="L945">            AttributedCharacterIterator aci = as.getIterator(null, p0 - start, p1 - start);</span>
<span class="nc" id="L946">            SwingUtilities2.drawString(getJComponent(v),</span>
                                       g2d,aci,x,y);
        }
<span class="nc" id="L949">    }</span>

    /*
     * Convenience function for determining ComponentOrientation.  Helps us
     * avoid having Munge directives throughout the code.
     */
    static boolean isLeftToRight( java.awt.Component c ) {
<span class="nc" id="L956">        return c.getComponentOrientation().isLeftToRight();</span>
    }


    /**
     * Provides a way to determine the next visually represented model
     * location that one might place a caret.  Some views may not be visible,
     * they might not be in the same order found in the model, or they just
     * might not allow access to some of the locations in the model.
     * &lt;p&gt;
     * This implementation assumes the views are layed out in a logical
     * manner. That is, that the view at index x + 1 is visually after
     * the View at index x, and that the View at index x - 1 is visually
     * before the View at x. There is support for reversing this behavior
     * only if the passed in &lt;code&gt;View&lt;/code&gt; is an instance of
     * &lt;code&gt;CompositeView&lt;/code&gt;. The &lt;code&gt;CompositeView&lt;/code&gt;
     * must then override the &lt;code&gt;flipEastAndWestAtEnds&lt;/code&gt; method.
     *
     * @param v View to query
     * @param pos the position to convert &amp;gt;= 0
     * @param a the allocated region to render into
     * @param direction the direction from the current position that can
     *  be thought of as the arrow keys typically found on a keyboard;
     *  this may be one of the following:
     *  &lt;ul&gt;
     *  &lt;li&gt;&lt;code&gt;SwingConstants.WEST&lt;/code&gt;
     *  &lt;li&gt;&lt;code&gt;SwingConstants.EAST&lt;/code&gt;
     *  &lt;li&gt;&lt;code&gt;SwingConstants.NORTH&lt;/code&gt;
     *  &lt;li&gt;&lt;code&gt;SwingConstants.SOUTH&lt;/code&gt;
     *  &lt;/ul&gt;
     * @param biasRet an array contain the bias that was checked
     * @return the location within the model that best represents the next
     *  location visual position
     * @exception BadLocationException
     * @exception IllegalArgumentException if &lt;code&gt;direction&lt;/code&gt; is invalid
     */
    static int getNextVisualPositionFrom(View v, int pos, Position.Bias b,
                                          Shape alloc, int direction,
                                          Position.Bias[] biasRet)
                             throws BadLocationException {
<span class="nc bnc" id="L996" title="All 2 branches missed.">        if (v.getViewCount() == 0) {</span>
            // Nothing to do.
<span class="nc" id="L998">            return pos;</span>
        }
<span class="nc bnc" id="L1000" title="All 4 branches missed.">        boolean top = (direction == SwingConstants.NORTH ||</span>
                       direction == SwingConstants.WEST);
        int retValue;
<span class="nc bnc" id="L1003" title="All 2 branches missed.">        if (pos == -1) {</span>
            // Start from the first View.
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            int childIndex = (top) ? v.getViewCount() - 1 : 0;</span>
<span class="nc" id="L1006">            View child = v.getView(childIndex);</span>
<span class="nc" id="L1007">            Shape childBounds = v.getChildAllocation(childIndex, alloc);</span>
<span class="nc" id="L1008">            retValue = child.getNextVisualPositionFrom(pos, b, childBounds,</span>
                                                       direction, biasRet);
<span class="nc bnc" id="L1010" title="All 6 branches missed.">            if (retValue == -1 &amp;&amp; !top &amp;&amp; v.getViewCount() &gt; 1) {</span>
                // Special case that should ONLY happen if first view
                // isn't valid (can happen when end position is put at
                // beginning of line.
<span class="nc" id="L1014">                child = v.getView(1);</span>
<span class="nc" id="L1015">                childBounds = v.getChildAllocation(1, alloc);</span>
<span class="nc" id="L1016">                retValue = child.getNextVisualPositionFrom(-1, biasRet[0],</span>
                                                           childBounds,
                                                           direction, biasRet);
            }
<span class="nc" id="L1020">        }</span>
        else {
<span class="nc bnc" id="L1022" title="All 2 branches missed.">            int increment = (top) ? -1 : 1;</span>
            int childIndex;
<span class="nc bnc" id="L1024" title="All 4 branches missed.">            if (b == Position.Bias.Backward &amp;&amp; pos &gt; 0) {</span>
<span class="nc" id="L1025">                childIndex = v.getViewIndex(pos - 1, Position.Bias.Forward);</span>
            }
            else {
<span class="nc" id="L1028">                childIndex = v.getViewIndex(pos, Position.Bias.Forward);</span>
            }
<span class="nc" id="L1030">            View child = v.getView(childIndex);</span>
<span class="nc" id="L1031">            Shape childBounds = v.getChildAllocation(childIndex, alloc);</span>
<span class="nc" id="L1032">            retValue = child.getNextVisualPositionFrom(pos, b, childBounds,</span>
                                                       direction, biasRet);
<span class="nc bnc" id="L1034" title="All 6 branches missed.">            if ((direction == SwingConstants.EAST ||</span>
                 direction == SwingConstants.WEST) &amp;&amp;
                (v instanceof CompositeView) &amp;&amp;
<span class="nc bnc" id="L1037" title="All 2 branches missed.">                ((CompositeView)v).flipEastAndWestAtEnds(pos, b)) {</span>
<span class="nc" id="L1038">                increment *= -1;</span>
            }
<span class="nc" id="L1040">            childIndex += increment;</span>
<span class="nc bnc" id="L1041" title="All 4 branches missed.">            if (retValue == -1 &amp;&amp; childIndex &gt;= 0 &amp;&amp;</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">                                  childIndex &lt; v.getViewCount()) {</span>
<span class="nc" id="L1043">                child = v.getView(childIndex);</span>
<span class="nc" id="L1044">                childBounds = v.getChildAllocation(childIndex, alloc);</span>
<span class="nc" id="L1045">                retValue = child.getNextVisualPositionFrom(</span>
                                     -1, b, childBounds, direction, biasRet);
                // If there is a bias change, it is a fake position
                // and we should skip it. This is usually the result
                // of two elements side be side flowing the same way.
<span class="nc bnc" id="L1050" title="All 4 branches missed.">                if (retValue == pos &amp;&amp; biasRet[0] != b) {</span>
<span class="nc" id="L1051">                    return getNextVisualPositionFrom(v, pos, biasRet[0],</span>
                                                     alloc, direction,
                                                     biasRet);
                }
            }
<span class="nc bnc" id="L1056" title="All 6 branches missed.">            else if (retValue != -1 &amp;&amp; biasRet[0] != b &amp;&amp;</span>
<span class="nc bnc" id="L1057" title="All 4 branches missed.">                     ((increment == 1 &amp;&amp; child.getEndOffset() == retValue) ||</span>
                      (increment == -1 &amp;&amp;
<span class="nc bnc" id="L1059" title="All 4 branches missed.">                       child.getStartOffset() == retValue)) &amp;&amp;</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">                     childIndex &gt;= 0 &amp;&amp; childIndex &lt; v.getViewCount()) {</span>
                // Reached the end of a view, make sure the next view
                // is a different direction.
<span class="nc" id="L1063">                child = v.getView(childIndex);</span>
<span class="nc" id="L1064">                childBounds = v.getChildAllocation(childIndex, alloc);</span>
<span class="nc" id="L1065">                Position.Bias originalBias = biasRet[0];</span>
<span class="nc" id="L1066">                int nextPos = child.getNextVisualPositionFrom(</span>
                                    -1, b, childBounds, direction, biasRet);
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                if (biasRet[0] == b) {</span>
<span class="nc" id="L1069">                    retValue = nextPos;</span>
                }
                else {
<span class="nc" id="L1072">                    biasRet[0] = originalBias;</span>
                }
            }
        }
<span class="nc" id="L1076">        return retValue;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>