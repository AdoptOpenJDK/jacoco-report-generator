<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BoxView.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">BoxView.java</span></div><h1>BoxView.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.io.PrintStream;
import java.util.Vector;
import java.awt.*;
import javax.swing.event.DocumentEvent;
import javax.swing.SizeRequirements;

/**
 * A view that arranges its children into a box shape by tiling
 * its children along an axis.  The box is somewhat like that
 * found in TeX where there is alignment of the
 * children, flexibility of the children is considered, etc.
 * This is a building block that might be useful to represent
 * things like a collection of lines, paragraphs,
 * lists, columns, pages, etc.  The axis along which the children are tiled is
 * considered the major axis.  The orthogonal axis is the minor axis.
 * &lt;p&gt;
 * Layout for each axis is handled separately by the methods
 * &lt;code&gt;layoutMajorAxis&lt;/code&gt; and &lt;code&gt;layoutMinorAxis&lt;/code&gt;.
 * Subclasses can change the layout algorithm by
 * reimplementing these methods.    These methods will be called
 * as necessary depending upon whether or not there is cached
 * layout information and the cache is considered
 * valid.  These methods are typically called if the given size
 * along the axis changes, or if &lt;code&gt;layoutChanged&lt;/code&gt; is
 * called to force an updated layout.  The &lt;code&gt;layoutChanged&lt;/code&gt;
 * method invalidates cached layout information, if there is any.
 * The requirements published to the parent view are calculated by
 * the methods &lt;code&gt;calculateMajorAxisRequirements&lt;/code&gt;
 * and  &lt;code&gt;calculateMinorAxisRequirements&lt;/code&gt;.
 * If the layout algorithm is changed, these methods will
 * likely need to be reimplemented.
 *
 * @author  Timothy Prinzing
 */
public class BoxView extends CompositeView {

    /**
     * Constructs a &lt;code&gt;BoxView&lt;/code&gt;.
     *
     * @param elem the element this view is responsible for
     * @param axis either &lt;code&gt;View.X_AXIS&lt;/code&gt; or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     */
    public BoxView(Element elem, int axis) {
<span class="nc" id="L70">        super(elem);</span>
<span class="nc" id="L71">        tempRect = new Rectangle();</span>
<span class="nc" id="L72">        this.majorAxis = axis;</span>

<span class="nc" id="L74">        majorOffsets = new int[0];</span>
<span class="nc" id="L75">        majorSpans = new int[0];</span>
<span class="nc" id="L76">        majorReqValid = false;</span>
<span class="nc" id="L77">        majorAllocValid = false;</span>
<span class="nc" id="L78">        minorOffsets = new int[0];</span>
<span class="nc" id="L79">        minorSpans = new int[0];</span>
<span class="nc" id="L80">        minorReqValid = false;</span>
<span class="nc" id="L81">        minorAllocValid = false;</span>
<span class="nc" id="L82">    }</span>

    /**
     * Fetches the tile axis property.  This is the axis along which
     * the child views are tiled.
     *
     * @return the major axis of the box, either
     *  &lt;code&gt;View.X_AXIS&lt;/code&gt; or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     *
     * @since 1.3
     */
    public int getAxis() {
<span class="nc" id="L94">        return majorAxis;</span>
    }

    /**
     * Sets the tile axis property.  This is the axis along which
     * the child views are tiled.
     *
     * @param axis either &lt;code&gt;View.X_AXIS&lt;/code&gt; or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     *
     * @since 1.3
     */
    public void setAxis(int axis) {
<span class="nc bnc" id="L106" title="All 2 branches missed.">        boolean axisChanged = (axis != majorAxis);</span>
<span class="nc" id="L107">        majorAxis = axis;</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (axisChanged) {</span>
<span class="nc" id="L109">            preferenceChanged(null, true, true);</span>
        }
<span class="nc" id="L111">    }</span>

    /**
     * Invalidates the layout along an axis.  This happens
     * automatically if the preferences have changed for
     * any of the child views.  In some cases the layout
     * may need to be recalculated when the preferences
     * have not changed.  The layout can be marked as
     * invalid by calling this method.  The layout will
     * be updated the next time the &lt;code&gt;setSize&lt;/code&gt; method
     * is called on this view (typically in paint).
     *
     * @param axis either &lt;code&gt;View.X_AXIS&lt;/code&gt; or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     *
     * @since 1.3
     */
    public void layoutChanged(int axis) {
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (axis == majorAxis) {</span>
<span class="nc" id="L129">            majorAllocValid = false;</span>
        } else {
<span class="nc" id="L131">            minorAllocValid = false;</span>
        }
<span class="nc" id="L133">    }</span>

    /**
     * Determines if the layout is valid along the given axis.
     *
     * @param axis either &lt;code&gt;View.X_AXIS&lt;/code&gt; or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     *
     * @since 1.4
     */
    protected boolean isLayoutValid(int axis) {
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (axis == majorAxis) {</span>
<span class="nc" id="L144">            return majorAllocValid;</span>
        } else {
<span class="nc" id="L146">            return minorAllocValid;</span>
        }
    }

    /**
     * Paints a child.  By default
     * that is all it does, but a subclass can use this to paint
     * things relative to the child.
     *
     * @param g the graphics context
     * @param alloc the allocated region to paint into
     * @param index the child index, &amp;gt;= 0 &amp;amp;&amp;amp; &amp;lt; getViewCount()
     */
    protected void paintChild(Graphics g, Rectangle alloc, int index) {
<span class="nc" id="L160">        View child = getView(index);</span>
<span class="nc" id="L161">        child.paint(g, alloc);</span>
<span class="nc" id="L162">    }</span>

    // --- View methods ---------------------------------------------

    /**
     * Invalidates the layout and resizes the cache of
     * requests/allocations.  The child allocations can still
     * be accessed for the old layout, but the new children
     * will have an offset and span of 0.
     *
     * @param index the starting index into the child views to insert
     *   the new views; this should be a value &amp;gt;= 0 and &amp;lt;= getViewCount
     * @param length the number of existing child views to remove;
     *   This should be a value &amp;gt;= 0 and &amp;lt;= (getViewCount() - offset)
     * @param elems the child views to add; this value can be
     *   &lt;code&gt;null&lt;/code&gt;to indicate no children are being added
     *   (useful to remove)
     */
    public void replace(int index, int length, View[] elems) {
<span class="nc" id="L181">        super.replace(index, length, elems);</span>

        // invalidate cache
<span class="nc bnc" id="L184" title="All 2 branches missed.">        int nInserted = (elems != null) ? elems.length : 0;</span>
<span class="nc" id="L185">        majorOffsets = updateLayoutArray(majorOffsets, index, nInserted);</span>
<span class="nc" id="L186">        majorSpans = updateLayoutArray(majorSpans, index, nInserted);</span>
<span class="nc" id="L187">        majorReqValid = false;</span>
<span class="nc" id="L188">        majorAllocValid = false;</span>
<span class="nc" id="L189">        minorOffsets = updateLayoutArray(minorOffsets, index, nInserted);</span>
<span class="nc" id="L190">        minorSpans = updateLayoutArray(minorSpans, index, nInserted);</span>
<span class="nc" id="L191">        minorReqValid = false;</span>
<span class="nc" id="L192">        minorAllocValid = false;</span>
<span class="nc" id="L193">    }</span>

    /**
     * Resizes the given layout array to match the new number of
     * child views.  The current number of child views are used to
     * produce the new array.  The contents of the old array are
     * inserted into the new array at the appropriate places so that
     * the old layout information is transferred to the new array.
     *
     * @param oldArray the original layout array
     * @param offset location where new views will be inserted
     * @param nInserted the number of child views being inserted;
     *          therefore the number of blank spaces to leave in the
     *          new array at location &lt;code&gt;offset&lt;/code&gt;
     * @return the new layout array
     */
    int[] updateLayoutArray(int[] oldArray, int offset, int nInserted) {
<span class="nc" id="L210">        int n = getViewCount();</span>
<span class="nc" id="L211">        int[] newArray = new int[n];</span>

<span class="nc" id="L213">        System.arraycopy(oldArray, 0, newArray, 0, offset);</span>
<span class="nc" id="L214">        System.arraycopy(oldArray, offset,</span>
                         newArray, offset + nInserted, n - nInserted - offset);
<span class="nc" id="L216">        return newArray;</span>
    }

    /**
     * Forwards the given &lt;code&gt;DocumentEvent&lt;/code&gt; to the child views
     * that need to be notified of the change to the model.
     * If a child changed its requirements and the allocation
     * was valid prior to forwarding the portion of the box
     * from the starting child to the end of the box will
     * be repainted.
     *
     * @param ec changes to the element this view is responsible
     *  for (may be &lt;code&gt;null&lt;/code&gt; if there were no changes)
     * @param e the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see #insertUpdate
     * @see #removeUpdate
     * @see #changedUpdate
     * @since 1.3
     */
    protected void forwardUpdate(DocumentEvent.ElementChange ec,
                                 DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc" id="L239">        boolean wasValid = isLayoutValid(majorAxis);</span>
<span class="nc" id="L240">        super.forwardUpdate(ec, e, a, f);</span>

        // determine if a repaint is needed
<span class="nc bnc" id="L243" title="All 4 branches missed.">        if (wasValid &amp;&amp; (! isLayoutValid(majorAxis))) {</span>
            // Repaint is needed because one of the tiled children
            // have changed their span along the major axis.  If there
            // is a hosting component and an allocated shape we repaint.
<span class="nc" id="L247">            Component c = getContainer();</span>
<span class="nc bnc" id="L248" title="All 4 branches missed.">            if ((a != null) &amp;&amp; (c != null)) {</span>
<span class="nc" id="L249">                int pos = e.getOffset();</span>
<span class="nc" id="L250">                int index = getViewIndexAtPosition(pos);</span>
<span class="nc" id="L251">                Rectangle alloc = getInsideAllocation(a);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                if (majorAxis == X_AXIS) {</span>
<span class="nc" id="L253">                    alloc.x += majorOffsets[index];</span>
<span class="nc" id="L254">                    alloc.width -= majorOffsets[index];</span>
                } else {
<span class="nc" id="L256">                    alloc.y += minorOffsets[index];</span>
<span class="nc" id="L257">                    alloc.height -= minorOffsets[index];</span>
                }
<span class="nc" id="L259">                c.repaint(alloc.x, alloc.y, alloc.width, alloc.height);</span>
            }
        }
<span class="nc" id="L262">    }</span>

    /**
     * This is called by a child to indicate its
     * preferred span has changed.  This is implemented to
     * throw away cached layout information so that new
     * calculations will be done the next time the children
     * need an allocation.
     *
     * @param child the child view
     * @param width true if the width preference should change
     * @param height true if the height preference should change
     */
    public void preferenceChanged(View child, boolean width, boolean height) {
<span class="nc bnc" id="L276" title="All 2 branches missed.">        boolean majorChanged = (majorAxis == X_AXIS) ? width : height;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        boolean minorChanged = (majorAxis == X_AXIS) ? height : width;</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (majorChanged) {</span>
<span class="nc" id="L279">            majorReqValid = false;</span>
<span class="nc" id="L280">            majorAllocValid = false;</span>
        }
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (minorChanged) {</span>
<span class="nc" id="L283">            minorReqValid = false;</span>
<span class="nc" id="L284">            minorAllocValid = false;</span>
        }
<span class="nc" id="L286">        super.preferenceChanged(child, width, height);</span>
<span class="nc" id="L287">    }</span>

    /**
     * Gets the resize weight.  A value of 0 or less is not resizable.
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt; or
     *          &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @return the weight
     * @exception IllegalArgumentException for an invalid axis
     */
    public int getResizeWeight(int axis) {
<span class="nc" id="L298">        checkRequests(axis);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (axis == majorAxis) {</span>
<span class="nc bnc" id="L300" title="All 4 branches missed.">            if ((majorRequest.preferred != majorRequest.minimum) ||</span>
                (majorRequest.preferred != majorRequest.maximum)) {
<span class="nc" id="L302">                return 1;</span>
            }
        } else {
<span class="nc bnc" id="L305" title="All 4 branches missed.">            if ((minorRequest.preferred != minorRequest.minimum) ||</span>
                (minorRequest.preferred != minorRequest.maximum)) {
<span class="nc" id="L307">                return 1;</span>
            }
        }
<span class="nc" id="L310">        return 0;</span>
    }

    /**
     * Sets the size of the view along an axis.  This should cause
     * layout of the view along the given axis.
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt; or
     *          &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @param span the span to layout to &gt;= 0
     */
    void setSpanOnAxis(int axis, float span) {
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (axis == majorAxis) {</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (majorSpan != (int) span) {</span>
<span class="nc" id="L324">                majorAllocValid = false;</span>
            }
<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (! majorAllocValid) {</span>
                // layout the major axis
<span class="nc" id="L328">                majorSpan = (int) span;</span>
<span class="nc" id="L329">                checkRequests(majorAxis);</span>
<span class="nc" id="L330">                layoutMajorAxis(majorSpan, axis, majorOffsets, majorSpans);</span>
<span class="nc" id="L331">                majorAllocValid = true;</span>

                // flush changes to the children
<span class="nc" id="L334">                updateChildSizes();</span>
            }
        } else {
<span class="nc bnc" id="L337" title="All 2 branches missed.">            if (((int) span) != minorSpan) {</span>
<span class="nc" id="L338">                minorAllocValid = false;</span>
            }
<span class="nc bnc" id="L340" title="All 2 branches missed.">            if (! minorAllocValid) {</span>
                // layout the minor axis
<span class="nc" id="L342">                minorSpan = (int) span;</span>
<span class="nc" id="L343">                checkRequests(axis);</span>
<span class="nc" id="L344">                layoutMinorAxis(minorSpan, axis, minorOffsets, minorSpans);</span>
<span class="nc" id="L345">                minorAllocValid = true;</span>

                // flush changes to the children
<span class="nc" id="L348">                updateChildSizes();</span>
            }
        }
<span class="nc" id="L351">    }</span>

    /**
     * Propagates the current allocations to the child views.
     */
    void updateChildSizes() {
<span class="nc" id="L357">        int n = getViewCount();</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">        if (majorAxis == X_AXIS) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L360">                View v = getView(i);</span>
<span class="nc" id="L361">                v.setSize((float) majorSpans[i], (float) minorSpans[i]);</span>
            }
        } else {
<span class="nc bnc" id="L364" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L365">                View v = getView(i);</span>
<span class="nc" id="L366">                v.setSize((float) minorSpans[i], (float) majorSpans[i]);</span>
            }
        }
<span class="nc" id="L369">    }</span>

    /**
     * Returns the size of the view along an axis.  This is implemented
     * to return zero.
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt; or
     *          &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @return the current span of the view along the given axis, &gt;= 0
     */
    float getSpanOnAxis(int axis) {
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (axis == majorAxis) {</span>
<span class="nc" id="L381">            return majorSpan;</span>
        } else {
<span class="nc" id="L383">            return minorSpan;</span>
        }
    }

    /**
     * Sets the size of the view.  This should cause
     * layout of the view if the view caches any layout
     * information.  This is implemented to call the
     * layout method with the sizes inside of the insets.
     *
     * @param width the width &amp;gt;= 0
     * @param height the height &amp;gt;= 0
     */
    public void setSize(float width, float height) {
<span class="nc" id="L397">        layout(Math.max(0, (int)(width - getLeftInset() - getRightInset())),</span>
<span class="nc" id="L398">               Math.max(0, (int)(height - getTopInset() - getBottomInset())));</span>
<span class="nc" id="L399">    }</span>

    /**
     * Renders the &lt;code&gt;BoxView&lt;/code&gt; using the given
     * rendering surface and area
     * on that surface.  Only the children that intersect
     * the clip bounds of the given &lt;code&gt;Graphics&lt;/code&gt;
     * will be rendered.
     *
     * @param g the rendering surface to use
     * @param allocation the allocated region to render into
     * @see View#paint
     */
    public void paint(Graphics g, Shape allocation) {
<span class="nc bnc" id="L413" title="All 2 branches missed.">        Rectangle alloc = (allocation instanceof Rectangle) ?</span>
<span class="nc" id="L414">                           (Rectangle)allocation : allocation.getBounds();</span>
<span class="nc" id="L415">        int n = getViewCount();</span>
<span class="nc" id="L416">        int x = alloc.x + getLeftInset();</span>
<span class="nc" id="L417">        int y = alloc.y + getTopInset();</span>
<span class="nc" id="L418">        Rectangle clip = g.getClipBounds();</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L420">            tempRect.x = x + getOffset(X_AXIS, i);</span>
<span class="nc" id="L421">            tempRect.y = y + getOffset(Y_AXIS, i);</span>
<span class="nc" id="L422">            tempRect.width = getSpan(X_AXIS, i);</span>
<span class="nc" id="L423">            tempRect.height = getSpan(Y_AXIS, i);</span>
<span class="nc" id="L424">            int trx0 = tempRect.x, trx1 = trx0 + tempRect.width;</span>
<span class="nc" id="L425">            int try0 = tempRect.y, try1 = try0 + tempRect.height;</span>
<span class="nc" id="L426">            int crx0 = clip.x, crx1 = crx0 + clip.width;</span>
<span class="nc" id="L427">            int cry0 = clip.y, cry1 = cry0 + clip.height;</span>
            // We should paint views that intersect with clipping region
            // even if the intersection has no inside points (is a line).
            // This is needed for supporting views that have zero width, like
            // views that contain only combining marks.
<span class="nc bnc" id="L432" title="All 8 branches missed.">            if ((trx1 &gt;= crx0) &amp;&amp; (try1 &gt;= cry0) &amp;&amp; (crx1 &gt;= trx0) &amp;&amp; (cry1 &gt;= try0)) {</span>
<span class="nc" id="L433">                paintChild(g, tempRect, i);</span>
            }
        }
<span class="nc" id="L436">    }</span>

    /**
     * Fetches the allocation for the given child view.
     * This enables finding out where various views
     * are located.  This is implemented to return
     * &lt;code&gt;null&lt;/code&gt; if the layout is invalid,
     * otherwise the superclass behavior is executed.
     *
     * @param index the index of the child, &amp;gt;= 0 &amp;amp;&amp;amp; &amp;gt; getViewCount()
     * @param a  the allocation to this view
     * @return the allocation to the child; or &lt;code&gt;null&lt;/code&gt;
     *          if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;;
     *          or &lt;code&gt;null&lt;/code&gt; if the layout is invalid
     */
    public Shape getChildAllocation(int index, Shape a) {
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (a != null) {</span>
<span class="nc" id="L453">            Shape ca = super.getChildAllocation(index, a);</span>
<span class="nc bnc" id="L454" title="All 4 branches missed.">            if ((ca != null) &amp;&amp; (! isAllocationValid())) {</span>
                // The child allocation may not have been set yet.
<span class="nc bnc" id="L456" title="All 2 branches missed.">                Rectangle r = (ca instanceof Rectangle) ?</span>
<span class="nc" id="L457">                    (Rectangle) ca : ca.getBounds();</span>
<span class="nc bnc" id="L458" title="All 4 branches missed.">                if ((r.width == 0) &amp;&amp; (r.height == 0)) {</span>
<span class="nc" id="L459">                    return null;</span>
                }
            }
<span class="nc" id="L462">            return ca;</span>
        }
<span class="nc" id="L464">        return null;</span>
    }

    /**
     * Provides a mapping from the document model coordinate space
     * to the coordinate space of the view mapped to it.  This makes
     * sure the allocation is valid before calling the superclass.
     *
     * @param pos the position to convert &amp;gt;= 0
     * @param a the allocated region to render into
     * @return the bounding box of the given position
     * @exception BadLocationException  if the given position does
     *  not represent a valid location in the associated document
     * @see View#modelToView
     */
    public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (! isAllocationValid()) {</span>
<span class="nc" id="L481">            Rectangle alloc = a.getBounds();</span>
<span class="nc" id="L482">            setSize(alloc.width, alloc.height);</span>
        }
<span class="nc" id="L484">        return super.modelToView(pos, a, b);</span>
    }

    /**
     * Provides a mapping from the view coordinate space to the logical
     * coordinate space of the model.
     *
     * @param x   x coordinate of the view location to convert &amp;gt;= 0
     * @param y   y coordinate of the view location to convert &amp;gt;= 0
     * @param a the allocated region to render into
     * @return the location within the model that best represents the
     *  given point in the view &amp;gt;= 0
     * @see View#viewToModel
     */
    public int viewToModel(float x, float y, Shape a, Position.Bias[] bias) {
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (! isAllocationValid()) {</span>
<span class="nc" id="L500">            Rectangle alloc = a.getBounds();</span>
<span class="nc" id="L501">            setSize(alloc.width, alloc.height);</span>
        }
<span class="nc" id="L503">        return super.viewToModel(x, y, a, bias);</span>
    }

    /**
     * Determines the desired alignment for this view along an
     * axis.  This is implemented to give the total alignment
     * needed to position the children with the alignment points
     * lined up along the axis orthogonal to the axis that is
     * being tiled.  The axis being tiled will request to be
     * centered (i.e. 0.5f).
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt;
     *   or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @return the desired alignment &amp;gt;= 0.0f &amp;amp;&amp;amp; &amp;lt;= 1.0f; this should
     *   be a value between 0.0 and 1.0 where 0 indicates alignment at the
     *   origin and 1.0 indicates alignment to the full span
     *   away from the origin; an alignment of 0.5 would be the
     *   center of the view
     * @exception IllegalArgumentException for an invalid axis
     */
    public float getAlignment(int axis) {
<span class="nc" id="L524">        checkRequests(axis);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (axis == majorAxis) {</span>
<span class="nc" id="L526">            return majorRequest.alignment;</span>
        } else {
<span class="nc" id="L528">            return minorRequest.alignment;</span>
        }
    }

    /**
     * Determines the preferred span for this view along an
     * axis.
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt;
     *           or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @return   the span the view would like to be rendered into &amp;gt;= 0;
     *           typically the view is told to render into the span
     *           that is returned, although there is no guarantee;
     *           the parent may choose to resize or break the view
     * @exception IllegalArgumentException for an invalid axis type
     */
    public float getPreferredSpan(int axis) {
<span class="nc" id="L545">        checkRequests(axis);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">        float marginSpan = (axis == X_AXIS) ? getLeftInset() + getRightInset() :</span>
<span class="nc" id="L547">            getTopInset() + getBottomInset();</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (axis == majorAxis) {</span>
<span class="nc" id="L549">            return ((float)majorRequest.preferred) + marginSpan;</span>
        } else {
<span class="nc" id="L551">            return ((float)minorRequest.preferred) + marginSpan;</span>
        }
    }

    /**
     * Determines the minimum span for this view along an
     * axis.
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt;
     *           or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @return  the span the view would like to be rendered into &amp;gt;= 0;
     *           typically the view is told to render into the span
     *           that is returned, although there is no guarantee;
     *           the parent may choose to resize or break the view
     * @exception IllegalArgumentException for an invalid axis type
     */
    public float getMinimumSpan(int axis) {
<span class="nc" id="L568">        checkRequests(axis);</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">        float marginSpan = (axis == X_AXIS) ? getLeftInset() + getRightInset() :</span>
<span class="nc" id="L570">            getTopInset() + getBottomInset();</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (axis == majorAxis) {</span>
<span class="nc" id="L572">            return ((float)majorRequest.minimum) + marginSpan;</span>
        } else {
<span class="nc" id="L574">            return ((float)minorRequest.minimum) + marginSpan;</span>
        }
    }

    /**
     * Determines the maximum span for this view along an
     * axis.
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt;
     *           or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @return   the span the view would like to be rendered into &amp;gt;= 0;
     *           typically the view is told to render into the span
     *           that is returned, although there is no guarantee;
     *           the parent may choose to resize or break the view
     * @exception IllegalArgumentException for an invalid axis type
     */
    public float getMaximumSpan(int axis) {
<span class="nc" id="L591">        checkRequests(axis);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">        float marginSpan = (axis == X_AXIS) ? getLeftInset() + getRightInset() :</span>
<span class="nc" id="L593">            getTopInset() + getBottomInset();</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (axis == majorAxis) {</span>
<span class="nc" id="L595">            return ((float)majorRequest.maximum) + marginSpan;</span>
        } else {
<span class="nc" id="L597">            return ((float)minorRequest.maximum) + marginSpan;</span>
        }
    }

    // --- local methods ----------------------------------------------------

    /**
     * Are the allocations for the children still
     * valid?
     *
     * @return true if allocations still valid
     */
    protected boolean isAllocationValid() {
<span class="nc bnc" id="L610" title="All 4 branches missed.">        return (majorAllocValid &amp;&amp; minorAllocValid);</span>
    }

    /**
     * Determines if a point falls before an allocated region.
     *
     * @param x the X coordinate &amp;gt;= 0
     * @param y the Y coordinate &amp;gt;= 0
     * @param innerAlloc the allocated region; this is the area
     *   inside of the insets
     * @return true if the point lies before the region else false
     */
    protected boolean isBefore(int x, int y, Rectangle innerAlloc) {
<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (majorAxis == View.X_AXIS) {</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">            return (x &lt; innerAlloc.x);</span>
        } else {
<span class="nc bnc" id="L626" title="All 2 branches missed.">            return (y &lt; innerAlloc.y);</span>
        }
    }

    /**
     * Determines if a point falls after an allocated region.
     *
     * @param x the X coordinate &amp;gt;= 0
     * @param y the Y coordinate &amp;gt;= 0
     * @param innerAlloc the allocated region; this is the area
     *   inside of the insets
     * @return true if the point lies after the region else false
     */
    protected boolean isAfter(int x, int y, Rectangle innerAlloc) {
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (majorAxis == View.X_AXIS) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">            return (x &gt; (innerAlloc.width + innerAlloc.x));</span>
        } else {
<span class="nc bnc" id="L643" title="All 2 branches missed.">            return (y &gt; (innerAlloc.height + innerAlloc.y));</span>
        }
    }

    /**
     * Fetches the child view at the given coordinates.
     *
     * @param x the X coordinate &amp;gt;= 0
     * @param y the Y coordinate &amp;gt;= 0
     * @param alloc the parents inner allocation on entry, which should
     *   be changed to the child's allocation on exit
     * @return the view
     */
    protected View getViewAtPoint(int x, int y, Rectangle alloc) {
<span class="nc" id="L657">        int n = getViewCount();</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">        if (majorAxis == View.X_AXIS) {</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">            if (x &lt; (alloc.x + majorOffsets[0])) {</span>
<span class="nc" id="L660">                childAllocation(0, alloc);</span>
<span class="nc" id="L661">                return getView(0);</span>
            }
<span class="nc bnc" id="L663" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">                if (x &lt; (alloc.x + majorOffsets[i])) {</span>
<span class="nc" id="L665">                    childAllocation(i - 1, alloc);</span>
<span class="nc" id="L666">                    return getView(i - 1);</span>
                }
            }
<span class="nc" id="L669">            childAllocation(n - 1, alloc);</span>
<span class="nc" id="L670">            return getView(n - 1);</span>
        } else {
<span class="nc bnc" id="L672" title="All 2 branches missed.">            if (y &lt; (alloc.y + majorOffsets[0])) {</span>
<span class="nc" id="L673">                childAllocation(0, alloc);</span>
<span class="nc" id="L674">                return getView(0);</span>
            }
<span class="nc bnc" id="L676" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">                if (y &lt; (alloc.y + majorOffsets[i])) {</span>
<span class="nc" id="L678">                    childAllocation(i - 1, alloc);</span>
<span class="nc" id="L679">                    return getView(i - 1);</span>
                }
            }
<span class="nc" id="L682">            childAllocation(n - 1, alloc);</span>
<span class="nc" id="L683">            return getView(n - 1);</span>
        }
    }

    /**
     * Allocates a region for a child view.
     *
     * @param index the index of the child view to
     *   allocate, &amp;gt;= 0 &amp;amp;&amp;amp; &amp;lt; getViewCount()
     * @param alloc the allocated region
     */
    protected void childAllocation(int index, Rectangle alloc) {
<span class="nc" id="L695">        alloc.x += getOffset(X_AXIS, index);</span>
<span class="nc" id="L696">        alloc.y += getOffset(Y_AXIS, index);</span>
<span class="nc" id="L697">        alloc.width = getSpan(X_AXIS, index);</span>
<span class="nc" id="L698">        alloc.height = getSpan(Y_AXIS, index);</span>
<span class="nc" id="L699">    }</span>

    /**
     * Perform layout on the box
     *
     * @param width the width (inside of the insets) &amp;gt;= 0
     * @param height the height (inside of the insets) &amp;gt;= 0
     */
    protected void layout(int width, int height) {
<span class="nc" id="L708">        setSpanOnAxis(X_AXIS, width);</span>
<span class="nc" id="L709">        setSpanOnAxis(Y_AXIS, height);</span>
<span class="nc" id="L710">    }</span>

    /**
     * Returns the current width of the box.  This is the width that
     * it was last allocated.
     * @return the current width of the box
     */
    public int getWidth() {
        int span;
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (majorAxis == X_AXIS) {</span>
<span class="nc" id="L720">            span = majorSpan;</span>
        } else {
<span class="nc" id="L722">            span = minorSpan;</span>
        }
<span class="nc" id="L724">        span += getLeftInset() - getRightInset();</span>
<span class="nc" id="L725">        return span;</span>
    }

    /**
     * Returns the current height of the box.  This is the height that
     * it was last allocated.
     * @return the current height of the box
     */
    public int getHeight() {
        int span;
<span class="nc bnc" id="L735" title="All 2 branches missed.">        if (majorAxis == Y_AXIS) {</span>
<span class="nc" id="L736">            span = majorSpan;</span>
        } else {
<span class="nc" id="L738">            span = minorSpan;</span>
        }
<span class="nc" id="L740">        span += getTopInset() - getBottomInset();</span>
<span class="nc" id="L741">        return span;</span>
    }

    /**
     * Performs layout for the major axis of the box (i.e. the
     * axis that it represents). The results of the layout (the
     * offset and span for each children) are placed in the given
     * arrays which represent the allocations to the children
     * along the major axis.
     *
     * @param targetSpan the total span given to the view, which
     *  would be used to layout the children
     * @param axis the axis being layed out
     * @param offsets the offsets from the origin of the view for
     *  each of the child views; this is a return value and is
     *  filled in by the implementation of this method
     * @param spans the span of each child view; this is a return
     *  value and is filled in by the implementation of this method
     */
    protected void layoutMajorAxis(int targetSpan, int axis, int[] offsets, int[] spans) {
        /*
         * first pass, calculate the preferred sizes
         * and the flexibility to adjust the sizes.
         */
<span class="nc" id="L765">        long preferred = 0;</span>
<span class="nc" id="L766">        int n = getViewCount();</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L768">            View v = getView(i);</span>
<span class="nc" id="L769">            spans[i] = (int) v.getPreferredSpan(axis);</span>
<span class="nc" id="L770">            preferred += spans[i];</span>
        }

        /*
         * Second pass, expand or contract by as much as possible to reach
         * the target span.
         */

        // determine the adjustment to be made
<span class="nc" id="L779">        long desiredAdjustment = targetSpan - preferred;</span>
<span class="nc" id="L780">        float adjustmentFactor = 0.0f;</span>
<span class="nc" id="L781">        int[] diffs = null;</span>

<span class="nc bnc" id="L783" title="All 2 branches missed.">        if (desiredAdjustment != 0) {</span>
<span class="nc" id="L784">            long totalSpan = 0;</span>
<span class="nc" id="L785">            diffs = new int[n];</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L787">                View v = getView(i);</span>
                int tmp;
<span class="nc bnc" id="L789" title="All 2 branches missed.">                if (desiredAdjustment &lt; 0) {</span>
<span class="nc" id="L790">                    tmp = (int)v.getMinimumSpan(axis);</span>
<span class="nc" id="L791">                    diffs[i] = spans[i] - tmp;</span>
                } else {
<span class="nc" id="L793">                    tmp = (int)v.getMaximumSpan(axis);</span>
<span class="nc" id="L794">                    diffs[i] = tmp - spans[i];</span>
                }
<span class="nc" id="L796">                totalSpan += tmp;</span>
            }

<span class="nc" id="L799">            float maximumAdjustment = Math.abs(totalSpan - preferred);</span>
<span class="nc" id="L800">                adjustmentFactor = desiredAdjustment / maximumAdjustment;</span>
<span class="nc" id="L801">                adjustmentFactor = Math.min(adjustmentFactor, 1.0f);</span>
<span class="nc" id="L802">                adjustmentFactor = Math.max(adjustmentFactor, -1.0f);</span>
            }

        // make the adjustments
<span class="nc" id="L806">        int totalOffset = 0;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L808">            offsets[i] = totalOffset;</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">            if (desiredAdjustment != 0) {</span>
<span class="nc" id="L810">                float adjF = adjustmentFactor * diffs[i];</span>
<span class="nc" id="L811">                spans[i] += Math.round(adjF);</span>
            }
<span class="nc" id="L813">            totalOffset = (int) Math.min((long) totalOffset + (long) spans[i], Integer.MAX_VALUE);</span>
        }
<span class="nc" id="L815">    }</span>

    /**
     * Performs layout for the minor axis of the box (i.e. the
     * axis orthogonal to the axis that it represents). The results
     * of the layout (the offset and span for each children) are
     * placed in the given arrays which represent the allocations to
     * the children along the minor axis.
     *
     * @param targetSpan the total span given to the view, which
     *  would be used to layout the children
     * @param axis the axis being layed out
     * @param offsets the offsets from the origin of the view for
     *  each of the child views; this is a return value and is
     *  filled in by the implementation of this method
     * @param spans the span of each child view; this is a return
     *  value and is filled in by the implementation of this method
     */
    protected void layoutMinorAxis(int targetSpan, int axis, int[] offsets, int[] spans) {
<span class="nc" id="L834">        int n = getViewCount();</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L836">            View v = getView(i);</span>
<span class="nc" id="L837">            int max = (int) v.getMaximumSpan(axis);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">            if (max &lt; targetSpan) {</span>
                // can't make the child this wide, align it
<span class="nc" id="L840">                float align = v.getAlignment(axis);</span>
<span class="nc" id="L841">                offsets[i] = (int) ((targetSpan - max) * align);</span>
<span class="nc" id="L842">                spans[i] = max;</span>
<span class="nc" id="L843">            } else {</span>
                // make it the target width, or as small as it can get.
<span class="nc" id="L845">                int min = (int)v.getMinimumSpan(axis);</span>
<span class="nc" id="L846">                offsets[i] = 0;</span>
<span class="nc" id="L847">                spans[i] = Math.max(min, targetSpan);</span>
            }
        }
<span class="nc" id="L850">    }</span>

    /**
     * Calculates the size requirements for the major axis
     * &lt;code&gt;axis&lt;/code&gt;.
     *
     * @param axis the axis being studied
     * @param r the &lt;code&gt;SizeRequirements&lt;/code&gt; object;
     *          if &lt;code&gt;null&lt;/code&gt; one will be created
     * @return the newly initialized &lt;code&gt;SizeRequirements&lt;/code&gt; object
     * @see javax.swing.SizeRequirements
     */
    protected SizeRequirements calculateMajorAxisRequirements(int axis, SizeRequirements r) {
        // calculate tiled request
<span class="nc" id="L864">        float min = 0;</span>
<span class="nc" id="L865">        float pref = 0;</span>
<span class="nc" id="L866">        float max = 0;</span>

<span class="nc" id="L868">        int n = getViewCount();</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L870">            View v = getView(i);</span>
<span class="nc" id="L871">            min += v.getMinimumSpan(axis);</span>
<span class="nc" id="L872">            pref += v.getPreferredSpan(axis);</span>
<span class="nc" id="L873">            max += v.getMaximumSpan(axis);</span>
        }

<span class="nc bnc" id="L876" title="All 2 branches missed.">        if (r == null) {</span>
<span class="nc" id="L877">            r = new SizeRequirements();</span>
        }
<span class="nc" id="L879">        r.alignment = 0.5f;</span>
<span class="nc" id="L880">        r.minimum = (int) min;</span>
<span class="nc" id="L881">        r.preferred = (int) pref;</span>
<span class="nc" id="L882">        r.maximum = (int) max;</span>
<span class="nc" id="L883">        return r;</span>
    }

    /**
     * Calculates the size requirements for the minor axis
     * &lt;code&gt;axis&lt;/code&gt;.
     *
     * @param axis the axis being studied
     * @param r the &lt;code&gt;SizeRequirements&lt;/code&gt; object;
     *          if &lt;code&gt;null&lt;/code&gt; one will be created
     * @return the newly initialized &lt;code&gt;SizeRequirements&lt;/code&gt; object
     * @see javax.swing.SizeRequirements
     */
    protected SizeRequirements calculateMinorAxisRequirements(int axis, SizeRequirements r) {
<span class="nc" id="L897">        int min = 0;</span>
<span class="nc" id="L898">        long pref = 0;</span>
<span class="nc" id="L899">        int max = Integer.MAX_VALUE;</span>
<span class="nc" id="L900">        int n = getViewCount();</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L902">            View v = getView(i);</span>
<span class="nc" id="L903">            min = Math.max((int) v.getMinimumSpan(axis), min);</span>
<span class="nc" id="L904">            pref = Math.max((int) v.getPreferredSpan(axis), pref);</span>
<span class="nc" id="L905">            max = Math.max((int) v.getMaximumSpan(axis), max);</span>
        }

<span class="nc bnc" id="L908" title="All 2 branches missed.">        if (r == null) {</span>
<span class="nc" id="L909">            r = new SizeRequirements();</span>
<span class="nc" id="L910">            r.alignment = 0.5f;</span>
        }
<span class="nc" id="L912">        r.preferred = (int) pref;</span>
<span class="nc" id="L913">        r.minimum = min;</span>
<span class="nc" id="L914">        r.maximum = max;</span>
<span class="nc" id="L915">        return r;</span>
    }

    /**
     * Checks the request cache and update if needed.
     * @param axis the axis being studied
     * @exception IllegalArgumentException if &lt;code&gt;axis&lt;/code&gt; is
     *  neither &lt;code&gt;View.X_AXIS&lt;/code&gt; nor &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     */
    void checkRequests(int axis) {
<span class="nc bnc" id="L925" title="All 4 branches missed.">        if ((axis != X_AXIS) &amp;&amp; (axis != Y_AXIS)) {</span>
<span class="nc" id="L926">            throw new IllegalArgumentException(&quot;Invalid axis: &quot; + axis);</span>
        }
<span class="nc bnc" id="L928" title="All 2 branches missed.">        if (axis == majorAxis) {</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">            if (!majorReqValid) {</span>
<span class="nc" id="L930">                majorRequest = calculateMajorAxisRequirements(axis,</span>
                                                              majorRequest);
<span class="nc" id="L932">                majorReqValid = true;</span>
            }
<span class="nc bnc" id="L934" title="All 2 branches missed.">        } else if (! minorReqValid) {</span>
<span class="nc" id="L935">            minorRequest = calculateMinorAxisRequirements(axis, minorRequest);</span>
<span class="nc" id="L936">            minorReqValid = true;</span>
        }
<span class="nc" id="L938">    }</span>

    /**
     * Computes the location and extent of each child view
     * in this &lt;code&gt;BoxView&lt;/code&gt; given the &lt;code&gt;targetSpan&lt;/code&gt;,
     * which is the width (or height) of the region we have to
     * work with.
     *
     * @param targetSpan the total span given to the view, which
     *  would be used to layout the children
     * @param axis the axis being studied, either
     *          &lt;code&gt;View.X_AXIS&lt;/code&gt; or &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @param offsets an empty array filled by this method with
     *          values specifying the location  of each child view
     * @param spans  an empty array filled by this method with
     *          values specifying the extent of each child view
     */
    protected void baselineLayout(int targetSpan, int axis, int[] offsets, int[] spans) {
<span class="nc" id="L956">        int totalAscent = (int)(targetSpan * getAlignment(axis));</span>
<span class="nc" id="L957">        int totalDescent = targetSpan - totalAscent;</span>

<span class="nc" id="L959">        int n = getViewCount();</span>

<span class="nc bnc" id="L961" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L962">            View v = getView(i);</span>
<span class="nc" id="L963">            float align = v.getAlignment(axis);</span>
            float viewSpan;

<span class="nc bnc" id="L966" title="All 2 branches missed.">            if (v.getResizeWeight(axis) &gt; 0) {</span>
                // if resizable then resize to the best fit

                // the smallest span possible
<span class="nc" id="L970">                float minSpan = v.getMinimumSpan(axis);</span>
                // the largest span possible
<span class="nc" id="L972">                float maxSpan = v.getMaximumSpan(axis);</span>

<span class="nc bnc" id="L974" title="All 2 branches missed.">                if (align == 0.0f) {</span>
                    // if the alignment is 0 then we need to fit into the descent
<span class="nc" id="L976">                    viewSpan = Math.max(Math.min(maxSpan, totalDescent), minSpan);</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">                } else if (align == 1.0f) {</span>
                    // if the alignment is 1 then we need to fit into the ascent
<span class="nc" id="L979">                    viewSpan = Math.max(Math.min(maxSpan, totalAscent), minSpan);</span>
                } else {
                    // figure out the span that we must fit into
<span class="nc" id="L982">                    float fitSpan = Math.min(totalAscent / align,</span>
                                             totalDescent / (1.0f - align));
                    // fit into the calculated span
<span class="nc" id="L985">                    viewSpan = Math.max(Math.min(maxSpan, fitSpan), minSpan);</span>
                }
<span class="nc" id="L987">            } else {</span>
                // otherwise use the preferred spans
<span class="nc" id="L989">                viewSpan = v.getPreferredSpan(axis);</span>
            }

<span class="nc" id="L992">            offsets[i] = totalAscent - (int)(viewSpan * align);</span>
<span class="nc" id="L993">            spans[i] = (int)viewSpan;</span>
        }
<span class="nc" id="L995">    }</span>

    /**
     * Calculates the size requirements for this &lt;code&gt;BoxView&lt;/code&gt;
     * by examining the size of each child view.
     *
     * @param axis the axis being studied
     * @param r the &lt;code&gt;SizeRequirements&lt;/code&gt; object;
     *          if &lt;code&gt;null&lt;/code&gt; one will be created
     * @return the newly initialized &lt;code&gt;SizeRequirements&lt;/code&gt; object
     */
    protected SizeRequirements baselineRequirements(int axis, SizeRequirements r) {
<span class="nc" id="L1007">        SizeRequirements totalAscent = new SizeRequirements();</span>
<span class="nc" id="L1008">        SizeRequirements totalDescent = new SizeRequirements();</span>

<span class="nc bnc" id="L1010" title="All 2 branches missed.">        if (r == null) {</span>
<span class="nc" id="L1011">            r = new SizeRequirements();</span>
        }

<span class="nc" id="L1014">        r.alignment = 0.5f;</span>

<span class="nc" id="L1016">        int n = getViewCount();</span>

        // loop through all children calculating the max of all their ascents and
        // descents at minimum, preferred, and maximum sizes
<span class="nc bnc" id="L1020" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L1021">            View v = getView(i);</span>
<span class="nc" id="L1022">            float align = v.getAlignment(axis);</span>
            float span;
            int ascent;
            int descent;

            // find the maximum of the preferred ascents and descents
<span class="nc" id="L1028">            span = v.getPreferredSpan(axis);</span>
<span class="nc" id="L1029">            ascent = (int)(align * span);</span>
<span class="nc" id="L1030">            descent = (int)(span - ascent);</span>
<span class="nc" id="L1031">            totalAscent.preferred = Math.max(ascent, totalAscent.preferred);</span>
<span class="nc" id="L1032">            totalDescent.preferred = Math.max(descent, totalDescent.preferred);</span>

<span class="nc bnc" id="L1034" title="All 2 branches missed.">            if (v.getResizeWeight(axis) &gt; 0) {</span>
                // if the view is resizable then do the same for the minimum and
                // maximum ascents and descents
<span class="nc" id="L1037">                span = v.getMinimumSpan(axis);</span>
<span class="nc" id="L1038">                ascent = (int)(align * span);</span>
<span class="nc" id="L1039">                descent = (int)(span - ascent);</span>
<span class="nc" id="L1040">                totalAscent.minimum = Math.max(ascent, totalAscent.minimum);</span>
<span class="nc" id="L1041">                totalDescent.minimum = Math.max(descent, totalDescent.minimum);</span>

<span class="nc" id="L1043">                span = v.getMaximumSpan(axis);</span>
<span class="nc" id="L1044">                ascent = (int)(align * span);</span>
<span class="nc" id="L1045">                descent = (int)(span - ascent);</span>
<span class="nc" id="L1046">                totalAscent.maximum = Math.max(ascent, totalAscent.maximum);</span>
<span class="nc" id="L1047">                totalDescent.maximum = Math.max(descent, totalDescent.maximum);</span>
            } else {
                // otherwise use the preferred
<span class="nc" id="L1050">                totalAscent.minimum = Math.max(ascent, totalAscent.minimum);</span>
<span class="nc" id="L1051">                totalDescent.minimum = Math.max(descent, totalDescent.minimum);</span>
<span class="nc" id="L1052">                totalAscent.maximum = Math.max(ascent, totalAscent.maximum);</span>
<span class="nc" id="L1053">                totalDescent.maximum = Math.max(descent, totalDescent.maximum);</span>
            }
        }

        // we now have an overall preferred, minimum, and maximum ascent and descent

        // calculate the preferred span as the sum of the preferred ascent and preferred descent
<span class="nc" id="L1060">        r.preferred = (int)Math.min((long)totalAscent.preferred + (long)totalDescent.preferred,</span>
                                    Integer.MAX_VALUE);

        // calculate the preferred alignment as the preferred ascent divided by the preferred span
<span class="nc bnc" id="L1064" title="All 2 branches missed.">        if (r.preferred &gt; 0) {</span>
<span class="nc" id="L1065">            r.alignment = (float)totalAscent.preferred / r.preferred;</span>
        }


<span class="nc bnc" id="L1069" title="All 2 branches missed.">        if (r.alignment == 0.0f) {</span>
            // if the preferred alignment is 0 then the minimum and maximum spans are simply
            // the minimum and maximum descents since there's nothing above the baseline
<span class="nc" id="L1072">            r.minimum = totalDescent.minimum;</span>
<span class="nc" id="L1073">            r.maximum = totalDescent.maximum;</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">        } else if (r.alignment == 1.0f) {</span>
            // if the preferred alignment is 1 then the minimum and maximum spans are simply
            // the minimum and maximum ascents since there's nothing below the baseline
<span class="nc" id="L1077">            r.minimum = totalAscent.minimum;</span>
<span class="nc" id="L1078">            r.maximum = totalAscent.maximum;</span>
        } else {
            // we want to honor the preferred alignment so we calculate two possible minimum
            // span values using 1) the minimum ascent and the alignment, and 2) the minimum
            // descent and the alignment. We'll choose the larger of these two numbers.
<span class="nc" id="L1083">            r.minimum = Math.round(Math.max(totalAscent.minimum / r.alignment,</span>
                                          totalDescent.minimum / (1.0f - r.alignment)));
            // a similar calculation is made for the maximum but we choose the smaller number.
<span class="nc" id="L1086">            r.maximum = Math.round(Math.min(totalAscent.maximum / r.alignment,</span>
                                          totalDescent.maximum / (1.0f - r.alignment)));
        }

<span class="nc" id="L1090">        return r;</span>
    }

    /**
     * Fetches the offset of a particular child's current layout.
     * @param axis the axis being studied
     * @param childIndex the index of the requested child
     * @return the offset (location) for the specified child
     */
    protected int getOffset(int axis, int childIndex) {
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        int[] offsets = (axis == majorAxis) ? majorOffsets : minorOffsets;</span>
<span class="nc" id="L1101">        return offsets[childIndex];</span>
    }

    /**
     * Fetches the span of a particular child's current layout.
     * @param axis the axis being studied
     * @param childIndex the index of the requested child
     * @return the span (width or height) of the specified child
     */
    protected int getSpan(int axis, int childIndex) {
<span class="nc bnc" id="L1111" title="All 2 branches missed.">        int[] spans = (axis == majorAxis) ? majorSpans : minorSpans;</span>
<span class="nc" id="L1112">        return spans[childIndex];</span>
    }

    /**
     * Determines in which direction the next view lays.
     * Consider the View at index n. Typically the &lt;code&gt;View&lt;/code&gt;s
     * are layed out from left to right, so that the &lt;code&gt;View&lt;/code&gt;
     * to the EAST will be at index n + 1, and the &lt;code&gt;View&lt;/code&gt;
     * to the WEST will be at index n - 1. In certain situations,
     * such as with bidirectional text, it is possible
     * that the &lt;code&gt;View&lt;/code&gt; to EAST is not at index n + 1,
     * but rather at index n - 1, or that the &lt;code&gt;View&lt;/code&gt;
     * to the WEST is not at index n - 1, but index n + 1.
     * In this case this method would return true,
     * indicating the &lt;code&gt;View&lt;/code&gt;s are layed out in
     * descending order. Otherwise the method would return false
     * indicating the &lt;code&gt;View&lt;/code&gt;s are layed out in ascending order.
     * &lt;p&gt;
     * If the receiver is laying its &lt;code&gt;View&lt;/code&gt;s along the
     * &lt;code&gt;Y_AXIS&lt;/code&gt;, this will will return the value from
     * invoking the same method on the &lt;code&gt;View&lt;/code&gt;
     * responsible for rendering &lt;code&gt;position&lt;/code&gt; and
     * &lt;code&gt;bias&lt;/code&gt;. Otherwise this will return false.
     *
     * @param position position into the model
     * @param bias either &lt;code&gt;Position.Bias.Forward&lt;/code&gt; or
     *          &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
     * @return true if the &lt;code&gt;View&lt;/code&gt;s surrounding the
     *          &lt;code&gt;View&lt;/code&gt; responding for rendering
     *          &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;bias&lt;/code&gt;
     *          are layed out in descending order; otherwise false
     */
    protected boolean flipEastAndWestAtEnds(int position,
                                            Position.Bias bias) {
<span class="nc bnc" id="L1146" title="All 2 branches missed.">        if(majorAxis == Y_AXIS) {</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">            int testPos = (bias == Position.Bias.Backward) ?</span>
<span class="nc" id="L1148">                          Math.max(0, position - 1) : position;</span>
<span class="nc" id="L1149">            int index = getViewIndexAtPosition(testPos);</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            if(index != -1) {</span>
<span class="nc" id="L1151">                View v = getView(index);</span>
<span class="nc bnc" id="L1152" title="All 4 branches missed.">                if(v != null &amp;&amp; v instanceof CompositeView) {</span>
<span class="nc" id="L1153">                    return ((CompositeView)v).flipEastAndWestAtEnds(position,</span>
                                                                    bias);
                }
            }
        }
<span class="nc" id="L1158">        return false;</span>
    }

    // --- variables ------------------------------------------------

    int majorAxis;

    int majorSpan;
    int minorSpan;

    /*
     * Request cache
     */
    boolean majorReqValid;
    boolean minorReqValid;
    SizeRequirements majorRequest;
    SizeRequirements minorRequest;

    /*
     * Allocation cache
     */
    boolean majorAllocValid;
    int[] majorOffsets;
    int[] majorSpans;
    boolean minorAllocValid;
    int[] minorOffsets;
    int[] minorSpans;

    /** used in paint. */
    Rectangle tempRect;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>