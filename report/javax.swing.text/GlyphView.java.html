<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GlyphView.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">GlyphView.java</span></div><h1>GlyphView.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.awt.*;
import java.text.BreakIterator;
import javax.swing.event.*;
import java.util.BitSet;
import java.util.Locale;

import javax.swing.UIManager;
import sun.swing.SwingUtilities2;
import static sun.swing.SwingUtilities2.IMPLIED_CR;

/**
 * A GlyphView is a styled chunk of text that represents a view
 * mapped over an element in the text model. This view is generally
 * responsible for displaying text glyphs using character level
 * attributes in some way.
 * An implementation of the GlyphPainter class is used to do the
 * actual rendering and model/view translations.  This separates
 * rendering from layout and management of the association with
 * the model.
 * &lt;p&gt;
 * The view supports breaking for the purpose of formatting.
 * The fragments produced by breaking share the view that has
 * primary responsibility for the element (i.e. they are nested
 * classes and carry only a small amount of state of their own)
 * so they can share its resources.
 * &lt;p&gt;
 * Since this view
 * represents text that may have tabs embedded in it, it implements the
 * &lt;code&gt;TabableView&lt;/code&gt; interface.  Tabs will only be
 * expanded if this view is embedded in a container that does
 * tab expansion.  ParagraphView is an example of a container
 * that does tab expansion.
 * &lt;p&gt;
 *
 * @since 1.3
 *
 * @author  Timothy Prinzing
 */
public class GlyphView extends View implements TabableView, Cloneable {

    /**
     * Constructs a new view wrapped on an element.
     *
     * @param elem the element
     */
    public GlyphView(Element elem) {
<span class="nc" id="L73">        super(elem);</span>
<span class="nc" id="L74">        offset = 0;</span>
<span class="nc" id="L75">        length = 0;</span>
<span class="nc" id="L76">        Element parent = elem.getParentElement();</span>
<span class="nc" id="L77">        AttributeSet attr = elem.getAttributes();</span>

        //         if there was an implied CR
<span class="nc bnc" id="L80" title="All 6 branches missed.">        impliedCR = (attr != null &amp;&amp; attr.getAttribute(IMPLIED_CR) != null &amp;&amp;</span>
        //         if this is non-empty paragraph
<span class="nc bnc" id="L82" title="All 2 branches missed.">                   parent != null &amp;&amp; parent.getElementCount() &gt; 1);</span>
<span class="nc" id="L83">        skipWidth = elem.getName().equals(&quot;br&quot;);</span>
<span class="nc" id="L84">    }</span>

    /**
     * Creates a shallow copy.  This is used by the
     * createFragment and breakView methods.
     *
     * @return the copy
     */
    protected final Object clone() {
        Object o;
        try {
<span class="nc" id="L95">            o = super.clone();</span>
<span class="nc" id="L96">        } catch (CloneNotSupportedException cnse) {</span>
<span class="nc" id="L97">            o = null;</span>
<span class="nc" id="L98">        }</span>
<span class="nc" id="L99">        return o;</span>
    }

    /**
     * Fetch the currently installed glyph painter.
     * If a painter has not yet been installed, and
     * a default was not yet needed, null is returned.
     */
    public GlyphPainter getGlyphPainter() {
<span class="nc" id="L108">        return painter;</span>
    }

    /**
     * Sets the painter to use for rendering glyphs.
     */
    public void setGlyphPainter(GlyphPainter p) {
<span class="nc" id="L115">        painter = p;</span>
<span class="nc" id="L116">    }</span>

    /**
     * Fetch a reference to the text that occupies
     * the given range.  This is normally used by
     * the GlyphPainter to determine what characters
     * it should render glyphs for.
     *
     * @param p0  the starting document offset &amp;gt;= 0
     * @param p1  the ending document offset &amp;gt;= p0
     * @return    the &lt;code&gt;Segment&lt;/code&gt; containing the text
     */
     public Segment getText(int p0, int p1) {
         // When done with the returned Segment it should be released by
         // invoking:
         //    SegmentCache.releaseSharedSegment(segment);
<span class="nc" id="L132">         Segment text = SegmentCache.getSharedSegment();</span>
         try {
<span class="nc" id="L134">             Document doc = getDocument();</span>
<span class="nc" id="L135">             doc.getText(p0, p1 - p0, text);</span>
<span class="nc" id="L136">         } catch (BadLocationException bl) {</span>
<span class="nc" id="L137">             throw new StateInvariantError(&quot;GlyphView: Stale view: &quot; + bl);</span>
<span class="nc" id="L138">         }</span>
<span class="nc" id="L139">         return text;</span>
     }

    /**
     * Fetch the background color to use to render the
     * glyphs.  If there is no background color, null should
     * be returned.  This is implemented to call
     * &lt;code&gt;StyledDocument.getBackground&lt;/code&gt; if the associated
     * document is a styled document, otherwise it returns null.
     */
    public Color getBackground() {
<span class="nc" id="L150">        Document doc = getDocument();</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (doc instanceof StyledDocument) {</span>
<span class="nc" id="L152">            AttributeSet attr = getAttributes();</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (attr.isDefined(StyleConstants.Background)) {</span>
<span class="nc" id="L154">                return ((StyledDocument)doc).getBackground(attr);</span>
            }
        }
<span class="nc" id="L157">        return null;</span>
    }

    /**
     * Fetch the foreground color to use to render the
     * glyphs.  If there is no foreground color, null should
     * be returned.  This is implemented to call
     * &lt;code&gt;StyledDocument.getBackground&lt;/code&gt; if the associated
     * document is a StyledDocument.  If the associated document
     * is not a StyledDocument, the associated components foreground
     * color is used.  If there is no associated component, null
     * is returned.
     */
    public Color getForeground() {
<span class="nc" id="L171">        Document doc = getDocument();</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (doc instanceof StyledDocument) {</span>
<span class="nc" id="L173">            AttributeSet attr = getAttributes();</span>
<span class="nc" id="L174">            return ((StyledDocument)doc).getForeground(attr);</span>
        }
<span class="nc" id="L176">        Component c = getContainer();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L178">            return c.getForeground();</span>
        }
<span class="nc" id="L180">        return null;</span>
    }

    /**
     * Fetch the font that the glyphs should be based
     * upon.  This is implemented to call
     * &lt;code&gt;StyledDocument.getFont&lt;/code&gt; if the associated
     * document is a StyledDocument.  If the associated document
     * is not a StyledDocument, the associated components font
     * is used.  If there is no associated component, null
     * is returned.
     */
    public Font getFont() {
<span class="nc" id="L193">        Document doc = getDocument();</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (doc instanceof StyledDocument) {</span>
<span class="nc" id="L195">            AttributeSet attr = getAttributes();</span>
<span class="nc" id="L196">            return ((StyledDocument)doc).getFont(attr);</span>
        }
<span class="nc" id="L198">        Component c = getContainer();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L200">            return c.getFont();</span>
        }
<span class="nc" id="L202">        return null;</span>
    }

    /**
     * Determine if the glyphs should be underlined.  If true,
     * an underline should be drawn through the baseline.
     */
    public boolean isUnderline() {
<span class="nc" id="L210">        AttributeSet attr = getAttributes();</span>
<span class="nc" id="L211">        return StyleConstants.isUnderline(attr);</span>
    }

    /**
     * Determine if the glyphs should have a strikethrough
     * line.  If true, a line should be drawn through the center
     * of the glyphs.
     */
    public boolean isStrikeThrough() {
<span class="nc" id="L220">        AttributeSet attr = getAttributes();</span>
<span class="nc" id="L221">        return StyleConstants.isStrikeThrough(attr);</span>
    }

    /**
     * Determine if the glyphs should be rendered as superscript.
     */
    public boolean isSubscript() {
<span class="nc" id="L228">        AttributeSet attr = getAttributes();</span>
<span class="nc" id="L229">        return StyleConstants.isSubscript(attr);</span>
    }

    /**
     * Determine if the glyphs should be rendered as subscript.
     */
    public boolean isSuperscript() {
<span class="nc" id="L236">        AttributeSet attr = getAttributes();</span>
<span class="nc" id="L237">        return StyleConstants.isSuperscript(attr);</span>
    }

    /**
     * Fetch the TabExpander to use if tabs are present in this view.
     */
    public TabExpander getTabExpander() {
<span class="nc" id="L244">        return expander;</span>
    }

    /**
     * Check to see that a glyph painter exists.  If a painter
     * doesn't exist, a default glyph painter will be installed.
     */
    protected void checkPainter() {
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (painter == null) {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (defaultPainter == null) {</span>
                // the classname should probably come from a property file.
<span class="nc" id="L255">                String classname = &quot;javax.swing.text.GlyphPainter1&quot;;</span>
                try {
                    Class c;
<span class="nc" id="L258">                    ClassLoader loader = getClass().getClassLoader();</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">                    if (loader != null) {</span>
<span class="nc" id="L260">                        c = loader.loadClass(classname);</span>
                    } else {
<span class="nc" id="L262">                        c = Class.forName(classname);</span>
                    }
<span class="nc" id="L264">                    Object o = c.newInstance();</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">                    if (o instanceof GlyphPainter) {</span>
<span class="nc" id="L266">                        defaultPainter = (GlyphPainter) o;</span>
                    }
<span class="nc" id="L268">                } catch (Throwable e) {</span>
<span class="nc" id="L269">                    throw new StateInvariantError(&quot;GlyphView: Can't load glyph painter: &quot;</span>
                                                  + classname);
<span class="nc" id="L271">                }</span>
            }
<span class="nc" id="L273">            setGlyphPainter(defaultPainter.getPainter(this, getStartOffset(),</span>
<span class="nc" id="L274">                                                      getEndOffset()));</span>
        }
<span class="nc" id="L276">    }</span>

    // --- TabableView methods --------------------------------------

    /**
     * Determines the desired span when using the given
     * tab expansion implementation.
     *
     * @param x the position the view would be located
     *  at for the purpose of tab expansion &amp;gt;= 0.
     * @param e how to expand the tabs when encountered.
     * @return the desired span &amp;gt;= 0
     * @see TabableView#getTabbedSpan
     */
    public float getTabbedSpan(float x, TabExpander e) {
<span class="nc" id="L291">        checkPainter();</span>

<span class="nc" id="L293">        TabExpander old = expander;</span>
<span class="nc" id="L294">        expander = e;</span>

<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (expander != old) {</span>
            // setting expander can change horizontal span of the view,
            // so we have to call preferenceChanged()
<span class="nc" id="L299">            preferenceChanged(null, true, false);</span>
        }

<span class="nc" id="L302">        this.x = (int) x;</span>
<span class="nc" id="L303">        int p0 = getStartOffset();</span>
<span class="nc" id="L304">        int p1 = getEndOffset();</span>
<span class="nc" id="L305">        float width = painter.getSpan(this, p0, p1, expander, x);</span>
<span class="nc" id="L306">        return width;</span>
    }

    /**
     * Determines the span along the same axis as tab
     * expansion for a portion of the view.  This is
     * intended for use by the TabExpander for cases
     * where the tab expansion involves aligning the
     * portion of text that doesn't have whitespace
     * relative to the tab stop.  There is therefore
     * an assumption that the range given does not
     * contain tabs.
     * &lt;p&gt;
     * This method can be called while servicing the
     * getTabbedSpan or getPreferredSize.  It has to
     * arrange for its own text buffer to make the
     * measurements.
     *
     * @param p0 the starting document offset &amp;gt;= 0
     * @param p1 the ending document offset &amp;gt;= p0
     * @return the span &amp;gt;= 0
     */
    public float getPartialSpan(int p0, int p1) {
<span class="nc" id="L329">        checkPainter();</span>
<span class="nc" id="L330">        float width = painter.getSpan(this, p0, p1, expander, x);</span>
<span class="nc" id="L331">        return width;</span>
    }

    // --- View methods ---------------------------------------------

    /**
     * Fetches the portion of the model that this view is responsible for.
     *
     * @return the starting offset into the model
     * @see View#getStartOffset
     */
    public int getStartOffset() {
<span class="nc" id="L343">        Element e = getElement();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        return (length &gt; 0) ? e.getStartOffset() + offset : e.getStartOffset();</span>
    }

    /**
     * Fetches the portion of the model that this view is responsible for.
     *
     * @return the ending offset into the model
     * @see View#getEndOffset
     */
    public int getEndOffset() {
<span class="nc" id="L354">        Element e = getElement();</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">        return (length &gt; 0) ? e.getStartOffset() + offset + length : e.getEndOffset();</span>
    }

    /**
     * Lazily initializes the selections field
     */
    private void initSelections(int p0, int p1) {
<span class="nc" id="L362">        int viewPosCount = p1 - p0 + 1;</span>
<span class="nc bnc" id="L363" title="All 4 branches missed.">        if (selections == null || viewPosCount &gt; selections.length) {</span>
<span class="nc" id="L364">            selections = new byte[viewPosCount];</span>
<span class="nc" id="L365">            return;</span>
        }
<span class="nc bnc" id="L367" title="All 2 branches missed.">        for (int i = 0; i &lt; viewPosCount; selections[i++] = 0);</span>
<span class="nc" id="L368">    }</span>

    /**
     * Renders a portion of a text style run.
     *
     * @param g the rendering surface to use
     * @param a the allocated region to render into
     */
    public void paint(Graphics g, Shape a) {
<span class="nc" id="L377">        checkPainter();</span>

<span class="nc" id="L379">        boolean paintedText = false;</span>
<span class="nc" id="L380">        Component c = getContainer();</span>
<span class="nc" id="L381">        int p0 = getStartOffset();</span>
<span class="nc" id="L382">        int p1 = getEndOffset();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        Rectangle alloc = (a instanceof Rectangle) ? (Rectangle)a : a.getBounds();</span>
<span class="nc" id="L384">        Color bg = getBackground();</span>
<span class="nc" id="L385">        Color fg = getForeground();</span>

<span class="nc bnc" id="L387" title="All 4 branches missed.">        if (c != null &amp;&amp; ! c.isEnabled()) {</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">            fg = (c instanceof JTextComponent ?</span>
<span class="nc" id="L389">                ((JTextComponent)c).getDisabledTextColor() :</span>
<span class="nc" id="L390">                UIManager.getColor(&quot;textInactiveText&quot;));</span>
        }
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (bg != null) {</span>
<span class="nc" id="L393">            g.setColor(bg);</span>
<span class="nc" id="L394">            g.fillRect(alloc.x, alloc.y, alloc.width, alloc.height);</span>
        }
<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (c instanceof JTextComponent) {</span>
<span class="nc" id="L397">            JTextComponent tc = (JTextComponent) c;</span>
<span class="nc" id="L398">            Highlighter h = tc.getHighlighter();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if (h instanceof LayeredHighlighter) {</span>
<span class="nc" id="L400">                ((LayeredHighlighter)h).paintLayeredHighlights</span>
<span class="nc" id="L401">                    (g, p0, p1, a, tc, this);</span>
            }
        }

<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (Utilities.isComposedTextElement(getElement())) {</span>
<span class="nc" id="L406">            Utilities.paintComposedText(g, a.getBounds(), this);</span>
<span class="nc" id="L407">            paintedText = true;</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        } else if(c instanceof JTextComponent) {</span>
<span class="nc" id="L409">            JTextComponent tc = (JTextComponent) c;</span>
<span class="nc" id="L410">            Color selFG = tc.getSelectedTextColor();</span>

<span class="nc" id="L412">            if (// there's a highlighter (bug 4532590), and</span>
<span class="nc bnc" id="L413" title="All 4 branches missed.">                (tc.getHighlighter() != null) &amp;&amp;</span>
                // selected text color is different from regular foreground
<span class="nc bnc" id="L415" title="All 2 branches missed.">                (selFG != null) &amp;&amp; !selFG.equals(fg)) {</span>

<span class="nc" id="L417">                Highlighter.Highlight[] h = tc.getHighlighter().getHighlights();</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                if(h.length != 0) {</span>
<span class="nc" id="L419">                    boolean initialized = false;</span>
<span class="nc" id="L420">                    int viewSelectionCount = 0;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                    for (int i = 0; i &lt; h.length; i++) {</span>
<span class="nc" id="L422">                        Highlighter.Highlight highlight = h[i];</span>
<span class="nc" id="L423">                        int hStart = highlight.getStartOffset();</span>
<span class="nc" id="L424">                        int hEnd = highlight.getEndOffset();</span>
<span class="nc bnc" id="L425" title="All 4 branches missed.">                        if (hStart &gt; p1 || hEnd &lt; p0) {</span>
                            // the selection is out of this view
<span class="nc" id="L427">                            continue;</span>
                        }
<span class="nc bnc" id="L429" title="All 2 branches missed.">                        if (!SwingUtilities2.useSelectedTextColor(highlight, tc)) {</span>
<span class="nc" id="L430">                            continue;</span>
                        }
<span class="nc bnc" id="L432" title="All 4 branches missed.">                        if (hStart &lt;= p0 &amp;&amp; hEnd &gt;= p1){</span>
                            // the whole view is selected
<span class="nc" id="L434">                            paintTextUsingColor(g, a, selFG, p0, p1);</span>
<span class="nc" id="L435">                            paintedText = true;</span>
<span class="nc" id="L436">                            break;</span>
                        }
                        // the array is lazily created only when the view
                        // is partially selected
<span class="nc bnc" id="L440" title="All 2 branches missed.">                        if (!initialized) {</span>
<span class="nc" id="L441">                            initSelections(p0, p1);</span>
<span class="nc" id="L442">                            initialized = true;</span>
                        }
<span class="nc" id="L444">                        hStart = Math.max(p0, hStart);</span>
<span class="nc" id="L445">                        hEnd = Math.min(p1, hEnd);</span>
<span class="nc" id="L446">                        paintTextUsingColor(g, a, selFG, hStart, hEnd);</span>
                        // the array represents view positions [0, p1-p0+1]
                        // later will iterate this array and sum its
                        // elements. Positions with sum == 0 are not selected.
<span class="nc" id="L450">                        selections[hStart-p0]++;</span>
<span class="nc" id="L451">                        selections[hEnd-p0]--;</span>

<span class="nc" id="L453">                        viewSelectionCount++;</span>
                    }

<span class="nc bnc" id="L456" title="All 4 branches missed.">                    if (!paintedText &amp;&amp; viewSelectionCount &gt; 0) {</span>
                        // the view is partially selected
<span class="nc" id="L458">                        int curPos = -1;</span>
<span class="nc" id="L459">                        int startPos = 0;</span>
<span class="nc" id="L460">                        int viewLen = p1 - p0;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                        while (curPos++ &lt; viewLen) {</span>
                            // searching for the next selection start
<span class="nc bnc" id="L463" title="All 4 branches missed.">                            while(curPos &lt; viewLen &amp;&amp;</span>
<span class="nc" id="L464">                                    selections[curPos] == 0) curPos++;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                            if (startPos != curPos) {</span>
                                // paint unselected text
<span class="nc" id="L467">                                paintTextUsingColor(g, a, fg,</span>
                                        p0 + startPos, p0 + curPos);
                            }
<span class="nc" id="L470">                            int checkSum = 0;</span>
                            // searching for next start position of unselected text
<span class="nc bnc" id="L472" title="All 4 branches missed.">                            while (curPos &lt; viewLen &amp;&amp;</span>
<span class="nc" id="L473">                                    (checkSum += selections[curPos]) != 0) curPos++;</span>
<span class="nc" id="L474">                            startPos = curPos;</span>
<span class="nc" id="L475">                        }</span>
<span class="nc" id="L476">                        paintedText = true;</span>
                    }
                }
            }
        }
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if(!paintedText)</span>
<span class="nc" id="L482">            paintTextUsingColor(g, a, fg, p0, p1);</span>
<span class="nc" id="L483">    }</span>

    /**
     * Paints the specified region of text in the specified color.
     */
    final void paintTextUsingColor(Graphics g, Shape a, Color c, int p0, int p1) {
        // render the glyphs
<span class="nc" id="L490">        g.setColor(c);</span>
<span class="nc" id="L491">        painter.paint(this, g, a, p0, p1);</span>

        // render underline or strikethrough if set.
<span class="nc" id="L494">        boolean underline = isUnderline();</span>
<span class="nc" id="L495">        boolean strike = isStrikeThrough();</span>
<span class="nc bnc" id="L496" title="All 4 branches missed.">        if (underline || strike) {</span>
            // calculate x coordinates
<span class="nc bnc" id="L498" title="All 2 branches missed.">            Rectangle alloc = (a instanceof Rectangle) ? (Rectangle)a : a.getBounds();</span>
<span class="nc" id="L499">            View parent = getParent();</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">            if ((parent != null) &amp;&amp; (parent.getEndOffset() == p1)) {</span>
                // strip whitespace on end
<span class="nc" id="L502">                Segment s = getText(p0, p1);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">                while (Character.isWhitespace(s.last())) {</span>
<span class="nc" id="L504">                    p1 -= 1;</span>
<span class="nc" id="L505">                    s.count -= 1;</span>
                }
<span class="nc" id="L507">                SegmentCache.releaseSharedSegment(s);</span>
            }
<span class="nc" id="L509">            int x0 = alloc.x;</span>
<span class="nc" id="L510">            int p = getStartOffset();</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">            if (p != p0) {</span>
<span class="nc" id="L512">                x0 += (int) painter.getSpan(this, p, p0, getTabExpander(), x0);</span>
            }
<span class="nc" id="L514">            int x1 = x0 + (int) painter.getSpan(this, p0, p1, getTabExpander(), x0);</span>

            // calculate y coordinate
<span class="nc" id="L517">            int y = alloc.y + (int)(painter.getHeight(this) - painter.getDescent(this));</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">            if (underline) {</span>
<span class="nc" id="L519">                int yTmp = y + 1;</span>
<span class="nc" id="L520">                g.drawLine(x0, yTmp, x1, yTmp);</span>
            }
<span class="nc bnc" id="L522" title="All 2 branches missed.">            if (strike) {</span>
                // move y coordinate above baseline
<span class="nc" id="L524">                int yTmp = y - (int) (painter.getAscent(this) * 0.3f);</span>
<span class="nc" id="L525">                g.drawLine(x0, yTmp, x1, yTmp);</span>
            }

        }
<span class="nc" id="L529">    }</span>

    /**
     * Determines the minimum span for this view along an axis.
     *
     * &lt;p&gt;This implementation returns the longest non-breakable area within
     * the view as a minimum span for {@code View.X_AXIS}.&lt;/p&gt;
     *
     * @param axis  may be either {@code View.X_AXIS} or {@code View.Y_AXIS}
     * @return      the minimum span the view can be rendered into
     * @throws IllegalArgumentException if the {@code axis} parameter is invalid
     * @see         javax.swing.text.View#getMinimumSpan
     */
    @Override
    public float getMinimumSpan(int axis) {
<span class="nc bnc" id="L544" title="All 3 branches missed.">        switch (axis) {</span>
            case View.X_AXIS:
<span class="nc bnc" id="L546" title="All 2 branches missed.">                if (minimumSpan &lt; 0) {</span>
<span class="nc" id="L547">                    minimumSpan = 0;</span>
<span class="nc" id="L548">                    int p0 = getStartOffset();</span>
<span class="nc" id="L549">                    int p1 = getEndOffset();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">                    while (p1 &gt; p0) {</span>
<span class="nc" id="L551">                        int breakSpot = getBreakSpot(p0, p1);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                        if (breakSpot == BreakIterator.DONE) {</span>
                            // the rest of the view is non-breakable
<span class="nc" id="L554">                            breakSpot = p0;</span>
                        }
<span class="nc" id="L556">                        minimumSpan = Math.max(minimumSpan,</span>
<span class="nc" id="L557">                                getPartialSpan(breakSpot, p1));</span>
                        // Note: getBreakSpot returns the *last* breakspot
<span class="nc" id="L559">                        p1 = breakSpot - 1;</span>
<span class="nc" id="L560">                    }</span>
                }
<span class="nc" id="L562">                return minimumSpan;</span>
            case View.Y_AXIS:
<span class="nc" id="L564">                return super.getMinimumSpan(axis);</span>
            default:
<span class="nc" id="L566">                throw new IllegalArgumentException(&quot;Invalid axis: &quot; + axis);</span>
        }
    }

    /**
     * Determines the preferred span for this view along an
     * axis.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return   the span the view would like to be rendered into &amp;gt;= 0.
     *           Typically the view is told to render into the span
     *           that is returned, although there is no guarantee.
     *           The parent may choose to resize or break the view.
     */
    public float getPreferredSpan(int axis) {
<span class="nc bnc" id="L581" title="All 2 branches missed.">        if (impliedCR) {</span>
<span class="nc" id="L582">            return 0;</span>
        }
<span class="nc" id="L584">        checkPainter();</span>
<span class="nc" id="L585">        int p0 = getStartOffset();</span>
<span class="nc" id="L586">        int p1 = getEndOffset();</span>
<span class="nc bnc" id="L587" title="All 3 branches missed.">        switch (axis) {</span>
        case View.X_AXIS:
<span class="nc bnc" id="L589" title="All 2 branches missed.">            if (skipWidth) {</span>
<span class="nc" id="L590">                return 0;</span>
            }
<span class="nc" id="L592">            return painter.getSpan(this, p0, p1, expander, this.x);</span>
        case View.Y_AXIS:
<span class="nc" id="L594">            float h = painter.getHeight(this);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">            if (isSuperscript()) {</span>
<span class="nc" id="L596">                h += h/3;</span>
            }
<span class="nc" id="L598">            return h;</span>
        default:
<span class="nc" id="L600">            throw new IllegalArgumentException(&quot;Invalid axis: &quot; + axis);</span>
        }
    }

    /**
     * Determines the desired alignment for this view along an
     * axis.  For the label, the alignment is along the font
     * baseline for the y axis, and the superclasses alignment
     * along the x axis.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return the desired alignment.  This should be a value
     *   between 0.0 and 1.0 inclusive, where 0 indicates alignment at the
     *   origin and 1.0 indicates alignment to the full span
     *   away from the origin.  An alignment of 0.5 would be the
     *   center of the view.
     */
    public float getAlignment(int axis) {
<span class="nc" id="L618">        checkPainter();</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">        if (axis == View.Y_AXIS) {</span>
<span class="nc" id="L620">            boolean sup = isSuperscript();</span>
<span class="nc" id="L621">            boolean sub = isSubscript();</span>
<span class="nc" id="L622">            float h = painter.getHeight(this);</span>
<span class="nc" id="L623">            float d = painter.getDescent(this);</span>
<span class="nc" id="L624">            float a = painter.getAscent(this);</span>
            float align;
<span class="nc bnc" id="L626" title="All 2 branches missed.">            if (sup) {</span>
<span class="nc" id="L627">                align = 1.0f;</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">            } else if (sub) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">                align = (h &gt; 0) ? (h - (d + (a / 2))) / h : 0;</span>
            } else {
<span class="nc bnc" id="L631" title="All 2 branches missed.">                align = (h &gt; 0) ? (h - d) / h : 0;</span>
            }
<span class="nc" id="L633">            return align;</span>
        }
<span class="nc" id="L635">        return super.getAlignment(axis);</span>
    }

    /**
     * Provides a mapping from the document model coordinate space
     * to the coordinate space of the view mapped to it.
     *
     * @param pos the position to convert &amp;gt;= 0
     * @param a   the allocated region to render into
     * @param b   either &lt;code&gt;Position.Bias.Forward&lt;/code&gt;
     *                or &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
     * @return the bounding box of the given position
     * @exception BadLocationException  if the given position does not represent a
     *   valid location in the associated document
     * @see View#modelToView
     */
    public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
<span class="nc" id="L652">        checkPainter();</span>
<span class="nc" id="L653">        return painter.modelToView(this, pos, b, a);</span>
    }

    /**
     * Provides a mapping from the view coordinate space to the logical
     * coordinate space of the model.
     *
     * @param x the X coordinate &amp;gt;= 0
     * @param y the Y coordinate &amp;gt;= 0
     * @param a the allocated region to render into
     * @param biasReturn either &lt;code&gt;Position.Bias.Forward&lt;/code&gt;
     *  or &lt;code&gt;Position.Bias.Backward&lt;/code&gt; is returned as the
     *  zero-th element of this array
     * @return the location within the model that best represents the
     *  given point of view &amp;gt;= 0
     * @see View#viewToModel
     */
    public int viewToModel(float x, float y, Shape a, Position.Bias[] biasReturn) {
<span class="nc" id="L671">        checkPainter();</span>
<span class="nc" id="L672">        return painter.viewToModel(this, x, y, a, biasReturn);</span>
    }

    /**
     * Determines how attractive a break opportunity in
     * this view is.  This can be used for determining which
     * view is the most attractive to call &lt;code&gt;breakView&lt;/code&gt;
     * on in the process of formatting.  The
     * higher the weight, the more attractive the break.  A
     * value equal to or lower than &lt;code&gt;View.BadBreakWeight&lt;/code&gt;
     * should not be considered for a break.  A value greater
     * than or equal to &lt;code&gt;View.ForcedBreakWeight&lt;/code&gt; should
     * be broken.
     * &lt;p&gt;
     * This is implemented to forward to the superclass for
     * the Y_AXIS.  Along the X_AXIS the following values
     * may be returned.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;View.ExcellentBreakWeight&lt;/b&gt;
     * &lt;dd&gt;if there is whitespace proceeding the desired break
     *   location.
     * &lt;dt&gt;&lt;b&gt;View.BadBreakWeight&lt;/b&gt;
     * &lt;dd&gt;if the desired break location results in a break
     *   location of the starting offset.
     * &lt;dt&gt;&lt;b&gt;View.GoodBreakWeight&lt;/b&gt;
     * &lt;dd&gt;if the other conditions don't occur.
     * &lt;/dl&gt;
     * This will normally result in the behavior of breaking
     * on a whitespace location if one can be found, otherwise
     * breaking between characters.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @param pos the potential location of the start of the
     *   broken view &amp;gt;= 0.  This may be useful for calculating tab
     *   positions.
     * @param len specifies the relative length from &lt;em&gt;pos&lt;/em&gt;
     *   where a potential break is desired &amp;gt;= 0.
     * @return the weight, which should be a value between
     *   View.ForcedBreakWeight and View.BadBreakWeight.
     * @see LabelView
     * @see ParagraphView
     * @see View#BadBreakWeight
     * @see View#GoodBreakWeight
     * @see View#ExcellentBreakWeight
     * @see View#ForcedBreakWeight
     */
    public int getBreakWeight(int axis, float pos, float len) {
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (axis == View.X_AXIS) {</span>
<span class="nc" id="L720">            checkPainter();</span>
<span class="nc" id="L721">            int p0 = getStartOffset();</span>
<span class="nc" id="L722">            int p1 = painter.getBoundedPosition(this, p0, pos, len);</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">            return p1 == p0 ? View.BadBreakWeight :</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                   getBreakSpot(p0, p1) != BreakIterator.DONE ?</span>
                            View.ExcellentBreakWeight : View.GoodBreakWeight;
        }
<span class="nc" id="L727">        return super.getBreakWeight(axis, pos, len);</span>
    }

    /**
     * Breaks this view on the given axis at the given length.
     * This is implemented to attempt to break on a whitespace
     * location, and returns a fragment with the whitespace at
     * the end.  If a whitespace location can't be found, the
     * nearest character is used.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @param p0 the location in the model where the
     *  fragment should start it's representation &amp;gt;= 0.
     * @param pos the position along the axis that the
     *  broken view would occupy &amp;gt;= 0.  This may be useful for
     *  things like tab calculations.
     * @param len specifies the distance along the axis
     *  where a potential break is desired &amp;gt;= 0.
     * @return the fragment of the view that represents the
     *  given span, if the view can be broken.  If the view
     *  doesn't support breaking behavior, the view itself is
     *  returned.
     * @see View#breakView
     */
    public View breakView(int axis, int p0, float pos, float len) {
<span class="nc bnc" id="L752" title="All 2 branches missed.">        if (axis == View.X_AXIS) {</span>
<span class="nc" id="L753">            checkPainter();</span>
<span class="nc" id="L754">            int p1 = painter.getBoundedPosition(this, p0, pos, len);</span>
<span class="nc" id="L755">            int breakSpot = getBreakSpot(p0, p1);</span>

<span class="nc bnc" id="L757" title="All 2 branches missed.">            if (breakSpot != -1) {</span>
<span class="nc" id="L758">                p1 = breakSpot;</span>
            }
            // else, no break in the region, return a fragment of the
            // bounded region.
<span class="nc bnc" id="L762" title="All 4 branches missed.">            if (p0 == getStartOffset() &amp;&amp; p1 == getEndOffset()) {</span>
<span class="nc" id="L763">                return this;</span>
            }
<span class="nc" id="L765">            GlyphView v = (GlyphView) createFragment(p0, p1);</span>
<span class="nc" id="L766">            v.x = (int) pos;</span>
<span class="nc" id="L767">            return v;</span>
        }
<span class="nc" id="L769">        return this;</span>
    }

    /**
     * Returns a location to break at in the passed in region, or
     * BreakIterator.DONE if there isn't a good location to break at
     * in the specified region.
     */
    private int getBreakSpot(int p0, int p1) {
<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (breakSpots == null) {</span>
            // Re-calculate breakpoints for the whole view
<span class="nc" id="L780">            int start = getStartOffset();</span>
<span class="nc" id="L781">            int end = getEndOffset();</span>
<span class="nc" id="L782">            int[] bs = new int[end + 1 - start];</span>
<span class="nc" id="L783">            int ix = 0;</span>

            // Breaker should work on the parent element because there may be
            // a valid breakpoint at the end edge of the view (space, etc.)
<span class="nc" id="L787">            Element parent = getElement().getParentElement();</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">            int pstart = (parent == null ? start : parent.getStartOffset());</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">            int pend = (parent == null ? end : parent.getEndOffset());</span>

<span class="nc" id="L791">            Segment s = getText(pstart, pend);</span>
<span class="nc" id="L792">            s.first();</span>
<span class="nc" id="L793">            BreakIterator breaker = getBreaker();</span>
<span class="nc" id="L794">            breaker.setText(s);</span>

            // Backward search should start from end+1 unless there's NO end+1
<span class="nc bnc" id="L797" title="All 2 branches missed.">            int startFrom = end + (pend &gt; end ? 1 : 0);</span>
            for (;;) {
<span class="nc" id="L799">                startFrom = breaker.preceding(s.offset + (startFrom - pstart))</span>
                          + (pstart - s.offset);
<span class="nc bnc" id="L801" title="All 2 branches missed.">                if (startFrom &gt; start) {</span>
                    // The break spot is within the view
<span class="nc" id="L803">                    bs[ix++] = startFrom;</span>
                } else {
                    break;
                }
            }

<span class="nc" id="L809">            SegmentCache.releaseSharedSegment(s);</span>
<span class="nc" id="L810">            breakSpots = new int[ix];</span>
<span class="nc" id="L811">            System.arraycopy(bs, 0, breakSpots, 0, ix);</span>
        }

<span class="nc" id="L814">        int breakSpot = BreakIterator.DONE;</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">        for (int i = 0; i &lt; breakSpots.length; i++) {</span>
<span class="nc" id="L816">            int bsp = breakSpots[i];</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">            if (bsp &lt;= p1) {</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">                if (bsp &gt; p0) {</span>
<span class="nc" id="L819">                    breakSpot = bsp;</span>
                }
                break;
            }
        }
<span class="nc" id="L824">        return breakSpot;</span>
    }

    /**
     * Return break iterator appropriate for the current document.
     *
     * For non-i18n documents a fast whitespace-based break iterator is used.
     */
    private BreakIterator getBreaker() {
<span class="nc" id="L833">        Document doc = getDocument();</span>
<span class="nc bnc" id="L834" title="All 4 branches missed.">        if ((doc != null) &amp;&amp; Boolean.TRUE.equals(</span>
<span class="nc" id="L835">                    doc.getProperty(AbstractDocument.MultiByteProperty))) {</span>
<span class="nc" id="L836">            Container c = getContainer();</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">            Locale locale = (c == null ? Locale.getDefault() : c.getLocale());</span>
<span class="nc" id="L838">            return BreakIterator.getLineInstance(locale);</span>
        } else {
<span class="nc" id="L840">            return new WhitespaceBasedBreakIterator();</span>
        }
    }

    /**
     * Creates a view that represents a portion of the element.
     * This is potentially useful during formatting operations
     * for taking measurements of fragments of the view.  If
     * the view doesn't support fragmenting (the default), it
     * should return itself.
     * &lt;p&gt;
     * This view does support fragmenting.  It is implemented
     * to return a nested class that shares state in this view
     * representing only a portion of the view.
     *
     * @param p0 the starting offset &amp;gt;= 0.  This should be a value
     *   greater or equal to the element starting offset and
     *   less than the element ending offset.
     * @param p1 the ending offset &amp;gt; p0.  This should be a value
     *   less than or equal to the elements end offset and
     *   greater than the elements starting offset.
     * @return the view fragment, or itself if the view doesn't
     *   support breaking into fragments
     * @see LabelView
     */
    public View createFragment(int p0, int p1) {
<span class="nc" id="L866">        checkPainter();</span>
<span class="nc" id="L867">        Element elem = getElement();</span>
<span class="nc" id="L868">        GlyphView v = (GlyphView) clone();</span>
<span class="nc" id="L869">        v.offset = p0 - elem.getStartOffset();</span>
<span class="nc" id="L870">        v.length = p1 - p0;</span>
<span class="nc" id="L871">        v.painter = painter.getPainter(v, p0, p1);</span>
<span class="nc" id="L872">        v.justificationInfo = null;</span>
<span class="nc" id="L873">        return v;</span>
    }

    /**
     * Provides a way to determine the next visually represented model
     * location that one might place a caret.  Some views may not be
     * visible, they might not be in the same order found in the model, or
     * they just might not allow access to some of the locations in the
     * model.
     * This method enables specifying a position to convert
     * within the range of &amp;gt;=0.  If the value is -1, a position
     * will be calculated automatically.  If the value &amp;lt; -1,
     * the {@code BadLocationException} will be thrown.
     *
     * @param pos the position to convert
     * @param a the allocated region to render into
     * @param direction the direction from the current position that can
     *  be thought of as the arrow keys typically found on a keyboard.
     *  This may be SwingConstants.WEST, SwingConstants.EAST,
     *  SwingConstants.NORTH, or SwingConstants.SOUTH.
     * @return the location within the model that best represents the next
     *  location visual position.
     * @exception BadLocationException the given position is not a valid
     *                                 position within the document
     * @exception IllegalArgumentException for an invalid direction
     */
    public int getNextVisualPositionFrom(int pos, Position.Bias b, Shape a,
                                         int direction,
                                         Position.Bias[] biasRet)
        throws BadLocationException {

<span class="nc bnc" id="L904" title="All 2 branches missed.">        if (pos &lt; -1) {</span>
<span class="nc" id="L905">            throw new BadLocationException(&quot;invalid position&quot;, pos);</span>
        }
<span class="nc" id="L907">        return painter.getNextVisualPositionFrom(this, pos, b, a, direction, biasRet);</span>
    }

    /**
     * Gives notification that something was inserted into
     * the document in a location that this view is responsible for.
     * This is implemented to call preferenceChanged along the
     * axis the glyphs are rendered.
     *
     * @param e the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#insertUpdate
     */
    public void insertUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc" id="L922">        justificationInfo = null;</span>
<span class="nc" id="L923">        breakSpots = null;</span>
<span class="nc" id="L924">        minimumSpan = -1;</span>
<span class="nc" id="L925">        syncCR();</span>
<span class="nc" id="L926">        preferenceChanged(null, true, false);</span>
<span class="nc" id="L927">    }</span>

    /**
     * Gives notification that something was removed from the document
     * in a location that this view is responsible for.
     * This is implemented to call preferenceChanged along the
     * axis the glyphs are rendered.
     *
     * @param e the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#removeUpdate
     */
    public void removeUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc" id="L941">        justificationInfo = null;</span>
<span class="nc" id="L942">        breakSpots = null;</span>
<span class="nc" id="L943">        minimumSpan = -1;</span>
<span class="nc" id="L944">        syncCR();</span>
<span class="nc" id="L945">        preferenceChanged(null, true, false);</span>
<span class="nc" id="L946">    }</span>

    /**
     * Gives notification from the document that attributes were changed
     * in a location that this view is responsible for.
     * This is implemented to call preferenceChanged along both the
     * horizontal and vertical axis.
     *
     * @param e the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#changedUpdate
     */
    public void changedUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc" id="L960">        minimumSpan = -1;</span>
<span class="nc" id="L961">        syncCR();</span>
<span class="nc" id="L962">        preferenceChanged(null, true, true);</span>
<span class="nc" id="L963">    }</span>

    // checks if the paragraph is empty and updates impliedCR flag
    // accordingly
    private void syncCR() {
<span class="nc bnc" id="L968" title="All 2 branches missed.">        if (impliedCR) {</span>
<span class="nc" id="L969">            Element parent = getElement().getParentElement();</span>
<span class="nc bnc" id="L970" title="All 4 branches missed.">            impliedCR = (parent != null &amp;&amp; parent.getElementCount() &gt; 1);</span>
        }
<span class="nc" id="L972">    }</span>

    /**
     * Class to hold data needed to justify this GlyphView in a PargraphView.Row
     */
    static class JustificationInfo {
        //justifiable content start
        final int start;
        //justifiable content end
        final int end;
        final int leadingSpaces;
        final int contentSpaces;
        final int trailingSpaces;
        final boolean hasTab;
        final BitSet spaceMap;
        JustificationInfo(int start, int end,
                          int leadingSpaces,
                          int contentSpaces,
                          int trailingSpaces,
                          boolean hasTab,
<span class="nc" id="L992">                          BitSet spaceMap) {</span>
<span class="nc" id="L993">            this.start = start;</span>
<span class="nc" id="L994">            this.end = end;</span>
<span class="nc" id="L995">            this.leadingSpaces = leadingSpaces;</span>
<span class="nc" id="L996">            this.contentSpaces = contentSpaces;</span>
<span class="nc" id="L997">            this.trailingSpaces = trailingSpaces;</span>
<span class="nc" id="L998">            this.hasTab = hasTab;</span>
<span class="nc" id="L999">            this.spaceMap = spaceMap;</span>
<span class="nc" id="L1000">        }</span>
    }



    JustificationInfo getJustificationInfo(int rowStartOffset) {
<span class="nc bnc" id="L1006" title="All 2 branches missed.">        if (justificationInfo != null) {</span>
<span class="nc" id="L1007">            return justificationInfo;</span>
        }
        //states for the parsing
        final int TRAILING = 0;
        final int CONTENT  = 1;
        final int SPACES   = 2;
<span class="nc" id="L1013">        int startOffset = getStartOffset();</span>
<span class="nc" id="L1014">        int endOffset = getEndOffset();</span>
<span class="nc" id="L1015">        Segment segment = getText(startOffset, endOffset);</span>
<span class="nc" id="L1016">        int txtOffset = segment.offset;</span>
<span class="nc" id="L1017">        int txtEnd = segment.offset + segment.count - 1;</span>
<span class="nc" id="L1018">        int startContentPosition = txtEnd + 1;</span>
<span class="nc" id="L1019">        int endContentPosition = txtOffset - 1;</span>
<span class="nc" id="L1020">        int lastTabPosition = txtOffset - 1;</span>
<span class="nc" id="L1021">        int trailingSpaces = 0;</span>
<span class="nc" id="L1022">        int contentSpaces = 0;</span>
<span class="nc" id="L1023">        int leadingSpaces = 0;</span>
<span class="nc" id="L1024">        boolean hasTab = false;</span>
<span class="nc" id="L1025">        BitSet spaceMap = new BitSet(endOffset - startOffset + 1);</span>

        //we parse conent to the right of the rightmost TAB only.
        //we are looking for the trailing and leading spaces.
        //position after the leading spaces (startContentPosition)
        //position before the trailing spaces (endContentPosition)
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        for (int i = txtEnd, state = TRAILING; i &gt;= txtOffset; i--) {</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">            if (' ' == segment.array[i]) {</span>
<span class="nc" id="L1033">                spaceMap.set(i - txtOffset);</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">                if (state == TRAILING) {</span>
<span class="nc" id="L1035">                    trailingSpaces++;</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">                } else if (state == CONTENT) {</span>
<span class="nc" id="L1037">                    state = SPACES;</span>
<span class="nc" id="L1038">                    leadingSpaces = 1;</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">                } else if (state == SPACES) {</span>
<span class="nc" id="L1040">                    leadingSpaces++;</span>
                }
<span class="nc bnc" id="L1042" title="All 2 branches missed.">            } else if ('\t' == segment.array[i]) {</span>
<span class="nc" id="L1043">                hasTab = true;</span>
<span class="nc" id="L1044">                break;</span>
            } else {
<span class="nc bnc" id="L1046" title="All 2 branches missed.">                if (state == TRAILING) {</span>
<span class="nc bnc" id="L1047" title="All 4 branches missed.">                    if ('\n' != segment.array[i]</span>
                          &amp;&amp; '\r' != segment.array[i]) {
<span class="nc" id="L1049">                        state = CONTENT;</span>
<span class="nc" id="L1050">                        endContentPosition = i;</span>
                    }
<span class="nc bnc" id="L1052" title="All 2 branches missed.">                } else if (state == CONTENT) {</span>
                    //do nothing
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                } else if (state == SPACES) {</span>
<span class="nc" id="L1055">                    contentSpaces += leadingSpaces;</span>
<span class="nc" id="L1056">                    leadingSpaces = 0;</span>
                }
<span class="nc" id="L1058">                startContentPosition = i;</span>
            }
        }

<span class="nc" id="L1062">        SegmentCache.releaseSharedSegment(segment);</span>

<span class="nc" id="L1064">        int startJustifiableContent = -1;</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        if (startContentPosition &lt; txtEnd) {</span>
<span class="nc" id="L1066">            startJustifiableContent =</span>
                startContentPosition - txtOffset;
        }
<span class="nc" id="L1069">        int endJustifiableContent = -1;</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">        if (endContentPosition &gt; txtOffset) {</span>
<span class="nc" id="L1071">            endJustifiableContent =</span>
                endContentPosition - txtOffset;
        }
<span class="nc" id="L1074">        justificationInfo =</span>
            new JustificationInfo(startJustifiableContent,
                                  endJustifiableContent,
                                  leadingSpaces,
                                  contentSpaces,
                                  trailingSpaces,
                                  hasTab,
                                  spaceMap);
<span class="nc" id="L1082">        return justificationInfo;</span>
    }

    // --- variables ------------------------------------------------

    /**
    * Used by paint() to store highlighted view positions
    */
<span class="nc" id="L1090">    private byte[] selections = null;</span>

    int offset;
    int length;
    // if it is an implied newline character
    boolean impliedCR;
    boolean skipWidth;

    /**
     * how to expand tabs
     */
    TabExpander expander;

    /** Cached minimum x-span value  */
<span class="nc" id="L1104">    private float minimumSpan = -1;</span>

    /** Cached breakpoints within the view  */
<span class="nc" id="L1107">    private int[] breakSpots = null;</span>

    /**
     * location for determining tab expansion against.
     */
    int x;

    /**
     * Glyph rendering functionality.
     */
    GlyphPainter painter;

    /**
     * The prototype painter used by default.
     */
    static GlyphPainter defaultPainter;

<span class="nc" id="L1124">    private JustificationInfo justificationInfo = null;</span>

    /**
     * A class to perform rendering of the glyphs.
     * This can be implemented to be stateless, or
     * to hold some information as a cache to
     * facilitate faster rendering and model/view
     * translation.  At a minimum, the GlyphPainter
     * allows a View implementation to perform its
     * duties independant of a particular version
     * of JVM and selection of capabilities (i.e.
     * shaping for i18n, etc).
     *
     * @since 1.3
     */
<span class="nc" id="L1139">    public static abstract class GlyphPainter {</span>

        /**
         * Determine the span the glyphs given a start location
         * (for tab expansion).
         */
        public abstract float getSpan(GlyphView v, int p0, int p1, TabExpander e, float x);

        public abstract float getHeight(GlyphView v);

        public abstract float getAscent(GlyphView v);

        public abstract float getDescent(GlyphView v);

        /**
         * Paint the glyphs representing the given range.
         */
        public abstract void paint(GlyphView v, Graphics g, Shape a, int p0, int p1);

        /**
         * Provides a mapping from the document model coordinate space
         * to the coordinate space of the view mapped to it.
         * This is shared by the broken views.
         *
         * @param v     the &lt;code&gt;GlyphView&lt;/code&gt; containing the
         *              destination coordinate space
         * @param pos   the position to convert
         * @param bias  either &lt;code&gt;Position.Bias.Forward&lt;/code&gt;
         *                  or &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
         * @param a     Bounds of the View
         * @return      the bounding box of the given position
         * @exception BadLocationException  if the given position does not represent a
         *   valid location in the associated document
         * @see View#modelToView
         */
        public abstract Shape modelToView(GlyphView v,
                                          int pos, Position.Bias bias,
                                          Shape a) throws BadLocationException;

        /**
         * Provides a mapping from the view coordinate space to the logical
         * coordinate space of the model.
         *
         * @param v          the &lt;code&gt;GlyphView&lt;/code&gt; to provide a mapping for
         * @param x          the X coordinate
         * @param y          the Y coordinate
         * @param a          the allocated region to render into
         * @param biasReturn either &lt;code&gt;Position.Bias.Forward&lt;/code&gt;
         *                   or &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
         *                   is returned as the zero-th element of this array
         * @return the location within the model that best represents the
         *         given point of view
         * @see View#viewToModel
         */
        public abstract int viewToModel(GlyphView v,
                                        float x, float y, Shape a,
                                        Position.Bias[] biasReturn);

        /**
         * Determines the model location that represents the
         * maximum advance that fits within the given span.
         * This could be used to break the given view.  The result
         * should be a location just shy of the given advance.  This
         * differs from viewToModel which returns the closest
         * position which might be proud of the maximum advance.
         *
         * @param v the view to find the model location to break at.
         * @param p0 the location in the model where the
         *  fragment should start it's representation &amp;gt;= 0.
         * @param x  the graphic location along the axis that the
         *  broken view would occupy &amp;gt;= 0.  This may be useful for
         *  things like tab calculations.
         * @param len specifies the distance into the view
         *  where a potential break is desired &amp;gt;= 0.
         * @return the maximum model location possible for a break.
         * @see View#breakView
         */
        public abstract int getBoundedPosition(GlyphView v, int p0, float x, float len);

        /**
         * Create a painter to use for the given GlyphView.  If
         * the painter carries state it can create another painter
         * to represent a new GlyphView that is being created.  If
         * the painter doesn't hold any significant state, it can
         * return itself.  The default behavior is to return itself.
         * @param v  the &lt;code&gt;GlyphView&lt;/code&gt; to provide a painter for
         * @param p0 the starting document offset &amp;gt;= 0
         * @param p1 the ending document offset &amp;gt;= p0
         */
        public GlyphPainter getPainter(GlyphView v, int p0, int p1) {
<span class="nc" id="L1229">            return this;</span>
        }

        /**
         * Provides a way to determine the next visually represented model
         * location that one might place a caret.  Some views may not be
         * visible, they might not be in the same order found in the model, or
         * they just might not allow access to some of the locations in the
         * model.
         *
         * @param v the view to use
         * @param pos the position to convert &amp;gt;= 0
         * @param b   either &lt;code&gt;Position.Bias.Forward&lt;/code&gt;
         *                or &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
         * @param a the allocated region to render into
         * @param direction the direction from the current position that can
         *  be thought of as the arrow keys typically found on a keyboard.
         *  This may be SwingConstants.WEST, SwingConstants.EAST,
         *  SwingConstants.NORTH, or SwingConstants.SOUTH.
         * @param biasRet  either &lt;code&gt;Position.Bias.Forward&lt;/code&gt;
         *                 or &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
         *                 is returned as the zero-th element of this array
         * @return the location within the model that best represents the next
         *  location visual position.
         * @exception BadLocationException
         * @exception IllegalArgumentException for an invalid direction
         */
        public int getNextVisualPositionFrom(GlyphView v, int pos, Position.Bias b, Shape a,
                                             int direction,
                                             Position.Bias[] biasRet)
            throws BadLocationException {

<span class="nc" id="L1261">            int startOffset = v.getStartOffset();</span>
<span class="nc" id="L1262">            int endOffset = v.getEndOffset();</span>
            Segment text;

<span class="nc bnc" id="L1265" title="All 4 branches missed.">            switch (direction) {</span>
            case View.NORTH:
            case View.SOUTH:
<span class="nc bnc" id="L1268" title="All 2 branches missed.">                if (pos != -1) {</span>
                    // Presumably pos is between startOffset and endOffset,
                    // since GlyphView is only one line, we won't contain
                    // the position to the nort/south, therefore return -1.
<span class="nc" id="L1272">                    return -1;</span>
                }
<span class="nc" id="L1274">                Container container = v.getContainer();</span>

<span class="nc bnc" id="L1276" title="All 2 branches missed.">                if (container instanceof JTextComponent) {</span>
<span class="nc" id="L1277">                    Caret c = ((JTextComponent)container).getCaret();</span>
                    Point magicPoint;
<span class="nc bnc" id="L1279" title="All 2 branches missed.">                    magicPoint = (c != null) ? c.getMagicCaretPosition() :null;</span>

<span class="nc bnc" id="L1281" title="All 2 branches missed.">                    if (magicPoint == null) {</span>
<span class="nc" id="L1282">                        biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L1283">                        return startOffset;</span>
                    }
<span class="nc" id="L1285">                    int value = v.viewToModel(magicPoint.x, 0f, a, biasRet);</span>
<span class="nc" id="L1286">                    return value;</span>
                }
                break;
            case View.EAST:
<span class="nc bnc" id="L1290" title="All 2 branches missed.">                if(startOffset == v.getDocument().getLength()) {</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">                    if(pos == -1) {</span>
<span class="nc" id="L1292">                        biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L1293">                        return startOffset;</span>
                    }
                    // End case for bidi text where newline is at beginning
                    // of line.
<span class="nc" id="L1297">                    return -1;</span>
                }
<span class="nc bnc" id="L1299" title="All 2 branches missed.">                if(pos == -1) {</span>
<span class="nc" id="L1300">                    biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L1301">                    return startOffset;</span>
                }
<span class="nc bnc" id="L1303" title="All 2 branches missed.">                if(pos == endOffset) {</span>
<span class="nc" id="L1304">                    return -1;</span>
                }
<span class="nc bnc" id="L1306" title="All 2 branches missed.">                if(++pos == endOffset) {</span>
                    // Assumed not used in bidi text, GlyphPainter2 will
                    // override as necessary, therefore return -1.
<span class="nc" id="L1309">                    return -1;</span>
                }
                else {
<span class="nc" id="L1312">                    biasRet[0] = Position.Bias.Forward;</span>
                }
<span class="nc" id="L1314">                return pos;</span>
            case View.WEST:
<span class="nc bnc" id="L1316" title="All 2 branches missed.">                if(startOffset == v.getDocument().getLength()) {</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">                    if(pos == -1) {</span>
<span class="nc" id="L1318">                        biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L1319">                        return startOffset;</span>
                    }
                    // End case for bidi text where newline is at beginning
                    // of line.
<span class="nc" id="L1323">                    return -1;</span>
                }
<span class="nc bnc" id="L1325" title="All 2 branches missed.">                if(pos == -1) {</span>
                    // Assumed not used in bidi text, GlyphPainter2 will
                    // override as necessary, therefore return -1.
<span class="nc" id="L1328">                    biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L1329">                    return endOffset - 1;</span>
                }
<span class="nc bnc" id="L1331" title="All 2 branches missed.">                if(pos == startOffset) {</span>
<span class="nc" id="L1332">                    return -1;</span>
                }
<span class="nc" id="L1334">                biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L1335">                return (pos - 1);</span>
            default:
<span class="nc" id="L1337">                throw new IllegalArgumentException(&quot;Bad direction: &quot; + direction);</span>
            }
<span class="nc" id="L1339">            return pos;</span>

        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>