<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GapContent.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">GapContent.java</span></div><h1>GapContent.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.util.Vector;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import javax.swing.undo.AbstractUndoableEdit;
import javax.swing.undo.CannotRedoException;
import javax.swing.undo.CannotUndoException;
import javax.swing.undo.UndoableEdit;
import javax.swing.SwingUtilities;
import java.lang.ref.WeakReference;
import java.lang.ref.ReferenceQueue;

/**
 * An implementation of the AbstractDocument.Content interface
 * implemented using a gapped buffer similar to that used by emacs.
 * The underlying storage is a array of unicode characters with
 * a gap somewhere.  The gap is moved to the location of changes
 * to take advantage of common behavior where most changes are
 * in the same location.  Changes that occur at a gap boundary are
 * generally cheap and moving the gap is generally cheaper than
 * moving the array contents directly to accommodate the change.
 * &lt;p&gt;
 * The positions tracking change are also generally cheap to
 * maintain.  The Position implementations (marks) store the array
 * index and can easily calculate the sequential position from
 * the current gap location.  Changes only require update to the
 * the marks between the old and new gap boundaries when the gap
 * is moved, so generally updating the marks is pretty cheap.
 * The marks are stored sorted so they can be located quickly
 * with a binary search.  This increases the cost of adding a
 * mark, and decreases the cost of keeping the mark updated.
 *
 * @author  Timothy Prinzing
 */
public class GapContent extends GapVector implements AbstractDocument.Content, Serializable {

    /**
     * Creates a new GapContent object.  Initial size defaults to 10.
     */
    public GapContent() {
<span class="nc" id="L67">        this(10);</span>
<span class="nc" id="L68">    }</span>

    /**
     * Creates a new GapContent object, with the initial
     * size specified.  The initial size will not be allowed
     * to go below 2, to give room for the implied break and
     * the gap.
     *
     * @param initialLength the initial size
     */
    public GapContent(int initialLength) {
<span class="nc" id="L79">        super(Math.max(initialLength,2));</span>
<span class="nc" id="L80">        char[] implied = new char[1];</span>
<span class="nc" id="L81">        implied[0] = '\n';</span>
<span class="nc" id="L82">        replace(0, 0, implied, implied.length);</span>

<span class="nc" id="L84">        marks = new MarkVector();</span>
<span class="nc" id="L85">        search = new MarkData(0);</span>
<span class="nc" id="L86">        queue = new ReferenceQueue&lt;StickyPosition&gt;();</span>
<span class="nc" id="L87">    }</span>

    /**
     * Allocate an array to store items of the type
     * appropriate (which is determined by the subclass).
     */
    protected Object allocateArray(int len) {
<span class="nc" id="L94">        return new char[len];</span>
    }

    /**
     * Get the length of the allocated array.
     */
    protected int getArrayLength() {
<span class="nc" id="L101">        char[] carray = (char[]) getArray();</span>
<span class="nc" id="L102">        return carray.length;</span>
    }

    // --- AbstractDocument.Content methods -------------------------

    /**
     * Returns the length of the content.
     *
     * @return the length &amp;gt;= 1
     * @see AbstractDocument.Content#length
     */
    public int length() {
<span class="nc" id="L114">        int len = getArrayLength() - (getGapEnd() - getGapStart());</span>
<span class="nc" id="L115">        return len;</span>
    }

    /**
     * Inserts a string into the content.
     *
     * @param where the starting position &amp;gt;= 0, &amp;lt; length()
     * @param str the non-null string to insert
     * @return an UndoableEdit object for undoing
     * @exception BadLocationException if the specified position is invalid
     * @see AbstractDocument.Content#insertString
     */
    public UndoableEdit insertString(int where, String str) throws BadLocationException {
<span class="nc bnc" id="L128" title="All 4 branches missed.">        if (where &gt; length() || where &lt; 0) {</span>
<span class="nc" id="L129">            throw new BadLocationException(&quot;Invalid insert&quot;, length());</span>
        }
<span class="nc" id="L131">        char[] chars = str.toCharArray();</span>
<span class="nc" id="L132">        replace(where, 0, chars, chars.length);</span>
<span class="nc" id="L133">        return new InsertUndo(where, str.length());</span>
    }

    /**
     * Removes part of the content.
     *
     * @param where the starting position &amp;gt;= 0, where + nitems &amp;lt; length()
     * @param nitems the number of characters to remove &amp;gt;= 0
     * @return an UndoableEdit object for undoing
     * @exception BadLocationException if the specified position is invalid
     * @see AbstractDocument.Content#remove
     */
    public UndoableEdit remove(int where, int nitems) throws BadLocationException {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (where + nitems &gt;= length()) {</span>
<span class="nc" id="L147">            throw new BadLocationException(&quot;Invalid remove&quot;, length() + 1);</span>
        }
<span class="nc" id="L149">        String removedString = getString(where, nitems);</span>
<span class="nc" id="L150">        UndoableEdit edit = new RemoveUndo(where, removedString);</span>
<span class="nc" id="L151">        replace(where, nitems, empty, 0);</span>
<span class="nc" id="L152">        return edit;</span>

    }

    /**
     * Retrieves a portion of the content.
     *
     * @param where the starting position &amp;gt;= 0
     * @param len the length to retrieve &amp;gt;= 0
     * @return a string representing the content
     * @exception BadLocationException if the specified position is invalid
     * @see AbstractDocument.Content#getString
     */
    public String getString(int where, int len) throws BadLocationException {
<span class="nc" id="L166">        Segment s = new Segment();</span>
<span class="nc" id="L167">        getChars(where, len, s);</span>
<span class="nc" id="L168">        return new String(s.array, s.offset, s.count);</span>
    }

    /**
     * Retrieves a portion of the content.  If the desired content spans
     * the gap, we copy the content.  If the desired content does not
     * span the gap, the actual store is returned to avoid the copy since
     * it is contiguous.
     *
     * @param where the starting position &amp;gt;= 0, where + len &amp;lt;= length()
     * @param len the number of characters to retrieve &amp;gt;= 0
     * @param chars the Segment object to return the characters in
     * @exception BadLocationException if the specified position is invalid
     * @see AbstractDocument.Content#getChars
     */
    public void getChars(int where, int len, Segment chars) throws BadLocationException {
<span class="nc" id="L184">        int end = where + len;</span>
<span class="nc bnc" id="L185" title="All 4 branches missed.">        if (where &lt; 0 || end &lt; 0) {</span>
<span class="nc" id="L186">            throw new BadLocationException(&quot;Invalid location&quot;, -1);</span>
        }
<span class="nc bnc" id="L188" title="All 4 branches missed.">        if (end &gt; length() || where &gt; length()) {</span>
<span class="nc" id="L189">            throw new BadLocationException(&quot;Invalid location&quot;, length() + 1);</span>
        }
<span class="nc" id="L191">        int g0 = getGapStart();</span>
<span class="nc" id="L192">        int g1 = getGapEnd();</span>
<span class="nc" id="L193">        char[] array = (char[]) getArray();</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if ((where + len) &lt;= g0) {</span>
            // below gap
<span class="nc" id="L196">            chars.array = array;</span>
<span class="nc" id="L197">            chars.offset = where;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">        } else if (where &gt;= g0) {</span>
            // above gap
<span class="nc" id="L200">            chars.array = array;</span>
<span class="nc" id="L201">            chars.offset = g1 + where - g0;</span>
        } else {
            // spans the gap
<span class="nc" id="L204">            int before = g0 - where;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (chars.isPartialReturn()) {</span>
                // partial return allowed, return amount before the gap
<span class="nc" id="L207">                chars.array = array;</span>
<span class="nc" id="L208">                chars.offset = where;</span>
<span class="nc" id="L209">                chars.count = before;</span>
<span class="nc" id="L210">                return;</span>
            }
            // partial return not allowed, must copy
<span class="nc" id="L213">            chars.array = new char[len];</span>
<span class="nc" id="L214">            chars.offset = 0;</span>
<span class="nc" id="L215">            System.arraycopy(array, where, chars.array, 0, before);</span>
<span class="nc" id="L216">            System.arraycopy(array, g1, chars.array, before, len - before);</span>
        }
<span class="nc" id="L218">        chars.count = len;</span>
<span class="nc" id="L219">    }</span>

    /**
     * Creates a position within the content that will
     * track change as the content is mutated.
     *
     * @param offset the offset to track &amp;gt;= 0
     * @return the position
     * @exception BadLocationException if the specified position is invalid
     */
    public Position createPosition(int offset) throws BadLocationException {
<span class="nc bnc" id="L230" title="All 2 branches missed.">        while ( queue.poll() != null ) {</span>
<span class="nc" id="L231">            unusedMarks++;</span>
        }
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (unusedMarks &gt; Math.max(5, (marks.size() / 10))) {</span>
<span class="nc" id="L234">            removeUnusedMarks();</span>
        }
<span class="nc" id="L236">        int g0 = getGapStart();</span>
<span class="nc" id="L237">        int g1 = getGapEnd();</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        int index = (offset &lt; g0) ? offset : offset + (g1 - g0);</span>
<span class="nc" id="L239">        search.index = index;</span>
<span class="nc" id="L240">        int sortIndex = findSortIndex(search);</span>
        MarkData m;
        StickyPosition position;
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (sortIndex &lt; marks.size()</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            &amp;&amp; (m = marks.elementAt(sortIndex)).index == index</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">            &amp;&amp; (position = m.getPosition()) != null) {</span>
            //position references the correct StickyPostition
        } else {
<span class="nc" id="L248">            position = new StickyPosition();</span>
<span class="nc" id="L249">            m = new MarkData(index,position,queue);</span>
<span class="nc" id="L250">            position.setMark(m);</span>
<span class="nc" id="L251">            marks.insertElementAt(m, sortIndex);</span>
        }

<span class="nc" id="L254">        return position;</span>
    }

    /**
     * Holds the data for a mark... separately from
     * the real mark so that the real mark (Position
     * that the caller of createPosition holds) can be
     * collected if there are no more references to
     * it.  The update table holds only a reference
     * to this data.
     */
    final class MarkData extends WeakReference&lt;StickyPosition&gt; {

<span class="nc" id="L267">        MarkData(int index) {</span>
<span class="nc" id="L268">            super(null);</span>
<span class="nc" id="L269">            this.index = index;</span>
<span class="nc" id="L270">        }</span>
<span class="nc" id="L271">        MarkData(int index, StickyPosition position, ReferenceQueue&lt;? super StickyPosition&gt; queue) {</span>
<span class="nc" id="L272">            super(position, queue);</span>
<span class="nc" id="L273">            this.index = index;</span>
<span class="nc" id="L274">        }</span>

        /**
         * Fetch the location in the contiguous sequence
         * being modeled.  The index in the gap array
         * is held by the mark, so it is adjusted according
         * to it's relationship to the gap.
         */
        public final int getOffset() {
<span class="nc" id="L283">            int g0 = getGapStart();</span>
<span class="nc" id="L284">            int g1 = getGapEnd();</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">            int offs = (index &lt; g0) ? index : index - (g1 - g0);</span>
<span class="nc" id="L286">            return Math.max(offs, 0);</span>
        }

        StickyPosition getPosition() {
<span class="nc" id="L290">            return get();</span>
        }
        int index;
    }

    final class StickyPosition implements Position {

<span class="nc" id="L297">        StickyPosition() {</span>
<span class="nc" id="L298">        }</span>

        void setMark(MarkData mark) {
<span class="nc" id="L301">            this.mark = mark;</span>
<span class="nc" id="L302">        }</span>

        public final int getOffset() {
<span class="nc" id="L305">            return mark.getOffset();</span>
        }

        public String toString() {
<span class="nc" id="L309">            return Integer.toString(getOffset());</span>
        }

        MarkData mark;
    }

    // --- variables --------------------------------------

<span class="nc" id="L317">    private static final char[] empty = new char[0];</span>
    private transient MarkVector marks;

    /**
     * Record used for searching for the place to
     * start updating mark indexs when the gap
     * boundaries are moved.
     */
    private transient MarkData search;

    /**
     * The number of unused mark entries
     */
<span class="nc" id="L330">    private transient int unusedMarks = 0;</span>

    private transient ReferenceQueue&lt;StickyPosition&gt; queue;

    final static int GROWTH_SIZE = 1024 * 512;

    // --- gap management -------------------------------

    /**
     * Make the gap bigger, moving any necessary data and updating
     * the appropriate marks
     */
    protected void shiftEnd(int newSize) {
<span class="nc" id="L343">        int oldGapEnd = getGapEnd();</span>

<span class="nc" id="L345">        super.shiftEnd(newSize);</span>

        // Adjust marks.
<span class="nc" id="L348">        int dg = getGapEnd() - oldGapEnd;</span>
<span class="nc" id="L349">        int adjustIndex = findMarkAdjustIndex(oldGapEnd);</span>
<span class="nc" id="L350">        int n = marks.size();</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">        for (int i = adjustIndex; i &lt; n; i++) {</span>
<span class="nc" id="L352">            MarkData mark = marks.elementAt(i);</span>
<span class="nc" id="L353">            mark.index += dg;</span>
        }
<span class="nc" id="L355">    }</span>

    /**
     * Overridden to make growth policy less agressive for large
     * text amount.
     */
    int getNewArraySize(int reqSize) {
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (reqSize &lt; GROWTH_SIZE) {</span>
<span class="nc" id="L363">            return super.getNewArraySize(reqSize);</span>
        } else {
<span class="nc" id="L365">            return reqSize + GROWTH_SIZE;</span>
        }
    }

    /**
     * Move the start of the gap to a new location,
     * without changing the size of the gap.  This
     * moves the data in the array and updates the
     * marks accordingly.
     */
    protected void shiftGap(int newGapStart) {
<span class="nc" id="L376">        int oldGapStart = getGapStart();</span>
<span class="nc" id="L377">        int dg = newGapStart - oldGapStart;</span>
<span class="nc" id="L378">        int oldGapEnd = getGapEnd();</span>
<span class="nc" id="L379">        int newGapEnd = oldGapEnd + dg;</span>
<span class="nc" id="L380">        int gapSize = oldGapEnd - oldGapStart;</span>

        // shift gap in the character array
<span class="nc" id="L383">        super.shiftGap(newGapStart);</span>

        // update the marks
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (dg &gt; 0) {</span>
            // Move gap up, move data and marks down.
<span class="nc" id="L388">            int adjustIndex = findMarkAdjustIndex(oldGapStart);</span>
<span class="nc" id="L389">            int n = marks.size();</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            for (int i = adjustIndex; i &lt; n; i++) {</span>
<span class="nc" id="L391">                MarkData mark = marks.elementAt(i);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                if (mark.index &gt;= newGapEnd) {</span>
<span class="nc" id="L393">                    break;</span>
                }
<span class="nc" id="L395">                mark.index -= gapSize;</span>
            }
<span class="nc bnc" id="L397" title="All 2 branches missed.">        } else if (dg &lt; 0) {</span>
            // Move gap down, move data and marks up.
<span class="nc" id="L399">            int adjustIndex = findMarkAdjustIndex(newGapStart);</span>
<span class="nc" id="L400">            int n = marks.size();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">            for (int i = adjustIndex; i &lt; n; i++) {</span>
<span class="nc" id="L402">                MarkData mark = marks.elementAt(i);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                if (mark.index &gt;= oldGapEnd) {</span>
<span class="nc" id="L404">                    break;</span>
                }
<span class="nc" id="L406">                mark.index += gapSize;</span>
            }
        }
<span class="nc" id="L409">        resetMarksAtZero();</span>
<span class="nc" id="L410">    }</span>

    /**
     * Resets all the marks that have an offset of 0 to have an index of
     * zero as well.
     */
    protected void resetMarksAtZero() {
<span class="nc bnc" id="L417" title="All 4 branches missed.">        if (marks != null &amp;&amp; getGapStart() == 0) {</span>
<span class="nc" id="L418">            int g1 = getGapEnd();</span>
<span class="nc" id="L419">            for (int counter = 0, maxCounter = marks.size();</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                 counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L421">                MarkData mark = marks.elementAt(counter);</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                if (mark.index &lt;= g1) {</span>
<span class="nc" id="L423">                    mark.index = 0;</span>
                }
                else {
                    break;
                }
            }
        }
<span class="nc" id="L430">    }</span>

    /**
     * Adjust the gap end downward.  This doesn't move
     * any data, but it does update any marks affected
     * by the boundary change.  All marks from the old
     * gap start down to the new gap start are squeezed
     * to the end of the gap (their location has been
     * removed).
     */
    protected void shiftGapStartDown(int newGapStart) {
        // Push aside all marks from oldGapStart down to newGapStart.
<span class="nc" id="L442">        int adjustIndex = findMarkAdjustIndex(newGapStart);</span>
<span class="nc" id="L443">        int n = marks.size();</span>
<span class="nc" id="L444">        int g0 = getGapStart();</span>
<span class="nc" id="L445">        int g1 = getGapEnd();</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        for (int i = adjustIndex; i &lt; n; i++) {</span>
<span class="nc" id="L447">            MarkData mark = marks.elementAt(i);</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (mark.index &gt; g0) {</span>
                // no more marks to adjust
<span class="nc" id="L450">                break;</span>
            }
<span class="nc" id="L452">            mark.index = g1;</span>
        }

        // shift the gap in the character array
<span class="nc" id="L456">        super.shiftGapStartDown(newGapStart);</span>

<span class="nc" id="L458">        resetMarksAtZero();</span>
<span class="nc" id="L459">    }</span>

    /**
     * Adjust the gap end upward.  This doesn't move
     * any data, but it does update any marks affected
     * by the boundary change. All marks from the old
     * gap end up to the new gap end are squeezed
     * to the end of the gap (their location has been
     * removed).
     */
    protected void shiftGapEndUp(int newGapEnd) {
<span class="nc" id="L470">        int adjustIndex = findMarkAdjustIndex(getGapEnd());</span>
<span class="nc" id="L471">        int n = marks.size();</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">        for (int i = adjustIndex; i &lt; n; i++) {</span>
<span class="nc" id="L473">            MarkData mark = marks.elementAt(i);</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">            if (mark.index &gt;= newGapEnd) {</span>
<span class="nc" id="L475">                break;</span>
            }
<span class="nc" id="L477">            mark.index = newGapEnd;</span>
        }

        // shift the gap in the character array
<span class="nc" id="L481">        super.shiftGapEndUp(newGapEnd);</span>

<span class="nc" id="L483">        resetMarksAtZero();</span>
<span class="nc" id="L484">    }</span>

    /**
     * Compares two marks.
     *
     * @param o1 the first object
     * @param o2 the second object
     * @return &lt; 0 if o1 &lt; o2, 0 if the same, &gt; 0 if o1 &gt; o2
     */
    final int compare(MarkData o1, MarkData o2) {
<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (o1.index &lt; o2.index) {</span>
<span class="nc" id="L495">            return -1;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        } else if (o1.index &gt; o2.index) {</span>
<span class="nc" id="L497">            return 1;</span>
        } else {
<span class="nc" id="L499">            return 0;</span>
        }
    }

    /**
     * Finds the index to start mark adjustments given
     * some search index.
     */
    final int findMarkAdjustIndex(int searchIndex) {
<span class="nc" id="L508">        search.index = Math.max(searchIndex, 1);</span>
<span class="nc" id="L509">        int index = findSortIndex(search);</span>

        // return the first in the series
        // (ie. there may be duplicates).
<span class="nc bnc" id="L513" title="All 2 branches missed.">        for (int i = index - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L514">            MarkData d = marks.elementAt(i);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            if (d.index != search.index) {</span>
<span class="nc" id="L516">                break;</span>
            }
<span class="nc" id="L518">            index -= 1;</span>
        }
<span class="nc" id="L520">        return index;</span>
    }

    /**
     * Finds the index of where to insert a new mark.
     *
     * @param o the mark to insert
     * @return the index
     */
    final int findSortIndex(MarkData o) {
<span class="nc" id="L530">        int lower = 0;</span>
<span class="nc" id="L531">        int upper = marks.size() - 1;</span>
<span class="nc" id="L532">        int mid = 0;</span>

<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (upper == -1) {</span>
<span class="nc" id="L535">            return 0;</span>
        }

        int cmp;
<span class="nc" id="L539">        MarkData last = marks.elementAt(upper);</span>
<span class="nc" id="L540">        cmp = compare(o, last);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (cmp &gt; 0)</span>
<span class="nc" id="L542">            return upper + 1;</span>

<span class="nc bnc" id="L544" title="All 2 branches missed.">        while (lower &lt;= upper) {</span>
<span class="nc" id="L545">            mid = lower + ((upper - lower) / 2);</span>
<span class="nc" id="L546">            MarkData entry = marks.elementAt(mid);</span>
<span class="nc" id="L547">            cmp = compare(o, entry);</span>

<span class="nc bnc" id="L549" title="All 2 branches missed.">            if (cmp == 0) {</span>
                // found a match
<span class="nc" id="L551">                return mid;</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            } else if (cmp &lt; 0) {</span>
<span class="nc" id="L553">                upper = mid - 1;</span>
            } else {
<span class="nc" id="L555">                lower = mid + 1;</span>
            }
<span class="nc" id="L557">        }</span>

        // didn't find it, but we indicate the index of where it would belong.
<span class="nc bnc" id="L560" title="All 2 branches missed.">        return (cmp &lt; 0) ? mid : mid + 1;</span>
    }

    /**
     * Remove all unused marks out of the sorted collection
     * of marks.
     */
    final void removeUnusedMarks() {
<span class="nc" id="L568">        int n = marks.size();</span>
<span class="nc" id="L569">        MarkVector cleaned = new MarkVector(n);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L571">            MarkData mark = marks.elementAt(i);</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">            if (mark.get() != null) {</span>
<span class="nc" id="L573">                cleaned.addElement(mark);</span>
            }
        }
<span class="nc" id="L576">        marks = cleaned;</span>
<span class="nc" id="L577">        unusedMarks = 0;</span>
<span class="nc" id="L578">    }</span>


    static class MarkVector extends GapVector {

        MarkVector() {
<span class="nc" id="L584">            super();</span>
<span class="nc" id="L585">        }</span>

        MarkVector(int size) {
<span class="nc" id="L588">            super(size);</span>
<span class="nc" id="L589">        }</span>

        /**
         * Allocate an array to store items of the type
         * appropriate (which is determined by the subclass).
         */
        protected Object allocateArray(int len) {
<span class="nc" id="L596">            return new MarkData[len];</span>
        }

        /**
         * Get the length of the allocated array
         */
        protected int getArrayLength() {
<span class="nc" id="L603">            MarkData[] marks = (MarkData[]) getArray();</span>
<span class="nc" id="L604">            return marks.length;</span>
        }

        /**
         * Returns the number of marks currently held
         */
        public int size() {
<span class="nc" id="L611">            int len = getArrayLength() - (getGapEnd() - getGapStart());</span>
<span class="nc" id="L612">            return len;</span>
        }

        /**
         * Inserts a mark into the vector
         */
        public void insertElementAt(MarkData m, int index) {
<span class="nc" id="L619">            oneMark[0] = m;</span>
<span class="nc" id="L620">            replace(index, 0, oneMark, 1);</span>
<span class="nc" id="L621">        }</span>

        /**
         * Add a mark to the end
         */
        public void addElement(MarkData m) {
<span class="nc" id="L627">            insertElementAt(m, size());</span>
<span class="nc" id="L628">        }</span>

        /**
         * Fetches the mark at the given index
         */
        public MarkData elementAt(int index) {
<span class="nc" id="L634">            int g0 = getGapStart();</span>
<span class="nc" id="L635">            int g1 = getGapEnd();</span>
<span class="nc" id="L636">            MarkData[] array = (MarkData[]) getArray();</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">            if (index &lt; g0) {</span>
                // below gap
<span class="nc" id="L639">                return array[index];</span>
            } else {
                // above gap
<span class="nc" id="L642">                index += g1 - g0;</span>
<span class="nc" id="L643">                return array[index];</span>
            }
        }

        /**
         * Replaces the elements in the specified range with the passed
         * in objects. This will NOT adjust the gap. The passed in indices
         * do not account for the gap, they are the same as would be used
         * int &lt;code&gt;elementAt&lt;/code&gt;.
         */
        protected void replaceRange(int start, int end, Object[] marks) {
<span class="nc" id="L654">            int g0 = getGapStart();</span>
<span class="nc" id="L655">            int g1 = getGapEnd();</span>
<span class="nc" id="L656">            int index = start;</span>
<span class="nc" id="L657">            int newIndex = 0;</span>
<span class="nc" id="L658">            Object[] array = (Object[]) getArray();</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">            if (start &gt;= g0) {</span>
                // Completely passed gap
<span class="nc" id="L661">                index += (g1 - g0);</span>
<span class="nc" id="L662">                end += (g1 - g0);</span>
            }
<span class="nc bnc" id="L664" title="All 2 branches missed.">            else if (end &gt;= g0) {</span>
                // straddles gap
<span class="nc" id="L666">                end += (g1 - g0);</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                while (index &lt; g0) {</span>
<span class="nc" id="L668">                    array[index++] = marks[newIndex++];</span>
                }
<span class="nc" id="L670">                index = g1;</span>
            }
            else {
                // below gap
<span class="nc bnc" id="L674" title="All 2 branches missed.">                while (index &lt; end) {</span>
<span class="nc" id="L675">                    array[index++] = marks[newIndex++];</span>
                }
            }
<span class="nc bnc" id="L678" title="All 2 branches missed.">            while (index &lt; end) {</span>
<span class="nc" id="L679">                array[index++] = marks[newIndex++];</span>
            }
<span class="nc" id="L681">        }</span>

<span class="nc" id="L683">        MarkData[] oneMark = new MarkData[1];</span>

    }

    // --- serialization -------------------------------------

    private void readObject(ObjectInputStream s)
      throws ClassNotFoundException, IOException {
<span class="nc" id="L691">        s.defaultReadObject();</span>
<span class="nc" id="L692">        marks = new MarkVector();</span>
<span class="nc" id="L693">        search = new MarkData(0);</span>
<span class="nc" id="L694">        queue = new ReferenceQueue&lt;StickyPosition&gt;();</span>
<span class="nc" id="L695">    }</span>


    // --- undo support --------------------------------------

    /**
     * Returns a Vector containing instances of UndoPosRef for the
     * Positions in the range
     * &lt;code&gt;offset&lt;/code&gt; to &lt;code&gt;offset&lt;/code&gt; + &lt;code&gt;length&lt;/code&gt;.
     * If &lt;code&gt;v&lt;/code&gt; is not null the matching Positions are placed in
     * there. The vector with the resulting Positions are returned.
     *
     * @param v the Vector to use, with a new one created on null
     * @param offset the starting offset &amp;gt;= 0
     * @param length the length &amp;gt;= 0
     * @return the set of instances
     */
    protected Vector getPositionsInRange(Vector v, int offset, int length) {
<span class="nc" id="L713">        int endOffset = offset + length;</span>
        int startIndex;
        int endIndex;
<span class="nc" id="L716">        int g0 = getGapStart();</span>
<span class="nc" id="L717">        int g1 = getGapEnd();</span>

        // Find the index of the marks.
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (offset &lt; g0) {</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">            if (offset == 0) {</span>
                // findMarkAdjustIndex start at 1!
<span class="nc" id="L723">                startIndex = 0;</span>
            }
            else {
<span class="nc" id="L726">                startIndex = findMarkAdjustIndex(offset);</span>
            }
<span class="nc bnc" id="L728" title="All 2 branches missed.">            if (endOffset &gt;= g0) {</span>
<span class="nc" id="L729">                endIndex = findMarkAdjustIndex(endOffset + (g1 - g0) + 1);</span>
            }
            else {
<span class="nc" id="L732">                endIndex = findMarkAdjustIndex(endOffset + 1);</span>
            }
        }
        else {
<span class="nc" id="L736">            startIndex = findMarkAdjustIndex(offset + (g1 - g0));</span>
<span class="nc" id="L737">            endIndex = findMarkAdjustIndex(endOffset + (g1 - g0) + 1);</span>
        }

<span class="nc bnc" id="L740" title="All 2 branches missed.">        Vector placeIn = (v == null) ? new Vector(Math.max(1, endIndex -</span>
                                                           startIndex)) : v;

<span class="nc bnc" id="L743" title="All 2 branches missed.">        for (int counter = startIndex; counter &lt; endIndex; counter++) {</span>
<span class="nc" id="L744">            placeIn.addElement(new UndoPosRef(marks.elementAt(counter)));</span>
        }
<span class="nc" id="L746">        return placeIn;</span>
    }

    /**
     * Resets the location for all the UndoPosRef instances
     * in &lt;code&gt;positions&lt;/code&gt;.
     * &lt;p&gt;
     * This is meant for internal usage, and is generally not of interest
     * to subclasses.
     *
     * @param positions the UndoPosRef instances to reset
     */
    protected void updateUndoPositions(Vector positions, int offset,
                                       int length) {
        // Find the indexs of the end points.
<span class="nc" id="L761">        int endOffset = offset + length;</span>
<span class="nc" id="L762">        int g1 = getGapEnd();</span>
        int startIndex;
<span class="nc" id="L764">        int endIndex = findMarkAdjustIndex(g1 + 1);</span>

<span class="nc bnc" id="L766" title="All 2 branches missed.">        if (offset != 0) {</span>
<span class="nc" id="L767">            startIndex = findMarkAdjustIndex(g1);</span>
        }
        else {
<span class="nc" id="L770">            startIndex = 0;</span>
        }

        // Reset the location of the refenences.
<span class="nc bnc" id="L774" title="All 2 branches missed.">        for(int counter = positions.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L775">            UndoPosRef ref = (UndoPosRef)positions.elementAt(counter);</span>
<span class="nc" id="L776">            ref.resetLocation(endOffset, g1);</span>
        }
        // We have to resort the marks in the range startIndex to endIndex.
        // We can take advantage of the fact that it will be in
        // increasing order, accept there will be a bunch of MarkData's with
        // the index g1 (or 0 if offset == 0) interspersed throughout.
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (startIndex &lt; endIndex) {</span>
<span class="nc" id="L783">            Object[] sorted = new Object[endIndex - startIndex];</span>
<span class="nc" id="L784">            int addIndex = 0;</span>
            int counter;
<span class="nc bnc" id="L786" title="All 2 branches missed.">            if (offset == 0) {</span>
                // If the offset is 0, the positions won't have incremented,
                // have to do the reverse thing.
                // Find the elements in startIndex whose index is 0
<span class="nc bnc" id="L790" title="All 2 branches missed.">                for (counter = startIndex; counter &lt; endIndex; counter++) {</span>
<span class="nc" id="L791">                    MarkData mark = marks.elementAt(counter);</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">                    if (mark.index == 0) {</span>
<span class="nc" id="L793">                        sorted[addIndex++] = mark;</span>
                    }
                }
<span class="nc bnc" id="L796" title="All 2 branches missed.">                for (counter = startIndex; counter &lt; endIndex; counter++) {</span>
<span class="nc" id="L797">                    MarkData mark = marks.elementAt(counter);</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">                    if (mark.index != 0) {</span>
<span class="nc" id="L799">                        sorted[addIndex++] = mark;</span>
                    }
                }
            }
            else {
<span class="nc bnc" id="L804" title="All 2 branches missed.">                for (counter = startIndex; counter &lt; endIndex; counter++) {</span>
<span class="nc" id="L805">                    MarkData mark = marks.elementAt(counter);</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">                    if (mark.index != g1) {</span>
<span class="nc" id="L807">                        sorted[addIndex++] = mark;</span>
                    }
                }
<span class="nc bnc" id="L810" title="All 2 branches missed.">                for (counter = startIndex; counter &lt; endIndex; counter++) {</span>
<span class="nc" id="L811">                    MarkData mark = marks.elementAt(counter);</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">                    if (mark.index == g1) {</span>
<span class="nc" id="L813">                        sorted[addIndex++] = mark;</span>
                    }
                }
            }
            // And replace
<span class="nc" id="L818">            marks.replaceRange(startIndex, endIndex, sorted);</span>
        }
<span class="nc" id="L820">    }</span>

    /**
     * Used to hold a reference to a Mark that is being reset as the
     * result of removing from the content.
     */
    final class UndoPosRef {
<span class="nc" id="L827">        UndoPosRef(MarkData rec) {</span>
<span class="nc" id="L828">            this.rec = rec;</span>
<span class="nc" id="L829">            this.undoLocation = rec.getOffset();</span>
<span class="nc" id="L830">        }</span>

        /**
         * Resets the location of the Position to the offset when the
         * receiver was instantiated.
         *
         * @param endOffset end location of inserted string.
         * @param g1 resulting end of gap.
         */
        protected void resetLocation(int endOffset, int g1) {
<span class="nc bnc" id="L840" title="All 2 branches missed.">            if (undoLocation != endOffset) {</span>
<span class="nc" id="L841">                this.rec.index = undoLocation;</span>
            }
            else {
<span class="nc" id="L844">                this.rec.index = g1;</span>
            }
<span class="nc" id="L846">        }</span>

        /** Previous Offset of rec. */
        protected int undoLocation;
        /** Mark to reset offset. */
        protected MarkData rec;
    } // End of GapContent.UndoPosRef


    /**
     * UnoableEdit created for inserts.
     */
    class InsertUndo extends AbstractUndoableEdit {
<span class="nc" id="L859">        protected InsertUndo(int offset, int length) {</span>
<span class="nc" id="L860">            super();</span>
<span class="nc" id="L861">            this.offset = offset;</span>
<span class="nc" id="L862">            this.length = length;</span>
<span class="nc" id="L863">        }</span>

        public void undo() throws CannotUndoException {
<span class="nc" id="L866">            super.undo();</span>
            try {
                // Get the Positions in the range being removed.
<span class="nc" id="L869">                posRefs = getPositionsInRange(null, offset, length);</span>
<span class="nc" id="L870">                string = getString(offset, length);</span>
<span class="nc" id="L871">                remove(offset, length);</span>
<span class="nc" id="L872">            } catch (BadLocationException bl) {</span>
<span class="nc" id="L873">              throw new CannotUndoException();</span>
<span class="nc" id="L874">            }</span>
<span class="nc" id="L875">        }</span>

        public void redo() throws CannotRedoException {
<span class="nc" id="L878">            super.redo();</span>
            try {
<span class="nc" id="L880">                insertString(offset, string);</span>
<span class="nc" id="L881">                string = null;</span>
                // Update the Positions that were in the range removed.
<span class="nc bnc" id="L883" title="All 2 branches missed.">                if(posRefs != null) {</span>
<span class="nc" id="L884">                    updateUndoPositions(posRefs, offset, length);</span>
<span class="nc" id="L885">                    posRefs = null;</span>
                }
<span class="nc" id="L887">            } catch (BadLocationException bl) {</span>
<span class="nc" id="L888">                throw new CannotRedoException();</span>
<span class="nc" id="L889">            }</span>
<span class="nc" id="L890">        }</span>

        /** Where string was inserted. */
        protected int offset;
        /** Length of string inserted. */
        protected int length;
        /** The string that was inserted. This will only be valid after an
         * undo. */
        protected String string;
        /** An array of instances of UndoPosRef for the Positions in the
         * range that was removed, valid after undo. */
        protected Vector posRefs;
    } // GapContent.InsertUndo


    /**
     * UndoableEdit created for removes.
     */
    class RemoveUndo extends AbstractUndoableEdit {
<span class="nc" id="L909">        protected RemoveUndo(int offset, String string) {</span>
<span class="nc" id="L910">            super();</span>
<span class="nc" id="L911">            this.offset = offset;</span>
<span class="nc" id="L912">            this.string = string;</span>
<span class="nc" id="L913">            this.length = string.length();</span>
<span class="nc" id="L914">            posRefs = getPositionsInRange(null, offset, length);</span>
<span class="nc" id="L915">        }</span>

        public void undo() throws CannotUndoException {
<span class="nc" id="L918">            super.undo();</span>
            try {
<span class="nc" id="L920">                insertString(offset, string);</span>
                // Update the Positions that were in the range removed.
<span class="nc bnc" id="L922" title="All 2 branches missed.">                if(posRefs != null) {</span>
<span class="nc" id="L923">                    updateUndoPositions(posRefs, offset, length);</span>
<span class="nc" id="L924">                    posRefs = null;</span>
                }
<span class="nc" id="L926">                string = null;</span>
<span class="nc" id="L927">            } catch (BadLocationException bl) {</span>
<span class="nc" id="L928">              throw new CannotUndoException();</span>
<span class="nc" id="L929">            }</span>
<span class="nc" id="L930">        }</span>

        public void redo() throws CannotRedoException {
<span class="nc" id="L933">            super.redo();</span>
            try {
<span class="nc" id="L935">                string = getString(offset, length);</span>
                // Get the Positions in the range being removed.
<span class="nc" id="L937">                posRefs = getPositionsInRange(null, offset, length);</span>
<span class="nc" id="L938">                remove(offset, length);</span>
<span class="nc" id="L939">            } catch (BadLocationException bl) {</span>
<span class="nc" id="L940">              throw new CannotRedoException();</span>
<span class="nc" id="L941">            }</span>
<span class="nc" id="L942">        }</span>

        /** Where the string was removed from. */
        protected int offset;
        /** Length of string removed. */
        protected int length;
        /** The string that was removed. This is valid when redo is valid. */
        protected String string;
        /** An array of instances of UndoPosRef for the Positions in the
         * range that was removed, valid before undo. */
        protected Vector posRefs;
    } // GapContent.RemoveUndo
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>