<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>WrappedPlainView.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">WrappedPlainView.java</span></div><h1>WrappedPlainView.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.awt.*;
import java.lang.ref.SoftReference;
import javax.swing.event.*;

/**
 * View of plain text (text with only one font and color)
 * that does line-wrapping.  This view expects that its
 * associated element has child elements that represent
 * the lines it should be wrapping.  It is implemented
 * as a vertical box that contains logical line views.
 * The logical line views are nested classes that render
 * the logical line as multiple physical line if the logical
 * line is too wide to fit within the allocation.  The
 * line views draw upon the outer class for its state
 * to reduce their memory requirements.
 * &lt;p&gt;
 * The line views do all of their rendering through the
 * &lt;code&gt;drawLine&lt;/code&gt; method which in turn does all of
 * its rendering through the &lt;code&gt;drawSelectedText&lt;/code&gt;
 * and &lt;code&gt;drawUnselectedText&lt;/code&gt; methods.  This
 * enables subclasses to easily specialize the rendering
 * without concern for the layout aspects.
 *
 * @author  Timothy Prinzing
 * @see     View
 */
public class WrappedPlainView extends BoxView implements TabExpander {

    /**
     * Creates a new WrappedPlainView.  Lines will be wrapped
     * on character boundaries.
     *
     * @param elem the element underlying the view
     */
    public WrappedPlainView(Element elem) {
<span class="nc" id="L62">        this(elem, false);</span>
<span class="nc" id="L63">    }</span>

    /**
     * Creates a new WrappedPlainView.  Lines can be wrapped on
     * either character or word boundaries depending upon the
     * setting of the wordWrap parameter.
     *
     * @param elem the element underlying the view
     * @param wordWrap should lines be wrapped on word boundaries?
     */
    public WrappedPlainView(Element elem, boolean wordWrap) {
<span class="nc" id="L74">        super(elem, Y_AXIS);</span>
<span class="nc" id="L75">        this.wordWrap = wordWrap;</span>
<span class="nc" id="L76">    }</span>

    /**
     * Returns the tab size set for the document, defaulting to 8.
     *
     * @return the tab size
     */
    protected int getTabSize() {
<span class="nc" id="L84">        Integer i = (Integer) getDocument().getProperty(PlainDocument.tabSizeAttribute);</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">        int size = (i != null) ? i.intValue() : 8;</span>
<span class="nc" id="L86">        return size;</span>
    }

    /**
     * Renders a line of text, suppressing whitespace at the end
     * and expanding any tabs.  This is implemented to make calls
     * to the methods &lt;code&gt;drawUnselectedText&lt;/code&gt; and
     * &lt;code&gt;drawSelectedText&lt;/code&gt; so that the way selected and
     * unselected text are rendered can be customized.
     *
     * @param p0 the starting document location to use &amp;gt;= 0
     * @param p1 the ending document location to use &amp;gt;= p1
     * @param g the graphics context
     * @param x the starting X position &amp;gt;= 0
     * @param y the starting Y position &amp;gt;= 0
     * @see #drawUnselectedText
     * @see #drawSelectedText
     */
    protected void drawLine(int p0, int p1, Graphics g, int x, int y) {
<span class="nc" id="L105">        Element lineMap = getElement();</span>
<span class="nc" id="L106">        Element line = lineMap.getElement(lineMap.getElementIndex(p0));</span>
        Element elem;

        try {
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (line.isLeaf()) {</span>
<span class="nc" id="L111">                 drawText(line, p0, p1, g, x, y);</span>
            } else {
                // this line contains the composed text.
<span class="nc" id="L114">                int idx = line.getElementIndex(p0);</span>
<span class="nc" id="L115">                int lastIdx = line.getElementIndex(p1);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">                for(; idx &lt;= lastIdx; idx++) {</span>
<span class="nc" id="L117">                    elem = line.getElement(idx);</span>
<span class="nc" id="L118">                    int start = Math.max(elem.getStartOffset(), p0);</span>
<span class="nc" id="L119">                    int end = Math.min(elem.getEndOffset(), p1);</span>
<span class="nc" id="L120">                    x = drawText(elem, start, end, g, x, y);</span>
                }
            }
<span class="nc" id="L123">        } catch (BadLocationException e) {</span>
<span class="nc" id="L124">            throw new StateInvariantError(&quot;Can't render: &quot; + p0 + &quot;,&quot; + p1);</span>
<span class="nc" id="L125">        }</span>
<span class="nc" id="L126">    }</span>

    private int drawText(Element elem, int p0, int p1, Graphics g, int x, int y) throws BadLocationException {
<span class="nc" id="L129">        p1 = Math.min(getDocument().getLength(), p1);</span>
<span class="nc" id="L130">        AttributeSet attr = elem.getAttributes();</span>

<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (Utilities.isComposedTextAttributeDefined(attr)) {</span>
<span class="nc" id="L133">            g.setColor(unselected);</span>
<span class="nc" id="L134">            x = Utilities.drawComposedText(this, attr, g, x, y,</span>
<span class="nc" id="L135">                                        p0-elem.getStartOffset(),</span>
<span class="nc" id="L136">                                        p1-elem.getStartOffset());</span>
        } else {
<span class="nc bnc" id="L138" title="All 4 branches missed.">            if (sel0 == sel1 || selected == unselected) {</span>
                // no selection, or it is invisible
<span class="nc" id="L140">                x = drawUnselectedText(g, x, y, p0, p1);</span>
<span class="nc bnc" id="L141" title="All 8 branches missed.">            } else if ((p0 &gt;= sel0 &amp;&amp; p0 &lt;= sel1) &amp;&amp; (p1 &gt;= sel0 &amp;&amp; p1 &lt;= sel1)) {</span>
<span class="nc" id="L142">                x = drawSelectedText(g, x, y, p0, p1);</span>
<span class="nc bnc" id="L143" title="All 4 branches missed.">            } else if (sel0 &gt;= p0 &amp;&amp; sel0 &lt;= p1) {</span>
<span class="nc bnc" id="L144" title="All 4 branches missed.">                if (sel1 &gt;= p0 &amp;&amp; sel1 &lt;= p1) {</span>
<span class="nc" id="L145">                    x = drawUnselectedText(g, x, y, p0, sel0);</span>
<span class="nc" id="L146">                    x = drawSelectedText(g, x, y, sel0, sel1);</span>
<span class="nc" id="L147">                    x = drawUnselectedText(g, x, y, sel1, p1);</span>
                } else {
<span class="nc" id="L149">                    x = drawUnselectedText(g, x, y, p0, sel0);</span>
<span class="nc" id="L150">                    x = drawSelectedText(g, x, y, sel0, p1);</span>
                }
<span class="nc bnc" id="L152" title="All 4 branches missed.">            } else if (sel1 &gt;= p0 &amp;&amp; sel1 &lt;= p1) {</span>
<span class="nc" id="L153">                x = drawSelectedText(g, x, y, p0, sel1);</span>
<span class="nc" id="L154">                x = drawUnselectedText(g, x, y, sel1, p1);</span>
            } else {
<span class="nc" id="L156">                x = drawUnselectedText(g, x, y, p0, p1);</span>
            }
        }

<span class="nc" id="L160">        return x;</span>
    }

    /**
     * Renders the given range in the model as normal unselected
     * text.
     *
     * @param g the graphics context
     * @param x the starting X coordinate &amp;gt;= 0
     * @param y the starting Y coordinate &amp;gt;= 0
     * @param p0 the beginning position in the model &amp;gt;= 0
     * @param p1 the ending position in the model &amp;gt;= p0
     * @return the X location of the end of the range &amp;gt;= 0
     * @exception BadLocationException if the range is invalid
     */
    protected int drawUnselectedText(Graphics g, int x, int y,
                                     int p0, int p1) throws BadLocationException {
<span class="nc" id="L177">        g.setColor(unselected);</span>
<span class="nc" id="L178">        Document doc = getDocument();</span>
<span class="nc" id="L179">        Segment segment = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L180">        doc.getText(p0, p1 - p0, segment);</span>
<span class="nc" id="L181">        int ret = Utilities.drawTabbedText(this, segment, x, y, g, this, p0);</span>
<span class="nc" id="L182">        SegmentCache.releaseSharedSegment(segment);</span>
<span class="nc" id="L183">        return ret;</span>
    }

    /**
     * Renders the given range in the model as selected text.  This
     * is implemented to render the text in the color specified in
     * the hosting component.  It assumes the highlighter will render
     * the selected background.
     *
     * @param g the graphics context
     * @param x the starting X coordinate &amp;gt;= 0
     * @param y the starting Y coordinate &amp;gt;= 0
     * @param p0 the beginning position in the model &amp;gt;= 0
     * @param p1 the ending position in the model &amp;gt;= p0
     * @return the location of the end of the range.
     * @exception BadLocationException if the range is invalid
     */
    protected int drawSelectedText(Graphics g, int x,
                                   int y, int p0, int p1) throws BadLocationException {
<span class="nc" id="L202">        g.setColor(selected);</span>
<span class="nc" id="L203">        Document doc = getDocument();</span>
<span class="nc" id="L204">        Segment segment = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L205">        doc.getText(p0, p1 - p0, segment);</span>
<span class="nc" id="L206">        int ret = Utilities.drawTabbedText(this, segment, x, y, g, this, p0);</span>
<span class="nc" id="L207">        SegmentCache.releaseSharedSegment(segment);</span>
<span class="nc" id="L208">        return ret;</span>
    }

    /**
     * Gives access to a buffer that can be used to fetch
     * text from the associated document.
     *
     * @return the buffer
     */
    protected final Segment getLineBuffer() {
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (lineBuffer == null) {</span>
<span class="nc" id="L219">            lineBuffer = new Segment();</span>
        }
<span class="nc" id="L221">        return lineBuffer;</span>
    }

    /**
     * This is called by the nested wrapped line
     * views to determine the break location.  This can
     * be reimplemented to alter the breaking behavior.
     * It will either break at word or character boundaries
     * depending upon the break argument given at
     * construction.
     */
    protected int calculateBreakPosition(int p0, int p1) {
        int p;
<span class="nc" id="L234">        Segment segment = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L235">        loadText(segment, p0, p1);</span>
<span class="nc" id="L236">        int currentWidth = getWidth();</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (wordWrap) {</span>
<span class="nc" id="L238">            p = p0 + Utilities.getBreakLocation(segment, metrics,</span>
                                                tabBase, tabBase + currentWidth,
                                                this, p0);
        } else {
<span class="nc" id="L242">            p = p0 + Utilities.getTabbedTextOffset(segment, metrics,</span>
                                                   tabBase, tabBase + currentWidth,
                                                   this, p0, false);
        }
<span class="nc" id="L246">        SegmentCache.releaseSharedSegment(segment);</span>
<span class="nc" id="L247">        return p;</span>
    }

    /**
     * Loads all of the children to initialize the view.
     * This is called by the &lt;code&gt;setParent&lt;/code&gt; method.
     * Subclasses can reimplement this to initialize their
     * child views in a different manner.  The default
     * implementation creates a child view for each
     * child element.
     *
     * @param f the view factory
     */
    protected void loadChildren(ViewFactory f) {
<span class="nc" id="L261">        Element e = getElement();</span>
<span class="nc" id="L262">        int n = e.getElementCount();</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (n &gt; 0) {</span>
<span class="nc" id="L264">            View[] added = new View[n];</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L266">                added[i] = new WrappedLine(e.getElement(i));</span>
            }
<span class="nc" id="L268">            replace(0, 0, added);</span>
        }
<span class="nc" id="L270">    }</span>

    /**
     * Update the child views in response to a
     * document event.
     */
    void updateChildren(DocumentEvent e, Shape a) {
<span class="nc" id="L277">        Element elem = getElement();</span>
<span class="nc" id="L278">        DocumentEvent.ElementChange ec = e.getChange(elem);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (ec != null) {</span>
            // the structure of this element changed.
<span class="nc" id="L281">            Element[] removedElems = ec.getChildrenRemoved();</span>
<span class="nc" id="L282">            Element[] addedElems = ec.getChildrenAdded();</span>
<span class="nc" id="L283">            View[] added = new View[addedElems.length];</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">            for (int i = 0; i &lt; addedElems.length; i++) {</span>
<span class="nc" id="L285">                added[i] = new WrappedLine(addedElems[i]);</span>
            }
<span class="nc" id="L287">            replace(ec.getIndex(), removedElems.length, added);</span>

            // should damge a little more intelligently.
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (a != null) {</span>
<span class="nc" id="L291">                preferenceChanged(null, true, true);</span>
<span class="nc" id="L292">                getContainer().repaint();</span>
            }
        }

        // update font metrics which may be used by the child views
<span class="nc" id="L297">        updateMetrics();</span>
<span class="nc" id="L298">    }</span>

    /**
     * Load the text buffer with the given range
     * of text.  This is used by the fragments
     * broken off of this view as well as this
     * view itself.
     */
    final void loadText(Segment segment, int p0, int p1) {
        try {
<span class="nc" id="L308">            Document doc = getDocument();</span>
<span class="nc" id="L309">            doc.getText(p0, p1 - p0, segment);</span>
<span class="nc" id="L310">        } catch (BadLocationException bl) {</span>
<span class="nc" id="L311">            throw new StateInvariantError(&quot;Can't get line text&quot;);</span>
<span class="nc" id="L312">        }</span>
<span class="nc" id="L313">    }</span>

    final void updateMetrics() {
<span class="nc" id="L316">        Component host = getContainer();</span>
<span class="nc" id="L317">        Font f = host.getFont();</span>
<span class="nc" id="L318">        metrics = host.getFontMetrics(f);</span>
<span class="nc" id="L319">        tabSize = getTabSize() * metrics.charWidth('m');</span>
<span class="nc" id="L320">    }</span>

    // --- TabExpander methods ------------------------------------------

    /**
     * Returns the next tab stop position after a given reference position.
     * This implementation does not support things like centering so it
     * ignores the tabOffset argument.
     *
     * @param x the current position &amp;gt;= 0
     * @param tabOffset the position within the text stream
     *   that the tab occurred at &amp;gt;= 0.
     * @return the tab stop, measured in points &amp;gt;= 0
     */
    public float nextTabStop(float x, int tabOffset) {
<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (tabSize == 0)</span>
<span class="nc" id="L336">            return x;</span>
<span class="nc" id="L337">        int ntabs = ((int) x - tabBase) / tabSize;</span>
<span class="nc" id="L338">        return tabBase + ((ntabs + 1) * tabSize);</span>
    }


    // --- View methods -------------------------------------

    /**
     * Renders using the given rendering surface and area
     * on that surface.  This is implemented to stash the
     * selection positions, selection colors, and font
     * metrics for the nested lines to use.
     *
     * @param g the rendering surface to use
     * @param a the allocated region to render into
     *
     * @see View#paint
     */
    public void paint(Graphics g, Shape a) {
<span class="nc" id="L356">        Rectangle alloc = (Rectangle) a;</span>
<span class="nc" id="L357">        tabBase = alloc.x;</span>
<span class="nc" id="L358">        JTextComponent host = (JTextComponent) getContainer();</span>
<span class="nc" id="L359">        sel0 = host.getSelectionStart();</span>
<span class="nc" id="L360">        sel1 = host.getSelectionEnd();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        unselected = (host.isEnabled()) ?</span>
<span class="nc" id="L362">            host.getForeground() : host.getDisabledTextColor();</span>
<span class="nc" id="L363">        Caret c = host.getCaret();</span>
<span class="nc bnc" id="L364" title="All 4 branches missed.">        selected = c.isSelectionVisible() &amp;&amp; host.getHighlighter() != null ?</span>
<span class="nc" id="L365">                        host.getSelectedTextColor() : unselected;</span>
<span class="nc" id="L366">        g.setFont(host.getFont());</span>

        // superclass paints the children
<span class="nc" id="L369">        super.paint(g, a);</span>
<span class="nc" id="L370">    }</span>

    /**
     * Sets the size of the view.  This should cause
     * layout of the view along the given axis, if it
     * has any layout duties.
     *
     * @param width the width &amp;gt;= 0
     * @param height the height &amp;gt;= 0
     */
    public void setSize(float width, float height) {
<span class="nc" id="L381">        updateMetrics();</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">        if ((int) width != getWidth()) {</span>
            // invalidate the view itself since the desired widths
            // of the children will be based upon this views width.
<span class="nc" id="L385">            preferenceChanged(null, true, true);</span>
<span class="nc" id="L386">            widthChanging = true;</span>
        }
<span class="nc" id="L388">        super.setSize(width, height);</span>
<span class="nc" id="L389">        widthChanging = false;</span>
<span class="nc" id="L390">    }</span>

    /**
     * Determines the preferred span for this view along an
     * axis.  This is implemented to provide the superclass
     * behavior after first making sure that the current font
     * metrics are cached (for the nested lines which use
     * the metrics to determine the height of the potentially
     * wrapped lines).
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return  the span the view would like to be rendered into.
     *           Typically the view is told to render into the span
     *           that is returned, although there is no guarantee.
     *           The parent may choose to resize or break the view.
     * @see View#getPreferredSpan
     */
    public float getPreferredSpan(int axis) {
<span class="nc" id="L408">        updateMetrics();</span>
<span class="nc" id="L409">        return super.getPreferredSpan(axis);</span>
    }

    /**
     * Determines the minimum span for this view along an
     * axis.  This is implemented to provide the superclass
     * behavior after first making sure that the current font
     * metrics are cached (for the nested lines which use
     * the metrics to determine the height of the potentially
     * wrapped lines).
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return  the span the view would like to be rendered into.
     *           Typically the view is told to render into the span
     *           that is returned, although there is no guarantee.
     *           The parent may choose to resize or break the view.
     * @see View#getMinimumSpan
     */
    public float getMinimumSpan(int axis) {
<span class="nc" id="L428">        updateMetrics();</span>
<span class="nc" id="L429">        return super.getMinimumSpan(axis);</span>
    }

    /**
     * Determines the maximum span for this view along an
     * axis.  This is implemented to provide the superclass
     * behavior after first making sure that the current font
     * metrics are cached (for the nested lines which use
     * the metrics to determine the height of the potentially
     * wrapped lines).
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return  the span the view would like to be rendered into.
     *           Typically the view is told to render into the span
     *           that is returned, although there is no guarantee.
     *           The parent may choose to resize or break the view.
     * @see View#getMaximumSpan
     */
    public float getMaximumSpan(int axis) {
<span class="nc" id="L448">        updateMetrics();</span>
<span class="nc" id="L449">        return super.getMaximumSpan(axis);</span>
    }

    /**
     * Gives notification that something was inserted into the
     * document in a location that this view is responsible for.
     * This is implemented to simply update the children.
     *
     * @param e the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#insertUpdate
     */
    public void insertUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc" id="L463">        updateChildren(e, a);</span>

<span class="nc bnc" id="L465" title="All 4 branches missed.">        Rectangle alloc = ((a != null) &amp;&amp; isAllocationValid()) ?</span>
<span class="nc" id="L466">            getInsideAllocation(a) : null;</span>
<span class="nc" id="L467">        int pos = e.getOffset();</span>
<span class="nc" id="L468">        View v = getViewAtPosition(pos, alloc);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (v != null) {</span>
<span class="nc" id="L470">            v.insertUpdate(e, alloc, f);</span>
        }
<span class="nc" id="L472">    }</span>

    /**
     * Gives notification that something was removed from the
     * document in a location that this view is responsible for.
     * This is implemented to simply update the children.
     *
     * @param e the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#removeUpdate
     */
    public void removeUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc" id="L485">        updateChildren(e, a);</span>

<span class="nc bnc" id="L487" title="All 4 branches missed.">        Rectangle alloc = ((a != null) &amp;&amp; isAllocationValid()) ?</span>
<span class="nc" id="L488">            getInsideAllocation(a) : null;</span>
<span class="nc" id="L489">        int pos = e.getOffset();</span>
<span class="nc" id="L490">        View v = getViewAtPosition(pos, alloc);</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (v != null) {</span>
<span class="nc" id="L492">            v.removeUpdate(e, alloc, f);</span>
        }
<span class="nc" id="L494">    }</span>

    /**
     * Gives notification from the document that attributes were changed
     * in a location that this view is responsible for.
     *
     * @param e the change information from the associated document
     * @param a the current allocation of the view
     * @param f the factory to use to rebuild if the view has children
     * @see View#changedUpdate
     */
    public void changedUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc" id="L506">        updateChildren(e, a);</span>
<span class="nc" id="L507">    }</span>

    // --- variables -------------------------------------------

    FontMetrics metrics;
    Segment lineBuffer;
    boolean widthChanging;
    int tabBase;
    int tabSize;
    boolean wordWrap;

    int sel0;
    int sel1;
    Color unselected;
    Color selected;


    /**
     * Simple view of a line that wraps if it doesn't
     * fit withing the horizontal space allocated.
     * This class tries to be lightweight by carrying little
     * state of it's own and sharing the state of the outer class
     * with it's sibblings.
     */
    class WrappedLine extends View {

<span class="nc" id="L533">        WrappedLine(Element elem) {</span>
<span class="nc" id="L534">            super(elem);</span>
<span class="nc" id="L535">            lineCount = -1;</span>
<span class="nc" id="L536">        }</span>

        /**
         * Determines the preferred span for this view along an
         * axis.
         *
         * @param axis may be either X_AXIS or Y_AXIS
         * @return   the span the view would like to be rendered into.
         *           Typically the view is told to render into the span
         *           that is returned, although there is no guarantee.
         *           The parent may choose to resize or break the view.
         * @see View#getPreferredSpan
         */
        public float getPreferredSpan(int axis) {
<span class="nc bnc" id="L550" title="All 3 branches missed.">            switch (axis) {</span>
            case View.X_AXIS:
<span class="nc" id="L552">                float width = getWidth();</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">                if (width == Integer.MAX_VALUE) {</span>
                    // We have been initially set to MAX_VALUE, but we don't
                    // want this as our preferred.
<span class="nc" id="L556">                    return 100f;</span>
                }
<span class="nc" id="L558">                return width;</span>
            case View.Y_AXIS:
<span class="nc bnc" id="L560" title="All 4 branches missed.">                if (lineCount &lt; 0 || widthChanging) {</span>
<span class="nc" id="L561">                    breakLines(getStartOffset());</span>
                }
<span class="nc" id="L563">                return lineCount * metrics.getHeight();</span>
            default:
<span class="nc" id="L565">                throw new IllegalArgumentException(&quot;Invalid axis: &quot; + axis);</span>
            }
        }

        /**
         * Renders using the given rendering surface and area on that
         * surface.  The view may need to do layout and create child
         * views to enable itself to render into the given allocation.
         *
         * @param g the rendering surface to use
         * @param a the allocated region to render into
         * @see View#paint
         */
        public void paint(Graphics g, Shape a) {
<span class="nc" id="L579">            Rectangle alloc = (Rectangle) a;</span>
<span class="nc" id="L580">            int y = alloc.y + metrics.getAscent();</span>
<span class="nc" id="L581">            int x = alloc.x;</span>

<span class="nc" id="L583">            JTextComponent host = (JTextComponent)getContainer();</span>
<span class="nc" id="L584">            Highlighter h = host.getHighlighter();</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">            LayeredHighlighter dh = (h instanceof LayeredHighlighter) ?</span>
                                     (LayeredHighlighter)h : null;

<span class="nc" id="L588">            int start = getStartOffset();</span>
<span class="nc" id="L589">            int end = getEndOffset();</span>
<span class="nc" id="L590">            int p0 = start;</span>
<span class="nc" id="L591">            int[] lineEnds = getLineEnds();</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">            for (int i = 0; i &lt; lineCount; i++) {</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">                int p1 = (lineEnds == null) ? end :</span>
                                             start + lineEnds[i];
<span class="nc bnc" id="L595" title="All 2 branches missed.">                if (dh != null) {</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                    int hOffset = (p1 == end)</span>
                                  ? (p1 - 1)
                                  : p1;
<span class="nc" id="L599">                    dh.paintLayeredHighlights(g, p0, hOffset, a, host, this);</span>
                }
<span class="nc" id="L601">                drawLine(p0, p1, g, x, y);</span>

<span class="nc" id="L603">                p0 = p1;</span>
<span class="nc" id="L604">                y += metrics.getHeight();</span>
            }
<span class="nc" id="L606">        }</span>

        /**
         * Provides a mapping from the document model coordinate space
         * to the coordinate space of the view mapped to it.
         *
         * @param pos the position to convert
         * @param a the allocated region to render into
         * @return the bounding box of the given position is returned
         * @exception BadLocationException  if the given position does not represent a
         *   valid location in the associated document
         * @see View#modelToView
         */
        public Shape modelToView(int pos, Shape a, Position.Bias b)
                throws BadLocationException {
<span class="nc" id="L621">            Rectangle alloc = a.getBounds();</span>
<span class="nc" id="L622">            alloc.height = metrics.getHeight();</span>
<span class="nc" id="L623">            alloc.width = 1;</span>

<span class="nc" id="L625">            int p0 = getStartOffset();</span>
<span class="nc bnc" id="L626" title="All 4 branches missed.">            if (pos &lt; p0 || pos &gt; getEndOffset()) {</span>
<span class="nc" id="L627">                throw new BadLocationException(&quot;Position out of range&quot;, pos);</span>
            }

<span class="nc bnc" id="L630" title="All 2 branches missed.">            int testP = (b == Position.Bias.Forward) ? pos :</span>
<span class="nc" id="L631">                        Math.max(p0, pos - 1);</span>
<span class="nc" id="L632">            int line = 0;</span>
<span class="nc" id="L633">            int[] lineEnds = getLineEnds();</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">            if (lineEnds != null) {</span>
<span class="nc" id="L635">                line = findLine(testP - p0);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">                if (line &gt; 0) {</span>
<span class="nc" id="L637">                    p0 += lineEnds[line - 1];</span>
                }
<span class="nc" id="L639">                alloc.y += alloc.height * line;</span>
            }

<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (pos &gt; p0) {</span>
<span class="nc" id="L643">                Segment segment = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L644">                loadText(segment, p0, pos);</span>
<span class="nc" id="L645">                alloc.x += Utilities.getTabbedTextWidth(segment, metrics,</span>
                        alloc.x, WrappedPlainView.this, p0);
<span class="nc" id="L647">                SegmentCache.releaseSharedSegment(segment);</span>
            }
<span class="nc" id="L649">            return alloc;</span>
        }

        /**
         * Provides a mapping from the view coordinate space to the logical
         * coordinate space of the model.
         *
         * @param fx the X coordinate
         * @param fy the Y coordinate
         * @param a the allocated region to render into
         * @return the location within the model that best represents the
         *  given point in the view
         * @see View#viewToModel
         */
        public int viewToModel(float fx, float fy, Shape a, Position.Bias[] bias) {
            // PENDING(prinz) implement bias properly
<span class="nc" id="L665">            bias[0] = Position.Bias.Forward;</span>

<span class="nc" id="L667">            Rectangle alloc = (Rectangle) a;</span>
<span class="nc" id="L668">            int x = (int) fx;</span>
<span class="nc" id="L669">            int y = (int) fy;</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            if (y &lt; alloc.y) {</span>
                // above the area covered by this icon, so the the position
                // is assumed to be the start of the coverage for this view.
<span class="nc" id="L673">                return getStartOffset();</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">            } else if (y &gt; alloc.y + alloc.height) {</span>
                // below the area covered by this icon, so the the position
                // is assumed to be the end of the coverage for this view.
<span class="nc" id="L677">                return getEndOffset() - 1;</span>
            } else {
                // positioned within the coverage of this view vertically,
                // so we figure out which line the point corresponds to.
                // if the line is greater than the number of lines contained, then
                // simply use the last line as it represents the last possible place
                // we can position to.
<span class="nc" id="L684">                alloc.height = metrics.getHeight();</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">                int line = (alloc.height &gt; 0 ?</span>
                            (y - alloc.y) / alloc.height : lineCount - 1);
<span class="nc bnc" id="L687" title="All 2 branches missed.">                if (line &gt;= lineCount) {</span>
<span class="nc" id="L688">                    return getEndOffset() - 1;</span>
                } else {
<span class="nc" id="L690">                    int p0 = getStartOffset();</span>
                    int p1;
<span class="nc bnc" id="L692" title="All 2 branches missed.">                    if (lineCount == 1) {</span>
<span class="nc" id="L693">                        p1 = getEndOffset();</span>
                    } else {
<span class="nc" id="L695">                        int[] lineEnds = getLineEnds();</span>
<span class="nc" id="L696">                        p1 = p0 + lineEnds[line];</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">                        if (line &gt; 0) {</span>
<span class="nc" id="L698">                            p0 += lineEnds[line - 1];</span>
                        }
                    }

<span class="nc bnc" id="L702" title="All 2 branches missed.">                    if (x &lt; alloc.x) {</span>
                        // point is to the left of the line
<span class="nc" id="L704">                        return p0;</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                    } else if (x &gt; alloc.x + alloc.width) {</span>
                        // point is to the right of the line
<span class="nc" id="L707">                        return p1 - 1;</span>
                    } else {
                        // Determine the offset into the text
<span class="nc" id="L710">                        Segment segment = SegmentCache.getSharedSegment();</span>
<span class="nc" id="L711">                        loadText(segment, p0, p1);</span>
<span class="nc" id="L712">                        int n = Utilities.getTabbedTextOffset(segment, metrics,</span>
                                                   alloc.x, x,
                                                   WrappedPlainView.this, p0);
<span class="nc" id="L715">                        SegmentCache.releaseSharedSegment(segment);</span>
<span class="nc" id="L716">                        return Math.min(p0 + n, p1 - 1);</span>
                    }
                }
            }
        }

        public void insertUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc" id="L723">            update(e, a);</span>
<span class="nc" id="L724">        }</span>

        public void removeUpdate(DocumentEvent e, Shape a, ViewFactory f) {
<span class="nc" id="L727">            update(e, a);</span>
<span class="nc" id="L728">        }</span>

        private void update(DocumentEvent ev, Shape a) {
<span class="nc" id="L731">            int oldCount = lineCount;</span>
<span class="nc" id="L732">            breakLines(ev.getOffset());</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">            if (oldCount != lineCount) {</span>
<span class="nc" id="L734">                WrappedPlainView.this.preferenceChanged(this, false, true);</span>
                // have to repaint any views after the receiver.
<span class="nc" id="L736">                getContainer().repaint();</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">            } else if (a != null) {</span>
<span class="nc" id="L738">                Component c = getContainer();</span>
<span class="nc" id="L739">                Rectangle alloc = (Rectangle) a;</span>
<span class="nc" id="L740">                c.repaint(alloc.x, alloc.y, alloc.width, alloc.height);</span>
            }
<span class="nc" id="L742">        }</span>

        /**
         * Returns line cache. If the cache was GC'ed, recreates it.
         * If there's no cache, returns null
         */
        final int[] getLineEnds() {
<span class="nc bnc" id="L749" title="All 2 branches missed.">            if (lineCache == null) {</span>
<span class="nc" id="L750">                return null;</span>
            } else {
<span class="nc" id="L752">                int[] lineEnds = lineCache.get();</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                if (lineEnds == null) {</span>
                    // Cache was GC'ed, so rebuild it
<span class="nc" id="L755">                    return breakLines(getStartOffset());</span>
                } else {
<span class="nc" id="L757">                    return lineEnds;</span>
                }
            }
        }

        /**
         * Creates line cache if text breaks into more than one physical line.
         * @param startPos position to start breaking from
         * @return the cache created, ot null if text breaks into one line
         */
        final int[] breakLines(int startPos) {
<span class="nc bnc" id="L768" title="All 2 branches missed.">            int[] lineEnds = (lineCache == null) ? null : lineCache.get();</span>
<span class="nc" id="L769">            int[] oldLineEnds = lineEnds;</span>
<span class="nc" id="L770">            int start = getStartOffset();</span>
<span class="nc" id="L771">            int lineIndex = 0;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">            if (lineEnds != null) {</span>
<span class="nc" id="L773">                lineIndex = findLine(startPos - start);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">                if (lineIndex &gt; 0) {</span>
<span class="nc" id="L775">                    lineIndex--;</span>
                }
            }

<span class="nc bnc" id="L779" title="All 2 branches missed.">            int p0 = (lineIndex == 0) ? start : start + lineEnds[lineIndex - 1];</span>
<span class="nc" id="L780">            int p1 = getEndOffset();</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">            while (p0 &lt; p1) {</span>
<span class="nc" id="L782">                int p = calculateBreakPosition(p0, p1);</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">                p0 = (p == p0) ? ++p : p;      // 4410243</span>

<span class="nc bnc" id="L785" title="All 4 branches missed.">                if (lineIndex == 0 &amp;&amp; p0 &gt;= p1) {</span>
                    // do not use cache if there's only one line
<span class="nc" id="L787">                    lineCache = null;</span>
<span class="nc" id="L788">                    lineEnds = null;</span>
<span class="nc" id="L789">                    lineIndex = 1;</span>
<span class="nc" id="L790">                    break;</span>
<span class="nc bnc" id="L791" title="All 4 branches missed.">                } else if (lineEnds == null || lineIndex &gt;= lineEnds.length) {</span>
                    // we have 2+ lines, and the cache is not big enough
                    // we try to estimate total number of lines
<span class="nc" id="L794">                    double growFactor = ((double)(p1 - start) / (p0 - start));</span>
<span class="nc" id="L795">                    int newSize = (int)Math.ceil((lineIndex + 1) * growFactor);</span>
<span class="nc" id="L796">                    newSize = Math.max(newSize, lineIndex + 2);</span>
<span class="nc" id="L797">                    int[] tmp = new int[newSize];</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">                    if (lineEnds != null) {</span>
<span class="nc" id="L799">                        System.arraycopy(lineEnds, 0, tmp, 0, lineIndex);</span>
                    }
<span class="nc" id="L801">                    lineEnds = tmp;</span>
                }
<span class="nc" id="L803">                lineEnds[lineIndex++] = p0 - start;</span>
<span class="nc" id="L804">            }</span>

<span class="nc" id="L806">            lineCount = lineIndex;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">            if (lineCount &gt; 1) {</span>
                // check if the cache is too big
<span class="nc" id="L809">                int maxCapacity = lineCount + lineCount / 3;</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">                if (lineEnds.length &gt; maxCapacity) {</span>
<span class="nc" id="L811">                    int[] tmp = new int[maxCapacity];</span>
<span class="nc" id="L812">                    System.arraycopy(lineEnds, 0, tmp, 0, lineCount);</span>
<span class="nc" id="L813">                    lineEnds = tmp;</span>
                }
            }

<span class="nc bnc" id="L817" title="All 4 branches missed.">            if (lineEnds != null &amp;&amp; lineEnds != oldLineEnds) {</span>
<span class="nc" id="L818">                lineCache = new SoftReference&lt;int[]&gt;(lineEnds);</span>
            }
<span class="nc" id="L820">            return lineEnds;</span>
        }

        /**
         * Binary search in the cache for line containing specified offset
         * (which is relative to the beginning of the view). This method
         * assumes that cache exists.
         */
        private int findLine(int offset) {
<span class="nc" id="L829">            int[] lineEnds = lineCache.get();</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">            if (offset &lt; lineEnds[0]) {</span>
<span class="nc" id="L831">                return 0;</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">            } else if (offset &gt; lineEnds[lineCount - 1]) {</span>
<span class="nc" id="L833">                return lineCount;</span>
            } else {
<span class="nc" id="L835">                return findLine(lineEnds, offset, 0, lineCount - 1);</span>
            }
        }

        private int findLine(int[] array, int offset, int min, int max) {
<span class="nc bnc" id="L840" title="All 2 branches missed.">            if (max - min &lt;= 1) {</span>
<span class="nc" id="L841">                return max;</span>
            } else {
<span class="nc" id="L843">                int mid = (max + min) / 2;</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">                return (offset &lt; array[mid]) ?</span>
<span class="nc" id="L845">                        findLine(array, offset, min, mid) :</span>
<span class="nc" id="L846">                        findLine(array, offset, mid, max);</span>
            }
        }

        int lineCount;
<span class="nc" id="L851">        SoftReference&lt;int[]&gt; lineCache = null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>