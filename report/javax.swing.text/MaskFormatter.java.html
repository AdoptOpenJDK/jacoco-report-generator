<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MaskFormatter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">MaskFormatter.java</span></div><h1>MaskFormatter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.text;

import java.io.*;
import java.text.*;
import java.util.*;
import javax.swing.*;

/**
 * &lt;code&gt;MaskFormatter&lt;/code&gt; is used to format and edit strings. The behavior
 * of a &lt;code&gt;MaskFormatter&lt;/code&gt; is controlled by way of a String mask
 * that specifies the valid characters that can be contained at a particular
 * location in the &lt;code&gt;Document&lt;/code&gt; model. The following characters can
 * be specified:
 *
 * &lt;table border=1 summary=&quot;Valid characters and their descriptions&quot;&gt;
 * &lt;tr&gt;
 *    &lt;th&gt;Character&amp;nbsp;&lt;/th&gt;
 *    &lt;th&gt;&lt;p style=&quot;text-align:left&quot;&gt;Description&lt;/p&gt;&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *    &lt;td&gt;#&lt;/td&gt;
 *    &lt;td&gt;Any valid number, uses &lt;code&gt;Character.isDigit&lt;/code&gt;.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *    &lt;td&gt;'&lt;/td&gt;
 *    &lt;td&gt;Escape character, used to escape any of the
 *       special formatting characters.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 *    &lt;td&gt;U&lt;/td&gt;&lt;td&gt;Any character (&lt;code&gt;Character.isLetter&lt;/code&gt;). All
 *        lowercase letters are mapped to upper case.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;L&lt;/td&gt;&lt;td&gt;Any character (&lt;code&gt;Character.isLetter&lt;/code&gt;). All
 *        upper case letters are mapped to lower case.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;Any character or number (&lt;code&gt;Character.isLetter&lt;/code&gt;
 *       or &lt;code&gt;Character.isDigit&lt;/code&gt;)&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;?&lt;/td&gt;&lt;td&gt;Any character
 *        (&lt;code&gt;Character.isLetter&lt;/code&gt;).&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;*&lt;/td&gt;&lt;td&gt;Anything.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;H&lt;/td&gt;&lt;td&gt;Any hex character (0-9, a-f or A-F).&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;
 * Typically characters correspond to one char, but in certain languages this
 * is not the case. The mask is on a per character basis, and will thus
 * adjust to fit as many chars as are needed.
 * &lt;p&gt;
 * You can further restrict the characters that can be input by the
 * &lt;code&gt;setInvalidCharacters&lt;/code&gt; and &lt;code&gt;setValidCharacters&lt;/code&gt;
 * methods. &lt;code&gt;setInvalidCharacters&lt;/code&gt; allows you to specify
 * which characters are not legal. &lt;code&gt;setValidCharacters&lt;/code&gt; allows
 * you to specify which characters are valid. For example, the following
 * code block is equivalent to a mask of '0xHHH' with no invalid/valid
 * characters:
 * &lt;pre&gt;
 * MaskFormatter formatter = new MaskFormatter(&quot;0x***&quot;);
 * formatter.setValidCharacters(&quot;0123456789abcdefABCDEF&quot;);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * When initially formatting a value if the length of the string is
 * less than the length of the mask, two things can happen. Either
 * the placeholder string will be used, or the placeholder character will
 * be used. Precedence is given to the placeholder string. For example:
 * &lt;pre&gt;
 *   MaskFormatter formatter = new MaskFormatter(&quot;###-####&quot;);
 *   formatter.setPlaceholderCharacter('_');
 *   formatter.getDisplayValue(tf, &quot;123&quot;);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Would result in the string '123-____'. If
 * &lt;code&gt;setPlaceholder(&quot;555-1212&quot;)&lt;/code&gt; was invoked '123-1212' would
 * result. The placeholder String is only used on the initial format,
 * on subsequent formats only the placeholder character will be used.
 * &lt;p&gt;
 * If a &lt;code&gt;MaskFormatter&lt;/code&gt; is configured to only allow valid characters
 * (&lt;code&gt;setAllowsInvalid(false)&lt;/code&gt;) literal characters will be skipped as
 * necessary when editing. Consider a &lt;code&gt;MaskFormatter&lt;/code&gt; with
 * the mask &quot;###-####&quot; and current value &quot;555-1212&quot;. Using the right
 * arrow key to navigate through the field will result in (| indicates the
 * position of the caret):
 * &lt;pre&gt;
 *   |555-1212
 *   5|55-1212
 *   55|5-1212
 *   555-|1212
 *   555-1|212
 * &lt;/pre&gt;
 * The '-' is a literal (non-editable) character, and is skipped.
 * &lt;p&gt;
 * Similar behavior will result when editing. Consider inserting the string
 * '123-45' and '12345' into the &lt;code&gt;MaskFormatter&lt;/code&gt; in the
 * previous example. Both inserts will result in the same String,
 * '123-45__'. When &lt;code&gt;MaskFormatter&lt;/code&gt;
 * is processing the insert at character position 3 (the '-'), two things can
 * happen:
 * &lt;ol&gt;
 *   &lt;li&gt;If the inserted character is '-', it is accepted.
 *   &lt;li&gt;If the inserted character matches the mask for the next non-literal
 *       character, it is accepted at the new location.
 *   &lt;li&gt;Anything else results in an invalid edit
 * &lt;/ol&gt;
 * &lt;p&gt;
 * By default &lt;code&gt;MaskFormatter&lt;/code&gt; will not allow invalid edits, you can
 * change this with the &lt;code&gt;setAllowsInvalid&lt;/code&gt; method, and will
 * commit edits on valid edits (use the &lt;code&gt;setCommitsOnValidEdit&lt;/code&gt; to
 * change this).
 * &lt;p&gt;
 * By default, &lt;code&gt;MaskFormatter&lt;/code&gt; is in overwrite mode. That is as
 * characters are typed a new character is not inserted, rather the character
 * at the current location is replaced with the newly typed character. You
 * can change this behavior by way of the method &lt;code&gt;setOverwriteMode&lt;/code&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @since 1.4
 */
public class MaskFormatter extends DefaultFormatter {
    // Potential values in mask.
    private static final char DIGIT_KEY = '#';
    private static final char LITERAL_KEY = '\'';
    private static final char UPPERCASE_KEY = 'U';
    private static final char LOWERCASE_KEY = 'L';
    private static final char ALPHA_NUMERIC_KEY = 'A';
    private static final char CHARACTER_KEY = '?';
    private static final char ANYTHING_KEY = '*';
    private static final char HEX_KEY = 'H';

<span class="nc" id="L163">    private static final MaskCharacter[] EmptyMaskChars = new MaskCharacter[0];</span>

    /** The user specified mask. */
    private String mask;

    private transient MaskCharacter[] maskChars;

    /** List of valid characters. */
    private String validCharacters;

    /** List of invalid characters. */
    private String invalidCharacters;

    /** String used for the passed in value if it does not completely
     * fill the mask. */
    private String placeholderString;

    /** String used to represent characters not present. */
    private char placeholder;

    /** Indicates if the value contains the literal characters. */
    private boolean containsLiteralChars;


    /**
     * Creates a MaskFormatter with no mask.
     */
<span class="nc" id="L190">    public MaskFormatter() {</span>
<span class="nc" id="L191">        setAllowsInvalid(false);</span>
<span class="nc" id="L192">        containsLiteralChars = true;</span>
<span class="nc" id="L193">        maskChars = EmptyMaskChars;</span>
<span class="nc" id="L194">        placeholder = ' ';</span>
<span class="nc" id="L195">    }</span>

    /**
     * Creates a &lt;code&gt;MaskFormatter&lt;/code&gt; with the specified mask.
     * A &lt;code&gt;ParseException&lt;/code&gt;
     * will be thrown if &lt;code&gt;mask&lt;/code&gt; is an invalid mask.
     *
     * @throws ParseException if mask does not contain valid mask characters
     */
    public MaskFormatter(String mask) throws ParseException {
<span class="nc" id="L205">        this();</span>
<span class="nc" id="L206">        setMask(mask);</span>
<span class="nc" id="L207">    }</span>

    /**
     * Sets the mask dictating the legal characters.
     * This will throw a &lt;code&gt;ParseException&lt;/code&gt; if &lt;code&gt;mask&lt;/code&gt; is
     * not valid.
     *
     * @throws ParseException if mask does not contain valid mask characters
     */
    public void setMask(String mask) throws ParseException {
<span class="nc" id="L217">        this.mask = mask;</span>
<span class="nc" id="L218">        updateInternalMask();</span>
<span class="nc" id="L219">    }</span>

    /**
     * Returns the formatting mask.
     *
     * @return Mask dictating legal character values.
     */
    public String getMask() {
<span class="nc" id="L227">        return mask;</span>
    }

    /**
     * Allows for further restricting of the characters that can be input.
     * Only characters specified in the mask, not in the
     * &lt;code&gt;invalidCharacters&lt;/code&gt;, and in
     * &lt;code&gt;validCharacters&lt;/code&gt; will be allowed to be input. Passing
     * in null (the default) implies the valid characters are only bound
     * by the mask and the invalid characters.
     *
     * @param validCharacters If non-null, specifies legal characters.
     */
    public void setValidCharacters(String validCharacters) {
<span class="nc" id="L241">        this.validCharacters = validCharacters;</span>
<span class="nc" id="L242">    }</span>

    /**
     * Returns the valid characters that can be input.
     *
     * @return Legal characters
     */
    public String getValidCharacters() {
<span class="nc" id="L250">        return validCharacters;</span>
    }

    /**
     * Allows for further restricting of the characters that can be input.
     * Only characters specified in the mask, not in the
     * &lt;code&gt;invalidCharacters&lt;/code&gt;, and in
     * &lt;code&gt;validCharacters&lt;/code&gt; will be allowed to be input. Passing
     * in null (the default) implies the valid characters are only bound
     * by the mask and the valid characters.
     *
     * @param invalidCharacters If non-null, specifies illegal characters.
     */
    public void setInvalidCharacters(String invalidCharacters) {
<span class="nc" id="L264">        this.invalidCharacters = invalidCharacters;</span>
<span class="nc" id="L265">    }</span>

    /**
     * Returns the characters that are not valid for input.
     *
     * @return illegal characters.
     */
    public String getInvalidCharacters() {
<span class="nc" id="L273">        return invalidCharacters;</span>
    }

    /**
     * Sets the string to use if the value does not completely fill in
     * the mask. A null value implies the placeholder char should be used.
     *
     * @param placeholder String used when formatting if the value does not
     *        completely fill the mask
     */
    public void setPlaceholder(String placeholder) {
<span class="nc" id="L284">        this.placeholderString = placeholder;</span>
<span class="nc" id="L285">    }</span>

    /**
     * Returns the String to use if the value does not completely fill
     * in the mask.
     *
     * @return String used when formatting if the value does not
     *        completely fill the mask
     */
    public String getPlaceholder() {
<span class="nc" id="L295">        return placeholderString;</span>
    }

    /**
     * Sets the character to use in place of characters that are not present
     * in the value, ie the user must fill them in. The default value is
     * a space.
     * &lt;p&gt;
     * This is only applicable if the placeholder string has not been
     * specified, or does not completely fill in the mask.
     *
     * @param placeholder Character used when formatting if the value does not
     *        completely fill the mask
     */
    public void setPlaceholderCharacter(char placeholder) {
<span class="nc" id="L310">        this.placeholder = placeholder;</span>
<span class="nc" id="L311">    }</span>

    /**
     * Returns the character to use in place of characters that are not present
     * in the value, ie the user must fill them in.
     *
     * @return Character used when formatting if the value does not
     *        completely fill the mask
     */
    public char getPlaceholderCharacter() {
<span class="nc" id="L321">        return placeholder;</span>
    }

    /**
     * If true, the returned value and set value will also contain the literal
     * characters in mask.
     * &lt;p&gt;
     * For example, if the mask is &lt;code&gt;'(###) ###-####'&lt;/code&gt;, the
     * current value is &lt;code&gt;'(415) 555-1212'&lt;/code&gt;, and
     * &lt;code&gt;valueContainsLiteralCharacters&lt;/code&gt; is
     * true &lt;code&gt;stringToValue&lt;/code&gt; will return
     * &lt;code&gt;'(415) 555-1212'&lt;/code&gt;. On the other hand, if
     * &lt;code&gt;valueContainsLiteralCharacters&lt;/code&gt; is false,
     * &lt;code&gt;stringToValue&lt;/code&gt; will return &lt;code&gt;'4155551212'&lt;/code&gt;.
     *
     * @param containsLiteralChars Used to indicate if literal characters in
     *        mask should be returned in stringToValue
     */
    public void setValueContainsLiteralCharacters(
                        boolean containsLiteralChars) {
<span class="nc" id="L341">        this.containsLiteralChars = containsLiteralChars;</span>
<span class="nc" id="L342">    }</span>

    /**
     * Returns true if &lt;code&gt;stringToValue&lt;/code&gt; should return literal
     * characters in the mask.
     *
     * @return True if literal characters in mask should be returned in
     *         stringToValue
     */
    public boolean getValueContainsLiteralCharacters() {
<span class="nc" id="L352">        return containsLiteralChars;</span>
    }

    /**
     * Parses the text, returning the appropriate Object representation of
     * the String &lt;code&gt;value&lt;/code&gt;. This strips the literal characters as
     * necessary and invokes supers &lt;code&gt;stringToValue&lt;/code&gt;, so that if
     * you have specified a value class (&lt;code&gt;setValueClass&lt;/code&gt;) an
     * instance of it will be created. This will throw a
     * &lt;code&gt;ParseException&lt;/code&gt; if the value does not match the current
     * mask.  Refer to {@link #setValueContainsLiteralCharacters} for details
     * on how literals are treated.
     *
     * @throws ParseException if there is an error in the conversion
     * @param value String to convert
     * @see #setValueContainsLiteralCharacters
     * @return Object representation of text
     */
    public Object stringToValue(String value) throws ParseException {
<span class="nc" id="L371">        return stringToValue(value, true);</span>
    }

    /**
     * Returns a String representation of the Object &lt;code&gt;value&lt;/code&gt;
     * based on the mask.  Refer to
     * {@link #setValueContainsLiteralCharacters} for details
     * on how literals are treated.
     *
     * @throws ParseException if there is an error in the conversion
     * @param value Value to convert
     * @see #setValueContainsLiteralCharacters
     * @return String representation of value
     */
    public String valueToString(Object value) throws ParseException {
<span class="nc bnc" id="L386" title="All 2 branches missed.">        String sValue = (value == null) ? &quot;&quot; : value.toString();</span>
<span class="nc" id="L387">        StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L388">        String placeholder = getPlaceholder();</span>
<span class="nc" id="L389">        int[] valueCounter = { 0 };</span>

<span class="nc" id="L391">        append(result, sValue, valueCounter, placeholder, maskChars);</span>
<span class="nc" id="L392">        return result.toString();</span>
    }

    /**
     * Installs the &lt;code&gt;DefaultFormatter&lt;/code&gt; onto a particular
     * &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     * This will invoke &lt;code&gt;valueToString&lt;/code&gt; to convert the
     * current value from the &lt;code&gt;JFormattedTextField&lt;/code&gt; to
     * a String. This will then install the &lt;code&gt;Action&lt;/code&gt;s from
     * &lt;code&gt;getActions&lt;/code&gt;, the &lt;code&gt;DocumentFilter&lt;/code&gt;
     * returned from &lt;code&gt;getDocumentFilter&lt;/code&gt; and the
     * &lt;code&gt;NavigationFilter&lt;/code&gt; returned from
     * &lt;code&gt;getNavigationFilter&lt;/code&gt; onto the
     * &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     * &lt;p&gt;
     * Subclasses will typically only need to override this if they
     * wish to install additional listeners on the
     * &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     * &lt;p&gt;
     * If there is a &lt;code&gt;ParseException&lt;/code&gt; in converting the
     * current value to a String, this will set the text to an empty
     * String, and mark the &lt;code&gt;JFormattedTextField&lt;/code&gt; as being
     * in an invalid state.
     * &lt;p&gt;
     * While this is a public method, this is typically only useful
     * for subclassers of &lt;code&gt;JFormattedTextField&lt;/code&gt;.
     * &lt;code&gt;JFormattedTextField&lt;/code&gt; will invoke this method at
     * the appropriate times when the value changes, or its internal
     * state changes.
     *
     * @param ftf JFormattedTextField to format for, may be null indicating
     *            uninstall from current JFormattedTextField.
     */
    public void install(JFormattedTextField ftf) {
<span class="nc" id="L426">        super.install(ftf);</span>
        // valueToString doesn't throw, but stringToValue does, need to
        // update the editValid state appropriately
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (ftf != null) {</span>
<span class="nc" id="L430">            Object value = ftf.getValue();</span>

            try {
<span class="nc" id="L433">                stringToValue(valueToString(value));</span>
<span class="nc" id="L434">            } catch (ParseException pe) {</span>
<span class="nc" id="L435">                setEditValid(false);</span>
<span class="nc" id="L436">            }</span>
        }
<span class="nc" id="L438">    }</span>

    /**
     * Actual &lt;code&gt;stringToValue&lt;/code&gt; implementation.
     * If &lt;code&gt;completeMatch&lt;/code&gt; is true, the value must exactly match
     * the mask, on the other hand if &lt;code&gt;completeMatch&lt;/code&gt; is false
     * the string must match the mask or the placeholder string.
     */
    private Object stringToValue(String value, boolean completeMatch) throws
                         ParseException {
        int errorOffset;

<span class="nc bnc" id="L450" title="All 2 branches missed.">        if ((errorOffset = getInvalidOffset(value, completeMatch)) == -1) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">            if (!getValueContainsLiteralCharacters()) {</span>
<span class="nc" id="L452">                value = stripLiteralChars(value);</span>
            }
<span class="nc" id="L454">            return super.stringToValue(value);</span>
        }
<span class="nc" id="L456">        throw new ParseException(&quot;stringToValue passed invalid value&quot;,</span>
                                 errorOffset);
    }

    /**
     * Returns -1 if the passed in string is valid, otherwise the index of
     * the first bogus character is returned.
     */
    private int getInvalidOffset(String string, boolean completeMatch) {
<span class="nc" id="L465">        int iLength = string.length();</span>

<span class="nc bnc" id="L467" title="All 2 branches missed.">        if (iLength != getMaxLength()) {</span>
            // trivially false
<span class="nc" id="L469">            return iLength;</span>
        }
<span class="nc bnc" id="L471" title="All 2 branches missed.">        for (int counter = 0, max = string.length(); counter &lt; max; counter++){</span>
<span class="nc" id="L472">            char aChar = string.charAt(counter);</span>

<span class="nc bnc" id="L474" title="All 4 branches missed.">            if (!isValidCharacter(counter, aChar) &amp;&amp;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">                (completeMatch || !isPlaceholder(counter, aChar))) {</span>
<span class="nc" id="L476">                return counter;</span>
            }
        }
<span class="nc" id="L479">        return -1;</span>
    }

    /**
     * Invokes &lt;code&gt;append&lt;/code&gt; on the mask characters in
     * &lt;code&gt;mask&lt;/code&gt;.
     */
    private void append(StringBuilder result, String value, int[] index,
                        String placeholder, MaskCharacter[] mask)
                          throws ParseException {
<span class="nc" id="L489">        for (int counter = 0, maxCounter = mask.length;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">             counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L491">            mask[counter].append(result, value, index, placeholder);</span>
        }
<span class="nc" id="L493">    }</span>

    /**
     * Updates the internal representation of the mask.
     */
    private void updateInternalMask() throws ParseException {
<span class="nc" id="L499">        String mask = getMask();</span>
<span class="nc" id="L500">        ArrayList&lt;MaskCharacter&gt; fixed = new ArrayList&lt;MaskCharacter&gt;();</span>
<span class="nc" id="L501">        ArrayList&lt;MaskCharacter&gt; temp = fixed;</span>

<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (mask != null) {</span>
<span class="nc" id="L504">            for (int counter = 0, maxCounter = mask.length();</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                 counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L506">                char maskChar = mask.charAt(counter);</span>

<span class="nc bnc" id="L508" title="All 9 branches missed.">                switch (maskChar) {</span>
                case DIGIT_KEY:
<span class="nc" id="L510">                    temp.add(new DigitMaskCharacter());</span>
<span class="nc" id="L511">                    break;</span>
                case LITERAL_KEY:
<span class="nc bnc" id="L513" title="All 2 branches missed.">                    if (++counter &lt; maxCounter) {</span>
<span class="nc" id="L514">                        maskChar = mask.charAt(counter);</span>
<span class="nc" id="L515">                        temp.add(new LiteralCharacter(maskChar));</span>
                    }
                    // else: Could actually throw if else
                    break;
                case UPPERCASE_KEY:
<span class="nc" id="L520">                    temp.add(new UpperCaseCharacter());</span>
<span class="nc" id="L521">                    break;</span>
                case LOWERCASE_KEY:
<span class="nc" id="L523">                    temp.add(new LowerCaseCharacter());</span>
<span class="nc" id="L524">                    break;</span>
                case ALPHA_NUMERIC_KEY:
<span class="nc" id="L526">                    temp.add(new AlphaNumericCharacter());</span>
<span class="nc" id="L527">                    break;</span>
                case CHARACTER_KEY:
<span class="nc" id="L529">                    temp.add(new CharCharacter());</span>
<span class="nc" id="L530">                    break;</span>
                case ANYTHING_KEY:
<span class="nc" id="L532">                    temp.add(new MaskCharacter());</span>
<span class="nc" id="L533">                    break;</span>
                case HEX_KEY:
<span class="nc" id="L535">                    temp.add(new HexCharacter());</span>
<span class="nc" id="L536">                    break;</span>
                default:
<span class="nc" id="L538">                    temp.add(new LiteralCharacter(maskChar));</span>
                    break;
                }
            }
        }
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (fixed.size() == 0) {</span>
<span class="nc" id="L544">            maskChars = EmptyMaskChars;</span>
        }
        else {
<span class="nc" id="L547">            maskChars = new MaskCharacter[fixed.size()];</span>
<span class="nc" id="L548">            fixed.toArray(maskChars);</span>
        }
<span class="nc" id="L550">    }</span>

    /**
     * Returns the MaskCharacter at the specified location.
     */
    private MaskCharacter getMaskCharacter(int index) {
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (index &gt;= maskChars.length) {</span>
<span class="nc" id="L557">            return null;</span>
        }
<span class="nc" id="L559">        return maskChars[index];</span>
    }

    /**
     * Returns true if the placeholder character matches aChar.
     */
    private boolean isPlaceholder(int index, char aChar) {
<span class="nc bnc" id="L566" title="All 2 branches missed.">        return (getPlaceholderCharacter() == aChar);</span>
    }

    /**
     * Returns true if the passed in character matches the mask at the
     * specified location.
     */
    private boolean isValidCharacter(int index, char aChar) {
<span class="nc" id="L574">        return getMaskCharacter(index).isValidCharacter(aChar);</span>
    }

    /**
     * Returns true if the character at the specified location is a literal,
     * that is it can not be edited.
     */
    private boolean isLiteral(int index) {
<span class="nc" id="L582">        return getMaskCharacter(index).isLiteral();</span>
    }

    /**
     * Returns the maximum length the text can be.
     */
    private int getMaxLength() {
<span class="nc" id="L589">        return maskChars.length;</span>
    }

    /**
     * Returns the literal character at the specified location.
     */
    private char getLiteral(int index) {
<span class="nc" id="L596">        return getMaskCharacter(index).getChar((char)0);</span>
    }

    /**
     * Returns the character to insert at the specified location based on
     * the passed in character.  This provides a way to map certain sets
     * of characters to alternative values (lowercase to
     * uppercase...).
     */
    private char getCharacter(int index, char aChar) {
<span class="nc" id="L606">        return getMaskCharacter(index).getChar(aChar);</span>
    }

    /**
     * Removes the literal characters from the passed in string.
     */
    private String stripLiteralChars(String string) {
<span class="nc" id="L613">        StringBuilder sb = null;</span>
<span class="nc" id="L614">        int last = 0;</span>

<span class="nc bnc" id="L616" title="All 2 branches missed.">        for (int counter = 0, max = string.length(); counter &lt; max; counter++){</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">            if (isLiteral(counter)) {</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">                if (sb == null) {</span>
<span class="nc" id="L619">                    sb = new StringBuilder();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">                    if (counter &gt; 0) {</span>
<span class="nc" id="L621">                        sb.append(string.substring(0, counter));</span>
                    }
<span class="nc" id="L623">                    last = counter + 1;</span>
                }
<span class="nc bnc" id="L625" title="All 2 branches missed.">                else if (last != counter) {</span>
<span class="nc" id="L626">                    sb.append(string.substring(last, counter));</span>
                }
<span class="nc" id="L628">                last = counter + 1;</span>
            }
        }
<span class="nc bnc" id="L631" title="All 2 branches missed.">        if (sb == null) {</span>
            // Assume the mask isn't all literals.
<span class="nc" id="L633">            return string;</span>
        }
<span class="nc bnc" id="L635" title="All 2 branches missed.">        else if (last != string.length()) {</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">            if (sb == null) {</span>
<span class="nc" id="L637">                return string.substring(last);</span>
            }
<span class="nc" id="L639">            sb.append(string.substring(last));</span>
        }
<span class="nc" id="L641">        return sb.toString();</span>
    }


    /**
     * Subclassed to update the internal representation of the mask after
     * the default read operation has completed.
     */
    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
<span class="nc" id="L651">        s.defaultReadObject();</span>
        try {
<span class="nc" id="L653">            updateInternalMask();</span>
<span class="nc" id="L654">        } catch (ParseException pe) {</span>
            // assert();
<span class="nc" id="L656">        }</span>
<span class="nc" id="L657">    }</span>

    /**
     * Returns true if the MaskFormatter allows invalid, or
     * the offset is less than the max length and the character at
     * &lt;code&gt;offset&lt;/code&gt; is a literal.
     */
    boolean isNavigatable(int offset) {
<span class="nc bnc" id="L665" title="All 2 branches missed.">        if (!getAllowsInvalid()) {</span>
<span class="nc bnc" id="L666" title="All 4 branches missed.">            return (offset &lt; getMaxLength() &amp;&amp; !isLiteral(offset));</span>
        }
<span class="nc" id="L668">        return true;</span>
    }

    /*
     * Returns true if the operation described by &lt;code&gt;rh&lt;/code&gt; will
     * result in a legal edit.  This may set the &lt;code&gt;value&lt;/code&gt;
     * field of &lt;code&gt;rh&lt;/code&gt;.
     * &lt;p&gt;
     * This is overriden to return true for a partial match.
     */
    boolean isValidEdit(ReplaceHolder rh) {
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (!getAllowsInvalid()) {</span>
<span class="nc" id="L680">            String newString = getReplaceString(rh.offset, rh.length, rh.text);</span>

            try {
<span class="nc" id="L683">                rh.value = stringToValue(newString, false);</span>

<span class="nc" id="L685">                return true;</span>
<span class="nc" id="L686">            } catch (ParseException pe) {</span>
<span class="nc" id="L687">                return false;</span>
            }
        }
<span class="nc" id="L690">        return true;</span>
    }

    /**
     * This method does the following (assuming !getAllowsInvalid()):
     * iterate over the max of the deleted region or the text length, for
     * each character:
     * &lt;ol&gt;
     * &lt;li&gt;If it is valid (matches the mask at the particular position, or
     *     matches the literal character at the position), allow it
     * &lt;li&gt;Else if the position identifies a literal character, add it. This
     *     allows for the user to paste in text that may/may not contain
     *     the literals.  For example, in pasing in 5551212 into ###-####
     *     when the 1 is evaluated it is illegal (by the first test), but there
     *     is a literal at this position (-), so it is used.  NOTE: This has
     *     a problem that you can't tell (without looking ahead) if you should
     *     eat literals in the text. For example, if you paste '555' into
     *     #5##, should it result in '5555' or '555 '? The current code will
     *     result in the latter, which feels a little better as selecting
     *     text than pasting will always result in the same thing.
     * &lt;li&gt;Else if at the end of the inserted text, the replace the item with
     *     the placeholder
     * &lt;li&gt;Otherwise the insert is bogus and false is returned.
     * &lt;/ol&gt;
     */
    boolean canReplace(ReplaceHolder rh) {
        // This method is rather long, but much of the burden is in
        // maintaining a String and swapping to a StringBuilder only if
        // absolutely necessary.
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (!getAllowsInvalid()) {</span>
<span class="nc" id="L720">            StringBuilder replace = null;</span>
<span class="nc" id="L721">            String text = rh.text;</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">            int tl = (text != null) ? text.length() : 0;</span>

<span class="nc bnc" id="L724" title="All 4 branches missed.">            if (tl == 0 &amp;&amp; rh.length == 1 &amp;&amp; getFormattedTextField().</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                              getSelectionStart() != rh.offset) {</span>
                // Backspace, adjust to actually delete next non-literal.
<span class="nc bnc" id="L727" title="All 4 branches missed.">                while (rh.offset &gt; 0 &amp;&amp; isLiteral(rh.offset)) {</span>
<span class="nc" id="L728">                    rh.offset--;</span>
                }
            }
<span class="nc" id="L731">            int max = Math.min(getMaxLength() - rh.offset,</span>
<span class="nc" id="L732">                               Math.max(tl, rh.length));</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">            for (int counter = 0, textIndex = 0; counter &lt; max; counter++) {</span>
<span class="nc bnc" id="L734" title="All 4 branches missed.">                if (textIndex &lt; tl &amp;&amp; isValidCharacter(rh.offset + counter,</span>
<span class="nc" id="L735">                                                   text.charAt(textIndex))) {</span>
<span class="nc" id="L736">                    char aChar = text.charAt(textIndex);</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">                    if (aChar != getCharacter(rh.offset + counter, aChar)) {</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">                        if (replace == null) {</span>
<span class="nc" id="L739">                            replace = new StringBuilder();</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">                            if (textIndex &gt; 0) {</span>
<span class="nc" id="L741">                                replace.append(text.substring(0, textIndex));</span>
                            }
                        }
                    }
<span class="nc bnc" id="L745" title="All 2 branches missed.">                    if (replace != null) {</span>
<span class="nc" id="L746">                        replace.append(getCharacter(rh.offset + counter,</span>
                                                    aChar));
                    }
<span class="nc" id="L749">                    textIndex++;</span>
<span class="nc" id="L750">                }</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">                else if (isLiteral(rh.offset + counter)) {</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">                    if (replace != null) {</span>
<span class="nc" id="L753">                        replace.append(getLiteral(rh.offset + counter));</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">                        if (textIndex &lt; tl) {</span>
<span class="nc" id="L755">                            max = Math.min(max + 1, getMaxLength() -</span>
                                           rh.offset);
                        }
                    }
<span class="nc bnc" id="L759" title="All 2 branches missed.">                    else if (textIndex &gt; 0) {</span>
<span class="nc" id="L760">                        replace = new StringBuilder(max);</span>
<span class="nc" id="L761">                        replace.append(text.substring(0, textIndex));</span>
<span class="nc" id="L762">                        replace.append(getLiteral(rh.offset + counter));</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">                        if (textIndex &lt; tl) {</span>
                            // Evaluate the character in text again.
<span class="nc" id="L765">                            max = Math.min(max + 1, getMaxLength() -</span>
                                           rh.offset);
                        }
<span class="nc bnc" id="L768" title="All 2 branches missed.">                        else if (rh.cursorPosition == -1) {</span>
<span class="nc" id="L769">                            rh.cursorPosition = rh.offset + counter;</span>
                        }
                    }
                    else {
<span class="nc" id="L773">                        rh.offset++;</span>
<span class="nc" id="L774">                        rh.length--;</span>
<span class="nc" id="L775">                        counter--;</span>
<span class="nc" id="L776">                        max--;</span>
                    }
                }
<span class="nc bnc" id="L779" title="All 2 branches missed.">                else if (textIndex &gt;= tl) {</span>
                    // placeholder
<span class="nc bnc" id="L781" title="All 2 branches missed.">                    if (replace == null) {</span>
<span class="nc" id="L782">                        replace = new StringBuilder();</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">                        if (text != null) {</span>
<span class="nc" id="L784">                            replace.append(text);</span>
                        }
                    }
<span class="nc" id="L787">                    replace.append(getPlaceholderCharacter());</span>
<span class="nc bnc" id="L788" title="All 4 branches missed.">                    if (tl &gt; 0 &amp;&amp; rh.cursorPosition == -1) {</span>
<span class="nc" id="L789">                        rh.cursorPosition = rh.offset + counter;</span>
                    }
                }
                else {
                    // Bogus character.
<span class="nc" id="L794">                    return false;</span>
                }
            }
<span class="nc bnc" id="L797" title="All 2 branches missed.">            if (replace != null) {</span>
<span class="nc" id="L798">                rh.text = replace.toString();</span>
            }
<span class="nc bnc" id="L800" title="All 4 branches missed.">            else if (text != null &amp;&amp; rh.offset + tl &gt; getMaxLength()) {</span>
<span class="nc" id="L801">                rh.text = text.substring(0, getMaxLength() - rh.offset);</span>
            }
<span class="nc bnc" id="L803" title="All 4 branches missed.">            if (getOverwriteMode() &amp;&amp; rh.text != null) {</span>
<span class="nc" id="L804">                rh.length = rh.text.length();</span>
            }
        }
<span class="nc" id="L807">        return super.canReplace(rh);</span>
    }


    //
    // Interal classes used to represent the mask.
    //
<span class="nc" id="L814">    private class MaskCharacter {</span>
        /**
         * Subclasses should override this returning true if the instance
         * represents a literal character. The default implementation
         * returns false.
         */
        public boolean isLiteral() {
<span class="nc" id="L821">            return false;</span>
        }

        /**
         * Returns true if &lt;code&gt;aChar&lt;/code&gt; is a valid reprensentation of
         * the receiver. The default implementation returns true if the
         * receiver represents a literal character and &lt;code&gt;getChar&lt;/code&gt;
         * == aChar. Otherwise, this will return true is &lt;code&gt;aChar&lt;/code&gt;
         * is contained in the valid characters and not contained
         * in the invalid characters.
         */
        public boolean isValidCharacter(char aChar) {
<span class="nc bnc" id="L833" title="All 2 branches missed.">            if (isLiteral()) {</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">                return (getChar(aChar) == aChar);</span>
            }

<span class="nc" id="L837">            aChar = getChar(aChar);</span>

<span class="nc" id="L839">            String filter = getValidCharacters();</span>

<span class="nc bnc" id="L841" title="All 4 branches missed.">            if (filter != null &amp;&amp; filter.indexOf(aChar) == -1) {</span>
<span class="nc" id="L842">                return false;</span>
            }
<span class="nc" id="L844">            filter = getInvalidCharacters();</span>
<span class="nc bnc" id="L845" title="All 4 branches missed.">            if (filter != null &amp;&amp; filter.indexOf(aChar) != -1) {</span>
<span class="nc" id="L846">                return false;</span>
            }
<span class="nc" id="L848">            return true;</span>
        }

        /**
         * Returns the character to insert for &lt;code&gt;aChar&lt;/code&gt;. The
         * default implementation returns &lt;code&gt;aChar&lt;/code&gt;. Subclasses
         * that wish to do some sort of mapping, perhaps lower case to upper
         * case should override this and do the necessary mapping.
         */
        public char getChar(char aChar) {
<span class="nc" id="L858">            return aChar;</span>
        }

        /**
         * Appends the necessary character in &lt;code&gt;formatting&lt;/code&gt; at
         * &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;buff&lt;/code&gt;.
         */
        public void append(StringBuilder buff, String formatting, int[] index,
                           String placeholder)
                          throws ParseException {
<span class="nc bnc" id="L868" title="All 2 branches missed.">            boolean inString = index[0] &lt; formatting.length();</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">            char aChar = inString ? formatting.charAt(index[0]) : 0;</span>

<span class="nc bnc" id="L871" title="All 2 branches missed.">            if (isLiteral()) {</span>
<span class="nc" id="L872">                buff.append(getChar(aChar));</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">                if (getValueContainsLiteralCharacters()) {</span>
<span class="nc bnc" id="L874" title="All 4 branches missed.">                    if (inString &amp;&amp; aChar != getChar(aChar)) {</span>
<span class="nc" id="L875">                        throw new ParseException(&quot;Invalid character: &quot; +</span>
                                                 aChar, index[0]);
                    }
<span class="nc" id="L878">                    index[0] = index[0] + 1;</span>
                }
            }
<span class="nc bnc" id="L881" title="All 2 branches missed.">            else if (index[0] &gt;= formatting.length()) {</span>
<span class="nc bnc" id="L882" title="All 4 branches missed.">                if (placeholder != null &amp;&amp; index[0] &lt; placeholder.length()) {</span>
<span class="nc" id="L883">                    buff.append(placeholder.charAt(index[0]));</span>
                }
                else {
<span class="nc" id="L886">                    buff.append(getPlaceholderCharacter());</span>
                }
<span class="nc" id="L888">                index[0] = index[0] + 1;</span>
            }
<span class="nc bnc" id="L890" title="All 2 branches missed.">            else if (isValidCharacter(aChar)) {</span>
<span class="nc" id="L891">                buff.append(getChar(aChar));</span>
<span class="nc" id="L892">                index[0] = index[0] + 1;</span>
            }
            else {
<span class="nc" id="L895">                throw new ParseException(&quot;Invalid character: &quot; + aChar,</span>
                                         index[0]);
            }
<span class="nc" id="L898">        }</span>
    }


    /**
     * Used to represent a fixed character in the mask.
     */
    private class LiteralCharacter extends MaskCharacter {
        private char fixedChar;

<span class="nc" id="L908">        public LiteralCharacter(char fixedChar) {</span>
<span class="nc" id="L909">            this.fixedChar = fixedChar;</span>
<span class="nc" id="L910">        }</span>

        public boolean isLiteral() {
<span class="nc" id="L913">            return true;</span>
        }

        public char getChar(char aChar) {
<span class="nc" id="L917">            return fixedChar;</span>
        }
    }


    /**
     * Represents a number, uses &lt;code&gt;Character.isDigit&lt;/code&gt;.
     */
<span class="nc" id="L925">    private class DigitMaskCharacter extends MaskCharacter {</span>
        public boolean isValidCharacter(char aChar) {
<span class="nc bnc" id="L927" title="All 2 branches missed.">            return (Character.isDigit(aChar) &amp;&amp;</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">                    super.isValidCharacter(aChar));</span>
        }
    }


    /**
     * Represents a character, lower case letters are mapped to upper case
     * using &lt;code&gt;Character.toUpperCase&lt;/code&gt;.
     */
<span class="nc" id="L937">    private class UpperCaseCharacter extends MaskCharacter {</span>
        public boolean isValidCharacter(char aChar) {
<span class="nc bnc" id="L939" title="All 2 branches missed.">            return (Character.isLetter(aChar) &amp;&amp;</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">                     super.isValidCharacter(aChar));</span>
        }

        public char getChar(char aChar) {
<span class="nc" id="L944">            return Character.toUpperCase(aChar);</span>
        }
    }


    /**
     * Represents a character, upper case letters are mapped to lower case
     * using &lt;code&gt;Character.toLowerCase&lt;/code&gt;.
     */
<span class="nc" id="L953">    private class LowerCaseCharacter extends MaskCharacter {</span>
        public boolean isValidCharacter(char aChar) {
<span class="nc bnc" id="L955" title="All 2 branches missed.">            return (Character.isLetter(aChar) &amp;&amp;</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">                     super.isValidCharacter(aChar));</span>
        }

        public char getChar(char aChar) {
<span class="nc" id="L960">            return Character.toLowerCase(aChar);</span>
        }
    }


    /**
     * Represents either a character or digit, uses
     * &lt;code&gt;Character.isLetterOrDigit&lt;/code&gt;.
     */
<span class="nc" id="L969">    private class AlphaNumericCharacter extends MaskCharacter {</span>
        public boolean isValidCharacter(char aChar) {
<span class="nc bnc" id="L971" title="All 2 branches missed.">            return (Character.isLetterOrDigit(aChar) &amp;&amp;</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">                     super.isValidCharacter(aChar));</span>
        }
    }


    /**
     * Represents a letter, uses &lt;code&gt;Character.isLetter&lt;/code&gt;.
     */
<span class="nc" id="L980">    private class CharCharacter extends MaskCharacter {</span>
        public boolean isValidCharacter(char aChar) {
<span class="nc bnc" id="L982" title="All 2 branches missed.">            return (Character.isLetter(aChar) &amp;&amp;</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">                     super.isValidCharacter(aChar));</span>
        }
    }


    /**
     * Represents a hex character, 0-9a-fA-F. a-f is mapped to A-F
     */
<span class="nc" id="L991">    private class HexCharacter extends MaskCharacter {</span>
        public boolean isValidCharacter(char aChar) {
<span class="nc bnc" id="L993" title="All 44 branches missed.">            return ((aChar == '0' || aChar == '1' ||</span>
                     aChar == '2' || aChar == '3' ||
                     aChar == '4' || aChar == '5' ||
                     aChar == '6' || aChar == '7' ||
                     aChar == '8' || aChar == '9' ||
                     aChar == 'a' || aChar == 'A' ||
                     aChar == 'b' || aChar == 'B' ||
                     aChar == 'c' || aChar == 'C' ||
                     aChar == 'd' || aChar == 'D' ||
                     aChar == 'e' || aChar == 'E' ||
                     aChar == 'f' || aChar == 'F') &amp;&amp;
<span class="nc bnc" id="L1004" title="All 2 branches missed.">                    super.isValidCharacter(aChar));</span>
        }

        public char getChar(char aChar) {
<span class="nc bnc" id="L1008" title="All 2 branches missed.">            if (Character.isDigit(aChar)) {</span>
<span class="nc" id="L1009">                return aChar;</span>
            }
<span class="nc" id="L1011">            return Character.toUpperCase(aChar);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>