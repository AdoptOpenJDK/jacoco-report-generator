<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultStyledDocument.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">DefaultStyledDocument.java</span></div><h1>DefaultStyledDocument.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.awt.Color;
import java.awt.Font;
import java.awt.font.TextAttribute;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.Vector;
import java.util.ArrayList;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import javax.swing.event.*;
import javax.swing.undo.AbstractUndoableEdit;
import javax.swing.undo.CannotRedoException;
import javax.swing.undo.CannotUndoException;
import javax.swing.undo.UndoableEdit;
import javax.swing.SwingUtilities;
import static sun.swing.SwingUtilities2.IMPLIED_CR;

/**
 * A document that can be marked up with character and paragraph
 * styles in a manner similar to the Rich Text Format.  The element
 * structure for this document represents style crossings for
 * style runs.  These style runs are mapped into a paragraph element
 * structure (which may reside in some other structure).  The
 * style runs break at paragraph boundaries since logical styles are
 * assigned to paragraph boundaries.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author  Timothy Prinzing
 * @see     Document
 * @see     AbstractDocument
 */
public class DefaultStyledDocument extends AbstractDocument implements StyledDocument {

    /**
     * Constructs a styled document.
     *
     * @param c  the container for the content
     * @param styles resources and style definitions which may
     *  be shared across documents
     */
    public DefaultStyledDocument(Content c, StyleContext styles) {
<span class="nc" id="L82">        super(c, styles);</span>
<span class="nc" id="L83">        listeningStyles = new Vector&lt;Style&gt;();</span>
<span class="nc" id="L84">        buffer = new ElementBuffer(createDefaultRoot());</span>
<span class="nc" id="L85">        Style defaultStyle = styles.getStyle(StyleContext.DEFAULT_STYLE);</span>
<span class="nc" id="L86">        setLogicalStyle(0, defaultStyle);</span>
<span class="nc" id="L87">    }</span>

    /**
     * Constructs a styled document with the default content
     * storage implementation and a shared set of styles.
     *
     * @param styles the styles
     */
    public DefaultStyledDocument(StyleContext styles) {
<span class="nc" id="L96">        this(new GapContent(BUFFER_SIZE_DEFAULT), styles);</span>
<span class="nc" id="L97">    }</span>

    /**
     * Constructs a default styled document.  This buffers
     * input content by a size of &lt;em&gt;BUFFER_SIZE_DEFAULT&lt;/em&gt;
     * and has a style context that is scoped by the lifetime
     * of the document and is not shared with other documents.
     */
    public DefaultStyledDocument() {
<span class="nc" id="L106">        this(new GapContent(BUFFER_SIZE_DEFAULT), new StyleContext());</span>
<span class="nc" id="L107">    }</span>

    /**
     * Gets the default root element.
     *
     * @return the root
     * @see Document#getDefaultRootElement
     */
    public Element getDefaultRootElement() {
<span class="nc" id="L116">        return buffer.getRootElement();</span>
    }

    /**
     * Initialize the document to reflect the given element
     * structure (i.e. the structure reported by the
     * &lt;code&gt;getDefaultRootElement&lt;/code&gt; method.  If the
     * document contained any data it will first be removed.
     */
    protected void create(ElementSpec[] data) {
        try {
<span class="nc bnc" id="L127" title="All 2 branches missed.">            if (getLength() != 0) {</span>
<span class="nc" id="L128">                remove(0, getLength());</span>
            }
<span class="nc" id="L130">            writeLock();</span>

            // install the content
<span class="nc" id="L133">            Content c = getContent();</span>
<span class="nc" id="L134">            int n = data.length;</span>
<span class="nc" id="L135">            StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L137">                ElementSpec es = data[i];</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                if (es.getLength() &gt; 0) {</span>
<span class="nc" id="L139">                    sb.append(es.getArray(), es.getOffset(),  es.getLength());</span>
                }
            }
<span class="nc" id="L142">            UndoableEdit cEdit = c.insertString(0, sb.toString());</span>

            // build the event and element structure
<span class="nc" id="L145">            int length = sb.length();</span>
<span class="nc" id="L146">            DefaultDocumentEvent evnt =</span>
                new DefaultDocumentEvent(0, length, DocumentEvent.EventType.INSERT);
<span class="nc" id="L148">            evnt.addEdit(cEdit);</span>
<span class="nc" id="L149">            buffer.create(length, data, evnt);</span>

            // update bidi (possibly)
<span class="nc" id="L152">            super.insertUpdate(evnt, null);</span>

            // notify the listeners
<span class="nc" id="L155">            evnt.end();</span>
<span class="nc" id="L156">            fireInsertUpdate(evnt);</span>
<span class="nc" id="L157">            fireUndoableEditUpdate(new UndoableEditEvent(this, evnt));</span>
<span class="nc" id="L158">        } catch (BadLocationException ble) {</span>
<span class="nc" id="L159">            throw new StateInvariantError(&quot;problem initializing&quot;);</span>
        } finally {
<span class="nc" id="L161">            writeUnlock();</span>
<span class="nc" id="L162">        }</span>

<span class="nc" id="L164">    }</span>

    /**
     * Inserts new elements in bulk.  This is useful to allow
     * parsing with the document in an unlocked state and
     * prepare an element structure modification.  This method
     * takes an array of tokens that describe how to update an
     * element structure so the time within a write lock can
     * be greatly reduced in an asynchronous update situation.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param offset the starting offset &amp;gt;= 0
     * @param data the element data
     * @exception BadLocationException for an invalid starting offset
     */
    protected void insert(int offset, ElementSpec[] data) throws BadLocationException {
<span class="nc bnc" id="L184" title="All 4 branches missed.">        if (data == null || data.length == 0) {</span>
<span class="nc" id="L185">            return;</span>
        }

        try {
<span class="nc" id="L189">            writeLock();</span>

            // install the content
<span class="nc" id="L192">            Content c = getContent();</span>
<span class="nc" id="L193">            int n = data.length;</span>
<span class="nc" id="L194">            StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L196">                ElementSpec es = data[i];</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">                if (es.getLength() &gt; 0) {</span>
<span class="nc" id="L198">                    sb.append(es.getArray(), es.getOffset(),  es.getLength());</span>
                }
            }
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (sb.length() == 0) {</span>
                // Nothing to insert, bail.
<span class="nc" id="L203">                return;</span>
            }
<span class="nc" id="L205">            UndoableEdit cEdit = c.insertString(offset, sb.toString());</span>

            // create event and build the element structure
<span class="nc" id="L208">            int length = sb.length();</span>
<span class="nc" id="L209">            DefaultDocumentEvent evnt =</span>
                new DefaultDocumentEvent(offset, length, DocumentEvent.EventType.INSERT);
<span class="nc" id="L211">            evnt.addEdit(cEdit);</span>
<span class="nc" id="L212">            buffer.insert(offset, length, data, evnt);</span>

            // update bidi (possibly)
<span class="nc" id="L215">            super.insertUpdate(evnt, null);</span>

            // notify the listeners
<span class="nc" id="L218">            evnt.end();</span>
<span class="nc" id="L219">            fireInsertUpdate(evnt);</span>
<span class="nc" id="L220">            fireUndoableEditUpdate(new UndoableEditEvent(this, evnt));</span>
        } finally {
<span class="nc" id="L222">            writeUnlock();</span>
<span class="nc" id="L223">        }</span>
<span class="nc" id="L224">    }</span>

    /**
     * Removes an element from this document.
     *
     * &lt;p&gt;The element is removed from its parent element, as well as
     * the text in the range identified by the element.  If the
     * element isn't associated with the document, {@code
     * IllegalArgumentException} is thrown.&lt;/p&gt;
     *
     * &lt;p&gt;As empty branch elements are not allowed in the document, if the
     * element is the sole child, its parent element is removed as well,
     * recursively.  This means that when replacing all the children of a
     * particular element, new children should be added &lt;em&gt;before&lt;/em&gt;
     * removing old children.
     *
     * &lt;p&gt;Element removal results in two events being fired, the
     * {@code DocumentEvent} for changes in element structure and {@code
     * UndoableEditEvent} for changes in document content.&lt;/p&gt;
     *
     * &lt;p&gt;If the element contains end-of-content mark (the last {@code
     * &quot;\n&quot;} character in document), this character is not removed;
     * instead, preceding leaf element is extended to cover the
     * character.  If the last leaf already ends with {@code &quot;\n&quot;,} it is
     * included in content removal.&lt;/p&gt;
     *
     * &lt;p&gt;If the element is {@code null,} {@code NullPointerException} is
     * thrown.  If the element structure would become invalid after the removal,
     * for example if the element is the document root element, {@code
     * IllegalArgumentException} is thrown.  If the current element structure is
     * invalid, {@code IllegalStateException} is thrown.&lt;/p&gt;
     *
     * @param  elem                      the element to remove
     * @throws NullPointerException      if the element is {@code null}
     * @throws IllegalArgumentException  if the element could not be removed
     * @throws IllegalStateException     if the element structure is invalid
     *
     * @since  1.7
     */
    public void removeElement(Element elem) {
        try {
<span class="nc" id="L265">            writeLock();</span>
<span class="nc" id="L266">            removeElementImpl(elem);</span>
        } finally {
<span class="nc" id="L268">            writeUnlock();</span>
<span class="nc" id="L269">        }</span>
<span class="nc" id="L270">    }</span>

    private void removeElementImpl(Element elem) {
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (elem.getDocument() != this) {</span>
<span class="nc" id="L274">            throw new IllegalArgumentException(&quot;element doesn't belong to document&quot;);</span>
        }
<span class="nc" id="L276">        BranchElement parent = (BranchElement) elem.getParentElement();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (parent == null) {</span>
<span class="nc" id="L278">            throw new IllegalArgumentException(&quot;can't remove the root element&quot;);</span>
        }

<span class="nc" id="L281">        int startOffset = elem.getStartOffset();</span>
<span class="nc" id="L282">        int removeFrom = startOffset;</span>
<span class="nc" id="L283">        int endOffset = elem.getEndOffset();</span>
<span class="nc" id="L284">        int removeTo = endOffset;</span>
<span class="nc" id="L285">        int lastEndOffset = getLength() + 1;</span>
<span class="nc" id="L286">        Content content = getContent();</span>
<span class="nc" id="L287">        boolean atEnd = false;</span>
<span class="nc" id="L288">        boolean isComposedText = Utilities.isComposedTextElement(elem);</span>

<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (endOffset &gt;= lastEndOffset) {</span>
            // element includes the last &quot;\n&quot; character, needs special handling
<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (startOffset &lt;= 0) {</span>
<span class="nc" id="L293">                throw new IllegalArgumentException(&quot;can't remove the whole content&quot;);</span>
            }
<span class="nc" id="L295">            removeTo = lastEndOffset - 1; // last &quot;\n&quot; must not be removed</span>
            try {
<span class="nc bnc" id="L297" title="All 2 branches missed.">                if (content.getString(startOffset - 1, 1).charAt(0) == '\n') {</span>
<span class="nc" id="L298">                    removeFrom--; // preceding leaf ends with &quot;\n&quot;, remove it</span>
                }
<span class="nc" id="L300">            } catch (BadLocationException ble) { // can't happen</span>
<span class="nc" id="L301">                throw new IllegalStateException(ble);</span>
<span class="nc" id="L302">            }</span>
<span class="nc" id="L303">            atEnd = true;</span>
        }
<span class="nc" id="L305">        int length = removeTo - removeFrom;</span>

<span class="nc" id="L307">        DefaultDocumentEvent dde = new DefaultDocumentEvent(removeFrom,</span>
                length, DefaultDocumentEvent.EventType.REMOVE);
<span class="nc" id="L309">        UndoableEdit ue = null;</span>
        // do not leave empty branch elements
<span class="nc bnc" id="L311" title="All 2 branches missed.">        while (parent.getElementCount() == 1) {</span>
<span class="nc" id="L312">            elem = parent;</span>
<span class="nc" id="L313">            parent = (BranchElement) parent.getParentElement();</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">            if (parent == null) { // shouldn't happen</span>
<span class="nc" id="L315">                throw new IllegalStateException(&quot;invalid element structure&quot;);</span>
            }
        }
<span class="nc" id="L318">        Element[] removed = { elem };</span>
<span class="nc" id="L319">        Element[] added = {};</span>
<span class="nc" id="L320">        int index = parent.getElementIndex(startOffset);</span>
<span class="nc" id="L321">        parent.replace(index, 1, added);</span>
<span class="nc" id="L322">        dde.addEdit(new ElementEdit(parent, index, removed, added));</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (length &gt; 0) {</span>
            try {
<span class="nc" id="L325">                ue = content.remove(removeFrom, length);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                if (ue != null) {</span>
<span class="nc" id="L327">                    dde.addEdit(ue);</span>
                }
<span class="nc" id="L329">            } catch (BadLocationException ble) {</span>
                // can only happen if the element structure is severely broken
<span class="nc" id="L331">                throw new IllegalStateException(ble);</span>
<span class="nc" id="L332">            }</span>
<span class="nc" id="L333">            lastEndOffset -= length;</span>
        }

<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (atEnd) {</span>
            // preceding leaf element should be extended to cover orphaned &quot;\n&quot;
<span class="nc" id="L338">            Element prevLeaf = parent.getElement(parent.getElementCount() - 1);</span>
<span class="nc bnc" id="L339" title="All 4 branches missed.">            while ((prevLeaf != null) &amp;&amp; !prevLeaf.isLeaf()) {</span>
<span class="nc" id="L340">                prevLeaf = prevLeaf.getElement(prevLeaf.getElementCount() - 1);</span>
            }
<span class="nc bnc" id="L342" title="All 2 branches missed.">            if (prevLeaf == null) { // shouldn't happen</span>
<span class="nc" id="L343">                throw new IllegalStateException(&quot;invalid element structure&quot;);</span>
            }
<span class="nc" id="L345">            int prevStartOffset = prevLeaf.getStartOffset();</span>
<span class="nc" id="L346">            BranchElement prevParent = (BranchElement) prevLeaf.getParentElement();</span>
<span class="nc" id="L347">            int prevIndex = prevParent.getElementIndex(prevStartOffset);</span>
            Element newElem;
<span class="nc" id="L349">            newElem = createLeafElement(prevParent, prevLeaf.getAttributes(),</span>
                                            prevStartOffset, lastEndOffset);
<span class="nc" id="L351">            Element[] prevRemoved = { prevLeaf };</span>
<span class="nc" id="L352">            Element[] prevAdded = { newElem };</span>
<span class="nc" id="L353">            prevParent.replace(prevIndex, 1, prevAdded);</span>
<span class="nc" id="L354">            dde.addEdit(new ElementEdit(prevParent, prevIndex,</span>
                                                    prevRemoved, prevAdded));
        }

<span class="nc" id="L358">        postRemoveUpdate(dde);</span>
<span class="nc" id="L359">        dde.end();</span>
<span class="nc" id="L360">        fireRemoveUpdate(dde);</span>
<span class="nc bnc" id="L361" title="All 4 branches missed.">        if (! (isComposedText &amp;&amp; (ue != null))) {</span>
            // do not fire UndoabeEdit event for composed text edit (unsupported)
<span class="nc" id="L363">            fireUndoableEditUpdate(new UndoableEditEvent(this, dde));</span>
        }
<span class="nc" id="L365">    }</span>

    /**
     * Adds a new style into the logical style hierarchy.  Style attributes
     * resolve from bottom up so an attribute specified in a child
     * will override an attribute specified in the parent.
     *
     * @param nm   the name of the style (must be unique within the
     *   collection of named styles).  The name may be null if the style
     *   is unnamed, but the caller is responsible
     *   for managing the reference returned as an unnamed style can't
     *   be fetched by name.  An unnamed style may be useful for things
     *   like character attribute overrides such as found in a style
     *   run.
     * @param parent the parent style.  This may be null if unspecified
     *   attributes need not be resolved in some other style.
     * @return the style
     */
    public Style addStyle(String nm, Style parent) {
<span class="nc" id="L384">        StyleContext styles = (StyleContext) getAttributeContext();</span>
<span class="nc" id="L385">        return styles.addStyle(nm, parent);</span>
    }

    /**
     * Removes a named style previously added to the document.
     *
     * @param nm  the name of the style to remove
     */
    public void removeStyle(String nm) {
<span class="nc" id="L394">        StyleContext styles = (StyleContext) getAttributeContext();</span>
<span class="nc" id="L395">        styles.removeStyle(nm);</span>
<span class="nc" id="L396">    }</span>

    /**
     * Fetches a named style previously added.
     *
     * @param nm  the name of the style
     * @return the style
     */
    public Style getStyle(String nm) {
<span class="nc" id="L405">        StyleContext styles = (StyleContext) getAttributeContext();</span>
<span class="nc" id="L406">        return styles.getStyle(nm);</span>
    }


    /**
     * Fetches the list of of style names.
     *
     * @return all the style names
     */
    public Enumeration&lt;?&gt; getStyleNames() {
<span class="nc" id="L416">        return ((StyleContext) getAttributeContext()).getStyleNames();</span>
    }

    /**
     * Sets the logical style to use for the paragraph at the
     * given position.  If attributes aren't explicitly set
     * for character and paragraph attributes they will resolve
     * through the logical style assigned to the paragraph, which
     * in turn may resolve through some hierarchy completely
     * independent of the element hierarchy in the document.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param pos the offset from the start of the document &amp;gt;= 0
     * @param s  the logical style to assign to the paragraph, null if none
     */
    public void setLogicalStyle(int pos, Style s) {
<span class="nc" id="L436">        Element paragraph = getParagraphElement(pos);</span>
<span class="nc bnc" id="L437" title="All 4 branches missed.">        if ((paragraph != null) &amp;&amp; (paragraph instanceof AbstractElement)) {</span>
            try {
<span class="nc" id="L439">                writeLock();</span>
<span class="nc" id="L440">                StyleChangeUndoableEdit edit = new StyleChangeUndoableEdit((AbstractElement)paragraph, s);</span>
<span class="nc" id="L441">                ((AbstractElement)paragraph).setResolveParent(s);</span>
<span class="nc" id="L442">                int p0 = paragraph.getStartOffset();</span>
<span class="nc" id="L443">                int p1 = paragraph.getEndOffset();</span>
<span class="nc" id="L444">                DefaultDocumentEvent e =</span>
                  new DefaultDocumentEvent(p0, p1 - p0, DocumentEvent.EventType.CHANGE);
<span class="nc" id="L446">                e.addEdit(edit);</span>
<span class="nc" id="L447">                e.end();</span>
<span class="nc" id="L448">                fireChangedUpdate(e);</span>
<span class="nc" id="L449">                fireUndoableEditUpdate(new UndoableEditEvent(this, e));</span>
            } finally {
<span class="nc" id="L451">                writeUnlock();</span>
<span class="nc" id="L452">            }</span>
        }
<span class="nc" id="L454">    }</span>

    /**
     * Fetches the logical style assigned to the paragraph
     * represented by the given position.
     *
     * @param p the location to translate to a paragraph
     *  and determine the logical style assigned &amp;gt;= 0.  This
     *  is an offset from the start of the document.
     * @return the style, null if none
     */
    public Style getLogicalStyle(int p) {
<span class="nc" id="L466">        Style s = null;</span>
<span class="nc" id="L467">        Element paragraph = getParagraphElement(p);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (paragraph != null) {</span>
<span class="nc" id="L469">            AttributeSet a = paragraph.getAttributes();</span>
<span class="nc" id="L470">            AttributeSet parent = a.getResolveParent();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (parent instanceof Style) {</span>
<span class="nc" id="L472">                s = (Style) parent;</span>
            }
        }
<span class="nc" id="L475">        return s;</span>
    }

    /**
     * Sets attributes for some part of the document.
     * A write lock is held by this operation while changes
     * are being made, and a DocumentEvent is sent to the listeners
     * after the change has been successfully completed.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param offset the offset in the document &amp;gt;= 0
     * @param length the length &amp;gt;= 0
     * @param s the attributes
     * @param replace true if the previous attributes should be replaced
     *  before setting the new attributes
     */
    public void setCharacterAttributes(int offset, int length, AttributeSet s, boolean replace) {
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (length == 0) {</span>
<span class="nc" id="L497">            return;</span>
        }
        try {
<span class="nc" id="L500">            writeLock();</span>
<span class="nc" id="L501">            DefaultDocumentEvent changes =</span>
                new DefaultDocumentEvent(offset, length, DocumentEvent.EventType.CHANGE);

            // split elements that need it
<span class="nc" id="L505">            buffer.change(offset, length, changes);</span>

<span class="nc" id="L507">            AttributeSet sCopy = s.copyAttributes();</span>

            // PENDING(prinz) - this isn't a very efficient way to iterate
            int lastEnd;
<span class="nc bnc" id="L511" title="All 2 branches missed.">            for (int pos = offset; pos &lt; (offset + length); pos = lastEnd) {</span>
<span class="nc" id="L512">                Element run = getCharacterElement(pos);</span>
<span class="nc" id="L513">                lastEnd = run.getEndOffset();</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                if (pos == lastEnd) {</span>
                    // offset + length beyond length of document, bail.
<span class="nc" id="L516">                    break;</span>
                }
<span class="nc" id="L518">                MutableAttributeSet attr = (MutableAttributeSet) run.getAttributes();</span>
<span class="nc" id="L519">                changes.addEdit(new AttributeUndoableEdit(run, sCopy, replace));</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">                if (replace) {</span>
<span class="nc" id="L521">                    attr.removeAttributes(attr);</span>
                }
<span class="nc" id="L523">                attr.addAttributes(s);</span>
            }
<span class="nc" id="L525">            changes.end();</span>
<span class="nc" id="L526">            fireChangedUpdate(changes);</span>
<span class="nc" id="L527">            fireUndoableEditUpdate(new UndoableEditEvent(this, changes));</span>
        } finally {
<span class="nc" id="L529">            writeUnlock();</span>
<span class="nc" id="L530">        }</span>

<span class="nc" id="L532">    }</span>

    /**
     * Sets attributes for a paragraph.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param offset the offset into the paragraph &amp;gt;= 0
     * @param length the number of characters affected &amp;gt;= 0
     * @param s the attributes
     * @param replace whether to replace existing attributes, or merge them
     */
    public void setParagraphAttributes(int offset, int length, AttributeSet s,
                                       boolean replace) {
        try {
<span class="nc" id="L550">            writeLock();</span>
<span class="nc" id="L551">            DefaultDocumentEvent changes =</span>
                new DefaultDocumentEvent(offset, length, DocumentEvent.EventType.CHANGE);

<span class="nc" id="L554">            AttributeSet sCopy = s.copyAttributes();</span>

            // PENDING(prinz) - this assumes a particular element structure
<span class="nc" id="L557">            Element section = getDefaultRootElement();</span>
<span class="nc" id="L558">            int index0 = section.getElementIndex(offset);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">            int index1 = section.getElementIndex(offset + ((length &gt; 0) ? length - 1 : 0));</span>
<span class="nc" id="L560">            boolean isI18N = Boolean.TRUE.equals(getProperty(I18NProperty));</span>
<span class="nc" id="L561">            boolean hasRuns = false;</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">            for (int i = index0; i &lt;= index1; i++) {</span>
<span class="nc" id="L563">                Element paragraph = section.getElement(i);</span>
<span class="nc" id="L564">                MutableAttributeSet attr = (MutableAttributeSet) paragraph.getAttributes();</span>
<span class="nc" id="L565">                changes.addEdit(new AttributeUndoableEdit(paragraph, sCopy, replace));</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">                if (replace) {</span>
<span class="nc" id="L567">                    attr.removeAttributes(attr);</span>
                }
<span class="nc" id="L569">                attr.addAttributes(s);</span>
<span class="nc bnc" id="L570" title="All 4 branches missed.">                if (isI18N &amp;&amp; !hasRuns) {</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">                    hasRuns = (attr.getAttribute(TextAttribute.RUN_DIRECTION) != null);</span>
                }
            }

<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (hasRuns) {</span>
<span class="nc" id="L576">                updateBidi( changes );</span>
            }

<span class="nc" id="L579">            changes.end();</span>
<span class="nc" id="L580">            fireChangedUpdate(changes);</span>
<span class="nc" id="L581">            fireUndoableEditUpdate(new UndoableEditEvent(this, changes));</span>
        } finally {
<span class="nc" id="L583">            writeUnlock();</span>
<span class="nc" id="L584">        }</span>
<span class="nc" id="L585">    }</span>

    /**
     * Gets the paragraph element at the offset &lt;code&gt;pos&lt;/code&gt;.
     * A paragraph consists of at least one child Element, which is usually
     * a leaf.
     *
     * @param pos the starting offset &amp;gt;= 0
     * @return the element
     */
    public Element getParagraphElement(int pos) {
        Element e;
<span class="nc bnc" id="L597" title="All 2 branches missed.">        for (e = getDefaultRootElement(); ! e.isLeaf(); ) {</span>
<span class="nc" id="L598">            int index = e.getElementIndex(pos);</span>
<span class="nc" id="L599">            e = e.getElement(index);</span>
<span class="nc" id="L600">        }</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">        if(e != null)</span>
<span class="nc" id="L602">            return e.getParentElement();</span>
<span class="nc" id="L603">        return e;</span>
    }

    /**
     * Gets a character element based on a position.
     *
     * @param pos the position in the document &amp;gt;= 0
     * @return the element
     */
    public Element getCharacterElement(int pos) {
        Element e;
<span class="nc bnc" id="L614" title="All 2 branches missed.">        for (e = getDefaultRootElement(); ! e.isLeaf(); ) {</span>
<span class="nc" id="L615">            int index = e.getElementIndex(pos);</span>
<span class="nc" id="L616">            e = e.getElement(index);</span>
<span class="nc" id="L617">        }</span>
<span class="nc" id="L618">        return e;</span>
    }

    // --- local methods -------------------------------------------------

    /**
     * Updates document structure as a result of text insertion.  This
     * will happen within a write lock.  This implementation simply
     * parses the inserted content for line breaks and builds up a set
     * of instructions for the element buffer.
     *
     * @param chng a description of the document change
     * @param attr the attributes
     */
    protected void insertUpdate(DefaultDocumentEvent chng, AttributeSet attr) {
<span class="nc" id="L633">        int offset = chng.getOffset();</span>
<span class="nc" id="L634">        int length = chng.getLength();</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">        if (attr == null) {</span>
<span class="nc" id="L636">            attr = SimpleAttributeSet.EMPTY;</span>
        }

        // Paragraph attributes should come from point after insertion.
        // You really only notice this when inserting at a paragraph
        // boundary.
<span class="nc" id="L642">        Element paragraph = getParagraphElement(offset + length);</span>
<span class="nc" id="L643">        AttributeSet pattr = paragraph.getAttributes();</span>
        // Character attributes should come from actual insertion point.
<span class="nc" id="L645">        Element pParagraph = getParagraphElement(offset);</span>
<span class="nc" id="L646">        Element run = pParagraph.getElement(pParagraph.getElementIndex</span>
<span class="nc" id="L647">                                            (offset));</span>
<span class="nc" id="L648">        int endOffset = offset + length;</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">        boolean insertingAtBoundry = (run.getEndOffset() == endOffset);</span>
<span class="nc" id="L650">        AttributeSet cattr = run.getAttributes();</span>

        try {
<span class="nc" id="L653">            Segment s = new Segment();</span>
<span class="nc" id="L654">            Vector&lt;ElementSpec&gt; parseBuffer = new Vector&lt;ElementSpec&gt;();</span>
<span class="nc" id="L655">            ElementSpec lastStartSpec = null;</span>
<span class="nc" id="L656">            boolean insertingAfterNewline = false;</span>
<span class="nc" id="L657">            short lastStartDirection = ElementSpec.OriginateDirection;</span>
            // Check if the previous character was a newline.
<span class="nc bnc" id="L659" title="All 2 branches missed.">            if (offset &gt; 0) {</span>
<span class="nc" id="L660">                getText(offset - 1, 1, s);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                if (s.array[s.offset] == '\n') {</span>
                    // Inserting after a newline.
<span class="nc" id="L663">                    insertingAfterNewline = true;</span>
<span class="nc" id="L664">                    lastStartDirection = createSpecsForInsertAfterNewline</span>
<span class="nc" id="L665">                                  (paragraph, pParagraph, pattr, parseBuffer,</span>
                                   offset, endOffset);
<span class="nc bnc" id="L667" title="All 2 branches missed.">                    for(int counter = parseBuffer.size() - 1; counter &gt;= 0;</span>
<span class="nc" id="L668">                        counter--) {</span>
<span class="nc" id="L669">                        ElementSpec spec = parseBuffer.elementAt(counter);</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">                        if(spec.getType() == ElementSpec.StartTagType) {</span>
<span class="nc" id="L671">                            lastStartSpec = spec;</span>
<span class="nc" id="L672">                            break;</span>
                        }
                    }
                }
            }
            // If not inserting after a new line, pull the attributes for
            // new paragraphs from the paragraph under the insertion point.
<span class="nc bnc" id="L679" title="All 2 branches missed.">            if(!insertingAfterNewline)</span>
<span class="nc" id="L680">                pattr = pParagraph.getAttributes();</span>

<span class="nc" id="L682">            getText(offset, length, s);</span>
<span class="nc" id="L683">            char[] txt = s.array;</span>
<span class="nc" id="L684">            int n = s.offset + s.count;</span>
<span class="nc" id="L685">            int lastOffset = s.offset;</span>

<span class="nc bnc" id="L687" title="All 2 branches missed.">            for (int i = s.offset; i &lt; n; i++) {</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">                if (txt[i] == '\n') {</span>
<span class="nc" id="L689">                    int breakOffset = i + 1;</span>
<span class="nc" id="L690">                    parseBuffer.addElement(</span>
                        new ElementSpec(attr, ElementSpec.ContentType,
                                               breakOffset - lastOffset));
<span class="nc" id="L693">                    parseBuffer.addElement(</span>
                        new ElementSpec(null, ElementSpec.EndTagType));
<span class="nc" id="L695">                    lastStartSpec = new ElementSpec(pattr, ElementSpec.</span>
                                                   StartTagType);
<span class="nc" id="L697">                    parseBuffer.addElement(lastStartSpec);</span>
<span class="nc" id="L698">                    lastOffset = breakOffset;</span>
                }
            }
<span class="nc bnc" id="L701" title="All 2 branches missed.">            if (lastOffset &lt; n) {</span>
<span class="nc" id="L702">                parseBuffer.addElement(</span>
                    new ElementSpec(attr, ElementSpec.ContentType,
                                           n - lastOffset));
            }

<span class="nc" id="L707">            ElementSpec first = parseBuffer.firstElement();</span>

<span class="nc" id="L709">            int docLength = getLength();</span>

            // Check for join previous of first content.
<span class="nc bnc" id="L712" title="All 2 branches missed.">            if(first.getType() == ElementSpec.ContentType &amp;&amp;</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">               cattr.isEqual(attr)) {</span>
<span class="nc" id="L714">                first.setDirection(ElementSpec.JoinPreviousDirection);</span>
            }

            // Do a join fracture/next for last start spec if necessary.
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if(lastStartSpec != null) {</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">                if(insertingAfterNewline) {</span>
<span class="nc" id="L720">                    lastStartSpec.setDirection(lastStartDirection);</span>
                }
                // Join to the fracture if NOT inserting at the end
                // (fracture only happens when not inserting at end of
                // paragraph).
<span class="nc bnc" id="L725" title="All 2 branches missed.">                else if(pParagraph.getEndOffset() != endOffset) {</span>
<span class="nc" id="L726">                    lastStartSpec.setDirection(ElementSpec.</span>
                                               JoinFractureDirection);
                }
                // Join to next if parent of pParagraph has another
                // element after pParagraph, and it isn't a leaf.
                else {
<span class="nc" id="L732">                    Element parent = pParagraph.getParentElement();</span>
<span class="nc" id="L733">                    int pParagraphIndex = parent.getElementIndex(offset);</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">                    if((pParagraphIndex + 1) &lt; parent.getElementCount() &amp;&amp;</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">                       !parent.getElement(pParagraphIndex + 1).isLeaf()) {</span>
<span class="nc" id="L736">                        lastStartSpec.setDirection(ElementSpec.</span>
                                                   JoinNextDirection);
                    }
                }
            }

            // Do a JoinNext for last spec if it is content, it doesn't
            // already have a direction set, no new paragraphs have been
            // inserted or a new paragraph has been inserted and its join
            // direction isn't originate, and the element at endOffset
            // is a leaf.
<span class="nc bnc" id="L747" title="All 4 branches missed.">            if(insertingAtBoundry &amp;&amp; endOffset &lt; docLength) {</span>
<span class="nc" id="L748">                ElementSpec last = parseBuffer.lastElement();</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                if(last.getType() == ElementSpec.ContentType &amp;&amp;</span>
<span class="nc bnc" id="L750" title="All 10 branches missed.">                   last.getDirection() != ElementSpec.JoinPreviousDirection &amp;&amp;</span>
                   ((lastStartSpec == null &amp;&amp; (paragraph == pParagraph ||
                                               insertingAfterNewline)) ||
<span class="nc bnc" id="L753" title="All 2 branches missed.">                    (lastStartSpec != null &amp;&amp; lastStartSpec.getDirection() !=</span>
                     ElementSpec.OriginateDirection))) {
<span class="nc" id="L755">                    Element nextRun = paragraph.getElement(paragraph.</span>
<span class="nc" id="L756">                                           getElementIndex(endOffset));</span>
                    // Don't try joining to a branch!
<span class="nc bnc" id="L758" title="All 2 branches missed.">                    if(nextRun.isLeaf() &amp;&amp;</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">                       attr.isEqual(nextRun.getAttributes())) {</span>
<span class="nc" id="L760">                        last.setDirection(ElementSpec.JoinNextDirection);</span>
                    }
                }
<span class="nc" id="L763">            }</span>
            // If not inserting at boundary and there is going to be a
            // fracture, then can join next on last content if cattr
            // matches the new attributes.
<span class="nc bnc" id="L767" title="All 4 branches missed.">            else if(!insertingAtBoundry &amp;&amp; lastStartSpec != null &amp;&amp;</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">                    lastStartSpec.getDirection() ==</span>
                    ElementSpec.JoinFractureDirection) {
<span class="nc" id="L770">                ElementSpec last = parseBuffer.lastElement();</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">                if(last.getType() == ElementSpec.ContentType &amp;&amp;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">                   last.getDirection() != ElementSpec.JoinPreviousDirection &amp;&amp;</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">                   attr.isEqual(cattr)) {</span>
<span class="nc" id="L774">                    last.setDirection(ElementSpec.JoinNextDirection);</span>
                }
            }

            // Check for the composed text element. If it is, merge the character attributes
            // into this element as well.
<span class="nc bnc" id="L780" title="All 2 branches missed.">            if (Utilities.isComposedTextAttributeDefined(attr)) {</span>
<span class="nc" id="L781">                MutableAttributeSet mattr = (MutableAttributeSet) attr;</span>
<span class="nc" id="L782">                mattr.addAttributes(cattr);</span>
<span class="nc" id="L783">                mattr.addAttribute(AbstractDocument.ElementNameAttribute,</span>
                        AbstractDocument.ContentElementName);

                // Assure that the composed text element is named properly
                // and doesn't have the CR attribute defined.
<span class="nc" id="L788">                mattr.addAttribute(StyleConstants.NameAttribute,</span>
                        AbstractDocument.ContentElementName);
<span class="nc bnc" id="L790" title="All 2 branches missed.">                if (mattr.isDefined(IMPLIED_CR)) {</span>
<span class="nc" id="L791">                    mattr.removeAttribute(IMPLIED_CR);</span>
                }
            }

<span class="nc" id="L795">            ElementSpec[] spec = new ElementSpec[parseBuffer.size()];</span>
<span class="nc" id="L796">            parseBuffer.copyInto(spec);</span>
<span class="nc" id="L797">            buffer.insert(offset, length, spec, chng);</span>
<span class="nc" id="L798">        } catch (BadLocationException bl) {</span>
<span class="nc" id="L799">        }</span>

<span class="nc" id="L801">        super.insertUpdate( chng, attr );</span>
<span class="nc" id="L802">    }</span>

    /**
     * This is called by insertUpdate when inserting after a new line.
     * It generates, in &lt;code&gt;parseBuffer&lt;/code&gt;, ElementSpecs that will
     * position the stack in &lt;code&gt;paragraph&lt;/code&gt;.&lt;p&gt;
     * It returns the direction the last StartSpec should have (this don't
     * necessarily create the last start spec).
     */
    short createSpecsForInsertAfterNewline(Element paragraph,
            Element pParagraph, AttributeSet pattr, Vector&lt;ElementSpec&gt; parseBuffer,
                                                 int offset, int endOffset) {
        // Need to find the common parent of pParagraph and paragraph.
<span class="nc bnc" id="L815" title="All 2 branches missed.">        if(paragraph.getParentElement() == pParagraph.getParentElement()) {</span>
            // The simple (and common) case that pParagraph and
            // paragraph have the same parent.
<span class="nc" id="L818">            ElementSpec spec = new ElementSpec(pattr, ElementSpec.EndTagType);</span>
<span class="nc" id="L819">            parseBuffer.addElement(spec);</span>
<span class="nc" id="L820">            spec = new ElementSpec(pattr, ElementSpec.StartTagType);</span>
<span class="nc" id="L821">            parseBuffer.addElement(spec);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">            if(pParagraph.getEndOffset() != endOffset)</span>
<span class="nc" id="L823">                return ElementSpec.JoinFractureDirection;</span>

<span class="nc" id="L825">            Element parent = pParagraph.getParentElement();</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">            if((parent.getElementIndex(offset) + 1) &lt; parent.getElementCount())</span>
<span class="nc" id="L827">                return ElementSpec.JoinNextDirection;</span>
<span class="nc" id="L828">        }</span>
        else {
            // Will only happen for text with more than 2 levels.
            // Find the common parent of a paragraph and pParagraph
<span class="nc" id="L832">            Vector&lt;Element&gt; leftParents = new Vector&lt;Element&gt;();</span>
<span class="nc" id="L833">            Vector&lt;Element&gt; rightParents = new Vector&lt;Element&gt;();</span>
<span class="nc" id="L834">            Element e = pParagraph;</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">            while(e != null) {</span>
<span class="nc" id="L836">                leftParents.addElement(e);</span>
<span class="nc" id="L837">                e = e.getParentElement();</span>
            }
<span class="nc" id="L839">            e = paragraph;</span>
<span class="nc" id="L840">            int leftIndex = -1;</span>
<span class="nc bnc" id="L841" title="All 4 branches missed.">            while(e != null &amp;&amp; (leftIndex = leftParents.indexOf(e)) == -1) {</span>
<span class="nc" id="L842">                rightParents.addElement(e);</span>
<span class="nc" id="L843">                e = e.getParentElement();</span>
            }
<span class="nc bnc" id="L845" title="All 2 branches missed.">            if(e != null) {</span>
                // e identifies the common parent.
                // Build the ends.
<span class="nc bnc" id="L848" title="All 2 branches missed.">                for(int counter = 0; counter &lt; leftIndex;</span>
<span class="nc" id="L849">                    counter++) {</span>
<span class="nc" id="L850">                    parseBuffer.addElement(new ElementSpec</span>
                                              (null, ElementSpec.EndTagType));
                }
                // And the starts.
                ElementSpec spec;
<span class="nc" id="L855">                for(int counter = rightParents.size() - 1;</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">                    counter &gt;= 0; counter--) {</span>
<span class="nc" id="L857">                    spec = new ElementSpec(rightParents.elementAt(counter).getAttributes(),</span>
                                   ElementSpec.StartTagType);
<span class="nc bnc" id="L859" title="All 2 branches missed.">                    if(counter &gt; 0)</span>
<span class="nc" id="L860">                        spec.setDirection(ElementSpec.JoinNextDirection);</span>
<span class="nc" id="L861">                    parseBuffer.addElement(spec);</span>
                }
                // If there are right parents, then we generated starts
                // down the right subtree and there will be an element to
                // join to.
<span class="nc bnc" id="L866" title="All 2 branches missed.">                if(rightParents.size() &gt; 0)</span>
<span class="nc" id="L867">                    return ElementSpec.JoinNextDirection;</span>
                // No right subtree, e.getElement(endOffset) is a
                // leaf. There will be a facture.
<span class="nc" id="L870">                return ElementSpec.JoinFractureDirection;</span>
            }
            // else: Could throw an exception here, but should never get here!
        }
<span class="nc" id="L874">        return ElementSpec.OriginateDirection;</span>
    }

    /**
     * Updates document structure as a result of text removal.
     *
     * @param chng a description of the document change
     */
    protected void removeUpdate(DefaultDocumentEvent chng) {
<span class="nc" id="L883">        super.removeUpdate(chng);</span>
<span class="nc" id="L884">        buffer.remove(chng.getOffset(), chng.getLength(), chng);</span>
<span class="nc" id="L885">    }</span>

    /**
     * Creates the root element to be used to represent the
     * default document structure.
     *
     * @return the element base
     */
    protected AbstractElement createDefaultRoot() {
        // grabs a write-lock for this initialization and
        // abandon it during initialization so in normal
        // operation we can detect an illegitimate attempt
        // to mutate attributes.
<span class="nc" id="L898">        writeLock();</span>
<span class="nc" id="L899">        BranchElement section = new SectionElement();</span>
<span class="nc" id="L900">        BranchElement paragraph = new BranchElement(section, null);</span>

<span class="nc" id="L902">        LeafElement brk = new LeafElement(paragraph, null, 0, 1);</span>
<span class="nc" id="L903">        Element[] buff = new Element[1];</span>
<span class="nc" id="L904">        buff[0] = brk;</span>
<span class="nc" id="L905">        paragraph.replace(0, 0, buff);</span>

<span class="nc" id="L907">        buff[0] = paragraph;</span>
<span class="nc" id="L908">        section.replace(0, 0, buff);</span>
<span class="nc" id="L909">        writeUnlock();</span>
<span class="nc" id="L910">        return section;</span>
    }

    /**
     * Gets the foreground color from an attribute set.
     *
     * @param attr the attribute set
     * @return the color
     */
    public Color getForeground(AttributeSet attr) {
<span class="nc" id="L920">        StyleContext styles = (StyleContext) getAttributeContext();</span>
<span class="nc" id="L921">        return styles.getForeground(attr);</span>
    }

    /**
     * Gets the background color from an attribute set.
     *
     * @param attr the attribute set
     * @return the color
     */
    public Color getBackground(AttributeSet attr) {
<span class="nc" id="L931">        StyleContext styles = (StyleContext) getAttributeContext();</span>
<span class="nc" id="L932">        return styles.getBackground(attr);</span>
    }

    /**
     * Gets the font from an attribute set.
     *
     * @param attr the attribute set
     * @return the font
     */
    public Font getFont(AttributeSet attr) {
<span class="nc" id="L942">        StyleContext styles = (StyleContext) getAttributeContext();</span>
<span class="nc" id="L943">        return styles.getFont(attr);</span>
    }

    /**
     * Called when any of this document's styles have changed.
     * Subclasses may wish to be intelligent about what gets damaged.
     *
     * @param style The Style that has changed.
     */
    protected void styleChanged(Style style) {
        // Only propagate change updated if have content
<span class="nc bnc" id="L954" title="All 2 branches missed.">        if (getLength() != 0) {</span>
            // lazily create a ChangeUpdateRunnable
<span class="nc bnc" id="L956" title="All 2 branches missed.">            if (updateRunnable == null) {</span>
<span class="nc" id="L957">                updateRunnable = new ChangeUpdateRunnable();</span>
            }

            // We may get a whole batch of these at once, so only
            // queue the runnable if it is not already pending
<span class="nc" id="L962">            synchronized(updateRunnable) {</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">                if (!updateRunnable.isPending) {</span>
<span class="nc" id="L964">                    SwingUtilities.invokeLater(updateRunnable);</span>
<span class="nc" id="L965">                    updateRunnable.isPending = true;</span>
                }
<span class="nc" id="L967">            }</span>
        }
<span class="nc" id="L969">    }</span>

    /**
     * Adds a document listener for notification of any changes.
     *
     * @param listener the listener
     * @see Document#addDocumentListener
     */
    public void addDocumentListener(DocumentListener listener) {
<span class="nc" id="L978">        synchronized(listeningStyles) {</span>
<span class="nc" id="L979">            int oldDLCount = listenerList.getListenerCount</span>
<span class="nc" id="L980">                                          (DocumentListener.class);</span>
<span class="nc" id="L981">            super.addDocumentListener(listener);</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">            if (oldDLCount == 0) {</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">                if (styleContextChangeListener == null) {</span>
<span class="nc" id="L984">                    styleContextChangeListener =</span>
<span class="nc" id="L985">                                      createStyleContextChangeListener();</span>
                }
<span class="nc bnc" id="L987" title="All 2 branches missed.">                if (styleContextChangeListener != null) {</span>
<span class="nc" id="L988">                    StyleContext styles = (StyleContext)getAttributeContext();</span>
<span class="nc" id="L989">                    List&lt;ChangeListener&gt; staleListeners =</span>
<span class="nc" id="L990">                        AbstractChangeHandler.getStaleListeners(styleContextChangeListener);</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">                    for (ChangeListener l: staleListeners) {</span>
<span class="nc" id="L992">                        styles.removeChangeListener(l);</span>
<span class="nc" id="L993">                    }</span>
<span class="nc" id="L994">                    styles.addChangeListener(styleContextChangeListener);</span>
                }
<span class="nc" id="L996">                updateStylesListeningTo();</span>
            }
<span class="nc" id="L998">        }</span>
<span class="nc" id="L999">    }</span>

    /**
     * Removes a document listener.
     *
     * @param listener the listener
     * @see Document#removeDocumentListener
     */
    public void removeDocumentListener(DocumentListener listener) {
<span class="nc" id="L1008">        synchronized(listeningStyles) {</span>
<span class="nc" id="L1009">            super.removeDocumentListener(listener);</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">            if (listenerList.getListenerCount(DocumentListener.class) == 0) {</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                for (int counter = listeningStyles.size() - 1; counter &gt;= 0;</span>
<span class="nc" id="L1012">                     counter--) {</span>
<span class="nc" id="L1013">                    listeningStyles.elementAt(counter).</span>
<span class="nc" id="L1014">                                    removeChangeListener(styleChangeListener);</span>
                }
<span class="nc" id="L1016">                listeningStyles.removeAllElements();</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">                if (styleContextChangeListener != null) {</span>
<span class="nc" id="L1018">                    StyleContext styles = (StyleContext)getAttributeContext();</span>
<span class="nc" id="L1019">                    styles.removeChangeListener(styleContextChangeListener);</span>
                }
            }
<span class="nc" id="L1022">        }</span>
<span class="nc" id="L1023">    }</span>

    /**
     * Returns a new instance of StyleChangeHandler.
     */
    ChangeListener createStyleChangeListener() {
<span class="nc" id="L1029">        return new StyleChangeHandler(this);</span>
    }

    /**
     * Returns a new instance of StyleContextChangeHandler.
     */
    ChangeListener createStyleContextChangeListener() {
<span class="nc" id="L1036">        return new StyleContextChangeHandler(this);</span>
    }

    /**
     * Adds a ChangeListener to new styles, and removes ChangeListener from
     * old styles.
     */
    void updateStylesListeningTo() {
<span class="nc" id="L1044">        synchronized(listeningStyles) {</span>
<span class="nc" id="L1045">            StyleContext styles = (StyleContext)getAttributeContext();</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            if (styleChangeListener == null) {</span>
<span class="nc" id="L1047">                styleChangeListener = createStyleChangeListener();</span>
            }
<span class="nc bnc" id="L1049" title="All 4 branches missed.">            if (styleChangeListener != null &amp;&amp; styles != null) {</span>
<span class="nc" id="L1050">                Enumeration styleNames = styles.getStyleNames();</span>
<span class="nc" id="L1051">                Vector v = (Vector)listeningStyles.clone();</span>
<span class="nc" id="L1052">                listeningStyles.removeAllElements();</span>
<span class="nc" id="L1053">                List&lt;ChangeListener&gt; staleListeners =</span>
<span class="nc" id="L1054">                    AbstractChangeHandler.getStaleListeners(styleChangeListener);</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">                while (styleNames.hasMoreElements()) {</span>
<span class="nc" id="L1056">                    String name = (String)styleNames.nextElement();</span>
<span class="nc" id="L1057">                    Style aStyle = styles.getStyle(name);</span>
<span class="nc" id="L1058">                    int index = v.indexOf(aStyle);</span>
<span class="nc" id="L1059">                    listeningStyles.addElement(aStyle);</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">                    if (index == -1) {</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">                        for (ChangeListener l: staleListeners) {</span>
<span class="nc" id="L1062">                            aStyle.removeChangeListener(l);</span>
<span class="nc" id="L1063">                        }</span>
<span class="nc" id="L1064">                        aStyle.addChangeListener(styleChangeListener);</span>
                    }
                    else {
<span class="nc" id="L1067">                        v.removeElementAt(index);</span>
                    }
<span class="nc" id="L1069">                }</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                for (int counter = v.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L1071">                    Style aStyle = (Style)v.elementAt(counter);</span>
<span class="nc" id="L1072">                    aStyle.removeChangeListener(styleChangeListener);</span>
                }
<span class="nc bnc" id="L1074" title="All 2 branches missed.">                if (listeningStyles.size() == 0) {</span>
<span class="nc" id="L1075">                    styleChangeListener = null;</span>
                }
            }
<span class="nc" id="L1078">        }</span>
<span class="nc" id="L1079">    }</span>

    private void readObject(ObjectInputStream s)
            throws ClassNotFoundException, IOException {
<span class="nc" id="L1083">        listeningStyles = new Vector&lt;Style&gt;();</span>
<span class="nc" id="L1084">        s.defaultReadObject();</span>
        // Reinstall style listeners.
<span class="nc bnc" id="L1086" title="All 2 branches missed.">        if (styleContextChangeListener == null &amp;&amp;</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">            listenerList.getListenerCount(DocumentListener.class) &gt; 0) {</span>
<span class="nc" id="L1088">            styleContextChangeListener = createStyleContextChangeListener();</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">            if (styleContextChangeListener != null) {</span>
<span class="nc" id="L1090">                StyleContext styles = (StyleContext)getAttributeContext();</span>
<span class="nc" id="L1091">                styles.addChangeListener(styleContextChangeListener);</span>
            }
<span class="nc" id="L1093">            updateStylesListeningTo();</span>
        }
<span class="nc" id="L1095">    }</span>

    // --- member variables -----------------------------------------------------------

    /**
     * The default size of the initial content buffer.
     */
    public static final int BUFFER_SIZE_DEFAULT = 4096;

    protected ElementBuffer buffer;

    /** Styles listening to. */
    private transient Vector&lt;Style&gt; listeningStyles;

    /** Listens to Styles. */
    private transient ChangeListener styleChangeListener;

    /** Listens to Styles. */
    private transient ChangeListener styleContextChangeListener;

    /** Run to create a change event for the document */
    private transient ChangeUpdateRunnable updateRunnable;

    /**
     * Default root element for a document... maps out the
     * paragraphs/lines contained.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    protected class SectionElement extends BranchElement {

        /**
         * Creates a new SectionElement.
         */
<span class="nc" id="L1136">        public SectionElement() {</span>
<span class="nc" id="L1137">            super(null, null);</span>
<span class="nc" id="L1138">        }</span>

        /**
         * Gets the name of the element.
         *
         * @return the name
         */
        public String getName() {
<span class="nc" id="L1146">            return SectionElementName;</span>
        }
    }

    /**
     * Specification for building elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    public static class ElementSpec {

        /**
         * A possible value for getType.  This specifies
         * that this record type is a start tag and
         * represents markup that specifies the start
         * of an element.
         */
        public static final short StartTagType = 1;

        /**
         * A possible value for getType.  This specifies
         * that this record type is a end tag and
         * represents markup that specifies the end
         * of an element.
         */
        public static final short EndTagType = 2;

        /**
         * A possible value for getType.  This specifies
         * that this record type represents content.
         */
        public static final short ContentType = 3;

        /**
         * A possible value for getDirection.  This specifies
         * that the data associated with this record should
         * be joined to what precedes it.
         */
        public static final short JoinPreviousDirection = 4;

        /**
         * A possible value for getDirection.  This specifies
         * that the data associated with this record should
         * be joined to what follows it.
         */
        public static final short JoinNextDirection = 5;

        /**
         * A possible value for getDirection.  This specifies
         * that the data associated with this record should
         * be used to originate a new element.  This would be
         * the normal value.
         */
        public static final short OriginateDirection = 6;

        /**
         * A possible value for getDirection.  This specifies
         * that the data associated with this record should
         * be joined to the fractured element.
         */
        public static final short JoinFractureDirection = 7;


        /**
         * Constructor useful for markup when the markup will not
         * be stored in the document.
         *
         * @param a the attributes for the element
         * @param type the type of the element (StartTagType, EndTagType,
         *  ContentType)
         */
        public ElementSpec(AttributeSet a, short type) {
<span class="nc" id="L1225">            this(a, type, null, 0, 0);</span>
<span class="nc" id="L1226">        }</span>

        /**
         * Constructor for parsing inside the document when
         * the data has already been added, but len information
         * is needed.
         *
         * @param a the attributes for the element
         * @param type the type of the element (StartTagType, EndTagType,
         *  ContentType)
         * @param len the length &amp;gt;= 0
         */
        public ElementSpec(AttributeSet a, short type, int len) {
<span class="nc" id="L1239">            this(a, type, null, 0, len);</span>
<span class="nc" id="L1240">        }</span>

        /**
         * Constructor for creating a spec externally for batch
         * input of content and markup into the document.
         *
         * @param a the attributes for the element
         * @param type the type of the element (StartTagType, EndTagType,
         *  ContentType)
         * @param txt the text for the element
         * @param offs the offset into the text &amp;gt;= 0
         * @param len the length of the text &amp;gt;= 0
         */
        public ElementSpec(AttributeSet a, short type, char[] txt,
<span class="nc" id="L1254">                                  int offs, int len) {</span>
<span class="nc" id="L1255">            attr = a;</span>
<span class="nc" id="L1256">            this.type = type;</span>
<span class="nc" id="L1257">            this.data = txt;</span>
<span class="nc" id="L1258">            this.offs = offs;</span>
<span class="nc" id="L1259">            this.len = len;</span>
<span class="nc" id="L1260">            this.direction = OriginateDirection;</span>
<span class="nc" id="L1261">        }</span>

        /**
         * Sets the element type.
         *
         * @param type the type of the element (StartTagType, EndTagType,
         *  ContentType)
         */
        public void setType(short type) {
<span class="nc" id="L1270">            this.type = type;</span>
<span class="nc" id="L1271">        }</span>

        /**
         * Gets the element type.
         *
         * @return  the type of the element (StartTagType, EndTagType,
         *  ContentType)
         */
        public short getType() {
<span class="nc" id="L1280">            return type;</span>
        }

        /**
         * Sets the direction.
         *
         * @param direction the direction (JoinPreviousDirection,
         *   JoinNextDirection)
         */
        public void setDirection(short direction) {
<span class="nc" id="L1290">            this.direction = direction;</span>
<span class="nc" id="L1291">        }</span>

        /**
         * Gets the direction.
         *
         * @return the direction (JoinPreviousDirection, JoinNextDirection)
         */
        public short getDirection() {
<span class="nc" id="L1299">            return direction;</span>
        }

        /**
         * Gets the element attributes.
         *
         * @return the attribute set
         */
        public AttributeSet getAttributes() {
<span class="nc" id="L1308">            return attr;</span>
        }

        /**
         * Gets the array of characters.
         *
         * @return the array
         */
        public char[] getArray() {
<span class="nc" id="L1317">            return data;</span>
        }


        /**
         * Gets the starting offset.
         *
         * @return the offset &amp;gt;= 0
         */
        public int getOffset() {
<span class="nc" id="L1327">            return offs;</span>
        }

        /**
         * Gets the length.
         *
         * @return the length &amp;gt;= 0
         */
        public int getLength() {
<span class="nc" id="L1336">            return len;</span>
        }

        /**
         * Converts the element to a string.
         *
         * @return the string
         */
        public String toString() {
<span class="nc" id="L1345">            String tlbl = &quot;??&quot;;</span>
<span class="nc" id="L1346">            String plbl = &quot;??&quot;;</span>
<span class="nc bnc" id="L1347" title="All 4 branches missed.">            switch(type) {</span>
            case StartTagType:
<span class="nc" id="L1349">                tlbl = &quot;StartTag&quot;;</span>
<span class="nc" id="L1350">                break;</span>
            case ContentType:
<span class="nc" id="L1352">                tlbl = &quot;Content&quot;;</span>
<span class="nc" id="L1353">                break;</span>
            case EndTagType:
<span class="nc" id="L1355">                tlbl = &quot;EndTag&quot;;</span>
                break;
            }
<span class="nc bnc" id="L1358" title="All 5 branches missed.">            switch(direction) {</span>
            case JoinPreviousDirection:
<span class="nc" id="L1360">                plbl = &quot;JoinPrevious&quot;;</span>
<span class="nc" id="L1361">                break;</span>
            case JoinNextDirection:
<span class="nc" id="L1363">                plbl = &quot;JoinNext&quot;;</span>
<span class="nc" id="L1364">                break;</span>
            case OriginateDirection:
<span class="nc" id="L1366">                plbl = &quot;Originate&quot;;</span>
<span class="nc" id="L1367">                break;</span>
            case JoinFractureDirection:
<span class="nc" id="L1369">                plbl = &quot;Fracture&quot;;</span>
                break;
            }
<span class="nc" id="L1372">            return tlbl + &quot;:&quot; + plbl + &quot;:&quot; + getLength();</span>
        }

        private AttributeSet attr;
        private int len;
        private short type;
        private short direction;

        private int offs;
        private char[] data;
    }

    /**
     * Class to manage changes to the element
     * hierarchy.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    public class ElementBuffer implements Serializable {

        /**
         * Creates a new ElementBuffer.
         *
         * @param root the root element
         * @since 1.4
         */
<span class="nc" id="L1405">        public ElementBuffer(Element root) {</span>
<span class="nc" id="L1406">            this.root = root;</span>
<span class="nc" id="L1407">            changes = new Vector&lt;ElemChanges&gt;();</span>
<span class="nc" id="L1408">            path = new Stack&lt;ElemChanges&gt;();</span>
<span class="nc" id="L1409">        }</span>

        /**
         * Gets the root element.
         *
         * @return the root element
         */
        public Element getRootElement() {
<span class="nc" id="L1417">            return root;</span>
        }

        /**
         * Inserts new content.
         *
         * @param offset the starting offset &amp;gt;= 0
         * @param length the length &amp;gt;= 0
         * @param data the data to insert
         * @param de the event capturing this edit
         */
        public void insert(int offset, int length, ElementSpec[] data,
                                 DefaultDocumentEvent de) {
<span class="nc bnc" id="L1430" title="All 2 branches missed.">            if (length == 0) {</span>
                // Nothing was inserted, no structure change.
<span class="nc" id="L1432">                return;</span>
            }
<span class="nc" id="L1434">            insertOp = true;</span>
<span class="nc" id="L1435">            beginEdits(offset, length);</span>
<span class="nc" id="L1436">            insertUpdate(data);</span>
<span class="nc" id="L1437">            endEdits(de);</span>

<span class="nc" id="L1439">            insertOp = false;</span>
<span class="nc" id="L1440">        }</span>

        void create(int length, ElementSpec[] data, DefaultDocumentEvent de) {
<span class="nc" id="L1443">            insertOp = true;</span>
<span class="nc" id="L1444">            beginEdits(offset, length);</span>

            // PENDING(prinz) this needs to be fixed to create a new
            // root element as well, but requires changes to the
            // DocumentEvent to inform the views that there is a new
            // root element.

            // Recreate the ending fake element to have the correct offsets.
<span class="nc" id="L1452">            Element elem = root;</span>
<span class="nc" id="L1453">            int index = elem.getElementIndex(0);</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">            while (! elem.isLeaf()) {</span>
<span class="nc" id="L1455">                Element child = elem.getElement(index);</span>
<span class="nc" id="L1456">                push(elem, index);</span>
<span class="nc" id="L1457">                elem = child;</span>
<span class="nc" id="L1458">                index = elem.getElementIndex(0);</span>
<span class="nc" id="L1459">            }</span>
<span class="nc" id="L1460">            ElemChanges ec = path.peek();</span>
<span class="nc" id="L1461">            Element child = ec.parent.getElement(ec.index);</span>
<span class="nc" id="L1462">            ec.added.addElement(createLeafElement(ec.parent,</span>
<span class="nc" id="L1463">                                child.getAttributes(), getLength(),</span>
<span class="nc" id="L1464">                                child.getEndOffset()));</span>
<span class="nc" id="L1465">            ec.removed.addElement(child);</span>
<span class="nc bnc" id="L1466" title="All 2 branches missed.">            while (path.size() &gt; 1) {</span>
<span class="nc" id="L1467">                pop();</span>
            }

<span class="nc" id="L1470">            int n = data.length;</span>

            // Reset the root elements attributes.
<span class="nc" id="L1473">            AttributeSet newAttrs = null;</span>
<span class="nc bnc" id="L1474" title="All 4 branches missed.">            if (n &gt; 0 &amp;&amp; data[0].getType() == ElementSpec.StartTagType) {</span>
<span class="nc" id="L1475">                newAttrs = data[0].getAttributes();</span>
            }
<span class="nc bnc" id="L1477" title="All 2 branches missed.">            if (newAttrs == null) {</span>
<span class="nc" id="L1478">                newAttrs = SimpleAttributeSet.EMPTY;</span>
            }
<span class="nc" id="L1480">            MutableAttributeSet attr = (MutableAttributeSet)root.</span>
<span class="nc" id="L1481">                                       getAttributes();</span>
<span class="nc" id="L1482">            de.addEdit(new AttributeUndoableEdit(root, newAttrs, true));</span>
<span class="nc" id="L1483">            attr.removeAttributes(attr);</span>
<span class="nc" id="L1484">            attr.addAttributes(newAttrs);</span>

            // fold in the specified subtree
<span class="nc bnc" id="L1487" title="All 2 branches missed.">            for (int i = 1; i &lt; n; i++) {</span>
<span class="nc" id="L1488">                insertElement(data[i]);</span>
            }

            // pop the remaining path
<span class="nc bnc" id="L1492" title="All 2 branches missed.">            while (path.size() != 0) {</span>
<span class="nc" id="L1493">                pop();</span>
            }

<span class="nc" id="L1496">            endEdits(de);</span>
<span class="nc" id="L1497">            insertOp = false;</span>
<span class="nc" id="L1498">        }</span>

        /**
         * Removes content.
         *
         * @param offset the starting offset &amp;gt;= 0
         * @param length the length &amp;gt;= 0
         * @param de the event capturing this edit
         */
        public void remove(int offset, int length, DefaultDocumentEvent de) {
<span class="nc" id="L1508">            beginEdits(offset, length);</span>
<span class="nc" id="L1509">            removeUpdate();</span>
<span class="nc" id="L1510">            endEdits(de);</span>
<span class="nc" id="L1511">        }</span>

        /**
         * Changes content.
         *
         * @param offset the starting offset &amp;gt;= 0
         * @param length the length &amp;gt;= 0
         * @param de the event capturing this edit
         */
        public void change(int offset, int length, DefaultDocumentEvent de) {
<span class="nc" id="L1521">            beginEdits(offset, length);</span>
<span class="nc" id="L1522">            changeUpdate();</span>
<span class="nc" id="L1523">            endEdits(de);</span>
<span class="nc" id="L1524">        }</span>

        /**
         * Inserts an update into the document.
         *
         * @param data the elements to insert
         */
        protected void insertUpdate(ElementSpec[] data) {
            // push the path
<span class="nc" id="L1533">            Element elem = root;</span>
<span class="nc" id="L1534">            int index = elem.getElementIndex(offset);</span>
<span class="nc bnc" id="L1535" title="All 2 branches missed.">            while (! elem.isLeaf()) {</span>
<span class="nc" id="L1536">                Element child = elem.getElement(index);</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">                push(elem, (child.isLeaf() ? index : index+1));</span>
<span class="nc" id="L1538">                elem = child;</span>
<span class="nc" id="L1539">                index = elem.getElementIndex(offset);</span>
<span class="nc" id="L1540">            }</span>

            // Build a copy of the original path.
<span class="nc" id="L1543">            insertPath = new ElemChanges[path.size()];</span>
<span class="nc" id="L1544">            path.copyInto(insertPath);</span>

            // Haven't created the fracture yet.
<span class="nc" id="L1547">            createdFracture = false;</span>

            // Insert the first content.
            int i;

<span class="nc" id="L1552">            recreateLeafs = false;</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">            if(data[0].getType() == ElementSpec.ContentType) {</span>
<span class="nc" id="L1554">                insertFirstContent(data);</span>
<span class="nc" id="L1555">                pos += data[0].getLength();</span>
<span class="nc" id="L1556">                i = 1;</span>
            }
            else {
<span class="nc" id="L1559">                fractureDeepestLeaf(data);</span>
<span class="nc" id="L1560">                i = 0;</span>
            }

            // fold in the specified subtree
<span class="nc" id="L1564">            int n = data.length;</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">            for (; i &lt; n; i++) {</span>
<span class="nc" id="L1566">                insertElement(data[i]);</span>
            }

            // Fracture, if we haven't yet.
<span class="nc bnc" id="L1570" title="All 2 branches missed.">            if(!createdFracture)</span>
<span class="nc" id="L1571">                fracture(-1);</span>

            // pop the remaining path
<span class="nc bnc" id="L1574" title="All 2 branches missed.">            while (path.size() != 0) {</span>
<span class="nc" id="L1575">                pop();</span>
            }

            // Offset the last index if necessary.
<span class="nc bnc" id="L1579" title="All 4 branches missed.">            if(offsetLastIndex &amp;&amp; offsetLastIndexOnReplace) {</span>
<span class="nc" id="L1580">                insertPath[insertPath.length - 1].index++;</span>
            }

            // Make sure an edit is going to be created for each of the
            // original path items that have a change.
<span class="nc bnc" id="L1585" title="All 2 branches missed.">            for(int counter = insertPath.length - 1; counter &gt;= 0;</span>
<span class="nc" id="L1586">                counter--) {</span>
<span class="nc" id="L1587">                ElemChanges change = insertPath[counter];</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">                if(change.parent == fracturedParent)</span>
<span class="nc" id="L1589">                    change.added.addElement(fracturedChild);</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">                if((change.added.size() &gt; 0 ||</span>
<span class="nc bnc" id="L1591" title="All 4 branches missed.">                    change.removed.size() &gt; 0) &amp;&amp; !changes.contains(change)) {</span>
                    // PENDING(sky): Do I need to worry about order here?
<span class="nc" id="L1593">                    changes.addElement(change);</span>
                }
            }

            // An insert at 0 with an initial end implies some elements
            // will have no children (the bottomost leaf would have length 0)
            // this will find what element need to be removed and remove it.
<span class="nc bnc" id="L1600" title="All 4 branches missed.">            if (offset == 0 &amp;&amp; fracturedParent != null &amp;&amp;</span>
<span class="nc bnc" id="L1601" title="All 2 branches missed.">                data[0].getType() == ElementSpec.EndTagType) {</span>
<span class="nc" id="L1602">                int counter = 0;</span>
<span class="nc bnc" id="L1603" title="All 2 branches missed.">                while (counter &lt; data.length &amp;&amp;</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">                       data[counter].getType() == ElementSpec.EndTagType) {</span>
<span class="nc" id="L1605">                    counter++;</span>
                }
<span class="nc" id="L1607">                ElemChanges change = insertPath[insertPath.length -</span>
                                               counter - 1];
<span class="nc" id="L1609">                change.removed.insertElementAt(change.parent.getElement</span>
<span class="nc" id="L1610">                                               (--change.index), 0);</span>
            }
<span class="nc" id="L1612">        }</span>

        /**
         * Updates the element structure in response to a removal from the
         * associated sequence in the document.  Any elements consumed by the
         * span of the removal are removed.
         */
        protected void removeUpdate() {
<span class="nc" id="L1620">            removeElements(root, offset, offset + length);</span>
<span class="nc" id="L1621">        }</span>

        /**
         * Updates the element structure in response to a change in the
         * document.
         */
        protected void changeUpdate() {
<span class="nc" id="L1628">            boolean didEnd = split(offset, length);</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">            if (! didEnd) {</span>
                // need to do the other end
<span class="nc bnc" id="L1631" title="All 2 branches missed.">                while (path.size() != 0) {</span>
<span class="nc" id="L1632">                    pop();</span>
                }
<span class="nc" id="L1634">                split(offset + length, 0);</span>
            }
<span class="nc bnc" id="L1636" title="All 2 branches missed.">            while (path.size() != 0) {</span>
<span class="nc" id="L1637">                pop();</span>
            }
<span class="nc" id="L1639">        }</span>

        boolean split(int offs, int len) {
<span class="nc" id="L1642">            boolean splitEnd = false;</span>
            // push the path
<span class="nc" id="L1644">            Element e = root;</span>
<span class="nc" id="L1645">            int index = e.getElementIndex(offs);</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">            while (! e.isLeaf()) {</span>
<span class="nc" id="L1647">                push(e, index);</span>
<span class="nc" id="L1648">                e = e.getElement(index);</span>
<span class="nc" id="L1649">                index = e.getElementIndex(offs);</span>
            }

<span class="nc" id="L1652">            ElemChanges ec = path.peek();</span>
<span class="nc" id="L1653">            Element child = ec.parent.getElement(ec.index);</span>
            // make sure there is something to do... if the
            // offset is already at a boundary then there is
            // nothing to do.
<span class="nc bnc" id="L1657" title="All 4 branches missed.">            if (child.getStartOffset() &lt; offs &amp;&amp; offs &lt; child.getEndOffset()) {</span>
                // we need to split, now see if the other end is within
                // the same parent.
<span class="nc" id="L1660">                int index0 = ec.index;</span>
<span class="nc" id="L1661">                int index1 = index0;</span>
<span class="nc bnc" id="L1662" title="All 4 branches missed.">                if (((offs + len) &lt; ec.parent.getEndOffset()) &amp;&amp; (len != 0)) {</span>
                    // it's a range split in the same parent
<span class="nc" id="L1664">                    index1 = ec.parent.getElementIndex(offs+len);</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">                    if (index1 == index0) {</span>
                        // it's a three-way split
<span class="nc" id="L1667">                        ec.removed.addElement(child);</span>
<span class="nc" id="L1668">                        e = createLeafElement(ec.parent, child.getAttributes(),</span>
<span class="nc" id="L1669">                                              child.getStartOffset(), offs);</span>
<span class="nc" id="L1670">                        ec.added.addElement(e);</span>
<span class="nc" id="L1671">                        e = createLeafElement(ec.parent, child.getAttributes(),</span>
                                          offs, offs + len);
<span class="nc" id="L1673">                        ec.added.addElement(e);</span>
<span class="nc" id="L1674">                        e = createLeafElement(ec.parent, child.getAttributes(),</span>
<span class="nc" id="L1675">                                              offs + len, child.getEndOffset());</span>
<span class="nc" id="L1676">                        ec.added.addElement(e);</span>
<span class="nc" id="L1677">                        return true;</span>
                    } else {
<span class="nc" id="L1679">                        child = ec.parent.getElement(index1);</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">                        if ((offs + len) == child.getStartOffset()) {</span>
                            // end is already on a boundary
<span class="nc" id="L1682">                            index1 = index0;</span>
                        }
                    }
<span class="nc" id="L1685">                    splitEnd = true;</span>
                }

                // split the first location
<span class="nc" id="L1689">                pos = offs;</span>
<span class="nc" id="L1690">                child = ec.parent.getElement(index0);</span>
<span class="nc" id="L1691">                ec.removed.addElement(child);</span>
<span class="nc" id="L1692">                e = createLeafElement(ec.parent, child.getAttributes(),</span>
<span class="nc" id="L1693">                                      child.getStartOffset(), pos);</span>
<span class="nc" id="L1694">                ec.added.addElement(e);</span>
<span class="nc" id="L1695">                e = createLeafElement(ec.parent, child.getAttributes(),</span>
<span class="nc" id="L1696">                                      pos, child.getEndOffset());</span>
<span class="nc" id="L1697">                ec.added.addElement(e);</span>

                // pick up things in the middle
<span class="nc bnc" id="L1700" title="All 2 branches missed.">                for (int i = index0 + 1; i &lt; index1; i++) {</span>
<span class="nc" id="L1701">                    child = ec.parent.getElement(i);</span>
<span class="nc" id="L1702">                    ec.removed.addElement(child);</span>
<span class="nc" id="L1703">                    ec.added.addElement(child);</span>
                }

<span class="nc bnc" id="L1706" title="All 2 branches missed.">                if (index1 != index0) {</span>
<span class="nc" id="L1707">                    child = ec.parent.getElement(index1);</span>
<span class="nc" id="L1708">                    pos = offs + len;</span>
<span class="nc" id="L1709">                    ec.removed.addElement(child);</span>
<span class="nc" id="L1710">                    e = createLeafElement(ec.parent, child.getAttributes(),</span>
<span class="nc" id="L1711">                                          child.getStartOffset(), pos);</span>
<span class="nc" id="L1712">                    ec.added.addElement(e);</span>
<span class="nc" id="L1713">                    e = createLeafElement(ec.parent, child.getAttributes(),</span>
<span class="nc" id="L1714">                                          pos, child.getEndOffset());</span>
<span class="nc" id="L1715">                    ec.added.addElement(e);</span>
                }
            }
<span class="nc" id="L1718">            return splitEnd;</span>
        }

        /**
         * Creates the UndoableEdit record for the edits made
         * in the buffer.
         */
        void endEdits(DefaultDocumentEvent de) {
<span class="nc" id="L1726">            int n = changes.size();</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L1728">                ElemChanges ec = changes.elementAt(i);</span>
<span class="nc" id="L1729">                Element[] removed = new Element[ec.removed.size()];</span>
<span class="nc" id="L1730">                ec.removed.copyInto(removed);</span>
<span class="nc" id="L1731">                Element[] added = new Element[ec.added.size()];</span>
<span class="nc" id="L1732">                ec.added.copyInto(added);</span>
<span class="nc" id="L1733">                int index = ec.index;</span>
<span class="nc" id="L1734">                ((BranchElement) ec.parent).replace(index, removed.length, added);</span>
<span class="nc" id="L1735">                ElementEdit ee = new ElementEdit(ec.parent, index, removed, added);</span>
<span class="nc" id="L1736">                de.addEdit(ee);</span>
            }

<span class="nc" id="L1739">            changes.removeAllElements();</span>
<span class="nc" id="L1740">            path.removeAllElements();</span>

            /*
            for (int i = 0; i &lt; n; i++) {
                ElemChanges ec = (ElemChanges) changes.elementAt(i);
                System.err.print(&quot;edited: &quot; + ec.parent + &quot; at: &quot; + ec.index +
                    &quot; removed &quot; + ec.removed.size());
                if (ec.removed.size() &gt; 0) {
                    int r0 = ((Element) ec.removed.firstElement()).getStartOffset();
                    int r1 = ((Element) ec.removed.lastElement()).getEndOffset();
                    System.err.print(&quot;[&quot; + r0 + &quot;,&quot; + r1 + &quot;]&quot;);
                }
                System.err.print(&quot; added &quot; + ec.added.size());
                if (ec.added.size() &gt; 0) {
                    int p0 = ((Element) ec.added.firstElement()).getStartOffset();
                    int p1 = ((Element) ec.added.lastElement()).getEndOffset();
                    System.err.print(&quot;[&quot; + p0 + &quot;,&quot; + p1 + &quot;]&quot;);
                }
                System.err.println(&quot;&quot;);
            }
            */
<span class="nc" id="L1761">        }</span>

        /**
         * Initialize the buffer
         */
        void beginEdits(int offset, int length) {
<span class="nc" id="L1767">            this.offset = offset;</span>
<span class="nc" id="L1768">            this.length = length;</span>
<span class="nc" id="L1769">            this.endOffset = offset + length;</span>
<span class="nc" id="L1770">            pos = offset;</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">            if (changes == null) {</span>
<span class="nc" id="L1772">                changes = new Vector&lt;ElemChanges&gt;();</span>
            } else {
<span class="nc" id="L1774">                changes.removeAllElements();</span>
            }
<span class="nc bnc" id="L1776" title="All 2 branches missed.">            if (path == null) {</span>
<span class="nc" id="L1777">                path = new Stack&lt;ElemChanges&gt;();</span>
            } else {
<span class="nc" id="L1779">                path.removeAllElements();</span>
            }
<span class="nc" id="L1781">            fracturedParent = null;</span>
<span class="nc" id="L1782">            fracturedChild = null;</span>
<span class="nc" id="L1783">            offsetLastIndex = offsetLastIndexOnReplace = false;</span>
<span class="nc" id="L1784">        }</span>

        /**
         * Pushes a new element onto the stack that represents
         * the current path.
         * @param record Whether or not the push should be
         *  recorded as an element change or not.
         * @param isFracture true if pushing on an element that was created
         * as the result of a fracture.
         */
        void push(Element e, int index, boolean isFracture) {
<span class="nc" id="L1795">            ElemChanges ec = new ElemChanges(e, index, isFracture);</span>
<span class="nc" id="L1796">            path.push(ec);</span>
<span class="nc" id="L1797">        }</span>

        void push(Element e, int index) {
<span class="nc" id="L1800">            push(e, index, false);</span>
<span class="nc" id="L1801">        }</span>

        void pop() {
<span class="nc" id="L1804">            ElemChanges ec = path.peek();</span>
<span class="nc" id="L1805">            path.pop();</span>
<span class="nc bnc" id="L1806" title="All 4 branches missed.">            if ((ec.added.size() &gt; 0) || (ec.removed.size() &gt; 0)) {</span>
<span class="nc" id="L1807">                changes.addElement(ec);</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">            } else if (! path.isEmpty()) {</span>
<span class="nc" id="L1809">                Element e = ec.parent;</span>
<span class="nc bnc" id="L1810" title="All 2 branches missed.">                if(e.getElementCount() == 0) {</span>
                    // if we pushed a branch element that didn't get
                    // used, make sure its not marked as having been added.
<span class="nc" id="L1813">                    ec = path.peek();</span>
<span class="nc" id="L1814">                    ec.added.removeElement(e);</span>
                }
            }
<span class="nc" id="L1817">        }</span>

        /**
         * move the current offset forward by n.
         */
        void advance(int n) {
<span class="nc" id="L1823">            pos += n;</span>
<span class="nc" id="L1824">        }</span>

        void insertElement(ElementSpec es) {
<span class="nc" id="L1827">            ElemChanges ec = path.peek();</span>
<span class="nc bnc" id="L1828" title="All 4 branches missed.">            switch(es.getType()) {</span>
            case ElementSpec.StartTagType:
<span class="nc bnc" id="L1830" title="All 3 branches missed.">                switch(es.getDirection()) {</span>
                case ElementSpec.JoinNextDirection:
                    // Don't create a new element, use the existing one
                    // at the specified location.
<span class="nc" id="L1834">                    Element parent = ec.parent.getElement(ec.index);</span>

<span class="nc bnc" id="L1836" title="All 2 branches missed.">                    if(parent.isLeaf()) {</span>
                        // This happens if inserting into a leaf, followed
                        // by a join next where next sibling is not a leaf.
<span class="nc bnc" id="L1839" title="All 2 branches missed.">                        if((ec.index + 1) &lt; ec.parent.getElementCount())</span>
<span class="nc" id="L1840">                            parent = ec.parent.getElement(ec.index + 1);</span>
                        else
<span class="nc" id="L1842">                            throw new StateInvariantError(&quot;Join next to leaf&quot;);</span>
                    }
                    // Not really a fracture, but need to treat it like
                    // one so that content join next will work correctly.
                    // We can do this because there will never be a join
                    // next followed by a join fracture.
<span class="nc" id="L1848">                    push(parent, 0, true);</span>
<span class="nc" id="L1849">                    break;</span>
                case ElementSpec.JoinFractureDirection:
<span class="nc bnc" id="L1851" title="All 2 branches missed.">                    if(!createdFracture) {</span>
                        // Should always be something on the stack!
<span class="nc" id="L1853">                        fracture(path.size() - 1);</span>
                    }
                    // If parent isn't a fracture, fracture will be
                    // fracturedChild.
<span class="nc bnc" id="L1857" title="All 2 branches missed.">                    if(!ec.isFracture) {</span>
<span class="nc" id="L1858">                        push(fracturedChild, 0, true);</span>
                    }
                    else
                        // Parent is a fracture, use 1st element.
<span class="nc" id="L1862">                        push(ec.parent.getElement(0), 0, true);</span>
<span class="nc" id="L1863">                    break;</span>
                default:
<span class="nc" id="L1865">                    Element belem = createBranchElement(ec.parent,</span>
<span class="nc" id="L1866">                                                        es.getAttributes());</span>
<span class="nc" id="L1867">                    ec.added.addElement(belem);</span>
<span class="nc" id="L1868">                    push(belem, 0);</span>
                    break;
                }
<span class="nc" id="L1871">                break;</span>
            case ElementSpec.EndTagType:
<span class="nc" id="L1873">                pop();</span>
<span class="nc" id="L1874">                break;</span>
            case ElementSpec.ContentType:
<span class="nc" id="L1876">              int len = es.getLength();</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">                if (es.getDirection() != ElementSpec.JoinNextDirection) {</span>
<span class="nc" id="L1878">                    Element leaf = createLeafElement(ec.parent, es.getAttributes(),</span>
                                                     pos, pos + len);
<span class="nc" id="L1880">                    ec.added.addElement(leaf);</span>
<span class="nc" id="L1881">                }</span>
                else {
                    // JoinNext on tail is only applicable if last element
                    // and attributes come from that of first element.
                    // With a little extra testing it would be possible
                    // to NOT due this again, as more than likely fracture()
                    // created this element.
<span class="nc bnc" id="L1888" title="All 2 branches missed.">                    if(!ec.isFracture) {</span>
<span class="nc" id="L1889">                        Element first = null;</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">                        if(insertPath != null) {</span>
<span class="nc" id="L1891">                            for(int counter = insertPath.length - 1;</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">                                counter &gt;= 0; counter--) {</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">                                if(insertPath[counter] == ec) {</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">                                    if(counter != (insertPath.length - 1))</span>
<span class="nc" id="L1895">                                        first = ec.parent.getElement(ec.index);</span>
                                    break;
                                }
                            }
                        }
<span class="nc bnc" id="L1900" title="All 2 branches missed.">                        if(first == null)</span>
<span class="nc" id="L1901">                            first = ec.parent.getElement(ec.index + 1);</span>
<span class="nc" id="L1902">                        Element leaf = createLeafElement(ec.parent, first.</span>
<span class="nc" id="L1903">                                 getAttributes(), pos, first.getEndOffset());</span>
<span class="nc" id="L1904">                        ec.added.addElement(leaf);</span>
<span class="nc" id="L1905">                        ec.removed.addElement(first);</span>
<span class="nc" id="L1906">                    }</span>
                    else {
                        // Parent was fractured element.
<span class="nc" id="L1909">                        Element first = ec.parent.getElement(0);</span>
<span class="nc" id="L1910">                        Element leaf = createLeafElement(ec.parent, first.</span>
<span class="nc" id="L1911">                                 getAttributes(), pos, first.getEndOffset());</span>
<span class="nc" id="L1912">                        ec.added.addElement(leaf);</span>
<span class="nc" id="L1913">                        ec.removed.addElement(first);</span>
                    }
                }
<span class="nc" id="L1916">                pos += len;</span>
                break;
            }
<span class="nc" id="L1919">        }</span>

        /**
         * Remove the elements from &lt;code&gt;elem&lt;/code&gt; in range
         * &lt;code&gt;rmOffs0&lt;/code&gt;, &lt;code&gt;rmOffs1&lt;/code&gt;. This uses
         * &lt;code&gt;canJoin&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; to handle joining
         * the endpoints of the insertion.
         *
         * @return true if elem will no longer have any elements.
         */
        boolean removeElements(Element elem, int rmOffs0, int rmOffs1) {
<span class="nc bnc" id="L1930" title="All 2 branches missed.">            if (! elem.isLeaf()) {</span>
                // update path for changes
<span class="nc" id="L1932">                int index0 = elem.getElementIndex(rmOffs0);</span>
<span class="nc" id="L1933">                int index1 = elem.getElementIndex(rmOffs1);</span>
<span class="nc" id="L1934">                push(elem, index0);</span>
<span class="nc" id="L1935">                ElemChanges ec = path.peek();</span>

                // if the range is contained by one element,
                // we just forward the request
<span class="nc bnc" id="L1939" title="All 2 branches missed.">                if (index0 == index1) {</span>
<span class="nc" id="L1940">                    Element child0 = elem.getElement(index0);</span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">                    if(rmOffs0 &lt;= child0.getStartOffset() &amp;&amp;</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">                       rmOffs1 &gt;= child0.getEndOffset()) {</span>
                        // Element totally removed.
<span class="nc" id="L1944">                        ec.removed.addElement(child0);</span>
                    }
<span class="nc bnc" id="L1946" title="All 2 branches missed.">                    else if(removeElements(child0, rmOffs0, rmOffs1)) {</span>
<span class="nc" id="L1947">                        ec.removed.addElement(child0);</span>
                    }
<span class="nc" id="L1949">                } else {</span>
                    // the removal range spans elements.  If we can join
                    // the two endpoints, do it.  Otherwise we remove the
                    // interior and forward to the endpoints.
<span class="nc" id="L1953">                    Element child0 = elem.getElement(index0);</span>
<span class="nc" id="L1954">                    Element child1 = elem.getElement(index1);</span>
<span class="nc bnc" id="L1955" title="All 2 branches missed.">                    boolean containsOffs1 = (rmOffs1 &lt; elem.getEndOffset());</span>
<span class="nc bnc" id="L1956" title="All 4 branches missed.">                    if (containsOffs1 &amp;&amp; canJoin(child0, child1)) {</span>
                        // remove and join
<span class="nc bnc" id="L1958" title="All 2 branches missed.">                        for (int i = index0; i &lt;= index1; i++) {</span>
<span class="nc" id="L1959">                            ec.removed.addElement(elem.getElement(i));</span>
                        }
<span class="nc" id="L1961">                        Element e = join(elem, child0, child1, rmOffs0, rmOffs1);</span>
<span class="nc" id="L1962">                        ec.added.addElement(e);</span>
<span class="nc" id="L1963">                    } else {</span>
                        // remove interior and forward
<span class="nc" id="L1965">                        int rmIndex0 = index0 + 1;</span>
<span class="nc" id="L1966">                        int rmIndex1 = index1 - 1;</span>
<span class="nc bnc" id="L1967" title="All 4 branches missed.">                        if (child0.getStartOffset() == rmOffs0 ||</span>
                            (index0 == 0 &amp;&amp;
<span class="nc bnc" id="L1969" title="All 2 branches missed.">                             child0.getStartOffset() &gt; rmOffs0 &amp;&amp;</span>
<span class="nc bnc" id="L1970" title="All 2 branches missed.">                             child0.getEndOffset() &lt;= rmOffs1)) {</span>
                            // start element completely consumed
<span class="nc" id="L1972">                            child0 = null;</span>
<span class="nc" id="L1973">                            rmIndex0 = index0;</span>
                        }
<span class="nc bnc" id="L1975" title="All 2 branches missed.">                        if (!containsOffs1) {</span>
<span class="nc" id="L1976">                            child1 = null;</span>
<span class="nc" id="L1977">                            rmIndex1++;</span>
                        }
<span class="nc bnc" id="L1979" title="All 2 branches missed.">                        else if (child1.getStartOffset() == rmOffs1) {</span>
                            // end element not touched
<span class="nc" id="L1981">                            child1 = null;</span>
                        }
<span class="nc bnc" id="L1983" title="All 2 branches missed.">                        if (rmIndex0 &lt;= rmIndex1) {</span>
<span class="nc" id="L1984">                            ec.index = rmIndex0;</span>
                        }
<span class="nc bnc" id="L1986" title="All 2 branches missed.">                        for (int i = rmIndex0; i &lt;= rmIndex1; i++) {</span>
<span class="nc" id="L1987">                            ec.removed.addElement(elem.getElement(i));</span>
                        }
<span class="nc bnc" id="L1989" title="All 2 branches missed.">                        if (child0 != null) {</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">                            if(removeElements(child0, rmOffs0, rmOffs1)) {</span>
<span class="nc" id="L1991">                                ec.removed.insertElementAt(child0, 0);</span>
<span class="nc" id="L1992">                                ec.index = index0;</span>
                            }
                        }
<span class="nc bnc" id="L1995" title="All 2 branches missed.">                        if (child1 != null) {</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">                            if(removeElements(child1, rmOffs0, rmOffs1)) {</span>
<span class="nc" id="L1997">                                ec.removed.addElement(child1);</span>
                            }
                        }
                    }
                }

                // publish changes
<span class="nc" id="L2004">                pop();</span>

                // Return true if we no longer have any children.
<span class="nc" id="L2007">                if(elem.getElementCount() == (ec.removed.size() -</span>
<span class="nc bnc" id="L2008" title="All 2 branches missed.">                                              ec.added.size())) {</span>
<span class="nc" id="L2009">                    return true;</span>
                }
            }
<span class="nc" id="L2012">            return false;</span>
        }

        /**
         * Can the two given elements be coelesced together
         * into one element?
         */
        boolean canJoin(Element e0, Element e1) {
<span class="nc bnc" id="L2020" title="All 4 branches missed.">            if ((e0 == null) || (e1 == null)) {</span>
<span class="nc" id="L2021">                return false;</span>
            }
            // Don't join a leaf to a branch.
<span class="nc" id="L2024">            boolean leaf0 = e0.isLeaf();</span>
<span class="nc" id="L2025">            boolean leaf1 = e1.isLeaf();</span>
<span class="nc bnc" id="L2026" title="All 2 branches missed.">            if(leaf0 != leaf1) {</span>
<span class="nc" id="L2027">                return false;</span>
            }
<span class="nc bnc" id="L2029" title="All 2 branches missed.">            if (leaf0) {</span>
                // Only join leaves if the attributes match, otherwise
                // style information will be lost.
<span class="nc" id="L2032">                return e0.getAttributes().isEqual(e1.getAttributes());</span>
            }
            // Only join non-leafs if the names are equal. This may result
            // in loss of style information, but this is typically acceptable
            // for non-leafs.
<span class="nc" id="L2037">            String name0 = e0.getName();</span>
<span class="nc" id="L2038">            String name1 = e1.getName();</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">            if (name0 != null) {</span>
<span class="nc" id="L2040">                return name0.equals(name1);</span>
            }
<span class="nc bnc" id="L2042" title="All 2 branches missed.">            if (name1 != null) {</span>
<span class="nc" id="L2043">                return name1.equals(name0);</span>
            }
            // Both names null, treat as equal.
<span class="nc" id="L2046">            return true;</span>
        }

        /**
         * Joins the two elements carving out a hole for the
         * given removed range.
         */
        Element join(Element p, Element left, Element right, int rmOffs0, int rmOffs1) {
<span class="nc bnc" id="L2054" title="All 4 branches missed.">            if (left.isLeaf() &amp;&amp; right.isLeaf()) {</span>
<span class="nc" id="L2055">                return createLeafElement(p, left.getAttributes(), left.getStartOffset(),</span>
<span class="nc" id="L2056">                                         right.getEndOffset());</span>
<span class="nc bnc" id="L2057" title="All 4 branches missed.">            } else if ((!left.isLeaf()) &amp;&amp; (!right.isLeaf())) {</span>
                // join two branch elements.  This copies the children before
                // the removal range on the left element, and after the removal
                // range on the right element.  The two elements on the edge
                // are joined if possible and needed.
<span class="nc" id="L2062">                Element to = createBranchElement(p, left.getAttributes());</span>
<span class="nc" id="L2063">                int ljIndex = left.getElementIndex(rmOffs0);</span>
<span class="nc" id="L2064">                int rjIndex = right.getElementIndex(rmOffs1);</span>
<span class="nc" id="L2065">                Element lj = left.getElement(ljIndex);</span>
<span class="nc bnc" id="L2066" title="All 2 branches missed.">                if (lj.getStartOffset() &gt;= rmOffs0) {</span>
<span class="nc" id="L2067">                    lj = null;</span>
                }
<span class="nc" id="L2069">                Element rj = right.getElement(rjIndex);</span>
<span class="nc bnc" id="L2070" title="All 2 branches missed.">                if (rj.getStartOffset() == rmOffs1) {</span>
<span class="nc" id="L2071">                    rj = null;</span>
                }
<span class="nc" id="L2073">                Vector&lt;Element&gt; children = new Vector&lt;Element&gt;();</span>

                // transfer the left
<span class="nc bnc" id="L2076" title="All 2 branches missed.">                for (int i = 0; i &lt; ljIndex; i++) {</span>
<span class="nc" id="L2077">                    children.addElement(clone(to, left.getElement(i)));</span>
                }

                // transfer the join/middle
<span class="nc bnc" id="L2081" title="All 2 branches missed.">                if (canJoin(lj, rj)) {</span>
<span class="nc" id="L2082">                    Element e = join(to, lj, rj, rmOffs0, rmOffs1);</span>
<span class="nc" id="L2083">                    children.addElement(e);</span>
<span class="nc" id="L2084">                } else {</span>
<span class="nc bnc" id="L2085" title="All 2 branches missed.">                    if (lj != null) {</span>
<span class="nc" id="L2086">                        children.addElement(cloneAsNecessary(to, lj, rmOffs0, rmOffs1));</span>
                    }
<span class="nc bnc" id="L2088" title="All 2 branches missed.">                    if (rj != null) {</span>
<span class="nc" id="L2089">                        children.addElement(cloneAsNecessary(to, rj, rmOffs0, rmOffs1));</span>
                    }
                }

                // transfer the right
<span class="nc" id="L2094">                int n = right.getElementCount();</span>
<span class="nc bnc" id="L2095" title="All 4 branches missed.">                for (int i = (rj == null) ? rjIndex : rjIndex + 1; i &lt; n; i++) {</span>
<span class="nc" id="L2096">                    children.addElement(clone(to, right.getElement(i)));</span>
                }

                // install the children
<span class="nc" id="L2100">                Element[] c = new Element[children.size()];</span>
<span class="nc" id="L2101">                children.copyInto(c);</span>
<span class="nc" id="L2102">                ((BranchElement)to).replace(0, 0, c);</span>
<span class="nc" id="L2103">                return to;</span>
            } else {
<span class="nc" id="L2105">                throw new StateInvariantError(</span>
                    &quot;No support to join leaf element with non-leaf element&quot;);
            }
        }

        /**
         * Creates a copy of this element, with a different
         * parent.
         *
         * @param parent the parent element
         * @param clonee the element to be cloned
         * @return the copy
         */
        public Element clone(Element parent, Element clonee) {
<span class="nc bnc" id="L2119" title="All 2 branches missed.">            if (clonee.isLeaf()) {</span>
<span class="nc" id="L2120">                return createLeafElement(parent, clonee.getAttributes(),</span>
<span class="nc" id="L2121">                                         clonee.getStartOffset(),</span>
<span class="nc" id="L2122">                                         clonee.getEndOffset());</span>
            }
<span class="nc" id="L2124">            Element e = createBranchElement(parent, clonee.getAttributes());</span>
<span class="nc" id="L2125">            int n = clonee.getElementCount();</span>
<span class="nc" id="L2126">            Element[] children = new Element[n];</span>
<span class="nc bnc" id="L2127" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L2128">                children[i] = clone(e, clonee.getElement(i));</span>
            }
<span class="nc" id="L2130">            ((BranchElement)e).replace(0, 0, children);</span>
<span class="nc" id="L2131">            return e;</span>
        }

        /**
         * Creates a copy of this element, with a different
         * parent. Children of this element included in the
         * removal range will be discarded.
         */
        Element cloneAsNecessary(Element parent, Element clonee, int rmOffs0, int rmOffs1) {
<span class="nc bnc" id="L2140" title="All 2 branches missed.">            if (clonee.isLeaf()) {</span>
<span class="nc" id="L2141">                return createLeafElement(parent, clonee.getAttributes(),</span>
<span class="nc" id="L2142">                                         clonee.getStartOffset(),</span>
<span class="nc" id="L2143">                                         clonee.getEndOffset());</span>
            }
<span class="nc" id="L2145">            Element e = createBranchElement(parent, clonee.getAttributes());</span>
<span class="nc" id="L2146">            int n = clonee.getElementCount();</span>
<span class="nc" id="L2147">            ArrayList&lt;Element&gt; childrenList = new ArrayList&lt;Element&gt;(n);</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L2149">                Element elem = clonee.getElement(i);</span>
<span class="nc bnc" id="L2150" title="All 4 branches missed.">                if (elem.getStartOffset() &lt; rmOffs0 || elem.getEndOffset() &gt; rmOffs1) {</span>
<span class="nc" id="L2151">                    childrenList.add(cloneAsNecessary(e, elem, rmOffs0, rmOffs1));</span>
                }
            }
<span class="nc" id="L2154">            Element[] children = new Element[childrenList.size()];</span>
<span class="nc" id="L2155">            children = childrenList.toArray(children);</span>
<span class="nc" id="L2156">            ((BranchElement)e).replace(0, 0, children);</span>
<span class="nc" id="L2157">            return e;</span>
        }

        /**
         * Determines if a fracture needs to be performed. A fracture
         * can be thought of as moving the right part of a tree to a
         * new location, where the right part is determined by what has
         * been inserted. &lt;code&gt;depth&lt;/code&gt; is used to indicate a
         * JoinToFracture is needed to an element at a depth
         * of &lt;code&gt;depth&lt;/code&gt;. Where the root is 0, 1 is the children
         * of the root...
         * &lt;p&gt;This will invoke &lt;code&gt;fractureFrom&lt;/code&gt; if it is determined
         * a fracture needs to happen.
         */
        void fracture(int depth) {
<span class="nc" id="L2172">            int cLength = insertPath.length;</span>
<span class="nc" id="L2173">            int lastIndex = -1;</span>
<span class="nc" id="L2174">            boolean needRecreate = recreateLeafs;</span>
<span class="nc" id="L2175">            ElemChanges lastChange = insertPath[cLength - 1];</span>
            // Use childAltered to determine when a child has been altered,
            // that is the point of insertion is less than the element count.
<span class="nc" id="L2178">            boolean childAltered = ((lastChange.index + 1) &lt;</span>
<span class="nc bnc" id="L2179" title="All 2 branches missed.">                                    lastChange.parent.getElementCount());</span>
<span class="nc bnc" id="L2180" title="All 2 branches missed.">            int deepestAlteredIndex = (needRecreate) ? cLength : -1;</span>
<span class="nc" id="L2181">            int lastAlteredIndex = cLength - 1;</span>

<span class="nc" id="L2183">            createdFracture = true;</span>
            // Determine where to start recreating from.
            // Start at - 2, as first one is indicated by recreateLeafs and
            // childAltered.
<span class="nc bnc" id="L2187" title="All 2 branches missed.">            for(int counter = cLength - 2; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L2188">                ElemChanges change = insertPath[counter];</span>
<span class="nc bnc" id="L2189" title="All 4 branches missed.">                if(change.added.size() &gt; 0 || counter == depth) {</span>
<span class="nc" id="L2190">                    lastIndex = counter;</span>
<span class="nc bnc" id="L2191" title="All 4 branches missed.">                    if(!needRecreate &amp;&amp; childAltered) {</span>
<span class="nc" id="L2192">                        needRecreate = true;</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">                        if(deepestAlteredIndex == -1)</span>
<span class="nc" id="L2194">                            deepestAlteredIndex = lastAlteredIndex + 1;</span>
                    }
                }
<span class="nc bnc" id="L2197" title="All 2 branches missed.">                if(!childAltered &amp;&amp; change.index &lt;</span>
<span class="nc bnc" id="L2198" title="All 2 branches missed.">                   change.parent.getElementCount()) {</span>
<span class="nc" id="L2199">                    childAltered = true;</span>
<span class="nc" id="L2200">                    lastAlteredIndex = counter;</span>
                }
            }
<span class="nc bnc" id="L2203" title="All 2 branches missed.">            if(needRecreate) {</span>
                // Recreate all children to right of parent starting
                // at lastIndex.
<span class="nc bnc" id="L2206" title="All 2 branches missed.">                if(lastIndex == -1)</span>
<span class="nc" id="L2207">                    lastIndex = cLength - 1;</span>
<span class="nc" id="L2208">                fractureFrom(insertPath, lastIndex, deepestAlteredIndex);</span>
            }
<span class="nc" id="L2210">        }</span>

        /**
         * Recreates the elements to the right of the insertion point.
         * This starts at &lt;code&gt;startIndex&lt;/code&gt; in &lt;code&gt;changed&lt;/code&gt;,
         * and calls duplicate to duplicate existing elements.
         * This will also duplicate the elements along the insertion
         * point, until a depth of &lt;code&gt;endFractureIndex&lt;/code&gt; is
         * reached, at which point only the elements to the right of
         * the insertion point are duplicated.
         */
        void fractureFrom(ElemChanges[] changed, int startIndex,
                          int endFractureIndex) {
            // Recreate the element representing the inserted index.
<span class="nc" id="L2224">            ElemChanges change = changed[startIndex];</span>
            Element child;
            Element newChild;
<span class="nc" id="L2227">            int changeLength = changed.length;</span>

<span class="nc bnc" id="L2229" title="All 2 branches missed.">            if((startIndex + 1) == changeLength)</span>
<span class="nc" id="L2230">                child = change.parent.getElement(change.index);</span>
            else
<span class="nc" id="L2232">                child = change.parent.getElement(change.index - 1);</span>
<span class="nc bnc" id="L2233" title="All 2 branches missed.">            if(child.isLeaf()) {</span>
<span class="nc" id="L2234">                newChild = createLeafElement(change.parent,</span>
<span class="nc" id="L2235">                               child.getAttributes(), Math.max(endOffset,</span>
<span class="nc" id="L2236">                               child.getStartOffset()), child.getEndOffset());</span>
            }
            else {
<span class="nc" id="L2239">                newChild = createBranchElement(change.parent,</span>
<span class="nc" id="L2240">                                               child.getAttributes());</span>
            }
<span class="nc" id="L2242">            fracturedParent = change.parent;</span>
<span class="nc" id="L2243">            fracturedChild = newChild;</span>

            // Recreate all the elements to the right of the
            // insertion point.
<span class="nc" id="L2247">            Element parent = newChild;</span>

<span class="nc bnc" id="L2249" title="All 2 branches missed.">            while(++startIndex &lt; endFractureIndex) {</span>
<span class="nc bnc" id="L2250" title="All 2 branches missed.">                boolean isEnd = ((startIndex + 1) == endFractureIndex);</span>
<span class="nc bnc" id="L2251" title="All 2 branches missed.">                boolean isEndLeaf = ((startIndex + 1) == changeLength);</span>

                // Create the newChild, a duplicate of the elment at
                // index. This isn't done if isEnd and offsetLastIndex are true
                // indicating a join previous was done.
<span class="nc" id="L2256">                change = changed[startIndex];</span>

                // Determine the child to duplicate, won't have to duplicate
                // if at end of fracture, or offseting index.
<span class="nc bnc" id="L2260" title="All 2 branches missed.">                if(isEnd) {</span>
<span class="nc bnc" id="L2261" title="All 4 branches missed.">                    if(offsetLastIndex || !isEndLeaf)</span>
<span class="nc" id="L2262">                        child = null;</span>
                    else
<span class="nc" id="L2264">                        child = change.parent.getElement(change.index);</span>
                }
                else {
<span class="nc" id="L2267">                    child = change.parent.getElement(change.index - 1);</span>
                }
                // Duplicate it.
<span class="nc bnc" id="L2270" title="All 2 branches missed.">                if(child != null) {</span>
<span class="nc bnc" id="L2271" title="All 2 branches missed.">                    if(child.isLeaf()) {</span>
<span class="nc" id="L2272">                        newChild = createLeafElement(parent,</span>
<span class="nc" id="L2273">                               child.getAttributes(), Math.max(endOffset,</span>
<span class="nc" id="L2274">                               child.getStartOffset()), child.getEndOffset());</span>
                    }
                    else {
<span class="nc" id="L2277">                        newChild = createBranchElement(parent,</span>
<span class="nc" id="L2278">                                                   child.getAttributes());</span>
                    }
                }
                else
<span class="nc" id="L2282">                    newChild = null;</span>

                // Recreate the remaining children (there may be none).
<span class="nc" id="L2285">                int kidsToMove = change.parent.getElementCount() -</span>
                                 change.index;
                Element[] kids;
                int moveStartIndex;
<span class="nc" id="L2289">                int kidStartIndex = 1;</span>

<span class="nc bnc" id="L2291" title="All 2 branches missed.">                if(newChild == null) {</span>
                    // Last part of fracture.
<span class="nc bnc" id="L2293" title="All 2 branches missed.">                    if(isEndLeaf) {</span>
<span class="nc" id="L2294">                        kidsToMove--;</span>
<span class="nc" id="L2295">                        moveStartIndex = change.index + 1;</span>
                    }
                    else {
<span class="nc" id="L2298">                        moveStartIndex = change.index;</span>
                    }
<span class="nc" id="L2300">                    kidStartIndex = 0;</span>
<span class="nc" id="L2301">                    kids = new Element[kidsToMove];</span>
                }
                else {
<span class="nc bnc" id="L2304" title="All 2 branches missed.">                    if(!isEnd) {</span>
                        // Branch.
<span class="nc" id="L2306">                        kidsToMove++;</span>
<span class="nc" id="L2307">                        moveStartIndex = change.index;</span>
                    }
                    else {
                        // Last leaf, need to recreate part of it.
<span class="nc" id="L2311">                        moveStartIndex = change.index + 1;</span>
                    }
<span class="nc" id="L2313">                    kids = new Element[kidsToMove];</span>
<span class="nc" id="L2314">                    kids[0] = newChild;</span>
                }

<span class="nc bnc" id="L2317" title="All 2 branches missed.">                for(int counter = kidStartIndex; counter &lt; kidsToMove;</span>
<span class="nc" id="L2318">                    counter++) {</span>
<span class="nc" id="L2319">                    Element toMove =change.parent.getElement(moveStartIndex++);</span>
<span class="nc" id="L2320">                    kids[counter] = recreateFracturedElement(parent, toMove);</span>
<span class="nc" id="L2321">                    change.removed.addElement(toMove);</span>
                }
<span class="nc" id="L2323">                ((BranchElement)parent).replace(0, 0, kids);</span>
<span class="nc" id="L2324">                parent = newChild;</span>
<span class="nc" id="L2325">            }</span>
<span class="nc" id="L2326">        }</span>

        /**
         * Recreates &lt;code&gt;toDuplicate&lt;/code&gt;. This is called when an
         * element needs to be created as the result of an insertion. This
         * will recurse and create all the children. This is similar to
         * &lt;code&gt;clone&lt;/code&gt;, but deteremines the offsets differently.
         */
        Element recreateFracturedElement(Element parent, Element toDuplicate) {
<span class="nc bnc" id="L2335" title="All 2 branches missed.">            if(toDuplicate.isLeaf()) {</span>
<span class="nc" id="L2336">                return createLeafElement(parent, toDuplicate.getAttributes(),</span>
<span class="nc" id="L2337">                                         Math.max(toDuplicate.getStartOffset(),</span>
                                                  endOffset),
<span class="nc" id="L2339">                                         toDuplicate.getEndOffset());</span>
            }
            // Not a leaf
<span class="nc" id="L2342">            Element newParent = createBranchElement(parent, toDuplicate.</span>
<span class="nc" id="L2343">                                                    getAttributes());</span>
<span class="nc" id="L2344">            int childCount = toDuplicate.getElementCount();</span>
<span class="nc" id="L2345">            Element[] newKids = new Element[childCount];</span>
<span class="nc bnc" id="L2346" title="All 2 branches missed.">            for(int counter = 0; counter &lt; childCount; counter++) {</span>
<span class="nc" id="L2347">                newKids[counter] = recreateFracturedElement(newParent,</span>
<span class="nc" id="L2348">                                             toDuplicate.getElement(counter));</span>
            }
<span class="nc" id="L2350">            ((BranchElement)newParent).replace(0, 0, newKids);</span>
<span class="nc" id="L2351">            return newParent;</span>
        }

        /**
         * Splits the bottommost leaf in &lt;code&gt;path&lt;/code&gt;.
         * This is called from insert when the first element is NOT content.
         */
        void fractureDeepestLeaf(ElementSpec[] specs) {
            // Split the bottommost leaf. It will be recreated elsewhere.
<span class="nc" id="L2360">            ElemChanges ec = path.peek();</span>
<span class="nc" id="L2361">            Element child = ec.parent.getElement(ec.index);</span>
            // Inserts at offset 0 do not need to recreate child (it would
            // have a length of 0!).
<span class="nc bnc" id="L2364" title="All 2 branches missed.">            if (offset != 0) {</span>
<span class="nc" id="L2365">                Element newChild = createLeafElement(ec.parent,</span>
<span class="nc" id="L2366">                                                 child.getAttributes(),</span>
<span class="nc" id="L2367">                                                 child.getStartOffset(),</span>
                                                 offset);

<span class="nc" id="L2370">                ec.added.addElement(newChild);</span>
            }
<span class="nc" id="L2372">            ec.removed.addElement(child);</span>
<span class="nc bnc" id="L2373" title="All 2 branches missed.">            if(child.getEndOffset() != endOffset)</span>
<span class="nc" id="L2374">                recreateLeafs = true;</span>
            else
<span class="nc" id="L2376">                offsetLastIndex = true;</span>
<span class="nc" id="L2377">        }</span>

        /**
         * Inserts the first content. This needs to be separate to handle
         * joining.
         */
        void insertFirstContent(ElementSpec[] specs) {
<span class="nc" id="L2384">            ElementSpec firstSpec = specs[0];</span>
<span class="nc" id="L2385">            ElemChanges ec = path.peek();</span>
<span class="nc" id="L2386">            Element child = ec.parent.getElement(ec.index);</span>
<span class="nc" id="L2387">            int firstEndOffset = offset + firstSpec.getLength();</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">            boolean isOnlyContent = (specs.length == 1);</span>

<span class="nc bnc" id="L2390" title="All 3 branches missed.">            switch(firstSpec.getDirection()) {</span>
            case ElementSpec.JoinPreviousDirection:
<span class="nc bnc" id="L2392" title="All 4 branches missed.">                if(child.getEndOffset() != firstEndOffset &amp;&amp;</span>
                    !isOnlyContent) {
                    // Create the left split part containing new content.
<span class="nc" id="L2395">                    Element newE = createLeafElement(ec.parent,</span>
<span class="nc" id="L2396">                            child.getAttributes(), child.getStartOffset(),</span>
                            firstEndOffset);
<span class="nc" id="L2398">                    ec.added.addElement(newE);</span>
<span class="nc" id="L2399">                    ec.removed.addElement(child);</span>
                    // Remainder will be created later.
<span class="nc bnc" id="L2401" title="All 2 branches missed.">                    if(child.getEndOffset() != endOffset)</span>
<span class="nc" id="L2402">                        recreateLeafs = true;</span>
                    else
<span class="nc" id="L2404">                        offsetLastIndex = true;</span>
<span class="nc" id="L2405">                }</span>
                else {
<span class="nc" id="L2407">                    offsetLastIndex = true;</span>
<span class="nc" id="L2408">                    offsetLastIndexOnReplace = true;</span>
                }
                // else Inserted at end, and is total length.
                // Update index incase something added/removed.
<span class="nc" id="L2412">                break;</span>
            case ElementSpec.JoinNextDirection:
<span class="nc bnc" id="L2414" title="All 2 branches missed.">                if(offset != 0) {</span>
                    // Recreate the first element, its offset will have
                    // changed.
<span class="nc" id="L2417">                    Element newE = createLeafElement(ec.parent,</span>
<span class="nc" id="L2418">                            child.getAttributes(), child.getStartOffset(),</span>
                            offset);
<span class="nc" id="L2420">                    ec.added.addElement(newE);</span>
                    // Recreate the second, merge part. We do no checking
                    // to see if JoinNextDirection is valid here!
<span class="nc" id="L2423">                    Element nextChild = ec.parent.getElement(ec.index + 1);</span>
<span class="nc bnc" id="L2424" title="All 2 branches missed.">                    if(isOnlyContent)</span>
<span class="nc" id="L2425">                        newE = createLeafElement(ec.parent, nextChild.</span>
<span class="nc" id="L2426">                            getAttributes(), offset, nextChild.getEndOffset());</span>
                    else
<span class="nc" id="L2428">                        newE = createLeafElement(ec.parent, nextChild.</span>
<span class="nc" id="L2429">                            getAttributes(), offset, firstEndOffset);</span>
<span class="nc" id="L2430">                    ec.added.addElement(newE);</span>
<span class="nc" id="L2431">                    ec.removed.addElement(child);</span>
<span class="nc" id="L2432">                    ec.removed.addElement(nextChild);</span>
<span class="nc" id="L2433">                }</span>
                // else nothin to do.
                // PENDING: if !isOnlyContent could raise here!
                break;
            default:
                // Inserted into middle, need to recreate split left
                // new content, and split right.
<span class="nc bnc" id="L2440" title="All 2 branches missed.">                if(child.getStartOffset() != offset) {</span>
<span class="nc" id="L2441">                    Element newE = createLeafElement(ec.parent,</span>
<span class="nc" id="L2442">                            child.getAttributes(), child.getStartOffset(),</span>
                            offset);
<span class="nc" id="L2444">                    ec.added.addElement(newE);</span>
                }
<span class="nc" id="L2446">                ec.removed.addElement(child);</span>
                // new content
<span class="nc" id="L2448">                Element newE = createLeafElement(ec.parent,</span>
<span class="nc" id="L2449">                                                 firstSpec.getAttributes(),</span>
                                                 offset, firstEndOffset);
<span class="nc" id="L2451">                ec.added.addElement(newE);</span>
<span class="nc bnc" id="L2452" title="All 2 branches missed.">                if(child.getEndOffset() != endOffset) {</span>
                    // Signals need to recreate right split later.
<span class="nc" id="L2454">                    recreateLeafs = true;</span>
                }
                else {
<span class="nc" id="L2457">                    offsetLastIndex = true;</span>
                }
                break;
            }
<span class="nc" id="L2461">        }</span>

        Element root;
        transient int pos;          // current position
        transient int offset;
        transient int length;
        transient int endOffset;
        transient Vector&lt;ElemChanges&gt; changes;
        transient Stack&lt;ElemChanges&gt; path;
        transient boolean insertOp;

        transient boolean recreateLeafs; // For insert.

        /** For insert, path to inserted elements. */
        transient ElemChanges[] insertPath;
        /** Only for insert, set to true when the fracture has been created. */
        transient boolean createdFracture;
        /** Parent that contains the fractured child. */
        transient Element fracturedParent;
        /** Fractured child. */
        transient Element fracturedChild;
        /** Used to indicate when fracturing that the last leaf should be
         * skipped. */
        transient boolean offsetLastIndex;
        /** Used to indicate that the parent of the deepest leaf should
         * offset the index by 1 when adding/removing elements in an
         * insert. */
        transient boolean offsetLastIndexOnReplace;

        /*
         * Internal record used to hold element change specifications
         */
        class ElemChanges {

<span class="nc" id="L2495">            ElemChanges(Element parent, int index, boolean isFracture) {</span>
<span class="nc" id="L2496">                this.parent = parent;</span>
<span class="nc" id="L2497">                this.index = index;</span>
<span class="nc" id="L2498">                this.isFracture = isFracture;</span>
<span class="nc" id="L2499">                added = new Vector&lt;Element&gt;();</span>
<span class="nc" id="L2500">                removed = new Vector&lt;Element&gt;();</span>
<span class="nc" id="L2501">            }</span>

            public String toString() {
<span class="nc" id="L2504">                return &quot;added: &quot; + added + &quot;\nremoved: &quot; + removed + &quot;\n&quot;;</span>
            }

            Element parent;
            int index;
            Vector&lt;Element&gt; added;
            Vector&lt;Element&gt; removed;
            boolean isFracture;
        }

    }

    /**
     * An UndoableEdit used to remember AttributeSet changes to an
     * Element.
     */
    public static class AttributeUndoableEdit extends AbstractUndoableEdit {
        public AttributeUndoableEdit(Element element, AttributeSet newAttributes,
                              boolean isReplacing) {
<span class="nc" id="L2523">            super();</span>
<span class="nc" id="L2524">            this.element = element;</span>
<span class="nc" id="L2525">            this.newAttributes = newAttributes;</span>
<span class="nc" id="L2526">            this.isReplacing = isReplacing;</span>
            // If not replacing, it may be more efficient to only copy the
            // changed values...
<span class="nc" id="L2529">            copy = element.getAttributes().copyAttributes();</span>
<span class="nc" id="L2530">        }</span>

        /**
         * Redoes a change.
         *
         * @exception CannotRedoException if the change cannot be redone
         */
        public void redo() throws CannotRedoException {
<span class="nc" id="L2538">            super.redo();</span>
<span class="nc" id="L2539">            MutableAttributeSet as = (MutableAttributeSet)element</span>
<span class="nc" id="L2540">                                     .getAttributes();</span>
<span class="nc bnc" id="L2541" title="All 2 branches missed.">            if(isReplacing)</span>
<span class="nc" id="L2542">                as.removeAttributes(as);</span>
<span class="nc" id="L2543">            as.addAttributes(newAttributes);</span>
<span class="nc" id="L2544">        }</span>

        /**
         * Undoes a change.
         *
         * @exception CannotUndoException if the change cannot be undone
         */
        public void undo() throws CannotUndoException {
<span class="nc" id="L2552">            super.undo();</span>
<span class="nc" id="L2553">            MutableAttributeSet as = (MutableAttributeSet)element.getAttributes();</span>
<span class="nc" id="L2554">            as.removeAttributes(as);</span>
<span class="nc" id="L2555">            as.addAttributes(copy);</span>
<span class="nc" id="L2556">        }</span>

        // AttributeSet containing additional entries, must be non-mutable!
        protected AttributeSet newAttributes;
        // Copy of the AttributeSet the Element contained.
        protected AttributeSet copy;
        // true if all the attributes in the element were removed first.
        protected boolean isReplacing;
        // Efected Element.
        protected Element element;
    }

    /**
     * UndoableEdit for changing the resolve parent of an Element.
     */
    static class StyleChangeUndoableEdit extends AbstractUndoableEdit {
        public StyleChangeUndoableEdit(AbstractElement element,
                                       Style newStyle) {
<span class="nc" id="L2574">            super();</span>
<span class="nc" id="L2575">            this.element = element;</span>
<span class="nc" id="L2576">            this.newStyle = newStyle;</span>
<span class="nc" id="L2577">            oldStyle = element.getResolveParent();</span>
<span class="nc" id="L2578">        }</span>

        /**
         * Redoes a change.
         *
         * @exception CannotRedoException if the change cannot be redone
         */
        public void redo() throws CannotRedoException {
<span class="nc" id="L2586">            super.redo();</span>
<span class="nc" id="L2587">            element.setResolveParent(newStyle);</span>
<span class="nc" id="L2588">        }</span>

        /**
         * Undoes a change.
         *
         * @exception CannotUndoException if the change cannot be undone
         */
        public void undo() throws CannotUndoException {
<span class="nc" id="L2596">            super.undo();</span>
<span class="nc" id="L2597">            element.setResolveParent(oldStyle);</span>
<span class="nc" id="L2598">        }</span>

        /** Element to change resolve parent of. */
        protected AbstractElement element;
        /** New style. */
        protected Style newStyle;
        /** Old style, before setting newStyle. */
        protected AttributeSet oldStyle;
    }

    /**
     * Base class for style change handlers with support for stale objects detection.
     */
    abstract static class AbstractChangeHandler implements ChangeListener {

        /* This has an implicit reference to the handler object.  */
        private class DocReference extends WeakReference&lt;DefaultStyledDocument&gt; {

<span class="nc" id="L2616">            DocReference(DefaultStyledDocument d, ReferenceQueue&lt;DefaultStyledDocument&gt; q) {</span>
<span class="nc" id="L2617">                super(d, q);</span>
<span class="nc" id="L2618">            }</span>

            /**
             * Return a reference to the style change handler object.
             */
            ChangeListener getListener() {
<span class="nc" id="L2624">                return AbstractChangeHandler.this;</span>
            }
        }

        /** Class-specific reference queues.  */
<span class="nc" id="L2629">        private final static Map&lt;Class, ReferenceQueue&lt;DefaultStyledDocument&gt;&gt; queueMap</span>
                = new HashMap&lt;Class, ReferenceQueue&lt;DefaultStyledDocument&gt;&gt;();

        /** A weak reference to the document object.  */
        private DocReference doc;

<span class="nc" id="L2635">        AbstractChangeHandler(DefaultStyledDocument d) {</span>
<span class="nc" id="L2636">            Class c = getClass();</span>
            ReferenceQueue&lt;DefaultStyledDocument&gt; q;
<span class="nc" id="L2638">            synchronized (queueMap) {</span>
<span class="nc" id="L2639">                q = queueMap.get(c);</span>
<span class="nc bnc" id="L2640" title="All 2 branches missed.">                if (q == null) {</span>
<span class="nc" id="L2641">                    q = new ReferenceQueue&lt;DefaultStyledDocument&gt;();</span>
<span class="nc" id="L2642">                    queueMap.put(c, q);</span>
                }
<span class="nc" id="L2644">            }</span>
<span class="nc" id="L2645">            doc = new DocReference(d, q);</span>
<span class="nc" id="L2646">        }</span>

        /**
         * Return a list of stale change listeners.
         *
         * A change listener becomes &quot;stale&quot; when its document is cleaned by GC.
         */
        static List&lt;ChangeListener&gt; getStaleListeners(ChangeListener l) {
<span class="nc" id="L2654">            List&lt;ChangeListener&gt; staleListeners = new ArrayList&lt;ChangeListener&gt;();</span>
<span class="nc" id="L2655">            ReferenceQueue&lt;DefaultStyledDocument&gt; q = queueMap.get(l.getClass());</span>

<span class="nc bnc" id="L2657" title="All 2 branches missed.">            if (q != null) {</span>
                DocReference r;
<span class="nc" id="L2659">                synchronized (q) {</span>
<span class="nc bnc" id="L2660" title="All 2 branches missed.">                    while ((r = (DocReference) q.poll()) != null) {</span>
<span class="nc" id="L2661">                        staleListeners.add(r.getListener());</span>
                    }
<span class="nc" id="L2663">                }</span>
            }

<span class="nc" id="L2666">            return staleListeners;</span>
        }

        /**
         * The ChangeListener wrapper which guards against dead documents.
         */
        public void stateChanged(ChangeEvent e) {
<span class="nc" id="L2673">            DefaultStyledDocument d = doc.get();</span>
<span class="nc bnc" id="L2674" title="All 2 branches missed.">            if (d != null) {</span>
<span class="nc" id="L2675">                fireStateChanged(d, e);</span>
            }
<span class="nc" id="L2677">        }</span>

        /** Run the actual class-specific stateChanged() method.  */
        abstract void fireStateChanged(DefaultStyledDocument d, ChangeEvent e);
    }

    /**
     * Added to all the Styles. When instances of this receive a
     * stateChanged method, styleChanged is invoked.
     */
    static class StyleChangeHandler extends AbstractChangeHandler {

        StyleChangeHandler(DefaultStyledDocument d) {
<span class="nc" id="L2690">            super(d);</span>
<span class="nc" id="L2691">        }</span>

        void fireStateChanged(DefaultStyledDocument d, ChangeEvent e) {
<span class="nc" id="L2694">            Object source = e.getSource();</span>
<span class="nc bnc" id="L2695" title="All 2 branches missed.">            if (source instanceof Style) {</span>
<span class="nc" id="L2696">                d.styleChanged((Style) source);</span>
            } else {
<span class="nc" id="L2698">                d.styleChanged(null);</span>
            }
<span class="nc" id="L2700">        }</span>
    }


    /**
     * Added to the StyleContext. When the StyleContext changes, this invokes
     * &lt;code&gt;updateStylesListeningTo&lt;/code&gt;.
     */
    static class StyleContextChangeHandler extends AbstractChangeHandler {

        StyleContextChangeHandler(DefaultStyledDocument d) {
<span class="nc" id="L2711">            super(d);</span>
<span class="nc" id="L2712">        }</span>

        void fireStateChanged(DefaultStyledDocument d, ChangeEvent e) {
<span class="nc" id="L2715">            d.updateStylesListeningTo();</span>
<span class="nc" id="L2716">        }</span>
    }


    /**
     * When run this creates a change event for the complete document
     * and fires it.
     */
<span class="nc" id="L2724">    class ChangeUpdateRunnable implements Runnable {</span>
<span class="nc" id="L2725">        boolean isPending = false;</span>

        public void run() {
<span class="nc" id="L2728">            synchronized(this) {</span>
<span class="nc" id="L2729">                isPending = false;</span>
<span class="nc" id="L2730">            }</span>

            try {
<span class="nc" id="L2733">                writeLock();</span>
<span class="nc" id="L2734">                DefaultDocumentEvent dde = new DefaultDocumentEvent(0,</span>
<span class="nc" id="L2735">                                              getLength(),</span>
                                              DocumentEvent.EventType.CHANGE);
<span class="nc" id="L2737">                dde.end();</span>
<span class="nc" id="L2738">                fireChangedUpdate(dde);</span>
            } finally {
<span class="nc" id="L2740">                writeUnlock();</span>
<span class="nc" id="L2741">            }</span>
<span class="nc" id="L2742">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>