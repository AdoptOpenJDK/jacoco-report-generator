<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AbstractDocument.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">AbstractDocument.java</span></div><h1>AbstractDocument.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.util.*;
import java.io.*;
import java.awt.font.TextAttribute;
import java.text.Bidi;

import javax.swing.UIManager;
import javax.swing.undo.*;
import javax.swing.event.*;
import javax.swing.tree.TreeNode;

import sun.font.BidiUtils;
import sun.swing.SwingUtilities2;

/**
 * An implementation of the document interface to serve as a
 * basis for implementing various kinds of documents.  At this
 * level there is very little policy, so there is a corresponding
 * increase in difficulty of use.
 * &lt;p&gt;
 * This class implements a locking mechanism for the document.  It
 * allows multiple readers or one writer, and writers must wait until
 * all observers of the document have been notified of a previous
 * change before beginning another mutation to the document.  The
 * read lock is acquired and released using the &lt;code&gt;render&lt;/code&gt;
 * method.  A write lock is acquired by the methods that mutate the
 * document, and are held for the duration of the method call.
 * Notification is done on the thread that produced the mutation,
 * and the thread has full read access to the document for the
 * duration of the notification, but other readers are kept out
 * until the notification has finished.  The notification is a
 * beans event notification which does not allow any further
 * mutations until all listeners have been notified.
 * &lt;p&gt;
 * Any models subclassed from this class and used in conjunction
 * with a text component that has a look and feel implementation
 * that is derived from BasicTextUI may be safely updated
 * asynchronously, because all access to the View hierarchy
 * is serialized by BasicTextUI if the document is of type
 * &lt;code&gt;AbstractDocument&lt;/code&gt;.  The locking assumes that an
 * independent thread will access the View hierarchy only from
 * the DocumentListener methods, and that there will be only
 * one event thread active at a time.
 * &lt;p&gt;
 * If concurrency support is desired, there are the following
 * additional implications.  The code path for any DocumentListener
 * implementation and any UndoListener implementation must be threadsafe,
 * and not access the component lock if trying to be safe from deadlocks.
 * The &lt;code&gt;repaint&lt;/code&gt; and &lt;code&gt;revalidate&lt;/code&gt; methods
 * on JComponent are safe.
 * &lt;p&gt;
 * AbstractDocument models an implied break at the end of the document.
 * Among other things this allows you to position the caret after the last
 * character. As a result of this, &lt;code&gt;getLength&lt;/code&gt; returns one less
 * than the length of the Content. If you create your own Content, be
 * sure and initialize it to have an additional character. Refer to
 * StringContent and GapContent for examples of this. Another implication
 * of this is that Elements that model the implied end character will have
 * an endOffset == (getLength() + 1). For example, in DefaultStyledDocument
 * &lt;code&gt;getParagraphElement(getLength()).getEndOffset() == getLength() + 1
 * &lt;/code&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author  Timothy Prinzing
 */
public abstract class AbstractDocument implements Document, Serializable {

    /**
     * Constructs a new &lt;code&gt;AbstractDocument&lt;/code&gt;, wrapped around some
     * specified content storage mechanism.
     *
     * @param data the content
     */
    protected AbstractDocument(Content data) {
<span class="nc" id="L108">        this(data, StyleContext.getDefaultStyleContext());</span>
<span class="nc" id="L109">    }</span>

    /**
     * Constructs a new &lt;code&gt;AbstractDocument&lt;/code&gt;, wrapped around some
     * specified content storage mechanism.
     *
     * @param data the content
     * @param context the attribute context
     */
<span class="nc" id="L118">    protected AbstractDocument(Content data, AttributeContext context) {</span>
<span class="nc" id="L119">        this.data = data;</span>
<span class="nc" id="L120">        this.context = context;</span>
<span class="nc" id="L121">        bidiRoot = new BidiRootElement();</span>

<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (defaultI18NProperty == null) {</span>
            // determine default setting for i18n support
<span class="nc" id="L125">            String o = java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L126">                new java.security.PrivilegedAction&lt;String&gt;() {</span>
                    public String run() {
<span class="nc" id="L128">                        return System.getProperty(I18NProperty);</span>
                    }
                }
            );
<span class="nc bnc" id="L132" title="All 2 branches missed.">            if (o != null) {</span>
<span class="nc" id="L133">                defaultI18NProperty = Boolean.valueOf(o);</span>
            } else {
<span class="nc" id="L135">                defaultI18NProperty = Boolean.FALSE;</span>
            }
        }
<span class="nc" id="L138">        putProperty( I18NProperty, defaultI18NProperty);</span>

        //REMIND(bcb) This creates an initial bidi element to account for
        //the \n that exists by default in the content.  Doing it this way
        //seems to expose a little too much knowledge of the content given
        //to us by the sub-class.  Consider having the sub-class' constructor
        //make an initial call to insertUpdate.
<span class="nc" id="L145">        writeLock();</span>
        try {
<span class="nc" id="L147">            Element[] p = new Element[1];</span>
<span class="nc" id="L148">            p[0] = new BidiElement( bidiRoot, 0, 1, 0 );</span>
<span class="nc" id="L149">            bidiRoot.replace(0,0,p);</span>
        } finally {
<span class="nc" id="L151">            writeUnlock();</span>
<span class="nc" id="L152">        }</span>
<span class="nc" id="L153">    }</span>

    /**
     * Supports managing a set of properties. Callers
     * can use the &lt;code&gt;documentProperties&lt;/code&gt; dictionary
     * to annotate the document with document-wide properties.
     *
     * @return a non-&lt;code&gt;null&lt;/code&gt; &lt;code&gt;Dictionary&lt;/code&gt;
     * @see #setDocumentProperties
     */
    public Dictionary&lt;Object,Object&gt; getDocumentProperties() {
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (documentProperties == null) {</span>
<span class="nc" id="L165">            documentProperties = new Hashtable&lt;Object, Object&gt;(2);</span>
        }
<span class="nc" id="L167">        return documentProperties;</span>
    }

    /**
     * Replaces the document properties dictionary for this document.
     *
     * @param x the new dictionary
     * @see #getDocumentProperties
     */
    public void setDocumentProperties(Dictionary&lt;Object,Object&gt; x) {
<span class="nc" id="L177">        documentProperties = x;</span>
<span class="nc" id="L178">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param e the event
     * @see EventListenerList
     */
    protected void fireInsertUpdate(DocumentEvent e) {
<span class="nc" id="L190">        notifyingListeners = true;</span>
        try {
            // Guaranteed to return a non-null array
<span class="nc" id="L193">            Object[] listeners = listenerList.getListenerList();</span>
            // Process the listeners last to first, notifying
            // those that are interested in this event
<span class="nc bnc" id="L196" title="All 2 branches missed.">            for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">                if (listeners[i]==DocumentListener.class) {</span>
                    // Lazily create the event:
                    // if (e == null)
                    // e = new ListSelectionEvent(this, firstIndex, lastIndex);
<span class="nc" id="L201">                    ((DocumentListener)listeners[i+1]).insertUpdate(e);</span>
                }
            }
        } finally {
<span class="nc" id="L205">            notifyingListeners = false;</span>
<span class="nc" id="L206">        }</span>
<span class="nc" id="L207">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param e the event
     * @see EventListenerList
     */
    protected void fireChangedUpdate(DocumentEvent e) {
<span class="nc" id="L219">        notifyingListeners = true;</span>
        try {
            // Guaranteed to return a non-null array
<span class="nc" id="L222">            Object[] listeners = listenerList.getListenerList();</span>
            // Process the listeners last to first, notifying
            // those that are interested in this event
<span class="nc bnc" id="L225" title="All 2 branches missed.">            for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">                if (listeners[i]==DocumentListener.class) {</span>
                    // Lazily create the event:
                    // if (e == null)
                    // e = new ListSelectionEvent(this, firstIndex, lastIndex);
<span class="nc" id="L230">                    ((DocumentListener)listeners[i+1]).changedUpdate(e);</span>
                }
            }
        } finally {
<span class="nc" id="L234">            notifyingListeners = false;</span>
<span class="nc" id="L235">        }</span>
<span class="nc" id="L236">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param e the event
     * @see EventListenerList
     */
    protected void fireRemoveUpdate(DocumentEvent e) {
<span class="nc" id="L248">        notifyingListeners = true;</span>
        try {
            // Guaranteed to return a non-null array
<span class="nc" id="L251">            Object[] listeners = listenerList.getListenerList();</span>
            // Process the listeners last to first, notifying
            // those that are interested in this event
<span class="nc bnc" id="L254" title="All 2 branches missed.">            for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                if (listeners[i]==DocumentListener.class) {</span>
                    // Lazily create the event:
                    // if (e == null)
                    // e = new ListSelectionEvent(this, firstIndex, lastIndex);
<span class="nc" id="L259">                    ((DocumentListener)listeners[i+1]).removeUpdate(e);</span>
                }
            }
        } finally {
<span class="nc" id="L263">            notifyingListeners = false;</span>
<span class="nc" id="L264">        }</span>
<span class="nc" id="L265">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param e the event
     * @see EventListenerList
     */
    protected void fireUndoableEditUpdate(UndoableEditEvent e) {
        // Guaranteed to return a non-null array
<span class="nc" id="L278">        Object[] listeners = listenerList.getListenerList();</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L281" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">            if (listeners[i]==UndoableEditListener.class) {</span>
                // Lazily create the event:
                // if (e == null)
                // e = new ListSelectionEvent(this, firstIndex, lastIndex);
<span class="nc" id="L286">                ((UndoableEditListener)listeners[i+1]).undoableEditHappened(e);</span>
            }
        }
<span class="nc" id="L289">    }</span>

    /**
     * Returns an array of all the objects currently registered
     * as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
     * upon this document.
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
     * &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
     *
     * &lt;p&gt;
     * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
     * with a class literal, such as
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
     * For example, you can query a
     * document &lt;code&gt;d&lt;/code&gt;
     * for its document listeners with the following code:
     *
     * &lt;pre&gt;DocumentListener[] mls = (DocumentListener[])(d.getListeners(DocumentListener.class));&lt;/pre&gt;
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @return an array of all objects registered as
     *          &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s on this component,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt;
     *          doesn't specify a class or interface that implements
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     *
     * @see #getDocumentListeners
     * @see #getUndoableEditListeners
     *
     * @since 1.3
     */
    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<span class="nc" id="L327">        return listenerList.getListeners(listenerType);</span>
    }

    /**
     * Gets the asynchronous loading priority.  If less than zero,
     * the document should not be loaded asynchronously.
     *
     * @return the asynchronous loading priority, or &lt;code&gt;-1&lt;/code&gt;
     *   if the document should not be loaded asynchronously
     */
    public int getAsynchronousLoadPriority() {
<span class="nc" id="L338">        Integer loadPriority = (Integer)</span>
<span class="nc" id="L339">            getProperty(AbstractDocument.AsyncLoadPriority);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (loadPriority != null) {</span>
<span class="nc" id="L341">            return loadPriority.intValue();</span>
        }
<span class="nc" id="L343">        return -1;</span>
    }

    /**
     * Sets the asynchronous loading priority.
     * @param p the new asynchronous loading priority; a value
     *   less than zero indicates that the document should not be
     *   loaded asynchronously
     */
    public void setAsynchronousLoadPriority(int p) {
<span class="nc bnc" id="L353" title="All 2 branches missed.">        Integer loadPriority = (p &gt;= 0) ? Integer.valueOf(p) : null;</span>
<span class="nc" id="L354">        putProperty(AbstractDocument.AsyncLoadPriority, loadPriority);</span>
<span class="nc" id="L355">    }</span>

    /**
     * Sets the &lt;code&gt;DocumentFilter&lt;/code&gt;. The &lt;code&gt;DocumentFilter&lt;/code&gt;
     * is passed &lt;code&gt;insert&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; to conditionally
     * allow inserting/deleting of the text.  A &lt;code&gt;null&lt;/code&gt; value
     * indicates that no filtering will occur.
     *
     * @param filter the &lt;code&gt;DocumentFilter&lt;/code&gt; used to constrain text
     * @see #getDocumentFilter
     * @since 1.4
     */
    public void setDocumentFilter(DocumentFilter filter) {
<span class="nc" id="L368">        documentFilter = filter;</span>
<span class="nc" id="L369">    }</span>

    /**
     * Returns the &lt;code&gt;DocumentFilter&lt;/code&gt; that is responsible for
     * filtering of insertion/removal. A &lt;code&gt;null&lt;/code&gt; return value
     * implies no filtering is to occur.
     *
     * @since 1.4
     * @see #setDocumentFilter
     * @return the DocumentFilter
     */
    public DocumentFilter getDocumentFilter() {
<span class="nc" id="L381">        return documentFilter;</span>
    }

    // --- Document methods -----------------------------------------

    /**
     * This allows the model to be safely rendered in the presence
     * of currency, if the model supports being updated asynchronously.
     * The given runnable will be executed in a way that allows it
     * to safely read the model with no changes while the runnable
     * is being executed.  The runnable itself may &lt;em&gt;not&lt;/em&gt;
     * make any mutations.
     * &lt;p&gt;
     * This is implemented to acquire a read lock for the duration
     * of the runnables execution.  There may be multiple runnables
     * executing at the same time, and all writers will be blocked
     * while there are active rendering runnables.  If the runnable
     * throws an exception, its lock will be safely released.
     * There is no protection against a runnable that never exits,
     * which will effectively leave the document locked for it's
     * lifetime.
     * &lt;p&gt;
     * If the given runnable attempts to make any mutations in
     * this implementation, a deadlock will occur.  There is
     * no tracking of individual rendering threads to enable
     * detecting this situation, but a subclass could incur
     * the overhead of tracking them and throwing an error.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param r the renderer to execute
     */
    public void render(Runnable r) {
<span class="nc" id="L417">        readLock();</span>
        try {
<span class="nc" id="L419">            r.run();</span>
        } finally {
<span class="nc" id="L421">            readUnlock();</span>
<span class="nc" id="L422">        }</span>
<span class="nc" id="L423">    }</span>

    /**
     * Returns the length of the data.  This is the number of
     * characters of content that represents the users data.
     *
     * @return the length &amp;gt;= 0
     * @see Document#getLength
     */
    public int getLength() {
<span class="nc" id="L433">        return data.length() - 1;</span>
    }

    /**
     * Adds a document listener for notification of any changes.
     *
     * @param listener the &lt;code&gt;DocumentListener&lt;/code&gt; to add
     * @see Document#addDocumentListener
     */
    public void addDocumentListener(DocumentListener listener) {
<span class="nc" id="L443">        listenerList.add(DocumentListener.class, listener);</span>
<span class="nc" id="L444">    }</span>

    /**
     * Removes a document listener.
     *
     * @param listener the &lt;code&gt;DocumentListener&lt;/code&gt; to remove
     * @see Document#removeDocumentListener
     */
    public void removeDocumentListener(DocumentListener listener) {
<span class="nc" id="L453">        listenerList.remove(DocumentListener.class, listener);</span>
<span class="nc" id="L454">    }</span>

    /**
     * Returns an array of all the document listeners
     * registered on this document.
     *
     * @return all of this document's &lt;code&gt;DocumentListener&lt;/code&gt;s
     *         or an empty array if no document listeners are
     *         currently registered
     *
     * @see #addDocumentListener
     * @see #removeDocumentListener
     * @since 1.4
     */
    public DocumentListener[] getDocumentListeners() {
<span class="nc" id="L469">        return listenerList.getListeners(DocumentListener.class);</span>
    }

    /**
     * Adds an undo listener for notification of any changes.
     * Undo/Redo operations performed on the &lt;code&gt;UndoableEdit&lt;/code&gt;
     * will cause the appropriate DocumentEvent to be fired to keep
     * the view(s) in sync with the model.
     *
     * @param listener the &lt;code&gt;UndoableEditListener&lt;/code&gt; to add
     * @see Document#addUndoableEditListener
     */
    public void addUndoableEditListener(UndoableEditListener listener) {
<span class="nc" id="L482">        listenerList.add(UndoableEditListener.class, listener);</span>
<span class="nc" id="L483">    }</span>

    /**
     * Removes an undo listener.
     *
     * @param listener the &lt;code&gt;UndoableEditListener&lt;/code&gt; to remove
     * @see Document#removeDocumentListener
     */
    public void removeUndoableEditListener(UndoableEditListener listener) {
<span class="nc" id="L492">        listenerList.remove(UndoableEditListener.class, listener);</span>
<span class="nc" id="L493">    }</span>

    /**
     * Returns an array of all the undoable edit listeners
     * registered on this document.
     *
     * @return all of this document's &lt;code&gt;UndoableEditListener&lt;/code&gt;s
     *         or an empty array if no undoable edit listeners are
     *         currently registered
     *
     * @see #addUndoableEditListener
     * @see #removeUndoableEditListener
     *
     * @since 1.4
     */
    public UndoableEditListener[] getUndoableEditListeners() {
<span class="nc" id="L509">        return listenerList.getListeners(UndoableEditListener.class);</span>
    }

    /**
     * A convenience method for looking up a property value. It is
     * equivalent to:
     * &lt;pre&gt;
     * getDocumentProperties().get(key);
     * &lt;/pre&gt;
     *
     * @param key the non-&lt;code&gt;null&lt;/code&gt; property key
     * @return the value of this property or &lt;code&gt;null&lt;/code&gt;
     * @see #getDocumentProperties
     */
    public final Object getProperty(Object key) {
<span class="nc" id="L524">        return getDocumentProperties().get(key);</span>
    }


    /**
     * A convenience method for storing up a property value.  It is
     * equivalent to:
     * &lt;pre&gt;
     * getDocumentProperties().put(key, value);
     * &lt;/pre&gt;
     * If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; this method will
     * remove the property.
     *
     * @param key the non-&lt;code&gt;null&lt;/code&gt; key
     * @param value the property value
     * @see #getDocumentProperties
     */
    public final void putProperty(Object key, Object value) {
<span class="nc bnc" id="L542" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L543">            getDocumentProperties().put(key, value);</span>
        } else {
<span class="nc" id="L545">            getDocumentProperties().remove(key);</span>
        }
<span class="nc bnc" id="L547" title="All 2 branches missed.">        if( key == TextAttribute.RUN_DIRECTION</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">            &amp;&amp; Boolean.TRUE.equals(getProperty(I18NProperty)) )</span>
        {
            //REMIND - this needs to flip on the i18n property if run dir
            //is rtl and the i18n property is not already on.
<span class="nc" id="L552">            writeLock();</span>
            try {
<span class="nc" id="L554">                DefaultDocumentEvent e</span>
<span class="nc" id="L555">                    = new DefaultDocumentEvent(0, getLength(),</span>
                                               DocumentEvent.EventType.INSERT);
<span class="nc" id="L557">                updateBidi( e );</span>
            } finally {
<span class="nc" id="L559">                writeUnlock();</span>
<span class="nc" id="L560">            }</span>
        }
<span class="nc" id="L562">    }</span>

    /**
     * Removes some content from the document.
     * Removing content causes a write lock to be held while the
     * actual changes are taking place.  Observers are notified
     * of the change on the thread that called this method.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param offs the starting offset &amp;gt;= 0
     * @param len the number of characters to remove &amp;gt;= 0
     * @exception BadLocationException  the given remove position is not a valid
     *   position within the document
     * @see Document#remove
     */
    public void remove(int offs, int len) throws BadLocationException {
<span class="nc" id="L582">        DocumentFilter filter = getDocumentFilter();</span>

<span class="nc" id="L584">        writeLock();</span>
        try {
<span class="nc bnc" id="L586" title="All 2 branches missed.">            if (filter != null) {</span>
<span class="nc" id="L587">                filter.remove(getFilterBypass(), offs, len);</span>
            }
            else {
<span class="nc" id="L590">                handleRemove(offs, len);</span>
            }
        } finally {
<span class="nc" id="L593">            writeUnlock();</span>
<span class="nc" id="L594">        }</span>
<span class="nc" id="L595">    }</span>

    /**
     * Performs the actual work of the remove. It is assumed the caller
     * will have obtained a &lt;code&gt;writeLock&lt;/code&gt; before invoking this.
     */
    void handleRemove(int offs, int len) throws BadLocationException {
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (len &gt; 0) {</span>
<span class="nc bnc" id="L603" title="All 4 branches missed.">            if (offs &lt; 0 || (offs + len) &gt; getLength()) {</span>
<span class="nc" id="L604">                throw new BadLocationException(&quot;Invalid remove&quot;,</span>
<span class="nc" id="L605">                                               getLength() + 1);</span>
            }
<span class="nc" id="L607">            DefaultDocumentEvent chng =</span>
                    new DefaultDocumentEvent(offs, len, DocumentEvent.EventType.REMOVE);

            boolean isComposedTextElement;
            // Check whether the position of interest is the composed text
<span class="nc" id="L612">            isComposedTextElement = Utilities.isComposedTextElement(this, offs);</span>

<span class="nc" id="L614">            removeUpdate(chng);</span>
<span class="nc" id="L615">            UndoableEdit u = data.remove(offs, len);</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">            if (u != null) {</span>
<span class="nc" id="L617">                chng.addEdit(u);</span>
            }
<span class="nc" id="L619">            postRemoveUpdate(chng);</span>
            // Mark the edit as done.
<span class="nc" id="L621">            chng.end();</span>
<span class="nc" id="L622">            fireRemoveUpdate(chng);</span>
            // only fire undo if Content implementation supports it
            // undo for the composed text is not supported for now
<span class="nc bnc" id="L625" title="All 4 branches missed.">            if ((u != null) &amp;&amp; !isComposedTextElement) {</span>
<span class="nc" id="L626">                fireUndoableEditUpdate(new UndoableEditEvent(this, chng));</span>
            }
        }
<span class="nc" id="L629">    }</span>

    /**
     * Deletes the region of text from &lt;code&gt;offset&lt;/code&gt; to
     * &lt;code&gt;offset + length&lt;/code&gt;, and replaces it with &lt;code&gt;text&lt;/code&gt;.
     * It is up to the implementation as to how this is implemented, some
     * implementations may treat this as two distinct operations: a remove
     * followed by an insert, others may treat the replace as one atomic
     * operation.
     *
     * @param offset index of child element
     * @param length length of text to delete, may be 0 indicating don't
     *               delete anything
     * @param text text to insert, &lt;code&gt;null&lt;/code&gt; indicates no text to insert
     * @param attrs AttributeSet indicating attributes of inserted text,
     *              &lt;code&gt;null&lt;/code&gt;
     *              is legal, and typically treated as an empty attributeset,
     *              but exact interpretation is left to the subclass
     * @exception BadLocationException the given position is not a valid
     *            position within the document
     * @since 1.4
     */
    public void replace(int offset, int length, String text,
                        AttributeSet attrs) throws BadLocationException {
<span class="nc bnc" id="L653" title="All 6 branches missed.">        if (length == 0 &amp;&amp; (text == null || text.length() == 0)) {</span>
<span class="nc" id="L654">            return;</span>
        }
<span class="nc" id="L656">        DocumentFilter filter = getDocumentFilter();</span>

<span class="nc" id="L658">        writeLock();</span>
        try {
<span class="nc bnc" id="L660" title="All 2 branches missed.">            if (filter != null) {</span>
<span class="nc" id="L661">                filter.replace(getFilterBypass(), offset, length, text,</span>
                               attrs);
            }
            else {
<span class="nc bnc" id="L665" title="All 2 branches missed.">                if (length &gt; 0) {</span>
<span class="nc" id="L666">                    remove(offset, length);</span>
                }
<span class="nc bnc" id="L668" title="All 4 branches missed.">                if (text != null &amp;&amp; text.length() &gt; 0) {</span>
<span class="nc" id="L669">                    insertString(offset, text, attrs);</span>
                }
            }
        } finally {
<span class="nc" id="L673">            writeUnlock();</span>
<span class="nc" id="L674">        }</span>
<span class="nc" id="L675">    }</span>

    /**
     * Inserts some content into the document.
     * Inserting content causes a write lock to be held while the
     * actual changes are taking place, followed by notification
     * to the observers on the thread that grabbed the write lock.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param offs the starting offset &amp;gt;= 0
     * @param str the string to insert; does nothing with null/empty strings
     * @param a the attributes for the inserted content
     * @exception BadLocationException  the given insert position is not a valid
     *   position within the document
     * @see Document#insertString
     */
    public void insertString(int offs, String str, AttributeSet a) throws BadLocationException {
<span class="nc bnc" id="L696" title="All 4 branches missed.">        if ((str == null) || (str.length() == 0)) {</span>
<span class="nc" id="L697">            return;</span>
        }
<span class="nc" id="L699">        DocumentFilter filter = getDocumentFilter();</span>
<span class="nc" id="L700">        InsertStringResult insertStringResult = null;</span>

<span class="nc" id="L702">        writeLock();</span>

        try {
<span class="nc bnc" id="L705" title="All 2 branches missed.">            if (filter != null) {</span>
<span class="nc" id="L706">                filter.insertString(getFilterBypass(), offs, str, a);</span>
            } else {
<span class="nc" id="L708">                insertStringResult = handleInsertString(offs, str, a);</span>
            }
        } finally {
<span class="nc" id="L711">            writeUnlock();</span>
<span class="nc" id="L712">        }</span>

<span class="nc" id="L714">        processInsertStringResult(insertStringResult);</span>
<span class="nc" id="L715">    }</span>

    /**
     * Performs the actual work of inserting the text; it is assumed the
     * caller has obtained a write lock before invoking this.
     */
    private InsertStringResult handleInsertString(int offs, String str, AttributeSet a)
            throws BadLocationException {
<span class="nc bnc" id="L723" title="All 4 branches missed.">        if ((str == null) || (str.length() == 0)) {</span>
<span class="nc" id="L724">            return null;</span>
        }
<span class="nc" id="L726">        UndoableEdit u = data.insertString(offs, str);</span>
<span class="nc" id="L727">        DefaultDocumentEvent e =</span>
<span class="nc" id="L728">            new DefaultDocumentEvent(offs, str.length(), DocumentEvent.EventType.INSERT);</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">        if (u != null) {</span>
<span class="nc" id="L730">            e.addEdit(u);</span>
        }

        // see if complex glyph layout support is needed
<span class="nc bnc" id="L734" title="All 2 branches missed.">        if( getProperty(I18NProperty).equals( Boolean.FALSE ) ) {</span>
            // if a default direction of right-to-left has been specified,
            // we want complex layout even if the text is all left to right.
<span class="nc" id="L737">            Object d = getProperty(TextAttribute.RUN_DIRECTION);</span>
<span class="nc bnc" id="L738" title="All 4 branches missed.">            if ((d != null) &amp;&amp; (d.equals(TextAttribute.RUN_DIRECTION_RTL))) {</span>
<span class="nc" id="L739">                putProperty( I18NProperty, Boolean.TRUE);</span>
            } else {
<span class="nc" id="L741">                char[] chars = str.toCharArray();</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">                if (SwingUtilities2.isComplexLayout(chars, 0, chars.length)) {</span>
<span class="nc" id="L743">                    putProperty( I18NProperty, Boolean.TRUE);</span>
                }
            }
        }

<span class="nc" id="L748">        insertUpdate(e, a);</span>
        // Mark the edit as done.
<span class="nc" id="L750">        e.end();</span>

<span class="nc" id="L752">        InsertStringResult result = new InsertStringResult();</span>

<span class="nc" id="L754">        result.documentEvent = e;</span>

        // only fire undo if Content implementation supports it
        // undo for the composed text is not supported for now
<span class="nc bnc" id="L758" title="All 6 branches missed.">        if (u != null &amp;&amp; (a == null || !a.isDefined(StyleConstants.ComposedTextAttribute))) {</span>
<span class="nc" id="L759">            result.undoableEditEvent = new UndoableEditEvent(this, e);</span>
        }

<span class="nc" id="L762">        return result;</span>
    }

    private void processInsertStringResult(InsertStringResult insertStringResult) {
<span class="nc bnc" id="L766" title="All 2 branches missed.">        if (insertStringResult == null) {</span>
<span class="nc" id="L767">            return;</span>
        }

<span class="nc" id="L770">        fireInsertUpdate(insertStringResult.documentEvent);</span>

<span class="nc bnc" id="L772" title="All 2 branches missed.">        if (insertStringResult.undoableEditEvent != null) {</span>
<span class="nc" id="L773">            fireUndoableEditUpdate(insertStringResult.undoableEditEvent);</span>
        }
<span class="nc" id="L775">    }</span>

    /**
     * Gets a sequence of text from the document.
     *
     * @param offset the starting offset &amp;gt;= 0
     * @param length the number of characters to retrieve &amp;gt;= 0
     * @return the text
     * @exception BadLocationException  the range given includes a position
     *   that is not a valid position within the document
     * @see Document#getText
     */
    public String getText(int offset, int length) throws BadLocationException {
<span class="nc bnc" id="L788" title="All 2 branches missed.">        if (length &lt; 0) {</span>
<span class="nc" id="L789">            throw new BadLocationException(&quot;Length must be positive&quot;, length);</span>
        }
<span class="nc" id="L791">        String str = data.getString(offset, length);</span>
<span class="nc" id="L792">        return str;</span>
    }

    /**
     * Fetches the text contained within the given portion
     * of the document.
     * &lt;p&gt;
     * If the partialReturn property on the txt parameter is false, the
     * data returned in the Segment will be the entire length requested and
     * may or may not be a copy depending upon how the data was stored.
     * If the partialReturn property is true, only the amount of text that
     * can be returned without creating a copy is returned.  Using partial
     * returns will give better performance for situations where large
     * parts of the document are being scanned.  The following is an example
     * of using the partial return to access the entire document:
     * &lt;p&gt;
     * &lt;pre&gt;
     * &amp;nbsp; int nleft = doc.getDocumentLength();
     * &amp;nbsp; Segment text = new Segment();
     * &amp;nbsp; int offs = 0;
     * &amp;nbsp; text.setPartialReturn(true);
     * &amp;nbsp; while (nleft &amp;gt; 0) {
     * &amp;nbsp;     doc.getText(offs, nleft, text);
     * &amp;nbsp;     // do something with text
     * &amp;nbsp;     nleft -= text.count;
     * &amp;nbsp;     offs += text.count;
     * &amp;nbsp; }
     * &lt;/pre&gt;
     *
     * @param offset the starting offset &amp;gt;= 0
     * @param length the number of characters to retrieve &amp;gt;= 0
     * @param txt the Segment object to retrieve the text into
     * @exception BadLocationException  the range given includes a position
     *   that is not a valid position within the document
     */
    public void getText(int offset, int length, Segment txt) throws BadLocationException {
<span class="nc bnc" id="L828" title="All 2 branches missed.">        if (length &lt; 0) {</span>
<span class="nc" id="L829">            throw new BadLocationException(&quot;Length must be positive&quot;, length);</span>
        }
<span class="nc" id="L831">        data.getChars(offset, length, txt);</span>
<span class="nc" id="L832">    }</span>

    /**
     * Returns a position that will track change as the document
     * is altered.
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     *
     * @param offs the position in the model &amp;gt;= 0
     * @return the position
     * @exception BadLocationException  if the given position does not
     *   represent a valid location in the associated document
     * @see Document#createPosition
     */
    public synchronized Position createPosition(int offs) throws BadLocationException {
<span class="nc" id="L850">        return data.createPosition(offs);</span>
    }

    /**
     * Returns a position that represents the start of the document.  The
     * position returned can be counted on to track change and stay
     * located at the beginning of the document.
     *
     * @return the position
     */
    public final Position getStartPosition() {
        Position p;
        try {
<span class="nc" id="L863">            p = createPosition(0);</span>
<span class="nc" id="L864">        } catch (BadLocationException bl) {</span>
<span class="nc" id="L865">            p = null;</span>
<span class="nc" id="L866">        }</span>
<span class="nc" id="L867">        return p;</span>
    }

    /**
     * Returns a position that represents the end of the document.  The
     * position returned can be counted on to track change and stay
     * located at the end of the document.
     *
     * @return the position
     */
    public final Position getEndPosition() {
        Position p;
        try {
<span class="nc" id="L880">            p = createPosition(data.length());</span>
<span class="nc" id="L881">        } catch (BadLocationException bl) {</span>
<span class="nc" id="L882">            p = null;</span>
<span class="nc" id="L883">        }</span>
<span class="nc" id="L884">        return p;</span>
    }

    /**
     * Gets all root elements defined.  Typically, there
     * will only be one so the default implementation
     * is to return the default root element.
     *
     * @return the root element
     */
    public Element[] getRootElements() {
<span class="nc" id="L895">        Element[] elems = new Element[2];</span>
<span class="nc" id="L896">        elems[0] = getDefaultRootElement();</span>
<span class="nc" id="L897">        elems[1] = getBidiRootElement();</span>
<span class="nc" id="L898">        return elems;</span>
    }

    /**
     * Returns the root element that views should be based upon
     * unless some other mechanism for assigning views to element
     * structures is provided.
     *
     * @return the root element
     * @see Document#getDefaultRootElement
     */
    public abstract Element getDefaultRootElement();

    // ---- local methods -----------------------------------------

    /**
     * Returns the &lt;code&gt;FilterBypass&lt;/code&gt;. This will create one if one
     * does not yet exist.
     */
    private DocumentFilter.FilterBypass getFilterBypass() {
<span class="nc bnc" id="L918" title="All 2 branches missed.">        if (filterBypass == null) {</span>
<span class="nc" id="L919">            filterBypass = new DefaultFilterBypass();</span>
        }
<span class="nc" id="L921">        return filterBypass;</span>
    }

    /**
     * Returns the root element of the bidirectional structure for this
     * document.  Its children represent character runs with a given
     * Unicode bidi level.
     */
    public Element getBidiRootElement() {
<span class="nc" id="L930">        return bidiRoot;</span>
    }

    /**
     * Returns true if the text in the range &lt;code&gt;p0&lt;/code&gt; to
     * &lt;code&gt;p1&lt;/code&gt; is left to right.
     */
    static boolean isLeftToRight(Document doc, int p0, int p1) {
<span class="nc bnc" id="L938" title="All 2 branches missed.">        if (Boolean.TRUE.equals(doc.getProperty(I18NProperty))) {</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">            if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L940">                AbstractDocument adoc = (AbstractDocument) doc;</span>
<span class="nc" id="L941">                Element bidiRoot = adoc.getBidiRootElement();</span>
<span class="nc" id="L942">                int index = bidiRoot.getElementIndex(p0);</span>
<span class="nc" id="L943">                Element bidiElem = bidiRoot.getElement(index);</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">                if (bidiElem.getEndOffset() &gt;= p1) {</span>
<span class="nc" id="L945">                    AttributeSet bidiAttrs = bidiElem.getAttributes();</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">                    return ((StyleConstants.getBidiLevel(bidiAttrs) % 2) == 0);</span>
                }
            }
        }
<span class="nc" id="L950">        return true;</span>
    }

    /**
     * Get the paragraph element containing the given position.  Sub-classes
     * must define for themselves what exactly constitutes a paragraph.  They
     * should keep in mind however that a paragraph should at least be the
     * unit of text over which to run the Unicode bidirectional algorithm.
     *
     * @param pos the starting offset &amp;gt;= 0
     * @return the element */
    public abstract Element getParagraphElement(int pos);


    /**
     * Fetches the context for managing attributes.  This
     * method effectively establishes the strategy used
     * for compressing AttributeSet information.
     *
     * @return the context
     */
    protected final AttributeContext getAttributeContext() {
<span class="nc" id="L972">        return context;</span>
    }

    /**
     * Updates document structure as a result of text insertion.  This
     * will happen within a write lock.  If a subclass of
     * this class reimplements this method, it should delegate to the
     * superclass as well.
     *
     * @param chng a description of the change
     * @param attr the attributes for the change
     */
    protected void insertUpdate(DefaultDocumentEvent chng, AttributeSet attr) {
<span class="nc bnc" id="L985" title="All 2 branches missed.">        if( getProperty(I18NProperty).equals( Boolean.TRUE ) )</span>
<span class="nc" id="L986">            updateBidi( chng );</span>

        // Check if a multi byte is encountered in the inserted text.
<span class="nc bnc" id="L989" title="All 2 branches missed.">        if (chng.type == DocumentEvent.EventType.INSERT &amp;&amp;</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">                        chng.getLength() &gt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">                        !Boolean.TRUE.equals(getProperty(MultiByteProperty))) {</span>
<span class="nc" id="L992">            Segment segment = SegmentCache.getSharedSegment();</span>
            try {
<span class="nc" id="L994">                getText(chng.getOffset(), chng.getLength(), segment);</span>
<span class="nc" id="L995">                segment.first();</span>
                do {
<span class="nc bnc" id="L997" title="All 2 branches missed.">                    if ((int)segment.current() &gt; 255) {</span>
<span class="nc" id="L998">                        putProperty(MultiByteProperty, Boolean.TRUE);</span>
<span class="nc" id="L999">                        break;</span>
                    }
<span class="nc bnc" id="L1001" title="All 2 branches missed.">                } while (segment.next() != Segment.DONE);</span>
<span class="nc" id="L1002">            } catch (BadLocationException ble) {</span>
                // Should never happen
<span class="nc" id="L1004">            }</span>
<span class="nc" id="L1005">            SegmentCache.releaseSharedSegment(segment);</span>
        }
<span class="nc" id="L1007">    }</span>

    /**
     * Updates any document structure as a result of text removal.  This
     * method is called before the text is actually removed from the Content.
     * This will happen within a write lock. If a subclass
     * of this class reimplements this method, it should delegate to the
     * superclass as well.
     *
     * @param chng a description of the change
     */
    protected void removeUpdate(DefaultDocumentEvent chng) {
<span class="nc" id="L1019">    }</span>

    /**
     * Updates any document structure as a result of text removal.  This
     * method is called after the text has been removed from the Content.
     * This will happen within a write lock. If a subclass
     * of this class reimplements this method, it should delegate to the
     * superclass as well.
     *
     * @param chng a description of the change
     */
    protected void postRemoveUpdate(DefaultDocumentEvent chng) {
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        if( getProperty(I18NProperty).equals( Boolean.TRUE ) )</span>
<span class="nc" id="L1032">            updateBidi( chng );</span>
<span class="nc" id="L1033">    }</span>


    /**
     * Update the bidi element structure as a result of the given change
     * to the document.  The given change will be updated to reflect the
     * changes made to the bidi structure.
     *
     * This method assumes that every offset in the model is contained in
     * exactly one paragraph.  This method also assumes that it is called
     * after the change is made to the default element structure.
     */
    void updateBidi( DefaultDocumentEvent chng ) {

        // Calculate the range of paragraphs affected by the change.
        int firstPStart;
        int lastPEnd;
<span class="nc bnc" id="L1050" title="All 2 branches missed.">        if( chng.type == DocumentEvent.EventType.INSERT</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">            || chng.type == DocumentEvent.EventType.CHANGE )</span>
        {
<span class="nc" id="L1053">            int chngStart = chng.getOffset();</span>
<span class="nc" id="L1054">            int chngEnd =  chngStart + chng.getLength();</span>
<span class="nc" id="L1055">            firstPStart = getParagraphElement(chngStart).getStartOffset();</span>
<span class="nc" id="L1056">            lastPEnd = getParagraphElement(chngEnd).getEndOffset();</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">        } else if( chng.type == DocumentEvent.EventType.REMOVE ) {</span>
<span class="nc" id="L1058">            Element paragraph = getParagraphElement( chng.getOffset() );</span>
<span class="nc" id="L1059">            firstPStart = paragraph.getStartOffset();</span>
<span class="nc" id="L1060">            lastPEnd = paragraph.getEndOffset();</span>
<span class="nc" id="L1061">        } else {</span>
<span class="nc" id="L1062">            throw new Error(&quot;Internal error: unknown event type.&quot;);</span>
        }
        //System.out.println(&quot;updateBidi: firstPStart = &quot; + firstPStart + &quot; lastPEnd = &quot; + lastPEnd );


        // Calculate the bidi levels for the affected range of paragraphs.  The
        // levels array will contain a bidi level for each character in the
        // affected text.
<span class="nc" id="L1070">        byte levels[] = calculateBidiLevels( firstPStart, lastPEnd );</span>


<span class="nc" id="L1073">        Vector&lt;Element&gt; newElements = new Vector&lt;Element&gt;();</span>

        // Calculate the first span of characters in the affected range with
        // the same bidi level.  If this level is the same as the level of the
        // previous bidi element (the existing bidi element containing
        // firstPStart-1), then merge in the previous element.  If not, but
        // the previous element overlaps the affected range, truncate the
        // previous element at firstPStart.
<span class="nc" id="L1081">        int firstSpanStart = firstPStart;</span>
<span class="nc" id="L1082">        int removeFromIndex = 0;</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if( firstSpanStart &gt; 0 ) {</span>
<span class="nc" id="L1084">            int prevElemIndex = bidiRoot.getElementIndex(firstPStart-1);</span>
<span class="nc" id="L1085">            removeFromIndex = prevElemIndex;</span>
<span class="nc" id="L1086">            Element prevElem = bidiRoot.getElement(prevElemIndex);</span>
<span class="nc" id="L1087">            int prevLevel=StyleConstants.getBidiLevel(prevElem.getAttributes());</span>
            //System.out.println(&quot;createbidiElements: prevElem= &quot; + prevElem  + &quot; prevLevel= &quot; + prevLevel + &quot;level[0] = &quot; + levels[0]);
<span class="nc bnc" id="L1089" title="All 2 branches missed.">            if( prevLevel==levels[0] ) {</span>
<span class="nc" id="L1090">                firstSpanStart = prevElem.getStartOffset();</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">            } else if( prevElem.getEndOffset() &gt; firstPStart ) {</span>
<span class="nc" id="L1092">                newElements.addElement(new BidiElement(bidiRoot,</span>
<span class="nc" id="L1093">                                                       prevElem.getStartOffset(),</span>
                                                       firstPStart, prevLevel));
            } else {
<span class="nc" id="L1096">                removeFromIndex++;</span>
            }
        }

<span class="nc" id="L1100">        int firstSpanEnd = 0;</span>
<span class="nc bnc" id="L1101" title="All 4 branches missed.">        while((firstSpanEnd&lt;levels.length) &amp;&amp; (levels[firstSpanEnd]==levels[0]))</span>
<span class="nc" id="L1102">            firstSpanEnd++;</span>


        // Calculate the last span of characters in the affected range with
        // the same bidi level.  If this level is the same as the level of the
        // next bidi element (the existing bidi element containing lastPEnd),
        // then merge in the next element.  If not, but the next element
        // overlaps the affected range, adjust the next element to start at
        // lastPEnd.
<span class="nc" id="L1111">        int lastSpanEnd = lastPEnd;</span>
<span class="nc" id="L1112">        Element newNextElem = null;</span>
<span class="nc" id="L1113">        int removeToIndex = bidiRoot.getElementCount() - 1;</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">        if( lastSpanEnd &lt;= getLength() ) {</span>
<span class="nc" id="L1115">            int nextElemIndex = bidiRoot.getElementIndex( lastPEnd );</span>
<span class="nc" id="L1116">            removeToIndex = nextElemIndex;</span>
<span class="nc" id="L1117">            Element nextElem = bidiRoot.getElement( nextElemIndex );</span>
<span class="nc" id="L1118">            int nextLevel = StyleConstants.getBidiLevel(nextElem.getAttributes());</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">            if( nextLevel == levels[levels.length-1] ) {</span>
<span class="nc" id="L1120">                lastSpanEnd = nextElem.getEndOffset();</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">            } else if( nextElem.getStartOffset() &lt; lastPEnd ) {</span>
<span class="nc" id="L1122">                newNextElem = new BidiElement(bidiRoot, lastPEnd,</span>
<span class="nc" id="L1123">                                              nextElem.getEndOffset(),</span>
                                              nextLevel);
            } else {
<span class="nc" id="L1126">                removeToIndex--;</span>
            }
        }

<span class="nc" id="L1130">        int lastSpanStart = levels.length;</span>
<span class="nc bnc" id="L1131" title="All 4 branches missed.">        while( (lastSpanStart&gt;firstSpanEnd)</span>
               &amp;&amp; (levels[lastSpanStart-1]==levels[levels.length-1]) )
<span class="nc" id="L1133">            lastSpanStart--;</span>


        // If the first and last spans are contiguous and have the same level,
        // merge them and create a single new element for the entire span.
        // Otherwise, create elements for the first and last spans as well as
        // any spans in between.
<span class="nc bnc" id="L1140" title="All 4 branches missed.">        if((firstSpanEnd==lastSpanStart)&amp;&amp;(levels[0]==levels[levels.length-1])){</span>
<span class="nc" id="L1141">            newElements.addElement(new BidiElement(bidiRoot, firstSpanStart,</span>
                                                   lastSpanEnd, levels[0]));
        } else {
            // Create an element for the first span.
<span class="nc" id="L1145">            newElements.addElement(new BidiElement(bidiRoot, firstSpanStart,</span>
                                                   firstSpanEnd+firstPStart,
                                                   levels[0]));
            // Create elements for the spans in between the first and last
<span class="nc bnc" id="L1149" title="All 2 branches missed.">            for( int i=firstSpanEnd; i&lt;lastSpanStart; ) {</span>
                //System.out.println(&quot;executed line 872&quot;);
                int j;
<span class="nc bnc" id="L1152" title="All 4 branches missed.">                for( j=i;  (j&lt;levels.length) &amp;&amp; (levels[j] == levels[i]); j++ );</span>
<span class="nc" id="L1153">                newElements.addElement(new BidiElement(bidiRoot, firstPStart+i,</span>
                                                       firstPStart+j,
                                                       (int)levels[i]));
<span class="nc" id="L1156">                i=j;</span>
<span class="nc" id="L1157">            }</span>
            // Create an element for the last span.
<span class="nc" id="L1159">            newElements.addElement(new BidiElement(bidiRoot,</span>
                                                   lastSpanStart+firstPStart,
                                                   lastSpanEnd,
                                                   levels[levels.length-1]));
        }

<span class="nc bnc" id="L1165" title="All 2 branches missed.">        if( newNextElem != null )</span>
<span class="nc" id="L1166">            newElements.addElement( newNextElem );</span>


        // Calculate the set of existing bidi elements which must be
        // removed.
<span class="nc" id="L1171">        int removedElemCount = 0;</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">        if( bidiRoot.getElementCount() &gt; 0 ) {</span>
<span class="nc" id="L1173">            removedElemCount = removeToIndex - removeFromIndex + 1;</span>
        }
<span class="nc" id="L1175">        Element[] removedElems = new Element[removedElemCount];</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">        for( int i=0; i&lt;removedElemCount; i++ ) {</span>
<span class="nc" id="L1177">            removedElems[i] = bidiRoot.getElement(removeFromIndex+i);</span>
        }

<span class="nc" id="L1180">        Element[] addedElems = new Element[ newElements.size() ];</span>
<span class="nc" id="L1181">        newElements.copyInto( addedElems );</span>

        // Update the change record.
<span class="nc" id="L1184">        ElementEdit ee = new ElementEdit( bidiRoot, removeFromIndex,</span>
                                          removedElems, addedElems );
<span class="nc" id="L1186">        chng.addEdit( ee );</span>

        // Update the bidi element structure.
<span class="nc" id="L1189">        bidiRoot.replace( removeFromIndex, removedElems.length, addedElems );</span>
<span class="nc" id="L1190">    }</span>


    /**
     * Calculate the levels array for a range of paragraphs.
     */
    private byte[] calculateBidiLevels( int firstPStart, int lastPEnd ) {

<span class="nc" id="L1198">        byte levels[] = new byte[ lastPEnd - firstPStart ];</span>
<span class="nc" id="L1199">        int  levelsEnd = 0;</span>
<span class="nc" id="L1200">        Boolean defaultDirection = null;</span>
<span class="nc" id="L1201">        Object d = getProperty(TextAttribute.RUN_DIRECTION);</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">        if (d instanceof Boolean) {</span>
<span class="nc" id="L1203">            defaultDirection = (Boolean) d;</span>
        }

        // For each paragraph in the given range of paragraphs, get its
        // levels array and add it to the levels array for the entire span.
<span class="nc bnc" id="L1208" title="All 2 branches missed.">        for(int o=firstPStart; o&lt;lastPEnd; ) {</span>
<span class="nc" id="L1209">            Element p = getParagraphElement( o );</span>
<span class="nc" id="L1210">            int pStart = p.getStartOffset();</span>
<span class="nc" id="L1211">            int pEnd = p.getEndOffset();</span>

            // default run direction for the paragraph.  This will be
            // null if there is no direction override specified (i.e.
            // the direction will be determined from the content).
<span class="nc" id="L1216">            Boolean direction = defaultDirection;</span>
<span class="nc" id="L1217">            d = p.getAttributes().getAttribute(TextAttribute.RUN_DIRECTION);</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">            if (d instanceof Boolean) {</span>
<span class="nc" id="L1219">                direction = (Boolean) d;</span>
            }

            //System.out.println(&quot;updateBidi: paragraph start = &quot; + pStart + &quot; paragraph end = &quot; + pEnd);

            // Create a Bidi over this paragraph then get the level
            // array.
<span class="nc" id="L1226">            Segment seg = SegmentCache.getSharedSegment();</span>
            try {
<span class="nc" id="L1228">                getText(pStart, pEnd-pStart, seg);</span>
<span class="nc" id="L1229">            } catch (BadLocationException e ) {</span>
<span class="nc" id="L1230">                throw new Error(&quot;Internal error: &quot; + e.toString());</span>
<span class="nc" id="L1231">            }</span>
            // REMIND(bcb) we should really be using a Segment here.
            Bidi bidiAnalyzer;
<span class="nc" id="L1234">            int bidiflag = Bidi.DIRECTION_DEFAULT_LEFT_TO_RIGHT;</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">            if (direction != null) {</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">                if (TextAttribute.RUN_DIRECTION_LTR.equals(direction)) {</span>
<span class="nc" id="L1237">                    bidiflag = Bidi.DIRECTION_LEFT_TO_RIGHT;</span>
                } else {
<span class="nc" id="L1239">                    bidiflag = Bidi.DIRECTION_RIGHT_TO_LEFT;</span>
                }
            }
<span class="nc" id="L1242">            bidiAnalyzer = new Bidi(seg.array, seg.offset, null, 0, seg.count,</span>
                    bidiflag);
<span class="nc" id="L1244">            BidiUtils.getLevels(bidiAnalyzer, levels, levelsEnd);</span>
<span class="nc" id="L1245">            levelsEnd += bidiAnalyzer.getLength();</span>

<span class="nc" id="L1247">            o =  p.getEndOffset();</span>
<span class="nc" id="L1248">            SegmentCache.releaseSharedSegment(seg);</span>
<span class="nc" id="L1249">        }</span>

        // REMIND(bcb) remove this code when debugging is done.
<span class="nc bnc" id="L1252" title="All 2 branches missed.">        if( levelsEnd != levels.length )</span>
<span class="nc" id="L1253">            throw new Error(&quot;levelsEnd assertion failed.&quot;);</span>

<span class="nc" id="L1255">        return levels;</span>
    }

    /**
     * Gives a diagnostic dump.
     *
     * @param out the output stream
     */
    public void dump(PrintStream out) {
<span class="nc" id="L1264">        Element root = getDefaultRootElement();</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">        if (root instanceof AbstractElement) {</span>
<span class="nc" id="L1266">            ((AbstractElement)root).dump(out, 0);</span>
        }
<span class="nc" id="L1268">        bidiRoot.dump(out,0);</span>
<span class="nc" id="L1269">    }</span>

    /**
     * Gets the content for the document.
     *
     * @return the content
     */
    protected final Content getContent() {
<span class="nc" id="L1277">        return data;</span>
    }

    /**
     * Creates a document leaf element.
     * Hook through which elements are created to represent the
     * document structure.  Because this implementation keeps
     * structure and content separate, elements grow automatically
     * when content is extended so splits of existing elements
     * follow.  The document itself gets to decide how to generate
     * elements to give flexibility in the type of elements used.
     *
     * @param parent the parent element
     * @param a the attributes for the element
     * @param p0 the beginning of the range &amp;gt;= 0
     * @param p1 the end of the range &amp;gt;= p0
     * @return the new element
     */
    protected Element createLeafElement(Element parent, AttributeSet a, int p0, int p1) {
<span class="nc" id="L1296">        return new LeafElement(parent, a, p0, p1);</span>
    }

    /**
     * Creates a document branch element, that can contain other elements.
     *
     * @param parent the parent element
     * @param a the attributes
     * @return the element
     */
    protected Element createBranchElement(Element parent, AttributeSet a) {
<span class="nc" id="L1307">        return new BranchElement(parent, a);</span>
    }

    // --- Document locking ----------------------------------

    /**
     * Fetches the current writing thread if there is one.
     * This can be used to distinguish whether a method is
     * being called as part of an existing modification or
     * if a lock needs to be acquired and a new transaction
     * started.
     *
     * @return the thread actively modifying the document
     *  or &lt;code&gt;null&lt;/code&gt; if there are no modifications in progress
     */
    protected synchronized final Thread getCurrentWriter() {
<span class="nc" id="L1323">        return currWriter;</span>
    }

    /**
     * Acquires a lock to begin mutating the document this lock
     * protects.  There can be no writing, notification of changes, or
     * reading going on in order to gain the lock.  Additionally a thread is
     * allowed to gain more than one &lt;code&gt;writeLock&lt;/code&gt;,
     * as long as it doesn't attempt to gain additional &lt;code&gt;writeLock&lt;/code&gt;s
     * from within document notification.  Attempting to gain a
     * &lt;code&gt;writeLock&lt;/code&gt; from within a DocumentListener notification will
     * result in an &lt;code&gt;IllegalStateException&lt;/code&gt;.  The ability
     * to obtain more than one &lt;code&gt;writeLock&lt;/code&gt; per thread allows
     * subclasses to gain a writeLock, perform a number of operations, then
     * release the lock.
     * &lt;p&gt;
     * Calls to &lt;code&gt;writeLock&lt;/code&gt;
     * must be balanced with calls to &lt;code&gt;writeUnlock&lt;/code&gt;, else the
     * &lt;code&gt;Document&lt;/code&gt; will be left in a locked state so that no
     * reading or writing can be done.
     *
     * @exception IllegalStateException thrown on illegal lock
     *  attempt.  If the document is implemented properly, this can
     *  only happen if a document listener attempts to mutate the
     *  document.  This situation violates the bean event model
     *  where order of delivery is not guaranteed and all listeners
     *  should be notified before further mutations are allowed.
     */
    protected synchronized final void writeLock() {
        try {
<span class="nc bnc" id="L1353" title="All 4 branches missed.">            while ((numReaders &gt; 0) || (currWriter != null)) {</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">                if (Thread.currentThread() == currWriter) {</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">                    if (notifyingListeners) {</span>
                        // Assuming one doesn't do something wrong in a
                        // subclass this should only happen if a
                        // DocumentListener tries to mutate the document.
<span class="nc" id="L1359">                        throw new IllegalStateException(</span>
                                      &quot;Attempt to mutate in notification&quot;);
                    }
<span class="nc" id="L1362">                    numWriters++;</span>
<span class="nc" id="L1363">                    return;</span>
                }
<span class="nc" id="L1365">                wait();</span>
            }
<span class="nc" id="L1367">            currWriter = Thread.currentThread();</span>
<span class="nc" id="L1368">            numWriters = 1;</span>
<span class="nc" id="L1369">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1370">            throw new Error(&quot;Interrupted attempt to acquire write lock&quot;);</span>
<span class="nc" id="L1371">        }</span>
<span class="nc" id="L1372">    }</span>

    /**
     * Releases a write lock previously obtained via &lt;code&gt;writeLock&lt;/code&gt;.
     * After decrementing the lock count if there are no outstanding locks
     * this will allow a new writer, or readers.
     *
     * @see #writeLock
     */
    protected synchronized final void writeUnlock() {
<span class="nc bnc" id="L1382" title="All 2 branches missed.">        if (--numWriters &lt;= 0) {</span>
<span class="nc" id="L1383">            numWriters = 0;</span>
<span class="nc" id="L1384">            currWriter = null;</span>
<span class="nc" id="L1385">            notifyAll();</span>
        }
<span class="nc" id="L1387">    }</span>

    /**
     * Acquires a lock to begin reading some state from the
     * document.  There can be multiple readers at the same time.
     * Writing blocks the readers until notification of the change
     * to the listeners has been completed.  This method should
     * be used very carefully to avoid unintended compromise
     * of the document.  It should always be balanced with a
     * &lt;code&gt;readUnlock&lt;/code&gt;.
     *
     * @see #readUnlock
     */
    public synchronized final void readLock() {
        try {
<span class="nc bnc" id="L1402" title="All 2 branches missed.">            while (currWriter != null) {</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">                if (currWriter == Thread.currentThread()) {</span>
                    // writer has full read access.... may try to acquire
                    // lock in notification
<span class="nc" id="L1406">                    return;</span>
                }
<span class="nc" id="L1408">                wait();</span>
            }
<span class="nc" id="L1410">            numReaders += 1;</span>
<span class="nc" id="L1411">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1412">            throw new Error(&quot;Interrupted attempt to acquire read lock&quot;);</span>
<span class="nc" id="L1413">        }</span>
<span class="nc" id="L1414">    }</span>

    /**
     * Does a read unlock.  This signals that one
     * of the readers is done.  If there are no more readers
     * then writing can begin again.  This should be balanced
     * with a readLock, and should occur in a finally statement
     * so that the balance is guaranteed.  The following is an
     * example.
     * &lt;pre&gt;&lt;code&gt;
     * &amp;nbsp;   readLock();
     * &amp;nbsp;   try {
     * &amp;nbsp;       // do something
     * &amp;nbsp;   } finally {
     * &amp;nbsp;       readUnlock();
     * &amp;nbsp;   }
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @see #readLock
     */
    public synchronized final void readUnlock() {
<span class="nc bnc" id="L1435" title="All 2 branches missed.">        if (currWriter == Thread.currentThread()) {</span>
            // writer has full read access.... may try to acquire
            // lock in notification
<span class="nc" id="L1438">            return;</span>
        }
<span class="nc bnc" id="L1440" title="All 2 branches missed.">        if (numReaders &lt;= 0) {</span>
<span class="nc" id="L1441">            throw new StateInvariantError(BAD_LOCK_STATE);</span>
        }
<span class="nc" id="L1443">        numReaders -= 1;</span>
<span class="nc" id="L1444">        notify();</span>
<span class="nc" id="L1445">    }</span>

    // --- serialization ---------------------------------------------

    private void readObject(ObjectInputStream s)
      throws ClassNotFoundException, IOException
    {
<span class="nc" id="L1452">        s.defaultReadObject();</span>
<span class="nc" id="L1453">        listenerList = new EventListenerList();</span>

        // Restore bidi structure
        //REMIND(bcb) This creates an initial bidi element to account for
        //the \n that exists by default in the content.
<span class="nc" id="L1458">        bidiRoot = new BidiRootElement();</span>
        try {
<span class="nc" id="L1460">            writeLock();</span>
<span class="nc" id="L1461">            Element[] p = new Element[1];</span>
<span class="nc" id="L1462">            p[0] = new BidiElement( bidiRoot, 0, 1, 0 );</span>
<span class="nc" id="L1463">            bidiRoot.replace(0,0,p);</span>
        } finally {
<span class="nc" id="L1465">            writeUnlock();</span>
<span class="nc" id="L1466">        }</span>
        // At this point bidi root is only partially correct. To fully
        // restore it we need access to getDefaultRootElement. But, this
        // is created by the subclass and at this point will be null. We
        // thus use registerValidation.
<span class="nc" id="L1471">        s.registerValidation(new ObjectInputValidation() {</span>
            public void validateObject() {
                try {
<span class="nc" id="L1474">                    writeLock();</span>
<span class="nc" id="L1475">                    DefaultDocumentEvent e = new DefaultDocumentEvent</span>
<span class="nc" id="L1476">                                   (0, getLength(),</span>
                                    DocumentEvent.EventType.INSERT);
<span class="nc" id="L1478">                    updateBidi( e );</span>
                }
                finally {
<span class="nc" id="L1481">                    writeUnlock();</span>
<span class="nc" id="L1482">                }</span>
<span class="nc" id="L1483">            }</span>
        }, 0);
<span class="nc" id="L1485">    }</span>

    // ----- member variables ------------------------------------------

    private transient int numReaders;
    private transient Thread currWriter;
    /**
     * The number of writers, all obtained from &lt;code&gt;currWriter&lt;/code&gt;.
     */
    private transient int numWriters;
    /**
     * True will notifying listeners.
     */
    private transient boolean notifyingListeners;

    private static Boolean defaultI18NProperty;

    /**
     * Storage for document-wide properties.
     */
<span class="nc" id="L1505">    private Dictionary&lt;Object,Object&gt; documentProperties = null;</span>

    /**
     * The event listener list for the document.
     */
<span class="nc" id="L1510">    protected EventListenerList listenerList = new EventListenerList();</span>

    /**
     * Where the text is actually stored, and a set of marks
     * that track change as the document is edited are managed.
     */
    private Content data;

    /**
     * Factory for the attributes.  This is the strategy for
     * attribute compression and control of the lifetime of
     * a set of attributes as a collection.  This may be shared
     * with other documents.
     */
    private AttributeContext context;

    /**
     * The root of the bidirectional structure for this document.  Its children
     * represent character runs with the same Unicode bidi level.
     */
    private transient BranchElement bidiRoot;

    /**
     * Filter for inserting/removing of text.
     */
    private DocumentFilter documentFilter;

    /**
     * Used by DocumentFilter to do actual insert/remove.
     */
    private transient DocumentFilter.FilterBypass filterBypass;

    private static final String BAD_LOCK_STATE = &quot;document lock failure&quot;;

    /**
     * Error message to indicate a bad location.
     */
    protected static final String BAD_LOCATION = &quot;document location failure&quot;;

    /**
     * Name of elements used to represent paragraphs
     */
    public static final String ParagraphElementName = &quot;paragraph&quot;;

    /**
     * Name of elements used to represent content
     */
    public static final String ContentElementName = &quot;content&quot;;

    /**
     * Name of elements used to hold sections (lines/paragraphs).
     */
    public static final String SectionElementName = &quot;section&quot;;

    /**
     * Name of elements used to hold a unidirectional run
     */
    public static final String BidiElementName = &quot;bidi level&quot;;

    /**
     * Name of the attribute used to specify element
     * names.
     */
    public static final String ElementNameAttribute = &quot;$ename&quot;;

    /**
     * Document property that indicates whether internationalization
     * functions such as text reordering or reshaping should be
     * performed. This property should not be publicly exposed,
     * since it is used for implementation convenience only.  As a
     * side effect, copies of this property may be in its subclasses
     * that live in different packages (e.g. HTMLDocument as of now),
     * so those copies should also be taken care of when this property
     * needs to be modified.
     */
    static final String I18NProperty = &quot;i18n&quot;;

    /**
     * Document property that indicates if a character has been inserted
     * into the document that is more than one byte long.  GlyphView uses
     * this to determine if it should use BreakIterator.
     */
<span class="nc" id="L1592">    static final Object MultiByteProperty = &quot;multiByte&quot;;</span>

    /**
     * Document property that indicates asynchronous loading is
     * desired, with the thread priority given as the value.
     */
    static final String AsyncLoadPriority = &quot;load priority&quot;;

    /**
     * Interface to describe a sequence of character content that
     * can be edited.  Implementations may or may not support a
     * history mechanism which will be reflected by whether or not
     * mutations return an UndoableEdit implementation.
     * @see AbstractDocument
     */
    public interface Content {

        /**
         * Creates a position within the content that will
         * track change as the content is mutated.
         *
         * @param offset the offset in the content &amp;gt;= 0
         * @return a Position
         * @exception BadLocationException for an invalid offset
         */
        public Position createPosition(int offset) throws BadLocationException;

        /**
         * Current length of the sequence of character content.
         *
         * @return the length &amp;gt;= 0
         */
        public int length();

        /**
         * Inserts a string of characters into the sequence.
         *
         * @param where   offset into the sequence to make the insertion &amp;gt;= 0
         * @param str     string to insert
         * @return  if the implementation supports a history mechanism,
         *    a reference to an &lt;code&gt;Edit&lt;/code&gt; implementation will be returned,
         *    otherwise returns &lt;code&gt;null&lt;/code&gt;
         * @exception BadLocationException  thrown if the area covered by
         *   the arguments is not contained in the character sequence
         */
        public UndoableEdit insertString(int where, String str) throws BadLocationException;

        /**
         * Removes some portion of the sequence.
         *
         * @param where   The offset into the sequence to make the
         *   insertion &amp;gt;= 0.
         * @param nitems  The number of items in the sequence to remove &amp;gt;= 0.
         * @return  If the implementation supports a history mechanism,
         *    a reference to an Edit implementation will be returned,
         *    otherwise null.
         * @exception BadLocationException  Thrown if the area covered by
         *   the arguments is not contained in the character sequence.
         */
        public UndoableEdit remove(int where, int nitems) throws BadLocationException;

        /**
         * Fetches a string of characters contained in the sequence.
         *
         * @param where   Offset into the sequence to fetch &amp;gt;= 0.
         * @param len     number of characters to copy &amp;gt;= 0.
         * @return the string
         * @exception BadLocationException  Thrown if the area covered by
         *   the arguments is not contained in the character sequence.
         */
        public String getString(int where, int len) throws BadLocationException;

        /**
         * Gets a sequence of characters and copies them into a Segment.
         *
         * @param where the starting offset &amp;gt;= 0
         * @param len the number of characters &amp;gt;= 0
         * @param txt the target location to copy into
         * @exception BadLocationException  Thrown if the area covered by
         *   the arguments is not contained in the character sequence.
         */
        public void getChars(int where, int len, Segment txt) throws BadLocationException;
    }

    /**
     * An interface that can be used to allow MutableAttributeSet
     * implementations to use pluggable attribute compression
     * techniques.  Each mutation of the attribute set can be
     * used to exchange a previous AttributeSet instance with
     * another, preserving the possibility of the AttributeSet
     * remaining immutable.  An implementation is provided by
     * the StyleContext class.
     *
     * The Element implementations provided by this class use
     * this interface to provide their MutableAttributeSet
     * implementations, so that different AttributeSet compression
     * techniques can be employed.  The method
     * &lt;code&gt;getAttributeContext&lt;/code&gt; should be implemented to
     * return the object responsible for implementing the desired
     * compression technique.
     *
     * @see StyleContext
     */
    public interface AttributeContext {

        /**
         * Adds an attribute to the given set, and returns
         * the new representative set.
         *
         * @param old the old attribute set
         * @param name the non-null attribute name
         * @param value the attribute value
         * @return the updated attribute set
         * @see MutableAttributeSet#addAttribute
         */
        public AttributeSet addAttribute(AttributeSet old, Object name, Object value);

        /**
         * Adds a set of attributes to the element.
         *
         * @param old the old attribute set
         * @param attr the attributes to add
         * @return the updated attribute set
         * @see MutableAttributeSet#addAttribute
         */
        public AttributeSet addAttributes(AttributeSet old, AttributeSet attr);

        /**
         * Removes an attribute from the set.
         *
         * @param old the old attribute set
         * @param name the non-null attribute name
         * @return the updated attribute set
         * @see MutableAttributeSet#removeAttribute
         */
        public AttributeSet removeAttribute(AttributeSet old, Object name);

        /**
         * Removes a set of attributes for the element.
         *
         * @param old the old attribute set
         * @param names the attribute names
         * @return the updated attribute set
         * @see MutableAttributeSet#removeAttributes
         */
        public AttributeSet removeAttributes(AttributeSet old, Enumeration&lt;?&gt; names);

        /**
         * Removes a set of attributes for the element.
         *
         * @param old the old attribute set
         * @param attrs the attributes
         * @return the updated attribute set
         * @see MutableAttributeSet#removeAttributes
         */
        public AttributeSet removeAttributes(AttributeSet old, AttributeSet attrs);

        /**
         * Fetches an empty AttributeSet.
         *
         * @return the attribute set
         */
        public AttributeSet getEmptySet();

        /**
         * Reclaims an attribute set.
         * This is a way for a MutableAttributeSet to mark that it no
         * longer need a particular immutable set.  This is only necessary
         * in 1.1 where there are no weak references.  A 1.1 implementation
         * would call this in its finalize method.
         *
         * @param a the attribute set to reclaim
         */
        public void reclaim(AttributeSet a);
    }

    /**
     * Implements the abstract part of an element.  By default elements
     * support attributes by having a field that represents the immutable
     * part of the current attribute set for the element.  The element itself
     * implements MutableAttributeSet which can be used to modify the set
     * by fetching a new immutable set.  The immutable sets are provided
     * by the AttributeContext associated with the document.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    public abstract class AbstractElement implements Element, MutableAttributeSet, Serializable, TreeNode {

        /**
         * Creates a new AbstractElement.
         *
         * @param parent the parent element
         * @param a the attributes for the element
         * @since 1.4
         */
<span class="nc" id="L1794">        public AbstractElement(Element parent, AttributeSet a) {</span>
<span class="nc" id="L1795">            this.parent = parent;</span>
<span class="nc" id="L1796">            attributes = getAttributeContext().getEmptySet();</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">            if (a != null) {</span>
<span class="nc" id="L1798">                addAttributes(a);</span>
            }
<span class="nc" id="L1800">        }</span>

        private final void indent(PrintWriter out, int n) {
<span class="nc bnc" id="L1803" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L1804">                out.print(&quot;  &quot;);</span>
            }
<span class="nc" id="L1806">        }</span>

        /**
         * Dumps a debugging representation of the element hierarchy.
         *
         * @param psOut the output stream
         * @param indentAmount the indentation level &amp;gt;= 0
         */
        public void dump(PrintStream psOut, int indentAmount) {
            PrintWriter out;
            try {
<span class="nc" id="L1817">                out = new PrintWriter(new OutputStreamWriter(psOut,&quot;JavaEsc&quot;),</span>
                                      true);
<span class="nc" id="L1819">            } catch (UnsupportedEncodingException e){</span>
<span class="nc" id="L1820">                out = new PrintWriter(psOut,true);</span>
<span class="nc" id="L1821">            }</span>
<span class="nc" id="L1822">            indent(out, indentAmount);</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">            if (getName() == null) {</span>
<span class="nc" id="L1824">                out.print(&quot;&lt;??&quot;);</span>
            } else {
<span class="nc" id="L1826">                out.print(&quot;&lt;&quot; + getName());</span>
            }
<span class="nc bnc" id="L1828" title="All 2 branches missed.">            if (getAttributeCount() &gt; 0) {</span>
<span class="nc" id="L1829">                out.println(&quot;&quot;);</span>
                // dump the attributes
<span class="nc" id="L1831">                Enumeration names = attributes.getAttributeNames();</span>
<span class="nc bnc" id="L1832" title="All 2 branches missed.">                while (names.hasMoreElements()) {</span>
<span class="nc" id="L1833">                    Object name = names.nextElement();</span>
<span class="nc" id="L1834">                    indent(out, indentAmount + 1);</span>
<span class="nc" id="L1835">                    out.println(name + &quot;=&quot; + getAttribute(name));</span>
<span class="nc" id="L1836">                }</span>
<span class="nc" id="L1837">                indent(out, indentAmount);</span>
            }
<span class="nc" id="L1839">            out.println(&quot;&gt;&quot;);</span>

<span class="nc bnc" id="L1841" title="All 2 branches missed.">            if (isLeaf()) {</span>
<span class="nc" id="L1842">                indent(out, indentAmount+1);</span>
<span class="nc" id="L1843">                out.print(&quot;[&quot; + getStartOffset() + &quot;,&quot; + getEndOffset() + &quot;]&quot;);</span>
<span class="nc" id="L1844">                Content c = getContent();</span>
                try {
<span class="nc" id="L1846">                    String contentStr = c.getString(getStartOffset(),</span>
<span class="nc" id="L1847">                                                    getEndOffset() - getStartOffset())/*.trim()*/;</span>
<span class="nc bnc" id="L1848" title="All 2 branches missed.">                    if (contentStr.length() &gt; 40) {</span>
<span class="nc" id="L1849">                        contentStr = contentStr.substring(0, 40) + &quot;...&quot;;</span>
                    }
<span class="nc" id="L1851">                    out.println(&quot;[&quot;+contentStr+&quot;]&quot;);</span>
<span class="nc" id="L1852">                } catch (BadLocationException e) {</span>
<span class="nc" id="L1853">                }</span>

<span class="nc" id="L1855">            } else {</span>
<span class="nc" id="L1856">                int n = getElementCount();</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L1858">                    AbstractElement e = (AbstractElement) getElement(i);</span>
<span class="nc" id="L1859">                    e.dump(psOut, indentAmount+1);</span>
                }
            }
<span class="nc" id="L1862">        }</span>

        // --- AttributeSet ----------------------------
        // delegated to the immutable field &quot;attributes&quot;

        /**
         * Gets the number of attributes that are defined.
         *
         * @return the number of attributes &amp;gt;= 0
         * @see AttributeSet#getAttributeCount
         */
        public int getAttributeCount() {
<span class="nc" id="L1874">            return attributes.getAttributeCount();</span>
        }

        /**
         * Checks whether a given attribute is defined.
         *
         * @param attrName the non-null attribute name
         * @return true if the attribute is defined
         * @see AttributeSet#isDefined
         */
        public boolean isDefined(Object attrName) {
<span class="nc" id="L1885">            return attributes.isDefined(attrName);</span>
        }

        /**
         * Checks whether two attribute sets are equal.
         *
         * @param attr the attribute set to check against
         * @return true if the same
         * @see AttributeSet#isEqual
         */
        public boolean isEqual(AttributeSet attr) {
<span class="nc" id="L1896">            return attributes.isEqual(attr);</span>
        }

        /**
         * Copies a set of attributes.
         *
         * @return the copy
         * @see AttributeSet#copyAttributes
         */
        public AttributeSet copyAttributes() {
<span class="nc" id="L1906">            return attributes.copyAttributes();</span>
        }

        /**
         * Gets the value of an attribute.
         *
         * @param attrName the non-null attribute name
         * @return the attribute value
         * @see AttributeSet#getAttribute
         */
        public Object getAttribute(Object attrName) {
<span class="nc" id="L1917">            Object value = attributes.getAttribute(attrName);</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">            if (value == null) {</span>
                // The delegate nor it's resolvers had a match,
                // so we'll try to resolve through the parent
                // element.
<span class="nc bnc" id="L1922" title="All 2 branches missed.">                AttributeSet a = (parent != null) ? parent.getAttributes() : null;</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">                if (a != null) {</span>
<span class="nc" id="L1924">                    value = a.getAttribute(attrName);</span>
                }
            }
<span class="nc" id="L1927">            return value;</span>
        }

        /**
         * Gets the names of all attributes.
         *
         * @return the attribute names as an enumeration
         * @see AttributeSet#getAttributeNames
         */
        public Enumeration&lt;?&gt; getAttributeNames() {
<span class="nc" id="L1937">            return attributes.getAttributeNames();</span>
        }

        /**
         * Checks whether a given attribute name/value is defined.
         *
         * @param name the non-null attribute name
         * @param value the attribute value
         * @return true if the name/value is defined
         * @see AttributeSet#containsAttribute
         */
        public boolean containsAttribute(Object name, Object value) {
<span class="nc" id="L1949">            return attributes.containsAttribute(name, value);</span>
        }


        /**
         * Checks whether the element contains all the attributes.
         *
         * @param attrs the attributes to check
         * @return true if the element contains all the attributes
         * @see AttributeSet#containsAttributes
         */
        public boolean containsAttributes(AttributeSet attrs) {
<span class="nc" id="L1961">            return attributes.containsAttributes(attrs);</span>
        }

        /**
         * Gets the resolving parent.
         * If not overridden, the resolving parent defaults to
         * the parent element.
         *
         * @return the attributes from the parent, &lt;code&gt;null&lt;/code&gt; if none
         * @see AttributeSet#getResolveParent
         */
        public AttributeSet getResolveParent() {
<span class="nc" id="L1973">            AttributeSet a = attributes.getResolveParent();</span>
<span class="nc bnc" id="L1974" title="All 4 branches missed.">            if ((a == null) &amp;&amp; (parent != null)) {</span>
<span class="nc" id="L1975">                a = parent.getAttributes();</span>
            }
<span class="nc" id="L1977">            return a;</span>
        }

        // --- MutableAttributeSet ----------------------------------
        // should fetch a new immutable record for the field
        // &quot;attributes&quot;.

        /**
         * Adds an attribute to the element.
         *
         * @param name the non-null attribute name
         * @param value the attribute value
         * @see MutableAttributeSet#addAttribute
         */
        public void addAttribute(Object name, Object value) {
<span class="nc" id="L1992">            checkForIllegalCast();</span>
<span class="nc" id="L1993">            AttributeContext context = getAttributeContext();</span>
<span class="nc" id="L1994">            attributes = context.addAttribute(attributes, name, value);</span>
<span class="nc" id="L1995">        }</span>

        /**
         * Adds a set of attributes to the element.
         *
         * @param attr the attributes to add
         * @see MutableAttributeSet#addAttribute
         */
        public void addAttributes(AttributeSet attr) {
<span class="nc" id="L2004">            checkForIllegalCast();</span>
<span class="nc" id="L2005">            AttributeContext context = getAttributeContext();</span>
<span class="nc" id="L2006">            attributes = context.addAttributes(attributes, attr);</span>
<span class="nc" id="L2007">        }</span>

        /**
         * Removes an attribute from the set.
         *
         * @param name the non-null attribute name
         * @see MutableAttributeSet#removeAttribute
         */
        public void removeAttribute(Object name) {
<span class="nc" id="L2016">            checkForIllegalCast();</span>
<span class="nc" id="L2017">            AttributeContext context = getAttributeContext();</span>
<span class="nc" id="L2018">            attributes = context.removeAttribute(attributes, name);</span>
<span class="nc" id="L2019">        }</span>

        /**
         * Removes a set of attributes for the element.
         *
         * @param names the attribute names
         * @see MutableAttributeSet#removeAttributes
         */
        public void removeAttributes(Enumeration&lt;?&gt; names) {
<span class="nc" id="L2028">            checkForIllegalCast();</span>
<span class="nc" id="L2029">            AttributeContext context = getAttributeContext();</span>
<span class="nc" id="L2030">            attributes = context.removeAttributes(attributes, names);</span>
<span class="nc" id="L2031">        }</span>

        /**
         * Removes a set of attributes for the element.
         *
         * @param attrs the attributes
         * @see MutableAttributeSet#removeAttributes
         */
        public void removeAttributes(AttributeSet attrs) {
<span class="nc" id="L2040">            checkForIllegalCast();</span>
<span class="nc" id="L2041">            AttributeContext context = getAttributeContext();</span>
<span class="nc bnc" id="L2042" title="All 2 branches missed.">            if (attrs == this) {</span>
<span class="nc" id="L2043">                attributes = context.getEmptySet();</span>
            } else {
<span class="nc" id="L2045">                attributes = context.removeAttributes(attributes, attrs);</span>
            }
<span class="nc" id="L2047">        }</span>

        /**
         * Sets the resolving parent.
         *
         * @param parent the parent, null if none
         * @see MutableAttributeSet#setResolveParent
         */
        public void setResolveParent(AttributeSet parent) {
<span class="nc" id="L2056">            checkForIllegalCast();</span>
<span class="nc" id="L2057">            AttributeContext context = getAttributeContext();</span>
<span class="nc bnc" id="L2058" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L2059">                attributes =</span>
<span class="nc" id="L2060">                    context.addAttribute(attributes, StyleConstants.ResolveAttribute,</span>
                                         parent);
            } else {
<span class="nc" id="L2063">                attributes =</span>
<span class="nc" id="L2064">                    context.removeAttribute(attributes, StyleConstants.ResolveAttribute);</span>
            }
<span class="nc" id="L2066">        }</span>

        private final void checkForIllegalCast() {
<span class="nc" id="L2069">            Thread t = getCurrentWriter();</span>
<span class="nc bnc" id="L2070" title="All 4 branches missed.">            if ((t == null) || (t != Thread.currentThread())) {</span>
<span class="nc" id="L2071">                throw new StateInvariantError(&quot;Illegal cast to MutableAttributeSet&quot;);</span>
            }
<span class="nc" id="L2073">        }</span>

        // --- Element methods -------------------------------------

        /**
         * Retrieves the underlying model.
         *
         * @return the model
         */
        public Document getDocument() {
<span class="nc" id="L2083">            return AbstractDocument.this;</span>
        }

        /**
         * Gets the parent of the element.
         *
         * @return the parent
         */
        public Element getParentElement() {
<span class="nc" id="L2092">            return parent;</span>
        }

        /**
         * Gets the attributes for the element.
         *
         * @return the attribute set
         */
        public AttributeSet getAttributes() {
<span class="nc" id="L2101">            return this;</span>
        }

        /**
         * Gets the name of the element.
         *
         * @return the name, null if none
         */
        public String getName() {
<span class="nc bnc" id="L2110" title="All 2 branches missed.">            if (attributes.isDefined(ElementNameAttribute)) {</span>
<span class="nc" id="L2111">                return (String) attributes.getAttribute(ElementNameAttribute);</span>
            }
<span class="nc" id="L2113">            return null;</span>
        }

        /**
         * Gets the starting offset in the model for the element.
         *
         * @return the offset &amp;gt;= 0
         */
        public abstract int getStartOffset();

        /**
         * Gets the ending offset in the model for the element.
         *
         * @return the offset &amp;gt;= 0
         */
        public abstract int getEndOffset();

        /**
         * Gets a child element.
         *
         * @param index the child index, &amp;gt;= 0 &amp;amp;&amp;amp; &amp;lt; getElementCount()
         * @return the child element
         */
        public abstract Element getElement(int index);

        /**
         * Gets the number of children for the element.
         *
         * @return the number of children &amp;gt;= 0
         */
        public abstract int getElementCount();

        /**
         * Gets the child element index closest to the given model offset.
         *
         * @param offset the offset &amp;gt;= 0
         * @return the element index &amp;gt;= 0
         */
        public abstract int getElementIndex(int offset);

        /**
         * Checks whether the element is a leaf.
         *
         * @return true if a leaf
         */
        public abstract boolean isLeaf();

        // --- TreeNode methods -------------------------------------

        /**
         * Returns the child &lt;code&gt;TreeNode&lt;/code&gt; at index
         * &lt;code&gt;childIndex&lt;/code&gt;.
         */
        public TreeNode getChildAt(int childIndex) {
<span class="nc" id="L2167">            return (TreeNode)getElement(childIndex);</span>
        }

        /**
         * Returns the number of children &lt;code&gt;TreeNode&lt;/code&gt;'s
         * receiver contains.
         * @return the number of children &lt;code&gt;TreeNodews&lt;/code&gt;'s
         * receiver contains
         */
        public int getChildCount() {
<span class="nc" id="L2177">            return getElementCount();</span>
        }

        /**
         * Returns the parent &lt;code&gt;TreeNode&lt;/code&gt; of the receiver.
         * @return the parent &lt;code&gt;TreeNode&lt;/code&gt; of the receiver
         */
        public TreeNode getParent() {
<span class="nc" id="L2185">            return (TreeNode)getParentElement();</span>
        }

        /**
         * Returns the index of &lt;code&gt;node&lt;/code&gt; in the receivers children.
         * If the receiver does not contain &lt;code&gt;node&lt;/code&gt;, -1 will be
         * returned.
         * @param node the location of interest
         * @return the index of &lt;code&gt;node&lt;/code&gt; in the receiver's
         * children, or -1 if absent
         */
        public int getIndex(TreeNode node) {
<span class="nc bnc" id="L2197" title="All 2 branches missed.">            for(int counter = getChildCount() - 1; counter &gt;= 0; counter--)</span>
<span class="nc bnc" id="L2198" title="All 2 branches missed.">                if(getChildAt(counter) == node)</span>
<span class="nc" id="L2199">                    return counter;</span>
<span class="nc" id="L2200">            return -1;</span>
        }

        /**
         * Returns true if the receiver allows children.
         * @return true if the receiver allows children, otherwise false
         */
        public abstract boolean getAllowsChildren();


        /**
         * Returns the children of the receiver as an
         * &lt;code&gt;Enumeration&lt;/code&gt;.
         * @return the children of the receiver as an &lt;code&gt;Enumeration&lt;/code&gt;
         */
        public abstract Enumeration children();


        // --- serialization ---------------------------------------------

        private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L2221">            s.defaultWriteObject();</span>
<span class="nc" id="L2222">            StyleContext.writeAttributeSet(s, attributes);</span>
<span class="nc" id="L2223">        }</span>

        private void readObject(ObjectInputStream s)
            throws ClassNotFoundException, IOException
        {
<span class="nc" id="L2228">            s.defaultReadObject();</span>
<span class="nc" id="L2229">            MutableAttributeSet attr = new SimpleAttributeSet();</span>
<span class="nc" id="L2230">            StyleContext.readAttributeSet(s, attr);</span>
<span class="nc" id="L2231">            AttributeContext context = getAttributeContext();</span>
<span class="nc" id="L2232">            attributes = context.addAttributes(SimpleAttributeSet.EMPTY, attr);</span>
<span class="nc" id="L2233">        }</span>

        // ---- variables -----------------------------------------------------

        private Element parent;
        private transient AttributeSet attributes;

    }

    /**
     * Implements a composite element that contains other elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    public class BranchElement extends AbstractElement {

        /**
         * Constructs a composite element that initially contains
         * no children.
         *
         * @param parent  The parent element
         * @param a the attributes for the element
         * @since 1.4
         */
<span class="nc" id="L2264">        public BranchElement(Element parent, AttributeSet a) {</span>
<span class="nc" id="L2265">            super(parent, a);</span>
<span class="nc" id="L2266">            children = new AbstractElement[1];</span>
<span class="nc" id="L2267">            nchildren = 0;</span>
<span class="nc" id="L2268">            lastIndex = -1;</span>
<span class="nc" id="L2269">        }</span>

        /**
         * Gets the child element that contains
         * the given model position.
         *
         * @param pos the position &amp;gt;= 0
         * @return the element, null if none
         */
        public Element positionToElement(int pos) {
<span class="nc" id="L2279">            int index = getElementIndex(pos);</span>
<span class="nc" id="L2280">            Element child = children[index];</span>
<span class="nc" id="L2281">            int p0 = child.getStartOffset();</span>
<span class="nc" id="L2282">            int p1 = child.getEndOffset();</span>
<span class="nc bnc" id="L2283" title="All 4 branches missed.">            if ((pos &gt;= p0) &amp;&amp; (pos &lt; p1)) {</span>
<span class="nc" id="L2284">                return child;</span>
            }
<span class="nc" id="L2286">            return null;</span>
        }

        /**
         * Replaces content with a new set of elements.
         *
         * @param offset the starting offset &amp;gt;= 0
         * @param length the length to replace &amp;gt;= 0
         * @param elems the new elements
         */
        public void replace(int offset, int length, Element[] elems) {
<span class="nc" id="L2297">            int delta = elems.length - length;</span>
<span class="nc" id="L2298">            int src = offset + length;</span>
<span class="nc" id="L2299">            int nmove = nchildren - src;</span>
<span class="nc" id="L2300">            int dest = src + delta;</span>
<span class="nc bnc" id="L2301" title="All 2 branches missed.">            if ((nchildren + delta) &gt;= children.length) {</span>
                // need to grow the array
<span class="nc" id="L2303">                int newLength = Math.max(2*children.length, nchildren + delta);</span>
<span class="nc" id="L2304">                AbstractElement[] newChildren = new AbstractElement[newLength];</span>
<span class="nc" id="L2305">                System.arraycopy(children, 0, newChildren, 0, offset);</span>
<span class="nc" id="L2306">                System.arraycopy(elems, 0, newChildren, offset, elems.length);</span>
<span class="nc" id="L2307">                System.arraycopy(children, src, newChildren, dest, nmove);</span>
<span class="nc" id="L2308">                children = newChildren;</span>
<span class="nc" id="L2309">            } else {</span>
                // patch the existing array
<span class="nc" id="L2311">                System.arraycopy(children, src, children, dest, nmove);</span>
<span class="nc" id="L2312">                System.arraycopy(elems, 0, children, offset, elems.length);</span>
            }
<span class="nc" id="L2314">            nchildren = nchildren + delta;</span>
<span class="nc" id="L2315">        }</span>

        /**
         * Converts the element to a string.
         *
         * @return the string
         */
        public String toString() {
<span class="nc" id="L2323">            return &quot;BranchElement(&quot; + getName() + &quot;) &quot; + getStartOffset() + &quot;,&quot; +</span>
<span class="nc" id="L2324">                getEndOffset() + &quot;\n&quot;;</span>
        }

        // --- Element methods -----------------------------------

        /**
         * Gets the element name.
         *
         * @return the element name
         */
        public String getName() {
<span class="nc" id="L2335">            String nm = super.getName();</span>
<span class="nc bnc" id="L2336" title="All 2 branches missed.">            if (nm == null) {</span>
<span class="nc" id="L2337">                nm = ParagraphElementName;</span>
            }
<span class="nc" id="L2339">            return nm;</span>
        }

        /**
         * Gets the starting offset in the model for the element.
         *
         * @return the offset &amp;gt;= 0
         */
        public int getStartOffset() {
<span class="nc" id="L2348">            return children[0].getStartOffset();</span>
        }

        /**
         * Gets the ending offset in the model for the element.
         * @throws NullPointerException if this element has no children
         *
         * @return the offset &amp;gt;= 0
         */
        public int getEndOffset() {
<span class="nc bnc" id="L2358" title="All 2 branches missed.">            Element child =</span>
                (nchildren &gt; 0) ? children[nchildren - 1] : children[0];
<span class="nc" id="L2360">            return child.getEndOffset();</span>
        }

        /**
         * Gets a child element.
         *
         * @param index the child index, &amp;gt;= 0 &amp;amp;&amp;amp; &amp;lt; getElementCount()
         * @return the child element, null if none
         */
        public Element getElement(int index) {
<span class="nc bnc" id="L2370" title="All 2 branches missed.">            if (index &lt; nchildren) {</span>
<span class="nc" id="L2371">                return children[index];</span>
            }
<span class="nc" id="L2373">            return null;</span>
        }

        /**
         * Gets the number of children for the element.
         *
         * @return the number of children &amp;gt;= 0
         */
        public int getElementCount()  {
<span class="nc" id="L2382">            return nchildren;</span>
        }

        /**
         * Gets the child element index closest to the given model offset.
         *
         * @param offset the offset &amp;gt;= 0
         * @return the element index &amp;gt;= 0
         */
        public int getElementIndex(int offset) {
            int index;
<span class="nc" id="L2393">            int lower = 0;</span>
<span class="nc" id="L2394">            int upper = nchildren - 1;</span>
<span class="nc" id="L2395">            int mid = 0;</span>
<span class="nc" id="L2396">            int p0 = getStartOffset();</span>
            int p1;

<span class="nc bnc" id="L2399" title="All 2 branches missed.">            if (nchildren == 0) {</span>
<span class="nc" id="L2400">                return 0;</span>
            }
<span class="nc bnc" id="L2402" title="All 2 branches missed.">            if (offset &gt;= getEndOffset()) {</span>
<span class="nc" id="L2403">                return nchildren - 1;</span>
            }

            // see if the last index can be used.
<span class="nc bnc" id="L2407" title="All 4 branches missed.">            if ((lastIndex &gt;= lower) &amp;&amp; (lastIndex &lt;= upper)) {</span>
<span class="nc" id="L2408">                Element lastHit = children[lastIndex];</span>
<span class="nc" id="L2409">                p0 = lastHit.getStartOffset();</span>
<span class="nc" id="L2410">                p1 = lastHit.getEndOffset();</span>
<span class="nc bnc" id="L2411" title="All 4 branches missed.">                if ((offset &gt;= p0) &amp;&amp; (offset &lt; p1)) {</span>
<span class="nc" id="L2412">                    return lastIndex;</span>
                }

                // last index wasn't a hit, but it does give useful info about
                // where a hit (if any) would be.
<span class="nc bnc" id="L2417" title="All 2 branches missed.">                if (offset &lt; p0) {</span>
<span class="nc" id="L2418">                    upper = lastIndex;</span>
                } else  {
<span class="nc" id="L2420">                    lower = lastIndex;</span>
                }
            }

<span class="nc bnc" id="L2424" title="All 2 branches missed.">            while (lower &lt;= upper) {</span>
<span class="nc" id="L2425">                mid = lower + ((upper - lower) / 2);</span>
<span class="nc" id="L2426">                Element elem = children[mid];</span>
<span class="nc" id="L2427">                p0 = elem.getStartOffset();</span>
<span class="nc" id="L2428">                p1 = elem.getEndOffset();</span>
<span class="nc bnc" id="L2429" title="All 4 branches missed.">                if ((offset &gt;= p0) &amp;&amp; (offset &lt; p1)) {</span>
                    // found the location
<span class="nc" id="L2431">                    index = mid;</span>
<span class="nc" id="L2432">                    lastIndex = index;</span>
<span class="nc" id="L2433">                    return index;</span>
<span class="nc bnc" id="L2434" title="All 2 branches missed.">                } else if (offset &lt; p0) {</span>
<span class="nc" id="L2435">                    upper = mid - 1;</span>
                } else {
<span class="nc" id="L2437">                    lower = mid + 1;</span>
                }
<span class="nc" id="L2439">            }</span>

            // didn't find it, but we indicate the index of where it would belong
<span class="nc bnc" id="L2442" title="All 2 branches missed.">            if (offset &lt; p0) {</span>
<span class="nc" id="L2443">                index = mid;</span>
            } else {
<span class="nc" id="L2445">                index = mid + 1;</span>
            }
<span class="nc" id="L2447">            lastIndex = index;</span>
<span class="nc" id="L2448">            return index;</span>
        }

        /**
         * Checks whether the element is a leaf.
         *
         * @return true if a leaf
         */
        public boolean isLeaf() {
<span class="nc" id="L2457">            return false;</span>
        }


        // ------ TreeNode ----------------------------------------------

        /**
         * Returns true if the receiver allows children.
         * @return true if the receiver allows children, otherwise false
         */
        public boolean getAllowsChildren() {
<span class="nc" id="L2468">            return true;</span>
        }


        /**
         * Returns the children of the receiver as an
         * &lt;code&gt;Enumeration&lt;/code&gt;.
         * @return the children of the receiver
         */
        public Enumeration children() {
<span class="nc bnc" id="L2478" title="All 2 branches missed.">            if(nchildren == 0)</span>
<span class="nc" id="L2479">                return null;</span>

<span class="nc" id="L2481">            Vector&lt;AbstractElement&gt; tempVector = new Vector&lt;AbstractElement&gt;(nchildren);</span>

<span class="nc bnc" id="L2483" title="All 2 branches missed.">            for(int counter = 0; counter &lt; nchildren; counter++)</span>
<span class="nc" id="L2484">                tempVector.addElement(children[counter]);</span>
<span class="nc" id="L2485">            return tempVector.elements();</span>
        }

        // ------ members ----------------------------------------------

        private AbstractElement[] children;
        private int nchildren;
        private int lastIndex;
    }

    /**
     * Implements an element that directly represents content of
     * some kind.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     *
     * @see     Element
     */
    public class LeafElement extends AbstractElement {

        /**
         * Constructs an element that represents content within the
         * document (has no children).
         *
         * @param parent  The parent element
         * @param a       The element attributes
         * @param offs0   The start offset &amp;gt;= 0
         * @param offs1   The end offset &amp;gt;= offs0
         * @since 1.4
         */
<span class="nc" id="L2522">        public LeafElement(Element parent, AttributeSet a, int offs0, int offs1) {</span>
<span class="nc" id="L2523">            super(parent, a);</span>
            try {
<span class="nc" id="L2525">                p0 = createPosition(offs0);</span>
<span class="nc" id="L2526">                p1 = createPosition(offs1);</span>
<span class="nc" id="L2527">            } catch (BadLocationException e) {</span>
<span class="nc" id="L2528">                p0 = null;</span>
<span class="nc" id="L2529">                p1 = null;</span>
<span class="nc" id="L2530">                throw new StateInvariantError(&quot;Can't create Position references&quot;);</span>
<span class="nc" id="L2531">            }</span>
<span class="nc" id="L2532">        }</span>

        /**
         * Converts the element to a string.
         *
         * @return the string
         */
        public String toString() {
<span class="nc" id="L2540">            return &quot;LeafElement(&quot; + getName() + &quot;) &quot; + p0 + &quot;,&quot; + p1 + &quot;\n&quot;;</span>
        }

        // --- Element methods ---------------------------------------------

        /**
         * Gets the starting offset in the model for the element.
         *
         * @return the offset &amp;gt;= 0
         */
        public int getStartOffset() {
<span class="nc" id="L2551">            return p0.getOffset();</span>
        }

        /**
         * Gets the ending offset in the model for the element.
         *
         * @return the offset &amp;gt;= 0
         */
        public int getEndOffset() {
<span class="nc" id="L2560">            return p1.getOffset();</span>
        }

        /**
         * Gets the element name.
         *
         * @return the name
         */
        public String getName() {
<span class="nc" id="L2569">            String nm = super.getName();</span>
<span class="nc bnc" id="L2570" title="All 2 branches missed.">            if (nm == null) {</span>
<span class="nc" id="L2571">                nm = ContentElementName;</span>
            }
<span class="nc" id="L2573">            return nm;</span>
        }

        /**
         * Gets the child element index closest to the given model offset.
         *
         * @param pos the offset &amp;gt;= 0
         * @return the element index &amp;gt;= 0
         */
        public int getElementIndex(int pos) {
<span class="nc" id="L2583">            return -1;</span>
        }

        /**
         * Gets a child element.
         *
         * @param index the child index, &amp;gt;= 0 &amp;amp;&amp;amp; &amp;lt; getElementCount()
         * @return the child element
         */
        public Element getElement(int index) {
<span class="nc" id="L2593">            return null;</span>
        }

        /**
         * Returns the number of child elements.
         *
         * @return the number of children &amp;gt;= 0
         */
        public int getElementCount()  {
<span class="nc" id="L2602">            return 0;</span>
        }

        /**
         * Checks whether the element is a leaf.
         *
         * @return true if a leaf
         */
        public boolean isLeaf() {
<span class="nc" id="L2611">            return true;</span>
        }

        // ------ TreeNode ----------------------------------------------

        /**
         * Returns true if the receiver allows children.
         * @return true if the receiver allows children, otherwise false
         */
        public boolean getAllowsChildren() {
<span class="nc" id="L2621">            return false;</span>
        }


        /**
         * Returns the children of the receiver as an
         * &lt;code&gt;Enumeration&lt;/code&gt;.
         * @return the children of the receiver
         */
        public Enumeration children() {
<span class="nc" id="L2631">            return null;</span>
        }

        // --- serialization ---------------------------------------------

        private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L2637">            s.defaultWriteObject();</span>
<span class="nc" id="L2638">            s.writeInt(p0.getOffset());</span>
<span class="nc" id="L2639">            s.writeInt(p1.getOffset());</span>
<span class="nc" id="L2640">        }</span>

        private void readObject(ObjectInputStream s)
            throws ClassNotFoundException, IOException
        {
<span class="nc" id="L2645">            s.defaultReadObject();</span>

            // set the range with positions that track change
<span class="nc" id="L2648">            int off0 = s.readInt();</span>
<span class="nc" id="L2649">            int off1 = s.readInt();</span>
            try {
<span class="nc" id="L2651">                p0 = createPosition(off0);</span>
<span class="nc" id="L2652">                p1 = createPosition(off1);</span>
<span class="nc" id="L2653">            } catch (BadLocationException e) {</span>
<span class="nc" id="L2654">                p0 = null;</span>
<span class="nc" id="L2655">                p1 = null;</span>
<span class="nc" id="L2656">                throw new IOException(&quot;Can't restore Position references&quot;);</span>
<span class="nc" id="L2657">            }</span>
<span class="nc" id="L2658">        }</span>

        // ---- members -----------------------------------------------------

        private transient Position p0;
        private transient Position p1;
    }

    /**
     * Represents the root element of the bidirectional element structure.
     * The root element is the only element in the bidi element structure
     * which contains children.
     */
    class BidiRootElement extends BranchElement {

<span class="nc" id="L2673">        BidiRootElement() {</span>
<span class="nc" id="L2674">            super( null, null );</span>
<span class="nc" id="L2675">        }</span>

        /**
         * Gets the name of the element.
         * @return the name
         */
        public String getName() {
<span class="nc" id="L2682">            return &quot;bidi root&quot;;</span>
        }
    }

    /**
     * Represents an element of the bidirectional element structure.
     */
    class BidiElement extends LeafElement {

        /**
         * Creates a new BidiElement.
         */
<span class="nc" id="L2694">        BidiElement(Element parent, int start, int end, int level) {</span>
<span class="nc" id="L2695">            super(parent, new SimpleAttributeSet(), start, end);</span>
<span class="nc" id="L2696">            addAttribute(StyleConstants.BidiLevel, Integer.valueOf(level));</span>
            //System.out.println(&quot;BidiElement: start = &quot; + start
            //                   + &quot; end = &quot; + end + &quot; level = &quot; + level );
<span class="nc" id="L2699">        }</span>

        /**
         * Gets the name of the element.
         * @return the name
         */
        public String getName() {
<span class="nc" id="L2706">            return BidiElementName;</span>
        }

        int getLevel() {
<span class="nc" id="L2710">            Integer o = (Integer) getAttribute(StyleConstants.BidiLevel);</span>
<span class="nc bnc" id="L2711" title="All 2 branches missed.">            if (o != null) {</span>
<span class="nc" id="L2712">                return o.intValue();</span>
            }
<span class="nc" id="L2714">            return 0;  // Level 0 is base level (non-embedded) left-to-right</span>
        }

        boolean isLeftToRight() {
<span class="nc bnc" id="L2718" title="All 2 branches missed.">            return ((getLevel() % 2) == 0);</span>
        }
    }

    /**
     * Stores document changes as the document is being
     * modified.  Can subsequently be used for change notification
     * when done with the document modification transaction.
     * This is used by the AbstractDocument class and its extensions
     * for broadcasting change information to the document listeners.
     */
    public class DefaultDocumentEvent extends CompoundEdit implements DocumentEvent {

        /**
         * Constructs a change record.
         *
         * @param offs the offset into the document of the change &amp;gt;= 0
         * @param len  the length of the change &amp;gt;= 0
         * @param type the type of event (DocumentEvent.EventType)
         * @since 1.4
         */
<span class="nc" id="L2739">        public DefaultDocumentEvent(int offs, int len, DocumentEvent.EventType type) {</span>
<span class="nc" id="L2740">            super();</span>
<span class="nc" id="L2741">            offset = offs;</span>
<span class="nc" id="L2742">            length = len;</span>
<span class="nc" id="L2743">            this.type = type;</span>
<span class="nc" id="L2744">        }</span>

        /**
         * Returns a string description of the change event.
         *
         * @return a string
         */
        public String toString() {
<span class="nc" id="L2752">            return edits.toString();</span>
        }

        // --- CompoundEdit methods --------------------------

        /**
         * Adds a document edit.  If the number of edits crosses
         * a threshold, this switches on a hashtable lookup for
         * ElementChange implementations since access of these
         * needs to be relatively quick.
         *
         * @param anEdit a document edit record
         * @return true if the edit was added
         */
        public boolean addEdit(UndoableEdit anEdit) {
            // if the number of changes gets too great, start using
            // a hashtable for to locate the change for a given element.
<span class="nc bnc" id="L2769" title="All 4 branches missed.">            if ((changeLookup == null) &amp;&amp; (edits.size() &gt; 10)) {</span>
<span class="nc" id="L2770">                changeLookup = new Hashtable&lt;Element, ElementChange&gt;();</span>
<span class="nc" id="L2771">                int n = edits.size();</span>
<span class="nc bnc" id="L2772" title="All 2 branches missed.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L2773">                    Object o = edits.elementAt(i);</span>
<span class="nc bnc" id="L2774" title="All 2 branches missed.">                    if (o instanceof DocumentEvent.ElementChange) {</span>
<span class="nc" id="L2775">                        DocumentEvent.ElementChange ec = (DocumentEvent.ElementChange) o;</span>
<span class="nc" id="L2776">                        changeLookup.put(ec.getElement(), ec);</span>
                    }
                }
            }

            // if we have a hashtable... add the entry if it's
            // an ElementChange.
<span class="nc bnc" id="L2783" title="All 4 branches missed.">            if ((changeLookup != null) &amp;&amp; (anEdit instanceof DocumentEvent.ElementChange)) {</span>
<span class="nc" id="L2784">                DocumentEvent.ElementChange ec = (DocumentEvent.ElementChange) anEdit;</span>
<span class="nc" id="L2785">                changeLookup.put(ec.getElement(), ec);</span>
            }
<span class="nc" id="L2787">            return super.addEdit(anEdit);</span>
        }

        /**
         * Redoes a change.
         *
         * @exception CannotRedoException if the change cannot be redone
         */
        public void redo() throws CannotRedoException {
<span class="nc" id="L2796">            writeLock();</span>
            try {
                // change the state
<span class="nc" id="L2799">                super.redo();</span>
                // fire a DocumentEvent to notify the view(s)
<span class="nc" id="L2801">                UndoRedoDocumentEvent ev = new UndoRedoDocumentEvent(this, false);</span>
<span class="nc bnc" id="L2802" title="All 2 branches missed.">                if (type == DocumentEvent.EventType.INSERT) {</span>
<span class="nc" id="L2803">                    fireInsertUpdate(ev);</span>
<span class="nc bnc" id="L2804" title="All 2 branches missed.">                } else if (type == DocumentEvent.EventType.REMOVE) {</span>
<span class="nc" id="L2805">                    fireRemoveUpdate(ev);</span>
                } else {
<span class="nc" id="L2807">                    fireChangedUpdate(ev);</span>
                }
            } finally {
<span class="nc" id="L2810">                writeUnlock();</span>
<span class="nc" id="L2811">            }</span>
<span class="nc" id="L2812">        }</span>

        /**
         * Undoes a change.
         *
         * @exception CannotUndoException if the change cannot be undone
         */
        public void undo() throws CannotUndoException {
<span class="nc" id="L2820">            writeLock();</span>
            try {
                // change the state
<span class="nc" id="L2823">                super.undo();</span>
                // fire a DocumentEvent to notify the view(s)
<span class="nc" id="L2825">                UndoRedoDocumentEvent ev = new UndoRedoDocumentEvent(this, true);</span>
<span class="nc bnc" id="L2826" title="All 2 branches missed.">                if (type == DocumentEvent.EventType.REMOVE) {</span>
<span class="nc" id="L2827">                    fireInsertUpdate(ev);</span>
<span class="nc bnc" id="L2828" title="All 2 branches missed.">                } else if (type == DocumentEvent.EventType.INSERT) {</span>
<span class="nc" id="L2829">                    fireRemoveUpdate(ev);</span>
                } else {
<span class="nc" id="L2831">                    fireChangedUpdate(ev);</span>
                }
            } finally {
<span class="nc" id="L2834">                writeUnlock();</span>
<span class="nc" id="L2835">            }</span>
<span class="nc" id="L2836">        }</span>

        /**
         * DefaultDocument events are significant.  If you wish to aggregate
         * DefaultDocumentEvents to present them as a single edit to the user
         * place them into a CompoundEdit.
         *
         * @return whether the event is significant for edit undo purposes
         */
        public boolean isSignificant() {
<span class="nc" id="L2846">            return true;</span>
        }


        /**
         * Provides a localized, human readable description of this edit
         * suitable for use in, say, a change log.
         *
         * @return the description
         */
        public String getPresentationName() {
<span class="nc" id="L2857">            DocumentEvent.EventType type = getType();</span>
<span class="nc bnc" id="L2858" title="All 2 branches missed.">            if(type == DocumentEvent.EventType.INSERT)</span>
<span class="nc" id="L2859">                return UIManager.getString(&quot;AbstractDocument.additionText&quot;);</span>
<span class="nc bnc" id="L2860" title="All 2 branches missed.">            if(type == DocumentEvent.EventType.REMOVE)</span>
<span class="nc" id="L2861">                return UIManager.getString(&quot;AbstractDocument.deletionText&quot;);</span>
<span class="nc" id="L2862">            return UIManager.getString(&quot;AbstractDocument.styleChangeText&quot;);</span>
        }

        /**
         * Provides a localized, human readable description of the undoable
         * form of this edit, e.g. for use as an Undo menu item. Typically
         * derived from getDescription();
         *
         * @return the description
         */
        public String getUndoPresentationName() {
<span class="nc" id="L2873">            return UIManager.getString(&quot;AbstractDocument.undoText&quot;) + &quot; &quot; +</span>
<span class="nc" id="L2874">                getPresentationName();</span>
        }

        /**
         * Provides a localized, human readable description of the redoable
         * form of this edit, e.g. for use as a Redo menu item. Typically
         * derived from getPresentationName();
         *
         * @return the description
         */
        public String getRedoPresentationName() {
<span class="nc" id="L2885">            return UIManager.getString(&quot;AbstractDocument.redoText&quot;) + &quot; &quot; +</span>
<span class="nc" id="L2886">                getPresentationName();</span>
        }

        // --- DocumentEvent methods --------------------------

        /**
         * Returns the type of event.
         *
         * @return the event type as a DocumentEvent.EventType
         * @see DocumentEvent#getType
         */
        public DocumentEvent.EventType getType() {
<span class="nc" id="L2898">            return type;</span>
        }

        /**
         * Returns the offset within the document of the start of the change.
         *
         * @return the offset &amp;gt;= 0
         * @see DocumentEvent#getOffset
         */
        public int getOffset() {
<span class="nc" id="L2908">            return offset;</span>
        }

        /**
         * Returns the length of the change.
         *
         * @return the length &amp;gt;= 0
         * @see DocumentEvent#getLength
         */
        public int getLength() {
<span class="nc" id="L2918">            return length;</span>
        }

        /**
         * Gets the document that sourced the change event.
         *
         * @return the document
         * @see DocumentEvent#getDocument
         */
        public Document getDocument() {
<span class="nc" id="L2928">            return AbstractDocument.this;</span>
        }

        /**
         * Gets the changes for an element.
         *
         * @param elem the element
         * @return the changes
         */
        public DocumentEvent.ElementChange getChange(Element elem) {
<span class="nc bnc" id="L2938" title="All 2 branches missed.">            if (changeLookup != null) {</span>
<span class="nc" id="L2939">                return changeLookup.get(elem);</span>
            }
<span class="nc" id="L2941">            int n = edits.size();</span>
<span class="nc bnc" id="L2942" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L2943">                Object o = edits.elementAt(i);</span>
<span class="nc bnc" id="L2944" title="All 2 branches missed.">                if (o instanceof DocumentEvent.ElementChange) {</span>
<span class="nc" id="L2945">                    DocumentEvent.ElementChange c = (DocumentEvent.ElementChange) o;</span>
<span class="nc bnc" id="L2946" title="All 2 branches missed.">                    if (elem.equals(c.getElement())) {</span>
<span class="nc" id="L2947">                        return c;</span>
                    }
                }
            }
<span class="nc" id="L2951">            return null;</span>
        }

        // --- member variables ------------------------------------

        private int offset;
        private int length;
        private Hashtable&lt;Element, ElementChange&gt; changeLookup;
        private DocumentEvent.EventType type;

    }

    /**
     * This event used when firing document changes while Undo/Redo
     * operations. It just wraps DefaultDocumentEvent and delegates
     * all calls to it except getType() which depends on operation
     * (Undo or Redo).
     */
    class UndoRedoDocumentEvent implements DocumentEvent {
<span class="nc" id="L2970">        private DefaultDocumentEvent src = null;</span>
<span class="nc" id="L2971">        private EventType type = null;</span>

<span class="nc" id="L2973">        public UndoRedoDocumentEvent(DefaultDocumentEvent src, boolean isUndo) {</span>
<span class="nc" id="L2974">            this.src = src;</span>
<span class="nc bnc" id="L2975" title="All 2 branches missed.">            if(isUndo) {</span>
<span class="nc bnc" id="L2976" title="All 2 branches missed.">                if(src.getType().equals(EventType.INSERT)) {</span>
<span class="nc" id="L2977">                    type = EventType.REMOVE;</span>
<span class="nc bnc" id="L2978" title="All 2 branches missed.">                } else if(src.getType().equals(EventType.REMOVE)) {</span>
<span class="nc" id="L2979">                    type = EventType.INSERT;</span>
                } else {
<span class="nc" id="L2981">                    type = src.getType();</span>
                }
            } else {
<span class="nc" id="L2984">                type = src.getType();</span>
            }
<span class="nc" id="L2986">        }</span>

        public DefaultDocumentEvent getSource() {
<span class="nc" id="L2989">            return src;</span>
        }

        // DocumentEvent methods delegated to DefaultDocumentEvent source
        // except getType() which depends on operation (Undo or Redo).
        public int getOffset() {
<span class="nc" id="L2995">            return src.getOffset();</span>
        }

        public int getLength() {
<span class="nc" id="L2999">            return src.getLength();</span>
        }

        public Document getDocument() {
<span class="nc" id="L3003">            return src.getDocument();</span>
        }

        public DocumentEvent.EventType getType() {
<span class="nc" id="L3007">            return type;</span>
        }

        public DocumentEvent.ElementChange getChange(Element elem) {
<span class="nc" id="L3011">            return src.getChange(elem);</span>
        }
    }

    /**
     * An implementation of ElementChange that can be added to the document
     * event.
     */
    public static class ElementEdit extends AbstractUndoableEdit implements DocumentEvent.ElementChange {

        /**
         * Constructs an edit record.  This does not modify the element
         * so it can safely be used to &lt;em&gt;catch up&lt;/em&gt; a view to the
         * current model state for views that just attached to a model.
         *
         * @param e the element
         * @param index the index into the model &amp;gt;= 0
         * @param removed a set of elements that were removed
         * @param added a set of elements that were added
         */
        public ElementEdit(Element e, int index, Element[] removed, Element[] added) {
<span class="nc" id="L3032">            super();</span>
<span class="nc" id="L3033">            this.e = e;</span>
<span class="nc" id="L3034">            this.index = index;</span>
<span class="nc" id="L3035">            this.removed = removed;</span>
<span class="nc" id="L3036">            this.added = added;</span>
<span class="nc" id="L3037">        }</span>

        /**
         * Returns the underlying element.
         *
         * @return the element
         */
        public Element getElement() {
<span class="nc" id="L3045">            return e;</span>
        }

        /**
         * Returns the index into the list of elements.
         *
         * @return the index &amp;gt;= 0
         */
        public int getIndex() {
<span class="nc" id="L3054">            return index;</span>
        }

        /**
         * Gets a list of children that were removed.
         *
         * @return the list
         */
        public Element[] getChildrenRemoved() {
<span class="nc" id="L3063">            return removed;</span>
        }

        /**
         * Gets a list of children that were added.
         *
         * @return the list
         */
        public Element[] getChildrenAdded() {
<span class="nc" id="L3072">            return added;</span>
        }

        /**
         * Redoes a change.
         *
         * @exception CannotRedoException if the change cannot be redone
         */
        public void redo() throws CannotRedoException {
<span class="nc" id="L3081">            super.redo();</span>

            // Since this event will be reused, switch around added/removed.
<span class="nc" id="L3084">            Element[] tmp = removed;</span>
<span class="nc" id="L3085">            removed = added;</span>
<span class="nc" id="L3086">            added = tmp;</span>

            // PENDING(prinz) need MutableElement interface, canRedo() should check
<span class="nc" id="L3089">            ((AbstractDocument.BranchElement)e).replace(index, removed.length, added);</span>
<span class="nc" id="L3090">        }</span>

        /**
         * Undoes a change.
         *
         * @exception CannotUndoException if the change cannot be undone
         */
        public void undo() throws CannotUndoException {
<span class="nc" id="L3098">            super.undo();</span>
            // PENDING(prinz) need MutableElement interface, canUndo() should check
<span class="nc" id="L3100">            ((AbstractDocument.BranchElement)e).replace(index, added.length, removed);</span>

            // Since this event will be reused, switch around added/removed.
<span class="nc" id="L3103">            Element[] tmp = removed;</span>
<span class="nc" id="L3104">            removed = added;</span>
<span class="nc" id="L3105">            added = tmp;</span>
<span class="nc" id="L3106">        }</span>

        private Element e;
        private int index;
        private Element[] removed;
        private Element[] added;
    }


<span class="nc" id="L3115">    private class DefaultFilterBypass extends DocumentFilter.FilterBypass {</span>
        public Document getDocument() {
<span class="nc" id="L3117">            return AbstractDocument.this;</span>
        }

        public void remove(int offset, int length) throws
            BadLocationException {
<span class="nc" id="L3122">            handleRemove(offset, length);</span>
<span class="nc" id="L3123">        }</span>

        public void insertString(int offset, String string,
                                 AttributeSet attr) throws
                                        BadLocationException {
<span class="nc" id="L3128">            InsertStringResult insertStringResult = handleInsertString(offset, string, attr);</span>

<span class="nc" id="L3130">            processInsertStringResult(insertStringResult);</span>
<span class="nc" id="L3131">        }</span>

        public void replace(int offset, int length, String text,
                            AttributeSet attrs) throws BadLocationException {
<span class="nc" id="L3135">            handleRemove(offset, length);</span>

<span class="nc" id="L3137">            InsertStringResult insertStringResult = handleInsertString(offset, text, attrs);</span>

<span class="nc" id="L3139">            processInsertStringResult(insertStringResult);</span>
<span class="nc" id="L3140">        }</span>
    }

<span class="nc" id="L3143">    private static class InsertStringResult {</span>
        DefaultDocumentEvent documentEvent;
        UndoableEditEvent undoableEditEvent;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>