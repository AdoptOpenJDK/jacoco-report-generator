<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultHighlighter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">DefaultHighlighter.java</span></div><h1>DefaultHighlighter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.util.Vector;
import java.awt.*;
import javax.swing.plaf.*;
import javax.swing.*;

/**
 * Implements the Highlighter interfaces.  Implements a simple highlight
 * painter that renders in a solid color.
 *
 * @author  Timothy Prinzing
 * @see     Highlighter
 */
public class DefaultHighlighter extends LayeredHighlighter {

    /**
     * Creates a new DefaultHighlighther object.
     */
<span class="nc" id="L44">    public DefaultHighlighter() {</span>
<span class="nc" id="L45">        drawsLayeredHighlights = true;</span>
<span class="nc" id="L46">    }</span>

    // ---- Highlighter methods ----------------------------------------------

    /**
     * Renders the highlights.
     *
     * @param g the graphics context
     */
    public void paint(Graphics g) {
        // PENDING(prinz) - should cull ranges not visible
<span class="nc" id="L57">        int len = highlights.size();</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L59">            HighlightInfo info = highlights.elementAt(i);</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">            if (!(info instanceof LayeredHighlightInfo)) {</span>
                // Avoid allocing unless we need it.
<span class="nc" id="L62">                Rectangle a = component.getBounds();</span>
<span class="nc" id="L63">                Insets insets = component.getInsets();</span>
<span class="nc" id="L64">                a.x = insets.left;</span>
<span class="nc" id="L65">                a.y = insets.top;</span>
<span class="nc" id="L66">                a.width -= insets.left + insets.right;</span>
<span class="nc" id="L67">                a.height -= insets.top + insets.bottom;</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">                for (; i &lt; len; i++) {</span>
<span class="nc" id="L69">                    info = highlights.elementAt(i);</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">                    if (!(info instanceof LayeredHighlightInfo)) {</span>
<span class="nc" id="L71">                        Highlighter.HighlightPainter p = info.getPainter();</span>
<span class="nc" id="L72">                        p.paint(g, info.getStartOffset(), info.getEndOffset(),</span>
                                a, component);
                    }
                }
            }
        }
<span class="nc" id="L78">    }</span>

    /**
     * Called when the UI is being installed into the
     * interface of a JTextComponent.  Installs the editor, and
     * removes any existing highlights.
     *
     * @param c the editor component
     * @see Highlighter#install
     */
    public void install(JTextComponent c) {
<span class="nc" id="L89">        component = c;</span>
<span class="nc" id="L90">        removeAllHighlights();</span>
<span class="nc" id="L91">    }</span>

    /**
     * Called when the UI is being removed from the interface of
     * a JTextComponent.
     *
     * @param c the component
     * @see Highlighter#deinstall
     */
    public void deinstall(JTextComponent c) {
<span class="nc" id="L101">        component = null;</span>
<span class="nc" id="L102">    }</span>

    /**
     * Adds a highlight to the view.  Returns a tag that can be used
     * to refer to the highlight.
     *
     * @param p0   the start offset of the range to highlight &amp;gt;= 0
     * @param p1   the end offset of the range to highlight &amp;gt;= p0
     * @param p    the painter to use to actually render the highlight
     * @return     an object that can be used as a tag
     *   to refer to the highlight
     * @exception BadLocationException if the specified location is invalid
     */
    public Object addHighlight(int p0, int p1, Highlighter.HighlightPainter p) throws BadLocationException {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (p0 &lt; 0) {</span>
<span class="nc" id="L117">            throw new BadLocationException(&quot;Invalid start offset&quot;, p0);</span>
        }

<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (p1 &lt; p0) {</span>
<span class="nc" id="L121">            throw new BadLocationException(&quot;Invalid end offset&quot;, p1);</span>
        }

<span class="nc" id="L124">        Document doc = component.getDocument();</span>
<span class="nc bnc" id="L125" title="All 4 branches missed.">        HighlightInfo i = (getDrawsLayeredHighlights() &amp;&amp;</span>
                           (p instanceof LayeredHighlighter.LayerPainter)) ?
                          new LayeredHighlightInfo() : new HighlightInfo();
<span class="nc" id="L128">        i.painter = p;</span>
<span class="nc" id="L129">        i.p0 = doc.createPosition(p0);</span>
<span class="nc" id="L130">        i.p1 = doc.createPosition(p1);</span>
<span class="nc" id="L131">        highlights.addElement(i);</span>
<span class="nc" id="L132">        safeDamageRange(p0, p1);</span>
<span class="nc" id="L133">        return i;</span>
    }

    /**
     * Removes a highlight from the view.
     *
     * @param tag the reference to the highlight
     */
    public void removeHighlight(Object tag) {
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (tag instanceof LayeredHighlightInfo) {</span>
<span class="nc" id="L143">            LayeredHighlightInfo lhi = (LayeredHighlightInfo)tag;</span>
<span class="nc bnc" id="L144" title="All 4 branches missed.">            if (lhi.width &gt; 0 &amp;&amp; lhi.height &gt; 0) {</span>
<span class="nc" id="L145">                component.repaint(lhi.x, lhi.y, lhi.width, lhi.height);</span>
            }
<span class="nc" id="L147">        }</span>
        else {
<span class="nc" id="L149">            HighlightInfo info = (HighlightInfo) tag;</span>
<span class="nc" id="L150">            safeDamageRange(info.p0, info.p1);</span>
        }
<span class="nc" id="L152">        highlights.removeElement(tag);</span>
<span class="nc" id="L153">    }</span>

    /**
     * Removes all highlights.
     */
    public void removeAllHighlights() {
<span class="nc" id="L159">        TextUI mapper = component.getUI();</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (getDrawsLayeredHighlights()) {</span>
<span class="nc" id="L161">            int len = highlights.size();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (len != 0) {</span>
<span class="nc" id="L163">                int minX = 0;</span>
<span class="nc" id="L164">                int minY = 0;</span>
<span class="nc" id="L165">                int maxX = 0;</span>
<span class="nc" id="L166">                int maxY = 0;</span>
<span class="nc" id="L167">                int p0 = -1;</span>
<span class="nc" id="L168">                int p1 = -1;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">                for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L170">                    HighlightInfo hi = highlights.elementAt(i);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">                    if (hi instanceof LayeredHighlightInfo) {</span>
<span class="nc" id="L172">                        LayeredHighlightInfo info = (LayeredHighlightInfo)hi;</span>
<span class="nc" id="L173">                        minX = Math.min(minX, info.x);</span>
<span class="nc" id="L174">                        minY = Math.min(minY, info.y);</span>
<span class="nc" id="L175">                        maxX = Math.max(maxX, info.x + info.width);</span>
<span class="nc" id="L176">                        maxY = Math.max(maxY, info.y + info.height);</span>
<span class="nc" id="L177">                    }</span>
                    else {
<span class="nc bnc" id="L179" title="All 2 branches missed.">                        if (p0 == -1) {</span>
<span class="nc" id="L180">                            p0 = hi.p0.getOffset();</span>
<span class="nc" id="L181">                            p1 = hi.p1.getOffset();</span>
                        }
                        else {
<span class="nc" id="L184">                            p0 = Math.min(p0, hi.p0.getOffset());</span>
<span class="nc" id="L185">                            p1 = Math.max(p1, hi.p1.getOffset());</span>
                        }
                    }
                }
<span class="nc bnc" id="L189" title="All 4 branches missed.">                if (minX != maxX &amp;&amp; minY != maxY) {</span>
<span class="nc" id="L190">                    component.repaint(minX, minY, maxX - minX, maxY - minY);</span>
                }
<span class="nc bnc" id="L192" title="All 2 branches missed.">                if (p0 != -1) {</span>
                    try {
<span class="nc" id="L194">                        safeDamageRange(p0, p1);</span>
<span class="nc" id="L195">                    } catch (BadLocationException e) {}</span>
                }
<span class="nc" id="L197">                highlights.removeAllElements();</span>
            }
<span class="nc" id="L199">        }</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        else if (mapper != null) {</span>
<span class="nc" id="L201">            int len = highlights.size();</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            if (len != 0) {</span>
<span class="nc" id="L203">                int p0 = Integer.MAX_VALUE;</span>
<span class="nc" id="L204">                int p1 = 0;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L206">                    HighlightInfo info = highlights.elementAt(i);</span>
<span class="nc" id="L207">                    p0 = Math.min(p0, info.p0.getOffset());</span>
<span class="nc" id="L208">                    p1 = Math.max(p1, info.p1.getOffset());</span>
                }
                try {
<span class="nc" id="L211">                    safeDamageRange(p0, p1);</span>
<span class="nc" id="L212">                } catch (BadLocationException e) {}</span>

<span class="nc" id="L214">                highlights.removeAllElements();</span>
            }
        }
<span class="nc" id="L217">    }</span>

    /**
     * Changes a highlight.
     *
     * @param tag the highlight tag
     * @param p0 the beginning of the range &amp;gt;= 0
     * @param p1 the end of the range &amp;gt;= p0
     * @exception BadLocationException if the specified location is invalid
     */
    public void changeHighlight(Object tag, int p0, int p1) throws BadLocationException {
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (p0 &lt; 0) {</span>
<span class="nc" id="L229">            throw new BadLocationException(&quot;Invalid beginning of the range&quot;, p0);</span>
        }

<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (p1 &lt; p0) {</span>
<span class="nc" id="L233">            throw new BadLocationException(&quot;Invalid end of the range&quot;, p1);</span>
        }

<span class="nc" id="L236">        Document doc = component.getDocument();</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (tag instanceof LayeredHighlightInfo) {</span>
<span class="nc" id="L238">            LayeredHighlightInfo lhi = (LayeredHighlightInfo)tag;</span>
<span class="nc bnc" id="L239" title="All 4 branches missed.">            if (lhi.width &gt; 0 &amp;&amp; lhi.height &gt; 0) {</span>
<span class="nc" id="L240">                component.repaint(lhi.x, lhi.y, lhi.width, lhi.height);</span>
            }
            // Mark the highlights region as invalid, it will reset itself
            // next time asked to paint.
<span class="nc" id="L244">            lhi.width = lhi.height = 0;</span>
<span class="nc" id="L245">            lhi.p0 = doc.createPosition(p0);</span>
<span class="nc" id="L246">            lhi.p1 = doc.createPosition(p1);</span>
<span class="nc" id="L247">            safeDamageRange(Math.min(p0, p1), Math.max(p0, p1));</span>
<span class="nc" id="L248">        }</span>
        else {
<span class="nc" id="L250">            HighlightInfo info = (HighlightInfo) tag;</span>
<span class="nc" id="L251">            int oldP0 = info.p0.getOffset();</span>
<span class="nc" id="L252">            int oldP1 = info.p1.getOffset();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (p0 == oldP0) {</span>
<span class="nc" id="L254">                safeDamageRange(Math.min(oldP1, p1),</span>
<span class="nc" id="L255">                                   Math.max(oldP1, p1));</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            } else if (p1 == oldP1) {</span>
<span class="nc" id="L257">                safeDamageRange(Math.min(p0, oldP0),</span>
<span class="nc" id="L258">                                   Math.max(p0, oldP0));</span>
            } else {
<span class="nc" id="L260">                safeDamageRange(oldP0, oldP1);</span>
<span class="nc" id="L261">                safeDamageRange(p0, p1);</span>
            }
<span class="nc" id="L263">            info.p0 = doc.createPosition(p0);</span>
<span class="nc" id="L264">            info.p1 = doc.createPosition(p1);</span>
        }
<span class="nc" id="L266">    }</span>

    /**
     * Makes a copy of the highlights.  Does not actually clone each highlight,
     * but only makes references to them.
     *
     * @return the copy
     * @see Highlighter#getHighlights
     */
    public Highlighter.Highlight[] getHighlights() {
<span class="nc" id="L276">        int size = highlights.size();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (size == 0) {</span>
<span class="nc" id="L278">            return noHighlights;</span>
        }
<span class="nc" id="L280">        Highlighter.Highlight[] h = new Highlighter.Highlight[size];</span>
<span class="nc" id="L281">        highlights.copyInto(h);</span>
<span class="nc" id="L282">        return h;</span>
    }

    /**
     * When leaf Views (such as LabelView) are rendering they should
     * call into this method. If a highlight is in the given region it will
     * be drawn immediately.
     *
     * @param g Graphics used to draw
     * @param p0 starting offset of view
     * @param p1 ending offset of view
     * @param viewBounds Bounds of View
     * @param editor JTextComponent
     * @param view View instance being rendered
     */
    public void paintLayeredHighlights(Graphics g, int p0, int p1,
                                       Shape viewBounds,
                                       JTextComponent editor, View view) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        for (int counter = highlights.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L301">            HighlightInfo tag = highlights.elementAt(counter);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (tag instanceof LayeredHighlightInfo) {</span>
<span class="nc" id="L303">                LayeredHighlightInfo lhi = (LayeredHighlightInfo)tag;</span>
<span class="nc" id="L304">                int start = lhi.getStartOffset();</span>
<span class="nc" id="L305">                int end = lhi.getEndOffset();</span>
<span class="nc bnc" id="L306" title="All 8 branches missed.">                if ((p0 &lt; start &amp;&amp; p1 &gt; start) ||</span>
                    (p0 &gt;= start &amp;&amp; p0 &lt; end)) {
<span class="nc" id="L308">                    lhi.paintLayeredHighlights(g, p0, p1, viewBounds,</span>
                                               editor, view);
                }
            }
        }
<span class="nc" id="L313">    }</span>

    /**
     * Queues damageRange() call into event dispatch thread
     * to be sure that views are in consistent state.
     */
    private void safeDamageRange(final Position p0, final Position p1) {
<span class="nc" id="L320">        safeDamager.damageRange(p0, p1);</span>
<span class="nc" id="L321">    }</span>

    /**
     * Queues damageRange() call into event dispatch thread
     * to be sure that views are in consistent state.
     */
    private void safeDamageRange(int a0, int a1) throws BadLocationException {
<span class="nc" id="L328">        Document doc = component.getDocument();</span>
<span class="nc" id="L329">        safeDamageRange(doc.createPosition(a0), doc.createPosition(a1));</span>
<span class="nc" id="L330">    }</span>

    /**
     * If true, highlights are drawn as the Views draw the text. That is
     * the Views will call into &lt;code&gt;paintLayeredHighlight&lt;/code&gt; which
     * will result in a rectangle being drawn before the text is drawn
     * (if the offsets are in a highlighted region that is). For this to
     * work the painter supplied must be an instance of
     * LayeredHighlightPainter.
     */
    public void setDrawsLayeredHighlights(boolean newValue) {
<span class="nc" id="L341">        drawsLayeredHighlights = newValue;</span>
<span class="nc" id="L342">    }</span>

    public boolean getDrawsLayeredHighlights() {
<span class="nc" id="L345">        return drawsLayeredHighlights;</span>
    }

    // ---- member variables --------------------------------------------

<span class="nc" id="L350">    private final static Highlighter.Highlight[] noHighlights =</span>
            new Highlighter.Highlight[0];
<span class="nc" id="L352">    private Vector&lt;HighlightInfo&gt; highlights = new Vector&lt;HighlightInfo&gt;();</span>
    private JTextComponent component;
    private boolean drawsLayeredHighlights;
<span class="nc" id="L355">    private SafeDamager safeDamager = new SafeDamager();</span>


    /**
     * Default implementation of LayeredHighlighter.LayerPainter that can
     * be used for painting highlights.
     * &lt;p&gt;
     * As of 1.4 this field is final.
     */
<span class="nc" id="L364">    public static final LayeredHighlighter.LayerPainter DefaultPainter = new DefaultHighlightPainter(null);</span>


    /**
     * Simple highlight painter that fills a highlighted area with
     * a solid color.
     */
    public static class DefaultHighlightPainter extends LayeredHighlighter.LayerPainter {

        /**
         * Constructs a new highlight painter. If &lt;code&gt;c&lt;/code&gt; is null,
         * the JTextComponent will be queried for its selection color.
         *
         * @param c the color for the highlight
         */
<span class="nc" id="L379">        public DefaultHighlightPainter(Color c) {</span>
<span class="nc" id="L380">            color = c;</span>
<span class="nc" id="L381">        }</span>

        /**
         * Returns the color of the highlight.
         *
         * @return the color
         */
        public Color getColor() {
<span class="nc" id="L389">            return color;</span>
        }

        // --- HighlightPainter methods ---------------------------------------

        /**
         * Paints a highlight.
         *
         * @param g the graphics context
         * @param offs0 the starting model offset &amp;gt;= 0
         * @param offs1 the ending model offset &amp;gt;= offs1
         * @param bounds the bounding box for the highlight
         * @param c the editor
         */
        public void paint(Graphics g, int offs0, int offs1, Shape bounds, JTextComponent c) {
<span class="nc" id="L404">            Rectangle alloc = bounds.getBounds();</span>
            try {
                // --- determine locations ---
<span class="nc" id="L407">                TextUI mapper = c.getUI();</span>
<span class="nc" id="L408">                Rectangle p0 = mapper.modelToView(c, offs0);</span>
<span class="nc" id="L409">                Rectangle p1 = mapper.modelToView(c, offs1);</span>

                // --- render ---
<span class="nc" id="L412">                Color color = getColor();</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">                if (color == null) {</span>
<span class="nc" id="L415">                    g.setColor(c.getSelectionColor());</span>
                }
                else {
<span class="nc" id="L418">                    g.setColor(color);</span>
                }
<span class="nc bnc" id="L420" title="All 2 branches missed.">                if (p0.y == p1.y) {</span>
                    // same line, render a rectangle
<span class="nc" id="L422">                    Rectangle r = p0.union(p1);</span>
<span class="nc" id="L423">                    g.fillRect(r.x, r.y, r.width, r.height);</span>
<span class="nc" id="L424">                } else {</span>
                    // different lines
<span class="nc" id="L426">                    int p0ToMarginWidth = alloc.x + alloc.width - p0.x;</span>
<span class="nc" id="L427">                    g.fillRect(p0.x, p0.y, p0ToMarginWidth, p0.height);</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                    if ((p0.y + p0.height) != p1.y) {</span>
<span class="nc" id="L429">                        g.fillRect(alloc.x, p0.y + p0.height, alloc.width,</span>
                                   p1.y - (p0.y + p0.height));
                    }
<span class="nc" id="L432">                    g.fillRect(alloc.x, p1.y, (p1.x - alloc.x), p1.height);</span>
                }
<span class="nc" id="L434">            } catch (BadLocationException e) {</span>
                // can't render
<span class="nc" id="L436">            }</span>
<span class="nc" id="L437">        }</span>

        // --- LayerPainter methods ----------------------------
        /**
         * Paints a portion of a highlight.
         *
         * @param g the graphics context
         * @param offs0 the starting model offset &amp;gt;= 0
         * @param offs1 the ending model offset &amp;gt;= offs1
         * @param bounds the bounding box of the view, which is not
         *        necessarily the region to paint.
         * @param c the editor
         * @param view View painting for
         * @return region drawing occurred in
         */
        public Shape paintLayer(Graphics g, int offs0, int offs1,
                                Shape bounds, JTextComponent c, View view) {
<span class="nc" id="L454">            Color color = getColor();</span>

<span class="nc bnc" id="L456" title="All 2 branches missed.">            if (color == null) {</span>
<span class="nc" id="L457">                g.setColor(c.getSelectionColor());</span>
            }
            else {
<span class="nc" id="L460">                g.setColor(color);</span>
            }

            Rectangle r;

<span class="nc bnc" id="L465" title="All 2 branches missed.">            if (offs0 == view.getStartOffset() &amp;&amp;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                offs1 == view.getEndOffset()) {</span>
                // Contained in view, can just use bounds.
<span class="nc bnc" id="L468" title="All 2 branches missed.">                if (bounds instanceof Rectangle) {</span>
<span class="nc" id="L469">                    r = (Rectangle) bounds;</span>
                }
                else {
<span class="nc" id="L472">                    r = bounds.getBounds();</span>
                }
            }
            else {
                // Should only render part of View.
                try {
                    // --- determine locations ---
<span class="nc" id="L479">                    Shape shape = view.modelToView(offs0, Position.Bias.Forward,</span>
                                                   offs1,Position.Bias.Backward,
                                                   bounds);
<span class="nc bnc" id="L482" title="All 2 branches missed.">                    r = (shape instanceof Rectangle) ?</span>
<span class="nc" id="L483">                                  (Rectangle)shape : shape.getBounds();</span>
<span class="nc" id="L484">                } catch (BadLocationException e) {</span>
                    // can't render
<span class="nc" id="L486">                    r = null;</span>
<span class="nc" id="L487">                }</span>
            }

<span class="nc bnc" id="L490" title="All 2 branches missed.">            if (r != null) {</span>
                // If we are asked to highlight, we should draw something even
                // if the model-to-view projection is of zero width (6340106).
<span class="nc" id="L493">                r.width = Math.max(r.width, 1);</span>

<span class="nc" id="L495">                g.fillRect(r.x, r.y, r.width, r.height);</span>
            }

<span class="nc" id="L498">            return r;</span>
        }

        private Color color;

    }


<span class="nc" id="L506">    class HighlightInfo implements Highlighter.Highlight {</span>

        public int getStartOffset() {
<span class="nc" id="L509">            return p0.getOffset();</span>
        }

        public int getEndOffset() {
<span class="nc" id="L513">            return p1.getOffset();</span>
        }

        public Highlighter.HighlightPainter getPainter() {
<span class="nc" id="L517">            return painter;</span>
        }

        Position p0;
        Position p1;
        Highlighter.HighlightPainter painter;
    }


    /**
     * LayeredHighlightPainter is used when a drawsLayeredHighlights is
     * true. It maintains a rectangle of the region to paint.
     */
<span class="nc" id="L530">    class LayeredHighlightInfo extends HighlightInfo {</span>

        void union(Shape bounds) {
<span class="nc bnc" id="L533" title="All 2 branches missed.">            if (bounds == null)</span>
<span class="nc" id="L534">                return;</span>

            Rectangle alloc;
<span class="nc bnc" id="L537" title="All 2 branches missed.">            if (bounds instanceof Rectangle) {</span>
<span class="nc" id="L538">                alloc = (Rectangle)bounds;</span>
            }
            else {
<span class="nc" id="L541">                alloc = bounds.getBounds();</span>
            }
<span class="nc bnc" id="L543" title="All 4 branches missed.">            if (width == 0 || height == 0) {</span>
<span class="nc" id="L544">                x = alloc.x;</span>
<span class="nc" id="L545">                y = alloc.y;</span>
<span class="nc" id="L546">                width = alloc.width;</span>
<span class="nc" id="L547">                height = alloc.height;</span>
            }
            else {
<span class="nc" id="L550">                width = Math.max(x + width, alloc.x + alloc.width);</span>
<span class="nc" id="L551">                height = Math.max(y + height, alloc.y + alloc.height);</span>
<span class="nc" id="L552">                x = Math.min(x, alloc.x);</span>
<span class="nc" id="L553">                width -= x;</span>
<span class="nc" id="L554">                y = Math.min(y, alloc.y);</span>
<span class="nc" id="L555">                height -= y;</span>
            }
<span class="nc" id="L557">        }</span>

        /**
         * Restricts the region based on the receivers offsets and messages
         * the painter to paint the region.
         */
        void paintLayeredHighlights(Graphics g, int p0, int p1,
                                    Shape viewBounds, JTextComponent editor,
                                    View view) {
<span class="nc" id="L566">            int start = getStartOffset();</span>
<span class="nc" id="L567">            int end = getEndOffset();</span>
            // Restrict the region to what we represent
<span class="nc" id="L569">            p0 = Math.max(start, p0);</span>
<span class="nc" id="L570">            p1 = Math.min(end, p1);</span>
            // Paint the appropriate region using the painter and union
            // the effected region with our bounds.
<span class="nc" id="L573">            union(((LayeredHighlighter.LayerPainter)painter).paintLayer</span>
<span class="nc" id="L574">                  (g, p0, p1, viewBounds, editor, view));</span>
<span class="nc" id="L575">        }</span>

        int x;
        int y;
        int width;
        int height;
    }

    /**
     * This class invokes &lt;code&gt;mapper.damageRange&lt;/code&gt; in
     * EventDispatchThread. The only one instance per Highlighter
     * is cretaed. When a number of ranges should be damaged
     * it collects them into queue and damages
     * them in consecutive order in &lt;code&gt;run&lt;/code&gt;
     * call.
     */
<span class="nc" id="L591">    class SafeDamager implements Runnable {</span>
<span class="nc" id="L592">        private Vector&lt;Position&gt; p0 = new Vector&lt;Position&gt;(10);</span>
<span class="nc" id="L593">        private Vector&lt;Position&gt; p1 = new Vector&lt;Position&gt;(10);</span>
<span class="nc" id="L594">        private Document lastDoc = null;</span>

        /**
         * Executes range(s) damage and cleans range queue.
         */
        public synchronized void run() {
<span class="nc bnc" id="L600" title="All 2 branches missed.">            if (component != null) {</span>
<span class="nc" id="L601">                TextUI mapper = component.getUI();</span>
<span class="nc bnc" id="L602" title="All 4 branches missed.">                if (mapper != null &amp;&amp; lastDoc == component.getDocument()) {</span>
                    // the Document should be the same to properly
                    // display highlights
<span class="nc" id="L605">                    int len = p0.size();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">                    for (int i = 0; i &lt; len; i++){</span>
<span class="nc" id="L607">                        mapper.damageRange(component,</span>
<span class="nc" id="L608">                                p0.get(i).getOffset(),</span>
<span class="nc" id="L609">                                p1.get(i).getOffset());</span>
                    }
                }
            }
<span class="nc" id="L613">            p0.clear();</span>
<span class="nc" id="L614">            p1.clear();</span>

            // release reference
<span class="nc" id="L617">            lastDoc = null;</span>
<span class="nc" id="L618">        }</span>

        /**
         * Adds the range to be damaged into the range queue. If the
         * range queue is empty (the first call or run() was already
         * invoked) then adds this class instance into EventDispatch
         * queue.
         *
         * The method also tracks if the current document changed or
         * component is null. In this case it removes all ranges added
         * before from range queue.
         */
        public synchronized void damageRange(Position pos0, Position pos1) {
<span class="nc bnc" id="L631" title="All 2 branches missed.">            if (component == null) {</span>
<span class="nc" id="L632">                p0.clear();</span>
<span class="nc" id="L633">                lastDoc = null;</span>
<span class="nc" id="L634">                return;</span>
            }

<span class="nc" id="L637">            boolean addToQueue = p0.isEmpty();</span>
<span class="nc" id="L638">            Document curDoc = component.getDocument();</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">            if (curDoc != lastDoc) {</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">                if (!p0.isEmpty()) {</span>
<span class="nc" id="L641">                    p0.clear();</span>
<span class="nc" id="L642">                    p1.clear();</span>
                }
<span class="nc" id="L644">                lastDoc = curDoc;</span>
            }
<span class="nc" id="L646">            p0.add(pos0);</span>
<span class="nc" id="L647">            p1.add(pos1);</span>

<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (addToQueue) {</span>
<span class="nc" id="L650">                SwingUtilities.invokeLater(this);</span>
            }
<span class="nc" id="L652">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>