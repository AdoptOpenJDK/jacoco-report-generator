<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DefaultCaret.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">DefaultCaret.java</span></div><h1>DefaultCaret.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.awt.*;
import java.awt.event.*;
import java.awt.datatransfer.*;
import java.beans.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.plaf.*;
import java.util.EventListener;
import sun.swing.SwingUtilities2;

/**
 * A default implementation of Caret.  The caret is rendered as
 * a vertical line in the color specified by the CaretColor property
 * of the associated JTextComponent.  It can blink at the rate specified
 * by the BlinkRate property.
 * &lt;p&gt;
 * This implementation expects two sources of asynchronous notification.
 * The timer thread fires asynchronously, and causes the caret to simply
 * repaint the most recent bounding box.  The caret also tracks change
 * as the document is modified.  Typically this will happen on the
 * event dispatch thread as a result of some mouse or keyboard event.
 * The caret behavior on both synchronous and asynchronous documents updates
 * is controlled by &lt;code&gt;UpdatePolicy&lt;/code&gt; property. The repaint of the
 * new caret location will occur on the event thread in any case, as calls to
 * &lt;code&gt;modelToView&lt;/code&gt; are only safe on the event thread.
 * &lt;p&gt;
 * The caret acts as a mouse and focus listener on the text component
 * it has been installed in, and defines the caret semantics based upon
 * those events.  The listener methods can be reimplemented to change the
 * semantics.
 * By default, the first mouse button will be used to set focus and caret
 * position.  Dragging the mouse pointer with the first mouse button will
 * sweep out a selection that is contiguous in the model.  If the associated
 * text component is editable, the caret will become visible when focus
 * is gained, and invisible when focus is lost.
 * &lt;p&gt;
 * The Highlighter bound to the associated text component is used to
 * render the selection by default.
 * Selection appearance can be customized by supplying a
 * painter to use for the highlights.  By default a painter is used that
 * will render a solid color as specified in the associated text component
 * in the &lt;code&gt;SelectionColor&lt;/code&gt; property.  This can easily be changed
 * by reimplementing the
 * {@link #getSelectionPainter getSelectionPainter}
 * method.
 * &lt;p&gt;
 * A customized caret appearance can be achieved by reimplementing
 * the paint method.  If the paint method is changed, the damage method
 * should also be reimplemented to cause a repaint for the area needed
 * to render the caret.  The caret extends the Rectangle class which
 * is used to hold the bounding box for where the caret was last rendered.
 * This enables the caret to repaint in a thread-safe manner when the
 * caret moves without making a call to modelToView which is unstable
 * between model updates and view repair (i.e. the order of delivery
 * to DocumentListeners is not guaranteed).
 * &lt;p&gt;
 * The magic caret position is set to null when the caret position changes.
 * A timer is used to determine the new location (after the caret change).
 * When the timer fires, if the magic caret position is still null it is
 * reset to the current caret position. Any actions that change
 * the caret position and want the magic caret position to remain the
 * same, must remember the magic caret position, change the cursor, and
 * then set the magic caret position to its original value. This has the
 * benefit that only actions that want the magic caret position to persist
 * (such as open/down) need to know about it.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author  Timothy Prinzing
 * @see     Caret
 */
public class DefaultCaret extends Rectangle implements Caret, FocusListener, MouseListener, MouseMotionListener {

    /**
     * Indicates that the caret position is to be updated only when
     * document changes are performed on the Event Dispatching Thread.
     * @see #setUpdatePolicy
     * @see #getUpdatePolicy
     * @since 1.5
     */
    public static final int UPDATE_WHEN_ON_EDT = 0;

    /**
     * Indicates that the caret should remain at the same
     * absolute position in the document regardless of any document
     * updates, except when the document length becomes less than
     * the current caret position due to removal. In that case the caret
     * position is adjusted to the end of the document.
     *
     * @see #setUpdatePolicy
     * @see #getUpdatePolicy
     * @since 1.5
     */
    public static final int NEVER_UPDATE = 1;

    /**
     * Indicates that the caret position is to be &lt;b&gt;always&lt;/b&gt;
     * updated accordingly to the document changes regardless whether
     * the document updates are performed on the Event Dispatching Thread
     * or not.
     *
     * @see #setUpdatePolicy
     * @see #getUpdatePolicy
     * @since 1.5
     */
    public static final int ALWAYS_UPDATE = 2;

    /**
     * Constructs a default caret.
     */
<span class="nc" id="L147">    public DefaultCaret() {</span>
<span class="nc" id="L148">    }</span>

    /**
     * Sets the caret movement policy on the document updates. Normally
     * the caret updates its absolute position within the document on
     * insertions occurred before or at the caret position and
     * on removals before the caret position. 'Absolute position'
     * means here the position relative to the start of the document.
     * For example if
     * a character is typed within editable text component it is inserted
     * at the caret position and the caret moves to the next absolute
     * position within the document due to insertion and if
     * &lt;code&gt;BACKSPACE&lt;/code&gt; is typed then caret decreases its absolute
     * position due to removal of a character before it. Sometimes
     * it may be useful to turn off the caret position updates so that
     * the caret stays at the same absolute position within the
     * document position regardless of any document updates.
     * &lt;p&gt;
     * The following update policies are allowed:
     * &lt;ul&gt;
     *   &lt;li&gt;&lt;code&gt;NEVER_UPDATE&lt;/code&gt;: the caret stays at the same
     *       absolute position in the document regardless of any document
     *       updates, except when document length becomes less than
     *       the current caret position due to removal. In that case caret
     *       position is adjusted to the end of the document.
     *       The caret doesn't try to keep itself visible by scrolling
     *       the associated view when using this policy. &lt;/li&gt;
     *   &lt;li&gt;&lt;code&gt;ALWAYS_UPDATE&lt;/code&gt;: the caret always tracks document
     *       changes. For regular changes it increases its position
     *       if an insertion occurs before or at its current position,
     *       and decreases position if a removal occurs before
     *       its current position. For undo/redo updates it is always
     *       moved to the position where update occurred. The caret
     *       also tries to keep itself visible by calling
     *       &lt;code&gt;adjustVisibility&lt;/code&gt; method.&lt;/li&gt;
     *   &lt;li&gt;&lt;code&gt;UPDATE_WHEN_ON_EDT&lt;/code&gt;: acts like &lt;code&gt;ALWAYS_UPDATE&lt;/code&gt;
     *       if the document updates are performed on the Event Dispatching Thread
     *       and like &lt;code&gt;NEVER_UPDATE&lt;/code&gt; if updates are performed on
     *       other thread. &lt;/li&gt;
     * &lt;/ul&gt; &lt;p&gt;
     * The default property value is &lt;code&gt;UPDATE_WHEN_ON_EDT&lt;/code&gt;.
     *
     * @param policy one of the following values : &lt;code&gt;UPDATE_WHEN_ON_EDT&lt;/code&gt;,
     * &lt;code&gt;NEVER_UPDATE&lt;/code&gt;, &lt;code&gt;ALWAYS_UPDATE&lt;/code&gt;
     * @throws IllegalArgumentException if invalid value is passed
     *
     * @see #getUpdatePolicy
     * @see #adjustVisibility
     * @see #UPDATE_WHEN_ON_EDT
     * @see #NEVER_UPDATE
     * @see #ALWAYS_UPDATE
     *
     * @since 1.5
     */
    public void setUpdatePolicy(int policy) {
<span class="nc" id="L203">        updatePolicy = policy;</span>
<span class="nc" id="L204">    }</span>

    /**
     * Gets the caret movement policy on document updates.
     *
     * @return one of the following values : &lt;code&gt;UPDATE_WHEN_ON_EDT&lt;/code&gt;,
     * &lt;code&gt;NEVER_UPDATE&lt;/code&gt;, &lt;code&gt;ALWAYS_UPDATE&lt;/code&gt;
     *
     * @see #setUpdatePolicy
     * @see #UPDATE_WHEN_ON_EDT
     * @see #NEVER_UPDATE
     * @see #ALWAYS_UPDATE
     *
     * @since 1.5
     */
    public int getUpdatePolicy() {
<span class="nc" id="L220">        return updatePolicy;</span>
    }

    /**
     * Gets the text editor component that this caret is
     * is bound to.
     *
     * @return the component
     */
    protected final JTextComponent getComponent() {
<span class="nc" id="L230">        return component;</span>
    }

    /**
     * Cause the caret to be painted.  The repaint
     * area is the bounding box of the caret (i.e.
     * the caret rectangle or &lt;em&gt;this&lt;/em&gt;).
     * &lt;p&gt;
     * This method is thread safe, although most Swing methods
     * are not. Please see
     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
     * in Swing&lt;/A&gt; for more information.
     */
    protected final synchronized void repaint() {
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (component != null) {</span>
<span class="nc" id="L245">            component.repaint(x, y, width, height);</span>
        }
<span class="nc" id="L247">    }</span>

    /**
     * Damages the area surrounding the caret to cause
     * it to be repainted in a new location.  If paint()
     * is reimplemented, this method should also be
     * reimplemented.  This method should update the
     * caret bounds (x, y, width, and height).
     *
     * @param r  the current location of the caret
     * @see #paint
     */
    protected synchronized void damage(Rectangle r) {
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (r != null) {</span>
<span class="nc" id="L261">            int damageWidth = getCaretWidth(r.height);</span>
<span class="nc" id="L262">            x = r.x - 4 - (damageWidth &gt;&gt; 1);</span>
<span class="nc" id="L263">            y = r.y;</span>
<span class="nc" id="L264">            width = 9 + damageWidth;</span>
<span class="nc" id="L265">            height = r.height;</span>
<span class="nc" id="L266">            repaint();</span>
        }
<span class="nc" id="L268">    }</span>

    /**
     * Scrolls the associated view (if necessary) to make
     * the caret visible.  Since how this should be done
     * is somewhat of a policy, this method can be
     * reimplemented to change the behavior.  By default
     * the scrollRectToVisible method is called on the
     * associated component.
     *
     * @param nloc the new position to scroll to
     */
    protected void adjustVisibility(Rectangle nloc) {
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if(component == null) {</span>
<span class="nc" id="L282">            return;</span>
        }
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L285">                component.scrollRectToVisible(nloc);</span>
        } else {
<span class="nc" id="L287">            SwingUtilities.invokeLater(new SafeScroller(nloc));</span>
        }
<span class="nc" id="L289">    }</span>

    /**
     * Gets the painter for the Highlighter.
     *
     * @return the painter
     */
    protected Highlighter.HighlightPainter getSelectionPainter() {
<span class="nc" id="L297">        return DefaultHighlighter.DefaultPainter;</span>
    }

    /**
     * Tries to set the position of the caret from
     * the coordinates of a mouse event, using viewToModel().
     *
     * @param e the mouse event
     */
    protected void positionCaret(MouseEvent e) {
<span class="nc" id="L307">        Point pt = new Point(e.getX(), e.getY());</span>
<span class="nc" id="L308">        Position.Bias[] biasRet = new Position.Bias[1];</span>
<span class="nc" id="L309">        int pos = component.getUI().viewToModel(component, pt, biasRet);</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if(biasRet[0] == null)</span>
<span class="nc" id="L311">            biasRet[0] = Position.Bias.Forward;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">        if (pos &gt;= 0) {</span>
<span class="nc" id="L313">            setDot(pos, biasRet[0]);</span>
        }
<span class="nc" id="L315">    }</span>

    /**
     * Tries to move the position of the caret from
     * the coordinates of a mouse event, using viewToModel().
     * This will cause a selection if the dot and mark
     * are different.
     *
     * @param e the mouse event
     */
    protected void moveCaret(MouseEvent e) {
<span class="nc" id="L326">        Point pt = new Point(e.getX(), e.getY());</span>
<span class="nc" id="L327">        Position.Bias[] biasRet = new Position.Bias[1];</span>
<span class="nc" id="L328">        int pos = component.getUI().viewToModel(component, pt, biasRet);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if(biasRet[0] == null)</span>
<span class="nc" id="L330">            biasRet[0] = Position.Bias.Forward;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (pos &gt;= 0) {</span>
<span class="nc" id="L332">            moveDot(pos, biasRet[0]);</span>
        }
<span class="nc" id="L334">    }</span>

    // --- FocusListener methods --------------------------

    /**
     * Called when the component containing the caret gains
     * focus.  This is implemented to set the caret to visible
     * if the component is editable.
     *
     * @param e the focus event
     * @see FocusListener#focusGained
     */
    public void focusGained(FocusEvent e) {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (component.isEnabled()) {</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">            if (component.isEditable()) {</span>
<span class="nc" id="L349">                setVisible(true);</span>
            }
<span class="nc" id="L351">            setSelectionVisible(true);</span>
        }
<span class="nc" id="L353">    }</span>

    /**
     * Called when the component containing the caret loses
     * focus.  This is implemented to set the caret to visibility
     * to false.
     *
     * @param e the focus event
     * @see FocusListener#focusLost
     */
    public void focusLost(FocusEvent e) {
<span class="nc" id="L364">        setVisible(false);</span>
<span class="nc bnc" id="L365" title="All 4 branches missed.">        setSelectionVisible(ownsSelection || e.isTemporary());</span>
<span class="nc" id="L366">    }</span>


    /**
     * Selects word based on the MouseEvent
     */
    private void selectWord(MouseEvent e) {
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (selectedWordEvent != null</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">            &amp;&amp; selectedWordEvent.getX() == e.getX()</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            &amp;&amp; selectedWordEvent.getY() == e.getY()) {</span>
            //we already done selection for this
<span class="nc" id="L377">            return;</span>
        }
<span class="nc" id="L379">                    Action a = null;</span>
<span class="nc" id="L380">                    ActionMap map = getComponent().getActionMap();</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">                    if (map != null) {</span>
<span class="nc" id="L382">                        a = map.get(DefaultEditorKit.selectWordAction);</span>
                    }
<span class="nc bnc" id="L384" title="All 2 branches missed.">                    if (a == null) {</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">                        if (selectWord == null) {</span>
<span class="nc" id="L386">                            selectWord = new DefaultEditorKit.SelectWordAction();</span>
                        }
<span class="nc" id="L388">                        a = selectWord;</span>
                    }
<span class="nc" id="L390">                    a.actionPerformed(new ActionEvent(getComponent(),</span>
<span class="nc" id="L391">                                                      ActionEvent.ACTION_PERFORMED, null, e.getWhen(), e.getModifiers()));</span>
<span class="nc" id="L392">        selectedWordEvent = e;</span>
<span class="nc" id="L393">    }</span>

    // --- MouseListener methods -----------------------------------

    /**
     * Called when the mouse is clicked.  If the click was generated
     * from button1, a double click selects a word,
     * and a triple click the current line.
     *
     * @param e the mouse event
     * @see MouseListener#mouseClicked
     */
    public void mouseClicked(MouseEvent e) {
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (getComponent() == null) {</span>
<span class="nc" id="L407">            return;</span>
        }

<span class="nc" id="L410">        int nclicks = SwingUtilities2.getAdjustedClickCount(getComponent(), e);</span>

<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (! e.isConsumed()) {</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            if (SwingUtilities.isLeftMouseButton(e)) {</span>
                // mouse 1 behavior
<span class="nc bnc" id="L415" title="All 2 branches missed.">                if(nclicks == 1) {</span>
<span class="nc" id="L416">                    selectedWordEvent = null;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">                } else if(nclicks == 2</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                          &amp;&amp; SwingUtilities2.canEventAccessSystemClipboard(e)) {</span>
<span class="nc" id="L419">                    selectWord(e);</span>
<span class="nc" id="L420">                    selectedWordEvent = null;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                } else if(nclicks == 3</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                          &amp;&amp; SwingUtilities2.canEventAccessSystemClipboard(e)) {</span>
<span class="nc" id="L423">                    Action a = null;</span>
<span class="nc" id="L424">                    ActionMap map = getComponent().getActionMap();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">                    if (map != null) {</span>
<span class="nc" id="L426">                        a = map.get(DefaultEditorKit.selectLineAction);</span>
                    }
<span class="nc bnc" id="L428" title="All 2 branches missed.">                    if (a == null) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                        if (selectLine == null) {</span>
<span class="nc" id="L430">                            selectLine = new DefaultEditorKit.SelectLineAction();</span>
                        }
<span class="nc" id="L432">                        a = selectLine;</span>
                    }
<span class="nc" id="L434">                    a.actionPerformed(new ActionEvent(getComponent(),</span>
<span class="nc" id="L435">                                                      ActionEvent.ACTION_PERFORMED, null, e.getWhen(), e.getModifiers()));</span>
<span class="nc" id="L436">                }</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            } else if (SwingUtilities.isMiddleMouseButton(e)) {</span>
                // mouse 2 behavior
<span class="nc bnc" id="L439" title="All 6 branches missed.">                if (nclicks == 1 &amp;&amp; component.isEditable() &amp;&amp; component.isEnabled()</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">                    &amp;&amp; SwingUtilities2.canEventAccessSystemClipboard(e)) {</span>
                    // paste system selection, if it exists
<span class="nc" id="L442">                    JTextComponent c = (JTextComponent) e.getSource();</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">                    if (c != null) {</span>
                        try {
<span class="nc" id="L445">                            Toolkit tk = c.getToolkit();</span>
<span class="nc" id="L446">                            Clipboard buffer = tk.getSystemSelection();</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                            if (buffer != null) {</span>
                                // platform supports system selections, update it.
<span class="nc" id="L449">                                adjustCaret(e);</span>
<span class="nc" id="L450">                                TransferHandler th = c.getTransferHandler();</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                                if (th != null) {</span>
<span class="nc" id="L452">                                    Transferable trans = null;</span>

                                    try {
<span class="nc" id="L455">                                        trans = buffer.getContents(null);</span>
<span class="nc" id="L456">                                    } catch (IllegalStateException ise) {</span>
                                        // clipboard was unavailable
<span class="nc" id="L458">                                        UIManager.getLookAndFeel().provideErrorFeedback(c);</span>
<span class="nc" id="L459">                                    }</span>

<span class="nc bnc" id="L461" title="All 2 branches missed.">                                    if (trans != null) {</span>
<span class="nc" id="L462">                                        th.importData(c, trans);</span>
                                    }
                                }
<span class="nc" id="L465">                                adjustFocus(true);</span>
                            }
<span class="nc" id="L467">                        } catch (HeadlessException he) {</span>
                            // do nothing... there is no system clipboard
<span class="nc" id="L469">                        }</span>
                    }
                }
            }
        }
<span class="nc" id="L474">    }</span>

    /**
     * If button 1 is pressed, this is implemented to
     * request focus on the associated text component,
     * and to set the caret position. If the shift key is held down,
     * the caret will be moved, potentially resulting in a selection,
     * otherwise the
     * caret position will be set to the new location.  If the component
     * is not enabled, there will be no request for focus.
     *
     * @param e the mouse event
     * @see MouseListener#mousePressed
     */
    public void mousePressed(MouseEvent e) {
<span class="nc" id="L489">        int nclicks = SwingUtilities2.getAdjustedClickCount(getComponent(), e);</span>

<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (SwingUtilities.isLeftMouseButton(e)) {</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (e.isConsumed()) {</span>
<span class="nc" id="L493">                shouldHandleRelease = true;</span>
            } else {
<span class="nc" id="L495">                shouldHandleRelease = false;</span>
<span class="nc" id="L496">                adjustCaretAndFocus(e);</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                if (nclicks == 2</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                    &amp;&amp; SwingUtilities2.canEventAccessSystemClipboard(e)) {</span>
<span class="nc" id="L499">                    selectWord(e);</span>
                }
            }
        }
<span class="nc" id="L503">    }</span>

    void adjustCaretAndFocus(MouseEvent e) {
<span class="nc" id="L506">        adjustCaret(e);</span>
<span class="nc" id="L507">        adjustFocus(false);</span>
<span class="nc" id="L508">    }</span>

    /**
     * Adjusts the caret location based on the MouseEvent.
     */
    private void adjustCaret(MouseEvent e) {
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if ((e.getModifiers() &amp; ActionEvent.SHIFT_MASK) != 0 &amp;&amp;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            getDot() != -1) {</span>
<span class="nc" id="L516">            moveCaret(e);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">        } else if (!e.isPopupTrigger()) {</span>
<span class="nc" id="L518">            positionCaret(e);</span>
        }
<span class="nc" id="L520">    }</span>

    /**
     * Adjusts the focus, if necessary.
     *
     * @param inWindow if true indicates requestFocusInWindow should be used
     */
    private void adjustFocus(boolean inWindow) {
<span class="nc bnc" id="L528" title="All 4 branches missed.">        if ((component != null) &amp;&amp; component.isEnabled() &amp;&amp;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">                                   component.isRequestFocusEnabled()) {</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">            if (inWindow) {</span>
<span class="nc" id="L531">                component.requestFocusInWindow();</span>
            }
            else {
<span class="nc" id="L534">                component.requestFocus();</span>
            }
        }
<span class="nc" id="L537">    }</span>

    /**
     * Called when the mouse is released.
     *
     * @param e the mouse event
     * @see MouseListener#mouseReleased
     */
    public void mouseReleased(MouseEvent e) {
<span class="nc bnc" id="L546" title="All 4 branches missed.">        if (!e.isConsumed()</span>
                &amp;&amp; shouldHandleRelease
<span class="nc bnc" id="L548" title="All 2 branches missed.">                &amp;&amp; SwingUtilities.isLeftMouseButton(e)) {</span>

<span class="nc" id="L550">            adjustCaretAndFocus(e);</span>
        }
<span class="nc" id="L552">    }</span>

    /**
     * Called when the mouse enters a region.
     *
     * @param e the mouse event
     * @see MouseListener#mouseEntered
     */
    public void mouseEntered(MouseEvent e) {
<span class="nc" id="L561">    }</span>

    /**
     * Called when the mouse exits a region.
     *
     * @param e the mouse event
     * @see MouseListener#mouseExited
     */
    public void mouseExited(MouseEvent e) {
<span class="nc" id="L570">    }</span>

    // --- MouseMotionListener methods -------------------------

    /**
     * Moves the caret position
     * according to the mouse pointer's current
     * location.  This effectively extends the
     * selection.  By default, this is only done
     * for mouse button 1.
     *
     * @param e the mouse event
     * @see MouseMotionListener#mouseDragged
     */
    public void mouseDragged(MouseEvent e) {
<span class="nc bnc" id="L585" title="All 4 branches missed.">        if ((! e.isConsumed()) &amp;&amp; SwingUtilities.isLeftMouseButton(e)) {</span>
<span class="nc" id="L586">            moveCaret(e);</span>
        }
<span class="nc" id="L588">    }</span>

    /**
     * Called when the mouse is moved.
     *
     * @param e the mouse event
     * @see MouseMotionListener#mouseMoved
     */
    public void mouseMoved(MouseEvent e) {
<span class="nc" id="L597">    }</span>

    // ---- Caret methods ---------------------------------

    /**
     * Renders the caret as a vertical line.  If this is reimplemented
     * the damage method should also be reimplemented as it assumes the
     * shape of the caret is a vertical line.  Sets the caret color to
     * the value returned by getCaretColor().
     * &lt;p&gt;
     * If there are multiple text directions present in the associated
     * document, a flag indicating the caret bias will be rendered.
     * This will occur only if the associated document is a subclass
     * of AbstractDocument and there are multiple bidi levels present
     * in the bidi element structure (i.e. the text has multiple
     * directions associated with it).
     *
     * @param g the graphics context
     * @see #damage
     */
    public void paint(Graphics g) {
<span class="nc bnc" id="L618" title="All 2 branches missed.">        if(isVisible()) {</span>
            try {
<span class="nc" id="L620">                TextUI mapper = component.getUI();</span>
<span class="nc" id="L621">                Rectangle r = mapper.modelToView(component, dot, dotBias);</span>

<span class="nc bnc" id="L623" title="All 6 branches missed.">                if ((r == null) || ((r.width == 0) &amp;&amp; (r.height == 0))) {</span>
<span class="nc" id="L624">                    return;</span>
                }
<span class="nc bnc" id="L626" title="All 4 branches missed.">                if (width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">                                !this._contains(r.x, r.y, r.width, r.height)) {</span>
                    // We seem to have gotten out of sync and no longer
                    // contain the right location, adjust accordingly.
<span class="nc" id="L630">                    Rectangle clip = g.getClipBounds();</span>

<span class="nc bnc" id="L632" title="All 4 branches missed.">                    if (clip != null &amp;&amp; !clip.contains(this)) {</span>
                        // Clip doesn't contain the old location, force it
                        // to be repainted lest we leave a caret around.
<span class="nc" id="L635">                        repaint();</span>
                    }
                    // This will potentially cause a repaint of something
                    // we're already repainting, but without changing the
                    // semantics of damage we can't really get around this.
<span class="nc" id="L640">                    damage(r);</span>
                }
<span class="nc" id="L642">                g.setColor(component.getCaretColor());</span>
<span class="nc" id="L643">                int paintWidth = getCaretWidth(r.height);</span>
<span class="nc" id="L644">                r.x -= paintWidth  &gt;&gt; 1;</span>
<span class="nc" id="L645">                g.fillRect(r.x, r.y, paintWidth, r.height);</span>

                // see if we should paint a flag to indicate the bias
                // of the caret.
                // PENDING(prinz) this should be done through
                // protected methods so that alternative LAF
                // will show bidi information.
<span class="nc" id="L652">                Document doc = component.getDocument();</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">                if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L654">                    Element bidi = ((AbstractDocument)doc).getBidiRootElement();</span>
<span class="nc bnc" id="L655" title="All 4 branches missed.">                    if ((bidi != null) &amp;&amp; (bidi.getElementCount() &gt; 1)) {</span>
                        // there are multiple directions present.
<span class="nc bnc" id="L657" title="All 2 branches missed.">                        flagXPoints[0] = r.x + ((dotLTR) ? paintWidth : 0);</span>
<span class="nc" id="L658">                        flagYPoints[0] = r.y;</span>
<span class="nc" id="L659">                        flagXPoints[1] = flagXPoints[0];</span>
<span class="nc" id="L660">                        flagYPoints[1] = flagYPoints[0] + 4;</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                        flagXPoints[2] = flagXPoints[0] + ((dotLTR) ? 4 : -4);</span>
<span class="nc" id="L662">                        flagYPoints[2] = flagYPoints[0];</span>
<span class="nc" id="L663">                        g.fillPolygon(flagXPoints, flagYPoints, 3);</span>
                    }
                }
<span class="nc" id="L666">            } catch (BadLocationException e) {</span>
                // can't render I guess
                //System.err.println(&quot;Can't render cursor&quot;);
<span class="nc" id="L669">            }</span>
        }
<span class="nc" id="L671">    }</span>

    /**
     * Called when the UI is being installed into the
     * interface of a JTextComponent.  This can be used
     * to gain access to the model that is being navigated
     * by the implementation of this interface.  Sets the dot
     * and mark to 0, and establishes document, property change,
     * focus, mouse, and mouse motion listeners.
     *
     * @param c the component
     * @see Caret#install
     */
    public void install(JTextComponent c) {
<span class="nc" id="L685">        component = c;</span>
<span class="nc" id="L686">        Document doc = c.getDocument();</span>
<span class="nc" id="L687">        dot = mark = 0;</span>
<span class="nc" id="L688">        dotLTR = markLTR = true;</span>
<span class="nc" id="L689">        dotBias = markBias = Position.Bias.Forward;</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (doc != null) {</span>
<span class="nc" id="L691">            doc.addDocumentListener(handler);</span>
        }
<span class="nc" id="L693">        c.addPropertyChangeListener(handler);</span>
<span class="nc" id="L694">        c.addFocusListener(this);</span>
<span class="nc" id="L695">        c.addMouseListener(this);</span>
<span class="nc" id="L696">        c.addMouseMotionListener(this);</span>

        // if the component already has focus, it won't
        // be notified.
<span class="nc bnc" id="L700" title="All 2 branches missed.">        if (component.hasFocus()) {</span>
<span class="nc" id="L701">            focusGained(null);</span>
        }

<span class="nc" id="L704">        Number ratio = (Number) c.getClientProperty(&quot;caretAspectRatio&quot;);</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">        if (ratio != null) {</span>
<span class="nc" id="L706">            aspectRatio = ratio.floatValue();</span>
        } else {
<span class="nc" id="L708">            aspectRatio = -1;</span>
        }

<span class="nc" id="L711">        Integer width = (Integer) c.getClientProperty(&quot;caretWidth&quot;);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (width != null) {</span>
<span class="nc" id="L713">            caretWidth = width.intValue();</span>
        } else {
<span class="nc" id="L715">            caretWidth = -1;</span>
        }
<span class="nc" id="L717">    }</span>

    /**
     * Called when the UI is being removed from the
     * interface of a JTextComponent.  This is used to
     * unregister any listeners that were attached.
     *
     * @param c the component
     * @see Caret#deinstall
     */
    public void deinstall(JTextComponent c) {
<span class="nc" id="L728">        c.removeMouseListener(this);</span>
<span class="nc" id="L729">        c.removeMouseMotionListener(this);</span>
<span class="nc" id="L730">        c.removeFocusListener(this);</span>
<span class="nc" id="L731">        c.removePropertyChangeListener(handler);</span>
<span class="nc" id="L732">        Document doc = c.getDocument();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">        if (doc != null) {</span>
<span class="nc" id="L734">            doc.removeDocumentListener(handler);</span>
        }
<span class="nc" id="L736">        synchronized(this) {</span>
<span class="nc" id="L737">            component = null;</span>
<span class="nc" id="L738">        }</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">        if (flasher != null) {</span>
<span class="nc" id="L740">            flasher.stop();</span>
        }


<span class="nc" id="L744">    }</span>

    /**
     * Adds a listener to track whenever the caret position has
     * been changed.
     *
     * @param l the listener
     * @see Caret#addChangeListener
     */
    public void addChangeListener(ChangeListener l) {
<span class="nc" id="L754">        listenerList.add(ChangeListener.class, l);</span>
<span class="nc" id="L755">    }</span>

    /**
     * Removes a listener that was tracking caret position changes.
     *
     * @param l the listener
     * @see Caret#removeChangeListener
     */
    public void removeChangeListener(ChangeListener l) {
<span class="nc" id="L764">        listenerList.remove(ChangeListener.class, l);</span>
<span class="nc" id="L765">    }</span>

    /**
     * Returns an array of all the change listeners
     * registered on this caret.
     *
     * @return all of this caret's &lt;code&gt;ChangeListener&lt;/code&gt;s
     *         or an empty
     *         array if no change listeners are currently registered
     *
     * @see #addChangeListener
     * @see #removeChangeListener
     *
     * @since 1.4
     */
    public ChangeListener[] getChangeListeners() {
<span class="nc" id="L781">        return listenerList.getListeners(ChangeListener.class);</span>
    }

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.  The listener list is processed last to first.
     *
     * @see EventListenerList
     */
    protected void fireStateChanged() {
        // Guaranteed to return a non-null array
<span class="nc" id="L794">        Object[] listeners = listenerList.getListenerList();</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L797" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">            if (listeners[i]==ChangeListener.class) {</span>
                // Lazily create the event:
<span class="nc bnc" id="L800" title="All 2 branches missed.">                if (changeEvent == null)</span>
<span class="nc" id="L801">                    changeEvent = new ChangeEvent(this);</span>
<span class="nc" id="L802">                ((ChangeListener)listeners[i+1]).stateChanged(changeEvent);</span>
            }
        }
<span class="nc" id="L805">    }</span>

    /**
     * Returns an array of all the objects currently registered
     * as &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s
     * upon this caret.
     * &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
     * &lt;code&gt;add&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt; method.
     *
     * &lt;p&gt;
     *
     * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
     * with a class literal,
     * such as
     * &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener.class&lt;/code&gt;.
     * For example, you can query a
     * &lt;code&gt;DefaultCaret&lt;/code&gt; &lt;code&gt;c&lt;/code&gt;
     * for its change listeners with the following code:
     *
     * &lt;pre&gt;ChangeListener[] cls = (ChangeListener[])(c.getListeners(ChangeListener.class));&lt;/pre&gt;
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @return an array of all objects registered as
     *          &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s on this component,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt;
     *          doesn't specify a class or interface that implements
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     *
     * @see #getChangeListeners
     *
     * @since 1.3
     */
    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<span class="nc" id="L844">        return listenerList.getListeners(listenerType);</span>
    }

    /**
     * Changes the selection visibility.
     *
     * @param vis the new visibility
     */
    public void setSelectionVisible(boolean vis) {
<span class="nc bnc" id="L853" title="All 2 branches missed.">        if (vis != selectionVisible) {</span>
<span class="nc" id="L854">            selectionVisible = vis;</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">            if (selectionVisible) {</span>
                // show
<span class="nc" id="L857">                Highlighter h = component.getHighlighter();</span>
<span class="nc bnc" id="L858" title="All 6 branches missed.">                if ((dot != mark) &amp;&amp; (h != null) &amp;&amp; (selectionTag == null)) {</span>
<span class="nc" id="L859">                    int p0 = Math.min(dot, mark);</span>
<span class="nc" id="L860">                    int p1 = Math.max(dot, mark);</span>
<span class="nc" id="L861">                    Highlighter.HighlightPainter p = getSelectionPainter();</span>
                    try {
<span class="nc" id="L863">                        selectionTag = h.addHighlight(p0, p1, p);</span>
<span class="nc" id="L864">                    } catch (BadLocationException bl) {</span>
<span class="nc" id="L865">                        selectionTag = null;</span>
<span class="nc" id="L866">                    }</span>
                }
<span class="nc" id="L868">            } else {</span>
                // hide
<span class="nc bnc" id="L870" title="All 2 branches missed.">                if (selectionTag != null) {</span>
<span class="nc" id="L871">                    Highlighter h = component.getHighlighter();</span>
<span class="nc" id="L872">                    h.removeHighlight(selectionTag);</span>
<span class="nc" id="L873">                    selectionTag = null;</span>
                }
            }
        }
<span class="nc" id="L877">    }</span>

    /**
     * Checks whether the current selection is visible.
     *
     * @return true if the selection is visible
     */
    public boolean isSelectionVisible() {
<span class="nc" id="L885">        return selectionVisible;</span>
    }

    /**
     * Determines if the caret is currently active.
     * &lt;p&gt;
     * This method returns whether or not the &lt;code&gt;Caret&lt;/code&gt;
     * is currently in a blinking state. It does not provide
     * information as to whether it is currently blinked on or off.
     * To determine if the caret is currently painted use the
     * &lt;code&gt;isVisible&lt;/code&gt; method.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if active else &lt;code&gt;false&lt;/code&gt;
     * @see #isVisible
     *
     * @since 1.5
     */
    public boolean isActive() {
<span class="nc" id="L903">        return active;</span>
    }

    /**
     * Indicates whether or not the caret is currently visible. As the
     * caret flashes on and off the return value of this will change
     * between true, when the caret is painted, and false, when the
     * caret is not painted. &lt;code&gt;isActive&lt;/code&gt; indicates whether
     * or not the caret is in a blinking state, such that it &lt;b&gt;can&lt;/b&gt;
     * be visible, and &lt;code&gt;isVisible&lt;/code&gt; indicates whether or not
     * the caret &lt;b&gt;is&lt;/b&gt; actually visible.
     * &lt;p&gt;
     * Subclasses that wish to render a different flashing caret
     * should override paint and only paint the caret if this method
     * returns true.
     *
     * @return true if visible else false
     * @see Caret#isVisible
     * @see #isActive
     */
    public boolean isVisible() {
<span class="nc" id="L924">        return visible;</span>
    }

    /**
     * Sets the caret visibility, and repaints the caret.
     * It is important to understand the relationship between this method,
     * &lt;code&gt;isVisible&lt;/code&gt; and &lt;code&gt;isActive&lt;/code&gt;.
     * Calling this method with a value of &lt;code&gt;true&lt;/code&gt; activates the
     * caret blinking. Setting it to &lt;code&gt;false&lt;/code&gt; turns it completely off.
     * To determine whether the blinking is active, you should call
     * &lt;code&gt;isActive&lt;/code&gt;. In effect, &lt;code&gt;isActive&lt;/code&gt; is an
     * appropriate corresponding &quot;getter&quot; method for this one.
     * &lt;code&gt;isVisible&lt;/code&gt; can be used to fetch the current
     * visibility status of the caret, meaning whether or not it is currently
     * painted. This status will change as the caret blinks on and off.
     * &lt;p&gt;
     * Here's a list showing the potential return values of both
     * &lt;code&gt;isActive&lt;/code&gt; and &lt;code&gt;isVisible&lt;/code&gt;
     * after calling this method:
     * &lt;p&gt;
     * &lt;b&gt;&lt;code&gt;setVisible(true)&lt;/code&gt;&lt;/b&gt;:
     * &lt;ul&gt;
     *     &lt;li&gt;isActive(): true&lt;/li&gt;
     *     &lt;li&gt;isVisible(): true or false depending on whether
     *         or not the caret is blinked on or off&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * &lt;b&gt;&lt;code&gt;setVisible(false)&lt;/code&gt;&lt;/b&gt;:
     * &lt;ul&gt;
     *     &lt;li&gt;isActive(): false&lt;/li&gt;
     *     &lt;li&gt;isVisible(): false&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param e the visibility specifier
     * @see #isActive
     * @see Caret#setVisible
     */
    public void setVisible(boolean e) {
        // focus lost notification can come in later after the
        // caret has been deinstalled, in which case the component
        // will be null.
<span class="nc" id="L965">        active = e;</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">        if (component != null) {</span>
<span class="nc" id="L967">            TextUI mapper = component.getUI();</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">            if (visible != e) {</span>
<span class="nc" id="L969">                visible = e;</span>
                // repaint the caret
                try {
<span class="nc" id="L972">                    Rectangle loc = mapper.modelToView(component, dot,dotBias);</span>
<span class="nc" id="L973">                    damage(loc);</span>
<span class="nc" id="L974">                } catch (BadLocationException badloc) {</span>
                    // hmm... not legally positioned
<span class="nc" id="L976">                }</span>
            }
        }
<span class="nc bnc" id="L979" title="All 2 branches missed.">        if (flasher != null) {</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">            if (visible) {</span>
<span class="nc" id="L981">                flasher.start();</span>
            } else {
<span class="nc" id="L983">                flasher.stop();</span>
            }
        }
<span class="nc" id="L986">    }</span>

    /**
     * Sets the caret blink rate.
     *
     * @param rate the rate in milliseconds, 0 to stop blinking
     * @see Caret#setBlinkRate
     */
    public void setBlinkRate(int rate) {
<span class="nc bnc" id="L995" title="All 2 branches missed.">        if (rate != 0) {</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">            if (flasher == null) {</span>
<span class="nc" id="L997">                flasher = new Timer(rate, handler);</span>
            }
<span class="nc" id="L999">            flasher.setDelay(rate);</span>
        } else {
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            if (flasher != null) {</span>
<span class="nc" id="L1002">                flasher.stop();</span>
<span class="nc" id="L1003">                flasher.removeActionListener(handler);</span>
<span class="nc" id="L1004">                flasher = null;</span>
            }
        }
<span class="nc" id="L1007">    }</span>

    /**
     * Gets the caret blink rate.
     *
     * @return the delay in milliseconds.  If this is
     *  zero the caret will not blink.
     * @see Caret#getBlinkRate
     */
    public int getBlinkRate() {
<span class="nc bnc" id="L1017" title="All 2 branches missed.">        return (flasher == null) ? 0 : flasher.getDelay();</span>
    }

    /**
     * Fetches the current position of the caret.
     *
     * @return the position &amp;gt;= 0
     * @see Caret#getDot
     */
    public int getDot() {
<span class="nc" id="L1027">        return dot;</span>
    }

    /**
     * Fetches the current position of the mark.  If there is a selection,
     * the dot and mark will not be the same.
     *
     * @return the position &amp;gt;= 0
     * @see Caret#getMark
     */
    public int getMark() {
<span class="nc" id="L1038">        return mark;</span>
    }

    /**
     * Sets the caret position and mark to the specified position,
     * with a forward bias. This implicitly sets the
     * selection range to zero.
     *
     * @param dot the position &amp;gt;= 0
     * @see #setDot(int, Position.Bias)
     * @see Caret#setDot
     */
    public void setDot(int dot) {
<span class="nc" id="L1051">        setDot(dot, Position.Bias.Forward);</span>
<span class="nc" id="L1052">    }</span>

    /**
     * Moves the caret position to the specified position,
     * with a forward bias.
     *
     * @param dot the position &amp;gt;= 0
     * @see #moveDot(int, javax.swing.text.Position.Bias)
     * @see Caret#moveDot
     */
    public void moveDot(int dot) {
<span class="nc" id="L1063">        moveDot(dot, Position.Bias.Forward);</span>
<span class="nc" id="L1064">    }</span>

    // ---- Bidi methods (we could put these in a subclass)

    /**
     * Moves the caret position to the specified position, with the
     * specified bias.
     *
     * @param dot the position &amp;gt;= 0
     * @param dotBias the bias for this position, not &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if the bias is &lt;code&gt;null&lt;/code&gt;
     * @see Caret#moveDot
     * @since 1.6
     */
    public void moveDot(int dot, Position.Bias dotBias) {
<span class="nc bnc" id="L1079" title="All 2 branches missed.">        if (dotBias == null) {</span>
<span class="nc" id="L1080">            throw new IllegalArgumentException(&quot;null bias&quot;);</span>
        }

<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (! component.isEnabled()) {</span>
            // don't allow selection on disabled components.
<span class="nc" id="L1085">            setDot(dot, dotBias);</span>
<span class="nc" id="L1086">            return;</span>
        }
<span class="nc bnc" id="L1088" title="All 2 branches missed.">        if (dot != this.dot) {</span>
<span class="nc" id="L1089">            NavigationFilter filter = component.getNavigationFilter();</span>

<span class="nc bnc" id="L1091" title="All 2 branches missed.">            if (filter != null) {</span>
<span class="nc" id="L1092">                filter.moveDot(getFilterBypass(), dot, dotBias);</span>
            }
            else {
<span class="nc" id="L1095">                handleMoveDot(dot, dotBias);</span>
            }
        }
<span class="nc" id="L1098">    }</span>

    void handleMoveDot(int dot, Position.Bias dotBias) {
<span class="nc" id="L1101">        changeCaretPosition(dot, dotBias);</span>

<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (selectionVisible) {</span>
<span class="nc" id="L1104">            Highlighter h = component.getHighlighter();</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">            if (h != null) {</span>
<span class="nc" id="L1106">                int p0 = Math.min(dot, mark);</span>
<span class="nc" id="L1107">                int p1 = Math.max(dot, mark);</span>

                // if p0 == p1 then there should be no highlight, remove it if necessary
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                if (p0 == p1) {</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">                    if (selectionTag != null) {</span>
<span class="nc" id="L1112">                        h.removeHighlight(selectionTag);</span>
<span class="nc" id="L1113">                        selectionTag = null;</span>
                    }
                // otherwise, change or add the highlight
                } else {
                    try {
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                        if (selectionTag != null) {</span>
<span class="nc" id="L1119">                            h.changeHighlight(selectionTag, p0, p1);</span>
                        } else {
<span class="nc" id="L1121">                            Highlighter.HighlightPainter p = getSelectionPainter();</span>
<span class="nc" id="L1122">                            selectionTag = h.addHighlight(p0, p1, p);</span>
                        }
<span class="nc" id="L1124">                    } catch (BadLocationException e) {</span>
<span class="nc" id="L1125">                        throw new StateInvariantError(&quot;Bad caret position&quot;);</span>
<span class="nc" id="L1126">                    }</span>
                }
            }
        }
<span class="nc" id="L1130">    }</span>

    /**
     * Sets the caret position and mark to the specified position, with the
     * specified bias. This implicitly sets the selection range
     * to zero.
     *
     * @param dot the position &amp;gt;= 0
     * @param dotBias the bias for this position, not &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if the bias is &lt;code&gt;null&lt;/code&gt;
     * @see Caret#setDot
     * @since 1.6
     */
    public void setDot(int dot, Position.Bias dotBias) {
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        if (dotBias == null) {</span>
<span class="nc" id="L1145">            throw new IllegalArgumentException(&quot;null bias&quot;);</span>
        }

<span class="nc" id="L1148">        NavigationFilter filter = component.getNavigationFilter();</span>

<span class="nc bnc" id="L1150" title="All 2 branches missed.">        if (filter != null) {</span>
<span class="nc" id="L1151">            filter.setDot(getFilterBypass(), dot, dotBias);</span>
        }
        else {
<span class="nc" id="L1154">            handleSetDot(dot, dotBias);</span>
        }
<span class="nc" id="L1156">    }</span>

    void handleSetDot(int dot, Position.Bias dotBias) {
        // move dot, if it changed
<span class="nc" id="L1160">        Document doc = component.getDocument();</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        if (doc != null) {</span>
<span class="nc" id="L1162">            dot = Math.min(dot, doc.getLength());</span>
        }
<span class="nc" id="L1164">        dot = Math.max(dot, 0);</span>

        // The position (0,Backward) is out of range so disallow it.
<span class="nc bnc" id="L1167" title="All 2 branches missed.">        if( dot == 0 )</span>
<span class="nc" id="L1168">            dotBias = Position.Bias.Forward;</span>

<span class="nc" id="L1170">        mark = dot;</span>
<span class="nc bnc" id="L1171" title="All 8 branches missed.">        if (this.dot != dot || this.dotBias != dotBias ||</span>
            selectionTag != null || forceCaretPositionChange) {
<span class="nc" id="L1173">            changeCaretPosition(dot, dotBias);</span>
        }
<span class="nc" id="L1175">        this.markBias = this.dotBias;</span>
<span class="nc" id="L1176">        this.markLTR = dotLTR;</span>
<span class="nc" id="L1177">        Highlighter h = component.getHighlighter();</span>
<span class="nc bnc" id="L1178" title="All 4 branches missed.">        if ((h != null) &amp;&amp; (selectionTag != null)) {</span>
<span class="nc" id="L1179">            h.removeHighlight(selectionTag);</span>
<span class="nc" id="L1180">            selectionTag = null;</span>
        }
<span class="nc" id="L1182">    }</span>

    /**
     * Returns the bias of the caret position.
     *
     * @return the bias of the caret position
     * @since 1.6
     */
    public Position.Bias getDotBias() {
<span class="nc" id="L1191">        return dotBias;</span>
    }

    /**
     * Returns the bias of the mark.
     *
     * @return the bias of the mark
     * @since 1.6
     */
    public Position.Bias getMarkBias() {
<span class="nc" id="L1201">        return markBias;</span>
    }

    boolean isDotLeftToRight() {
<span class="nc" id="L1205">        return dotLTR;</span>
    }

    boolean isMarkLeftToRight() {
<span class="nc" id="L1209">        return markLTR;</span>
    }

    boolean isPositionLTR(int position, Position.Bias bias) {
<span class="nc" id="L1213">        Document doc = component.getDocument();</span>
<span class="nc bnc" id="L1214" title="All 4 branches missed.">        if(bias == Position.Bias.Backward &amp;&amp; --position &lt; 0)</span>
<span class="nc" id="L1215">            position = 0;</span>
<span class="nc" id="L1216">        return AbstractDocument.isLeftToRight(doc, position, position);</span>
    }

    Position.Bias guessBiasForOffset(int offset, Position.Bias lastBias,
                                     boolean lastLTR) {
        // There is an abiguous case here. That if your model looks like:
        // abAB with the cursor at abB]A (visual representation of
        // 3 forward) deleting could either become abB] or
        // ab[B. I'ld actually prefer abB]. But, if I implement that
        // a delete at abBA] would result in aBA] vs a[BA which I
        // think is totally wrong. To get this right we need to know what
        // was deleted. And we could get this from the bidi structure
        // in the change event. So:
        // PENDING: base this off what was deleted.
<span class="nc bnc" id="L1230" title="All 2 branches missed.">        if(lastLTR != isPositionLTR(offset, lastBias)) {</span>
<span class="nc" id="L1231">            lastBias = Position.Bias.Backward;</span>
        }
<span class="nc bnc" id="L1233" title="All 2 branches missed.">        else if(lastBias != Position.Bias.Backward &amp;&amp;</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">                lastLTR != isPositionLTR(offset, Position.Bias.Backward)) {</span>
<span class="nc" id="L1235">            lastBias = Position.Bias.Backward;</span>
        }
<span class="nc bnc" id="L1237" title="All 4 branches missed.">        if (lastBias == Position.Bias.Backward &amp;&amp; offset &gt; 0) {</span>
            try {
<span class="nc" id="L1239">                Segment s = new Segment();</span>
<span class="nc" id="L1240">                component.getDocument().getText(offset - 1, 1, s);</span>
<span class="nc bnc" id="L1241" title="All 4 branches missed.">                if (s.count &gt; 0 &amp;&amp; s.array[s.offset] == '\n') {</span>
<span class="nc" id="L1242">                    lastBias = Position.Bias.Forward;</span>
                }
            }
<span class="nc" id="L1245">            catch (BadLocationException ble) {}</span>
        }
<span class="nc" id="L1247">        return lastBias;</span>
    }

    // ---- local methods --------------------------------------------

    /**
     * Sets the caret position (dot) to a new location.  This
     * causes the old and new location to be repainted.  It
     * also makes sure that the caret is within the visible
     * region of the view, if the view is scrollable.
     */
    void changeCaretPosition(int dot, Position.Bias dotBias) {
        // repaint the old position and set the new value of
        // the dot.
<span class="nc" id="L1261">        repaint();</span>


        // Make sure the caret is visible if this window has the focus.
<span class="nc bnc" id="L1265" title="All 4 branches missed.">        if (flasher != null &amp;&amp; flasher.isRunning()) {</span>
<span class="nc" id="L1266">            visible = true;</span>
<span class="nc" id="L1267">            flasher.restart();</span>
        }

        // notify listeners at the caret moved
<span class="nc" id="L1271">        this.dot = dot;</span>
<span class="nc" id="L1272">        this.dotBias = dotBias;</span>
<span class="nc" id="L1273">        dotLTR = isPositionLTR(dot, dotBias);</span>
<span class="nc" id="L1274">        fireStateChanged();</span>

<span class="nc" id="L1276">        updateSystemSelection();</span>

<span class="nc" id="L1278">        setMagicCaretPosition(null);</span>

        // We try to repaint the caret later, since things
        // may be unstable at the time this is called
        // (i.e. we don't want to depend upon notification
        // order or the fact that this might happen on
        // an unsafe thread).
<span class="nc" id="L1285">        Runnable callRepaintNewCaret = new Runnable() {</span>
            public void run() {
<span class="nc" id="L1287">                repaintNewCaret();</span>
<span class="nc" id="L1288">            }</span>
        };
<span class="nc" id="L1290">        SwingUtilities.invokeLater(callRepaintNewCaret);</span>
<span class="nc" id="L1291">    }</span>

    /**
     * Repaints the new caret position, with the
     * assumption that this is happening on the
     * event thread so that calling &lt;code&gt;modelToView&lt;/code&gt;
     * is safe.
     */
    void repaintNewCaret() {
<span class="nc bnc" id="L1300" title="All 2 branches missed.">        if (component != null) {</span>
<span class="nc" id="L1301">            TextUI mapper = component.getUI();</span>
<span class="nc" id="L1302">            Document doc = component.getDocument();</span>
<span class="nc bnc" id="L1303" title="All 4 branches missed.">            if ((mapper != null) &amp;&amp; (doc != null)) {</span>
                // determine the new location and scroll if
                // not visible.
                Rectangle newLoc;
                try {
<span class="nc" id="L1308">                    newLoc = mapper.modelToView(component, this.dot, this.dotBias);</span>
<span class="nc" id="L1309">                } catch (BadLocationException e) {</span>
<span class="nc" id="L1310">                    newLoc = null;</span>
<span class="nc" id="L1311">                }</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">                if (newLoc != null) {</span>
<span class="nc" id="L1313">                    adjustVisibility(newLoc);</span>
                    // If there is no magic caret position, make one
<span class="nc bnc" id="L1315" title="All 2 branches missed.">                    if (getMagicCaretPosition() == null) {</span>
<span class="nc" id="L1316">                        setMagicCaretPosition(new Point(newLoc.x, newLoc.y));</span>
                    }
                }

                // repaint the new position
<span class="nc" id="L1321">                damage(newLoc);</span>
            }
        }
<span class="nc" id="L1324">    }</span>

    private void updateSystemSelection() {
<span class="nc bnc" id="L1327" title="All 2 branches missed.">        if ( ! SwingUtilities2.canCurrentEventAccessSystemClipboard() ) {</span>
<span class="nc" id="L1328">            return;</span>
        }
<span class="nc bnc" id="L1330" title="All 6 branches missed.">        if (this.dot != this.mark &amp;&amp; component != null &amp;&amp; component.hasFocus()) {</span>
<span class="nc" id="L1331">            Clipboard clip = getSystemSelection();</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">            if (clip != null) {</span>
                String selectedText;
<span class="nc bnc" id="L1334" title="All 2 branches missed.">                if (component instanceof JPasswordField</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">                    &amp;&amp; component.getClientProperty(&quot;JPasswordField.cutCopyAllowed&quot;) !=</span>
                    Boolean.TRUE) {
                    //fix for 4793761
<span class="nc" id="L1338">                    StringBuilder txt = null;</span>
<span class="nc" id="L1339">                    char echoChar = ((JPasswordField)component).getEchoChar();</span>
<span class="nc" id="L1340">                    int p0 = Math.min(getDot(), getMark());</span>
<span class="nc" id="L1341">                    int p1 = Math.max(getDot(), getMark());</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">                    for (int i = p0; i &lt; p1; i++) {</span>
<span class="nc bnc" id="L1343" title="All 2 branches missed.">                        if (txt == null) {</span>
<span class="nc" id="L1344">                            txt = new StringBuilder();</span>
                        }
<span class="nc" id="L1346">                        txt.append(echoChar);</span>
                    }
<span class="nc bnc" id="L1348" title="All 2 branches missed.">                    selectedText = (txt != null) ? txt.toString() : null;</span>
<span class="nc" id="L1349">                } else {</span>
<span class="nc" id="L1350">                    selectedText = component.getSelectedText();</span>
                }
                try {
<span class="nc" id="L1353">                    clip.setContents(</span>
<span class="nc" id="L1354">                        new StringSelection(selectedText), getClipboardOwner());</span>

<span class="nc" id="L1356">                    ownsSelection = true;</span>
<span class="nc" id="L1357">                } catch (IllegalStateException ise) {</span>
                    // clipboard was unavailable
                    // no need to provide error feedback to user since updating
                    // the system selection is not a user invoked action
<span class="nc" id="L1361">                }</span>
            }
        }
<span class="nc" id="L1364">    }</span>

    private Clipboard getSystemSelection() {
        try {
<span class="nc" id="L1368">            return component.getToolkit().getSystemSelection();</span>
<span class="nc" id="L1369">        } catch (HeadlessException he) {</span>
            // do nothing... there is no system clipboard
<span class="nc" id="L1371">        } catch (SecurityException se) {</span>
            // do nothing... there is no allowed system clipboard
<span class="nc" id="L1373">        }</span>
<span class="nc" id="L1374">        return null;</span>
    }

    private ClipboardOwner getClipboardOwner() {
<span class="nc" id="L1378">        return handler;</span>
    }

    /**
     * This is invoked after the document changes to verify the current
     * dot/mark is valid. We do this in case the &lt;code&gt;NavigationFilter&lt;/code&gt;
     * changed where to position the dot, that resulted in the current location
     * being bogus.
     */
    private void ensureValidPosition() {
<span class="nc" id="L1388">        int length = component.getDocument().getLength();</span>
<span class="nc bnc" id="L1389" title="All 4 branches missed.">        if (dot &gt; length || mark &gt; length) {</span>
            // Current location is bogus and filter likely vetoed the
            // change, force the reset without giving the filter a
            // chance at changing it.
<span class="nc" id="L1393">            handleSetDot(length, Position.Bias.Forward);</span>
        }
<span class="nc" id="L1395">    }</span>


    /**
     * Saves the current caret position.  This is used when
     * caret up/down actions occur, moving between lines
     * that have uneven end positions.
     *
     * @param p the position
     * @see #getMagicCaretPosition
     */
    public void setMagicCaretPosition(Point p) {
<span class="nc" id="L1407">        magicCaretPosition = p;</span>
<span class="nc" id="L1408">    }</span>

    /**
     * Gets the saved caret position.
     *
     * @return the position
     * see #setMagicCaretPosition
     */
    public Point getMagicCaretPosition() {
<span class="nc" id="L1417">        return magicCaretPosition;</span>
    }

    /**
     * Compares this object to the specified object.
     * The superclass behavior of comparing rectangles
     * is not desired, so this is changed to the Object
     * behavior.
     *
     * @param     obj   the object to compare this font with
     * @return    &lt;code&gt;true&lt;/code&gt; if the objects are equal;
     *            &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L1431" title="All 2 branches missed.">        return (this == obj);</span>
    }

    public String toString() {
<span class="nc" id="L1435">        String s = &quot;Dot=(&quot; + dot + &quot;, &quot; + dotBias + &quot;)&quot;;</span>
<span class="nc" id="L1436">        s += &quot; Mark=(&quot; + mark + &quot;, &quot; + markBias + &quot;)&quot;;</span>
<span class="nc" id="L1437">        return s;</span>
    }

    private NavigationFilter.FilterBypass getFilterBypass() {
<span class="nc bnc" id="L1441" title="All 2 branches missed.">        if (filterBypass == null) {</span>
<span class="nc" id="L1442">            filterBypass = new DefaultFilterBypass();</span>
        }
<span class="nc" id="L1444">        return filterBypass;</span>
    }

    // Rectangle.contains returns false if passed a rect with a w or h == 0,
    // this won't (assuming X,Y are contained with this rectangle).
    private boolean _contains(int X, int Y, int W, int H) {
<span class="nc" id="L1450">        int w = this.width;</span>
<span class="nc" id="L1451">        int h = this.height;</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">        if ((w | h | W | H) &lt; 0) {</span>
            // At least one of the dimensions is negative...
<span class="nc" id="L1454">            return false;</span>
        }
        // Note: if any dimension is zero, tests below must return false...
<span class="nc" id="L1457">        int x = this.x;</span>
<span class="nc" id="L1458">        int y = this.y;</span>
<span class="nc bnc" id="L1459" title="All 4 branches missed.">        if (X &lt; x || Y &lt; y) {</span>
<span class="nc" id="L1460">            return false;</span>
        }
<span class="nc bnc" id="L1462" title="All 2 branches missed.">        if (W &gt; 0) {</span>
<span class="nc" id="L1463">            w += x;</span>
<span class="nc" id="L1464">            W += X;</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">            if (W &lt;= X) {</span>
                // X+W overflowed or W was zero, return false if...
                // either original w or W was zero or
                // x+w did not overflow or
                // the overflowed x+w is smaller than the overflowed X+W
<span class="nc bnc" id="L1470" title="All 4 branches missed.">                if (w &gt;= x || W &gt; w) return false;</span>
            } else {
                // X+W did not overflow and W was not zero, return false if...
                // original w was zero or
                // x+w did not overflow and x+w is smaller than X+W
<span class="nc bnc" id="L1475" title="All 4 branches missed.">                if (w &gt;= x &amp;&amp; W &gt; w) return false;</span>
            }
        }
<span class="nc bnc" id="L1478" title="All 2 branches missed.">        else if ((x + w) &lt; X) {</span>
<span class="nc" id="L1479">            return false;</span>
        }
<span class="nc bnc" id="L1481" title="All 2 branches missed.">        if (H &gt; 0) {</span>
<span class="nc" id="L1482">            h += y;</span>
<span class="nc" id="L1483">            H += Y;</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">            if (H &lt;= Y) {</span>
<span class="nc bnc" id="L1485" title="All 4 branches missed.">                if (h &gt;= y || H &gt; h) return false;</span>
            } else {
<span class="nc bnc" id="L1487" title="All 4 branches missed.">                if (h &gt;= y &amp;&amp; H &gt; h) return false;</span>
            }
        }
<span class="nc bnc" id="L1490" title="All 2 branches missed.">        else if ((y + h) &lt; Y) {</span>
<span class="nc" id="L1491">            return false;</span>
        }
<span class="nc" id="L1493">        return true;</span>
    }

    int getCaretWidth(int height) {
<span class="nc bnc" id="L1497" title="All 2 branches missed.">        if (aspectRatio &gt; -1) {</span>
<span class="nc" id="L1498">            return (int) (aspectRatio * height) + 1;</span>
        }

<span class="nc bnc" id="L1501" title="All 2 branches missed.">        if (caretWidth &gt; -1) {</span>
<span class="nc" id="L1502">            return caretWidth;</span>
        } else {
<span class="nc" id="L1504">            Object property = UIManager.get(&quot;Caret.width&quot;);</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">            if (property instanceof Integer) {</span>
<span class="nc" id="L1506">                return ((Integer) property).intValue();</span>
            } else {
<span class="nc" id="L1508">                return 1;</span>
            }
        }
    }

    // --- serialization ---------------------------------------------

    private void readObject(ObjectInputStream s)
      throws ClassNotFoundException, IOException
    {
<span class="nc" id="L1518">        s.defaultReadObject();</span>
<span class="nc" id="L1519">        handler = new Handler();</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">        if (!s.readBoolean()) {</span>
<span class="nc" id="L1521">            dotBias = Position.Bias.Forward;</span>
        }
        else {
<span class="nc" id="L1524">            dotBias = Position.Bias.Backward;</span>
        }
<span class="nc bnc" id="L1526" title="All 2 branches missed.">        if (!s.readBoolean()) {</span>
<span class="nc" id="L1527">            markBias = Position.Bias.Forward;</span>
        }
        else {
<span class="nc" id="L1530">            markBias = Position.Bias.Backward;</span>
        }
<span class="nc" id="L1532">    }</span>

    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L1535">        s.defaultWriteObject();</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">        s.writeBoolean((dotBias == Position.Bias.Backward));</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">        s.writeBoolean((markBias == Position.Bias.Backward));</span>
<span class="nc" id="L1538">    }</span>

    // ---- member variables ------------------------------------------

    /**
     * The event listener list.
     */
<span class="nc" id="L1545">    protected EventListenerList listenerList = new EventListenerList();</span>

    /**
     * The change event for the model.
     * Only one ChangeEvent is needed per model instance since the
     * event's only (read-only) state is the source property.  The source
     * of events generated here is always &quot;this&quot;.
     */
<span class="nc" id="L1553">    protected transient ChangeEvent changeEvent = null;</span>

    // package-private to avoid inner classes private member
    // access bug
    JTextComponent component;

<span class="nc" id="L1559">    int updatePolicy = UPDATE_WHEN_ON_EDT;</span>
    boolean visible;
    boolean active;
    int dot;
    int mark;
    Object selectionTag;
    boolean selectionVisible;
    Timer flasher;
    Point magicCaretPosition;
    transient Position.Bias dotBias;
    transient Position.Bias markBias;
    boolean dotLTR;
    boolean markLTR;
<span class="nc" id="L1572">    transient Handler handler = new Handler();</span>
<span class="nc" id="L1573">    transient private int[] flagXPoints = new int[3];</span>
<span class="nc" id="L1574">    transient private int[] flagYPoints = new int[3];</span>
    private transient NavigationFilter.FilterBypass filterBypass;
<span class="nc" id="L1576">    static private transient Action selectWord = null;</span>
<span class="nc" id="L1577">    static private transient Action selectLine = null;</span>
    /**
     * This is used to indicate if the caret currently owns the selection.
     * This is always false if the system does not support the system
     * clipboard.
     */
    private boolean ownsSelection;

    /**
     * If this is true, the location of the dot is updated regardless of
     * the current location. This is set in the DocumentListener
     * such that even if the model location of dot hasn't changed (perhaps do
     * to a forward delete) the visual location is updated.
     */
    private boolean forceCaretPositionChange;

    /**
     * Whether or not mouseReleased should adjust the caret and focus.
     * This flag is set by mousePressed if it wanted to adjust the caret
     * and focus but couldn't because of a possible DnD operation.
     */
    private transient boolean shouldHandleRelease;


    /**
     * holds last MouseEvent which caused the word selection
     */
<span class="nc" id="L1604">    private transient MouseEvent selectedWordEvent = null;</span>

    /**
     * The width of the caret in pixels.
     */
<span class="nc" id="L1609">    private int caretWidth = -1;</span>
<span class="nc" id="L1610">    private float aspectRatio = -1;</span>

    class SafeScroller implements Runnable {

<span class="nc" id="L1614">        SafeScroller(Rectangle r) {</span>
<span class="nc" id="L1615">            this.r = r;</span>
<span class="nc" id="L1616">        }</span>

        public void run() {
<span class="nc bnc" id="L1619" title="All 2 branches missed.">            if (component != null) {</span>
<span class="nc" id="L1620">                component.scrollRectToVisible(r);</span>
            }
<span class="nc" id="L1622">        }</span>

        Rectangle r;
    }


<span class="nc" id="L1628">    class Handler implements PropertyChangeListener, DocumentListener, ActionListener, ClipboardOwner {</span>

        // --- ActionListener methods ----------------------------------

        /**
         * Invoked when the blink timer fires.  This is called
         * asynchronously.  The simply changes the visibility
         * and repaints the rectangle that last bounded the caret.
         *
         * @param e the action event
         */
        public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L1640" title="All 4 branches missed.">            if (width == 0 || height == 0) {</span>
                // setVisible(true) will cause a scroll, only do this if the
                // new location is really valid.
<span class="nc bnc" id="L1643" title="All 2 branches missed.">                if (component != null) {</span>
<span class="nc" id="L1644">                    TextUI mapper = component.getUI();</span>
                    try {
<span class="nc" id="L1646">                        Rectangle r = mapper.modelToView(component, dot,</span>
                                                         dotBias);
<span class="nc bnc" id="L1648" title="All 6 branches missed.">                        if (r != null &amp;&amp; r.width != 0 &amp;&amp; r.height != 0) {</span>
<span class="nc" id="L1649">                            damage(r);</span>
                        }
<span class="nc" id="L1651">                    } catch (BadLocationException ble) {</span>
<span class="nc" id="L1652">                    }</span>
                }
            }
<span class="nc bnc" id="L1655" title="All 2 branches missed.">            visible = !visible;</span>
<span class="nc" id="L1656">            repaint();</span>
<span class="nc" id="L1657">        }</span>

        // --- DocumentListener methods --------------------------------

        /**
         * Updates the dot and mark if they were changed by
         * the insertion.
         *
         * @param e the document event
         * @see DocumentListener#insertUpdate
         */
        public void insertUpdate(DocumentEvent e) {
<span class="nc bnc" id="L1669" title="All 2 branches missed.">            if (getUpdatePolicy() == NEVER_UPDATE ||</span>
<span class="nc bnc" id="L1670" title="All 2 branches missed.">                    (getUpdatePolicy() == UPDATE_WHEN_ON_EDT &amp;&amp;</span>
<span class="nc bnc" id="L1671" title="All 2 branches missed.">                    !SwingUtilities.isEventDispatchThread())) {</span>

<span class="nc bnc" id="L1673" title="All 6 branches missed.">                if ((e.getOffset() &lt;= dot || e.getOffset() &lt;= mark)</span>
                        &amp;&amp; selectionTag != null) {
                    try {
<span class="nc" id="L1676">                        component.getHighlighter().changeHighlight(selectionTag,</span>
<span class="nc" id="L1677">                                Math.min(dot, mark), Math.max(dot, mark));</span>
<span class="nc" id="L1678">                    } catch (BadLocationException e1) {</span>
<span class="nc" id="L1679">                        e1.printStackTrace();</span>
<span class="nc" id="L1680">                    }</span>
                }
<span class="nc" id="L1682">                return;</span>
            }
<span class="nc" id="L1684">            int offset = e.getOffset();</span>
<span class="nc" id="L1685">            int length = e.getLength();</span>
<span class="nc" id="L1686">            int newDot = dot;</span>
<span class="nc" id="L1687">            short changed = 0;</span>

<span class="nc bnc" id="L1689" title="All 2 branches missed.">            if (e instanceof AbstractDocument.UndoRedoDocumentEvent) {</span>
<span class="nc" id="L1690">                setDot(offset + length);</span>
<span class="nc" id="L1691">                return;</span>
            }
<span class="nc bnc" id="L1693" title="All 2 branches missed.">            if (newDot &gt;= offset) {</span>
<span class="nc" id="L1694">                newDot += length;</span>
<span class="nc" id="L1695">                changed |= 1;</span>
            }
<span class="nc" id="L1697">            int newMark = mark;</span>
<span class="nc bnc" id="L1698" title="All 2 branches missed.">            if (newMark &gt;= offset) {</span>
<span class="nc" id="L1699">                newMark += length;</span>
<span class="nc" id="L1700">                changed |= 2;</span>
            }

<span class="nc bnc" id="L1703" title="All 2 branches missed.">            if (changed != 0) {</span>
<span class="nc" id="L1704">                Position.Bias dotBias = DefaultCaret.this.dotBias;</span>
<span class="nc bnc" id="L1705" title="All 2 branches missed.">                if (dot == offset) {</span>
<span class="nc" id="L1706">                    Document doc = component.getDocument();</span>
                    boolean isNewline;
                    try {
<span class="nc" id="L1709">                        Segment s = new Segment();</span>
<span class="nc" id="L1710">                        doc.getText(newDot - 1, 1, s);</span>
<span class="nc bnc" id="L1711" title="All 4 branches missed.">                        isNewline = (s.count &gt; 0 &amp;&amp;</span>
                                s.array[s.offset] == '\n');
<span class="nc" id="L1713">                    } catch (BadLocationException ble) {</span>
<span class="nc" id="L1714">                        isNewline = false;</span>
<span class="nc" id="L1715">                    }</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">                    if (isNewline) {</span>
<span class="nc" id="L1717">                        dotBias = Position.Bias.Forward;</span>
                    } else {
<span class="nc" id="L1719">                        dotBias = Position.Bias.Backward;</span>
                    }
                }
<span class="nc bnc" id="L1722" title="All 2 branches missed.">                if (newMark == newDot) {</span>
<span class="nc" id="L1723">                    setDot(newDot, dotBias);</span>
<span class="nc" id="L1724">                    ensureValidPosition();</span>
                }
                else {
<span class="nc" id="L1727">                    setDot(newMark, markBias);</span>
<span class="nc bnc" id="L1728" title="All 2 branches missed.">                    if (getDot() == newMark) {</span>
                        // Due this test in case the filter vetoed the
                        // change in which case this probably won't be
                        // valid either.
<span class="nc" id="L1732">                        moveDot(newDot, dotBias);</span>
                    }
<span class="nc" id="L1734">                    ensureValidPosition();</span>
                }
            }
<span class="nc" id="L1737">        }</span>

        /**
         * Updates the dot and mark if they were changed
         * by the removal.
         *
         * @param e the document event
         * @see DocumentListener#removeUpdate
         */
        public void removeUpdate(DocumentEvent e) {
<span class="nc bnc" id="L1747" title="All 2 branches missed.">            if (getUpdatePolicy() == NEVER_UPDATE ||</span>
<span class="nc bnc" id="L1748" title="All 2 branches missed.">                    (getUpdatePolicy() == UPDATE_WHEN_ON_EDT &amp;&amp;</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">                    !SwingUtilities.isEventDispatchThread())) {</span>

<span class="nc" id="L1751">                int length = component.getDocument().getLength();</span>
<span class="nc" id="L1752">                dot = Math.min(dot, length);</span>
<span class="nc" id="L1753">                mark = Math.min(mark, length);</span>
<span class="nc bnc" id="L1754" title="All 6 branches missed.">                if ((e.getOffset() &lt; dot || e.getOffset() &lt; mark)</span>
                        &amp;&amp; selectionTag != null) {
                    try {
<span class="nc" id="L1757">                        component.getHighlighter().changeHighlight(selectionTag,</span>
<span class="nc" id="L1758">                                Math.min(dot, mark), Math.max(dot, mark));</span>
<span class="nc" id="L1759">                    } catch (BadLocationException e1) {</span>
<span class="nc" id="L1760">                        e1.printStackTrace();</span>
<span class="nc" id="L1761">                    }</span>
                }
<span class="nc" id="L1763">                return;</span>
            }
<span class="nc" id="L1765">            int offs0 = e.getOffset();</span>
<span class="nc" id="L1766">            int offs1 = offs0 + e.getLength();</span>
<span class="nc" id="L1767">            int newDot = dot;</span>
<span class="nc" id="L1768">            boolean adjustDotBias = false;</span>
<span class="nc" id="L1769">            int newMark = mark;</span>
<span class="nc" id="L1770">            boolean adjustMarkBias = false;</span>

<span class="nc bnc" id="L1772" title="All 2 branches missed.">            if(e instanceof AbstractDocument.UndoRedoDocumentEvent) {</span>
<span class="nc" id="L1773">                setDot(offs0);</span>
<span class="nc" id="L1774">                return;</span>
            }
<span class="nc bnc" id="L1776" title="All 2 branches missed.">            if (newDot &gt;= offs1) {</span>
<span class="nc" id="L1777">                newDot -= (offs1 - offs0);</span>
<span class="nc bnc" id="L1778" title="All 2 branches missed.">                if(newDot == offs1) {</span>
<span class="nc" id="L1779">                    adjustDotBias = true;</span>
                }
<span class="nc bnc" id="L1781" title="All 2 branches missed.">            } else if (newDot &gt;= offs0) {</span>
<span class="nc" id="L1782">                newDot = offs0;</span>
<span class="nc" id="L1783">                adjustDotBias = true;</span>
            }
<span class="nc bnc" id="L1785" title="All 2 branches missed.">            if (newMark &gt;= offs1) {</span>
<span class="nc" id="L1786">                newMark -= (offs1 - offs0);</span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">                if(newMark == offs1) {</span>
<span class="nc" id="L1788">                    adjustMarkBias = true;</span>
                }
<span class="nc bnc" id="L1790" title="All 2 branches missed.">            } else if (newMark &gt;= offs0) {</span>
<span class="nc" id="L1791">                newMark = offs0;</span>
<span class="nc" id="L1792">                adjustMarkBias = true;</span>
            }
<span class="nc bnc" id="L1794" title="All 2 branches missed.">            if (newMark == newDot) {</span>
<span class="nc" id="L1795">                forceCaretPositionChange = true;</span>
                try {
<span class="nc" id="L1797">                    setDot(newDot, guessBiasForOffset(newDot, dotBias,</span>
                            dotLTR));
                } finally {
<span class="nc" id="L1800">                    forceCaretPositionChange = false;</span>
<span class="nc" id="L1801">                }</span>
<span class="nc" id="L1802">                ensureValidPosition();</span>
            } else {
<span class="nc" id="L1804">                Position.Bias dotBias = DefaultCaret.this.dotBias;</span>
<span class="nc" id="L1805">                Position.Bias markBias = DefaultCaret.this.markBias;</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">                if(adjustDotBias) {</span>
<span class="nc" id="L1807">                    dotBias = guessBiasForOffset(newDot, dotBias, dotLTR);</span>
                }
<span class="nc bnc" id="L1809" title="All 2 branches missed.">                if(adjustMarkBias) {</span>
<span class="nc" id="L1810">                    markBias = guessBiasForOffset(mark, markBias, markLTR);</span>
                }
<span class="nc" id="L1812">                setDot(newMark, markBias);</span>
<span class="nc bnc" id="L1813" title="All 2 branches missed.">                if (getDot() == newMark) {</span>
                    // Due this test in case the filter vetoed the change
                    // in which case this probably won't be valid either.
<span class="nc" id="L1816">                    moveDot(newDot, dotBias);</span>
                }
<span class="nc" id="L1818">                ensureValidPosition();</span>
            }
<span class="nc" id="L1820">        }</span>

        /**
         * Gives notification that an attribute or set of attributes changed.
         *
         * @param e the document event
         * @see DocumentListener#changedUpdate
         */
        public void changedUpdate(DocumentEvent e) {
<span class="nc bnc" id="L1829" title="All 2 branches missed.">            if (getUpdatePolicy() == NEVER_UPDATE ||</span>
<span class="nc bnc" id="L1830" title="All 2 branches missed.">                    (getUpdatePolicy() == UPDATE_WHEN_ON_EDT &amp;&amp;</span>
<span class="nc bnc" id="L1831" title="All 2 branches missed.">                    !SwingUtilities.isEventDispatchThread())) {</span>
<span class="nc" id="L1832">                return;</span>
            }
<span class="nc bnc" id="L1834" title="All 2 branches missed.">            if(e instanceof AbstractDocument.UndoRedoDocumentEvent) {</span>
<span class="nc" id="L1835">                setDot(e.getOffset() + e.getLength());</span>
            }
<span class="nc" id="L1837">        }</span>

        // --- PropertyChangeListener methods -----------------------

        /**
         * This method gets called when a bound property is changed.
         * We are looking for document changes on the editor.
         */
        public void propertyChange(PropertyChangeEvent evt) {
<span class="nc" id="L1846">            Object oldValue = evt.getOldValue();</span>
<span class="nc" id="L1847">            Object newValue = evt.getNewValue();</span>
<span class="nc bnc" id="L1848" title="All 4 branches missed.">            if ((oldValue instanceof Document) || (newValue instanceof Document)) {</span>
<span class="nc" id="L1849">                setDot(0);</span>
<span class="nc bnc" id="L1850" title="All 2 branches missed.">                if (oldValue != null) {</span>
<span class="nc" id="L1851">                    ((Document)oldValue).removeDocumentListener(this);</span>
                }
<span class="nc bnc" id="L1853" title="All 2 branches missed.">                if (newValue != null) {</span>
<span class="nc" id="L1854">                    ((Document)newValue).addDocumentListener(this);</span>
                }
<span class="nc bnc" id="L1856" title="All 2 branches missed.">            } else if(&quot;enabled&quot;.equals(evt.getPropertyName())) {</span>
<span class="nc" id="L1857">                Boolean enabled = (Boolean) evt.getNewValue();</span>
<span class="nc bnc" id="L1858" title="All 2 branches missed.">                if(component.isFocusOwner()) {</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">                    if(enabled == Boolean.TRUE) {</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">                        if(component.isEditable()) {</span>
<span class="nc" id="L1861">                            setVisible(true);</span>
                        }
<span class="nc" id="L1863">                        setSelectionVisible(true);</span>
                    } else {
<span class="nc" id="L1865">                        setVisible(false);</span>
<span class="nc" id="L1866">                        setSelectionVisible(false);</span>
                    }
                }
<span class="nc bnc" id="L1869" title="All 2 branches missed.">            } else if(&quot;caretWidth&quot;.equals(evt.getPropertyName())) {</span>
<span class="nc" id="L1870">                Integer newWidth = (Integer) evt.getNewValue();</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">                if (newWidth != null) {</span>
<span class="nc" id="L1872">                    caretWidth = newWidth.intValue();</span>
                } else {
<span class="nc" id="L1874">                    caretWidth = -1;</span>
                }
<span class="nc" id="L1876">                repaint();</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">            } else if(&quot;caretAspectRatio&quot;.equals(evt.getPropertyName())) {</span>
<span class="nc" id="L1878">                Number newRatio = (Number) evt.getNewValue();</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">                if (newRatio != null) {</span>
<span class="nc" id="L1880">                    aspectRatio = newRatio.floatValue();</span>
                } else {
<span class="nc" id="L1882">                    aspectRatio = -1;</span>
                }
<span class="nc" id="L1884">                repaint();</span>
            }
<span class="nc" id="L1886">        }</span>


        //
        // ClipboardOwner
        //
        /**
         * Toggles the visibility of the selection when ownership is lost.
         */
        public void lostOwnership(Clipboard clipboard,
                                      Transferable contents) {
<span class="nc bnc" id="L1897" title="All 2 branches missed.">            if (ownsSelection) {</span>
<span class="nc" id="L1898">                ownsSelection = false;</span>
<span class="nc bnc" id="L1899" title="All 4 branches missed.">                if (component != null &amp;&amp; !component.hasFocus()) {</span>
<span class="nc" id="L1900">                    setSelectionVisible(false);</span>
                }
            }
<span class="nc" id="L1903">        }</span>
    }


<span class="nc" id="L1907">    private class DefaultFilterBypass extends NavigationFilter.FilterBypass {</span>
        public Caret getCaret() {
<span class="nc" id="L1909">            return DefaultCaret.this;</span>
        }

        public void setDot(int dot, Position.Bias bias) {
<span class="nc" id="L1913">            handleSetDot(dot, bias);</span>
<span class="nc" id="L1914">        }</span>

        public void moveDot(int dot, Position.Bias bias) {
<span class="nc" id="L1917">            handleMoveDot(dot, bias);</span>
<span class="nc" id="L1918">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>