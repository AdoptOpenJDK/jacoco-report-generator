<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AsyncBoxView.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">AsyncBoxView.java</span></div><h1>AsyncBoxView.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.util.*;
import java.util.List;
import java.awt.*;
import javax.swing.SwingUtilities;
import javax.swing.event.DocumentEvent;

/**
 * A box that does layout asynchronously.  This
 * is useful to keep the GUI event thread moving by
 * not doing any layout on it.  The layout is done
 * on a granularity of operations on the child views.
 * After each child view is accessed for some part
 * of layout (a potentially time consuming operation)
 * the remaining tasks can be abandoned or a new higher
 * priority task (i.e. to service a synchronous request
 * or a visible area) can be taken on.
 * &lt;p&gt;
 * While the child view is being accessed
 * a read lock is acquired on the associated document
 * so that the model is stable while being accessed.
 *
 * @author  Timothy Prinzing
 * @since   1.3
 */
public class AsyncBoxView extends View {

    /**
     * Construct a box view that does asynchronous layout.
     *
     * @param elem the element of the model to represent
     * @param axis the axis to tile along.  This can be
     *  either X_AXIS or Y_AXIS.
     */
    public AsyncBoxView(Element elem, int axis) {
<span class="nc" id="L61">        super(elem);</span>
<span class="nc" id="L62">        stats = new ArrayList&lt;ChildState&gt;();</span>
<span class="nc" id="L63">        this.axis = axis;</span>
<span class="nc" id="L64">        locator = new ChildLocator();</span>
<span class="nc" id="L65">        flushTask = new FlushTask();</span>
<span class="nc" id="L66">        minorSpan = Short.MAX_VALUE;</span>
<span class="nc" id="L67">        estimatedMajorSpan = false;</span>
<span class="nc" id="L68">    }</span>

    /**
     * Fetch the major axis (the axis the children
     * are tiled along).  This will have a value of
     * either X_AXIS or Y_AXIS.
     */
    public int getMajorAxis() {
<span class="nc" id="L76">        return axis;</span>
    }

    /**
     * Fetch the minor axis (the axis orthogonal
     * to the tiled axis).  This will have a value of
     * either X_AXIS or Y_AXIS.
     */
    public int getMinorAxis() {
<span class="nc bnc" id="L85" title="All 2 branches missed.">        return (axis == X_AXIS) ? Y_AXIS : X_AXIS;</span>
    }

    /**
     * Get the top part of the margin around the view.
     */
    public float getTopInset() {
<span class="nc" id="L92">        return topInset;</span>
    }

    /**
     * Set the top part of the margin around the view.
     *
     * @param i the value of the inset
     */
    public void setTopInset(float i) {
<span class="nc" id="L101">        topInset = i;</span>
<span class="nc" id="L102">    }</span>

    /**
     * Get the bottom part of the margin around the view.
     */
    public float getBottomInset() {
<span class="nc" id="L108">        return bottomInset;</span>
    }

    /**
     * Set the bottom part of the margin around the view.
     *
     * @param i the value of the inset
     */
    public void setBottomInset(float i) {
<span class="nc" id="L117">        bottomInset = i;</span>
<span class="nc" id="L118">    }</span>

    /**
     * Get the left part of the margin around the view.
     */
    public float getLeftInset() {
<span class="nc" id="L124">        return leftInset;</span>
    }

    /**
     * Set the left part of the margin around the view.
     *
     * @param i the value of the inset
     */
    public void setLeftInset(float i) {
<span class="nc" id="L133">        leftInset = i;</span>
<span class="nc" id="L134">    }</span>

    /**
     * Get the right part of the margin around the view.
     */
    public float getRightInset() {
<span class="nc" id="L140">        return rightInset;</span>
    }

    /**
     * Set the right part of the margin around the view.
     *
     * @param i the value of the inset
     */
    public void setRightInset(float i) {
<span class="nc" id="L149">        rightInset = i;</span>
<span class="nc" id="L150">    }</span>

    /**
     * Fetch the span along an axis that is taken up by the insets.
     *
     * @param axis the axis to determine the total insets along,
     *  either X_AXIS or Y_AXIS.
     * @since 1.4
     */
    protected float getInsetSpan(int axis) {
<span class="nc bnc" id="L160" title="All 2 branches missed.">        float margin = (axis == X_AXIS) ?</span>
<span class="nc" id="L161">            getLeftInset() + getRightInset() : getTopInset() + getBottomInset();</span>
<span class="nc" id="L162">        return margin;</span>
    }

    /**
     * Set the estimatedMajorSpan property that determines if the
     * major span should be treated as being estimated.  If this
     * property is true, the value of setSize along the major axis
     * will change the requirements along the major axis and incremental
     * changes will be ignored until all of the children have been updated
     * (which will cause the property to automatically be set to false).
     * If the property is false the value of the majorSpan will be
     * considered to be accurate and incremental changes will be
     * added into the total as they are calculated.
     *
     * @since 1.4
     */
    protected void setEstimatedMajorSpan(boolean isEstimated) {
<span class="nc" id="L179">        estimatedMajorSpan = isEstimated;</span>
<span class="nc" id="L180">    }</span>

    /**
     * Is the major span currently estimated?
     *
     * @since 1.4
     */
    protected boolean getEstimatedMajorSpan() {
<span class="nc" id="L188">        return estimatedMajorSpan;</span>
    }

    /**
     * Fetch the object representing the layout state of
     * of the child at the given index.
     *
     * @param index the child index.  This should be a
     *   value &amp;gt;= 0 and &amp;lt; getViewCount().
     */
    protected ChildState getChildState(int index) {
<span class="nc" id="L199">        synchronized(stats) {</span>
<span class="nc bnc" id="L200" title="All 4 branches missed.">            if ((index &gt;= 0) &amp;&amp; (index &lt; stats.size())) {</span>
<span class="nc" id="L201">                return stats.get(index);</span>
            }
<span class="nc" id="L203">            return null;</span>
<span class="nc" id="L204">        }</span>
    }

    /**
     * Fetch the queue to use for layout.
     */
    protected LayoutQueue getLayoutQueue() {
<span class="nc" id="L211">        return LayoutQueue.getDefaultQueue();</span>
    }

    /**
     * New ChildState records are created through
     * this method to allow subclasses the extend
     * the ChildState records to do/hold more
     */
    protected ChildState createChildState(View v) {
<span class="nc" id="L220">        return new ChildState(v);</span>
    }

    /**
     * Requirements changed along the major axis.
     * This is called by the thread doing layout for
     * the given ChildState object when it has completed
     * fetching the child views new preferences.
     * Typically this would be the layout thread, but
     * might be the event thread if it is trying to update
     * something immediately (such as to perform a
     * model/view translation).
     * &lt;p&gt;
     * This is implemented to mark the major axis as having
     * changed so that a future check to see if the requirements
     * need to be published to the parent view will consider
     * the major axis.  If the span along the major axis is
     * not estimated, it is updated by the given delta to reflect
     * the incremental change.  The delta is ignored if the
     * major span is estimated.
     */
    protected synchronized void majorRequirementChange(ChildState cs, float delta) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (estimatedMajorSpan == false) {</span>
<span class="nc" id="L243">            majorSpan += delta;</span>
        }
<span class="nc" id="L245">        majorChanged = true;</span>
<span class="nc" id="L246">    }</span>

    /**
     * Requirements changed along the minor axis.
     * This is called by the thread doing layout for
     * the given ChildState object when it has completed
     * fetching the child views new preferences.
     * Typically this would be the layout thread, but
     * might be the GUI thread if it is trying to update
     * something immediately (such as to perform a
     * model/view translation).
     */
    protected synchronized void minorRequirementChange(ChildState cs) {
<span class="nc" id="L259">        minorChanged = true;</span>
<span class="nc" id="L260">    }</span>

    /**
     * Publish the changes in preferences upward to the parent
     * view.  This is normally called by the layout thread.
     */
    protected void flushRequirementChanges() {
<span class="nc" id="L267">        AbstractDocument doc = (AbstractDocument) getDocument();</span>
        try {
<span class="nc" id="L269">            doc.readLock();</span>

<span class="nc" id="L271">            View parent = null;</span>
<span class="nc" id="L272">            boolean horizontal = false;</span>
<span class="nc" id="L273">            boolean vertical = false;</span>

<span class="nc" id="L275">            synchronized(this) {</span>
                // perform tasks that iterate over the children while
                // preventing the collection from changing.
<span class="nc" id="L278">                synchronized(stats) {</span>
<span class="nc" id="L279">                    int n = getViewCount();</span>
<span class="nc bnc" id="L280" title="All 6 branches missed.">                    if ((n &gt; 0) &amp;&amp; (minorChanged || estimatedMajorSpan)) {</span>
<span class="nc" id="L281">                        LayoutQueue q = getLayoutQueue();</span>
<span class="nc" id="L282">                        ChildState min = getChildState(0);</span>
<span class="nc" id="L283">                        ChildState pref = getChildState(0);</span>
<span class="nc" id="L284">                        float span = 0f;</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                        for (int i = 1; i &lt; n; i++) {</span>
<span class="nc" id="L286">                            ChildState cs = getChildState(i);</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                            if (minorChanged) {</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">                                if (cs.min &gt; min.min) {</span>
<span class="nc" id="L289">                                    min = cs;</span>
                                }
<span class="nc bnc" id="L291" title="All 2 branches missed.">                                if (cs.pref &gt; pref.pref) {</span>
<span class="nc" id="L292">                                    pref = cs;</span>
                                }
                            }
<span class="nc bnc" id="L295" title="All 2 branches missed.">                            if (estimatedMajorSpan) {</span>
<span class="nc" id="L296">                                span += cs.getMajorSpan();</span>
                            }
                        }

<span class="nc bnc" id="L300" title="All 2 branches missed.">                        if (minorChanged) {</span>
<span class="nc" id="L301">                            minRequest = min;</span>
<span class="nc" id="L302">                            prefRequest = pref;</span>
                        }
<span class="nc bnc" id="L304" title="All 2 branches missed.">                        if (estimatedMajorSpan) {</span>
<span class="nc" id="L305">                            majorSpan = span;</span>
<span class="nc" id="L306">                            estimatedMajorSpan = false;</span>
<span class="nc" id="L307">                            majorChanged = true;</span>
                        }
                    }
<span class="nc" id="L310">                }</span>

                // message preferenceChanged
<span class="nc bnc" id="L313" title="All 4 branches missed.">                if (majorChanged || minorChanged) {</span>
<span class="nc" id="L314">                    parent = getParent();</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">                    if (parent != null) {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                        if (axis == X_AXIS) {</span>
<span class="nc" id="L317">                            horizontal = majorChanged;</span>
<span class="nc" id="L318">                            vertical = minorChanged;</span>
                        } else {
<span class="nc" id="L320">                            vertical = majorChanged;</span>
<span class="nc" id="L321">                            horizontal = minorChanged;</span>
                        }
                    }
<span class="nc" id="L324">                    majorChanged = false;</span>
<span class="nc" id="L325">                    minorChanged = false;</span>
                }
<span class="nc" id="L327">            }</span>

            // propagate a preferenceChanged, using the
            // layout thread.
<span class="nc bnc" id="L331" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L332">                parent.preferenceChanged(this, horizontal, vertical);</span>

                // probably want to change this to be more exact.
<span class="nc" id="L335">                Component c = getContainer();</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                if (c != null) {</span>
<span class="nc" id="L337">                    c.repaint();</span>
                }
            }
        } finally {
<span class="nc" id="L341">            doc.readUnlock();</span>
<span class="nc" id="L342">        }</span>
<span class="nc" id="L343">    }</span>

    /**
     * Calls the superclass to update the child views, and
     * updates the status records for the children.  This
     * is expected to be called while a write lock is held
     * on the model so that interaction with the layout
     * thread will not happen (i.e. the layout thread
     * acquires a read lock before doing anything).
     *
     * @param offset the starting offset into the child views &amp;gt;= 0
     * @param length the number of existing views to replace &amp;gt;= 0
     * @param views the child views to insert
     */
    public void replace(int offset, int length, View[] views) {
<span class="nc" id="L358">        synchronized(stats) {</span>
            // remove the replaced state records
<span class="nc bnc" id="L360" title="All 2 branches missed.">            for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L361">                ChildState cs = stats.remove(offset);</span>
<span class="nc" id="L362">                float csSpan = cs.getMajorSpan();</span>

<span class="nc" id="L364">                cs.getChildView().setParent(null);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                if (csSpan != 0) {</span>
<span class="nc" id="L366">                    majorRequirementChange(cs, -csSpan);</span>
                }
            }

            // insert the state records for the new children
<span class="nc" id="L371">            LayoutQueue q = getLayoutQueue();</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (views != null) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">                for (int i = 0; i &lt; views.length; i++) {</span>
<span class="nc" id="L374">                    ChildState s = createChildState(views[i]);</span>
<span class="nc" id="L375">                    stats.add(offset + i, s);</span>
<span class="nc" id="L376">                    q.addTask(s);</span>
                }
            }

            // notify that the size changed
<span class="nc" id="L381">            q.addTask(flushTask);</span>
<span class="nc" id="L382">        }</span>
<span class="nc" id="L383">    }</span>

    /**
     * Loads all of the children to initialize the view.
     * This is called by the {@link #setParent setParent}
     * method.  Subclasses can reimplement this to initialize
     * their child views in a different manner.  The default
     * implementation creates a child view for each
     * child element.
     * &lt;p&gt;
     * Normally a write-lock is held on the Document while
     * the children are being changed, which keeps the rendering
     * and layout threads safe.  The exception to this is when
     * the view is initialized to represent an existing element
     * (via this method), so it is synchronized to exclude
     * preferenceChanged while we are initializing.
     *
     * @param f the view factory
     * @see #setParent
     */
    protected void loadChildren(ViewFactory f) {
<span class="nc" id="L404">        Element e = getElement();</span>
<span class="nc" id="L405">        int n = e.getElementCount();</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (n &gt; 0) {</span>
<span class="nc" id="L407">            View[] added = new View[n];</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L409">                added[i] = f.create(e.getElement(i));</span>
            }
<span class="nc" id="L411">            replace(0, 0, added);</span>
        }
<span class="nc" id="L413">    }</span>

    /**
     * Fetches the child view index representing the given position in
     * the model.  This is implemented to fetch the view in the case
     * where there is a child view for each child element.
     *
     * @param pos the position &amp;gt;= 0
     * @return  index of the view representing the given position, or
     *   -1 if no view represents that position
     */
    protected synchronized int getViewIndexAtPosition(int pos, Position.Bias b) {
<span class="nc bnc" id="L425" title="All 2 branches missed.">        boolean isBackward = (b == Position.Bias.Backward);</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">        pos = (isBackward) ? Math.max(0, pos - 1) : pos;</span>
<span class="nc" id="L427">        Element elem = getElement();</span>
<span class="nc" id="L428">        return elem.getElementIndex(pos);</span>
    }

    /**
     * Update the layout in response to receiving notification of
     * change from the model.  This is implemented to note the
     * change on the ChildLocator so that offsets of the children
     * will be correctly computed.
     *
     * @param ec changes to the element this view is responsible
     *  for (may be null if there were no changes).
     * @param e the change information from the associated document
     * @param a the current allocation of the view
     * @see #insertUpdate
     * @see #removeUpdate
     * @see #changedUpdate
     */
    protected void updateLayout(DocumentEvent.ElementChange ec,
                                    DocumentEvent e, Shape a) {
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (ec != null) {</span>
            // the newly inserted children don't have a valid
            // offset so the child locator needs to be messaged
            // that the child prior to the new children has
            // changed size.
<span class="nc" id="L452">            int index = Math.max(ec.getIndex() - 1, 0);</span>
<span class="nc" id="L453">            ChildState cs = getChildState(index);</span>
<span class="nc" id="L454">            locator.childChanged(cs);</span>
        }
<span class="nc" id="L456">    }</span>

    // --- View methods ------------------------------------

    /**
     * Sets the parent of the view.
     * This is reimplemented to provide the superclass
     * behavior as well as calling the &lt;code&gt;loadChildren&lt;/code&gt;
     * method if this view does not already have children.
     * The children should not be loaded in the
     * constructor because the act of setting the parent
     * may cause them to try to search up the hierarchy
     * (to get the hosting Container for example).
     * If this view has children (the view is being moved
     * from one place in the view hierarchy to another),
     * the &lt;code&gt;loadChildren&lt;/code&gt; method will not be called.
     *
     * @param parent the parent of the view, null if none
     */
    public void setParent(View parent) {
<span class="nc" id="L476">        super.setParent(parent);</span>
<span class="nc bnc" id="L477" title="All 4 branches missed.">        if ((parent != null) &amp;&amp; (getViewCount() == 0)) {</span>
<span class="nc" id="L478">            ViewFactory f = getViewFactory();</span>
<span class="nc" id="L479">            loadChildren(f);</span>
        }
<span class="nc" id="L481">    }</span>

    /**
     * Child views can call this on the parent to indicate that
     * the preference has changed and should be reconsidered
     * for layout.  This is reimplemented to queue new work
     * on the layout thread.  This method gets messaged from
     * multiple threads via the children.
     *
     * @param child the child view
     * @param width true if the width preference has changed
     * @param height true if the height preference has changed
     * @see javax.swing.JComponent#revalidate
     */
    public synchronized void preferenceChanged(View child, boolean width, boolean height) {
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (child == null) {</span>
<span class="nc" id="L497">            getParent().preferenceChanged(this, width, height);</span>
        } else {
<span class="nc bnc" id="L499" title="All 2 branches missed.">            if (changing != null) {</span>
<span class="nc" id="L500">                View cv = changing.getChildView();</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">                if (cv == child) {</span>
                    // size was being changed on the child, no need to
                    // queue work for it.
<span class="nc" id="L504">                    changing.preferenceChanged(width, height);</span>
<span class="nc" id="L505">                    return;</span>
                }
            }
<span class="nc" id="L508">            int index = getViewIndex(child.getStartOffset(),</span>
                                     Position.Bias.Forward);
<span class="nc" id="L510">            ChildState cs = getChildState(index);</span>
<span class="nc" id="L511">            cs.preferenceChanged(width, height);</span>
<span class="nc" id="L512">            LayoutQueue q = getLayoutQueue();</span>
<span class="nc" id="L513">            q.addTask(cs);</span>
<span class="nc" id="L514">            q.addTask(flushTask);</span>
        }
<span class="nc" id="L516">    }</span>

    /**
     * Sets the size of the view.  This should cause
     * layout of the view if the view caches any layout
     * information.
     * &lt;p&gt;
     * Since the major axis is updated asynchronously and should be
     * the sum of the tiled children the call is ignored for the major
     * axis.  Since the minor axis is flexible, work is queued to resize
     * the children if the minor span changes.
     *
     * @param width the width &amp;gt;= 0
     * @param height the height &amp;gt;= 0
     */
    public void setSize(float width, float height) {
<span class="nc" id="L532">        setSpanOnAxis(X_AXIS, width);</span>
<span class="nc" id="L533">        setSpanOnAxis(Y_AXIS, height);</span>
<span class="nc" id="L534">    }</span>

    /**
     * Retrieves the size of the view along an axis.
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt; or
     *          &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @return the current span of the view along the given axis, &gt;= 0
     */
    float getSpanOnAxis(int axis) {
<span class="nc bnc" id="L544" title="All 2 branches missed.">        if (axis == getMajorAxis()) {</span>
<span class="nc" id="L545">            return majorSpan;</span>
        }
<span class="nc" id="L547">        return minorSpan;</span>
    }

    /**
     * Sets the size of the view along an axis.  Since the major
     * axis is updated asynchronously and should be the sum of the
     * tiled children the call is ignored for the major axis.  Since
     * the minor axis is flexible, work is queued to resize the
     * children if the minor span changes.
     *
     * @param axis may be either &lt;code&gt;View.X_AXIS&lt;/code&gt; or
     *          &lt;code&gt;View.Y_AXIS&lt;/code&gt;
     * @param span the span to layout to &gt;= 0
     */
    void setSpanOnAxis(int axis, float span) {
<span class="nc" id="L562">        float margin = getInsetSpan(axis);</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (axis == getMinorAxis()) {</span>
<span class="nc" id="L564">            float targetSpan = span - margin;</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if (targetSpan != minorSpan) {</span>
<span class="nc" id="L566">                minorSpan = targetSpan;</span>

                // mark all of the ChildState instances as needing to
                // resize the child, and queue up work to fix them.
<span class="nc" id="L570">                int n = getViewCount();</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">                if (n != 0) {</span>
<span class="nc" id="L572">                    LayoutQueue q = getLayoutQueue();</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">                    for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L574">                        ChildState cs = getChildState(i);</span>
<span class="nc" id="L575">                        cs.childSizeValid = false;</span>
<span class="nc" id="L576">                        q.addTask(cs);</span>
                    }
<span class="nc" id="L578">                    q.addTask(flushTask);</span>
                }
            }
<span class="nc" id="L581">        } else {</span>
            // along the major axis the value is ignored
            // unless the estimatedMajorSpan property is
            // true.
<span class="nc bnc" id="L585" title="All 2 branches missed.">            if (estimatedMajorSpan) {</span>
<span class="nc" id="L586">                majorSpan = span - margin;</span>
            }
        }
<span class="nc" id="L589">    }</span>

    /**
     * Render the view using the given allocation and
     * rendering surface.
     * &lt;p&gt;
     * This is implemented to determine whether or not the
     * desired region to be rendered (i.e. the unclipped
     * area) is up to date or not.  If up-to-date the children
     * are rendered.  If not up-to-date, a task to build
     * the desired area is placed on the layout queue as
     * a high priority task.  This keeps by event thread
     * moving by rendering if ready, and postponing until
     * a later time if not ready (since paint requests
     * can be rescheduled).
     *
     * @param g the rendering surface to use
     * @param alloc the allocated region to render into
     * @see View#paint
     */
    public void paint(Graphics g, Shape alloc) {
<span class="nc" id="L610">        synchronized (locator) {</span>
<span class="nc" id="L611">            locator.setAllocation(alloc);</span>
<span class="nc" id="L612">            locator.paintChildren(g);</span>
<span class="nc" id="L613">        }</span>
<span class="nc" id="L614">    }</span>

    /**
     * Determines the preferred span for this view along an
     * axis.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return   the span the view would like to be rendered into &amp;gt;= 0.
     *           Typically the view is told to render into the span
     *           that is returned, although there is no guarantee.
     *           The parent may choose to resize or break the view.
     * @exception IllegalArgumentException for an invalid axis type
     */
    public float getPreferredSpan(int axis) {
<span class="nc" id="L628">        float margin = getInsetSpan(axis);</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">        if (axis == this.axis) {</span>
<span class="nc" id="L630">            return majorSpan + margin;</span>
        }
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (prefRequest != null) {</span>
<span class="nc" id="L633">            View child = prefRequest.getChildView();</span>
<span class="nc" id="L634">            return child.getPreferredSpan(axis) + margin;</span>
        }

        // nothing is known about the children yet
<span class="nc" id="L638">        return margin + 30;</span>
    }

    /**
     * Determines the minimum span for this view along an
     * axis.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return  the span the view would like to be rendered into &amp;gt;= 0.
     *           Typically the view is told to render into the span
     *           that is returned, although there is no guarantee.
     *           The parent may choose to resize or break the view.
     * @exception IllegalArgumentException for an invalid axis type
     */
    public float getMinimumSpan(int axis) {
<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (axis == this.axis) {</span>
<span class="nc" id="L654">            return getPreferredSpan(axis);</span>
        }
<span class="nc bnc" id="L656" title="All 2 branches missed.">        if (minRequest != null) {</span>
<span class="nc" id="L657">            View child = minRequest.getChildView();</span>
<span class="nc" id="L658">            return child.getMinimumSpan(axis);</span>
        }

        // nothing is known about the children yet
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (axis == X_AXIS) {</span>
<span class="nc" id="L663">            return getLeftInset() + getRightInset() + 5;</span>
        } else {
<span class="nc" id="L665">            return getTopInset() + getBottomInset() + 5;</span>
        }
    }

    /**
     * Determines the maximum span for this view along an
     * axis.
     *
     * @param axis may be either View.X_AXIS or View.Y_AXIS
     * @return   the span the view would like to be rendered into &amp;gt;= 0.
     *           Typically the view is told to render into the span
     *           that is returned, although there is no guarantee.
     *           The parent may choose to resize or break the view.
     * @exception IllegalArgumentException for an invalid axis type
     */
    public float getMaximumSpan(int axis) {
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (axis == this.axis) {</span>
<span class="nc" id="L682">            return getPreferredSpan(axis);</span>
        }
<span class="nc" id="L684">        return Integer.MAX_VALUE;</span>
    }


    /**
     * Returns the number of views in this view.  Since
     * the default is to not be a composite view this
     * returns 0.
     *
     * @return the number of views &amp;gt;= 0
     * @see View#getViewCount
     */
    public int getViewCount() {
<span class="nc" id="L697">        synchronized(stats) {</span>
<span class="nc" id="L698">            return stats.size();</span>
<span class="nc" id="L699">        }</span>
    }

    /**
     * Gets the nth child view.  Since there are no
     * children by default, this returns null.
     *
     * @param n the number of the view to get, &amp;gt;= 0 &amp;amp;&amp;amp; &amp;lt; getViewCount()
     * @return the view
     */
    public View getView(int n) {
<span class="nc" id="L710">        ChildState cs = getChildState(n);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (cs != null) {</span>
<span class="nc" id="L712">            return cs.getChildView();</span>
        }
<span class="nc" id="L714">        return null;</span>
    }

    /**
     * Fetches the allocation for the given child view.
     * This enables finding out where various views
     * are located, without assuming the views store
     * their location.  This returns null since the
     * default is to not have any child views.
     *
     * @param index the index of the child, &amp;gt;= 0 &amp;amp;&amp;amp; &amp;lt; getViewCount()
     * @param a  the allocation to this view.
     * @return the allocation to the child
     */
    public Shape getChildAllocation(int index, Shape a) {
<span class="nc" id="L729">        Shape ca = locator.getChildAllocation(index, a);</span>
<span class="nc" id="L730">        return ca;</span>
    }

    /**
     * Returns the child view index representing the given position in
     * the model.  By default a view has no children so this is implemented
     * to return -1 to indicate there is no valid child index for any
     * position.
     *
     * @param pos the position &amp;gt;= 0
     * @return  index of the view representing the given position, or
     *   -1 if no view represents that position
     * @since 1.3
     */
    public int getViewIndex(int pos, Position.Bias b) {
<span class="nc" id="L745">        return getViewIndexAtPosition(pos, b);</span>
    }

    /**
     * Provides a mapping from the document model coordinate space
     * to the coordinate space of the view mapped to it.
     *
     * @param pos the position to convert &amp;gt;= 0
     * @param a the allocated region to render into
     * @param b the bias toward the previous character or the
     *  next character represented by the offset, in case the
     *  position is a boundary of two views.
     * @return the bounding box of the given position is returned
     * @exception BadLocationException  if the given position does
     *   not represent a valid location in the associated document
     * @exception IllegalArgumentException for an invalid bias argument
     * @see View#viewToModel
     */
    public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
<span class="nc" id="L764">        int index = getViewIndex(pos, b);</span>
<span class="nc" id="L765">        Shape ca = locator.getChildAllocation(index, a);</span>

        // forward to the child view, and make sure we don't
        // interact with the layout thread by synchronizing
        // on the child state.
<span class="nc" id="L770">        ChildState cs = getChildState(index);</span>
<span class="nc" id="L771">        synchronized (cs) {</span>
<span class="nc" id="L772">            View cv = cs.getChildView();</span>
<span class="nc" id="L773">            Shape v = cv.modelToView(pos, ca, b);</span>
<span class="nc" id="L774">            return v;</span>
<span class="nc" id="L775">        }</span>
    }

    /**
     * Provides a mapping from the view coordinate space to the logical
     * coordinate space of the model.  The biasReturn argument will be
     * filled in to indicate that the point given is closer to the next
     * character in the model or the previous character in the model.
     * &lt;p&gt;
     * This is expected to be called by the GUI thread, holding a
     * read-lock on the associated model.  It is implemented to
     * locate the child view and determine it's allocation with a
     * lock on the ChildLocator object, and to call viewToModel
     * on the child view with a lock on the ChildState object
     * to avoid interaction with the layout thread.
     *
     * @param x the X coordinate &amp;gt;= 0
     * @param y the Y coordinate &amp;gt;= 0
     * @param a the allocated region to render into
     * @return the location within the model that best represents the
     *  given point in the view &amp;gt;= 0.  The biasReturn argument will be
     * filled in to indicate that the point given is closer to the next
     * character in the model or the previous character in the model.
     */
    public int viewToModel(float x, float y, Shape a, Position.Bias[] biasReturn) {
        int pos;    // return position
        int index;  // child index to forward to
        Shape ca;   // child allocation

        // locate the child view and it's allocation so that
        // we can forward to it.  Make sure the layout thread
        // doesn't change anything by trying to flush changes
        // to the parent while the GUI thread is trying to
        // find the child and it's allocation.
<span class="nc" id="L809">        synchronized (locator) {</span>
<span class="nc" id="L810">            index = locator.getViewIndexAtPoint(x, y, a);</span>
<span class="nc" id="L811">            ca = locator.getChildAllocation(index, a);</span>
<span class="nc" id="L812">        }</span>

        // forward to the child view, and make sure we don't
        // interact with the layout thread by synchronizing
        // on the child state.
<span class="nc" id="L817">        ChildState cs = getChildState(index);</span>
<span class="nc" id="L818">        synchronized (cs) {</span>
<span class="nc" id="L819">            View v = cs.getChildView();</span>
<span class="nc" id="L820">            pos = v.viewToModel(x, y, ca, biasReturn);</span>
<span class="nc" id="L821">        }</span>
<span class="nc" id="L822">        return pos;</span>
    }

    /**
     * Provides a way to determine the next visually represented model
     * location that one might place a caret.  Some views may not be visible,
     * they might not be in the same order found in the model, or they just
     * might not allow access to some of the locations in the model.
     * This method enables specifying a position to convert
     * within the range of &amp;gt;=0.  If the value is -1, a position
     * will be calculated automatically.  If the value &amp;lt; -1,
     * the {@code BadLocationException} will be thrown.
     *
     * @param pos the position to convert
     * @param a the allocated region to render into
     * @param direction the direction from the current position that can
     *  be thought of as the arrow keys typically found on a keyboard;
     *  this may be one of the following:
     *  &lt;ul style=&quot;list-style-type:none&quot;&gt;
     *  &lt;li&gt;&lt;code&gt;SwingConstants.WEST&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;&lt;code&gt;SwingConstants.EAST&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;&lt;code&gt;SwingConstants.NORTH&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;&lt;code&gt;SwingConstants.SOUTH&lt;/code&gt;&lt;/li&gt;
     *  &lt;/ul&gt;
     * @param biasRet an array contain the bias that was checked
     * @return the location within the model that best represents the next
     *  location visual position
     * @exception BadLocationException the given position is not a valid
     *                                 position within the document
     * @exception IllegalArgumentException if &lt;code&gt;direction&lt;/code&gt; is invalid
     */
    public int getNextVisualPositionFrom(int pos, Position.Bias b, Shape a,
                                         int direction,
                                         Position.Bias[] biasRet)
                                                  throws BadLocationException {
<span class="nc bnc" id="L857" title="All 2 branches missed.">        if (pos &lt; -1) {</span>
<span class="nc" id="L858">            throw new BadLocationException(&quot;invalid position&quot;, pos);</span>
        }
<span class="nc" id="L860">        return Utilities.getNextVisualPositionFrom(</span>
                            this, pos, b, a, direction, biasRet);
    }

    // --- variables -----------------------------------------

    /**
     * The major axis against which the children are
     * tiled.
     */
    int axis;

    /**
     * The children and their layout statistics.
     */
    List&lt;ChildState&gt; stats;

    /**
     * Current span along the major axis.  This
     * is also the value returned by getMinimumSize,
     * getPreferredSize, and getMaximumSize along
     * the major axis.
     */
    float majorSpan;

    /**
     * Is the span along the major axis estimated?
     */
    boolean estimatedMajorSpan;

    /**
     * Current span along the minor axis.  This
     * is what layout was done against (i.e. things
     * are flexible in this direction).
     */
    float minorSpan;

    /**
     * Object that manages the offsets of the
     * children.  All locking for management of
     * child locations is on this object.
     */
    protected ChildLocator locator;

    float topInset;
    float bottomInset;
    float leftInset;
    float rightInset;

    ChildState minRequest;
    ChildState prefRequest;
    boolean majorChanged;
    boolean minorChanged;
    Runnable flushTask;

    /**
     * Child that is actively changing size.  This often
     * causes a preferenceChanged, so this is a cache to
     * possibly speed up the marking the state.  It also
     * helps flag an opportunity to avoid adding to flush
     * task to the layout queue.
     */
    ChildState changing;

    /**
     * A class to manage the effective position of the
     * child views in a localized area while changes are
     * being made around the localized area.  The AsyncBoxView
     * may be continuously changing, but the visible area
     * needs to remain fairly stable until the layout thread
     * decides to publish an update to the parent.
     * @since 1.3
     */
    public class ChildLocator {

        /**
         * construct a child locator.
         */
<span class="nc" id="L938">        public ChildLocator() {</span>
<span class="nc" id="L939">            lastAlloc = new Rectangle();</span>
<span class="nc" id="L940">            childAlloc = new Rectangle();</span>
<span class="nc" id="L941">        }</span>

        /**
         * Notification that a child changed.  This can effect
         * whether or not new offset calculations are needed.
         * This is called by a ChildState object that has
         * changed it's major span.  This can therefore be
         * called by multiple threads.
         */
        public synchronized void childChanged(ChildState cs) {
<span class="nc bnc" id="L951" title="All 2 branches missed.">            if (lastValidOffset == null) {</span>
<span class="nc" id="L952">                lastValidOffset = cs;</span>
<span class="nc" id="L953">            } else if (cs.getChildView().getStartOffset() &lt;</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">                       lastValidOffset.getChildView().getStartOffset()) {</span>
<span class="nc" id="L955">                lastValidOffset = cs;</span>
            }
<span class="nc" id="L957">        }</span>

        /**
         * Paint the children that intersect the clip area.
         */
        public synchronized void paintChildren(Graphics g) {
<span class="nc" id="L963">            Rectangle clip = g.getClipBounds();</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">            float targetOffset = (axis == X_AXIS) ?</span>
                clip.x - lastAlloc.x : clip.y - lastAlloc.y;
<span class="nc" id="L966">            int index = getViewIndexAtVisualOffset(targetOffset);</span>
<span class="nc" id="L967">            int n = getViewCount();</span>
<span class="nc" id="L968">            float offs = getChildState(index).getMajorOffset();</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">            for (int i = index; i &lt; n; i++) {</span>
<span class="nc" id="L970">                ChildState cs = getChildState(i);</span>
<span class="nc" id="L971">                cs.setMajorOffset(offs);</span>
<span class="nc" id="L972">                Shape ca = getChildAllocation(i);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">                if (intersectsClip(ca, clip)) {</span>
<span class="nc" id="L974">                    synchronized (cs) {</span>
<span class="nc" id="L975">                        View v = cs.getChildView();</span>
<span class="nc" id="L976">                        v.paint(g, ca);</span>
<span class="nc" id="L977">                    }</span>
                } else {
                    // done painting intersection
                    break;
                }
<span class="nc" id="L982">                offs += cs.getMajorSpan();</span>
            }
<span class="nc" id="L984">        }</span>

        /**
         * Fetch the allocation to use for a child view.
         * This will update the offsets for all children
         * not yet updated before the given index.
         */
        public synchronized Shape getChildAllocation(int index, Shape a) {
<span class="nc bnc" id="L992" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc" id="L993">                return null;</span>
            }
<span class="nc" id="L995">            setAllocation(a);</span>
<span class="nc" id="L996">            ChildState cs = getChildState(index);</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">            if (lastValidOffset == null) {</span>
<span class="nc" id="L998">                lastValidOffset = getChildState(0);</span>
            }
<span class="nc" id="L1000">            if (cs.getChildView().getStartOffset() &gt;</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">                lastValidOffset.getChildView().getStartOffset()) {</span>
                // offsets need to be updated
<span class="nc" id="L1003">                updateChildOffsetsToIndex(index);</span>
            }
<span class="nc" id="L1005">            Shape ca = getChildAllocation(index);</span>
<span class="nc" id="L1006">            return ca;</span>
        }

        /**
         * Fetches the child view index at the given point.
         * This is called by the various View methods that
         * need to calculate which child to forward a message
         * to.  This should be called by a block synchronized
         * on this object, and would typically be followed
         * with one or more calls to getChildAllocation that
         * should also be in the synchronized block.
         *
         * @param x the X coordinate &amp;gt;= 0
         * @param y the Y coordinate &amp;gt;= 0
         * @param a the allocation to the View
         * @return the nearest child index
         */
        public int getViewIndexAtPoint(float x, float y, Shape a) {
<span class="nc" id="L1024">            setAllocation(a);</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">            float targetOffset = (axis == X_AXIS) ? x - lastAlloc.x : y - lastAlloc.y;</span>
<span class="nc" id="L1026">            int index = getViewIndexAtVisualOffset(targetOffset);</span>
<span class="nc" id="L1027">            return index;</span>
        }

        /**
         * Fetch the allocation to use for a child view.
         * &lt;em&gt;This does not update the offsets in the ChildState
         * records.&lt;/em&gt;
         */
        protected Shape getChildAllocation(int index) {
<span class="nc" id="L1036">            ChildState cs = getChildState(index);</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (! cs.isLayoutValid()) {</span>
<span class="nc" id="L1038">                cs.run();</span>
            }
<span class="nc bnc" id="L1040" title="All 2 branches missed.">            if (axis == X_AXIS) {</span>
<span class="nc" id="L1041">                childAlloc.x = lastAlloc.x + (int) cs.getMajorOffset();</span>
<span class="nc" id="L1042">                childAlloc.y = lastAlloc.y + (int) cs.getMinorOffset();</span>
<span class="nc" id="L1043">                childAlloc.width = (int) cs.getMajorSpan();</span>
<span class="nc" id="L1044">                childAlloc.height = (int) cs.getMinorSpan();</span>
            } else {
<span class="nc" id="L1046">                childAlloc.y = lastAlloc.y + (int) cs.getMajorOffset();</span>
<span class="nc" id="L1047">                childAlloc.x = lastAlloc.x + (int) cs.getMinorOffset();</span>
<span class="nc" id="L1048">                childAlloc.height = (int) cs.getMajorSpan();</span>
<span class="nc" id="L1049">                childAlloc.width = (int) cs.getMinorSpan();</span>
            }
<span class="nc" id="L1051">            childAlloc.x += (int)getLeftInset();</span>
<span class="nc" id="L1052">            childAlloc.y += (int)getRightInset();</span>
<span class="nc" id="L1053">            return childAlloc;</span>
        }

        /**
         * Copy the currently allocated shape into the Rectangle
         * used to store the current allocation.  This would be
         * a floating point rectangle in a Java2D-specific implementation.
         */
        protected void setAllocation(Shape a) {
<span class="nc bnc" id="L1062" title="All 2 branches missed.">            if (a instanceof Rectangle) {</span>
<span class="nc" id="L1063">                lastAlloc.setBounds((Rectangle) a);</span>
            } else {
<span class="nc" id="L1065">                lastAlloc.setBounds(a.getBounds());</span>
            }
<span class="nc" id="L1067">            setSize(lastAlloc.width, lastAlloc.height);</span>
<span class="nc" id="L1068">        }</span>

        /**
         * Locate the view responsible for an offset into the box
         * along the major axis.  Make sure that offsets are set
         * on the ChildState objects up to the given target span
         * past the desired offset.
         *
         * @return   index of the view representing the given visual
         *   location (targetOffset), or -1 if no view represents
         *   that location
         */
        protected int getViewIndexAtVisualOffset(float targetOffset) {
<span class="nc" id="L1081">            int n = getViewCount();</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">            if (n &gt; 0) {</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">                boolean lastValid = (lastValidOffset != null);</span>

<span class="nc bnc" id="L1085" title="All 2 branches missed.">                if (lastValidOffset == null) {</span>
<span class="nc" id="L1086">                    lastValidOffset = getChildState(0);</span>
                }
<span class="nc bnc" id="L1088" title="All 2 branches missed.">                if (targetOffset &gt; majorSpan) {</span>
                    // should only get here on the first time display.
<span class="nc bnc" id="L1090" title="All 2 branches missed.">                    if (!lastValid) {</span>
<span class="nc" id="L1091">                        return 0;</span>
                    }
<span class="nc" id="L1093">                    int pos = lastValidOffset.getChildView().getStartOffset();</span>
<span class="nc" id="L1094">                    int index = getViewIndex(pos, Position.Bias.Forward);</span>
<span class="nc" id="L1095">                    return index;</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">                } else if (targetOffset &gt; lastValidOffset.getMajorOffset()) {</span>
                    // roll offset calculations forward
<span class="nc" id="L1098">                    return updateChildOffsets(targetOffset);</span>
                } else {
                    // no changes prior to the needed offset
                    // this should be a binary search
<span class="nc" id="L1102">                    float offs = 0f;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">                    for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L1104">                        ChildState cs = getChildState(i);</span>
<span class="nc" id="L1105">                        float nextOffs = offs + cs.getMajorSpan();</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">                        if (targetOffset &lt; nextOffs) {</span>
<span class="nc" id="L1107">                            return i;</span>
                        }
<span class="nc" id="L1109">                        offs = nextOffs;</span>
                    }
                }
            }
<span class="nc" id="L1113">            return n - 1;</span>
        }

        /**
         * Move the location of the last offset calculation forward
         * to the desired offset.
         */
        int updateChildOffsets(float targetOffset) {
<span class="nc" id="L1121">            int n = getViewCount();</span>
<span class="nc" id="L1122">            int targetIndex = n - 1;</span>
<span class="nc" id="L1123">            int pos = lastValidOffset.getChildView().getStartOffset();</span>
<span class="nc" id="L1124">            int startIndex = getViewIndex(pos, Position.Bias.Forward);</span>
<span class="nc" id="L1125">            float start = lastValidOffset.getMajorOffset();</span>
<span class="nc" id="L1126">            float lastOffset = start;</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">            for (int i = startIndex; i &lt; n; i++) {</span>
<span class="nc" id="L1128">                ChildState cs = getChildState(i);</span>
<span class="nc" id="L1129">                cs.setMajorOffset(lastOffset);</span>
<span class="nc" id="L1130">                lastOffset += cs.getMajorSpan();</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">                if (targetOffset &lt; lastOffset) {</span>
<span class="nc" id="L1132">                    targetIndex = i;</span>
<span class="nc" id="L1133">                    lastValidOffset = cs;</span>
<span class="nc" id="L1134">                    break;</span>
                }
            }

<span class="nc" id="L1138">            return targetIndex;</span>
        }

        /**
         * Move the location of the last offset calculation forward
         * to the desired index.
         */
        void updateChildOffsetsToIndex(int index) {
<span class="nc" id="L1146">            int pos = lastValidOffset.getChildView().getStartOffset();</span>
<span class="nc" id="L1147">            int startIndex = getViewIndex(pos, Position.Bias.Forward);</span>
<span class="nc" id="L1148">            float lastOffset = lastValidOffset.getMajorOffset();</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">            for (int i = startIndex; i &lt;= index; i++) {</span>
<span class="nc" id="L1150">                ChildState cs = getChildState(i);</span>
<span class="nc" id="L1151">                cs.setMajorOffset(lastOffset);</span>
<span class="nc" id="L1152">                lastOffset += cs.getMajorSpan();</span>
            }
<span class="nc" id="L1154">        }</span>

        boolean intersectsClip(Shape childAlloc, Rectangle clip) {
<span class="nc bnc" id="L1157" title="All 2 branches missed.">            Rectangle cs = (childAlloc instanceof Rectangle) ?</span>
<span class="nc" id="L1158">                (Rectangle) childAlloc : childAlloc.getBounds();</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">            if (cs.intersects(clip)) {</span>
                // Make sure that lastAlloc also contains childAlloc,
                // this will be false if haven't yet flushed changes.
<span class="nc" id="L1162">                return lastAlloc.intersects(cs);</span>
            }
<span class="nc" id="L1164">            return false;</span>
        }

        /**
         * The location of the last offset calculation
         * that is valid.
         */
        protected ChildState lastValidOffset;

        /**
         * The last seen allocation (for repainting when changes
         * are flushed upward).
         */
        protected Rectangle lastAlloc;

        /**
         * A shape to use for the child allocation to avoid
         * creating a lot of garbage.
         */
        protected Rectangle childAlloc;
    }

    /**
     * A record representing the layout state of a
     * child view.  It is runnable as a task on another
     * thread.  All access to the child view that is
     * based upon a read-lock on the model should synchronize
     * on this object (i.e. The layout thread and the GUI
     * thread can both have a read lock on the model at the
     * same time and are not protected from each other).
     * Access to a child view hierarchy is serialized via
     * synchronization on the ChildState instance.
     * @since 1.3
     */
    public class ChildState implements Runnable {

        /**
         * Construct a child status.  This needs to start
         * out as fairly large so we don't falsely begin with
         * the idea that all of the children are visible.
         * @since 1.4
         */
<span class="nc" id="L1206">        public ChildState(View v) {</span>
<span class="nc" id="L1207">            child = v;</span>
<span class="nc" id="L1208">            minorValid = false;</span>
<span class="nc" id="L1209">            majorValid = false;</span>
<span class="nc" id="L1210">            childSizeValid = false;</span>
<span class="nc" id="L1211">            child.setParent(AsyncBoxView.this);</span>
<span class="nc" id="L1212">        }</span>

        /**
         * Fetch the child view this record represents
         */
        public View getChildView() {
<span class="nc" id="L1218">            return child;</span>
        }

        /**
         * Update the child state.  This should be
         * called by the thread that desires to spend
         * time updating the child state (intended to
         * be the layout thread).
         * &lt;p&gt;
         * This acquires a read lock on the associated
         * document for the duration of the update to
         * ensure the model is not changed while it is
         * operating.  The first thing to do would be
         * to see if any work actually needs to be done.
         * The following could have conceivably happened
         * while the state was waiting to be updated:
         * &lt;ol&gt;
         * &lt;li&gt;The child may have been removed from the
         * view hierarchy.
         * &lt;li&gt;The child may have been updated by a
         * higher priority operation (i.e. the child
         * may have become visible).
         * &lt;/ol&gt;
         */
        public void run () {
<span class="nc" id="L1243">            AbstractDocument doc = (AbstractDocument) getDocument();</span>
            try {
<span class="nc" id="L1245">                doc.readLock();</span>
<span class="nc bnc" id="L1246" title="All 6 branches missed.">                if (minorValid &amp;&amp; majorValid &amp;&amp; childSizeValid) {</span>
                    // nothing to do
<span class="nc" id="L1248">                    return;</span>
                }
<span class="nc bnc" id="L1250" title="All 2 branches missed.">                if (child.getParent() == AsyncBoxView.this) {</span>
                    // this may overwrite anothers threads cached
                    // value for actively changing... but that just
                    // means it won't use the cache if there is an
                    // overwrite.
<span class="nc" id="L1255">                    synchronized(AsyncBoxView.this) {</span>
<span class="nc" id="L1256">                        changing = this;</span>
<span class="nc" id="L1257">                    }</span>
<span class="nc" id="L1258">                    updateChild();</span>
<span class="nc" id="L1259">                    synchronized(AsyncBoxView.this) {</span>
<span class="nc" id="L1260">                        changing = null;</span>
<span class="nc" id="L1261">                    }</span>

                    // setting the child size on the minor axis
                    // may have caused it to change it's preference
                    // along the major axis.
<span class="nc" id="L1266">                    updateChild();</span>
                }
            } finally {
<span class="nc" id="L1269">                doc.readUnlock();</span>
<span class="nc" id="L1270">            }</span>
<span class="nc" id="L1271">        }</span>

        void updateChild() {
<span class="nc" id="L1274">            boolean minorUpdated = false;</span>
<span class="nc" id="L1275">            synchronized(this) {</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">                if (! minorValid) {</span>
<span class="nc" id="L1277">                    int minorAxis = getMinorAxis();</span>
<span class="nc" id="L1278">                    min = child.getMinimumSpan(minorAxis);</span>
<span class="nc" id="L1279">                    pref = child.getPreferredSpan(minorAxis);</span>
<span class="nc" id="L1280">                    max = child.getMaximumSpan(minorAxis);</span>
<span class="nc" id="L1281">                    minorValid = true;</span>
<span class="nc" id="L1282">                    minorUpdated = true;</span>
                }
<span class="nc" id="L1284">            }</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">            if (minorUpdated) {</span>
<span class="nc" id="L1286">                minorRequirementChange(this);</span>
            }

<span class="nc" id="L1289">            boolean majorUpdated = false;</span>
<span class="nc" id="L1290">            float delta = 0.0f;</span>
<span class="nc" id="L1291">            synchronized(this) {</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">                if (! majorValid) {</span>
<span class="nc" id="L1293">                    float old = span;</span>
<span class="nc" id="L1294">                    span = child.getPreferredSpan(axis);</span>
<span class="nc" id="L1295">                    delta = span - old;</span>
<span class="nc" id="L1296">                    majorValid = true;</span>
<span class="nc" id="L1297">                    majorUpdated = true;</span>
                }
<span class="nc" id="L1299">            }</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">            if (majorUpdated) {</span>
<span class="nc" id="L1301">                majorRequirementChange(this, delta);</span>
<span class="nc" id="L1302">                locator.childChanged(this);</span>
            }

<span class="nc" id="L1305">            synchronized(this) {</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">                if (! childSizeValid) {</span>
                    float w;
                    float h;
<span class="nc bnc" id="L1309" title="All 2 branches missed.">                    if (axis == X_AXIS) {</span>
<span class="nc" id="L1310">                        w = span;</span>
<span class="nc" id="L1311">                        h = getMinorSpan();</span>
                    } else {
<span class="nc" id="L1313">                        w = getMinorSpan();</span>
<span class="nc" id="L1314">                        h = span;</span>
                    }
<span class="nc" id="L1316">                    childSizeValid = true;</span>
<span class="nc" id="L1317">                    child.setSize(w, h);</span>
                }
<span class="nc" id="L1319">            }</span>

<span class="nc" id="L1321">        }</span>

        /**
         * What is the span along the minor axis.
         */
        public float getMinorSpan() {
<span class="nc bnc" id="L1327" title="All 2 branches missed.">            if (max &lt; minorSpan) {</span>
<span class="nc" id="L1328">                return max;</span>
            }
            // make it the target width, or as small as it can get.
<span class="nc" id="L1331">            return Math.max(min, minorSpan);</span>
        }

        /**
         * What is the offset along the minor axis
         */
        public float getMinorOffset() {
<span class="nc bnc" id="L1338" title="All 2 branches missed.">            if (max &lt; minorSpan) {</span>
                // can't make the child this wide, align it
<span class="nc" id="L1340">                float align = child.getAlignment(getMinorAxis());</span>
<span class="nc" id="L1341">                return ((minorSpan - max) * align);</span>
            }
<span class="nc" id="L1343">            return 0f;</span>
        }

        /**
         * What is the span along the major axis.
         */
        public float getMajorSpan() {
<span class="nc" id="L1350">            return span;</span>
        }

        /**
         * Get the offset along the major axis
         */
        public float getMajorOffset() {
<span class="nc" id="L1357">            return offset;</span>
        }

        /**
         * This method should only be called by the ChildLocator,
         * it is simply a convenient place to hold the cached
         * location.
         */
        public void setMajorOffset(float offs) {
<span class="nc" id="L1366">            offset = offs;</span>
<span class="nc" id="L1367">        }</span>

        /**
         * Mark preferences changed for this child.
         *
         * @param width true if the width preference has changed
         * @param height true if the height preference has changed
         * @see javax.swing.JComponent#revalidate
         */
        public void preferenceChanged(boolean width, boolean height) {
<span class="nc bnc" id="L1377" title="All 2 branches missed.">            if (axis == X_AXIS) {</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">                if (width) {</span>
<span class="nc" id="L1379">                    majorValid = false;</span>
                }
<span class="nc bnc" id="L1381" title="All 2 branches missed.">                if (height) {</span>
<span class="nc" id="L1382">                    minorValid = false;</span>
                }
            } else {
<span class="nc bnc" id="L1385" title="All 2 branches missed.">                if (width) {</span>
<span class="nc" id="L1386">                    minorValid = false;</span>
                }
<span class="nc bnc" id="L1388" title="All 2 branches missed.">                if (height) {</span>
<span class="nc" id="L1389">                    majorValid = false;</span>
                }
            }
<span class="nc" id="L1392">            childSizeValid = false;</span>
<span class="nc" id="L1393">        }</span>

        /**
         * Has the child view been laid out.
         */
        public boolean isLayoutValid() {
<span class="nc bnc" id="L1399" title="All 6 branches missed.">            return (minorValid &amp;&amp; majorValid &amp;&amp; childSizeValid);</span>
        }

        // minor axis
        private float min;
        private float pref;
        private float max;
        private boolean minorValid;

        // major axis
        private float span;
        private float offset;
        private boolean majorValid;

        private View child;
        private boolean childSizeValid;
    }

    /**
     * Task to flush requirement changes upward
     */
<span class="nc" id="L1420">    class FlushTask implements Runnable {</span>

        public void run() {
<span class="nc" id="L1423">            flushRequirementChanges();</span>
<span class="nc" id="L1424">        }</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>