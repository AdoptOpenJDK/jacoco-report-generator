<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>GlyphPainter2.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.text</a> &gt; <span class="el_source">GlyphPainter2.java</span></div><h1>GlyphPainter2.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.text;

import java.text.*;
import java.awt.*;
import java.awt.font.*;
import java.awt.geom.Rectangle2D;

/**
 * A class to perform rendering of the glyphs.
 * This can be implemented to be stateless, or
 * to hold some information as a cache to
 * facilitate faster rendering and model/view
 * translation.  At a minimum, the GlyphPainter
 * allows a View implementation to perform its
 * duties independent of a particular version
 * of JVM and selection of capabilities (i.e.
 * shaping for i18n, etc).
 * &lt;p&gt;
 * This implementation is intended for operation
 * under the JDK.  It uses the
 * java.awt.font.TextLayout class to do i18n capable
 * rendering.
 *
 * @author  Timothy Prinzing
 * @see GlyphView
 */
class GlyphPainter2 extends GlyphView.GlyphPainter {

<span class="nc" id="L53">    public GlyphPainter2(TextLayout layout) {</span>
<span class="nc" id="L54">        this.layout = layout;</span>
<span class="nc" id="L55">    }</span>

    /**
     * Create a painter to use for the given GlyphView.
     */
    public GlyphView.GlyphPainter getPainter(GlyphView v, int p0, int p1) {
<span class="nc" id="L61">        return null;</span>
    }

    /**
     * Determine the span the glyphs given a start location
     * (for tab expansion).  This implementation assumes it
     * has no tabs (i.e. TextLayout doesn't deal with tab
     * expansion).
     */
    public float getSpan(GlyphView v, int p0, int p1,
                         TabExpander e, float x) {

<span class="nc bnc" id="L73" title="All 4 branches missed.">        if ((p0 == v.getStartOffset()) &amp;&amp; (p1 == v.getEndOffset())) {</span>
<span class="nc" id="L74">            return layout.getAdvance();</span>
        }
<span class="nc" id="L76">        int p = v.getStartOffset();</span>
<span class="nc" id="L77">        int index0 = p0 - p;</span>
<span class="nc" id="L78">        int index1 = p1 - p;</span>

<span class="nc" id="L80">        TextHitInfo hit0 = TextHitInfo.afterOffset(index0);</span>
<span class="nc" id="L81">        TextHitInfo hit1 = TextHitInfo.beforeOffset(index1);</span>
<span class="nc" id="L82">        float[] locs = layout.getCaretInfo(hit0);</span>
<span class="nc" id="L83">        float x0 = locs[0];</span>
<span class="nc" id="L84">        locs = layout.getCaretInfo(hit1);</span>
<span class="nc" id="L85">        float x1 = locs[0];</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        return (x1 &gt; x0) ? x1 - x0 : x0 - x1;</span>
    }

    public float getHeight(GlyphView v) {
<span class="nc" id="L90">        return layout.getAscent() + layout.getDescent() + layout.getLeading();</span>
    }

    /**
     * Fetch the ascent above the baseline for the glyphs
     * corresponding to the given range in the model.
     */
    public float getAscent(GlyphView v) {
<span class="nc" id="L98">        return layout.getAscent();</span>
    }

    /**
     * Fetch the descent below the baseline for the glyphs
     * corresponding to the given range in the model.
     */
    public float getDescent(GlyphView v) {
<span class="nc" id="L106">        return layout.getDescent();</span>
    }

    /**
     * Paint the glyphs for the given view.  This is implemented
     * to only render if the Graphics is of type Graphics2D which
     * is required by TextLayout (and this should be the case if
     * running on the JDK).
     */
    public void paint(GlyphView v, Graphics g, Shape a, int p0, int p1) {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (g instanceof Graphics2D) {</span>
<span class="nc" id="L117">            Rectangle2D alloc = a.getBounds2D();</span>
<span class="nc" id="L118">            Graphics2D g2d = (Graphics2D)g;</span>
<span class="nc" id="L119">            float y = (float) alloc.getY() + layout.getAscent() + layout.getLeading();</span>
<span class="nc" id="L120">            float x = (float) alloc.getX();</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">            if( p0 &gt; v.getStartOffset() || p1 &lt; v.getEndOffset() ) {</span>
                try {
                    //TextLayout can't render only part of it's range, so if a
                    //partial range is required, add a clip region.
<span class="nc" id="L125">                    Shape s = v.modelToView(p0, Position.Bias.Forward,</span>
                                            p1, Position.Bias.Backward, a);
<span class="nc" id="L127">                    Shape savedClip = g.getClip();</span>
<span class="nc" id="L128">                    g2d.clip(s);</span>
<span class="nc" id="L129">                    layout.draw(g2d, x, y);</span>
<span class="nc" id="L130">                    g.setClip(savedClip);</span>
<span class="nc" id="L131">                } catch (BadLocationException e) {}</span>
            } else {
<span class="nc" id="L133">                layout.draw(g2d, x, y);</span>
            }
        }
<span class="nc" id="L136">    }</span>

    public Shape modelToView(GlyphView v, int pos, Position.Bias bias,
                             Shape a) throws BadLocationException {
<span class="nc" id="L140">        int offs = pos - v.getStartOffset();</span>
<span class="nc" id="L141">        Rectangle2D alloc = a.getBounds2D();</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        TextHitInfo hit = (bias == Position.Bias.Forward) ?</span>
<span class="nc" id="L143">            TextHitInfo.afterOffset(offs) : TextHitInfo.beforeOffset(offs);</span>
<span class="nc" id="L144">        float[] locs = layout.getCaretInfo(hit);</span>

        // vertical at the baseline, should use slope and check if glyphs
        // are being rendered vertically.
<span class="nc" id="L148">        alloc.setRect(alloc.getX() + locs[0], alloc.getY(), 1, alloc.getHeight());</span>
<span class="nc" id="L149">        return alloc;</span>
    }

    /**
     * Provides a mapping from the view coordinate space to the logical
     * coordinate space of the model.
     *
     * @param v the view containing the view coordinates
     * @param x the X coordinate
     * @param y the Y coordinate
     * @param a the allocated region to render into
     * @param biasReturn either &lt;code&gt;Position.Bias.Forward&lt;/code&gt;
     *  or &lt;code&gt;Position.Bias.Backward&lt;/code&gt; is returned as the
     *  zero-th element of this array
     * @return the location within the model that best represents the
     *  given point of view
     * @see View#viewToModel
     */
    public int viewToModel(GlyphView v, float x, float y, Shape a,
                           Position.Bias[] biasReturn) {

<span class="nc bnc" id="L170" title="All 2 branches missed.">        Rectangle2D alloc = (a instanceof Rectangle2D) ? (Rectangle2D)a : a.getBounds2D();</span>
        //Move the y co-ord of the hit onto the baseline.  This is because TextLayout supports
        //italic carets and we do not.
<span class="nc" id="L173">        TextHitInfo hit = layout.hitTestChar(x - (float)alloc.getX(), 0);</span>
<span class="nc" id="L174">        int pos = hit.getInsertionIndex();</span>

<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (pos == v.getEndOffset()) {</span>
<span class="nc" id="L177">            pos--;</span>
        }

<span class="nc bnc" id="L180" title="All 2 branches missed.">        biasReturn[0] = hit.isLeadingEdge() ? Position.Bias.Forward : Position.Bias.Backward;</span>
<span class="nc" id="L181">        return pos + v.getStartOffset();</span>
    }

    /**
     * Determines the model location that represents the
     * maximum advance that fits within the given span.
     * This could be used to break the given view.  The result
     * should be a location just shy of the given advance.  This
     * differs from viewToModel which returns the closest
     * position which might be proud of the maximum advance.
     *
     * @param v the view to find the model location to break at.
     * @param p0 the location in the model where the
     *  fragment should start it's representation &gt;= 0.
     * @param pos the graphic location along the axis that the
     *  broken view would occupy &gt;= 0.  This may be useful for
     *  things like tab calculations.
     * @param len specifies the distance into the view
     *  where a potential break is desired &gt;= 0.
     * @return the maximum model location possible for a break.
     * @see View#breakView
     */
    public int getBoundedPosition(GlyphView v, int p0, float x, float len) {
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if( len &lt; 0 )</span>
<span class="nc" id="L205">            throw new IllegalArgumentException(&quot;Length must be &gt;= 0.&quot;);</span>
        // note: this only works because swing uses TextLayouts that are
        // only pure rtl or pure ltr
        TextHitInfo hit;
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (layout.isLeftToRight()) {</span>
<span class="nc" id="L210">            hit = layout.hitTestChar(len, 0);</span>
        } else {
<span class="nc" id="L212">            hit = layout.hitTestChar(layout.getAdvance() - len, 0);</span>
        }
<span class="nc" id="L214">        return v.getStartOffset() + hit.getCharIndex();</span>
    }

    /**
         * Provides a way to determine the next visually represented model
         * location that one might place a caret.  Some views may not be
         * visible, they might not be in the same order found in the model, or
         * they just might not allow access to some of the locations in the
         * model.
         *
         * @param v the view to use
         * @param pos the position to convert &gt;= 0
         * @param a the allocated region to render into
         * @param direction the direction from the current position that can
         *  be thought of as the arrow keys typically found on a keyboard.
         *  This may be SwingConstants.WEST, SwingConstants.EAST,
         *  SwingConstants.NORTH, or SwingConstants.SOUTH.
         * @return the location within the model that best represents the next
         *  location visual position.
         * @exception BadLocationException
         * @exception IllegalArgumentException for an invalid direction
         */
        public int getNextVisualPositionFrom(GlyphView v, int pos,
                                             Position.Bias b, Shape a,
                                             int direction,
                                             Position.Bias[] biasRet)
            throws BadLocationException {

<span class="nc" id="L242">            Document doc = v.getDocument();</span>
<span class="nc" id="L243">            int startOffset = v.getStartOffset();</span>
<span class="nc" id="L244">            int endOffset = v.getEndOffset();</span>
            Segment text;
            boolean viewIsLeftToRight;
            TextHitInfo currentHit, nextHit;

<span class="nc bnc" id="L249" title="All 5 branches missed.">            switch (direction) {</span>
            case View.NORTH:
<span class="nc" id="L251">                break;</span>
            case View.SOUTH:
<span class="nc" id="L253">                break;</span>
            case View.EAST:
<span class="nc" id="L255">                viewIsLeftToRight = AbstractDocument.isLeftToRight(doc, startOffset, endOffset);</span>

<span class="nc bnc" id="L257" title="All 2 branches missed.">                if(startOffset == doc.getLength()) {</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">                    if(pos == -1) {</span>
<span class="nc" id="L259">                        biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L260">                        return startOffset;</span>
                    }
                    // End case for bidi text where newline is at beginning
                    // of line.
<span class="nc" id="L264">                    return -1;</span>
                }
<span class="nc bnc" id="L266" title="All 2 branches missed.">                if(pos == -1) {</span>
                    // Entering view from the left.
<span class="nc bnc" id="L268" title="All 2 branches missed.">                    if( viewIsLeftToRight ) {</span>
<span class="nc" id="L269">                        biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L270">                        return startOffset;</span>
                    } else {
<span class="nc" id="L272">                        text = v.getText(endOffset - 1, endOffset);</span>
<span class="nc" id="L273">                        char c = text.array[text.offset];</span>
<span class="nc" id="L274">                        SegmentCache.releaseSharedSegment(text);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">                        if(c == '\n') {</span>
<span class="nc" id="L276">                            biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L277">                            return endOffset-1;</span>
                        }
<span class="nc" id="L279">                        biasRet[0] = Position.Bias.Backward;</span>
<span class="nc" id="L280">                        return endOffset;</span>
                    }
                }
<span class="nc bnc" id="L283" title="All 2 branches missed.">                if( b==Position.Bias.Forward )</span>
<span class="nc" id="L284">                    currentHit = TextHitInfo.afterOffset(pos-startOffset);</span>
                else
<span class="nc" id="L286">                    currentHit = TextHitInfo.beforeOffset(pos-startOffset);</span>
<span class="nc" id="L287">                nextHit = layout.getNextRightHit(currentHit);</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">                if( nextHit == null ) {</span>
<span class="nc" id="L289">                    return -1;</span>
                }
<span class="nc bnc" id="L291" title="All 2 branches missed.">                if( viewIsLeftToRight != layout.isLeftToRight() ) {</span>
                    // If the layout's base direction is different from
                    // this view's run direction, we need to use the weak
                    // carrat.
<span class="nc" id="L295">                    nextHit = layout.getVisualOtherHit(nextHit);</span>
                }
<span class="nc" id="L297">                pos = nextHit.getInsertionIndex() + startOffset;</span>

<span class="nc bnc" id="L299" title="All 2 branches missed.">                if(pos == endOffset) {</span>
                    // A move to the right from an internal position will
                    // only take us to the endOffset in a left to right run.
<span class="nc" id="L302">                    text = v.getText(endOffset - 1, endOffset);</span>
<span class="nc" id="L303">                    char c = text.array[text.offset];</span>
<span class="nc" id="L304">                    SegmentCache.releaseSharedSegment(text);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                    if(c == '\n') {</span>
<span class="nc" id="L306">                        return -1;</span>
                    }
<span class="nc" id="L308">                    biasRet[0] = Position.Bias.Backward;</span>
<span class="nc" id="L309">                }</span>
                else {
<span class="nc" id="L311">                    biasRet[0] = Position.Bias.Forward;</span>
                }
<span class="nc" id="L313">                return pos;</span>
            case View.WEST:
<span class="nc" id="L315">                viewIsLeftToRight = AbstractDocument.isLeftToRight(doc, startOffset, endOffset);</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">                if(startOffset == doc.getLength()) {</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                    if(pos == -1) {</span>
<span class="nc" id="L319">                        biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L320">                        return startOffset;</span>
                    }
                    // End case for bidi text where newline is at beginning
                    // of line.
<span class="nc" id="L324">                    return -1;</span>
                }
<span class="nc bnc" id="L326" title="All 2 branches missed.">                if(pos == -1) {</span>
                    // Entering view from the right
<span class="nc bnc" id="L328" title="All 2 branches missed.">                    if( viewIsLeftToRight ) {</span>
<span class="nc" id="L329">                        text = v.getText(endOffset - 1, endOffset);</span>
<span class="nc" id="L330">                        char c = text.array[text.offset];</span>
<span class="nc" id="L331">                        SegmentCache.releaseSharedSegment(text);</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">                        if ((c == '\n') || Character.isSpaceChar(c)) {</span>
<span class="nc" id="L333">                            biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L334">                            return endOffset - 1;</span>
                        }
<span class="nc" id="L336">                        biasRet[0] = Position.Bias.Backward;</span>
<span class="nc" id="L337">                        return endOffset;</span>
                    } else {
<span class="nc" id="L339">                        biasRet[0] = Position.Bias.Forward;</span>
<span class="nc" id="L340">                        return startOffset;</span>
                   }
                }
<span class="nc bnc" id="L343" title="All 2 branches missed.">                if( b==Position.Bias.Forward )</span>
<span class="nc" id="L344">                    currentHit = TextHitInfo.afterOffset(pos-startOffset);</span>
                else
<span class="nc" id="L346">                    currentHit = TextHitInfo.beforeOffset(pos-startOffset);</span>
<span class="nc" id="L347">                nextHit = layout.getNextLeftHit(currentHit);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                if( nextHit == null ) {</span>
<span class="nc" id="L349">                    return -1;</span>
                }
<span class="nc bnc" id="L351" title="All 2 branches missed.">                if( viewIsLeftToRight != layout.isLeftToRight() ) {</span>
                    // If the layout's base direction is different from
                    // this view's run direction, we need to use the weak
                    // carrat.
<span class="nc" id="L355">                    nextHit = layout.getVisualOtherHit(nextHit);</span>
                }
<span class="nc" id="L357">                pos = nextHit.getInsertionIndex() + startOffset;</span>

<span class="nc bnc" id="L359" title="All 2 branches missed.">                if(pos == endOffset) {</span>
                    // A move to the left from an internal position will
                    // only take us to the endOffset in a right to left run.
<span class="nc" id="L362">                    text = v.getText(endOffset - 1, endOffset);</span>
<span class="nc" id="L363">                    char c = text.array[text.offset];</span>
<span class="nc" id="L364">                    SegmentCache.releaseSharedSegment(text);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                    if(c == '\n') {</span>
<span class="nc" id="L366">                        return -1;</span>
                    }
<span class="nc" id="L368">                    biasRet[0] = Position.Bias.Backward;</span>
<span class="nc" id="L369">                }</span>
                else {
<span class="nc" id="L371">                    biasRet[0] = Position.Bias.Forward;</span>
                }
<span class="nc" id="L373">                return pos;</span>
            default:
<span class="nc" id="L375">                throw new IllegalArgumentException(&quot;Bad direction: &quot; + direction);</span>
            }
<span class="nc" id="L377">            return pos;</span>

        }
    // --- variables ---------------------------------------------

    TextLayout layout;

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>