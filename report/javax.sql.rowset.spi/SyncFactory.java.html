<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SyncFactory.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.sql.rowset.spi</a> &gt; <span class="el_source">SyncFactory.java</span></div><h1>SyncFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.sql.rowset.spi;

import java.util.logging.*;
import java.util.*;

import java.sql.*;
import javax.sql.*;

import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.io.FileNotFoundException;

import javax.naming.*;

/**
 * The Service Provider Interface (SPI) mechanism that generates &lt;code&gt;SyncProvider&lt;/code&gt;
 * instances to be used by disconnected &lt;code&gt;RowSet&lt;/code&gt; objects.
 * The &lt;code&gt;SyncProvider&lt;/code&gt; instances in turn provide the
 * &lt;code&gt;javax.sql.RowSetReader&lt;/code&gt; object the &lt;code&gt;RowSet&lt;/code&gt; object
 * needs to populate itself with data and the
 * &lt;code&gt;javax.sql.RowSetWriter&lt;/code&gt; object it needs to
 * propagate changes to its
 * data back to the underlying data source.
 * &lt;P&gt;
 * Because the methods in the &lt;code&gt;SyncFactory&lt;/code&gt; class are all static,
 * there is only one &lt;code&gt;SyncFactory&lt;/code&gt; object
 * per Java VM at any one time. This ensures that there is a single source from which a
 * &lt;code&gt;RowSet&lt;/code&gt; implementation can obtain its &lt;code&gt;SyncProvider&lt;/code&gt;
 * implementation.
 *
 * &lt;h3&gt;1.0 Overview&lt;/h3&gt;
 * The &lt;code&gt;SyncFactory&lt;/code&gt; class provides an internal registry of available
 * synchronization provider implementations (&lt;code&gt;SyncProvider&lt;/code&gt; objects).
 * This registry may be queried to determine which
 * synchronization providers are available.
 * The following line of code gets an enumeration of the providers currently registered.
 * &lt;PRE&gt;
 *     java.util.Enumeration e = SyncFactory.getRegisteredProviders();
 * &lt;/PRE&gt;
 * All standard &lt;code&gt;RowSet&lt;/code&gt; implementations must provide at least two providers:
 * &lt;UL&gt;
 *  &lt;LI&gt;an optimistic provider for use with a &lt;code&gt;CachedRowSet&lt;/code&gt; implementation
 *     or an implementation derived from it
 *  &lt;LI&gt;an XML provider, which is used for reading and writing XML, such as with
 *       &lt;code&gt;WebRowSet&lt;/code&gt; objects
 * &lt;/UL&gt;
 * Note that the JDBC RowSet Implementations include the &lt;code&gt;SyncProvider&lt;/code&gt;
 * implementations &lt;code&gt;RIOptimisticProvider&lt;/code&gt; and &lt;code&gt;RIXmlProvider&lt;/code&gt;,
 * which satisfy this requirement.
 * &lt;P&gt;
 * The &lt;code&gt;SyncFactory&lt;/code&gt; class provides accessor methods to assist
 * applications in determining which synchronization providers are currently
 * registered with the &lt;code&gt;SyncFactory&lt;/code&gt;.
 * &lt;p&gt;
 * Other methods let &lt;code&gt;RowSet&lt;/code&gt; persistence providers be
 * registered or de-registered with the factory mechanism. This
 * allows additional synchronization provider implementations to be made
 * available to &lt;code&gt;RowSet&lt;/code&gt; objects at run time.
 * &lt;p&gt;
 * Applications can apply a degree of filtering to determine the level of
 * synchronization that a &lt;code&gt;SyncProvider&lt;/code&gt; implementation offers.
 * The following criteria determine whether a provider is
 * made available to a &lt;code&gt;RowSet&lt;/code&gt; object:
 * &lt;ol&gt;
 * &lt;li&gt;If a particular provider is specified by a &lt;code&gt;RowSet&lt;/code&gt; object, and
 * the &lt;code&gt;SyncFactory&lt;/code&gt; does not contain a reference to this provider,
 * a &lt;code&gt;SyncFactoryException&lt;/code&gt; is thrown stating that the synchronization
 * provider could not be found.
 *
 * &lt;li&gt;If a &lt;code&gt;RowSet&lt;/code&gt; implementation is instantiated with a specified
 * provider and the specified provider has been properly registered, the
 * requested provider is supplied. Otherwise a &lt;code&gt;SyncFactoryException&lt;/code&gt;
 * is thrown.
 *
 * &lt;li&gt;If a &lt;code&gt;RowSet&lt;/code&gt; object does not specify a
 * &lt;code&gt;SyncProvider&lt;/code&gt; implementation and no additional
 * &lt;code&gt;SyncProvider&lt;/code&gt; implementations are available, the reference
 * implementation providers are supplied.
 * &lt;/ol&gt;
 * &lt;h3&gt;2.0 Registering &lt;code&gt;SyncProvider&lt;/code&gt; Implementations&lt;/h3&gt;
 * &lt;p&gt;
 * Both vendors and developers can register &lt;code&gt;SyncProvider&lt;/code&gt;
 * implementations using one of the following mechanisms.
 * &lt;ul&gt;
 * &lt;LI&gt;&lt;B&gt;Using the command line&lt;/B&gt;&lt;BR&gt;
 * The name of the provider is supplied on the command line, which will add
 * the provider to the system properties.
 * For example:
 * &lt;PRE&gt;
 *    -Drowset.provider.classname=com.fred.providers.HighAvailabilityProvider
 * &lt;/PRE&gt;
 * &lt;li&gt;&lt;b&gt;Using the Standard Properties File&lt;/b&gt;&lt;BR&gt;
 * The reference implementation is targeted
 * to ship with J2SE 1.5, which will include an additional resource file
 * that may be edited by hand. Here is an example of the properties file
 * included in the reference implementation:
 * &lt;PRE&gt;
 *   #Default JDBC RowSet sync providers listing
 *   #
 *
 *   # Optimistic synchronization provider
 *   rowset.provider.classname.0=com.sun.rowset.providers.RIOptimisticProvider
 *   rowset.provider.vendor.0=Oracle Corporation
 *   rowset.provider.version.0=1.0
 *
 *   # XML Provider using standard XML schema
 *   rowset.provider.classname.1=com.sun.rowset.providers.RIXMLProvider
 *   rowset.provider.vendor.1=Oracle Corporation
 *   rowset.provider.version.1=1.0
 * &lt;/PRE&gt;
 * The &lt;code&gt;SyncFactory&lt;/code&gt; checks this file and registers the
 * &lt;code&gt;SyncProvider&lt;/code&gt; implementations that it contains. A
 * developer or vendor can add other implementations to this file.
 * For example, here is a possible addition:
 * &lt;PRE&gt;
 *     rowset.provider.classname.2=com.fred.providers.HighAvailabilityProvider
 *     rowset.provider.vendor.2=Fred, Inc.
 *     rowset.provider.version.2=1.0
 * &lt;/PRE&gt;
 *
 * &lt;li&gt;&lt;b&gt;Using a JNDI Context&lt;/b&gt;&lt;BR&gt;
 * Available providers can be registered on a JNDI
 * context, and the &lt;code&gt;SyncFactory&lt;/code&gt; will attempt to load
 * &lt;code&gt;SyncProvider&lt;/code&gt; implementations from that JNDI context.
 * For example, the following code fragment registers a provider implementation
 * on a JNDI context.  This is something a deployer would normally do. In this
 * example, &lt;code&gt;MyProvider&lt;/code&gt; is being registered on a CosNaming
 * namespace, which is the namespace used by J2EE resources.
 * &lt;PRE&gt;
 *    import javax.naming.*;
 *
 *    Hashtable svrEnv = new  Hashtable();
 *    srvEnv.put(Context.INITIAL_CONTEXT_FACTORY, &quot;CosNaming&quot;);
 *
 *    Context ctx = new InitialContext(svrEnv);
 *    com.fred.providers.MyProvider = new MyProvider();
 *    ctx.rebind(&quot;providers/MyProvider&quot;, syncProvider);
 * &lt;/PRE&gt;
 * &lt;/ul&gt;
 * Next, an application will register the JNDI context with the
 * &lt;code&gt;SyncFactory&lt;/code&gt; instance.  This allows the &lt;code&gt;SyncFactory&lt;/code&gt;
 * to browse within the JNDI context looking for &lt;code&gt;SyncProvider&lt;/code&gt;
 * implementations.
 * &lt;PRE&gt;
 *    Hashtable appEnv = new Hashtable();
 *    appEnv.put(Context.INITIAL_CONTEXT_FACTORY, &quot;CosNaming&quot;);
 *    appEnv.put(Context.PROVIDER_URL, &quot;iiop://hostname/providers&quot;);
 *    Context ctx = new InitialContext(appEnv);
 *
 *    SyncFactory.registerJNDIContext(ctx);
 * &lt;/PRE&gt;
 * If a &lt;code&gt;RowSet&lt;/code&gt; object attempts to obtain a &lt;code&gt;MyProvider&lt;/code&gt;
 * object, the &lt;code&gt;SyncFactory&lt;/code&gt; will try to locate it. First it searches
 * for it in the system properties, then it looks in the resource files, and
 * finally it checks the JNDI context that has been set. The &lt;code&gt;SyncFactory&lt;/code&gt;
 * instance verifies that the requested provider is a valid extension of the
 * &lt;code&gt;SyncProvider&lt;/code&gt; abstract class and then gives it to the
 * &lt;code&gt;RowSet&lt;/code&gt; object. In the following code fragment, a new
 * &lt;code&gt;CachedRowSet&lt;/code&gt; object is created and initialized with
 * &lt;i&gt;env&lt;/i&gt;, which contains the binding to &lt;code&gt;MyProvider&lt;/code&gt;.
 * &lt;PRE&gt;
 *    Hashtable env = new Hashtable();
 *    env.put(SyncFactory.ROWSET_SYNC_PROVIDER, &quot;com.fred.providers.MyProvider&quot;);
 *    CachedRowSet crs = new com.sun.rowset.CachedRowSetImpl(env);
 * &lt;/PRE&gt;
 * Further details on these mechanisms are available in the
 * &lt;code&gt;javax.sql.rowset.spi&lt;/code&gt; package specification.
 *
 * @author  Jonathan Bruce
 * @see javax.sql.rowset.spi.SyncProvider
 * @see javax.sql.rowset.spi.SyncFactoryException
 */
public class SyncFactory {

    /**
     * Creates a new &lt;code&gt;SyncFactory&lt;/code&gt; object, which is the singleton
     * instance.
     * Having a private constructor guarantees that no more than
     * one &lt;code&gt;SyncProvider&lt;/code&gt; object can exist at a time.
     */
<span class="nc" id="L207">    private SyncFactory() {</span>
<span class="nc" id="L208">    }</span>

    /**
     * The standard property-id for a synchronization provider implementation
     * name.
     */
    public static final String ROWSET_SYNC_PROVIDER =
            &quot;rowset.provider.classname&quot;;
    /**
     * The standard property-id for a synchronization provider implementation
     * vendor name.
     */
    public static final String ROWSET_SYNC_VENDOR =
            &quot;rowset.provider.vendor&quot;;
    /**
     * The standard property-id for a synchronization provider implementation
     * version tag.
     */
    public static final String ROWSET_SYNC_PROVIDER_VERSION =
            &quot;rowset.provider.version&quot;;
    /**
     * The standard resource file name.
     */
<span class="nc" id="L231">    private static String ROWSET_PROPERTIES = &quot;rowset.properties&quot;;</span>

    /**
     *  Permission required to invoke setJNDIContext and setLogger
     */
<span class="nc" id="L236">    private static final SQLPermission SET_SYNCFACTORY_PERMISSION =</span>
            new SQLPermission(&quot;setSyncFactory&quot;);
    /**
     * The initial JNDI context where &lt;code&gt;SyncProvider&lt;/code&gt; implementations can
     * be stored and from which they can be invoked.
     */
    private static Context ic;
    /**
     * The &lt;code&gt;Logger&lt;/code&gt; object to be used by the &lt;code&gt;SyncFactory&lt;/code&gt;.
     */
    private static volatile Logger rsLogger;

    /**
     * The registry of available &lt;code&gt;SyncProvider&lt;/code&gt; implementations.
     * See section 2.0 of the class comment for &lt;code&gt;SyncFactory&lt;/code&gt; for an
     * explanation of how a provider can be added to this registry.
     */
    private static Hashtable&lt;String, SyncProvider&gt; implementations;

    /**
     * Adds the the given synchronization provider to the factory register. Guidelines
     * are provided in the &lt;code&gt;SyncProvider&lt;/code&gt; specification for the
     * required naming conventions for &lt;code&gt;SyncProvider&lt;/code&gt;
     * implementations.
     * &lt;p&gt;
     * Synchronization providers bound to a JNDI context can be
     * registered by binding a SyncProvider instance to a JNDI namespace.
     *
     * &lt;pre&gt;
     * {@code
     * SyncProvider p = new MySyncProvider();
     * InitialContext ic = new InitialContext();
     * ic.bind (&quot;jdbc/rowset/MySyncProvider&quot;, p);
     * } &lt;/pre&gt;
     *
     * Furthermore, an initial JNDI context should be set with the
     * &lt;code&gt;SyncFactory&lt;/code&gt; using the &lt;code&gt;setJNDIContext&lt;/code&gt; method.
     * The &lt;code&gt;SyncFactory&lt;/code&gt; leverages this context to search for
     * available &lt;code&gt;SyncProvider&lt;/code&gt; objects bound to the JNDI
     * context and its child nodes.
     *
     * @param providerID A &lt;code&gt;String&lt;/code&gt; object with the unique ID of the
     *             synchronization provider being registered
     * @throws SyncFactoryException if an attempt is made to supply an empty
     *         or null provider name
     * @see #setJNDIContext
     */
    public static synchronized void registerProvider(String providerID)
            throws SyncFactoryException {

<span class="nc" id="L286">        ProviderImpl impl = new ProviderImpl();</span>
<span class="nc" id="L287">        impl.setClassname(providerID);</span>
<span class="nc" id="L288">        initMapIfNecessary();</span>
<span class="nc" id="L289">        implementations.put(providerID, impl);</span>

<span class="nc" id="L291">    }</span>

    /**
     * Returns the &lt;code&gt;SyncFactory&lt;/code&gt; singleton.
     *
     * @return the &lt;code&gt;SyncFactory&lt;/code&gt; instance
     */
    public static SyncFactory getSyncFactory() {
        /*
         * Using Initialization on Demand Holder idiom as
         * Effective Java 2nd Edition,ITEM 71, indicates it is more performant
         * than the Double-Check Locking idiom.
         */
<span class="nc" id="L304">        return SyncFactoryHolder.factory;</span>
    }

    /**
     * Removes the designated currently registered synchronization provider from the
     * Factory SPI register.
     *
     * @param providerID The unique-id of the synchronization provider
     * @throws SyncFactoryException If an attempt is made to
     * unregister a SyncProvider implementation that was not registered.
     */
    public static synchronized void unregisterProvider(String providerID)
            throws SyncFactoryException {
<span class="nc" id="L317">        initMapIfNecessary();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (implementations.containsKey(providerID)) {</span>
<span class="nc" id="L319">            implementations.remove(providerID);</span>
        }
<span class="nc" id="L321">    }</span>
<span class="nc" id="L322">    private static String colon = &quot;:&quot;;</span>
<span class="nc" id="L323">    private static String strFileSep = &quot;/&quot;;</span>

    private static synchronized void initMapIfNecessary() throws SyncFactoryException {

        // Local implementation class names and keys from Properties
        // file, translate names into Class objects using Class.forName
        // and store mappings
<span class="nc" id="L330">        Properties properties = new Properties();</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (implementations == null) {</span>
<span class="nc" id="L333">            implementations = new Hashtable&lt;&gt;();</span>

            try {

                // check if user is supplying his Synchronisation Provider
                // Implementation if not using Oracle's implementation.
                // properties.load(new FileInputStream(ROWSET_PROPERTIES));

                // The rowset.properties needs to be in jdk/jre/lib when
                // integrated with jdk.
                // else it should be picked from -D option from command line.

                // -Drowset.properties will add to standard properties. Similar
                // keys will over-write

                /*
                 * Dependent on application
                 */
<span class="nc" id="L351">                String strRowsetProperties = System.getProperty(&quot;rowset.properties&quot;);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                if (strRowsetProperties != null) {</span>
                    // Load user's implementation of SyncProvider
                    // here. -Drowset.properties=/abc/def/pqr.txt
<span class="nc" id="L355">                    ROWSET_PROPERTIES = strRowsetProperties;</span>
<span class="nc" id="L356">                    try (FileInputStream fis = new FileInputStream(ROWSET_PROPERTIES)) {</span>
<span class="nc" id="L357">                        properties.load(fis);</span>
<span class="nc bnc" id="L358" title="All 8 branches missed.">                    }</span>
<span class="nc" id="L359">                    parseProperties(properties);</span>
                }

                /*
                 * Always available
                 */
<span class="nc" id="L365">                ROWSET_PROPERTIES = &quot;javax&quot; + strFileSep + &quot;sql&quot; +</span>
                        strFileSep + &quot;rowset&quot; + strFileSep +
                        &quot;rowset.properties&quot;;

<span class="nc" id="L369">                ClassLoader cl = Thread.currentThread().getContextClassLoader();</span>

<span class="nc bnc" id="L371" title="All 2 branches missed.">                try (InputStream stream =</span>
<span class="nc" id="L372">                         (cl == null) ? ClassLoader.getSystemResourceAsStream(ROWSET_PROPERTIES)</span>
<span class="nc" id="L373">                                      : cl.getResourceAsStream(ROWSET_PROPERTIES)) {</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                    if (stream == null) {</span>
<span class="nc" id="L375">                        throw new SyncFactoryException(</span>
                            &quot;Resource &quot; + ROWSET_PROPERTIES + &quot; not found&quot;);
                    }
<span class="nc" id="L378">                    properties.load(stream);</span>
<span class="nc bnc" id="L379" title="All 8 branches missed.">                }</span>

<span class="nc" id="L381">                parseProperties(properties);</span>

            // removed else, has properties should sum together

<span class="nc" id="L385">            } catch (FileNotFoundException e) {</span>
<span class="nc" id="L386">                throw new SyncFactoryException(&quot;Cannot locate properties file: &quot; + e);</span>
<span class="nc" id="L387">            } catch (IOException e) {</span>
<span class="nc" id="L388">                throw new SyncFactoryException(&quot;IOException: &quot; + e);</span>
<span class="nc" id="L389">            }</span>

            /*
             * Now deal with -Drowset.provider.classname
             * load additional properties from -D command line
             */
<span class="nc" id="L395">            properties.clear();</span>
<span class="nc" id="L396">            String providerImpls = System.getProperty(ROWSET_SYNC_PROVIDER);</span>

<span class="nc bnc" id="L398" title="All 2 branches missed.">            if (providerImpls != null) {</span>
<span class="nc" id="L399">                int i = 0;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">                if (providerImpls.indexOf(colon) &gt; 0) {</span>
<span class="nc" id="L401">                    StringTokenizer tokenizer = new StringTokenizer(providerImpls, colon);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">                    while (tokenizer.hasMoreElements()) {</span>
<span class="nc" id="L403">                        properties.put(ROWSET_SYNC_PROVIDER + &quot;.&quot; + i, tokenizer.nextToken());</span>
<span class="nc" id="L404">                        i++;</span>
                    }
<span class="nc" id="L406">                } else {</span>
<span class="nc" id="L407">                    properties.put(ROWSET_SYNC_PROVIDER, providerImpls);</span>
                }
<span class="nc" id="L409">                parseProperties(properties);</span>
            }
        }
<span class="nc" id="L412">    }</span>

    /**
     * The internal debug switch.
     */
<span class="nc" id="L417">    private static boolean debug = false;</span>
    /**
     * Internal registry count for the number of providers contained in the
     * registry.
     */
<span class="nc" id="L422">    private static int providerImplIndex = 0;</span>

    /**
     * Internal handler for all standard property parsing. Parses standard
     * ROWSET properties and stores lazy references into the the internal registry.
     */
    private static void parseProperties(Properties p) {

<span class="nc" id="L430">        ProviderImpl impl = null;</span>
<span class="nc" id="L431">        String key = null;</span>
<span class="nc" id="L432">        String[] propertyNames = null;</span>

<span class="nc bnc" id="L434" title="All 2 branches missed.">        for (Enumeration&lt;?&gt; e = p.propertyNames(); e.hasMoreElements();) {</span>

<span class="nc" id="L436">            String str = (String) e.nextElement();</span>

<span class="nc" id="L438">            int w = str.length();</span>

<span class="nc bnc" id="L440" title="All 2 branches missed.">            if (str.startsWith(SyncFactory.ROWSET_SYNC_PROVIDER)) {</span>

<span class="nc" id="L442">                impl = new ProviderImpl();</span>
<span class="nc" id="L443">                impl.setIndex(providerImplIndex++);</span>

<span class="nc bnc" id="L445" title="All 2 branches missed.">                if (w == (SyncFactory.ROWSET_SYNC_PROVIDER).length()) {</span>
                    // no property index has been set.
<span class="nc" id="L447">                    propertyNames = getPropertyNames(false);</span>
                } else {
                    // property index has been set.
<span class="nc" id="L450">                    propertyNames = getPropertyNames(true, str.substring(w - 1));</span>
                }

<span class="nc" id="L453">                key = p.getProperty(propertyNames[0]);</span>
<span class="nc" id="L454">                impl.setClassname(key);</span>
<span class="nc" id="L455">                impl.setVendor(p.getProperty(propertyNames[1]));</span>
<span class="nc" id="L456">                impl.setVersion(p.getProperty(propertyNames[2]));</span>
<span class="nc" id="L457">                implementations.put(key, impl);</span>
            }
<span class="nc" id="L459">        }</span>
<span class="nc" id="L460">    }</span>

    /**
     * Used by the parseProperties methods to disassemble each property tuple.
     */
    private static String[] getPropertyNames(boolean append) {
<span class="nc" id="L466">        return getPropertyNames(append, null);</span>
    }

    /**
     * Disassembles each property and its associated value. Also handles
     * overloaded property names that contain indexes.
     */
    private static String[] getPropertyNames(boolean append,
            String propertyIndex) {
<span class="nc" id="L475">        String dot = &quot;.&quot;;</span>
<span class="nc" id="L476">        String[] propertyNames =</span>
                new String[]{SyncFactory.ROWSET_SYNC_PROVIDER,
            SyncFactory.ROWSET_SYNC_VENDOR,
            SyncFactory.ROWSET_SYNC_PROVIDER_VERSION};
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (append) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            for (int i = 0; i &lt; propertyNames.length; i++) {</span>
<span class="nc" id="L482">                propertyNames[i] = propertyNames[i] +</span>
                        dot +
                        propertyIndex;
            }
<span class="nc" id="L486">            return propertyNames;</span>
        } else {
<span class="nc" id="L488">            return propertyNames;</span>
        }
    }

    /**
     * Internal debug method that outputs the registry contents.
     */
    private static void showImpl(ProviderImpl impl) {
<span class="nc" id="L496">        System.out.println(&quot;Provider implementation:&quot;);</span>
<span class="nc" id="L497">        System.out.println(&quot;Classname: &quot; + impl.getClassname());</span>
<span class="nc" id="L498">        System.out.println(&quot;Vendor: &quot; + impl.getVendor());</span>
<span class="nc" id="L499">        System.out.println(&quot;Version: &quot; + impl.getVersion());</span>
<span class="nc" id="L500">        System.out.println(&quot;Impl index: &quot; + impl.getIndex());</span>
<span class="nc" id="L501">    }</span>

    /**
     * Returns the &lt;code&gt;SyncProvider&lt;/code&gt; instance identified by &lt;i&gt;providerID&lt;/i&gt;.
     *
     * @param providerID the unique identifier of the provider
     * @return a &lt;code&gt;SyncProvider&lt;/code&gt; implementation
     * @throws SyncFactoryException If the SyncProvider cannot be found,
     * the providerID is {@code null}, or
     * some error was encountered when trying to invoke this provider.
     */
    public static SyncProvider getInstance(String providerID)
            throws SyncFactoryException {

<span class="nc bnc" id="L515" title="All 2 branches missed.">        if(providerID == null) {</span>
<span class="nc" id="L516">            throw new SyncFactoryException(&quot;The providerID cannot be null&quot;);</span>
        }

<span class="nc" id="L519">        initMapIfNecessary(); // populate HashTable</span>
<span class="nc" id="L520">        initJNDIContext();    // check JNDI context for any additional bindings</span>

<span class="nc" id="L522">        ProviderImpl impl = (ProviderImpl) implementations.get(providerID);</span>

<span class="nc bnc" id="L524" title="All 2 branches missed.">        if (impl == null) {</span>
            // Requested SyncProvider is unavailable. Return default provider.
<span class="nc" id="L526">            return new com.sun.rowset.providers.RIOptimisticProvider();</span>
        }

        // Attempt to invoke classname from registered SyncProvider list
<span class="nc" id="L530">        Class&lt;?&gt; c = null;</span>
        try {
<span class="nc" id="L532">            ClassLoader cl = Thread.currentThread().getContextClassLoader();</span>

            /**
             * The SyncProvider implementation of the user will be in
             * the classpath. We need to find the ClassLoader which loads
             * this SyncFactory and try to laod the SyncProvider class from
             * there.
             **/
<span class="nc" id="L540">            c = Class.forName(providerID, true, cl);</span>

<span class="nc bnc" id="L542" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L543">                return (SyncProvider) c.newInstance();</span>
            } else {
<span class="nc" id="L545">                return new com.sun.rowset.providers.RIOptimisticProvider();</span>
            }

<span class="nc" id="L548">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L549">            throw new SyncFactoryException(&quot;IllegalAccessException: &quot; + e.getMessage());</span>
<span class="nc" id="L550">        } catch (InstantiationException e) {</span>
<span class="nc" id="L551">            throw new SyncFactoryException(&quot;InstantiationException: &quot; + e.getMessage());</span>
<span class="nc" id="L552">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L553">            throw new SyncFactoryException(&quot;ClassNotFoundException: &quot; + e.getMessage());</span>
        }
    }

    /**
     * Returns an Enumeration of currently registered synchronization
     * providers.  A &lt;code&gt;RowSet&lt;/code&gt; implementation may use any provider in
     * the enumeration as its &lt;code&gt;SyncProvider&lt;/code&gt; object.
     * &lt;p&gt;
     * At a minimum, the reference synchronization provider allowing
     * RowSet content data to be stored using a JDBC driver should be
     * possible.
     *
     * @return Enumeration  A enumeration of available synchronization
     * providers that are registered with this Factory
     * @throws SyncFactoryException If an error occurs obtaining the registered
     * providers
     */
    public static Enumeration&lt;SyncProvider&gt; getRegisteredProviders()
            throws SyncFactoryException {
<span class="nc" id="L573">        initMapIfNecessary();</span>
        // return a collection of classnames
        // of type SyncProvider
<span class="nc" id="L576">        return implementations.elements();</span>
    }

    /**
     * Sets the logging object to be used by the &lt;code&gt;SyncProvider&lt;/code&gt;
     * implementation provided by the &lt;code&gt;SyncFactory&lt;/code&gt;. All
     * &lt;code&gt;SyncProvider&lt;/code&gt; implementations can log their events to
     * this object and the application can retrieve a handle to this
     * object using the &lt;code&gt;getLogger&lt;/code&gt; method.
     * &lt;p&gt;
     * This method checks to see that there is an {@code SQLPermission}
     * object  which grants the permission {@code setSyncFactory}
     * before allowing the method to succeed.  If a
     * {@code SecurityManager} exists and its
     * {@code checkPermission} method denies calling {@code setLogger},
     * this method throws a
     * {@code java.lang.SecurityException}.
     *
     * @param logger A Logger object instance
     * @throws java.lang.SecurityException if a security manager exists and its
     *   {@code checkPermission} method denies calling {@code setLogger}
     * @throws NullPointerException if the logger is null
     * @see SecurityManager#checkPermission
     */
    public static void setLogger(Logger logger) {

<span class="nc" id="L602">        SecurityManager sec = System.getSecurityManager();</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">        if (sec != null) {</span>
<span class="nc" id="L604">            sec.checkPermission(SET_SYNCFACTORY_PERMISSION);</span>
        }

<span class="nc bnc" id="L607" title="All 2 branches missed.">        if(logger == null){</span>
<span class="nc" id="L608">            throw new NullPointerException(&quot;You must provide a Logger&quot;);</span>
        }
<span class="nc" id="L610">        rsLogger = logger;</span>
<span class="nc" id="L611">    }</span>

    /**
     * Sets the logging object that is used by &lt;code&gt;SyncProvider&lt;/code&gt;
     * implementations provided by the &lt;code&gt;SyncFactory&lt;/code&gt; SPI. All
     * &lt;code&gt;SyncProvider&lt;/code&gt; implementations can log their events
     * to this object and the application can retrieve a handle to this
     * object using the &lt;code&gt;getLogger&lt;/code&gt; method.
     * &lt;p&gt;
     * This method checks to see that there is an {@code SQLPermission}
     * object  which grants the permission {@code setSyncFactory}
     * before allowing the method to succeed.  If a
     * {@code SecurityManager} exists and its
     * {@code checkPermission} method denies calling {@code setLogger},
     * this method throws a
     * {@code java.lang.SecurityException}.
     *
     * @param logger a Logger object instance
     * @param level a Level object instance indicating the degree of logging
     * required
     * @throws java.lang.SecurityException if a security manager exists and its
     *   {@code checkPermission} method denies calling {@code setLogger}
     * @throws NullPointerException if the logger is null
     * @see SecurityManager#checkPermission
     * @see LoggingPermission
     */
    public static void setLogger(Logger logger, Level level) {
        // singleton
<span class="nc" id="L639">        SecurityManager sec = System.getSecurityManager();</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (sec != null) {</span>
<span class="nc" id="L641">            sec.checkPermission(SET_SYNCFACTORY_PERMISSION);</span>
        }

<span class="nc bnc" id="L644" title="All 2 branches missed.">        if(logger == null){</span>
<span class="nc" id="L645">            throw new NullPointerException(&quot;You must provide a Logger&quot;);</span>
        }
<span class="nc" id="L647">        logger.setLevel(level);</span>
<span class="nc" id="L648">        rsLogger = logger;</span>
<span class="nc" id="L649">    }</span>

    /**
     * Returns the logging object for applications to retrieve
     * synchronization events posted by SyncProvider implementations.
     * @return The {@code Logger} that has been specified for use by
     * {@code SyncProvider} implementations
     * @throws SyncFactoryException if no logging object has been set.
     */
    public static Logger getLogger() throws SyncFactoryException {

<span class="nc" id="L660">        Logger result = rsLogger;</span>
        // only one logger per session
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L663">            throw new SyncFactoryException(&quot;(SyncFactory) : No logger has been set&quot;);</span>
        }

<span class="nc" id="L666">        return result;</span>
    }

    /**
     * Sets the initial JNDI context from which SyncProvider implementations
     * can be retrieved from a JNDI namespace
     * &lt;p&gt;
     *  This method checks to see that there is an {@code SQLPermission}
     * object  which grants the permission {@code setSyncFactory}
     * before allowing the method to succeed.  If a
     * {@code SecurityManager} exists and its
     * {@code checkPermission} method denies calling {@code setJNDIContext},
     * this method throws a
     * {@code java.lang.SecurityException}.
     *
     * @param ctx a valid JNDI context
     * @throws SyncFactoryException if the supplied JNDI context is null
     * @throws java.lang.SecurityException if a security manager exists and its
     *  {@code checkPermission} method denies calling {@code setJNDIContext}
     * @see SecurityManager#checkPermission
     */
    public static synchronized void setJNDIContext(javax.naming.Context ctx)
            throws SyncFactoryException {
<span class="nc" id="L689">        SecurityManager sec = System.getSecurityManager();</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (sec != null) {</span>
<span class="nc" id="L691">            sec.checkPermission(SET_SYNCFACTORY_PERMISSION);</span>
        }
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (ctx == null) {</span>
<span class="nc" id="L694">            throw new SyncFactoryException(&quot;Invalid JNDI context supplied&quot;);</span>
        }
<span class="nc" id="L696">        ic = ctx;</span>
<span class="nc" id="L697">    }</span>

    /**
     * Controls JNDI context initialization.
     *
     * @throws SyncFactoryException if an error occurs parsing the JNDI context
     */
    private static synchronized void initJNDIContext() throws SyncFactoryException {

<span class="nc bnc" id="L706" title="All 4 branches missed.">        if ((ic != null) &amp;&amp; (lazyJNDICtxRefresh == false)) {</span>
            try {
<span class="nc" id="L708">                parseProperties(parseJNDIContext());</span>
<span class="nc" id="L709">                lazyJNDICtxRefresh = true; // touch JNDI namespace once.</span>
<span class="nc" id="L710">            } catch (NamingException e) {</span>
<span class="nc" id="L711">                e.printStackTrace();</span>
<span class="nc" id="L712">                throw new SyncFactoryException(&quot;SPI: NamingException: &quot; + e.getExplanation());</span>
<span class="nc" id="L713">            } catch (Exception e) {</span>
<span class="nc" id="L714">                e.printStackTrace();</span>
<span class="nc" id="L715">                throw new SyncFactoryException(&quot;SPI: Exception: &quot; + e.getMessage());</span>
<span class="nc" id="L716">            }</span>
        }
<span class="nc" id="L718">    }</span>
    /**
     * Internal switch indicating whether the JNDI namespace should be re-read.
     */
<span class="nc" id="L722">    private static boolean lazyJNDICtxRefresh = false;</span>

    /**
     * Parses the set JNDI Context and passes bindings to the enumerateBindings
     * method when complete.
     */
    private static Properties parseJNDIContext() throws NamingException {

<span class="nc" id="L730">        NamingEnumeration&lt;?&gt; bindings = ic.listBindings(&quot;&quot;);</span>
<span class="nc" id="L731">        Properties properties = new Properties();</span>

        // Hunt one level below context for available SyncProvider objects
<span class="nc" id="L734">        enumerateBindings(bindings, properties);</span>

<span class="nc" id="L736">        return properties;</span>
    }

    /**
     * Scans each binding on JNDI context and determines if any binding is an
     * instance of SyncProvider, if so, add this to the registry and continue to
     * scan the current context using a re-entrant call to this method until all
     * bindings have been enumerated.
     */
    private static void enumerateBindings(NamingEnumeration&lt;?&gt; bindings,
            Properties properties) throws NamingException {

<span class="nc" id="L748">        boolean syncProviderObj = false; // move to parameters ?</span>

        try {
<span class="nc" id="L751">            Binding bd = null;</span>
<span class="nc" id="L752">            Object elementObj = null;</span>
<span class="nc" id="L753">            String element = null;</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">            while (bindings.hasMore()) {</span>
<span class="nc" id="L755">                bd = (Binding) bindings.next();</span>
<span class="nc" id="L756">                element = bd.getName();</span>
<span class="nc" id="L757">                elementObj = bd.getObject();</span>

<span class="nc bnc" id="L759" title="All 2 branches missed.">                if (!(ic.lookup(element) instanceof Context)) {</span>
                    // skip directories/sub-contexts
<span class="nc bnc" id="L761" title="All 2 branches missed.">                    if (ic.lookup(element) instanceof SyncProvider) {</span>
<span class="nc" id="L762">                        syncProviderObj = true;</span>
                    }
                }

<span class="nc bnc" id="L766" title="All 2 branches missed.">                if (syncProviderObj) {</span>
<span class="nc" id="L767">                    SyncProvider sync = (SyncProvider) elementObj;</span>
<span class="nc" id="L768">                    properties.put(SyncFactory.ROWSET_SYNC_PROVIDER,</span>
<span class="nc" id="L769">                            sync.getProviderID());</span>
<span class="nc" id="L770">                    syncProviderObj = false; // reset</span>
<span class="nc" id="L771">                }</span>

            }
<span class="nc" id="L774">        } catch (javax.naming.NotContextException e) {</span>
<span class="nc" id="L775">            bindings.next();</span>
            // Re-entrant call into method
<span class="nc" id="L777">            enumerateBindings(bindings, properties);</span>
<span class="nc" id="L778">        }</span>
<span class="nc" id="L779">    }</span>

    /**
     * Lazy initialization Holder class used by {@code getSyncFactory}
     */
<span class="nc" id="L784">    private static class SyncFactoryHolder {</span>
<span class="nc" id="L785">        static final SyncFactory factory = new SyncFactory();</span>
    }
}

/**
 * Internal class that defines the lazy reference construct for each registered
 * SyncProvider implementation.
 */
<span class="nc" id="L793">class ProviderImpl extends SyncProvider {</span>

<span class="nc" id="L795">    private String className = null;</span>
<span class="nc" id="L796">    private String vendorName = null;</span>
<span class="nc" id="L797">    private String ver = null;</span>
    private int index;

    public void setClassname(String classname) {
<span class="nc" id="L801">        className = classname;</span>
<span class="nc" id="L802">    }</span>

    public String getClassname() {
<span class="nc" id="L805">        return className;</span>
    }

    public void setVendor(String vendor) {
<span class="nc" id="L809">        vendorName = vendor;</span>
<span class="nc" id="L810">    }</span>

    public String getVendor() {
<span class="nc" id="L813">        return vendorName;</span>
    }

    public void setVersion(String providerVer) {
<span class="nc" id="L817">        ver = providerVer;</span>
<span class="nc" id="L818">    }</span>

    public String getVersion() {
<span class="nc" id="L821">        return ver;</span>
    }

    public void setIndex(int i) {
<span class="nc" id="L825">        index = i;</span>
<span class="nc" id="L826">    }</span>

    public int getIndex() {
<span class="nc" id="L829">        return index;</span>
    }

    public int getDataSourceLock() throws SyncProviderException {

<span class="nc" id="L834">        int dsLock = 0;</span>
        try {
<span class="nc" id="L836">            dsLock = SyncFactory.getInstance(className).getDataSourceLock();</span>
<span class="nc" id="L837">        } catch (SyncFactoryException sfEx) {</span>

<span class="nc" id="L839">            throw new SyncProviderException(sfEx.getMessage());</span>
<span class="nc" id="L840">        }</span>

<span class="nc" id="L842">        return dsLock;</span>
    }

    public int getProviderGrade() {

<span class="nc" id="L847">        int grade = 0;</span>

        try {
<span class="nc" id="L850">            grade = SyncFactory.getInstance(className).getProviderGrade();</span>
<span class="nc" id="L851">        } catch (SyncFactoryException sfEx) {</span>
            //
<span class="nc" id="L853">        }</span>

<span class="nc" id="L855">        return grade;</span>
    }

    public String getProviderID() {
<span class="nc" id="L859">        return className;</span>
    }

    /*
    public javax.sql.RowSetInternal getRowSetInternal() {
    try
    {
    return SyncFactory.getInstance(className).getRowSetInternal();
    } catch(SyncFactoryException sfEx) {
    //
    }
    }
     */
    public javax.sql.RowSetReader getRowSetReader() {

<span class="nc" id="L874">        RowSetReader rsReader = null;</span>

        try {
<span class="nc" id="L877">            rsReader = SyncFactory.getInstance(className).getRowSetReader();</span>
<span class="nc" id="L878">        } catch (SyncFactoryException sfEx) {</span>
            //
<span class="nc" id="L880">        }</span>

<span class="nc" id="L882">        return rsReader;</span>

    }

    public javax.sql.RowSetWriter getRowSetWriter() {

<span class="nc" id="L888">        RowSetWriter rsWriter = null;</span>
        try {
<span class="nc" id="L890">            rsWriter = SyncFactory.getInstance(className).getRowSetWriter();</span>
<span class="nc" id="L891">        } catch (SyncFactoryException sfEx) {</span>
            //
<span class="nc" id="L893">        }</span>

<span class="nc" id="L895">        return rsWriter;</span>
    }

    public void setDataSourceLock(int param)
            throws SyncProviderException {

        try {
<span class="nc" id="L902">            SyncFactory.getInstance(className).setDataSourceLock(param);</span>
<span class="nc" id="L903">        } catch (SyncFactoryException sfEx) {</span>

<span class="nc" id="L905">            throw new SyncProviderException(sfEx.getMessage());</span>
<span class="nc" id="L906">        }</span>
<span class="nc" id="L907">    }</span>

    public int supportsUpdatableView() {

<span class="nc" id="L911">        int view = 0;</span>

        try {
<span class="nc" id="L914">            view = SyncFactory.getInstance(className).supportsUpdatableView();</span>
<span class="nc" id="L915">        } catch (SyncFactoryException sfEx) {</span>
            //
<span class="nc" id="L917">        }</span>

<span class="nc" id="L919">        return view;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>