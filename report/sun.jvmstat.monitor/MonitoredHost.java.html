<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MonitoredHost.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.jvmstat.monitor</a> &gt; <span class="el_source">MonitoredHost.java</span></div><h1>MonitoredHost.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.jvmstat.monitor;

import java.util.*;
import java.net.*;
import java.lang.reflect.*;

import sun.jvmstat.monitor.event.HostListener;

/**
 * An abstraction for a host that contains instrumented Java Virtual
 * Machines. The class provides abstract factory methods for creating
 * concrete instances of this class and factory methods for creating
 * {@link MonitoredVm} instances. Concrete implementations of this class
 * provide methods for managing the communications protocols and provide
 * for event notification.
 *
 * @author Brian Doherty
 * @since 1.5
 *
 * @see HostIdentifier
 * @see VmIdentifier
 * @see MonitoredVm
 * @see HostListener
 */
<span class="nc bnc" id="L50" title="All 2 branches missed.">public abstract class MonitoredHost {</span>
<span class="nc" id="L51">    private static Map&lt;HostIdentifier, MonitoredHost&gt; monitoredHosts =</span>
                new HashMap&lt;HostIdentifier, MonitoredHost&gt;();

    /*
     * The monitoring implementation override mechanism. The value of
     * this property is used as the class name for the concrete MonitoredHost
     * subclass that implements the monitoring APIs.  Setting this property
     * will cause the remaining override mechanisms to be ignored. When
     * this mechanism is used, the HostIdentifier scheme name, which
     * indicates the communications protocol, is not used to locate a
     * the protocol specific package. However, the HostIdentifier is
     * still passed to the corresponding single arg constructor.
     * This property is not expected to be set in normal circumstances.
     */
    private static final String IMPL_OVERRIDE_PROP_NAME =
            &quot;sun.jvmstat.monitor.MonitoredHost&quot;;

    /*
     * The monitoring package name override mechanism. The value
     * the this property is used as base package name for the
     * monitoring implementation package. This property is not
     * expected to be set under normal circumstances.
     */
    private static final String IMPL_PKG_PROP_NAME =
            &quot;sun.jvmstat.monitor.package&quot;;
<span class="nc" id="L76">    private static final String IMPL_PACKAGE =</span>
<span class="nc" id="L77">            System.getProperty(IMPL_PKG_PROP_NAME, &quot;sun.jvmstat.perfdata&quot;);</span>

    /*
     * The default optimized local protocol override mechanism. The value
     * of this property is used to construct the default package name
     * for the default optimized local protocol as follows:
     *        &lt;IMPL_PACKAGE&gt;.monitor.&lt;LOCAL_PROTOCOL&gt;
     * This property is not expected to be set under normal circumstances.
     */
    private static final String LOCAL_PROTOCOL_PROP_NAME =
            &quot;sun.jvmstat.monitor.local&quot;;
<span class="nc" id="L88">    private static final String LOCAL_PROTOCOL =</span>
<span class="nc" id="L89">            System.getProperty(LOCAL_PROTOCOL_PROP_NAME, &quot;local&quot;);</span>

    /*
     * The default remote protocol override mechanism. The value of
     * this property is used to construct the default package name
     * for the default remote protocol protocol as follows:
     *        &lt;IMPL_PACKAGE&gt;.monitor.protocol.&lt;REMOTE_PROTOCOL&gt;
     * This property is not expected to be set under normal circumstances.
     */
    private static final String REMOTE_PROTOCOL_PROP_NAME =
            &quot;sun.jvmstat.monitor.remote&quot;;
<span class="nc" id="L100">    private static final String REMOTE_PROTOCOL =</span>
<span class="nc" id="L101">            System.getProperty(REMOTE_PROTOCOL_PROP_NAME, &quot;rmi&quot;);</span>

    /*
     * The default class name of the MonitoredHost implementation subclass.
     * There is no override mechanism for this variable, other than the
     * IMPL_OVERRIDE_PROP_NAME override, which is larger in scope. A concrete
     * instance of this class is expected to be found in:
     *     &lt;IMPL_PACKAGE&gt;.monitor.protocol.&lt;protocol&gt;.&lt;MONITORED_HOST_CLASS&gt;
     */
    private static final String MONITORED_HOST_CLASS = &quot;MonitoredHostProvider&quot;;

    /**
     * The HostIdentifier for this MonitoredHost instance.
     */
    protected HostIdentifier hostId;

    /**
     * The polling interval, in milliseconds, for this MonitoredHost instance.
     */
    protected int interval;

    /**
     * The last Exception encountered while polling this MonitoredHost.
     */
    protected Exception lastException;

    /**
     * Factory method to construct MonitoredHost instances to manage
     * connections to the host indicated by &lt;tt&gt;hostIdString&lt;/tt&gt;
     *
     * @param hostIdString a String representation of a {@link HostIdentifier}
     * @return MonitoredHost - the MonitoredHost instance for communicating
     *                         with the indicated host using the protocol
     *                         specified in hostIdString.
     * @throws MonitorException  Thrown if monitoring errors occur.
     * @throws URISyntaxException Thrown when the hostIdString is poorly
     *                            formed. This exception may get encapsulated
     *                            into MonitorException in a future revision.
     */
    public static MonitoredHost getMonitoredHost(String hostIdString)
                  throws MonitorException, URISyntaxException {
<span class="nc" id="L142">        HostIdentifier hostId = new HostIdentifier(hostIdString);</span>
<span class="nc" id="L143">        return getMonitoredHost(hostId);</span>
    }

    /**
     * Factory method to construct a MonitoredHost instance to manage the
     * connection to the Java Virtual Machine indicated by &lt;tt&gt;vmid&lt;/tt&gt;.
     *
     * This method provide a convenient short cut for attaching to a specific
     * instrumented Java Virtual Machine. The information in the VmIdentifier
     * is used to construct a corresponding HostIdentifier, which in turn is
     * used to create the MonitoredHost instance.
     *
     * @param vmid The identifier for the target Java Virtual Machine.
     * @return MonitoredHost - The MonitoredHost object needed to attach to
     *                         the target Java Virtual Machine.
     *
     * @throws MonitorException Thrown if monitoring errors occur.
     */
    public static MonitoredHost getMonitoredHost(VmIdentifier vmid)
                 throws MonitorException {
        // use the VmIdentifier to construct the corresponding HostIdentifier
<span class="nc" id="L164">        HostIdentifier hostId = new HostIdentifier(vmid);</span>
<span class="nc" id="L165">        return getMonitoredHost(hostId);</span>
    }

    /**
     * Factory method to construct a MonitoredHost instance to manage the
     * connection to the host indicated by &lt;tt&gt;hostId&lt;/tt&gt;.
     *
     * @param hostId the identifier for the target host.
     * @return MonitoredHost - The MonitoredHost object needed to attach to
     *                         the target host.
     *
     * @throws MonitorException Thrown if monitoring errors occur.
     */
    public static MonitoredHost getMonitoredHost(HostIdentifier hostId)
                  throws MonitorException {
        /*
         * determine the class name to load. If the system property is set,
         * use the indicated class. otherwise, use the default class.
         */
<span class="nc" id="L184">        String classname = System.getProperty(IMPL_OVERRIDE_PROP_NAME);</span>
<span class="nc" id="L185">        MonitoredHost mh = null;</span>

<span class="nc" id="L187">        synchronized(monitoredHosts) {</span>
<span class="nc" id="L188">            mh = monitoredHosts.get(hostId);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (mh != null) {</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                if (mh.isErrored()) {</span>
<span class="nc" id="L191">                    monitoredHosts.remove(hostId);</span>
                } else {
<span class="nc" id="L193">                    return mh;</span>
                }
            }
<span class="nc" id="L196">        }</span>

<span class="nc" id="L198">        hostId = resolveHostId(hostId);</span>

<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (classname == null) {</span>
            // construct the class name
<span class="nc" id="L202">            classname = IMPL_PACKAGE + &quot;.monitor.protocol.&quot;</span>
<span class="nc" id="L203">                        + hostId.getScheme() + &quot;.&quot; + MONITORED_HOST_CLASS;</span>
        }

        try {
            // run the constructor taking a single String parameter.
<span class="nc" id="L208">            Class&lt;?&gt; c = Class.forName(classname);</span>

<span class="nc" id="L210">            Constructor cons = c.getConstructor(</span>
<span class="nc" id="L211">                new Class[] { hostId.getClass() }</span>
            );

<span class="nc" id="L214">            mh = (MonitoredHost)cons.newInstance(new Object[] { hostId } );</span>

<span class="nc" id="L216">            synchronized(monitoredHosts) {</span>
<span class="nc" id="L217">                monitoredHosts.put(mh.hostId, mh);</span>
<span class="nc" id="L218">            }</span>
<span class="nc" id="L219">            return mh;</span>
<span class="nc" id="L220">        } catch (ClassNotFoundException e) {</span>
            // from Class.forName();
<span class="nc" id="L222">            throw new IllegalArgumentException(&quot;Could not find &quot; + classname</span>
<span class="nc" id="L223">                                               + &quot;: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L224">        } catch (NoSuchMethodException e) {</span>
            // from Class.getConstructor();
<span class="nc" id="L226">            throw new IllegalArgumentException(</span>
                &quot;Expected constructor missing in &quot; + classname + &quot;: &quot;
<span class="nc" id="L228">                + e.getMessage(), e);</span>
<span class="nc" id="L229">        } catch (IllegalAccessException e) {</span>
            // from Constructor.newInstance()
<span class="nc" id="L231">            throw new IllegalArgumentException(</span>
                &quot;Unexpected constructor access in &quot; + classname + &quot;: &quot;
<span class="nc" id="L233">                + e.getMessage(), e);</span>
<span class="nc" id="L234">        } catch (InstantiationException e) {</span>
<span class="nc" id="L235">            throw new IllegalArgumentException(classname + &quot;is abstract: &quot;</span>
<span class="nc" id="L236">                                               + e.getMessage(), e);</span>
<span class="nc" id="L237">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L238">            Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (cause instanceof MonitorException) {</span>
<span class="nc" id="L240">                throw (MonitorException)cause;</span>
            }
<span class="nc" id="L242">            throw new RuntimeException(&quot;Unexpected exception&quot;, e);</span>
        }
    }

    /**
     * Method to resolve unspecified components of the given HostIdentifier
     * by constructing a new HostIdentifier that replaces the unspecified
     * components with the default values.
     *
     * @param hostId the unresolved HostIdentifier.
     * @return HostIdentifier - a resolved HostIdentifier.
     *
     * @throws MonitorException Thrown if monitoring errors occur.
     */
    protected static HostIdentifier resolveHostId(HostIdentifier hostId)
                     throws MonitorException {
<span class="nc" id="L258">        String hostname = hostId.getHost();</span>
<span class="nc" id="L259">        String scheme = hostId.getScheme();</span>
<span class="nc" id="L260">        StringBuffer sb = new StringBuffer();</span>

<span class="nc bnc" id="L262" title="All 4 branches missed.">        assert hostname != null;</span>

<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (scheme == null) {</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (hostname.compareTo(&quot;localhost&quot;) == 0) {</span>
<span class="nc" id="L266">                scheme = LOCAL_PROTOCOL;</span>
            } else {
<span class="nc" id="L268">                scheme = REMOTE_PROTOCOL;</span>
            }
        }

<span class="nc" id="L272">        sb.append(scheme).append(&quot;:&quot;).append(hostId.getSchemeSpecificPart());</span>

<span class="nc" id="L274">        String frag = hostId.getFragment();</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (frag != null) {</span>
<span class="nc" id="L276">            sb.append(&quot;#&quot;).append(frag);</span>
        }

        try {
<span class="nc" id="L280">            return new HostIdentifier(sb.toString());</span>
<span class="nc" id="L281">        } catch (URISyntaxException e) {</span>
            // programming error - HostIdentifier was valid.
<span class="nc bnc" id="L283" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L284">            throw new IllegalArgumentException(&quot;Malformed URI created: &quot;</span>
<span class="nc" id="L285">                                               + sb.toString());</span>
        }
    }

    /**
     * Return the resolved HostIdentifier for this MonitoredHost.
     *
     * @return HostIdentifier - the resolved HostIdentifier.
     */
    public HostIdentifier getHostIdentifier() {
<span class="nc" id="L295">        return hostId;</span>
    }

    /* ---- Methods to support polled MonitoredHost Implementations ----- */

    /**
     * Set the polling interval for this MonitoredHost.
     *
     * @param interval the polling interval, in milliseconds
     */
    public void setInterval(int interval) {
<span class="nc" id="L306">        this.interval = interval;</span>
<span class="nc" id="L307">    }</span>

    /**
     * Get the polling interval.
     *
     * @return int - the polling interval in milliseconds for this MonitoredHost
     */
    public int getInterval() {
<span class="nc" id="L315">        return interval;</span>
    }

    /**
     * Set the last exception encountered while polling this MonitoredHost.
     *
     * @param lastException the last exception encountered;
     */
    public void setLastException(Exception lastException) {
<span class="nc" id="L324">        this.lastException = lastException;</span>
<span class="nc" id="L325">    }</span>

    /**
     * Get the last exception encountered while polling this MonitoredHost.
     *
     * @return Exception - the last exception occurred while polling this
     *                     MonitoredHost, or &lt;tt&gt;null&lt;/tt&gt; if no exception
     *                     has occurred or the exception has been cleared,
     */
    public Exception getLastException() {
<span class="nc" id="L335">        return lastException;</span>
    }

    /**
     * Clear the last exception.
     */
    public void clearLastException() {
<span class="nc" id="L342">        lastException = null;</span>
<span class="nc" id="L343">    }</span>

    /**
     * Test if this MonitoredHost is in the errored state. If this method
     * returns true, then the Exception returned by getLastException()
     * indicates the Exception that caused the error condition.
     *
     * @return boolean - true if the MonitoredHost instance has experienced
     *                   an error, or false if it hasn't or if any past
     *                   error has been cleared.
     */
    public boolean isErrored() {
<span class="nc bnc" id="L355" title="All 2 branches missed.">        return lastException != null;</span>
    }

    /**
     * Get the MonitoredVm for the given Java Virtual Machine. The default
     * sampling interval is used for the MonitoredVm instance.
     *
     * @param id the VmIdentifier specifying the target Java Virtual Machine.
     * @return MonitoredVm - the MonitoredVm instance for the target Java
     *                       Virtual Machine.
     * @throws MonitorException Thrown if monitoring errors occur.
     */
    public abstract MonitoredVm getMonitoredVm(VmIdentifier id)
                                throws MonitorException;

    /**
     * Get the MonitoredVm for the given Java Virtual Machine. The sampling
     * interval is set to the given interval.
     *
     * @param id the VmIdentifier specifying the target Java Virtual Machine.
     * @param interval the sampling interval for the target Java Virtual Machine.
     * @return MonitoredVm - the MonitoredVm instance for the target Java
     *                       Virtual Machine.
     * @throws MonitorException Thrown if monitoring errors occur.
     */
    public abstract MonitoredVm getMonitoredVm(VmIdentifier id, int interval)
                                throws MonitorException;

    /**
     * Detach from the indicated MonitoredVm.
     *
     * @param vm the monitored Java Virtual Machine.
     * @throws MonitorException Thrown if monitoring errors occur.
     */
    public abstract void detach(MonitoredVm vm) throws MonitorException;

    /**
     * Add a HostListener. The given listener is added to the list
     * of HostListener objects to be notified of MonitoredHost related events.
     *
     * @param listener the HostListener to add.
     * @throws MonitorException Thrown if monitoring errors occur.
     */
    public abstract void addHostListener(HostListener listener)
                         throws MonitorException;

    /**
     * Remove a HostListener. The given listener is removed from the list
     * of HostListener objects to be notified of MonitoredHost related events.
     *
     * @param listener the HostListener to add.
     * @throws MonitorException Thrown if monitoring errors occur.
     */
    public abstract void removeHostListener(HostListener listener)
                         throws MonitorException;

    /**
     * Return the current set of active Java Virtual Machines for this
     * MonitoredHost. The returned Set contains {@link Integer} instances
     * holding the local virtual machine identifier, or &lt;em&gt;lvmid&lt;/em&gt;
     * for each instrumented Java Virtual Machine currently available.
     *
     * @return Set - the current set of active Java Virtual Machines associated
     *               with this MonitoredHost, or the empty set of none.
     * @throws MonitorException Thrown if monitoring errors occur.
     */
    public abstract Set&lt;Integer&gt; activeVms() throws MonitorException;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>