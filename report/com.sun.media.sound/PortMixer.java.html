<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PortMixer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">PortMixer.java</span></div><h1>PortMixer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import java.util.Vector;

import javax.sound.sampled.Control;
import javax.sound.sampled.Line;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.Port;
import javax.sound.sampled.BooleanControl;
import javax.sound.sampled.CompoundControl;
import javax.sound.sampled.FloatControl;


/**
 * A Mixer which only provides Ports.
 *
 * @author Florian Bomers
 */
final class PortMixer extends AbstractMixer {

    // CONSTANTS
    private static final int SRC_UNKNOWN      = 0x01;
    private static final int SRC_MICROPHONE   = 0x02;
    private static final int SRC_LINE_IN      = 0x03;
    private static final int SRC_COMPACT_DISC = 0x04;
    private static final int SRC_MASK         = 0xFF;

    private static final int DST_UNKNOWN      = 0x0100;
    private static final int DST_SPEAKER      = 0x0200;
    private static final int DST_HEADPHONE    = 0x0300;
    private static final int DST_LINE_OUT     = 0x0400;
    private static final int DST_MASK         = 0xFF00;

    // INSTANCE VARIABLES
    private Port.Info[] portInfos;
    // cache of instantiated ports
    private PortMixerPort[] ports;

    // instance ID of the native implementation
<span class="nc" id="L65">    private long id = 0;</span>

    // CONSTRUCTOR
    PortMixer(PortMixerProvider.PortMixerInfo portMixerInfo) {
        // pass in Line.Info, mixer, controls
<span class="nc" id="L70">        super(portMixerInfo,              // Mixer.Info</span>
              null,                       // Control[]
              null,                       // Line.Info[] sourceLineInfo
              null);                      // Line.Info[] targetLineInfo

        if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixer: constructor&quot;);

<span class="nc" id="L77">        int count = 0;</span>
<span class="nc" id="L78">        int srcLineCount = 0;</span>
<span class="nc" id="L79">        int dstLineCount = 0;</span>

        try {
            try {
<span class="nc" id="L83">                id = nOpen(getMixerIndex());</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">                if (id != 0) {</span>
<span class="nc" id="L85">                    count = nGetPortCount(id);</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">                    if (count &lt; 0) {</span>
                        if (Printer.trace) Printer.trace(&quot;nGetPortCount() returned error code: &quot; + count);
<span class="nc" id="L88">                        count = 0;</span>
                    }
                }
<span class="nc" id="L91">            } catch (Exception e) {}</span>

<span class="nc" id="L93">            portInfos = new Port.Info[count];</span>

<span class="nc bnc" id="L95" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L96">                int type = nGetPortType(id, i);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">                srcLineCount += ((type &amp; SRC_MASK) != 0)?1:0;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                dstLineCount += ((type &amp; DST_MASK) != 0)?1:0;</span>
<span class="nc" id="L99">                portInfos[i] = getPortInfo(i, type);</span>
            }
        } finally {
<span class="nc bnc" id="L102" title="All 4 branches missed.">            if (id != 0) {</span>
<span class="nc" id="L103">                nClose(id);</span>
            }
<span class="nc" id="L105">            id = 0;</span>
<span class="nc" id="L106">        }</span>

        // fill sourceLineInfo and targetLineInfos with copies of the ones in portInfos
<span class="nc" id="L109">        sourceLineInfo = new Port.Info[srcLineCount];</span>
<span class="nc" id="L110">        targetLineInfo = new Port.Info[dstLineCount];</span>

<span class="nc" id="L112">        srcLineCount = 0; dstLineCount = 0;</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">            if (portInfos[i].isSource()) {</span>
<span class="nc" id="L115">                sourceLineInfo[srcLineCount++] = portInfos[i];</span>
            } else {
<span class="nc" id="L117">                targetLineInfo[dstLineCount++] = portInfos[i];</span>
            }
        }

        if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixer: constructor completed&quot;);
<span class="nc" id="L122">    }</span>


    // ABSTRACT MIXER: ABSTRACT METHOD IMPLEMENTATIONS

    public Line getLine(Line.Info info) throws LineUnavailableException {
<span class="nc" id="L128">        Line.Info fullInfo = getLineInfo(info);</span>

<span class="nc bnc" id="L130" title="All 4 branches missed.">        if ((fullInfo != null) &amp;&amp; (fullInfo instanceof Port.Info)) {</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            for (int i = 0; i &lt; portInfos.length; i++) {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">                if (fullInfo.equals(portInfos[i])) {</span>
<span class="nc" id="L133">                    return getPort(i);</span>
                }
            }
        }
<span class="nc" id="L137">        throw new IllegalArgumentException(&quot;Line unsupported: &quot; + info);</span>
    }


    public int getMaxLines(Line.Info info) {
<span class="nc" id="L142">        Line.Info fullInfo = getLineInfo(info);</span>

        // if it's not supported at all, return 0.
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (fullInfo == null) {</span>
<span class="nc" id="L146">            return 0;</span>
        }

<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (fullInfo instanceof Port.Info) {</span>
            //return AudioSystem.NOT_SPECIFIED; // if several instances of PortMixerPort
<span class="nc" id="L151">            return 1;</span>
        }
<span class="nc" id="L153">        return 0;</span>
    }


    protected void implOpen() throws LineUnavailableException {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixer: implOpen (id=&quot;+id+&quot;)&quot;);

        // open the mixer device
<span class="nc" id="L161">        id = nOpen(getMixerIndex());</span>

        if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixer: implOpen succeeded.&quot;);
<span class="nc" id="L164">    }</span>

    protected void implClose() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixer: implClose&quot;);

        // close the mixer device
<span class="nc" id="L170">        long thisID = id;</span>
<span class="nc" id="L171">        id = 0;</span>
<span class="nc" id="L172">        nClose(thisID);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (ports != null) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            for (int i = 0; i &lt; ports.length; i++) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                if (ports[i] != null) {</span>
<span class="nc" id="L176">                    ports[i].disposeControls();</span>
                }
            }
        }

        if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixer: implClose succeeded&quot;);
<span class="nc" id="L182">    }</span>

<span class="nc" id="L184">    protected void implStart() {}</span>
<span class="nc" id="L185">    protected void implStop() {}</span>

    // IMPLEMENTATION HELPERS

    private Port.Info getPortInfo(int portIndex, int type) {
<span class="nc bnc" id="L190" title="All 9 branches missed.">        switch (type) {</span>
<span class="nc" id="L191">        case SRC_UNKNOWN:      return new PortInfo(nGetPortName(getID(), portIndex), true);</span>
<span class="nc" id="L192">        case SRC_MICROPHONE:   return Port.Info.MICROPHONE;</span>
<span class="nc" id="L193">        case SRC_LINE_IN:      return Port.Info.LINE_IN;</span>
<span class="nc" id="L194">        case SRC_COMPACT_DISC: return Port.Info.COMPACT_DISC;</span>

<span class="nc" id="L196">        case DST_UNKNOWN:      return new PortInfo(nGetPortName(getID(), portIndex), false);</span>
<span class="nc" id="L197">        case DST_SPEAKER:      return Port.Info.SPEAKER;</span>
<span class="nc" id="L198">        case DST_HEADPHONE:    return Port.Info.HEADPHONE;</span>
<span class="nc" id="L199">        case DST_LINE_OUT:     return Port.Info.LINE_OUT;</span>
        }
        // should never happen...
        if (Printer.debug) Printer.debug(&quot;unknown port type: &quot;+type);
<span class="nc" id="L203">        return null;</span>
    }

    int getMixerIndex() {
<span class="nc" id="L207">        return ((PortMixerProvider.PortMixerInfo) getMixerInfo()).getIndex();</span>
    }

    Port getPort(int index) {
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (ports == null) {</span>
<span class="nc" id="L212">            ports = new PortMixerPort[portInfos.length];</span>
        }
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (ports[index] == null) {</span>
<span class="nc" id="L215">            ports[index] = new PortMixerPort((Port.Info)portInfos[index], this, index);</span>
<span class="nc" id="L216">            return ports[index];</span>
        }
        // $$fb TODO: return (Port) (ports[index].clone());
<span class="nc" id="L219">        return ports[index];</span>
    }

    long getID() {
<span class="nc" id="L223">        return id;</span>
    }

    // INNER CLASSES

    /**
     * Private inner class representing a Port for the PortMixer.
     */
    private static final class PortMixerPort extends AbstractLine
            implements Port {

        private final int portIndex;
        private long id;

        // CONSTRUCTOR
        private PortMixerPort(Port.Info info,
                              PortMixer mixer,
                              int portIndex) {
<span class="nc" id="L241">            super(info, mixer, null);</span>
            if (Printer.trace) Printer.trace(&quot;PortMixerPort CONSTRUCTOR: info: &quot; + info);
<span class="nc" id="L243">            this.portIndex = portIndex;</span>
<span class="nc" id="L244">        }</span>


        // ABSTRACT METHOD IMPLEMENTATIONS

        // ABSTRACT LINE

        void implOpen() throws LineUnavailableException {
            if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixerPort: implOpen().&quot;);
<span class="nc" id="L253">            long newID = ((PortMixer) mixer).getID();</span>
<span class="nc bnc" id="L254" title="All 6 branches missed.">            if ((id == 0) || (newID != id) || (controls.length == 0)) {</span>
<span class="nc" id="L255">                id = newID;</span>
<span class="nc" id="L256">                Vector vector = new Vector();</span>
<span class="nc" id="L257">                synchronized (vector) {</span>
<span class="nc" id="L258">                    nGetControls(id, portIndex, vector);</span>
<span class="nc" id="L259">                    controls = new Control[vector.size()];</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                    for (int i = 0; i &lt; controls.length; i++) {</span>
<span class="nc" id="L261">                        controls[i] = (Control) vector.elementAt(i);</span>
                    }
<span class="nc" id="L263">                }</span>
<span class="nc" id="L264">            } else {</span>
<span class="nc" id="L265">                enableControls(controls, true);</span>
            }
            if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixerPort: implOpen() succeeded&quot;);
<span class="nc" id="L268">        }</span>

        private void enableControls(Control[] controls, boolean enable) {
<span class="nc bnc" id="L271" title="All 2 branches missed.">            for (int i = 0; i &lt; controls.length; i++) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">                if (controls[i] instanceof BoolCtrl) {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">                    ((BoolCtrl) controls[i]).closed = !enable;</span>
                }
<span class="nc bnc" id="L275" title="All 2 branches missed.">                else if (controls[i] instanceof FloatCtrl) {</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">                    ((FloatCtrl) controls[i]).closed = !enable;</span>
                }
<span class="nc bnc" id="L278" title="All 2 branches missed.">                else if (controls[i] instanceof CompoundControl) {</span>
<span class="nc" id="L279">                    enableControls(((CompoundControl) controls[i]).getMemberControls(), enable);</span>
                }
            }
<span class="nc" id="L282">        }</span>

        private void disposeControls() {
<span class="nc" id="L285">            enableControls(controls, false);</span>
<span class="nc" id="L286">            controls = new Control[0];</span>
<span class="nc" id="L287">        }</span>


        void implClose() {
            if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixerPort: implClose()&quot;);
            // get rid of controls
<span class="nc" id="L293">            enableControls(controls, false);</span>
            if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixerPort: implClose() succeeded&quot;);
<span class="nc" id="L295">        }</span>

        // METHOD OVERRIDES

        // this is very similar to open(AudioFormat, int) in AbstractDataLine...
        public void open() throws LineUnavailableException {
<span class="nc" id="L301">            synchronized (mixer) {</span>
                // if the line is not currently open, try to open it with this format and buffer size
<span class="nc bnc" id="L303" title="All 2 branches missed.">                if (!isOpen()) {</span>
                    if (Printer.trace) Printer.trace(&quot;&gt; PortMixerPort: open&quot;);
                    // reserve mixer resources for this line
<span class="nc" id="L306">                    mixer.open(this);</span>
                    try {
                        // open the line.  may throw LineUnavailableException.
<span class="nc" id="L309">                        implOpen();</span>

                        // if we succeeded, set the open state to true and send events
<span class="nc" id="L312">                        setOpen(true);</span>
<span class="nc" id="L313">                    } catch (LineUnavailableException e) {</span>
                        // release mixer resources for this line and then throw the exception
<span class="nc" id="L315">                        mixer.close(this);</span>
<span class="nc" id="L316">                        throw e;</span>
<span class="nc" id="L317">                    }</span>
                    if (Printer.trace) Printer.trace(&quot;&lt; PortMixerPort: open succeeded&quot;);
                }
<span class="nc" id="L320">            }</span>
<span class="nc" id="L321">        }</span>

        // this is very similar to close() in AbstractDataLine...
        public void close() {
<span class="nc" id="L325">            synchronized (mixer) {</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                if (isOpen()) {</span>
                    if (Printer.trace) Printer.trace(&quot;&gt; PortMixerPort.close()&quot;);

                    // set the open state to false and send events
<span class="nc" id="L330">                    setOpen(false);</span>

                    // close resources for this line
<span class="nc" id="L333">                    implClose();</span>

                    // release mixer resources for this line
<span class="nc" id="L336">                    mixer.close(this);</span>
                    if (Printer.trace) Printer.trace(&quot;&lt; PortMixerPort.close() succeeded&quot;);
                }
<span class="nc" id="L339">            }</span>
<span class="nc" id="L340">        }</span>

    } // class PortMixerPort

    /**
     * Private inner class representing a BooleanControl for PortMixerPort
     */
    private static final class BoolCtrl extends BooleanControl {
        // the handle to the native control function
        private final long controlID;
<span class="nc" id="L350">        private boolean closed = false;</span>

        private static BooleanControl.Type createType(String name) {
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (name.equals(&quot;Mute&quot;)) {</span>
<span class="nc" id="L354">                return BooleanControl.Type.MUTE;</span>
            }
<span class="nc bnc" id="L356" title="All 2 branches missed.">            else if (name.equals(&quot;Select&quot;)) {</span>
                // $$fb add as new static type?
                //return BooleanControl.Type.SELECT;
            }
<span class="nc" id="L360">            return new BCT(name);</span>
        }


        private BoolCtrl(long controlID, String name) {
<span class="nc" id="L365">            this(controlID, createType(name));</span>
<span class="nc" id="L366">        }</span>

        private BoolCtrl(long controlID, BooleanControl.Type typ) {
<span class="nc" id="L369">            super(typ, false);</span>
<span class="nc" id="L370">            this.controlID = controlID;</span>
<span class="nc" id="L371">        }</span>

        public void setValue(boolean value) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">            if (!closed) {</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                nControlSetIntValue(controlID, value?1:0);</span>
            }
<span class="nc" id="L377">        }</span>

        public boolean getValue() {
<span class="nc bnc" id="L380" title="All 2 branches missed.">            if (!closed) {</span>
                // never use any cached values
<span class="nc bnc" id="L382" title="All 2 branches missed.">                return (nControlGetIntValue(controlID)!=0)?true:false;</span>
            }
            // ??
<span class="nc" id="L385">            return false;</span>
        }

        /**
         * inner class for custom types
         */
        private static final class BCT extends BooleanControl.Type {
            private BCT(String name) {
<span class="nc" id="L393">                super(name);</span>
<span class="nc" id="L394">            }</span>
        }
    }

    /**
     * Private inner class representing a CompoundControl for PortMixerPort
     */
    private static final class CompCtrl extends CompoundControl {
        private CompCtrl(String name, Control[] controls) {
<span class="nc" id="L403">            super(new CCT(name), controls);</span>
<span class="nc" id="L404">        }</span>

        /**
         * inner class for custom compound control types
         */
        private static final class CCT extends CompoundControl.Type {
            private CCT(String name) {
<span class="nc" id="L411">                super(name);</span>
<span class="nc" id="L412">            }</span>
        }
    }

    /**
     * Private inner class representing a BooleanControl for PortMixerPort
     */
    private static final class FloatCtrl extends FloatControl {
        // the handle to the native control function
        private final long controlID;
<span class="nc" id="L422">        private boolean closed = false;</span>

        // predefined float control types. See also Ports.h
<span class="nc" id="L425">        private final static FloatControl.Type[] FLOAT_CONTROL_TYPES = {</span>
            null,
            FloatControl.Type.BALANCE,
            FloatControl.Type.MASTER_GAIN,
            FloatControl.Type.PAN,
            FloatControl.Type.VOLUME
        };

        private FloatCtrl(long controlID, String name,
                          float min, float max, float precision, String units) {
<span class="nc" id="L435">            this(controlID, new FCT(name), min, max, precision, units);</span>
<span class="nc" id="L436">        }</span>

        private FloatCtrl(long controlID, int type,
                          float min, float max, float precision, String units) {
<span class="nc" id="L440">            this(controlID, FLOAT_CONTROL_TYPES[type], min, max, precision, units);</span>
<span class="nc" id="L441">        }</span>

        private FloatCtrl(long controlID, FloatControl.Type typ,
                         float min, float max, float precision, String units) {
<span class="nc" id="L445">            super(typ, min, max, precision, 1000, min, units);</span>
<span class="nc" id="L446">            this.controlID = controlID;</span>
<span class="nc" id="L447">        }</span>

        public void setValue(float value) {
<span class="nc bnc" id="L450" title="All 2 branches missed.">            if (!closed) {</span>
<span class="nc" id="L451">                nControlSetFloatValue(controlID, value);</span>
            }
<span class="nc" id="L453">        }</span>

        public float getValue() {
<span class="nc bnc" id="L456" title="All 2 branches missed.">            if (!closed) {</span>
                // never use any cached values
<span class="nc" id="L458">                return nControlGetFloatValue(controlID);</span>
            }
            // ??
<span class="nc" id="L461">            return getMinimum();</span>
        }

        /**
         * inner class for custom types
         */
        private static final class FCT extends FloatControl.Type {
            private FCT(String name) {
<span class="nc" id="L469">                super(name);</span>
<span class="nc" id="L470">            }</span>
        }
    }

    /**
     * Private inner class representing a port info
     */
    private static final class PortInfo extends Port.Info {
        private PortInfo(String name, boolean isSource) {
<span class="nc" id="L479">            super(Port.class, name, isSource);</span>
<span class="nc" id="L480">        }</span>
    }

    // open the mixer with the given index. Returns a handle ID
    private static native long nOpen(int mixerIndex) throws LineUnavailableException;
    private static native void nClose(long id);

    // gets the number of ports for this mixer
    private static native int nGetPortCount(long id);

    // gets the type of the port with this index
    private static native int nGetPortType(long id, int portIndex);

    // gets the name of the port with this index
    private static native String nGetPortName(long id, int portIndex);

    // fills the vector with the controls for this port
    private static native void nGetControls(long id, int portIndex, Vector vector);

    // getters/setters for controls
    private static native void nControlSetIntValue(long controlID, int value);
    private static native int nControlGetIntValue(long controlID);
    private static native void nControlSetFloatValue(long controlID, float value);
    private static native float nControlGetFloatValue(long controlID);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>