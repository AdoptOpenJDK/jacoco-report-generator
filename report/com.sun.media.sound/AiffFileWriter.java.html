<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AiffFileWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">AiffFileWriter.java</span></div><h1>AiffFileWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

import java.io.BufferedOutputStream;
import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.RandomAccessFile;
import java.io.SequenceInputStream;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;

//$$fb this class is buggy. Should be replaced in future.

/**
 * AIFF file writer.
 *
 * @author Jan Borgersen
 */
public final class AiffFileWriter extends SunFileWriter {

    /**
     * Constructs a new AiffFileWriter object.
     */
    public AiffFileWriter() {
<span class="nc" id="L59">        super(new AudioFileFormat.Type[]{AudioFileFormat.Type.AIFF});</span>
<span class="nc" id="L60">    }</span>


    // METHODS TO IMPLEMENT AudioFileWriter

    public AudioFileFormat.Type[] getAudioFileTypes(AudioInputStream stream) {

<span class="nc" id="L67">        AudioFileFormat.Type[] filetypes = new AudioFileFormat.Type[types.length];</span>
<span class="nc" id="L68">        System.arraycopy(types, 0, filetypes, 0, types.length);</span>

        // make sure we can write this stream
<span class="nc" id="L71">        AudioFormat format = stream.getFormat();</span>
<span class="nc" id="L72">        AudioFormat.Encoding encoding = format.getEncoding();</span>

<span class="nc bnc" id="L74" title="All 2 branches missed.">        if( (AudioFormat.Encoding.ALAW.equals(encoding)) ||</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">            (AudioFormat.Encoding.ULAW.equals(encoding)) ||</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">            (AudioFormat.Encoding.PCM_SIGNED.equals(encoding)) ||</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">            (AudioFormat.Encoding.PCM_UNSIGNED.equals(encoding)) ) {</span>

<span class="nc" id="L79">            return filetypes;</span>
        }

<span class="nc" id="L82">        return new AudioFileFormat.Type[0];</span>
    }


    public int write(AudioInputStream stream, AudioFileFormat.Type fileType, OutputStream out) throws IOException {

        //$$fb the following check must come first ! Otherwise
        // the next frame length check may throw an IOException and
        // interrupt iterating File Writers. (see bug 4351296)

        // throws IllegalArgumentException if not supported
<span class="nc" id="L93">        AiffFileFormat aiffFileFormat = (AiffFileFormat)getAudioFileFormat(fileType, stream);</span>

        // we must know the total data length to calculate the file length
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if( stream.getFrameLength() == AudioSystem.NOT_SPECIFIED ) {</span>
<span class="nc" id="L97">            throw new IOException(&quot;stream length not specified&quot;);</span>
        }

<span class="nc" id="L100">        int bytesWritten = writeAiffFile(stream, aiffFileFormat, out);</span>
<span class="nc" id="L101">        return bytesWritten;</span>
    }


    public int write(AudioInputStream stream, AudioFileFormat.Type fileType, File out) throws IOException {

        // throws IllegalArgumentException if not supported
<span class="nc" id="L108">        AiffFileFormat aiffFileFormat = (AiffFileFormat)getAudioFileFormat(fileType, stream);</span>

        // first write the file without worrying about length fields
<span class="nc" id="L111">        FileOutputStream fos = new FileOutputStream( out );     // throws IOException</span>
<span class="nc" id="L112">        BufferedOutputStream bos = new BufferedOutputStream( fos, bisBufferSize );</span>
<span class="nc" id="L113">        int bytesWritten = writeAiffFile(stream, aiffFileFormat, bos );</span>
<span class="nc" id="L114">        bos.close();</span>

        // now, if length fields were not specified, calculate them,
        // open as a random access file, write the appropriate fields,
        // close again....
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if( aiffFileFormat.getByteLength()== AudioSystem.NOT_SPECIFIED ) {</span>

            // $$kk: 10.22.99: jan: please either implement this or throw an exception!
            // $$fb: 2001-07-13: done. Fixes Bug 4479981
<span class="nc" id="L123">            int ssndBlockSize           = (aiffFileFormat.getFormat().getChannels() * aiffFileFormat.getFormat().getSampleSizeInBits());</span>

<span class="nc" id="L125">            int aiffLength=bytesWritten;</span>
<span class="nc" id="L126">            int ssndChunkSize=aiffLength-aiffFileFormat.getHeaderSize()+16;</span>
<span class="nc" id="L127">            long dataSize=ssndChunkSize-16;</span>
<span class="nc" id="L128">            int numFrames=(int) (dataSize*8/ssndBlockSize);</span>

<span class="nc" id="L130">            RandomAccessFile raf=new RandomAccessFile(out, &quot;rw&quot;);</span>
            // skip FORM magic
<span class="nc" id="L132">            raf.skipBytes(4);</span>
<span class="nc" id="L133">            raf.writeInt(aiffLength-8);</span>
            // skip aiff2 magic, fver chunk, comm magic, comm size, channel count,
<span class="nc" id="L135">            raf.skipBytes(4+aiffFileFormat.getFverChunkSize()+4+4+2);</span>
            // write frame count
<span class="nc" id="L137">            raf.writeInt(numFrames);</span>
            // skip sample size, samplerate, SSND magic
<span class="nc" id="L139">            raf.skipBytes(2+10+4);</span>
<span class="nc" id="L140">            raf.writeInt(ssndChunkSize-8);</span>
            // that's all
<span class="nc" id="L142">            raf.close();</span>
        }

<span class="nc" id="L145">        return bytesWritten;</span>
    }


    // -----------------------------------------------------------------------

    /**
     * Returns the AudioFileFormat describing the file that will be written from this AudioInputStream.
     * Throws IllegalArgumentException if not supported.
     */
    private AudioFileFormat getAudioFileFormat(AudioFileFormat.Type type, AudioInputStream stream) {

<span class="nc" id="L157">        AudioFormat format = null;</span>
<span class="nc" id="L158">        AiffFileFormat fileFormat = null;</span>
<span class="nc" id="L159">        AudioFormat.Encoding encoding = AudioFormat.Encoding.PCM_SIGNED;</span>

<span class="nc" id="L161">        AudioFormat streamFormat = stream.getFormat();</span>
<span class="nc" id="L162">        AudioFormat.Encoding streamEncoding = streamFormat.getEncoding();</span>


        float sampleRate;
        int sampleSizeInBits;
        int channels;
        int frameSize;
        float frameRate;
        int fileSize;
<span class="nc" id="L171">        boolean convert8to16 = false;</span>

<span class="nc bnc" id="L173" title="All 2 branches missed.">        if( !types[0].equals(type) ) {</span>
<span class="nc" id="L174">            throw new IllegalArgumentException(&quot;File type &quot; + type + &quot; not supported.&quot;);</span>
        }

<span class="nc bnc" id="L177" title="All 2 branches missed.">        if( (AudioFormat.Encoding.ALAW.equals(streamEncoding)) ||</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            (AudioFormat.Encoding.ULAW.equals(streamEncoding)) ) {</span>

<span class="nc bnc" id="L180" title="All 2 branches missed.">            if( streamFormat.getSampleSizeInBits()==8 ) {</span>

<span class="nc" id="L182">                encoding = AudioFormat.Encoding.PCM_SIGNED;</span>
<span class="nc" id="L183">                sampleSizeInBits=16;</span>
<span class="nc" id="L184">                convert8to16 = true;</span>

            } else {

                // can't convert non-8-bit ALAW,ULAW
<span class="nc" id="L189">                throw new IllegalArgumentException(&quot;Encoding &quot; + streamEncoding + &quot; supported only for 8-bit data.&quot;);</span>
            }
<span class="nc bnc" id="L191" title="All 2 branches missed.">        } else if ( streamFormat.getSampleSizeInBits()==8 ) {</span>

<span class="nc" id="L193">            encoding = AudioFormat.Encoding.PCM_UNSIGNED;</span>
<span class="nc" id="L194">            sampleSizeInBits=8;</span>

        } else {

<span class="nc" id="L198">            encoding = AudioFormat.Encoding.PCM_SIGNED;</span>
<span class="nc" id="L199">            sampleSizeInBits=streamFormat.getSampleSizeInBits();</span>
        }


<span class="nc" id="L203">        format = new AudioFormat( encoding,</span>
<span class="nc" id="L204">                                  streamFormat.getSampleRate(),</span>
                                  sampleSizeInBits,
<span class="nc" id="L206">                                  streamFormat.getChannels(),</span>
<span class="nc" id="L207">                                  streamFormat.getFrameSize(),</span>
<span class="nc" id="L208">                                  streamFormat.getFrameRate(),</span>
                                  true);        // AIFF is big endian


<span class="nc bnc" id="L212" title="All 2 branches missed.">        if( stream.getFrameLength()!=AudioSystem.NOT_SPECIFIED ) {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if( convert8to16 ) {</span>
<span class="nc" id="L214">                fileSize = (int)stream.getFrameLength()*streamFormat.getFrameSize()*2 + AiffFileFormat.AIFF_HEADERSIZE;</span>
            } else {
<span class="nc" id="L216">                fileSize = (int)stream.getFrameLength()*streamFormat.getFrameSize() + AiffFileFormat.AIFF_HEADERSIZE;</span>
            }
        } else {
<span class="nc" id="L219">            fileSize = AudioSystem.NOT_SPECIFIED;</span>
        }

<span class="nc" id="L222">        fileFormat = new AiffFileFormat( AudioFileFormat.Type.AIFF,</span>
                                         fileSize,
                                         format,
<span class="nc" id="L225">                                         (int)stream.getFrameLength() );</span>

<span class="nc" id="L227">        return fileFormat;</span>
    }


    private int writeAiffFile(InputStream in, AiffFileFormat aiffFileFormat, OutputStream out) throws IOException {

<span class="nc" id="L233">        int bytesRead = 0;</span>
<span class="nc" id="L234">        int bytesWritten = 0;</span>
<span class="nc" id="L235">        InputStream fileStream = getFileStream(aiffFileFormat, in);</span>
<span class="nc" id="L236">        byte buffer[] = new byte[bisBufferSize];</span>
<span class="nc" id="L237">        int maxLength = aiffFileFormat.getByteLength();</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">        while( (bytesRead = fileStream.read( buffer )) &gt;= 0 ) {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            if (maxLength&gt;0) {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                if( bytesRead &lt; maxLength ) {</span>
<span class="nc" id="L242">                    out.write( buffer, 0, (int)bytesRead );</span>
<span class="nc" id="L243">                    bytesWritten += bytesRead;</span>
<span class="nc" id="L244">                    maxLength -= bytesRead;</span>
                } else {
<span class="nc" id="L246">                    out.write( buffer, 0, (int)maxLength );</span>
<span class="nc" id="L247">                    bytesWritten += maxLength;</span>
<span class="nc" id="L248">                    maxLength = 0;</span>
<span class="nc" id="L249">                    break;</span>
                }

            } else {
<span class="nc" id="L253">                out.write( buffer, 0, (int)bytesRead );</span>
<span class="nc" id="L254">                bytesWritten += bytesRead;</span>
            }
        }

<span class="nc" id="L258">        return bytesWritten;</span>
    }

    private InputStream getFileStream(AiffFileFormat aiffFileFormat, InputStream audioStream) throws IOException  {

        // private method ... assumes aiffFileFormat is a supported file format

<span class="nc" id="L265">        AudioFormat format = aiffFileFormat.getFormat();</span>
<span class="nc" id="L266">        AudioFormat streamFormat = null;</span>
<span class="nc" id="L267">        AudioFormat.Encoding encoding = null;</span>

        //$$fb a little bit nicer handling of constants

        //int headerSize          = 54;
<span class="nc" id="L272">        int headerSize          = aiffFileFormat.getHeaderSize();</span>

        //int fverChunkSize       = 0;
<span class="nc" id="L275">        int fverChunkSize       = aiffFileFormat.getFverChunkSize();</span>
        //int commChunkSize       = 26;
<span class="nc" id="L277">        int commChunkSize       = aiffFileFormat.getCommChunkSize();</span>
<span class="nc" id="L278">        int aiffLength          = -1;</span>
<span class="nc" id="L279">        int ssndChunkSize       = -1;</span>
        //int ssndOffset                        = headerSize - 16;
<span class="nc" id="L281">        int ssndOffset                  = aiffFileFormat.getSsndChunkOffset();</span>
<span class="nc" id="L282">        short channels = (short) format.getChannels();</span>
<span class="nc" id="L283">        short sampleSize = (short) format.getSampleSizeInBits();</span>
<span class="nc" id="L284">        int ssndBlockSize               = (channels * sampleSize);</span>
<span class="nc" id="L285">        int numFrames                   = aiffFileFormat.getFrameLength();</span>
<span class="nc" id="L286">        long dataSize            = -1;</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if( numFrames != AudioSystem.NOT_SPECIFIED) {</span>
<span class="nc" id="L288">            dataSize = (long) numFrames * ssndBlockSize / 8;</span>
<span class="nc" id="L289">            ssndChunkSize = (int)dataSize + 16;</span>
<span class="nc" id="L290">            aiffLength = (int)dataSize+headerSize;</span>
        }
<span class="nc" id="L292">        float sampleFramesPerSecond = format.getSampleRate();</span>
<span class="nc" id="L293">        int compCode = AiffFileFormat.AIFC_PCM;</span>

<span class="nc" id="L295">        byte header[] = null;</span>
<span class="nc" id="L296">        ByteArrayInputStream headerStream = null;</span>
<span class="nc" id="L297">        ByteArrayOutputStream baos = null;</span>
<span class="nc" id="L298">        DataOutputStream dos = null;</span>
<span class="nc" id="L299">        SequenceInputStream aiffStream = null;</span>
<span class="nc" id="L300">        InputStream codedAudioStream = audioStream;</span>

        // if we need to do any format conversion, do it here....

<span class="nc bnc" id="L304" title="All 2 branches missed.">        if( audioStream instanceof AudioInputStream ) {</span>

<span class="nc" id="L306">            streamFormat = ((AudioInputStream)audioStream).getFormat();</span>
<span class="nc" id="L307">            encoding = streamFormat.getEncoding();</span>


            // $$jb: Note that AIFF samples are ALWAYS signed
<span class="nc bnc" id="L311" title="All 2 branches missed.">            if( (AudioFormat.Encoding.PCM_UNSIGNED.equals(encoding)) ||</span>
<span class="nc bnc" id="L312" title="All 4 branches missed.">                ( (AudioFormat.Encoding.PCM_SIGNED.equals(encoding)) &amp;&amp; !streamFormat.isBigEndian() ) ) {</span>

                // plug in the transcoder to convert to PCM_SIGNED. big endian
<span class="nc" id="L315">                codedAudioStream = AudioSystem.getAudioInputStream( new AudioFormat (</span>
                                                                                     AudioFormat.Encoding.PCM_SIGNED,
<span class="nc" id="L317">                                                                                     streamFormat.getSampleRate(),</span>
<span class="nc" id="L318">                                                                                     streamFormat.getSampleSizeInBits(),</span>
<span class="nc" id="L319">                                                                                     streamFormat.getChannels(),</span>
<span class="nc" id="L320">                                                                                     streamFormat.getFrameSize(),</span>
<span class="nc" id="L321">                                                                                     streamFormat.getFrameRate(),</span>
                                                                                     true ),
                                                                    (AudioInputStream)audioStream );

<span class="nc bnc" id="L325" title="All 2 branches missed.">            } else if( (AudioFormat.Encoding.ULAW.equals(encoding)) ||</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                       (AudioFormat.Encoding.ALAW.equals(encoding)) ) {</span>

<span class="nc bnc" id="L328" title="All 2 branches missed.">                if( streamFormat.getSampleSizeInBits() != 8 ) {</span>
<span class="nc" id="L329">                    throw new IllegalArgumentException(&quot;unsupported encoding&quot;);</span>
                }

                                //$$fb 2001-07-13: this is probably not what we want:
                                //     writing PCM when ULAW/ALAW is requested. AIFC is able to write ULAW !

                                // plug in the transcoder to convert to PCM_SIGNED_BIG_ENDIAN
<span class="nc" id="L336">                codedAudioStream = AudioSystem.getAudioInputStream( new AudioFormat (</span>
                                                                                     AudioFormat.Encoding.PCM_SIGNED,
<span class="nc" id="L338">                                                                                     streamFormat.getSampleRate(),</span>
<span class="nc" id="L339">                                                                                     streamFormat.getSampleSizeInBits() * 2,</span>
<span class="nc" id="L340">                                                                                     streamFormat.getChannels(),</span>
<span class="nc" id="L341">                                                                                     streamFormat.getFrameSize() * 2,</span>
<span class="nc" id="L342">                                                                                     streamFormat.getFrameRate(),</span>
                                                                                     true ),
                                                                    (AudioInputStream)audioStream );
            }
        }


        // Now create an AIFF stream header...
<span class="nc" id="L350">        baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L351">        dos = new DataOutputStream(baos);</span>

        // Write the outer FORM chunk
<span class="nc" id="L354">        dos.writeInt(AiffFileFormat.AIFF_MAGIC);</span>
<span class="nc" id="L355">        dos.writeInt( (aiffLength-8) );</span>
<span class="nc" id="L356">        dos.writeInt(AiffFileFormat.AIFF_MAGIC2);</span>

        // Write a FVER chunk - only for AIFC
        //dos.writeInt(FVER_MAGIC);
        //dos.writeInt( (fverChunkSize-8) );
        //dos.writeInt(FVER_TIMESTAMP);

        // Write a COMM chunk
<span class="nc" id="L364">        dos.writeInt(AiffFileFormat.COMM_MAGIC);</span>
<span class="nc" id="L365">        dos.writeInt( (commChunkSize-8) );</span>
<span class="nc" id="L366">        dos.writeShort(channels);</span>
<span class="nc" id="L367">        dos.writeInt(numFrames);</span>
<span class="nc" id="L368">        dos.writeShort(sampleSize);</span>
<span class="nc" id="L369">        write_ieee_extended(dos, sampleFramesPerSecond);   // 10 bytes</span>

        //Only for AIFC
        //dos.writeInt(compCode);
        //dos.writeInt(compCode);
        //dos.writeShort(0);

        // Write the SSND chunk header
<span class="nc" id="L377">        dos.writeInt(AiffFileFormat.SSND_MAGIC);</span>
<span class="nc" id="L378">        dos.writeInt( (ssndChunkSize-8) );</span>
        // ssndOffset and ssndBlockSize set to 0 upon
        // recommendation in &quot;Sound Manager&quot; chapter in
        // &quot;Inside Macintosh Sound&quot;, pp 2-87  (from Babu)
<span class="nc" id="L382">        dos.writeInt(0);        // ssndOffset</span>
<span class="nc" id="L383">        dos.writeInt(0);        // ssndBlockSize</span>

        // Concat this with the audioStream and return it

<span class="nc" id="L387">        dos.close();</span>
<span class="nc" id="L388">        header = baos.toByteArray();</span>
<span class="nc" id="L389">        headerStream = new ByteArrayInputStream( header );</span>

<span class="nc" id="L391">        aiffStream = new SequenceInputStream(headerStream,</span>
                            new NoCloseInputStream(codedAudioStream));

<span class="nc" id="L394">        return aiffStream;</span>

    }




    // HELPER METHODS

    private static final int DOUBLE_MANTISSA_LENGTH = 52;
    private static final int DOUBLE_EXPONENT_LENGTH = 11;
    private static final long DOUBLE_SIGN_MASK     = 0x8000000000000000L;
    private static final long DOUBLE_EXPONENT_MASK = 0x7FF0000000000000L;
    private static final long DOUBLE_MANTISSA_MASK = 0x000FFFFFFFFFFFFFL;
    private static final int DOUBLE_EXPONENT_OFFSET = 1023;

    private static final int EXTENDED_EXPONENT_OFFSET = 16383;
    private static final int EXTENDED_MANTISSA_LENGTH = 63;
    private static final int EXTENDED_EXPONENT_LENGTH = 15;
    private static final long EXTENDED_INTEGER_MASK = 0x8000000000000000L;

    /**
     * Extended precision IEEE floating-point conversion routine.
     * @argument DataOutputStream
     * @argument double
     * @exception IOException
     */
    private void write_ieee_extended(DataOutputStream dos, float f) throws IOException {
        /* The special cases NaN, Infinity and Zero are ignored, since
           they do not represent useful sample rates anyway.
           Denormalized number aren't handled, too. Below, there is a cast
           from float to double. We hope that in this conversion,
           numbers are normalized. Numbers that cannot be normalized are
           ignored, too, as they, too, do not represent useful sample rates. */
<span class="nc" id="L428">        long doubleBits = Double.doubleToLongBits((double) f);</span>

<span class="nc" id="L430">        long sign = (doubleBits &amp; DOUBLE_SIGN_MASK)</span>
            &gt;&gt; (DOUBLE_EXPONENT_LENGTH + DOUBLE_MANTISSA_LENGTH);
<span class="nc" id="L432">        long doubleExponent = (doubleBits &amp; DOUBLE_EXPONENT_MASK)</span>
            &gt;&gt; DOUBLE_MANTISSA_LENGTH;
<span class="nc" id="L434">        long doubleMantissa = doubleBits &amp; DOUBLE_MANTISSA_MASK;</span>

<span class="nc" id="L436">        long extendedExponent = doubleExponent - DOUBLE_EXPONENT_OFFSET</span>
            + EXTENDED_EXPONENT_OFFSET;
<span class="nc" id="L438">        long extendedMantissa = doubleMantissa</span>
            &lt;&lt; (EXTENDED_MANTISSA_LENGTH - DOUBLE_MANTISSA_LENGTH);
<span class="nc" id="L440">        long extendedSign = sign &lt;&lt; EXTENDED_EXPONENT_LENGTH;</span>
<span class="nc" id="L441">        short extendedBits79To64 = (short) (extendedSign | extendedExponent);</span>
<span class="nc" id="L442">        long extendedBits63To0 = EXTENDED_INTEGER_MASK | extendedMantissa;</span>

<span class="nc" id="L444">        dos.writeShort(extendedBits79To64);</span>
<span class="nc" id="L445">        dos.writeLong(extendedBits63To0);</span>
<span class="nc" id="L446">    }</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>