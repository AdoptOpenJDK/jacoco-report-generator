<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WaveFileWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">WaveFileWriter.java</span></div><h1>WaveFileWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

import java.io.BufferedOutputStream;
import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.RandomAccessFile;
import java.io.SequenceInputStream;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;

//$$fb this class is buggy. Should be replaced in future.

/**
 * WAVE file writer.
 *
 * @author Jan Borgersen
 */
public final class WaveFileWriter extends SunFileWriter {

    // magic numbers
    static  final int RIFF_MAGIC = 1380533830;
    static  final int WAVE_MAGIC = 1463899717;
    static  final int FMT_MAGIC  = 0x666d7420; // &quot;fmt &quot;
    static  final int DATA_MAGIC = 0x64617461; // &quot;data&quot;

    // encodings
    static final int WAVE_FORMAT_UNKNOWN   = 0x0000;
    static final int WAVE_FORMAT_PCM       = 0x0001;
    static final int WAVE_FORMAT_ADPCM     = 0x0002;
    static final int WAVE_FORMAT_ALAW      = 0x0006;
    static final int WAVE_FORMAT_MULAW     = 0x0007;
    static final int WAVE_FORMAT_OKI_ADPCM = 0x0010;
    static final int WAVE_FORMAT_DIGISTD   = 0x0015;
    static final int WAVE_FORMAT_DIGIFIX   = 0x0016;
    static final int WAVE_IBM_FORMAT_MULAW = 0x0101;
    static final int WAVE_IBM_FORMAT_ALAW  = 0x0102;
    static final int WAVE_IBM_FORMAT_ADPCM = 0x0103;
    static final int WAVE_FORMAT_DVI_ADPCM = 0x0011;
    static final int WAVE_FORMAT_SX7383    = 0x1C07;

    /**
     * Constructs a new WaveFileWriter object.
     */
    public WaveFileWriter() {
<span class="nc" id="L80">        super(new AudioFileFormat.Type[]{AudioFileFormat.Type.WAVE});</span>
<span class="nc" id="L81">    }</span>


    // METHODS TO IMPLEMENT AudioFileWriter


    public AudioFileFormat.Type[] getAudioFileTypes(AudioInputStream stream) {

<span class="nc" id="L89">        AudioFileFormat.Type[] filetypes = new AudioFileFormat.Type[types.length];</span>
<span class="nc" id="L90">        System.arraycopy(types, 0, filetypes, 0, types.length);</span>

        // make sure we can write this stream
<span class="nc" id="L93">        AudioFormat format = stream.getFormat();</span>
<span class="nc" id="L94">        AudioFormat.Encoding encoding = format.getEncoding();</span>

<span class="nc bnc" id="L96" title="All 2 branches missed.">        if( AudioFormat.Encoding.ALAW.equals(encoding) ||</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            AudioFormat.Encoding.ULAW.equals(encoding) ||</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">            AudioFormat.Encoding.PCM_SIGNED.equals(encoding) ||</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">            AudioFormat.Encoding.PCM_UNSIGNED.equals(encoding) ) {</span>

<span class="nc" id="L101">            return filetypes;</span>
        }

<span class="nc" id="L104">        return new AudioFileFormat.Type[0];</span>
    }


    public int write(AudioInputStream stream, AudioFileFormat.Type fileType, OutputStream out) throws IOException {

        //$$fb the following check must come first ! Otherwise
        // the next frame length check may throw an IOException and
        // interrupt iterating File Writers. (see bug 4351296)

        // throws IllegalArgumentException if not supported
<span class="nc" id="L115">        WaveFileFormat waveFileFormat = (WaveFileFormat)getAudioFileFormat(fileType, stream);</span>

        //$$fb when we got this far, we are committed to write this file

        // we must know the total data length to calculate the file length
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if( stream.getFrameLength() == AudioSystem.NOT_SPECIFIED ) {</span>
<span class="nc" id="L121">            throw new IOException(&quot;stream length not specified&quot;);</span>
        }

<span class="nc" id="L124">        int bytesWritten = writeWaveFile(stream, waveFileFormat, out);</span>
<span class="nc" id="L125">        return bytesWritten;</span>
    }


    public int write(AudioInputStream stream, AudioFileFormat.Type fileType, File out) throws IOException {

        // throws IllegalArgumentException if not supported
<span class="nc" id="L132">        WaveFileFormat waveFileFormat = (WaveFileFormat)getAudioFileFormat(fileType, stream);</span>

        // first write the file without worrying about length fields
<span class="nc" id="L135">        FileOutputStream fos = new FileOutputStream( out );     // throws IOException</span>
<span class="nc" id="L136">        BufferedOutputStream bos = new BufferedOutputStream( fos, bisBufferSize );</span>
<span class="nc" id="L137">        int bytesWritten = writeWaveFile(stream, waveFileFormat, bos );</span>
<span class="nc" id="L138">        bos.close();</span>

        // now, if length fields were not specified, calculate them,
        // open as a random access file, write the appropriate fields,
        // close again....
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if( waveFileFormat.getByteLength()== AudioSystem.NOT_SPECIFIED ) {</span>

<span class="nc" id="L145">            int dataLength=bytesWritten-waveFileFormat.getHeaderSize();</span>
<span class="nc" id="L146">            int riffLength=dataLength + waveFileFormat.getHeaderSize() - 8;</span>

<span class="nc" id="L148">            RandomAccessFile raf=new RandomAccessFile(out, &quot;rw&quot;);</span>
            // skip RIFF magic
<span class="nc" id="L150">            raf.skipBytes(4);</span>
<span class="nc" id="L151">            raf.writeInt(big2little( riffLength ));</span>
            // skip WAVE magic, fmt_ magic, fmt_ length, fmt_ chunk, data magic
<span class="nc" id="L153">            raf.skipBytes(4+4+4+WaveFileFormat.getFmtChunkSize(waveFileFormat.getWaveType())+4);</span>
<span class="nc" id="L154">            raf.writeInt(big2little( dataLength ));</span>
            // that's all
<span class="nc" id="L156">            raf.close();</span>
        }

<span class="nc" id="L159">        return bytesWritten;</span>
    }

    //--------------------------------------------------------------------

    /**
     * Returns the AudioFileFormat describing the file that will be written from this AudioInputStream.
     * Throws IllegalArgumentException if not supported.
     */
    private AudioFileFormat getAudioFileFormat(AudioFileFormat.Type type, AudioInputStream stream) {
<span class="nc" id="L169">        AudioFormat format = null;</span>
<span class="nc" id="L170">        WaveFileFormat fileFormat = null;</span>
<span class="nc" id="L171">        AudioFormat.Encoding encoding = AudioFormat.Encoding.PCM_SIGNED;</span>

<span class="nc" id="L173">        AudioFormat streamFormat = stream.getFormat();</span>
<span class="nc" id="L174">        AudioFormat.Encoding streamEncoding = streamFormat.getEncoding();</span>

        float sampleRate;
        int sampleSizeInBits;
        int channels;
        int frameSize;
        float frameRate;
        int fileSize;

<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (!types[0].equals(type)) {</span>
<span class="nc" id="L184">            throw new IllegalArgumentException(&quot;File type &quot; + type + &quot; not supported.&quot;);</span>
        }
<span class="nc" id="L186">        int waveType = WaveFileFormat.WAVE_FORMAT_PCM;</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">        if( AudioFormat.Encoding.ALAW.equals(streamEncoding) ||</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            AudioFormat.Encoding.ULAW.equals(streamEncoding) ) {</span>

<span class="nc" id="L191">            encoding = streamEncoding;</span>
<span class="nc" id="L192">            sampleSizeInBits = streamFormat.getSampleSizeInBits();</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">            if (streamEncoding.equals(AudioFormat.Encoding.ALAW)) {</span>
<span class="nc" id="L194">                waveType = WAVE_FORMAT_ALAW;</span>
            } else {
<span class="nc" id="L196">                waveType = WAVE_FORMAT_MULAW;</span>
            }
<span class="nc bnc" id="L198" title="All 2 branches missed.">        } else if ( streamFormat.getSampleSizeInBits()==8 ) {</span>
<span class="nc" id="L199">            encoding = AudioFormat.Encoding.PCM_UNSIGNED;</span>
<span class="nc" id="L200">            sampleSizeInBits=8;</span>
        } else {
<span class="nc" id="L202">            encoding = AudioFormat.Encoding.PCM_SIGNED;</span>
<span class="nc" id="L203">            sampleSizeInBits=streamFormat.getSampleSizeInBits();</span>
        }


<span class="nc" id="L207">        format = new AudioFormat( encoding,</span>
<span class="nc" id="L208">                                  streamFormat.getSampleRate(),</span>
                                  sampleSizeInBits,
<span class="nc" id="L210">                                  streamFormat.getChannels(),</span>
<span class="nc" id="L211">                                  streamFormat.getFrameSize(),</span>
<span class="nc" id="L212">                                  streamFormat.getFrameRate(),</span>
                                  false);       // WAVE is little endian

<span class="nc bnc" id="L215" title="All 2 branches missed.">        if( stream.getFrameLength()!=AudioSystem.NOT_SPECIFIED ) {</span>
<span class="nc" id="L216">            fileSize = (int)stream.getFrameLength()*streamFormat.getFrameSize()</span>
<span class="nc" id="L217">                + WaveFileFormat.getHeaderSize(waveType);</span>
        } else {
<span class="nc" id="L219">            fileSize = AudioSystem.NOT_SPECIFIED;</span>
        }

<span class="nc" id="L222">        fileFormat = new WaveFileFormat( AudioFileFormat.Type.WAVE,</span>
                                         fileSize,
                                         format,
<span class="nc" id="L225">                                         (int)stream.getFrameLength() );</span>

<span class="nc" id="L227">        return fileFormat;</span>
    }


    private int writeWaveFile(InputStream in, WaveFileFormat waveFileFormat, OutputStream out) throws IOException {

<span class="nc" id="L233">        int bytesRead = 0;</span>
<span class="nc" id="L234">        int bytesWritten = 0;</span>
<span class="nc" id="L235">        InputStream fileStream = getFileStream(waveFileFormat, in);</span>
<span class="nc" id="L236">        byte buffer[] = new byte[bisBufferSize];</span>
<span class="nc" id="L237">        int maxLength = waveFileFormat.getByteLength();</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">        while( (bytesRead = fileStream.read( buffer )) &gt;= 0 ) {</span>

<span class="nc bnc" id="L241" title="All 2 branches missed.">            if (maxLength&gt;0) {</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                if( bytesRead &lt; maxLength ) {</span>
<span class="nc" id="L243">                    out.write( buffer, 0, (int)bytesRead );</span>
<span class="nc" id="L244">                    bytesWritten += bytesRead;</span>
<span class="nc" id="L245">                    maxLength -= bytesRead;</span>
                } else {
<span class="nc" id="L247">                    out.write( buffer, 0, (int)maxLength );</span>
<span class="nc" id="L248">                    bytesWritten += maxLength;</span>
<span class="nc" id="L249">                    maxLength = 0;</span>
<span class="nc" id="L250">                    break;</span>
                }
            } else {
<span class="nc" id="L253">                out.write( buffer, 0, (int)bytesRead );</span>
<span class="nc" id="L254">                bytesWritten += bytesRead;</span>
            }
        }

<span class="nc" id="L258">        return bytesWritten;</span>
    }

    private InputStream getFileStream(WaveFileFormat waveFileFormat, InputStream audioStream) throws IOException {
        // private method ... assumes audioFileFormat is a supported file type

        // WAVE header fields
<span class="nc" id="L265">        AudioFormat audioFormat = waveFileFormat.getFormat();</span>
<span class="nc" id="L266">        int headerLength       = waveFileFormat.getHeaderSize();</span>
<span class="nc" id="L267">        int riffMagic          = WaveFileFormat.RIFF_MAGIC;</span>
<span class="nc" id="L268">        int waveMagic          = WaveFileFormat.WAVE_MAGIC;</span>
<span class="nc" id="L269">        int fmtMagic           = WaveFileFormat.FMT_MAGIC;</span>
<span class="nc" id="L270">        int fmtLength          = WaveFileFormat.getFmtChunkSize(waveFileFormat.getWaveType());</span>
<span class="nc" id="L271">        short wav_type         = (short) waveFileFormat.getWaveType();</span>
<span class="nc" id="L272">        short channels         = (short) audioFormat.getChannels();</span>
<span class="nc" id="L273">        short sampleSizeInBits = (short) audioFormat.getSampleSizeInBits();</span>
<span class="nc" id="L274">        int sampleRate         = (int) audioFormat.getSampleRate();</span>
<span class="nc" id="L275">        int frameSizeInBytes   = (int) audioFormat.getFrameSize();</span>
<span class="nc" id="L276">        int frameRate              = (int) audioFormat.getFrameRate();</span>
<span class="nc" id="L277">        int avgBytesPerSec     = channels * sampleSizeInBits * sampleRate / 8;;</span>
<span class="nc" id="L278">        short blockAlign       = (short) ((sampleSizeInBits / 8) * channels);</span>
<span class="nc" id="L279">        int dataMagic              = WaveFileFormat.DATA_MAGIC;</span>
<span class="nc" id="L280">        int dataLength             = waveFileFormat.getFrameLength() * frameSizeInBytes;</span>
<span class="nc" id="L281">        int length                         = waveFileFormat.getByteLength();</span>
<span class="nc" id="L282">        int riffLength = dataLength + headerLength - 8;</span>

<span class="nc" id="L284">        byte header[] = null;</span>
<span class="nc" id="L285">        ByteArrayInputStream headerStream = null;</span>
<span class="nc" id="L286">        ByteArrayOutputStream baos = null;</span>
<span class="nc" id="L287">        DataOutputStream dos = null;</span>
<span class="nc" id="L288">        SequenceInputStream waveStream = null;</span>

<span class="nc" id="L290">        AudioFormat audioStreamFormat = null;</span>
<span class="nc" id="L291">        AudioFormat.Encoding encoding = null;</span>
<span class="nc" id="L292">        InputStream codedAudioStream = audioStream;</span>

        // if audioStream is an AudioInputStream and we need to convert, do it here...
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if(audioStream instanceof AudioInputStream) {</span>
<span class="nc" id="L296">            audioStreamFormat = ((AudioInputStream)audioStream).getFormat();</span>

<span class="nc" id="L298">            encoding = audioStreamFormat.getEncoding();</span>

<span class="nc bnc" id="L300" title="All 2 branches missed.">            if(AudioFormat.Encoding.PCM_SIGNED.equals(encoding)) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                if( sampleSizeInBits==8 ) {</span>
<span class="nc" id="L302">                    wav_type = WaveFileFormat.WAVE_FORMAT_PCM;</span>
                    // plug in the transcoder to convert from PCM_SIGNED to PCM_UNSIGNED
<span class="nc" id="L304">                    codedAudioStream = AudioSystem.getAudioInputStream( new AudioFormat(</span>
                                                                                        AudioFormat.Encoding.PCM_UNSIGNED,
<span class="nc" id="L306">                                                                                        audioStreamFormat.getSampleRate(),</span>
<span class="nc" id="L307">                                                                                        audioStreamFormat.getSampleSizeInBits(),</span>
<span class="nc" id="L308">                                                                                        audioStreamFormat.getChannels(),</span>
<span class="nc" id="L309">                                                                                        audioStreamFormat.getFrameSize(),</span>
<span class="nc" id="L310">                                                                                        audioStreamFormat.getFrameRate(),</span>
                                                                                        false),
                                                                        (AudioInputStream)audioStream);
                }
            }
<span class="nc bnc" id="L315" title="All 4 branches missed.">            if( (AudioFormat.Encoding.PCM_SIGNED.equals(encoding) &amp;&amp; audioStreamFormat.isBigEndian()) ||</span>
<span class="nc bnc" id="L316" title="All 4 branches missed.">                (AudioFormat.Encoding.PCM_UNSIGNED.equals(encoding) &amp;&amp; !audioStreamFormat.isBigEndian()) ||</span>
<span class="nc bnc" id="L317" title="All 4 branches missed.">                (AudioFormat.Encoding.PCM_UNSIGNED.equals(encoding) &amp;&amp; audioStreamFormat.isBigEndian()) ) {</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                if( sampleSizeInBits!=8) {</span>
<span class="nc" id="L319">                    wav_type = WaveFileFormat.WAVE_FORMAT_PCM;</span>
                    // plug in the transcoder to convert to PCM_SIGNED_LITTLE_ENDIAN
<span class="nc" id="L321">                    codedAudioStream = AudioSystem.getAudioInputStream( new AudioFormat(</span>
                                                                                        AudioFormat.Encoding.PCM_SIGNED,
<span class="nc" id="L323">                                                                                        audioStreamFormat.getSampleRate(),</span>
<span class="nc" id="L324">                                                                                        audioStreamFormat.getSampleSizeInBits(),</span>
<span class="nc" id="L325">                                                                                        audioStreamFormat.getChannels(),</span>
<span class="nc" id="L326">                                                                                        audioStreamFormat.getFrameSize(),</span>
<span class="nc" id="L327">                                                                                        audioStreamFormat.getFrameRate(),</span>
                                                                                        false),
                                                                        (AudioInputStream)audioStream);
                }
            }
        }


        // Now push the header into a stream, concat, and return the new SequenceInputStream

<span class="nc" id="L337">        baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L338">        dos = new DataOutputStream(baos);</span>

        // we write in littleendian...
<span class="nc" id="L341">        dos.writeInt(riffMagic);</span>
<span class="nc" id="L342">        dos.writeInt(big2little( riffLength ));</span>
<span class="nc" id="L343">        dos.writeInt(waveMagic);</span>
<span class="nc" id="L344">        dos.writeInt(fmtMagic);</span>
<span class="nc" id="L345">        dos.writeInt(big2little(fmtLength));</span>
<span class="nc" id="L346">        dos.writeShort(big2littleShort(wav_type));</span>
<span class="nc" id="L347">        dos.writeShort(big2littleShort(channels));</span>
<span class="nc" id="L348">        dos.writeInt(big2little(sampleRate));</span>
<span class="nc" id="L349">        dos.writeInt(big2little(avgBytesPerSec));</span>
<span class="nc" id="L350">        dos.writeShort(big2littleShort(blockAlign));</span>
<span class="nc" id="L351">        dos.writeShort(big2littleShort(sampleSizeInBits));</span>
        //$$fb 2002-04-16: Fix for 4636355: RIFF audio headers could be _more_ spec compliant
<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (wav_type != WaveFileFormat.WAVE_FORMAT_PCM) {</span>
            // add length 0 for &quot;codec specific data length&quot;
<span class="nc" id="L355">            dos.writeShort(0);</span>
        }

<span class="nc" id="L358">        dos.writeInt(dataMagic);</span>
<span class="nc" id="L359">        dos.writeInt(big2little(dataLength));</span>

<span class="nc" id="L361">        dos.close();</span>
<span class="nc" id="L362">        header = baos.toByteArray();</span>
<span class="nc" id="L363">        headerStream = new ByteArrayInputStream( header );</span>
<span class="nc" id="L364">        waveStream = new SequenceInputStream(headerStream,</span>
                            new NoCloseInputStream(codedAudioStream));

<span class="nc" id="L367">        return (InputStream)waveStream;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>