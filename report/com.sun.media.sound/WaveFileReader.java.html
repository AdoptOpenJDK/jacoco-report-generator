<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WaveFileReader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">WaveFileReader.java</span></div><h1>WaveFileReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import java.io.DataInputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.UnsupportedAudioFileException;



/**
 * WAVE file reader.
 *
 * @author Kara Kytle
 * @author Jan Borgersen
 * @author Florian Bomers
 */
<span class="nc" id="L51">public final class WaveFileReader extends SunFileReader {</span>

    private static final int MAX_READ_LENGTH = 12;

    /**
     * Obtains the audio file format of the input stream provided.  The stream must
     * point to valid audio file data.  In general, audio file providers may
     * need to read some data from the stream before determining whether they
     * support it.  These parsers must
     * be able to mark the stream, read enough data to determine whether they
     * support the stream, and, if not, reset the stream's read pointer to its original
     * position.  If the input stream does not support this, this method may fail
     * with an IOException.
     * @param stream the input stream from which file format information should be
     * extracted
     * @return an &lt;code&gt;AudioFileFormat&lt;/code&gt; object describing the audio file format
     * @throws UnsupportedAudioFileException if the stream does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     * @see InputStream#markSupported
     * @see InputStream#mark
     */
    public AudioFileFormat getAudioFileFormat(InputStream stream) throws UnsupportedAudioFileException, IOException {
        // fix for 4489272: AudioSystem.getAudioFileFormat() fails for InputStream, but works for URL
<span class="nc" id="L75">        AudioFileFormat aff = getFMT(stream, true);</span>
        // the following is not strictly necessary - but was implemented like that in 1.3.0 - 1.4.1
        // so I leave it as it was. May remove this for 1.5.0
<span class="nc" id="L78">        stream.reset();</span>
<span class="nc" id="L79">        return aff;</span>
    }


    /**
     * Obtains the audio file format of the URL provided.  The URL must
     * point to valid audio file data.
     * @param url the URL from which file format information should be
     * extracted
     * @return an &lt;code&gt;AudioFileFormat&lt;/code&gt; object describing the audio file format
     * @throws UnsupportedAudioFileException if the URL does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     */
    public AudioFileFormat getAudioFileFormat(URL url) throws UnsupportedAudioFileException, IOException {
<span class="nc" id="L94">        InputStream urlStream = url.openStream(); // throws IOException</span>
<span class="nc" id="L95">        AudioFileFormat fileFormat = null;</span>
        try {
<span class="nc" id="L97">            fileFormat = getFMT(urlStream, false);</span>
        } finally {
<span class="nc" id="L99">            urlStream.close();</span>
<span class="nc" id="L100">        }</span>
<span class="nc" id="L101">        return fileFormat;</span>
    }


    /**
     * Obtains the audio file format of the File provided.  The File must
     * point to valid audio file data.
     * @param file the File from which file format information should be
     * extracted
     * @return an &lt;code&gt;AudioFileFormat&lt;/code&gt; object describing the audio file format
     * @throws UnsupportedAudioFileException if the File does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     */
    public AudioFileFormat getAudioFileFormat(File file) throws UnsupportedAudioFileException, IOException {
<span class="nc" id="L116">        AudioFileFormat fileFormat = null;</span>
<span class="nc" id="L117">        FileInputStream fis = new FileInputStream(file);       // throws IOException</span>
        // part of fix for 4325421
        try {
<span class="nc" id="L120">            fileFormat = getFMT(fis, false);</span>
        } finally {
<span class="nc" id="L122">            fis.close();</span>
<span class="nc" id="L123">        }</span>

<span class="nc" id="L125">        return fileFormat;</span>
    }


    /**
     * Obtains an audio stream from the input stream provided.  The stream must
     * point to valid audio file data.  In general, audio file providers may
     * need to read some data from the stream before determining whether they
     * support it.  These parsers must
     * be able to mark the stream, read enough data to determine whether they
     * support the stream, and, if not, reset the stream's read pointer to its original
     * position.  If the input stream does not support this, this method may fail
     * with an IOException.
     * @param stream the input stream from which the &lt;code&gt;AudioInputStream&lt;/code&gt; should be
     * constructed
     * @return an &lt;code&gt;AudioInputStream&lt;/code&gt; object based on the audio file data contained
     * in the input stream.
     * @throws UnsupportedAudioFileException if the stream does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     * @see InputStream#markSupported
     * @see InputStream#mark
     */
    public AudioInputStream getAudioInputStream(InputStream stream) throws UnsupportedAudioFileException, IOException {
        // getFMT leaves the input stream at the beginning of the audio data
<span class="nc" id="L150">        AudioFileFormat fileFormat = getFMT(stream, true); // throws UnsupportedAudioFileException, IOException</span>

        // we've got everything, and the stream is at the
        // beginning of the audio data, so return an AudioInputStream.
<span class="nc" id="L154">        return new AudioInputStream(stream, fileFormat.getFormat(), fileFormat.getFrameLength());</span>
    }


    /**
     * Obtains an audio stream from the URL provided.  The URL must
     * point to valid audio file data.
     * @param url the URL for which the &lt;code&gt;AudioInputStream&lt;/code&gt; should be
     * constructed
     * @return an &lt;code&gt;AudioInputStream&lt;/code&gt; object based on the audio file data pointed
     * to by the URL
     * @throws UnsupportedAudioFileException if the URL does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     */
    public AudioInputStream getAudioInputStream(URL url) throws UnsupportedAudioFileException, IOException {
<span class="nc" id="L170">        InputStream urlStream = url.openStream();  // throws IOException</span>
<span class="nc" id="L171">        AudioFileFormat fileFormat = null;</span>
        try {
<span class="nc" id="L173">            fileFormat = getFMT(urlStream, false);</span>
        } finally {
<span class="nc bnc" id="L175" title="All 4 branches missed.">            if (fileFormat == null) {</span>
<span class="nc" id="L176">                urlStream.close();</span>
            }
        }
<span class="nc" id="L179">        return new AudioInputStream(urlStream, fileFormat.getFormat(), fileFormat.getFrameLength());</span>
    }


    /**
     * Obtains an audio stream from the File provided.  The File must
     * point to valid audio file data.
     * @param file the File for which the &lt;code&gt;AudioInputStream&lt;/code&gt; should be
     * constructed
     * @return an &lt;code&gt;AudioInputStream&lt;/code&gt; object based on the audio file data pointed
     * to by the File
     * @throws UnsupportedAudioFileException if the File does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     */
    public AudioInputStream getAudioInputStream(File file) throws UnsupportedAudioFileException, IOException {
<span class="nc" id="L195">        FileInputStream fis = new FileInputStream(file); // throws IOException</span>
<span class="nc" id="L196">        AudioFileFormat fileFormat = null;</span>
        // part of fix for 4325421
        try {
<span class="nc" id="L199">            fileFormat = getFMT(fis, false);</span>
        } finally {
<span class="nc bnc" id="L201" title="All 4 branches missed.">            if (fileFormat == null) {</span>
<span class="nc" id="L202">                fis.close();</span>
            }
        }
<span class="nc" id="L205">        return new AudioInputStream(fis, fileFormat.getFormat(), fileFormat.getFrameLength());</span>
    }


    //--------------------------------------------------------------------


    private AudioFileFormat getFMT(InputStream stream, boolean doReset) throws UnsupportedAudioFileException, IOException {

        // assumes sream is rewound

        int bytesRead;
<span class="nc" id="L217">        int nread = 0;</span>
        int fmt;
<span class="nc" id="L219">        int length = 0;</span>
<span class="nc" id="L220">        int wav_type = 0;</span>
        short channels;
        long sampleRate;
        long avgBytesPerSec;
        short blockAlign;
        int sampleSizeInBits;
<span class="nc" id="L226">        AudioFormat.Encoding encoding = null;</span>

<span class="nc" id="L228">        DataInputStream dis = new DataInputStream( stream );</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (doReset) {</span>
<span class="nc" id="L231">            dis.mark(MAX_READ_LENGTH);</span>
        }

<span class="nc" id="L234">        int magic = dis.readInt();</span>
<span class="nc" id="L235">        int fileLength = rllong(dis);</span>
<span class="nc" id="L236">        int waveMagic = dis.readInt();</span>
        int totallength;
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (fileLength &lt;= 0) {</span>
<span class="nc" id="L239">            fileLength = AudioSystem.NOT_SPECIFIED;</span>
<span class="nc" id="L240">            totallength = AudioSystem.NOT_SPECIFIED;</span>
        } else {
<span class="nc" id="L242">            totallength = fileLength + 8;</span>
        }

<span class="nc bnc" id="L245" title="All 4 branches missed.">        if ((magic != WaveFileFormat.RIFF_MAGIC) || (waveMagic != WaveFileFormat.WAVE_MAGIC)) {</span>
            // not WAVE, throw UnsupportedAudioFileException
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (doReset) {</span>
<span class="nc" id="L248">                dis.reset();</span>
            }
<span class="nc" id="L250">            throw new UnsupportedAudioFileException(&quot;not a WAVE file&quot;);</span>
        }

        // find and read the &quot;fmt&quot; chunk
        // we break out of this loop either by hitting EOF or finding &quot;fmt &quot;
        while(true) {

            try {
<span class="nc" id="L258">                fmt = dis.readInt();</span>
<span class="nc" id="L259">                nread += 4;</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                if( fmt==WaveFileFormat.FMT_MAGIC ) {</span>
                    // we've found the 'fmt' chunk
<span class="nc" id="L262">                    break;</span>
                } else {
                    // else not 'fmt', skip this chunk
<span class="nc" id="L265">                    length = rllong(dis);</span>
<span class="nc" id="L266">                    nread += 4;</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">                    if (length % 2 &gt; 0) length++;</span>
<span class="nc" id="L268">                    nread += dis.skipBytes(length);</span>
                }
<span class="nc" id="L270">            } catch (EOFException eof) {</span>
                                // we've reached the end of the file without finding the 'fmt' chunk
<span class="nc" id="L272">                throw new UnsupportedAudioFileException(&quot;Not a valid WAV file&quot;);</span>
<span class="nc" id="L273">            }</span>
        }

        // Read the format chunk size.
<span class="nc" id="L277">        length = rllong(dis);</span>
<span class="nc" id="L278">        nread += 4;</span>

        // This is the nread position at the end of the format chunk
<span class="nc" id="L281">        int endLength = nread + length;</span>

        // Read the wave format data out of the format chunk.

        // encoding.
<span class="nc" id="L286">        wav_type = rlshort(dis); nread += 2;</span>

<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (wav_type == WaveFileFormat.WAVE_FORMAT_PCM)</span>
<span class="nc" id="L289">            encoding = AudioFormat.Encoding.PCM_SIGNED;  // if 8-bit, we need PCM_UNSIGNED, below...</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">        else if ( wav_type == WaveFileFormat.WAVE_FORMAT_ALAW )</span>
<span class="nc" id="L291">            encoding = AudioFormat.Encoding.ALAW;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        else if ( wav_type == WaveFileFormat.WAVE_FORMAT_MULAW )</span>
<span class="nc" id="L293">            encoding = AudioFormat.Encoding.ULAW;</span>
        else {
            // we don't support any other WAVE formats....
<span class="nc" id="L296">            throw new UnsupportedAudioFileException(&quot;Not a supported WAV file&quot;);</span>
        }
        // channels
<span class="nc" id="L299">        channels = rlshort(dis); nread += 2;</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (channels &lt;= 0) {</span>
<span class="nc" id="L301">            throw new UnsupportedAudioFileException(&quot;Invalid number of channels&quot;);</span>
        }

        // sample rate.
<span class="nc" id="L305">        sampleRate = rllong(dis); nread += 4;</span>

        // this is the avgBytesPerSec
<span class="nc" id="L308">        avgBytesPerSec = rllong(dis); nread += 4;</span>

        // this is blockAlign value
<span class="nc" id="L311">        blockAlign = rlshort(dis); nread += 2;</span>

        // this is the PCM-specific value bitsPerSample
<span class="nc" id="L314">        sampleSizeInBits = (int)rlshort(dis); nread += 2;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">        if (sampleSizeInBits &lt;= 0) {</span>
<span class="nc" id="L316">            throw new UnsupportedAudioFileException(&quot;Invalid bitsPerSample&quot;);</span>
        }

        // if sampleSizeInBits==8, we need to use PCM_UNSIGNED
<span class="nc bnc" id="L320" title="All 4 branches missed.">        if ((sampleSizeInBits==8) &amp;&amp; encoding.equals(AudioFormat.Encoding.PCM_SIGNED))</span>
<span class="nc" id="L321">            encoding = AudioFormat.Encoding.PCM_UNSIGNED;</span>

        // skip any difference between the length of the format chunk
        // and what we read

        // if the length of the chunk is odd, there's an extra pad byte
        // at the end.  i've never seen this in the fmt chunk, but we
        // should check to make sure.

<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (length % 2 != 0) length += 1;</span>

        // $$jb: 07.28.99: endLength&gt;nread, not length&gt;nread.
        //       This fixes #4257986
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (endLength &gt; nread)</span>
<span class="nc" id="L335">            nread += dis.skipBytes(endLength - nread);</span>

        // we have a format now, so find the &quot;data&quot; chunk
        // we break out of this loop either by hitting EOF or finding &quot;data&quot;
        // $$kk: if &quot;data&quot; chunk precedes &quot;fmt&quot; chunk we are hosed -- can this legally happen?
<span class="nc" id="L340">        nread = 0;</span>
        while(true) {
            try{
<span class="nc" id="L343">                int datahdr = dis.readInt();</span>
<span class="nc" id="L344">                nread+=4;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                if (datahdr == WaveFileFormat.DATA_MAGIC) {</span>
                    // we've found the 'data' chunk
<span class="nc" id="L347">                    break;</span>
                } else {
                    // else not 'data', skip this chunk
<span class="nc" id="L350">                    int thisLength = rllong(dis); nread += 4;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    if (thisLength % 2 &gt; 0) thisLength++;</span>
<span class="nc" id="L352">                    nread += dis.skipBytes(thisLength);</span>
                }
<span class="nc" id="L354">            } catch (EOFException eof) {</span>
                // we've reached the end of the file without finding the 'data' chunk
<span class="nc" id="L356">                throw new UnsupportedAudioFileException(&quot;Not a valid WAV file&quot;);</span>
<span class="nc" id="L357">            }</span>
        }
        // this is the length of the data chunk
<span class="nc" id="L360">        int dataLength = rllong(dis); nread += 4;</span>

        // now build the new AudioFileFormat and return

<span class="nc" id="L364">        AudioFormat format = new AudioFormat(encoding,</span>
                                             (float)sampleRate,
                                             sampleSizeInBits, channels,
<span class="nc" id="L367">                                             calculatePCMFrameSize(sampleSizeInBits, channels),</span>
                                             (float)sampleRate, false);

<span class="nc" id="L370">        return new WaveFileFormat(AudioFileFormat.Type.WAVE,</span>
                                  totallength,
                                  format,
<span class="nc" id="L373">                                  dataLength / format.getFrameSize());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>