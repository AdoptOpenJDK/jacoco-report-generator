<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AuFileWriter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">AuFileWriter.java</span></div><h1>AuFileWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

import java.io.BufferedOutputStream;
import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.RandomAccessFile;
import java.io.SequenceInputStream;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;


/**
 * AU file writer.
 *
 * @author Jan Borgersen
 */
public final class AuFileWriter extends SunFileWriter {

    //$$fb value for length field if length is not known
    public final static int UNKNOWN_SIZE=-1;

    /**
     * Constructs a new AuFileWriter object.
     */
    public AuFileWriter() {
<span class="nc" id="L61">        super(new AudioFileFormat.Type[]{AudioFileFormat.Type.AU});</span>
<span class="nc" id="L62">    }</span>

    public AudioFileFormat.Type[] getAudioFileTypes(AudioInputStream stream) {

<span class="nc" id="L66">        AudioFileFormat.Type[] filetypes = new AudioFileFormat.Type[types.length];</span>
<span class="nc" id="L67">        System.arraycopy(types, 0, filetypes, 0, types.length);</span>

        // make sure we can write this stream
<span class="nc" id="L70">        AudioFormat format = stream.getFormat();</span>
<span class="nc" id="L71">        AudioFormat.Encoding encoding = format.getEncoding();</span>

<span class="nc bnc" id="L73" title="All 2 branches missed.">        if( (AudioFormat.Encoding.ALAW.equals(encoding)) ||</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">            (AudioFormat.Encoding.ULAW.equals(encoding)) ||</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">            (AudioFormat.Encoding.PCM_SIGNED.equals(encoding)) ||</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">            (AudioFormat.Encoding.PCM_UNSIGNED.equals(encoding)) ) {</span>

<span class="nc" id="L78">            return filetypes;</span>
        }

<span class="nc" id="L81">        return new AudioFileFormat.Type[0];</span>
    }


    public int write(AudioInputStream stream, AudioFileFormat.Type fileType, OutputStream out) throws IOException {

        // we must know the total data length to calculate the file length
        //$$fb 2001-07-13: fix for bug 4351296: do not throw an exception
        //if( stream.getFrameLength() == AudioSystem.NOT_SPECIFIED ) {
        //      throw new IOException(&quot;stream length not specified&quot;);
        //}

        // throws IllegalArgumentException if not supported
<span class="nc" id="L94">        AuFileFormat auFileFormat = (AuFileFormat)getAudioFileFormat(fileType, stream);</span>

<span class="nc" id="L96">        int bytesWritten = writeAuFile(stream, auFileFormat, out);</span>
<span class="nc" id="L97">        return bytesWritten;</span>
    }



    public int write(AudioInputStream stream, AudioFileFormat.Type fileType, File out) throws IOException {

        // throws IllegalArgumentException if not supported
<span class="nc" id="L105">        AuFileFormat auFileFormat = (AuFileFormat)getAudioFileFormat(fileType, stream);</span>

        // first write the file without worrying about length fields
<span class="nc" id="L108">        FileOutputStream fos = new FileOutputStream( out );     // throws IOException</span>
<span class="nc" id="L109">        BufferedOutputStream bos = new BufferedOutputStream( fos, bisBufferSize );</span>
<span class="nc" id="L110">        int bytesWritten = writeAuFile(stream, auFileFormat, bos );</span>
<span class="nc" id="L111">        bos.close();</span>

        // now, if length fields were not specified, calculate them,
        // open as a random access file, write the appropriate fields,
        // close again....
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if( auFileFormat.getByteLength()== AudioSystem.NOT_SPECIFIED ) {</span>

            // $$kk: 10.22.99: jan: please either implement this or throw an exception!
            // $$fb: 2001-07-13: done. Fixes Bug 4479981
<span class="nc" id="L120">            RandomAccessFile raf=new RandomAccessFile(out, &quot;rw&quot;);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">            if (raf.length()&lt;=0x7FFFFFFFl) {</span>
                // skip AU magic and data offset field
<span class="nc" id="L123">                raf.skipBytes(8);</span>
<span class="nc" id="L124">                raf.writeInt(bytesWritten-AuFileFormat.AU_HEADERSIZE);</span>
                // that's all
            }
<span class="nc" id="L127">            raf.close();</span>
        }

<span class="nc" id="L130">        return bytesWritten;</span>
    }


    // -------------------------------------------------------------

    /**
     * Returns the AudioFileFormat describing the file that will be written from this AudioInputStream.
     * Throws IllegalArgumentException if not supported.
     */
    private AudioFileFormat getAudioFileFormat(AudioFileFormat.Type type, AudioInputStream stream) {

<span class="nc" id="L142">        AudioFormat format = null;</span>
<span class="nc" id="L143">        AuFileFormat fileFormat = null;</span>
<span class="nc" id="L144">        AudioFormat.Encoding encoding = AudioFormat.Encoding.PCM_SIGNED;</span>

<span class="nc" id="L146">        AudioFormat streamFormat = stream.getFormat();</span>
<span class="nc" id="L147">        AudioFormat.Encoding streamEncoding = streamFormat.getEncoding();</span>


        float sampleRate;
        int sampleSizeInBits;
        int channels;
        int frameSize;
        float frameRate;
        int fileSize;

<span class="nc bnc" id="L157" title="All 2 branches missed.">        if( !types[0].equals(type) ) {</span>
<span class="nc" id="L158">            throw new IllegalArgumentException(&quot;File type &quot; + type + &quot; not supported.&quot;);</span>
        }

<span class="nc bnc" id="L161" title="All 2 branches missed.">        if( (AudioFormat.Encoding.ALAW.equals(streamEncoding)) ||</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            (AudioFormat.Encoding.ULAW.equals(streamEncoding)) ) {</span>

<span class="nc" id="L164">            encoding = streamEncoding;</span>
<span class="nc" id="L165">            sampleSizeInBits = streamFormat.getSampleSizeInBits();</span>

<span class="nc bnc" id="L167" title="All 2 branches missed.">        } else if ( streamFormat.getSampleSizeInBits()==8 ) {</span>

<span class="nc" id="L169">            encoding = AudioFormat.Encoding.PCM_SIGNED;</span>
<span class="nc" id="L170">            sampleSizeInBits=8;</span>

        } else {

<span class="nc" id="L174">            encoding = AudioFormat.Encoding.PCM_SIGNED;</span>
<span class="nc" id="L175">            sampleSizeInBits=streamFormat.getSampleSizeInBits();</span>
        }


<span class="nc" id="L179">        format = new AudioFormat( encoding,</span>
<span class="nc" id="L180">                                  streamFormat.getSampleRate(),</span>
                                  sampleSizeInBits,
<span class="nc" id="L182">                                  streamFormat.getChannels(),</span>
<span class="nc" id="L183">                                  streamFormat.getFrameSize(),</span>
<span class="nc" id="L184">                                  streamFormat.getFrameRate(),</span>
                                  true);        // AU is always big endian


<span class="nc bnc" id="L188" title="All 2 branches missed.">        if( stream.getFrameLength()!=AudioSystem.NOT_SPECIFIED ) {</span>
<span class="nc" id="L189">            fileSize = (int)stream.getFrameLength()*streamFormat.getFrameSize() + AuFileFormat.AU_HEADERSIZE;</span>
        } else {
<span class="nc" id="L191">            fileSize = AudioSystem.NOT_SPECIFIED;</span>
        }

<span class="nc" id="L194">        fileFormat = new AuFileFormat( AudioFileFormat.Type.AU,</span>
                                       fileSize,
                                       format,
<span class="nc" id="L197">                                       (int)stream.getFrameLength() );</span>

<span class="nc" id="L199">        return fileFormat;</span>
    }


    private InputStream getFileStream(AuFileFormat auFileFormat, InputStream audioStream) throws IOException {

        // private method ... assumes auFileFormat is a supported file type

<span class="nc" id="L207">        AudioFormat format            = auFileFormat.getFormat();</span>

<span class="nc" id="L209">        int magic          = AuFileFormat.AU_SUN_MAGIC;</span>
<span class="nc" id="L210">        int headerSize     = AuFileFormat.AU_HEADERSIZE;</span>
<span class="nc" id="L211">        long dataSize       = auFileFormat.getFrameLength();</span>
        //$$fb fix for Bug 4351296
        //int dataSizeInBytes = dataSize * format.getFrameSize();
<span class="nc bnc" id="L214" title="All 2 branches missed.">        long dataSizeInBytes = (dataSize==AudioSystem.NOT_SPECIFIED)?UNKNOWN_SIZE:dataSize * format.getFrameSize();</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (dataSizeInBytes&gt;0x7FFFFFFFl) {</span>
<span class="nc" id="L216">            dataSizeInBytes=UNKNOWN_SIZE;</span>
        }
<span class="nc" id="L218">        int encoding_local = auFileFormat.getAuType();</span>
<span class="nc" id="L219">        int sampleRate     = (int)format.getSampleRate();</span>
<span class="nc" id="L220">        int channels       = format.getChannels();</span>
        //$$fb below is the fix for 4297100.
        //boolean bigendian      = format.isBigEndian();
<span class="nc" id="L223">        boolean bigendian      = true;                  // force bigendian</span>

<span class="nc" id="L225">        byte header[] = null;</span>
<span class="nc" id="L226">        ByteArrayInputStream headerStream = null;</span>
<span class="nc" id="L227">        ByteArrayOutputStream baos = null;</span>
<span class="nc" id="L228">        DataOutputStream dos = null;</span>
<span class="nc" id="L229">        SequenceInputStream auStream = null;</span>

<span class="nc" id="L231">        AudioFormat audioStreamFormat = null;</span>
<span class="nc" id="L232">        AudioFormat.Encoding encoding = null;</span>
<span class="nc" id="L233">        InputStream codedAudioStream = audioStream;</span>

        // if we need to do any format conversion, do it here.

<span class="nc" id="L237">        codedAudioStream = audioStream;</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">        if( audioStream instanceof AudioInputStream ) {</span>


<span class="nc" id="L242">            audioStreamFormat = ((AudioInputStream)audioStream).getFormat();</span>
<span class="nc" id="L243">            encoding = audioStreamFormat.getEncoding();</span>

            //$$ fb 2001-07-13: Bug 4391108
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if( (AudioFormat.Encoding.PCM_UNSIGNED.equals(encoding)) ||</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">                (AudioFormat.Encoding.PCM_SIGNED.equals(encoding)</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">                 &amp;&amp; bigendian != audioStreamFormat.isBigEndian()) ) {</span>

                                // plug in the transcoder to convert to PCM_SIGNED, bigendian
                                // NOTE: little endian AU is not common, so we're always converting
                                //       to big endian unless the passed in audioFileFormat is little.
                                // $$fb this NOTE is superseded. We always write big endian au files, this is by far the standard.
<span class="nc" id="L254">                codedAudioStream = AudioSystem.getAudioInputStream( new AudioFormat (</span>
                                                                                     AudioFormat.Encoding.PCM_SIGNED,
<span class="nc" id="L256">                                                                                     audioStreamFormat.getSampleRate(),</span>
<span class="nc" id="L257">                                                                                     audioStreamFormat.getSampleSizeInBits(),</span>
<span class="nc" id="L258">                                                                                     audioStreamFormat.getChannels(),</span>
<span class="nc" id="L259">                                                                                     audioStreamFormat.getFrameSize(),</span>
<span class="nc" id="L260">                                                                                     audioStreamFormat.getFrameRate(),</span>
                                                                                     bigendian),
                                                                    (AudioInputStream)audioStream );


            }
        }

<span class="nc" id="L268">        baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L269">        dos = new DataOutputStream(baos);</span>


<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (bigendian) {</span>
<span class="nc" id="L273">            dos.writeInt(AuFileFormat.AU_SUN_MAGIC);</span>
<span class="nc" id="L274">            dos.writeInt(headerSize);</span>
<span class="nc" id="L275">            dos.writeInt((int)dataSizeInBytes);</span>
<span class="nc" id="L276">            dos.writeInt(encoding_local);</span>
<span class="nc" id="L277">            dos.writeInt(sampleRate);</span>
<span class="nc" id="L278">            dos.writeInt(channels);</span>
        } else {
<span class="nc" id="L280">            dos.writeInt(AuFileFormat.AU_SUN_INV_MAGIC);</span>
<span class="nc" id="L281">            dos.writeInt(big2little(headerSize));</span>
<span class="nc" id="L282">            dos.writeInt(big2little((int)dataSizeInBytes));</span>
<span class="nc" id="L283">            dos.writeInt(big2little(encoding_local));</span>
<span class="nc" id="L284">            dos.writeInt(big2little(sampleRate));</span>
<span class="nc" id="L285">            dos.writeInt(big2little(channels));</span>
        }

        // Now create a new InputStream from headerStream and the InputStream
        // in audioStream

<span class="nc" id="L291">        dos.close();</span>
<span class="nc" id="L292">        header = baos.toByteArray();</span>
<span class="nc" id="L293">        headerStream = new ByteArrayInputStream( header );</span>
<span class="nc" id="L294">        auStream = new SequenceInputStream(headerStream,</span>
                        new NoCloseInputStream(codedAudioStream));

<span class="nc" id="L297">        return auStream;</span>
    }

    private int writeAuFile(InputStream in, AuFileFormat auFileFormat, OutputStream out) throws IOException {

<span class="nc" id="L302">        int bytesRead = 0;</span>
<span class="nc" id="L303">        int bytesWritten = 0;</span>
<span class="nc" id="L304">        InputStream fileStream = getFileStream(auFileFormat, in);</span>
<span class="nc" id="L305">        byte buffer[] = new byte[bisBufferSize];</span>
<span class="nc" id="L306">        int maxLength = auFileFormat.getByteLength();</span>

<span class="nc bnc" id="L308" title="All 2 branches missed.">        while( (bytesRead = fileStream.read( buffer )) &gt;= 0 ) {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (maxLength&gt;0) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                if( bytesRead &lt; maxLength ) {</span>
<span class="nc" id="L311">                    out.write( buffer, 0, (int)bytesRead );</span>
<span class="nc" id="L312">                    bytesWritten += bytesRead;</span>
<span class="nc" id="L313">                    maxLength -= bytesRead;</span>
                } else {
<span class="nc" id="L315">                    out.write( buffer, 0, (int)maxLength );</span>
<span class="nc" id="L316">                    bytesWritten += maxLength;</span>
<span class="nc" id="L317">                    maxLength = 0;</span>
<span class="nc" id="L318">                    break;</span>
                }
            } else {
<span class="nc" id="L321">                out.write( buffer, 0, (int)bytesRead );</span>
<span class="nc" id="L322">                bytesWritten += bytesRead;</span>
            }
        }

<span class="nc" id="L326">        return bytesWritten;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>