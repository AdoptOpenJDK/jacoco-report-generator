<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>EventDispatcher.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">EventDispatcher.java</span></div><h1>EventDispatcher.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import java.util.ArrayList;
import java.util.List;

import javax.sound.midi.ControllerEventListener;
import javax.sound.midi.MetaEventListener;
import javax.sound.midi.MetaMessage;
import javax.sound.midi.ShortMessage;
import javax.sound.sampled.LineEvent;
import javax.sound.sampled.LineListener;



/**
 * EventDispatcher.  Used by various classes in the Java Sound implementation
 * to send events.
 *
 * @author David Rivas
 * @author Kara Kytle
 * @author Florian Bomers
 */
<span class="nc" id="L48">final class EventDispatcher implements Runnable {</span>

    /**
     * time of inactivity until the auto closing clips
     * are closed
     */
    private static final int AUTO_CLOSE_TIME = 5000;


    /**
     * List of events
     */
<span class="nc" id="L60">    private final ArrayList eventQueue = new ArrayList();</span>


    /**
     * Thread object for this EventDispatcher instance
     */
<span class="nc" id="L66">    private Thread thread = null;</span>


    /*
     * support for auto-closing Clips
     */
<span class="nc" id="L72">    private final ArrayList&lt;ClipInfo&gt; autoClosingClips = new ArrayList&lt;ClipInfo&gt;();</span>

    /*
     * support for monitoring data lines
     */
<span class="nc" id="L77">    private final ArrayList&lt;LineMonitor&gt; lineMonitors = new ArrayList&lt;LineMonitor&gt;();</span>

    /**
     * Approximate interval between calls to LineMonitor.checkLine
     */
    static final int LINE_MONITOR_TIME = 400;


    /**
     * This start() method starts an event thread if one is not already active.
     */
    synchronized void start() {

<span class="nc bnc" id="L90" title="All 2 branches missed.">        if(thread == null) {</span>
<span class="nc" id="L91">            thread = JSSecurityManager.createThread(this,</span>
                                                    &quot;Java Sound Event Dispatcher&quot;,   // name
                                                    true,  // daemon
                                                    -1,    // priority
                                                    true); // doStart
        }
<span class="nc" id="L97">    }</span>


    /**
     * Invoked when there is at least one event in the queue.
     * Implement this as a callback to process one event.
     */
    void processEvent(EventInfo eventInfo) {
<span class="nc" id="L105">        int count = eventInfo.getListenerCount();</span>

        // process an LineEvent
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (eventInfo.getEvent() instanceof LineEvent) {</span>
<span class="nc" id="L109">            LineEvent event = (LineEvent) eventInfo.getEvent();</span>
            if (Printer.debug) Printer.debug(&quot;Sending &quot;+event+&quot; to &quot;+count+&quot; listeners&quot;);
<span class="nc bnc" id="L111" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
                try {
<span class="nc" id="L113">                    ((LineListener) eventInfo.getListener(i)).update(event);</span>
<span class="nc" id="L114">                } catch (Throwable t) {</span>
                    if (Printer.err) t.printStackTrace();
<span class="nc" id="L116">                }</span>
            }
<span class="nc" id="L118">            return;</span>
        }

        // process a MetaMessage
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (eventInfo.getEvent() instanceof MetaMessage) {</span>
<span class="nc" id="L123">            MetaMessage event = (MetaMessage)eventInfo.getEvent();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
                try {
<span class="nc" id="L126">                    ((MetaEventListener) eventInfo.getListener(i)).meta(event);</span>
<span class="nc" id="L127">                } catch (Throwable t) {</span>
                    if (Printer.err) t.printStackTrace();
<span class="nc" id="L129">                }</span>
            }
<span class="nc" id="L131">            return;</span>
        }

        // process a Controller or Mode Event
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (eventInfo.getEvent() instanceof ShortMessage) {</span>
<span class="nc" id="L136">            ShortMessage event = (ShortMessage)eventInfo.getEvent();</span>
<span class="nc" id="L137">            int status = event.getStatus();</span>

            // Controller and Mode events have status byte 0xBc, where
            // c is the channel they are sent on.
<span class="nc bnc" id="L141" title="All 2 branches missed.">            if ((status &amp; 0xF0) == 0xB0) {</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                for (int i = 0; i &lt; count; i++) {</span>
                    try {
<span class="nc" id="L144">                        ((ControllerEventListener) eventInfo.getListener(i)).controlChange(event);</span>
<span class="nc" id="L145">                    } catch (Throwable t) {</span>
                        if (Printer.err) t.printStackTrace();
<span class="nc" id="L147">                    }</span>
                }
            }
<span class="nc" id="L150">            return;</span>
        }

<span class="nc" id="L153">        Printer.err(&quot;Unknown event type: &quot; + eventInfo.getEvent());</span>
<span class="nc" id="L154">    }</span>


    /**
     * Wait until there is something in the event queue to process.  Then
     * dispatch the event to the listeners.The entire method does not
     * need to be synchronized since this includes taking the event out
     * from the queue and processing the event. We only need to provide
     * exclusive access over the code where an event is removed from the
     *queue.
     */
    void dispatchEvents() {

<span class="nc" id="L167">        EventInfo eventInfo = null;</span>

<span class="nc" id="L169">        synchronized (this) {</span>

            // Wait till there is an event in the event queue.
            try {

<span class="nc bnc" id="L174" title="All 2 branches missed.">                if (eventQueue.size() == 0) {</span>
<span class="nc bnc" id="L175" title="All 4 branches missed.">                    if (autoClosingClips.size() &gt; 0 || lineMonitors.size() &gt; 0) {</span>
<span class="nc" id="L176">                        int waitTime = AUTO_CLOSE_TIME;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                        if (lineMonitors.size() &gt; 0) {</span>
<span class="nc" id="L178">                            waitTime = LINE_MONITOR_TIME;</span>
                        }
<span class="nc" id="L180">                        wait(waitTime);</span>
<span class="nc" id="L181">                    } else {</span>
<span class="nc" id="L182">                        wait();</span>
                    }
                }
<span class="nc" id="L185">            } catch (InterruptedException e) {</span>
<span class="nc" id="L186">            }</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (eventQueue.size() &gt; 0) {</span>
                // Remove the event from the queue and dispatch it to the listeners.
<span class="nc" id="L189">                eventInfo = (EventInfo) eventQueue.remove(0);</span>
            }

<span class="nc" id="L192">        } // end of synchronized</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (eventInfo != null) {</span>
<span class="nc" id="L194">            processEvent(eventInfo);</span>
        } else {
<span class="nc bnc" id="L196" title="All 2 branches missed.">            if (autoClosingClips.size() &gt; 0) {</span>
<span class="nc" id="L197">                closeAutoClosingClips();</span>
            }
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (lineMonitors.size() &gt; 0) {</span>
<span class="nc" id="L200">                monitorLines();</span>
            }
        }
<span class="nc" id="L203">    }</span>


    /**
     * Queue the given event in the event queue.
     */
    private synchronized void postEvent(EventInfo eventInfo) {
<span class="nc" id="L210">        eventQueue.add(eventInfo);</span>
<span class="nc" id="L211">        notifyAll();</span>
<span class="nc" id="L212">    }</span>


    /**
     * A loop to dispatch events.
     */
    public void run() {

        while (true) {
            try {
<span class="nc" id="L222">                dispatchEvents();</span>
<span class="nc" id="L223">            } catch (Throwable t) {</span>
                if (Printer.err) t.printStackTrace();
<span class="nc" id="L225">            }</span>
        }
    }


    /**
     * Send audio and MIDI events.
     */
    void sendAudioEvents(Object event, List listeners) {
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if ((listeners == null)</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            || (listeners.size() == 0)) {</span>
            // nothing to do
<span class="nc" id="L237">            return;</span>
        }

<span class="nc" id="L240">        start();</span>

<span class="nc" id="L242">        EventInfo eventInfo = new EventInfo(event, listeners);</span>
<span class="nc" id="L243">        postEvent(eventInfo);</span>
<span class="nc" id="L244">    }</span>


    /*
     * go through the list of registered auto-closing
     * Clip instances and close them, if appropriate
     *
     * This method is called in regular intervals
     */
    private void closeAutoClosingClips() {
<span class="nc" id="L254">        synchronized(autoClosingClips) {</span>
            if (Printer.debug)Printer.debug(&quot;&gt; EventDispatcher.closeAutoClosingClips (&quot;+autoClosingClips.size()+&quot; clips)&quot;);
<span class="nc" id="L256">            long currTime = System.currentTimeMillis();</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            for (int i = autoClosingClips.size()-1; i &gt;= 0 ; i--) {</span>
<span class="nc" id="L258">                ClipInfo info = autoClosingClips.get(i);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">                if (info.isExpired(currTime)) {</span>
<span class="nc" id="L260">                    AutoClosingClip clip = info.getClip();</span>
                    // sanity check
<span class="nc bnc" id="L262" title="All 4 branches missed.">                    if (!clip.isOpen() || !clip.isAutoClosing()) {</span>
                        if (Printer.debug)Printer.debug(&quot;EventDispatcher: removing clip &quot;+clip+&quot;  isOpen:&quot;+clip.isOpen());
<span class="nc" id="L264">                        autoClosingClips.remove(i);</span>
                    }
<span class="nc bnc" id="L266" title="All 6 branches missed.">                    else if (!clip.isRunning() &amp;&amp; !clip.isActive() &amp;&amp; clip.isAutoClosing()) {</span>
                        if (Printer.debug)Printer.debug(&quot;EventDispatcher: closing clip &quot;+clip);
<span class="nc" id="L268">                        clip.close();</span>
                    } else {
                        if (Printer.debug)Printer.debug(&quot;Doing nothing with clip &quot;+clip+&quot;:&quot;);
                        if (Printer.debug)Printer.debug(&quot;  open=&quot;+clip.isOpen()+&quot;, autoclosing=&quot;+clip.isAutoClosing());
                        if (Printer.debug)Printer.debug(&quot;  isRunning=&quot;+clip.isRunning()+&quot;, isActive=&quot;+clip.isActive());
                    }
                } else {
                    if (Printer.debug)Printer.debug(&quot;EventDispatcher: clip &quot;+info.getClip()+&quot; not yet expired&quot;);
                }
            }
<span class="nc" id="L278">        }</span>
        if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.closeAutoClosingClips (&quot;+autoClosingClips.size()+&quot; clips)&quot;);
<span class="nc" id="L280">    }</span>

    private int getAutoClosingClipIndex(AutoClosingClip clip) {
<span class="nc" id="L283">        synchronized(autoClosingClips) {</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">            for (int i = autoClosingClips.size()-1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                if (clip.equals(autoClosingClips.get(i).getClip())) {</span>
<span class="nc" id="L286">                    return i;</span>
                }
            }
<span class="nc" id="L289">        }</span>
<span class="nc" id="L290">        return -1;</span>
    }

    /**
     * called from auto-closing clips when one of their open() method is called
     */
    void autoClosingClipOpened(AutoClosingClip clip) {
        if (Printer.debug)Printer.debug(&quot;&gt; EventDispatcher.autoClosingClipOpened &quot;);
<span class="nc" id="L298">        int index = 0;</span>
<span class="nc" id="L299">        synchronized(autoClosingClips) {</span>
<span class="nc" id="L300">            index = getAutoClosingClipIndex(clip);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (index == -1) {</span>
                if (Printer.debug)Printer.debug(&quot;EventDispatcher: adding auto-closing clip &quot;+clip);
<span class="nc" id="L303">                autoClosingClips.add(new ClipInfo(clip));</span>
            }
<span class="nc" id="L305">        }</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (index == -1) {</span>
<span class="nc" id="L307">            synchronized (this) {</span>
                // this is only for the case that the first clip is set to autoclosing,
                // and it is already open, and nothing is done with it.
                // EventDispatcher.process() method would block in wait() and
                // never close this first clip, keeping the device open.
<span class="nc" id="L312">                notifyAll();</span>
<span class="nc" id="L313">            }</span>
        }
        if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.autoClosingClipOpened finished(&quot;+autoClosingClips.size()+&quot; clips)&quot;);
<span class="nc" id="L316">    }</span>

    /**
     * called from auto-closing clips when their closed() method is called
     */
    void autoClosingClipClosed(AutoClosingClip clip) {
        // nothing to do -- is removed from arraylist above
<span class="nc" id="L323">    }</span>


    // ////////////////////////// Line Monitoring Support /////////////////// //
    /*
     * go through the list of registered line monitors
     * and call their checkLine method
     *
     * This method is called in regular intervals
     */
    private void monitorLines() {
<span class="nc" id="L334">        synchronized(lineMonitors) {</span>
            if (Printer.debug)Printer.debug(&quot;&gt; EventDispatcher.monitorLines (&quot;+lineMonitors.size()+&quot; monitors)&quot;);
<span class="nc bnc" id="L336" title="All 2 branches missed.">            for (int i = 0; i &lt; lineMonitors.size(); i++) {</span>
<span class="nc" id="L337">                lineMonitors.get(i).checkLine();</span>
            }
<span class="nc" id="L339">        }</span>
        if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.monitorLines(&quot;+lineMonitors.size()+&quot; monitors)&quot;);
<span class="nc" id="L341">    }</span>


    /**
     * Add this LineMonitor instance to the list of monitors
     */
    void addLineMonitor(LineMonitor lm) {
        if (Printer.trace)Printer.trace(&quot;&gt; EventDispatcher.addLineMonitor(&quot;+lm+&quot;)&quot;);
<span class="nc" id="L349">        synchronized(lineMonitors) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            if (lineMonitors.indexOf(lm) &gt;= 0) {</span>
                if (Printer.trace)Printer.trace(&quot;&lt; EventDispatcher.addLineMonitor finished -- this monitor already exists!&quot;);
<span class="nc" id="L352">                return;</span>
            }
            if (Printer.debug)Printer.debug(&quot;EventDispatcher: adding line monitor &quot;+lm);
<span class="nc" id="L355">            lineMonitors.add(lm);</span>
<span class="nc" id="L356">        }</span>
<span class="nc" id="L357">        synchronized (this) {</span>
            // need to interrupt the infinite wait()
<span class="nc" id="L359">            notifyAll();</span>
<span class="nc" id="L360">        }</span>
        if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.addLineMonitor finished -- now (&quot;+lineMonitors.size()+&quot; monitors)&quot;);
<span class="nc" id="L362">    }</span>

    /**
     * Remove this LineMonitor instance from the list of monitors
     */
    void removeLineMonitor(LineMonitor lm) {
        if (Printer.trace)Printer.trace(&quot;&gt; EventDispatcher.removeLineMonitor(&quot;+lm+&quot;)&quot;);
<span class="nc" id="L369">        synchronized(lineMonitors) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">            if (lineMonitors.indexOf(lm) &lt; 0) {</span>
                if (Printer.trace)Printer.trace(&quot;&lt; EventDispatcher.removeLineMonitor finished -- this monitor does not exist!&quot;);
<span class="nc" id="L372">                return;</span>
            }
            if (Printer.debug)Printer.debug(&quot;EventDispatcher: removing line monitor &quot;+lm);
<span class="nc" id="L375">            lineMonitors.remove(lm);</span>
<span class="nc" id="L376">        }</span>
        if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.removeLineMonitor finished -- now (&quot;+lineMonitors.size()+&quot; monitors)&quot;);
<span class="nc" id="L378">    }</span>

    // /////////////////////////////////// INNER CLASSES ////////////////////////////////////////// //

    /**
     * Container for an event and a set of listeners to deliver it to.
     */
    private class EventInfo {

        private final Object event;
        private final Object[] listeners;

        /**
         * Create a new instance of this event Info class
         * @param event the event to be dispatched
         * @param listeners listener list; will be copied
         */
<span class="nc" id="L395">        EventInfo(Object event, List listeners) {</span>
<span class="nc" id="L396">            this.event = event;</span>
<span class="nc" id="L397">            this.listeners = listeners.toArray();</span>
<span class="nc" id="L398">        }</span>

        Object getEvent() {
<span class="nc" id="L401">            return event;</span>
        }

        int getListenerCount() {
<span class="nc" id="L405">            return listeners.length;</span>
        }

        Object getListener(int index) {
<span class="nc" id="L409">            return listeners[index];</span>
        }

    } // class EventInfo


    /**
     * Container for a clip with its expiration time
     */
    private class ClipInfo {

        private final AutoClosingClip clip;
        private final long expiration;

        /**
         * Create a new instance of this clip Info class
         */
<span class="nc" id="L426">        ClipInfo(AutoClosingClip clip) {</span>
<span class="nc" id="L427">            this.clip = clip;</span>
<span class="nc" id="L428">            this.expiration = System.currentTimeMillis() + AUTO_CLOSE_TIME;</span>
<span class="nc" id="L429">        }</span>

        AutoClosingClip getClip() {
<span class="nc" id="L432">            return clip;</span>
        }

        boolean isExpired(long currTime) {
<span class="nc bnc" id="L436" title="All 2 branches missed.">            return currTime &gt; expiration;</span>
        }
    } // class ClipInfo


    /**
     * Interface that a class that wants to get regular
     * line monitor events implements
     */
<span class="nc" id="L445">    interface LineMonitor {</span>
        /**
         * Called by event dispatcher in regular intervals
         */
        public void checkLine();
    }

} // class EventDispatcher
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>