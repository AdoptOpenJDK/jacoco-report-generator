<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AbstractDataLine.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">AbstractDataLine.java</span></div><h1>AbstractDataLine.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Control;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineEvent;
import javax.sound.sampled.LineUnavailableException;


/**
 * AbstractDataLine
 *
 * @author Kara Kytle
 */
abstract class AbstractDataLine extends AbstractLine implements DataLine {

    // DEFAULTS

    // default format
    private final AudioFormat defaultFormat;

    // default buffer size in bytes
    private final int defaultBufferSize;

    // the lock for synchronization
<span class="nc" id="L52">    protected final Object lock = new Object();</span>

    // STATE

    // current format
    protected AudioFormat format;

    // current buffer size in bytes
    protected int bufferSize;

<span class="nc" id="L62">    protected boolean running = false;</span>
<span class="nc" id="L63">    private boolean started = false;</span>
<span class="nc" id="L64">    private boolean active = false;</span>


    /**
     * Constructs a new AbstractLine.
     */
    protected AbstractDataLine(DataLine.Info info, AbstractMixer mixer, Control[] controls) {
<span class="nc" id="L71">        this(info, mixer, controls, null, AudioSystem.NOT_SPECIFIED);</span>
<span class="nc" id="L72">    }</span>

    /**
     * Constructs a new AbstractLine.
     */
    protected AbstractDataLine(DataLine.Info info, AbstractMixer mixer, Control[] controls, AudioFormat format, int bufferSize) {

<span class="nc" id="L79">        super(info, mixer, controls);</span>

        // record the default values
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (format != null) {</span>
<span class="nc" id="L83">            defaultFormat = format;</span>
        } else {
            // default CD-quality
<span class="nc" id="L86">            defaultFormat = new AudioFormat(44100.0f, 16, 2, true, Platform.isBigEndian());</span>
        }
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (bufferSize &gt; 0) {</span>
<span class="nc" id="L89">            defaultBufferSize = bufferSize;</span>
        } else {
            // 0.5 seconds buffer
<span class="nc" id="L92">            defaultBufferSize = ((int) (defaultFormat.getFrameRate() / 2)) * defaultFormat.getFrameSize();</span>
        }

        // set the initial values to the defaults
<span class="nc" id="L96">        this.format = defaultFormat;</span>
<span class="nc" id="L97">        this.bufferSize = defaultBufferSize;</span>
<span class="nc" id="L98">    }</span>


    // DATA LINE METHODS

    public final void open(AudioFormat format, int bufferSize) throws LineUnavailableException {
        //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
<span class="nc" id="L105">        synchronized (mixer) {</span>
            if (Printer.trace) Printer.trace(&quot;&gt; AbstractDataLine.open(format, bufferSize) (class: &quot;+getClass().getName());

            // if the line is not currently open, try to open it with this format and buffer size
<span class="nc bnc" id="L109" title="All 2 branches missed.">            if (!isOpen()) {</span>
                // make sure that the format is specified correctly
                // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
<span class="nc" id="L112">                Toolkit.isFullySpecifiedAudioFormat(format);</span>

                if (Printer.debug) Printer.debug(&quot;  need to open the mixer...&quot;);
                // reserve mixer resources for this line
                //mixer.open(this, format, bufferSize);
<span class="nc" id="L117">                mixer.open(this);</span>

                try {
                    // open the data line.  may throw LineUnavailableException.
<span class="nc" id="L121">                    implOpen(format, bufferSize);</span>

                    // if we succeeded, set the open state to true and send events
<span class="nc" id="L124">                    setOpen(true);</span>

<span class="nc" id="L126">                } catch (LineUnavailableException e) {</span>
                    // release mixer resources for this line and then throw the exception
<span class="nc" id="L128">                    mixer.close(this);</span>
<span class="nc" id="L129">                    throw e;</span>
<span class="nc" id="L130">                }</span>
            } else {
                if (Printer.debug) Printer.debug(&quot;  dataline already open&quot;);

                // if the line is already open and the requested format differs from the
                // current settings, throw an IllegalStateException
                //$$fb 2002-04-02: fix for 4661602: Buffersize is checked when re-opening line
<span class="nc bnc" id="L137" title="All 2 branches missed.">                if (!format.matches(getFormat())) {</span>
<span class="nc" id="L138">                    throw new IllegalStateException(&quot;Line is already open with format &quot; + getFormat() +</span>
<span class="nc" id="L139">                                                    &quot; and bufferSize &quot; + getBufferSize());</span>
                }
                //$$fb 2002-07-26: allow changing the buffersize of already open lines
<span class="nc bnc" id="L142" title="All 2 branches missed.">                if (bufferSize &gt; 0) {</span>
<span class="nc" id="L143">                    setBufferSize(bufferSize);</span>
                }
            }

            if (Printer.trace) Printer.trace(&quot;&lt; AbstractDataLine.open(format, bufferSize) completed&quot;);
<span class="nc" id="L148">        }</span>
<span class="nc" id="L149">    }</span>


    public final void open(AudioFormat format) throws LineUnavailableException {
<span class="nc" id="L153">        open(format, AudioSystem.NOT_SPECIFIED);</span>
<span class="nc" id="L154">    }</span>


    /**
     * This implementation always returns 0.
     */
    public int available() {
<span class="nc" id="L161">        return 0;</span>
    }


    /**
     * This implementation does nothing.
     */
    public void drain() {
        if (Printer.trace) Printer.trace(&quot;AbstractDataLine: drain&quot;);
<span class="nc" id="L170">    }</span>


    /**
     * This implementation does nothing.
     */
    public void flush() {
        if (Printer.trace) Printer.trace(&quot;AbstractDataLine: flush&quot;);
<span class="nc" id="L178">    }</span>


    public final void start() {
        //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
<span class="nc" id="L183">        synchronized(mixer) {</span>
            if (Printer.trace) Printer.trace(&quot;&gt; &quot;+getClass().getName()+&quot;.start() - AbstractDataLine&quot;);

            // $$kk: 06.06.99: if not open, this doesn't work....???
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (isOpen()) {</span>

<span class="nc bnc" id="L189" title="All 2 branches missed.">                if (!isStartedRunning()) {</span>
<span class="nc" id="L190">                    mixer.start(this);</span>
<span class="nc" id="L191">                    implStart();</span>
<span class="nc" id="L192">                    running = true;</span>
                }
            }
<span class="nc" id="L195">        }</span>

<span class="nc" id="L197">        synchronized(lock) {</span>
<span class="nc" id="L198">            lock.notifyAll();</span>
<span class="nc" id="L199">        }</span>

        if (Printer.trace) Printer.trace(&quot;&lt; &quot;+getClass().getName()+&quot;.start() - AbstractDataLine&quot;);
<span class="nc" id="L202">    }</span>


    public final void stop() {

        //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
<span class="nc" id="L208">        synchronized(mixer) {</span>
            if (Printer.trace) Printer.trace(&quot;&gt; &quot;+getClass().getName()+&quot;.stop() - AbstractDataLine&quot;);

            // $$kk: 06.06.99: if not open, this doesn't work.
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (isOpen()) {</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">                if (isStartedRunning()) {</span>

<span class="nc" id="L216">                    implStop();</span>
<span class="nc" id="L217">                    mixer.stop(this);</span>

<span class="nc" id="L219">                    running = false;</span>

                    // $$kk: 11.10.99: this is not exactly correct, but will probably work
<span class="nc bnc" id="L222" title="All 4 branches missed.">                    if (started &amp;&amp; (!isActive())) {</span>
<span class="nc" id="L223">                        setStarted(false);</span>
                    }
                }
            }
<span class="nc" id="L227">        }</span>

<span class="nc" id="L229">        synchronized(lock) {</span>
<span class="nc" id="L230">            lock.notifyAll();</span>
<span class="nc" id="L231">        }</span>

        if (Printer.trace) Printer.trace(&quot;&lt; &quot;+getClass().getName()+&quot;.stop() - AbstractDataLine&quot;);
<span class="nc" id="L234">    }</span>

    // $$jb: 12.10.99: The official API for this is isRunning().
    // Per the denied RFE 4297981,
    // the change to isStarted() is technically an unapproved API change.
    // The 'started' variable is false when playback of data stops.
    // It is changed throughout the implementation with setStarted().
    // This state is what should be returned by isRunning() in the API.
    // Note that the 'running' variable is true between calls to
    // start() and stop().  This state is accessed now through the
    // isStartedRunning() method, defined below.  I have not changed
    // the variable names at this point, since 'running' is accessed
    // in MixerSourceLine and MixerClip, and I want to touch as little
    // code as possible to change isStarted() back to isRunning().

    public final boolean isRunning() {
<span class="nc" id="L250">        return started;</span>
    }

    public final boolean isActive() {
<span class="nc" id="L254">        return active;</span>
    }


    public final long getMicrosecondPosition() {

<span class="nc" id="L260">        long microseconds = getLongFramePosition();</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">        if (microseconds != AudioSystem.NOT_SPECIFIED) {</span>
<span class="nc" id="L262">            microseconds = Toolkit.frames2micros(getFormat(), microseconds);</span>
        }
<span class="nc" id="L264">        return microseconds;</span>
    }


    public final AudioFormat getFormat() {
<span class="nc" id="L269">        return format;</span>
    }


    public final int getBufferSize() {
<span class="nc" id="L274">        return bufferSize;</span>
    }

    /**
     * This implementation does NOT change the buffer size
     */
    public final int setBufferSize(int newSize) {
<span class="nc" id="L281">        return getBufferSize();</span>
    }

    /**
     * This implementation returns AudioSystem.NOT_SPECIFIED.
     */
    public final float getLevel() {
<span class="nc" id="L288">        return (float)AudioSystem.NOT_SPECIFIED;</span>
    }


    // HELPER METHODS

    /**
     * running is true after start is called and before stop is called,
     * regardless of whether data is actually being presented.
     */
    // $$jb: 12.10.99: calling this method isRunning() conflicts with
    // the official API that was once called isStarted().  Since we
    // use this method throughout the implementation, I am renaming
    // it to isStartedRunning().  This is part of backing out the
    // change denied in RFE 4297981.

    final boolean isStartedRunning() {
<span class="nc" id="L305">        return running;</span>
    }

    /**
     * This method sets the active state and generates
     * events if it changes.
     */
    final void setActive(boolean active) {

        if (Printer.trace) Printer.trace(&quot;&gt; AbstractDataLine: setActive(&quot; + active + &quot;)&quot;);

        //boolean sendEvents = false;
        //long position = getLongFramePosition();

<span class="nc" id="L319">        synchronized (this) {</span>

            //if (Printer.debug) Printer.debug(&quot;    AbstractDataLine: setActive: this.active: &quot; + this.active);
            //if (Printer.debug) Printer.debug(&quot;                                 active: &quot; + active);

<span class="nc bnc" id="L324" title="All 2 branches missed.">            if (this.active != active) {</span>
<span class="nc" id="L325">                this.active = active;</span>
                //sendEvents = true;
            }
<span class="nc" id="L328">        }</span>

        //if (Printer.debug) Printer.debug(&quot;                                 this.active: &quot; + this.active);
        //if (Printer.debug) Printer.debug(&quot;                                 sendEvents: &quot; + sendEvents);


        // $$kk: 11.19.99: take ACTIVE / INACTIVE / EOM events out;
        // putting them in is technically an API change.
        // do not generate ACTIVE / INACTIVE events for now
        // if (sendEvents) {
        //
        //      if (active) {
        //              sendEvents(new LineEvent(this, LineEvent.Type.ACTIVE, position));
        //      } else {
        //              sendEvents(new LineEvent(this, LineEvent.Type.INACTIVE, position));
        //      }
        //}
<span class="nc" id="L345">    }</span>

    /**
     * This method sets the started state and generates
     * events if it changes.
     */
    final void setStarted(boolean started) {

        if (Printer.trace) Printer.trace(&quot;&gt; AbstractDataLine: setStarted(&quot; + started + &quot;)&quot;);

<span class="nc" id="L355">        boolean sendEvents = false;</span>
<span class="nc" id="L356">        long position = getLongFramePosition();</span>

<span class="nc" id="L358">        synchronized (this) {</span>

            //if (Printer.debug) Printer.debug(&quot;    AbstractDataLine: setStarted: this.started: &quot; + this.started);
            //if (Printer.debug) Printer.debug(&quot;                                  started: &quot; + started);

<span class="nc bnc" id="L363" title="All 2 branches missed.">            if (this.started != started) {</span>
<span class="nc" id="L364">                this.started = started;</span>
<span class="nc" id="L365">                sendEvents = true;</span>
            }
<span class="nc" id="L367">        }</span>

        //if (Printer.debug) Printer.debug(&quot;                                  this.started: &quot; + this.started);
        //if (Printer.debug) Printer.debug(&quot;                                  sendEvents: &quot; + sendEvents);

<span class="nc bnc" id="L372" title="All 2 branches missed.">        if (sendEvents) {</span>

<span class="nc bnc" id="L374" title="All 2 branches missed.">            if (started) {</span>
<span class="nc" id="L375">                sendEvents(new LineEvent(this, LineEvent.Type.START, position));</span>
            } else {
<span class="nc" id="L377">                sendEvents(new LineEvent(this, LineEvent.Type.STOP, position));</span>
            }
        }
        if (Printer.trace) Printer.trace(&quot;&lt; AbstractDataLine: setStarted completed&quot;);
<span class="nc" id="L381">    }</span>


    /**
     * This method generates a STOP event and sets the started state to false.
     * It is here for historic reasons when an EOM event existed.
     */
    final void setEOM() {

        if (Printer.trace) Printer.trace(&quot;&gt; AbstractDataLine: setEOM()&quot;);
        //$$fb 2002-04-21: sometimes, 2 STOP events are generated.
        // better use setStarted() to send STOP event.
<span class="nc" id="L393">        setStarted(false);</span>
        if (Printer.trace) Printer.trace(&quot;&lt; AbstractDataLine: setEOM() completed&quot;);
<span class="nc" id="L395">    }</span>




    // OVERRIDES OF ABSTRACT LINE METHODS

    /**
     * Try to open the line with the current format and buffer size values.
     * If the line is not open, these will be the defaults.  If the
     * line is open, this should return quietly because the values
     * requested will match the current ones.
     */
    public final void open() throws LineUnavailableException {

        if (Printer.trace) Printer.trace(&quot;&gt; &quot;+getClass().getName()+&quot;.open() - AbstractDataLine&quot;);

        // this may throw a LineUnavailableException.
<span class="nc" id="L413">        open(format, bufferSize);</span>
        if (Printer.trace) Printer.trace(&quot;&lt; &quot;+getClass().getName()+&quot;.open() - AbstractDataLine&quot;);
<span class="nc" id="L415">    }</span>


    /**
     * This should also stop the line.  The closed line should not be running or active.
     * After we close the line, we reset the format and buffer size to the defaults.
     */
    public final void close() {
        //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
<span class="nc" id="L424">        synchronized (mixer) {</span>
            if (Printer.trace) Printer.trace(&quot;&gt; &quot;+getClass().getName()+&quot;.close() - in AbstractDataLine.&quot;);

<span class="nc bnc" id="L427" title="All 2 branches missed.">            if (isOpen()) {</span>

                // stop
<span class="nc" id="L430">                stop();</span>

                // set the open state to false and send events
<span class="nc" id="L433">                setOpen(false);</span>

                // close resources for this line
<span class="nc" id="L436">                implClose();</span>

                // release mixer resources for this line
<span class="nc" id="L439">                mixer.close(this);</span>

                // reset format and buffer size to the defaults
<span class="nc" id="L442">                format = defaultFormat;</span>
<span class="nc" id="L443">                bufferSize = defaultBufferSize;</span>
            }
<span class="nc" id="L445">        }</span>
        if (Printer.trace) Printer.trace(&quot;&lt; &quot;+getClass().getName()+&quot;.close() - in AbstractDataLine&quot;);
<span class="nc" id="L447">    }</span>


    // IMPLEMENTATIONS OF ABSTRACT LINE ABSTRACE METHODS


    // ABSTRACT METHODS

    abstract void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException;
    abstract void implClose();

    abstract void implStart();
    abstract void implStop();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>