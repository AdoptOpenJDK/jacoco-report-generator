<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractMidiDevice.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">AbstractMidiDevice.java</span></div><h1>AbstractMidiDevice.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import java.util.ArrayList;
import java.util.List;
import java.util.Collections;

import javax.sound.midi.*;


/**
 * Abstract AbstractMidiDevice class representing functionality shared by
 * MidiInDevice and MidiOutDevice objects.
 *
 * @author David Rivas
 * @author Kara Kytle
 * @author Matthias Pfisterer
 * @author Florian Bomers
 */
abstract class AbstractMidiDevice implements MidiDevice, ReferenceCountingDevice {

    // STATIC VARIABLES
    private static final boolean TRACE_TRANSMITTER = false;

    // INSTANCE VARIABLES

    private ArrayList&lt;Receiver&gt; receiverList;

    private TransmitterList transmitterList;

    // lock to protect receiverList and transmitterList
    // from simultaneous creation and destruction
    // reduces possibility of deadlock, compared to
    // synchronizing to the class instance
<span class="nc" id="L59">    private final Object traRecLock = new Object();</span>

    // DEVICE ATTRIBUTES

    private final MidiDevice.Info info;


    // DEVICE STATE

<span class="nc" id="L68">    private boolean open          = false;</span>
    private int openRefCount;

    /** List of Receivers and Transmitters that opened the device implicitely.
     */
    private List openKeepingObjects;

    /**
     * This is the device handle returned from native code
     */
<span class="nc" id="L78">    protected long id                   = 0;</span>



    // CONSTRUCTOR


    /**
     * Constructs an AbstractMidiDevice with the specified info object.
     * @param info the description of the device
     */
    /*
     * The initial mode and and only supported mode default to OMNI_ON_POLY.
     */
<span class="nc" id="L92">    protected AbstractMidiDevice(MidiDevice.Info info) {</span>

        if(Printer.trace) Printer.trace(&quot;&gt;&gt; AbstractMidiDevice CONSTRUCTOR&quot;);

<span class="nc" id="L96">        this.info = info;</span>
<span class="nc" id="L97">        openRefCount = 0;</span>

        if(Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMidiDevice CONSTRUCTOR completed&quot;);
<span class="nc" id="L100">    }</span>


    // MIDI DEVICE METHODS

    public final MidiDevice.Info getDeviceInfo() {
<span class="nc" id="L106">        return info;</span>
    }

    /** Open the device from an application program.
     * Setting the open reference count to -1 here prevents Transmitters and Receivers that
     * opened the the device implicitly from closing it. The only way to close the device after
     * this call is a call to close().
     */
    public final void open() throws MidiUnavailableException {
        if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: open()&quot;);
<span class="nc" id="L116">        synchronized(this) {</span>
<span class="nc" id="L117">            openRefCount = -1;</span>
<span class="nc" id="L118">            doOpen();</span>
<span class="nc" id="L119">        }</span>
        if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: open() completed&quot;);
<span class="nc" id="L121">    }</span>



    /** Open the device implicitly.
     * This method is intended to be used by AbstractReceiver
     * and BasicTransmitter. Actually, it is called by getReceiverReferenceCounting() and
     * getTransmitterReferenceCounting(). These, in turn, are called by MidiSytem on calls to
     * getReceiver() and getTransmitter(). The former methods should pass the Receiver or
     * Transmitter just created as the object parameter to this method. Storing references to
     * these objects is necessary to be able to decide later (when it comes to closing) if
     * R/T's are ones that opened the device implicitly.
     *
     * @object The Receiver or Transmitter instance that triggered this implicit open.
     */
    private void openInternal(Object object) throws MidiUnavailableException {
        if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: openInternal()&quot;);
<span class="nc" id="L138">        synchronized(this) {</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (openRefCount != -1) {</span>
<span class="nc" id="L140">                openRefCount++;</span>
<span class="nc" id="L141">                getOpenKeepingObjects().add(object);</span>
            }
            // double calls to doOpens() will be catched by the open flag.
<span class="nc" id="L144">            doOpen();</span>
<span class="nc" id="L145">        }</span>
        if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: openInternal() completed&quot;);
<span class="nc" id="L147">    }</span>


    private void doOpen() throws MidiUnavailableException {
        if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: doOpen()&quot;);
<span class="nc" id="L152">        synchronized(this) {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (! isOpen()) {</span>
<span class="nc" id="L154">                implOpen();</span>
<span class="nc" id="L155">                open = true;</span>
            }
<span class="nc" id="L157">        }</span>
        if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: doOpen() completed&quot;);
<span class="nc" id="L159">    }</span>


    public final void close() {
        if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: close()&quot;);
<span class="nc" id="L164">        synchronized (this) {</span>
<span class="nc" id="L165">            doClose();</span>
<span class="nc" id="L166">            openRefCount = 0;</span>
<span class="nc" id="L167">        }</span>
        if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: close() completed&quot;);
<span class="nc" id="L169">    }</span>


    /** Close the device for an object that implicitely opened it.
     * This method is intended to be used by Transmitter.close() and Receiver.close().
     * Those methods should pass this for the object parameter. Since Transmitters or Receivers
     * do not know if their device has been opened implicitely because of them, they call this
     * method in any case. This method now is able to seperate Receivers/Transmitters that opened
     * the device implicitely from those that didn't by looking up the R/T in the
     * openKeepingObjects list. Only if the R/T is contained there, the reference count is
     * reduced.
     *
     * @param object The object that might have been opening the device implicitely (for now,
     * this may be a Transmitter or receiver).
     */
    public final void closeInternal(Object object) {
        if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: closeInternal()&quot;);
<span class="nc" id="L186">        synchronized(this) {</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (getOpenKeepingObjects().remove(object)) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                if (openRefCount &gt; 0) {</span>
<span class="nc" id="L189">                    openRefCount--;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                    if (openRefCount == 0) {</span>
<span class="nc" id="L191">                        doClose();</span>
                    }
                }
            }
<span class="nc" id="L195">        }</span>
        if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: closeInternal() completed&quot;);
<span class="nc" id="L197">    }</span>


    public final void doClose() {
        if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: doClose()&quot;);
<span class="nc" id="L202">        synchronized(this) {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (isOpen()) {</span>
<span class="nc" id="L204">                implClose();</span>
<span class="nc" id="L205">                open = false;</span>
            }
<span class="nc" id="L207">        }</span>
        if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: doClose() completed&quot;);
<span class="nc" id="L209">    }</span>


    public final boolean isOpen() {
<span class="nc" id="L213">        return open;</span>
    }


    protected void implClose() {
<span class="nc" id="L218">        synchronized (traRecLock) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (receiverList != null) {</span>
                // close all receivers
<span class="nc bnc" id="L221" title="All 2 branches missed.">                for(int i = 0; i &lt; receiverList.size(); i++) {</span>
<span class="nc" id="L222">                    receiverList.get(i).close();</span>
                }
<span class="nc" id="L224">                receiverList.clear();</span>
            }
<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (transmitterList != null) {</span>
                // close all transmitters
<span class="nc" id="L228">                transmitterList.close();</span>
            }
<span class="nc" id="L230">        }</span>
<span class="nc" id="L231">    }</span>


    /**
     * This implementation always returns -1.
     * Devices that actually provide this should over-ride
     * this method.
     */
    public long getMicrosecondPosition() {
<span class="nc" id="L240">        return -1;</span>
    }


    /** Return the maximum number of Receivers supported by this device.
        Depending on the return value of hasReceivers(), this method returns either 0 or -1.
        Subclasses should rather override hasReceivers() than override this method.
     */
    public final int getMaxReceivers() {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (hasReceivers()) {</span>
<span class="nc" id="L250">            return -1;</span>
        } else {
<span class="nc" id="L252">            return 0;</span>
        }
    }


    /** Return the maximum number of Transmitters supported by this device.
        Depending on the return value of hasTransmitters(), this method returns either 0 or -1.
        Subclasses should override hasTransmitters().
     */
    public final int getMaxTransmitters() {
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (hasTransmitters()) {</span>
<span class="nc" id="L263">            return -1;</span>
        } else {
<span class="nc" id="L265">            return 0;</span>
        }
    }


    /** Retrieve a Receiver for this device.
        This method returns the value returned by createReceiver(), if it doesn't throw
        an exception. Subclasses should rather override createReceiver() than override
        this method.
        If createReceiver returns a Receiver, it is added to the internal list
        of Receivers (see getReceiversList)
     */
    public final Receiver getReceiver() throws MidiUnavailableException {
        Receiver receiver;
<span class="nc" id="L279">        synchronized (traRecLock) {</span>
<span class="nc" id="L280">            receiver = createReceiver(); // may throw MidiUnavailableException</span>
<span class="nc" id="L281">            getReceiverList().add(receiver);</span>
<span class="nc" id="L282">        }</span>
<span class="nc" id="L283">        return receiver;</span>
    }


    public final List&lt;Receiver&gt; getReceivers() {
        List&lt;Receiver&gt; recs;
<span class="nc" id="L289">        synchronized (traRecLock) {</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (receiverList == null) {</span>
<span class="nc" id="L291">                recs = Collections.unmodifiableList(new ArrayList&lt;Receiver&gt;(0));</span>
            } else {
<span class="nc" id="L293">                recs = Collections.unmodifiableList</span>
<span class="nc" id="L294">                    ((List&lt;Receiver&gt;) (receiverList.clone()));</span>
            }
<span class="nc" id="L296">        }</span>
<span class="nc" id="L297">        return recs;</span>
    }


    /**
     * This implementation uses createTransmitter, which may throw an exception.
     * If a transmitter is returned in createTransmitter, it is added to the internal
     * TransmitterList
     */
    public final Transmitter getTransmitter() throws MidiUnavailableException {
        Transmitter transmitter;
<span class="nc" id="L308">        synchronized (traRecLock) {</span>
<span class="nc" id="L309">            transmitter = createTransmitter(); // may throw MidiUnavailableException</span>
<span class="nc" id="L310">            getTransmitterList().add(transmitter);</span>
<span class="nc" id="L311">        }</span>
<span class="nc" id="L312">        return transmitter;</span>
    }


    public final List&lt;Transmitter&gt; getTransmitters() {
        List&lt;Transmitter&gt; tras;
<span class="nc" id="L318">        synchronized (traRecLock) {</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (transmitterList == null</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">                || transmitterList.transmitters.size() == 0) {</span>
<span class="nc" id="L321">                tras = Collections.unmodifiableList(new ArrayList&lt;Transmitter&gt;(0));</span>
            } else {
<span class="nc" id="L323">                tras = Collections.unmodifiableList((List&lt;Transmitter&gt;) (transmitterList.transmitters.clone()));</span>
            }
<span class="nc" id="L325">        }</span>
<span class="nc" id="L326">        return tras;</span>
    }


    // HELPER METHODS

    final long getId() {
<span class="nc" id="L333">        return id;</span>
    }


    // REFERENCE COUNTING

    /** Retrieve a Receiver and open the device implicitly.
        This method is called by MidiSystem.getReceiver().
     */
    public final Receiver getReceiverReferenceCounting()
            throws MidiUnavailableException {
        /* Keep this order of commands! If getReceiver() throws an exception,
           openInternal() should not be called!
        */
        Receiver receiver;
<span class="nc" id="L348">        synchronized (traRecLock) {</span>
<span class="nc" id="L349">            receiver = getReceiver();</span>
<span class="nc" id="L350">            AbstractMidiDevice.this.openInternal(receiver);</span>
<span class="nc" id="L351">        }</span>
<span class="nc" id="L352">        return receiver;</span>
    }


    /** Retrieve a Transmitter and open the device implicitly.
        This method is called by MidiSystem.getTransmitter().
     */
    public final Transmitter getTransmitterReferenceCounting()
            throws MidiUnavailableException {
        /* Keep this order of commands! If getTransmitter() throws an exception,
           openInternal() should not be called!
        */
        Transmitter transmitter;
<span class="nc" id="L365">        synchronized (traRecLock) {</span>
<span class="nc" id="L366">            transmitter = getTransmitter();</span>
<span class="nc" id="L367">            AbstractMidiDevice.this.openInternal(transmitter);</span>
<span class="nc" id="L368">        }</span>
<span class="nc" id="L369">        return transmitter;</span>
    }


    /** Return the list of objects that have opened the device implicitely.
     */
    private synchronized List getOpenKeepingObjects() {
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (openKeepingObjects == null) {</span>
<span class="nc" id="L377">            openKeepingObjects = new ArrayList();</span>
        }
<span class="nc" id="L379">        return openKeepingObjects;</span>
    }



    // RECEIVER HANDLING METHODS


    /** Return the internal list of Receivers, possibly creating it first.
     */
    private List&lt;Receiver&gt; getReceiverList() {
<span class="nc" id="L390">        synchronized (traRecLock) {</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">            if (receiverList == null) {</span>
<span class="nc" id="L392">                receiverList = new ArrayList&lt;Receiver&gt;();</span>
            }
<span class="nc" id="L394">        }</span>
<span class="nc" id="L395">        return receiverList;</span>
    }


    /** Returns if this device supports Receivers.
        Subclasses that use Receivers should override this method to
        return true. They also should override createReceiver().

        @return true, if the device supports Receivers, false otherwise.
    */
    protected boolean hasReceivers() {
<span class="nc" id="L406">        return false;</span>
    }


    /** Create a Receiver object.
        throwing an exception here means that Receivers aren't enabled.
        Subclasses that use Receivers should override this method with
        one that returns objects implementing Receiver.
        Classes overriding this method should also override hasReceivers()
        to return true.
    */
    protected Receiver createReceiver() throws MidiUnavailableException {
<span class="nc" id="L418">        throw new MidiUnavailableException(&quot;MIDI IN receiver not available&quot;);</span>
    }



    // TRANSMITTER HANDLING

    /** Return the internal list of Transmitters, possibly creating it first.
     */
    final TransmitterList getTransmitterList() {
<span class="nc" id="L428">        synchronized (traRecLock) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (transmitterList == null) {</span>
<span class="nc" id="L430">                transmitterList = new TransmitterList();</span>
            }
<span class="nc" id="L432">        }</span>
<span class="nc" id="L433">        return transmitterList;</span>
    }


    /** Returns if this device supports Transmitters.
        Subclasses that use Transmitters should override this method to
        return true. They also should override createTransmitter().

        @return true, if the device supports Transmitters, false otherwise.
    */
    protected boolean hasTransmitters() {
<span class="nc" id="L444">        return false;</span>
    }


    /** Create a Transmitter object.
        throwing an exception here means that Transmitters aren't enabled.
        Subclasses that use Transmitters should override this method with
        one that returns objects implementing Transmitters.
        Classes overriding this method should also override hasTransmitters()
        to return true.
    */
    protected Transmitter createTransmitter() throws MidiUnavailableException {
<span class="nc" id="L456">        throw new MidiUnavailableException(&quot;MIDI OUT transmitter not available&quot;);</span>
    }

    // ABSTRACT METHODS

    protected abstract void implOpen() throws MidiUnavailableException;


    /**
     * close this device if discarded by the garbage collector
     */
    protected final void finalize() {
<span class="nc" id="L468">        close();</span>
<span class="nc" id="L469">    }</span>

    // INNER CLASSES

    /** Base class for Receivers.
        Subclasses that use Receivers must use this base class, since it
        contains magic necessary to manage implicit closing the device.
        This is necessary for Receivers retrieved via MidiSystem.getReceiver()
        (which opens the device implicitely).
     */
<span class="nc" id="L479">    abstract class AbstractReceiver implements MidiDeviceReceiver {</span>
<span class="nc" id="L480">        private boolean open = true;</span>


        /** Deliver a MidiMessage.
            This method contains magic related to the closed state of a
            Receiver. Therefore, subclasses should not override this method.
            Instead, they should implement implSend().
        */
        @Override
        public final synchronized void send(final MidiMessage message,
                                            final long timeStamp) {
<span class="nc bnc" id="L491" title="All 2 branches missed.">            if (!open) {</span>
<span class="nc" id="L492">                throw new IllegalStateException(&quot;Receiver is not open&quot;);</span>
            }
<span class="nc" id="L494">            implSend(message, timeStamp);</span>
<span class="nc" id="L495">        }</span>

        abstract void implSend(MidiMessage message, long timeStamp);

        /** Close the Receiver.
         * Here, the call to the magic method closeInternal() takes place.
         * Therefore, subclasses that override this method must call
         * 'super.close()'.
         */
        @Override
        public final void close() {
<span class="nc" id="L506">            open = false;</span>
<span class="nc" id="L507">            synchronized (AbstractMidiDevice.this.traRecLock) {</span>
<span class="nc" id="L508">                AbstractMidiDevice.this.getReceiverList().remove(this);</span>
<span class="nc" id="L509">            }</span>
<span class="nc" id="L510">            AbstractMidiDevice.this.closeInternal(this);</span>
<span class="nc" id="L511">        }</span>

        @Override
        public final MidiDevice getMidiDevice() {
<span class="nc" id="L515">            return AbstractMidiDevice.this;</span>
        }

        final boolean isOpen() {
<span class="nc" id="L519">            return open;</span>
        }

        //$$fb is that a good idea?
        //protected void finalize() {
        //    close();
        //}

    } // class AbstractReceiver


    /**
     * Transmitter base class.
     * This class especially makes sure the device is closed if it
     * has been opened implicitly by a call to MidiSystem.getTransmitter().
     * The logic of doing so is actually in closeInternal().
     *
     * Also, it has some optimizations regarding sending to the Receivers,
     * for known Receivers, and managing itself in the TransmitterList.
     */
    class BasicTransmitter implements MidiDeviceTransmitter {

<span class="nc" id="L541">        private Receiver receiver = null;</span>
<span class="nc" id="L542">        TransmitterList tlist = null;</span>

<span class="nc" id="L544">        protected BasicTransmitter() {</span>
<span class="nc" id="L545">        }</span>

        private void setTransmitterList(TransmitterList tlist) {
<span class="nc" id="L548">            this.tlist = tlist;</span>
<span class="nc" id="L549">        }</span>

        public final void setReceiver(Receiver receiver) {
<span class="nc bnc" id="L552" title="All 4 branches missed.">            if (tlist != null &amp;&amp; this.receiver != receiver) {</span>
                if (Printer.debug) Printer.debug(&quot;Transmitter &quot;+toString()+&quot;: set receiver &quot;+receiver);
<span class="nc" id="L554">                tlist.receiverChanged(this, this.receiver, receiver);</span>
<span class="nc" id="L555">                this.receiver = receiver;</span>
            }
<span class="nc" id="L557">        }</span>

        public final Receiver getReceiver() {
<span class="nc" id="L560">            return receiver;</span>
        }


        /** Close the Transmitter.
         * Here, the call to the magic method closeInternal() takes place.
         * Therefore, subclasses that override this method must call
         * 'super.close()'.
         */
        public final void close() {
<span class="nc" id="L570">            AbstractMidiDevice.this.closeInternal(this);</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">            if (tlist != null) {</span>
<span class="nc" id="L572">                tlist.receiverChanged(this, this.receiver, null);</span>
<span class="nc" id="L573">                tlist.remove(this);</span>
<span class="nc" id="L574">                tlist = null;</span>
            }
<span class="nc" id="L576">        }</span>

        public final MidiDevice getMidiDevice() {
<span class="nc" id="L579">            return AbstractMidiDevice.this;</span>
        }

    } // class BasicTransmitter


    /**
     * a class to manage a list of transmitters
     */
<span class="nc" id="L588">    final class TransmitterList {</span>

<span class="nc" id="L590">        private final ArrayList&lt;Transmitter&gt; transmitters = new ArrayList&lt;Transmitter&gt;();</span>
        private MidiOutDevice.MidiOutReceiver midiOutReceiver;

        // how many transmitters must be present for optimized
        // handling
<span class="nc" id="L595">        private int optimizedReceiverCount = 0;</span>


        private void add(Transmitter t) {
<span class="nc" id="L599">            synchronized(transmitters) {</span>
<span class="nc" id="L600">                transmitters.add(t);</span>
<span class="nc" id="L601">            }</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">            if (t instanceof BasicTransmitter) {</span>
<span class="nc" id="L603">                ((BasicTransmitter) t).setTransmitterList(this);</span>
            }
            if (Printer.debug) Printer.debug(&quot;--added transmitter &quot;+t);
<span class="nc" id="L606">        }</span>

        private void remove(Transmitter t) {
<span class="nc" id="L609">            synchronized(transmitters) {</span>
<span class="nc" id="L610">                int index = transmitters.indexOf(t);</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">                if (index &gt;= 0) {</span>
<span class="nc" id="L612">                    transmitters.remove(index);</span>
                    if (Printer.debug) Printer.debug(&quot;--removed transmitter &quot;+t);
                }
<span class="nc" id="L615">            }</span>
<span class="nc" id="L616">        }</span>

        private void receiverChanged(BasicTransmitter t,
                                     Receiver oldR,
                                     Receiver newR) {
<span class="nc" id="L621">            synchronized(transmitters) {</span>
                // some optimization
<span class="nc bnc" id="L623" title="All 2 branches missed.">                if (midiOutReceiver == oldR) {</span>
<span class="nc" id="L624">                    midiOutReceiver = null;</span>
                }
<span class="nc bnc" id="L626" title="All 2 branches missed.">                if (newR != null) {</span>
<span class="nc bnc" id="L627" title="All 4 branches missed.">                    if ((newR instanceof MidiOutDevice.MidiOutReceiver)</span>
                        &amp;&amp; (midiOutReceiver == null)) {
<span class="nc" id="L629">                        midiOutReceiver = ((MidiOutDevice.MidiOutReceiver) newR);</span>
                    }
                }
<span class="nc bnc" id="L632" title="All 2 branches missed.">                optimizedReceiverCount =</span>
                      ((midiOutReceiver!=null)?1:0);
<span class="nc" id="L634">            }</span>
            // more potential for optimization here
<span class="nc" id="L636">        }</span>


        /** closes all transmitters and empties the list */
        void close() {
<span class="nc" id="L641">            synchronized (transmitters) {</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">                for(int i = 0; i &lt; transmitters.size(); i++) {</span>
<span class="nc" id="L643">                    transmitters.get(i).close();</span>
                }
<span class="nc" id="L645">                transmitters.clear();</span>
<span class="nc" id="L646">            }</span>
            if (Printer.trace) Printer.trace(&quot;TransmitterList.close() succeeded&quot;);
<span class="nc" id="L648">        }</span>



        /**
        * Send this message to all receivers
        * status = packedMessage &amp; 0xFF
        * data1 = (packedMessage &amp; 0xFF00) &gt;&gt; 8;
        * data1 = (packedMessage &amp; 0xFF0000) &gt;&gt; 16;
        */
        void sendMessage(int packedMessage, long timeStamp) {
            try {
<span class="nc" id="L660">                synchronized(transmitters) {</span>
<span class="nc" id="L661">                    int size = transmitters.size();</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">                    if (optimizedReceiverCount == size) {</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">                        if (midiOutReceiver != null) {</span>
                            if (TRACE_TRANSMITTER) Printer.println(&quot;Sending packed message to MidiOutReceiver&quot;);
<span class="nc" id="L665">                            midiOutReceiver.sendPackedMidiMessage(packedMessage, timeStamp);</span>
                        }
                    } else {
                        if (TRACE_TRANSMITTER) Printer.println(&quot;Sending packed message to &quot;+size+&quot; transmitter's receivers&quot;);
<span class="nc bnc" id="L669" title="All 2 branches missed.">                        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L670">                            Receiver receiver = ((Transmitter)transmitters.get(i)).getReceiver();</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">                            if (receiver != null) {</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">                                if (optimizedReceiverCount &gt; 0) {</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                                    if (receiver instanceof MidiOutDevice.MidiOutReceiver) {</span>
<span class="nc" id="L674">                                        ((MidiOutDevice.MidiOutReceiver) receiver).sendPackedMidiMessage(packedMessage, timeStamp);</span>
                                    } else {
<span class="nc" id="L676">                                        receiver.send(new FastShortMessage(packedMessage), timeStamp);</span>
                                    }
                                } else {
<span class="nc" id="L679">                                    receiver.send(new FastShortMessage(packedMessage), timeStamp);</span>
                                }
                            }
                        }
                    }
<span class="nc" id="L684">                }</span>
<span class="nc" id="L685">            } catch (InvalidMidiDataException e) {</span>
                // this happens when invalid data comes over the wire. Ignore it.
<span class="nc" id="L687">            }</span>
<span class="nc" id="L688">        }</span>

        void sendMessage(byte[] data, long timeStamp) {
            try {
<span class="nc" id="L692">                synchronized(transmitters) {</span>
<span class="nc" id="L693">                    int size = transmitters.size();</span>
                    if (TRACE_TRANSMITTER) Printer.println(&quot;Sending long message to &quot;+size+&quot; transmitter's receivers&quot;);
<span class="nc bnc" id="L695" title="All 2 branches missed.">                    for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L696">                        Receiver receiver = ((Transmitter)transmitters.get(i)).getReceiver();</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">                        if (receiver != null) {</span>
                            //$$fb 2002-04-02: SysexMessages are mutable, so
                            // an application could change the contents of this object,
                            // or try to use the object later. So we can't get around object creation
                            // But the array need not be unique for each FastSysexMessage object,
                            // because it cannot be modified.
<span class="nc" id="L703">                            receiver.send(new FastSysexMessage(data), timeStamp);</span>
                        }
                    }
<span class="nc" id="L706">                }</span>
<span class="nc" id="L707">            } catch (InvalidMidiDataException e) {</span>
                // this happens when invalid data comes over the wire. Ignore it.
<span class="nc" id="L709">                return;</span>
<span class="nc" id="L710">            }</span>
<span class="nc" id="L711">        }</span>


        /**
        * Send this message to all transmitters
        */
        void sendMessage(MidiMessage message, long timeStamp) {
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if (message instanceof FastShortMessage) {</span>
<span class="nc" id="L719">                sendMessage(((FastShortMessage) message).getPackedMsg(), timeStamp);</span>
<span class="nc" id="L720">                return;</span>
            }
<span class="nc" id="L722">            synchronized(transmitters) {</span>
<span class="nc" id="L723">                int size = transmitters.size();</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                if (optimizedReceiverCount == size) {</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                    if (midiOutReceiver != null) {</span>
                        if (TRACE_TRANSMITTER) Printer.println(&quot;Sending MIDI message to MidiOutReceiver&quot;);
<span class="nc" id="L727">                        midiOutReceiver.send(message, timeStamp);</span>
                    }
                } else {
                    if (TRACE_TRANSMITTER) Printer.println(&quot;Sending MIDI message to &quot;+size+&quot; transmitter's receivers&quot;);
<span class="nc bnc" id="L731" title="All 2 branches missed.">                    for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L732">                        Receiver receiver = ((Transmitter)transmitters.get(i)).getReceiver();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                        if (receiver != null) {</span>
                            //$$fb 2002-04-02: ShortMessages are mutable, so
                            // an application could change the contents of this object,
                            // or try to use the object later.
                            // We violate this spec here, to avoid costly (and gc-intensive)
                            // object creation for potentially hundred of messages per second.
                            // The spec should be changed to allow Immutable MidiMessages
                            // (i.e. throws InvalidStateException or so in setMessage)
<span class="nc" id="L741">                            receiver.send(message, timeStamp);</span>
                        }
                    }
                }
<span class="nc" id="L745">            }</span>
<span class="nc" id="L746">        }</span>


    } // TransmitterList

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>