<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AiffFileReader.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">AiffFileReader.java</span></div><h1>AiffFileReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.UnsupportedAudioFileException;


/**
 * AIFF file reader and writer.
 *
 * @author Kara Kytle
 * @author Jan Borgersen
 * @author Florian Bomers
 */
<span class="nc" id="L50">public final class AiffFileReader extends SunFileReader {</span>

    private static final int MAX_READ_LENGTH = 8;

    // METHODS TO IMPLEMENT AudioFileReader

    /**
     * Obtains the audio file format of the input stream provided.  The stream must
     * point to valid audio file data.  In general, audio file providers may
     * need to read some data from the stream before determining whether they
     * support it.  These parsers must
     * be able to mark the stream, read enough data to determine whether they
     * support the stream, and, if not, reset the stream's read pointer to its original
     * position.  If the input stream does not support this, this method may fail
     * with an IOException.
     * @param stream the input stream from which file format information should be
     * extracted
     * @return an &lt;code&gt;AudioFileFormat&lt;/code&gt; object describing the audio file format
     * @throws UnsupportedAudioFileException if the stream does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     * @see InputStream#markSupported
     * @see InputStream#mark
     */
    public AudioFileFormat getAudioFileFormat(InputStream stream) throws UnsupportedAudioFileException, IOException {
        // fix for 4489272: AudioSystem.getAudioFileFormat() fails for InputStream, but works for URL
<span class="nc" id="L76">        AudioFileFormat aff = getCOMM(stream, true);</span>
        // the following is not strictly necessary - but was implemented like that in 1.3.0 - 1.4.1
        // so I leave it as it was. May remove this for 1.5.0
<span class="nc" id="L79">        stream.reset();</span>
<span class="nc" id="L80">        return aff;</span>
    }


    /**
     * Obtains the audio file format of the URL provided.  The URL must
     * point to valid audio file data.
     * @param url the URL from which file format information should be
     * extracted
     * @return an &lt;code&gt;AudioFileFormat&lt;/code&gt; object describing the audio file format
     * @throws UnsupportedAudioFileException if the URL does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     */
    public AudioFileFormat getAudioFileFormat(URL url) throws UnsupportedAudioFileException, IOException {
<span class="nc" id="L95">        AudioFileFormat fileFormat = null;</span>
<span class="nc" id="L96">        InputStream urlStream = url.openStream();       // throws IOException</span>
        try {
<span class="nc" id="L98">            fileFormat = getCOMM(urlStream, false);</span>
        } finally {
<span class="nc" id="L100">            urlStream.close();</span>
<span class="nc" id="L101">        }</span>
<span class="nc" id="L102">        return fileFormat;</span>
    }


    /**
     * Obtains the audio file format of the File provided.  The File must
     * point to valid audio file data.
     * @param file the File from which file format information should be
     * extracted
     * @return an &lt;code&gt;AudioFileFormat&lt;/code&gt; object describing the audio file format
     * @throws UnsupportedAudioFileException if the File does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     */
    public AudioFileFormat getAudioFileFormat(File file) throws UnsupportedAudioFileException, IOException {
<span class="nc" id="L117">        AudioFileFormat fileFormat = null;</span>
<span class="nc" id="L118">        FileInputStream fis = new FileInputStream(file);       // throws IOException</span>
        // part of fix for 4325421
        try {
<span class="nc" id="L121">            fileFormat = getCOMM(fis, false);</span>
        } finally {
<span class="nc" id="L123">            fis.close();</span>
<span class="nc" id="L124">        }</span>

<span class="nc" id="L126">        return fileFormat;</span>
    }




    /**
     * Obtains an audio stream from the input stream provided.  The stream must
     * point to valid audio file data.  In general, audio file providers may
     * need to read some data from the stream before determining whether they
     * support it.  These parsers must
     * be able to mark the stream, read enough data to determine whether they
     * support the stream, and, if not, reset the stream's read pointer to its original
     * position.  If the input stream does not support this, this method may fail
     * with an IOException.
     * @param stream the input stream from which the &lt;code&gt;AudioInputStream&lt;/code&gt; should be
     * constructed
     * @return an &lt;code&gt;AudioInputStream&lt;/code&gt; object based on the audio file data contained
     * in the input stream.
     * @throws UnsupportedAudioFileException if the stream does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     * @see InputStream#markSupported
     * @see InputStream#mark
     */
    public AudioInputStream getAudioInputStream(InputStream stream) throws UnsupportedAudioFileException, IOException {
        // getCOMM leaves the input stream at the beginning of the audio data
<span class="nc" id="L153">        AudioFileFormat fileFormat = getCOMM(stream, true);     // throws UnsupportedAudioFileException, IOException</span>

        // we've got everything, and the stream is at the
        // beginning of the audio data, so return an AudioInputStream.
<span class="nc" id="L157">        return new AudioInputStream(stream, fileFormat.getFormat(), fileFormat.getFrameLength());</span>
    }


    /**
     * Obtains an audio stream from the URL provided.  The URL must
     * point to valid audio file data.
     * @param url the URL for which the &lt;code&gt;AudioInputStream&lt;/code&gt; should be
     * constructed
     * @return an &lt;code&gt;AudioInputStream&lt;/code&gt; object based on the audio file data pointed
     * to by the URL
     * @throws UnsupportedAudioFileException if the URL does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     */
    public AudioInputStream getAudioInputStream(URL url) throws UnsupportedAudioFileException, IOException {
<span class="nc" id="L173">        InputStream urlStream = url.openStream();  // throws IOException</span>
<span class="nc" id="L174">        AudioFileFormat fileFormat = null;</span>
        try {
<span class="nc" id="L176">            fileFormat = getCOMM(urlStream, false);</span>
        } finally {
<span class="nc bnc" id="L178" title="All 4 branches missed.">            if (fileFormat == null) {</span>
<span class="nc" id="L179">                urlStream.close();</span>
            }
        }
<span class="nc" id="L182">        return new AudioInputStream(urlStream, fileFormat.getFormat(), fileFormat.getFrameLength());</span>
    }


    /**
     * Obtains an audio stream from the File provided.  The File must
     * point to valid audio file data.
     * @param file the File for which the &lt;code&gt;AudioInputStream&lt;/code&gt; should be
     * constructed
     * @return an &lt;code&gt;AudioInputStream&lt;/code&gt; object based on the audio file data pointed
     * to by the File
     * @throws UnsupportedAudioFileException if the File does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     */
    public AudioInputStream getAudioInputStream(File file)
        throws UnsupportedAudioFileException, IOException {

<span class="nc" id="L200">        FileInputStream fis = new FileInputStream(file); // throws IOException</span>
<span class="nc" id="L201">        AudioFileFormat fileFormat = null;</span>
        // part of fix for 4325421
        try {
<span class="nc" id="L204">            fileFormat = getCOMM(fis, false);</span>
        } finally {
<span class="nc bnc" id="L206" title="All 4 branches missed.">            if (fileFormat == null) {</span>
<span class="nc" id="L207">                fis.close();</span>
            }
        }
<span class="nc" id="L210">        return new AudioInputStream(fis, fileFormat.getFormat(), fileFormat.getFrameLength());</span>
    }

    //--------------------------------------------------------------------

    private AudioFileFormat getCOMM(InputStream is, boolean doReset)
        throws UnsupportedAudioFileException, IOException {

<span class="nc" id="L218">        DataInputStream dis = new DataInputStream(is);</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (doReset) {</span>
<span class="nc" id="L221">            dis.mark(MAX_READ_LENGTH);</span>
        }

        // assumes a stream at the beginning of the file which has already
        // passed the magic number test...
        // leaves the input stream at the beginning of the audio data
<span class="nc" id="L227">        int fileRead = 0;</span>
<span class="nc" id="L228">        int dataLength = 0;</span>
<span class="nc" id="L229">        AudioFormat format = null;</span>

        // Read the magic number
<span class="nc" id="L232">        int magic = dis.readInt();</span>

        // $$fb: fix for 4369044: javax.sound.sampled.AudioSystem.getAudioInputStream() works wrong with Cp037
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (magic != AiffFileFormat.AIFF_MAGIC) {</span>
            // not AIFF, throw exception
<span class="nc bnc" id="L237" title="All 2 branches missed.">            if (doReset) {</span>
<span class="nc" id="L238">                dis.reset();</span>
            }
<span class="nc" id="L240">            throw new UnsupportedAudioFileException(&quot;not an AIFF file&quot;);</span>
        }

<span class="nc" id="L243">        int length = dis.readInt();</span>
<span class="nc" id="L244">        int iffType = dis.readInt();</span>
<span class="nc" id="L245">        fileRead += 12;</span>

        int totallength;
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if(length &lt;= 0 ) {</span>
<span class="nc" id="L249">            length = AudioSystem.NOT_SPECIFIED;</span>
<span class="nc" id="L250">            totallength = AudioSystem.NOT_SPECIFIED;</span>
        } else {
<span class="nc" id="L252">            totallength = length + 8;</span>
        }

        // Is this an AIFC or just plain AIFF file.
<span class="nc" id="L256">        boolean aifc = false;</span>
        // $$fb: fix for 4369044: javax.sound.sampled.AudioSystem.getAudioInputStream() works wrong with Cp037
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (iffType ==  AiffFileFormat.AIFC_MAGIC) {</span>
<span class="nc" id="L259">            aifc = true;</span>
        }

        // Loop through the AIFF chunks until
        // we get to the SSND chunk.
<span class="nc" id="L264">        boolean ssndFound = false;</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        while (!ssndFound) {</span>
            // Read the chunk name
<span class="nc" id="L267">            int chunkName = dis.readInt();</span>
<span class="nc" id="L268">            int chunkLen = dis.readInt();</span>
<span class="nc" id="L269">            fileRead += 8;</span>

<span class="nc" id="L271">            int chunkRead = 0;</span>

            // Switch on the chunk name.
<span class="nc bnc" id="L274" title="All 4 branches missed.">            switch (chunkName) {</span>
            case AiffFileFormat.FVER_MAGIC:
                // Ignore format version for now.
<span class="nc" id="L277">                break;</span>

            case AiffFileFormat.COMM_MAGIC:
                // AIFF vs. AIFC
                // $$fb: fix for 4399551: Repost of bug candidate: cannot replay aif file (Review ID: 108108)
<span class="nc bnc" id="L282" title="All 8 branches missed.">                if ((!aifc &amp;&amp; chunkLen &lt; 18) || (aifc &amp;&amp; chunkLen &lt; 22)) {</span>
<span class="nc" id="L283">                    throw new UnsupportedAudioFileException(&quot;Invalid AIFF/COMM chunksize&quot;);</span>
                }
                // Read header info.
<span class="nc" id="L286">                int channels = dis.readUnsignedShort();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                if (channels &lt;= 0) {</span>
<span class="nc" id="L288">                    throw new UnsupportedAudioFileException(&quot;Invalid number of channels&quot;);</span>
                }
<span class="nc" id="L290">                dis.readInt(); // numSampleFrames</span>
<span class="nc" id="L291">                int sampleSizeInBits = dis.readUnsignedShort();</span>
<span class="nc bnc" id="L292" title="All 4 branches missed.">                if (sampleSizeInBits &lt; 1 || sampleSizeInBits &gt; 32) {</span>
<span class="nc" id="L293">                    throw new UnsupportedAudioFileException(&quot;Invalid AIFF/COMM sampleSize&quot;);</span>
                }
<span class="nc" id="L295">                float sampleRate = (float) read_ieee_extended(dis);</span>
<span class="nc" id="L296">                chunkRead += (2 + 4 + 2 + 10);</span>

                // If this is not AIFC then we assume it's
                // a linearly encoded file.
<span class="nc" id="L300">                AudioFormat.Encoding encoding = AudioFormat.Encoding.PCM_SIGNED;</span>

<span class="nc bnc" id="L302" title="All 2 branches missed.">                if (aifc) {</span>
<span class="nc" id="L303">                    int enc = dis.readInt(); chunkRead += 4;</span>
<span class="nc bnc" id="L304" title="All 3 branches missed.">                    switch (enc) {</span>
                    case AiffFileFormat.AIFC_PCM:
<span class="nc" id="L306">                        encoding = AudioFormat.Encoding.PCM_SIGNED;</span>
<span class="nc" id="L307">                        break;</span>
                    case AiffFileFormat.AIFC_ULAW:
<span class="nc" id="L309">                        encoding = AudioFormat.Encoding.ULAW;</span>
<span class="nc" id="L310">                        sampleSizeInBits = 8; // Java Sound convention</span>
<span class="nc" id="L311">                        break;</span>
                    default:
<span class="nc" id="L313">                        throw new UnsupportedAudioFileException(&quot;Invalid AIFF encoding&quot;);</span>
                    }
                }
<span class="nc" id="L316">                int frameSize = calculatePCMFrameSize(sampleSizeInBits, channels);</span>
                //$fb what's that ??
                //if (sampleSizeInBits == 8) {
                //    encoding = AudioFormat.Encoding.PCM_SIGNED;
                //}
<span class="nc" id="L321">                format =  new AudioFormat(encoding, sampleRate,</span>
                                          sampleSizeInBits, channels,
                                          frameSize, sampleRate, true);
<span class="nc" id="L324">                break;</span>
            case AiffFileFormat.SSND_MAGIC:
                // Data chunk.
                // we are getting *weird* numbers for chunkLen sometimes;
                // this really should be the size of the data chunk....
<span class="nc" id="L329">                int dataOffset = dis.readInt();</span>
<span class="nc" id="L330">                int blocksize = dis.readInt();</span>
<span class="nc" id="L331">                chunkRead += 8;</span>

                // okay, now we are done reading the header.  we need to set the size
                // of the data segment.  we know that sometimes the value we get for
                // the chunksize is absurd.  this is the best i can think of:if the
                // value seems okay, use it.  otherwise, we get our value of
                // length by assuming that everything left is the data segment;
                // its length should be our original length (for all AIFF data chunks)
                // minus what we've read so far.
                // $$kk: we should be able to get length for the data chunk right after
                // we find &quot;SSND.&quot;  however, some aiff files give *weird* numbers.  what
                // is going on??

<span class="nc bnc" id="L344" title="All 2 branches missed.">                if (chunkLen &lt; length) {</span>
<span class="nc" id="L345">                    dataLength = chunkLen - chunkRead;</span>
                } else {
                    // $$kk: 11.03.98: this seems dangerous!
<span class="nc" id="L348">                    dataLength = length - (fileRead + chunkRead);</span>
                }
<span class="nc" id="L350">                ssndFound = true;</span>
                break;
            } // switch
<span class="nc" id="L353">            fileRead += chunkRead;</span>
            // skip the remainder of this chunk
<span class="nc bnc" id="L355" title="All 2 branches missed.">            if (!ssndFound) {</span>
<span class="nc" id="L356">                int toSkip = chunkLen - chunkRead;</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">                if (toSkip &gt; 0) {</span>
<span class="nc" id="L358">                    fileRead += dis.skipBytes(toSkip);</span>
                }
            }
<span class="nc" id="L361">        } // while</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (format == null) {</span>
<span class="nc" id="L364">            throw new UnsupportedAudioFileException(&quot;missing COMM chunk&quot;);</span>
        }
<span class="nc bnc" id="L366" title="All 2 branches missed.">        AudioFileFormat.Type type = aifc?AudioFileFormat.Type.AIFC:AudioFileFormat.Type.AIFF;</span>

<span class="nc" id="L368">        return new AiffFileFormat(type, totallength, format, dataLength / format.getFrameSize());</span>
    }

    // HELPER METHODS
    /** write_ieee_extended(DataOutputStream dos, double f) throws IOException {
     * Extended precision IEEE floating-point conversion routine.
     * @argument DataOutputStream
     * @argument double
     * @return void
     * @exception IOException
     */
    private void write_ieee_extended(DataOutputStream dos, double f) throws IOException {

<span class="nc" id="L381">        int exponent = 16398;</span>
<span class="nc" id="L382">        double highMantissa = f;</span>

        // For now write the integer portion of f
        // $$jb: 03.30.99: stay in synch with JMF on this!!!!
<span class="nc bnc" id="L386" title="All 2 branches missed.">        while (highMantissa &lt; 44000) {</span>
<span class="nc" id="L387">            highMantissa *= 2;</span>
<span class="nc" id="L388">            exponent--;</span>
        }
<span class="nc" id="L390">        dos.writeShort(exponent);</span>
<span class="nc" id="L391">        dos.writeInt( ((int) highMantissa) &lt;&lt; 16);</span>
<span class="nc" id="L392">        dos.writeInt(0); // low Mantissa</span>
<span class="nc" id="L393">    }</span>


    /**
     * read_ieee_extended
     * Extended precision IEEE floating-point conversion routine.
     * @argument DataInputStream
     * @return double
     * @exception IOException
     */
    private double read_ieee_extended(DataInputStream dis) throws IOException {

<span class="nc" id="L405">        double f = 0;</span>
<span class="nc" id="L406">        int expon = 0;</span>
<span class="nc" id="L407">        long hiMant = 0, loMant = 0;</span>
        long t1, t2;
<span class="nc" id="L409">        double HUGE = ((double)3.40282346638528860e+38);</span>


<span class="nc" id="L412">        expon = dis.readUnsignedShort();</span>

<span class="nc" id="L414">        t1 = (long)dis.readUnsignedShort();</span>
<span class="nc" id="L415">        t2 = (long)dis.readUnsignedShort();</span>
<span class="nc" id="L416">        hiMant = t1 &lt;&lt; 16 | t2;</span>

<span class="nc" id="L418">        t1 = (long)dis.readUnsignedShort();</span>
<span class="nc" id="L419">        t2 = (long)dis.readUnsignedShort();</span>
<span class="nc" id="L420">        loMant = t1 &lt;&lt; 16 | t2;</span>

<span class="nc bnc" id="L422" title="All 6 branches missed.">        if (expon == 0 &amp;&amp; hiMant == 0 &amp;&amp; loMant == 0) {</span>
<span class="nc" id="L423">            f = 0;</span>
        } else {
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (expon == 0x7FFF)</span>
<span class="nc" id="L426">                f = HUGE;</span>
            else {
<span class="nc" id="L428">                expon -= 16383;</span>
<span class="nc" id="L429">                expon -= 31;</span>
<span class="nc" id="L430">                f = (hiMant * Math.pow(2, expon));</span>
<span class="nc" id="L431">                expon -= 32;</span>
<span class="nc" id="L432">                f += (loMant * Math.pow(2, expon));</span>
            }
        }

<span class="nc" id="L436">        return f;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>