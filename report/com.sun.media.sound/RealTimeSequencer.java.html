<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RealTimeSequencer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">RealTimeSequencer.java</span></div><h1>RealTimeSequencer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import java.io.IOException;
import java.io.InputStream;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;

import javax.sound.midi.*;


/**
 * A Real Time Sequencer
 *
 * @author Florian Bomers
 */

/* TODO:
 * - rename PlayThread to PlayEngine (because isn't a thread)
 */
final class RealTimeSequencer extends AbstractMidiDevice
        implements Sequencer, AutoConnectSequencer {

    // STATIC VARIABLES

    /** debugging flags */
    private final static boolean DEBUG_PUMP = false;
    private final static boolean DEBUG_PUMP_ALL = false;

    /**
     * Event Dispatcher thread. Should be using a shared event
     * dispatcher instance with a factory in EventDispatcher
     */
<span class="nc" id="L61">    private static final Map&lt;ThreadGroup, EventDispatcher&gt; dispatchers =</span>
            new WeakHashMap&lt;&gt;();

    /**
     * All RealTimeSequencers share this info object.
     */
<span class="nc" id="L67">    static final RealTimeSequencerInfo info = new RealTimeSequencerInfo();</span>


<span class="nc" id="L70">    private static final Sequencer.SyncMode[] masterSyncModes = { Sequencer.SyncMode.INTERNAL_CLOCK };</span>
<span class="nc" id="L71">    private static final Sequencer.SyncMode[] slaveSyncModes  = { Sequencer.SyncMode.NO_SYNC };</span>

<span class="nc" id="L73">    private static final Sequencer.SyncMode masterSyncMode    = Sequencer.SyncMode.INTERNAL_CLOCK;</span>
<span class="nc" id="L74">    private static final Sequencer.SyncMode slaveSyncMode     = Sequencer.SyncMode.NO_SYNC;</span>


    /**
     * Sequence on which this sequencer is operating.
     */
<span class="nc" id="L80">    private Sequence sequence = null;</span>

    // caches

    /**
     * Same for setTempoInMPQ...
     * -1 means not set.
     */
<span class="nc" id="L88">    private double cacheTempoMPQ = -1;</span>


    /**
     * cache value for tempo factor until sequence is set
     * -1 means not set.
     */
<span class="nc" id="L95">    private float cacheTempoFactor = -1;</span>


    /** if a particular track is muted */
<span class="nc" id="L99">    private boolean[] trackMuted = null;</span>
    /** if a particular track is solo */
<span class="nc" id="L101">    private boolean[] trackSolo = null;</span>

    /** tempo cache for getMicrosecondPosition */
<span class="nc" id="L104">    private final MidiUtils.TempoCache tempoCache = new MidiUtils.TempoCache();</span>

    /**
     * True if the sequence is running.
     */
<span class="nc" id="L109">    private boolean running = false;</span>


    /** the thread for pushing out the MIDI messages */
    private PlayThread playThread;


    /**
     * True if we are recording
     */
<span class="nc" id="L119">    private boolean recording = false;</span>


    /**
     * List of tracks to which we're recording
     */
<span class="nc" id="L125">    private final List recordingTracks = new ArrayList();</span>


<span class="nc" id="L128">    private long loopStart = 0;</span>
<span class="nc" id="L129">    private long loopEnd = -1;</span>
<span class="nc" id="L130">    private int loopCount = 0;</span>


    /**
     * Meta event listeners
     */
<span class="nc" id="L136">    private final ArrayList metaEventListeners = new ArrayList();</span>


    /**
     * Control change listeners
     */
<span class="nc" id="L142">    private final ArrayList controllerEventListeners = new ArrayList();</span>


    /** automatic connection support */
<span class="nc" id="L146">    private boolean autoConnect = false;</span>

    /** if we need to autoconnect at next open */
<span class="nc" id="L149">    private boolean doAutoConnectAtNextOpen = false;</span>

    /** the receiver that this device is auto-connected to */
<span class="nc" id="L152">    Receiver autoConnectedReceiver = null;</span>


    /* ****************************** CONSTRUCTOR ****************************** */

    RealTimeSequencer() throws MidiUnavailableException {
<span class="nc" id="L158">        super(info);</span>

        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer CONSTRUCTOR&quot;);
        if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer CONSTRUCTOR completed&quot;);
<span class="nc" id="L162">    }</span>


    /* ****************************** SEQUENCER METHODS ******************** */

    public synchronized void setSequence(Sequence sequence)
        throws InvalidMidiDataException {

        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setSequence(&quot; + sequence +&quot;)&quot;);

<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (sequence != this.sequence) {</span>
<span class="nc bnc" id="L173" title="All 4 branches missed.">            if (this.sequence != null &amp;&amp; sequence == null) {</span>
<span class="nc" id="L174">                setCaches();</span>
<span class="nc" id="L175">                stop();</span>
                // initialize some non-cached values
<span class="nc" id="L177">                trackMuted = null;</span>
<span class="nc" id="L178">                trackSolo = null;</span>
<span class="nc" id="L179">                loopStart = 0;</span>
<span class="nc" id="L180">                loopEnd = -1;</span>
<span class="nc" id="L181">                loopCount = 0;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                if (getDataPump() != null) {</span>
<span class="nc" id="L183">                    getDataPump().setTickPos(0);</span>
<span class="nc" id="L184">                    getDataPump().resetLoopCount();</span>
                }
            }

<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (playThread != null) {</span>
<span class="nc" id="L189">                playThread.setSequence(sequence);</span>
            }

            // store this sequence (do not copy - we want to give the possibility
            // of modifying the sequence at runtime)
<span class="nc" id="L194">            this.sequence = sequence;</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">            if (sequence != null) {</span>
<span class="nc" id="L197">                tempoCache.refresh(sequence);</span>
                // rewind to the beginning
<span class="nc" id="L199">                setTickPosition(0);</span>
                // propagate caches
<span class="nc" id="L201">                propagateCaches();</span>
            }
        }
<span class="nc bnc" id="L204" title="All 2 branches missed.">        else if (sequence != null) {</span>
<span class="nc" id="L205">            tempoCache.refresh(sequence);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (playThread != null) {</span>
<span class="nc" id="L207">                playThread.setSequence(sequence);</span>
            }
        }

        if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: setSequence(&quot; + sequence +&quot;) completed&quot;);
<span class="nc" id="L212">    }</span>


    public synchronized void setSequence(InputStream stream) throws IOException, InvalidMidiDataException {

        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setSequence(&quot; + stream +&quot;)&quot;);

<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L220">            setSequence((Sequence) null);</span>
<span class="nc" id="L221">            return;</span>
        }

<span class="nc" id="L224">        Sequence seq = MidiSystem.getSequence(stream); // can throw IOException, InvalidMidiDataException</span>

<span class="nc" id="L226">        setSequence(seq);</span>

        if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: setSequence(&quot; + stream +&quot;) completed&quot;);

<span class="nc" id="L230">    }</span>


    public Sequence getSequence() {
<span class="nc" id="L234">        return sequence;</span>
    }


    public synchronized void start() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: start()&quot;);

        // sequencer not open: throw an exception
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (!isOpen()) {</span>
<span class="nc" id="L243">            throw new IllegalStateException(&quot;sequencer not open&quot;);</span>
        }

        // sequence not available: throw an exception
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (sequence == null) {</span>
<span class="nc" id="L248">            throw new IllegalStateException(&quot;sequence not set&quot;);</span>
        }

        // already running: return quietly
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (running == true) {</span>
<span class="nc" id="L253">            return;</span>
        }

        // start playback
<span class="nc" id="L257">        implStart();</span>

        if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: start() completed&quot;);
<span class="nc" id="L260">    }</span>


    public synchronized void stop() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: stop()&quot;);

<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (!isOpen()) {</span>
<span class="nc" id="L267">            throw new IllegalStateException(&quot;sequencer not open&quot;);</span>
        }
<span class="nc" id="L269">        stopRecording();</span>

        // not running; just return
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (running == false) {</span>
            if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: stop() not running!&quot;);
<span class="nc" id="L274">            return;</span>
        }

        // stop playback
<span class="nc" id="L278">        implStop();</span>

        if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: stop() completed&quot;);
<span class="nc" id="L281">    }</span>


    public boolean isRunning() {
<span class="nc" id="L285">        return running;</span>
    }


    public void startRecording() {
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (!isOpen()) {</span>
<span class="nc" id="L291">            throw new IllegalStateException(&quot;Sequencer not open&quot;);</span>
        }

<span class="nc" id="L294">        start();</span>
<span class="nc" id="L295">        recording = true;</span>
<span class="nc" id="L296">    }</span>


    public void stopRecording() {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (!isOpen()) {</span>
<span class="nc" id="L301">            throw new IllegalStateException(&quot;Sequencer not open&quot;);</span>
        }
<span class="nc" id="L303">        recording = false;</span>
<span class="nc" id="L304">    }</span>


    public boolean isRecording() {
<span class="nc" id="L308">        return recording;</span>
    }


    public void recordEnable(Track track, int channel) {
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (!findTrack(track)) {</span>
<span class="nc" id="L314">            throw new IllegalArgumentException(&quot;Track does not exist in the current sequence&quot;);</span>
        }

<span class="nc" id="L317">        synchronized(recordingTracks) {</span>
<span class="nc" id="L318">            RecordingTrack rc = RecordingTrack.get(recordingTracks, track);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (rc != null) {</span>
<span class="nc" id="L320">                rc.channel = channel;</span>
            } else {
<span class="nc" id="L322">                recordingTracks.add(new RecordingTrack(track, channel));</span>
            }
<span class="nc" id="L324">        }</span>

<span class="nc" id="L326">    }</span>


    public void recordDisable(Track track) {
<span class="nc" id="L330">        synchronized(recordingTracks) {</span>
<span class="nc" id="L331">            RecordingTrack rc = RecordingTrack.get(recordingTracks, track);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (rc != null) {</span>
<span class="nc" id="L333">                recordingTracks.remove(rc);</span>
            }
<span class="nc" id="L335">        }</span>

<span class="nc" id="L337">    }</span>


    private boolean findTrack(Track track) {
<span class="nc" id="L341">        boolean found = false;</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (sequence != null) {</span>
<span class="nc" id="L343">            Track[] tracks = sequence.getTracks();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            for (int i = 0; i &lt; tracks.length; i++) {</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                if (track == tracks[i]) {</span>
<span class="nc" id="L346">                    found = true;</span>
<span class="nc" id="L347">                    break;</span>
                }
            }
        }
<span class="nc" id="L351">        return found;</span>
    }


    public float getTempoInBPM() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTempoInBPM() &quot;);

<span class="nc" id="L358">        return (float) MidiUtils.convertTempo(getTempoInMPQ());</span>
    }


    public void setTempoInBPM(float bpm) {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTempoInBPM() &quot;);
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (bpm &lt;= 0) {</span>
            // should throw IllegalArgumentException
<span class="nc" id="L366">            bpm = 1.0f;</span>
        }

<span class="nc" id="L369">        setTempoInMPQ((float) MidiUtils.convertTempo((double) bpm));</span>
<span class="nc" id="L370">    }</span>


    public float getTempoInMPQ() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTempoInMPQ() &quot;);

<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (needCaching()) {</span>
            // if the sequencer is closed, return cached value
<span class="nc bnc" id="L378" title="All 2 branches missed.">            if (cacheTempoMPQ != -1) {</span>
<span class="nc" id="L379">                return (float) cacheTempoMPQ;</span>
            }
            // if sequence is set, return current tempo
<span class="nc bnc" id="L382" title="All 2 branches missed.">            if (sequence != null) {</span>
<span class="nc" id="L383">                return tempoCache.getTempoMPQAt(getTickPosition());</span>
            }

            // last resort: return a standard tempo: 120bpm
<span class="nc" id="L387">            return (float) MidiUtils.DEFAULT_TEMPO_MPQ;</span>
        }
<span class="nc" id="L389">        return (float)getDataPump().getTempoMPQ();</span>
    }


    public void setTempoInMPQ(float mpq) {
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (mpq &lt;= 0) {</span>
            // should throw IllegalArgumentException
<span class="nc" id="L396">            mpq = 1.0f;</span>
        }

        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTempoInMPQ() &quot;);

<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (needCaching()) {</span>
            // cache the value
<span class="nc" id="L403">            cacheTempoMPQ = mpq;</span>
        } else {
            // set the native tempo in MPQ
<span class="nc" id="L406">            getDataPump().setTempoMPQ(mpq);</span>

            // reset the tempoInBPM and tempoInMPQ values so we won't use them again
<span class="nc" id="L409">            cacheTempoMPQ = -1;</span>
        }
<span class="nc" id="L411">    }</span>


    public void setTempoFactor(float factor) {
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (factor &lt;= 0) {</span>
            // should throw IllegalArgumentException
<span class="nc" id="L417">            return;</span>
        }

        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTempoFactor() &quot;);

<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (needCaching()) {</span>
<span class="nc" id="L423">            cacheTempoFactor = factor;</span>
        } else {
<span class="nc" id="L425">            getDataPump().setTempoFactor(factor);</span>
            // don't need cache anymore
<span class="nc" id="L427">            cacheTempoFactor = -1;</span>
        }
<span class="nc" id="L429">    }</span>


    public float getTempoFactor() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTempoFactor() &quot;);

<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (needCaching()) {</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            if (cacheTempoFactor != -1) {</span>
<span class="nc" id="L437">                return cacheTempoFactor;</span>
            }
<span class="nc" id="L439">            return 1.0f;</span>
        }
<span class="nc" id="L441">        return getDataPump().getTempoFactor();</span>
    }


    public long getTickLength() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTickLength() &quot;);

<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (sequence == null) {</span>
<span class="nc" id="L449">            return 0;</span>
        }

<span class="nc" id="L452">        return sequence.getTickLength();</span>
    }


    public synchronized long getTickPosition() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTickPosition() &quot;);

<span class="nc bnc" id="L459" title="All 4 branches missed.">        if (getDataPump() == null || sequence == null) {</span>
<span class="nc" id="L460">            return 0;</span>
        }

<span class="nc" id="L463">        return getDataPump().getTickPos();</span>
    }


    public synchronized void setTickPosition(long tick) {
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (tick &lt; 0) {</span>
            // should throw IllegalArgumentException
<span class="nc" id="L470">            return;</span>
        }

        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTickPosition(&quot;+tick+&quot;) &quot;);

<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (getDataPump() == null) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">            if (tick != 0) {</span>
                // throw new InvalidStateException(&quot;cannot set position in closed state&quot;);
            }
        }
<span class="nc bnc" id="L480" title="All 2 branches missed.">        else if (sequence == null) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (tick != 0) {</span>
                // throw new InvalidStateException(&quot;cannot set position if sequence is not set&quot;);
            }
        } else {
<span class="nc" id="L485">            getDataPump().setTickPos(tick);</span>
        }
<span class="nc" id="L487">    }</span>


    public long getMicrosecondLength() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getMicrosecondLength() &quot;);

<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (sequence == null) {</span>
<span class="nc" id="L494">            return 0;</span>
        }

<span class="nc" id="L497">        return sequence.getMicrosecondLength();</span>
    }


    public long getMicrosecondPosition() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getMicrosecondPosition() &quot;);

<span class="nc bnc" id="L504" title="All 4 branches missed.">        if (getDataPump() == null || sequence == null) {</span>
<span class="nc" id="L505">            return 0;</span>
        }
<span class="nc" id="L507">        synchronized (tempoCache) {</span>
<span class="nc" id="L508">            return MidiUtils.tick2microsecond(sequence, getDataPump().getTickPos(), tempoCache);</span>
<span class="nc" id="L509">        }</span>
    }


    public void setMicrosecondPosition(long microseconds) {
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (microseconds &lt; 0) {</span>
            // should throw IllegalArgumentException
<span class="nc" id="L516">            return;</span>
        }

        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setMicrosecondPosition(&quot;+microseconds+&quot;) &quot;);

<span class="nc bnc" id="L521" title="All 2 branches missed.">        if (getDataPump() == null) {</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">            if (microseconds != 0) {</span>
                // throw new InvalidStateException(&quot;cannot set position in closed state&quot;);
            }
        }
<span class="nc bnc" id="L526" title="All 2 branches missed.">        else if (sequence == null) {</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">            if (microseconds != 0) {</span>
                // throw new InvalidStateException(&quot;cannot set position if sequence is not set&quot;);
            }
        } else {
<span class="nc" id="L531">            synchronized(tempoCache) {</span>
<span class="nc" id="L532">                setTickPosition(MidiUtils.microsecond2tick(sequence, microseconds, tempoCache));</span>
<span class="nc" id="L533">            }</span>
        }
<span class="nc" id="L535">    }</span>


    public void setMasterSyncMode(Sequencer.SyncMode sync) {
        // not supported
<span class="nc" id="L540">    }</span>


    public Sequencer.SyncMode getMasterSyncMode() {
<span class="nc" id="L544">        return masterSyncMode;</span>
    }


    public Sequencer.SyncMode[] getMasterSyncModes() {
<span class="nc" id="L549">        Sequencer.SyncMode[] returnedModes = new Sequencer.SyncMode[masterSyncModes.length];</span>
<span class="nc" id="L550">        System.arraycopy(masterSyncModes, 0, returnedModes, 0, masterSyncModes.length);</span>
<span class="nc" id="L551">        return returnedModes;</span>
    }


    public void setSlaveSyncMode(Sequencer.SyncMode sync) {
        // not supported
<span class="nc" id="L557">    }</span>


    public Sequencer.SyncMode getSlaveSyncMode() {
<span class="nc" id="L561">        return slaveSyncMode;</span>
    }


    public Sequencer.SyncMode[] getSlaveSyncModes() {
<span class="nc" id="L566">        Sequencer.SyncMode[] returnedModes = new Sequencer.SyncMode[slaveSyncModes.length];</span>
<span class="nc" id="L567">        System.arraycopy(slaveSyncModes, 0, returnedModes, 0, slaveSyncModes.length);</span>
<span class="nc" id="L568">        return returnedModes;</span>
    }

    int getTrackCount() {
<span class="nc" id="L572">        Sequence seq = getSequence();</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">        if (seq != null) {</span>
            // $$fb wish there was a nicer way to get the number of tracks...
<span class="nc" id="L575">            return sequence.getTracks().length;</span>
        }
<span class="nc" id="L577">        return 0;</span>
    }



    public synchronized void setTrackMute(int track, boolean mute) {
<span class="nc" id="L583">        int trackCount = getTrackCount();</span>
<span class="nc bnc" id="L584" title="All 4 branches missed.">        if (track &lt; 0 || track &gt;= getTrackCount()) return;</span>
<span class="nc" id="L585">        trackMuted = ensureBoolArraySize(trackMuted, trackCount);</span>
<span class="nc" id="L586">        trackMuted[track] = mute;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (getDataPump() != null) {</span>
<span class="nc" id="L588">            getDataPump().muteSoloChanged();</span>
        }
<span class="nc" id="L590">    }</span>


    public synchronized boolean getTrackMute(int track) {
<span class="nc bnc" id="L594" title="All 4 branches missed.">        if (track &lt; 0 || track &gt;= getTrackCount()) return false;</span>
<span class="nc bnc" id="L595" title="All 4 branches missed.">        if (trackMuted == null || trackMuted.length &lt;= track) return false;</span>
<span class="nc" id="L596">        return trackMuted[track];</span>
    }


    public synchronized void setTrackSolo(int track, boolean solo) {
<span class="nc" id="L601">        int trackCount = getTrackCount();</span>
<span class="nc bnc" id="L602" title="All 4 branches missed.">        if (track &lt; 0 || track &gt;= getTrackCount()) return;</span>
<span class="nc" id="L603">        trackSolo = ensureBoolArraySize(trackSolo, trackCount);</span>
<span class="nc" id="L604">        trackSolo[track] = solo;</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">        if (getDataPump() != null) {</span>
<span class="nc" id="L606">            getDataPump().muteSoloChanged();</span>
        }
<span class="nc" id="L608">    }</span>


    public synchronized boolean getTrackSolo(int track) {
<span class="nc bnc" id="L612" title="All 4 branches missed.">        if (track &lt; 0 || track &gt;= getTrackCount()) return false;</span>
<span class="nc bnc" id="L613" title="All 4 branches missed.">        if (trackSolo == null || trackSolo.length &lt;= track) return false;</span>
<span class="nc" id="L614">        return trackSolo[track];</span>
    }


    public boolean addMetaEventListener(MetaEventListener listener) {
<span class="nc" id="L619">        synchronized(metaEventListeners) {</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            if (! metaEventListeners.contains(listener)) {</span>

<span class="nc" id="L622">                metaEventListeners.add(listener);</span>
            }
<span class="nc" id="L624">            return true;</span>
<span class="nc" id="L625">        }</span>
    }


    public void removeMetaEventListener(MetaEventListener listener) {
<span class="nc" id="L630">        synchronized(metaEventListeners) {</span>
<span class="nc" id="L631">            int index = metaEventListeners.indexOf(listener);</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (index &gt;= 0) {</span>
<span class="nc" id="L633">                metaEventListeners.remove(index);</span>
            }
<span class="nc" id="L635">        }</span>
<span class="nc" id="L636">    }</span>


    public int[] addControllerEventListener(ControllerEventListener listener, int[] controllers) {
<span class="nc" id="L640">        synchronized(controllerEventListeners) {</span>

            // first find the listener.  if we have one, add the controllers
            // if not, create a new element for it.
<span class="nc" id="L644">            ControllerListElement cve = null;</span>
<span class="nc" id="L645">            boolean flag = false;</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">            for(int i=0; i &lt; controllerEventListeners.size(); i++) {</span>

<span class="nc" id="L648">                cve = (ControllerListElement) controllerEventListeners.get(i);</span>

<span class="nc bnc" id="L650" title="All 2 branches missed.">                if (cve.listener.equals(listener)) {</span>
<span class="nc" id="L651">                    cve.addControllers(controllers);</span>
<span class="nc" id="L652">                    flag = true;</span>
<span class="nc" id="L653">                    break;</span>
                }
            }
<span class="nc bnc" id="L656" title="All 2 branches missed.">            if (!flag) {</span>
<span class="nc" id="L657">                cve = new ControllerListElement(listener, controllers);</span>
<span class="nc" id="L658">                controllerEventListeners.add(cve);</span>
            }

            // and return all the controllers this listener is interested in
<span class="nc" id="L662">            return cve.getControllers();</span>
<span class="nc" id="L663">        }</span>
    }


    public int[] removeControllerEventListener(ControllerEventListener listener, int[] controllers) {
<span class="nc" id="L668">        synchronized(controllerEventListeners) {</span>
<span class="nc" id="L669">            ControllerListElement cve = null;</span>
<span class="nc" id="L670">            boolean flag = false;</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">            for (int i=0; i &lt; controllerEventListeners.size(); i++) {</span>
<span class="nc" id="L672">                cve = (ControllerListElement) controllerEventListeners.get(i);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                if (cve.listener.equals(listener)) {</span>
<span class="nc" id="L674">                    cve.removeControllers(controllers);</span>
<span class="nc" id="L675">                    flag = true;</span>
<span class="nc" id="L676">                    break;</span>
                }
            }
<span class="nc bnc" id="L679" title="All 2 branches missed.">            if (!flag) {</span>
<span class="nc" id="L680">                return new int[0];</span>
            }
<span class="nc bnc" id="L682" title="All 2 branches missed.">            if (controllers == null) {</span>
<span class="nc" id="L683">                int index = controllerEventListeners.indexOf(cve);</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                if (index &gt;= 0) {</span>
<span class="nc" id="L685">                    controllerEventListeners.remove(index);</span>
                }
<span class="nc" id="L687">                return new int[0];</span>
            }
<span class="nc" id="L689">            return cve.getControllers();</span>
<span class="nc" id="L690">        }</span>
    }


    ////////////////// LOOPING (added in 1.5) ///////////////////////

    public void setLoopStartPoint(long tick) {
<span class="nc bnc" id="L697" title="All 8 branches missed.">        if ((tick &gt; getTickLength())</span>
            || ((loopEnd != -1) &amp;&amp; (tick &gt; loopEnd))
            || (tick &lt; 0)) {
<span class="nc" id="L700">            throw new IllegalArgumentException(&quot;invalid loop start point: &quot;+tick);</span>
        }
<span class="nc" id="L702">        loopStart = tick;</span>
<span class="nc" id="L703">    }</span>

    public long getLoopStartPoint() {
<span class="nc" id="L706">        return loopStart;</span>
    }

    public void setLoopEndPoint(long tick) {
<span class="nc bnc" id="L710" title="All 8 branches missed.">        if ((tick &gt; getTickLength())</span>
            || ((loopStart &gt; tick) &amp;&amp; (tick != -1))
            || (tick &lt; -1)) {
<span class="nc" id="L713">            throw new IllegalArgumentException(&quot;invalid loop end point: &quot;+tick);</span>
        }
<span class="nc" id="L715">        loopEnd = tick;</span>
<span class="nc" id="L716">    }</span>

    public long getLoopEndPoint() {
<span class="nc" id="L719">        return loopEnd;</span>
    }

    public void setLoopCount(int count) {
<span class="nc bnc" id="L723" title="All 4 branches missed.">        if (count != LOOP_CONTINUOUSLY</span>
            &amp;&amp; count &lt; 0) {
<span class="nc" id="L725">            throw new IllegalArgumentException(&quot;illegal value for loop count: &quot;+count);</span>
        }
<span class="nc" id="L727">        loopCount = count;</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (getDataPump() != null) {</span>
<span class="nc" id="L729">            getDataPump().resetLoopCount();</span>
        }
<span class="nc" id="L731">    }</span>

    public int getLoopCount() {
<span class="nc" id="L734">        return loopCount;</span>
    }


    /* *********************************** play control ************************* */

    /*
     */
    protected void implOpen() throws MidiUnavailableException {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implOpen()&quot;);

        //openInternalSynth();

        // create PlayThread
<span class="nc" id="L748">        playThread = new PlayThread();</span>

        //id = nOpen();
        //if (id == 0) {
        //    throw new MidiUnavailableException(&quot;unable to open sequencer&quot;);
        //}
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (sequence != null) {</span>
<span class="nc" id="L755">            playThread.setSequence(sequence);</span>
        }

        // propagate caches
<span class="nc" id="L759">        propagateCaches();</span>

<span class="nc bnc" id="L761" title="All 2 branches missed.">        if (doAutoConnectAtNextOpen) {</span>
<span class="nc" id="L762">            doAutoConnect();</span>
        }
        if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implOpen() succeeded&quot;);
<span class="nc" id="L765">    }</span>

    private void doAutoConnect() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: doAutoConnect()&quot;);
<span class="nc" id="L769">        Receiver rec = null;</span>
        // first try to connect to the default synthesizer
        // IMPORTANT: this code needs to be synch'ed with
        //            MidiSystem.getSequencer(boolean), because the same
        //            algorithm needs to be used!
        try {
<span class="nc" id="L775">            Synthesizer synth = MidiSystem.getSynthesizer();</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (synth instanceof ReferenceCountingDevice) {</span>
<span class="nc" id="L777">                rec = ((ReferenceCountingDevice) synth).getReceiverReferenceCounting();</span>
            } else {
<span class="nc" id="L779">                synth.open();</span>
                try {
<span class="nc" id="L781">                    rec = synth.getReceiver();</span>
                } finally {
                    // make sure that the synth is properly closed
<span class="nc bnc" id="L784" title="All 4 branches missed.">                    if (rec == null) {</span>
<span class="nc" id="L785">                        synth.close();</span>
                    }
                }
            }
<span class="nc" id="L789">        } catch (Exception e) {</span>
            // something went wrong with synth
<span class="nc" id="L791">        }</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">        if (rec == null) {</span>
            // then try to connect to the default Receiver
            try {
<span class="nc" id="L795">                rec = MidiSystem.getReceiver();</span>
<span class="nc" id="L796">            } catch (Exception e) {</span>
                // something went wrong. Nothing to do then!
<span class="nc" id="L798">            }</span>
        }
<span class="nc bnc" id="L800" title="All 2 branches missed.">        if (rec != null) {</span>
<span class="nc" id="L801">            autoConnectedReceiver = rec;</span>
            try {
<span class="nc" id="L803">                getTransmitter().setReceiver(rec);</span>
<span class="nc" id="L804">            } catch (Exception e) {}</span>
        }
        if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: doAutoConnect() succeeded&quot;);
<span class="nc" id="L807">    }</span>

    private synchronized void propagateCaches() {
        // only set caches if open and sequence is set
<span class="nc bnc" id="L811" title="All 4 branches missed.">        if (sequence != null &amp;&amp; isOpen()) {</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">            if (cacheTempoFactor != -1) {</span>
<span class="nc" id="L813">                setTempoFactor(cacheTempoFactor);</span>
            }
<span class="nc bnc" id="L815" title="All 2 branches missed.">            if (cacheTempoMPQ == -1) {</span>
<span class="nc" id="L816">                setTempoInMPQ((new MidiUtils.TempoCache(sequence)).getTempoMPQAt(getTickPosition()));</span>
            } else {
<span class="nc" id="L818">                setTempoInMPQ((float) cacheTempoMPQ);</span>
            }
        }
<span class="nc" id="L821">    }</span>

    /** populate the caches with the current values */
    private synchronized void setCaches() {
<span class="nc" id="L825">        cacheTempoFactor = getTempoFactor();</span>
<span class="nc" id="L826">        cacheTempoMPQ = getTempoInMPQ();</span>
<span class="nc" id="L827">    }</span>



    protected synchronized void implClose() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implClose() &quot;);

<span class="nc bnc" id="L834" title="All 2 branches missed.">        if (playThread == null) {</span>
            if (Printer.err) Printer.err(&quot;RealTimeSequencer.implClose() called, but playThread not instanciated!&quot;);
        } else {
            // Interrupt playback loop.
<span class="nc" id="L838">            playThread.close();</span>
<span class="nc" id="L839">            playThread = null;</span>
        }

<span class="nc" id="L842">        super.implClose();</span>

<span class="nc" id="L844">        sequence = null;</span>
<span class="nc" id="L845">        running = false;</span>
<span class="nc" id="L846">        cacheTempoMPQ = -1;</span>
<span class="nc" id="L847">        cacheTempoFactor = -1;</span>
<span class="nc" id="L848">        trackMuted = null;</span>
<span class="nc" id="L849">        trackSolo = null;</span>
<span class="nc" id="L850">        loopStart = 0;</span>
<span class="nc" id="L851">        loopEnd = -1;</span>
<span class="nc" id="L852">        loopCount = 0;</span>

        /** if this sequencer is set to autoconnect, need to
         * re-establish the connection at next open!
         */
<span class="nc" id="L857">        doAutoConnectAtNextOpen = autoConnect;</span>

<span class="nc bnc" id="L859" title="All 2 branches missed.">        if (autoConnectedReceiver != null) {</span>
            try {
<span class="nc" id="L861">                autoConnectedReceiver.close();</span>
<span class="nc" id="L862">            } catch (Exception e) {}</span>
<span class="nc" id="L863">            autoConnectedReceiver = null;</span>
        }

        if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implClose() completed&quot;);
<span class="nc" id="L867">    }</span>

    void implStart() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implStart()&quot;);

<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (playThread == null) {</span>
            if (Printer.err) Printer.err(&quot;RealTimeSequencer.implStart() called, but playThread not instanciated!&quot;);
<span class="nc" id="L874">            return;</span>
        }

<span class="nc" id="L877">        tempoCache.refresh(sequence);</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">        if (!running) {</span>
<span class="nc" id="L879">            running  = true;</span>
<span class="nc" id="L880">            playThread.start();</span>
        }
        if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implStart() completed&quot;);
<span class="nc" id="L883">    }</span>


    void implStop() {
        if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implStop()&quot;);

<span class="nc bnc" id="L889" title="All 2 branches missed.">        if (playThread == null) {</span>
            if (Printer.err) Printer.err(&quot;RealTimeSequencer.implStop() called, but playThread not instanciated!&quot;);
<span class="nc" id="L891">            return;</span>
        }

<span class="nc" id="L894">        recording = false;</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">        if (running) {</span>
<span class="nc" id="L896">            running = false;</span>
<span class="nc" id="L897">            playThread.stop();</span>
        }
        if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implStop() completed&quot;);
<span class="nc" id="L900">    }</span>

    private static EventDispatcher getEventDispatcher() {
        // create and start the global event thread
        //TODO  need a way to stop this thread when the engine is done
<span class="nc" id="L905">        final ThreadGroup tg = Thread.currentThread().getThreadGroup();</span>
<span class="nc" id="L906">        synchronized (dispatchers) {</span>
<span class="nc" id="L907">            EventDispatcher eventDispatcher = dispatchers.get(tg);</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            if (eventDispatcher == null) {</span>
<span class="nc" id="L909">                eventDispatcher = new EventDispatcher();</span>
<span class="nc" id="L910">                dispatchers.put(tg, eventDispatcher);</span>
<span class="nc" id="L911">                eventDispatcher.start();</span>
            }
<span class="nc" id="L913">            return eventDispatcher;</span>
<span class="nc" id="L914">        }</span>
    }

    /**
     * Send midi player events.
     * must not be synchronized on &quot;this&quot;
     */
    void sendMetaEvents(MidiMessage message) {
<span class="nc bnc" id="L922" title="All 2 branches missed.">        if (metaEventListeners.size() == 0) return;</span>

        //if (Printer.debug) Printer.debug(&quot;sending a meta event&quot;);
<span class="nc" id="L925">        getEventDispatcher().sendAudioEvents(message, metaEventListeners);</span>
<span class="nc" id="L926">    }</span>

    /**
     * Send midi player events.
     */
    void sendControllerEvents(MidiMessage message) {
<span class="nc" id="L932">        int size = controllerEventListeners.size();</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">        if (size == 0) return;</span>

        //if (Printer.debug) Printer.debug(&quot;sending a controller event&quot;);

<span class="nc bnc" id="L937" title="All 2 branches missed.">        if (! (message instanceof ShortMessage)) {</span>
            if (Printer.debug) Printer.debug(&quot;sendControllerEvents: message is NOT instanceof ShortMessage!&quot;);
<span class="nc" id="L939">            return;</span>
        }
<span class="nc" id="L941">        ShortMessage msg = (ShortMessage) message;</span>
<span class="nc" id="L942">        int controller = msg.getData1();</span>
<span class="nc" id="L943">        List sendToListeners = new ArrayList();</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L945">            ControllerListElement cve = (ControllerListElement) controllerEventListeners.get(i);</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">            for(int j = 0; j &lt; cve.controllers.length; j++) {</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">                if (cve.controllers[j] == controller) {</span>
<span class="nc" id="L948">                    sendToListeners.add(cve.listener);</span>
<span class="nc" id="L949">                    break;</span>
                }
            }
        }
<span class="nc" id="L953">        getEventDispatcher().sendAudioEvents(message, sendToListeners);</span>
<span class="nc" id="L954">    }</span>



    private boolean needCaching() {
<span class="nc bnc" id="L959" title="All 6 branches missed.">        return !isOpen() || (sequence == null) || (playThread == null);</span>
    }

    /**
     * return the data pump instance, owned by play thread
     * if playthread is null, return null.
     * This method is guaranteed to return non-null if
     * needCaching returns false
     */
    private DataPump getDataPump() {
<span class="nc bnc" id="L969" title="All 2 branches missed.">        if (playThread != null) {</span>
<span class="nc" id="L970">            return playThread.getDataPump();</span>
        }
<span class="nc" id="L972">        return null;</span>
    }

    private MidiUtils.TempoCache getTempoCache() {
<span class="nc" id="L976">        return tempoCache;</span>
    }

    private static boolean[] ensureBoolArraySize(boolean[] array, int desiredSize) {
<span class="nc bnc" id="L980" title="All 2 branches missed.">        if (array == null) {</span>
<span class="nc" id="L981">            return new boolean[desiredSize];</span>
        }
<span class="nc bnc" id="L983" title="All 2 branches missed.">        if (array.length &lt; desiredSize) {</span>
<span class="nc" id="L984">            boolean[] newArray = new boolean[desiredSize];</span>
<span class="nc" id="L985">            System.arraycopy(array, 0, newArray, 0, array.length);</span>
<span class="nc" id="L986">            return newArray;</span>
        }
<span class="nc" id="L988">        return array;</span>
    }


    // OVERRIDES OF ABSTRACT MIDI DEVICE METHODS

    protected boolean hasReceivers() {
<span class="nc" id="L995">        return true;</span>
    }

    // for recording
    protected Receiver createReceiver() throws MidiUnavailableException {
<span class="nc" id="L1000">        return new SequencerReceiver();</span>
    }


    protected boolean hasTransmitters() {
<span class="nc" id="L1005">        return true;</span>
    }


    protected Transmitter createTransmitter() throws MidiUnavailableException {
<span class="nc" id="L1010">        return new SequencerTransmitter();</span>
    }


    // interface AutoConnectSequencer
    public void setAutoConnect(Receiver autoConnectedReceiver) {
<span class="nc bnc" id="L1016" title="All 2 branches missed.">        this.autoConnect = (autoConnectedReceiver != null);</span>
<span class="nc" id="L1017">        this.autoConnectedReceiver = autoConnectedReceiver;</span>
<span class="nc" id="L1018">    }</span>



    // INNER CLASSES

    /**
     * An own class to distinguish the class name from
     * the transmitter of other devices
     */
    private class SequencerTransmitter extends BasicTransmitter {
<span class="nc" id="L1029">        private SequencerTransmitter() {</span>
<span class="nc" id="L1030">            super();</span>
<span class="nc" id="L1031">        }</span>
    }


<span class="nc" id="L1035">    final class SequencerReceiver extends AbstractReceiver {</span>

        void implSend(MidiMessage message, long timeStamp) {
<span class="nc bnc" id="L1038" title="All 2 branches missed.">            if (recording) {</span>
<span class="nc" id="L1039">                long tickPos = 0;</span>

                // convert timeStamp to ticks
<span class="nc bnc" id="L1042" title="All 2 branches missed.">                if (timeStamp &lt; 0) {</span>
<span class="nc" id="L1043">                    tickPos = getTickPosition();</span>
                } else {
<span class="nc" id="L1045">                    synchronized(tempoCache) {</span>
<span class="nc" id="L1046">                        tickPos = MidiUtils.microsecond2tick(sequence, timeStamp, tempoCache);</span>
<span class="nc" id="L1047">                    }</span>
                }

                // and record to the first matching Track
<span class="nc" id="L1051">                Track track = null;</span>
                // do not record real-time events
                // see 5048381: NullPointerException when saving a MIDI sequence
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                if (message.getLength() &gt; 1) {</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">                    if (message instanceof ShortMessage) {</span>
<span class="nc" id="L1056">                        ShortMessage sm = (ShortMessage) message;</span>
                        // all real-time messages have 0xF in the high nibble of the status byte
<span class="nc bnc" id="L1058" title="All 2 branches missed.">                        if ((sm.getStatus() &amp; 0xF0) != 0xF0) {</span>
<span class="nc" id="L1059">                            track = RecordingTrack.get(recordingTracks, sm.getChannel());</span>
                        }
<span class="nc" id="L1061">                    } else {</span>
                        // $$jb: where to record meta, sysex events?
                        // $$fb: the first recording track
<span class="nc" id="L1064">                        track = RecordingTrack.get(recordingTracks, -1);</span>
                    }
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                    if (track != null) {</span>
                        // create a copy of this message
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                        if (message instanceof ShortMessage) {</span>
<span class="nc" id="L1069">                            message = new FastShortMessage((ShortMessage) message);</span>
                        } else {
<span class="nc" id="L1071">                            message = (MidiMessage) message.clone();</span>
                        }

                        // create new MidiEvent
<span class="nc" id="L1075">                        MidiEvent me = new MidiEvent(message, tickPos);</span>
<span class="nc" id="L1076">                        track.add(me);</span>
                    }
                }
            }
<span class="nc" id="L1080">        }</span>
    }


    private static class RealTimeSequencerInfo extends MidiDevice.Info {

        private static final String name = &quot;Real Time Sequencer&quot;;
        private static final String vendor = &quot;Oracle Corporation&quot;;
        private static final String description = &quot;Software sequencer&quot;;
        private static final String version = &quot;Version 1.0&quot;;

        private RealTimeSequencerInfo() {
<span class="nc" id="L1092">            super(name, vendor, description, version);</span>
<span class="nc" id="L1093">        }</span>
    } // class Info


    private class ControllerListElement {

        // $$jb: using an array for controllers b/c its
        //       easier to deal with than turning all the
        //       ints into objects to use a Vector
        int []  controllers;
        final ControllerEventListener listener;

<span class="nc" id="L1105">        private ControllerListElement(ControllerEventListener listener, int[] controllers) {</span>

<span class="nc" id="L1107">            this.listener = listener;</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">            if (controllers == null) {</span>
<span class="nc" id="L1109">                controllers = new int[128];</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                for (int i = 0; i &lt; 128; i++) {</span>
<span class="nc" id="L1111">                    controllers[i] = i;</span>
                }
            }
<span class="nc" id="L1114">            this.controllers = controllers;</span>
<span class="nc" id="L1115">        }</span>

        private void addControllers(int[] c) {

<span class="nc bnc" id="L1119" title="All 2 branches missed.">            if (c==null) {</span>
<span class="nc" id="L1120">                controllers = new int[128];</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">                for (int i = 0; i &lt; 128; i++) {</span>
<span class="nc" id="L1122">                    controllers[i] = i;</span>
                }
<span class="nc" id="L1124">                return;</span>
            }
<span class="nc" id="L1126">            int temp[] = new int[ controllers.length + c.length ];</span>
            int elements;

            // first add what we have
<span class="nc bnc" id="L1130" title="All 2 branches missed.">            for(int i=0; i&lt;controllers.length; i++) {</span>
<span class="nc" id="L1131">                temp[i] = controllers[i];</span>
            }
<span class="nc" id="L1133">            elements = controllers.length;</span>
            // now add the new controllers only if we don't already have them
<span class="nc bnc" id="L1135" title="All 2 branches missed.">            for(int i=0; i&lt;c.length; i++) {</span>
<span class="nc" id="L1136">                boolean flag = false;</span>

<span class="nc bnc" id="L1138" title="All 2 branches missed.">                for(int j=0; j&lt;controllers.length; j++) {</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">                    if (c[i] == controllers[j]) {</span>
<span class="nc" id="L1140">                        flag = true;</span>
<span class="nc" id="L1141">                        break;</span>
                    }
                }
<span class="nc bnc" id="L1144" title="All 2 branches missed.">                if (!flag) {</span>
<span class="nc" id="L1145">                    temp[elements++] = c[i];</span>
                }
            }
            // now keep only the elements we need
<span class="nc" id="L1149">            int newc[] = new int[ elements ];</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            for(int i=0; i&lt;elements; i++){</span>
<span class="nc" id="L1151">                newc[i] = temp[i];</span>
            }
<span class="nc" id="L1153">            controllers = newc;</span>
<span class="nc" id="L1154">        }</span>

        private void removeControllers(int[] c) {

<span class="nc bnc" id="L1158" title="All 2 branches missed.">            if (c==null) {</span>
<span class="nc" id="L1159">                controllers = new int[0];</span>
            } else {
<span class="nc" id="L1161">                int temp[] = new int[ controllers.length ];</span>
<span class="nc" id="L1162">                int elements = 0;</span>


<span class="nc bnc" id="L1165" title="All 2 branches missed.">                for(int i=0; i&lt;controllers.length; i++){</span>
<span class="nc" id="L1166">                    boolean flag = false;</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">                    for(int j=0; j&lt;c.length; j++) {</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">                        if (controllers[i] == c[j]) {</span>
<span class="nc" id="L1169">                            flag = true;</span>
<span class="nc" id="L1170">                            break;</span>
                        }
                    }
<span class="nc bnc" id="L1173" title="All 2 branches missed.">                    if (!flag){</span>
<span class="nc" id="L1174">                        temp[elements++] = controllers[i];</span>
                    }
                }
                // now keep only the elements remaining
<span class="nc" id="L1178">                int newc[] = new int[ elements ];</span>
<span class="nc bnc" id="L1179" title="All 2 branches missed.">                for(int i=0; i&lt;elements; i++) {</span>
<span class="nc" id="L1180">                    newc[i] = temp[i];</span>
                }
<span class="nc" id="L1182">                controllers = newc;</span>

            }
<span class="nc" id="L1185">        }</span>

        private int[] getControllers() {

            // return a copy of our array of controllers,
            // so others can't mess with it
<span class="nc bnc" id="L1191" title="All 2 branches missed.">            if (controllers == null) {</span>
<span class="nc" id="L1192">                return null;</span>
            }

<span class="nc" id="L1195">            int c[] = new int[controllers.length];</span>

<span class="nc bnc" id="L1197" title="All 2 branches missed.">            for(int i=0; i&lt;controllers.length; i++){</span>
<span class="nc" id="L1198">                c[i] = controllers[i];</span>
            }
<span class="nc" id="L1200">            return c;</span>
        }

    } // class ControllerListElement


    static class RecordingTrack {

        private final Track track;
        private int channel;

<span class="nc" id="L1211">        RecordingTrack(Track track, int channel) {</span>
<span class="nc" id="L1212">            this.track = track;</span>
<span class="nc" id="L1213">            this.channel = channel;</span>
<span class="nc" id="L1214">        }</span>

        static RecordingTrack get(List recordingTracks, Track track) {

<span class="nc" id="L1218">            synchronized(recordingTracks) {</span>
<span class="nc" id="L1219">                int size = recordingTracks.size();</span>

<span class="nc bnc" id="L1221" title="All 2 branches missed.">                for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1222">                    RecordingTrack current = (RecordingTrack)recordingTracks.get(i);</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">                    if (current.track == track) {</span>
<span class="nc" id="L1224">                        return current;</span>
                    }
                }
<span class="nc" id="L1227">            }</span>
<span class="nc" id="L1228">            return null;</span>
        }

        static Track get(List recordingTracks, int channel) {

<span class="nc" id="L1233">            synchronized(recordingTracks) {</span>
<span class="nc" id="L1234">                int size = recordingTracks.size();</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">                for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1236">                    RecordingTrack current = (RecordingTrack)recordingTracks.get(i);</span>
<span class="nc bnc" id="L1237" title="All 4 branches missed.">                    if ((current.channel == channel) || (current.channel == -1)) {</span>
<span class="nc" id="L1238">                        return current.track;</span>
                    }
                }
<span class="nc" id="L1241">            }</span>
<span class="nc" id="L1242">            return null;</span>

        }
    }


    final class PlayThread implements Runnable {
        private Thread thread;
<span class="nc" id="L1250">        private final Object lock = new Object();</span>

        /** true if playback is interrupted (in close) */
<span class="nc" id="L1253">        boolean interrupted = false;</span>
<span class="nc" id="L1254">        boolean isPumping = false;</span>

<span class="nc" id="L1256">        private final DataPump dataPump = new DataPump();</span>


<span class="nc" id="L1259">        PlayThread() {</span>
            // nearly MAX_PRIORITY
<span class="nc" id="L1261">            int priority = Thread.NORM_PRIORITY</span>
                + ((Thread.MAX_PRIORITY - Thread.NORM_PRIORITY) * 3) / 4;
<span class="nc" id="L1263">            thread = JSSecurityManager.createThread(this,</span>
                                                    &quot;Java Sound Sequencer&quot;, // name
                                                    false,                  // daemon
                                                    priority,               // priority
                                                    true);                  // doStart
<span class="nc" id="L1268">        }</span>

        DataPump getDataPump() {
<span class="nc" id="L1271">            return dataPump;</span>
        }

        synchronized void setSequence(Sequence seq) {
<span class="nc" id="L1275">            dataPump.setSequence(seq);</span>
<span class="nc" id="L1276">        }</span>


        /** start thread and pump. Requires up-to-date tempoCache */
        synchronized void start() {
            // mark the sequencer running
<span class="nc" id="L1282">            running = true;</span>

<span class="nc bnc" id="L1284" title="All 2 branches missed.">            if (!dataPump.hasCachedTempo()) {</span>
<span class="nc" id="L1285">                long tickPos = getTickPosition();</span>
<span class="nc" id="L1286">                dataPump.setTempoMPQ(tempoCache.getTempoMPQAt(tickPos));</span>
            }
<span class="nc" id="L1288">            dataPump.checkPointMillis = 0; // means restarted</span>
<span class="nc" id="L1289">            dataPump.clearNoteOnCache();</span>
<span class="nc" id="L1290">            dataPump.needReindex = true;</span>

<span class="nc" id="L1292">            dataPump.resetLoopCount();</span>

            // notify the thread
<span class="nc" id="L1295">            synchronized(lock) {</span>
<span class="nc" id="L1296">                lock.notifyAll();</span>
<span class="nc" id="L1297">            }</span>

            if (Printer.debug) Printer.debug(&quot; -&gt;Started MIDI play thread&quot;);

<span class="nc" id="L1301">        }</span>

        // waits until stopped
        synchronized void stop() {
<span class="nc" id="L1305">            playThreadImplStop();</span>
<span class="nc" id="L1306">            long t = System.nanoTime() / 1000000l;</span>
<span class="nc bnc" id="L1307" title="All 2 branches missed.">            while (isPumping) {</span>
<span class="nc" id="L1308">                synchronized(lock) {</span>
                    try {
<span class="nc" id="L1310">                        lock.wait(2000);</span>
<span class="nc" id="L1311">                    } catch (InterruptedException ie) {</span>
                        // ignore
<span class="nc" id="L1313">                    }</span>
<span class="nc" id="L1314">                }</span>
                // don't wait for more than 2 seconds
<span class="nc bnc" id="L1316" title="All 2 branches missed.">                if ((System.nanoTime()/1000000l) - t &gt; 1900) {</span>
                    if (Printer.err) Printer.err(&quot;Waited more than 2 seconds in RealTimeSequencer.PlayThread.stop()!&quot;);
                    //break;
                }
            }
<span class="nc" id="L1321">        }</span>

        void playThreadImplStop() {
            // mark the sequencer running
<span class="nc" id="L1325">            running = false;</span>
<span class="nc" id="L1326">            synchronized(lock) {</span>
<span class="nc" id="L1327">                lock.notifyAll();</span>
<span class="nc" id="L1328">            }</span>
<span class="nc" id="L1329">        }</span>

        void close() {
<span class="nc" id="L1332">            Thread oldThread = null;</span>
<span class="nc" id="L1333">            synchronized (this) {</span>
                // dispose of thread
<span class="nc" id="L1335">                interrupted = true;</span>
<span class="nc" id="L1336">                oldThread = thread;</span>
<span class="nc" id="L1337">                thread = null;</span>
<span class="nc" id="L1338">            }</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">            if (oldThread != null) {</span>
                // wake up the thread if it's in wait()
<span class="nc" id="L1341">                synchronized(lock) {</span>
<span class="nc" id="L1342">                    lock.notifyAll();</span>
<span class="nc" id="L1343">                }</span>
            }
            // wait for the thread to terminate itself,
            // but max. 2 seconds. Must not be synchronized!
<span class="nc bnc" id="L1347" title="All 2 branches missed.">            if (oldThread != null) {</span>
                try {
<span class="nc" id="L1349">                    oldThread.join(2000);</span>
<span class="nc" id="L1350">                } catch (InterruptedException ie) {}</span>
            }
<span class="nc" id="L1352">        }</span>


        /**
         * Main process loop driving the media flow.
         *
         * Make sure to NOT synchronize on RealTimeSequencer
         * anywhere here (even implicit). That is a sure deadlock!
         */
        public void run() {

<span class="nc bnc" id="L1363" title="All 2 branches missed.">            while (!interrupted) {</span>
<span class="nc" id="L1364">                boolean EOM = false;</span>
<span class="nc" id="L1365">                boolean wasRunning = running;</span>
<span class="nc bnc" id="L1366" title="All 4 branches missed.">                isPumping = !interrupted &amp;&amp; running;</span>
<span class="nc bnc" id="L1367" title="All 6 branches missed.">                while (!EOM &amp;&amp; !interrupted &amp;&amp; running) {</span>
<span class="nc" id="L1368">                    EOM = dataPump.pump();</span>

                    try {
<span class="nc" id="L1371">                        Thread.sleep(1);</span>
<span class="nc" id="L1372">                    } catch (InterruptedException ie) {</span>
                        // ignore
<span class="nc" id="L1374">                    }</span>
                }
                if (Printer.debug) {
                    Printer.debug(&quot;Exited main pump loop because: &quot;);
                    if (EOM) Printer.debug(&quot; -&gt; EOM is reached&quot;);
                    if (!running) Printer.debug(&quot; -&gt; running was set to false&quot;);
                    if (interrupted) Printer.debug(&quot; -&gt; interrupted was set to true&quot;);
                }

<span class="nc" id="L1383">                playThreadImplStop();</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">                if (wasRunning) {</span>
<span class="nc" id="L1385">                    dataPump.notesOff(true);</span>
                }
<span class="nc bnc" id="L1387" title="All 2 branches missed.">                if (EOM) {</span>
<span class="nc" id="L1388">                    dataPump.setTickPos(sequence.getTickLength());</span>

                    // send EOT event (mis-used for end of media)
<span class="nc" id="L1391">                    MetaMessage message = new MetaMessage();</span>
                    try{
<span class="nc" id="L1393">                        message.setMessage(MidiUtils.META_END_OF_TRACK_TYPE, new byte[0], 0);</span>
<span class="nc" id="L1394">                    } catch(InvalidMidiDataException e1) {}</span>
<span class="nc" id="L1395">                    sendMetaEvents(message);</span>
                }
<span class="nc" id="L1397">                synchronized (lock) {</span>
<span class="nc" id="L1398">                    isPumping = false;</span>
                    // wake up a waiting stop() method
<span class="nc" id="L1400">                    lock.notifyAll();</span>
<span class="nc bnc" id="L1401" title="All 4 branches missed.">                    while (!running &amp;&amp; !interrupted) {</span>
                        try {
<span class="nc" id="L1403">                            lock.wait();</span>
<span class="nc" id="L1404">                        } catch (Exception ex) {}</span>
                    }
<span class="nc" id="L1406">                }</span>
<span class="nc" id="L1407">            } // end of while(!EOM &amp;&amp; !interrupted &amp;&amp; running)</span>
            if (Printer.debug) Printer.debug(&quot;end of play thread&quot;);
<span class="nc" id="L1409">        }</span>
    }


    /**
     * class that does the actual dispatching of events,
     * used to be in native in MMAPI
     */
    private class DataPump {
        private float currTempo;         // MPQ tempo
        private float tempoFactor;       // 1.0 is default
        private float inverseTempoFactor;// = 1.0 / tempoFactor
        private long ignoreTempoEventAt; // ignore next META tempo during playback at this tick pos only
        private int resolution;
        private float divisionType;
        private long checkPointMillis;   // microseconds at checkoint
        private long checkPointTick;     // ticks at checkpoint
        private int[] noteOnCache;       // bit-mask of notes that are currently on
        private Track[] tracks;
        private boolean[] trackDisabled; // if true, do not play this track
        private int[] trackReadPos;      // read index per track
        private long lastTick;
<span class="nc" id="L1431">        private boolean needReindex = false;</span>
<span class="nc" id="L1432">        private int currLoopCounter = 0;</span>

        //private sun.misc.Perf perf = sun.misc.Perf.getPerf();
        //private long perfFreq = perf.highResFrequency();


<span class="nc" id="L1438">        DataPump() {</span>
<span class="nc" id="L1439">            init();</span>
<span class="nc" id="L1440">        }</span>

        synchronized void init() {
<span class="nc" id="L1443">            ignoreTempoEventAt = -1;</span>
<span class="nc" id="L1444">            tempoFactor = 1.0f;</span>
<span class="nc" id="L1445">            inverseTempoFactor = 1.0f;</span>
<span class="nc" id="L1446">            noteOnCache = new int[128];</span>
<span class="nc" id="L1447">            tracks = null;</span>
<span class="nc" id="L1448">            trackDisabled = null;</span>
<span class="nc" id="L1449">        }</span>

        synchronized void setTickPos(long tickPos) {
<span class="nc" id="L1452">            long oldLastTick = tickPos;</span>
<span class="nc" id="L1453">            lastTick = tickPos;</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">            if (running) {</span>
<span class="nc" id="L1455">                notesOff(false);</span>
            }
<span class="nc bnc" id="L1457" title="All 4 branches missed.">            if (running || tickPos &gt; 0) {</span>
                // will also reindex
<span class="nc" id="L1459">                chaseEvents(oldLastTick, tickPos);</span>
            } else {
<span class="nc" id="L1461">                needReindex = true;</span>
            }
<span class="nc bnc" id="L1463" title="All 2 branches missed.">            if (!hasCachedTempo()) {</span>
<span class="nc" id="L1464">                setTempoMPQ(getTempoCache().getTempoMPQAt(lastTick, currTempo));</span>
                // treat this as if it is a real time tempo change
<span class="nc" id="L1466">                ignoreTempoEventAt = -1;</span>
            }
            // trigger re-configuration
<span class="nc" id="L1469">            checkPointMillis = 0;</span>
<span class="nc" id="L1470">        }</span>

        long getTickPos() {
<span class="nc" id="L1473">            return lastTick;</span>
        }

        // hasCachedTempo is only valid if it is the current position
        boolean hasCachedTempo() {
<span class="nc bnc" id="L1478" title="All 2 branches missed.">            if (ignoreTempoEventAt != lastTick) {</span>
<span class="nc" id="L1479">                ignoreTempoEventAt = -1;</span>
            }
<span class="nc bnc" id="L1481" title="All 2 branches missed.">            return ignoreTempoEventAt &gt;= 0;</span>
        }

        // this method is also used internally in the pump!
        synchronized void setTempoMPQ(float tempoMPQ) {
<span class="nc bnc" id="L1486" title="All 4 branches missed.">            if (tempoMPQ &gt; 0 &amp;&amp; tempoMPQ != currTempo) {</span>
<span class="nc" id="L1487">                ignoreTempoEventAt = lastTick;</span>
<span class="nc" id="L1488">                this.currTempo = tempoMPQ;</span>
                // re-calculate check point
<span class="nc" id="L1490">                checkPointMillis = 0;</span>
            }
<span class="nc" id="L1492">        }</span>

        float getTempoMPQ() {
<span class="nc" id="L1495">            return currTempo;</span>
        }

        synchronized void setTempoFactor(float factor) {
<span class="nc bnc" id="L1499" title="All 4 branches missed.">            if (factor &gt; 0 &amp;&amp; factor != this.tempoFactor) {</span>
<span class="nc" id="L1500">                tempoFactor = factor;</span>
<span class="nc" id="L1501">                inverseTempoFactor = 1.0f / factor;</span>
                // re-calculate check point
<span class="nc" id="L1503">                checkPointMillis = 0;</span>
            }
<span class="nc" id="L1505">        }</span>

        float getTempoFactor() {
<span class="nc" id="L1508">            return tempoFactor;</span>
        }

        synchronized void muteSoloChanged() {
<span class="nc" id="L1512">            boolean[] newDisabled = makeDisabledArray();</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">            if (running) {</span>
<span class="nc" id="L1514">                applyDisabledTracks(trackDisabled, newDisabled);</span>
            }
<span class="nc" id="L1516">            trackDisabled = newDisabled;</span>
<span class="nc" id="L1517">        }</span>



        synchronized void setSequence(Sequence seq) {
<span class="nc bnc" id="L1522" title="All 2 branches missed.">            if (seq == null) {</span>
<span class="nc" id="L1523">                init();</span>
<span class="nc" id="L1524">                return;</span>
            }
<span class="nc" id="L1526">            tracks = seq.getTracks();</span>
<span class="nc" id="L1527">            muteSoloChanged();</span>
<span class="nc" id="L1528">            resolution = seq.getResolution();</span>
<span class="nc" id="L1529">            divisionType = seq.getDivisionType();</span>
<span class="nc" id="L1530">            trackReadPos = new int[tracks.length];</span>
            // trigger re-initialization
<span class="nc" id="L1532">            checkPointMillis = 0;</span>
<span class="nc" id="L1533">            needReindex = true;</span>
<span class="nc" id="L1534">        }</span>

        synchronized void resetLoopCount() {
<span class="nc" id="L1537">            currLoopCounter = loopCount;</span>
<span class="nc" id="L1538">        }</span>

        void clearNoteOnCache() {
<span class="nc bnc" id="L1541" title="All 2 branches missed.">            for (int i = 0; i &lt; 128; i++) {</span>
<span class="nc" id="L1542">                noteOnCache[i] = 0;</span>
            }
<span class="nc" id="L1544">        }</span>

        void notesOff(boolean doControllers) {
<span class="nc" id="L1547">            int done = 0;</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">            for (int ch=0; ch&lt;16; ch++) {</span>
<span class="nc" id="L1549">                int channelMask = (1&lt;&lt;ch);</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">                for (int i=0; i&lt;128; i++) {</span>
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                    if ((noteOnCache[i] &amp; channelMask) != 0) {</span>
<span class="nc" id="L1552">                        noteOnCache[i] ^= channelMask;</span>
                        // send note on with velocity 0
<span class="nc" id="L1554">                        getTransmitterList().sendMessage((ShortMessage.NOTE_ON | ch) | (i&lt;&lt;8), -1);</span>
<span class="nc" id="L1555">                        done++;</span>
                    }
                }
                /* all notes off */
<span class="nc" id="L1559">                getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (123&lt;&lt;8), -1);</span>
                /* sustain off */
<span class="nc" id="L1561">                getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (64&lt;&lt;8), -1);</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">                if (doControllers) {</span>
                    /* reset all controllers */
<span class="nc" id="L1564">                    getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (121&lt;&lt;8), -1);</span>
<span class="nc" id="L1565">                    done++;</span>
                }
            }
            if (DEBUG_PUMP) Printer.println(&quot;  noteOff: sent &quot;+done+&quot; messages.&quot;);
<span class="nc" id="L1569">        }</span>


        private boolean[] makeDisabledArray() {
<span class="nc bnc" id="L1573" title="All 2 branches missed.">            if (tracks == null) {</span>
<span class="nc" id="L1574">                return null;</span>
            }
<span class="nc" id="L1576">            boolean[] newTrackDisabled = new boolean[tracks.length];</span>
            boolean[] solo;
            boolean[] mute;
<span class="nc" id="L1579">            synchronized(RealTimeSequencer.this) {</span>
<span class="nc" id="L1580">                mute = trackMuted;</span>
<span class="nc" id="L1581">                solo = trackSolo;</span>
<span class="nc" id="L1582">            }</span>
            // if one track is solo, then only play solo
<span class="nc" id="L1584">            boolean hasSolo = false;</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">            if (solo != null) {</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">                for (int i = 0; i &lt; solo.length; i++) {</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">                    if (solo[i]) {</span>
<span class="nc" id="L1588">                        hasSolo = true;</span>
<span class="nc" id="L1589">                        break;</span>
                    }
                }
            }
<span class="nc bnc" id="L1593" title="All 2 branches missed.">            if (hasSolo) {</span>
                // only the channels with solo play, regardless of mute
<span class="nc bnc" id="L1595" title="All 2 branches missed.">                for (int i = 0; i &lt; newTrackDisabled.length; i++) {</span>
<span class="nc bnc" id="L1596" title="All 4 branches missed.">                    newTrackDisabled[i] = (i &gt;= solo.length) || (!solo[i]);</span>
                }
            } else {
                // mute the selected channels
<span class="nc bnc" id="L1600" title="All 2 branches missed.">                for (int i = 0; i &lt; newTrackDisabled.length; i++) {</span>
<span class="nc bnc" id="L1601" title="All 6 branches missed.">                    newTrackDisabled[i] = (mute != null) &amp;&amp; (i &lt; mute.length) &amp;&amp; (mute[i]);</span>
                }
            }
<span class="nc" id="L1604">            return newTrackDisabled;</span>
        }

        /**
         * chase all events from beginning of Track
         * and send note off for those events that are active
         * in noteOnCache array.
         * It is possible, of course, to catch notes from other tracks,
         * but better than more complicated logic to detect
         * which notes are really from this track
         */
        private void sendNoteOffIfOn(Track track, long endTick) {
<span class="nc" id="L1616">            int size = track.size();</span>
<span class="nc" id="L1617">            int done = 0;</span>
            try {
<span class="nc bnc" id="L1619" title="All 2 branches missed.">                for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1620">                    MidiEvent event = track.get(i);</span>
<span class="nc bnc" id="L1621" title="All 2 branches missed.">                    if (event.getTick() &gt; endTick) break;</span>
<span class="nc" id="L1622">                    MidiMessage msg = event.getMessage();</span>
<span class="nc" id="L1623">                    int status = msg.getStatus();</span>
<span class="nc" id="L1624">                    int len = msg.getLength();</span>
<span class="nc bnc" id="L1625" title="All 4 branches missed.">                    if (len == 3 &amp;&amp; ((status &amp; 0xF0) == ShortMessage.NOTE_ON)) {</span>
<span class="nc" id="L1626">                        int note = -1;</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">                        if (msg instanceof ShortMessage) {</span>
<span class="nc" id="L1628">                            ShortMessage smsg = (ShortMessage) msg;</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">                            if (smsg.getData2() &gt; 0) {</span>
                                // only consider Note On with velocity &gt; 0
<span class="nc" id="L1631">                                note = smsg.getData1();</span>
                            }
<span class="nc" id="L1633">                        } else {</span>
<span class="nc" id="L1634">                            byte[] data = msg.getMessage();</span>
<span class="nc bnc" id="L1635" title="All 2 branches missed.">                            if ((data[2] &amp; 0x7F) &gt; 0) {</span>
                                // only consider Note On with velocity &gt; 0
<span class="nc" id="L1637">                                note = data[1] &amp; 0x7F;</span>
                            }
                        }
<span class="nc bnc" id="L1640" title="All 2 branches missed.">                        if (note &gt;= 0) {</span>
<span class="nc" id="L1641">                            int bit = 1&lt;&lt;(status &amp; 0x0F);</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">                            if ((noteOnCache[note] &amp; bit) != 0) {</span>
                                // the bit is set. Send Note Off
<span class="nc" id="L1644">                                getTransmitterList().sendMessage(status | (note&lt;&lt;8), -1);</span>
                                // clear the bit
<span class="nc" id="L1646">                                noteOnCache[note] &amp;= (0xFFFF ^ bit);</span>
<span class="nc" id="L1647">                                done++;</span>
                            }
                        }
                    }
                }
<span class="nc" id="L1652">            } catch (ArrayIndexOutOfBoundsException aioobe) {</span>
                // this happens when messages are removed
                // from the track while this method executes
<span class="nc" id="L1655">            }</span>
            if (DEBUG_PUMP) Printer.println(&quot;  sendNoteOffIfOn: sent &quot;+done+&quot; messages.&quot;);
<span class="nc" id="L1657">        }</span>


        /**
         * Runtime application of mute/solo:
         * if a track is muted that was previously playing, send
         *    note off events for all currently playing notes
         */
        private void applyDisabledTracks(boolean[] oldDisabled, boolean[] newDisabled) {
<span class="nc" id="L1666">            byte[][] tempArray = null;</span>
<span class="nc" id="L1667">            synchronized(RealTimeSequencer.this) {</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">                for (int i = 0; i &lt; newDisabled.length; i++) {</span>
<span class="nc bnc" id="L1669" title="All 8 branches missed.">                    if (((oldDisabled == null)</span>
                         || (i &gt;= oldDisabled.length)
                         || !oldDisabled[i])
                        &amp;&amp; newDisabled[i]) {
                        // case that a track gets muted: need to
                        // send appropriate note off events to prevent
                        // hanging notes

<span class="nc bnc" id="L1677" title="All 2 branches missed.">                        if (tracks.length &gt; i) {</span>
<span class="nc" id="L1678">                            sendNoteOffIfOn(tracks[i], lastTick);</span>
                        }
                    }
<span class="nc bnc" id="L1681" title="All 8 branches missed.">                    else if ((oldDisabled != null)</span>
                             &amp;&amp; (i &lt; oldDisabled.length)
                             &amp;&amp; oldDisabled[i]
                             &amp;&amp; !newDisabled[i]) {
                        // case that a track was muted and is now unmuted
                        // need to chase events and re-index this track
<span class="nc bnc" id="L1687" title="All 2 branches missed.">                        if (tempArray == null) {</span>
<span class="nc" id="L1688">                            tempArray = new byte[128][16];</span>
                        }
<span class="nc" id="L1690">                        chaseTrackEvents(i, 0, lastTick, true, tempArray);</span>
                    }
                }
<span class="nc" id="L1693">            }</span>
<span class="nc" id="L1694">        }</span>

        /** go through all events from startTick to endTick
         * chase the controller state and program change state
         * and then set the end-states at once.
         *
         * needs to be called in synchronized state
         * @param tempArray an byte[128][16] to hold controller messages
         */
        private void chaseTrackEvents(int trackNum,
                                      long startTick,
                                      long endTick,
                                      boolean doReindex,
                                      byte[][] tempArray) {
<span class="nc bnc" id="L1708" title="All 2 branches missed.">            if (startTick &gt; endTick) {</span>
                // start from the beginning
<span class="nc" id="L1710">                startTick = 0;</span>
            }
<span class="nc" id="L1712">            byte[] progs = new byte[16];</span>
            // init temp array with impossible values
<span class="nc bnc" id="L1714" title="All 2 branches missed.">            for (int ch = 0; ch &lt; 16; ch++) {</span>
<span class="nc" id="L1715">                progs[ch] = -1;</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">                for (int co = 0; co &lt; 128; co++) {</span>
<span class="nc" id="L1717">                    tempArray[co][ch] = -1;</span>
                }
            }
<span class="nc" id="L1720">            Track track = tracks[trackNum];</span>
<span class="nc" id="L1721">            int size = track.size();</span>
            try {
<span class="nc bnc" id="L1723" title="All 2 branches missed.">                for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1724">                    MidiEvent event = track.get(i);</span>
<span class="nc bnc" id="L1725" title="All 2 branches missed.">                    if (event.getTick() &gt;= endTick) {</span>
<span class="nc bnc" id="L1726" title="All 4 branches missed.">                        if (doReindex &amp;&amp; (trackNum &lt; trackReadPos.length)) {</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">                            trackReadPos[trackNum] = (i &gt; 0)?(i-1):0;</span>
                            if (DEBUG_PUMP) Printer.println(&quot;  chaseEvents: setting trackReadPos[&quot;+trackNum+&quot;] = &quot;+trackReadPos[trackNum]);
                        }
                        break;
                    }
<span class="nc" id="L1732">                    MidiMessage msg = event.getMessage();</span>
<span class="nc" id="L1733">                    int status = msg.getStatus();</span>
<span class="nc" id="L1734">                    int len = msg.getLength();</span>
<span class="nc bnc" id="L1735" title="All 4 branches missed.">                    if (len == 3 &amp;&amp; ((status &amp; 0xF0) == ShortMessage.CONTROL_CHANGE)) {</span>
<span class="nc bnc" id="L1736" title="All 2 branches missed.">                        if (msg instanceof ShortMessage) {</span>
<span class="nc" id="L1737">                            ShortMessage smsg = (ShortMessage) msg;</span>
<span class="nc" id="L1738">                            tempArray[smsg.getData1() &amp; 0x7F][status &amp; 0x0F] = (byte) smsg.getData2();</span>
<span class="nc" id="L1739">                        } else {</span>
<span class="nc" id="L1740">                            byte[] data = msg.getMessage();</span>
<span class="nc" id="L1741">                            tempArray[data[1] &amp; 0x7F][status &amp; 0x0F] = data[2];</span>
                        }
                    }
<span class="nc bnc" id="L1744" title="All 4 branches missed.">                    if (len == 2 &amp;&amp; ((status &amp; 0xF0) == ShortMessage.PROGRAM_CHANGE)) {</span>
<span class="nc bnc" id="L1745" title="All 2 branches missed.">                        if (msg instanceof ShortMessage) {</span>
<span class="nc" id="L1746">                            ShortMessage smsg = (ShortMessage) msg;</span>
<span class="nc" id="L1747">                            progs[status &amp; 0x0F] = (byte) smsg.getData1();</span>
<span class="nc" id="L1748">                        } else {</span>
<span class="nc" id="L1749">                            byte[] data = msg.getMessage();</span>
<span class="nc" id="L1750">                            progs[status &amp; 0x0F] = data[1];</span>
                        }
                    }
                }
<span class="nc" id="L1754">            } catch (ArrayIndexOutOfBoundsException aioobe) {</span>
                // this happens when messages are removed
                // from the track while this method executes
<span class="nc" id="L1757">            }</span>
<span class="nc" id="L1758">            int numControllersSent = 0;</span>
            // now send out the aggregated controllers and program changes
<span class="nc bnc" id="L1760" title="All 2 branches missed.">            for (int ch = 0; ch &lt; 16; ch++) {</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">                for (int co = 0; co &lt; 128; co++) {</span>
<span class="nc" id="L1762">                    byte controllerValue = tempArray[co][ch];</span>
<span class="nc bnc" id="L1763" title="All 2 branches missed.">                    if (controllerValue &gt;= 0) {</span>
<span class="nc" id="L1764">                        int packedMsg = (ShortMessage.CONTROL_CHANGE | ch) | (co&lt;&lt;8) | (controllerValue&lt;&lt;16);</span>
<span class="nc" id="L1765">                        getTransmitterList().sendMessage(packedMsg, -1);</span>
<span class="nc" id="L1766">                        numControllersSent++;</span>
                    }
                }
                // send program change *after* controllers, to
                // correctly initialize banks
<span class="nc bnc" id="L1771" title="All 2 branches missed.">                if (progs[ch] &gt;= 0) {</span>
<span class="nc" id="L1772">                    getTransmitterList().sendMessage((ShortMessage.PROGRAM_CHANGE | ch) | (progs[ch]&lt;&lt;8), -1);</span>
                }
<span class="nc bnc" id="L1774" title="All 6 branches missed.">                if (progs[ch] &gt;= 0 || startTick == 0 || endTick == 0) {</span>
                    // reset pitch bend on this channel (E0 00 40)
<span class="nc" id="L1776">                    getTransmitterList().sendMessage((ShortMessage.PITCH_BEND | ch) | (0x40 &lt;&lt; 16), -1);</span>
                    // reset sustain pedal on this channel
<span class="nc" id="L1778">                    getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (64 &lt;&lt; 8), -1);</span>
                }
            }
            if (DEBUG_PUMP) Printer.println(&quot;  chaseTrackEvents track &quot;+trackNum+&quot;: sent &quot;+numControllersSent+&quot; controllers.&quot;);
<span class="nc" id="L1782">        }</span>


        /** chase controllers and program for all tracks */
        synchronized void chaseEvents(long startTick, long endTick) {
            if (DEBUG_PUMP) Printer.println(&quot;&gt;&gt; chaseEvents from tick &quot;+startTick+&quot;..&quot;+(endTick-1));
<span class="nc" id="L1788">            byte[][] tempArray = new byte[128][16];</span>
<span class="nc bnc" id="L1789" title="All 2 branches missed.">            for (int t = 0; t &lt; tracks.length; t++) {</span>
<span class="nc bnc" id="L1790" title="All 6 branches missed.">                if ((trackDisabled == null)</span>
                    || (trackDisabled.length &lt;= t)
                    || (!trackDisabled[t])) {
                    // if track is not disabled, chase the events for it
<span class="nc" id="L1794">                    chaseTrackEvents(t, startTick, endTick, true, tempArray);</span>
                }
            }
            if (DEBUG_PUMP) Printer.println(&quot;&lt;&lt; chaseEvents&quot;);
<span class="nc" id="L1798">        }</span>


        // playback related methods (pumping)

        private long getCurrentTimeMillis() {
<span class="nc" id="L1804">            return System.nanoTime() / 1000000l;</span>
            //return perf.highResCounter() * 1000 / perfFreq;
        }

        private long millis2tick(long millis) {
<span class="nc bnc" id="L1809" title="All 2 branches missed.">            if (divisionType != Sequence.PPQ) {</span>
<span class="nc" id="L1810">                double dTick = ((((double) millis) * tempoFactor)</span>
                                * ((double) divisionType)
                                * ((double) resolution))
                    / ((double) 1000);
<span class="nc" id="L1814">                return (long) dTick;</span>
            }
<span class="nc" id="L1816">            return MidiUtils.microsec2ticks(millis * 1000,</span>
                                            currTempo * inverseTempoFactor,
                                            resolution);
        }

        private long tick2millis(long tick) {
<span class="nc bnc" id="L1822" title="All 2 branches missed.">            if (divisionType != Sequence.PPQ) {</span>
<span class="nc" id="L1823">                double dMillis = ((((double) tick) * 1000) /</span>
                                  (tempoFactor * ((double) divisionType) * ((double) resolution)));
<span class="nc" id="L1825">                return (long) dMillis;</span>
            }
<span class="nc" id="L1827">            return MidiUtils.ticks2microsec(tick,</span>
                                            currTempo * inverseTempoFactor,
                                            resolution) / 1000;
        }

        private void ReindexTrack(int trackNum, long tick) {
<span class="nc bnc" id="L1833" title="All 4 branches missed.">            if (trackNum &lt; trackReadPos.length &amp;&amp; trackNum &lt; tracks.length) {</span>
<span class="nc" id="L1834">                trackReadPos[trackNum] = MidiUtils.tick2index(tracks[trackNum], tick);</span>
                if (DEBUG_PUMP) Printer.println(&quot;  reindexTrack: setting trackReadPos[&quot;+trackNum+&quot;] = &quot;+trackReadPos[trackNum]);
            }
<span class="nc" id="L1837">        }</span>

        /* returns if changes are pending */
        private boolean dispatchMessage(int trackNum, MidiEvent event) {
<span class="nc" id="L1841">            boolean changesPending = false;</span>
<span class="nc" id="L1842">            MidiMessage message = event.getMessage();</span>
<span class="nc" id="L1843">            int msgStatus = message.getStatus();</span>
<span class="nc" id="L1844">            int msgLen = message.getLength();</span>
<span class="nc bnc" id="L1845" title="All 4 branches missed.">            if (msgStatus == MetaMessage.META &amp;&amp; msgLen &gt;= 2) {</span>
                // a meta message. Do not send it to the device.
                // 0xFF with length=1 is a MIDI realtime message
                // which shouldn't be in a Sequence, but we play it
                // nonetheless.

                // see if this is a tempo message. Only on track 0.
<span class="nc bnc" id="L1852" title="All 2 branches missed.">                if (trackNum == 0) {</span>
<span class="nc" id="L1853">                    int newTempo = MidiUtils.getTempoMPQ(message);</span>
<span class="nc bnc" id="L1854" title="All 2 branches missed.">                    if (newTempo &gt; 0) {</span>
<span class="nc bnc" id="L1855" title="All 2 branches missed.">                        if (event.getTick() != ignoreTempoEventAt) {</span>
<span class="nc" id="L1856">                            setTempoMPQ(newTempo); // sets ignoreTempoEventAt!</span>
<span class="nc" id="L1857">                            changesPending = true;</span>
                        }
                        // next loop, do not ignore anymore tempo events.
<span class="nc" id="L1860">                        ignoreTempoEventAt = -1;</span>
                    }
                }
                // send to listeners
<span class="nc" id="L1864">                sendMetaEvents(message);</span>

            } else {
                // not meta, send to device
<span class="nc" id="L1868">                getTransmitterList().sendMessage(message, -1);</span>

<span class="nc bnc" id="L1870" title="All 4 branches missed.">                switch (msgStatus &amp; 0xF0) {</span>
                case ShortMessage.NOTE_OFF: {
                    // note off - clear the bit in the noteOnCache array
<span class="nc" id="L1873">                    int note = ((ShortMessage) message).getData1() &amp; 0x7F;</span>
<span class="nc" id="L1874">                    noteOnCache[note] &amp;= (0xFFFF ^ (1&lt;&lt;(msgStatus &amp; 0x0F)));</span>
<span class="nc" id="L1875">                    break;</span>
                }

                case ShortMessage.NOTE_ON: {
                    // note on
<span class="nc" id="L1880">                    ShortMessage smsg = (ShortMessage) message;</span>
<span class="nc" id="L1881">                    int note = smsg.getData1() &amp; 0x7F;</span>
<span class="nc" id="L1882">                    int vel = smsg.getData2() &amp; 0x7F;</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">                    if (vel &gt; 0) {</span>
                        // if velocity &gt; 0 set the bit in the noteOnCache array
<span class="nc" id="L1885">                        noteOnCache[note] |= 1&lt;&lt;(msgStatus &amp; 0x0F);</span>
                    } else {
                        // if velocity = 0 clear the bit in the noteOnCache array
<span class="nc" id="L1888">                        noteOnCache[note] &amp;= (0xFFFF ^ (1&lt;&lt;(msgStatus &amp; 0x0F)));</span>
                    }
<span class="nc" id="L1890">                    break;</span>
                }

                case ShortMessage.CONTROL_CHANGE:
                    // if controller message, send controller listeners
<span class="nc" id="L1895">                    sendControllerEvents(message);</span>
                    break;

                }
            }
<span class="nc" id="L1900">            return changesPending;</span>
        }


        /** the main pump method
         * @return true if end of sequence is reached
         */
        synchronized boolean pump() {
            long currMillis;
<span class="nc" id="L1909">            long targetTick = lastTick;</span>
            MidiEvent currEvent;
<span class="nc" id="L1911">            boolean changesPending = false;</span>
<span class="nc" id="L1912">            boolean doLoop = false;</span>
<span class="nc" id="L1913">            boolean EOM = false;</span>

<span class="nc" id="L1915">            currMillis = getCurrentTimeMillis();</span>
<span class="nc" id="L1916">            int finishedTracks = 0;</span>
            do {
<span class="nc" id="L1918">                changesPending = false;</span>

                // need to re-find indexes in tracks?
<span class="nc bnc" id="L1921" title="All 2 branches missed.">                if (needReindex) {</span>
                    if (DEBUG_PUMP) Printer.println(&quot;Need to re-index at &quot;+currMillis+&quot; millis. TargetTick=&quot;+targetTick);
<span class="nc bnc" id="L1923" title="All 2 branches missed.">                    if (trackReadPos.length &lt; tracks.length) {</span>
<span class="nc" id="L1924">                        trackReadPos = new int[tracks.length];</span>
                    }
<span class="nc bnc" id="L1926" title="All 2 branches missed.">                    for (int t = 0; t &lt; tracks.length; t++) {</span>
<span class="nc" id="L1927">                        ReindexTrack(t, targetTick);</span>
                        if (DEBUG_PUMP_ALL) Printer.println(&quot;  Setting trackReadPos[&quot;+t+&quot;]=&quot;+trackReadPos[t]);
                    }
<span class="nc" id="L1930">                    needReindex = false;</span>
<span class="nc" id="L1931">                    checkPointMillis = 0;</span>
                }

                // get target tick from current time in millis
<span class="nc bnc" id="L1935" title="All 2 branches missed.">                if (checkPointMillis == 0) {</span>
                    // new check point
<span class="nc" id="L1937">                    currMillis = getCurrentTimeMillis();</span>
<span class="nc" id="L1938">                    checkPointMillis = currMillis;</span>
<span class="nc" id="L1939">                    targetTick = lastTick;</span>
<span class="nc" id="L1940">                    checkPointTick = targetTick;</span>
                    if (DEBUG_PUMP) Printer.println(&quot;New checkpoint to &quot;+currMillis+&quot; millis. &quot;
                                                       +&quot;TargetTick=&quot;+targetTick
                                                       +&quot; new tempo=&quot;+MidiUtils.convertTempo(currTempo)+&quot;bpm&quot;);
                } else {
                    // calculate current tick based on current time in milliseconds
<span class="nc" id="L1946">                    targetTick = checkPointTick + millis2tick(currMillis - checkPointMillis);</span>
                    if (DEBUG_PUMP_ALL) Printer.println(&quot;targetTick = &quot;+targetTick+&quot; at &quot;+currMillis+&quot; millis&quot;);
<span class="nc bnc" id="L1948" title="All 2 branches missed.">                    if ((loopEnd != -1)</span>
<span class="nc bnc" id="L1949" title="All 4 branches missed.">                        &amp;&amp; ((loopCount &gt; 0 &amp;&amp; currLoopCounter &gt; 0)</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">                            || (loopCount == LOOP_CONTINUOUSLY))) {</span>
<span class="nc bnc" id="L1951" title="All 4 branches missed.">                        if (lastTick &lt;= loopEnd &amp;&amp; targetTick &gt;= loopEnd) {</span>
                            // need to loop!
                            // only play until loop end
<span class="nc" id="L1954">                            targetTick = loopEnd - 1;</span>
<span class="nc" id="L1955">                            doLoop = true;</span>
                            if (DEBUG_PUMP) Printer.println(&quot;set doLoop to true. lastTick=&quot;+lastTick
                                                               +&quot;  targetTick=&quot;+targetTick
                                                               +&quot;  loopEnd=&quot;+loopEnd
                                                               +&quot;  jumping to loopStart=&quot;+loopStart
                                                               +&quot;  new currLoopCounter=&quot;+currLoopCounter);
                            if (DEBUG_PUMP) Printer.println(&quot;  currMillis=&quot;+currMillis
                                                               +&quot;  checkPointMillis=&quot;+checkPointMillis
                                                               +&quot;  checkPointTick=&quot;+checkPointTick);

                        }
                    }
<span class="nc" id="L1967">                    lastTick = targetTick;</span>
                }

<span class="nc" id="L1970">                finishedTracks = 0;</span>

<span class="nc bnc" id="L1972" title="All 2 branches missed.">                for (int t = 0; t &lt; tracks.length; t++) {</span>
                    try {
<span class="nc" id="L1974">                        boolean disabled = trackDisabled[t];</span>
<span class="nc" id="L1975">                        Track thisTrack = tracks[t];</span>
<span class="nc" id="L1976">                        int readPos = trackReadPos[t];</span>
<span class="nc" id="L1977">                        int size = thisTrack.size();</span>
                        // play all events that are due until targetTick
<span class="nc bnc" id="L1979" title="All 4 branches missed.">                        while (!changesPending &amp;&amp; (readPos &lt; size)</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">                               &amp;&amp; (currEvent = thisTrack.get(readPos)).getTick() &lt;= targetTick) {</span>

<span class="nc bnc" id="L1982" title="All 4 branches missed.">                            if ((readPos == size -1) &amp;&amp;  MidiUtils.isMetaEndOfTrack(currEvent.getMessage())) {</span>
                                // do not send out this message. Finished with this track
<span class="nc" id="L1984">                                readPos = size;</span>
<span class="nc" id="L1985">                                break;</span>
                            }
                            // TODO: some kind of heuristics if the MIDI messages have changed
                            // significantly (i.e. deleted or inserted a bunch of messages)
                            // since last time. Would need to set needReindex = true then
<span class="nc" id="L1990">                            readPos++;</span>
                            // only play this event if the track is enabled,
                            // or if it is a tempo message on track 0
                            // Note: cannot put this check outside
                            //       this inner loop in order to detect end of file
<span class="nc bnc" id="L1995" title="All 4 branches missed.">                            if (!disabled ||</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">                                ((t == 0) &amp;&amp; (MidiUtils.isMetaTempo(currEvent.getMessage())))) {</span>
<span class="nc" id="L1997">                                changesPending = dispatchMessage(t, currEvent);</span>
                            }
                        }
<span class="nc bnc" id="L2000" title="All 2 branches missed.">                        if (readPos &gt;= size) {</span>
<span class="nc" id="L2001">                            finishedTracks++;</span>
                        }
                        if (DEBUG_PUMP_ALL) {
                            System.out.print(&quot; pumped track &quot;+t+&quot; (&quot;+size+&quot; events) &quot;
                                             +&quot; from index: &quot;+trackReadPos[t]
                                             +&quot; to &quot;+(readPos-1));
                            System.out.print(&quot; -&gt; ticks: &quot;);
                            if (trackReadPos[t] &lt; size) {
                                System.out.print(&quot;&quot;+(thisTrack.get(trackReadPos[t]).getTick()));
                            } else {
                                System.out.print(&quot;EOT&quot;);
                            }
                            System.out.print(&quot; to &quot;);
                            if (readPos &lt; size) {
                                System.out.print(&quot;&quot;+(thisTrack.get(readPos-1).getTick()));
                            } else {
                                System.out.print(&quot;EOT&quot;);
                            }
                            System.out.println();
                        }
<span class="nc" id="L2021">                        trackReadPos[t] = readPos;</span>
<span class="nc" id="L2022">                    } catch(Exception e) {</span>
                        if (Printer.debug) Printer.debug(&quot;Exception in Sequencer pump!&quot;);
                        if (Printer.debug) e.printStackTrace();
<span class="nc bnc" id="L2025" title="All 2 branches missed.">                        if (e instanceof ArrayIndexOutOfBoundsException) {</span>
<span class="nc" id="L2026">                            needReindex = true;</span>
<span class="nc" id="L2027">                            changesPending = true;</span>
                        }
<span class="nc" id="L2029">                    }</span>
<span class="nc bnc" id="L2030" title="All 2 branches missed.">                    if (changesPending) {</span>
<span class="nc" id="L2031">                        break;</span>
                    }
                }
<span class="nc bnc" id="L2034" title="All 2 branches missed.">                EOM = (finishedTracks == tracks.length);</span>
<span class="nc bnc" id="L2035" title="All 2 branches missed.">                if (doLoop</span>
<span class="nc bnc" id="L2036" title="All 4 branches missed.">                    || ( ((loopCount &gt; 0 &amp;&amp; currLoopCounter &gt; 0)</span>
<span class="nc bnc" id="L2037" title="All 4 branches missed.">                          || (loopCount == LOOP_CONTINUOUSLY))</span>
                         &amp;&amp; !changesPending
<span class="nc bnc" id="L2039" title="All 4 branches missed.">                         &amp;&amp; (loopEnd == -1)</span>
                         &amp;&amp; EOM)) {

<span class="nc" id="L2042">                    long oldCheckPointMillis = checkPointMillis;</span>
<span class="nc" id="L2043">                    long loopEndTick = loopEnd;</span>
<span class="nc bnc" id="L2044" title="All 2 branches missed.">                    if (loopEndTick == -1) {</span>
<span class="nc" id="L2045">                        loopEndTick = lastTick;</span>
                    }

                    // need to loop back!
<span class="nc bnc" id="L2049" title="All 2 branches missed.">                    if (loopCount != LOOP_CONTINUOUSLY) {</span>
<span class="nc" id="L2050">                        currLoopCounter--;</span>
                    }
                    if (DEBUG_PUMP) Printer.println(&quot;Execute loop: lastTick=&quot;+lastTick
                                                       +&quot;  loopEnd=&quot;+loopEnd
                                                       +&quot;  jumping to loopStart=&quot;+loopStart
                                                       +&quot;  new currLoopCounter=&quot;+currLoopCounter);
<span class="nc" id="L2056">                    setTickPos(loopStart);</span>
                    // now patch the checkPointMillis so that
                    // it points to the exact beginning of when the loop was finished

                    // $$fb TODO: although this is mathematically correct (i.e. the loop position
                    //            is correct, and doesn't drift away with several repetition,
                    //            there is a slight lag when looping back, probably caused
                    //            by the chasing.

<span class="nc" id="L2065">                    checkPointMillis = oldCheckPointMillis + tick2millis(loopEndTick - checkPointTick);</span>
<span class="nc" id="L2066">                    checkPointTick = loopStart;</span>
                    if (DEBUG_PUMP) Printer.println(&quot;  Setting currMillis=&quot;+currMillis
                                                       +&quot;  new checkPointMillis=&quot;+checkPointMillis
                                                       +&quot;  new checkPointTick=&quot;+checkPointTick);
                    // no need for reindexing, is done in setTickPos
<span class="nc" id="L2071">                    needReindex = false;</span>
<span class="nc" id="L2072">                    changesPending = false;</span>
                    // reset doLoop flag
<span class="nc" id="L2074">                    doLoop = false;</span>
<span class="nc" id="L2075">                    EOM = false;</span>
                }
<span class="nc bnc" id="L2077" title="All 2 branches missed.">            } while (changesPending);</span>

<span class="nc" id="L2079">            return EOM;</span>
        }

    } // class DataPump

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>