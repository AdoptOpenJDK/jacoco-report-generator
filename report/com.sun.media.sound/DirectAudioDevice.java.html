<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DirectAudioDevice.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">DirectAudioDevice.java</span></div><h1>DirectAudioDevice.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Vector;

import javax.sound.sampled.*;

// IDEA:
// Use java.util.concurrent.Semaphore,
// java.util.concurrent.locks.ReentrantLock and other new classes/methods
// to improve this class's thread safety.


/**
 * A Mixer which provides direct access to audio devices
 *
 * @author Florian Bomers
 */
final class DirectAudioDevice extends AbstractMixer {

    // CONSTANTS
    private static final int CLIP_BUFFER_TIME = 1000; // in milliseconds

    private static final int DEFAULT_LINE_BUFFER_TIME = 500; // in milliseconds

    // INSTANCE VARIABLES

    /** number of opened lines */
<span class="nc" id="L55">    private int deviceCountOpened = 0;</span>

    /** number of started lines */
<span class="nc" id="L58">    private int deviceCountStarted = 0;</span>

    // CONSTRUCTOR
    DirectAudioDevice(DirectAudioDeviceProvider.DirectAudioDeviceInfo portMixerInfo) {
        // pass in Line.Info, mixer, controls
<span class="nc" id="L63">        super(portMixerInfo,              // Mixer.Info</span>
              null,                       // Control[]
              null,                       // Line.Info[] sourceLineInfo
              null);                      // Line.Info[] targetLineInfo

        if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectAudioDevice: constructor&quot;);

        // source lines
<span class="nc" id="L71">        DirectDLI srcLineInfo = createDataLineInfo(true);</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        if (srcLineInfo != null) {</span>
<span class="nc" id="L73">            sourceLineInfo = new Line.Info[2];</span>
            // SourcedataLine
<span class="nc" id="L75">            sourceLineInfo[0] = srcLineInfo;</span>
            // Clip
<span class="nc" id="L77">            sourceLineInfo[1] = new DirectDLI(Clip.class, srcLineInfo.getFormats(),</span>
<span class="nc" id="L78">                                              srcLineInfo.getHardwareFormats(),</span>
                                              32, // arbitrary minimum buffer size
                                              AudioSystem.NOT_SPECIFIED);
        } else {
<span class="nc" id="L82">            sourceLineInfo = new Line.Info[0];</span>
        }

        // TargetDataLine
<span class="nc" id="L86">        DataLine.Info dstLineInfo = createDataLineInfo(false);</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (dstLineInfo != null) {</span>
<span class="nc" id="L88">            targetLineInfo = new Line.Info[1];</span>
<span class="nc" id="L89">            targetLineInfo[0] = dstLineInfo;</span>
        } else {
<span class="nc" id="L91">            targetLineInfo = new Line.Info[0];</span>
        }
        if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectAudioDevice: constructor completed&quot;);
<span class="nc" id="L94">    }</span>

    private DirectDLI createDataLineInfo(boolean isSource) {
<span class="nc" id="L97">        Vector formats = new Vector();</span>
<span class="nc" id="L98">        AudioFormat[] hardwareFormatArray = null;</span>
<span class="nc" id="L99">        AudioFormat[] formatArray = null;</span>

<span class="nc" id="L101">        synchronized(formats) {</span>
<span class="nc" id="L102">            nGetFormats(getMixerIndex(), getDeviceID(),</span>
                        isSource /* true:SourceDataLine/Clip, false:TargetDataLine */,
                        formats);
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (formats.size() &gt; 0) {</span>
<span class="nc" id="L106">                int size = formats.size();</span>
<span class="nc" id="L107">                int formatArraySize = size;</span>
<span class="nc" id="L108">                hardwareFormatArray = new AudioFormat[size];</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">                for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L110">                    AudioFormat format = (AudioFormat)formats.elementAt(i);</span>
<span class="nc" id="L111">                    hardwareFormatArray[i] = format;</span>
<span class="nc" id="L112">                    int bits = format.getSampleSizeInBits();</span>
<span class="nc" id="L113">                    boolean isSigned = format.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED);</span>
<span class="nc" id="L114">                    boolean isUnsigned = format.getEncoding().equals(AudioFormat.Encoding.PCM_UNSIGNED);</span>
<span class="nc bnc" id="L115" title="All 4 branches missed.">                    if ((isSigned || isUnsigned)) {</span>
                        // will insert a magically converted format here
<span class="nc" id="L117">                        formatArraySize++;</span>
                    }
                }
<span class="nc" id="L120">                formatArray = new AudioFormat[formatArraySize];</span>
<span class="nc" id="L121">                int formatArrayIndex = 0;</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">                for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L123">                    AudioFormat format = hardwareFormatArray[i];</span>
<span class="nc" id="L124">                    formatArray[formatArrayIndex++] = format;</span>
<span class="nc" id="L125">                    int bits = format.getSampleSizeInBits();</span>
<span class="nc" id="L126">                    boolean isSigned = format.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED);</span>
<span class="nc" id="L127">                    boolean isUnsigned = format.getEncoding().equals(AudioFormat.Encoding.PCM_UNSIGNED);</span>
                    // add convenience formats (automatic conversion)
<span class="nc bnc" id="L129" title="All 2 branches missed.">                    if (bits == 8) {</span>
                        // add the other signed'ness for 8-bit
<span class="nc bnc" id="L131" title="All 2 branches missed.">                        if (isSigned) {</span>
<span class="nc" id="L132">                            formatArray[formatArrayIndex++] =</span>
                                new AudioFormat(AudioFormat.Encoding.PCM_UNSIGNED,
<span class="nc" id="L134">                                    format.getSampleRate(), bits, format.getChannels(),</span>
<span class="nc" id="L135">                                    format.getFrameSize(), format.getSampleRate(),</span>
<span class="nc" id="L136">                                    format.isBigEndian());</span>
                        }
<span class="nc bnc" id="L138" title="All 2 branches missed.">                        else if (isUnsigned) {</span>
<span class="nc" id="L139">                            formatArray[formatArrayIndex++] =</span>
                                new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,
<span class="nc" id="L141">                                    format.getSampleRate(), bits, format.getChannels(),</span>
<span class="nc" id="L142">                                    format.getFrameSize(), format.getSampleRate(),</span>
<span class="nc" id="L143">                                    format.isBigEndian());</span>
                        }
<span class="nc bnc" id="L145" title="All 6 branches missed.">                    } else if (bits &gt; 8 &amp;&amp; (isSigned || isUnsigned)) {</span>
                        // add the other endian'ness for more than 8-bit
<span class="nc" id="L147">                        formatArray[formatArrayIndex++] =</span>
<span class="nc" id="L148">                            new AudioFormat(format.getEncoding(),</span>
<span class="nc" id="L149">                                              format.getSampleRate(), bits,</span>
<span class="nc" id="L150">                                              format.getChannels(),</span>
<span class="nc" id="L151">                                              format.getFrameSize(),</span>
<span class="nc" id="L152">                                              format.getSampleRate(),</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                                              !format.isBigEndian());</span>
                    }
                    //System.out.println(&quot;Adding &quot;+v.get(v.size()-1));
                }
            }
<span class="nc" id="L158">        }</span>
        // todo: find out more about the buffer size ?
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (formatArray != null) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            return new DirectDLI(isSource?SourceDataLine.class:TargetDataLine.class,</span>
                                 formatArray, hardwareFormatArray,
                                 32, // arbitrary minimum buffer size
                                 AudioSystem.NOT_SPECIFIED);
        }
<span class="nc" id="L166">        return null;</span>
    }

    // ABSTRACT MIXER: ABSTRACT METHOD IMPLEMENTATIONS

    public Line getLine(Line.Info info) throws LineUnavailableException {
<span class="nc" id="L172">        Line.Info fullInfo = getLineInfo(info);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (fullInfo == null) {</span>
<span class="nc" id="L174">            throw new IllegalArgumentException(&quot;Line unsupported: &quot; + info);</span>
        }
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (fullInfo instanceof DataLine.Info) {</span>

<span class="nc" id="L178">            DataLine.Info dataLineInfo = (DataLine.Info)fullInfo;</span>
            AudioFormat lineFormat;
<span class="nc" id="L180">            int lineBufferSize = AudioSystem.NOT_SPECIFIED;</span>

            // if a format is specified by the info class passed in, use it.
            // otherwise use a format from fullInfo.

<span class="nc" id="L185">            AudioFormat[] supportedFormats = null;</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (info instanceof DataLine.Info) {</span>
<span class="nc" id="L188">                supportedFormats = ((DataLine.Info)info).getFormats();</span>
<span class="nc" id="L189">                lineBufferSize = ((DataLine.Info)info).getMaxBufferSize();</span>
            }

<span class="nc bnc" id="L192" title="All 4 branches missed.">            if ((supportedFormats == null) || (supportedFormats.length == 0)) {</span>
                // use the default format
<span class="nc" id="L194">                lineFormat = null;</span>
            } else {
                // use the last format specified in the line.info object passed
                // in by the app
<span class="nc" id="L198">                lineFormat = supportedFormats[supportedFormats.length-1];</span>

                // if something is not specified, use default format
<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (!Toolkit.isFullySpecifiedPCMFormat(lineFormat)) {</span>
<span class="nc" id="L202">                    lineFormat = null;</span>
                }
            }

<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (dataLineInfo.getLineClass().isAssignableFrom(DirectSDL.class)) {</span>
<span class="nc" id="L207">                return new DirectSDL(dataLineInfo, lineFormat, lineBufferSize, this);</span>
            }
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (dataLineInfo.getLineClass().isAssignableFrom(DirectClip.class)) {</span>
<span class="nc" id="L210">                return new DirectClip(dataLineInfo, lineFormat, lineBufferSize, this);</span>
            }
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (dataLineInfo.getLineClass().isAssignableFrom(DirectTDL.class)) {</span>
<span class="nc" id="L213">                return new DirectTDL(dataLineInfo, lineFormat, lineBufferSize, this);</span>
            }
        }
<span class="nc" id="L216">        throw new IllegalArgumentException(&quot;Line unsupported: &quot; + info);</span>
    }


    public int getMaxLines(Line.Info info) {
<span class="nc" id="L221">        Line.Info fullInfo = getLineInfo(info);</span>

        // if it's not supported at all, return 0.
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (fullInfo == null) {</span>
<span class="nc" id="L225">            return 0;</span>
        }

<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (fullInfo instanceof DataLine.Info) {</span>
            // DirectAudioDevices should mix !
<span class="nc" id="L230">            return getMaxSimulLines();</span>
        }

<span class="nc" id="L233">        return 0;</span>
    }


    protected void implOpen() throws LineUnavailableException {
        if (Printer.trace) Printer.trace(&quot;DirectAudioDevice: implOpen - void method&quot;);
<span class="nc" id="L239">    }</span>

    protected void implClose() {
        if (Printer.trace) Printer.trace(&quot;DirectAudioDevice: implClose - void method&quot;);
<span class="nc" id="L243">    }</span>

    protected void implStart() {
        if (Printer.trace) Printer.trace(&quot;DirectAudioDevice: implStart - void method&quot;);
<span class="nc" id="L247">    }</span>

    protected void implStop() {
        if (Printer.trace) Printer.trace(&quot;DirectAudioDevice: implStop - void method&quot;);
<span class="nc" id="L251">    }</span>


    // IMPLEMENTATION HELPERS

    int getMixerIndex() {
<span class="nc" id="L257">        return ((DirectAudioDeviceProvider.DirectAudioDeviceInfo) getMixerInfo()).getIndex();</span>
    }

    int getDeviceID() {
<span class="nc" id="L261">        return ((DirectAudioDeviceProvider.DirectAudioDeviceInfo) getMixerInfo()).getDeviceID();</span>
    }

    int getMaxSimulLines() {
<span class="nc" id="L265">        return ((DirectAudioDeviceProvider.DirectAudioDeviceInfo) getMixerInfo()).getMaxSimulLines();</span>
    }

    private static void addFormat(Vector v, int bits, int frameSizeInBytes, int channels, float sampleRate,
                                  int encoding, boolean signed, boolean bigEndian) {
<span class="nc" id="L270">        AudioFormat.Encoding enc = null;</span>
<span class="nc bnc" id="L271" title="All 4 branches missed.">        switch (encoding) {</span>
        case PCM:
<span class="nc bnc" id="L273" title="All 2 branches missed.">            enc = signed?AudioFormat.Encoding.PCM_SIGNED:AudioFormat.Encoding.PCM_UNSIGNED;</span>
<span class="nc" id="L274">            break;</span>
        case ULAW:
<span class="nc" id="L276">            enc = AudioFormat.Encoding.ULAW;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (bits != 8) {</span>
                if (Printer.err) Printer.err(&quot;DirectAudioDevice.addFormat called with ULAW, but bitsPerSample=&quot;+bits);
<span class="nc" id="L279">                bits = 8; frameSizeInBytes = channels;</span>
            }
            break;
        case ALAW:
<span class="nc" id="L283">            enc = AudioFormat.Encoding.ALAW;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">            if (bits != 8) {</span>
                if (Printer.err) Printer.err(&quot;DirectAudioDevice.addFormat called with ALAW, but bitsPerSample=&quot;+bits);
<span class="nc" id="L286">                bits = 8; frameSizeInBytes = channels;</span>
            }
            break;
        }
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (enc==null) {</span>
            if (Printer.err) Printer.err(&quot;DirectAudioDevice.addFormat called with unknown encoding: &quot;+encoding);
<span class="nc" id="L292">            return;</span>
        }
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (frameSizeInBytes &lt;= 0) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (channels &gt; 0) {</span>
<span class="nc" id="L296">                frameSizeInBytes = ((bits + 7) / 8) * channels;</span>
            } else {
<span class="nc" id="L298">                frameSizeInBytes = AudioSystem.NOT_SPECIFIED;</span>
            }
        }
<span class="nc" id="L301">        v.add(new AudioFormat(enc, sampleRate, bits, channels, frameSizeInBytes, sampleRate, bigEndian));</span>
<span class="nc" id="L302">    }</span>

    protected static AudioFormat getSignOrEndianChangedFormat(AudioFormat format) {
<span class="nc" id="L305">        boolean isSigned = format.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED);</span>
<span class="nc" id="L306">        boolean isUnsigned = format.getEncoding().equals(AudioFormat.Encoding.PCM_UNSIGNED);</span>
<span class="nc bnc" id="L307" title="All 4 branches missed.">        if (format.getSampleSizeInBits() &gt; 8 &amp;&amp; isSigned) {</span>
            // if this is PCM_SIGNED and 16-bit or higher, then try with endian-ness magic
<span class="nc" id="L309">            return new AudioFormat(format.getEncoding(),</span>
<span class="nc" id="L310">                                   format.getSampleRate(), format.getSampleSizeInBits(), format.getChannels(),</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                                   format.getFrameSize(), format.getFrameRate(), !format.isBigEndian());</span>
        }
<span class="nc bnc" id="L313" title="All 6 branches missed.">        else if (format.getSampleSizeInBits() == 8 &amp;&amp; (isSigned || isUnsigned)) {</span>
            // if this is PCM and 8-bit, then try with signed-ness magic
<span class="nc bnc" id="L315" title="All 2 branches missed.">            return new AudioFormat(isSigned?AudioFormat.Encoding.PCM_UNSIGNED:AudioFormat.Encoding.PCM_SIGNED,</span>
<span class="nc" id="L316">                                   format.getSampleRate(), format.getSampleSizeInBits(), format.getChannels(),</span>
<span class="nc" id="L317">                                   format.getFrameSize(), format.getFrameRate(), format.isBigEndian());</span>
        }
<span class="nc" id="L319">        return null;</span>
    }




    // INNER CLASSES


    /**
     * Private inner class for the DataLine.Info objects
     * adds a little magic for the isFormatSupported so
     * that the automagic conversion of endianness and sign
     * does not show up in the formats array.
     * I.e. the formats array contains only the formats
     * that are really supported by the hardware,
     * but isFormatSupported() also returns true
     * for formats with wrong endianness.
     */
    private static final class DirectDLI extends DataLine.Info {
        final AudioFormat[] hardwareFormats;

        private DirectDLI(Class clazz, AudioFormat[] formatArray,
                          AudioFormat[] hardwareFormatArray,
                          int minBuffer, int maxBuffer) {
<span class="nc" id="L344">            super(clazz, formatArray, minBuffer, maxBuffer);</span>
<span class="nc" id="L345">            this.hardwareFormats = hardwareFormatArray;</span>
<span class="nc" id="L346">        }</span>

        public boolean isFormatSupportedInHardware(AudioFormat format) {
<span class="nc bnc" id="L349" title="All 2 branches missed.">            if (format == null) return false;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            for (int i = 0; i &lt; hardwareFormats.length; i++) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                if (format.matches(hardwareFormats[i])) {</span>
<span class="nc" id="L352">                    return true;</span>
                }
            }
<span class="nc" id="L355">            return false;</span>
        }

        /*public boolean isFormatSupported(AudioFormat format) {
         *   return isFormatSupportedInHardware(format)
         *      || isFormatSupportedInHardware(getSignOrEndianChangedFormat(format));
         *}
         */

         private AudioFormat[] getHardwareFormats() {
<span class="nc" id="L365">             return hardwareFormats;</span>
         }
    }

    /**
     * Private inner class as base class for direct lines
     */
    private static class DirectDL extends AbstractDataLine implements EventDispatcher.LineMonitor {
        protected final int mixerIndex;
        protected final int deviceID;
        protected long id;
        protected int waitTime;
<span class="nc" id="L377">        protected volatile boolean flushing = false;</span>
        protected final boolean isSource;         // true for SourceDataLine, false for TargetDataLine
        protected volatile long bytePosition;
<span class="nc" id="L380">        protected volatile boolean doIO = false;     // true in between start() and stop() calls</span>
<span class="nc" id="L381">        protected volatile boolean stoppedWritten = false; // true if a write occurred in stopped state</span>
<span class="nc" id="L382">        protected volatile boolean drained = false; // set to true when drain function returns, set to false in write()</span>
<span class="nc" id="L383">        protected boolean monitoring = false;</span>

        // if native needs to manually swap samples/convert sign, this
        // is set to the framesize
<span class="nc" id="L387">        protected int softwareConversionSize = 0;</span>
        protected AudioFormat hardwareFormat;

<span class="nc" id="L390">        private final Gain gainControl = new Gain();</span>
<span class="nc" id="L391">        private final Mute muteControl = new Mute();</span>
<span class="nc" id="L392">        private final Balance balanceControl = new Balance();</span>
<span class="nc" id="L393">        private final Pan panControl = new Pan();</span>
        private float leftGain, rightGain;
<span class="nc" id="L395">        protected volatile boolean noService = false; // do not run the nService method</span>

        // Guards all native calls.
<span class="nc" id="L398">        protected final Object lockNative = new Object();</span>

        // CONSTRUCTOR
        protected DirectDL(DataLine.Info info,
                           DirectAudioDevice mixer,
                           AudioFormat format,
                           int bufferSize,
                           int mixerIndex,
                           int deviceID,
                           boolean isSource) {
<span class="nc" id="L408">            super(info, mixer, null, format, bufferSize);</span>
            if (Printer.trace) Printer.trace(&quot;DirectDL CONSTRUCTOR: info: &quot; + info);
<span class="nc" id="L410">            this.mixerIndex = mixerIndex;</span>
<span class="nc" id="L411">            this.deviceID = deviceID;</span>
<span class="nc" id="L412">            this.waitTime = 10; // 10 milliseconds default wait time</span>
<span class="nc" id="L413">            this.isSource = isSource;</span>

<span class="nc" id="L415">        }</span>


        // ABSTRACT METHOD IMPLEMENTATIONS

        // ABSTRACT LINE / DATALINE

        void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException {
            if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectDL: implOpen(&quot;+format+&quot;, &quot;+bufferSize+&quot; bytes)&quot;);

            // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
<span class="nc" id="L426">            Toolkit.isFullySpecifiedAudioFormat(format);</span>

            // check for record permission
<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (!isSource) {</span>
<span class="nc" id="L430">                JSSecurityManager.checkRecordPermission();</span>
            }
<span class="nc" id="L432">            int encoding = PCM;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (format.getEncoding().equals(AudioFormat.Encoding.ULAW)) {</span>
<span class="nc" id="L434">                encoding = ULAW;</span>
            }
<span class="nc bnc" id="L436" title="All 2 branches missed.">            else if (format.getEncoding().equals(AudioFormat.Encoding.ALAW)) {</span>
<span class="nc" id="L437">                encoding = ALAW;</span>
            }

<span class="nc bnc" id="L440" title="All 2 branches missed.">            if (bufferSize &lt;= AudioSystem.NOT_SPECIFIED) {</span>
<span class="nc" id="L441">                bufferSize = (int) Toolkit.millis2bytes(format, DEFAULT_LINE_BUFFER_TIME);</span>
            }

<span class="nc" id="L444">            DirectDLI ddli = null;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            if (info instanceof DirectDLI) {</span>
<span class="nc" id="L446">                ddli = (DirectDLI) info;</span>
            }

            /* set up controls */
<span class="nc bnc" id="L450" title="All 2 branches missed.">            if (isSource) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                if (!format.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED)</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">                    &amp;&amp; !format.getEncoding().equals(AudioFormat.Encoding.PCM_UNSIGNED)) {</span>
                    // no controls for non-PCM formats */
<span class="nc" id="L454">                    controls = new Control[0];</span>
                }
<span class="nc bnc" id="L456" title="All 2 branches missed.">                else if (format.getChannels() &gt; 2</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                         || format.getSampleSizeInBits() &gt; 16) {</span>
                    // no support for more than 2 channels or more than 16 bits
<span class="nc" id="L459">                    controls = new Control[0];</span>
                } else {
<span class="nc bnc" id="L461" title="All 2 branches missed.">                    if (format.getChannels() == 1) {</span>
<span class="nc" id="L462">                        controls = new Control[2];</span>
                    } else {
<span class="nc" id="L464">                        controls = new Control[4];</span>
<span class="nc" id="L465">                        controls[2] = balanceControl;</span>
                        /* to keep compatibility with apps that rely on
                         * MixerSourceLine's PanControl
                         */
<span class="nc" id="L469">                        controls[3] = panControl;</span>
                    }
<span class="nc" id="L471">                    controls[0] = gainControl;</span>
<span class="nc" id="L472">                    controls[1] = muteControl;</span>
                }
            }
            if (Printer.debug) Printer.debug(&quot;DirectAudioDevice: got &quot;+controls.length+&quot; controls.&quot;);

<span class="nc" id="L477">            hardwareFormat = format;</span>

            /* some magic to account for not-supported endianness or signed-ness */
<span class="nc" id="L480">            softwareConversionSize = 0;</span>
<span class="nc bnc" id="L481" title="All 4 branches missed.">            if (ddli != null &amp;&amp; !ddli.isFormatSupportedInHardware(format)) {</span>
<span class="nc" id="L482">                AudioFormat newFormat = getSignOrEndianChangedFormat(format);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                if (ddli.isFormatSupportedInHardware(newFormat)) {</span>
                    // apparently, the new format can be used.
<span class="nc" id="L485">                    hardwareFormat = newFormat;</span>
                    // So do endian/sign conversion in software
<span class="nc" id="L487">                    softwareConversionSize = format.getFrameSize() / format.getChannels();</span>
                    if (Printer.debug) {
                        Printer.debug(&quot;DirectAudioDevice: softwareConversionSize &quot;
                                      +softwareConversionSize+&quot;:&quot;);
                        Printer.debug(&quot;  from &quot;+format);
                        Printer.debug(&quot;  to   &quot;+newFormat);
                    }
                }
            }

            // align buffer to full frames
<span class="nc" id="L498">            bufferSize = ((int) bufferSize / format.getFrameSize()) * format.getFrameSize();</span>

<span class="nc" id="L500">            id = nOpen(mixerIndex, deviceID, isSource,</span>
                    encoding,
<span class="nc" id="L502">                    hardwareFormat.getSampleRate(),</span>
<span class="nc" id="L503">                    hardwareFormat.getSampleSizeInBits(),</span>
<span class="nc" id="L504">                    hardwareFormat.getFrameSize(),</span>
<span class="nc" id="L505">                    hardwareFormat.getChannels(),</span>
<span class="nc" id="L506">                    hardwareFormat.getEncoding().equals(</span>
                        AudioFormat.Encoding.PCM_SIGNED),
<span class="nc" id="L508">                    hardwareFormat.isBigEndian(),</span>
                    bufferSize);

<span class="nc bnc" id="L511" title="All 2 branches missed.">            if (id == 0) {</span>
                // TODO: nicer error messages...
<span class="nc" id="L513">                throw new LineUnavailableException(</span>
                        &quot;line with format &quot;+format+&quot; not supported.&quot;);
            }

<span class="nc" id="L517">            this.bufferSize = nGetBufferSize(id, isSource);</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">            if (this.bufferSize &lt; 1) {</span>
                // this is an error!
<span class="nc" id="L520">                this.bufferSize = bufferSize;</span>
            }
<span class="nc" id="L522">            this.format = format;</span>
            // wait time = 1/4 of buffer time
<span class="nc" id="L524">            waitTime = (int) Toolkit.bytes2millis(format, this.bufferSize) / 4;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (waitTime &lt; 10) {</span>
<span class="nc" id="L526">                waitTime = 1;</span>
            }
<span class="nc bnc" id="L528" title="All 2 branches missed.">            else if (waitTime &gt; 1000) {</span>
                // we have seen large buffer sizes!
                // never wait for more than a second
<span class="nc" id="L531">                waitTime = 1000;</span>
            }
<span class="nc" id="L533">            bytePosition = 0;</span>
<span class="nc" id="L534">            stoppedWritten = false;</span>
<span class="nc" id="L535">            doIO = false;</span>
<span class="nc" id="L536">            calcVolume();</span>

            if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectDL: implOpen() succeeded&quot;);
<span class="nc" id="L539">        }</span>


        void implStart() {
            if (Printer.trace) Printer.trace(&quot; &gt;&gt; DirectDL: implStart()&quot;);

            // check for record permission
<span class="nc bnc" id="L546" title="All 2 branches missed.">            if (!isSource) {</span>
<span class="nc" id="L547">                JSSecurityManager.checkRecordPermission();</span>
            }

<span class="nc" id="L550">            synchronized (lockNative)</span>
            {
<span class="nc" id="L552">                nStart(id, isSource);</span>
<span class="nc" id="L553">            }</span>
            // check for monitoring/servicing
<span class="nc" id="L555">            monitoring = requiresServicing();</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">            if (monitoring) {</span>
<span class="nc" id="L557">                getEventDispatcher().addLineMonitor(this);</span>
            }

<span class="nc" id="L560">            doIO = true;</span>

            // need to set Active and Started
            // note: the current API always requires that
            //       Started and Active are set at the same time...
<span class="nc bnc" id="L565" title="All 4 branches missed.">            if (isSource &amp;&amp; stoppedWritten) {</span>
<span class="nc" id="L566">                setStarted(true);</span>
<span class="nc" id="L567">                setActive(true);</span>
            }

            if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectDL: implStart() succeeded&quot;);
<span class="nc" id="L571">        }</span>

        void implStop() {
            if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectDL: implStop()&quot;);

            // check for record permission
<span class="nc bnc" id="L577" title="All 2 branches missed.">            if (!isSource) {</span>
<span class="nc" id="L578">                JSSecurityManager.checkRecordPermission();</span>
            }

<span class="nc bnc" id="L581" title="All 2 branches missed.">            if (monitoring) {</span>
<span class="nc" id="L582">                getEventDispatcher().removeLineMonitor(this);</span>
<span class="nc" id="L583">                monitoring = false;</span>
            }
<span class="nc" id="L585">            synchronized (lockNative) {</span>
<span class="nc" id="L586">                nStop(id, isSource);</span>
<span class="nc" id="L587">            }</span>
            // wake up any waiting threads
<span class="nc" id="L589">            synchronized(lock) {</span>
                // need to set doIO to false before notifying the
                // read/write thread, that's why isStartedRunning()
                // cannot be used
<span class="nc" id="L593">                doIO = false;</span>
<span class="nc" id="L594">                lock.notifyAll();</span>
<span class="nc" id="L595">            }</span>
<span class="nc" id="L596">            setActive(false);</span>
<span class="nc" id="L597">            setStarted(false);</span>
<span class="nc" id="L598">            stoppedWritten = false;</span>

            if (Printer.trace) Printer.trace(&quot; &lt;&lt; DirectDL: implStop() succeeded&quot;);
<span class="nc" id="L601">        }</span>

        void implClose() {
            if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectDL: implClose()&quot;);

            // check for record permission
<span class="nc bnc" id="L607" title="All 2 branches missed.">            if (!isSource) {</span>
<span class="nc" id="L608">                JSSecurityManager.checkRecordPermission();</span>
            }

            // be sure to remove this monitor
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (monitoring) {</span>
<span class="nc" id="L613">                getEventDispatcher().removeLineMonitor(this);</span>
<span class="nc" id="L614">                monitoring = false;</span>
            }

<span class="nc" id="L617">            doIO = false;</span>
<span class="nc" id="L618">            long oldID = id;</span>
<span class="nc" id="L619">            id = 0;</span>
<span class="nc" id="L620">            synchronized (lockNative) {</span>
<span class="nc" id="L621">                nClose(oldID, isSource);</span>
<span class="nc" id="L622">            }</span>
<span class="nc" id="L623">            bytePosition = 0;</span>
<span class="nc" id="L624">            softwareConversionSize = 0;</span>
            if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectDL: implClose() succeeded&quot;);
<span class="nc" id="L626">        }</span>

        // METHOD OVERRIDES

        public int available() {
<span class="nc bnc" id="L631" title="All 2 branches missed.">            if (id == 0) {</span>
<span class="nc" id="L632">                return 0;</span>
            }
            int a;
<span class="nc" id="L635">            synchronized (lockNative) {</span>
<span class="nc" id="L636">                a = nAvailable(id, isSource);</span>
<span class="nc" id="L637">            }</span>
<span class="nc" id="L638">            return a;</span>
        }


        public void drain() {
<span class="nc" id="L643">            noService = true;</span>
            // additional safeguard against draining forever
            // this occurred on Solaris 8 x86, probably due to a bug
            // in the audio driver
<span class="nc" id="L647">            int counter = 0;</span>
<span class="nc" id="L648">            long startPos = getLongFramePosition();</span>
<span class="nc" id="L649">            boolean posChanged = false;</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">            while (!drained) {</span>
<span class="nc" id="L651">                synchronized (lockNative) {</span>
<span class="nc bnc" id="L652" title="All 6 branches missed.">                    if ((id == 0) || (!doIO) || !nIsStillDraining(id, isSource))</span>
<span class="nc" id="L653">                        break;</span>
<span class="nc" id="L654">                }</span>
                // check every now and then for a new position
<span class="nc bnc" id="L656" title="All 2 branches missed.">                if ((counter % 5) == 4) {</span>
<span class="nc" id="L657">                    long thisFramePos = getLongFramePosition();</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">                    posChanged = posChanged | (thisFramePos != startPos);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">                    if ((counter % 50) &gt; 45) {</span>
                        // when some time elapsed, check that the frame position
                        // really changed
<span class="nc bnc" id="L662" title="All 2 branches missed.">                        if (!posChanged) {</span>
                            if (Printer.err) Printer.err(&quot;Native reports isDraining, but frame position does not increase!&quot;);
<span class="nc" id="L664">                            break;</span>
                        }
<span class="nc" id="L666">                        posChanged = false;</span>
<span class="nc" id="L667">                        startPos = thisFramePos;</span>
                    }
                }
<span class="nc" id="L670">                counter++;</span>
<span class="nc" id="L671">                synchronized(lock) {</span>
                    try {
<span class="nc" id="L673">                        lock.wait(10);</span>
<span class="nc" id="L674">                    } catch (InterruptedException ie) {}</span>
<span class="nc" id="L675">                }</span>
            }

<span class="nc bnc" id="L678" title="All 4 branches missed.">            if (doIO &amp;&amp; id != 0) {</span>
<span class="nc" id="L679">                drained = true;</span>
            }
<span class="nc" id="L681">            noService = false;</span>
<span class="nc" id="L682">        }</span>

        public void flush() {
<span class="nc bnc" id="L685" title="All 2 branches missed.">            if (id != 0) {</span>
                // first stop ongoing read/write method
<span class="nc" id="L687">                flushing = true;</span>
<span class="nc" id="L688">                synchronized(lock) {</span>
<span class="nc" id="L689">                    lock.notifyAll();</span>
<span class="nc" id="L690">                }</span>
<span class="nc" id="L691">                synchronized (lockNative) {</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                    if (id != 0) {</span>
                        // then flush native buffers
<span class="nc" id="L694">                        nFlush(id, isSource);</span>
                    }
<span class="nc" id="L696">                }</span>
<span class="nc" id="L697">                drained = true;</span>
            }
<span class="nc" id="L699">        }</span>

        // replacement for getFramePosition (see AbstractDataLine)
        public long getLongFramePosition() {
            long pos;
<span class="nc" id="L704">            synchronized (lockNative) {</span>
<span class="nc" id="L705">                pos = nGetBytePosition(id, isSource, bytePosition);</span>
<span class="nc" id="L706">            }</span>
            // hack because ALSA sometimes reports wrong framepos
<span class="nc bnc" id="L708" title="All 2 branches missed.">            if (pos &lt; 0) {</span>
                if (Printer.debug) Printer.debug(&quot;DirectLine.getLongFramePosition: Native reported pos=&quot;
                                                 +pos+&quot;! is changed to 0. byteposition=&quot;+bytePosition);
<span class="nc" id="L711">                pos = 0;</span>
            }
<span class="nc" id="L713">            return (pos / getFormat().getFrameSize());</span>
        }


        /*
         * write() belongs into SourceDataLine and Clip,
         * so define it here and make it accessible by
         * declaring the respective interfaces with DirectSDL and DirectClip
         */
        public int write(byte[] b, int off, int len) {
<span class="nc" id="L723">            flushing = false;</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (len == 0) {</span>
<span class="nc" id="L725">                return 0;</span>
            }
<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (len &lt; 0) {</span>
<span class="nc" id="L728">                throw new IllegalArgumentException(&quot;illegal len: &quot;+len);</span>
            }
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (len % getFormat().getFrameSize() != 0) {</span>
<span class="nc" id="L731">                throw new IllegalArgumentException(&quot;illegal request to write &quot;</span>
                                                   +&quot;non-integral number of frames (&quot;
                                                   +len+&quot; bytes, &quot;
<span class="nc" id="L734">                                                   +&quot;frameSize = &quot;+getFormat().getFrameSize()+&quot; bytes)&quot;);</span>
            }
<span class="nc bnc" id="L736" title="All 2 branches missed.">            if (off &lt; 0) {</span>
<span class="nc" id="L737">                throw new ArrayIndexOutOfBoundsException(off);</span>
            }
<span class="nc bnc" id="L739" title="All 2 branches missed.">            if ((long)off + (long)len &gt; (long)b.length) {</span>
<span class="nc" id="L740">                throw new ArrayIndexOutOfBoundsException(b.length);</span>
            }

<span class="nc bnc" id="L743" title="All 4 branches missed.">            if (!isActive() &amp;&amp; doIO) {</span>
                // this is not exactly correct... would be nicer
                // if the native sub system sent a callback when IO really starts
<span class="nc" id="L746">                setActive(true);</span>
<span class="nc" id="L747">                setStarted(true);</span>
            }
<span class="nc" id="L749">            int written = 0;</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">            while (!flushing) {</span>
                int thisWritten;
<span class="nc" id="L752">                synchronized (lockNative) {</span>
<span class="nc" id="L753">                    thisWritten = nWrite(id, b, off, len,</span>
                            softwareConversionSize,
                            leftGain, rightGain);
<span class="nc bnc" id="L756" title="All 2 branches missed.">                    if (thisWritten &lt; 0) {</span>
                        // error in native layer
<span class="nc" id="L758">                        break;</span>
                    }
<span class="nc" id="L760">                    bytePosition += thisWritten;</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">                    if (thisWritten &gt; 0) {</span>
<span class="nc" id="L762">                        drained = false;</span>
                    }
<span class="nc" id="L764">                }</span>
<span class="nc" id="L765">                len -= thisWritten;</span>
<span class="nc" id="L766">                written += thisWritten;</span>
<span class="nc bnc" id="L767" title="All 4 branches missed.">                if (doIO &amp;&amp; len &gt; 0) {</span>
<span class="nc" id="L768">                    off += thisWritten;</span>
<span class="nc" id="L769">                    synchronized (lock) {</span>
                        try {
<span class="nc" id="L771">                            lock.wait(waitTime);</span>
<span class="nc" id="L772">                        } catch (InterruptedException ie) {}</span>
<span class="nc" id="L773">                    }</span>
                } else {
                    break;
                }
<span class="nc" id="L777">            }</span>
<span class="nc bnc" id="L778" title="All 4 branches missed.">            if (written &gt; 0 &amp;&amp; !doIO) {</span>
<span class="nc" id="L779">                stoppedWritten = true;</span>
            }
<span class="nc" id="L781">            return written;</span>
        }

        protected boolean requiresServicing() {
<span class="nc" id="L785">            return nRequiresServicing(id, isSource);</span>
        }

        // called from event dispatcher for lines that need servicing
        public void checkLine() {
<span class="nc" id="L790">            synchronized (lockNative) {</span>
<span class="nc bnc" id="L791" title="All 10 branches missed.">                if (monitoring</span>
                        &amp;&amp; doIO
                        &amp;&amp; id != 0
                        &amp;&amp; !flushing
                        &amp;&amp; !noService) {
<span class="nc" id="L796">                    nService(id, isSource);</span>
                }
<span class="nc" id="L798">            }</span>
<span class="nc" id="L799">        }</span>

        private void calcVolume() {
<span class="nc bnc" id="L802" title="All 2 branches missed.">            if (getFormat() == null) {</span>
<span class="nc" id="L803">                return;</span>
            }
<span class="nc bnc" id="L805" title="All 2 branches missed.">            if (muteControl.getValue()) {</span>
<span class="nc" id="L806">                leftGain = 0.0f;</span>
<span class="nc" id="L807">                rightGain = 0.0f;</span>
<span class="nc" id="L808">                return;</span>
            }
<span class="nc" id="L810">            float gain = gainControl.getLinearGain();</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">            if (getFormat().getChannels() == 1) {</span>
                // trivial case: only use gain
<span class="nc" id="L813">                leftGain = gain;</span>
<span class="nc" id="L814">                rightGain = gain;</span>
            } else {
                // need to combine gain and balance
<span class="nc" id="L817">                float bal = balanceControl.getValue();</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">                if (bal &lt; 0.0f) {</span>
                    // left
<span class="nc" id="L820">                    leftGain = gain;</span>
<span class="nc" id="L821">                    rightGain = gain * (bal + 1.0f);</span>
                } else {
<span class="nc" id="L823">                    leftGain = gain * (1.0f - bal);</span>
<span class="nc" id="L824">                    rightGain = gain;</span>
                }
            }
<span class="nc" id="L827">        }</span>


        /////////////////// CONTROLS /////////////////////////////

        protected final class Gain extends FloatControl {

<span class="nc" id="L834">            private float linearGain = 1.0f;</span>

<span class="nc" id="L836">            private Gain() {</span>

<span class="nc" id="L838">                super(FloatControl.Type.MASTER_GAIN,</span>
<span class="nc" id="L839">                      Toolkit.linearToDB(0.0f),</span>
<span class="nc" id="L840">                      Toolkit.linearToDB(2.0f),</span>
<span class="nc" id="L841">                      Math.abs(Toolkit.linearToDB(1.0f)-Toolkit.linearToDB(0.0f))/128.0f,</span>
                      -1,
                      0.0f,
                      &quot;dB&quot;, &quot;Minimum&quot;, &quot;&quot;, &quot;Maximum&quot;);
<span class="nc" id="L845">            }</span>

            public void setValue(float newValue) {
                // adjust value within range ?? spec says IllegalArgumentException
                //newValue = Math.min(newValue, getMaximum());
                //newValue = Math.max(newValue, getMinimum());

<span class="nc" id="L852">                float newLinearGain = Toolkit.dBToLinear(newValue);</span>
<span class="nc" id="L853">                super.setValue(Toolkit.linearToDB(newLinearGain));</span>
                // if no exception, commit to our new gain
<span class="nc" id="L855">                linearGain = newLinearGain;</span>
<span class="nc" id="L856">                calcVolume();</span>
<span class="nc" id="L857">            }</span>

            float getLinearGain() {
<span class="nc" id="L860">                return linearGain;</span>
            }
        } // class Gain


        private final class Mute extends BooleanControl {

<span class="nc" id="L867">            private Mute() {</span>
<span class="nc" id="L868">                super(BooleanControl.Type.MUTE, false, &quot;True&quot;, &quot;False&quot;);</span>
<span class="nc" id="L869">            }</span>

            public void setValue(boolean newValue) {
<span class="nc" id="L872">                super.setValue(newValue);</span>
<span class="nc" id="L873">                calcVolume();</span>
<span class="nc" id="L874">            }</span>
        }  // class Mute

        private final class Balance extends FloatControl {

<span class="nc" id="L879">            private Balance() {</span>
<span class="nc" id="L880">                super(FloatControl.Type.BALANCE, -1.0f, 1.0f, (1.0f / 128.0f), -1, 0.0f,</span>
                      &quot;&quot;, &quot;Left&quot;, &quot;Center&quot;, &quot;Right&quot;);
<span class="nc" id="L882">            }</span>

            public void setValue(float newValue) {
<span class="nc" id="L885">                setValueImpl(newValue);</span>
<span class="nc" id="L886">                panControl.setValueImpl(newValue);</span>
<span class="nc" id="L887">                calcVolume();</span>
<span class="nc" id="L888">            }</span>

            void setValueImpl(float newValue) {
<span class="nc" id="L891">                super.setValue(newValue);</span>
<span class="nc" id="L892">            }</span>

        } // class Balance

        private final class Pan extends FloatControl {

<span class="nc" id="L898">            private Pan() {</span>
<span class="nc" id="L899">                super(FloatControl.Type.PAN, -1.0f, 1.0f, (1.0f / 128.0f), -1, 0.0f,</span>
                      &quot;&quot;, &quot;Left&quot;, &quot;Center&quot;, &quot;Right&quot;);
<span class="nc" id="L901">            }</span>

            public void setValue(float newValue) {
<span class="nc" id="L904">                setValueImpl(newValue);</span>
<span class="nc" id="L905">                balanceControl.setValueImpl(newValue);</span>
<span class="nc" id="L906">                calcVolume();</span>
<span class="nc" id="L907">            }</span>
            void setValueImpl(float newValue) {
<span class="nc" id="L909">                super.setValue(newValue);</span>
<span class="nc" id="L910">            }</span>
        } // class Pan



    } // class DirectDL


    /**
     * Private inner class representing a SourceDataLine
     */
    private static final class DirectSDL extends DirectDL
            implements SourceDataLine {

        // CONSTRUCTOR
        private DirectSDL(DataLine.Info info,
                          AudioFormat format,
                          int bufferSize,
                          DirectAudioDevice mixer) {
<span class="nc" id="L929">            super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), true);</span>
            if (Printer.trace) Printer.trace(&quot;DirectSDL CONSTRUCTOR: completed&quot;);
<span class="nc" id="L931">        }</span>

    }

    /**
     * Private inner class representing a TargetDataLine
     */
    private static final class DirectTDL extends DirectDL
            implements TargetDataLine {

        // CONSTRUCTOR
        private DirectTDL(DataLine.Info info,
                          AudioFormat format,
                          int bufferSize,
                          DirectAudioDevice mixer) {
<span class="nc" id="L946">            super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), false);</span>
            if (Printer.trace) Printer.trace(&quot;DirectTDL CONSTRUCTOR: completed&quot;);
<span class="nc" id="L948">        }</span>

        // METHOD OVERRIDES

        public int read(byte[] b, int off, int len) {
<span class="nc" id="L953">            flushing = false;</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">            if (len == 0) {</span>
<span class="nc" id="L955">                return 0;</span>
            }
<span class="nc bnc" id="L957" title="All 2 branches missed.">            if (len &lt; 0) {</span>
<span class="nc" id="L958">                throw new IllegalArgumentException(&quot;illegal len: &quot;+len);</span>
            }
<span class="nc bnc" id="L960" title="All 2 branches missed.">            if (len % getFormat().getFrameSize() != 0) {</span>
<span class="nc" id="L961">                throw new IllegalArgumentException(&quot;illegal request to read &quot;</span>
                                                   +&quot;non-integral number of frames (&quot;
                                                   +len+&quot; bytes, &quot;
<span class="nc" id="L964">                                                   +&quot;frameSize = &quot;+getFormat().getFrameSize()+&quot; bytes)&quot;);</span>
            }
<span class="nc bnc" id="L966" title="All 2 branches missed.">            if (off &lt; 0) {</span>
<span class="nc" id="L967">                throw new ArrayIndexOutOfBoundsException(off);</span>
            }
<span class="nc bnc" id="L969" title="All 2 branches missed.">            if ((long)off + (long)len &gt; (long)b.length) {</span>
<span class="nc" id="L970">                throw new ArrayIndexOutOfBoundsException(b.length);</span>
            }
<span class="nc bnc" id="L972" title="All 4 branches missed.">            if (!isActive() &amp;&amp; doIO) {</span>
                // this is not exactly correct... would be nicer
                // if the native sub system sent a callback when IO really starts
<span class="nc" id="L975">                setActive(true);</span>
<span class="nc" id="L976">                setStarted(true);</span>
            }
<span class="nc" id="L978">            int read = 0;</span>
<span class="nc bnc" id="L979" title="All 4 branches missed.">            while (doIO &amp;&amp; !flushing) {</span>
                int thisRead;
<span class="nc" id="L981">                synchronized (lockNative) {</span>
<span class="nc" id="L982">                    thisRead = nRead(id, b, off, len, softwareConversionSize);</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">                    if (thisRead &lt; 0) {</span>
                        // error in native layer
<span class="nc" id="L985">                        break;</span>
                    }
<span class="nc" id="L987">                    bytePosition += thisRead;</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">                    if (thisRead &gt; 0) {</span>
<span class="nc" id="L989">                        drained = false;</span>
                    }
<span class="nc" id="L991">                }</span>
<span class="nc" id="L992">                len -= thisRead;</span>
<span class="nc" id="L993">                read += thisRead;</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">                if (len &gt; 0) {</span>
<span class="nc" id="L995">                    off += thisRead;</span>
<span class="nc" id="L996">                    synchronized(lock) {</span>
                        try {
<span class="nc" id="L998">                            lock.wait(waitTime);</span>
<span class="nc" id="L999">                        } catch (InterruptedException ie) {}</span>
<span class="nc" id="L1000">                    }</span>
                } else {
                    break;
                }
<span class="nc" id="L1004">            }</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            if (flushing) {</span>
<span class="nc" id="L1006">                read = 0;</span>
            }
<span class="nc" id="L1008">            return read;</span>
        }

    }

    /**
     * Private inner class representing a Clip
     * This clip is realized in software only
     */
    private static final class DirectClip extends DirectDL
            implements Clip, Runnable, AutoClosingClip {

        private Thread thread;
<span class="nc" id="L1021">        private byte[] audioData = null;</span>
        private int frameSize;         // size of one frame in bytes
        private int m_lengthInFrames;
        private int loopCount;
        private int clipBytePosition;   // index in the audioData array at current playback
        private int newFramePosition;   // set in setFramePosition()
        private int loopStartFrame;
        private int loopEndFrame;      // the last sample included in the loop

        // auto closing clip support
<span class="nc" id="L1031">        private boolean autoclosing = false;</span>

        // CONSTRUCTOR
        private DirectClip(DataLine.Info info,
                           AudioFormat format,
                           int bufferSize,
                           DirectAudioDevice mixer) {
<span class="nc" id="L1038">            super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), true);</span>
            if (Printer.trace) Printer.trace(&quot;DirectClip CONSTRUCTOR: completed&quot;);
<span class="nc" id="L1040">        }</span>

        // CLIP METHODS

        public void open(AudioFormat format, byte[] data, int offset, int bufferSize)
            throws LineUnavailableException {

            // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
<span class="nc" id="L1048">            Toolkit.isFullySpecifiedAudioFormat(format);</span>

<span class="nc" id="L1050">            byte[] newData = new byte[bufferSize];</span>
<span class="nc" id="L1051">            System.arraycopy(data, offset, newData, 0, bufferSize);</span>
<span class="nc" id="L1052">            open(format, newData, bufferSize / format.getFrameSize());</span>
<span class="nc" id="L1053">        }</span>

        // this method does not copy the data array
        private void open(AudioFormat format, byte[] data, int frameLength)
            throws LineUnavailableException {

            // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
<span class="nc" id="L1060">            Toolkit.isFullySpecifiedAudioFormat(format);</span>

<span class="nc" id="L1062">            synchronized (mixer) {</span>
                if (Printer.trace) Printer.trace(&quot;&gt; DirectClip.open(format, data, frameLength)&quot;);
                if (Printer.debug) Printer.debug(&quot;   data=&quot;+((data==null)?&quot;null&quot;:&quot;&quot;+data.length+&quot; bytes&quot;));
                if (Printer.debug) Printer.debug(&quot;   frameLength=&quot;+frameLength);

<span class="nc bnc" id="L1067" title="All 2 branches missed.">                if (isOpen()) {</span>
<span class="nc" id="L1068">                    throw new IllegalStateException(&quot;Clip is already open with format &quot; + getFormat() +</span>
<span class="nc" id="L1069">                                                    &quot; and frame lengh of &quot; + getFrameLength());</span>
                } else {
                    // if the line is not currently open, try to open it with this format and buffer size
<span class="nc" id="L1072">                    this.audioData = data;</span>
<span class="nc" id="L1073">                    this.frameSize = format.getFrameSize();</span>
<span class="nc" id="L1074">                    this.m_lengthInFrames = frameLength;</span>
                    // initialize loop selection with full range
<span class="nc" id="L1076">                    bytePosition = 0;</span>
<span class="nc" id="L1077">                    clipBytePosition = 0;</span>
<span class="nc" id="L1078">                    newFramePosition = -1; // means: do not set to a new readFramePos</span>
<span class="nc" id="L1079">                    loopStartFrame = 0;</span>
<span class="nc" id="L1080">                    loopEndFrame = frameLength - 1;</span>
<span class="nc" id="L1081">                    loopCount = 0; // means: play the clip irrespective of loop points from beginning to end</span>

                    try {
                        // use DirectDL's open method to open it
<span class="nc" id="L1085">                        open(format, (int) Toolkit.millis2bytes(format, CLIP_BUFFER_TIME)); // one second buffer</span>
<span class="nc" id="L1086">                    } catch (LineUnavailableException lue) {</span>
<span class="nc" id="L1087">                        audioData = null;</span>
<span class="nc" id="L1088">                        throw lue;</span>
<span class="nc" id="L1089">                    } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L1090">                        audioData = null;</span>
<span class="nc" id="L1091">                        throw iae;</span>
<span class="nc" id="L1092">                    }</span>

                    // if we got this far, we can instanciate the thread
<span class="nc" id="L1095">                    int priority = Thread.NORM_PRIORITY</span>
                        + (Thread.MAX_PRIORITY - Thread.NORM_PRIORITY) / 3;
<span class="nc" id="L1097">                    thread = JSSecurityManager.createThread(this,</span>
                                                            &quot;Direct Clip&quot;, // name
                                                            true,     // daemon
                                                            priority, // priority
                                                            false);  // doStart
                    // cannot start in createThread, because the thread
                    // uses the &quot;thread&quot; variable as indicator if it should
                    // continue to run
<span class="nc" id="L1105">                    thread.start();</span>
                }
<span class="nc" id="L1107">            }</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">            if (isAutoClosing()) {</span>
<span class="nc" id="L1109">                getEventDispatcher().autoClosingClipOpened(this);</span>
            }
            if (Printer.trace) Printer.trace(&quot;&lt; DirectClip.open completed&quot;);
<span class="nc" id="L1112">        }</span>


        public void open(AudioInputStream stream) throws LineUnavailableException, IOException {

            // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
<span class="nc" id="L1118">            Toolkit.isFullySpecifiedAudioFormat(format);</span>

<span class="nc" id="L1120">            synchronized (mixer) {</span>
                if (Printer.trace) Printer.trace(&quot;&gt; DirectClip.open(stream)&quot;);
<span class="nc" id="L1122">                byte[] streamData = null;</span>

<span class="nc bnc" id="L1124" title="All 2 branches missed.">                if (isOpen()) {</span>
<span class="nc" id="L1125">                    throw new IllegalStateException(&quot;Clip is already open with format &quot; + getFormat() +</span>
<span class="nc" id="L1126">                                                    &quot; and frame lengh of &quot; + getFrameLength());</span>
                }
<span class="nc" id="L1128">                int lengthInFrames = (int)stream.getFrameLength();</span>
                if (Printer.debug) Printer.debug(&quot;DirectClip: open(AIS): lengthInFrames: &quot; + lengthInFrames);

<span class="nc" id="L1131">                int bytesRead = 0;</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">                if (lengthInFrames != AudioSystem.NOT_SPECIFIED) {</span>
                    // read the data from the stream into an array in one fell swoop.
<span class="nc" id="L1134">                    int arraysize = lengthInFrames * stream.getFormat().getFrameSize();</span>
<span class="nc" id="L1135">                    streamData = new byte[arraysize];</span>

<span class="nc" id="L1137">                    int bytesRemaining = arraysize;</span>
<span class="nc" id="L1138">                    int thisRead = 0;</span>
<span class="nc bnc" id="L1139" title="All 4 branches missed.">                    while (bytesRemaining &gt; 0 &amp;&amp; thisRead &gt;= 0) {</span>
<span class="nc" id="L1140">                        thisRead = stream.read(streamData, bytesRead, bytesRemaining);</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">                        if (thisRead &gt; 0) {</span>
<span class="nc" id="L1142">                            bytesRead += thisRead;</span>
<span class="nc" id="L1143">                            bytesRemaining -= thisRead;</span>
                        }
<span class="nc bnc" id="L1145" title="All 2 branches missed.">                        else if (thisRead == 0) {</span>
<span class="nc" id="L1146">                            Thread.yield();</span>
                        }
                    }
<span class="nc" id="L1149">                } else {</span>
                    // read data from the stream until we reach the end of the stream
                    // we use a slightly modified version of ByteArrayOutputStream
                    // to get direct access to the byte array (we don't want a new array
                    // to be allocated)
<span class="nc" id="L1154">                    int MAX_READ_LIMIT = 16384;</span>
<span class="nc" id="L1155">                    DirectBAOS dbaos  = new DirectBAOS();</span>
<span class="nc" id="L1156">                    byte tmp[] = new byte[MAX_READ_LIMIT];</span>
<span class="nc" id="L1157">                    int thisRead = 0;</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">                    while (thisRead &gt;= 0) {</span>
<span class="nc" id="L1159">                        thisRead = stream.read(tmp, 0, tmp.length);</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">                        if (thisRead &gt; 0) {</span>
<span class="nc" id="L1161">                            dbaos.write(tmp, 0, thisRead);</span>
<span class="nc" id="L1162">                            bytesRead += thisRead;</span>
                        }
<span class="nc bnc" id="L1164" title="All 2 branches missed.">                        else if (thisRead == 0) {</span>
<span class="nc" id="L1165">                            Thread.yield();</span>
                        }
                    } // while
<span class="nc" id="L1168">                    streamData = dbaos.getInternalBuffer();</span>
                }
<span class="nc" id="L1170">                lengthInFrames = bytesRead / stream.getFormat().getFrameSize();</span>

                if (Printer.debug) Printer.debug(&quot;Read to end of stream. lengthInFrames: &quot; + lengthInFrames);

                // now try to open the device
<span class="nc" id="L1175">                open(stream.getFormat(), streamData, lengthInFrames);</span>

                if (Printer.trace) Printer.trace(&quot;&lt; DirectClip.open(stream) succeeded&quot;);
<span class="nc" id="L1178">            } // synchronized</span>
<span class="nc" id="L1179">        }</span>


        public int getFrameLength() {
<span class="nc" id="L1183">            return m_lengthInFrames;</span>
        }


        public long getMicrosecondLength() {
<span class="nc" id="L1188">            return Toolkit.frames2micros(getFormat(), getFrameLength());</span>
        }


        public void setFramePosition(int frames) {
            if (Printer.trace) Printer.trace(&quot;&gt; DirectClip: setFramePosition: &quot; + frames);

<span class="nc bnc" id="L1195" title="All 2 branches missed.">            if (frames &lt; 0) {</span>
<span class="nc" id="L1196">                frames = 0;</span>
            }
<span class="nc bnc" id="L1198" title="All 2 branches missed.">            else if (frames &gt;= getFrameLength()) {</span>
<span class="nc" id="L1199">                frames = getFrameLength();</span>
            }
<span class="nc bnc" id="L1201" title="All 2 branches missed.">            if (doIO) {</span>
<span class="nc" id="L1202">                newFramePosition = frames;</span>
            } else {
<span class="nc" id="L1204">                clipBytePosition = frames * frameSize;</span>
<span class="nc" id="L1205">                newFramePosition = -1;</span>
            }
            // fix for failing test050
            // $$fb although getFramePosition should return the number of rendered
            // frames, it is intuitive that setFramePosition will modify that
            // value.
<span class="nc" id="L1211">            bytePosition = frames * frameSize;</span>

            // cease currently playing buffer
<span class="nc" id="L1214">            flush();</span>

            // set new native position (if necessary)
            // this must come after the flush!
<span class="nc" id="L1218">            synchronized (lockNative) {</span>
<span class="nc" id="L1219">                nSetBytePosition(id, isSource, frames * frameSize);</span>
<span class="nc" id="L1220">            }</span>

            if (Printer.debug) Printer.debug(&quot;  DirectClip.setFramePosition: &quot;
                                             +&quot; doIO=&quot;+doIO
                                             +&quot; newFramePosition=&quot;+newFramePosition
                                             +&quot; clipBytePosition=&quot;+clipBytePosition
                                             +&quot; bytePosition=&quot;+bytePosition
                                             +&quot; getLongFramePosition()=&quot;+getLongFramePosition());
            if (Printer.trace) Printer.trace(&quot;&lt; DirectClip: setFramePosition&quot;);
<span class="nc" id="L1229">        }</span>

        // replacement for getFramePosition (see AbstractDataLine)
        public long getLongFramePosition() {
            /* $$fb
             * this would be intuitive, but the definition of getFramePosition
             * is the number of frames rendered since opening the device...
             * That also means that setFramePosition() means something very
             * different from getFramePosition() for Clip.
             */
            // take into account the case that a new position was set...
            //if (!doIO &amp;&amp; newFramePosition &gt;= 0) {
            //return newFramePosition;
            //}
<span class="nc" id="L1243">            return super.getLongFramePosition();</span>
        }


        public synchronized void setMicrosecondPosition(long microseconds) {
            if (Printer.trace) Printer.trace(&quot;&gt; DirectClip: setMicrosecondPosition: &quot; + microseconds);

<span class="nc" id="L1250">            long frames = Toolkit.micros2frames(getFormat(), microseconds);</span>
<span class="nc" id="L1251">            setFramePosition((int) frames);</span>

            if (Printer.trace) Printer.trace(&quot;&lt; DirectClip: setMicrosecondPosition succeeded&quot;);
<span class="nc" id="L1254">        }</span>

        public void setLoopPoints(int start, int end) {
            if (Printer.trace) Printer.trace(&quot;&gt; DirectClip: setLoopPoints: start: &quot; + start + &quot; end: &quot; + end);

<span class="nc bnc" id="L1259" title="All 4 branches missed.">            if (start &lt; 0 || start &gt;= getFrameLength()) {</span>
<span class="nc" id="L1260">                throw new IllegalArgumentException(&quot;illegal value for start: &quot;+start);</span>
            }
<span class="nc bnc" id="L1262" title="All 2 branches missed.">            if (end &gt;= getFrameLength()) {</span>
<span class="nc" id="L1263">                throw new IllegalArgumentException(&quot;illegal value for end: &quot;+end);</span>
            }

<span class="nc bnc" id="L1266" title="All 2 branches missed.">            if (end == -1) {</span>
<span class="nc" id="L1267">                end = getFrameLength() - 1;</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">                if (end &lt; 0) {</span>
<span class="nc" id="L1269">                    end = 0;</span>
                }
            }

            // if the end position is less than the start position, throw IllegalArgumentException
<span class="nc bnc" id="L1274" title="All 2 branches missed.">            if (end &lt; start) {</span>
<span class="nc" id="L1275">                throw new IllegalArgumentException(&quot;End position &quot; + end + &quot;  preceeds start position &quot; + start);</span>
            }

            // slight race condition with the run() method, but not a big problem
<span class="nc" id="L1279">            loopStartFrame = start;</span>
<span class="nc" id="L1280">            loopEndFrame = end;</span>

            if (Printer.trace) Printer.trace(&quot;  loopStart: &quot; + loopStartFrame + &quot; loopEnd: &quot; + loopEndFrame);
            if (Printer.trace) Printer.trace(&quot;&lt; DirectClip: setLoopPoints completed&quot;);
<span class="nc" id="L1284">        }</span>


        public void loop(int count) {
            // note: when count reaches 0, it means that the entire clip
            // will be played, i.e. it will play past the loop end point
<span class="nc" id="L1290">            loopCount = count;</span>
<span class="nc" id="L1291">            start();</span>
<span class="nc" id="L1292">        }</span>

        // ABSTRACT METHOD IMPLEMENTATIONS

        // ABSTRACT LINE

        void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException {
            // only if audioData wasn't set in a calling open(format, byte[], frameSize)
            // this call is allowed.
<span class="nc bnc" id="L1301" title="All 2 branches missed.">            if (audioData == null) {</span>
<span class="nc" id="L1302">                throw new IllegalArgumentException(&quot;illegal call to open() in interface Clip&quot;);</span>
            }
<span class="nc" id="L1304">            super.implOpen(format, bufferSize);</span>
<span class="nc" id="L1305">        }</span>

        void implClose() {
            if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectClip: implClose()&quot;);

            // dispose of thread
<span class="nc" id="L1311">            Thread oldThread = thread;</span>
<span class="nc" id="L1312">            thread = null;</span>
<span class="nc" id="L1313">            doIO = false;</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">            if (oldThread != null) {</span>
                // wake up the thread if it's in wait()
<span class="nc" id="L1316">                synchronized(lock) {</span>
<span class="nc" id="L1317">                    lock.notifyAll();</span>
<span class="nc" id="L1318">                }</span>
                // wait for the thread to terminate itself,
                // but max. 2 seconds. Must not be synchronized!
                try {
<span class="nc" id="L1322">                    oldThread.join(2000);</span>
<span class="nc" id="L1323">                } catch (InterruptedException ie) {}</span>
            }
<span class="nc" id="L1325">            super.implClose();</span>
            // remove audioData reference and hand it over to gc
<span class="nc" id="L1327">            audioData = null;</span>
<span class="nc" id="L1328">            newFramePosition = -1;</span>

            // remove this instance from the list of auto closing clips
<span class="nc" id="L1331">            getEventDispatcher().autoClosingClipClosed(this);</span>

            if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectClip: implClose() succeeded&quot;);
<span class="nc" id="L1334">        }</span>


        void implStart() {
            if (Printer.trace) Printer.trace(&quot;&gt; DirectClip: implStart()&quot;);
<span class="nc" id="L1339">            super.implStart();</span>
            if (Printer.trace) Printer.trace(&quot;&lt; DirectClip: implStart() succeeded&quot;);
<span class="nc" id="L1341">        }</span>

        void implStop() {
            if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectClip: implStop()&quot;);

<span class="nc" id="L1346">            super.implStop();</span>
            // reset loopCount field so that playback will be normal with
            // next call to start()
<span class="nc" id="L1349">            loopCount = 0;</span>

            if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectClip: implStop() succeeded&quot;);
<span class="nc" id="L1352">        }</span>


        // main playback loop
        public void run() {
            if (Printer.trace) Printer.trace(&quot;&gt;&gt;&gt; DirectClip: run() threadID=&quot;+Thread.currentThread().getId());
<span class="nc bnc" id="L1358" title="All 2 branches missed.">            while (thread != null) {</span>
                // doIO is volatile, but we could check it, then get
                // pre-empted while another thread changes doIO and notifies,
                // before we wait (so we sleep in wait forever).
<span class="nc" id="L1362">                synchronized(lock) {</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">                    if (!doIO) {</span>
                        try {
<span class="nc" id="L1365">                            lock.wait();</span>
<span class="nc" id="L1366">                        } catch(InterruptedException ie) {}</span>
                    }
<span class="nc" id="L1368">                }</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">                while (doIO) {</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                    if (newFramePosition &gt;= 0) {</span>
<span class="nc" id="L1371">                        clipBytePosition = newFramePosition * frameSize;</span>
<span class="nc" id="L1372">                        newFramePosition = -1;</span>
                    }
<span class="nc" id="L1374">                    int endFrame = getFrameLength() - 1;</span>
<span class="nc bnc" id="L1375" title="All 4 branches missed.">                    if (loopCount &gt; 0 || loopCount == LOOP_CONTINUOUSLY) {</span>
<span class="nc" id="L1376">                        endFrame = loopEndFrame;</span>
                    }
<span class="nc" id="L1378">                    long framePos = (clipBytePosition / frameSize);</span>
<span class="nc" id="L1379">                    int toWriteFrames = (int) (endFrame - framePos + 1);</span>
<span class="nc" id="L1380">                    int toWriteBytes = toWriteFrames * frameSize;</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">                    if (toWriteBytes &gt; getBufferSize()) {</span>
<span class="nc" id="L1382">                        toWriteBytes = Toolkit.align(getBufferSize(), frameSize);</span>
                    }
<span class="nc" id="L1384">                    int written = write(audioData, (int) clipBytePosition, toWriteBytes); // increases bytePosition</span>
<span class="nc" id="L1385">                    clipBytePosition += written;</span>
                    // make sure nobody called setFramePosition, or stop() during the write() call
<span class="nc bnc" id="L1387" title="All 6 branches missed.">                    if (doIO &amp;&amp; newFramePosition &lt; 0 &amp;&amp; written &gt;= 0) {</span>
<span class="nc" id="L1388">                        framePos = clipBytePosition / frameSize;</span>
                        // since endFrame is the last frame to be played,
                        // framePos is after endFrame when all frames, including framePos,
                        // are played.
<span class="nc bnc" id="L1392" title="All 2 branches missed.">                        if (framePos &gt; endFrame) {</span>
                            // at end of playback. If looping is on, loop back to the beginning.
<span class="nc bnc" id="L1394" title="All 4 branches missed.">                            if (loopCount &gt; 0 || loopCount == LOOP_CONTINUOUSLY) {</span>
<span class="nc bnc" id="L1395" title="All 2 branches missed.">                                if (loopCount != LOOP_CONTINUOUSLY) {</span>
<span class="nc" id="L1396">                                    loopCount--;</span>
                                }
<span class="nc" id="L1398">                                newFramePosition = loopStartFrame;</span>
                            } else {
                                // no looping, stop playback
                                if (Printer.debug) Printer.debug(&quot;stop clip in run() loop:&quot;);
                                if (Printer.debug) Printer.debug(&quot;  doIO=&quot;+doIO+&quot; written=&quot;+written+&quot; clipBytePosition=&quot;+clipBytePosition);
                                if (Printer.debug) Printer.debug(&quot;  framePos=&quot;+framePos+&quot; endFrame=&quot;+endFrame);
<span class="nc" id="L1404">                                drain();</span>
<span class="nc" id="L1405">                                stop();</span>
                            }
                        }
                    }
<span class="nc" id="L1409">                }</span>
            }
            if (Printer.trace) Printer.trace(&quot;&lt;&lt;&lt; DirectClip: run() threadID=&quot;+Thread.currentThread().getId());
<span class="nc" id="L1412">        }</span>

        // AUTO CLOSING CLIP SUPPORT

        /* $$mp 2003-10-01
           The following two methods are common between this class and
           MixerClip. They should be moved to a base class, together
           with the instance variable 'autoclosing'. */

        public boolean isAutoClosing() {
<span class="nc" id="L1422">            return autoclosing;</span>
        }

        public void setAutoClosing(boolean value) {
<span class="nc bnc" id="L1426" title="All 2 branches missed.">            if (value != autoclosing) {</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">                if (isOpen()) {</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">                    if (value) {</span>
<span class="nc" id="L1429">                        getEventDispatcher().autoClosingClipOpened(this);</span>
                    } else {
<span class="nc" id="L1431">                        getEventDispatcher().autoClosingClipClosed(this);</span>
                    }
                }
<span class="nc" id="L1434">                autoclosing = value;</span>
            }
<span class="nc" id="L1436">        }</span>

        protected boolean requiresServicing() {
            // no need for servicing for Clips
<span class="nc" id="L1440">            return false;</span>
        }

    } // DirectClip

    /*
     * private inner class representing a ByteArrayOutputStream
     * which allows retrieval of the internal array
     */
    private static class DirectBAOS extends ByteArrayOutputStream {
        DirectBAOS() {
<span class="nc" id="L1451">            super();</span>
<span class="nc" id="L1452">        }</span>

        public byte[] getInternalBuffer() {
<span class="nc" id="L1455">            return buf;</span>
        }

    } // class DirectBAOS


    private static native void nGetFormats(int mixerIndex, int deviceID,
                                           boolean isSource, Vector formats);

    private static native long nOpen(int mixerIndex, int deviceID, boolean isSource,
                                     int encoding,
                                     float sampleRate,
                                     int sampleSizeInBits,
                                     int frameSize,
                                     int channels,
                                     boolean signed,
                                     boolean bigEndian,
                                     int bufferSize) throws LineUnavailableException;
    private static native void nStart(long id, boolean isSource);
    private static native void nStop(long id, boolean isSource);
    private static native void nClose(long id, boolean isSource);
    private static native int nWrite(long id, byte[] b, int off, int len, int conversionSize,
                                     float volLeft, float volRight);
    private static native int nRead(long id, byte[] b, int off, int len, int conversionSize);
    private static native int nGetBufferSize(long id, boolean isSource);
    private static native boolean nIsStillDraining(long id, boolean isSource);
    private static native void nFlush(long id, boolean isSource);
    private static native int nAvailable(long id, boolean isSource);
    // javaPos is number of bytes read/written in Java layer
    private static native long nGetBytePosition(long id, boolean isSource, long javaPos);
    private static native void nSetBytePosition(long id, boolean isSource, long pos);

    // returns if the native implementation needs regular calls to nService()
    private static native boolean nRequiresServicing(long id, boolean isSource);
    // called in irregular intervals
    private static native void nService(long id, boolean isSource);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>