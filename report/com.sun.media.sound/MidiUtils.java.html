<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MidiUtils.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">MidiUtils.java</span></div><h1>MidiUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.sound;

import javax.sound.midi.*;
import java.util.ArrayList;

// TODO:
// - define and use a global symbolic constant for 60000000 (see convertTempo)

/**
 * Some utilities for MIDI (some stuff is used from javax.sound.midi)
 *
 * @author Florian Bomers
 */
public final class MidiUtils {

    public final static int DEFAULT_TEMPO_MPQ = 500000; // 120bpm
    public final static int META_END_OF_TRACK_TYPE = 0x2F;
    public final static int META_TEMPO_TYPE = 0x51;

    /**
     * Suppresses default constructor, ensuring non-instantiability.
     */
<span class="nc" id="L48">    private MidiUtils() {</span>
<span class="nc" id="L49">    }</span>

    /** return true if the passed message is Meta End Of Track */
    public static boolean isMetaEndOfTrack(MidiMessage midiMsg) {
        // first check if it is a META message at all
<span class="nc bnc" id="L54" title="All 2 branches missed.">        if (midiMsg.getLength() != 3</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">            || midiMsg.getStatus() != MetaMessage.META) {</span>
<span class="nc" id="L56">            return false;</span>
        }
        // now get message and check for end of track
<span class="nc" id="L59">        byte[] msg = midiMsg.getMessage();</span>
<span class="nc bnc" id="L60" title="All 4 branches missed.">        return ((msg[1] &amp; 0xFF) == META_END_OF_TRACK_TYPE) &amp;&amp; (msg[2] == 0);</span>
    }


    /** return if the given message is a meta tempo message */
    public static boolean isMetaTempo(MidiMessage midiMsg) {
        // first check if it is a META message at all
<span class="nc bnc" id="L67" title="All 2 branches missed.">        if (midiMsg.getLength() != 6</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">            || midiMsg.getStatus() != MetaMessage.META) {</span>
<span class="nc" id="L69">            return false;</span>
        }
        // now get message and check for tempo
<span class="nc" id="L72">        byte[] msg = midiMsg.getMessage();</span>
        // meta type must be 0x51, and data length must be 3
<span class="nc bnc" id="L74" title="All 4 branches missed.">        return ((msg[1] &amp; 0xFF) == META_TEMPO_TYPE) &amp;&amp; (msg[2] == 3);</span>
    }


    /** parses this message for a META tempo message and returns
     * the tempo in MPQ, or -1 if this isn't a tempo message
     */
    public static int getTempoMPQ(MidiMessage midiMsg) {
        // first check if it is a META message at all
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (midiMsg.getLength() != 6</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">            || midiMsg.getStatus() != MetaMessage.META) {</span>
<span class="nc" id="L85">            return -1;</span>
        }
<span class="nc" id="L87">        byte[] msg = midiMsg.getMessage();</span>
<span class="nc bnc" id="L88" title="All 4 branches missed.">        if (((msg[1] &amp; 0xFF) != META_TEMPO_TYPE) || (msg[2] != 3)) {</span>
<span class="nc" id="L89">            return -1;</span>
        }
<span class="nc" id="L91">        int tempo =    (msg[5] &amp; 0xFF)</span>
                    | ((msg[4] &amp; 0xFF) &lt;&lt; 8)
                    | ((msg[3] &amp; 0xFF) &lt;&lt; 16);
<span class="nc" id="L94">        return tempo;</span>
    }


    /**
     * converts&lt;br&gt;
     * 1 - MPQ-Tempo to BPM tempo&lt;br&gt;
     * 2 - BPM tempo to MPQ tempo&lt;br&gt;
     */
    public static double convertTempo(double tempo) {
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (tempo &lt;= 0) {</span>
<span class="nc" id="L105">            tempo = 1;</span>
        }
<span class="nc" id="L107">        return ((double) 60000000l) / tempo;</span>
    }


    /**
     * convert tick to microsecond with given tempo.
     * Does not take tempo changes into account.
     * Does not work for SMPTE timing!
     */
    public static long ticks2microsec(long tick, double tempoMPQ, int resolution) {
<span class="nc" id="L117">        return (long) (((double) tick) * tempoMPQ / resolution);</span>
    }

    /**
     * convert tempo to microsecond with given tempo
     * Does not take tempo changes into account.
     * Does not work for SMPTE timing!
     */
    public static long microsec2ticks(long us, double tempoMPQ, int resolution) {
        // do not round to nearest tick
        //return (long) Math.round((((double)us) * resolution) / tempoMPQ);
<span class="nc" id="L128">        return (long) ((((double)us) * resolution) / tempoMPQ);</span>
    }


    /**
     * Given a tick, convert to microsecond
     * @param cache tempo info and current tempo
     */
    public static long tick2microsecond(Sequence seq, long tick, TempoCache cache) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (seq.getDivisionType() != Sequence.PPQ ) {</span>
<span class="nc" id="L138">            double seconds = ((double)tick / (double)(seq.getDivisionType() * seq.getResolution()));</span>
<span class="nc" id="L139">            return (long) (1000000 * seconds);</span>
        }

<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (cache == null) {</span>
<span class="nc" id="L143">            cache = new TempoCache(seq);</span>
        }

<span class="nc" id="L146">        int resolution = seq.getResolution();</span>

<span class="nc" id="L148">        long[] ticks = cache.ticks;</span>
<span class="nc" id="L149">        int[] tempos = cache.tempos; // in MPQ</span>
<span class="nc" id="L150">        int cacheCount = tempos.length;</span>

        // optimization to not always go through entire list of tempo events
<span class="nc" id="L153">        int snapshotIndex = cache.snapshotIndex;</span>
<span class="nc" id="L154">        int snapshotMicro = cache.snapshotMicro;</span>

        // walk through all tempo changes and add time for the respective blocks
<span class="nc" id="L157">        long us = 0; // microsecond</span>

<span class="nc bnc" id="L159" title="All 6 branches missed.">        if (snapshotIndex &lt;= 0</span>
            || snapshotIndex &gt;= cacheCount
            || ticks[snapshotIndex] &gt; tick) {
<span class="nc" id="L162">            snapshotMicro = 0;</span>
<span class="nc" id="L163">            snapshotIndex = 0;</span>
        }
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (cacheCount &gt; 0) {</span>
            // this implementation needs a tempo event at tick 0!
<span class="nc" id="L167">            int i = snapshotIndex + 1;</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">            while (i &lt; cacheCount &amp;&amp; ticks[i] &lt;= tick) {</span>
<span class="nc" id="L169">                snapshotMicro += ticks2microsec(ticks[i] - ticks[i - 1], tempos[i - 1], resolution);</span>
<span class="nc" id="L170">                snapshotIndex = i;</span>
<span class="nc" id="L171">                i++;</span>
            }
<span class="nc" id="L173">            us = snapshotMicro</span>
<span class="nc" id="L174">                + ticks2microsec(tick - ticks[snapshotIndex],</span>
                                 tempos[snapshotIndex],
                                 resolution);
        }
<span class="nc" id="L178">        cache.snapshotIndex = snapshotIndex;</span>
<span class="nc" id="L179">        cache.snapshotMicro = snapshotMicro;</span>
<span class="nc" id="L180">        return us;</span>
    }

    /**
     * Given a microsecond time, convert to tick.
     * returns tempo at the given time in cache.getCurrTempoMPQ
     */
    public static long microsecond2tick(Sequence seq, long micros, TempoCache cache) {
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (seq.getDivisionType() != Sequence.PPQ ) {</span>
<span class="nc" id="L189">            double dTick = ( ((double) micros)</span>
<span class="nc" id="L190">                           * ((double) seq.getDivisionType())</span>
<span class="nc" id="L191">                           * ((double) seq.getResolution()))</span>
                           / ((double) 1000000);
<span class="nc" id="L193">            long tick = (long) dTick;</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">            if (cache != null) {</span>
<span class="nc" id="L195">                cache.currTempo = (int) cache.getTempoMPQAt(tick);</span>
            }
<span class="nc" id="L197">            return tick;</span>
        }

<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (cache == null) {</span>
<span class="nc" id="L201">            cache = new TempoCache(seq);</span>
        }
<span class="nc" id="L203">        long[] ticks = cache.ticks;</span>
<span class="nc" id="L204">        int[] tempos = cache.tempos; // in MPQ</span>
<span class="nc" id="L205">        int cacheCount = tempos.length;</span>

<span class="nc" id="L207">        int resolution = seq.getResolution();</span>

<span class="nc" id="L209">        long us = 0; long tick = 0; int newReadPos = 0; int i = 1;</span>

        // walk through all tempo changes and add time for the respective blocks
        // to find the right tick
<span class="nc bnc" id="L213" title="All 4 branches missed.">        if (micros &gt; 0 &amp;&amp; cacheCount &gt; 0) {</span>
            // this loop requires that the first tempo Event is at time 0
<span class="nc bnc" id="L215" title="All 2 branches missed.">            while (i &lt; cacheCount) {</span>
<span class="nc" id="L216">                long nextTime = us + ticks2microsec(ticks[i] - ticks[i - 1],</span>
                                                    tempos[i - 1], resolution);
<span class="nc bnc" id="L218" title="All 2 branches missed.">                if (nextTime &gt; micros) {</span>
<span class="nc" id="L219">                    break;</span>
                }
<span class="nc" id="L221">                us = nextTime;</span>
<span class="nc" id="L222">                i++;</span>
<span class="nc" id="L223">            }</span>
<span class="nc" id="L224">            tick = ticks[i - 1] + microsec2ticks(micros - us, tempos[i - 1], resolution);</span>
            if (Printer.debug) Printer.debug(&quot;microsecond2tick(&quot; + (micros / 1000)+&quot;) = &quot;+tick+&quot; ticks.&quot;);
            //if (Printer.debug) Printer.debug(&quot;   -&gt; convert back = &quot; + (tick2microsecond(seq, tick, null) / 1000)+&quot; microseconds&quot;);
        }
<span class="nc" id="L228">        cache.currTempo = tempos[i - 1];</span>
<span class="nc" id="L229">        return tick;</span>
    }


    /**
     * Binary search for the event indexes of the track
     *
     * @param tick - tick number of index to be found in array
     * @return index in track which is on or after &quot;tick&quot;.
     *   if no entries are found that follow after tick, track.size() is returned
     */
    public static int tick2index(Track track, long tick) {
<span class="nc" id="L241">        int ret = 0;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (tick &gt; 0) {</span>
<span class="nc" id="L243">            int low = 0;</span>
<span class="nc" id="L244">            int high = track.size() - 1;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">            while (low &lt; high) {</span>
                // take the middle event as estimate
<span class="nc" id="L247">                ret = (low + high) &gt;&gt; 1;</span>
                // tick of estimate
<span class="nc" id="L249">                long t = track.get(ret).getTick();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                if (t == tick) {</span>
<span class="nc" id="L251">                    break;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                } else if (t &lt; tick) {</span>
                    // estimate too low
<span class="nc bnc" id="L254" title="All 2 branches missed.">                    if (low == high - 1) {</span>
                        // &quot;or after tick&quot;
<span class="nc" id="L256">                        ret++;</span>
<span class="nc" id="L257">                        break;</span>
                    }
<span class="nc" id="L259">                    low = ret;</span>
                } else { // if (t&gt;tick)
                    // estimate too high
<span class="nc" id="L262">                    high = ret;</span>
                }
<span class="nc" id="L264">            }</span>
        }
<span class="nc" id="L266">        return ret;</span>
    }


    public static final class TempoCache {
        long[] ticks;
        int[] tempos; // in MPQ
        // index in ticks/tempos at the snapshot
<span class="nc" id="L274">        int snapshotIndex = 0;</span>
        // microsecond at the snapshot
<span class="nc" id="L276">        int snapshotMicro = 0;</span>

        int currTempo; // MPQ, used as return value for microsecond2tick

<span class="nc" id="L280">        private boolean firstTempoIsFake = false;</span>

<span class="nc" id="L282">        public TempoCache() {</span>
            // just some defaults, to prevents weird stuff
<span class="nc" id="L284">            ticks = new long[1];</span>
<span class="nc" id="L285">            tempos = new int[1];</span>
<span class="nc" id="L286">            tempos[0] = DEFAULT_TEMPO_MPQ;</span>
<span class="nc" id="L287">            snapshotIndex = 0;</span>
<span class="nc" id="L288">            snapshotMicro = 0;</span>
<span class="nc" id="L289">        }</span>

        public TempoCache(Sequence seq) {
<span class="nc" id="L292">            this();</span>
<span class="nc" id="L293">            refresh(seq);</span>
<span class="nc" id="L294">        }</span>


        public synchronized void refresh(Sequence seq) {
<span class="nc" id="L298">            ArrayList list = new ArrayList();</span>
<span class="nc" id="L299">            Track[] tracks = seq.getTracks();</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">            if (tracks.length &gt; 0) {</span>
                // tempo events only occur in track 0
<span class="nc" id="L302">                Track track = tracks[0];</span>
<span class="nc" id="L303">                int c = track.size();</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                for (int i = 0; i &lt; c; i++) {</span>
<span class="nc" id="L305">                    MidiEvent ev = track.get(i);</span>
<span class="nc" id="L306">                    MidiMessage msg = ev.getMessage();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">                    if (isMetaTempo(msg)) {</span>
                        // found a tempo event. Add it to the list
<span class="nc" id="L309">                        list.add(ev);</span>
                    }
                }
            }
<span class="nc" id="L313">            int size = list.size() + 1;</span>
<span class="nc" id="L314">            firstTempoIsFake = true;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if ((size &gt; 1)</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                &amp;&amp; (((MidiEvent) list.get(0)).getTick() == 0)) {</span>
                // do not need to add an initial tempo event at the beginning
<span class="nc" id="L318">                size--;</span>
<span class="nc" id="L319">                firstTempoIsFake = false;</span>
            }
<span class="nc" id="L321">            ticks  = new long[size];</span>
<span class="nc" id="L322">            tempos = new int[size];</span>
<span class="nc" id="L323">            int e = 0;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">            if (firstTempoIsFake) {</span>
                // add tempo 120 at beginning
<span class="nc" id="L326">                ticks[0] = 0;</span>
<span class="nc" id="L327">                tempos[0] = DEFAULT_TEMPO_MPQ;</span>
<span class="nc" id="L328">                e++;</span>
            }
<span class="nc bnc" id="L330" title="All 2 branches missed.">            for (int i = 0; i &lt; list.size(); i++, e++) {</span>
<span class="nc" id="L331">                MidiEvent evt = (MidiEvent) list.get(i);</span>
<span class="nc" id="L332">                ticks[e] = evt.getTick();</span>
<span class="nc" id="L333">                tempos[e] = getTempoMPQ(evt.getMessage());</span>
            }
<span class="nc" id="L335">            snapshotIndex = 0;</span>
<span class="nc" id="L336">            snapshotMicro = 0;</span>
<span class="nc" id="L337">        }</span>

        public int getCurrTempoMPQ() {
<span class="nc" id="L340">            return currTempo;</span>
        }

        float getTempoMPQAt(long tick) {
<span class="nc" id="L344">            return getTempoMPQAt(tick, -1.0f);</span>
        }

        synchronized float getTempoMPQAt(long tick, float startTempoMPQ) {
<span class="nc bnc" id="L348" title="All 2 branches missed.">            for (int i = 0; i &lt; ticks.length; i++) {</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">                if (ticks[i] &gt; tick) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                    if (i &gt; 0) i--;</span>
<span class="nc bnc" id="L351" title="All 6 branches missed.">                    if (startTempoMPQ &gt; 0 &amp;&amp; i == 0 &amp;&amp; firstTempoIsFake) {</span>
<span class="nc" id="L352">                        return startTempoMPQ;</span>
                    }
<span class="nc" id="L354">                    return (float) tempos[i];</span>
                }
            }
<span class="nc" id="L357">            return tempos[tempos.length - 1];</span>
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>