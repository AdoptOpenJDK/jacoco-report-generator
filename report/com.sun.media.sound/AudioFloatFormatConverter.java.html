<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AudioFloatFormatConverter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">AudioFloatFormatConverter.java</span></div><h1>AudioFloatFormatConverter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.media.sound;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.AudioFormat.Encoding;
import javax.sound.sampled.spi.FormatConversionProvider;

/**
 * This class is used to convert between 8,16,24,32 bit signed/unsigned
 * big/litle endian fixed/floating stereo/mono/multi-channel audio streams and
 * perform sample-rate conversion if needed.
 *
 * @author Karl Helgason
 */
<span class="nc" id="L45">public final class AudioFloatFormatConverter extends FormatConversionProvider {</span>

    private static class AudioFloatFormatConverterInputStream extends
            InputStream {
        private final AudioFloatConverter converter;

        private final AudioFloatInputStream stream;

        private float[] readfloatbuffer;

        private final int fsize;

        AudioFloatFormatConverterInputStream(AudioFormat targetFormat,
<span class="nc" id="L58">                AudioFloatInputStream stream) {</span>
<span class="nc" id="L59">            this.stream = stream;</span>
<span class="nc" id="L60">            converter = AudioFloatConverter.getConverter(targetFormat);</span>
<span class="nc" id="L61">            fsize = ((targetFormat.getSampleSizeInBits() + 7) / 8);</span>
<span class="nc" id="L62">        }</span>

        public int read() throws IOException {
<span class="nc" id="L65">            byte[] b = new byte[1];</span>
<span class="nc" id="L66">            int ret = read(b);</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">            if (ret &lt; 0)</span>
<span class="nc" id="L68">                return ret;</span>
<span class="nc" id="L69">            return b[0] &amp; 0xFF;</span>
        }

        public int read(byte[] b, int off, int len) throws IOException {

<span class="nc" id="L74">            int flen = len / fsize;</span>
<span class="nc bnc" id="L75" title="All 4 branches missed.">            if (readfloatbuffer == null || readfloatbuffer.length &lt; flen)</span>
<span class="nc" id="L76">                readfloatbuffer = new float[flen];</span>
<span class="nc" id="L77">            int ret = stream.read(readfloatbuffer, 0, flen);</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">            if (ret &lt; 0)</span>
<span class="nc" id="L79">                return ret;</span>
<span class="nc" id="L80">            converter.toByteArray(readfloatbuffer, 0, ret, b, off);</span>
<span class="nc" id="L81">            return ret * fsize;</span>
        }

        public int available() throws IOException {
<span class="nc" id="L85">            int ret = stream.available();</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">            if (ret &lt; 0)</span>
<span class="nc" id="L87">                return ret;</span>
<span class="nc" id="L88">            return ret * fsize;</span>
        }

        public void close() throws IOException {
<span class="nc" id="L92">            stream.close();</span>
<span class="nc" id="L93">        }</span>

        public synchronized void mark(int readlimit) {
<span class="nc" id="L96">            stream.mark(readlimit * fsize);</span>
<span class="nc" id="L97">        }</span>

        public boolean markSupported() {
<span class="nc" id="L100">            return stream.markSupported();</span>
        }

        public synchronized void reset() throws IOException {
<span class="nc" id="L104">            stream.reset();</span>
<span class="nc" id="L105">        }</span>

        public long skip(long n) throws IOException {
<span class="nc" id="L108">            long ret = stream.skip(n / fsize);</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">            if (ret &lt; 0)</span>
<span class="nc" id="L110">                return ret;</span>
<span class="nc" id="L111">            return ret * fsize;</span>
        }

    }

    private static class AudioFloatInputStreamChannelMixer extends
            AudioFloatInputStream {

        private final int targetChannels;

        private final int sourceChannels;

        private final AudioFloatInputStream ais;

        private final AudioFormat targetFormat;

        private float[] conversion_buffer;

        AudioFloatInputStreamChannelMixer(AudioFloatInputStream ais,
<span class="nc" id="L130">                int targetChannels) {</span>
<span class="nc" id="L131">            this.sourceChannels = ais.getFormat().getChannels();</span>
<span class="nc" id="L132">            this.targetChannels = targetChannels;</span>
<span class="nc" id="L133">            this.ais = ais;</span>
<span class="nc" id="L134">            AudioFormat format = ais.getFormat();</span>
<span class="nc" id="L135">            targetFormat = new AudioFormat(format.getEncoding(), format</span>
<span class="nc" id="L136">                    .getSampleRate(), format.getSampleSizeInBits(),</span>
<span class="nc" id="L137">                    targetChannels, (format.getFrameSize() / sourceChannels)</span>
<span class="nc" id="L138">                            * targetChannels, format.getFrameRate(), format</span>
<span class="nc" id="L139">                            .isBigEndian());</span>
<span class="nc" id="L140">        }</span>

        public int available() throws IOException {
<span class="nc" id="L143">            return (ais.available() / sourceChannels) * targetChannels;</span>
        }

        public void close() throws IOException {
<span class="nc" id="L147">            ais.close();</span>
<span class="nc" id="L148">        }</span>

        public AudioFormat getFormat() {
<span class="nc" id="L151">            return targetFormat;</span>
        }

        public long getFrameLength() {
<span class="nc" id="L155">            return ais.getFrameLength();</span>
        }

        public void mark(int readlimit) {
<span class="nc" id="L159">            ais.mark((readlimit / targetChannels) * sourceChannels);</span>
<span class="nc" id="L160">        }</span>

        public boolean markSupported() {
<span class="nc" id="L163">            return ais.markSupported();</span>
        }

        public int read(float[] b, int off, int len) throws IOException {
<span class="nc" id="L167">            int len2 = (len / targetChannels) * sourceChannels;</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">            if (conversion_buffer == null || conversion_buffer.length &lt; len2)</span>
<span class="nc" id="L169">                conversion_buffer = new float[len2];</span>
<span class="nc" id="L170">            int ret = ais.read(conversion_buffer, 0, len2);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (ret &lt; 0)</span>
<span class="nc" id="L172">                return ret;</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (sourceChannels == 1) {</span>
<span class="nc" id="L174">                int cs = targetChannels;</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                for (int c = 0; c &lt; targetChannels; c++) {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">                    for (int i = 0, ix = off + c; i &lt; len2; i++, ix += cs) {</span>
<span class="nc" id="L177">                        b[ix] = conversion_buffer[i];</span>
                    }
                }
<span class="nc bnc" id="L180" title="All 2 branches missed.">            } else if (targetChannels == 1) {</span>
<span class="nc" id="L181">                int cs = sourceChannels;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                for (int i = 0, ix = off; i &lt; len2; i += cs, ix++) {</span>
<span class="nc" id="L183">                    b[ix] = conversion_buffer[i];</span>
                }
<span class="nc bnc" id="L185" title="All 2 branches missed.">                for (int c = 1; c &lt; sourceChannels; c++) {</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                    for (int i = c, ix = off; i &lt; len2; i += cs, ix++) {</span>
<span class="nc" id="L187">                        b[ix] += conversion_buffer[i];</span>
                    }
                }
<span class="nc" id="L190">                float vol = 1f / ((float) sourceChannels);</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                for (int i = 0, ix = off; i &lt; len2; i += cs, ix++) {</span>
<span class="nc" id="L192">                    b[ix] *= vol;</span>
                }
<span class="nc" id="L194">            } else {</span>
<span class="nc" id="L195">                int minChannels = Math.min(sourceChannels, targetChannels);</span>
<span class="nc" id="L196">                int off_len = off + len;</span>
<span class="nc" id="L197">                int ct = targetChannels;</span>
<span class="nc" id="L198">                int cs = sourceChannels;</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                for (int c = 0; c &lt; minChannels; c++) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                    for (int i = off + c, ix = c; i &lt; off_len; i += ct, ix += cs) {</span>
<span class="nc" id="L201">                        b[i] = conversion_buffer[ix];</span>
                    }
                }
<span class="nc bnc" id="L204" title="All 2 branches missed.">                for (int c = minChannels; c &lt; targetChannels; c++) {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                    for (int i = off + c; i &lt; off_len; i += ct) {</span>
<span class="nc" id="L206">                        b[i] = 0;</span>
                    }
                }
            }
<span class="nc" id="L210">            return (ret / sourceChannels) * targetChannels;</span>
        }

        public void reset() throws IOException {
<span class="nc" id="L214">            ais.reset();</span>
<span class="nc" id="L215">        }</span>

        public long skip(long len) throws IOException {
<span class="nc" id="L218">            long ret = ais.skip((len / targetChannels) * sourceChannels);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (ret &lt; 0)</span>
<span class="nc" id="L220">                return ret;</span>
<span class="nc" id="L221">            return (ret / sourceChannels) * targetChannels;</span>
        }

    }

    private static class AudioFloatInputStreamResampler extends
            AudioFloatInputStream {

        private final AudioFloatInputStream ais;

        private final AudioFormat targetFormat;

        private float[] skipbuffer;

        private SoftAbstractResampler resampler;

<span class="nc" id="L237">        private final float[] pitch = new float[1];</span>

        private final float[] ibuffer2;

        private final float[][] ibuffer;

<span class="nc" id="L243">        private float ibuffer_index = 0;</span>

<span class="nc" id="L245">        private int ibuffer_len = 0;</span>

        private final int nrofchannels;

        private float[][] cbuffer;

<span class="nc" id="L251">        private final int buffer_len = 512;</span>

        private final int pad;

        private final int pad2;

<span class="nc" id="L257">        private final float[] ix = new float[1];</span>

<span class="nc" id="L259">        private final int[] ox = new int[1];</span>

<span class="nc" id="L261">        private float[][] mark_ibuffer = null;</span>

<span class="nc" id="L263">        private float mark_ibuffer_index = 0;</span>

<span class="nc" id="L265">        private int mark_ibuffer_len = 0;</span>

        AudioFloatInputStreamResampler(AudioFloatInputStream ais,
<span class="nc" id="L268">                AudioFormat format) {</span>
<span class="nc" id="L269">            this.ais = ais;</span>
<span class="nc" id="L270">            AudioFormat sourceFormat = ais.getFormat();</span>
<span class="nc" id="L271">            targetFormat = new AudioFormat(sourceFormat.getEncoding(), format</span>
<span class="nc" id="L272">                    .getSampleRate(), sourceFormat.getSampleSizeInBits(),</span>
<span class="nc" id="L273">                    sourceFormat.getChannels(), sourceFormat.getFrameSize(),</span>
<span class="nc" id="L274">                    format.getSampleRate(), sourceFormat.isBigEndian());</span>
<span class="nc" id="L275">            nrofchannels = targetFormat.getChannels();</span>
<span class="nc" id="L276">            Object interpolation = format.getProperty(&quot;interpolation&quot;);</span>
<span class="nc bnc" id="L277" title="All 4 branches missed.">            if (interpolation != null &amp;&amp; (interpolation instanceof String)) {</span>
<span class="nc" id="L278">                String resamplerType = (String) interpolation;</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                if (resamplerType.equalsIgnoreCase(&quot;point&quot;))</span>
<span class="nc" id="L280">                    this.resampler = new SoftPointResampler();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">                if (resamplerType.equalsIgnoreCase(&quot;linear&quot;))</span>
<span class="nc" id="L282">                    this.resampler = new SoftLinearResampler2();</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                if (resamplerType.equalsIgnoreCase(&quot;linear1&quot;))</span>
<span class="nc" id="L284">                    this.resampler = new SoftLinearResampler();</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                if (resamplerType.equalsIgnoreCase(&quot;linear2&quot;))</span>
<span class="nc" id="L286">                    this.resampler = new SoftLinearResampler2();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                if (resamplerType.equalsIgnoreCase(&quot;cubic&quot;))</span>
<span class="nc" id="L288">                    this.resampler = new SoftCubicResampler();</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                if (resamplerType.equalsIgnoreCase(&quot;lanczos&quot;))</span>
<span class="nc" id="L290">                    this.resampler = new SoftLanczosResampler();</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                if (resamplerType.equalsIgnoreCase(&quot;sinc&quot;))</span>
<span class="nc" id="L292">                    this.resampler = new SoftSincResampler();</span>
            }
<span class="nc bnc" id="L294" title="All 2 branches missed.">            if (resampler == null)</span>
<span class="nc" id="L295">                resampler = new SoftLinearResampler2(); // new</span>
                                                        // SoftLinearResampler2();
<span class="nc" id="L297">            pitch[0] = sourceFormat.getSampleRate() / format.getSampleRate();</span>
<span class="nc" id="L298">            pad = resampler.getPadding();</span>
<span class="nc" id="L299">            pad2 = pad * 2;</span>
<span class="nc" id="L300">            ibuffer = new float[nrofchannels][buffer_len + pad2];</span>
<span class="nc" id="L301">            ibuffer2 = new float[nrofchannels * buffer_len];</span>
<span class="nc" id="L302">            ibuffer_index = buffer_len + pad;</span>
<span class="nc" id="L303">            ibuffer_len = buffer_len;</span>
<span class="nc" id="L304">        }</span>

        public int available() throws IOException {
<span class="nc" id="L307">            return 0;</span>
        }

        public void close() throws IOException {
<span class="nc" id="L311">            ais.close();</span>
<span class="nc" id="L312">        }</span>

        public AudioFormat getFormat() {
<span class="nc" id="L315">            return targetFormat;</span>
        }

        public long getFrameLength() {
<span class="nc" id="L319">            return AudioSystem.NOT_SPECIFIED; // ais.getFrameLength();</span>
        }

        public void mark(int readlimit) {
<span class="nc" id="L323">            ais.mark((int) (readlimit * pitch[0]));</span>
<span class="nc" id="L324">            mark_ibuffer_index = ibuffer_index;</span>
<span class="nc" id="L325">            mark_ibuffer_len = ibuffer_len;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (mark_ibuffer == null) {</span>
<span class="nc" id="L327">                mark_ibuffer = new float[ibuffer.length][ibuffer[0].length];</span>
            }
<span class="nc bnc" id="L329" title="All 2 branches missed.">            for (int c = 0; c &lt; ibuffer.length; c++) {</span>
<span class="nc" id="L330">                float[] from = ibuffer[c];</span>
<span class="nc" id="L331">                float[] to = mark_ibuffer[c];</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                for (int i = 0; i &lt; to.length; i++) {</span>
<span class="nc" id="L333">                    to[i] = from[i];</span>
                }
            }
<span class="nc" id="L336">        }</span>

        public boolean markSupported() {
<span class="nc" id="L339">            return ais.markSupported();</span>
        }

        private void readNextBuffer() throws IOException {

<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (ibuffer_len == -1)</span>
<span class="nc" id="L345">                return;</span>

<span class="nc bnc" id="L347" title="All 2 branches missed.">            for (int c = 0; c &lt; nrofchannels; c++) {</span>
<span class="nc" id="L348">                float[] buff = ibuffer[c];</span>
<span class="nc" id="L349">                int buffer_len_pad = ibuffer_len + pad2;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                for (int i = ibuffer_len, ix = 0; i &lt; buffer_len_pad; i++, ix++) {</span>
<span class="nc" id="L351">                    buff[ix] = buff[i];</span>
                }
            }

<span class="nc" id="L355">            ibuffer_index -= (ibuffer_len);</span>

<span class="nc" id="L357">            ibuffer_len = ais.read(ibuffer2);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (ibuffer_len &gt;= 0) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                while (ibuffer_len &lt; ibuffer2.length) {</span>
<span class="nc" id="L360">                    int ret = ais.read(ibuffer2, ibuffer_len, ibuffer2.length</span>
                            - ibuffer_len);
<span class="nc bnc" id="L362" title="All 2 branches missed.">                    if (ret == -1)</span>
<span class="nc" id="L363">                        break;</span>
<span class="nc" id="L364">                    ibuffer_len += ret;</span>
<span class="nc" id="L365">                }</span>
<span class="nc" id="L366">                Arrays.fill(ibuffer2, ibuffer_len, ibuffer2.length, 0);</span>
<span class="nc" id="L367">                ibuffer_len /= nrofchannels;</span>
            } else {
<span class="nc" id="L369">                Arrays.fill(ibuffer2, 0, ibuffer2.length, 0);</span>
            }

<span class="nc" id="L372">            int ibuffer2_len = ibuffer2.length;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            for (int c = 0; c &lt; nrofchannels; c++) {</span>
<span class="nc" id="L374">                float[] buff = ibuffer[c];</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                for (int i = c, ix = pad2; i &lt; ibuffer2_len; i += nrofchannels, ix++) {</span>
<span class="nc" id="L376">                    buff[ix] = ibuffer2[i];</span>
                }
            }

<span class="nc" id="L380">        }</span>

        public int read(float[] b, int off, int len) throws IOException {

<span class="nc bnc" id="L384" title="All 4 branches missed.">            if (cbuffer == null || cbuffer[0].length &lt; len / nrofchannels) {</span>
<span class="nc" id="L385">                cbuffer = new float[nrofchannels][len / nrofchannels];</span>
            }
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (ibuffer_len == -1)</span>
<span class="nc" id="L388">                return -1;</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">            if (len &lt; 0)</span>
<span class="nc" id="L390">                return 0;</span>
<span class="nc" id="L391">            int offlen = off + len;</span>
<span class="nc" id="L392">            int remain = len / nrofchannels;</span>
<span class="nc" id="L393">            int destPos = 0;</span>
<span class="nc" id="L394">            int in_end = ibuffer_len;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">            while (remain &gt; 0) {</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">                if (ibuffer_len &gt;= 0) {</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                    if (ibuffer_index &gt;= (ibuffer_len + pad))</span>
<span class="nc" id="L398">                        readNextBuffer();</span>
<span class="nc" id="L399">                    in_end = ibuffer_len + pad;</span>
                }

<span class="nc bnc" id="L402" title="All 2 branches missed.">                if (ibuffer_len &lt; 0) {</span>
<span class="nc" id="L403">                    in_end = pad2;</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                    if (ibuffer_index &gt;= in_end)</span>
<span class="nc" id="L405">                        break;</span>
                }

<span class="nc bnc" id="L408" title="All 2 branches missed.">                if (ibuffer_index &lt; 0)</span>
<span class="nc" id="L409">                    break;</span>
<span class="nc" id="L410">                int preDestPos = destPos;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                for (int c = 0; c &lt; nrofchannels; c++) {</span>
<span class="nc" id="L412">                    ix[0] = ibuffer_index;</span>
<span class="nc" id="L413">                    ox[0] = destPos;</span>
<span class="nc" id="L414">                    float[] buff = ibuffer[c];</span>
<span class="nc" id="L415">                    resampler.interpolate(buff, ix, in_end, pitch, 0,</span>
                            cbuffer[c], ox, len / nrofchannels);
                }
<span class="nc" id="L418">                ibuffer_index = ix[0];</span>
<span class="nc" id="L419">                destPos = ox[0];</span>
<span class="nc" id="L420">                remain -= destPos - preDestPos;</span>
<span class="nc" id="L421">            }</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            for (int c = 0; c &lt; nrofchannels; c++) {</span>
<span class="nc" id="L423">                int ix = 0;</span>
<span class="nc" id="L424">                float[] buff = cbuffer[c];</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">                for (int i = c + off; i &lt; offlen; i += nrofchannels) {</span>
<span class="nc" id="L426">                    b[i] = buff[ix++];</span>
                }
            }
<span class="nc" id="L429">            return len - remain * nrofchannels;</span>
        }

        public void reset() throws IOException {
<span class="nc" id="L433">            ais.reset();</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (mark_ibuffer == null)</span>
<span class="nc" id="L435">                return;</span>
<span class="nc" id="L436">            ibuffer_index = mark_ibuffer_index;</span>
<span class="nc" id="L437">            ibuffer_len = mark_ibuffer_len;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (int c = 0; c &lt; ibuffer.length; c++) {</span>
<span class="nc" id="L439">                float[] from = mark_ibuffer[c];</span>
<span class="nc" id="L440">                float[] to = ibuffer[c];</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                for (int i = 0; i &lt; to.length; i++) {</span>
<span class="nc" id="L442">                    to[i] = from[i];</span>
                }
            }

<span class="nc" id="L446">        }</span>

        public long skip(long len) throws IOException {
<span class="nc bnc" id="L449" title="All 2 branches missed.">            if (len &lt; 0)</span>
<span class="nc" id="L450">                return 0;</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">            if (skipbuffer == null)</span>
<span class="nc" id="L452">                skipbuffer = new float[1024 * targetFormat.getFrameSize()];</span>
<span class="nc" id="L453">            float[] l_skipbuffer = skipbuffer;</span>
<span class="nc" id="L454">            long remain = len;</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            while (remain &gt; 0) {</span>
<span class="nc" id="L456">                int ret = read(l_skipbuffer, 0, (int) Math.min(remain,</span>
                        skipbuffer.length));
<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (ret &lt; 0) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">                    if (remain == len)</span>
<span class="nc" id="L460">                        return ret;</span>
                    break;
                }
<span class="nc" id="L463">                remain -= ret;</span>
<span class="nc" id="L464">            }</span>
<span class="nc" id="L465">            return len - remain;</span>

        }

    }

<span class="nc" id="L471">    private final Encoding[] formats = {Encoding.PCM_SIGNED,</span>
                                        Encoding.PCM_UNSIGNED,
                                        Encoding.PCM_FLOAT};

    public AudioInputStream getAudioInputStream(Encoding targetEncoding,
            AudioInputStream sourceStream) {
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (sourceStream.getFormat().getEncoding().equals(targetEncoding))</span>
<span class="nc" id="L478">            return sourceStream;</span>
<span class="nc" id="L479">        AudioFormat format = sourceStream.getFormat();</span>
<span class="nc" id="L480">        int channels = format.getChannels();</span>
<span class="nc" id="L481">        Encoding encoding = targetEncoding;</span>
<span class="nc" id="L482">        float samplerate = format.getSampleRate();</span>
<span class="nc" id="L483">        int bits = format.getSampleSizeInBits();</span>
<span class="nc" id="L484">        boolean bigendian = format.isBigEndian();</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if (targetEncoding.equals(Encoding.PCM_FLOAT))</span>
<span class="nc" id="L486">            bits = 32;</span>
<span class="nc" id="L487">        AudioFormat targetFormat = new AudioFormat(encoding, samplerate, bits,</span>
                channels, channels * bits / 8, samplerate, bigendian);
<span class="nc" id="L489">        return getAudioInputStream(targetFormat, sourceStream);</span>
    }

    public AudioInputStream getAudioInputStream(AudioFormat targetFormat,
            AudioInputStream sourceStream) {
<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (!isConversionSupported(targetFormat, sourceStream.getFormat()))</span>
<span class="nc" id="L495">            throw new IllegalArgumentException(&quot;Unsupported conversion: &quot;</span>
<span class="nc" id="L496">                    + sourceStream.getFormat().toString() + &quot; to &quot;</span>
<span class="nc" id="L497">                    + targetFormat.toString());</span>
<span class="nc" id="L498">        return getAudioInputStream(targetFormat, AudioFloatInputStream</span>
<span class="nc" id="L499">                .getInputStream(sourceStream));</span>
    }

    public AudioInputStream getAudioInputStream(AudioFormat targetFormat,
            AudioFloatInputStream sourceStream) {

<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (!isConversionSupported(targetFormat, sourceStream.getFormat()))</span>
<span class="nc" id="L506">            throw new IllegalArgumentException(&quot;Unsupported conversion: &quot;</span>
<span class="nc" id="L507">                    + sourceStream.getFormat().toString() + &quot; to &quot;</span>
<span class="nc" id="L508">                    + targetFormat.toString());</span>
<span class="nc" id="L509">        if (targetFormat.getChannels() != sourceStream.getFormat()</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                .getChannels())</span>
<span class="nc" id="L511">            sourceStream = new AudioFloatInputStreamChannelMixer(sourceStream,</span>
<span class="nc" id="L512">                    targetFormat.getChannels());</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (Math.abs(targetFormat.getSampleRate()</span>
<span class="nc" id="L514">                - sourceStream.getFormat().getSampleRate()) &gt; 0.000001)</span>
<span class="nc" id="L515">            sourceStream = new AudioFloatInputStreamResampler(sourceStream,</span>
                    targetFormat);
<span class="nc" id="L517">        return new AudioInputStream(new AudioFloatFormatConverterInputStream(</span>
                targetFormat, sourceStream), targetFormat, sourceStream
<span class="nc" id="L519">                .getFrameLength());</span>
    }

    public Encoding[] getSourceEncodings() {
<span class="nc" id="L523">        return new Encoding[] { Encoding.PCM_SIGNED, Encoding.PCM_UNSIGNED,</span>
                Encoding.PCM_FLOAT };
    }

    public Encoding[] getTargetEncodings() {
<span class="nc" id="L528">        return new Encoding[] { Encoding.PCM_SIGNED, Encoding.PCM_UNSIGNED,</span>
                Encoding.PCM_FLOAT };
    }

    public Encoding[] getTargetEncodings(AudioFormat sourceFormat) {
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (AudioFloatConverter.getConverter(sourceFormat) == null)</span>
<span class="nc" id="L534">            return new Encoding[0];</span>
<span class="nc" id="L535">        return new Encoding[] { Encoding.PCM_SIGNED, Encoding.PCM_UNSIGNED,</span>
                Encoding.PCM_FLOAT };
    }

    public AudioFormat[] getTargetFormats(Encoding targetEncoding,
            AudioFormat sourceFormat) {
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (AudioFloatConverter.getConverter(sourceFormat) == null)</span>
<span class="nc" id="L542">            return new AudioFormat[0];</span>
<span class="nc" id="L543">        int channels = sourceFormat.getChannels();</span>

<span class="nc" id="L545">        ArrayList&lt;AudioFormat&gt; formats = new ArrayList&lt;AudioFormat&gt;();</span>

<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (targetEncoding.equals(Encoding.PCM_SIGNED))</span>
<span class="nc" id="L548">            formats.add(new AudioFormat(Encoding.PCM_SIGNED,</span>
                    AudioSystem.NOT_SPECIFIED, 8, channels, channels,
                    AudioSystem.NOT_SPECIFIED, false));
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (targetEncoding.equals(Encoding.PCM_UNSIGNED))</span>
<span class="nc" id="L552">            formats.add(new AudioFormat(Encoding.PCM_UNSIGNED,</span>
                    AudioSystem.NOT_SPECIFIED, 8, channels, channels,
                    AudioSystem.NOT_SPECIFIED, false));

<span class="nc bnc" id="L556" title="All 2 branches missed.">        for (int bits = 16; bits &lt; 32; bits += 8) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            if (targetEncoding.equals(Encoding.PCM_SIGNED)) {</span>
<span class="nc" id="L558">                formats.add(new AudioFormat(Encoding.PCM_SIGNED,</span>
                        AudioSystem.NOT_SPECIFIED, bits, channels, channels
                                * bits / 8, AudioSystem.NOT_SPECIFIED, false));
<span class="nc" id="L561">                formats.add(new AudioFormat(Encoding.PCM_SIGNED,</span>
                        AudioSystem.NOT_SPECIFIED, bits, channels, channels
                                * bits / 8, AudioSystem.NOT_SPECIFIED, true));
            }
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if (targetEncoding.equals(Encoding.PCM_UNSIGNED)) {</span>
<span class="nc" id="L566">                formats.add(new AudioFormat(Encoding.PCM_UNSIGNED,</span>
                        AudioSystem.NOT_SPECIFIED, bits, channels, channels
                                * bits / 8, AudioSystem.NOT_SPECIFIED, true));
<span class="nc" id="L569">                formats.add(new AudioFormat(Encoding.PCM_UNSIGNED,</span>
                        AudioSystem.NOT_SPECIFIED, bits, channels, channels
                                * bits / 8, AudioSystem.NOT_SPECIFIED, false));
            }
        }

<span class="nc bnc" id="L575" title="All 2 branches missed.">        if (targetEncoding.equals(Encoding.PCM_FLOAT)) {</span>
<span class="nc" id="L576">            formats.add(new AudioFormat(Encoding.PCM_FLOAT,</span>
                    AudioSystem.NOT_SPECIFIED, 32, channels, channels * 4,
                    AudioSystem.NOT_SPECIFIED, false));
<span class="nc" id="L579">            formats.add(new AudioFormat(Encoding.PCM_FLOAT,</span>
                    AudioSystem.NOT_SPECIFIED, 32, channels, channels * 4,
                    AudioSystem.NOT_SPECIFIED, true));
<span class="nc" id="L582">            formats.add(new AudioFormat(Encoding.PCM_FLOAT,</span>
                    AudioSystem.NOT_SPECIFIED, 64, channels, channels * 8,
                    AudioSystem.NOT_SPECIFIED, false));
<span class="nc" id="L585">            formats.add(new AudioFormat(Encoding.PCM_FLOAT,</span>
                    AudioSystem.NOT_SPECIFIED, 64, channels, channels * 8,
                    AudioSystem.NOT_SPECIFIED, true));
        }

<span class="nc" id="L590">        return formats.toArray(new AudioFormat[formats.size()]);</span>
    }

    public boolean isConversionSupported(AudioFormat targetFormat,
            AudioFormat sourceFormat) {
<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (AudioFloatConverter.getConverter(sourceFormat) == null)</span>
<span class="nc" id="L596">            return false;</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">        if (AudioFloatConverter.getConverter(targetFormat) == null)</span>
<span class="nc" id="L598">            return false;</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (sourceFormat.getChannels() &lt;= 0)</span>
<span class="nc" id="L600">            return false;</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">        if (targetFormat.getChannels() &lt;= 0)</span>
<span class="nc" id="L602">            return false;</span>
<span class="nc" id="L603">        return true;</span>
    }

    public boolean isConversionSupported(Encoding targetEncoding,
            AudioFormat sourceFormat) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (AudioFloatConverter.getConverter(sourceFormat) == null)</span>
<span class="nc" id="L609">            return false;</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">        for (int i = 0; i &lt; formats.length; i++) {</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">            if (targetEncoding.equals(formats[i]))</span>
<span class="nc" id="L612">                return true;</span>
        }
<span class="nc" id="L614">        return false;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>