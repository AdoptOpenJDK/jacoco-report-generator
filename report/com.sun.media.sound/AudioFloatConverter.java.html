<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AudioFloatConverter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.media.sound</a> &gt; <span class="el_source">AudioFloatConverter.java</span></div><h1>AudioFloatConverter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.media.sound;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioFormat.Encoding;

/**
 * This class is used to convert between 8,16,24,32,32+ bit signed/unsigned
 * big/litle endian fixed/floating point byte buffers and float buffers.
 *
 * @author Karl Helgason
 */
<span class="nc" id="L41">public abstract class AudioFloatConverter {</span>

    /***************************************************************************
     *
     * LSB Filter, used filter least significant byte in samples arrays.
     *
     * Is used filter out data in lsb byte when SampleSizeInBits is not
     * dividable by 8.
     *
     **************************************************************************/

    private static class AudioFloatLSBFilter extends AudioFloatConverter {

        private final AudioFloatConverter converter;

        final private int offset;

        final private int stepsize;

        final private byte mask;

        private byte[] mask_buffer;

<span class="nc" id="L64">        AudioFloatLSBFilter(AudioFloatConverter converter, AudioFormat format) {</span>
<span class="nc" id="L65">            int bits = format.getSampleSizeInBits();</span>
<span class="nc" id="L66">            boolean bigEndian = format.isBigEndian();</span>
<span class="nc" id="L67">            this.converter = converter;</span>
<span class="nc" id="L68">            stepsize = (bits + 7) / 8;</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            offset = bigEndian ? (stepsize - 1) : 0;</span>
<span class="nc" id="L70">            int lsb_bits = bits % 8;</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">            if (lsb_bits == 0)</span>
<span class="nc" id="L72">                mask = (byte) 0x00;</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">            else if (lsb_bits == 1)</span>
<span class="nc" id="L74">                mask = (byte) 0x80;</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">            else if (lsb_bits == 2)</span>
<span class="nc" id="L76">                mask = (byte) 0xC0;</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">            else if (lsb_bits == 3)</span>
<span class="nc" id="L78">                mask = (byte) 0xE0;</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">            else if (lsb_bits == 4)</span>
<span class="nc" id="L80">                mask = (byte) 0xF0;</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">            else if (lsb_bits == 5)</span>
<span class="nc" id="L82">                mask = (byte) 0xF8;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">            else if (lsb_bits == 6)</span>
<span class="nc" id="L84">                mask = (byte) 0xFC;</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">            else if (lsb_bits == 7)</span>
<span class="nc" id="L86">                mask = (byte) 0xFE;</span>
            else
<span class="nc" id="L88">                mask = (byte) 0xFF;</span>
<span class="nc" id="L89">        }</span>

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L93">            byte[] ret = converter.toByteArray(in_buff, in_offset, in_len,</span>
                    out_buff, out_offset);

<span class="nc" id="L96">            int out_offset_end = in_len * stepsize;</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            for (int i = out_offset + offset; i &lt; out_offset_end; i += stepsize) {</span>
<span class="nc" id="L98">                out_buff[i] = (byte) (out_buff[i] &amp; mask);</span>
            }

<span class="nc" id="L101">            return ret;</span>
        }

        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc bnc" id="L106" title="All 4 branches missed.">            if (mask_buffer == null || mask_buffer.length &lt; in_buff.length)</span>
<span class="nc" id="L107">                mask_buffer = new byte[in_buff.length];</span>
<span class="nc" id="L108">            System.arraycopy(in_buff, 0, mask_buffer, 0, in_buff.length);</span>
<span class="nc" id="L109">            int in_offset_end = out_len * stepsize;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            for (int i = in_offset + offset; i &lt; in_offset_end; i += stepsize) {</span>
<span class="nc" id="L111">                mask_buffer[i] = (byte) (mask_buffer[i] &amp; mask);</span>
            }
<span class="nc" id="L113">            float[] ret = converter.toFloatArray(mask_buffer, in_offset,</span>
                    out_buff, out_offset, out_len);
<span class="nc" id="L115">            return ret;</span>
        }

    }

    /***************************************************************************
     *
     * 64 bit float, little/big-endian
     *
     **************************************************************************/

    // PCM 64 bit float, little-endian
<span class="nc" id="L127">    private static class AudioFloatConversion64L extends AudioFloatConverter {</span>
<span class="nc" id="L128">        ByteBuffer bytebuffer = null;</span>

<span class="nc" id="L130">        DoubleBuffer floatbuffer = null;</span>

<span class="nc" id="L132">        double[] double_buff = null;</span>

        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L136">            int in_len = out_len * 8;</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">            if (bytebuffer == null || bytebuffer.capacity() &lt; in_len) {</span>
<span class="nc" id="L138">                bytebuffer = ByteBuffer.allocate(in_len).order(</span>
                        ByteOrder.LITTLE_ENDIAN);
<span class="nc" id="L140">                floatbuffer = bytebuffer.asDoubleBuffer();</span>
            }
<span class="nc" id="L142">            bytebuffer.position(0);</span>
<span class="nc" id="L143">            floatbuffer.position(0);</span>
<span class="nc" id="L144">            bytebuffer.put(in_buff, in_offset, in_len);</span>
<span class="nc bnc" id="L145" title="All 4 branches missed.">            if (double_buff == null</span>
                    || double_buff.length &lt; out_len + out_offset)
<span class="nc" id="L147">                double_buff = new double[out_len + out_offset];</span>
<span class="nc" id="L148">            floatbuffer.get(double_buff, out_offset, out_len);</span>
<span class="nc" id="L149">            int out_offset_end = out_offset + out_len;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">            for (int i = out_offset; i &lt; out_offset_end; i++) {</span>
<span class="nc" id="L151">                out_buff[i] = (float) double_buff[i];</span>
            }
<span class="nc" id="L153">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L158">            int out_len = in_len * 8;</span>
<span class="nc bnc" id="L159" title="All 4 branches missed.">            if (bytebuffer == null || bytebuffer.capacity() &lt; out_len) {</span>
<span class="nc" id="L160">                bytebuffer = ByteBuffer.allocate(out_len).order(</span>
                        ByteOrder.LITTLE_ENDIAN);
<span class="nc" id="L162">                floatbuffer = bytebuffer.asDoubleBuffer();</span>
            }
<span class="nc" id="L164">            floatbuffer.position(0);</span>
<span class="nc" id="L165">            bytebuffer.position(0);</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">            if (double_buff == null || double_buff.length &lt; in_offset + in_len)</span>
<span class="nc" id="L167">                double_buff = new double[in_offset + in_len];</span>
<span class="nc" id="L168">            int in_offset_end = in_offset + in_len;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            for (int i = in_offset; i &lt; in_offset_end; i++) {</span>
<span class="nc" id="L170">                double_buff[i] = in_buff[i];</span>
            }
<span class="nc" id="L172">            floatbuffer.put(double_buff, in_offset, in_len);</span>
<span class="nc" id="L173">            bytebuffer.get(out_buff, out_offset, out_len);</span>
<span class="nc" id="L174">            return out_buff;</span>
        }
    }

    // PCM 64 bit float, big-endian
<span class="nc" id="L179">    private static class AudioFloatConversion64B extends AudioFloatConverter {</span>
<span class="nc" id="L180">        ByteBuffer bytebuffer = null;</span>

<span class="nc" id="L182">        DoubleBuffer floatbuffer = null;</span>

<span class="nc" id="L184">        double[] double_buff = null;</span>

        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L188">            int in_len = out_len * 8;</span>
<span class="nc bnc" id="L189" title="All 4 branches missed.">            if (bytebuffer == null || bytebuffer.capacity() &lt; in_len) {</span>
<span class="nc" id="L190">                bytebuffer = ByteBuffer.allocate(in_len).order(</span>
                        ByteOrder.BIG_ENDIAN);
<span class="nc" id="L192">                floatbuffer = bytebuffer.asDoubleBuffer();</span>
            }
<span class="nc" id="L194">            bytebuffer.position(0);</span>
<span class="nc" id="L195">            floatbuffer.position(0);</span>
<span class="nc" id="L196">            bytebuffer.put(in_buff, in_offset, in_len);</span>
<span class="nc bnc" id="L197" title="All 4 branches missed.">            if (double_buff == null</span>
                    || double_buff.length &lt; out_len + out_offset)
<span class="nc" id="L199">                double_buff = new double[out_len + out_offset];</span>
<span class="nc" id="L200">            floatbuffer.get(double_buff, out_offset, out_len);</span>
<span class="nc" id="L201">            int out_offset_end = out_offset + out_len;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            for (int i = out_offset; i &lt; out_offset_end; i++) {</span>
<span class="nc" id="L203">                out_buff[i] = (float) double_buff[i];</span>
            }
<span class="nc" id="L205">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L210">            int out_len = in_len * 8;</span>
<span class="nc bnc" id="L211" title="All 4 branches missed.">            if (bytebuffer == null || bytebuffer.capacity() &lt; out_len) {</span>
<span class="nc" id="L212">                bytebuffer = ByteBuffer.allocate(out_len).order(</span>
                        ByteOrder.BIG_ENDIAN);
<span class="nc" id="L214">                floatbuffer = bytebuffer.asDoubleBuffer();</span>
            }
<span class="nc" id="L216">            floatbuffer.position(0);</span>
<span class="nc" id="L217">            bytebuffer.position(0);</span>
<span class="nc bnc" id="L218" title="All 4 branches missed.">            if (double_buff == null || double_buff.length &lt; in_offset + in_len)</span>
<span class="nc" id="L219">                double_buff = new double[in_offset + in_len];</span>
<span class="nc" id="L220">            int in_offset_end = in_offset + in_len;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            for (int i = in_offset; i &lt; in_offset_end; i++) {</span>
<span class="nc" id="L222">                double_buff[i] = in_buff[i];</span>
            }
<span class="nc" id="L224">            floatbuffer.put(double_buff, in_offset, in_len);</span>
<span class="nc" id="L225">            bytebuffer.get(out_buff, out_offset, out_len);</span>
<span class="nc" id="L226">            return out_buff;</span>
        }
    }

    /***************************************************************************
     *
     * 32 bit float, little/big-endian
     *
     **************************************************************************/

    // PCM 32 bit float, little-endian
<span class="nc" id="L237">    private static class AudioFloatConversion32L extends AudioFloatConverter {</span>
<span class="nc" id="L238">        ByteBuffer bytebuffer = null;</span>

<span class="nc" id="L240">        FloatBuffer floatbuffer = null;</span>

        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L244">            int in_len = out_len * 4;</span>
<span class="nc bnc" id="L245" title="All 4 branches missed.">            if (bytebuffer == null || bytebuffer.capacity() &lt; in_len) {</span>
<span class="nc" id="L246">                bytebuffer = ByteBuffer.allocate(in_len).order(</span>
                        ByteOrder.LITTLE_ENDIAN);
<span class="nc" id="L248">                floatbuffer = bytebuffer.asFloatBuffer();</span>
            }
<span class="nc" id="L250">            bytebuffer.position(0);</span>
<span class="nc" id="L251">            floatbuffer.position(0);</span>
<span class="nc" id="L252">            bytebuffer.put(in_buff, in_offset, in_len);</span>
<span class="nc" id="L253">            floatbuffer.get(out_buff, out_offset, out_len);</span>
<span class="nc" id="L254">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L259">            int out_len = in_len * 4;</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">            if (bytebuffer == null || bytebuffer.capacity() &lt; out_len) {</span>
<span class="nc" id="L261">                bytebuffer = ByteBuffer.allocate(out_len).order(</span>
                        ByteOrder.LITTLE_ENDIAN);
<span class="nc" id="L263">                floatbuffer = bytebuffer.asFloatBuffer();</span>
            }
<span class="nc" id="L265">            floatbuffer.position(0);</span>
<span class="nc" id="L266">            bytebuffer.position(0);</span>
<span class="nc" id="L267">            floatbuffer.put(in_buff, in_offset, in_len);</span>
<span class="nc" id="L268">            bytebuffer.get(out_buff, out_offset, out_len);</span>
<span class="nc" id="L269">            return out_buff;</span>
        }
    }

    // PCM 32 bit float, big-endian
<span class="nc" id="L274">    private static class AudioFloatConversion32B extends AudioFloatConverter {</span>
<span class="nc" id="L275">        ByteBuffer bytebuffer = null;</span>

<span class="nc" id="L277">        FloatBuffer floatbuffer = null;</span>

        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L281">            int in_len = out_len * 4;</span>
<span class="nc bnc" id="L282" title="All 4 branches missed.">            if (bytebuffer == null || bytebuffer.capacity() &lt; in_len) {</span>
<span class="nc" id="L283">                bytebuffer = ByteBuffer.allocate(in_len).order(</span>
                        ByteOrder.BIG_ENDIAN);
<span class="nc" id="L285">                floatbuffer = bytebuffer.asFloatBuffer();</span>
            }
<span class="nc" id="L287">            bytebuffer.position(0);</span>
<span class="nc" id="L288">            floatbuffer.position(0);</span>
<span class="nc" id="L289">            bytebuffer.put(in_buff, in_offset, in_len);</span>
<span class="nc" id="L290">            floatbuffer.get(out_buff, out_offset, out_len);</span>
<span class="nc" id="L291">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L296">            int out_len = in_len * 4;</span>
<span class="nc bnc" id="L297" title="All 4 branches missed.">            if (bytebuffer == null || bytebuffer.capacity() &lt; out_len) {</span>
<span class="nc" id="L298">                bytebuffer = ByteBuffer.allocate(out_len).order(</span>
                        ByteOrder.BIG_ENDIAN);
<span class="nc" id="L300">                floatbuffer = bytebuffer.asFloatBuffer();</span>
            }
<span class="nc" id="L302">            floatbuffer.position(0);</span>
<span class="nc" id="L303">            bytebuffer.position(0);</span>
<span class="nc" id="L304">            floatbuffer.put(in_buff, in_offset, in_len);</span>
<span class="nc" id="L305">            bytebuffer.get(out_buff, out_offset, out_len);</span>
<span class="nc" id="L306">            return out_buff;</span>
        }
    }

    /***************************************************************************
     *
     * 8 bit signed/unsigned
     *
     **************************************************************************/

    // PCM 8 bit, signed
<span class="nc" id="L317">    private static class AudioFloatConversion8S extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L320">            int ix = in_offset;</span>
<span class="nc" id="L321">            int ox = out_offset;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++)</span>
<span class="nc" id="L323">                out_buff[ox++] = in_buff[ix++] * (1.0f / 127.0f);</span>
<span class="nc" id="L324">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L329">            int ix = in_offset;</span>
<span class="nc" id="L330">            int ox = out_offset;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++)</span>
<span class="nc" id="L332">                out_buff[ox++] = (byte) (in_buff[ix++] * 127.0f);</span>
<span class="nc" id="L333">            return out_buff;</span>
        }
    }

    // PCM 8 bit, unsigned
<span class="nc" id="L338">    private static class AudioFloatConversion8U extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L341">            int ix = in_offset;</span>
<span class="nc" id="L342">            int ox = out_offset;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++)</span>
<span class="nc" id="L344">                out_buff[ox++] = ((in_buff[ix++] &amp; 0xFF) - 127)</span>
                        * (1.0f / 127.0f);
<span class="nc" id="L346">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L351">            int ix = in_offset;</span>
<span class="nc" id="L352">            int ox = out_offset;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++)</span>
<span class="nc" id="L354">                out_buff[ox++] = (byte) (127 + in_buff[ix++] * 127.0f);</span>
<span class="nc" id="L355">            return out_buff;</span>
        }
    }

    /***************************************************************************
     *
     * 16 bit signed/unsigned, little/big-endian
     *
     **************************************************************************/

    // PCM 16 bit, signed, little-endian
<span class="nc" id="L366">    private static class AudioFloatConversion16SL extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L369">            int ix = in_offset;</span>
<span class="nc" id="L370">            int len = out_offset + out_len;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">            for (int ox = out_offset; ox &lt; len; ox++) {</span>
<span class="nc" id="L372">                out_buff[ox] = ((short) ((in_buff[ix++] &amp; 0xFF) |</span>
                           (in_buff[ix++] &lt;&lt; 8))) * (1.0f / 32767.0f);
            }

<span class="nc" id="L376">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L381">            int ox = out_offset;</span>
<span class="nc" id="L382">            int len = in_offset + in_len;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">            for (int ix = in_offset; ix &lt; len; ix++) {</span>
<span class="nc" id="L384">                int x = (int) (in_buff[ix] * 32767.0);</span>
<span class="nc" id="L385">                out_buff[ox++] = (byte) x;</span>
<span class="nc" id="L386">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
            }
<span class="nc" id="L388">            return out_buff;</span>
        }
    }

    // PCM 16 bit, signed, big-endian
<span class="nc" id="L393">    private static class AudioFloatConversion16SB extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L396">            int ix = in_offset;</span>
<span class="nc" id="L397">            int ox = out_offset;</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L399">                out_buff[ox++] = ((short) ((in_buff[ix++] &lt;&lt; 8) |</span>
                        (in_buff[ix++] &amp; 0xFF))) * (1.0f / 32767.0f);
            }
<span class="nc" id="L402">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L407">            int ix = in_offset;</span>
<span class="nc" id="L408">            int ox = out_offset;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L410">                int x = (int) (in_buff[ix++] * 32767.0);</span>
<span class="nc" id="L411">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L412">                out_buff[ox++] = (byte) x;</span>
            }
<span class="nc" id="L414">            return out_buff;</span>
        }
    }

    // PCM 16 bit, unsigned, little-endian
<span class="nc" id="L419">    private static class AudioFloatConversion16UL extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L422">            int ix = in_offset;</span>
<span class="nc" id="L423">            int ox = out_offset;</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L425">                int x = (in_buff[ix++] &amp; 0xFF) | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8);</span>
<span class="nc" id="L426">                out_buff[ox++] = (x - 32767) * (1.0f / 32767.0f);</span>
            }
<span class="nc" id="L428">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L433">            int ix = in_offset;</span>
<span class="nc" id="L434">            int ox = out_offset;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L436">                int x = 32767 + (int) (in_buff[ix++] * 32767.0);</span>
<span class="nc" id="L437">                out_buff[ox++] = (byte) x;</span>
<span class="nc" id="L438">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
            }
<span class="nc" id="L440">            return out_buff;</span>
        }
    }

    // PCM 16 bit, unsigned, big-endian
<span class="nc" id="L445">    private static class AudioFloatConversion16UB extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L448">            int ix = in_offset;</span>
<span class="nc" id="L449">            int ox = out_offset;</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L451">                int x = ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8) | (in_buff[ix++] &amp; 0xFF);</span>
<span class="nc" id="L452">                out_buff[ox++] = (x - 32767) * (1.0f / 32767.0f);</span>
            }
<span class="nc" id="L454">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L459">            int ix = in_offset;</span>
<span class="nc" id="L460">            int ox = out_offset;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L462">                int x = 32767 + (int) (in_buff[ix++] * 32767.0);</span>
<span class="nc" id="L463">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L464">                out_buff[ox++] = (byte) x;</span>
            }
<span class="nc" id="L466">            return out_buff;</span>
        }
    }

    /***************************************************************************
     *
     * 24 bit signed/unsigned, little/big-endian
     *
     **************************************************************************/

    // PCM 24 bit, signed, little-endian
<span class="nc" id="L477">    private static class AudioFloatConversion24SL extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L480">            int ix = in_offset;</span>
<span class="nc" id="L481">            int ox = out_offset;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L483">                int x = (in_buff[ix++] &amp; 0xFF) | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8)</span>
                        | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16);
<span class="nc bnc" id="L485" title="All 2 branches missed.">                if (x &gt; 0x7FFFFF)</span>
<span class="nc" id="L486">                    x -= 0x1000000;</span>
<span class="nc" id="L487">                out_buff[ox++] = x * (1.0f / (float)0x7FFFFF);</span>
            }
<span class="nc" id="L489">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L494">            int ix = in_offset;</span>
<span class="nc" id="L495">            int ox = out_offset;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L497">                int x = (int) (in_buff[ix++] * (float)0x7FFFFF);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                if (x &lt; 0)</span>
<span class="nc" id="L499">                    x += 0x1000000;</span>
<span class="nc" id="L500">                out_buff[ox++] = (byte) x;</span>
<span class="nc" id="L501">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L502">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
            }
<span class="nc" id="L504">            return out_buff;</span>
        }
    }

    // PCM 24 bit, signed, big-endian
<span class="nc" id="L509">    private static class AudioFloatConversion24SB extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L512">            int ix = in_offset;</span>
<span class="nc" id="L513">            int ox = out_offset;</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L515">                int x = ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16)</span>
                        | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8) | (in_buff[ix++] &amp; 0xFF);
<span class="nc bnc" id="L517" title="All 2 branches missed.">                if (x &gt; 0x7FFFFF)</span>
<span class="nc" id="L518">                    x -= 0x1000000;</span>
<span class="nc" id="L519">                out_buff[ox++] = x * (1.0f / (float)0x7FFFFF);</span>
            }
<span class="nc" id="L521">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L526">            int ix = in_offset;</span>
<span class="nc" id="L527">            int ox = out_offset;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L529">                int x = (int) (in_buff[ix++] * (float)0x7FFFFF);</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                if (x &lt; 0)</span>
<span class="nc" id="L531">                    x += 0x1000000;</span>
<span class="nc" id="L532">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
<span class="nc" id="L533">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L534">                out_buff[ox++] = (byte) x;</span>
            }
<span class="nc" id="L536">            return out_buff;</span>
        }
    }

    // PCM 24 bit, unsigned, little-endian
<span class="nc" id="L541">    private static class AudioFloatConversion24UL extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L544">            int ix = in_offset;</span>
<span class="nc" id="L545">            int ox = out_offset;</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L547">                int x = (in_buff[ix++] &amp; 0xFF) | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8)</span>
                        | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16);
<span class="nc" id="L549">                x -= 0x7FFFFF;</span>
<span class="nc" id="L550">                out_buff[ox++] = x * (1.0f / (float)0x7FFFFF);</span>
            }
<span class="nc" id="L552">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L557">            int ix = in_offset;</span>
<span class="nc" id="L558">            int ox = out_offset;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L560">                int x = (int) (in_buff[ix++] * (float)0x7FFFFF);</span>
<span class="nc" id="L561">                x += 0x7FFFFF;</span>
<span class="nc" id="L562">                out_buff[ox++] = (byte) x;</span>
<span class="nc" id="L563">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L564">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
            }
<span class="nc" id="L566">            return out_buff;</span>
        }
    }

    // PCM 24 bit, unsigned, big-endian
<span class="nc" id="L571">    private static class AudioFloatConversion24UB extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L574">            int ix = in_offset;</span>
<span class="nc" id="L575">            int ox = out_offset;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L577">                int x = ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16)</span>
                        | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8) | (in_buff[ix++] &amp; 0xFF);
<span class="nc" id="L579">                x -= 0x7FFFFF;</span>
<span class="nc" id="L580">                out_buff[ox++] = x * (1.0f / (float)0x7FFFFF);</span>
            }
<span class="nc" id="L582">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L587">            int ix = in_offset;</span>
<span class="nc" id="L588">            int ox = out_offset;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L590">                int x = (int) (in_buff[ix++] * (float)0x7FFFFF);</span>
<span class="nc" id="L591">                x += 0x7FFFFF;</span>
<span class="nc" id="L592">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
<span class="nc" id="L593">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L594">                out_buff[ox++] = (byte) x;</span>
            }
<span class="nc" id="L596">            return out_buff;</span>
        }
    }

    /***************************************************************************
     *
     * 32 bit signed/unsigned, little/big-endian
     *
     **************************************************************************/

    // PCM 32 bit, signed, little-endian
<span class="nc" id="L607">    private static class AudioFloatConversion32SL extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L610">            int ix = in_offset;</span>
<span class="nc" id="L611">            int ox = out_offset;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L613">                int x = (in_buff[ix++] &amp; 0xFF) | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8) |</span>
                        ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16) |
                        ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 24);
<span class="nc" id="L616">                out_buff[ox++] = x * (1.0f / (float)0x7FFFFFFF);</span>
            }
<span class="nc" id="L618">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L623">            int ix = in_offset;</span>
<span class="nc" id="L624">            int ox = out_offset;</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L626">                int x = (int) (in_buff[ix++] * (float)0x7FFFFFFF);</span>
<span class="nc" id="L627">                out_buff[ox++] = (byte) x;</span>
<span class="nc" id="L628">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L629">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
<span class="nc" id="L630">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 24);</span>
            }
<span class="nc" id="L632">            return out_buff;</span>
        }
    }

    // PCM 32 bit, signed, big-endian
<span class="nc" id="L637">    private static class AudioFloatConversion32SB extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L640">            int ix = in_offset;</span>
<span class="nc" id="L641">            int ox = out_offset;</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L643">                int x = ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 24) |</span>
                        ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16) |
                        ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8) | (in_buff[ix++] &amp; 0xFF);
<span class="nc" id="L646">                out_buff[ox++] = x * (1.0f / (float)0x7FFFFFFF);</span>
            }
<span class="nc" id="L648">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L653">            int ix = in_offset;</span>
<span class="nc" id="L654">            int ox = out_offset;</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L656">                int x = (int) (in_buff[ix++] * (float)0x7FFFFFFF);</span>
<span class="nc" id="L657">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 24);</span>
<span class="nc" id="L658">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
<span class="nc" id="L659">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L660">                out_buff[ox++] = (byte) x;</span>
            }
<span class="nc" id="L662">            return out_buff;</span>
        }
    }

    // PCM 32 bit, unsigned, little-endian
<span class="nc" id="L667">    private static class AudioFloatConversion32UL extends AudioFloatConverter {</span>
        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L670">            int ix = in_offset;</span>
<span class="nc" id="L671">            int ox = out_offset;</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L673">                int x = (in_buff[ix++] &amp; 0xFF) | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8) |</span>
                        ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16) |
                        ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 24);
<span class="nc" id="L676">                x -= 0x7FFFFFFF;</span>
<span class="nc" id="L677">                out_buff[ox++] = x * (1.0f / (float)0x7FFFFFFF);</span>
            }
<span class="nc" id="L679">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L684">            int ix = in_offset;</span>
<span class="nc" id="L685">            int ox = out_offset;</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L687">                int x = (int) (in_buff[ix++] * (float)0x7FFFFFFF);</span>
<span class="nc" id="L688">                x += 0x7FFFFFFF;</span>
<span class="nc" id="L689">                out_buff[ox++] = (byte) x;</span>
<span class="nc" id="L690">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L691">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
<span class="nc" id="L692">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 24);</span>
            }
<span class="nc" id="L694">            return out_buff;</span>
        }
    }

    // PCM 32 bit, unsigned, big-endian
<span class="nc" id="L699">    private static class AudioFloatConversion32UB extends AudioFloatConverter {</span>

        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L703">            int ix = in_offset;</span>
<span class="nc" id="L704">            int ox = out_offset;</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L706">                int x = ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 24) |</span>
                        ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16) |
                        ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8) | (in_buff[ix++] &amp; 0xFF);
<span class="nc" id="L709">                x -= 0x7FFFFFFF;</span>
<span class="nc" id="L710">                out_buff[ox++] = x * (1.0f / (float)0x7FFFFFFF);</span>
            }
<span class="nc" id="L712">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L717">            int ix = in_offset;</span>
<span class="nc" id="L718">            int ox = out_offset;</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L720">                int x = (int) (in_buff[ix++] * (float)0x7FFFFFFF);</span>
<span class="nc" id="L721">                x += 0x7FFFFFFF;</span>
<span class="nc" id="L722">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 24);</span>
<span class="nc" id="L723">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
<span class="nc" id="L724">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L725">                out_buff[ox++] = (byte) x;</span>
            }
<span class="nc" id="L727">            return out_buff;</span>
        }
    }

    /***************************************************************************
     *
     * 32+ bit signed/unsigned, little/big-endian
     *
     **************************************************************************/

    // PCM 32+ bit, signed, little-endian
    private static class AudioFloatConversion32xSL extends AudioFloatConverter {

        final int xbytes;

<span class="nc" id="L742">        AudioFloatConversion32xSL(int xbytes) {</span>
<span class="nc" id="L743">            this.xbytes = xbytes;</span>
<span class="nc" id="L744">        }</span>

        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L748">            int ix = in_offset;</span>
<span class="nc" id="L749">            int ox = out_offset;</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L751">                ix += xbytes;</span>
<span class="nc" id="L752">                int x = (in_buff[ix++] &amp; 0xFF) | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8)</span>
                        | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16)
                        | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 24);
<span class="nc" id="L755">                out_buff[ox++] = x * (1.0f / (float)0x7FFFFFFF);</span>
            }
<span class="nc" id="L757">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L762">            int ix = in_offset;</span>
<span class="nc" id="L763">            int ox = out_offset;</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L765">                int x = (int) (in_buff[ix++] * (float)0x7FFFFFFF);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">                for (int j = 0; j &lt; xbytes; j++) {</span>
<span class="nc" id="L767">                    out_buff[ox++] = 0;</span>
                }
<span class="nc" id="L769">                out_buff[ox++] = (byte) x;</span>
<span class="nc" id="L770">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L771">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
<span class="nc" id="L772">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 24);</span>
            }
<span class="nc" id="L774">            return out_buff;</span>
        }
    }

    // PCM 32+ bit, signed, big-endian
    private static class AudioFloatConversion32xSB extends AudioFloatConverter {

        final int xbytes;

<span class="nc" id="L783">        AudioFloatConversion32xSB(int xbytes) {</span>
<span class="nc" id="L784">            this.xbytes = xbytes;</span>
<span class="nc" id="L785">        }</span>

        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L789">            int ix = in_offset;</span>
<span class="nc" id="L790">            int ox = out_offset;</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L792">                int x = ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 24)</span>
                        | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16)
                        | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8)
                        | (in_buff[ix++] &amp; 0xFF);
<span class="nc" id="L796">                ix += xbytes;</span>
<span class="nc" id="L797">                out_buff[ox++] = x * (1.0f / (float)0x7FFFFFFF);</span>
            }
<span class="nc" id="L799">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L804">            int ix = in_offset;</span>
<span class="nc" id="L805">            int ox = out_offset;</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L807">                int x = (int) (in_buff[ix++] * (float)0x7FFFFFFF);</span>
<span class="nc" id="L808">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 24);</span>
<span class="nc" id="L809">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
<span class="nc" id="L810">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L811">                out_buff[ox++] = (byte) x;</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">                for (int j = 0; j &lt; xbytes; j++) {</span>
<span class="nc" id="L813">                    out_buff[ox++] = 0;</span>
                }
            }
<span class="nc" id="L816">            return out_buff;</span>
        }
    }

    // PCM 32+ bit, unsigned, little-endian
    private static class AudioFloatConversion32xUL extends AudioFloatConverter {

        final int xbytes;

<span class="nc" id="L825">        AudioFloatConversion32xUL(int xbytes) {</span>
<span class="nc" id="L826">            this.xbytes = xbytes;</span>
<span class="nc" id="L827">        }</span>

        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L831">            int ix = in_offset;</span>
<span class="nc" id="L832">            int ox = out_offset;</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L834">                ix += xbytes;</span>
<span class="nc" id="L835">                int x = (in_buff[ix++] &amp; 0xFF) | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8)</span>
                        | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16)
                        | ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 24);
<span class="nc" id="L838">                x -= 0x7FFFFFFF;</span>
<span class="nc" id="L839">                out_buff[ox++] = x * (1.0f / (float)0x7FFFFFFF);</span>
            }
<span class="nc" id="L841">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L846">            int ix = in_offset;</span>
<span class="nc" id="L847">            int ox = out_offset;</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L849">                int x = (int) (in_buff[ix++] * (float)0x7FFFFFFF);</span>
<span class="nc" id="L850">                x += 0x7FFFFFFF;</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">                for (int j = 0; j &lt; xbytes; j++) {</span>
<span class="nc" id="L852">                    out_buff[ox++] = 0;</span>
                }
<span class="nc" id="L854">                out_buff[ox++] = (byte) x;</span>
<span class="nc" id="L855">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L856">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
<span class="nc" id="L857">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 24);</span>
            }
<span class="nc" id="L859">            return out_buff;</span>
        }
    }

    // PCM 32+ bit, unsigned, big-endian
<span class="nc" id="L864">    private static class AudioFloatConversion32xUB extends AudioFloatConverter {</span>

        final int xbytes;

<span class="nc" id="L868">        AudioFloatConversion32xUB(int xbytes) {</span>
<span class="nc" id="L869">            this.xbytes = xbytes;</span>
<span class="nc" id="L870">        }</span>

        public float[] toFloatArray(byte[] in_buff, int in_offset,
                float[] out_buff, int out_offset, int out_len) {
<span class="nc" id="L874">            int ix = in_offset;</span>
<span class="nc" id="L875">            int ox = out_offset;</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">            for (int i = 0; i &lt; out_len; i++) {</span>
<span class="nc" id="L877">                int x = ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 24) |</span>
                        ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 16) |
                        ((in_buff[ix++] &amp; 0xFF) &lt;&lt; 8) | (in_buff[ix++] &amp; 0xFF);
<span class="nc" id="L880">                ix += xbytes;</span>
<span class="nc" id="L881">                x -= 2147483647;</span>
<span class="nc" id="L882">                out_buff[ox++] = x * (1.0f / 2147483647.0f);</span>
            }
<span class="nc" id="L884">            return out_buff;</span>
        }

        public byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                byte[] out_buff, int out_offset) {
<span class="nc" id="L889">            int ix = in_offset;</span>
<span class="nc" id="L890">            int ox = out_offset;</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">            for (int i = 0; i &lt; in_len; i++) {</span>
<span class="nc" id="L892">                int x = (int) (in_buff[ix++] * 2147483647.0);</span>
<span class="nc" id="L893">                x += 2147483647;</span>
<span class="nc" id="L894">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 24);</span>
<span class="nc" id="L895">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 16);</span>
<span class="nc" id="L896">                out_buff[ox++] = (byte) (x &gt;&gt;&gt; 8);</span>
<span class="nc" id="L897">                out_buff[ox++] = (byte) x;</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">                for (int j = 0; j &lt; xbytes; j++) {</span>
<span class="nc" id="L899">                    out_buff[ox++] = 0;</span>
                }
            }
<span class="nc" id="L902">            return out_buff;</span>
        }
    }

    public static AudioFloatConverter getConverter(AudioFormat format) {
<span class="nc" id="L907">        AudioFloatConverter conv = null;</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">        if (format.getFrameSize() == 0)</span>
<span class="nc" id="L909">            return null;</span>
<span class="nc" id="L910">        if (format.getFrameSize() !=</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">                ((format.getSampleSizeInBits() + 7) / 8) * format.getChannels()) {</span>
<span class="nc" id="L912">            return null;</span>
        }
<span class="nc bnc" id="L914" title="All 2 branches missed.">        if (format.getEncoding().equals(Encoding.PCM_SIGNED)) {</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">            if (format.isBigEndian()) {</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">                if (format.getSampleSizeInBits() &lt;= 8) {</span>
<span class="nc" id="L917">                    conv = new AudioFloatConversion8S();</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 8 &amp;&amp;</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">                      format.getSampleSizeInBits() &lt;= 16) {</span>
<span class="nc" id="L920">                    conv = new AudioFloatConversion16SB();</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 16 &amp;&amp;</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">                      format.getSampleSizeInBits() &lt;= 24) {</span>
<span class="nc" id="L923">                    conv = new AudioFloatConversion24SB();</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 24 &amp;&amp;</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                      format.getSampleSizeInBits() &lt;= 32) {</span>
<span class="nc" id="L926">                    conv = new AudioFloatConversion32SB();</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 32) {</span>
<span class="nc" id="L928">                    conv = new AudioFloatConversion32xSB(((format</span>
<span class="nc" id="L929">                            .getSampleSizeInBits() + 7) / 8) - 4);</span>
                }
            } else {
<span class="nc bnc" id="L932" title="All 2 branches missed.">                if (format.getSampleSizeInBits() &lt;= 8) {</span>
<span class="nc" id="L933">                    conv = new AudioFloatConversion8S();</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 8 &amp;&amp;</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">                         format.getSampleSizeInBits() &lt;= 16) {</span>
<span class="nc" id="L936">                    conv = new AudioFloatConversion16SL();</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 16 &amp;&amp;</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">                         format.getSampleSizeInBits() &lt;= 24) {</span>
<span class="nc" id="L939">                    conv = new AudioFloatConversion24SL();</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 24 &amp;&amp;</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">                         format.getSampleSizeInBits() &lt;= 32) {</span>
<span class="nc" id="L942">                    conv = new AudioFloatConversion32SL();</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 32) {</span>
<span class="nc" id="L944">                    conv = new AudioFloatConversion32xSL(((format</span>
<span class="nc" id="L945">                            .getSampleSizeInBits() + 7) / 8) - 4);</span>
                }
            }
<span class="nc bnc" id="L948" title="All 2 branches missed.">        } else if (format.getEncoding().equals(Encoding.PCM_UNSIGNED)) {</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">            if (format.isBigEndian()) {</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">                if (format.getSampleSizeInBits() &lt;= 8) {</span>
<span class="nc" id="L951">                    conv = new AudioFloatConversion8U();</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 8 &amp;&amp;</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">                        format.getSampleSizeInBits() &lt;= 16) {</span>
<span class="nc" id="L954">                    conv = new AudioFloatConversion16UB();</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 16 &amp;&amp;</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">                        format.getSampleSizeInBits() &lt;= 24) {</span>
<span class="nc" id="L957">                    conv = new AudioFloatConversion24UB();</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 24 &amp;&amp;</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">                        format.getSampleSizeInBits() &lt;= 32) {</span>
<span class="nc" id="L960">                    conv = new AudioFloatConversion32UB();</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 32) {</span>
<span class="nc" id="L962">                    conv = new AudioFloatConversion32xUB(((</span>
<span class="nc" id="L963">                            format.getSampleSizeInBits() + 7) / 8) - 4);</span>
                }
            } else {
<span class="nc bnc" id="L966" title="All 2 branches missed.">                if (format.getSampleSizeInBits() &lt;= 8) {</span>
<span class="nc" id="L967">                    conv = new AudioFloatConversion8U();</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 8 &amp;&amp;</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">                        format.getSampleSizeInBits() &lt;= 16) {</span>
<span class="nc" id="L970">                    conv = new AudioFloatConversion16UL();</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 16 &amp;&amp;</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">                        format.getSampleSizeInBits() &lt;= 24) {</span>
<span class="nc" id="L973">                    conv = new AudioFloatConversion24UL();</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 24 &amp;&amp;</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">                        format.getSampleSizeInBits() &lt;= 32) {</span>
<span class="nc" id="L976">                    conv = new AudioFloatConversion32UL();</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">                } else if (format.getSampleSizeInBits() &gt; 32) {</span>
<span class="nc" id="L978">                    conv = new AudioFloatConversion32xUL(((</span>
<span class="nc" id="L979">                            format.getSampleSizeInBits() + 7) / 8) - 4);</span>
                }
            }
<span class="nc bnc" id="L982" title="All 2 branches missed.">        } else if (format.getEncoding().equals(Encoding.PCM_FLOAT)) {</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">            if (format.getSampleSizeInBits() == 32) {</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">                if (format.isBigEndian())</span>
<span class="nc" id="L985">                    conv = new AudioFloatConversion32B();</span>
                else
<span class="nc" id="L987">                    conv = new AudioFloatConversion32L();</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">            } else if (format.getSampleSizeInBits() == 64) {</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">                if (format.isBigEndian())</span>
<span class="nc" id="L990">                    conv = new AudioFloatConversion64B();</span>
                else
<span class="nc" id="L992">                    conv = new AudioFloatConversion64L();</span>
            }

        }

<span class="nc bnc" id="L997" title="All 2 branches missed.">        if ((format.getEncoding().equals(Encoding.PCM_SIGNED) ||</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">                format.getEncoding().equals(Encoding.PCM_UNSIGNED)) &amp;&amp;</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">                (format.getSampleSizeInBits() % 8 != 0)) {</span>
<span class="nc" id="L1000">            conv = new AudioFloatLSBFilter(conv, format);</span>
        }

<span class="nc bnc" id="L1003" title="All 2 branches missed.">        if (conv != null)</span>
<span class="nc" id="L1004">            conv.format = format;</span>
<span class="nc" id="L1005">        return conv;</span>
    }

    private AudioFormat format;

    public final AudioFormat getFormat() {
<span class="nc" id="L1011">        return format;</span>
    }

    public abstract float[] toFloatArray(byte[] in_buff, int in_offset,
            float[] out_buff, int out_offset, int out_len);

    public final float[] toFloatArray(byte[] in_buff, float[] out_buff,
            int out_offset, int out_len) {
<span class="nc" id="L1019">        return toFloatArray(in_buff, 0, out_buff, out_offset, out_len);</span>
    }

    public final float[] toFloatArray(byte[] in_buff, int in_offset,
            float[] out_buff, int out_len) {
<span class="nc" id="L1024">        return toFloatArray(in_buff, in_offset, out_buff, 0, out_len);</span>
    }

    public final float[] toFloatArray(byte[] in_buff, float[] out_buff,
                                      int out_len) {
<span class="nc" id="L1029">        return toFloatArray(in_buff, 0, out_buff, 0, out_len);</span>
    }

    public final float[] toFloatArray(byte[] in_buff, float[] out_buff) {
<span class="nc" id="L1033">        return toFloatArray(in_buff, 0, out_buff, 0, out_buff.length);</span>
    }

    public abstract byte[] toByteArray(float[] in_buff, int in_offset,
            int in_len, byte[] out_buff, int out_offset);

    public final byte[] toByteArray(float[] in_buff, int in_len,
                                    byte[] out_buff, int out_offset) {
<span class="nc" id="L1041">        return toByteArray(in_buff, 0, in_len, out_buff, out_offset);</span>
    }

    public final byte[] toByteArray(float[] in_buff, int in_offset, int in_len,
                                    byte[] out_buff) {
<span class="nc" id="L1046">        return toByteArray(in_buff, in_offset, in_len, out_buff, 0);</span>
    }

    public final byte[] toByteArray(float[] in_buff, int in_len,
                                    byte[] out_buff) {
<span class="nc" id="L1051">        return toByteArray(in_buff, 0, in_len, out_buff, 0);</span>
    }

    public final byte[] toByteArray(float[] in_buff, byte[] out_buff) {
<span class="nc" id="L1055">        return toByteArray(in_buff, 0, in_buff.length, out_buff, 0);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>