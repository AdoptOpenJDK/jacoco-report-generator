<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>HKSCS.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.nio.cs.ext</a> &gt; <span class="el_source">HKSCS.java</span></div><h1>HKSCS.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.cs.ext;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CoderResult;
import java.util.Arrays;
import sun.nio.cs.Surrogate;
import static sun.nio.cs.CharsetMapping.*;

<span class="nc" id="L38">public class HKSCS {</span>

    public static class Decoder extends DoubleByte.Decoder {
<span class="nc" id="L41">        static int b2Min = 0x40;</span>
<span class="nc" id="L42">        static int b2Max = 0xfe;</span>

        private char[][] b2cBmp;
        private char[][] b2cSupp;
        private DoubleByte.Decoder big5Dec;

        protected Decoder(Charset cs,
                          DoubleByte.Decoder big5Dec,
                          char[][] b2cBmp, char[][] b2cSupp)
        {
            // super(cs, 0.5f, 1.0f);
            // need to extends DoubleByte.Decoder so the
            // sun.io can use it. this implementation
<span class="nc" id="L55">            super(cs, 0.5f, 1.0f, null, null, 0, 0);</span>
<span class="nc" id="L56">            this.big5Dec = big5Dec;</span>
<span class="nc" id="L57">            this.b2cBmp = b2cBmp;</span>
<span class="nc" id="L58">            this.b2cSupp = b2cSupp;</span>
<span class="nc" id="L59">        }</span>

        public char decodeSingle(int b) {
<span class="nc" id="L62">            return big5Dec.decodeSingle(b);</span>
        }

        public char decodeBig5(int b1, int b2) {
<span class="nc" id="L66">            return big5Dec.decodeDouble(b1, b2);</span>
        }

        public char decodeDouble(int b1, int b2) {
<span class="nc" id="L70">            return b2cBmp[b1][b2 - b2Min];</span>
        }

        public char decodeDoubleEx(int b1, int b2) {
            /* if the b2cSupp is null, the subclass need
               to override the methold
            if (b2cSupp == null)
                return UNMAPPABLE_DECODING;
             */
<span class="nc" id="L79">            return b2cSupp[b1][b2 - b2Min];</span>
        }

        protected CoderResult decodeArrayLoop(ByteBuffer src, CharBuffer dst) {
<span class="nc" id="L83">            byte[] sa = src.array();</span>
<span class="nc" id="L84">            int sp = src.arrayOffset() + src.position();</span>
<span class="nc" id="L85">            int sl = src.arrayOffset() + src.limit();</span>

<span class="nc" id="L87">            char[] da = dst.array();</span>
<span class="nc" id="L88">            int dp = dst.arrayOffset() + dst.position();</span>
<span class="nc" id="L89">            int dl = dst.arrayOffset() + dst.limit();</span>

            try {
<span class="nc bnc" id="L92" title="All 2 branches missed.">                while (sp &lt; sl) {</span>
<span class="nc" id="L93">                    int b1 = sa[sp] &amp; 0xff;</span>
<span class="nc" id="L94">                    char c = decodeSingle(b1);</span>
<span class="nc" id="L95">                    int inSize = 1, outSize = 1;</span>
<span class="nc" id="L96">                    char[] cc = null;</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">                    if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                        if (sl - sp &lt; 2)</span>
<span class="nc" id="L99">                            return CoderResult.UNDERFLOW;</span>
<span class="nc" id="L100">                        int b2 = sa[sp + 1] &amp; 0xff;</span>
<span class="nc" id="L101">                        inSize++;</span>
<span class="nc bnc" id="L102" title="All 4 branches missed.">                        if (b2 &lt; b2Min || b2 &gt; b2Max)</span>
<span class="nc" id="L103">                            return CoderResult.unmappableForLength(2);</span>
<span class="nc" id="L104">                        c = decodeDouble(b1, b2);           //bmp</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">                        if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc" id="L106">                            c = decodeDoubleEx(b1, b2);     //supp</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">                            if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc" id="L108">                                c = decodeBig5(b1, b2);     //big5</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">                                if (c == UNMAPPABLE_DECODING)</span>
<span class="nc" id="L110">                                    return CoderResult.unmappableForLength(2);</span>
                            } else {
                                // supplementary character in u+2xxxx area
<span class="nc" id="L113">                                outSize = 2;</span>
                            }
                        }
                    }
<span class="nc bnc" id="L117" title="All 2 branches missed.">                    if (dl - dp &lt; outSize)</span>
<span class="nc" id="L118">                        return CoderResult.OVERFLOW;</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">                    if (outSize == 2) {</span>
                        // supplementary characters
<span class="nc" id="L121">                        da[dp++] = Surrogate.high(0x20000 + c);</span>
<span class="nc" id="L122">                        da[dp++] = Surrogate.low(0x20000 + c);</span>
                    } else {
<span class="nc" id="L124">                        da[dp++] = c;</span>
                    }
<span class="nc" id="L126">                    sp += inSize;</span>
<span class="nc" id="L127">                }</span>
<span class="nc" id="L128">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L130">                src.position(sp - src.arrayOffset());</span>
<span class="nc" id="L131">                dst.position(dp - dst.arrayOffset());</span>
            }
        }

        protected CoderResult decodeBufferLoop(ByteBuffer src, CharBuffer dst) {
<span class="nc" id="L136">            int mark = src.position();</span>
            try {
<span class="nc bnc" id="L138" title="All 2 branches missed.">                while (src.hasRemaining()) {</span>
<span class="nc" id="L139">                    char[] cc = null;</span>
<span class="nc" id="L140">                    int b1 = src.get() &amp; 0xff;</span>
<span class="nc" id="L141">                    int inSize = 1, outSize = 1;</span>
<span class="nc" id="L142">                    char c = decodeSingle(b1);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">                    if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                        if (src.remaining() &lt; 1)</span>
<span class="nc" id="L145">                            return CoderResult.UNDERFLOW;</span>
<span class="nc" id="L146">                        int b2 = src.get() &amp; 0xff;</span>
<span class="nc" id="L147">                        inSize++;</span>
<span class="nc bnc" id="L148" title="All 4 branches missed.">                        if (b2 &lt; b2Min || b2 &gt; b2Max)</span>
<span class="nc" id="L149">                            return CoderResult.unmappableForLength(2);</span>
<span class="nc" id="L150">                        c = decodeDouble(b1, b2);           //bmp</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">                        if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc" id="L152">                            c = decodeDoubleEx(b1, b2);     //supp</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                            if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc" id="L154">                                c = decodeBig5(b1, b2);     //big5</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                                if (c == UNMAPPABLE_DECODING)</span>
<span class="nc" id="L156">                                    return CoderResult.unmappableForLength(2);</span>
                            } else {
<span class="nc" id="L158">                                outSize = 2;</span>
                            }
                        }
                    }
<span class="nc bnc" id="L162" title="All 2 branches missed.">                    if (dst.remaining() &lt; outSize)</span>
<span class="nc" id="L163">                        return CoderResult.OVERFLOW;</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">                    if (outSize == 2) {</span>
<span class="nc" id="L165">                        dst.put(Surrogate.high(0x20000 + c));</span>
<span class="nc" id="L166">                        dst.put(Surrogate.low(0x20000 + c));</span>
                    } else {
<span class="nc" id="L168">                        dst.put(c);</span>
                    }
<span class="nc" id="L170">                    mark += inSize;</span>
<span class="nc" id="L171">                }</span>
<span class="nc" id="L172">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L174">                src.position(mark);</span>
            }
        }

        public int decode(byte[] src, int sp, int len, char[] dst) {
<span class="nc" id="L179">            int dp = 0;</span>
<span class="nc" id="L180">            int sl = sp + len;</span>
<span class="nc" id="L181">            char repl = replacement().charAt(0);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">            while (sp &lt; sl) {</span>
<span class="nc" id="L183">                int b1 = src[sp++] &amp; 0xff;</span>
<span class="nc" id="L184">                char c = decodeSingle(b1);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                    if (sl == sp) {</span>
<span class="nc" id="L187">                        c = repl;</span>
                    } else {
<span class="nc" id="L189">                        int b2 = src[sp++] &amp; 0xff;</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">                        if (b2 &lt; b2Min || b2 &gt; b2Max) {</span>
<span class="nc" id="L191">                            c = repl;</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                        } else if ((c = decodeDouble(b1, b2)) == UNMAPPABLE_DECODING) {</span>
<span class="nc" id="L193">                            c = decodeDoubleEx(b1, b2);     //supp</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">                            if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc" id="L195">                                c = decodeBig5(b1, b2);     //big5</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                                if (c == UNMAPPABLE_DECODING)</span>
<span class="nc" id="L197">                                    c = repl;</span>
                            } else {
                                // supplementary character in u+2xxxx area
<span class="nc" id="L200">                                dst[dp++] = Surrogate.high(0x20000 + c);</span>
<span class="nc" id="L201">                                dst[dp++] = Surrogate.low(0x20000 + c);</span>
<span class="nc" id="L202">                                continue;</span>
                            }
                        }
                    }
                }
<span class="nc" id="L207">                dst[dp++] = c;</span>
<span class="nc" id="L208">            }</span>
<span class="nc" id="L209">            return dp;</span>
        }

        public CoderResult decodeLoop(ByteBuffer src, CharBuffer dst) {
<span class="nc bnc" id="L213" title="All 4 branches missed.">            if (src.hasArray() &amp;&amp; dst.hasArray())</span>
<span class="nc" id="L214">                return decodeArrayLoop(src, dst);</span>
            else
<span class="nc" id="L216">                return decodeBufferLoop(src, dst);</span>
        }

        static void initb2c(char[][]b2c, String[] b2cStr)
        {
<span class="nc bnc" id="L221" title="All 2 branches missed.">            for (int i = 0; i &lt; b2cStr.length; i++) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                if (b2cStr[i] == null)</span>
<span class="nc" id="L223">                    b2c[i] = DoubleByte.B2C_UNMAPPABLE;</span>
                else
<span class="nc" id="L225">                    b2c[i] = b2cStr[i].toCharArray();</span>
            }
<span class="nc" id="L227">        }</span>

    }

<span class="nc" id="L231">    public static class Encoder extends DoubleByte.Encoder {</span>
        private DoubleByte.Encoder big5Enc;
        private char[][] c2bBmp;
        private char[][] c2bSupp;

        protected Encoder(Charset cs,
                          DoubleByte.Encoder big5Enc,
                          char[][] c2bBmp,
                          char[][] c2bSupp)
        {
<span class="nc" id="L241">            super(cs, null, null);</span>
<span class="nc" id="L242">            this.big5Enc = big5Enc;</span>
<span class="nc" id="L243">            this.c2bBmp = c2bBmp;</span>
<span class="nc" id="L244">            this.c2bSupp = c2bSupp;</span>
<span class="nc" id="L245">        }</span>

        public int encodeBig5(char ch) {
<span class="nc" id="L248">            return big5Enc.encodeChar(ch);</span>
        }

        public int encodeChar(char ch) {
<span class="nc" id="L252">            int bb = c2bBmp[ch &gt;&gt; 8][ch &amp; 0xff];</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (bb == UNMAPPABLE_ENCODING)</span>
<span class="nc" id="L254">                return encodeBig5(ch);</span>
<span class="nc" id="L255">            return bb;</span>
        }

        public int encodeSupp(int cp) {
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if ((cp &amp; 0xf0000) != 0x20000)</span>
<span class="nc" id="L260">                return UNMAPPABLE_ENCODING;</span>
<span class="nc" id="L261">            return c2bSupp[(cp &gt;&gt; 8) &amp; 0xff][cp &amp; 0xff];</span>
        }

        public boolean canEncode(char c) {
<span class="nc bnc" id="L265" title="All 2 branches missed.">            return encodeChar(c) != UNMAPPABLE_ENCODING;</span>
        }

        protected CoderResult encodeArrayLoop(CharBuffer src, ByteBuffer dst) {
<span class="nc" id="L269">            char[] sa = src.array();</span>
<span class="nc" id="L270">            int sp = src.arrayOffset() + src.position();</span>
<span class="nc" id="L271">            int sl = src.arrayOffset() + src.limit();</span>

<span class="nc" id="L273">            byte[] da = dst.array();</span>
<span class="nc" id="L274">            int dp = dst.arrayOffset() + dst.position();</span>
<span class="nc" id="L275">            int dl = dst.arrayOffset() + dst.limit();</span>

            try {
<span class="nc bnc" id="L278" title="All 2 branches missed.">                while (sp &lt; sl) {</span>
<span class="nc" id="L279">                    char c = sa[sp];</span>
<span class="nc" id="L280">                    int inSize = 1;</span>
<span class="nc" id="L281">                    int bb = encodeChar(c);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                    if (bb == UNMAPPABLE_ENCODING) {</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                        if (Character.isSurrogate(c)) {</span>
                            int cp;
<span class="nc bnc" id="L285" title="All 2 branches missed.">                            if ((cp = sgp().parse(c, sa, sp, sl)) &lt; 0)</span>
<span class="nc" id="L286">                                return sgp.error();</span>
<span class="nc" id="L287">                            bb = encodeSupp(cp);</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">                            if (bb == UNMAPPABLE_ENCODING)</span>
<span class="nc" id="L289">                                return CoderResult.unmappableForLength(2);</span>
<span class="nc" id="L290">                            inSize = 2;</span>
<span class="nc" id="L291">                        } else {</span>
<span class="nc" id="L292">                            return CoderResult.unmappableForLength(1);</span>
                        }
                    }
<span class="nc bnc" id="L295" title="All 2 branches missed.">                    if (bb &gt; MAX_SINGLEBYTE) {    // DoubleByte</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                        if (dl - dp &lt; 2)</span>
<span class="nc" id="L297">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L298">                        da[dp++] = (byte)(bb &gt;&gt; 8);</span>
<span class="nc" id="L299">                        da[dp++] = (byte)bb;</span>
                    } else {                      // SingleByte
<span class="nc bnc" id="L301" title="All 2 branches missed.">                        if (dl - dp &lt; 1)</span>
<span class="nc" id="L302">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L303">                        da[dp++] = (byte)bb;</span>
                    }
<span class="nc" id="L305">                    sp += inSize;</span>
<span class="nc" id="L306">                }</span>
<span class="nc" id="L307">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L309">                src.position(sp - src.arrayOffset());</span>
<span class="nc" id="L310">                dst.position(dp - dst.arrayOffset());</span>
            }
        }

        protected CoderResult encodeBufferLoop(CharBuffer src, ByteBuffer dst) {
<span class="nc" id="L315">            int mark = src.position();</span>
            try {
<span class="nc bnc" id="L317" title="All 2 branches missed.">                while (src.hasRemaining()) {</span>
<span class="nc" id="L318">                    int inSize = 1;</span>
<span class="nc" id="L319">                    char c = src.get();</span>
<span class="nc" id="L320">                    int bb = encodeChar(c);</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">                    if (bb == UNMAPPABLE_ENCODING) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">                        if (Character.isSurrogate(c)) {</span>
                            int cp;
<span class="nc bnc" id="L324" title="All 2 branches missed.">                            if ((cp = sgp().parse(c, src)) &lt; 0)</span>
<span class="nc" id="L325">                                return sgp.error();</span>
<span class="nc" id="L326">                            bb = encodeSupp(cp);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                            if (bb == UNMAPPABLE_ENCODING)</span>
<span class="nc" id="L328">                                return CoderResult.unmappableForLength(2);</span>
<span class="nc" id="L329">                            inSize = 2;</span>
<span class="nc" id="L330">                        } else {</span>
<span class="nc" id="L331">                            return CoderResult.unmappableForLength(1);</span>
                        }
                    }
<span class="nc bnc" id="L334" title="All 2 branches missed.">                    if (bb &gt; MAX_SINGLEBYTE) {  // DoubleByte</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                        if (dst.remaining() &lt; 2)</span>
<span class="nc" id="L336">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L337">                        dst.put((byte)(bb &gt;&gt; 8));</span>
<span class="nc" id="L338">                        dst.put((byte)(bb));</span>
                    } else {
<span class="nc bnc" id="L340" title="All 2 branches missed.">                        if (dst.remaining() &lt; 1)</span>
<span class="nc" id="L341">                        return CoderResult.OVERFLOW;</span>
<span class="nc" id="L342">                        dst.put((byte)bb);</span>
                    }
<span class="nc" id="L344">                    mark += inSize;</span>
<span class="nc" id="L345">                }</span>
<span class="nc" id="L346">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L348">                src.position(mark);</span>
            }
        }

        protected CoderResult encodeLoop(CharBuffer src, ByteBuffer dst) {
<span class="nc bnc" id="L353" title="All 4 branches missed.">            if (src.hasArray() &amp;&amp; dst.hasArray())</span>
<span class="nc" id="L354">                return encodeArrayLoop(src, dst);</span>
            else
<span class="nc" id="L356">                return encodeBufferLoop(src, dst);</span>
        }

<span class="nc" id="L359">        private byte[] repl = replacement();</span>
        protected void implReplaceWith(byte[] newReplacement) {
<span class="nc" id="L361">            repl = newReplacement;</span>
<span class="nc" id="L362">        }</span>

        public int encode(char[] src, int sp, int len, byte[] dst) {
<span class="nc" id="L365">            int dp = 0;</span>
<span class="nc" id="L366">            int sl = sp + len;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">            while (sp &lt; sl) {</span>
<span class="nc" id="L368">                char c = src[sp++];</span>
<span class="nc" id="L369">                int bb = encodeChar(c);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                if (bb == UNMAPPABLE_ENCODING) {</span>
<span class="nc bnc" id="L371" title="All 4 branches missed.">                    if (!Character.isHighSurrogate(c) || sp == sl ||</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                        !Character.isLowSurrogate(src[sp]) ||</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">                        (bb = encodeSupp(Character.toCodePoint(c, src[sp++])))</span>
                        == UNMAPPABLE_ENCODING) {
<span class="nc" id="L375">                        dst[dp++] = repl[0];</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                        if (repl.length &gt; 1)</span>
<span class="nc" id="L377">                            dst[dp++] = repl[1];</span>
                        continue;
                    }
<span class="nc" id="L380">                    sp++;</span>
                }
<span class="nc bnc" id="L382" title="All 2 branches missed.">                if (bb &gt; MAX_SINGLEBYTE) {        // DoubleByte</span>
<span class="nc" id="L383">                    dst[dp++] = (byte)(bb &gt;&gt; 8);</span>
<span class="nc" id="L384">                    dst[dp++] = (byte)bb;</span>
                } else {                          // SingleByte
<span class="nc" id="L386">                    dst[dp++] = (byte)bb;</span>
                }
<span class="nc" id="L388">            }</span>
<span class="nc" id="L389">            return dp;</span>
        }


<span class="nc" id="L393">        static char[] C2B_UNMAPPABLE = new char[0x100];</span>
        static {
<span class="nc" id="L395">            Arrays.fill(C2B_UNMAPPABLE, (char)UNMAPPABLE_ENCODING);</span>
<span class="nc" id="L396">        }</span>

       static void initc2b(char[][] c2b, String[] b2cStr, String pua) {
            // init c2b/c2bSupp from b2cStr and supp
<span class="nc" id="L400">            int b2Min = 0x40;</span>
<span class="nc" id="L401">            Arrays.fill(c2b, C2B_UNMAPPABLE);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            for (int b1 = 0; b1 &lt; 0x100; b1++) {</span>
<span class="nc" id="L403">                String s = b2cStr[b1];</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                if (s == null)</span>
<span class="nc" id="L405">                    continue;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="nc" id="L407">                    char c = s.charAt(i);</span>
<span class="nc" id="L408">                    int hi = c &gt;&gt; 8;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">                    if (c2b[hi] == C2B_UNMAPPABLE) {</span>
<span class="nc" id="L410">                        c2b[hi] = new char[0x100];</span>
<span class="nc" id="L411">                        Arrays.fill(c2b[hi], (char)UNMAPPABLE_ENCODING);</span>
                    }
<span class="nc" id="L413">                    c2b[hi][c &amp; 0xff] = (char)((b1 &lt;&lt; 8) | (i + b2Min));</span>
                }
            }
<span class="nc bnc" id="L416" title="All 2 branches missed.">            if (pua != null) {        // add the compatibility pua entries</span>
<span class="nc" id="L417">                char c = '\ue000';    //first pua character</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                for (int i = 0; i &lt; pua.length(); i++) {</span>
<span class="nc" id="L419">                    char bb = pua.charAt(i);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                    if (bb != UNMAPPABLE_DECODING) {</span>
<span class="nc" id="L421">                        int hi = c &gt;&gt; 8;</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                        if (c2b[hi] == C2B_UNMAPPABLE) {</span>
<span class="nc" id="L423">                            c2b[hi] = new char[0x100];</span>
<span class="nc" id="L424">                            Arrays.fill(c2b[hi], (char)UNMAPPABLE_ENCODING);</span>
                        }
<span class="nc" id="L426">                        c2b[hi][c &amp; 0xff] = bb;</span>
                    }
<span class="nc" id="L428">                    c++;</span>
                }
            }
<span class="nc" id="L431">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>