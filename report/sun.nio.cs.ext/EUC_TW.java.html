<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EUC_TW.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.nio.cs.ext</a> &gt; <span class="el_source">EUC_TW.java</span></div><h1>EUC_TW.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.cs.ext;

import java.io.*;
import java.nio.CharBuffer;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CoderResult;
import java.util.Arrays;
import sun.nio.cs.HistoricallyNamedCharset;
import static sun.nio.cs.CharsetMapping.*;

public class EUC_TW extends Charset implements HistoricallyNamedCharset
{
    private static final int SS2 = 0x8E;

    /*
       (1) EUC_TW
       Second byte of EUC_TW for cs2 is in range of
       0xA1-0xB0 for plane 1-16. According to CJKV /163,
       plane1 is coded in both cs1 and cs2. This impl
       however does not decode the codepoints of plane1
       in cs2, so only p2-p7 and p15 are supported in cs2.

       Plane2  0xA2;
       Plane3  0xA3;
       Plane4  0xA4;
       Plane5  0xA5;
       Plane6  0xA6;
       Plane7  0xA7;
       Plane15 0xAF;

       (2) Mapping
       The fact that all supplementary characters encoded in EUC_TW are
       in 0x2xxxx range gives us the room to optimize the data tables.

       Decoding:
       (1) save the lower 16-bit value of all codepoints of b-&gt;c mapping
           in a String array table  String[plane] b2c.
       (2) save &quot;codepoint is supplementary&quot; info (one bit) in a
           byte[] b2cIsSupp, so 8 codepoints (same codepoint value, different
           plane No) share one byte.

       Encoding:
       (1)c-&gt;b mappings are stored in
          char[]c2b/char[]c2bIndex
          char[]c2bSupp/char[]c2bIndexsupp  (indexed by lower 16-bit
       (2)byte[] c2bPlane stores the &quot;plane info&quot; of each euc-tw codepoints,
          BMP and Supp share the low/high 4 bits of one byte.

       Mapping tables are stored separated in EUC_TWMapping, which
       is generated by tool.
     */

    public EUC_TW() {
<span class="nc" id="L82">        super(&quot;x-EUC-TW&quot;, ExtendedCharsets.aliasesFor(&quot;x-EUC-TW&quot;));</span>
<span class="nc" id="L83">    }</span>

    public String historicalName() {
<span class="nc" id="L86">        return &quot;EUC_TW&quot;;</span>
    }

    public boolean contains(Charset cs) {
<span class="nc bnc" id="L90" title="All 4 branches missed.">        return ((cs.name().equals(&quot;US-ASCII&quot;))</span>
                || (cs instanceof EUC_TW));
    }

    public CharsetDecoder newDecoder() {
<span class="nc" id="L95">        return new Decoder(this);</span>
    }

    public CharsetEncoder newEncoder() {
<span class="nc" id="L99">        return new Encoder(this);</span>
    }

    public static class Decoder extends CharsetDecoder {
        public Decoder(Charset cs) {
<span class="nc" id="L104">            super(cs, 2.0f, 2.0f);</span>
<span class="nc" id="L105">        }</span>

<span class="nc" id="L107">        char[] c1 = new char[1];</span>
<span class="nc" id="L108">        char[] c2 = new char[2];</span>
        public char[] toUnicode(int b1, int b2, int p) {
<span class="nc" id="L110">            return decode(b1, b2, p, c1, c2);</span>
        }

<span class="nc" id="L113">        static final String[] b2c =  EUC_TWMapping.b2c;</span>
        static final int b1Min    =  EUC_TWMapping.b1Min;
        static final int b1Max    =  EUC_TWMapping.b1Max;
        static final int b2Min    =  EUC_TWMapping.b2Min;
        static final int b2Max    =  EUC_TWMapping.b2Max;
        static final int dbSegSize = b2Max - b2Min + 1;
        static final byte[] b2cIsSupp;

        // adjust from cns planeNo to the plane index of b2c
<span class="nc" id="L122">        static final byte[] cnspToIndex = new byte[0x100];</span>
        static {
<span class="nc" id="L124">            Arrays.fill(cnspToIndex, (byte)-1);</span>
<span class="nc" id="L125">            cnspToIndex[0xa2] = 1; cnspToIndex[0xa3] = 2; cnspToIndex[0xa4] = 3;</span>
<span class="nc" id="L126">            cnspToIndex[0xa5] = 4; cnspToIndex[0xa6] = 5; cnspToIndex[0xa7] = 6;</span>
<span class="nc" id="L127">            cnspToIndex[0xaf] = 7;</span>
        }

        //static final BitSet b2cIsSupp;
        static {
<span class="nc" id="L132">            String b2cIsSuppStr = EUC_TWMapping.b2cIsSuppStr;</span>
            // work on a local copy is much faster than operate
            // directly on b2cIsSupp
<span class="nc" id="L135">            byte[] flag = new byte[b2cIsSuppStr.length() &lt;&lt; 1];</span>
<span class="nc" id="L136">            int off = 0;</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">            for (int i = 0; i &lt; b2cIsSuppStr.length(); i++) {</span>
<span class="nc" id="L138">                char c = b2cIsSuppStr.charAt(i);</span>
<span class="nc" id="L139">                flag[off++] = (byte)(c &gt;&gt; 8);</span>
<span class="nc" id="L140">                flag[off++] = (byte)(c &amp; 0xff);</span>
            }
<span class="nc" id="L142">            b2cIsSupp = flag;</span>
<span class="nc" id="L143">        }</span>

        static boolean isLegalDB(int b) {
<span class="nc bnc" id="L146" title="All 4 branches missed.">           return b &gt;= b1Min &amp;&amp; b &lt;= b1Max;</span>
        }

        static char[] decode(int b1, int b2, int p, char[] c1, char[] c2)
        {
<span class="nc bnc" id="L151" title="All 8 branches missed.">            if (b1 &lt; b1Min || b1 &gt; b1Max || b2 &lt; b2Min || b2 &gt; b2Max)</span>
<span class="nc" id="L152">                return null;</span>
<span class="nc" id="L153">            int index = (b1 - b1Min) * dbSegSize + b2 - b2Min;</span>
<span class="nc" id="L154">            char c = b2c[p].charAt(index);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (c == UNMAPPABLE_DECODING)</span>
<span class="nc" id="L156">                return null;</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if ((b2cIsSupp[index] &amp; (1 &lt;&lt; p)) == 0) {</span>
<span class="nc" id="L158">                c1[0] = c;</span>
<span class="nc" id="L159">                return c1;</span>
            } else {
<span class="nc" id="L161">                c2[0] = Character.highSurrogate(0x20000 + c);</span>
<span class="nc" id="L162">                c2[1] = Character.lowSurrogate(0x20000 + c);</span>
<span class="nc" id="L163">                return c2;</span>
            }
        }

        private CoderResult decodeArrayLoop(ByteBuffer src,
                                            CharBuffer dst)
        {
<span class="nc" id="L170">            byte[] sa = src.array();</span>
<span class="nc" id="L171">            int sp = src.arrayOffset() + src.position();</span>
<span class="nc" id="L172">            int sl = src.arrayOffset() + src.limit();</span>

<span class="nc" id="L174">            char[] da = dst.array();</span>
<span class="nc" id="L175">            int dp = dst.arrayOffset() + dst.position();</span>
<span class="nc" id="L176">            int dl = dst.arrayOffset() + dst.limit();</span>
            try {
<span class="nc bnc" id="L178" title="All 2 branches missed.">                while (sp &lt; sl) {</span>
<span class="nc" id="L179">                    int byte1 = sa[sp] &amp; 0xff;</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                    if (byte1 == SS2) { // Codeset 2  G2</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                        if ( sl - sp &lt; 4)</span>
<span class="nc" id="L182">                            return CoderResult.UNDERFLOW;</span>
<span class="nc" id="L183">                        int cnsPlane = cnspToIndex[sa[sp + 1] &amp; 0xff];</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">                        if (cnsPlane &lt; 0)</span>
<span class="nc" id="L185">                            return CoderResult.malformedForLength(2);</span>
<span class="nc" id="L186">                        byte1 = sa[sp + 2] &amp; 0xff;</span>
<span class="nc" id="L187">                        int byte2 = sa[sp + 3] &amp; 0xff;</span>
<span class="nc" id="L188">                        char[] cc = toUnicode(byte1, byte2, cnsPlane);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                        if (cc == null) {</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">                            if (!isLegalDB(byte1) || !isLegalDB(byte2))</span>
<span class="nc" id="L191">                                return CoderResult.malformedForLength(4);</span>
<span class="nc" id="L192">                            return CoderResult.unmappableForLength(4);</span>
                        }
<span class="nc bnc" id="L194" title="All 2 branches missed.">                        if (dl - dp &lt; cc.length)</span>
<span class="nc" id="L195">                            return CoderResult.OVERFLOW;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                        if (cc.length == 1) {</span>
<span class="nc" id="L197">                            da[dp++] = cc[0];</span>
                        } else {
<span class="nc" id="L199">                            da[dp++] = cc[0];</span>
<span class="nc" id="L200">                            da[dp++] = cc[1];</span>
                        }
<span class="nc" id="L202">                        sp += 4;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                    } else if (byte1 &lt; 0x80) {  // ASCII      G0</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">                        if (dl - dp &lt; 1)</span>
<span class="nc" id="L205">                           return CoderResult.OVERFLOW;</span>
<span class="nc" id="L206">                        da[dp++] = (char) byte1;</span>
<span class="nc" id="L207">                        sp++;</span>
                    } else {                    // Codeset 1  G1
<span class="nc bnc" id="L209" title="All 2 branches missed.">                        if ( sl - sp &lt; 2)</span>
<span class="nc" id="L210">                            return CoderResult.UNDERFLOW;</span>
<span class="nc" id="L211">                        int byte2 = sa[sp + 1] &amp; 0xff;</span>
<span class="nc" id="L212">                        char[] cc = toUnicode(byte1, byte2, 0);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                        if (cc == null) {</span>
<span class="nc bnc" id="L214" title="All 4 branches missed.">                            if (!isLegalDB(byte1) || !isLegalDB(byte2))</span>
<span class="nc" id="L215">                                return CoderResult.malformedForLength(1);</span>
<span class="nc" id="L216">                            return CoderResult.unmappableForLength(2);</span>
                        }
<span class="nc bnc" id="L218" title="All 2 branches missed.">                        if (dl - dp &lt; 1)</span>
<span class="nc" id="L219">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L220">                        da[dp++] = cc[0];</span>
<span class="nc" id="L221">                        sp += 2;</span>
                    }
<span class="nc" id="L223">                }</span>
<span class="nc" id="L224">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L226">                src.position(sp - src.arrayOffset());</span>
<span class="nc" id="L227">                dst.position(dp - dst.arrayOffset());</span>
            }
        }

        private CoderResult decodeBufferLoop(ByteBuffer src,
                                             CharBuffer dst)
        {
<span class="nc" id="L234">            int mark = src.position();</span>
            try {
<span class="nc bnc" id="L236" title="All 2 branches missed.">                while (src.hasRemaining()) {</span>
<span class="nc" id="L237">                    int byte1 = src.get() &amp; 0xff;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                    if (byte1 == SS2) {            // Codeset 2  G2</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                        if ( src.remaining() &lt; 3)</span>
<span class="nc" id="L240">                            return CoderResult.UNDERFLOW;</span>
<span class="nc" id="L241">                        int cnsPlane = cnspToIndex[src.get() &amp; 0xff];</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                        if (cnsPlane &lt; 0)</span>
<span class="nc" id="L243">                            return CoderResult.malformedForLength(2);</span>
<span class="nc" id="L244">                        byte1 = src.get() &amp; 0xff;</span>
<span class="nc" id="L245">                        int byte2 = src.get() &amp; 0xff;</span>
<span class="nc" id="L246">                        char[] cc = toUnicode(byte1, byte2, cnsPlane);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">                        if (cc == null) {</span>
<span class="nc bnc" id="L248" title="All 4 branches missed.">                            if (!isLegalDB(byte1) || !isLegalDB(byte2))</span>
<span class="nc" id="L249">                                return CoderResult.malformedForLength(4);</span>
<span class="nc" id="L250">                            return CoderResult.unmappableForLength(4);</span>
                        }
<span class="nc bnc" id="L252" title="All 2 branches missed.">                        if (dst.remaining() &lt; cc.length)</span>
<span class="nc" id="L253">                            return CoderResult.OVERFLOW;</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                        if (cc.length == 1) {</span>
<span class="nc" id="L255">                            dst.put(cc[0]);</span>
                        } else {
<span class="nc" id="L257">                            dst.put(cc[0]);</span>
<span class="nc" id="L258">                            dst.put(cc[1]);</span>
                        }
<span class="nc" id="L260">                        mark += 4;</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">                    } else if (byte1 &lt; 0x80) {        // ASCII      G0</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                        if (!dst.hasRemaining())</span>
<span class="nc" id="L263">                           return CoderResult.OVERFLOW;</span>
<span class="nc" id="L264">                        dst.put((char) byte1);</span>
<span class="nc" id="L265">                        mark++;</span>
                    } else {                          // Codeset 1  G1
<span class="nc bnc" id="L267" title="All 2 branches missed.">                        if (!src.hasRemaining())</span>
<span class="nc" id="L268">                            return CoderResult.UNDERFLOW;</span>
<span class="nc" id="L269">                        int byte2 = src.get() &amp; 0xff;</span>
<span class="nc" id="L270">                        char[] cc = toUnicode(byte1, byte2, 0);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                        if (cc == null) {</span>
<span class="nc bnc" id="L272" title="All 4 branches missed.">                            if (!isLegalDB(byte1) || !isLegalDB(byte2))</span>
<span class="nc" id="L273">                                return CoderResult.malformedForLength(1);</span>
<span class="nc" id="L274">                            return CoderResult.unmappableForLength(2);</span>
                        }
<span class="nc bnc" id="L276" title="All 2 branches missed.">                        if (!dst.hasRemaining())</span>
<span class="nc" id="L277">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L278">                        dst.put(cc[0]);</span>
<span class="nc" id="L279">                        mark +=2;</span>
                    }
<span class="nc" id="L281">               }</span>
<span class="nc" id="L282">               return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L284">                src.position(mark);</span>
            }
        }

        protected CoderResult decodeLoop(ByteBuffer src, CharBuffer dst)
        {
<span class="nc bnc" id="L290" title="All 4 branches missed.">            if (src.hasArray() &amp;&amp; dst.hasArray())</span>
<span class="nc" id="L291">                return decodeArrayLoop(src, dst);</span>
            else
<span class="nc" id="L293">                return decodeBufferLoop(src, dst);</span>
        }
    }

    public static class Encoder extends CharsetEncoder {
<span class="nc" id="L298">        private byte[] bb = new byte[4];</span>

        public Encoder(Charset cs) {
<span class="nc" id="L301">            super(cs, 4.0f, 4.0f);</span>
<span class="nc" id="L302">        }</span>

        public boolean canEncode(char c) {
<span class="nc bnc" id="L305" title="All 4 branches missed.">            return (c &lt;= '\u007f' || toEUC(c, bb) != -1);</span>
        }

        public boolean canEncode(CharSequence cs) {
<span class="nc" id="L309">            int i = 0;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">            while (i &lt; cs.length()) {</span>
<span class="nc" id="L311">                char c = cs.charAt(i++);</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                if (Character.isHighSurrogate(c)) {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">                    if (i == cs.length())</span>
<span class="nc" id="L314">                        return false;</span>
<span class="nc" id="L315">                    char low = cs.charAt(i++);</span>
<span class="nc bnc" id="L316" title="All 4 branches missed.">                    if (!Character.isLowSurrogate(low) || toEUC(c, low, bb) == -1)</span>
<span class="nc" id="L317">                        return false;</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                } else if (!canEncode(c)) {</span>
<span class="nc" id="L319">                    return false;</span>
                }
<span class="nc" id="L321">            }</span>
<span class="nc" id="L322">            return true;</span>
        }

        public int toEUC(char hi, char low, byte[] bb) {
<span class="nc" id="L326">            return encode(hi, low, bb);</span>
        }

        public int toEUC(char c, byte[] bb) {
<span class="nc" id="L330">            return encode(c, bb);</span>
        }

        private CoderResult encodeArrayLoop(CharBuffer src,
                                            ByteBuffer dst)
        {
<span class="nc" id="L336">            char[] sa = src.array();</span>
<span class="nc" id="L337">            int sp = src.arrayOffset() + src.position();</span>
<span class="nc" id="L338">            int sl = src.arrayOffset() + src.limit();</span>

<span class="nc" id="L340">            byte[] da = dst.array();</span>
<span class="nc" id="L341">            int dp = dst.arrayOffset() + dst.position();</span>
<span class="nc" id="L342">            int dl = dst.arrayOffset() + dst.limit();</span>

            int inSize;
            int outSize;

            try {
<span class="nc bnc" id="L348" title="All 2 branches missed.">                while (sp &lt; sl) {</span>
<span class="nc" id="L349">                    char c = sa[sp];</span>
<span class="nc" id="L350">                    inSize = 1;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    if (c &lt; 0x80) {  // ASCII</span>
<span class="nc" id="L352">                        bb[0] = (byte)c;</span>
<span class="nc" id="L353">                        outSize = 1;</span>
                    } else {
<span class="nc" id="L355">                        outSize = toEUC(c, bb);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">                        if (outSize == -1) {</span>
                            // to check surrogates only after BMP failed
                            // has the benefit of improving the BMP encoding
                            // 10% faster, with the price of the slowdown of
                            // supplementary character encoding. given the use
                            // of supplementary characters is really rare, this
                            // is something worth doing.
<span class="nc bnc" id="L363" title="All 2 branches missed.">                            if (Character.isHighSurrogate(c)) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                                if ((sp + 1) == sl)</span>
<span class="nc" id="L365">                                    return CoderResult.UNDERFLOW;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                                if (!Character.isLowSurrogate(sa[sp + 1]))</span>
<span class="nc" id="L367">                                    return CoderResult.malformedForLength(1);</span>
<span class="nc" id="L368">                                outSize = toEUC(c, sa[sp+1], bb);</span>
<span class="nc" id="L369">                                    inSize = 2;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                            } else if (Character.isLowSurrogate(c)) {</span>
<span class="nc" id="L371">                                return CoderResult.malformedForLength(1);</span>
                            }
                        }
                    }
<span class="nc bnc" id="L375" title="All 2 branches missed.">                    if (outSize == -1)</span>
<span class="nc" id="L376">                        return CoderResult.unmappableForLength(inSize);</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">                    if ( dl - dp &lt; outSize)</span>
<span class="nc" id="L378">                        return CoderResult.OVERFLOW;</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">                    for (int i = 0; i &lt; outSize; i++)</span>
<span class="nc" id="L380">                        da[dp++] = bb[i];</span>
<span class="nc" id="L381">                    sp  += inSize;</span>
<span class="nc" id="L382">                }</span>
<span class="nc" id="L383">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L385">                src.position(sp - src.arrayOffset());</span>
<span class="nc" id="L386">                dst.position(dp - dst.arrayOffset());</span>
            }
        }

        private CoderResult encodeBufferLoop(CharBuffer src,
                                             ByteBuffer dst)
        {
            int outSize;
            int inSize;
<span class="nc" id="L395">            int mark = src.position();</span>

            try {
<span class="nc bnc" id="L398" title="All 2 branches missed.">                while (src.hasRemaining()) {</span>
<span class="nc" id="L399">                    inSize = 1;</span>
<span class="nc" id="L400">                    char c = src.get();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">                    if (c &lt; 0x80) {   // ASCII</span>
<span class="nc" id="L402">                        outSize = 1;</span>
<span class="nc" id="L403">                        bb[0] = (byte)c;</span>
                    } else {
<span class="nc" id="L405">                        outSize = toEUC(c, bb);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                        if (outSize == -1) {</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                            if (Character.isHighSurrogate(c)) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">                                if (!src.hasRemaining())</span>
<span class="nc" id="L409">                                    return CoderResult.UNDERFLOW;</span>
<span class="nc" id="L410">                                char c2 = src.get();</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                                if (!Character.isLowSurrogate(c2))</span>
<span class="nc" id="L412">                                    return CoderResult.malformedForLength(1);</span>
<span class="nc" id="L413">                                outSize = toEUC(c, c2, bb);</span>
<span class="nc" id="L414">                                inSize = 2;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                            } else if (Character.isLowSurrogate(c)) {</span>
<span class="nc" id="L416">                                return CoderResult.malformedForLength(1);</span>
                            }
                        }
                    }
<span class="nc bnc" id="L420" title="All 2 branches missed.">                    if (outSize == -1)</span>
<span class="nc" id="L421">                        return CoderResult.unmappableForLength(inSize);</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                    if (dst.remaining() &lt; outSize)</span>
<span class="nc" id="L423">                        return CoderResult.OVERFLOW;</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">                    for (int i = 0; i &lt; outSize; i++)</span>
<span class="nc" id="L425">                        dst.put(bb[i]);</span>
<span class="nc" id="L426">                    mark += inSize;</span>
<span class="nc" id="L427">                }</span>
<span class="nc" id="L428">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L430">                src.position(mark);</span>
            }
        }

        protected CoderResult encodeLoop(CharBuffer src, ByteBuffer dst)
        {
<span class="nc bnc" id="L436" title="All 4 branches missed.">            if (src.hasArray() &amp;&amp; dst.hasArray())</span>
<span class="nc" id="L437">                return encodeArrayLoop(src, dst);</span>
            else
<span class="nc" id="L439">                return encodeBufferLoop(src, dst);</span>
        }

        static int encode(char hi, char low, byte[] bb) {
<span class="nc" id="L443">            int c = Character.toCodePoint(hi, low);</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">            if ((c &amp; 0xf0000) != 0x20000)</span>
<span class="nc" id="L445">                return -1;</span>
<span class="nc" id="L446">            c -= 0x20000;</span>
<span class="nc" id="L447">            int index = c2bSuppIndex[c &gt;&gt; 8];</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (index  == UNMAPPABLE_ENCODING)</span>
<span class="nc" id="L449">                return -1;</span>
<span class="nc" id="L450">            index = index + (c &amp; 0xff);</span>
<span class="nc" id="L451">            int db = c2bSupp[index];</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (db == UNMAPPABLE_ENCODING)</span>
<span class="nc" id="L453">                return -1;</span>
<span class="nc" id="L454">            int p = (c2bPlane[index] &gt;&gt; 4) &amp; 0xf;</span>
<span class="nc" id="L455">            bb[0] = (byte)SS2;</span>
<span class="nc" id="L456">            bb[1] = (byte)(0xa0 | p);</span>
<span class="nc" id="L457">            bb[2] = (byte)(db &gt;&gt; 8);</span>
<span class="nc" id="L458">            bb[3] = (byte)db;</span>
<span class="nc" id="L459">            return 4;</span>
        }

        static int encode(char c, byte[] bb) {
<span class="nc" id="L463">            int index = c2bIndex[c &gt;&gt; 8];</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">            if (index  == UNMAPPABLE_ENCODING)</span>
<span class="nc" id="L465">                return -1;</span>
<span class="nc" id="L466">            index = index + (c &amp; 0xff);</span>
<span class="nc" id="L467">            int db = c2b[index];</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (db == UNMAPPABLE_ENCODING)</span>
<span class="nc" id="L469">                return -1;</span>
<span class="nc" id="L470">            int p = c2bPlane[index] &amp; 0xf;</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (p == 0) {</span>
<span class="nc" id="L472">                bb[0] = (byte)(db &gt;&gt; 8);</span>
<span class="nc" id="L473">                bb[1] = (byte)db;</span>
<span class="nc" id="L474">                return 2;</span>
            } else {
<span class="nc" id="L476">                bb[0] = (byte)SS2;</span>
<span class="nc" id="L477">                bb[1] = (byte)(0xa0 | p);</span>
<span class="nc" id="L478">                bb[2] = (byte)(db &gt;&gt; 8);</span>
<span class="nc" id="L479">                bb[3] = (byte)db;</span>
<span class="nc" id="L480">                return 4;</span>
            }
        }

        static final char[] c2b;
        static final char[] c2bIndex;
        static final char[] c2bSupp;
        static final char[] c2bSuppIndex;
        static final byte[] c2bPlane;
        static {
<span class="nc" id="L490">            int b1Min    =  Decoder.b1Min;</span>
<span class="nc" id="L491">            int b1Max    =  Decoder.b1Max;</span>
<span class="nc" id="L492">            int b2Min    =  Decoder.b2Min;</span>
<span class="nc" id="L493">            int b2Max    =  Decoder.b2Max;</span>
<span class="nc" id="L494">            int dbSegSize = Decoder.dbSegSize;</span>
<span class="nc" id="L495">            String[] b2c = Decoder.b2c;</span>
<span class="nc" id="L496">            byte[] b2cIsSupp = Decoder.b2cIsSupp;</span>

<span class="nc" id="L498">            c2bIndex = EUC_TWMapping.c2bIndex;</span>
<span class="nc" id="L499">            c2bSuppIndex = EUC_TWMapping.c2bSuppIndex;</span>
<span class="nc" id="L500">            char[] c2b0 = new char[EUC_TWMapping.C2BSIZE];</span>
<span class="nc" id="L501">            char[] c2bSupp0 = new char[EUC_TWMapping.C2BSUPPSIZE];</span>
<span class="nc" id="L502">            byte[] c2bPlane0 = new byte[Math.max(EUC_TWMapping.C2BSIZE,</span>
                                                 EUC_TWMapping.C2BSUPPSIZE)];

<span class="nc" id="L505">            Arrays.fill(c2b0, (char)UNMAPPABLE_ENCODING);</span>
<span class="nc" id="L506">            Arrays.fill(c2bSupp0, (char)UNMAPPABLE_ENCODING);</span>

<span class="nc bnc" id="L508" title="All 2 branches missed.">            for (int p = 0; p &lt; b2c.length; p++) {</span>
<span class="nc" id="L509">                String db = b2c[p];</span>
                /*
                   adjust the &quot;plane&quot; from 0..7 to 0, 2, 3, 4, 5, 6, 7, 0xf,
                   which helps balance between footprint (to save the plane
                   info in 4 bits) and runtime performance (to require only
                   one operation &quot;0xa0 | plane&quot; to encode the plane byte)
                */
<span class="nc" id="L516">                int plane = p;</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                if (plane == 7)</span>
<span class="nc" id="L518">                    plane = 0xf;</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">                else if (plane != 0)</span>
<span class="nc" id="L520">                    plane = p + 1;</span>

<span class="nc" id="L522">                int off = 0;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">                for (int b1 = b1Min; b1 &lt;= b1Max; b1++) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">                    for (int b2 = b2Min; b2 &lt;= b2Max; b2++) {</span>
<span class="nc" id="L525">                        char c = db.charAt(off);</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">                        if (c != UNMAPPABLE_DECODING) {</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">                            if ((b2cIsSupp[off] &amp; (1 &lt;&lt; p)) != 0) {</span>
<span class="nc" id="L528">                                int index = c2bSuppIndex[c &gt;&gt; 8] + (c&amp;0xff);</span>
<span class="nc" id="L529">                                c2bSupp0[index] = (char)((b1 &lt;&lt; 8) + b2);</span>
<span class="nc" id="L530">                                c2bPlane0[index] |= (byte)(plane &lt;&lt; 4);</span>
<span class="nc" id="L531">                            } else {</span>
<span class="nc" id="L532">                                int index = c2bIndex[c &gt;&gt; 8] + (c&amp;0xff);</span>
<span class="nc" id="L533">                                c2b0[index] = (char)((b1 &lt;&lt; 8) + b2);</span>
<span class="nc" id="L534">                                c2bPlane0[index] |= (byte)plane;</span>
                            }
                        }
<span class="nc" id="L537">                        off++;</span>
                    }
                }
            }
<span class="nc" id="L541">            c2b = c2b0;</span>
<span class="nc" id="L542">            c2bSupp = c2bSupp0;</span>
<span class="nc" id="L543">            c2bPlane = c2bPlane0;</span>
<span class="nc" id="L544">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>