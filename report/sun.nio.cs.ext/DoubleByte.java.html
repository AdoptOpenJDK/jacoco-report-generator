<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DoubleByte.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.nio.cs.ext</a> &gt; <span class="el_source">DoubleByte.java</span></div><h1>DoubleByte.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.cs.ext;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CoderResult;
import java.util.Arrays;
import sun.nio.cs.Surrogate;
import sun.nio.cs.ArrayDecoder;
import sun.nio.cs.ArrayEncoder;
import static sun.nio.cs.CharsetMapping.*;

/*
 * Four types of &quot;DoubleByte&quot; charsets are implemented in this class
 * (1)DoubleByte
 *    The &quot;mostly widely used&quot; multibyte charset, a combination of
 *    a singlebyte character set (usually the ASCII charset) and a
 *    doublebyte character set. The codepoint values of singlebyte
 *    and doublebyte don't overlap. Microsoft's multibyte charsets
 *    and IBM's &quot;DBCS_ASCII&quot; charsets, such as IBM1381, 942, 943,
 *    948, 949 and 950 are such charsets.
 *
 * (2)DoubleByte_EBCDIC
 *    IBM EBCDIC Mix multibyte charset. Use SO and SI to shift (switch)
 *    in and out between the singlebyte character set and doublebyte
 *    character set.
 *
 * (3)DoubleByte_SIMPLE_EUC
 *    It's a &quot;simple&quot; form of EUC encoding scheme, only have the
 *    singlebyte character set G0 and one doublebyte character set
 *    G1 are defined, G2 (with SS2) and G3 (with SS3) are not used.
 *    So it is actually the same as the &quot;typical&quot; type (1) mentioned
 *    above, except it return &quot;malformed&quot; for the SS2 and SS3 when
 *    decoding.
 *
 * (4)DoubleByte ONLY
 *    A &quot;pure&quot; doublebyte only character set. From implementation
 *    point of view, this is the type (1) with &quot;decodeSingle&quot; always
 *    returns unmappable.
 *
 * For simplicity, all implementations share the same decoding and
 * encoding data structure.
 *
 * Decoding:
 *
 *    char[][] b2c;
 *    char[] b2cSB;
 *    int b2Min, b2Max
 *
 *    public char decodeSingle(int b) {
 *        return b2cSB.[b];
 *    }
 *
 *    public char decodeDouble(int b1, int b2) {
 *        if (b2 &lt; b2Min || b2 &gt; b2Max)
 *            return UNMAPPABLE_DECODING;
 *         return b2c[b1][b2 - b2Min];
 *    }
 *
 *    (1)b2Min, b2Max are the corresponding min and max value of the
 *       low-half of the double-byte.
 *    (2)The high 8-bit/b1 of the double-byte are used to indexed into
 *       b2c array.
 *
 * Encoding:
 *
 *    char[] c2b;
 *    char[] c2bIndex;
 *
 *    public int encodeChar(char ch) {
 *        return c2b[c2bIndex[ch &gt;&gt; 8] + (ch &amp; 0xff)];
 *    }
 *
 */

<span class="nc" id="L103">public class DoubleByte {</span>

    public final static char[] B2C_UNMAPPABLE;
    static {
<span class="nc" id="L107">        B2C_UNMAPPABLE = new char[0x100];</span>
<span class="nc" id="L108">        Arrays.fill(B2C_UNMAPPABLE, UNMAPPABLE_DECODING);</span>
<span class="nc" id="L109">    }</span>

    public static class Decoder extends CharsetDecoder
                                implements DelegatableDecoder, ArrayDecoder
    {
        final char[][] b2c;
        final char[] b2cSB;
        final int b2Min;
        final int b2Max;

        // for SimpleEUC override
        protected CoderResult crMalformedOrUnderFlow(int b) {
<span class="nc" id="L121">            return CoderResult.UNDERFLOW;</span>
        }

        protected CoderResult crMalformedOrUnmappable(int b1, int b2) {
<span class="nc bnc" id="L125" title="All 4 branches missed.">            if (b2c[b1] == B2C_UNMAPPABLE ||                // isNotLeadingByte(b1)</span>
                b2c[b2] != B2C_UNMAPPABLE ||                // isLeadingByte(b2)
<span class="nc bnc" id="L127" title="All 2 branches missed.">                decodeSingle(b2) != UNMAPPABLE_DECODING) {  // isSingle(b2)</span>
<span class="nc" id="L128">                return CoderResult.malformedForLength(1);</span>
            }
<span class="nc" id="L130">            return CoderResult.unmappableForLength(2);</span>
        }

        Decoder(Charset cs, float avgcpb, float maxcpb,
                char[][] b2c, char[] b2cSB,
                int b2Min, int b2Max) {
<span class="nc" id="L136">            super(cs, avgcpb, maxcpb);</span>
<span class="nc" id="L137">            this.b2c = b2c;</span>
<span class="nc" id="L138">            this.b2cSB = b2cSB;</span>
<span class="nc" id="L139">            this.b2Min = b2Min;</span>
<span class="nc" id="L140">            this.b2Max = b2Max;</span>
<span class="nc" id="L141">        }</span>

        Decoder(Charset cs, char[][] b2c, char[] b2cSB, int b2Min, int b2Max) {
<span class="nc" id="L144">            this(cs, 0.5f, 1.0f, b2c, b2cSB, b2Min, b2Max);</span>
<span class="nc" id="L145">        }</span>

        protected CoderResult decodeArrayLoop(ByteBuffer src, CharBuffer dst) {
<span class="nc" id="L148">            byte[] sa = src.array();</span>
<span class="nc" id="L149">            int sp = src.arrayOffset() + src.position();</span>
<span class="nc" id="L150">            int sl = src.arrayOffset() + src.limit();</span>

<span class="nc" id="L152">            char[] da = dst.array();</span>
<span class="nc" id="L153">            int dp = dst.arrayOffset() + dst.position();</span>
<span class="nc" id="L154">            int dl = dst.arrayOffset() + dst.limit();</span>

            try {
<span class="nc bnc" id="L157" title="All 4 branches missed.">                while (sp &lt; sl &amp;&amp; dp &lt; dl) {</span>
                    // inline the decodeSingle/Double() for better performance
<span class="nc" id="L159">                    int inSize = 1;</span>
<span class="nc" id="L160">                    int b1 = sa[sp] &amp; 0xff;</span>
<span class="nc" id="L161">                    char c = b2cSB[b1];</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                    if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">                        if (sl - sp &lt; 2)</span>
<span class="nc" id="L164">                            return crMalformedOrUnderFlow(b1);</span>
<span class="nc" id="L165">                        int b2 = sa[sp + 1] &amp; 0xff;</span>
<span class="nc bnc" id="L166" title="All 6 branches missed.">                        if (b2 &lt; b2Min || b2 &gt; b2Max ||</span>
                            (c = b2c[b1][b2 - b2Min]) == UNMAPPABLE_DECODING) {
<span class="nc" id="L168">                            return crMalformedOrUnmappable(b1, b2);</span>
                        }
<span class="nc" id="L170">                        inSize++;</span>
                    }
<span class="nc" id="L172">                    da[dp++] = c;</span>
<span class="nc" id="L173">                    sp += inSize;</span>
<span class="nc" id="L174">                }</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                return (sp &gt;= sl) ? CoderResult.UNDERFLOW</span>
                                  : CoderResult.OVERFLOW;
            } finally {
<span class="nc" id="L178">                src.position(sp - src.arrayOffset());</span>
<span class="nc" id="L179">                dst.position(dp - dst.arrayOffset());</span>
            }
        }

        protected CoderResult decodeBufferLoop(ByteBuffer src, CharBuffer dst) {
<span class="nc" id="L184">            int mark = src.position();</span>
            try {

<span class="nc bnc" id="L187" title="All 4 branches missed.">                while (src.hasRemaining() &amp;&amp; dst.hasRemaining()) {</span>
<span class="nc" id="L188">                    int b1 = src.get() &amp; 0xff;</span>
<span class="nc" id="L189">                    char c = b2cSB[b1];</span>
<span class="nc" id="L190">                    int inSize = 1;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                    if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                        if (src.remaining() &lt; 1)</span>
<span class="nc" id="L193">                            return crMalformedOrUnderFlow(b1);</span>
<span class="nc" id="L194">                        int b2 = src.get() &amp; 0xff;</span>
<span class="nc bnc" id="L195" title="All 6 branches missed.">                        if (b2 &lt; b2Min || b2 &gt; b2Max ||</span>
                            (c = b2c[b1][b2 - b2Min]) == UNMAPPABLE_DECODING)
<span class="nc" id="L197">                            return crMalformedOrUnmappable(b1, b2);</span>
<span class="nc" id="L198">                        inSize++;</span>
                    }
<span class="nc" id="L200">                    dst.put(c);</span>
<span class="nc" id="L201">                    mark += inSize;</span>
<span class="nc" id="L202">                }</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                return src.hasRemaining()? CoderResult.OVERFLOW</span>
                                         : CoderResult.UNDERFLOW;
            } finally {
<span class="nc" id="L206">                src.position(mark);</span>
            }
        }

        // Make some protected methods public for use by JISAutoDetect
        public CoderResult decodeLoop(ByteBuffer src, CharBuffer dst) {
<span class="nc bnc" id="L212" title="All 4 branches missed.">            if (src.hasArray() &amp;&amp; dst.hasArray())</span>
<span class="nc" id="L213">                return decodeArrayLoop(src, dst);</span>
            else
<span class="nc" id="L215">                return decodeBufferLoop(src, dst);</span>
        }

        public int decode(byte[] src, int sp, int len, char[] dst) {
<span class="nc" id="L219">            int dp = 0;</span>
<span class="nc" id="L220">            int sl = sp + len;</span>
<span class="nc" id="L221">            char repl = replacement().charAt(0);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">            while (sp &lt; sl) {</span>
<span class="nc" id="L223">                int b1 = src[sp++] &amp; 0xff;</span>
<span class="nc" id="L224">                char c = b2cSB[b1];</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">                if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">                    if (sp &lt; sl) {</span>
<span class="nc" id="L227">                        int b2 = src[sp++] &amp; 0xff;</span>
<span class="nc bnc" id="L228" title="All 6 branches missed.">                        if (b2 &lt; b2Min || b2 &gt; b2Max ||</span>
                            (c = b2c[b1][b2 - b2Min]) == UNMAPPABLE_DECODING) {
<span class="nc bnc" id="L230" title="All 4 branches missed.">                            if (b2c[b1] == B2C_UNMAPPABLE ||  // isNotLeadingByte</span>
                                b2c[b2] != B2C_UNMAPPABLE ||  // isLeadingByte
<span class="nc bnc" id="L232" title="All 2 branches missed.">                                decodeSingle(b2) != UNMAPPABLE_DECODING) {</span>
<span class="nc" id="L233">                                sp--;</span>
                            }
                        }
                    }
<span class="nc bnc" id="L237" title="All 2 branches missed.">                    if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc" id="L238">                        c = repl;</span>
                    }
                }
<span class="nc" id="L241">                dst[dp++] = c;</span>
<span class="nc" id="L242">            }</span>
<span class="nc" id="L243">            return dp;</span>
        }

        public void implReset() {
<span class="nc" id="L247">            super.implReset();</span>
<span class="nc" id="L248">        }</span>

        public CoderResult implFlush(CharBuffer out) {
<span class="nc" id="L251">            return super.implFlush(out);</span>
        }

        // decode loops are not using decodeSingle/Double() for performance
        // reason.
        public char decodeSingle(int b) {
<span class="nc" id="L257">            return b2cSB[b];</span>
        }

        public char decodeDouble(int b1, int b2) {
<span class="nc bnc" id="L261" title="All 8 branches missed.">            if (b1 &lt; 0 || b1 &gt; b2c.length ||</span>
                b2 &lt; b2Min || b2 &gt; b2Max)
<span class="nc" id="L263">                return UNMAPPABLE_DECODING;</span>
<span class="nc" id="L264">            return  b2c[b1][b2 - b2Min];</span>
        }
    }

    // IBM_EBCDIC_DBCS
    public static class Decoder_EBCDIC extends Decoder {
        private static final int SBCS = 0;
        private static final int DBCS = 1;
        private static final int SO = 0x0e;
        private static final int SI = 0x0f;
        private int  currentState;

        Decoder_EBCDIC(Charset cs,
                       char[][] b2c, char[] b2cSB, int b2Min, int b2Max) {
<span class="nc" id="L278">            super(cs, b2c, b2cSB, b2Min, b2Max);</span>
<span class="nc" id="L279">        }</span>

        public void implReset() {
<span class="nc" id="L282">            currentState = SBCS;</span>
<span class="nc" id="L283">        }</span>

        // Check validity of dbcs ebcdic byte pair values
        //
        // First byte : 0x41 -- 0xFE
        // Second byte: 0x41 -- 0xFE
        // Doublebyte blank: 0x4040
        //
        // The validation implementation in &quot;old&quot; DBCS_IBM_EBCDIC and sun.io
        // as
        //            if ((b1 != 0x40 || b2 != 0x40) &amp;&amp;
        //                (b2 &lt; 0x41 || b2 &gt; 0xfe)) {...}
        // is not correct/complete (range check for b1)
        //
        private static boolean isDoubleByte(int b1, int b2) {
<span class="nc bnc" id="L298" title="All 12 branches missed.">            return (0x41 &lt;= b1 &amp;&amp; b1 &lt;= 0xfe &amp;&amp; 0x41 &lt;= b2 &amp;&amp; b2 &lt;= 0xfe)</span>
                   || (b1 == 0x40 &amp;&amp; b2 == 0x40); // DBCS-HOST SPACE
        }

        protected CoderResult decodeArrayLoop(ByteBuffer src, CharBuffer dst) {
<span class="nc" id="L303">            byte[] sa = src.array();</span>
<span class="nc" id="L304">            int sp = src.arrayOffset() + src.position();</span>
<span class="nc" id="L305">            int sl = src.arrayOffset() + src.limit();</span>
<span class="nc" id="L306">            char[] da = dst.array();</span>
<span class="nc" id="L307">            int dp = dst.arrayOffset() + dst.position();</span>
<span class="nc" id="L308">            int dl = dst.arrayOffset() + dst.limit();</span>

            try {
                // don't check dp/dl together here, it's possible to
                // decdoe a SO/SI without space in output buffer.
<span class="nc bnc" id="L313" title="All 2 branches missed.">                while (sp &lt; sl) {</span>
<span class="nc" id="L314">                    int b1 = sa[sp] &amp; 0xff;</span>
<span class="nc" id="L315">                    int inSize = 1;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                    if (b1 == SO) {  // Shift out</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                        if (currentState != SBCS)</span>
<span class="nc" id="L318">                            return CoderResult.malformedForLength(1);</span>
                        else
<span class="nc" id="L320">                            currentState = DBCS;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">                    } else if (b1 == SI) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">                        if (currentState != DBCS)</span>
<span class="nc" id="L323">                            return CoderResult.malformedForLength(1);</span>
                        else
<span class="nc" id="L325">                            currentState = SBCS;</span>
                    } else {
<span class="nc" id="L327">                        char c =  UNMAPPABLE_DECODING;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">                        if (currentState == SBCS) {</span>
<span class="nc" id="L329">                            c = b2cSB[b1];</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">                            if (c == UNMAPPABLE_DECODING)</span>
<span class="nc" id="L331">                                return CoderResult.unmappableForLength(1);</span>
                        } else {
<span class="nc bnc" id="L333" title="All 2 branches missed.">                            if (sl - sp &lt; 2)</span>
<span class="nc" id="L334">                                return CoderResult.UNDERFLOW;</span>
<span class="nc" id="L335">                            int b2 = sa[sp + 1] &amp; 0xff;</span>
<span class="nc bnc" id="L336" title="All 6 branches missed.">                            if (b2 &lt; b2Min || b2 &gt; b2Max ||</span>
                                (c = b2c[b1][b2 - b2Min]) == UNMAPPABLE_DECODING) {
<span class="nc bnc" id="L338" title="All 2 branches missed.">                                if (!isDoubleByte(b1, b2))</span>
<span class="nc" id="L339">                                    return CoderResult.malformedForLength(2);</span>
<span class="nc" id="L340">                                return CoderResult.unmappableForLength(2);</span>
                            }
<span class="nc" id="L342">                            inSize++;</span>
                        }
<span class="nc bnc" id="L344" title="All 2 branches missed.">                        if (dl - dp &lt; 1)</span>
<span class="nc" id="L345">                            return CoderResult.OVERFLOW;</span>

<span class="nc" id="L347">                        da[dp++] = c;</span>
                    }
<span class="nc" id="L349">                    sp += inSize;</span>
<span class="nc" id="L350">                }</span>
<span class="nc" id="L351">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L353">                src.position(sp - src.arrayOffset());</span>
<span class="nc" id="L354">                dst.position(dp - dst.arrayOffset());</span>
            }
        }

        protected CoderResult decodeBufferLoop(ByteBuffer src, CharBuffer dst) {
<span class="nc" id="L359">            int mark = src.position();</span>
            try {
<span class="nc bnc" id="L361" title="All 2 branches missed.">                while (src.hasRemaining()) {</span>
<span class="nc" id="L362">                    int b1 = src.get() &amp; 0xff;</span>
<span class="nc" id="L363">                    int inSize = 1;</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                    if (b1 == SO) {  // Shift out</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                        if (currentState != SBCS)</span>
<span class="nc" id="L366">                            return CoderResult.malformedForLength(1);</span>
                        else
<span class="nc" id="L368">                            currentState = DBCS;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                    } else if (b1 == SI) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                        if (currentState != DBCS)</span>
<span class="nc" id="L371">                            return CoderResult.malformedForLength(1);</span>
                        else
<span class="nc" id="L373">                            currentState = SBCS;</span>
                    } else {
<span class="nc" id="L375">                        char c = UNMAPPABLE_DECODING;</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                        if (currentState == SBCS) {</span>
<span class="nc" id="L377">                            c = b2cSB[b1];</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                            if (c == UNMAPPABLE_DECODING)</span>
<span class="nc" id="L379">                                return CoderResult.unmappableForLength(1);</span>
                        } else {
<span class="nc bnc" id="L381" title="All 2 branches missed.">                            if (src.remaining() &lt; 1)</span>
<span class="nc" id="L382">                                return CoderResult.UNDERFLOW;</span>
<span class="nc" id="L383">                            int b2 = src.get()&amp;0xff;</span>
<span class="nc bnc" id="L384" title="All 6 branches missed.">                            if (b2 &lt; b2Min || b2 &gt; b2Max ||</span>
                                (c = b2c[b1][b2 - b2Min]) == UNMAPPABLE_DECODING) {
<span class="nc bnc" id="L386" title="All 2 branches missed.">                                if (!isDoubleByte(b1, b2))</span>
<span class="nc" id="L387">                                    return CoderResult.malformedForLength(2);</span>
<span class="nc" id="L388">                                return CoderResult.unmappableForLength(2);</span>
                            }
<span class="nc" id="L390">                            inSize++;</span>
                        }

<span class="nc bnc" id="L393" title="All 2 branches missed.">                        if (dst.remaining() &lt; 1)</span>
<span class="nc" id="L394">                            return CoderResult.OVERFLOW;</span>

<span class="nc" id="L396">                        dst.put(c);</span>
                    }
<span class="nc" id="L398">                    mark += inSize;</span>
<span class="nc" id="L399">                }</span>
<span class="nc" id="L400">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L402">                src.position(mark);</span>
            }
        }

        public int decode(byte[] src, int sp, int len, char[] dst) {
<span class="nc" id="L407">            int dp = 0;</span>
<span class="nc" id="L408">            int sl = sp + len;</span>
<span class="nc" id="L409">            currentState = SBCS;</span>
<span class="nc" id="L410">            char repl = replacement().charAt(0);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            while (sp &lt; sl) {</span>
<span class="nc" id="L412">                int b1 = src[sp++] &amp; 0xff;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                if (b1 == SO) {  // Shift out</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">                    if (currentState != SBCS)</span>
<span class="nc" id="L415">                        dst[dp++] = repl;</span>
                    else
<span class="nc" id="L417">                        currentState = DBCS;</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                } else if (b1 == SI) {</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                    if (currentState != DBCS)</span>
<span class="nc" id="L420">                        dst[dp++] = repl;</span>
                    else
<span class="nc" id="L422">                        currentState = SBCS;</span>
                } else {
<span class="nc" id="L424">                    char c =  UNMAPPABLE_DECODING;</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">                    if (currentState == SBCS) {</span>
<span class="nc" id="L426">                        c = b2cSB[b1];</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">                        if (c == UNMAPPABLE_DECODING)</span>
<span class="nc" id="L428">                            c = repl;</span>
                    } else {
<span class="nc bnc" id="L430" title="All 2 branches missed.">                        if (sl == sp) {</span>
<span class="nc" id="L431">                            c = repl;</span>
                        } else {
<span class="nc" id="L433">                            int b2 = src[sp++] &amp; 0xff;</span>
<span class="nc bnc" id="L434" title="All 6 branches missed.">                            if (b2 &lt; b2Min || b2 &gt; b2Max ||</span>
                                (c = b2c[b1][b2 - b2Min]) == UNMAPPABLE_DECODING) {
<span class="nc" id="L436">                                c = repl;</span>
                            }
                        }
                    }
<span class="nc" id="L440">                    dst[dp++] = c;</span>
                }
<span class="nc" id="L442">            }</span>
<span class="nc" id="L443">            return dp;</span>
        }
    }

    // DBCS_ONLY
    public static class Decoder_DBCSONLY extends Decoder {
        static final char[] b2cSB_UNMAPPABLE;
        static {
<span class="nc" id="L451">            b2cSB_UNMAPPABLE = new char[0x100];</span>
<span class="nc" id="L452">            Arrays.fill(b2cSB_UNMAPPABLE, UNMAPPABLE_DECODING);</span>
<span class="nc" id="L453">        }</span>
        Decoder_DBCSONLY(Charset cs, char[][] b2c, char[] b2cSB, int b2Min, int b2Max) {
<span class="nc" id="L455">            super(cs, 0.5f, 1.0f, b2c, b2cSB_UNMAPPABLE, b2Min, b2Max);</span>
<span class="nc" id="L456">        }</span>
    }

    // EUC_SIMPLE
    // The only thing we need to &quot;override&quot; is to check SS2/SS3 and
    // return &quot;malformed&quot; if found
    public static class Decoder_EUC_SIM extends Decoder {
<span class="nc" id="L463">        private final int SS2 =  0x8E;</span>
<span class="nc" id="L464">        private final int SS3 =  0x8F;</span>

        Decoder_EUC_SIM(Charset cs,
                        char[][] b2c, char[] b2cSB, int b2Min, int b2Max) {
<span class="nc" id="L468">            super(cs, b2c, b2cSB, b2Min, b2Max);</span>
<span class="nc" id="L469">        }</span>

        // No support provided for G2/G3 for SimpleEUC
        protected CoderResult crMalformedOrUnderFlow(int b) {
<span class="nc bnc" id="L473" title="All 4 branches missed.">            if (b == SS2 || b == SS3 )</span>
<span class="nc" id="L474">                return CoderResult.malformedForLength(1);</span>
<span class="nc" id="L475">            return CoderResult.UNDERFLOW;</span>
        }

        protected CoderResult crMalformedOrUnmappable(int b1, int b2) {
<span class="nc bnc" id="L479" title="All 4 branches missed.">            if (b1 == SS2 || b1 == SS3 )</span>
<span class="nc" id="L480">                return CoderResult.malformedForLength(1);</span>
<span class="nc" id="L481">            return CoderResult.unmappableForLength(2);</span>
        }

        public int decode(byte[] src, int sp, int len, char[] dst) {
<span class="nc" id="L485">            int dp = 0;</span>
<span class="nc" id="L486">            int sl = sp + len;</span>
<span class="nc" id="L487">            char repl = replacement().charAt(0);</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">            while (sp &lt; sl) {</span>
<span class="nc" id="L489">                int b1 = src[sp++] &amp; 0xff;</span>
<span class="nc" id="L490">                char c = b2cSB[b1];</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">                if (c == UNMAPPABLE_DECODING) {</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                    if (sp &lt; sl) {</span>
<span class="nc" id="L493">                        int b2 = src[sp++] &amp; 0xff;</span>
<span class="nc bnc" id="L494" title="All 6 branches missed.">                        if (b2 &lt; b2Min || b2 &gt; b2Max ||</span>
                            (c = b2c[b1][b2 - b2Min]) == UNMAPPABLE_DECODING) {
<span class="nc bnc" id="L496" title="All 4 branches missed.">                            if (b1 == SS2 || b1 == SS3) {</span>
<span class="nc" id="L497">                                sp--;</span>
                            }
<span class="nc" id="L499">                            c = repl;</span>
                        }
<span class="nc" id="L501">                    } else {</span>
<span class="nc" id="L502">                        c = repl;</span>
                    }
                }
<span class="nc" id="L505">                dst[dp++] = c;</span>
<span class="nc" id="L506">            }</span>
<span class="nc" id="L507">            return dp;</span>
        }
    }

    public static class Encoder extends CharsetEncoder
                                implements ArrayEncoder
    {
<span class="nc" id="L514">        final int MAX_SINGLEBYTE = 0xff;</span>
        private final char[] c2b;
        private final char[] c2bIndex;
        Surrogate.Parser sgp;

        protected Encoder(Charset cs, char[] c2b, char[] c2bIndex) {
<span class="nc" id="L520">            super(cs, 2.0f, 2.0f);</span>
<span class="nc" id="L521">            this.c2b = c2b;</span>
<span class="nc" id="L522">            this.c2bIndex = c2bIndex;</span>
<span class="nc" id="L523">        }</span>

        Encoder(Charset cs, float avg, float max, byte[] repl, char[] c2b, char[] c2bIndex) {
<span class="nc" id="L526">            super(cs, avg, max, repl);</span>
<span class="nc" id="L527">            this.c2b = c2b;</span>
<span class="nc" id="L528">            this.c2bIndex = c2bIndex;</span>
<span class="nc" id="L529">        }</span>

        public boolean canEncode(char c) {
<span class="nc bnc" id="L532" title="All 2 branches missed.">            return encodeChar(c) != UNMAPPABLE_ENCODING;</span>
        }

        Surrogate.Parser sgp() {
<span class="nc bnc" id="L536" title="All 2 branches missed.">            if (sgp == null)</span>
<span class="nc" id="L537">                sgp = new Surrogate.Parser();</span>
<span class="nc" id="L538">            return sgp;</span>
        }

        protected CoderResult encodeArrayLoop(CharBuffer src, ByteBuffer dst) {
<span class="nc" id="L542">            char[] sa = src.array();</span>
<span class="nc" id="L543">            int sp = src.arrayOffset() + src.position();</span>
<span class="nc" id="L544">            int sl = src.arrayOffset() + src.limit();</span>

<span class="nc" id="L546">            byte[] da = dst.array();</span>
<span class="nc" id="L547">            int dp = dst.arrayOffset() + dst.position();</span>
<span class="nc" id="L548">            int dl = dst.arrayOffset() + dst.limit();</span>

            try {
<span class="nc bnc" id="L551" title="All 2 branches missed.">                while (sp &lt; sl) {</span>
<span class="nc" id="L552">                    char c = sa[sp];</span>
<span class="nc" id="L553">                    int bb = encodeChar(c);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                    if (bb == UNMAPPABLE_ENCODING) {</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">                        if (Character.isSurrogate(c)) {</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                            if (sgp().parse(c, sa, sp, sl) &lt; 0)</span>
<span class="nc" id="L557">                                return sgp.error();</span>
<span class="nc" id="L558">                            return sgp.unmappableResult();</span>
                        }
<span class="nc" id="L560">                        return CoderResult.unmappableForLength(1);</span>
                    }

<span class="nc bnc" id="L563" title="All 2 branches missed.">                    if (bb &gt; MAX_SINGLEBYTE) {    // DoubleByte</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                        if (dl - dp &lt; 2)</span>
<span class="nc" id="L565">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L566">                        da[dp++] = (byte)(bb &gt;&gt; 8);</span>
<span class="nc" id="L567">                        da[dp++] = (byte)bb;</span>
                    } else {                      // SingleByte
<span class="nc bnc" id="L569" title="All 2 branches missed.">                        if (dl - dp &lt; 1)</span>
<span class="nc" id="L570">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L571">                        da[dp++] = (byte)bb;</span>
                    }

<span class="nc" id="L574">                    sp++;</span>
<span class="nc" id="L575">                }</span>
<span class="nc" id="L576">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L578">                src.position(sp - src.arrayOffset());</span>
<span class="nc" id="L579">                dst.position(dp - dst.arrayOffset());</span>
            }
        }

        protected CoderResult encodeBufferLoop(CharBuffer src, ByteBuffer dst) {
<span class="nc" id="L584">            int mark = src.position();</span>
            try {
<span class="nc bnc" id="L586" title="All 2 branches missed.">                while (src.hasRemaining()) {</span>
<span class="nc" id="L587">                    char c = src.get();</span>
<span class="nc" id="L588">                    int bb = encodeChar(c);</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                    if (bb == UNMAPPABLE_ENCODING) {</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">                        if (Character.isSurrogate(c)) {</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">                            if (sgp().parse(c, src) &lt; 0)</span>
<span class="nc" id="L592">                                return sgp.error();</span>
<span class="nc" id="L593">                            return sgp.unmappableResult();</span>
                        }
<span class="nc" id="L595">                        return CoderResult.unmappableForLength(1);</span>
                    }
<span class="nc bnc" id="L597" title="All 2 branches missed.">                    if (bb &gt; MAX_SINGLEBYTE) {  // DoubleByte</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">                        if (dst.remaining() &lt; 2)</span>
<span class="nc" id="L599">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L600">                        dst.put((byte)(bb &gt;&gt; 8));</span>
<span class="nc" id="L601">                        dst.put((byte)(bb));</span>
                    } else {
<span class="nc bnc" id="L603" title="All 2 branches missed.">                        if (dst.remaining() &lt; 1)</span>
<span class="nc" id="L604">                        return CoderResult.OVERFLOW;</span>
<span class="nc" id="L605">                        dst.put((byte)bb);</span>
                    }
<span class="nc" id="L607">                    mark++;</span>
<span class="nc" id="L608">                }</span>
<span class="nc" id="L609">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L611">                src.position(mark);</span>
            }
        }

        protected CoderResult encodeLoop(CharBuffer src, ByteBuffer dst) {
<span class="nc bnc" id="L616" title="All 4 branches missed.">            if (src.hasArray() &amp;&amp; dst.hasArray())</span>
<span class="nc" id="L617">                return encodeArrayLoop(src, dst);</span>
            else
<span class="nc" id="L619">                return encodeBufferLoop(src, dst);</span>
        }

<span class="nc" id="L622">        protected byte[] repl = replacement();</span>
        protected void implReplaceWith(byte[] newReplacement) {
<span class="nc" id="L624">            repl = newReplacement;</span>
<span class="nc" id="L625">        }</span>

        public int encode(char[] src, int sp, int len, byte[] dst) {
<span class="nc" id="L628">            int dp = 0;</span>
<span class="nc" id="L629">            int sl = sp + len;</span>
<span class="nc" id="L630">            int dl = dst.length;</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            while (sp &lt; sl) {</span>
<span class="nc" id="L632">                char c = src[sp++];</span>
<span class="nc" id="L633">                int bb = encodeChar(c);</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                if (bb == UNMAPPABLE_ENCODING) {</span>
<span class="nc bnc" id="L635" title="All 4 branches missed.">                    if (Character.isHighSurrogate(c) &amp;&amp; sp &lt; sl &amp;&amp;</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">                        Character.isLowSurrogate(src[sp])) {</span>
<span class="nc" id="L637">                        sp++;</span>
                    }
<span class="nc" id="L639">                    dst[dp++] = repl[0];</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">                    if (repl.length &gt; 1)</span>
<span class="nc" id="L641">                        dst[dp++] = repl[1];</span>
                    continue;
                } //else
<span class="nc bnc" id="L644" title="All 2 branches missed.">                if (bb &gt; MAX_SINGLEBYTE) { // DoubleByte</span>
<span class="nc" id="L645">                    dst[dp++] = (byte)(bb &gt;&gt; 8);</span>
<span class="nc" id="L646">                    dst[dp++] = (byte)bb;</span>
                } else {                          // SingleByte
<span class="nc" id="L648">                    dst[dp++] = (byte)bb;</span>
                }

<span class="nc" id="L651">            }</span>
<span class="nc" id="L652">            return dp;</span>
        }

        public int encodeChar(char ch) {
<span class="nc" id="L656">            return c2b[c2bIndex[ch &gt;&gt; 8] + (ch &amp; 0xff)];</span>
        }

        // init the c2b and c2bIndex tables from b2c.
        static void initC2B(String[] b2c, String b2cSB, String b2cNR,  String c2bNR,
                            int b2Min, int b2Max,
                            char[] c2b, char[] c2bIndex)
        {
<span class="nc" id="L664">            Arrays.fill(c2b, (char)UNMAPPABLE_ENCODING);</span>
<span class="nc" id="L665">            int off = 0x100;</span>

<span class="nc" id="L667">            char[][] b2c_ca = new char[b2c.length][];</span>
<span class="nc" id="L668">            char[] b2cSB_ca = null;</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">            if (b2cSB != null)</span>
<span class="nc" id="L670">                b2cSB_ca = b2cSB.toCharArray();</span>

<span class="nc bnc" id="L672" title="All 2 branches missed.">            for (int i = 0; i &lt; b2c.length; i++) {</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                if (b2c[i] == null)</span>
<span class="nc" id="L674">                    continue;</span>
<span class="nc" id="L675">                b2c_ca[i] = b2c[i].toCharArray();</span>
            }

<span class="nc bnc" id="L678" title="All 2 branches missed.">            if (b2cNR != null) {</span>
<span class="nc" id="L679">                int j = 0;</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                while (j &lt; b2cNR.length()) {</span>
<span class="nc" id="L681">                    char b  = b2cNR.charAt(j++);</span>
<span class="nc" id="L682">                    char c  = b2cNR.charAt(j++);</span>
<span class="nc bnc" id="L683" title="All 4 branches missed.">                    if (b &lt; 0x100 &amp;&amp; b2cSB_ca != null) {</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                        if (b2cSB_ca[b] == c)</span>
<span class="nc" id="L685">                            b2cSB_ca[b] = UNMAPPABLE_DECODING;</span>
                    } else {
<span class="nc bnc" id="L687" title="All 2 branches missed.">                        if (b2c_ca[b &gt;&gt; 8][(b &amp; 0xff) - b2Min] == c)</span>
<span class="nc" id="L688">                            b2c_ca[b &gt;&gt; 8][(b &amp; 0xff) - b2Min] = UNMAPPABLE_DECODING;</span>
                    }
<span class="nc" id="L690">                }</span>
            }

<span class="nc bnc" id="L693" title="All 2 branches missed.">            if (b2cSB_ca != null) {      // SingleByte</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                for (int b = 0; b &lt; b2cSB_ca.length; b++) {</span>
<span class="nc" id="L695">                    char c = b2cSB_ca[b];</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">                    if (c == UNMAPPABLE_DECODING)</span>
<span class="nc" id="L697">                        continue;</span>
<span class="nc" id="L698">                    int index = c2bIndex[c &gt;&gt; 8];</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">                    if (index == 0) {</span>
<span class="nc" id="L700">                        index = off;</span>
<span class="nc" id="L701">                        off += 0x100;</span>
<span class="nc" id="L702">                        c2bIndex[c &gt;&gt; 8] = (char)index;</span>
                    }
<span class="nc" id="L704">                    c2b[index + (c &amp; 0xff)] = (char)b;</span>
                }
            }

<span class="nc bnc" id="L708" title="All 2 branches missed.">            for (int b1 = 0; b1 &lt; b2c.length; b1++) {  // DoubleByte</span>
<span class="nc" id="L709">                char[] db = b2c_ca[b1];</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">                if (db == null)</span>
<span class="nc" id="L711">                    continue;</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                for (int b2 = b2Min; b2 &lt;= b2Max; b2++) {</span>
<span class="nc" id="L713">                    char c = db[b2 - b2Min];</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">                    if (c == UNMAPPABLE_DECODING)</span>
<span class="nc" id="L715">                        continue;</span>
<span class="nc" id="L716">                    int index = c2bIndex[c &gt;&gt; 8];</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">                    if (index == 0) {</span>
<span class="nc" id="L718">                        index = off;</span>
<span class="nc" id="L719">                        off += 0x100;</span>
<span class="nc" id="L720">                        c2bIndex[c &gt;&gt; 8] = (char)index;</span>
                    }
<span class="nc" id="L722">                    c2b[index + (c &amp; 0xff)] = (char)((b1 &lt;&lt; 8) | b2);</span>
                }
            }

<span class="nc bnc" id="L726" title="All 2 branches missed.">            if (c2bNR != null) {</span>
                // add c-&gt;b only nr entries
<span class="nc bnc" id="L728" title="All 2 branches missed.">                for (int i = 0; i &lt; c2bNR.length(); i += 2) {</span>
<span class="nc" id="L729">                    char b = c2bNR.charAt(i);</span>
<span class="nc" id="L730">                    char c = c2bNR.charAt(i + 1);</span>
<span class="nc" id="L731">                    int index = (c &gt;&gt; 8);</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">                    if (c2bIndex[index] == 0) {</span>
<span class="nc" id="L733">                        c2bIndex[index] = (char)off;</span>
<span class="nc" id="L734">                        off += 0x100;</span>
                    }
<span class="nc" id="L736">                    index = c2bIndex[index] + (c &amp; 0xff);</span>
<span class="nc" id="L737">                    c2b[index] = b;</span>
                }
            }
<span class="nc" id="L740">        }</span>
    }

    public static class Encoder_DBCSONLY extends Encoder {
        Encoder_DBCSONLY(Charset cs, byte[] repl,
                         char[] c2b, char[] c2bIndex) {
<span class="nc" id="L746">            super(cs, 2.0f, 2.0f, repl, c2b, c2bIndex);</span>
<span class="nc" id="L747">        }</span>

        public int encodeChar(char ch) {
<span class="nc" id="L750">            int bb = super.encodeChar(ch);</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">            if (bb &lt;= MAX_SINGLEBYTE)</span>
<span class="nc" id="L752">                return UNMAPPABLE_ENCODING;</span>
<span class="nc" id="L753">            return bb;</span>
        }
    }



    public static class Encoder_EBCDIC extends Encoder {
        static final int SBCS = 0;
        static final int DBCS = 1;
        static final byte SO = 0x0e;
        static final byte SI = 0x0f;

<span class="nc" id="L765">        protected int  currentState = SBCS;</span>

        Encoder_EBCDIC(Charset cs, char[] c2b, char[] c2bIndex) {
<span class="nc" id="L768">            super(cs, 4.0f, 5.0f, new byte[] {(byte)0x6f}, c2b, c2bIndex);</span>
<span class="nc" id="L769">        }</span>

        protected void implReset() {
<span class="nc" id="L772">            currentState = SBCS;</span>
<span class="nc" id="L773">        }</span>

        protected CoderResult implFlush(ByteBuffer out) {
<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (currentState == DBCS) {</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">                if (out.remaining() &lt; 1)</span>
<span class="nc" id="L778">                    return CoderResult.OVERFLOW;</span>
<span class="nc" id="L779">                out.put(SI);</span>
            }
<span class="nc" id="L781">            implReset();</span>
<span class="nc" id="L782">            return CoderResult.UNDERFLOW;</span>
        }

        protected CoderResult encodeArrayLoop(CharBuffer src, ByteBuffer dst) {
<span class="nc" id="L786">            char[] sa = src.array();</span>
<span class="nc" id="L787">            int sp = src.arrayOffset() + src.position();</span>
<span class="nc" id="L788">            int sl = src.arrayOffset() + src.limit();</span>
<span class="nc" id="L789">            byte[] da = dst.array();</span>
<span class="nc" id="L790">            int dp = dst.arrayOffset() + dst.position();</span>
<span class="nc" id="L791">            int dl = dst.arrayOffset() + dst.limit();</span>

            try {
<span class="nc bnc" id="L794" title="All 2 branches missed.">                while (sp &lt; sl) {</span>
<span class="nc" id="L795">                    char c = sa[sp];</span>
<span class="nc" id="L796">                    int bb = encodeChar(c);</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">                    if (bb == UNMAPPABLE_ENCODING) {</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">                        if (Character.isSurrogate(c)) {</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">                            if (sgp().parse(c, sa, sp, sl) &lt; 0)</span>
<span class="nc" id="L800">                                return sgp.error();</span>
<span class="nc" id="L801">                            return sgp.unmappableResult();</span>
                        }
<span class="nc" id="L803">                        return CoderResult.unmappableForLength(1);</span>
                    }
<span class="nc bnc" id="L805" title="All 2 branches missed.">                    if (bb &gt; MAX_SINGLEBYTE) {  // DoubleByte</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">                        if (currentState == SBCS) {</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">                            if (dl - dp &lt; 1)</span>
<span class="nc" id="L808">                                return CoderResult.OVERFLOW;</span>
<span class="nc" id="L809">                            currentState = DBCS;</span>
<span class="nc" id="L810">                            da[dp++] = SO;</span>
                        }
<span class="nc bnc" id="L812" title="All 2 branches missed.">                        if (dl - dp &lt; 2)</span>
<span class="nc" id="L813">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L814">                        da[dp++] = (byte)(bb &gt;&gt; 8);</span>
<span class="nc" id="L815">                        da[dp++] = (byte)bb;</span>
                    } else {                    // SingleByte
<span class="nc bnc" id="L817" title="All 2 branches missed.">                        if (currentState == DBCS) {</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">                            if (dl - dp &lt; 1)</span>
<span class="nc" id="L819">                                return CoderResult.OVERFLOW;</span>
<span class="nc" id="L820">                            currentState = SBCS;</span>
<span class="nc" id="L821">                            da[dp++] = SI;</span>
                        }
<span class="nc bnc" id="L823" title="All 2 branches missed.">                        if (dl - dp &lt; 1)</span>
<span class="nc" id="L824">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L825">                        da[dp++] = (byte)bb;</span>

                    }
<span class="nc" id="L828">                    sp++;</span>
<span class="nc" id="L829">                }</span>
<span class="nc" id="L830">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L832">                src.position(sp - src.arrayOffset());</span>
<span class="nc" id="L833">                dst.position(dp - dst.arrayOffset());</span>
            }
        }

        protected CoderResult encodeBufferLoop(CharBuffer src, ByteBuffer dst) {
<span class="nc" id="L838">            int mark = src.position();</span>
            try {
<span class="nc bnc" id="L840" title="All 2 branches missed.">                while (src.hasRemaining()) {</span>
<span class="nc" id="L841">                    char c = src.get();</span>
<span class="nc" id="L842">                    int bb = encodeChar(c);</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">                    if (bb == UNMAPPABLE_ENCODING) {</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">                        if (Character.isSurrogate(c)) {</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">                            if (sgp().parse(c, src) &lt; 0)</span>
<span class="nc" id="L846">                                return sgp.error();</span>
<span class="nc" id="L847">                            return sgp.unmappableResult();</span>
                        }
<span class="nc" id="L849">                        return CoderResult.unmappableForLength(1);</span>
                    }
<span class="nc bnc" id="L851" title="All 2 branches missed.">                    if (bb &gt; MAX_SINGLEBYTE) {  // DoubleByte</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">                        if (currentState == SBCS) {</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">                            if (dst.remaining() &lt; 1)</span>
<span class="nc" id="L854">                                return CoderResult.OVERFLOW;</span>
<span class="nc" id="L855">                            currentState = DBCS;</span>
<span class="nc" id="L856">                            dst.put(SO);</span>
                        }
<span class="nc bnc" id="L858" title="All 2 branches missed.">                        if (dst.remaining() &lt; 2)</span>
<span class="nc" id="L859">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L860">                        dst.put((byte)(bb &gt;&gt; 8));</span>
<span class="nc" id="L861">                        dst.put((byte)(bb));</span>
                    } else {                  // Single-byte
<span class="nc bnc" id="L863" title="All 2 branches missed.">                        if (currentState == DBCS) {</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">                            if (dst.remaining() &lt; 1)</span>
<span class="nc" id="L865">                                return CoderResult.OVERFLOW;</span>
<span class="nc" id="L866">                            currentState = SBCS;</span>
<span class="nc" id="L867">                            dst.put(SI);</span>
                        }
<span class="nc bnc" id="L869" title="All 2 branches missed.">                        if (dst.remaining() &lt; 1)</span>
<span class="nc" id="L870">                            return CoderResult.OVERFLOW;</span>
<span class="nc" id="L871">                        dst.put((byte)bb);</span>
                    }
<span class="nc" id="L873">                    mark++;</span>
<span class="nc" id="L874">                }</span>
<span class="nc" id="L875">                return CoderResult.UNDERFLOW;</span>
            } finally {
<span class="nc" id="L877">                src.position(mark);</span>
            }
        }

        public int encode(char[] src, int sp, int len, byte[] dst) {
<span class="nc" id="L882">            int dp = 0;</span>
<span class="nc" id="L883">            int sl = sp + len;</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">            while (sp &lt; sl) {</span>
<span class="nc" id="L885">                char c = src[sp++];</span>
<span class="nc" id="L886">                int bb = encodeChar(c);</span>

<span class="nc bnc" id="L888" title="All 2 branches missed.">                if (bb == UNMAPPABLE_ENCODING) {</span>
<span class="nc bnc" id="L889" title="All 4 branches missed.">                    if (Character.isHighSurrogate(c) &amp;&amp; sp &lt; sl &amp;&amp;</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">                        Character.isLowSurrogate(src[sp])) {</span>
<span class="nc" id="L891">                        sp++;</span>
                    }
<span class="nc" id="L893">                    dst[dp++] = repl[0];</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">                    if (repl.length &gt; 1)</span>
<span class="nc" id="L895">                        dst[dp++] = repl[1];</span>
                    continue;
                } //else
<span class="nc bnc" id="L898" title="All 2 branches missed.">                if (bb &gt; MAX_SINGLEBYTE) {           // DoubleByte</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">                    if (currentState == SBCS) {</span>
<span class="nc" id="L900">                        currentState = DBCS;</span>
<span class="nc" id="L901">                        dst[dp++] = SO;</span>
                    }
<span class="nc" id="L903">                    dst[dp++] = (byte)(bb &gt;&gt; 8);</span>
<span class="nc" id="L904">                    dst[dp++] = (byte)bb;</span>
                } else {                             // SingleByte
<span class="nc bnc" id="L906" title="All 2 branches missed.">                    if (currentState == DBCS) {</span>
<span class="nc" id="L907">                         currentState = SBCS;</span>
<span class="nc" id="L908">                         dst[dp++] = SI;</span>
                    }
<span class="nc" id="L910">                    dst[dp++] = (byte)bb;</span>
                }
<span class="nc" id="L912">            }</span>

<span class="nc bnc" id="L914" title="All 2 branches missed.">            if (currentState == DBCS) {</span>
<span class="nc" id="L915">                 currentState = SBCS;</span>
<span class="nc" id="L916">                 dst[dp++] = SI;</span>
            }
<span class="nc" id="L918">            return dp;</span>
        }
    }

    // EUC_SIMPLE
<span class="nc" id="L923">    public static class Encoder_EUC_SIM extends Encoder {</span>
        Encoder_EUC_SIM(Charset cs, char[] c2b, char[] c2bIndex) {
<span class="nc" id="L925">            super(cs, c2b, c2bIndex);</span>
<span class="nc" id="L926">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>