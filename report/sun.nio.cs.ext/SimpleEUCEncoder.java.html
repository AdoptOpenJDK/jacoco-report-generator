<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SimpleEUCEncoder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.nio.cs.ext</a> &gt; <span class="el_source">SimpleEUCEncoder.java</span></div><h1>SimpleEUCEncoder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 */

package sun.nio.cs.ext;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CoderResult;
import sun.nio.cs.Surrogate;


<span class="nc bnc" id="L39" title="All 2 branches missed.">public abstract class SimpleEUCEncoder</span>
    extends CharsetEncoder
{

    protected short  index1[];
    protected String index2;
    protected String index2a;
    protected String index2b;
    protected String index2c;
    protected int    mask1;
    protected int    mask2;
    protected int    shift;

<span class="nc" id="L52">    private byte[] outputByte = new byte[4];</span>
<span class="nc" id="L53">    private final Surrogate.Parser sgp = new Surrogate.Parser();</span>

    protected SimpleEUCEncoder(Charset cs)
    {
<span class="nc" id="L57">        super(cs, 3.0f, 4.0f);</span>
<span class="nc" id="L58">    }</span>

    /**
     * Returns true if the given character can be converted to the
     * target character encoding.
     */

    public boolean canEncode(char ch) {
       int    index;
       String theChars;

<span class="nc" id="L69">       index = index1[((ch &amp; mask1) &gt;&gt; shift)] + (ch &amp; mask2);</span>

<span class="nc bnc" id="L71" title="All 2 branches missed.">       if (index &lt; 7500)</span>
<span class="nc" id="L72">         theChars = index2;</span>
       else
<span class="nc bnc" id="L74" title="All 2 branches missed.">         if (index &lt; 15000) {</span>
<span class="nc" id="L75">           index = index - 7500;</span>
<span class="nc" id="L76">           theChars = index2a;</span>
         }
         else
<span class="nc bnc" id="L79" title="All 2 branches missed.">           if (index &lt; 22500){</span>
<span class="nc" id="L80">             index = index - 15000;</span>
<span class="nc" id="L81">             theChars = index2b;</span>
           }
           else {
<span class="nc" id="L84">             index = index - 22500;</span>
<span class="nc" id="L85">             theChars = index2c;</span>
           }

<span class="nc bnc" id="L88" title="All 2 branches missed.">       if (theChars.charAt(2*index) != '\u0000' ||</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">                    theChars.charAt(2*index + 1) != '\u0000')</span>
<span class="nc" id="L90">         return (true);</span>

       // only return true if input char was unicode null - all others are
       //     undefined
<span class="nc bnc" id="L94" title="All 2 branches missed.">       return( ch == '\u0000');</span>

    }
    private CoderResult encodeArrayLoop(CharBuffer src, ByteBuffer dst) {
<span class="nc" id="L98">        char[] sa = src.array();</span>
<span class="nc" id="L99">        int sp = src.arrayOffset() + src.position();</span>
<span class="nc" id="L100">        int sl = src.arrayOffset() + src.limit();</span>
<span class="nc bnc" id="L101" title="All 4 branches missed.">        assert (sp &lt;= sl);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        sp = (sp &lt;= sl ? sp : sl);</span>
<span class="nc" id="L103">        byte[] da = dst.array();</span>
<span class="nc" id="L104">        int dp = dst.arrayOffset() + dst.position();</span>
<span class="nc" id="L105">        int dl = dst.arrayOffset() + dst.limit();</span>
<span class="nc bnc" id="L106" title="All 4 branches missed.">        assert (dp &lt;= dl);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">        dp = (dp &lt;= dl ? dp : dl);</span>

        int     index;
        int     spaceNeeded;
        int     i;

        try {
<span class="nc bnc" id="L114" title="All 2 branches missed.">            while (sp &lt; sl) {</span>
<span class="nc" id="L115">                boolean allZeroes = true;</span>
<span class="nc" id="L116">                char inputChar = sa[sp];</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">                if (Character.isSurrogate(inputChar)) {</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">                    if (sgp.parse(inputChar, sa, sp, sl) &lt; 0)</span>
<span class="nc" id="L119">                        return sgp.error();</span>
<span class="nc" id="L120">                    return sgp.unmappableResult();</span>
                }

<span class="nc bnc" id="L123" title="All 2 branches missed.">                if (inputChar &gt;= '\uFFFE')</span>
<span class="nc" id="L124">                    return CoderResult.unmappableForLength(1);</span>

                String theChars;
                char   aChar;

                 // We have a valid character, get the bytes for it
<span class="nc" id="L130">                index = index1[((inputChar &amp; mask1) &gt;&gt; shift)] + (inputChar &amp; mask2);</span>

<span class="nc bnc" id="L132" title="All 2 branches missed.">                if (index &lt; 7500)</span>
<span class="nc" id="L133">                    theChars = index2;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">                else if (index &lt; 15000) {</span>
<span class="nc" id="L135">                     index = index - 7500;</span>
<span class="nc" id="L136">                     theChars = index2a;</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">                } else if (index &lt; 22500){</span>
<span class="nc" id="L138">                    index = index - 15000;</span>
<span class="nc" id="L139">                    theChars = index2b;</span>
                }
                else {
<span class="nc" id="L142">                    index = index - 22500;</span>
<span class="nc" id="L143">                    theChars = index2c;</span>
                }

<span class="nc" id="L146">                aChar = theChars.charAt(2*index);</span>
<span class="nc" id="L147">                outputByte[0] = (byte)((aChar &amp; 0xff00)&gt;&gt;8);</span>
<span class="nc" id="L148">                outputByte[1] = (byte)(aChar &amp; 0x00ff);</span>
<span class="nc" id="L149">                aChar = theChars.charAt(2*index + 1);</span>
<span class="nc" id="L150">                outputByte[2] = (byte)((aChar &amp; 0xff00)&gt;&gt;8);</span>
<span class="nc" id="L151">                outputByte[3] = (byte)(aChar &amp; 0x00ff);</span>

<span class="nc bnc" id="L153" title="All 2 branches missed.">            for (i = 0; i &lt; outputByte.length; i++) {</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                if (outputByte[i] != 0x00) {</span>
<span class="nc" id="L155">                allZeroes = false;</span>
<span class="nc" id="L156">                break;</span>
                }
            }

<span class="nc bnc" id="L160" title="All 4 branches missed.">            if (allZeroes &amp;&amp; inputChar != '\u0000') {</span>
<span class="nc" id="L161">                return CoderResult.unmappableForLength(1);</span>
            }

<span class="nc" id="L164">            int oindex = 0;</span>

<span class="nc" id="L166">            for (spaceNeeded = outputByte.length;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">                 spaceNeeded &gt; 1; spaceNeeded--){</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                if (outputByte[oindex++] != 0x00 )</span>
<span class="nc" id="L169">                    break;</span>
            }

<span class="nc bnc" id="L172" title="All 2 branches missed.">            if (dp + spaceNeeded &gt; dl)</span>
<span class="nc" id="L173">                return CoderResult.OVERFLOW;</span>

<span class="nc" id="L175">            for (i = outputByte.length - spaceNeeded;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">                 i &lt; outputByte.length; i++) {</span>
<span class="nc" id="L177">                    da[dp++] = outputByte[i];</span>
            }
<span class="nc" id="L179">            sp++;</span>
<span class="nc" id="L180">        }</span>
<span class="nc" id="L181">        return CoderResult.UNDERFLOW;</span>
        } finally {
<span class="nc" id="L183">            src.position(sp - src.arrayOffset());</span>
<span class="nc" id="L184">            dst.position(dp - dst.arrayOffset());</span>
        }
    }

    private CoderResult encodeBufferLoop(CharBuffer src, ByteBuffer dst) {
        int     index;
        int     spaceNeeded;
        int     i;
<span class="nc" id="L192">        int mark = src.position();</span>
        try {
<span class="nc bnc" id="L194" title="All 2 branches missed.">            while (src.hasRemaining()) {</span>
<span class="nc" id="L195">                char inputChar = src.get();</span>
<span class="nc" id="L196">                boolean allZeroes = true;</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">                if (Character.isSurrogate(inputChar)) {</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">                    if (sgp.parse(inputChar, src) &lt; 0)</span>
<span class="nc" id="L199">                        return sgp.error();</span>
<span class="nc" id="L200">                    return sgp.unmappableResult();</span>
                }

<span class="nc bnc" id="L203" title="All 2 branches missed.">                if (inputChar &gt;= '\uFFFE')</span>
<span class="nc" id="L204">                    return CoderResult.unmappableForLength(1);</span>

                String theChars;
                char   aChar;

                 // We have a valid character, get the bytes for it
<span class="nc" id="L210">                index = index1[((inputChar &amp; mask1) &gt;&gt; shift)] + (inputChar &amp; mask2);</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">                if (index &lt; 7500)</span>
<span class="nc" id="L213">                    theChars = index2;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                else if (index &lt; 15000) {</span>
<span class="nc" id="L215">                     index = index - 7500;</span>
<span class="nc" id="L216">                     theChars = index2a;</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                } else if (index &lt; 22500){</span>
<span class="nc" id="L218">                    index = index - 15000;</span>
<span class="nc" id="L219">                    theChars = index2b;</span>
                }
                else {
<span class="nc" id="L222">                    index = index - 22500;</span>
<span class="nc" id="L223">                    theChars = index2c;</span>
                }

<span class="nc" id="L226">                aChar = theChars.charAt(2*index);</span>
<span class="nc" id="L227">                outputByte[0] = (byte)((aChar &amp; 0xff00)&gt;&gt;8);</span>
<span class="nc" id="L228">                outputByte[1] = (byte)(aChar &amp; 0x00ff);</span>
<span class="nc" id="L229">                aChar = theChars.charAt(2*index + 1);</span>
<span class="nc" id="L230">                outputByte[2] = (byte)((aChar &amp; 0xff00)&gt;&gt;8);</span>
<span class="nc" id="L231">                outputByte[3] = (byte)(aChar &amp; 0x00ff);</span>

<span class="nc bnc" id="L233" title="All 2 branches missed.">            for (i = 0; i &lt; outputByte.length; i++) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                if (outputByte[i] != 0x00) {</span>
<span class="nc" id="L235">                allZeroes = false;</span>
<span class="nc" id="L236">                break;</span>
                }
            }
<span class="nc bnc" id="L239" title="All 4 branches missed.">            if (allZeroes &amp;&amp; inputChar != '\u0000') {</span>
<span class="nc" id="L240">                return CoderResult.unmappableForLength(1);</span>
            }

<span class="nc" id="L243">            int oindex = 0;</span>

<span class="nc" id="L245">            for (spaceNeeded = outputByte.length;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                 spaceNeeded &gt; 1; spaceNeeded--){</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">                if (outputByte[oindex++] != 0x00 )</span>
<span class="nc" id="L248">                    break;</span>
            }
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (dst.remaining() &lt; spaceNeeded)</span>
<span class="nc" id="L251">                return CoderResult.OVERFLOW;</span>

<span class="nc" id="L253">            for (i = outputByte.length - spaceNeeded;</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                 i &lt; outputByte.length; i++) {</span>
<span class="nc" id="L255">                    dst.put(outputByte[i]);</span>
            }
<span class="nc" id="L257">            mark++;</span>
<span class="nc" id="L258">            }</span>
<span class="nc" id="L259">            return CoderResult.UNDERFLOW;</span>
        } finally {
<span class="nc" id="L261">            src.position(mark);</span>
        }
    }

    protected CoderResult encodeLoop(CharBuffer src, ByteBuffer dst) {
<span class="nc bnc" id="L266" title="All 4 branches missed.">        if (true &amp;&amp; src.hasArray() &amp;&amp; dst.hasArray())</span>
<span class="nc" id="L267">            return encodeArrayLoop(src, dst);</span>
        else
<span class="nc" id="L269">            return encodeBufferLoop(src, dst);</span>
    }

    public byte encode(char inputChar) {
<span class="nc" id="L273">        return (byte)index2.charAt(index1[(inputChar &amp; mask1) &gt;&gt; shift] +</span>
                (inputChar &amp; mask2));
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>