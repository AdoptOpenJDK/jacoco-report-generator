<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JISAutoDetect.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.nio.cs.ext</a> &gt; <span class="el_source">JISAutoDetect.java</span></div><h1>JISAutoDetect.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.cs.ext;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CoderResult;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.MalformedInputException;
import sun.nio.cs.HistoricallyNamedCharset;
import java.security.AccessController;
import sun.security.action.GetPropertyAction;
import static java.lang.Character.UnicodeBlock;


public class JISAutoDetect
    extends Charset
    implements HistoricallyNamedCharset
{

    private final static int EUCJP_MASK       = 0x01;
    private final static int SJIS2B_MASK      = 0x02;
    private final static int SJIS1B_MASK      = 0x04;
    private final static int EUCJP_KANA1_MASK = 0x08;
    private final static int EUCJP_KANA2_MASK = 0x10;

    public JISAutoDetect() {
<span class="nc" id="L54">        super(&quot;x-JISAutoDetect&quot;, ExtendedCharsets.aliasesFor(&quot;x-JISAutoDetect&quot;));</span>
<span class="nc" id="L55">    }</span>

    public boolean contains(Charset cs) {
<span class="nc bnc" id="L58" title="All 8 branches missed.">        return ((cs.name().equals(&quot;US-ASCII&quot;))</span>
                || (cs instanceof SJIS)
                || (cs instanceof EUC_JP)
                || (cs instanceof ISO2022_JP));
    }

    public boolean canEncode() {
<span class="nc" id="L65">        return false;</span>
    }

    public CharsetDecoder newDecoder() {
<span class="nc" id="L69">        return new Decoder(this);</span>
    }

    public String historicalName() {
<span class="nc" id="L73">        return &quot;JISAutoDetect&quot;;</span>
    }

    public CharsetEncoder newEncoder() {
<span class="nc" id="L77">        throw new UnsupportedOperationException();</span>
    }

    /**
     * accessor methods used to share byte masking tables
     * with the sun.io JISAutoDetect implementation
     */

    public static byte[] getByteMask1() {
<span class="nc" id="L86">        return Decoder.maskTable1;</span>
    }

    public static byte[] getByteMask2() {
<span class="nc" id="L90">        return Decoder.maskTable2;</span>
    }

    public final static boolean canBeSJIS1B(int mask) {
<span class="nc bnc" id="L94" title="All 2 branches missed.">        return (mask &amp; SJIS1B_MASK) != 0;</span>
    }

    public final static boolean canBeEUCJP(int mask) {
<span class="nc bnc" id="L98" title="All 2 branches missed.">        return (mask &amp; EUCJP_MASK) != 0;</span>
    }

    public final static boolean canBeEUCKana(int mask1, int mask2) {
<span class="nc bnc" id="L102" title="All 4 branches missed.">        return ((mask1 &amp; EUCJP_KANA1_MASK) != 0)</span>
            &amp;&amp; ((mask2 &amp; EUCJP_KANA2_MASK) != 0);
    }

    // A heuristic algorithm for guessing if EUC-decoded text really
    // might be Japanese text.  Better heuristics are possible...
    private static boolean looksLikeJapanese(CharBuffer cb) {
<span class="nc" id="L109">        int hiragana = 0;       // Fullwidth Hiragana</span>
<span class="nc" id="L110">        int katakana = 0;       // Halfwidth Katakana</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        while (cb.hasRemaining()) {</span>
<span class="nc" id="L112">            char c = cb.get();</span>
<span class="nc bnc" id="L113" title="All 6 branches missed.">            if (0x3040 &lt;= c &amp;&amp; c &lt;= 0x309f &amp;&amp; ++hiragana &gt; 1) return true;</span>
<span class="nc bnc" id="L114" title="All 6 branches missed.">            if (0xff65 &lt;= c &amp;&amp; c &lt;= 0xff9f &amp;&amp; ++katakana &gt; 1) return true;</span>
<span class="nc" id="L115">        }</span>
<span class="nc" id="L116">        return false;</span>
    }

    private static class Decoder extends CharsetDecoder {

<span class="nc" id="L121">        private final static String SJISName = getSJISName();</span>
<span class="nc" id="L122">        private final static String EUCJPName = getEUCJPName();</span>
<span class="nc" id="L123">        private DelegatableDecoder detectedDecoder = null;</span>

        public Decoder(Charset cs) {
<span class="nc" id="L126">            super(cs, 0.5f, 1.0f);</span>
<span class="nc" id="L127">        }</span>

        private static boolean isPlainASCII(byte b) {
<span class="nc bnc" id="L130" title="All 4 branches missed.">            return b &gt;= 0 &amp;&amp; b != 0x1b;</span>
        }

        private static void copyLeadingASCII(ByteBuffer src, CharBuffer dst) {
<span class="nc" id="L134">            int start = src.position();</span>
<span class="nc" id="L135">            int limit = start + Math.min(src.remaining(), dst.remaining());</span>
            int p;
            byte b;
<span class="nc bnc" id="L138" title="All 4 branches missed.">            for (p = start; p &lt; limit &amp;&amp; isPlainASCII(b = src.get(p)); p++)</span>
<span class="nc" id="L139">                dst.put((char)(b &amp; 0xff));</span>
<span class="nc" id="L140">            src.position(p);</span>
<span class="nc" id="L141">        }</span>

        private CoderResult decodeLoop(Charset cs,
                                       ByteBuffer src, CharBuffer dst) {
<span class="nc" id="L145">            detectedDecoder = (DelegatableDecoder) cs.newDecoder();</span>
<span class="nc" id="L146">            return detectedDecoder.decodeLoop(src, dst);</span>
        }

        protected CoderResult decodeLoop(ByteBuffer src, CharBuffer dst) {
<span class="nc bnc" id="L150" title="All 2 branches missed.">            if (detectedDecoder == null) {</span>
<span class="nc" id="L151">                copyLeadingASCII(src, dst);</span>

                // All ASCII?
<span class="nc bnc" id="L154" title="All 2 branches missed.">                if (! src.hasRemaining())</span>
<span class="nc" id="L155">                    return CoderResult.UNDERFLOW;</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                if (! dst.hasRemaining())</span>
<span class="nc" id="L157">                    return CoderResult.OVERFLOW;</span>

                // We need to perform double, not float, arithmetic; otherwise
                // we lose low order bits when src is larger than 2**24.
<span class="nc" id="L161">                int cbufsiz = (int)(src.limit() * (double)maxCharsPerByte());</span>
<span class="nc" id="L162">                CharBuffer sandbox = CharBuffer.allocate(cbufsiz);</span>

                // First try ISO-2022-JP, since there is no ambiguity
<span class="nc" id="L165">                Charset cs2022 = Charset.forName(&quot;ISO-2022-JP&quot;);</span>
<span class="nc" id="L166">                DelegatableDecoder dd2022</span>
<span class="nc" id="L167">                    = (DelegatableDecoder) cs2022.newDecoder();</span>
<span class="nc" id="L168">                ByteBuffer src2022 = src.asReadOnlyBuffer();</span>
<span class="nc" id="L169">                CoderResult res2022 = dd2022.decodeLoop(src2022, sandbox);</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                if (! res2022.isError())</span>
<span class="nc" id="L171">                    return decodeLoop(cs2022, src, dst);</span>

                // We must choose between EUC and SJIS
<span class="nc" id="L174">                Charset csEUCJ = Charset.forName(EUCJPName);</span>
<span class="nc" id="L175">                Charset csSJIS = Charset.forName(SJISName);</span>

<span class="nc" id="L177">                DelegatableDecoder ddEUCJ</span>
<span class="nc" id="L178">                    = (DelegatableDecoder) csEUCJ.newDecoder();</span>
<span class="nc" id="L179">                ByteBuffer srcEUCJ = src.asReadOnlyBuffer();</span>
<span class="nc" id="L180">                sandbox.clear();</span>
<span class="nc" id="L181">                CoderResult resEUCJ = ddEUCJ.decodeLoop(srcEUCJ, sandbox);</span>
                // If EUC decoding fails, must be SJIS
<span class="nc bnc" id="L183" title="All 2 branches missed.">                if (resEUCJ.isError())</span>
<span class="nc" id="L184">                    return decodeLoop(csSJIS, src, dst);</span>

<span class="nc" id="L186">                DelegatableDecoder ddSJIS</span>
<span class="nc" id="L187">                    = (DelegatableDecoder) csSJIS.newDecoder();</span>
<span class="nc" id="L188">                ByteBuffer srcSJIS = src.asReadOnlyBuffer();</span>
<span class="nc" id="L189">                CharBuffer sandboxSJIS = CharBuffer.allocate(cbufsiz);</span>
<span class="nc" id="L190">                CoderResult resSJIS = ddSJIS.decodeLoop(srcSJIS, sandboxSJIS);</span>
                // If SJIS decoding fails, must be EUC
<span class="nc bnc" id="L192" title="All 2 branches missed.">                if (resSJIS.isError())</span>
<span class="nc" id="L193">                    return decodeLoop(csEUCJ, src, dst);</span>

                // From here on, we have some ambiguity, and must guess.

                // We prefer input that does not appear to end mid-character.
<span class="nc bnc" id="L198" title="All 2 branches missed.">                if (srcEUCJ.position() &gt; srcSJIS.position())</span>
<span class="nc" id="L199">                    return decodeLoop(csEUCJ, src, dst);</span>

<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (srcEUCJ.position() &lt; srcSJIS.position())</span>
<span class="nc" id="L202">                    return decodeLoop(csSJIS, src, dst);</span>

                // end-of-input is after the first byte of the first char?
<span class="nc bnc" id="L205" title="All 2 branches missed.">                if (src.position() == srcEUCJ.position())</span>
<span class="nc" id="L206">                    return CoderResult.UNDERFLOW;</span>

                // Use heuristic knowledge of typical Japanese text
<span class="nc" id="L209">                sandbox.flip();</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                Charset guess = looksLikeJapanese(sandbox) ? csEUCJ : csSJIS;</span>
<span class="nc" id="L211">                return decodeLoop(guess, src, dst);</span>
            }

<span class="nc" id="L214">            return detectedDecoder.decodeLoop(src, dst);</span>
        }

        protected void implReset() {
<span class="nc" id="L218">            detectedDecoder = null;</span>
<span class="nc" id="L219">        }</span>

        protected CoderResult implFlush(CharBuffer out) {
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if (detectedDecoder != null)</span>
<span class="nc" id="L223">                return detectedDecoder.implFlush(out);</span>
            else
<span class="nc" id="L225">                return super.implFlush(out);</span>
        }

        public boolean isAutoDetecting() {
<span class="nc" id="L229">            return true;</span>
        }

        public boolean isCharsetDetected() {
<span class="nc bnc" id="L233" title="All 2 branches missed.">            return detectedDecoder != null;</span>
        }

        public Charset detectedCharset() {
<span class="nc bnc" id="L237" title="All 2 branches missed.">            if (detectedDecoder == null)</span>
<span class="nc" id="L238">                throw new IllegalStateException(&quot;charset not yet detected&quot;);</span>
<span class="nc" id="L239">            return ((CharsetDecoder) detectedDecoder).charset();</span>
        }

        /**
         * Returned Shift_JIS Charset name is OS dependent
         */
        private static String getSJISName() {
<span class="nc" id="L246">            String osName = AccessController.doPrivileged(</span>
                new GetPropertyAction(&quot;os.name&quot;));
<span class="nc bnc" id="L248" title="All 4 branches missed.">            if (osName.equals(&quot;Solaris&quot;) || osName.equals(&quot;SunOS&quot;))</span>
<span class="nc" id="L249">                return(&quot;PCK&quot;);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            else if (osName.startsWith(&quot;Windows&quot;))</span>
<span class="nc" id="L251">                return(&quot;windows-31J&quot;);</span>
            else
<span class="nc" id="L253">                return(&quot;Shift_JIS&quot;);</span>
        }

        /**
         * Returned EUC-JP Charset name is OS dependent
         */

        private static String getEUCJPName() {
<span class="nc" id="L261">            String osName = AccessController.doPrivileged(</span>
                new GetPropertyAction(&quot;os.name&quot;));
<span class="nc bnc" id="L263" title="All 4 branches missed.">            if (osName.equals(&quot;Solaris&quot;) || osName.equals(&quot;SunOS&quot;))</span>
<span class="nc" id="L264">                return(&quot;x-eucjp-open&quot;);</span>
            else
<span class="nc" id="L266">                return(&quot;EUC_JP&quot;);</span>
        }

        // Mask tables - each entry indicates possibility of first or
        // second byte being SJIS or EUC_JP
<span class="nc" id="L271">        private static final byte maskTable1[] = {</span>
            0, 0, 0, 0, // 0x00 - 0x03
            0, 0, 0, 0, // 0x04 - 0x07
            0, 0, 0, 0, // 0x08 - 0x0b
            0, 0, 0, 0, // 0x0c - 0x0f
            0, 0, 0, 0, // 0x10 - 0x13
            0, 0, 0, 0, // 0x14 - 0x17
            0, 0, 0, 0, // 0x18 - 0x1b
            0, 0, 0, 0, // 0x1c - 0x1f
            0, 0, 0, 0, // 0x20 - 0x23
            0, 0, 0, 0, // 0x24 - 0x27
            0, 0, 0, 0, // 0x28 - 0x2b
            0, 0, 0, 0, // 0x2c - 0x2f
            0, 0, 0, 0, // 0x30 - 0x33
            0, 0, 0, 0, // 0x34 - 0x37
            0, 0, 0, 0, // 0x38 - 0x3b
            0, 0, 0, 0, // 0x3c - 0x3f
            0, 0, 0, 0, // 0x40 - 0x43
            0, 0, 0, 0, // 0x44 - 0x47
            0, 0, 0, 0, // 0x48 - 0x4b
            0, 0, 0, 0, // 0x4c - 0x4f
            0, 0, 0, 0, // 0x50 - 0x53
            0, 0, 0, 0, // 0x54 - 0x57
            0, 0, 0, 0, // 0x58 - 0x5b
            0, 0, 0, 0, // 0x5c - 0x5f
            0, 0, 0, 0, // 0x60 - 0x63
            0, 0, 0, 0, // 0x64 - 0x67
            0, 0, 0, 0, // 0x68 - 0x6b
            0, 0, 0, 0, // 0x6c - 0x6f
            0, 0, 0, 0, // 0x70 - 0x73
            0, 0, 0, 0, // 0x74 - 0x77
            0, 0, 0, 0, // 0x78 - 0x7b
            0, 0, 0, 0, // 0x7c - 0x7f
            0, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK,   // 0x80 - 0x83
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x84 - 0x87
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x88 - 0x8b
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK,   // 0x8c - 0x8f
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x90 - 0x93
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x94 - 0x97
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x98 - 0x9b
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x9c - 0x9f
            0, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,  // 0xa0 - 0xa3
            SJIS1B_MASK|EUCJP_MASK|EUCJP_KANA1_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,    // 0xa4 - 0xa7
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xa8 - 0xab
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xac - 0xaf
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xb0 - 0xb3
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xb4 - 0xb7
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xb8 - 0xbb
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xbc - 0xbf
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xc0 - 0xc3
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xc4 - 0xc7
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xc8 - 0xcb
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xcc - 0xcf
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xd0 - 0xd3
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xd4 - 0xd7
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xd8 - 0xdb
            SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK, SJIS1B_MASK|EUCJP_MASK,     // 0xdc - 0xdf
            SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK,     // 0xe0 - 0xe3
            SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK,     // 0xe4 - 0xe7
            SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK,     // 0xe8 - 0xeb
            SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK,     // 0xec - 0xef
            SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK,     // 0xf0 - 0xf3
            SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK,     // 0xf4 - 0xf7
            SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK,     // 0xf8 - 0xfb
            SJIS2B_MASK|EUCJP_MASK, EUCJP_MASK, EUCJP_MASK, 0   // 0xfc - 0xff
        };

<span class="nc" id="L338">        private static final byte maskTable2[] = {</span>
            0, 0, 0, 0, // 0x00 - 0x03
            0, 0, 0, 0, // 0x04 - 0x07
            0, 0, 0, 0, // 0x08 - 0x0b
            0, 0, 0, 0, // 0x0c - 0x0f
            0, 0, 0, 0, // 0x10 - 0x13
            0, 0, 0, 0, // 0x14 - 0x17
            0, 0, 0, 0, // 0x18 - 0x1b
            0, 0, 0, 0, // 0x1c - 0x1f
            0, 0, 0, 0, // 0x20 - 0x23
            0, 0, 0, 0, // 0x24 - 0x27
            0, 0, 0, 0, // 0x28 - 0x2b
            0, 0, 0, 0, // 0x2c - 0x2f
            0, 0, 0, 0, // 0x30 - 0x33
            0, 0, 0, 0, // 0x34 - 0x37
            0, 0, 0, 0, // 0x38 - 0x3b
            0, 0, 0, 0, // 0x3c - 0x3f
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x40 - 0x43
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x44 - 0x47
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x48 - 0x4b
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x4c - 0x4f
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x50 - 0x53
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x54 - 0x57
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x58 - 0x5b
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x5c - 0x5f
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x60 - 0x63
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x64 - 0x67
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x68 - 0x6b
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x6c - 0x6f
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x70 - 0x73
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x74 - 0x77
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x78 - 0x7b
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, 0,   // 0x7c - 0x7f
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x80 - 0x83
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x84 - 0x87
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x88 - 0x8b
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x8c - 0x8f
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x90 - 0x93
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x94 - 0x97
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x98 - 0x9b
            SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, SJIS2B_MASK, // 0x9c - 0x9f
            SJIS2B_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xa0 - 0xa3
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xa4 - 0xa7
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xa8 - 0xab
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xac - 0xaf
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xb0 - 0xb3
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xb4 - 0xb7
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xb8 - 0xbb
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xbc - 0xbf
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xc0 - 0xc3
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xc4 - 0xc7
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xc8 - 0xcb
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xcc - 0xcf
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xd0 - 0xd3
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xd4 - 0xd7
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xd8 - 0xdb
            SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS1B_MASK|SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xdc - 0xdf
            SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xe0 - 0xe3
            SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xe4 - 0xe7
            SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xe8 - 0xeb
            SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xec - 0xef
            SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, SJIS2B_MASK|EUCJP_MASK|EUCJP_KANA2_MASK, // 0xf0 - 0xf3
            SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK,     // 0xf4 - 0xf7
            SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK, SJIS2B_MASK|EUCJP_MASK,     // 0xf8 - 0xfb
            SJIS2B_MASK|EUCJP_MASK, EUCJP_MASK, EUCJP_MASK, 0   // 0xfc - 0xff
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>