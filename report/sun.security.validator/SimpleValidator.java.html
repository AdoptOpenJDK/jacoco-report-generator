<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SimpleValidator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.validator</a> &gt; <span class="el_source">SimpleValidator.java</span></div><h1>SimpleValidator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.validator;

import java.io.IOException;
import java.util.*;

import java.security.*;
import java.security.cert.*;

import javax.security.auth.x500.X500Principal;

import sun.security.x509.X509CertImpl;
import sun.security.x509.NetscapeCertTypeExtension;
import sun.security.util.DerValue;
import sun.security.util.DerInputStream;
import sun.security.util.ObjectIdentifier;

import sun.security.provider.certpath.AlgorithmChecker;
import sun.security.provider.certpath.UntrustedChecker;

/**
 * A simple validator implementation. It is based on code from the JSSE
 * X509TrustManagerImpl. This implementation is designed for compatibility with
 * deployed certificates and previous J2SE versions. It will never support
 * more advanced features and will be deemphasized in favor of the PKIX
 * validator going forward.
 * &lt;p&gt;
 * {@code SimpleValidator} objects are immutable once they have been created.
 * Please DO NOT add methods that can change the state of an instance once
 * it has been created.
 *
 * @author Andreas Sterbenz
 */
public final class SimpleValidator extends Validator {

    // Constants for the OIDs we need

    final static String OID_BASIC_CONSTRAINTS = &quot;2.5.29.19&quot;;

    final static String OID_NETSCAPE_CERT_TYPE = &quot;2.16.840.1.113730.1.1&quot;;

    final static String OID_KEY_USAGE = &quot;2.5.29.15&quot;;

    final static String OID_EXTENDED_KEY_USAGE = &quot;2.5.29.37&quot;;

    final static String OID_EKU_ANY_USAGE = &quot;2.5.29.37.0&quot;;

<span class="fc" id="L72">    final static ObjectIdentifier OBJID_NETSCAPE_CERT_TYPE =</span>
        NetscapeCertTypeExtension.NetscapeCertType_Id;

    private final static String NSCT_SSL_CA =
                                NetscapeCertTypeExtension.SSL_CA;

    private final static String NSCT_CODE_SIGNING_CA =
                                NetscapeCertTypeExtension.OBJECT_SIGNING_CA;

    /**
     * The trusted certificates as:
     * Map (X500Principal)subject of trusted cert -&gt; List of X509Certificate
     * The list is used because there may be multiple certificates
     * with an identical subject DN.
     */
    private final Map&lt;X500Principal, List&lt;X509Certificate&gt;&gt;
                                            trustedX500Principals;

    /**
     * Set of the trusted certificates. Present only for
     * getTrustedCertificates().
     */
    private final Collection&lt;X509Certificate&gt; trustedCerts;

    SimpleValidator(String variant, Collection&lt;X509Certificate&gt; trustedCerts) {
<span class="fc" id="L97">        super(TYPE_SIMPLE, variant);</span>
<span class="fc" id="L98">        this.trustedCerts = trustedCerts;</span>
<span class="fc" id="L99">        trustedX500Principals =</span>
                        new HashMap&lt;X500Principal, List&lt;X509Certificate&gt;&gt;();
<span class="fc bfc" id="L101" title="All 2 branches covered.">        for (X509Certificate cert : trustedCerts) {</span>
<span class="fc" id="L102">            X500Principal principal = cert.getSubjectX500Principal();</span>
<span class="fc" id="L103">            List&lt;X509Certificate&gt; list = trustedX500Principals.get(principal);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">            if (list == null) {</span>
                // this actually should be a set, but duplicate entries
                // are not a problem and we can avoid the Set overhead
<span class="fc" id="L107">                list = new ArrayList&lt;X509Certificate&gt;(2);</span>
<span class="fc" id="L108">                trustedX500Principals.put(principal, list);</span>
            }
<span class="fc" id="L110">            list.add(cert);</span>
<span class="fc" id="L111">        }</span>
<span class="fc" id="L112">    }</span>

    public Collection&lt;X509Certificate&gt; getTrustedCertificates() {
<span class="nc" id="L115">        return trustedCerts;</span>
    }

    /**
     * Perform simple validation of chain. The arguments otherCerts and
     * parameter are ignored.
     */
    @Override
    X509Certificate[] engineValidate(X509Certificate[] chain,
            Collection&lt;X509Certificate&gt; otherCerts,
            AlgorithmConstraints constraints,
            Object parameter) throws CertificateException {
<span class="pc bpc" id="L127" title="2 of 4 branches missed.">        if ((chain == null) || (chain.length == 0)) {</span>
<span class="nc" id="L128">            throw new CertificateException</span>
                (&quot;null or zero-length certificate chain&quot;);
        }

        // make sure chain includes a trusted cert
<span class="fc" id="L133">        chain = buildTrustedChain(chain);</span>

        @SuppressWarnings(&quot;deprecation&quot;)
<span class="fc" id="L136">        Date date = validationDate;</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if (date == null) {</span>
<span class="fc" id="L138">            date = new Date();</span>
        }

        // create distrusted certificates checker
<span class="fc" id="L142">        UntrustedChecker untrustedChecker = new UntrustedChecker();</span>

        // create default algorithm constraints checker
<span class="fc" id="L145">        TrustAnchor anchor = new TrustAnchor(chain[chain.length - 1], null);</span>
<span class="fc" id="L146">        AlgorithmChecker defaultAlgChecker = new AlgorithmChecker(anchor);</span>

        // create application level algorithm constraints checker
<span class="fc" id="L149">        AlgorithmChecker appAlgChecker = null;</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (constraints != null) {</span>
<span class="fc" id="L151">            appAlgChecker = new AlgorithmChecker(anchor, constraints);</span>
        }

        // verify top down, starting at the certificate issued by
        // the trust anchor
<span class="fc" id="L156">        int maxPathLength = chain.length - 1;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        for (int i = chain.length - 2; i &gt;= 0; i--) {</span>
<span class="fc" id="L158">            X509Certificate issuerCert = chain[i + 1];</span>
<span class="fc" id="L159">            X509Certificate cert = chain[i];</span>

            // check untrusted certificate
            try {
                // Untrusted checker does not care about the unresolved
                // critical extensions.
<span class="fc" id="L165">                untrustedChecker.check(cert, Collections.&lt;String&gt;emptySet());</span>
<span class="fc" id="L166">            } catch (CertPathValidatorException cpve) {</span>
<span class="fc" id="L167">                throw new ValidatorException(</span>
<span class="fc" id="L168">                    &quot;Untrusted certificate: &quot; + cert.getSubjectX500Principal(),</span>
                    ValidatorException.T_UNTRUSTED_CERT, cert, cpve);
<span class="fc" id="L170">            }</span>

            // check certificate algorithm
            try {
                // Algorithm checker does not care about the unresolved
                // critical extensions.
<span class="fc" id="L176">                defaultAlgChecker.check(cert, Collections.&lt;String&gt;emptySet());</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">                if (appAlgChecker != null) {</span>
<span class="fc" id="L178">                    appAlgChecker.check(cert, Collections.&lt;String&gt;emptySet());</span>
                }
<span class="nc" id="L180">            } catch (CertPathValidatorException cpve) {</span>
<span class="nc" id="L181">                throw new ValidatorException</span>
                        (ValidatorException.T_ALGORITHM_DISABLED, cert, cpve);
<span class="fc" id="L183">            }</span>

            // no validity check for code signing certs
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">            if ((variant.equals(VAR_CODE_SIGNING) == false)</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">                        &amp;&amp; (variant.equals(VAR_JCE_SIGNING) == false)) {</span>
<span class="fc" id="L188">                cert.checkValidity(date);</span>
            }

            // check name chaining
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">            if (cert.getIssuerX500Principal().equals(</span>
<span class="fc" id="L193">                        issuerCert.getSubjectX500Principal()) == false) {</span>
<span class="nc" id="L194">                throw new ValidatorException</span>
                        (ValidatorException.T_NAME_CHAINING, cert);
            }

            // check signature
            try {
<span class="fc" id="L200">                cert.verify(issuerCert.getPublicKey());</span>
<span class="nc" id="L201">            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L202">                throw new ValidatorException</span>
                        (ValidatorException.T_SIGNATURE_ERROR, cert, e);
<span class="fc" id="L204">            }</span>

            // check extensions for CA certs
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (i != 0) {</span>
<span class="fc" id="L208">                maxPathLength = checkExtensions(cert, maxPathLength);</span>
            }
        }

<span class="fc" id="L212">        return chain;</span>
    }

    private int checkExtensions(X509Certificate cert, int maxPathLen)
            throws CertificateException {
<span class="fc" id="L217">        Set&lt;String&gt; critSet = cert.getCriticalExtensionOIDs();</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if (critSet == null) {</span>
<span class="nc" id="L219">            critSet = Collections.&lt;String&gt;emptySet();</span>
        }

        // Check the basic constraints extension
<span class="fc" id="L223">        int pathLenConstraint =</span>
<span class="fc" id="L224">                checkBasicConstraints(cert, critSet, maxPathLen);</span>

        // Check the key usage and extended key usage extensions
<span class="fc" id="L227">        checkKeyUsage(cert, critSet);</span>

        // check Netscape certificate type extension
<span class="fc" id="L230">        checkNetscapeCertType(cert, critSet);</span>

<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (!critSet.isEmpty()) {</span>
<span class="nc" id="L233">            throw new ValidatorException</span>
                (&quot;Certificate contains unknown critical extensions: &quot; + critSet,
                ValidatorException.T_CA_EXTENSIONS, cert);
        }

<span class="fc" id="L238">        return pathLenConstraint;</span>
    }

    private void checkNetscapeCertType(X509Certificate cert,
            Set&lt;String&gt; critSet) throws CertificateException {
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        if (variant.equals(VAR_GENERIC)) {</span>
            // nothing
<span class="fc bfc" id="L245" title="All 2 branches covered.">        } else if (variant.equals(VAR_TLS_CLIENT)</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">                || variant.equals(VAR_TLS_SERVER)) {</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">            if (getNetscapeCertTypeBit(cert, NSCT_SSL_CA) == false) {</span>
<span class="nc" id="L248">                throw new ValidatorException</span>
                        (&quot;Invalid Netscape CertType extension for SSL CA &quot;
                        + &quot;certificate&quot;,
                        ValidatorException.T_CA_EXTENSIONS, cert);
            }
<span class="fc" id="L253">            critSet.remove(OID_NETSCAPE_CERT_TYPE);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        } else if (variant.equals(VAR_CODE_SIGNING)</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                || variant.equals(VAR_JCE_SIGNING)) {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (getNetscapeCertTypeBit(cert, NSCT_CODE_SIGNING_CA) == false) {</span>
<span class="nc" id="L257">                throw new ValidatorException</span>
                        (&quot;Invalid Netscape CertType extension for code &quot;
                        + &quot;signing CA certificate&quot;,
                        ValidatorException.T_CA_EXTENSIONS, cert);
            }
<span class="nc" id="L262">            critSet.remove(OID_NETSCAPE_CERT_TYPE);</span>
        } else {
<span class="nc" id="L264">            throw new CertificateException(&quot;Unknown variant &quot; + variant);</span>
        }
<span class="fc" id="L266">    }</span>

    /**
     * Get the value of the specified bit in the Netscape certificate type
     * extension. If the extension is not present at all, we return true.
     */
    static boolean getNetscapeCertTypeBit(X509Certificate cert, String type) {
        try {
            NetscapeCertTypeExtension ext;
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">            if (cert instanceof X509CertImpl) {</span>
<span class="fc" id="L276">                X509CertImpl certImpl = (X509CertImpl)cert;</span>
<span class="fc" id="L277">                ObjectIdentifier oid = OBJID_NETSCAPE_CERT_TYPE;</span>
<span class="fc" id="L278">                ext = (NetscapeCertTypeExtension)certImpl.getExtension(oid);</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">                if (ext == null) {</span>
<span class="fc" id="L280">                    return true;</span>
                }
<span class="nc" id="L282">            } else {</span>
<span class="nc" id="L283">                byte[] extVal = cert.getExtensionValue(OID_NETSCAPE_CERT_TYPE);</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                if (extVal == null) {</span>
<span class="nc" id="L285">                    return true;</span>
                }
<span class="nc" id="L287">                DerInputStream in = new DerInputStream(extVal);</span>
<span class="nc" id="L288">                byte[] encoded = in.getOctetString();</span>
<span class="nc" id="L289">                encoded = new DerValue(encoded).getUnalignedBitString()</span>
<span class="nc" id="L290">                                                                .toByteArray();</span>
<span class="nc" id="L291">                ext = new NetscapeCertTypeExtension(encoded);</span>
            }
<span class="nc" id="L293">            Boolean val = ext.get(type);</span>
<span class="nc" id="L294">            return val.booleanValue();</span>
<span class="nc" id="L295">        } catch (IOException e) {</span>
<span class="nc" id="L296">            return false;</span>
        }
    }

    private int checkBasicConstraints(X509Certificate cert,
            Set&lt;String&gt; critSet, int maxPathLen) throws CertificateException {

<span class="fc" id="L303">        critSet.remove(OID_BASIC_CONSTRAINTS);</span>
<span class="fc" id="L304">        int constraints = cert.getBasicConstraints();</span>
        // reject, if extension missing or not a CA (constraints == -1)
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (constraints &lt; 0) {</span>
<span class="nc" id="L307">            throw new ValidatorException(&quot;End user tried to act as a CA&quot;,</span>
                ValidatorException.T_CA_EXTENSIONS, cert);
        }

        // if the certificate is self-issued, ignore the pathLenConstraint
        // checking.
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (!X509CertImpl.isSelfIssued(cert)) {</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">            if (maxPathLen &lt;= 0) {</span>
<span class="nc" id="L315">                throw new ValidatorException(&quot;Violated path length constraints&quot;,</span>
                    ValidatorException.T_CA_EXTENSIONS, cert);
            }

<span class="fc" id="L319">            maxPathLen--;</span>
        }

<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (maxPathLen &gt; constraints) {</span>
<span class="fc" id="L323">            maxPathLen = constraints;</span>
        }

<span class="fc" id="L326">        return maxPathLen;</span>
    }

    /*
     * Verify the key usage and extended key usage for intermediate
     * certificates.
     */
    private void checkKeyUsage(X509Certificate cert, Set&lt;String&gt; critSet)
            throws CertificateException {

<span class="fc" id="L336">        critSet.remove(OID_KEY_USAGE);</span>
        // EKU irrelevant in CA certificates
<span class="fc" id="L338">        critSet.remove(OID_EXTENDED_KEY_USAGE);</span>

        // check key usage extension
<span class="fc" id="L341">        boolean[] keyUsageInfo = cert.getKeyUsage();</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        if (keyUsageInfo != null) {</span>
            // keyUsageInfo[5] is for keyCertSign.
<span class="pc bpc" id="L344" title="2 of 4 branches missed.">            if ((keyUsageInfo.length &lt; 6) || (keyUsageInfo[5] == false)) {</span>
<span class="nc" id="L345">                throw new ValidatorException</span>
                        (&quot;Wrong key usage: expected keyCertSign&quot;,
                        ValidatorException.T_CA_EXTENSIONS, cert);
            }
        }
<span class="fc" id="L350">    }</span>

    /**
     * Build a trusted certificate chain. This method always returns a chain
     * with a trust anchor as the final cert in the chain. If no trust anchor
     * could be found, a CertificateException is thrown.
     */
    private X509Certificate[] buildTrustedChain(X509Certificate[] chain)
            throws CertificateException {
<span class="fc" id="L359">        List&lt;X509Certificate&gt; c = new ArrayList&lt;X509Certificate&gt;(chain.length);</span>
        // scan chain starting at EE cert
        // if a trusted certificate is found, append it and return
<span class="fc bfc" id="L362" title="All 2 branches covered.">        for (int i = 0; i &lt; chain.length; i++) {</span>
<span class="fc" id="L363">            X509Certificate cert = chain[i];</span>
<span class="fc" id="L364">            X509Certificate trustedCert = getTrustedCertificate(cert);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">            if (trustedCert != null) {</span>
<span class="fc" id="L366">                c.add(trustedCert);</span>
<span class="fc" id="L367">                return c.toArray(CHAIN0);</span>
            }
<span class="fc" id="L369">            c.add(cert);</span>
        }

        // check if we can append a trusted cert
<span class="fc" id="L373">        X509Certificate cert = chain[chain.length - 1];</span>
<span class="fc" id="L374">        X500Principal subject = cert.getSubjectX500Principal();</span>
<span class="fc" id="L375">        X500Principal issuer = cert.getIssuerX500Principal();</span>
<span class="fc" id="L376">        List&lt;X509Certificate&gt; list = trustedX500Principals.get(issuer);</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        if (list != null) {</span>
<span class="fc" id="L378">            X509Certificate trustedCert = list.iterator().next();</span>
<span class="fc" id="L379">            c.add(trustedCert);</span>
<span class="fc" id="L380">            return c.toArray(CHAIN0);</span>
        }

        // no trusted cert found, error
<span class="nc" id="L384">        throw new ValidatorException(ValidatorException.T_NO_TRUST_ANCHOR);</span>
    }

    /**
     * Return a trusted certificate that matches the input certificate,
     * or null if no such certificate can be found. This method also handles
     * cases where a CA re-issues a trust anchor with the same public key and
     * same subject and issuer names but a new validity period, etc.
     */
    private X509Certificate getTrustedCertificate(X509Certificate cert) {
<span class="fc" id="L394">        Principal certSubjectName = cert.getSubjectX500Principal();</span>
<span class="fc" id="L395">        List&lt;X509Certificate&gt; list = trustedX500Principals.get(certSubjectName);</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (list == null) {</span>
<span class="fc" id="L397">            return null;</span>
        }

<span class="fc" id="L400">        Principal certIssuerName = cert.getIssuerX500Principal();</span>
<span class="fc" id="L401">        PublicKey certPublicKey = cert.getPublicKey();</span>

<span class="fc bfc" id="L403" title="All 2 branches covered.">        for (X509Certificate mycert : list) {</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">            if (mycert.equals(cert)) {</span>
<span class="fc" id="L405">                return cert;</span>
            }
<span class="fc bfc" id="L407" title="All 2 branches covered.">            if (!mycert.getIssuerX500Principal().equals(certIssuerName)) {</span>
<span class="fc" id="L408">                continue;</span>
            }
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">            if (!mycert.getPublicKey().equals(certPublicKey)) {</span>
<span class="fc" id="L411">                continue;</span>
            }

            // All tests pass, this must be the one to use...
<span class="nc" id="L415">            return mycert;</span>
        }
<span class="fc" id="L417">        return null;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>