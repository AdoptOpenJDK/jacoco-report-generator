<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EndEntityChecker.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.validator</a> &gt; <span class="el_source">EndEntityChecker.java</span></div><h1>EndEntityChecker.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.validator;

import java.util.*;

import java.security.cert.*;

import sun.security.x509.NetscapeCertTypeExtension;

/**
 * Class to check if an end entity cert is suitable for use in some
 * context.&lt;p&gt;
 *
 * This class is used internally by the validator. Currently, seven variants
 * are supported defined as VAR_XXX constants in the Validator class:
 * &lt;ul&gt;
 * &lt;li&gt;Generic. No additional requirements, all certificates are ok.
 *
 * &lt;li&gt;TLS server. Requires that a String parameter is passed to
 * validate that specifies the name of the TLS key exchange algorithm
 * in use. See the JSSE X509TrustManager spec for details.
 *
 * &lt;li&gt;TLS client.
 *
 * &lt;li&gt;Code signing.
 *
 * &lt;li&gt;JCE code signing. Some early JCE code signing certs issued to
 * providers had incorrect extensions. In this mode the checks
 * are relaxed compared to standard code signing checks in order to
 * allow these certificates to pass.
 *
 * &lt;li&gt;Plugin code signing. WebStart and Plugin require their own variant
 * which is equivalent to VAR_CODE_SIGNING with additional checks for
 * compatibility/special cases. See also PKIXValidator.
 *
 * &lt;li&gt;TSA Server (see RFC 3161, section 2.3).
 *
 * &lt;/ul&gt;
 *
 * @author Andreas Sterbenz
 */
class EndEntityChecker {

    // extended key usage OIDs for TLS server, TLS client, code signing
    // and any usage

    private final static String OID_EXTENDED_KEY_USAGE =
                                SimpleValidator.OID_EXTENDED_KEY_USAGE;

    private final static String OID_EKU_TLS_SERVER = &quot;1.3.6.1.5.5.7.3.1&quot;;

    private final static String OID_EKU_TLS_CLIENT = &quot;1.3.6.1.5.5.7.3.2&quot;;

    private final static String OID_EKU_CODE_SIGNING = &quot;1.3.6.1.5.5.7.3.3&quot;;

    private final static String OID_EKU_TIME_STAMPING = &quot;1.3.6.1.5.5.7.3.8&quot;;

    private final static String OID_EKU_ANY_USAGE = &quot;2.5.29.37.0&quot;;

    // the Netscape Server-Gated-Cryptography EKU extension OID
    private final static String OID_EKU_NS_SGC = &quot;2.16.840.1.113730.4.1&quot;;

    // the Microsoft Server-Gated-Cryptography EKU extension OID
    private final static String OID_EKU_MS_SGC = &quot;1.3.6.1.4.1.311.10.3.3&quot;;

    // the recognized extension OIDs
    private final static String OID_SUBJECT_ALT_NAME = &quot;2.5.29.17&quot;;

    private final static String NSCT_SSL_CLIENT =
                                NetscapeCertTypeExtension.SSL_CLIENT;

    private final static String NSCT_SSL_SERVER =
                                NetscapeCertTypeExtension.SSL_SERVER;

    private final static String NSCT_CODE_SIGNING =
                                NetscapeCertTypeExtension.OBJECT_SIGNING;

    // bit numbers in the key usage extension
    private final static int KU_SIGNATURE = 0;
    private final static int KU_KEY_ENCIPHERMENT = 2;
    private final static int KU_KEY_AGREEMENT = 4;

    // TLS key exchange algorithms requiring digitalSignature key usage
<span class="fc" id="L108">    private final static Collection&lt;String&gt; KU_SERVER_SIGNATURE =</span>
<span class="fc" id="L109">        Arrays.asList(&quot;DHE_DSS&quot;, &quot;DHE_RSA&quot;, &quot;ECDHE_ECDSA&quot;, &quot;ECDHE_RSA&quot;,</span>
            &quot;RSA_EXPORT&quot;, &quot;UNKNOWN&quot;);

    // TLS key exchange algorithms requiring keyEncipherment key usage
<span class="fc" id="L113">    private final static Collection&lt;String&gt; KU_SERVER_ENCRYPTION =</span>
<span class="fc" id="L114">        Arrays.asList(&quot;RSA&quot;);</span>

    // TLS key exchange algorithms requiring keyAgreement key usage
<span class="fc" id="L117">    private final static Collection&lt;String&gt; KU_SERVER_KEY_AGREEMENT =</span>
<span class="fc" id="L118">        Arrays.asList(&quot;DH_DSS&quot;, &quot;DH_RSA&quot;, &quot;ECDH_ECDSA&quot;, &quot;ECDH_RSA&quot;);</span>

    // variant of this end entity cert checker
    private final String variant;

    // type of the validator this checker belongs to
    private final String type;

<span class="fc" id="L126">    private EndEntityChecker(String type, String variant) {</span>
<span class="fc" id="L127">        this.type = type;</span>
<span class="fc" id="L128">        this.variant = variant;</span>
<span class="fc" id="L129">    }</span>

    static EndEntityChecker getInstance(String type, String variant) {
<span class="fc" id="L132">        return new EndEntityChecker(type, variant);</span>
    }

    void check(X509Certificate cert, Object parameter)
            throws CertificateException {
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if (variant.equals(Validator.VAR_GENERIC)) {</span>
            // no checks
<span class="nc" id="L139">            return;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">        } else if (variant.equals(Validator.VAR_TLS_SERVER)) {</span>
<span class="fc" id="L141">            checkTLSServer(cert, (String)parameter);</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        } else if (variant.equals(Validator.VAR_TLS_CLIENT)) {</span>
<span class="fc" id="L143">            checkTLSClient(cert);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        } else if (variant.equals(Validator.VAR_CODE_SIGNING)) {</span>
<span class="nc" id="L145">            checkCodeSigning(cert);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        } else if (variant.equals(Validator.VAR_JCE_SIGNING)) {</span>
<span class="nc" id="L147">            checkCodeSigning(cert);</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        } else if (variant.equals(Validator.VAR_PLUGIN_CODE_SIGNING)) {</span>
<span class="nc" id="L149">            checkCodeSigning(cert);</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        } else if (variant.equals(Validator.VAR_TSA_SERVER)) {</span>
<span class="nc" id="L151">            checkTSAServer(cert);</span>
        } else {
<span class="nc" id="L153">            throw new CertificateException(&quot;Unknown variant: &quot; + variant);</span>
        }
<span class="fc" id="L155">    }</span>

    /**
     * Utility method returning the Set of critical extensions for
     * certificate cert (never null).
     */
    private Set&lt;String&gt; getCriticalExtensions(X509Certificate cert) {
<span class="fc" id="L162">        Set&lt;String&gt; exts = cert.getCriticalExtensionOIDs();</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (exts == null) {</span>
<span class="nc" id="L164">            exts = Collections.emptySet();</span>
        }
<span class="fc" id="L166">        return exts;</span>
    }

    /**
     * Utility method checking if there are any unresolved critical extensions.
     * @throws CertificateException if so.
     */
    private void checkRemainingExtensions(Set&lt;String&gt; exts)
            throws CertificateException {
        // basic constraints irrelevant in EE certs
<span class="fc" id="L176">        exts.remove(SimpleValidator.OID_BASIC_CONSTRAINTS);</span>

        // If the subject field contains an empty sequence, the subjectAltName
        // extension MUST be marked critical.
        // We do not check the validity of the critical extension, just mark
        // it recognizable here.
<span class="fc" id="L182">        exts.remove(OID_SUBJECT_ALT_NAME);</span>

<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (!exts.isEmpty()) {</span>
<span class="nc" id="L185">            throw new CertificateException(&quot;Certificate contains unsupported &quot;</span>
                + &quot;critical extensions: &quot; + exts);
        }
<span class="fc" id="L188">    }</span>

    /**
     * Utility method checking if the extended key usage extension in
     * certificate cert allows use for expectedEKU.
     */
    private boolean checkEKU(X509Certificate cert, Set&lt;String&gt; exts,
            String expectedEKU) throws CertificateException {
<span class="fc" id="L196">        List&lt;String&gt; eku = cert.getExtendedKeyUsage();</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (eku == null) {</span>
<span class="fc" id="L198">            return true;</span>
        }
<span class="pc bpc" id="L200" title="3 of 4 branches missed.">        return eku.contains(expectedEKU) || eku.contains(OID_EKU_ANY_USAGE);</span>
    }

    /**
     * Utility method checking if bit 'bit' is set in this certificates
     * key usage extension.
     * @throws CertificateException if not
     */
    private boolean checkKeyUsage(X509Certificate cert, int bit)
            throws CertificateException {
<span class="fc" id="L210">        boolean[] keyUsage = cert.getKeyUsage();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (keyUsage == null) {</span>
<span class="fc" id="L212">            return true;</span>
        }
<span class="pc bpc" id="L214" title="2 of 4 branches missed.">        return (keyUsage.length &gt; bit) &amp;&amp; keyUsage[bit];</span>
    }

    /**
     * Check whether this certificate can be used for TLS client
     * authentication.
     * @throws CertificateException if not.
     */
    private void checkTLSClient(X509Certificate cert)
            throws CertificateException {
<span class="fc" id="L224">        Set&lt;String&gt; exts = getCriticalExtensions(cert);</span>

<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (checkKeyUsage(cert, KU_SIGNATURE) == false) {</span>
<span class="nc" id="L227">            throw new ValidatorException</span>
                (&quot;KeyUsage does not allow digital signatures&quot;,
                ValidatorException.T_EE_EXTENSIONS, cert);
        }

<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (checkEKU(cert, exts, OID_EKU_TLS_CLIENT) == false) {</span>
<span class="nc" id="L233">            throw new ValidatorException(&quot;Extended key usage does not &quot;</span>
                + &quot;permit use for TLS client authentication&quot;,
                ValidatorException.T_EE_EXTENSIONS, cert);
        }

<span class="pc bpc" id="L238" title="1 of 2 branches missed.">        if (!SimpleValidator.getNetscapeCertTypeBit(cert, NSCT_SSL_CLIENT)) {</span>
<span class="nc" id="L239">            throw new ValidatorException</span>
                (&quot;Netscape cert type does not permit use for SSL client&quot;,
                ValidatorException.T_EE_EXTENSIONS, cert);
        }

        // remove extensions we checked
<span class="fc" id="L245">        exts.remove(SimpleValidator.OID_KEY_USAGE);</span>
<span class="fc" id="L246">        exts.remove(SimpleValidator.OID_EXTENDED_KEY_USAGE);</span>
<span class="fc" id="L247">        exts.remove(SimpleValidator.OID_NETSCAPE_CERT_TYPE);</span>

<span class="fc" id="L249">        checkRemainingExtensions(exts);</span>
<span class="fc" id="L250">    }</span>

    /**
     * Check whether this certificate can be used for TLS server authentication
     * using the specified authentication type parameter. See X509TrustManager
     * specification for details.
     * @throws CertificateException if not.
     */
    private void checkTLSServer(X509Certificate cert, String parameter)
            throws CertificateException {
<span class="fc" id="L260">        Set&lt;String&gt; exts = getCriticalExtensions(cert);</span>

<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (KU_SERVER_ENCRYPTION.contains(parameter)) {</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">            if (checkKeyUsage(cert, KU_KEY_ENCIPHERMENT) == false) {</span>
<span class="nc" id="L264">                throw new ValidatorException</span>
                        (&quot;KeyUsage does not allow key encipherment&quot;,
                        ValidatorException.T_EE_EXTENSIONS, cert);
            }
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">        } else if (KU_SERVER_SIGNATURE.contains(parameter)) {</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">            if (checkKeyUsage(cert, KU_SIGNATURE) == false) {</span>
<span class="nc" id="L270">                throw new ValidatorException</span>
                        (&quot;KeyUsage does not allow digital signatures&quot;,
                        ValidatorException.T_EE_EXTENSIONS, cert);
            }
<span class="nc bnc" id="L274" title="All 2 branches missed.">        } else if (KU_SERVER_KEY_AGREEMENT.contains(parameter)) {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (checkKeyUsage(cert, KU_KEY_AGREEMENT) == false) {</span>
<span class="nc" id="L276">                throw new ValidatorException</span>
                        (&quot;KeyUsage does not allow key agreement&quot;,
                        ValidatorException.T_EE_EXTENSIONS, cert);
            }
        } else {
<span class="nc" id="L281">            throw new CertificateException(&quot;Unknown authType: &quot; + parameter);</span>
        }

<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        if (checkEKU(cert, exts, OID_EKU_TLS_SERVER) == false) {</span>
            // check for equivalent but now obsolete Server-Gated-Cryptography
            // (aka Step-Up, 128 bit) EKU OIDs
<span class="nc bnc" id="L287" title="All 2 branches missed.">            if ((checkEKU(cert, exts, OID_EKU_MS_SGC) == false) &amp;&amp;</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">                (checkEKU(cert, exts, OID_EKU_NS_SGC) == false)) {</span>
<span class="nc" id="L289">                throw new ValidatorException</span>
                    (&quot;Extended key usage does not permit use for TLS &quot;
                    + &quot;server authentication&quot;,
                    ValidatorException.T_EE_EXTENSIONS, cert);
            }
        }

<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (!SimpleValidator.getNetscapeCertTypeBit(cert, NSCT_SSL_SERVER)) {</span>
<span class="nc" id="L297">            throw new ValidatorException</span>
                (&quot;Netscape cert type does not permit use for SSL server&quot;,
                ValidatorException.T_EE_EXTENSIONS, cert);
        }

        // remove extensions we checked
<span class="fc" id="L303">        exts.remove(SimpleValidator.OID_KEY_USAGE);</span>
<span class="fc" id="L304">        exts.remove(SimpleValidator.OID_EXTENDED_KEY_USAGE);</span>
<span class="fc" id="L305">        exts.remove(SimpleValidator.OID_NETSCAPE_CERT_TYPE);</span>

<span class="fc" id="L307">        checkRemainingExtensions(exts);</span>
<span class="fc" id="L308">    }</span>

    /**
     * Check whether this certificate can be used for code signing.
     * @throws CertificateException if not.
     */
    private void checkCodeSigning(X509Certificate cert)
            throws CertificateException {
<span class="nc" id="L316">        Set&lt;String&gt; exts = getCriticalExtensions(cert);</span>

<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (checkKeyUsage(cert, KU_SIGNATURE) == false) {</span>
<span class="nc" id="L319">            throw new ValidatorException</span>
                (&quot;KeyUsage does not allow digital signatures&quot;,
                ValidatorException.T_EE_EXTENSIONS, cert);
        }

<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (checkEKU(cert, exts, OID_EKU_CODE_SIGNING) == false) {</span>
<span class="nc" id="L325">            throw new ValidatorException</span>
                (&quot;Extended key usage does not permit use for code signing&quot;,
                ValidatorException.T_EE_EXTENSIONS, cert);
        }

        // do not check Netscape cert type for JCE code signing checks
        // (some certs were issued with incorrect extensions)
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (variant.equals(Validator.VAR_JCE_SIGNING) == false) {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (!SimpleValidator.getNetscapeCertTypeBit(cert, NSCT_CODE_SIGNING)) {</span>
<span class="nc" id="L334">                throw new ValidatorException</span>
                    (&quot;Netscape cert type does not permit use for code signing&quot;,
                    ValidatorException.T_EE_EXTENSIONS, cert);
            }
<span class="nc" id="L338">            exts.remove(SimpleValidator.OID_NETSCAPE_CERT_TYPE);</span>
        }

        // remove extensions we checked
<span class="nc" id="L342">        exts.remove(SimpleValidator.OID_KEY_USAGE);</span>
<span class="nc" id="L343">        exts.remove(SimpleValidator.OID_EXTENDED_KEY_USAGE);</span>

<span class="nc" id="L345">        checkRemainingExtensions(exts);</span>
<span class="nc" id="L346">    }</span>

    /**
     * Check whether this certificate can be used by a time stamping authority
     * server (see RFC 3161, section 2.3).
     * @throws CertificateException if not.
     */
    private void checkTSAServer(X509Certificate cert)
            throws CertificateException {
<span class="nc" id="L355">        Set&lt;String&gt; exts = getCriticalExtensions(cert);</span>

<span class="nc bnc" id="L357" title="All 2 branches missed.">        if (checkKeyUsage(cert, KU_SIGNATURE) == false) {</span>
<span class="nc" id="L358">            throw new ValidatorException</span>
                (&quot;KeyUsage does not allow digital signatures&quot;,
                ValidatorException.T_EE_EXTENSIONS, cert);
        }

<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (cert.getExtendedKeyUsage() == null) {</span>
<span class="nc" id="L364">            throw new ValidatorException</span>
                (&quot;Certificate does not contain an extended key usage &quot; +
                &quot;extension required for a TSA server&quot;,
                ValidatorException.T_EE_EXTENSIONS, cert);
        }

<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (checkEKU(cert, exts, OID_EKU_TIME_STAMPING) == false) {</span>
<span class="nc" id="L371">            throw new ValidatorException</span>
                (&quot;Extended key usage does not permit use for TSA server&quot;,
                ValidatorException.T_EE_EXTENSIONS, cert);
        }

        // remove extensions we checked
<span class="nc" id="L377">        exts.remove(SimpleValidator.OID_KEY_USAGE);</span>
<span class="nc" id="L378">        exts.remove(SimpleValidator.OID_EXTENDED_KEY_USAGE);</span>

<span class="nc" id="L380">        checkRemainingExtensions(exts);</span>
<span class="nc" id="L381">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>