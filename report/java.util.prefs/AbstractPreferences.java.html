<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AbstractPreferences.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.prefs</a> &gt; <span class="el_source">AbstractPreferences.java</span></div><h1>AbstractPreferences.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util.prefs;

import java.util.*;
import java.io.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
// These imports needed only as a workaround for a JavaDoc bug
import java.lang.Integer;
import java.lang.Long;
import java.lang.Float;
import java.lang.Double;

/**
 * This class provides a skeletal implementation of the {@link Preferences}
 * class, greatly easing the task of implementing it.
 *
 * &lt;p&gt;&lt;strong&gt;This class is for &lt;tt&gt;Preferences&lt;/tt&gt; implementers only.
 * Normal users of the &lt;tt&gt;Preferences&lt;/tt&gt; facility should have no need to
 * consult this documentation.  The {@link Preferences} documentation
 * should suffice.&lt;/strong&gt;
 *
 * &lt;p&gt;Implementors must override the nine abstract service-provider interface
 * (SPI) methods: {@link #getSpi(String)}, {@link #putSpi(String,String)},
 * {@link #removeSpi(String)}, {@link #childSpi(String)}, {@link
 * #removeNodeSpi()}, {@link #keysSpi()}, {@link #childrenNamesSpi()}, {@link
 * #syncSpi()} and {@link #flushSpi()}.  All of the concrete methods specify
 * precisely how they are implemented atop these SPI methods.  The implementor
 * may, at his discretion, override one or more of the concrete methods if the
 * default implementation is unsatisfactory for any reason, such as
 * performance.
 *
 * &lt;p&gt;The SPI methods fall into three groups concerning exception
 * behavior. The &lt;tt&gt;getSpi&lt;/tt&gt; method should never throw exceptions, but it
 * doesn't really matter, as any exception thrown by this method will be
 * intercepted by {@link #get(String,String)}, which will return the specified
 * default value to the caller.  The &lt;tt&gt;removeNodeSpi, keysSpi,
 * childrenNamesSpi, syncSpi&lt;/tt&gt; and &lt;tt&gt;flushSpi&lt;/tt&gt; methods are specified
 * to throw {@link BackingStoreException}, and the implementation is required
 * to throw this checked exception if it is unable to perform the operation.
 * The exception propagates outward, causing the corresponding API method
 * to fail.
 *
 * &lt;p&gt;The remaining SPI methods {@link #putSpi(String,String)}, {@link
 * #removeSpi(String)} and {@link #childSpi(String)} have more complicated
 * exception behavior.  They are not specified to throw
 * &lt;tt&gt;BackingStoreException&lt;/tt&gt;, as they can generally obey their contracts
 * even if the backing store is unavailable.  This is true because they return
 * no information and their effects are not required to become permanent until
 * a subsequent call to {@link Preferences#flush()} or
 * {@link Preferences#sync()}. Generally speaking, these SPI methods should not
 * throw exceptions.  In some implementations, there may be circumstances
 * under which these calls cannot even enqueue the requested operation for
 * later processing.  Even under these circumstances it is generally better to
 * simply ignore the invocation and return, rather than throwing an
 * exception.  Under these circumstances, however, all subsequent invocations
 * of &lt;tt&gt;flush()&lt;/tt&gt; and &lt;tt&gt;sync&lt;/tt&gt; should return &lt;tt&gt;false&lt;/tt&gt;, as
 * returning &lt;tt&gt;true&lt;/tt&gt; would imply that all previous operations had
 * successfully been made permanent.
 *
 * &lt;p&gt;There is one circumstance under which &lt;tt&gt;putSpi, removeSpi and
 * childSpi&lt;/tt&gt; &lt;i&gt;should&lt;/i&gt; throw an exception: if the caller lacks
 * sufficient privileges on the underlying operating system to perform the
 * requested operation.  This will, for instance, occur on most systems
 * if a non-privileged user attempts to modify system preferences.
 * (The required privileges will vary from implementation to
 * implementation.  On some implementations, they are the right to modify the
 * contents of some directory in the file system; on others they are the right
 * to modify contents of some key in a registry.)  Under any of these
 * circumstances, it would generally be undesirable to let the program
 * continue executing as if these operations would become permanent at a later
 * time.  While implementations are not required to throw an exception under
 * these circumstances, they are encouraged to do so.  A {@link
 * SecurityException} would be appropriate.
 *
 * &lt;p&gt;Most of the SPI methods require the implementation to read or write
 * information at a preferences node.  The implementor should beware of the
 * fact that another VM may have concurrently deleted this node from the
 * backing store.  It is the implementation's responsibility to recreate the
 * node if it has been deleted.
 *
 * &lt;p&gt;Implementation note: In Sun's default &lt;tt&gt;Preferences&lt;/tt&gt;
 * implementations, the user's identity is inherited from the underlying
 * operating system and does not change for the lifetime of the virtual
 * machine.  It is recognized that server-side &lt;tt&gt;Preferences&lt;/tt&gt;
 * implementations may have the user identity change from request to request,
 * implicitly passed to &lt;tt&gt;Preferences&lt;/tt&gt; methods via the use of a
 * static {@link ThreadLocal} instance.  Authors of such implementations are
 * &lt;i&gt;strongly&lt;/i&gt; encouraged to determine the user at the time preferences
 * are accessed (for example by the {@link #get(String,String)} or {@link
 * #put(String,String)} method) rather than permanently associating a user
 * with each &lt;tt&gt;Preferences&lt;/tt&gt; instance.  The latter behavior conflicts
 * with normal &lt;tt&gt;Preferences&lt;/tt&gt; usage and would lead to great confusion.
 *
 * @author  Josh Bloch
 * @see     Preferences
 * @since   1.4
 */
public abstract class AbstractPreferences extends Preferences {
    /**
     * Our name relative to parent.
     */
    private final String name;

    /**
     * Our absolute path name.
     */
    private final String absolutePath;

    /**
     * Our parent node.
     */
    final AbstractPreferences parent;

    /**
     * Our root node.
     */
    private final AbstractPreferences root; // Relative to this node

    /**
     * This field should be &lt;tt&gt;true&lt;/tt&gt; if this node did not exist in the
     * backing store prior to the creation of this object.  The field
     * is initialized to false, but may be set to true by a subclass
     * constructor (and should not be modified thereafter).  This field
     * indicates whether a node change event should be fired when
     * creation is complete.
     */
<span class="fc" id="L152">    protected boolean newNode = false;</span>

    /**
     * All known unremoved children of this node.  (This &quot;cache&quot; is consulted
     * prior to calling childSpi() or getChild().
     */
<span class="fc" id="L158">    private Map&lt;String, AbstractPreferences&gt; kidCache = new HashMap&lt;&gt;();</span>

    /**
     * This field is used to keep track of whether or not this node has
     * been removed.  Once it's set to true, it will never be reset to false.
     */
<span class="fc" id="L164">    private boolean removed = false;</span>

    /**
     * Registered preference change listeners.
     */
<span class="fc" id="L169">    private PreferenceChangeListener[] prefListeners =</span>
        new PreferenceChangeListener[0];

    /**
     * Registered node change listeners.
     */
<span class="fc" id="L175">    private NodeChangeListener[] nodeListeners = new NodeChangeListener[0];</span>

    /**
     * An object whose monitor is used to lock this node.  This object
     * is used in preference to the node itself to reduce the likelihood of
     * intentional or unintentional denial of service due to a locked node.
     * To avoid deadlock, a node is &lt;i&gt;never&lt;/i&gt; locked by a thread that
     * holds a lock on a descendant of that node.
     */
<span class="fc" id="L184">    protected final Object lock = new Object();</span>

    /**
     * Creates a preference node with the specified parent and the specified
     * name relative to its parent.
     *
     * @param parent the parent of this preference node, or null if this
     *               is the root.
     * @param name the name of this preference node, relative to its parent,
     *             or &lt;tt&gt;&quot;&quot;&lt;/tt&gt; if this is the root.
     * @throws IllegalArgumentException if &lt;tt&gt;name&lt;/tt&gt; contains a slash
     *          (&lt;tt&gt;'/'&lt;/tt&gt;),  or &lt;tt&gt;parent&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt; and
     *          name isn't &lt;tt&gt;&quot;&quot;&lt;/tt&gt;.
     */
<span class="fc" id="L198">    protected AbstractPreferences(AbstractPreferences parent, String name) {</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (parent==null) {</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            if (!name.equals(&quot;&quot;))</span>
<span class="nc" id="L201">                throw new IllegalArgumentException(&quot;Root name '&quot;+name+</span>
                                                   &quot;' must be \&quot;\&quot;&quot;);
<span class="fc" id="L203">            this.absolutePath = &quot;/&quot;;</span>
<span class="fc" id="L204">            root = this;</span>
        } else {
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">            if (name.indexOf('/') != -1)</span>
<span class="nc" id="L207">                throw new IllegalArgumentException(&quot;Name '&quot; + name +</span>
                                                 &quot;' contains '/'&quot;);
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">            if (name.equals(&quot;&quot;))</span>
<span class="nc" id="L210">              throw new IllegalArgumentException(&quot;Illegal name: empty string&quot;);</span>

<span class="fc" id="L212">            root = parent.root;</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">            absolutePath = (parent==root ? &quot;/&quot; + name</span>
<span class="fc" id="L214">                                         : parent.absolutePath() + &quot;/&quot; + name);</span>
        }
<span class="fc" id="L216">        this.name = name;</span>
<span class="fc" id="L217">        this.parent = parent;</span>
<span class="fc" id="L218">    }</span>

    /**
     * Implements the &lt;tt&gt;put&lt;/tt&gt; method as per the specification in
     * {@link Preferences#put(String,String)}.
     *
     * &lt;p&gt;This implementation checks that the key and value are legal,
     * obtains this preference node's lock, checks that the node
     * has not been removed, invokes {@link #putSpi(String,String)}, and if
     * there are any preference change listeners, enqueues a notification
     * event for processing by the event dispatch thread.
     *
     * @param key key with which the specified value is to be associated.
     * @param value value to be associated with the specified key.
     * @throws NullPointerException if key or value is &lt;tt&gt;null&lt;/tt&gt;.
     * @throws IllegalArgumentException if &lt;tt&gt;key.length()&lt;/tt&gt; exceeds
     *       &lt;tt&gt;MAX_KEY_LENGTH&lt;/tt&gt; or if &lt;tt&gt;value.length&lt;/tt&gt; exceeds
     *       &lt;tt&gt;MAX_VALUE_LENGTH&lt;/tt&gt;.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */
    public void put(String key, String value) {
<span class="pc bpc" id="L240" title="2 of 4 branches missed.">        if (key==null || value==null)</span>
<span class="nc" id="L241">            throw new NullPointerException();</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        if (key.length() &gt; MAX_KEY_LENGTH)</span>
<span class="nc" id="L243">            throw new IllegalArgumentException(&quot;Key too long: &quot;+key);</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (value.length() &gt; MAX_VALUE_LENGTH)</span>
<span class="nc" id="L245">            throw new IllegalArgumentException(&quot;Value too long: &quot;+value);</span>

<span class="fc" id="L247">        synchronized(lock) {</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">            if (removed)</span>
<span class="nc" id="L249">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>

<span class="fc" id="L251">            putSpi(key, value);</span>
<span class="fc" id="L252">            enqueuePreferenceChangeEvent(key, value);</span>
<span class="pc" id="L253">        }</span>
<span class="fc" id="L254">    }</span>

    /**
     * Implements the &lt;tt&gt;get&lt;/tt&gt; method as per the specification in
     * {@link Preferences#get(String,String)}.
     *
     * &lt;p&gt;This implementation first checks to see if &lt;tt&gt;key&lt;/tt&gt; is
     * &lt;tt&gt;null&lt;/tt&gt; throwing a &lt;tt&gt;NullPointerException&lt;/tt&gt; if this is
     * the case.  Then it obtains this preference node's lock,
     * checks that the node has not been removed, invokes {@link
     * #getSpi(String)}, and returns the result, unless the &lt;tt&gt;getSpi&lt;/tt&gt;
     * invocation returns &lt;tt&gt;null&lt;/tt&gt; or throws an exception, in which case
     * this invocation returns &lt;tt&gt;def&lt;/tt&gt;.
     *
     * @param key key whose associated value is to be returned.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with &lt;tt&gt;key&lt;/tt&gt;.
     * @return the value associated with &lt;tt&gt;key&lt;/tt&gt;, or &lt;tt&gt;def&lt;/tt&gt;
     *         if no value is associated with &lt;tt&gt;key&lt;/tt&gt;.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if key is &lt;tt&gt;null&lt;/tt&gt;.  (A
     *         &lt;tt&gt;null&lt;/tt&gt; default &lt;i&gt;is&lt;/i&gt; permitted.)
     */
    public String get(String key, String def) {
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">        if (key==null)</span>
<span class="nc" id="L280">            throw new NullPointerException(&quot;Null key&quot;);</span>
<span class="fc" id="L281">        synchronized(lock) {</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">            if (removed)</span>
<span class="nc" id="L283">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>

<span class="fc" id="L285">            String result = null;</span>
            try {
<span class="fc" id="L287">                result = getSpi(key);</span>
<span class="nc" id="L288">            } catch (Exception e) {</span>
                // Ignoring exception causes default to be returned
<span class="fc" id="L290">            }</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">            return (result==null ? def : result);</span>
<span class="nc" id="L292">        }</span>
    }

    /**
     * Implements the &lt;tt&gt;remove(String)&lt;/tt&gt; method as per the specification
     * in {@link Preferences#remove(String)}.
     *
     * &lt;p&gt;This implementation obtains this preference node's lock,
     * checks that the node has not been removed, invokes
     * {@link #removeSpi(String)} and if there are any preference
     * change listeners, enqueues a notification event for processing by the
     * event dispatch thread.
     *
     * @param key key whose mapping is to be removed from the preference node.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException {@inheritDoc}.
     */
    public void remove(String key) {
<span class="nc" id="L311">        Objects.requireNonNull(key, &quot;Specified key cannot be null&quot;);</span>
<span class="nc" id="L312">        synchronized(lock) {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">            if (removed)</span>
<span class="nc" id="L314">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>

<span class="nc" id="L316">            removeSpi(key);</span>
<span class="nc" id="L317">            enqueuePreferenceChangeEvent(key, null);</span>
<span class="nc" id="L318">        }</span>
<span class="nc" id="L319">    }</span>

    /**
     * Implements the &lt;tt&gt;clear&lt;/tt&gt; method as per the specification in
     * {@link Preferences#clear()}.
     *
     * &lt;p&gt;This implementation obtains this preference node's lock,
     * invokes {@link #keys()} to obtain an array of keys, and
     * iterates over the array invoking {@link #remove(String)} on each key.
     *
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */
    public void clear() throws BackingStoreException {
<span class="nc" id="L336">        synchronized(lock) {</span>
<span class="nc" id="L337">            String[] keys = keys();</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            for (int i=0; i&lt;keys.length; i++)</span>
<span class="nc" id="L339">                remove(keys[i]);</span>
<span class="nc" id="L340">        }</span>
<span class="nc" id="L341">    }</span>

    /**
     * Implements the &lt;tt&gt;putInt&lt;/tt&gt; method as per the specification in
     * {@link Preferences#putInt(String,int)}.
     *
     * &lt;p&gt;This implementation translates &lt;tt&gt;value&lt;/tt&gt; to a string with
     * {@link Integer#toString(int)} and invokes {@link #put(String,String)}
     * on the result.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key is &lt;tt&gt;null&lt;/tt&gt;.
     * @throws IllegalArgumentException if &lt;tt&gt;key.length()&lt;/tt&gt; exceeds
     *         &lt;tt&gt;MAX_KEY_LENGTH&lt;/tt&gt;.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */
    public void putInt(String key, int value) {
<span class="nc" id="L360">        put(key, Integer.toString(value));</span>
<span class="nc" id="L361">    }</span>

    /**
     * Implements the &lt;tt&gt;getInt&lt;/tt&gt; method as per the specification in
     * {@link Preferences#getInt(String,int)}.
     *
     * &lt;p&gt;This implementation invokes {@link #get(String,String) &lt;tt&gt;get(key,
     * null)&lt;/tt&gt;}.  If the return value is non-null, the implementation
     * attempts to translate it to an &lt;tt&gt;int&lt;/tt&gt; with
     * {@link Integer#parseInt(String)}.  If the attempt succeeds, the return
     * value is returned by this method.  Otherwise, &lt;tt&gt;def&lt;/tt&gt; is returned.
     *
     * @param key key whose associated value is to be returned as an int.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with &lt;tt&gt;key&lt;/tt&gt;
     *        or the associated value cannot be interpreted as an int.
     * @return the int value represented by the string associated with
     *         &lt;tt&gt;key&lt;/tt&gt; in this preference node, or &lt;tt&gt;def&lt;/tt&gt; if the
     *         associated value does not exist or cannot be interpreted as
     *         an int.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.
     */
    public int getInt(String key, int def) {
<span class="nc" id="L386">        int result = def;</span>
        try {
<span class="nc" id="L388">            String value = get(key, null);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">            if (value != null)</span>
<span class="nc" id="L390">                result = Integer.parseInt(value);</span>
<span class="nc" id="L391">        } catch (NumberFormatException e) {</span>
            // Ignoring exception causes specified default to be returned
<span class="nc" id="L393">        }</span>

<span class="nc" id="L395">        return result;</span>
    }

    /**
     * Implements the &lt;tt&gt;putLong&lt;/tt&gt; method as per the specification in
     * {@link Preferences#putLong(String,long)}.
     *
     * &lt;p&gt;This implementation translates &lt;tt&gt;value&lt;/tt&gt; to a string with
     * {@link Long#toString(long)} and invokes {@link #put(String,String)}
     * on the result.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key is &lt;tt&gt;null&lt;/tt&gt;.
     * @throws IllegalArgumentException if &lt;tt&gt;key.length()&lt;/tt&gt; exceeds
     *         &lt;tt&gt;MAX_KEY_LENGTH&lt;/tt&gt;.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */
    public void putLong(String key, long value) {
<span class="nc" id="L415">        put(key, Long.toString(value));</span>
<span class="nc" id="L416">    }</span>

    /**
     * Implements the &lt;tt&gt;getLong&lt;/tt&gt; method as per the specification in
     * {@link Preferences#getLong(String,long)}.
     *
     * &lt;p&gt;This implementation invokes {@link #get(String,String) &lt;tt&gt;get(key,
     * null)&lt;/tt&gt;}.  If the return value is non-null, the implementation
     * attempts to translate it to a &lt;tt&gt;long&lt;/tt&gt; with
     * {@link Long#parseLong(String)}.  If the attempt succeeds, the return
     * value is returned by this method.  Otherwise, &lt;tt&gt;def&lt;/tt&gt; is returned.
     *
     * @param key key whose associated value is to be returned as a long.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with &lt;tt&gt;key&lt;/tt&gt;
     *        or the associated value cannot be interpreted as a long.
     * @return the long value represented by the string associated with
     *         &lt;tt&gt;key&lt;/tt&gt; in this preference node, or &lt;tt&gt;def&lt;/tt&gt; if the
     *         associated value does not exist or cannot be interpreted as
     *         a long.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.
     */
    public long getLong(String key, long def) {
<span class="nc" id="L441">        long result = def;</span>
        try {
<span class="nc" id="L443">            String value = get(key, null);</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">            if (value != null)</span>
<span class="nc" id="L445">                result = Long.parseLong(value);</span>
<span class="nc" id="L446">        } catch (NumberFormatException e) {</span>
            // Ignoring exception causes specified default to be returned
<span class="nc" id="L448">        }</span>

<span class="nc" id="L450">        return result;</span>
    }

    /**
     * Implements the &lt;tt&gt;putBoolean&lt;/tt&gt; method as per the specification in
     * {@link Preferences#putBoolean(String,boolean)}.
     *
     * &lt;p&gt;This implementation translates &lt;tt&gt;value&lt;/tt&gt; to a string with
     * {@link String#valueOf(boolean)} and invokes {@link #put(String,String)}
     * on the result.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key is &lt;tt&gt;null&lt;/tt&gt;.
     * @throws IllegalArgumentException if &lt;tt&gt;key.length()&lt;/tt&gt; exceeds
     *         &lt;tt&gt;MAX_KEY_LENGTH&lt;/tt&gt;.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */
    public void putBoolean(String key, boolean value) {
<span class="nc" id="L470">        put(key, String.valueOf(value));</span>
<span class="nc" id="L471">    }</span>

    /**
     * Implements the &lt;tt&gt;getBoolean&lt;/tt&gt; method as per the specification in
     * {@link Preferences#getBoolean(String,boolean)}.
     *
     * &lt;p&gt;This implementation invokes {@link #get(String,String) &lt;tt&gt;get(key,
     * null)&lt;/tt&gt;}.  If the return value is non-null, it is compared with
     * &lt;tt&gt;&quot;true&quot;&lt;/tt&gt; using {@link String#equalsIgnoreCase(String)}.  If the
     * comparison returns &lt;tt&gt;true&lt;/tt&gt;, this invocation returns
     * &lt;tt&gt;true&lt;/tt&gt;.  Otherwise, the original return value is compared with
     * &lt;tt&gt;&quot;false&quot;&lt;/tt&gt;, again using {@link String#equalsIgnoreCase(String)}.
     * If the comparison returns &lt;tt&gt;true&lt;/tt&gt;, this invocation returns
     * &lt;tt&gt;false&lt;/tt&gt;.  Otherwise, this invocation returns &lt;tt&gt;def&lt;/tt&gt;.
     *
     * @param key key whose associated value is to be returned as a boolean.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with &lt;tt&gt;key&lt;/tt&gt;
     *        or the associated value cannot be interpreted as a boolean.
     * @return the boolean value represented by the string associated with
     *         &lt;tt&gt;key&lt;/tt&gt; in this preference node, or &lt;tt&gt;def&lt;/tt&gt; if the
     *         associated value does not exist or cannot be interpreted as
     *         a boolean.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.
     */
    public boolean getBoolean(String key, boolean def) {
<span class="nc" id="L499">        boolean result = def;</span>
<span class="nc" id="L500">        String value = get(key, null);</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">            if (value.equalsIgnoreCase(&quot;true&quot;))</span>
<span class="nc" id="L503">                result = true;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">            else if (value.equalsIgnoreCase(&quot;false&quot;))</span>
<span class="nc" id="L505">                result = false;</span>
        }

<span class="nc" id="L508">        return result;</span>
    }

    /**
     * Implements the &lt;tt&gt;putFloat&lt;/tt&gt; method as per the specification in
     * {@link Preferences#putFloat(String,float)}.
     *
     * &lt;p&gt;This implementation translates &lt;tt&gt;value&lt;/tt&gt; to a string with
     * {@link Float#toString(float)} and invokes {@link #put(String,String)}
     * on the result.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key is &lt;tt&gt;null&lt;/tt&gt;.
     * @throws IllegalArgumentException if &lt;tt&gt;key.length()&lt;/tt&gt; exceeds
     *         &lt;tt&gt;MAX_KEY_LENGTH&lt;/tt&gt;.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */
    public void putFloat(String key, float value) {
<span class="nc" id="L528">        put(key, Float.toString(value));</span>
<span class="nc" id="L529">    }</span>

    /**
     * Implements the &lt;tt&gt;getFloat&lt;/tt&gt; method as per the specification in
     * {@link Preferences#getFloat(String,float)}.
     *
     * &lt;p&gt;This implementation invokes {@link #get(String,String) &lt;tt&gt;get(key,
     * null)&lt;/tt&gt;}.  If the return value is non-null, the implementation
     * attempts to translate it to an &lt;tt&gt;float&lt;/tt&gt; with
     * {@link Float#parseFloat(String)}.  If the attempt succeeds, the return
     * value is returned by this method.  Otherwise, &lt;tt&gt;def&lt;/tt&gt; is returned.
     *
     * @param key key whose associated value is to be returned as a float.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with &lt;tt&gt;key&lt;/tt&gt;
     *        or the associated value cannot be interpreted as a float.
     * @return the float value represented by the string associated with
     *         &lt;tt&gt;key&lt;/tt&gt; in this preference node, or &lt;tt&gt;def&lt;/tt&gt; if the
     *         associated value does not exist or cannot be interpreted as
     *         a float.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.
     */
    public float getFloat(String key, float def) {
<span class="nc" id="L554">        float result = def;</span>
        try {
<span class="nc" id="L556">            String value = get(key, null);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            if (value != null)</span>
<span class="nc" id="L558">                result = Float.parseFloat(value);</span>
<span class="nc" id="L559">        } catch (NumberFormatException e) {</span>
            // Ignoring exception causes specified default to be returned
<span class="nc" id="L561">        }</span>

<span class="nc" id="L563">        return result;</span>
    }

    /**
     * Implements the &lt;tt&gt;putDouble&lt;/tt&gt; method as per the specification in
     * {@link Preferences#putDouble(String,double)}.
     *
     * &lt;p&gt;This implementation translates &lt;tt&gt;value&lt;/tt&gt; to a string with
     * {@link Double#toString(double)} and invokes {@link #put(String,String)}
     * on the result.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key is &lt;tt&gt;null&lt;/tt&gt;.
     * @throws IllegalArgumentException if &lt;tt&gt;key.length()&lt;/tt&gt; exceeds
     *         &lt;tt&gt;MAX_KEY_LENGTH&lt;/tt&gt;.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */
    public void putDouble(String key, double value) {
<span class="nc" id="L583">        put(key, Double.toString(value));</span>
<span class="nc" id="L584">    }</span>

    /**
     * Implements the &lt;tt&gt;getDouble&lt;/tt&gt; method as per the specification in
     * {@link Preferences#getDouble(String,double)}.
     *
     * &lt;p&gt;This implementation invokes {@link #get(String,String) &lt;tt&gt;get(key,
     * null)&lt;/tt&gt;}.  If the return value is non-null, the implementation
     * attempts to translate it to an &lt;tt&gt;double&lt;/tt&gt; with
     * {@link Double#parseDouble(String)}.  If the attempt succeeds, the return
     * value is returned by this method.  Otherwise, &lt;tt&gt;def&lt;/tt&gt; is returned.
     *
     * @param key key whose associated value is to be returned as a double.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with &lt;tt&gt;key&lt;/tt&gt;
     *        or the associated value cannot be interpreted as a double.
     * @return the double value represented by the string associated with
     *         &lt;tt&gt;key&lt;/tt&gt; in this preference node, or &lt;tt&gt;def&lt;/tt&gt; if the
     *         associated value does not exist or cannot be interpreted as
     *         a double.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.
     */
    public double getDouble(String key, double def) {
<span class="nc" id="L609">        double result = def;</span>
        try {
<span class="nc" id="L611">            String value = get(key, null);</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (value != null)</span>
<span class="nc" id="L613">                result = Double.parseDouble(value);</span>
<span class="nc" id="L614">        } catch (NumberFormatException e) {</span>
            // Ignoring exception causes specified default to be returned
<span class="nc" id="L616">        }</span>

<span class="nc" id="L618">        return result;</span>
    }

    /**
     * Implements the &lt;tt&gt;putByteArray&lt;/tt&gt; method as per the specification in
     * {@link Preferences#putByteArray(String,byte[])}.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key or value is &lt;tt&gt;null&lt;/tt&gt;.
     * @throws IllegalArgumentException if key.length() exceeds MAX_KEY_LENGTH
     *         or if value.length exceeds MAX_VALUE_LENGTH*3/4.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */
    public void putByteArray(String key, byte[] value) {
<span class="nc" id="L634">        put(key, Base64.byteArrayToBase64(value));</span>
<span class="nc" id="L635">    }</span>

    /**
     * Implements the &lt;tt&gt;getByteArray&lt;/tt&gt; method as per the specification in
     * {@link Preferences#getByteArray(String,byte[])}.
     *
     * @param key key whose associated value is to be returned as a byte array.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with &lt;tt&gt;key&lt;/tt&gt;
     *        or the associated value cannot be interpreted as a byte array.
     * @return the byte array value represented by the string associated with
     *         &lt;tt&gt;key&lt;/tt&gt; in this preference node, or &lt;tt&gt;def&lt;/tt&gt; if the
     *         associated value does not exist or cannot be interpreted as
     *         a byte array.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if &lt;tt&gt;key&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.  (A
     *         &lt;tt&gt;null&lt;/tt&gt; value for &lt;tt&gt;def&lt;/tt&gt; &lt;i&gt;is&lt;/i&gt; permitted.)
     */
    public byte[] getByteArray(String key, byte[] def) {
<span class="nc" id="L655">        byte[] result = def;</span>
<span class="nc" id="L656">        String value = get(key, null);</span>
        try {
<span class="nc bnc" id="L658" title="All 2 branches missed.">            if (value != null)</span>
<span class="nc" id="L659">                result = Base64.base64ToByteArray(value);</span>
        }
<span class="nc" id="L661">        catch (RuntimeException e) {</span>
            // Ignoring exception causes specified default to be returned
<span class="nc" id="L663">        }</span>

<span class="nc" id="L665">        return result;</span>
    }

    /**
     * Implements the &lt;tt&gt;keys&lt;/tt&gt; method as per the specification in
     * {@link Preferences#keys()}.
     *
     * &lt;p&gt;This implementation obtains this preference node's lock, checks that
     * the node has not been removed and invokes {@link #keysSpi()}.
     *
     * @return an array of the keys that have an associated value in this
     *         preference node.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */
    public String[] keys() throws BackingStoreException {
<span class="fc" id="L684">        synchronized(lock) {</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">            if (removed)</span>
<span class="nc" id="L686">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>

<span class="fc" id="L688">            return keysSpi();</span>
<span class="nc" id="L689">        }</span>
    }

    /**
     * Implements the &lt;tt&gt;children&lt;/tt&gt; method as per the specification in
     * {@link Preferences#childrenNames()}.
     *
     * &lt;p&gt;This implementation obtains this preference node's lock, checks that
     * the node has not been removed, constructs a &lt;tt&gt;TreeSet&lt;/tt&gt; initialized
     * to the names of children already cached (the children in this node's
     * &quot;child-cache&quot;), invokes {@link #childrenNamesSpi()}, and adds all of the
     * returned child-names into the set.  The elements of the tree set are
     * dumped into a &lt;tt&gt;String&lt;/tt&gt; array using the &lt;tt&gt;toArray&lt;/tt&gt; method,
     * and this array is returned.
     *
     * @return the names of the children of this preference node.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @see #cachedChildren()
     */
    public String[] childrenNames() throws BackingStoreException {
<span class="fc" id="L713">        synchronized(lock) {</span>
<span class="pc bpc" id="L714" title="1 of 2 branches missed.">            if (removed)</span>
<span class="nc" id="L715">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>

<span class="fc" id="L717">            Set&lt;String&gt; s = new TreeSet&lt;&gt;(kidCache.keySet());</span>
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">            for (String kid : childrenNamesSpi())</span>
<span class="nc" id="L719">                s.add(kid);</span>
<span class="fc" id="L720">            return s.toArray(EMPTY_STRING_ARRAY);</span>
<span class="nc" id="L721">        }</span>
    }

<span class="fc" id="L724">    private static final String[] EMPTY_STRING_ARRAY = new String[0];</span>

    /**
     * Returns all known unremoved children of this node.
     *
     * @return all known unremoved children of this node.
     */
    protected final AbstractPreferences[] cachedChildren() {
<span class="fc" id="L732">        return kidCache.values().toArray(EMPTY_ABSTRACT_PREFS_ARRAY);</span>
    }

<span class="fc" id="L735">    private static final AbstractPreferences[] EMPTY_ABSTRACT_PREFS_ARRAY</span>
        = new AbstractPreferences[0];

    /**
     * Implements the &lt;tt&gt;parent&lt;/tt&gt; method as per the specification in
     * {@link Preferences#parent()}.
     *
     * &lt;p&gt;This implementation obtains this preference node's lock, checks that
     * the node has not been removed and returns the parent value that was
     * passed to this node's constructor.
     *
     * @return the parent of this preference node.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */
    public Preferences parent() {
<span class="fc" id="L751">        synchronized(lock) {</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">            if (removed)</span>
<span class="nc" id="L753">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>

<span class="fc" id="L755">            return parent;</span>
<span class="nc" id="L756">        }</span>
    }

    /**
     * Implements the &lt;tt&gt;node&lt;/tt&gt; method as per the specification in
     * {@link Preferences#node(String)}.
     *
     * &lt;p&gt;This implementation obtains this preference node's lock and checks
     * that the node has not been removed.  If &lt;tt&gt;path&lt;/tt&gt; is &lt;tt&gt;&quot;&quot;&lt;/tt&gt;,
     * this node is returned; if &lt;tt&gt;path&lt;/tt&gt; is &lt;tt&gt;&quot;/&quot;&lt;/tt&gt;, this node's
     * root is returned.  If the first character in &lt;tt&gt;path&lt;/tt&gt; is
     * not &lt;tt&gt;'/'&lt;/tt&gt;, the implementation breaks &lt;tt&gt;path&lt;/tt&gt; into
     * tokens and recursively traverses the path from this node to the
     * named node, &quot;consuming&quot; a name and a slash from &lt;tt&gt;path&lt;/tt&gt; at
     * each step of the traversal.  At each step, the current node is locked
     * and the node's child-cache is checked for the named node.  If it is
     * not found, the name is checked to make sure its length does not
     * exceed &lt;tt&gt;MAX_NAME_LENGTH&lt;/tt&gt;.  Then the {@link #childSpi(String)}
     * method is invoked, and the result stored in this node's child-cache.
     * If the newly created &lt;tt&gt;Preferences&lt;/tt&gt; object's {@link #newNode}
     * field is &lt;tt&gt;true&lt;/tt&gt; and there are any node change listeners,
     * a notification event is enqueued for processing by the event dispatch
     * thread.
     *
     * &lt;p&gt;When there are no more tokens, the last value found in the
     * child-cache or returned by &lt;tt&gt;childSpi&lt;/tt&gt; is returned by this
     * method.  If during the traversal, two &lt;tt&gt;&quot;/&quot;&lt;/tt&gt; tokens occur
     * consecutively, or the final token is &lt;tt&gt;&quot;/&quot;&lt;/tt&gt; (rather than a name),
     * an appropriate &lt;tt&gt;IllegalArgumentException&lt;/tt&gt; is thrown.
     *
     * &lt;p&gt; If the first character of &lt;tt&gt;path&lt;/tt&gt; is &lt;tt&gt;'/'&lt;/tt&gt;
     * (indicating an absolute path name) this preference node's
     * lock is dropped prior to breaking &lt;tt&gt;path&lt;/tt&gt; into tokens, and
     * this method recursively traverses the path starting from the root
     * (rather than starting from this node).  The traversal is otherwise
     * identical to the one described for relative path names.  Dropping
     * the lock on this node prior to commencing the traversal at the root
     * node is essential to avoid the possibility of deadlock, as per the
     * {@link #lock locking invariant}.
     *
     * @param path the path name of the preference node to return.
     * @return the specified preference node.
     * @throws IllegalArgumentException if the path name is invalid (i.e.,
     *         it contains multiple consecutive slash characters, or ends
     *         with a slash character and is more than one character long).
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */
    public Preferences node(String path) {
<span class="fc" id="L805">        synchronized(lock) {</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">            if (removed)</span>
<span class="nc" id="L807">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">            if (path.equals(&quot;&quot;))</span>
<span class="nc" id="L809">                return this;</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">            if (path.equals(&quot;/&quot;))</span>
<span class="nc" id="L811">                return root;</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">            if (path.charAt(0) != '/')</span>
<span class="fc" id="L813">                return node(new StringTokenizer(path, &quot;/&quot;, true));</span>
<span class="pc" id="L814">        }</span>

        // Absolute path.  Note that we've dropped our lock to avoid deadlock
<span class="fc" id="L817">        return root.node(new StringTokenizer(path.substring(1), &quot;/&quot;, true));</span>
    }

    /**
     * tokenizer contains &lt;name&gt; {'/' &lt;name&gt;}*
     */
    private Preferences node(StringTokenizer path) {
<span class="fc" id="L824">        String token = path.nextToken();</span>
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">        if (token.equals(&quot;/&quot;))  // Check for consecutive slashes</span>
<span class="nc" id="L826">            throw new IllegalArgumentException(&quot;Consecutive slashes in path&quot;);</span>
<span class="fc" id="L827">        synchronized(lock) {</span>
<span class="fc" id="L828">            AbstractPreferences child = kidCache.get(token);</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">            if (child == null) {</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">                if (token.length() &gt; MAX_NAME_LENGTH)</span>
<span class="nc" id="L831">                    throw new IllegalArgumentException(</span>
                        &quot;Node name &quot; + token + &quot; too long&quot;);
<span class="fc" id="L833">                child = childSpi(token);</span>
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">                if (child.newNode)</span>
<span class="fc" id="L835">                    enqueueNodeAddedEvent(child);</span>
<span class="fc" id="L836">                kidCache.put(token, child);</span>
            }
<span class="fc bfc" id="L838" title="All 2 branches covered.">            if (!path.hasMoreTokens())</span>
<span class="fc" id="L839">                return child;</span>
<span class="fc" id="L840">            path.nextToken();  // Consume slash</span>
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">            if (!path.hasMoreTokens())</span>
<span class="nc" id="L842">                throw new IllegalArgumentException(&quot;Path ends with slash&quot;);</span>
<span class="fc" id="L843">            return child.node(path);</span>
<span class="nc" id="L844">        }</span>
    }

    /**
     * Implements the &lt;tt&gt;nodeExists&lt;/tt&gt; method as per the specification in
     * {@link Preferences#nodeExists(String)}.
     *
     * &lt;p&gt;This implementation is very similar to {@link #node(String)},
     * except that {@link #getChild(String)} is used instead of {@link
     * #childSpi(String)}.
     *
     * @param path the path name of the node whose existence is to be checked.
     * @return true if the specified node exists.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @throws IllegalArgumentException if the path name is invalid (i.e.,
     *         it contains multiple consecutive slash characters, or ends
     *         with a slash character and is more than one character long).
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method and
     *         &lt;tt&gt;pathname&lt;/tt&gt; is not the empty string (&lt;tt&gt;&quot;&quot;&lt;/tt&gt;).
     */
    public boolean nodeExists(String path)
        throws BackingStoreException
    {
<span class="nc" id="L870">        synchronized(lock) {</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">            if (path.equals(&quot;&quot;))</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">                return !removed;</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">            if (removed)</span>
<span class="nc" id="L874">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">            if (path.equals(&quot;/&quot;))</span>
<span class="nc" id="L876">                return true;</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">            if (path.charAt(0) != '/')</span>
<span class="nc" id="L878">                return nodeExists(new StringTokenizer(path, &quot;/&quot;, true));</span>
<span class="nc" id="L879">        }</span>

        // Absolute path.  Note that we've dropped our lock to avoid deadlock
<span class="nc" id="L882">        return root.nodeExists(new StringTokenizer(path.substring(1), &quot;/&quot;,</span>
                                                   true));
    }

    /**
     * tokenizer contains &lt;name&gt; {'/' &lt;name&gt;}*
     */
    private boolean nodeExists(StringTokenizer path)
        throws BackingStoreException
    {
<span class="nc" id="L892">        String token = path.nextToken();</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">        if (token.equals(&quot;/&quot;))  // Check for consecutive slashes</span>
<span class="nc" id="L894">            throw new IllegalArgumentException(&quot;Consecutive slashes in path&quot;);</span>
<span class="nc" id="L895">        synchronized(lock) {</span>
<span class="nc" id="L896">            AbstractPreferences child = kidCache.get(token);</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">            if (child == null)</span>
<span class="nc" id="L898">                child = getChild(token);</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            if (child==null)</span>
<span class="nc" id="L900">                return false;</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">            if (!path.hasMoreTokens())</span>
<span class="nc" id="L902">                return true;</span>
<span class="nc" id="L903">            path.nextToken();  // Consume slash</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">            if (!path.hasMoreTokens())</span>
<span class="nc" id="L905">                throw new IllegalArgumentException(&quot;Path ends with slash&quot;);</span>
<span class="nc" id="L906">            return child.nodeExists(path);</span>
<span class="nc" id="L907">        }</span>
    }

    /**

     * Implements the &lt;tt&gt;removeNode()&lt;/tt&gt; method as per the specification in
     * {@link Preferences#removeNode()}.
     *
     * &lt;p&gt;This implementation checks to see that this node is the root; if so,
     * it throws an appropriate exception.  Then, it locks this node's parent,
     * and calls a recursive helper method that traverses the subtree rooted at
     * this node.  The recursive method locks the node on which it was called,
     * checks that it has not already been removed, and then ensures that all
     * of its children are cached: The {@link #childrenNamesSpi()} method is
     * invoked and each returned child name is checked for containment in the
     * child-cache.  If a child is not already cached, the {@link
     * #childSpi(String)} method is invoked to create a &lt;tt&gt;Preferences&lt;/tt&gt;
     * instance for it, and this instance is put into the child-cache.  Then
     * the helper method calls itself recursively on each node contained in its
     * child-cache.  Next, it invokes {@link #removeNodeSpi()}, marks itself
     * as removed, and removes itself from its parent's child-cache.  Finally,
     * if there are any node change listeners, it enqueues a notification
     * event for processing by the event dispatch thread.
     *
     * &lt;p&gt;Note that the helper method is always invoked with all ancestors up
     * to the &quot;closest non-removed ancestor&quot; locked.
     *
     * @throws IllegalStateException if this node (or an ancestor) has already
     *         been removed with the {@link #removeNode()} method.
     * @throws UnsupportedOperationException if this method is invoked on
     *         the root node.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     */
    public void removeNode() throws BackingStoreException {
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">        if (this==root)</span>
<span class="nc" id="L944">            throw new UnsupportedOperationException(&quot;Can't remove the root!&quot;);</span>
<span class="fc" id="L945">        synchronized(parent.lock) {</span>
<span class="fc" id="L946">            removeNode2();</span>
<span class="fc" id="L947">            parent.kidCache.remove(name);</span>
<span class="pc" id="L948">        }</span>
<span class="fc" id="L949">    }</span>

    /*
     * Called with locks on all nodes on path from parent of &quot;removal root&quot;
     * to this (including the former but excluding the latter).
     */
    private void removeNode2() throws BackingStoreException {
<span class="fc" id="L956">        synchronized(lock) {</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">            if (removed)</span>
<span class="nc" id="L958">                throw new IllegalStateException(&quot;Node already removed.&quot;);</span>

            // Ensure that all children are cached
<span class="fc" id="L961">            String[] kidNames = childrenNamesSpi();</span>
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">            for (int i=0; i&lt;kidNames.length; i++)</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">                if (!kidCache.containsKey(kidNames[i]))</span>
<span class="nc" id="L964">                    kidCache.put(kidNames[i], childSpi(kidNames[i]));</span>

            // Recursively remove all cached children
<span class="fc" id="L967">            for (Iterator&lt;AbstractPreferences&gt; i = kidCache.values().iterator();</span>
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">                 i.hasNext();) {</span>
                try {
<span class="nc" id="L970">                    i.next().removeNode2();</span>
<span class="nc" id="L971">                    i.remove();</span>
<span class="nc" id="L972">                } catch (BackingStoreException x) { }</span>
            }

            // Now we have no descendants - it's time to die!
<span class="fc" id="L976">            removeNodeSpi();</span>
<span class="fc" id="L977">            removed = true;</span>
<span class="fc" id="L978">            parent.enqueueNodeRemovedEvent(this);</span>
<span class="pc" id="L979">        }</span>
<span class="fc" id="L980">    }</span>

    /**
     * Implements the &lt;tt&gt;name&lt;/tt&gt; method as per the specification in
     * {@link Preferences#name()}.
     *
     * &lt;p&gt;This implementation merely returns the name that was
     * passed to this node's constructor.
     *
     * @return this preference node's name, relative to its parent.
     */
    public String name() {
<span class="fc" id="L992">        return name;</span>
    }

    /**
     * Implements the &lt;tt&gt;absolutePath&lt;/tt&gt; method as per the specification in
     * {@link Preferences#absolutePath()}.
     *
     * &lt;p&gt;This implementation merely returns the absolute path name that
     * was computed at the time that this node was constructed (based on
     * the name that was passed to this node's constructor, and the names
     * that were passed to this node's ancestors' constructors).
     *
     * @return this preference node's absolute path name.
     */
    public String absolutePath() {
<span class="fc" id="L1007">        return absolutePath;</span>
    }

    /**
     * Implements the &lt;tt&gt;isUserNode&lt;/tt&gt; method as per the specification in
     * {@link Preferences#isUserNode()}.
     *
     * &lt;p&gt;This implementation compares this node's root node (which is stored
     * in a private field) with the value returned by
     * {@link Preferences#userRoot()}.  If the two object references are
     * identical, this method returns true.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if this preference node is in the user
     *         preference tree, &lt;tt&gt;false&lt;/tt&gt; if it's in the system
     *         preference tree.
     */
    public boolean isUserNode() {
<span class="nc" id="L1024">        return AccessController.doPrivileged(</span>
<span class="nc" id="L1025">            new PrivilegedAction&lt;Boolean&gt;() {</span>
                public Boolean run() {
<span class="nc bnc" id="L1027" title="All 2 branches missed.">                    return root == Preferences.userRoot();</span>
            }
<span class="nc" id="L1029">            }).booleanValue();</span>
    }

    public void addPreferenceChangeListener(PreferenceChangeListener pcl) {
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (pcl==null)</span>
<span class="nc" id="L1034">            throw new NullPointerException(&quot;Change listener is null.&quot;);</span>
<span class="nc" id="L1035">        synchronized(lock) {</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">            if (removed)</span>
<span class="nc" id="L1037">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>

            // Copy-on-write
<span class="nc" id="L1040">            PreferenceChangeListener[] old = prefListeners;</span>
<span class="nc" id="L1041">            prefListeners = new PreferenceChangeListener[old.length + 1];</span>
<span class="nc" id="L1042">            System.arraycopy(old, 0, prefListeners, 0, old.length);</span>
<span class="nc" id="L1043">            prefListeners[old.length] = pcl;</span>
<span class="nc" id="L1044">        }</span>
<span class="nc" id="L1045">        startEventDispatchThreadIfNecessary();</span>
<span class="nc" id="L1046">    }</span>

    public void removePreferenceChangeListener(PreferenceChangeListener pcl) {
<span class="nc" id="L1049">        synchronized(lock) {</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            if (removed)</span>
<span class="nc" id="L1051">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>
<span class="nc bnc" id="L1052" title="All 4 branches missed.">            if ((prefListeners == null) || (prefListeners.length == 0))</span>
<span class="nc" id="L1053">                throw new IllegalArgumentException(&quot;Listener not registered.&quot;);</span>

            // Copy-on-write
<span class="nc" id="L1056">            PreferenceChangeListener[] newPl =</span>
                new PreferenceChangeListener[prefListeners.length - 1];
<span class="nc" id="L1058">            int i = 0;</span>
<span class="nc bnc" id="L1059" title="All 4 branches missed.">            while (i &lt; newPl.length &amp;&amp; prefListeners[i] != pcl)</span>
<span class="nc" id="L1060">                newPl[i] = prefListeners[i++];</span>

<span class="nc bnc" id="L1062" title="All 4 branches missed.">            if (i == newPl.length &amp;&amp;  prefListeners[i] != pcl)</span>
<span class="nc" id="L1063">                throw new IllegalArgumentException(&quot;Listener not registered.&quot;);</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">            while (i &lt; newPl.length)</span>
<span class="nc" id="L1065">                newPl[i] = prefListeners[++i];</span>
<span class="nc" id="L1066">            prefListeners = newPl;</span>
<span class="nc" id="L1067">        }</span>
<span class="nc" id="L1068">    }</span>

    public void addNodeChangeListener(NodeChangeListener ncl) {
<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">        if (ncl==null)</span>
<span class="nc" id="L1072">            throw new NullPointerException(&quot;Change listener is null.&quot;);</span>
<span class="fc" id="L1073">        synchronized(lock) {</span>
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">            if (removed)</span>
<span class="nc" id="L1075">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>

            // Copy-on-write
<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">            if (nodeListeners == null) {</span>
<span class="nc" id="L1079">                nodeListeners = new NodeChangeListener[1];</span>
<span class="nc" id="L1080">                nodeListeners[0] = ncl;</span>
            } else {
<span class="fc" id="L1082">                NodeChangeListener[] old = nodeListeners;</span>
<span class="fc" id="L1083">                nodeListeners = new NodeChangeListener[old.length + 1];</span>
<span class="fc" id="L1084">                System.arraycopy(old, 0, nodeListeners, 0, old.length);</span>
<span class="fc" id="L1085">                nodeListeners[old.length] = ncl;</span>
            }
<span class="pc" id="L1087">        }</span>
<span class="fc" id="L1088">        startEventDispatchThreadIfNecessary();</span>
<span class="fc" id="L1089">    }</span>

    public void removeNodeChangeListener(NodeChangeListener ncl) {
<span class="nc" id="L1092">        synchronized(lock) {</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">            if (removed)</span>
<span class="nc" id="L1094">                throw new IllegalStateException(&quot;Node has been removed.&quot;);</span>
<span class="nc bnc" id="L1095" title="All 4 branches missed.">            if ((nodeListeners == null) || (nodeListeners.length == 0))</span>
<span class="nc" id="L1096">                throw new IllegalArgumentException(&quot;Listener not registered.&quot;);</span>

            // Copy-on-write
<span class="nc" id="L1099">            int i = 0;</span>
<span class="nc bnc" id="L1100" title="All 4 branches missed.">            while (i &lt; nodeListeners.length &amp;&amp; nodeListeners[i] != ncl)</span>
<span class="nc" id="L1101">                i++;</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">            if (i == nodeListeners.length)</span>
<span class="nc" id="L1103">                throw new IllegalArgumentException(&quot;Listener not registered.&quot;);</span>
<span class="nc" id="L1104">            NodeChangeListener[] newNl =</span>
                new NodeChangeListener[nodeListeners.length - 1];
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            if (i != 0)</span>
<span class="nc" id="L1107">                System.arraycopy(nodeListeners, 0, newNl, 0, i);</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">            if (i != newNl.length)</span>
<span class="nc" id="L1109">                System.arraycopy(nodeListeners, i + 1,</span>
                                 newNl, i, newNl.length - i);
<span class="nc" id="L1111">            nodeListeners = newNl;</span>
<span class="nc" id="L1112">        }</span>
<span class="nc" id="L1113">    }</span>

    // &quot;SPI&quot; METHODS

    /**
     * Put the given key-value association into this preference node.  It is
     * guaranteed that &lt;tt&gt;key&lt;/tt&gt; and &lt;tt&gt;value&lt;/tt&gt; are non-null and of
     * legal length.  Also, it is guaranteed that this node has not been
     * removed.  (The implementor needn't check for any of these things.)
     *
     * &lt;p&gt;This method is invoked with the lock on this node held.
     * @param key the key
     * @param value the value
     */
    protected abstract void putSpi(String key, String value);

    /**
     * Return the value associated with the specified key at this preference
     * node, or &lt;tt&gt;null&lt;/tt&gt; if there is no association for this key, or the
     * association cannot be determined at this time.  It is guaranteed that
     * &lt;tt&gt;key&lt;/tt&gt; is non-null.  Also, it is guaranteed that this node has
     * not been removed.  (The implementor needn't check for either of these
     * things.)
     *
     * &lt;p&gt; Generally speaking, this method should not throw an exception
     * under any circumstances.  If, however, if it does throw an exception,
     * the exception will be intercepted and treated as a &lt;tt&gt;null&lt;/tt&gt;
     * return value.
     *
     * &lt;p&gt;This method is invoked with the lock on this node held.
     *
     * @param key the key
     * @return the value associated with the specified key at this preference
     *          node, or &lt;tt&gt;null&lt;/tt&gt; if there is no association for this
     *          key, or the association cannot be determined at this time.
     */
    protected abstract String getSpi(String key);

    /**
     * Remove the association (if any) for the specified key at this
     * preference node.  It is guaranteed that &lt;tt&gt;key&lt;/tt&gt; is non-null.
     * Also, it is guaranteed that this node has not been removed.
     * (The implementor needn't check for either of these things.)
     *
     * &lt;p&gt;This method is invoked with the lock on this node held.
     * @param key the key
     */
    protected abstract void removeSpi(String key);

    /**
     * Removes this preference node, invalidating it and any preferences that
     * it contains.  The named child will have no descendants at the time this
     * invocation is made (i.e., the {@link Preferences#removeNode()} method
     * invokes this method repeatedly in a bottom-up fashion, removing each of
     * a node's descendants before removing the node itself).
     *
     * &lt;p&gt;This method is invoked with the lock held on this node and its
     * parent (and all ancestors that are being removed as a
     * result of a single invocation to {@link Preferences#removeNode()}).
     *
     * &lt;p&gt;The removal of a node needn't become persistent until the
     * &lt;tt&gt;flush&lt;/tt&gt; method is invoked on this node (or an ancestor).
     *
     * &lt;p&gt;If this node throws a &lt;tt&gt;BackingStoreException&lt;/tt&gt;, the exception
     * will propagate out beyond the enclosing {@link #removeNode()}
     * invocation.
     *
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     */
    protected abstract void removeNodeSpi() throws BackingStoreException;

    /**
     * Returns all of the keys that have an associated value in this
     * preference node.  (The returned array will be of size zero if
     * this node has no preferences.)  It is guaranteed that this node has not
     * been removed.
     *
     * &lt;p&gt;This method is invoked with the lock on this node held.
     *
     * &lt;p&gt;If this node throws a &lt;tt&gt;BackingStoreException&lt;/tt&gt;, the exception
     * will propagate out beyond the enclosing {@link #keys()} invocation.
     *
     * @return an array of the keys that have an associated value in this
     *         preference node.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     */
    protected abstract String[] keysSpi() throws BackingStoreException;

    /**
     * Returns the names of the children of this preference node.  (The
     * returned array will be of size zero if this node has no children.)
     * This method need not return the names of any nodes already cached,
     * but may do so without harm.
     *
     * &lt;p&gt;This method is invoked with the lock on this node held.
     *
     * &lt;p&gt;If this node throws a &lt;tt&gt;BackingStoreException&lt;/tt&gt;, the exception
     * will propagate out beyond the enclosing {@link #childrenNames()}
     * invocation.
     *
     * @return an array containing the names of the children of this
     *         preference node.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     */
    protected abstract String[] childrenNamesSpi()
        throws BackingStoreException;

    /**
     * Returns the named child if it exists, or &lt;tt&gt;null&lt;/tt&gt; if it does not.
     * It is guaranteed that &lt;tt&gt;nodeName&lt;/tt&gt; is non-null, non-empty,
     * does not contain the slash character ('/'), and is no longer than
     * {@link #MAX_NAME_LENGTH} characters.  Also, it is guaranteed
     * that this node has not been removed.  (The implementor needn't check
     * for any of these things if he chooses to override this method.)
     *
     * &lt;p&gt;Finally, it is guaranteed that the named node has not been returned
     * by a previous invocation of this method or {@link #childSpi} after the
     * last time that it was removed.  In other words, a cached value will
     * always be used in preference to invoking this method.  (The implementor
     * needn't maintain his own cache of previously returned children if he
     * chooses to override this method.)
     *
     * &lt;p&gt;This implementation obtains this preference node's lock, invokes
     * {@link #childrenNames()} to get an array of the names of this node's
     * children, and iterates over the array comparing the name of each child
     * with the specified node name.  If a child node has the correct name,
     * the {@link #childSpi(String)} method is invoked and the resulting
     * node is returned.  If the iteration completes without finding the
     * specified name, &lt;tt&gt;null&lt;/tt&gt; is returned.
     *
     * @param nodeName name of the child to be searched for.
     * @return the named child if it exists, or null if it does not.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     */
    protected AbstractPreferences getChild(String nodeName)
            throws BackingStoreException {
<span class="nc" id="L1257">        synchronized(lock) {</span>
            // assert kidCache.get(nodeName)==null;
<span class="nc" id="L1259">            String[] kidNames = childrenNames();</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">            for (int i=0; i&lt;kidNames.length; i++)</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">                if (kidNames[i].equals(nodeName))</span>
<span class="nc" id="L1262">                    return childSpi(kidNames[i]);</span>
<span class="nc" id="L1263">        }</span>
<span class="nc" id="L1264">        return null;</span>
    }

    /**
     * Returns the named child of this preference node, creating it if it does
     * not already exist.  It is guaranteed that &lt;tt&gt;name&lt;/tt&gt; is non-null,
     * non-empty, does not contain the slash character ('/'), and is no longer
     * than {@link #MAX_NAME_LENGTH} characters.  Also, it is guaranteed that
     * this node has not been removed.  (The implementor needn't check for any
     * of these things.)
     *
     * &lt;p&gt;Finally, it is guaranteed that the named node has not been returned
     * by a previous invocation of this method or {@link #getChild(String)}
     * after the last time that it was removed.  In other words, a cached
     * value will always be used in preference to invoking this method.
     * Subclasses need not maintain their own cache of previously returned
     * children.
     *
     * &lt;p&gt;The implementer must ensure that the returned node has not been
     * removed.  If a like-named child of this node was previously removed, the
     * implementer must return a newly constructed &lt;tt&gt;AbstractPreferences&lt;/tt&gt;
     * node; once removed, an &lt;tt&gt;AbstractPreferences&lt;/tt&gt; node
     * cannot be &quot;resuscitated.&quot;
     *
     * &lt;p&gt;If this method causes a node to be created, this node is not
     * guaranteed to be persistent until the &lt;tt&gt;flush&lt;/tt&gt; method is
     * invoked on this node or one of its ancestors (or descendants).
     *
     * &lt;p&gt;This method is invoked with the lock on this node held.
     *
     * @param name The name of the child node to return, relative to
     *        this preference node.
     * @return The named child node.
     */
    protected abstract AbstractPreferences childSpi(String name);

    /**
     * Returns the absolute path name of this preferences node.
     */
    public String toString() {
<span class="nc bnc" id="L1304" title="All 2 branches missed.">        return (this.isUserNode() ? &quot;User&quot; : &quot;System&quot;) +</span>
<span class="nc" id="L1305">               &quot; Preference Node: &quot; + this.absolutePath();</span>
    }

    /**
     * Implements the &lt;tt&gt;sync&lt;/tt&gt; method as per the specification in
     * {@link Preferences#sync()}.
     *
     * &lt;p&gt;This implementation calls a recursive helper method that locks this
     * node, invokes syncSpi() on it, unlocks this node, and recursively
     * invokes this method on each &quot;cached child.&quot;  A cached child is a child
     * of this node that has been created in this VM and not subsequently
     * removed.  In effect, this method does a depth first traversal of the
     * &quot;cached subtree&quot; rooted at this node, calling syncSpi() on each node in
     * the subTree while only that node is locked. Note that syncSpi() is
     * invoked top-down.
     *
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @see #flush()
     */
    public void sync() throws BackingStoreException {
<span class="fc" id="L1329">        sync2();</span>
<span class="fc" id="L1330">    }</span>

    private void sync2() throws BackingStoreException {
        AbstractPreferences[] cachedKids;

<span class="fc" id="L1335">        synchronized(lock) {</span>
<span class="pc bpc" id="L1336" title="1 of 2 branches missed.">            if (removed)</span>
<span class="nc" id="L1337">                throw new IllegalStateException(&quot;Node has been removed&quot;);</span>
<span class="fc" id="L1338">            syncSpi();</span>
<span class="fc" id="L1339">            cachedKids = cachedChildren();</span>
<span class="fc" id="L1340">        }</span>

<span class="pc bpc" id="L1342" title="1 of 2 branches missed.">        for (int i=0; i&lt;cachedKids.length; i++)</span>
<span class="nc" id="L1343">            cachedKids[i].sync2();</span>
<span class="fc" id="L1344">    }</span>

    /**
     * This method is invoked with this node locked.  The contract of this
     * method is to synchronize any cached preferences stored at this node
     * with any stored in the backing store.  (It is perfectly possible that
     * this node does not exist on the backing store, either because it has
     * been deleted by another VM, or because it has not yet been created.)
     * Note that this method should &lt;i&gt;not&lt;/i&gt; synchronize the preferences in
     * any subnodes of this node.  If the backing store naturally syncs an
     * entire subtree at once, the implementer is encouraged to override
     * sync(), rather than merely overriding this method.
     *
     * &lt;p&gt;If this node throws a &lt;tt&gt;BackingStoreException&lt;/tt&gt;, the exception
     * will propagate out beyond the enclosing {@link #sync()} invocation.
     *
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     */
    protected abstract void syncSpi() throws BackingStoreException;

    /**
     * Implements the &lt;tt&gt;flush&lt;/tt&gt; method as per the specification in
     * {@link Preferences#flush()}.
     *
     * &lt;p&gt;This implementation calls a recursive helper method that locks this
     * node, invokes flushSpi() on it, unlocks this node, and recursively
     * invokes this method on each &quot;cached child.&quot;  A cached child is a child
     * of this node that has been created in this VM and not subsequently
     * removed.  In effect, this method does a depth first traversal of the
     * &quot;cached subtree&quot; rooted at this node, calling flushSpi() on each node in
     * the subTree while only that node is locked. Note that flushSpi() is
     * invoked top-down.
     *
     * &lt;p&gt; If this method is invoked on a node that has been removed with
     * the {@link #removeNode()} method, flushSpi() is invoked on this node,
     * but not on others.
     *
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @see #flush()
     */
    public void flush() throws BackingStoreException {
<span class="nc" id="L1389">        flush2();</span>
<span class="nc" id="L1390">    }</span>

    private void flush2() throws BackingStoreException {
        AbstractPreferences[] cachedKids;

<span class="nc" id="L1395">        synchronized(lock) {</span>
<span class="nc" id="L1396">            flushSpi();</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">            if(removed)</span>
<span class="nc" id="L1398">                return;</span>
<span class="nc" id="L1399">            cachedKids = cachedChildren();</span>
<span class="nc" id="L1400">        }</span>

<span class="nc bnc" id="L1402" title="All 2 branches missed.">        for (int i = 0; i &lt; cachedKids.length; i++)</span>
<span class="nc" id="L1403">            cachedKids[i].flush2();</span>
<span class="nc" id="L1404">    }</span>

    /**
     * This method is invoked with this node locked.  The contract of this
     * method is to force any cached changes in the contents of this
     * preference node to the backing store, guaranteeing their persistence.
     * (It is perfectly possible that this node does not exist on the backing
     * store, either because it has been deleted by another VM, or because it
     * has not yet been created.)  Note that this method should &lt;i&gt;not&lt;/i&gt;
     * flush the preferences in any subnodes of this node.  If the backing
     * store naturally flushes an entire subtree at once, the implementer is
     * encouraged to override flush(), rather than merely overriding this
     * method.
     *
     * &lt;p&gt;If this node throws a &lt;tt&gt;BackingStoreException&lt;/tt&gt;, the exception
     * will propagate out beyond the enclosing {@link #flush()} invocation.
     *
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     */
    protected abstract void flushSpi() throws BackingStoreException;

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; iff this node (or an ancestor) has been
     * removed with the {@link #removeNode()} method.  This method
     * locks this node prior to returning the contents of the private
     * field used to track this state.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; iff this node (or an ancestor) has been
     *       removed with the {@link #removeNode()} method.
     */
    protected boolean isRemoved() {
<span class="fc" id="L1437">        synchronized(lock) {</span>
<span class="fc" id="L1438">            return removed;</span>
<span class="nc" id="L1439">        }</span>
    }

    /**
     * Queue of pending notification events.  When a preference or node
     * change event for which there are one or more listeners occurs,
     * it is placed on this queue and the queue is notified.  A background
     * thread waits on this queue and delivers the events.  This decouples
     * event delivery from preference activity, greatly simplifying
     * locking and reducing opportunity for deadlock.
     */
<span class="fc" id="L1450">    private static final List&lt;EventObject&gt; eventQueue = new LinkedList&lt;&gt;();</span>

    /**
     * These two classes are used to distinguish NodeChangeEvents on
     * eventQueue so the event dispatch thread knows whether to call
     * childAdded or childRemoved.
     */
    private class NodeAddedEvent extends NodeChangeEvent {
        private static final long serialVersionUID = -6743557530157328528L;
<span class="fc" id="L1459">        NodeAddedEvent(Preferences parent, Preferences child) {</span>
<span class="fc" id="L1460">            super(parent, child);</span>
<span class="fc" id="L1461">        }</span>
    }
    private class NodeRemovedEvent extends NodeChangeEvent {
        private static final long serialVersionUID = 8735497392918824837L;
<span class="nc" id="L1465">        NodeRemovedEvent(Preferences parent, Preferences child) {</span>
<span class="nc" id="L1466">            super(parent, child);</span>
<span class="nc" id="L1467">        }</span>
    }

    /**
     * A single background thread (&quot;the event notification thread&quot;) monitors
     * the event queue and delivers events that are placed on the queue.
     */
<span class="fc" id="L1474">    private static class EventDispatchThread extends Thread {</span>
        public void run() {
            while(true) {
                // Wait on eventQueue till an event is present
<span class="fc" id="L1478">                EventObject event = null;</span>
<span class="fc" id="L1479">                synchronized(eventQueue) {</span>
                    try {
<span class="pc bpc" id="L1481" title="1 of 2 branches missed.">                        while (eventQueue.isEmpty())</span>
<span class="nc" id="L1482">                            eventQueue.wait();</span>
<span class="fc" id="L1483">                        event = eventQueue.remove(0);</span>
<span class="nc" id="L1484">                    } catch (InterruptedException e) {</span>
                        // XXX Log &quot;Event dispatch thread interrupted. Exiting&quot;
<span class="nc" id="L1486">                        return;</span>
<span class="fc" id="L1487">                    }</span>
<span class="pc" id="L1488">                }</span>

                // Now we have event &amp; hold no locks; deliver evt to listeners
<span class="fc" id="L1491">                AbstractPreferences src=(AbstractPreferences)event.getSource();</span>
<span class="pc bpc" id="L1492" title="1 of 2 branches missed.">                if (event instanceof PreferenceChangeEvent) {</span>
<span class="nc" id="L1493">                    PreferenceChangeEvent pce = (PreferenceChangeEvent)event;</span>
<span class="nc" id="L1494">                    PreferenceChangeListener[] listeners = src.prefListeners();</span>
<span class="nc bnc" id="L1495" title="All 2 branches missed.">                    for (int i=0; i&lt;listeners.length; i++)</span>
<span class="nc" id="L1496">                        listeners[i].preferenceChange(pce);</span>
<span class="nc" id="L1497">                } else {</span>
<span class="fc" id="L1498">                    NodeChangeEvent nce = (NodeChangeEvent)event;</span>
<span class="fc" id="L1499">                    NodeChangeListener[] listeners = src.nodeListeners();</span>
<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">                    if (nce instanceof NodeAddedEvent) {</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">                        for (int i=0; i&lt;listeners.length; i++)</span>
<span class="fc" id="L1502">                            listeners[i].childAdded(nce);</span>
                    } else {
                        // assert nce instanceof NodeRemovedEvent;
<span class="nc bnc" id="L1505" title="All 2 branches missed.">                        for (int i=0; i&lt;listeners.length; i++)</span>
<span class="nc" id="L1506">                            listeners[i].childRemoved(nce);</span>
                    }
                }
<span class="fc" id="L1509">            }</span>
        }
    }

<span class="fc" id="L1513">    private static Thread eventDispatchThread = null;</span>

    /**
     * This method starts the event dispatch thread the first time it
     * is called.  The event dispatch thread will be started only
     * if someone registers a listener.
     */
    private static synchronized void startEventDispatchThreadIfNecessary() {
<span class="pc bpc" id="L1521" title="1 of 2 branches missed.">        if (eventDispatchThread == null) {</span>
            // XXX Log &quot;Starting event dispatch thread&quot;
<span class="fc" id="L1523">            eventDispatchThread = new EventDispatchThread();</span>
<span class="fc" id="L1524">            eventDispatchThread.setDaemon(true);</span>
<span class="fc" id="L1525">            eventDispatchThread.start();</span>
        }
<span class="fc" id="L1527">    }</span>

    /**
     * Return this node's preference/node change listeners.  Even though
     * we're using a copy-on-write lists, we use synchronized accessors to
     * ensure information transmission from the writing thread to the
     * reading thread.
     */
    PreferenceChangeListener[] prefListeners() {
<span class="nc" id="L1536">        synchronized(lock) {</span>
<span class="nc" id="L1537">            return prefListeners;</span>
<span class="nc" id="L1538">        }</span>
    }
    NodeChangeListener[] nodeListeners() {
<span class="fc" id="L1541">        synchronized(lock) {</span>
<span class="fc" id="L1542">            return nodeListeners;</span>
<span class="nc" id="L1543">        }</span>
    }

    /**
     * Enqueue a preference change event for delivery to registered
     * preference change listeners unless there are no registered
     * listeners.  Invoked with this.lock held.
     */
    private void enqueuePreferenceChangeEvent(String key, String newValue) {
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">        if (prefListeners.length != 0) {</span>
<span class="nc" id="L1553">            synchronized(eventQueue) {</span>
<span class="nc" id="L1554">                eventQueue.add(new PreferenceChangeEvent(this, key, newValue));</span>
<span class="nc" id="L1555">                eventQueue.notify();</span>
<span class="nc" id="L1556">            }</span>
        }
<span class="fc" id="L1558">    }</span>

    /**
     * Enqueue a &quot;node added&quot; event for delivery to registered node change
     * listeners unless there are no registered listeners.  Invoked with
     * this.lock held.
     */
    private void enqueueNodeAddedEvent(Preferences child) {
<span class="fc bfc" id="L1566" title="All 2 branches covered.">        if (nodeListeners.length != 0) {</span>
<span class="fc" id="L1567">            synchronized(eventQueue) {</span>
<span class="fc" id="L1568">                eventQueue.add(new NodeAddedEvent(this, child));</span>
<span class="fc" id="L1569">                eventQueue.notify();</span>
<span class="pc" id="L1570">            }</span>
        }
<span class="fc" id="L1572">    }</span>

    /**
     * Enqueue a &quot;node removed&quot; event for delivery to registered node change
     * listeners unless there are no registered listeners.  Invoked with
     * this.lock held.
     */
    private void enqueueNodeRemovedEvent(Preferences child) {
<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">        if (nodeListeners.length != 0) {</span>
<span class="nc" id="L1581">            synchronized(eventQueue) {</span>
<span class="nc" id="L1582">                eventQueue.add(new NodeRemovedEvent(this, child));</span>
<span class="nc" id="L1583">                eventQueue.notify();</span>
<span class="nc" id="L1584">            }</span>
        }
<span class="fc" id="L1586">    }</span>

    /**
     * Implements the &lt;tt&gt;exportNode&lt;/tt&gt; method as per the specification in
     * {@link Preferences#exportNode(OutputStream)}.
     *
     * @param os the output stream on which to emit the XML document.
     * @throws IOException if writing to the specified output stream
     *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.
     * @throws BackingStoreException if preference data cannot be read from
     *         backing store.
     */
    public void exportNode(OutputStream os)
        throws IOException, BackingStoreException
    {
<span class="nc" id="L1601">        XmlSupport.export(os, this, false);</span>
<span class="nc" id="L1602">    }</span>

    /**
     * Implements the &lt;tt&gt;exportSubtree&lt;/tt&gt; method as per the specification in
     * {@link Preferences#exportSubtree(OutputStream)}.
     *
     * @param os the output stream on which to emit the XML document.
     * @throws IOException if writing to the specified output stream
     *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.
     * @throws BackingStoreException if preference data cannot be read from
     *         backing store.
     */
    public void exportSubtree(OutputStream os)
        throws IOException, BackingStoreException
    {
<span class="nc" id="L1617">        XmlSupport.export(os, this, true);</span>
<span class="nc" id="L1618">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>