<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>XmlSupport.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.prefs</a> &gt; <span class="el_source">XmlSupport.java</span></div><h1>XmlSupport.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util.prefs;

import java.util.*;
import java.io.*;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.*;
import org.xml.sax.*;
import org.w3c.dom.*;

/**
 * XML Support for java.util.prefs. Methods to import and export preference
 * nodes and subtrees.
 *
 * @author  Josh Bloch and Mark Reinhold
 * @see     Preferences
 * @since   1.4
 */
<span class="nc" id="L45">class XmlSupport {</span>
    // The required DTD URI for exported preferences
    private static final String PREFS_DTD_URI =
        &quot;http://java.sun.com/dtd/preferences.dtd&quot;;

    // The actual DTD corresponding to the URI
    private static final String PREFS_DTD =
        &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;&quot; +

        &quot;&lt;!-- DTD for preferences --&gt;&quot;               +

        &quot;&lt;!ELEMENT preferences (root) &gt;&quot;             +
        &quot;&lt;!ATTLIST preferences&quot;                      +
        &quot; EXTERNAL_XML_VERSION CDATA \&quot;0.0\&quot;  &gt;&quot;     +

        &quot;&lt;!ELEMENT root (map, node*) &gt;&quot;              +
        &quot;&lt;!ATTLIST root&quot;                             +
        &quot;          type (system|user) #REQUIRED &gt;&quot;   +

        &quot;&lt;!ELEMENT node (map, node*) &gt;&quot;              +
        &quot;&lt;!ATTLIST node&quot;                             +
        &quot;          name CDATA #REQUIRED &gt;&quot;           +

        &quot;&lt;!ELEMENT map (entry*) &gt;&quot;                   +
        &quot;&lt;!ATTLIST map&quot;                              +
        &quot;  MAP_XML_VERSION CDATA \&quot;0.0\&quot;  &gt;&quot;         +
        &quot;&lt;!ELEMENT entry EMPTY &gt;&quot;                    +
        &quot;&lt;!ATTLIST entry&quot;                            +
        &quot;          key CDATA #REQUIRED&quot;              +
        &quot;          value CDATA #REQUIRED &gt;&quot;          ;
    /**
     * Version number for the format exported preferences files.
     */
    private static final String EXTERNAL_XML_VERSION = &quot;1.0&quot;;

    /*
     * Version number for the internal map files.
     */
    private static final String MAP_XML_VERSION = &quot;1.0&quot;;

    /**
     * Export the specified preferences node and, if subTree is true, all
     * subnodes, to the specified output stream.  Preferences are exported as
     * an XML document conforming to the definition in the Preferences spec.
     *
     * @throws IOException if writing to the specified output stream
     *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.
     * @throws BackingStoreException if preference data cannot be read from
     *         backing store.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link Preferences#removeNode()} method.
     */
    static void export(OutputStream os, final Preferences p, boolean subTree)
        throws IOException, BackingStoreException {
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (((AbstractPreferences)p).isRemoved())</span>
<span class="nc" id="L100">            throw new IllegalStateException(&quot;Node has been removed&quot;);</span>
<span class="fc" id="L101">        Document doc = createPrefsDoc(&quot;preferences&quot;);</span>
<span class="fc" id="L102">        Element preferences =  doc.getDocumentElement() ;</span>
<span class="fc" id="L103">        preferences.setAttribute(&quot;EXTERNAL_XML_VERSION&quot;, EXTERNAL_XML_VERSION);</span>
<span class="fc" id="L104">        Element xmlRoot =  (Element)</span>
<span class="fc" id="L105">        preferences.appendChild(doc.createElement(&quot;root&quot;));</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        xmlRoot.setAttribute(&quot;type&quot;, (p.isUserNode() ? &quot;user&quot; : &quot;system&quot;));</span>

        // Get bottom-up list of nodes from p to root, excluding root
<span class="fc" id="L109">        List&lt;Preferences&gt; ancestors = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L111" title="All 2 branches covered.">        for (Preferences kid = p, dad = kid.parent(); dad != null;</span>
<span class="fc" id="L112">                                   kid = dad, dad = kid.parent()) {</span>
<span class="fc" id="L113">            ancestors.add(kid);</span>
        }
<span class="fc" id="L115">        Element e = xmlRoot;</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        for (int i=ancestors.size()-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L117">            e.appendChild(doc.createElement(&quot;map&quot;));</span>
<span class="fc" id="L118">            e = (Element) e.appendChild(doc.createElement(&quot;node&quot;));</span>
<span class="fc" id="L119">            e.setAttribute(&quot;name&quot;, ancestors.get(i).name());</span>
        }
<span class="nc" id="L121">        putPreferencesInXml(e, doc, p, subTree);</span>

<span class="nc" id="L123">        writeDoc(doc, os);</span>
<span class="nc" id="L124">    }</span>

    /**
     * Put the preferences in the specified Preferences node into the
     * specified XML element which is assumed to represent a node
     * in the specified XML document which is assumed to conform to
     * PREFS_DTD.  If subTree is true, create children of the specified
     * XML node conforming to all of the children of the specified
     * Preferences node and recurse.
     *
     * @throws BackingStoreException if it is not possible to read
     *         the preferences or children out of the specified
     *         preferences node.
     */
    private static void putPreferencesInXml(Element elt, Document doc,
               Preferences prefs, boolean subTree) throws BackingStoreException
    {
<span class="fc" id="L141">        Preferences[] kidsCopy = null;</span>
<span class="fc" id="L142">        String[] kidNames = null;</span>

        // Node is locked to export its contents and get a
        // copy of children, then lock is released,
        // and, if subTree = true, recursive calls are made on children
<span class="fc" id="L147">        synchronized (((AbstractPreferences)prefs).lock) {</span>
            // Check if this node was concurrently removed. If yes
            // remove it from XML Document and return.
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">            if (((AbstractPreferences)prefs).isRemoved()) {</span>
<span class="nc" id="L151">                elt.getParentNode().removeChild(elt);</span>
<span class="nc" id="L152">                return;</span>
            }
            // Put map in xml element
<span class="fc" id="L155">            String[] keys = prefs.keys();</span>
<span class="fc" id="L156">            Element map = (Element) elt.appendChild(doc.createElement(&quot;map&quot;));</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            for (int i=0; i&lt;keys.length; i++) {</span>
<span class="fc" id="L158">                Element entry = (Element)</span>
<span class="fc" id="L159">                    map.appendChild(doc.createElement(&quot;entry&quot;));</span>
<span class="fc" id="L160">                entry.setAttribute(&quot;key&quot;, keys[i]);</span>
                // NEXT STATEMENT THROWS NULL PTR EXC INSTEAD OF ASSERT FAIL
<span class="fc" id="L162">                entry.setAttribute(&quot;value&quot;, prefs.get(keys[i], null));</span>
            }
            // Recurse if appropriate
<span class="fc bfc" id="L165" title="All 2 branches covered.">            if (subTree) {</span>
                /* Get a copy of kids while lock is held */
<span class="fc" id="L167">                kidNames = prefs.childrenNames();</span>
<span class="fc" id="L168">                kidsCopy = new Preferences[kidNames.length];</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">                for (int i = 0; i &lt;  kidNames.length; i++)</span>
<span class="fc" id="L170">                    kidsCopy[i] = prefs.node(kidNames[i]);</span>
            }
            // release lock
<span class="pc" id="L173">        }</span>

<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (subTree) {</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">            for (int i=0; i &lt; kidNames.length; i++) {</span>
<span class="fc" id="L177">                Element xmlKid = (Element)</span>
<span class="fc" id="L178">                    elt.appendChild(doc.createElement(&quot;node&quot;));</span>
<span class="fc" id="L179">                xmlKid.setAttribute(&quot;name&quot;, kidNames[i]);</span>
<span class="fc" id="L180">                putPreferencesInXml(xmlKid, doc, kidsCopy[i], subTree);</span>
            }
        }
<span class="fc" id="L183">    }</span>

    /**
     * Import preferences from the specified input stream, which is assumed
     * to contain an XML document in the format described in the Preferences
     * spec.
     *
     * @throws IOException if reading from the specified output stream
     *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.
     * @throws InvalidPreferencesFormatException Data on input stream does not
     *         constitute a valid XML document with the mandated document type.
     */
    static void importPreferences(InputStream is)
        throws IOException, InvalidPreferencesFormatException
    {
        try {
<span class="fc" id="L199">            Document doc = loadPrefsDoc(is);</span>
<span class="fc" id="L200">            String xmlVersion =</span>
<span class="fc" id="L201">                doc.getDocumentElement().getAttribute(&quot;EXTERNAL_XML_VERSION&quot;);</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">            if (xmlVersion.compareTo(EXTERNAL_XML_VERSION) &gt; 0)</span>
<span class="nc" id="L203">                throw new InvalidPreferencesFormatException(</span>
                &quot;Exported preferences file format version &quot; + xmlVersion +
                &quot; is not supported. This java installation can read&quot; +
                &quot; versions &quot; + EXTERNAL_XML_VERSION + &quot; or older. You may need&quot; +
                &quot; to install a newer version of JDK.&quot;);

<span class="fc" id="L209">            Element xmlRoot = (Element) doc.getDocumentElement().</span>
<span class="fc" id="L210">                                               getChildNodes().item(0);</span>
<span class="fc" id="L211">            Preferences prefsRoot =</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">                (xmlRoot.getAttribute(&quot;type&quot;).equals(&quot;user&quot;) ?</span>
<span class="pc" id="L213">                            Preferences.userRoot() : Preferences.systemRoot());</span>
<span class="fc" id="L214">            ImportSubtree(prefsRoot, xmlRoot);</span>
<span class="nc" id="L215">        } catch(SAXException e) {</span>
<span class="nc" id="L216">            throw new InvalidPreferencesFormatException(e);</span>
<span class="fc" id="L217">        }</span>
<span class="fc" id="L218">    }</span>

    /**
     * Create a new prefs XML document.
     */
    private static Document createPrefsDoc( String qname ) {
        try {
<span class="fc" id="L225">            DOMImplementation di = DocumentBuilderFactory.newInstance().</span>
<span class="fc" id="L226">                newDocumentBuilder().getDOMImplementation();</span>
<span class="fc" id="L227">            DocumentType dt = di.createDocumentType(qname, null, PREFS_DTD_URI);</span>
<span class="fc" id="L228">            return di.createDocument(null, qname, dt);</span>
<span class="nc" id="L229">        } catch(ParserConfigurationException e) {</span>
<span class="nc" id="L230">            throw new AssertionError(e);</span>
        }
    }

    /**
     * Load an XML document from specified input stream, which must
     * have the requisite DTD URI.
     */
    private static Document loadPrefsDoc(InputStream in)
        throws SAXException, IOException
    {
<span class="fc" id="L241">        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="fc" id="L242">        dbf.setIgnoringElementContentWhitespace(true);</span>
<span class="fc" id="L243">        dbf.setValidating(true);</span>
<span class="fc" id="L244">        dbf.setCoalescing(true);</span>
<span class="fc" id="L245">        dbf.setIgnoringComments(true);</span>
        try {
<span class="fc" id="L247">            DocumentBuilder db = dbf.newDocumentBuilder();</span>
<span class="fc" id="L248">            db.setEntityResolver(new Resolver());</span>
<span class="fc" id="L249">            db.setErrorHandler(new EH());</span>
<span class="fc" id="L250">            return db.parse(new InputSource(in));</span>
<span class="nc" id="L251">        } catch (ParserConfigurationException e) {</span>
<span class="nc" id="L252">            throw new AssertionError(e);</span>
        }
    }

    /**
     * Write XML document to the specified output stream.
     */
    private static final void writeDoc(Document doc, OutputStream out)
        throws IOException
    {
        try {
<span class="fc" id="L263">            TransformerFactory tf = TransformerFactory.newInstance();</span>
            try {
<span class="fc" id="L265">                tf.setAttribute(&quot;indent-number&quot;, new Integer(2));</span>
<span class="nc" id="L266">            } catch (IllegalArgumentException iae) {</span>
                //Ignore the IAE. Should not fail the writeout even the
                //transformer provider does not support &quot;indent-number&quot;.
<span class="fc" id="L269">            }</span>
<span class="nc" id="L270">            Transformer t = tf.newTransformer();</span>
<span class="nc" id="L271">            t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doc.getDoctype().getSystemId());</span>
<span class="nc" id="L272">            t.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>
            //Transformer resets the &quot;indent&quot; info if the &quot;result&quot; is a StreamResult with
            //an OutputStream object embedded, creating a Writer object on top of that
            //OutputStream object however works.
<span class="nc" id="L276">            t.transform(new DOMSource(doc),</span>
                        new StreamResult(new BufferedWriter(new OutputStreamWriter(out, &quot;UTF-8&quot;))));
<span class="nc" id="L278">        } catch(TransformerException e) {</span>
<span class="nc" id="L279">            throw new AssertionError(e);</span>
<span class="nc" id="L280">        }</span>
<span class="nc" id="L281">    }</span>

    /**
     * Recursively traverse the specified preferences node and store
     * the described preferences into the system or current user
     * preferences tree, as appropriate.
     */
    private static void ImportSubtree(Preferences prefsNode, Element xmlNode) {
<span class="fc" id="L289">        NodeList xmlKids = xmlNode.getChildNodes();</span>
<span class="fc" id="L290">        int numXmlKids = xmlKids.getLength();</span>
        /*
         * We first lock the node, import its contents and get
         * child nodes. Then we unlock the node and go to children
         * Since some of the children might have been concurrently
         * deleted we check for this.
         */
        Preferences[] prefsKids;
        /* Lock the node */
<span class="fc" id="L299">        synchronized (((AbstractPreferences)prefsNode).lock) {</span>
            //If removed, return silently
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">            if (((AbstractPreferences)prefsNode).isRemoved())</span>
<span class="nc" id="L302">                return;</span>

            // Import any preferences at this node
<span class="fc" id="L305">            Element firstXmlKid = (Element) xmlKids.item(0);</span>
<span class="fc" id="L306">            ImportPrefs(prefsNode, firstXmlKid);</span>
<span class="fc" id="L307">            prefsKids = new Preferences[numXmlKids - 1];</span>

            // Get involved children
<span class="fc bfc" id="L310" title="All 2 branches covered.">            for (int i=1; i &lt; numXmlKids; i++) {</span>
<span class="fc" id="L311">                Element xmlKid = (Element) xmlKids.item(i);</span>
<span class="fc" id="L312">                prefsKids[i-1] = prefsNode.node(xmlKid.getAttribute(&quot;name&quot;));</span>
            }
<span class="pc" id="L314">        } // unlocked the node</span>
        // import children
<span class="fc bfc" id="L316" title="All 2 branches covered.">        for (int i=1; i &lt; numXmlKids; i++)</span>
<span class="fc" id="L317">            ImportSubtree(prefsKids[i-1], (Element)xmlKids.item(i));</span>
<span class="fc" id="L318">    }</span>

    /**
     * Import the preferences described by the specified XML element
     * (a map from a preferences document) into the specified
     * preferences node.
     */
    private static void ImportPrefs(Preferences prefsNode, Element map) {
<span class="fc" id="L326">        NodeList entries = map.getChildNodes();</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (int i=0, numEntries = entries.getLength(); i &lt; numEntries; i++) {</span>
<span class="fc" id="L328">            Element entry = (Element) entries.item(i);</span>
<span class="fc" id="L329">            prefsNode.put(entry.getAttribute(&quot;key&quot;),</span>
<span class="fc" id="L330">                          entry.getAttribute(&quot;value&quot;));</span>
        }
<span class="fc" id="L332">    }</span>

    /**
     * Export the specified Map&lt;String,String&gt; to a map document on
     * the specified OutputStream as per the prefs DTD.  This is used
     * as the internal (undocumented) format for FileSystemPrefs.
     *
     * @throws IOException if writing to the specified output stream
     *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.
     */
    static void exportMap(OutputStream os, Map&lt;String, String&gt; map) throws IOException {
<span class="fc" id="L343">        Document doc = createPrefsDoc(&quot;map&quot;);</span>
<span class="fc" id="L344">        Element xmlMap = doc.getDocumentElement( ) ;</span>
<span class="fc" id="L345">        xmlMap.setAttribute(&quot;MAP_XML_VERSION&quot;, MAP_XML_VERSION);</span>

<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        for (Iterator&lt;Map.Entry&lt;String, String&gt;&gt; i = map.entrySet().iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L348">            Map.Entry&lt;String, String&gt; e = i.next();</span>
<span class="fc" id="L349">            Element xe = (Element)</span>
<span class="fc" id="L350">                xmlMap.appendChild(doc.createElement(&quot;entry&quot;));</span>
<span class="fc" id="L351">            xe.setAttribute(&quot;key&quot;,   e.getKey());</span>
<span class="fc" id="L352">            xe.setAttribute(&quot;value&quot;, e.getValue());</span>
<span class="fc" id="L353">        }</span>

<span class="nc" id="L355">        writeDoc(doc, os);</span>
<span class="nc" id="L356">    }</span>

    /**
     * Import Map from the specified input stream, which is assumed
     * to contain a map document as per the prefs DTD.  This is used
     * as the internal (undocumented) format for FileSystemPrefs.  The
     * key-value pairs specified in the XML document will be put into
     * the specified Map.  (If this Map is empty, it will contain exactly
     * the key-value pairs int the XML-document when this method returns.)
     *
     * @throws IOException if reading from the specified output stream
     *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.
     * @throws InvalidPreferencesFormatException Data on input stream does not
     *         constitute a valid XML document with the mandated document type.
     */
    static void importMap(InputStream is, Map&lt;String, String&gt; m)
        throws IOException, InvalidPreferencesFormatException
    {
        try {
<span class="nc" id="L375">            Document doc = loadPrefsDoc(is);</span>
<span class="nc" id="L376">            Element xmlMap = doc.getDocumentElement();</span>
            // check version
<span class="nc" id="L378">            String mapVersion = xmlMap.getAttribute(&quot;MAP_XML_VERSION&quot;);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">            if (mapVersion.compareTo(MAP_XML_VERSION) &gt; 0)</span>
<span class="nc" id="L380">                throw new InvalidPreferencesFormatException(</span>
                &quot;Preferences map file format version &quot; + mapVersion +
                &quot; is not supported. This java installation can read&quot; +
                &quot; versions &quot; + MAP_XML_VERSION + &quot; or older. You may need&quot; +
                &quot; to install a newer version of JDK.&quot;);

<span class="nc" id="L386">            NodeList entries = xmlMap.getChildNodes();</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            for (int i=0, numEntries=entries.getLength(); i&lt;numEntries; i++) {</span>
<span class="nc" id="L388">                Element entry = (Element) entries.item(i);</span>
<span class="nc" id="L389">                m.put(entry.getAttribute(&quot;key&quot;), entry.getAttribute(&quot;value&quot;));</span>
            }
<span class="nc" id="L391">        } catch(SAXException e) {</span>
<span class="nc" id="L392">            throw new InvalidPreferencesFormatException(e);</span>
<span class="nc" id="L393">        }</span>
<span class="nc" id="L394">    }</span>

<span class="fc" id="L396">    private static class Resolver implements EntityResolver {</span>
        public InputSource resolveEntity(String pid, String sid)
            throws SAXException
        {
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">            if (sid.equals(PREFS_DTD_URI)) {</span>
                InputSource is;
<span class="fc" id="L402">                is = new InputSource(new StringReader(PREFS_DTD));</span>
<span class="fc" id="L403">                is.setSystemId(PREFS_DTD_URI);</span>
<span class="fc" id="L404">                return is;</span>
            }
<span class="nc" id="L406">            throw new SAXException(&quot;Invalid system identifier: &quot; + sid);</span>
        }
    }

<span class="pc" id="L410">    private static class EH implements ErrorHandler {</span>
        public void error(SAXParseException x) throws SAXException {
<span class="nc" id="L412">            throw x;</span>
        }
        public void fatalError(SAXParseException x) throws SAXException {
<span class="nc" id="L415">            throw x;</span>
        }
        public void warning(SAXParseException x) throws SAXException {
<span class="nc" id="L418">            throw x;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>