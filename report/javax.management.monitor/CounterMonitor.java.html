<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CounterMonitor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.management.monitor</a> &gt; <span class="el_source">CounterMonitor.java</span></div><h1>CounterMonitor.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management.monitor;

import static com.sun.jmx.defaults.JmxProperties.MONITOR_LOGGER;
import java.util.logging.Level;
import javax.management.ObjectName;
import javax.management.MBeanNotificationInfo;
import static javax.management.monitor.Monitor.NumericalType.*;
import static javax.management.monitor.MonitorNotification.*;

/**
 * Defines a monitor MBean designed to observe the values of a counter
 * attribute.
 *
 * &lt;P&gt; A counter monitor sends a {@link
 * MonitorNotification#THRESHOLD_VALUE_EXCEEDED threshold
 * notification} when the value of the counter reaches or exceeds a
 * threshold known as the comparison level.  The notify flag must be
 * set to &lt;CODE&gt;true&lt;/CODE&gt;.
 *
 * &lt;P&gt; In addition, an offset mechanism enables particular counting
 * intervals to be detected.  If the offset value is not zero,
 * whenever the threshold is triggered by the counter value reaching a
 * comparison level, that comparison level is incremented by the
 * offset value.  This is regarded as taking place instantaneously,
 * that is, before the count is incremented.  Thus, for each level,
 * the threshold triggers an event notification every time the count
 * increases by an interval equal to the offset value.
 *
 * &lt;P&gt; If the counter can wrap around its maximum value, the modulus
 * needs to be specified.  The modulus is the value at which the
 * counter is reset to zero.
 *
 * &lt;P&gt; If the counter difference mode is used, the value of the
 * derived gauge is calculated as the difference between the observed
 * counter values for two successive observations.  If this difference
 * is negative, the value of the derived gauge is incremented by the
 * value of the modulus.  The derived gauge value (V[t]) is calculated
 * using the following method:
 *
 * &lt;UL&gt;
 * &lt;LI&gt;if (counter[t] - counter[t-GP]) is positive then
 * V[t] = counter[t] - counter[t-GP]
 * &lt;LI&gt;if (counter[t] - counter[t-GP]) is negative then
 * V[t] = counter[t] - counter[t-GP] + MODULUS
 * &lt;/UL&gt;
 *
 * This implementation of the counter monitor requires the observed
 * attribute to be of the type integer (&lt;CODE&gt;Byte&lt;/CODE&gt;,
 * &lt;CODE&gt;Integer&lt;/CODE&gt;, &lt;CODE&gt;Short&lt;/CODE&gt;, &lt;CODE&gt;Long&lt;/CODE&gt;).
 *
 *
 * @since 1.5
 */
public class CounterMonitor extends Monitor implements CounterMonitorMBean {

    /*
     * ------------------------------------------
     *  PACKAGE CLASSES
     * ------------------------------------------
     */

    static class CounterMonitorObservedObject extends ObservedObject {

        public CounterMonitorObservedObject(ObjectName observedObject) {
<span class="nc" id="L90">            super(observedObject);</span>
<span class="nc" id="L91">        }</span>

        public final synchronized Number getThreshold() {
<span class="nc" id="L94">            return threshold;</span>
        }
        public final synchronized void setThreshold(Number threshold) {
<span class="nc" id="L97">            this.threshold = threshold;</span>
<span class="nc" id="L98">        }</span>
        public final synchronized Number getPreviousScanCounter() {
<span class="nc" id="L100">            return previousScanCounter;</span>
        }
        public final synchronized void setPreviousScanCounter(
                                                  Number previousScanCounter) {
<span class="nc" id="L104">            this.previousScanCounter = previousScanCounter;</span>
<span class="nc" id="L105">        }</span>
        public final synchronized boolean getModulusExceeded() {
<span class="nc" id="L107">            return modulusExceeded;</span>
        }
        public final synchronized void setModulusExceeded(
                                                 boolean modulusExceeded) {
<span class="nc" id="L111">            this.modulusExceeded = modulusExceeded;</span>
<span class="nc" id="L112">        }</span>
        public final synchronized Number getDerivedGaugeExceeded() {
<span class="nc" id="L114">            return derivedGaugeExceeded;</span>
        }
        public final synchronized void setDerivedGaugeExceeded(
                                                 Number derivedGaugeExceeded) {
<span class="nc" id="L118">            this.derivedGaugeExceeded = derivedGaugeExceeded;</span>
<span class="nc" id="L119">        }</span>
        public final synchronized boolean getDerivedGaugeValid() {
<span class="nc" id="L121">            return derivedGaugeValid;</span>
        }
        public final synchronized void setDerivedGaugeValid(
                                                 boolean derivedGaugeValid) {
<span class="nc" id="L125">            this.derivedGaugeValid = derivedGaugeValid;</span>
<span class="nc" id="L126">        }</span>
        public final synchronized boolean getEventAlreadyNotified() {
<span class="nc" id="L128">            return eventAlreadyNotified;</span>
        }
        public final synchronized void setEventAlreadyNotified(
                                               boolean eventAlreadyNotified) {
<span class="nc" id="L132">            this.eventAlreadyNotified = eventAlreadyNotified;</span>
<span class="nc" id="L133">        }</span>
        public final synchronized NumericalType getType() {
<span class="nc" id="L135">            return type;</span>
        }
        public final synchronized void setType(NumericalType type) {
<span class="nc" id="L138">            this.type = type;</span>
<span class="nc" id="L139">        }</span>

        private Number threshold;
        private Number previousScanCounter;
        private boolean modulusExceeded;
        private Number derivedGaugeExceeded;
        private boolean derivedGaugeValid;
        private boolean eventAlreadyNotified;
        private NumericalType type;
    }

    /*
     * ------------------------------------------
     *  PRIVATE VARIABLES
     * ------------------------------------------
     */

    /**
     * Counter modulus.
     * &lt;BR&gt;The default value is a null Integer object.
     */
<span class="nc" id="L160">    private Number modulus = INTEGER_ZERO;</span>

    /**
     * Counter offset.
     * &lt;BR&gt;The default value is a null Integer object.
     */
<span class="nc" id="L166">    private Number offset = INTEGER_ZERO;</span>

    /**
     * Flag indicating if the counter monitor notifies when exceeding
     * the threshold.  The default value is set to
     * &lt;CODE&gt;false&lt;/CODE&gt;.
     */
<span class="nc" id="L173">    private boolean notify = false;</span>

    /**
     * Flag indicating if the counter difference mode is used.  If the
     * counter difference mode is used, the derived gauge is the
     * difference between two consecutive observed values.  Otherwise,
     * the derived gauge is directly the value of the observed
     * attribute.  The default value is set to &lt;CODE&gt;false&lt;/CODE&gt;.
     */
<span class="nc" id="L182">    private boolean differenceMode = false;</span>

    /**
     * Initial counter threshold.  This value is used to initialize
     * the threshold when a new object is added to the list and reset
     * the threshold to its initial value each time the counter
     * resets.
     */
<span class="nc" id="L190">    private Number initThreshold = INTEGER_ZERO;</span>

<span class="nc" id="L192">    private static final String[] types = {</span>
        RUNTIME_ERROR,
        OBSERVED_OBJECT_ERROR,
        OBSERVED_ATTRIBUTE_ERROR,
        OBSERVED_ATTRIBUTE_TYPE_ERROR,
        THRESHOLD_ERROR,
        THRESHOLD_VALUE_EXCEEDED
    };

<span class="nc" id="L201">    private static final MBeanNotificationInfo[] notifsInfo = {</span>
        new MBeanNotificationInfo(
            types,
            &quot;javax.management.monitor.MonitorNotification&quot;,
            &quot;Notifications sent by the CounterMonitor MBean&quot;)
    };

    /*
     * ------------------------------------------
     *  CONSTRUCTORS
     * ------------------------------------------
     */

    /**
     * Default constructor.
     */
<span class="nc" id="L217">    public CounterMonitor() {</span>
<span class="nc" id="L218">    }</span>

    /*
     * ------------------------------------------
     *  PUBLIC METHODS
     * ------------------------------------------
     */

    /**
     * Starts the counter monitor.
     */
    public synchronized void start() {
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (isActive()) {</span>
<span class="nc" id="L231">            MONITOR_LOGGER.logp(Level.FINER, CounterMonitor.class.getName(),</span>
                    &quot;start&quot;, &quot;the monitor is already active&quot;);
<span class="nc" id="L233">            return;</span>
        }
        // Reset values.
        //
<span class="nc bnc" id="L237" title="All 2 branches missed.">        for (ObservedObject o : observedObjects) {</span>
<span class="nc" id="L238">            final CounterMonitorObservedObject cmo =</span>
                (CounterMonitorObservedObject) o;
<span class="nc" id="L240">            cmo.setThreshold(initThreshold);</span>
<span class="nc" id="L241">            cmo.setModulusExceeded(false);</span>
<span class="nc" id="L242">            cmo.setEventAlreadyNotified(false);</span>
<span class="nc" id="L243">            cmo.setPreviousScanCounter(null);</span>
<span class="nc" id="L244">        }</span>
<span class="nc" id="L245">        doStart();</span>
<span class="nc" id="L246">    }</span>

    /**
     * Stops the counter monitor.
     */
    public synchronized void stop() {
<span class="nc" id="L252">        doStop();</span>
<span class="nc" id="L253">    }</span>

    // GETTERS AND SETTERS
    //--------------------

    /**
     * Gets the derived gauge of the specified object, if this object is
     * contained in the set of observed MBeans, or &lt;code&gt;null&lt;/code&gt; otherwise.
     *
     * @param object the name of the object whose derived gauge is to
     * be returned.
     *
     * @return The derived gauge of the specified object.
     *
     */
    @Override
    public synchronized Number getDerivedGauge(ObjectName object) {
<span class="nc" id="L270">        return (Number) super.getDerivedGauge(object);</span>
    }

    /**
     * Gets the derived gauge timestamp of the specified object, if
     * this object is contained in the set of observed MBeans, or
     * &lt;code&gt;0&lt;/code&gt; otherwise.
     *
     * @param object the name of the object whose derived gauge
     * timestamp is to be returned.
     *
     * @return The derived gauge timestamp of the specified object.
     *
     */
    @Override
    public synchronized long getDerivedGaugeTimeStamp(ObjectName object) {
<span class="nc" id="L286">        return super.getDerivedGaugeTimeStamp(object);</span>
    }

    /**
     * Gets the current threshold value of the specified object, if
     * this object is contained in the set of observed MBeans, or
     * &lt;code&gt;null&lt;/code&gt; otherwise.
     *
     * @param object the name of the object whose threshold is to be
     * returned.
     *
     * @return The threshold value of the specified object.
     *
     */
    public synchronized Number getThreshold(ObjectName object) {
<span class="nc" id="L301">        final CounterMonitorObservedObject o =</span>
<span class="nc" id="L302">            (CounterMonitorObservedObject) getObservedObject(object);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (o == null)</span>
<span class="nc" id="L304">            return null;</span>

        // If the counter that is monitored rolls over when it reaches a
        // maximum value, then the modulus value needs to be set to that
        // maximum value. The threshold will then also roll over whenever
        // it strictly exceeds the modulus value. When the threshold rolls
        // over, it is reset to the value that was specified through the
        // latest call to the monitor's setInitThreshold method, before
        // any offsets were applied.
        //
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (offset.longValue() &gt; 0L &amp;&amp;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            modulus.longValue() &gt; 0L &amp;&amp;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            o.getThreshold().longValue() &gt; modulus.longValue()) {</span>
<span class="nc" id="L317">            return initThreshold;</span>
        } else {
<span class="nc" id="L319">            return o.getThreshold();</span>
        }
    }

    /**
     * Gets the initial threshold value common to all observed objects.
     *
     * @return The initial threshold.
     *
     * @see #setInitThreshold
     *
     */
    public synchronized Number getInitThreshold() {
<span class="nc" id="L332">        return initThreshold;</span>
    }

    /**
     * Sets the initial threshold value common to all observed objects.
     *
     * &lt;BR&gt;The current threshold of every object in the set of
     * observed MBeans is updated consequently.
     *
     * @param value The initial threshold value.
     *
     * @exception IllegalArgumentException The specified
     * threshold is null or the threshold value is less than zero.
     *
     * @see #getInitThreshold
     *
     */
    public synchronized void setInitThreshold(Number value)
        throws IllegalArgumentException {

<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L353">            throw new IllegalArgumentException(&quot;Null threshold&quot;);</span>
        }
<span class="nc bnc" id="L355" title="All 2 branches missed.">        if (value.longValue() &lt; 0L) {</span>
<span class="nc" id="L356">            throw new IllegalArgumentException(&quot;Negative threshold&quot;);</span>
        }

<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (initThreshold.equals(value))</span>
<span class="nc" id="L360">            return;</span>
<span class="nc" id="L361">        initThreshold = value;</span>

        // Reset values.
        //
<span class="nc" id="L365">        int index = 0;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">        for (ObservedObject o : observedObjects) {</span>
<span class="nc" id="L367">            resetAlreadyNotified(o, index++, THRESHOLD_ERROR_NOTIFIED);</span>
<span class="nc" id="L368">            final CounterMonitorObservedObject cmo =</span>
                (CounterMonitorObservedObject) o;
<span class="nc" id="L370">            cmo.setThreshold(value);</span>
<span class="nc" id="L371">            cmo.setModulusExceeded(false);</span>
<span class="nc" id="L372">            cmo.setEventAlreadyNotified(false);</span>
<span class="nc" id="L373">        }</span>
<span class="nc" id="L374">    }</span>

    /**
     * Returns the derived gauge of the first object in the set of
     * observed MBeans.
     *
     * @return The derived gauge.
     *
     * @deprecated As of JMX 1.2, replaced by
     * {@link #getDerivedGauge(ObjectName)}
     */
    @Deprecated
    public synchronized Number getDerivedGauge() {
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (observedObjects.isEmpty()) {</span>
<span class="nc" id="L388">            return null;</span>
        } else {
<span class="nc" id="L390">            return (Number) observedObjects.get(0).getDerivedGauge();</span>
        }
    }

    /**
     * Gets the derived gauge timestamp of the first object in the set
     * of observed MBeans.
     *
     * @return The derived gauge timestamp.
     *
     * @deprecated As of JMX 1.2, replaced by
     * {@link #getDerivedGaugeTimeStamp(ObjectName)}
     */
    @Deprecated
    public synchronized long getDerivedGaugeTimeStamp() {
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (observedObjects.isEmpty()) {</span>
<span class="nc" id="L406">            return 0;</span>
        } else {
<span class="nc" id="L408">            return observedObjects.get(0).getDerivedGaugeTimeStamp();</span>
        }
    }

    /**
     * Gets the threshold value of the first object in the set of
     * observed MBeans.
     *
     * @return The threshold value.
     *
     * @see #setThreshold
     *
     * @deprecated As of JMX 1.2, replaced by {@link #getThreshold(ObjectName)}
     */
    @Deprecated
    public synchronized Number getThreshold() {
<span class="nc" id="L424">        return getThreshold(getObservedObject());</span>
    }

    /**
     * Sets the initial threshold value.
     *
     * @param value The initial threshold value.
     *
     * @exception IllegalArgumentException The specified threshold is
     * null or the threshold value is less than zero.
     *
     * @see #getThreshold()
     *
     * @deprecated As of JMX 1.2, replaced by {@link #setInitThreshold}
     */
    @Deprecated
    public synchronized void setThreshold(Number value)
        throws IllegalArgumentException {
<span class="nc" id="L442">        setInitThreshold(value);</span>
<span class="nc" id="L443">    }</span>

    /**
     * Gets the offset value common to all observed MBeans.
     *
     * @return The offset value.
     *
     * @see #setOffset
     */
    public synchronized Number getOffset() {
<span class="nc" id="L453">        return offset;</span>
    }

    /**
     * Sets the offset value common to all observed MBeans.
     *
     * @param value The offset value.
     *
     * @exception IllegalArgumentException The specified
     * offset is null or the offset value is less than zero.
     *
     * @see #getOffset
     */
    public synchronized void setOffset(Number value)
        throws IllegalArgumentException {

<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L470">            throw new IllegalArgumentException(&quot;Null offset&quot;);</span>
        }
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (value.longValue() &lt; 0L) {</span>
<span class="nc" id="L473">            throw new IllegalArgumentException(&quot;Negative offset&quot;);</span>
        }

<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (offset.equals(value))</span>
<span class="nc" id="L477">            return;</span>
<span class="nc" id="L478">        offset = value;</span>

<span class="nc" id="L480">        int index = 0;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">        for (ObservedObject o : observedObjects) {</span>
<span class="nc" id="L482">            resetAlreadyNotified(o, index++, THRESHOLD_ERROR_NOTIFIED);</span>
<span class="nc" id="L483">        }</span>
<span class="nc" id="L484">    }</span>

    /**
     * Gets the modulus value common to all observed MBeans.
     *
     * @see #setModulus
     *
     * @return The modulus value.
     */
    public synchronized Number getModulus() {
<span class="nc" id="L494">        return modulus;</span>
    }

    /**
     * Sets the modulus value common to all observed MBeans.
     *
     * @param value The modulus value.
     *
     * @exception IllegalArgumentException The specified
     * modulus is null or the modulus value is less than zero.
     *
     * @see #getModulus
     */
    public synchronized void setModulus(Number value)
        throws IllegalArgumentException {

<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L511">            throw new IllegalArgumentException(&quot;Null modulus&quot;);</span>
        }
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (value.longValue() &lt; 0L) {</span>
<span class="nc" id="L514">            throw new IllegalArgumentException(&quot;Negative modulus&quot;);</span>
        }

<span class="nc bnc" id="L517" title="All 2 branches missed.">        if (modulus.equals(value))</span>
<span class="nc" id="L518">            return;</span>
<span class="nc" id="L519">        modulus = value;</span>

        // Reset values.
        //
<span class="nc" id="L523">        int index = 0;</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">        for (ObservedObject o : observedObjects) {</span>
<span class="nc" id="L525">            resetAlreadyNotified(o, index++, THRESHOLD_ERROR_NOTIFIED);</span>
<span class="nc" id="L526">            final CounterMonitorObservedObject cmo =</span>
                (CounterMonitorObservedObject) o;
<span class="nc" id="L528">            cmo.setModulusExceeded(false);</span>
<span class="nc" id="L529">        }</span>
<span class="nc" id="L530">    }</span>

    /**
     * Gets the notification's on/off switch value common to all
     * observed MBeans.
     *
     * @return &lt;CODE&gt;true&lt;/CODE&gt; if the counter monitor notifies when
     * exceeding the threshold, &lt;CODE&gt;false&lt;/CODE&gt; otherwise.
     *
     * @see #setNotify
     */
    public synchronized boolean getNotify() {
<span class="nc" id="L542">        return notify;</span>
    }

    /**
     * Sets the notification's on/off switch value common to all
     * observed MBeans.
     *
     * @param value The notification's on/off switch value.
     *
     * @see #getNotify
     */
    public synchronized void setNotify(boolean value) {
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (notify == value)</span>
<span class="nc" id="L555">            return;</span>
<span class="nc" id="L556">        notify = value;</span>
<span class="nc" id="L557">    }</span>

    /**
     * Gets the difference mode flag value common to all observed MBeans.
     *
     * @return &lt;CODE&gt;true&lt;/CODE&gt; if the difference mode is used,
     * &lt;CODE&gt;false&lt;/CODE&gt; otherwise.
     *
     * @see #setDifferenceMode
     */
    public synchronized boolean getDifferenceMode() {
<span class="nc" id="L568">        return differenceMode;</span>
    }

    /**
     * Sets the difference mode flag value common to all observed MBeans.
     *
     * @param value The difference mode flag value.
     *
     * @see #getDifferenceMode
     */
    public synchronized void setDifferenceMode(boolean value) {
<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (differenceMode == value)</span>
<span class="nc" id="L580">            return;</span>
<span class="nc" id="L581">        differenceMode = value;</span>

        // Reset values.
        //
<span class="nc bnc" id="L585" title="All 2 branches missed.">        for (ObservedObject o : observedObjects) {</span>
<span class="nc" id="L586">            final CounterMonitorObservedObject cmo =</span>
                (CounterMonitorObservedObject) o;
<span class="nc" id="L588">            cmo.setThreshold(initThreshold);</span>
<span class="nc" id="L589">            cmo.setModulusExceeded(false);</span>
<span class="nc" id="L590">            cmo.setEventAlreadyNotified(false);</span>
<span class="nc" id="L591">            cmo.setPreviousScanCounter(null);</span>
<span class="nc" id="L592">        }</span>
<span class="nc" id="L593">    }</span>

    /**
     * Returns a &lt;CODE&gt;NotificationInfo&lt;/CODE&gt; object containing the
     * name of the Java class of the notification and the notification
     * types sent by the counter monitor.
     */
    @Override
    public MBeanNotificationInfo[] getNotificationInfo() {
<span class="nc" id="L602">        return notifsInfo.clone();</span>
    }

    /*
     * ------------------------------------------
     *  PRIVATE METHODS
     * ------------------------------------------
     */

    /**
     * Updates the derived gauge attribute of the observed object.
     *
     * @param scanCounter The value of the observed attribute.
     * @param o The observed object.
     * @return &lt;CODE&gt;true&lt;/CODE&gt; if the derived gauge value is valid,
     * &lt;CODE&gt;false&lt;/CODE&gt; otherwise.  The derived gauge value is
     * invalid when the differenceMode flag is set to
     * &lt;CODE&gt;true&lt;/CODE&gt; and it is the first notification (so we
     * haven't 2 consecutive values to update the derived gauge).
     */
    private synchronized boolean updateDerivedGauge(
        Object scanCounter, CounterMonitorObservedObject o) {

        boolean is_derived_gauge_valid;

        // The counter difference mode is used.
        //
<span class="nc bnc" id="L629" title="All 2 branches missed.">        if (differenceMode) {</span>

            // The previous scan counter has been initialized.
            //
<span class="nc bnc" id="L633" title="All 2 branches missed.">            if (o.getPreviousScanCounter() != null) {</span>
<span class="nc" id="L634">                setDerivedGaugeWithDifference((Number)scanCounter, null, o);</span>

                // If derived gauge is negative it means that the
                // counter has wrapped around and the value of the
                // threshold needs to be reset to its initial value.
                //
<span class="nc bnc" id="L640" title="All 2 branches missed.">                if (((Number)o.getDerivedGauge()).longValue() &lt; 0L) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">                    if (modulus.longValue() &gt; 0L) {</span>
<span class="nc" id="L642">                        setDerivedGaugeWithDifference((Number)scanCounter,</span>
                                                      modulus, o);
                    }
<span class="nc" id="L645">                    o.setThreshold(initThreshold);</span>
<span class="nc" id="L646">                    o.setEventAlreadyNotified(false);</span>
                }
<span class="nc" id="L648">                is_derived_gauge_valid = true;</span>
            }
            // The previous scan counter has not been initialized.
            // We cannot update the derived gauge...
            //
            else {
<span class="nc" id="L654">                is_derived_gauge_valid = false;</span>
            }
<span class="nc" id="L656">            o.setPreviousScanCounter((Number)scanCounter);</span>
        }
        // The counter difference mode is not used.
        //
        else {
<span class="nc" id="L661">            o.setDerivedGauge((Number)scanCounter);</span>
<span class="nc" id="L662">            is_derived_gauge_valid = true;</span>
        }
<span class="nc" id="L664">        return is_derived_gauge_valid;</span>
    }

    /**
     * Updates the notification attribute of the observed object
     * and notifies the listeners only once if the notify flag
     * is set to &lt;CODE&gt;true&lt;/CODE&gt;.
     * @param o The observed object.
     */
    private synchronized MonitorNotification updateNotifications(
        CounterMonitorObservedObject o) {

<span class="nc" id="L676">        MonitorNotification n = null;</span>

        // Send notification if notify is true.
        //
<span class="nc bnc" id="L680" title="All 2 branches missed.">        if (!o.getEventAlreadyNotified()) {</span>
<span class="nc" id="L681">            if (((Number)o.getDerivedGauge()).longValue() &gt;=</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                o.getThreshold().longValue()) {</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">                if (notify) {</span>
<span class="nc" id="L684">                    n = new MonitorNotification(THRESHOLD_VALUE_EXCEEDED,</span>
                                                this,
                                                0,
                                                0,
                                                &quot;&quot;,
                                                null,
                                                null,
                                                null,
<span class="nc" id="L692">                                                o.getThreshold());</span>
                }
<span class="nc bnc" id="L694" title="All 2 branches missed.">                if (!differenceMode) {</span>
<span class="nc" id="L695">                    o.setEventAlreadyNotified(true);</span>
                }
            }
        } else {
<span class="nc bnc" id="L699" title="All 2 branches missed.">            if (MONITOR_LOGGER.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L700">                final StringBuilder strb = new StringBuilder()</span>
<span class="nc" id="L701">                .append(&quot;The notification:&quot;)</span>
<span class="nc" id="L702">                .append(&quot;\n\tNotification observed object = &quot;)</span>
<span class="nc" id="L703">                .append(o.getObservedObject())</span>
<span class="nc" id="L704">                .append(&quot;\n\tNotification observed attribute = &quot;)</span>
<span class="nc" id="L705">                .append(getObservedAttribute())</span>
<span class="nc" id="L706">                .append(&quot;\n\tNotification threshold level = &quot;)</span>
<span class="nc" id="L707">                .append(o.getThreshold())</span>
<span class="nc" id="L708">                .append(&quot;\n\tNotification derived gauge = &quot;)</span>
<span class="nc" id="L709">                .append(o.getDerivedGauge())</span>
<span class="nc" id="L710">                .append(&quot;\nhas already been sent&quot;);</span>
<span class="nc" id="L711">                MONITOR_LOGGER.logp(Level.FINER, CounterMonitor.class.getName(),</span>
<span class="nc" id="L712">                        &quot;updateNotifications&quot;, strb.toString());</span>
            }
        }

<span class="nc" id="L716">        return n;</span>
    }

    /**
     * Updates the threshold attribute of the observed object.
     * @param o The observed object.
     */
    private synchronized void updateThreshold(CounterMonitorObservedObject o) {

        // Calculate the new threshold value if the threshold has been
        // exceeded and if the offset value is greater than zero.
        //
<span class="nc" id="L728">        if (((Number)o.getDerivedGauge()).longValue() &gt;=</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">            o.getThreshold().longValue()) {</span>

<span class="nc bnc" id="L731" title="All 2 branches missed.">            if (offset.longValue() &gt; 0L) {</span>

                // Increment the threshold until its value is greater
                // than the one for the current derived gauge.
                //
<span class="nc" id="L736">                long threshold_value = o.getThreshold().longValue();</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">                while (((Number)o.getDerivedGauge()).longValue() &gt;=</span>
                       threshold_value) {
<span class="nc" id="L739">                    threshold_value += offset.longValue();</span>
                }

                // Set threshold attribute.
                //
<span class="nc bnc" id="L744" title="All 5 branches missed.">                switch (o.getType()) {</span>
                    case INTEGER:
<span class="nc" id="L746">                        o.setThreshold(Integer.valueOf((int)threshold_value));</span>
<span class="nc" id="L747">                        break;</span>
                    case BYTE:
<span class="nc" id="L749">                        o.setThreshold(Byte.valueOf((byte)threshold_value));</span>
<span class="nc" id="L750">                        break;</span>
                    case SHORT:
<span class="nc" id="L752">                        o.setThreshold(Short.valueOf((short)threshold_value));</span>
<span class="nc" id="L753">                        break;</span>
                    case LONG:
<span class="nc" id="L755">                        o.setThreshold(Long.valueOf(threshold_value));</span>
<span class="nc" id="L756">                        break;</span>
                    default:
                        // Should never occur...
<span class="nc" id="L759">                        MONITOR_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L760">                                CounterMonitor.class.getName(),</span>
                                &quot;updateThreshold&quot;,
                                &quot;the threshold type is invalid&quot;);
                        break;
                }

                // If the counter can wrap around when it reaches
                // its maximum and we are not dealing with counter
                // differences then we need to reset the threshold
                // to its initial value too.
                //
<span class="nc bnc" id="L771" title="All 2 branches missed.">                if (!differenceMode) {</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">                    if (modulus.longValue() &gt; 0L) {</span>
<span class="nc" id="L773">                        if (o.getThreshold().longValue() &gt;</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">                            modulus.longValue()) {</span>
<span class="nc" id="L775">                            o.setModulusExceeded(true);</span>
<span class="nc" id="L776">                            o.setDerivedGaugeExceeded(</span>
<span class="nc" id="L777">                                (Number) o.getDerivedGauge());</span>
                        }
                    }
                }

                // Threshold value has been modified so we can notify again.
                //
<span class="nc" id="L784">                o.setEventAlreadyNotified(false);</span>
<span class="nc" id="L785">            } else {</span>
<span class="nc" id="L786">                o.setModulusExceeded(true);</span>
<span class="nc" id="L787">                o.setDerivedGaugeExceeded((Number) o.getDerivedGauge());</span>
            }
        }
<span class="nc" id="L790">    }</span>

    /**
     * Sets the derived gauge of the specified observed object when the
     * differenceMode flag is set to &lt;CODE&gt;true&lt;/CODE&gt;.  Integer types
     * only are allowed.
     *
     * @param scanCounter The value of the observed attribute.
     * @param mod The counter modulus value.
     * @param o The observed object.
     */
    private synchronized void setDerivedGaugeWithDifference(
        Number scanCounter, Number mod, CounterMonitorObservedObject o) {
        /* We do the arithmetic using longs here even though the
           result may end up in a smaller type.  Since
           l == (byte)l (mod 256) for any long l,
           (byte) ((byte)l1 + (byte)l2) == (byte) (l1 + l2),
           and likewise for subtraction.  So it's the same as if
           we had done the arithmetic in the smaller type.*/

<span class="nc" id="L810">        long derived =</span>
<span class="nc" id="L811">            scanCounter.longValue() - o.getPreviousScanCounter().longValue();</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">        if (mod != null)</span>
<span class="nc" id="L813">            derived += modulus.longValue();</span>

<span class="nc bnc" id="L815" title="All 5 branches missed.">        switch (o.getType()) {</span>
<span class="nc" id="L816">        case INTEGER: o.setDerivedGauge(Integer.valueOf((int) derived)); break;</span>
<span class="nc" id="L817">        case BYTE: o.setDerivedGauge(Byte.valueOf((byte) derived)); break;</span>
<span class="nc" id="L818">        case SHORT: o.setDerivedGauge(Short.valueOf((short) derived)); break;</span>
<span class="nc" id="L819">        case LONG: o.setDerivedGauge(Long.valueOf(derived)); break;</span>
        default:
            // Should never occur...
<span class="nc" id="L822">            MONITOR_LOGGER.logp(Level.FINEST, CounterMonitor.class.getName(),</span>
                    &quot;setDerivedGaugeWithDifference&quot;,
                    &quot;the threshold type is invalid&quot;);
            break;
        }
<span class="nc" id="L827">    }</span>

    /*
     * ------------------------------------------
     *  PACKAGE METHODS
     * ------------------------------------------
     */

    /**
     * Factory method for ObservedObject creation.
     *
     * @since 1.6
     */
    @Override
    ObservedObject createObservedObject(ObjectName object) {
<span class="nc" id="L842">        final CounterMonitorObservedObject cmo =</span>
            new CounterMonitorObservedObject(object);
<span class="nc" id="L844">        cmo.setThreshold(initThreshold);</span>
<span class="nc" id="L845">        cmo.setModulusExceeded(false);</span>
<span class="nc" id="L846">        cmo.setEventAlreadyNotified(false);</span>
<span class="nc" id="L847">        cmo.setPreviousScanCounter(null);</span>
<span class="nc" id="L848">        return cmo;</span>
    }

    /**
     * This method globally sets the derived gauge type for the given
     * &quot;object&quot; and &quot;attribute&quot; after checking that the type of the
     * supplied observed attribute value is one of the value types
     * supported by this monitor.
     */
    @Override
    synchronized boolean isComparableTypeValid(ObjectName object,
                                               String attribute,
                                               Comparable&lt;?&gt; value) {
<span class="nc" id="L861">        final CounterMonitorObservedObject o =</span>
<span class="nc" id="L862">            (CounterMonitorObservedObject) getObservedObject(object);</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">        if (o == null)</span>
<span class="nc" id="L864">            return false;</span>

        // Check that the observed attribute is of type &quot;Integer&quot;.
        //
<span class="nc bnc" id="L868" title="All 2 branches missed.">        if (value instanceof Integer) {</span>
<span class="nc" id="L869">            o.setType(INTEGER);</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">        } else if (value instanceof Byte) {</span>
<span class="nc" id="L871">            o.setType(BYTE);</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">        } else if (value instanceof Short) {</span>
<span class="nc" id="L873">            o.setType(SHORT);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">        } else if (value instanceof Long) {</span>
<span class="nc" id="L875">            o.setType(LONG);</span>
        } else {
<span class="nc" id="L877">            return false;</span>
        }
<span class="nc" id="L879">        return true;</span>
    }

    @Override
    synchronized Comparable&lt;?&gt; getDerivedGaugeFromComparable(
                                                  ObjectName object,
                                                  String attribute,
                                                  Comparable&lt;?&gt; value) {
<span class="nc" id="L887">        final CounterMonitorObservedObject o =</span>
<span class="nc" id="L888">            (CounterMonitorObservedObject) getObservedObject(object);</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">        if (o == null)</span>
<span class="nc" id="L890">            return null;</span>

        // Check if counter has wrapped around.
        //
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (o.getModulusExceeded()) {</span>
<span class="nc" id="L895">            if (((Number)o.getDerivedGauge()).longValue() &lt;</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">                o.getDerivedGaugeExceeded().longValue()) {</span>
<span class="nc" id="L897">                    o.setThreshold(initThreshold);</span>
<span class="nc" id="L898">                    o.setModulusExceeded(false);</span>
<span class="nc" id="L899">                    o.setEventAlreadyNotified(false);</span>
            }
        }

        // Update the derived gauge attributes and check the
        // validity of the new value. The derived gauge value
        // is invalid when the differenceMode flag is set to
        // true and it is the first notification, i.e. we
        // haven't got 2 consecutive values to update the
        // derived gauge.
        //
<span class="nc" id="L910">        o.setDerivedGaugeValid(updateDerivedGauge(value, o));</span>

<span class="nc" id="L912">        return (Comparable&lt;?&gt;) o.getDerivedGauge();</span>
    }

    @Override
    synchronized void onErrorNotification(MonitorNotification notification) {
<span class="nc" id="L917">        final CounterMonitorObservedObject o = (CounterMonitorObservedObject)</span>
<span class="nc" id="L918">            getObservedObject(notification.getObservedObject());</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">        if (o == null)</span>
<span class="nc" id="L920">            return;</span>

        // Reset values.
        //
<span class="nc" id="L924">        o.setModulusExceeded(false);</span>
<span class="nc" id="L925">        o.setEventAlreadyNotified(false);</span>
<span class="nc" id="L926">        o.setPreviousScanCounter(null);</span>
<span class="nc" id="L927">    }</span>

    @Override
    synchronized MonitorNotification buildAlarmNotification(
                                               ObjectName object,
                                               String attribute,
                                               Comparable&lt;?&gt; value) {
<span class="nc" id="L934">        final CounterMonitorObservedObject o =</span>
<span class="nc" id="L935">            (CounterMonitorObservedObject) getObservedObject(object);</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">        if (o == null)</span>
<span class="nc" id="L937">            return null;</span>

        // Notify the listeners and update the threshold if
        // the updated derived gauge value is valid.
        //
        final MonitorNotification alarm;
<span class="nc bnc" id="L943" title="All 2 branches missed.">        if (o.getDerivedGaugeValid()) {</span>
<span class="nc" id="L944">            alarm = updateNotifications(o);</span>
<span class="nc" id="L945">            updateThreshold(o);</span>
        } else {
<span class="nc" id="L947">            alarm = null;</span>
        }
<span class="nc" id="L949">        return alarm;</span>
    }

    /**
     * Tests if the threshold, offset and modulus of the specified observed
     * object are of the same type as the counter. Only integer types are
     * allowed.
     *
     * Note:
     *   If the optional offset or modulus have not been initialized, their
     *   default value is an Integer object with a value equal to zero.
     *
     * @param object The observed object.
     * @param attribute The observed attribute.
     * @param value The sample value.
     * @return &lt;CODE&gt;true&lt;/CODE&gt; if type is the same,
     * &lt;CODE&gt;false&lt;/CODE&gt; otherwise.
     */
    @Override
    synchronized boolean isThresholdTypeValid(ObjectName object,
                                              String attribute,
                                              Comparable&lt;?&gt; value) {
<span class="nc" id="L971">        final CounterMonitorObservedObject o =</span>
<span class="nc" id="L972">            (CounterMonitorObservedObject) getObservedObject(object);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">        if (o == null)</span>
<span class="nc" id="L974">            return false;</span>

<span class="nc" id="L976">        Class&lt;? extends Number&gt; c = classForType(o.getType());</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">        return (c.isInstance(o.getThreshold()) &amp;&amp;</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">                isValidForType(offset, c) &amp;&amp;</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">                isValidForType(modulus, c));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>