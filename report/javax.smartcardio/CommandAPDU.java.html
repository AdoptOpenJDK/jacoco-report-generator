<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CommandAPDU.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.smartcardio</a> &gt; <span class="el_source">CommandAPDU.java</span></div><h1>CommandAPDU.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.smartcardio;

import java.util.Arrays;

import java.nio.ByteBuffer;

/**
 * A command APDU following the structure defined in ISO/IEC 7816-4.
 * It consists of a four byte header and a conditional body of variable length.
 * This class does not attempt to verify that the APDU encodes a semantically
 * valid command.
 *
 * &lt;p&gt;Note that when the expected length of the response APDU is specified
 * in the {@linkplain #CommandAPDU(int,int,int,int,int) constructors},
 * the actual length (Ne) must be specified, not its
 * encoded form (Le). Similarly, {@linkplain #getNe} returns the actual
 * value Ne. In other words, a value of 0 means &quot;no data in the response APDU&quot;
 * rather than &quot;maximum length.&quot;
 *
 * &lt;p&gt;This class supports both the short and extended forms of length
 * encoding for Ne and Nc. However, note that not all terminals and Smart Cards
 * are capable of accepting APDUs that use the extended form.
 *
 * &lt;p&gt;For the header bytes CLA, INS, P1, and P2 the Java type &lt;code&gt;int&lt;/code&gt;
 * is used to represent the 8 bit unsigned values. In the constructors, only
 * the 8 lowest bits of the &lt;code&gt;int&lt;/code&gt; value specified by the application
 * are significant. The accessor methods always return the byte as an unsigned
 * value between 0 and 255.
 *
 * &lt;p&gt;Instances of this class are immutable. Where data is passed in or out
 * via byte arrays, defensive cloning is performed.
 *
 * @see ResponseAPDU
 * @see CardChannel#transmit CardChannel.transmit
 *
 * @since   1.6
 * @author  Andreas Sterbenz
 * @author  JSR 268 Expert Group
 */
public final class CommandAPDU implements java.io.Serializable {

    private static final long serialVersionUID = 398698301286670877L;

    private static final int MAX_APDU_SIZE = 65544;

    /** @serial */
    private byte[] apdu;

    // value of nc
    private transient int nc;

    // value of ne
    private transient int ne;

    // index of start of data within the apdu array
    private transient int dataOffset;

    /**
     * Constructs a CommandAPDU from a byte array containing the complete
     * APDU contents (header and body).
     *
     * &lt;p&gt;Note that the apdu bytes are copied to protect against
     * subsequent modification.
     *
     * @param apdu the complete command APDU
     *
     * @throws NullPointerException if apdu is null
     * @throws IllegalArgumentException if apdu does not contain a valid
     *   command APDU
     */
<span class="nc" id="L96">    public CommandAPDU(byte[] apdu) {</span>
<span class="nc" id="L97">        this.apdu = apdu.clone();</span>
<span class="nc" id="L98">        parse();</span>
<span class="nc" id="L99">    }</span>

    /**
     * Constructs a CommandAPDU from a byte array containing the complete
     * APDU contents (header and body). The APDU starts at the index
     * &lt;code&gt;apduOffset&lt;/code&gt; in the byte array and is &lt;code&gt;apduLength&lt;/code&gt;
     * bytes long.
     *
     * &lt;p&gt;Note that the apdu bytes are copied to protect against
     * subsequent modification.
     *
     * @param apdu the complete command APDU
     * @param apduOffset the offset in the byte array at which the apdu
     *   data begins
     * @param apduLength the length of the APDU
     *
     * @throws NullPointerException if apdu is null
     * @throws IllegalArgumentException if apduOffset or apduLength are
     *   negative or if apduOffset + apduLength are greater than apdu.length,
     *   or if the specified bytes are not a valid APDU
     */
<span class="nc" id="L120">    public CommandAPDU(byte[] apdu, int apduOffset, int apduLength) {</span>
<span class="nc" id="L121">        checkArrayBounds(apdu, apduOffset, apduLength);</span>
<span class="nc" id="L122">        this.apdu = new byte[apduLength];</span>
<span class="nc" id="L123">        System.arraycopy(apdu, apduOffset, this.apdu, 0, apduLength);</span>
<span class="nc" id="L124">        parse();</span>
<span class="nc" id="L125">    }</span>

    private void checkArrayBounds(byte[] b, int ofs, int len) {
<span class="nc bnc" id="L128" title="All 4 branches missed.">        if ((ofs &lt; 0) || (len &lt; 0)) {</span>
<span class="nc" id="L129">            throw new IllegalArgumentException</span>
                (&quot;Offset and length must not be negative&quot;);
        }
<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (b == null) {</span>
<span class="nc bnc" id="L133" title="All 4 branches missed.">            if ((ofs != 0) &amp;&amp; (len != 0)) {</span>
<span class="nc" id="L134">                throw new IllegalArgumentException</span>
                    (&quot;offset and length must be 0 if array is null&quot;);
            }
        } else {
<span class="nc bnc" id="L138" title="All 2 branches missed.">            if (ofs &gt; b.length - len) {</span>
<span class="nc" id="L139">                throw new IllegalArgumentException</span>
                    (&quot;Offset plus length exceed array size&quot;);
            }
        }
<span class="nc" id="L143">    }</span>

    /**
     * Creates a CommandAPDU from the ByteBuffer containing the complete APDU
     * contents (header and body).
     * The buffer's &lt;code&gt;position&lt;/code&gt; must be set to the start of the APDU,
     * its &lt;code&gt;limit&lt;/code&gt; to the end of the APDU. Upon return, the buffer's
     * &lt;code&gt;position&lt;/code&gt; is equal to its limit; its limit remains unchanged.
     *
     * &lt;p&gt;Note that the data in the ByteBuffer is copied to protect against
     * subsequent modification.
     *
     * @param apdu the ByteBuffer containing the complete APDU
     *
     * @throws NullPointerException if apdu is null
     * @throws IllegalArgumentException if apdu does not contain a valid
     *   command APDU
     */
<span class="nc" id="L161">    public CommandAPDU(ByteBuffer apdu) {</span>
<span class="nc" id="L162">        this.apdu = new byte[apdu.remaining()];</span>
<span class="nc" id="L163">        apdu.get(this.apdu);</span>
<span class="nc" id="L164">        parse();</span>
<span class="nc" id="L165">    }</span>

    /**
     * Constructs a CommandAPDU from the four header bytes. This is case 1
     * in ISO 7816, no command body.
     *
     * @param cla the class byte CLA
     * @param ins the instruction byte INS
     * @param p1 the parameter byte P1
     * @param p2 the parameter byte P2
     */
    public CommandAPDU(int cla, int ins, int p1, int p2) {
<span class="nc" id="L177">        this(cla, ins, p1, p2, null, 0, 0, 0);</span>
<span class="nc" id="L178">    }</span>

    /**
     * Constructs a CommandAPDU from the four header bytes and the expected
     * response data length. This is case 2 in ISO 7816, empty command data
     * field with Ne specified. If Ne is 0, the APDU is encoded as ISO 7816
     * case 1.
     *
     * @param cla the class byte CLA
     * @param ins the instruction byte INS
     * @param p1 the parameter byte P1
     * @param p2 the parameter byte P2
     * @param ne the maximum number of expected data bytes in a response APDU
     *
     * @throws IllegalArgumentException if ne is negative or greater than
     *   65536
     */
    public CommandAPDU(int cla, int ins, int p1, int p2, int ne) {
<span class="nc" id="L196">        this(cla, ins, p1, p2, null, 0, 0, ne);</span>
<span class="nc" id="L197">    }</span>

    /**
     * Constructs a CommandAPDU from the four header bytes and command data.
     * This is case 3 in ISO 7816, command data present and Ne absent. The
     * value Nc is taken as data.length. If &lt;code&gt;data&lt;/code&gt; is null or
     * its length is 0, the APDU is encoded as ISO 7816 case 1.
     *
     * &lt;p&gt;Note that the data bytes are copied to protect against
     * subsequent modification.
     *
     * @param cla the class byte CLA
     * @param ins the instruction byte INS
     * @param p1 the parameter byte P1
     * @param p2 the parameter byte P2
     * @param data the byte array containing the data bytes of the command body
     *
     * @throws IllegalArgumentException if data.length is greater than 65535
     */
    public CommandAPDU(int cla, int ins, int p1, int p2, byte[] data) {
<span class="nc" id="L217">        this(cla, ins, p1, p2, data, 0, arrayLength(data), 0);</span>
<span class="nc" id="L218">    }</span>

    /**
     * Constructs a CommandAPDU from the four header bytes and command data.
     * This is case 3 in ISO 7816, command data present and Ne absent. The
     * value Nc is taken as dataLength. If &lt;code&gt;dataLength&lt;/code&gt;
     * is 0, the APDU is encoded as ISO 7816 case 1.
     *
     * &lt;p&gt;Note that the data bytes are copied to protect against
     * subsequent modification.
     *
     * @param cla the class byte CLA
     * @param ins the instruction byte INS
     * @param p1 the parameter byte P1
     * @param p2 the parameter byte P2
     * @param data the byte array containing the data bytes of the command body
     * @param dataOffset the offset in the byte array at which the data
     *   bytes of the command body begin
     * @param dataLength the number of the data bytes in the command body
     *
     * @throws NullPointerException if data is null and dataLength is not 0
     * @throws IllegalArgumentException if dataOffset or dataLength are
     *   negative or if dataOffset + dataLength are greater than data.length
     *   or if dataLength is greater than 65535
     */
    public CommandAPDU(int cla, int ins, int p1, int p2, byte[] data,
            int dataOffset, int dataLength) {
<span class="nc" id="L245">        this(cla, ins, p1, p2, data, dataOffset, dataLength, 0);</span>
<span class="nc" id="L246">    }</span>

    /**
     * Constructs a CommandAPDU from the four header bytes, command data,
     * and expected response data length. This is case 4 in ISO 7816,
     * command data and Ne present. The value Nc is taken as data.length
     * if &lt;code&gt;data&lt;/code&gt; is non-null and as 0 otherwise. If Ne or Nc
     * are zero, the APDU is encoded as case 1, 2, or 3 per ISO 7816.
     *
     * &lt;p&gt;Note that the data bytes are copied to protect against
     * subsequent modification.
     *
     * @param cla the class byte CLA
     * @param ins the instruction byte INS
     * @param p1 the parameter byte P1
     * @param p2 the parameter byte P2
     * @param data the byte array containing the data bytes of the command body
     * @param ne the maximum number of expected data bytes in a response APDU
     *
     * @throws IllegalArgumentException if data.length is greater than 65535
     *   or if ne is negative or greater than 65536
     */
    public CommandAPDU(int cla, int ins, int p1, int p2, byte[] data, int ne) {
<span class="nc" id="L269">        this(cla, ins, p1, p2, data, 0, arrayLength(data), ne);</span>
<span class="nc" id="L270">    }</span>

    private static int arrayLength(byte[] b) {
<span class="nc bnc" id="L273" title="All 2 branches missed.">        return (b != null) ? b.length : 0;</span>
    }

    /**
     * Command APDU encoding options:
     *
     * case 1:  |CLA|INS|P1 |P2 |                                 len = 4
     * case 2s: |CLA|INS|P1 |P2 |LE |                             len = 5
     * case 3s: |CLA|INS|P1 |P2 |LC |...BODY...|                  len = 6..260
     * case 4s: |CLA|INS|P1 |P2 |LC |...BODY...|LE |              len = 7..261
     * case 2e: |CLA|INS|P1 |P2 |00 |LE1|LE2|                     len = 7
     * case 3e: |CLA|INS|P1 |P2 |00 |LC1|LC2|...BODY...|          len = 8..65542
     * case 4e: |CLA|INS|P1 |P2 |00 |LC1|LC2|...BODY...|LE1|LE2|  len =10..65544
     *
     * LE, LE1, LE2 may be 0x00.
     * LC must not be 0x00 and LC1|LC2 must not be 0x00|0x00
     */
    private void parse() {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (apdu.length &lt; 4) {</span>
<span class="nc" id="L292">            throw new IllegalArgumentException(&quot;apdu must be at least 4 bytes long&quot;);</span>
        }
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (apdu.length == 4) {</span>
            // case 1
<span class="nc" id="L296">            return;</span>
        }
<span class="nc" id="L298">        int l1 = apdu[4] &amp; 0xff;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (apdu.length == 5) {</span>
            // case 2s
<span class="nc bnc" id="L301" title="All 2 branches missed.">            this.ne = (l1 == 0) ? 256 : l1;</span>
<span class="nc" id="L302">            return;</span>
        }
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (l1 != 0) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            if (apdu.length == 4 + 1 + l1) {</span>
                // case 3s
<span class="nc" id="L307">                this.nc = l1;</span>
<span class="nc" id="L308">                this.dataOffset = 5;</span>
<span class="nc" id="L309">                return;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">            } else if (apdu.length == 4 + 2 + l1) {</span>
                // case 4s
<span class="nc" id="L312">                this.nc = l1;</span>
<span class="nc" id="L313">                this.dataOffset = 5;</span>
<span class="nc" id="L314">                int l2 = apdu[apdu.length - 1] &amp; 0xff;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">                this.ne = (l2 == 0) ? 256 : l2;</span>
<span class="nc" id="L316">                return;</span>
            } else {
<span class="nc" id="L318">                throw new IllegalArgumentException</span>
                    (&quot;Invalid APDU: length=&quot; + apdu.length + &quot;, b1=&quot; + l1);
            }
        }
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (apdu.length &lt; 7) {</span>
<span class="nc" id="L323">            throw new IllegalArgumentException</span>
                (&quot;Invalid APDU: length=&quot; + apdu.length + &quot;, b1=&quot; + l1);
        }
<span class="nc" id="L326">        int l2 = ((apdu[5] &amp; 0xff) &lt;&lt; 8) | (apdu[6] &amp; 0xff);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (apdu.length == 7) {</span>
            // case 2e
<span class="nc bnc" id="L329" title="All 2 branches missed.">            this.ne = (l2 == 0) ? 65536 : l2;</span>
<span class="nc" id="L330">            return;</span>
        }
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (l2 == 0) {</span>
<span class="nc" id="L333">            throw new IllegalArgumentException(&quot;Invalid APDU: length=&quot;</span>
                    + apdu.length + &quot;, b1=&quot; + l1 + &quot;, b2||b3=&quot; + l2);
        }
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (apdu.length == 4 + 3 + l2) {</span>
            // case 3e
<span class="nc" id="L338">            this.nc = l2;</span>
<span class="nc" id="L339">            this.dataOffset = 7;</span>
<span class="nc" id="L340">            return;</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        } else if (apdu.length == 4 + 5 + l2) {</span>
            // case 4e
<span class="nc" id="L343">            this.nc = l2;</span>
<span class="nc" id="L344">            this.dataOffset = 7;</span>
<span class="nc" id="L345">            int leOfs = apdu.length - 2;</span>
<span class="nc" id="L346">            int l3 = ((apdu[leOfs] &amp; 0xff) &lt;&lt; 8) | (apdu[leOfs + 1] &amp; 0xff);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            this.ne = (l3 == 0) ? 65536 : l3;</span>
<span class="nc" id="L348">        } else {</span>
<span class="nc" id="L349">            throw new IllegalArgumentException(&quot;Invalid APDU: length=&quot;</span>
                    + apdu.length + &quot;, b1=&quot; + l1 + &quot;, b2||b3=&quot; + l2);
        }
<span class="nc" id="L352">    }</span>

    /**
     * Constructs a CommandAPDU from the four header bytes, command data,
     * and expected response data length. This is case 4 in ISO 7816,
     * command data and Le present. The value Nc is taken as
     * &lt;code&gt;dataLength&lt;/code&gt;.
     * If Ne or Nc
     * are zero, the APDU is encoded as case 1, 2, or 3 per ISO 7816.
     *
     * &lt;p&gt;Note that the data bytes are copied to protect against
     * subsequent modification.
     *
     * @param cla the class byte CLA
     * @param ins the instruction byte INS
     * @param p1 the parameter byte P1
     * @param p2 the parameter byte P2
     * @param data the byte array containing the data bytes of the command body
     * @param dataOffset the offset in the byte array at which the data
     *   bytes of the command body begin
     * @param dataLength the number of the data bytes in the command body
     * @param ne the maximum number of expected data bytes in a response APDU
     *
     * @throws NullPointerException if data is null and dataLength is not 0
     * @throws IllegalArgumentException if dataOffset or dataLength are
     *   negative or if dataOffset + dataLength are greater than data.length,
     *   or if ne is negative or greater than 65536,
     *   or if dataLength is greater than 65535
     */
    public CommandAPDU(int cla, int ins, int p1, int p2, byte[] data,
<span class="nc" id="L382">            int dataOffset, int dataLength, int ne) {</span>
<span class="nc" id="L383">        checkArrayBounds(data, dataOffset, dataLength);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (dataLength &gt; 65535) {</span>
<span class="nc" id="L385">            throw new IllegalArgumentException(&quot;dataLength is too large&quot;);</span>
        }
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (ne &lt; 0) {</span>
<span class="nc" id="L388">            throw new IllegalArgumentException(&quot;ne must not be negative&quot;);</span>
        }
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (ne &gt; 65536) {</span>
<span class="nc" id="L391">            throw new IllegalArgumentException(&quot;ne is too large&quot;);</span>
        }
<span class="nc" id="L393">        this.ne = ne;</span>
<span class="nc" id="L394">        this.nc = dataLength;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (dataLength == 0) {</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (ne == 0) {</span>
                // case 1
<span class="nc" id="L398">                this.apdu = new byte[4];</span>
<span class="nc" id="L399">                setHeader(cla, ins, p1, p2);</span>
            } else {
                // case 2s or 2e
<span class="nc bnc" id="L402" title="All 2 branches missed.">                if (ne &lt;= 256) {</span>
                    // case 2s
                    // 256 is encoded as 0x00
<span class="nc bnc" id="L405" title="All 2 branches missed.">                    byte len = (ne != 256) ? (byte)ne : 0;</span>
<span class="nc" id="L406">                    this.apdu = new byte[5];</span>
<span class="nc" id="L407">                    setHeader(cla, ins, p1, p2);</span>
<span class="nc" id="L408">                    this.apdu[4] = len;</span>
<span class="nc" id="L409">                } else {</span>
                    // case 2e
                    byte l1, l2;
                    // 65536 is encoded as 0x00 0x00
<span class="nc bnc" id="L413" title="All 2 branches missed.">                    if (ne == 65536) {</span>
<span class="nc" id="L414">                        l1 = 0;</span>
<span class="nc" id="L415">                        l2 = 0;</span>
                    } else {
<span class="nc" id="L417">                        l1 = (byte)(ne &gt;&gt; 8);</span>
<span class="nc" id="L418">                        l2 = (byte)ne;</span>
                    }
<span class="nc" id="L420">                    this.apdu = new byte[7];</span>
<span class="nc" id="L421">                    setHeader(cla, ins, p1, p2);</span>
<span class="nc" id="L422">                    this.apdu[5] = l1;</span>
<span class="nc" id="L423">                    this.apdu[6] = l2;</span>
<span class="nc" id="L424">                }</span>
            }
        } else {
<span class="nc bnc" id="L427" title="All 2 branches missed.">            if (ne == 0) {</span>
                // case 3s or 3e
<span class="nc bnc" id="L429" title="All 2 branches missed.">                if (dataLength &lt;= 255) {</span>
                    // case 3s
<span class="nc" id="L431">                    apdu = new byte[4 + 1 + dataLength];</span>
<span class="nc" id="L432">                    setHeader(cla, ins, p1, p2);</span>
<span class="nc" id="L433">                    apdu[4] = (byte)dataLength;</span>
<span class="nc" id="L434">                    this.dataOffset = 5;</span>
<span class="nc" id="L435">                    System.arraycopy(data, dataOffset, apdu, 5, dataLength);</span>
                } else {
                    // case 3e
<span class="nc" id="L438">                    apdu = new byte[4 + 3 + dataLength];</span>
<span class="nc" id="L439">                    setHeader(cla, ins, p1, p2);</span>
<span class="nc" id="L440">                    apdu[4] = 0;</span>
<span class="nc" id="L441">                    apdu[5] = (byte)(dataLength &gt;&gt; 8);</span>
<span class="nc" id="L442">                    apdu[6] = (byte)dataLength;</span>
<span class="nc" id="L443">                    this.dataOffset = 7;</span>
<span class="nc" id="L444">                    System.arraycopy(data, dataOffset, apdu, 7, dataLength);</span>
                }
            } else {
                // case 4s or 4e
<span class="nc bnc" id="L448" title="All 4 branches missed.">                if ((dataLength &lt;= 255) &amp;&amp; (ne &lt;= 256)) {</span>
                    // case 4s
<span class="nc" id="L450">                    apdu = new byte[4 + 2 + dataLength];</span>
<span class="nc" id="L451">                    setHeader(cla, ins, p1, p2);</span>
<span class="nc" id="L452">                    apdu[4] = (byte)dataLength;</span>
<span class="nc" id="L453">                    this.dataOffset = 5;</span>
<span class="nc" id="L454">                    System.arraycopy(data, dataOffset, apdu, 5, dataLength);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">                    apdu[apdu.length - 1] = (ne != 256) ? (byte)ne : 0;</span>
                } else {
                    // case 4e
<span class="nc" id="L458">                    apdu = new byte[4 + 5 + dataLength];</span>
<span class="nc" id="L459">                    setHeader(cla, ins, p1, p2);</span>
<span class="nc" id="L460">                    apdu[4] = 0;</span>
<span class="nc" id="L461">                    apdu[5] = (byte)(dataLength &gt;&gt; 8);</span>
<span class="nc" id="L462">                    apdu[6] = (byte)dataLength;</span>
<span class="nc" id="L463">                    this.dataOffset = 7;</span>
<span class="nc" id="L464">                    System.arraycopy(data, dataOffset, apdu, 7, dataLength);</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                    if (ne != 65536) {</span>
<span class="nc" id="L466">                        int leOfs = apdu.length - 2;</span>
<span class="nc" id="L467">                        apdu[leOfs] = (byte)(ne &gt;&gt; 8);</span>
<span class="nc" id="L468">                        apdu[leOfs + 1] = (byte)ne;</span>
                    } // else le == 65536: no need to fill in, encoded as 0
                }
            }
        }
<span class="nc" id="L473">    }</span>

    private void setHeader(int cla, int ins, int p1, int p2) {
<span class="nc" id="L476">        apdu[0] = (byte)cla;</span>
<span class="nc" id="L477">        apdu[1] = (byte)ins;</span>
<span class="nc" id="L478">        apdu[2] = (byte)p1;</span>
<span class="nc" id="L479">        apdu[3] = (byte)p2;</span>
<span class="nc" id="L480">    }</span>

    /**
     * Returns the value of the class byte CLA.
     *
     * @return the value of the class byte CLA.
     */
    public int getCLA() {
<span class="nc" id="L488">        return apdu[0] &amp; 0xff;</span>
    }

    /**
     * Returns the value of the instruction byte INS.
     *
     * @return the value of the instruction byte INS.
     */
    public int getINS() {
<span class="nc" id="L497">        return apdu[1] &amp; 0xff;</span>
    }

    /**
     * Returns the value of the parameter byte P1.
     *
     * @return the value of the parameter byte P1.
     */
    public int getP1() {
<span class="nc" id="L506">        return apdu[2] &amp; 0xff;</span>
    }

    /**
     * Returns the value of the parameter byte P2.
     *
     * @return the value of the parameter byte P2.
     */
    public int getP2() {
<span class="nc" id="L515">        return apdu[3] &amp; 0xff;</span>
    }

    /**
     * Returns the number of data bytes in the command body (Nc) or 0 if this
     * APDU has no body. This call is equivalent to
     * &lt;code&gt;getData().length&lt;/code&gt;.
     *
     * @return the number of data bytes in the command body or 0 if this APDU
     * has no body.
     */
    public int getNc() {
<span class="nc" id="L527">        return nc;</span>
    }

    /**
     * Returns a copy of the data bytes in the command body. If this APDU as
     * no body, this method returns a byte array with length zero.
     *
     * @return a copy of the data bytes in the command body or the empty
     *    byte array if this APDU has no body.
     */
    public byte[] getData() {
<span class="nc" id="L538">        byte[] data = new byte[nc];</span>
<span class="nc" id="L539">        System.arraycopy(apdu, dataOffset, data, 0, nc);</span>
<span class="nc" id="L540">        return data;</span>
    }

    /**
     * Returns the maximum number of expected data bytes in a response
     * APDU (Ne).
     *
     * @return the maximum number of expected data bytes in a response APDU.
     */
    public int getNe() {
<span class="nc" id="L550">        return ne;</span>
    }

    /**
     * Returns a copy of the bytes in this APDU.
     *
     * @return a copy of the bytes in this APDU.
     */
    public byte[] getBytes() {
<span class="nc" id="L559">        return apdu.clone();</span>
    }

    /**
     * Returns a string representation of this command APDU.
     *
     * @return a String representation of this command APDU.
     */
    public String toString() {
<span class="nc" id="L568">        return &quot;CommmandAPDU: &quot; + apdu.length + &quot; bytes, nc=&quot; + nc + &quot;, ne=&quot; + ne;</span>
    }

    /**
     * Compares the specified object with this command APDU for equality.
     * Returns true if the given object is also a CommandAPDU and its bytes are
     * identical to the bytes in this CommandAPDU.
     *
     * @param obj the object to be compared for equality with this command APDU
     * @return true if the specified object is equal to this command APDU
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L581">            return true;</span>
        }
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (obj instanceof CommandAPDU == false) {</span>
<span class="nc" id="L584">            return false;</span>
        }
<span class="nc" id="L586">        CommandAPDU other = (CommandAPDU)obj;</span>
<span class="nc" id="L587">        return Arrays.equals(this.apdu, other.apdu);</span>
     }

    /**
     * Returns the hash code value for this command APDU.
     *
     * @return the hash code value for this command APDU.
     */
    public int hashCode() {
<span class="nc" id="L596">        return Arrays.hashCode(apdu);</span>
    }

    private void readObject(java.io.ObjectInputStream in)
            throws java.io.IOException, ClassNotFoundException {
<span class="nc" id="L601">        apdu = (byte[])in.readUnshared();</span>
        // initialize transient fields
<span class="nc" id="L603">        parse();</span>
<span class="nc" id="L604">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>