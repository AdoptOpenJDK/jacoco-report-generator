<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FileTime.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.nio.file.attribute</a> &gt; <span class="el_source">FileTime.java</span></div><h1>FileTime.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.nio.file.attribute;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

/**
 * Represents the value of a file's time stamp attribute. For example, it may
 * represent the time that the file was last
 * {@link BasicFileAttributes#lastModifiedTime() modified},
 * {@link BasicFileAttributes#lastAccessTime() accessed},
 * or {@link BasicFileAttributes#creationTime() created}.
 *
 * &lt;p&gt; Instances of this class are immutable.
 *
 * @since 1.7
 * @see java.nio.file.Files#setLastModifiedTime
 * @see java.nio.file.Files#getLastModifiedTime
 */

public final class FileTime
    implements Comparable&lt;FileTime&gt;
{
    /**
     * The unit of granularity to interpret the value. Null if
     * this {@code FileTime} is converted from an {@code Instant},
     * the {@code value} and {@code unit} pair will not be used
     * in this scenario.
     */
    private final TimeUnit unit;

    /**
     * The value since the epoch; can be negative.
     */
    private final long value;

    /**
     * The value as Instant (created lazily, if not from an instant)
     */
    private Instant instant;

    /**
     * The value return by toString (created lazily)
     */
    private String valueAsString;

    /**
     * Initializes a new instance of this class.
     */
<span class="fc" id="L77">    private FileTime(long value, TimeUnit unit, Instant instant) {</span>
<span class="fc" id="L78">        this.value = value;</span>
<span class="fc" id="L79">        this.unit = unit;</span>
<span class="fc" id="L80">        this.instant = instant;</span>
<span class="fc" id="L81">    }</span>

    /**
     * Returns a {@code FileTime} representing a value at the given unit of
     * granularity.
     *
     * @param   value
     *          the value since the epoch (1970-01-01T00:00:00Z); can be
     *          negative
     * @param   unit
     *          the unit of granularity to interpret the value
     *
     * @return  a {@code FileTime} representing the given value
     */
    public static FileTime from(long value, TimeUnit unit) {
<span class="fc" id="L96">        Objects.requireNonNull(unit, &quot;unit&quot;);</span>
<span class="fc" id="L97">        return new FileTime(value, unit, null);</span>
    }

    /**
     * Returns a {@code FileTime} representing the given value in milliseconds.
     *
     * @param   value
     *          the value, in milliseconds, since the epoch
     *          (1970-01-01T00:00:00Z); can be negative
     *
     * @return  a {@code FileTime} representing the given value
     */
    public static FileTime fromMillis(long value) {
<span class="fc" id="L110">        return new FileTime(value, TimeUnit.MILLISECONDS, null);</span>
    }

    /**
     * Returns a {@code FileTime} representing the same point of time value
     * on the time-line as the provided {@code Instant} object.
     *
     * @param   instant
     *          the instant to convert
     * @return  a {@code FileTime} representing the same point on the time-line
     *          as the provided instant
     * @since 1.8
     */
    public static FileTime from(Instant instant) {
<span class="nc" id="L124">        Objects.requireNonNull(instant, &quot;instant&quot;);</span>
<span class="nc" id="L125">        return new FileTime(0, null, instant);</span>
    }

    /**
     * Returns the value at the given unit of granularity.
     *
     * &lt;p&gt; Conversion from a coarser granularity that would numerically overflow
     * saturate to {@code Long.MIN_VALUE} if negative or {@code Long.MAX_VALUE}
     * if positive.
     *
     * @param   unit
     *          the unit of granularity for the return value
     *
     * @return  value in the given unit of granularity, since the epoch
     *          since the epoch (1970-01-01T00:00:00Z); can be negative
     */
    public long to(TimeUnit unit) {
<span class="fc" id="L142">        Objects.requireNonNull(unit, &quot;unit&quot;);</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (this.unit != null) {</span>
<span class="fc" id="L144">            return unit.convert(this.value, this.unit);</span>
        } else {
<span class="nc" id="L146">            long secs = unit.convert(instant.getEpochSecond(), TimeUnit.SECONDS);</span>
<span class="nc bnc" id="L147" title="All 4 branches missed.">            if (secs == Long.MIN_VALUE || secs == Long.MAX_VALUE) {</span>
<span class="nc" id="L148">                return secs;</span>
            }
<span class="nc" id="L150">            long nanos = unit.convert(instant.getNano(), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L151">            long r = secs + nanos;</span>
            // Math.addExact() variant
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (((secs ^ r) &amp; (nanos ^ r)) &lt; 0) {</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                return (secs &lt; 0) ? Long.MIN_VALUE : Long.MAX_VALUE;</span>
            }
<span class="nc" id="L156">            return r;</span>
        }
    }

    /**
     * Returns the value in milliseconds.
     *
     * &lt;p&gt; Conversion from a coarser granularity that would numerically overflow
     * saturate to {@code Long.MIN_VALUE} if negative or {@code Long.MAX_VALUE}
     * if positive.
     *
     * @return  the value in milliseconds, since the epoch (1970-01-01T00:00:00Z)
     */
    public long toMillis() {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (unit != null) {</span>
<span class="fc" id="L171">            return unit.toMillis(value);</span>
        } else {
<span class="nc" id="L173">            long secs = instant.getEpochSecond();</span>
<span class="nc" id="L174">            int  nanos = instant.getNano();</span>
            // Math.multiplyExact() variant
<span class="nc" id="L176">            long r = secs * 1000;</span>
<span class="nc" id="L177">            long ax = Math.abs(secs);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            if (((ax | 1000) &gt;&gt;&gt; 31 != 0)) {</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">                if ((r / 1000) != secs) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                    return (secs &lt; 0) ? Long.MIN_VALUE : Long.MAX_VALUE;</span>
                }
            }
<span class="nc" id="L183">            return r + nanos / 1000_000;</span>
        }
    }

    /**
     * Time unit constants for conversion.
     */
    private static final long HOURS_PER_DAY      = 24L;
    private static final long MINUTES_PER_HOUR   = 60L;
    private static final long SECONDS_PER_MINUTE = 60L;
    private static final long SECONDS_PER_HOUR   = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
    private static final long SECONDS_PER_DAY    = SECONDS_PER_HOUR * HOURS_PER_DAY;
    private static final long MILLIS_PER_SECOND  = 1000L;
    private static final long MICROS_PER_SECOND  = 1000_000L;
    private static final long NANOS_PER_SECOND   = 1000_000_000L;
    private static final int  NANOS_PER_MILLI    = 1000_000;
    private static final int  NANOS_PER_MICRO    = 1000;
    // The epoch second of Instant.MIN.
    private static final long MIN_SECOND = -31557014167219200L;
    // The epoch second of Instant.MAX.
    private static final long MAX_SECOND = 31556889864403199L;

    /*
     * Scale d by m, checking for overflow.
     */
    private static long scale(long d, long m, long over) {
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (d &gt;  over) return Long.MAX_VALUE;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (d &lt; -over) return Long.MIN_VALUE;</span>
<span class="nc" id="L211">        return d * m;</span>
    }

    /**
     * Converts this {@code FileTime} object to an {@code Instant}.
     *
     * &lt;p&gt; The conversion creates an {@code Instant} that represents the
     * same point on the time-line as this {@code FileTime}.
     *
     * &lt;p&gt; {@code FileTime} can store points on the time-line further in the
     * future and further in the past than {@code Instant}. Conversion
     * from such further time points saturates to {@link Instant#MIN} if
     * earlier than {@code Instant.MIN} or {@link Instant#MAX} if later
     * than {@code Instant.MAX}.
     *
     * @return  an instant representing the same point on the time-line as
     *          this {@code FileTime} object
     * @since 1.8
     */
    public Instant toInstant() {
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (instant == null) {</span>
<span class="fc" id="L232">            long secs = 0L;</span>
<span class="fc" id="L233">            int nanos = 0;</span>
<span class="pc bpc" id="L234" title="6 of 8 branches missed.">            switch (unit) {</span>
                case DAYS:
<span class="nc" id="L236">                    secs = scale(value, SECONDS_PER_DAY,</span>
                                 Long.MAX_VALUE/SECONDS_PER_DAY);
<span class="nc" id="L238">                    break;</span>
                case HOURS:
<span class="nc" id="L240">                    secs = scale(value, SECONDS_PER_HOUR,</span>
                                 Long.MAX_VALUE/SECONDS_PER_HOUR);
<span class="nc" id="L242">                    break;</span>
                case MINUTES:
<span class="nc" id="L244">                    secs = scale(value, SECONDS_PER_MINUTE,</span>
                                 Long.MAX_VALUE/SECONDS_PER_MINUTE);
<span class="nc" id="L246">                    break;</span>
                case SECONDS:
<span class="fc" id="L248">                    secs = value;</span>
<span class="fc" id="L249">                    break;</span>
                case MILLISECONDS:
<span class="fc" id="L251">                    secs = Math.floorDiv(value, MILLIS_PER_SECOND);</span>
<span class="fc" id="L252">                    nanos = (int)Math.floorMod(value, MILLIS_PER_SECOND)</span>
                            * NANOS_PER_MILLI;
<span class="fc" id="L254">                    break;</span>
                case MICROSECONDS:
<span class="nc" id="L256">                    secs = Math.floorDiv(value, MICROS_PER_SECOND);</span>
<span class="nc" id="L257">                    nanos = (int)Math.floorMod(value, MICROS_PER_SECOND)</span>
                            * NANOS_PER_MICRO;
<span class="nc" id="L259">                    break;</span>
                case NANOSECONDS:
<span class="nc" id="L261">                    secs = Math.floorDiv(value, NANOS_PER_SECOND);</span>
<span class="nc" id="L262">                    nanos = (int)Math.floorMod(value, NANOS_PER_SECOND);</span>
<span class="nc" id="L263">                    break;</span>
<span class="nc" id="L264">                default : throw new AssertionError(&quot;Unit not handled&quot;);</span>
            }
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">            if (secs &lt;= MIN_SECOND)</span>
<span class="nc" id="L267">                instant = Instant.MIN;</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">            else if (secs &gt;= MAX_SECOND)</span>
<span class="nc" id="L269">                instant = Instant.MAX;</span>
            else
<span class="fc" id="L271">                instant = Instant.ofEpochSecond(secs, nanos);</span>
        }
<span class="fc" id="L273">        return instant;</span>
    }

    /**
     * Tests this {@code FileTime} for equality with the given object.
     *
     * &lt;p&gt; The result is {@code true} if and only if the argument is not {@code
     * null} and is a {@code FileTime} that represents the same time. This
     * method satisfies the general contract of the {@code Object.equals} method.
     *
     * @param   obj
     *          the object to compare with
     *
     * @return  {@code true} if, and only if, the given object is a {@code
     *          FileTime} that represents the same time
     */
    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L291" title="2 of 4 branches missed.">        return (obj instanceof FileTime) ? compareTo((FileTime)obj) == 0 : false;</span>
    }

    /**
     * Computes a hash code for this file time.
     *
     * &lt;p&gt; The hash code is based upon the value represented, and satisfies the
     * general contract of the {@link Object#hashCode} method.
     *
     * @return  the hash-code value
     */
    @Override
    public int hashCode() {
        // hashcode of instant representation to satisfy contract with equals
<span class="nc" id="L305">        return toInstant().hashCode();</span>
    }

    private long toDays() {
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (unit != null) {</span>
<span class="nc" id="L310">            return unit.toDays(value);</span>
        } else {
<span class="nc" id="L312">            return TimeUnit.SECONDS.toDays(toInstant().getEpochSecond());</span>
        }
    }

    private long toExcessNanos(long days) {
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (unit != null) {</span>
<span class="nc" id="L318">            return unit.toNanos(value - unit.convert(days, TimeUnit.DAYS));</span>
        } else {
<span class="nc" id="L320">            return TimeUnit.SECONDS.toNanos(toInstant().getEpochSecond()</span>
<span class="nc" id="L321">                                            - TimeUnit.DAYS.toSeconds(days));</span>
        }
    }

    /**
     * Compares the value of two {@code FileTime} objects for order.
     *
     * @param   other
     *          the other {@code FileTime} to be compared
     *
     * @return  {@code 0} if this {@code FileTime} is equal to {@code other}, a
     *          value less than 0 if this {@code FileTime} represents a time
     *          that is before {@code other}, and a value greater than 0 if this
     *          {@code FileTime} represents a time that is after {@code other}
     */
    @Override
    public int compareTo(FileTime other) {
        // same granularity
<span class="pc bpc" id="L339" title="1 of 4 branches missed.">        if (unit != null &amp;&amp; unit == other.unit) {</span>
<span class="fc" id="L340">            return Long.compare(value, other.value);</span>
        } else {
            // compare using instant representation when unit differs
<span class="fc" id="L343">            long secs = toInstant().getEpochSecond();</span>
<span class="fc" id="L344">            long secsOther = other.toInstant().getEpochSecond();</span>
<span class="fc" id="L345">            int cmp = Long.compare(secs, secsOther);</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">            if (cmp != 0) {</span>
<span class="nc" id="L347">                return cmp;</span>
            }
<span class="fc" id="L349">            cmp = Long.compare(toInstant().getNano(), other.toInstant().getNano());</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if (cmp != 0) {</span>
<span class="nc" id="L351">                return cmp;</span>
            }
<span class="pc bpc" id="L353" title="2 of 4 branches missed.">            if (secs != MAX_SECOND &amp;&amp; secs != MIN_SECOND) {</span>
<span class="fc" id="L354">                return 0;</span>
            }
            // if both this and other's Instant reps are MIN/MAX,
            // use daysSinceEpoch and nanosOfDays, which will not
            // saturate during calculation.
<span class="nc" id="L359">            long days = toDays();</span>
<span class="nc" id="L360">            long daysOther = other.toDays();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">            if (days == daysOther) {</span>
<span class="nc" id="L362">                return Long.compare(toExcessNanos(days), other.toExcessNanos(daysOther));</span>
            }
<span class="nc" id="L364">            return Long.compare(days, daysOther);</span>
        }
    }

    // days in a 400 year cycle = 146097
    // days in a 10,000 year cycle = 146097 * 25
    // seconds per day = 86400
    private static final long DAYS_PER_10000_YEARS = 146097L * 25L;
    private static final long SECONDS_PER_10000_YEARS = 146097L * 25L * 86400L;
    private static final long SECONDS_0000_TO_1970 = ((146097L * 5L) - (30L * 365L + 7L)) * 86400L;

    // append year/month/day/hour/minute/second/nano with width and 0 padding
    private StringBuilder append(StringBuilder sb, int w, int d) {
<span class="fc bfc" id="L377" title="All 2 branches covered.">        while (w &gt; 0) {</span>
<span class="fc" id="L378">            sb.append((char)(d/w + '0'));</span>
<span class="fc" id="L379">            d = d % w;</span>
<span class="fc" id="L380">            w /= 10;</span>
        }
<span class="fc" id="L382">        return sb;</span>
    }

    /**
     * Returns the string representation of this {@code FileTime}. The string
     * is returned in the &lt;a
     * href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO&amp;nbsp;8601&lt;/a&gt; format:
     * &lt;pre&gt;
     *     YYYY-MM-DDThh:mm:ss[.s+]Z
     * &lt;/pre&gt;
     * where &quot;{@code [.s+]}&quot; represents a dot followed by one of more digits
     * for the decimal fraction of a second. It is only present when the decimal
     * fraction of a second is not zero. For example, {@code
     * FileTime.fromMillis(1234567890000L).toString()} yields {@code
     * &quot;2009-02-13T23:31:30Z&quot;}, and {@code FileTime.fromMillis(1234567890123L).toString()}
     * yields {@code &quot;2009-02-13T23:31:30.123Z&quot;}.
     *
     * &lt;p&gt; A {@code FileTime} is primarily intended to represent the value of a
     * file's time stamp. Where used to represent &lt;i&gt;extreme values&lt;/i&gt;, where
     * the year is less than &quot;{@code 0001}&quot; or greater than &quot;{@code 9999}&quot; then
     * this method deviates from ISO 8601 in the same manner as the
     * &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#deviantformats&quot;&gt;XML Schema
     * language&lt;/a&gt;. That is, the year may be expanded to more than four digits
     * and may be negative-signed. If more than four digits then leading zeros
     * are not present. The year before &quot;{@code 0001}&quot; is &quot;{@code -0001}&quot;.
     *
     * @return  the string representation of this file time
     */
    @Override
    public String toString() {
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if (valueAsString == null) {</span>
<span class="fc" id="L413">            long secs = 0L;</span>
<span class="fc" id="L414">            int  nanos = 0;</span>
<span class="pc bpc" id="L415" title="1 of 4 branches missed.">            if (instant == null &amp;&amp; unit.compareTo(TimeUnit.SECONDS) &gt;= 0) {</span>
<span class="fc" id="L416">                secs = unit.toSeconds(value);</span>
            } else {
<span class="fc" id="L418">                secs = toInstant().getEpochSecond();</span>
<span class="fc" id="L419">                nanos = toInstant().getNano();</span>
            }
            LocalDateTime ldt;
<span class="fc" id="L422">            int year = 0;</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            if (secs &gt;= -SECONDS_0000_TO_1970) {</span>
                // current era
<span class="fc" id="L425">                long zeroSecs = secs - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;</span>
<span class="fc" id="L426">                long hi = Math.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;</span>
<span class="fc" id="L427">                long lo = Math.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);</span>
<span class="fc" id="L428">                ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, nanos, ZoneOffset.UTC);</span>
<span class="fc" id="L429">                year = ldt.getYear() +  (int)hi * 10000;</span>
<span class="fc" id="L430">            } else {</span>
                // before current era
<span class="nc" id="L432">                long zeroSecs = secs + SECONDS_0000_TO_1970;</span>
<span class="nc" id="L433">                long hi = zeroSecs / SECONDS_PER_10000_YEARS;</span>
<span class="nc" id="L434">                long lo = zeroSecs % SECONDS_PER_10000_YEARS;</span>
<span class="nc" id="L435">                ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, nanos, ZoneOffset.UTC);</span>
<span class="nc" id="L436">                year = ldt.getYear() + (int)hi * 10000;</span>
            }
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">            if (year &lt;= 0) {</span>
<span class="nc" id="L439">                year = year - 1;</span>
            }
<span class="fc" id="L441">            int fraction = ldt.getNano();</span>
<span class="fc" id="L442">            StringBuilder sb = new StringBuilder(64);</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">            sb.append(year &lt; 0 ? &quot;-&quot; : &quot;&quot;);</span>
<span class="fc" id="L444">            year = Math.abs(year);</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">            if (year &lt; 10000) {</span>
<span class="fc" id="L446">                append(sb, 1000, Math.abs(year));</span>
            } else {
<span class="nc" id="L448">                sb.append(String.valueOf(year));</span>
            }
<span class="fc" id="L450">            sb.append('-');</span>
<span class="fc" id="L451">            append(sb, 10, ldt.getMonthValue());</span>
<span class="fc" id="L452">            sb.append('-');</span>
<span class="fc" id="L453">            append(sb, 10, ldt.getDayOfMonth());</span>
<span class="fc" id="L454">            sb.append('T');</span>
<span class="fc" id="L455">            append(sb, 10, ldt.getHour());</span>
<span class="fc" id="L456">            sb.append(':');</span>
<span class="fc" id="L457">            append(sb, 10, ldt.getMinute());</span>
<span class="fc" id="L458">            sb.append(':');</span>
<span class="fc" id="L459">            append(sb, 10, ldt.getSecond());</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">            if (fraction != 0) {</span>
<span class="nc" id="L461">                sb.append('.');</span>
                // adding leading zeros and stripping any trailing zeros
<span class="nc" id="L463">                int w = 100_000_000;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                while (fraction % 10 == 0) {</span>
<span class="nc" id="L465">                    fraction /= 10;</span>
<span class="nc" id="L466">                    w /= 10;</span>
                }
<span class="nc" id="L468">                append(sb, w, fraction);</span>
            }
<span class="fc" id="L470">            sb.append('Z');</span>
<span class="fc" id="L471">            valueAsString = sb.toString();</span>
        }
<span class="fc" id="L473">        return valueAsString;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>