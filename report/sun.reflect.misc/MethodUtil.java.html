<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MethodUtil.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.reflect.misc</a> &gt; <span class="el_source">MethodUtil.java</span></div><h1>MethodUtil.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.reflect.misc;

import java.security.AllPermission;
import java.security.AccessController;
import java.security.PermissionCollection;
import java.security.SecureClassLoader;
import java.security.PrivilegedExceptionAction;
import java.security.CodeSource;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.net.URL;
import java.net.URLConnection;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.Map;
import sun.misc.IOUtils;


<span class="nc" id="L48">class Trampoline {</span>
    static {
<span class="nc bnc" id="L50" title="All 2 branches missed.">        if (Trampoline.class.getClassLoader() == null) {</span>
<span class="nc" id="L51">            throw new Error(</span>
                &quot;Trampoline must not be defined by the bootstrap classloader&quot;);
        }
<span class="nc" id="L54">    }</span>

    private static void ensureInvocableMethod(Method m)
        throws InvocationTargetException
    {
<span class="nc" id="L59">        Class&lt;?&gt; clazz = m.getDeclaringClass();</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">        if (clazz.equals(AccessController.class) ||</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">            clazz.equals(Method.class) ||</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">            clazz.getName().startsWith(&quot;java.lang.invoke.&quot;))</span>
<span class="nc" id="L63">            throw new InvocationTargetException(</span>
                new UnsupportedOperationException(&quot;invocation not supported&quot;));
<span class="nc" id="L65">    }</span>

    private static Object invoke(Method m, Object obj, Object[] params)
        throws InvocationTargetException, IllegalAccessException
    {
<span class="nc" id="L70">        ensureInvocableMethod(m);</span>
<span class="nc" id="L71">        return m.invoke(obj, params);</span>
    }
}

/*
 * Create a trampoline class.
 */
public final class MethodUtil extends SecureClassLoader {
<span class="nc" id="L79">    private static String MISC_PKG = &quot;sun.reflect.misc.&quot;;</span>
<span class="nc" id="L80">    private static String TRAMPOLINE = MISC_PKG + &quot;Trampoline&quot;;</span>
<span class="nc" id="L81">    private static Method bounce = getTrampoline();</span>

    private MethodUtil() {
<span class="nc" id="L84">        super();</span>
<span class="nc" id="L85">    }</span>

    public static Method getMethod(Class&lt;?&gt; cls, String name, Class&lt;?&gt;[] args)
        throws NoSuchMethodException {
<span class="nc" id="L89">        ReflectUtil.checkPackageAccess(cls);</span>
<span class="nc" id="L90">        return cls.getMethod(name, args);</span>
    }

    public static Method[] getMethods(Class&lt;?&gt; cls) {
<span class="nc" id="L94">        ReflectUtil.checkPackageAccess(cls);</span>
<span class="nc" id="L95">        return cls.getMethods();</span>
    }

    /*
     * Discover the public methods on public classes
     * and interfaces accessible to any caller by calling
     * Class.getMethods() and walking towards Object until
     * we're done.
     */
     public static Method[] getPublicMethods(Class&lt;?&gt; cls) {
        // compatibility for update release
<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (System.getSecurityManager() == null) {</span>
<span class="nc" id="L107">            return cls.getMethods();</span>
        }
<span class="nc" id="L109">        Map&lt;Signature, Method&gt; sigs = new HashMap&lt;Signature, Method&gt;();</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        while (cls != null) {</span>
<span class="nc" id="L111">            boolean done = getInternalPublicMethods(cls, sigs);</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">            if (done) {</span>
<span class="nc" id="L113">                break;</span>
            }
<span class="nc" id="L115">            getInterfaceMethods(cls, sigs);</span>
<span class="nc" id="L116">            cls = cls.getSuperclass();</span>
<span class="nc" id="L117">        }</span>
<span class="nc" id="L118">        return sigs.values().toArray(new Method[sigs.size()]);</span>
    }

    /*
     * Process the immediate interfaces of this class or interface.
     */
    private static void getInterfaceMethods(Class&lt;?&gt; cls,
                                            Map&lt;Signature, Method&gt; sigs) {
<span class="nc" id="L126">        Class&lt;?&gt;[] intfs = cls.getInterfaces();</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        for (int i=0; i &lt; intfs.length; i++) {</span>
<span class="nc" id="L128">            Class&lt;?&gt; intf = intfs[i];</span>
<span class="nc" id="L129">            boolean done = getInternalPublicMethods(intf, sigs);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (!done) {</span>
<span class="nc" id="L131">                getInterfaceMethods(intf, sigs);</span>
            }
        }
<span class="nc" id="L134">    }</span>

    /*
     *
     * Process the methods in this class or interface
     */
    private static boolean getInternalPublicMethods(Class&lt;?&gt; cls,
                                                    Map&lt;Signature, Method&gt; sigs) {
<span class="nc" id="L142">        Method[] methods = null;</span>
        try {
            /*
             * This class or interface is non-public so we
             * can't use any of it's methods. Go back and
             * try again with a superclass or superinterface.
             */
<span class="nc bnc" id="L149" title="All 2 branches missed.">            if (!Modifier.isPublic(cls.getModifiers())) {</span>
<span class="nc" id="L150">                return false;</span>
            }
<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (!ReflectUtil.isPackageAccessible(cls)) {</span>
<span class="nc" id="L153">                return false;</span>
            }

<span class="nc" id="L156">            methods = cls.getMethods();</span>
<span class="nc" id="L157">        } catch (SecurityException se) {</span>
<span class="nc" id="L158">            return false;</span>
<span class="nc" id="L159">        }</span>

        /*
         * Check for inherited methods with non-public
         * declaring classes. They might override and hide
         * methods from their superclasses or
         * superinterfaces.
         */
<span class="nc" id="L167">        boolean done = true;</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        for (int i=0; i &lt; methods.length; i++) {</span>
<span class="nc" id="L169">            Class&lt;?&gt; dc = methods[i].getDeclaringClass();</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (!Modifier.isPublic(dc.getModifiers())) {</span>
<span class="nc" id="L171">                done = false;</span>
<span class="nc" id="L172">                break;</span>
            }
        }

<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (done) {</span>
            /*
             * We're done. Spray all the methods into
             * the list and then we're out of here.
             */
<span class="nc bnc" id="L181" title="All 2 branches missed.">            for (int i=0; i &lt; methods.length; i++) {</span>
<span class="nc" id="L182">                addMethod(sigs, methods[i]);</span>
            }
        } else {
            /*
             * Simulate cls.getDeclaredMethods() by
             * stripping away inherited methods.
             */
<span class="nc bnc" id="L189" title="All 2 branches missed.">            for (int i=0; i &lt; methods.length; i++) {</span>
<span class="nc" id="L190">                Class&lt;?&gt; dc = methods[i].getDeclaringClass();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                if (cls.equals(dc)) {</span>
<span class="nc" id="L192">                    addMethod(sigs, methods[i]);</span>
                }
            }
        }
<span class="nc" id="L196">        return done;</span>
    }

    private static void addMethod(Map&lt;Signature, Method&gt; sigs, Method method) {
<span class="nc" id="L200">        Signature signature = new Signature(method);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (!sigs.containsKey(signature)) {</span>
<span class="nc" id="L202">            sigs.put(signature, method);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        } else if (!method.getDeclaringClass().isInterface()){</span>
            /*
             * Superclasses beat interfaces.
             */
<span class="nc" id="L207">            Method old = sigs.get(signature);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if (old.getDeclaringClass().isInterface()) {</span>
<span class="nc" id="L209">                sigs.put(signature, method);</span>
            }
        }
<span class="nc" id="L212">    }</span>

    /**
     * A class that represents the unique elements of a method that will be a
     * key in the method cache.
     */
    private static class Signature {
        private String methodName;
        private Class&lt;?&gt;[] argClasses;

<span class="nc" id="L222">        private volatile int hashCode = 0;</span>

<span class="nc" id="L224">        Signature(Method m) {</span>
<span class="nc" id="L225">            this.methodName = m.getName();</span>
<span class="nc" id="L226">            this.argClasses = m.getParameterTypes();</span>
<span class="nc" id="L227">        }</span>

        public boolean equals(Object o2) {
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (this == o2) {</span>
<span class="nc" id="L231">                return true;</span>
            }
<span class="nc" id="L233">            Signature that = (Signature)o2;</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (!(methodName.equals(that.methodName))) {</span>
<span class="nc" id="L235">                return false;</span>
            }
<span class="nc bnc" id="L237" title="All 2 branches missed.">            if (argClasses.length != that.argClasses.length) {</span>
<span class="nc" id="L238">                return false;</span>
            }
<span class="nc bnc" id="L240" title="All 2 branches missed.">            for (int i = 0; i &lt; argClasses.length; i++) {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                if (!(argClasses[i] == that.argClasses[i])) {</span>
<span class="nc" id="L242">                  return false;</span>
                }
            }
<span class="nc" id="L245">            return true;</span>
        }

        /**
         * Hash code computed using algorithm suggested in
         * Effective Java, Item 8.
         */
        public int hashCode() {
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (hashCode == 0) {</span>
<span class="nc" id="L254">                int result = 17;</span>
<span class="nc" id="L255">                result = 37 * result + methodName.hashCode();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">                if (argClasses != null) {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">                    for (int i = 0; i &lt; argClasses.length; i++) {</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">                        result = 37 * result + ((argClasses[i] == null) ? 0 :</span>
<span class="nc" id="L259">                            argClasses[i].hashCode());</span>
                    }
                }
<span class="nc" id="L262">                hashCode = result;</span>
            }
<span class="nc" id="L264">            return hashCode;</span>
        }
    }


    /*
     * Bounce through the trampoline.
     */
    public static Object invoke(Method m, Object obj, Object[] params)
        throws InvocationTargetException, IllegalAccessException {
        try {
<span class="nc" id="L275">            return bounce.invoke(null, new Object[] {m, obj, params});</span>
<span class="nc" id="L276">        } catch (InvocationTargetException ie) {</span>
<span class="nc" id="L277">            Throwable t = ie.getCause();</span>

<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (t instanceof InvocationTargetException) {</span>
<span class="nc" id="L280">                throw (InvocationTargetException)t;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            } else if (t instanceof IllegalAccessException) {</span>
<span class="nc" id="L282">                throw (IllegalAccessException)t;</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">            } else if (t instanceof RuntimeException) {</span>
<span class="nc" id="L284">                throw (RuntimeException)t;</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">            } else if (t instanceof Error) {</span>
<span class="nc" id="L286">                throw (Error)t;</span>
            } else {
<span class="nc" id="L288">                throw new Error(&quot;Unexpected invocation error&quot;, t);</span>
            }
<span class="nc" id="L290">        } catch (IllegalAccessException iae) {</span>
            // this can't happen
<span class="nc" id="L292">            throw new Error(&quot;Unexpected invocation error&quot;, iae);</span>
        }
    }

    private static Method getTrampoline() {
        try {
<span class="nc" id="L298">            return AccessController.doPrivileged(</span>
<span class="nc" id="L299">                new PrivilegedExceptionAction&lt;Method&gt;() {</span>
                    public Method run() throws Exception {
<span class="nc" id="L301">                        Class&lt;?&gt; t = getTrampolineClass();</span>
<span class="nc" id="L302">                        Class&lt;?&gt;[] types = {</span>
                            Method.class, Object.class, Object[].class
                        };
<span class="nc" id="L305">                        Method b = t.getDeclaredMethod(&quot;invoke&quot;, types);</span>
<span class="nc" id="L306">                        b.setAccessible(true);</span>
<span class="nc" id="L307">                        return b;</span>
                    }
                });
<span class="nc" id="L310">        } catch (Exception e) {</span>
<span class="nc" id="L311">            throw new InternalError(&quot;bouncer cannot be found&quot;, e);</span>
        }
    }


    protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        // First, check if the class has already been loaded
<span class="nc" id="L320">        ReflectUtil.checkPackageAccess(name);</span>
<span class="nc" id="L321">        Class&lt;?&gt; c = findLoadedClass(name);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (c == null) {</span>
            try {
<span class="nc" id="L324">                c = findClass(name);</span>
<span class="nc" id="L325">            } catch (ClassNotFoundException e) {</span>
                // Fall through ...
<span class="nc" id="L327">            }</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if (c == null) {</span>
<span class="nc" id="L329">                c = getParent().loadClass(name);</span>
            }
        }
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (resolve) {</span>
<span class="nc" id="L333">            resolveClass(c);</span>
        }
<span class="nc" id="L335">        return c;</span>
    }


    protected Class&lt;?&gt; findClass(final String name)
        throws ClassNotFoundException
    {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (!name.startsWith(MISC_PKG)) {</span>
<span class="nc" id="L343">            throw new ClassNotFoundException(name);</span>
        }
<span class="nc" id="L345">        String path = name.replace('.', '/').concat(&quot;.class&quot;);</span>
<span class="nc" id="L346">        URL res = getResource(path);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (res != null) {</span>
            try {
<span class="nc" id="L349">                return defineClass(name, res);</span>
<span class="nc" id="L350">            } catch (IOException e) {</span>
<span class="nc" id="L351">                throw new ClassNotFoundException(name, e);</span>
            }
        } else {
<span class="nc" id="L354">            throw new ClassNotFoundException(name);</span>
        }
    }


    /*
     * Define the proxy classes
     */
    private Class&lt;?&gt; defineClass(String name, URL url) throws IOException {
<span class="nc" id="L363">        byte[] b = getBytes(url);</span>
<span class="nc" id="L364">        CodeSource cs = new CodeSource(null, (java.security.cert.Certificate[])null);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (!name.equals(TRAMPOLINE)) {</span>
<span class="nc" id="L366">            throw new IOException(&quot;MethodUtil: bad name &quot; + name);</span>
        }
<span class="nc" id="L368">        return defineClass(name, b, 0, b.length, cs);</span>
    }


    /*
     * Returns the contents of the specified URL as an array of bytes.
     */
    private static byte[] getBytes(URL url) throws IOException {
<span class="nc" id="L376">        URLConnection uc = url.openConnection();</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (uc instanceof java.net.HttpURLConnection) {</span>
<span class="nc" id="L378">            java.net.HttpURLConnection huc = (java.net.HttpURLConnection) uc;</span>
<span class="nc" id="L379">            int code = huc.getResponseCode();</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            if (code &gt;= java.net.HttpURLConnection.HTTP_BAD_REQUEST) {</span>
<span class="nc" id="L381">                throw new IOException(&quot;open HTTP connection failed.&quot;);</span>
            }
        }
<span class="nc" id="L384">        int len = uc.getContentLength();</span>
<span class="nc" id="L385">        InputStream in = new BufferedInputStream(uc.getInputStream());</span>

        byte[] b;
        try {
<span class="nc" id="L389">            b = IOUtils.readFully(in, len, true);</span>
        } finally {
<span class="nc" id="L391">            in.close();</span>
<span class="nc" id="L392">        }</span>
<span class="nc" id="L393">        return b;</span>
    }


    protected PermissionCollection getPermissions(CodeSource codesource)
    {
<span class="nc" id="L399">        PermissionCollection perms = super.getPermissions(codesource);</span>
<span class="nc" id="L400">        perms.add(new AllPermission());</span>
<span class="nc" id="L401">        return perms;</span>
    }

    private static Class&lt;?&gt; getTrampolineClass() {
        try {
<span class="nc" id="L406">            return Class.forName(TRAMPOLINE, true, new MethodUtil());</span>
<span class="nc" id="L407">        } catch (ClassNotFoundException e) {</span>
        }
<span class="nc" id="L409">        return null;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>