<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReverseState.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.provider.certpath</a> &gt; <span class="el_source">ReverseState.java</span></div><h1>ReverseState.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider.certpath;

import java.io.IOException;
import java.security.PublicKey;
import java.security.cert.CertificateException;
import java.security.cert.CertPathValidatorException;
import java.security.cert.PKIXCertPathChecker;
import java.security.cert.PKIXRevocationChecker;
import java.security.cert.TrustAnchor;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import javax.security.auth.x500.X500Principal;

import sun.security.provider.certpath.PKIX.BuilderParams;
import sun.security.util.Debug;
import sun.security.x509.NameConstraintsExtension;
import sun.security.x509.SubjectKeyIdentifierExtension;
import sun.security.x509.X509CertImpl;

/**
 * A specification of a reverse PKIX validation state
 * which is initialized by each build and updated each time a
 * certificate is added to the current path.
 * @since       1.4
 * @author      Sean Mullan
 * @author      Yassir Elley
 */

<span class="nc" id="L58">class ReverseState implements State {</span>

<span class="nc" id="L60">    private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);</span>

    /* The subject DN of the last cert in the path */
    X500Principal subjectDN;

    /* The subject public key of the last cert */
    PublicKey pubKey;

    /* The subject key identifier extension (if any) of the last cert */
    SubjectKeyIdentifierExtension subjKeyId;

    /* The PKIX constrained/excluded subtrees state variable */
    NameConstraintsExtension nc;

    /* The PKIX explicit policy, policy mapping, and inhibit_any-policy
       state variables */
    int explicitPolicy;
    int policyMapping;
    int inhibitAnyPolicy;
    int certIndex;
    PolicyNodeImpl rootNode;

    /* The number of remaining CA certs which may follow in the path.
     * -1: previous cert was an EE cert
     * 0: only EE certs may follow.
     * &gt;0 and &lt;Integer.MAX_VALUE:no more than this number of CA certs may follow
     * Integer.MAX_VALUE: unlimited
     */
    int remainingCACerts;

    /* The list of user-defined checkers retrieved from the PKIXParameters
     * instance */
    ArrayList&lt;PKIXCertPathChecker&gt; userCheckers;

    /* Flag indicating if state is initial (path is just starting) */
<span class="nc" id="L95">    private boolean init = true;</span>

    /* the checker used for revocation status */
    RevocationChecker revChecker;

    /* the algorithm checker */
    AlgorithmChecker algorithmChecker;

    /* the untrusted certificates checker */
    UntrustedChecker untrustedChecker;

    /* the trust anchor used to validate the path */
    TrustAnchor trustAnchor;

    /* Flag indicating if current cert can vouch for the CRL for
     * the next cert
     */
<span class="nc" id="L112">    boolean crlSign = true;</span>

    /**
     * Returns a boolean flag indicating if the state is initial
     * (just starting)
     *
     * @return boolean flag indicating if the state is initial (just starting)
     */
    @Override
    public boolean isInitial() {
<span class="nc" id="L122">        return init;</span>
    }

    /**
     * Display state for debugging purposes
     */
    @Override
    public String toString() {
<span class="nc" id="L130">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L131">        sb.append(&quot;State [&quot;);</span>
<span class="nc" id="L132">        sb.append(&quot;\n  subjectDN of last cert: &quot;).append(subjectDN);</span>
<span class="nc" id="L133">        sb.append(&quot;\n  subjectKeyIdentifier: &quot;).append</span>
<span class="nc" id="L134">                 (String.valueOf(subjKeyId));</span>
<span class="nc" id="L135">        sb.append(&quot;\n  nameConstraints: &quot;).append(String.valueOf(nc));</span>
<span class="nc" id="L136">        sb.append(&quot;\n  certIndex: &quot;).append(certIndex);</span>
<span class="nc" id="L137">        sb.append(&quot;\n  explicitPolicy: &quot;).append(explicitPolicy);</span>
<span class="nc" id="L138">        sb.append(&quot;\n  policyMapping:  &quot;).append(policyMapping);</span>
<span class="nc" id="L139">        sb.append(&quot;\n  inhibitAnyPolicy:  &quot;).append(inhibitAnyPolicy);</span>
<span class="nc" id="L140">        sb.append(&quot;\n  rootNode: &quot;).append(rootNode);</span>
<span class="nc" id="L141">        sb.append(&quot;\n  remainingCACerts: &quot;).append(remainingCACerts);</span>
<span class="nc" id="L142">        sb.append(&quot;\n  crlSign: &quot;).append(crlSign);</span>
<span class="nc" id="L143">        sb.append(&quot;\n  init: &quot;).append(init);</span>
<span class="nc" id="L144">        sb.append(&quot;\n]\n&quot;);</span>
<span class="nc" id="L145">        return sb.toString();</span>
    }

    /**
     * Initialize the state.
     *
     * @param buildParams builder parameters
     */
    public void initState(BuilderParams buildParams)
        throws CertPathValidatorException
    {
        /*
         * Initialize number of remainingCACerts.
         * Note that -1 maxPathLen implies unlimited.
         * 0 implies only an EE cert is acceptable.
         */
<span class="nc" id="L161">        int maxPathLen = buildParams.maxPathLength();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        remainingCACerts = (maxPathLen == -1) ? Integer.MAX_VALUE</span>
                                              : maxPathLen;

        /* Initialize explicit policy state variable */
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (buildParams.explicitPolicyRequired()) {</span>
<span class="nc" id="L167">            explicitPolicy = 0;</span>
        } else {
            // unconstrained if maxPathLen is -1,
            // otherwise, we want to initialize this to the value of the
            // longest possible path + 1 (i.e. maxpathlen + finalcert + 1)
<span class="nc bnc" id="L172" title="All 2 branches missed.">            explicitPolicy = (maxPathLen == -1) ? maxPathLen : maxPathLen + 2;</span>
        }

        /* Initialize policy mapping state variable */
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (buildParams.policyMappingInhibited()) {</span>
<span class="nc" id="L177">            policyMapping = 0;</span>
        } else {
<span class="nc bnc" id="L179" title="All 2 branches missed.">            policyMapping = (maxPathLen == -1) ? maxPathLen : maxPathLen + 2;</span>
        }

        /* Initialize inhibit any policy state variable */
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (buildParams.anyPolicyInhibited()) {</span>
<span class="nc" id="L184">            inhibitAnyPolicy = 0;</span>
        } else {
<span class="nc bnc" id="L186" title="All 2 branches missed.">            inhibitAnyPolicy = (maxPathLen == -1) ? maxPathLen : maxPathLen + 2;</span>
        }

        /* Initialize certIndex */
<span class="nc" id="L190">        certIndex = 1;</span>

        /* Initialize policy tree */
<span class="nc" id="L193">        Set&lt;String&gt; initExpPolSet = new HashSet&lt;&gt;(1);</span>
<span class="nc" id="L194">        initExpPolSet.add(PolicyChecker.ANY_POLICY);</span>

<span class="nc" id="L196">        rootNode = new PolicyNodeImpl(null, PolicyChecker.ANY_POLICY, null,</span>
                                      false, initExpPolSet, false);

        /*
         * Initialize each user-defined checker
         * Shallow copy the checkers
         */
<span class="nc" id="L203">        userCheckers = new ArrayList&lt;&gt;(buildParams.certPathCheckers());</span>
        /* initialize each checker (just in case) */
<span class="nc bnc" id="L205" title="All 2 branches missed.">        for (PKIXCertPathChecker checker : userCheckers) {</span>
<span class="nc" id="L206">            checker.init(false);</span>
<span class="nc" id="L207">        }</span>

        /* Start by trusting the cert to sign CRLs */
<span class="nc" id="L210">        crlSign = true;</span>

<span class="nc" id="L212">        init = true;</span>
<span class="nc" id="L213">    }</span>

    /**
     * Update the state with the specified trust anchor.
     *
     * @param anchor the most-trusted CA
     * @param buildParams builder parameters
     */
    public void updateState(TrustAnchor anchor, BuilderParams buildParams)
        throws CertificateException, IOException, CertPathValidatorException
    {
<span class="nc" id="L224">        trustAnchor = anchor;</span>
<span class="nc" id="L225">        X509Certificate trustedCert = anchor.getTrustedCert();</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (trustedCert != null) {</span>
<span class="nc" id="L227">            updateState(trustedCert);</span>
        } else {
<span class="nc" id="L229">            X500Principal caName = anchor.getCA();</span>
<span class="nc" id="L230">            updateState(anchor.getCAPublicKey(), caName);</span>
        }

        // The user specified AlgorithmChecker and RevocationChecker may not be
        // able to set the trust anchor until now.
<span class="nc" id="L235">        boolean revCheckerAdded = false;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        for (PKIXCertPathChecker checker : userCheckers) {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">            if (checker instanceof AlgorithmChecker) {</span>
<span class="nc" id="L238">                ((AlgorithmChecker)checker).trySetTrustAnchor(anchor);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            } else if (checker instanceof PKIXRevocationChecker) {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">                if (revCheckerAdded) {</span>
<span class="nc" id="L241">                    throw new CertPathValidatorException(</span>
                        &quot;Only one PKIXRevocationChecker can be specified&quot;);
                }
                // if it's our own, initialize it
<span class="nc bnc" id="L245" title="All 2 branches missed.">                if (checker instanceof RevocationChecker) {</span>
<span class="nc" id="L246">                    ((RevocationChecker)checker).init(anchor, buildParams);</span>
                }
<span class="nc" id="L248">                ((PKIXRevocationChecker)checker).init(false);</span>
<span class="nc" id="L249">                revCheckerAdded = true;</span>
            }
<span class="nc" id="L251">        }</span>

        // only create a RevocationChecker if revocation is enabled and
        // a PKIXRevocationChecker has not already been added
<span class="nc bnc" id="L255" title="All 4 branches missed.">        if (buildParams.revocationEnabled() &amp;&amp; !revCheckerAdded) {</span>
<span class="nc" id="L256">            revChecker = new RevocationChecker(anchor, buildParams);</span>
<span class="nc" id="L257">            revChecker.init(false);</span>
        }

<span class="nc" id="L260">        init = false;</span>
<span class="nc" id="L261">    }</span>

    /**
     * Update the state. This method is used when the most-trusted CA is
     * a trusted public-key and caName, instead of a trusted cert.
     *
     * @param pubKey the public key of the trusted CA
     * @param subjectDN the subject distinguished name of the trusted CA
     */
    private void updateState(PublicKey pubKey, X500Principal subjectDN) {

        /* update subject DN */
<span class="nc" id="L273">        this.subjectDN = subjectDN;</span>

        /* update subject public key */
<span class="nc" id="L276">        this.pubKey = pubKey;</span>
<span class="nc" id="L277">    }</span>

    /**
     * Update the state with the next certificate added to the path.
     *
     * @param cert the certificate which is used to update the state
     */
    public void updateState(X509Certificate cert)
        throws CertificateException, IOException, CertPathValidatorException {

<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (cert == null) {</span>
<span class="nc" id="L288">            return;</span>
        }

        /* update subject DN */
<span class="nc" id="L292">        subjectDN = cert.getSubjectX500Principal();</span>

        /* check for key needing to inherit alg parameters */
<span class="nc" id="L295">        X509CertImpl icert = X509CertImpl.toImpl(cert);</span>
<span class="nc" id="L296">        PublicKey newKey = cert.getPublicKey();</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (PKIX.isDSAPublicKeyWithoutParams(newKey)) {</span>
<span class="nc" id="L298">            newKey = BasicChecker.makeInheritedParamsKey(newKey, pubKey);</span>
        }

        /* update subject public key */
<span class="nc" id="L302">        pubKey = newKey;</span>

        /*
         * if this is a trusted cert (init == true), then we
         * don't update any of the remaining fields
         */
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (init) {</span>
<span class="nc" id="L309">            init = false;</span>
<span class="nc" id="L310">            return;</span>
        }

        /* update subject key identifier */
<span class="nc" id="L314">        subjKeyId = icert.getSubjectKeyIdentifierExtension();</span>

        /* update crlSign */
<span class="nc" id="L317">        crlSign = RevocationChecker.certCanSignCrl(cert);</span>

        /* update current name constraints */
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (nc != null) {</span>
<span class="nc" id="L321">            nc.merge(icert.getNameConstraintsExtension());</span>
        } else {
<span class="nc" id="L323">            nc = icert.getNameConstraintsExtension();</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">            if (nc != null) {</span>
                // Make sure we do a clone here, because we're probably
                // going to modify this object later and we don't want to
                // be sharing it with a Certificate object!
<span class="nc" id="L328">                nc = (NameConstraintsExtension) nc.clone();</span>
            }
        }

        /* update policy state variables */
<span class="nc" id="L333">        explicitPolicy =</span>
<span class="nc" id="L334">            PolicyChecker.mergeExplicitPolicy(explicitPolicy, icert, false);</span>
<span class="nc" id="L335">        policyMapping =</span>
<span class="nc" id="L336">            PolicyChecker.mergePolicyMapping(policyMapping, icert);</span>
<span class="nc" id="L337">        inhibitAnyPolicy =</span>
<span class="nc" id="L338">            PolicyChecker.mergeInhibitAnyPolicy(inhibitAnyPolicy, icert);</span>
<span class="nc" id="L339">        certIndex++;</span>

        /*
         * Update remaining CA certs
         */
<span class="nc" id="L344">        remainingCACerts =</span>
<span class="nc" id="L345">            ConstraintsChecker.mergeBasicConstraints(cert, remainingCACerts);</span>

<span class="nc" id="L347">        init = false;</span>
<span class="nc" id="L348">    }</span>

    /**
     * Returns a boolean flag indicating if a key lacking necessary key
     * algorithm parameters has been encountered.
     *
     * @return boolean flag indicating if key lacking parameters encountered.
     */
    @Override
    public boolean keyParamsNeeded() {
        /* when building in reverse, we immediately get parameters needed
         * or else throw an exception
         */
<span class="nc" id="L361">        return false;</span>
    }

    /*
     * Clone current state. The state is cloned as each cert is
     * added to the path. This is necessary if backtracking occurs,
     * and a prior state needs to be restored.
     *
     * Note that this is a SMART clone. Not all fields are fully copied,
     * because some of them (e.g., subjKeyId) will
     * not have their contents modified by subsequent calls to updateState.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;) // Safe casts assuming clone() works correctly
    public Object clone() {
        try {
<span class="nc" id="L377">            ReverseState clonedState = (ReverseState) super.clone();</span>

            /* clone checkers, if cloneable */
<span class="nc" id="L380">            clonedState.userCheckers =</span>
<span class="nc" id="L381">                        (ArrayList&lt;PKIXCertPathChecker&gt;)userCheckers.clone();</span>
<span class="nc" id="L382">            ListIterator&lt;PKIXCertPathChecker&gt; li =</span>
<span class="nc" id="L383">                        clonedState.userCheckers.listIterator();</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">            while (li.hasNext()) {</span>
<span class="nc" id="L385">                PKIXCertPathChecker checker = li.next();</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">                if (checker instanceof Cloneable) {</span>
<span class="nc" id="L387">                    li.set((PKIXCertPathChecker)checker.clone());</span>
                }
<span class="nc" id="L389">            }</span>

            /* make copy of name constraints */
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (nc != null) {</span>
<span class="nc" id="L393">                clonedState.nc = (NameConstraintsExtension) nc.clone();</span>
            }

            /* make copy of policy tree */
<span class="nc bnc" id="L397" title="All 2 branches missed.">            if (rootNode != null) {</span>
<span class="nc" id="L398">                clonedState.rootNode = rootNode.copyTree();</span>
            }

<span class="nc" id="L401">            return clonedState;</span>
<span class="nc" id="L402">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L403">            throw new InternalError(e.toString(), e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>