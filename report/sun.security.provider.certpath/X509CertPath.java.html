<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>X509CertPath.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.provider.certpath</a> &gt; <span class="el_source">X509CertPath.java</span></div><h1>X509CertPath.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider.certpath;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.cert.CertificateEncodingException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.CertPath;
import java.security.cert.X509Certificate;
import java.util.*;

import sun.security.pkcs.ContentInfo;
import sun.security.pkcs.PKCS7;
import sun.security.pkcs.SignerInfo;
import sun.security.x509.AlgorithmId;
import sun.security.util.DerValue;
import sun.security.util.DerOutputStream;
import sun.security.util.DerInputStream;

/**
 * A {@link java.security.cert.CertPath CertPath} (certification path)
 * consisting exclusively of
 * {@link java.security.cert.X509Certificate X509Certificate}s.
 * &lt;p&gt;
 * By convention, X.509 &lt;code&gt;CertPath&lt;/code&gt;s are stored from target
 * to trust anchor.
 * That is, the issuer of one certificate is the subject of the following
 * one. However, unvalidated X.509 &lt;code&gt;CertPath&lt;/code&gt;s may not follow
 * this convention. PKIX &lt;code&gt;CertPathValidator&lt;/code&gt;s will detect any
 * departure from this convention and throw a
 * &lt;code&gt;CertPathValidatorException&lt;/code&gt;.
 *
 * @author      Yassir Elley
 * @since       1.4
 */
public class X509CertPath extends CertPath {

    private static final long serialVersionUID = 4989800333263052980L;

    /**
     * List of certificates in this chain
     */
    private List&lt;X509Certificate&gt; certs;

    /**
     * The names of our encodings.  PkiPath is the default.
     */
    private static final String COUNT_ENCODING = &quot;count&quot;;
    private static final String PKCS7_ENCODING = &quot;PKCS7&quot;;
    private static final String PKIPATH_ENCODING = &quot;PkiPath&quot;;

    /**
     * List of supported encodings
     */
    private static final Collection&lt;String&gt; encodingList;

    static {
<span class="fc" id="L86">        List&lt;String&gt; list = new ArrayList&lt;&gt;(2);</span>
<span class="fc" id="L87">        list.add(PKIPATH_ENCODING);</span>
<span class="fc" id="L88">        list.add(PKCS7_ENCODING);</span>
<span class="fc" id="L89">        encodingList = Collections.unmodifiableCollection(list);</span>
<span class="fc" id="L90">    }</span>

    /**
     * Creates an &lt;code&gt;X509CertPath&lt;/code&gt; from a &lt;code&gt;List&lt;/code&gt; of
     * &lt;code&gt;X509Certificate&lt;/code&gt;s.
     * &lt;p&gt;
     * The certificates are copied out of the supplied &lt;code&gt;List&lt;/code&gt;
     * object.
     *
     * @param certs a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;X509Certificate&lt;/code&gt;s
     * @exception CertificateException if &lt;code&gt;certs&lt;/code&gt; contains an element
     *                      that is not an &lt;code&gt;X509Certificate&lt;/code&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public X509CertPath(List&lt;? extends Certificate&gt; certs) throws CertificateException {
<span class="fc" id="L105">        super(&quot;X.509&quot;);</span>

        // Ensure that the List contains only X509Certificates
        //
        // Note; The certs parameter is not necessarily to be of Certificate
        // for some old code. For compatibility, to make sure the exception
        // is CertificateException, rather than ClassCastException, please
        // don't use
        //     for (Certificate obj : certs)
<span class="fc bfc" id="L114" title="All 2 branches covered.">        for (Object obj : certs) {</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            if (obj instanceof X509Certificate == false) {</span>
<span class="nc" id="L116">                throw new CertificateException</span>
                    (&quot;List is not all X509Certificates: &quot;
<span class="nc" id="L118">                    + obj.getClass().getName());</span>
            }
<span class="fc" id="L120">        }</span>

        // Assumes that the resulting List is thread-safe. This is true
        // because we ensure that it cannot be modified after construction
        // and the methods in the Sun JDK 1.4 implementation of ArrayList that
        // allow read-only access are thread-safe.
<span class="fc" id="L126">        this.certs = Collections.unmodifiableList(</span>
                new ArrayList&lt;X509Certificate&gt;((List&lt;X509Certificate&gt;)certs));
<span class="fc" id="L128">    }</span>

    /**
     * Creates an &lt;code&gt;X509CertPath&lt;/code&gt;, reading the encoded form
     * from an &lt;code&gt;InputStream&lt;/code&gt;. The data is assumed to be in
     * the default encoding.
     *
     * @param is the &lt;code&gt;InputStream&lt;/code&gt; to read the data from
     * @exception CertificateException if an exception occurs while decoding
     */
    public X509CertPath(InputStream is) throws CertificateException {
<span class="nc" id="L139">        this(is, PKIPATH_ENCODING);</span>
<span class="nc" id="L140">    }</span>

    /**
     * Creates an &lt;code&gt;X509CertPath&lt;/code&gt;, reading the encoded form
     * from an InputStream. The data is assumed to be in the specified
     * encoding.
     *
     * @param is the &lt;code&gt;InputStream&lt;/code&gt; to read the data from
     * @param encoding the encoding used
     * @exception CertificateException if an exception occurs while decoding or
     *   the encoding requested is not supported
     */
    public X509CertPath(InputStream is, String encoding)
            throws CertificateException {
<span class="nc" id="L154">        super(&quot;X.509&quot;);</span>

<span class="nc bnc" id="L156" title="All 10 branches missed.">        switch (encoding) {</span>
            case PKIPATH_ENCODING:
<span class="nc" id="L158">                certs = parsePKIPATH(is);</span>
<span class="nc" id="L159">                break;</span>
            case PKCS7_ENCODING:
<span class="nc" id="L161">                certs = parsePKCS7(is);</span>
<span class="nc" id="L162">                break;</span>
            default:
<span class="nc" id="L164">                throw new CertificateException(&quot;unsupported encoding&quot;);</span>
        }
<span class="nc" id="L166">    }</span>

    /**
     * Parse a PKIPATH format CertPath from an InputStream. Return an
     * unmodifiable List of the certificates.
     *
     * @param is the &lt;code&gt;InputStream&lt;/code&gt; to read the data from
     * @return an unmodifiable List of the certificates
     * @exception CertificateException if an exception occurs
     */
    private static List&lt;X509Certificate&gt; parsePKIPATH(InputStream is)
            throws CertificateException {
<span class="nc" id="L178">        List&lt;X509Certificate&gt; certList = null;</span>
<span class="nc" id="L179">        CertificateFactory certFac = null;</span>

<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (is == null) {</span>
<span class="nc" id="L182">            throw new CertificateException(&quot;input stream is null&quot;);</span>
        }

        try {
<span class="nc" id="L186">            DerInputStream dis = new DerInputStream(readAllBytes(is));</span>
<span class="nc" id="L187">            DerValue[] seq = dis.getSequence(3);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (seq.length == 0) {</span>
<span class="nc" id="L189">                return Collections.&lt;X509Certificate&gt;emptyList();</span>
            }

<span class="nc" id="L192">            certFac = CertificateFactory.getInstance(&quot;X.509&quot;);</span>
<span class="nc" id="L193">            certList = new ArrayList&lt;X509Certificate&gt;(seq.length);</span>

            // append certs in reverse order (target to trust anchor)
<span class="nc bnc" id="L196" title="All 2 branches missed.">            for (int i = seq.length-1; i &gt;= 0; i--) {</span>
<span class="nc" id="L197">                certList.add((X509Certificate)certFac.generateCertificate</span>
<span class="nc" id="L198">                    (new ByteArrayInputStream(seq[i].toByteArray())));</span>
            }

<span class="nc" id="L201">            return Collections.unmodifiableList(certList);</span>

<span class="nc" id="L203">        } catch (IOException ioe) {</span>
<span class="nc" id="L204">            throw new CertificateException(&quot;IOException parsing PkiPath data: &quot;</span>
                    + ioe, ioe);
        }
    }

    /**
     * Parse a PKCS#7 format CertPath from an InputStream. Return an
     * unmodifiable List of the certificates.
     *
     * @param is the &lt;code&gt;InputStream&lt;/code&gt; to read the data from
     * @return an unmodifiable List of the certificates
     * @exception CertificateException if an exception occurs
     */
    private static List&lt;X509Certificate&gt; parsePKCS7(InputStream is)
            throws CertificateException {
        List&lt;X509Certificate&gt; certList;

<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (is == null) {</span>
<span class="nc" id="L222">            throw new CertificateException(&quot;input stream is null&quot;);</span>
        }

        try {
<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (is.markSupported() == false) {</span>
                // Copy the entire input stream into an InputStream that does
                // support mark
<span class="nc" id="L229">                is = new ByteArrayInputStream(readAllBytes(is));</span>
            }
<span class="nc" id="L231">            PKCS7 pkcs7 = new PKCS7(is);</span>

<span class="nc" id="L233">            X509Certificate[] certArray = pkcs7.getCertificates();</span>
            // certs are optional in PKCS #7
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (certArray != null) {</span>
<span class="nc" id="L236">                certList = Arrays.asList(certArray);</span>
            } else {
                // no certs provided
<span class="nc" id="L239">                certList = new ArrayList&lt;X509Certificate&gt;(0);</span>
            }
<span class="nc" id="L241">        } catch (IOException ioe) {</span>
<span class="nc" id="L242">            throw new CertificateException(&quot;IOException parsing PKCS7 data: &quot; +</span>
                                        ioe);
<span class="nc" id="L244">        }</span>
        // Assumes that the resulting List is thread-safe. This is true
        // because we ensure that it cannot be modified after construction
        // and the methods in the Sun JDK 1.4 implementation of ArrayList that
        // allow read-only access are thread-safe.
<span class="nc" id="L249">        return Collections.unmodifiableList(certList);</span>
    }

    /*
     * Reads the entire contents of an InputStream into a byte array.
     *
     * @param is the InputStream to read from
     * @return the bytes read from the InputStream
     */
    private static byte[] readAllBytes(InputStream is) throws IOException {
<span class="nc" id="L259">        byte[] buffer = new byte[8192];</span>
<span class="nc" id="L260">        ByteArrayOutputStream baos = new ByteArrayOutputStream(2048);</span>
        int n;
<span class="nc bnc" id="L262" title="All 2 branches missed.">        while ((n = is.read(buffer)) != -1) {</span>
<span class="nc" id="L263">            baos.write(buffer, 0, n);</span>
        }
<span class="nc" id="L265">        return baos.toByteArray();</span>
    }

    /**
     * Returns the encoded form of this certification path, using the
     * default encoding.
     *
     * @return the encoded bytes
     * @exception CertificateEncodingException if an encoding error occurs
     */
    @Override
    public byte[] getEncoded() throws CertificateEncodingException {
        // @@@ Should cache the encoded form
<span class="nc" id="L278">        return encodePKIPATH();</span>
    }

    /**
     * Encode the CertPath using PKIPATH format.
     *
     * @return a byte array containing the binary encoding of the PkiPath object
     * @exception CertificateEncodingException if an exception occurs
     */
    private byte[] encodePKIPATH() throws CertificateEncodingException {

<span class="nc" id="L289">        ListIterator&lt;X509Certificate&gt; li = certs.listIterator(certs.size());</span>
        try {
<span class="nc" id="L291">            DerOutputStream bytes = new DerOutputStream();</span>
            // encode certs in reverse order (trust anchor to target)
            // according to PkiPath format
<span class="nc bnc" id="L294" title="All 2 branches missed.">            while (li.hasPrevious()) {</span>
<span class="nc" id="L295">                X509Certificate cert = li.previous();</span>
                // check for duplicate cert
<span class="nc bnc" id="L297" title="All 2 branches missed.">                if (certs.lastIndexOf(cert) != certs.indexOf(cert)) {</span>
<span class="nc" id="L298">                    throw new CertificateEncodingException</span>
                        (&quot;Duplicate Certificate&quot;);
                }
                // get encoded certificates
<span class="nc" id="L302">                byte[] encoded = cert.getEncoded();</span>
<span class="nc" id="L303">                bytes.write(encoded);</span>
<span class="nc" id="L304">            }</span>

            // Wrap the data in a SEQUENCE
<span class="nc" id="L307">            DerOutputStream derout = new DerOutputStream();</span>
<span class="nc" id="L308">            derout.write(DerValue.tag_SequenceOf, bytes);</span>
<span class="nc" id="L309">            return derout.toByteArray();</span>

<span class="nc" id="L311">        } catch (IOException ioe) {</span>
<span class="nc" id="L312">           throw new CertificateEncodingException(&quot;IOException encoding &quot; +</span>
                   &quot;PkiPath data: &quot; + ioe, ioe);
        }
    }

    /**
     * Encode the CertPath using PKCS#7 format.
     *
     * @return a byte array containing the binary encoding of the PKCS#7 object
     * @exception CertificateEncodingException if an exception occurs
     */
    private byte[] encodePKCS7() throws CertificateEncodingException {
<span class="nc" id="L324">        PKCS7 p7 = new PKCS7(new AlgorithmId[0],</span>
                             new ContentInfo(ContentInfo.DATA_OID, null),
<span class="nc" id="L326">                             certs.toArray(new X509Certificate[certs.size()]),</span>
                             new SignerInfo[0]);
<span class="nc" id="L328">        DerOutputStream derout = new DerOutputStream();</span>
        try {
<span class="nc" id="L330">            p7.encodeSignedData(derout);</span>
<span class="nc" id="L331">        } catch (IOException ioe) {</span>
<span class="nc" id="L332">            throw new CertificateEncodingException(ioe.getMessage());</span>
<span class="nc" id="L333">        }</span>
<span class="nc" id="L334">        return derout.toByteArray();</span>
    }

    /**
     * Returns the encoded form of this certification path, using the
     * specified encoding.
     *
     * @param encoding the name of the encoding to use
     * @return the encoded bytes
     * @exception CertificateEncodingException if an encoding error occurs or
     *   the encoding requested is not supported
     */
    @Override
    public byte[] getEncoded(String encoding)
            throws CertificateEncodingException {
<span class="nc bnc" id="L349" title="All 10 branches missed.">        switch (encoding) {</span>
            case PKIPATH_ENCODING:
<span class="nc" id="L351">                return encodePKIPATH();</span>
            case PKCS7_ENCODING:
<span class="nc" id="L353">                return encodePKCS7();</span>
            default:
<span class="nc" id="L355">                throw new CertificateEncodingException(&quot;unsupported encoding&quot;);</span>
        }
    }

    /**
     * Returns the encodings supported by this certification path, with the
     * default encoding first.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; over the names of the supported
     *         encodings (as Strings)
     */
    public static Iterator&lt;String&gt; getEncodingsStatic() {
<span class="nc" id="L367">        return encodingList.iterator();</span>
    }

    /**
     * Returns an iteration of the encodings supported by this certification
     * path, with the default encoding first.
     * &lt;p&gt;
     * Attempts to modify the returned &lt;code&gt;Iterator&lt;/code&gt; via its
     * &lt;code&gt;remove&lt;/code&gt; method result in an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; over the names of the supported
     *         encodings (as Strings)
     */
    @Override
    public Iterator&lt;String&gt; getEncodings() {
<span class="nc" id="L383">        return getEncodingsStatic();</span>
    }

    /**
     * Returns the list of certificates in this certification path.
     * The &lt;code&gt;List&lt;/code&gt; returned must be immutable and thread-safe.
     *
     * @return an immutable &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;X509Certificate&lt;/code&gt;s
     *         (may be empty, but not null)
     */
    @Override
    public List&lt;X509Certificate&gt; getCertificates() {
<span class="fc" id="L395">        return certs;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>