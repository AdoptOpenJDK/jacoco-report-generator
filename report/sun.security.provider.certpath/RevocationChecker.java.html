<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RevocationChecker.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.provider.certpath</a> &gt; <span class="el_source">RevocationChecker.java</span></div><h1>RevocationChecker.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider.certpath;

import java.io.IOException;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.security.AccessController;
import java.security.InvalidAlgorithmParameterException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivilegedAction;
import java.security.PublicKey;
import java.security.Security;
import java.security.cert.CertPathValidatorException.BasicReason;
import java.security.cert.Extension;
import java.security.cert.*;
import java.util.*;
import javax.security.auth.x500.X500Principal;

import static sun.security.provider.certpath.OCSP.*;
import static sun.security.provider.certpath.PKIX.*;
import sun.security.action.GetPropertyAction;
import sun.security.x509.*;
import static sun.security.x509.PKIXExtensions.*;
import sun.security.util.Debug;

class RevocationChecker extends PKIXRevocationChecker {

<span class="fc" id="L53">    private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);</span>

    private TrustAnchor anchor;
    private ValidatorParams params;
    private boolean onlyEE;
    private boolean softFail;
    private boolean crlDP;
    private URI responderURI;
    private X509Certificate responderCert;
    private List&lt;CertStore&gt; certStores;
    private Map&lt;X509Certificate, byte[]&gt; ocspResponses;
    private List&lt;Extension&gt; ocspExtensions;
    private boolean legacy;
<span class="pc" id="L66">    private LinkedList&lt;CertPathValidatorException&gt; softFailExceptions =</span>
        new LinkedList&lt;&gt;();

    // state variables
    private X509Certificate issuerCert;
    private PublicKey prevPubKey;
    private boolean crlSignFlag;
    private int certIndex;

<span class="pc" id="L75">    private enum Mode { PREFER_OCSP, PREFER_CRLS, ONLY_CRLS, ONLY_OCSP };</span>
<span class="pc" id="L76">    private Mode mode = Mode.PREFER_OCSP;</span>

<span class="fc" id="L78">    private static class RevocationProperties {</span>
        boolean onlyEE;
        boolean ocspEnabled;
        boolean crlDPEnabled;
        String ocspUrl;
        String ocspSubject;
        String ocspIssuer;
        String ocspSerial;
    }

<span class="nc" id="L88">    RevocationChecker() {</span>
<span class="nc" id="L89">        legacy = false;</span>
<span class="nc" id="L90">    }</span>

    RevocationChecker(TrustAnchor anchor, ValidatorParams params)
        throws CertPathValidatorException
<span class="fc" id="L94">    {</span>
<span class="fc" id="L95">        legacy = true;</span>
<span class="fc" id="L96">        init(anchor, params);</span>
<span class="fc" id="L97">    }</span>

    void init(TrustAnchor anchor, ValidatorParams params)
        throws CertPathValidatorException
    {
<span class="fc" id="L102">        RevocationProperties rp = getRevocationProperties();</span>
<span class="fc" id="L103">        URI uri = getOcspResponder();</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">        responderURI = (uri == null) ? toURI(rp.ocspUrl) : uri;</span>
<span class="fc" id="L105">        X509Certificate cert = getOcspResponderCert();</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        responderCert = (cert == null)</span>
<span class="pc" id="L107">                        ? getResponderCert(rp, params.trustAnchors(),</span>
<span class="fc" id="L108">                                           params.certStores())</span>
                        : cert;
<span class="fc" id="L110">        Set&lt;Option&gt; options = getOptions();</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        for (Option option : options) {</span>
<span class="pc bnc" id="L112" title="All 2 branches missed.">            switch (option) {</span>
            case ONLY_END_ENTITY:
            case PREFER_CRLS:
            case SOFT_FAIL:
            case NO_FALLBACK:
<span class="nc" id="L117">                break;</span>
            default:
<span class="nc" id="L119">                throw new CertPathValidatorException(</span>
                    &quot;Unrecognized revocation parameter option: &quot; + option);
            }
<span class="nc" id="L122">        }</span>
<span class="fc" id="L123">        softFail = options.contains(Option.SOFT_FAIL);</span>

        // set mode, only end entity flag
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if (legacy) {</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">            mode = (rp.ocspEnabled) ? Mode.PREFER_OCSP : Mode.ONLY_CRLS;</span>
<span class="fc" id="L128">            onlyEE = rp.onlyEE;</span>
        } else {
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (options.contains(Option.NO_FALLBACK)) {</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                if (options.contains(Option.PREFER_CRLS)) {</span>
<span class="nc" id="L132">                    mode = Mode.ONLY_CRLS;</span>
                } else {
<span class="nc" id="L134">                    mode = Mode.ONLY_OCSP;</span>
                }
<span class="nc bnc" id="L136" title="All 2 branches missed.">            } else if (options.contains(Option.PREFER_CRLS)) {</span>
<span class="nc" id="L137">                mode = Mode.PREFER_CRLS;</span>
            }
<span class="nc" id="L139">            onlyEE = options.contains(Option.ONLY_END_ENTITY);</span>
        }
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (legacy) {</span>
<span class="fc" id="L142">            crlDP = rp.crlDPEnabled;</span>
        } else {
<span class="nc" id="L144">            crlDP = true;</span>
        }
<span class="fc" id="L146">        ocspResponses = getOcspResponses();</span>
<span class="fc" id="L147">        ocspExtensions = getOcspExtensions();</span>

<span class="fc" id="L149">        this.anchor = anchor;</span>
<span class="fc" id="L150">        this.params = params;</span>
<span class="fc" id="L151">        this.certStores = new ArrayList&lt;&gt;(params.certStores());</span>
        try {
<span class="fc" id="L153">            this.certStores.add(CertStore.getInstance(&quot;Collection&quot;,</span>
<span class="fc" id="L154">                new CollectionCertStoreParameters(params.certificates())));</span>
<span class="nc" id="L155">        } catch (InvalidAlgorithmParameterException |</span>
                 NoSuchAlgorithmException e) {
            // should never occur but not necessarily fatal, so log it,
            // ignore and continue
<span class="nc bnc" id="L159" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L160">                debug.println(&quot;RevocationChecker: &quot; +</span>
                              &quot;error creating Collection CertStore: &quot; + e);
            }
<span class="fc" id="L163">        }</span>
<span class="fc" id="L164">    }</span>

    private static URI toURI(String uriString)
        throws CertPathValidatorException
    {
        try {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">            if (uriString != null) {</span>
<span class="nc" id="L171">                return new URI(uriString);</span>
            }
<span class="fc" id="L173">            return null;</span>
<span class="nc" id="L174">        } catch (URISyntaxException e) {</span>
<span class="nc" id="L175">            throw new CertPathValidatorException(</span>
                &quot;cannot parse ocsp.responderURL property&quot;, e);
        }
    }

    private static RevocationProperties getRevocationProperties() {
<span class="fc" id="L181">        return AccessController.doPrivileged(</span>
<span class="fc" id="L182">            new PrivilegedAction&lt;RevocationProperties&gt;() {</span>
                public RevocationProperties run() {
<span class="fc" id="L184">                    RevocationProperties rp = new RevocationProperties();</span>
<span class="fc" id="L185">                    String onlyEE = Security.getProperty(</span>
                        &quot;com.sun.security.onlyCheckRevocationOfEECert&quot;);
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">                    rp.onlyEE = onlyEE != null</span>
<span class="pc bnc" id="L188" title="All 2 branches missed.">                                &amp;&amp; onlyEE.equalsIgnoreCase(&quot;true&quot;);</span>
<span class="fc" id="L189">                    String ocspEnabled = Security.getProperty(&quot;ocsp.enable&quot;);</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">                    rp.ocspEnabled = ocspEnabled != null</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">                                     &amp;&amp; ocspEnabled.equalsIgnoreCase(&quot;true&quot;);</span>
<span class="fc" id="L192">                    rp.ocspUrl = Security.getProperty(&quot;ocsp.responderURL&quot;);</span>
<span class="fc" id="L193">                    rp.ocspSubject</span>
<span class="fc" id="L194">                        = Security.getProperty(&quot;ocsp.responderCertSubjectName&quot;);</span>
<span class="fc" id="L195">                    rp.ocspIssuer</span>
<span class="fc" id="L196">                        = Security.getProperty(&quot;ocsp.responderCertIssuerName&quot;);</span>
<span class="fc" id="L197">                    rp.ocspSerial</span>
<span class="fc" id="L198">                        = Security.getProperty(&quot;ocsp.responderCertSerialNumber&quot;);</span>
<span class="fc" id="L199">                    rp.crlDPEnabled</span>
<span class="fc" id="L200">                        = Boolean.getBoolean(&quot;com.sun.security.enableCRLDP&quot;);</span>
<span class="fc" id="L201">                    return rp;</span>
                }
            }
        );
    }

    private static X509Certificate getResponderCert(RevocationProperties rp,
                                                    Set&lt;TrustAnchor&gt; anchors,
                                                    List&lt;CertStore&gt; stores)
        throws CertPathValidatorException
    {
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (rp.ocspSubject != null) {</span>
<span class="nc" id="L213">            return getResponderCert(rp.ocspSubject, anchors, stores);</span>
<span class="pc bpc" id="L214" title="3 of 4 branches missed.">        } else if (rp.ocspIssuer != null &amp;&amp; rp.ocspSerial != null) {</span>
<span class="nc" id="L215">            return getResponderCert(rp.ocspIssuer, rp.ocspSerial,</span>
                                    anchors, stores);
<span class="pc bpc" id="L217" title="2 of 4 branches missed.">        } else if (rp.ocspIssuer != null || rp.ocspSerial != null) {</span>
<span class="nc" id="L218">            throw new CertPathValidatorException(</span>
                &quot;Must specify both ocsp.responderCertIssuerName and &quot; +
                &quot;ocsp.responderCertSerialNumber properties&quot;);
        }
<span class="fc" id="L222">        return null;</span>
    }

    private static X509Certificate getResponderCert(String subject,
                                                    Set&lt;TrustAnchor&gt; anchors,
                                                    List&lt;CertStore&gt; stores)
        throws CertPathValidatorException
    {
<span class="nc" id="L230">        X509CertSelector sel = new X509CertSelector();</span>
        try {
<span class="nc" id="L232">            sel.setSubject(new X500Principal(subject));</span>
<span class="nc" id="L233">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L234">            throw new CertPathValidatorException(</span>
                &quot;cannot parse ocsp.responderCertSubjectName property&quot;, e);
<span class="nc" id="L236">        }</span>
<span class="nc" id="L237">        return getResponderCert(sel, anchors, stores);</span>
    }

    private static X509Certificate getResponderCert(String issuer,
                                                    String serial,
                                                    Set&lt;TrustAnchor&gt; anchors,
                                                    List&lt;CertStore&gt; stores)
        throws CertPathValidatorException
    {
<span class="nc" id="L246">        X509CertSelector sel = new X509CertSelector();</span>
        try {
<span class="nc" id="L248">            sel.setIssuer(new X500Principal(issuer));</span>
<span class="nc" id="L249">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L250">            throw new CertPathValidatorException(</span>
                &quot;cannot parse ocsp.responderCertIssuerName property&quot;, e);
<span class="nc" id="L252">        }</span>
        try {
<span class="nc" id="L254">            sel.setSerialNumber(new BigInteger(stripOutSeparators(serial), 16));</span>
<span class="nc" id="L255">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L256">            throw new CertPathValidatorException(</span>
                &quot;cannot parse ocsp.responderCertSerialNumber property&quot;, e);
<span class="nc" id="L258">        }</span>
<span class="nc" id="L259">        return getResponderCert(sel, anchors, stores);</span>
    }

    private static X509Certificate getResponderCert(X509CertSelector sel,
                                                    Set&lt;TrustAnchor&gt; anchors,
                                                    List&lt;CertStore&gt; stores)
        throws CertPathValidatorException
    {
        // first check TrustAnchors
<span class="nc bnc" id="L268" title="All 2 branches missed.">        for (TrustAnchor anchor : anchors) {</span>
<span class="nc" id="L269">            X509Certificate cert = anchor.getTrustedCert();</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            if (cert == null) {</span>
<span class="nc" id="L271">                continue;</span>
            }
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (sel.match(cert)) {</span>
<span class="nc" id="L274">                return cert;</span>
            }
<span class="nc" id="L276">        }</span>
        // now check CertStores
<span class="nc bnc" id="L278" title="All 2 branches missed.">        for (CertStore store : stores) {</span>
            try {
<span class="nc" id="L280">                Collection&lt;? extends Certificate&gt; certs =</span>
<span class="nc" id="L281">                    store.getCertificates(sel);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                if (!certs.isEmpty()) {</span>
<span class="nc" id="L283">                    return (X509Certificate)certs.iterator().next();</span>
                }
<span class="nc" id="L285">            } catch (CertStoreException e) {</span>
                // ignore and try next CertStore
<span class="nc bnc" id="L287" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L288">                    debug.println(&quot;CertStore exception:&quot; + e);</span>
                }
<span class="nc" id="L290">                continue;</span>
<span class="nc" id="L291">            }</span>
<span class="nc" id="L292">        }</span>
<span class="nc" id="L293">        throw new CertPathValidatorException(</span>
            &quot;Cannot find the responder's certificate &quot; +
            &quot;(set using the OCSP security properties).&quot;);
    }

    @Override
    public void init(boolean forward) throws CertPathValidatorException {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if (forward) {</span>
<span class="nc" id="L301">            throw new</span>
                CertPathValidatorException(&quot;forward checking not supported&quot;);
        }
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">        if (anchor != null) {</span>
<span class="fc" id="L305">            issuerCert = anchor.getTrustedCert();</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">            prevPubKey = (issuerCert != null) ? issuerCert.getPublicKey()</span>
<span class="pc" id="L307">                                              : anchor.getCAPublicKey();</span>
        }
<span class="fc" id="L309">        crlSignFlag = true;</span>
<span class="pc bpc" id="L310" title="2 of 4 branches missed.">        if (params != null &amp;&amp; params.certPath() != null) {</span>
<span class="fc" id="L311">            certIndex = params.certPath().getCertificates().size() - 1;</span>
        } else {
<span class="nc" id="L313">            certIndex = -1;</span>
        }
<span class="fc" id="L315">        softFailExceptions.clear();</span>
<span class="fc" id="L316">    }</span>

    @Override
    public boolean isForwardCheckingSupported() {
<span class="fc" id="L320">        return false;</span>
    }

    @Override
    public Set&lt;String&gt; getSupportedExtensions() {
<span class="nc" id="L325">        return null;</span>
    }

    @Override
    public List&lt;CertPathValidatorException&gt; getSoftFailExceptions() {
<span class="nc" id="L330">        return Collections.unmodifiableList(softFailExceptions);</span>
    }

    @Override
    public void check(Certificate cert, Collection&lt;String&gt; unresolvedCritExts)
        throws CertPathValidatorException
    {
<span class="fc" id="L337">        check((X509Certificate)cert, unresolvedCritExts,</span>
              prevPubKey, crlSignFlag);
<span class="fc" id="L339">    }</span>

    private void check(X509Certificate xcert,
                       Collection&lt;String&gt; unresolvedCritExts,
                       PublicKey pubKey, boolean crlSignFlag)
        throws CertPathValidatorException
    {
        try {
<span class="pc bpc" id="L347" title="3 of 4 branches missed.">            if (onlyEE &amp;&amp; xcert.getBasicConstraints() != -1) {</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L349">                    debug.println(&quot;Skipping revocation check, not end &quot; +</span>
                                  &quot;entity cert&quot;);
                }
<span class="nc" id="L352">                return;</span>
            }
<span class="pc bpc" id="L354" title="2 of 3 branches missed.">            switch (mode) {</span>
                case PREFER_OCSP:
                case ONLY_OCSP:
<span class="nc" id="L357">                    checkOCSP(xcert, unresolvedCritExts);</span>
<span class="nc" id="L358">                    break;</span>
                case PREFER_CRLS:
                case ONLY_CRLS:
<span class="fc" id="L361">                    checkCRLs(xcert, unresolvedCritExts, null,</span>
                              pubKey, crlSignFlag);
                    break;
            }
<span class="nc" id="L365">        } catch (CertPathValidatorException e) {</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">            if (e.getReason() == BasicReason.REVOKED) {</span>
<span class="nc" id="L367">                throw e;</span>
            }
<span class="nc" id="L369">            boolean eSoftFail = isSoftFailException(e);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">            if (eSoftFail) {</span>
<span class="nc bnc" id="L371" title="All 4 branches missed.">                if (mode == Mode.ONLY_OCSP || mode == Mode.ONLY_CRLS) {</span>
<span class="nc" id="L372">                    return;</span>
                }
            } else {
<span class="nc bnc" id="L375" title="All 4 branches missed.">                if (mode == Mode.ONLY_OCSP || mode == Mode.ONLY_CRLS) {</span>
<span class="nc" id="L376">                    throw e;</span>
                }
            }
<span class="nc" id="L379">            CertPathValidatorException cause = e;</span>
            // Otherwise, failover
<span class="nc bnc" id="L381" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L382">                debug.println(&quot;RevocationChecker.check() &quot; + e.getMessage());</span>
<span class="nc" id="L383">                debug.println(&quot;RevocationChecker.check() preparing to failover&quot;);</span>
            }
            try {
<span class="nc bnc" id="L386" title="All 3 branches missed.">                switch (mode) {</span>
                    case PREFER_OCSP:
<span class="nc" id="L388">                        checkCRLs(xcert, unresolvedCritExts, null,</span>
                                  pubKey, crlSignFlag);
<span class="nc" id="L390">                        break;</span>
                    case PREFER_CRLS:
<span class="nc" id="L392">                        checkOCSP(xcert, unresolvedCritExts);</span>
                        break;
                }
<span class="nc" id="L395">            } catch (CertPathValidatorException x) {</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L397">                    debug.println(&quot;RevocationChecker.check() failover failed&quot;);</span>
<span class="nc" id="L398">                    debug.println(&quot;RevocationChecker.check() &quot; + x.getMessage());</span>
                }
<span class="nc bnc" id="L400" title="All 2 branches missed.">                if (x.getReason() == BasicReason.REVOKED) {</span>
<span class="nc" id="L401">                    throw x;</span>
                }
<span class="nc bnc" id="L403" title="All 2 branches missed.">                if (!isSoftFailException(x)) {</span>
<span class="nc" id="L404">                    cause.addSuppressed(x);</span>
<span class="nc" id="L405">                    throw cause;</span>
                } else {
                    // only pass if both exceptions were soft failures
<span class="nc bnc" id="L408" title="All 2 branches missed.">                    if (!eSoftFail) {</span>
<span class="nc" id="L409">                        throw cause;</span>
                    }
                }
<span class="nc" id="L412">            }</span>
        } finally {
<span class="pc" id="L414">            updateState(xcert);</span>
<span class="pc" id="L415">        }</span>
<span class="fc" id="L416">    }</span>

    private boolean isSoftFailException(CertPathValidatorException e) {
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (softFail &amp;&amp;</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">            e.getReason() == BasicReason.UNDETERMINED_REVOCATION_STATUS)</span>
        {
            // recreate exception with correct index
<span class="nc" id="L423">            CertPathValidatorException e2 = new CertPathValidatorException(</span>
<span class="nc" id="L424">                e.getMessage(), e.getCause(), params.certPath(), certIndex,</span>
<span class="nc" id="L425">                e.getReason());</span>
<span class="nc" id="L426">            softFailExceptions.addFirst(e2);</span>
<span class="nc" id="L427">            return true;</span>
        }
<span class="nc" id="L429">        return false;</span>
    }

    private void updateState(X509Certificate cert)
        throws CertPathValidatorException
    {
<span class="fc" id="L435">        issuerCert = cert;</span>

        // Make new public key if parameters are missing
<span class="fc" id="L438">        PublicKey pubKey = cert.getPublicKey();</span>
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        if (PKIX.isDSAPublicKeyWithoutParams(pubKey)) {</span>
            // pubKey needs to inherit DSA parameters from prev key
<span class="nc" id="L441">            pubKey = BasicChecker.makeInheritedParamsKey(pubKey, prevPubKey);</span>
        }
<span class="fc" id="L443">        prevPubKey = pubKey;</span>
<span class="fc" id="L444">        crlSignFlag = certCanSignCrl(cert);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (certIndex &gt; 0) {</span>
<span class="fc" id="L446">            certIndex--;</span>
        }
<span class="fc" id="L448">    }</span>

    // Maximum clock skew in milliseconds (15 minutes) allowed when checking
    // validity of CRLs
    private static final long MAX_CLOCK_SKEW = 900000;
    private void checkCRLs(X509Certificate cert,
                           Collection&lt;String&gt; unresolvedCritExts,
                           Set&lt;X509Certificate&gt; stackedCerts,
                           PublicKey pubKey, boolean signFlag)
        throws CertPathValidatorException
    {
<span class="fc" id="L459">        checkCRLs(cert, pubKey, signFlag, true,</span>
<span class="fc" id="L460">                  stackedCerts, params.trustAnchors());</span>
<span class="fc" id="L461">    }</span>

    private void checkCRLs(X509Certificate cert, PublicKey prevKey,
                           boolean signFlag, boolean allowSeparateKey,
                           Set&lt;X509Certificate&gt; stackedCerts,
                           Set&lt;TrustAnchor&gt; anchors)
        throws CertPathValidatorException
    {
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L470">            debug.println(&quot;RevocationChecker.checkCRLs()&quot; +</span>
                          &quot; ---checking revocation status ...&quot;);
        }

        // reject circular dependencies - RFC 3280 is not explicit on how
        // to handle this, so we feel it is safest to reject them until
        // the issue is resolved in the PKIX WG.
<span class="pc bpc" id="L477" title="1 of 4 branches missed.">        if (stackedCerts != null &amp;&amp; stackedCerts.contains(cert)) {</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L479">                debug.println(&quot;RevocationChecker.checkCRLs()&quot; +</span>
                              &quot; circular dependency&quot;);
            }
<span class="nc" id="L482">            throw new CertPathValidatorException</span>
                 (&quot;Could not determine revocation status&quot;, null, null, -1,
                  BasicReason.UNDETERMINED_REVOCATION_STATUS);
        }

<span class="fc" id="L487">        Set&lt;X509CRL&gt; possibleCRLs = new HashSet&lt;&gt;();</span>
<span class="fc" id="L488">        Set&lt;X509CRL&gt; approvedCRLs = new HashSet&lt;&gt;();</span>
<span class="fc" id="L489">        X509CRLSelector sel = new X509CRLSelector();</span>
<span class="fc" id="L490">        sel.setCertificateChecking(cert);</span>
<span class="fc" id="L491">        CertPathHelper.setDateAndTime(sel, params.date(), MAX_CLOCK_SKEW);</span>

        // First, check user-specified CertStores
<span class="fc" id="L494">        CertPathValidatorException networkFailureException = null;</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">        for (CertStore store : certStores) {</span>
            try {
<span class="fc bfc" id="L497" title="All 2 branches covered.">                for (CRL crl : store.getCRLs(sel)) {</span>
<span class="fc" id="L498">                    possibleCRLs.add((X509CRL)crl);</span>
<span class="fc" id="L499">                }</span>
<span class="nc" id="L500">            } catch (CertStoreException e) {</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L502">                    debug.println(&quot;RevocationChecker.checkCRLs() &quot; +</span>
<span class="nc" id="L503">                                  &quot;CertStoreException: &quot; + e.getMessage());</span>
                }
<span class="nc bnc" id="L505" title="All 2 branches missed.">                if (networkFailureException == null &amp;&amp;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                    CertStoreHelper.isCausedByNetworkIssue(store.getType(),e)) {</span>
                    // save this exception, we may need to throw it later
<span class="nc" id="L508">                    networkFailureException = new CertPathValidatorException(</span>
                        &quot;Unable to determine revocation status due to &quot; +
                        &quot;network error&quot;, e, null, -1,
                        BasicReason.UNDETERMINED_REVOCATION_STATUS);
                }
<span class="fc" id="L513">            }</span>
<span class="fc" id="L514">        }</span>

<span class="pc bpc" id="L516" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L517">            debug.println(&quot;RevocationChecker.checkCRLs() &quot; +</span>
<span class="nc" id="L518">                          &quot;possible crls.size() = &quot; + possibleCRLs.size());</span>
        }
<span class="fc" id="L520">        boolean[] reasonsMask = new boolean[9];</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">        if (!possibleCRLs.isEmpty()) {</span>
            // Now that we have a list of possible CRLs, see which ones can
            // be approved
<span class="fc" id="L524">            approvedCRLs.addAll(verifyPossibleCRLs(possibleCRLs, cert, prevKey,</span>
                                                   signFlag, reasonsMask,
                                                   anchors));
        }

<span class="pc bpc" id="L529" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L530">            debug.println(&quot;RevocationChecker.checkCRLs() &quot; +</span>
<span class="nc" id="L531">                          &quot;approved crls.size() = &quot; + approvedCRLs.size());</span>
        }

        // make sure that we have at least one CRL that _could_ cover
        // the certificate in question and all reasons are covered
<span class="fc bfc" id="L536" title="All 2 branches covered.">        if (!approvedCRLs.isEmpty() &amp;&amp;</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">            Arrays.equals(reasonsMask, ALL_REASONS))</span>
        {
<span class="fc" id="L539">            checkApprovedCRLs(cert, approvedCRLs);</span>
        } else {
            // Check Distribution Points
            // all CRLs returned by the DP Fetcher have also been verified
            try {
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">                if (crlDP) {</span>
<span class="fc" id="L545">                    approvedCRLs.addAll(DistributionPointFetcher.getCRLs(</span>
                                        sel, signFlag, prevKey,
<span class="fc" id="L547">                                        params.sigProvider(), certStores,</span>
                                        reasonsMask, anchors, null));
                }
<span class="nc" id="L550">            } catch (CertStoreException e) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">                if (e instanceof CertStoreTypeException) {</span>
<span class="nc" id="L552">                    CertStoreTypeException cste = (CertStoreTypeException)e;</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">                    if (CertStoreHelper.isCausedByNetworkIssue(cste.getType(),</span>
                                                               e)) {
<span class="nc" id="L555">                        throw new CertPathValidatorException(</span>
                            &quot;Unable to determine revocation status due to &quot; +
                            &quot;network error&quot;, e, null, -1,
                            BasicReason.UNDETERMINED_REVOCATION_STATUS);
                    }
                }
<span class="nc" id="L561">                throw new CertPathValidatorException(e);</span>
<span class="fc" id="L562">            }</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">            if (!approvedCRLs.isEmpty() &amp;&amp;</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                Arrays.equals(reasonsMask, ALL_REASONS))</span>
            {
<span class="nc" id="L566">                checkApprovedCRLs(cert, approvedCRLs);</span>
            } else {
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">                if (allowSeparateKey) {</span>
                    try {
<span class="fc" id="L570">                        verifyWithSeparateSigningKey(cert, prevKey, signFlag,</span>
                                                     stackedCerts);
<span class="fc" id="L572">                        return;</span>
<span class="nc" id="L573">                    } catch (CertPathValidatorException cpve) {</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">                        if (networkFailureException != null) {</span>
                            // if a network issue previously prevented us from
                            // retrieving a CRL from one of the user-specified
                            // CertStores, throw it now so it can be handled
                            // appropriately
<span class="nc" id="L579">                            throw networkFailureException;</span>
                        }
<span class="nc" id="L581">                        throw cpve;</span>
                    }
                } else {
<span class="nc bnc" id="L584" title="All 2 branches missed.">                    if (networkFailureException != null) {</span>
                        // if a network issue previously prevented us from
                        // retrieving a CRL from one of the user-specified
                        // CertStores, throw it now so it can be handled
                        // appropriately
<span class="nc" id="L589">                        throw networkFailureException;</span>
                    }
<span class="nc" id="L591">                    throw new CertPathValidatorException(</span>
                        &quot;Could not determine revocation status&quot;, null, null, -1,
                        BasicReason.UNDETERMINED_REVOCATION_STATUS);
                }
            }
        }
<span class="fc" id="L597">    }</span>

    private void checkApprovedCRLs(X509Certificate cert,
                                   Set&lt;X509CRL&gt; approvedCRLs)
        throws CertPathValidatorException
    {
        // See if the cert is in the set of approved crls.
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L605">            BigInteger sn = cert.getSerialNumber();</span>
<span class="nc" id="L606">            debug.println(&quot;RevocationChecker.checkApprovedCRLs() &quot; +</span>
                          &quot;starting the final sweep...&quot;);
<span class="nc" id="L608">            debug.println(&quot;RevocationChecker.checkApprovedCRLs()&quot; +</span>
<span class="nc" id="L609">                          &quot; cert SN: &quot; + sn.toString());</span>
        }

<span class="fc" id="L612">        CRLReason reasonCode = CRLReason.UNSPECIFIED;</span>
<span class="fc" id="L613">        X509CRLEntryImpl entry = null;</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">        for (X509CRL crl : approvedCRLs) {</span>
<span class="fc" id="L615">            X509CRLEntry e = crl.getRevokedCertificate(cert);</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">            if (e != null) {</span>
                try {
<span class="nc" id="L618">                    entry = X509CRLEntryImpl.toImpl(e);</span>
<span class="nc" id="L619">                } catch (CRLException ce) {</span>
<span class="nc" id="L620">                    throw new CertPathValidatorException(ce);</span>
<span class="nc" id="L621">                }</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L623">                    debug.println(&quot;RevocationChecker.checkApprovedCRLs()&quot;</span>
<span class="nc" id="L624">                        + &quot; CRL entry: &quot; + entry.toString());</span>
                }

                /*
                 * Abort CRL validation and throw exception if there are any
                 * unrecognized critical CRL entry extensions (see section
                 * 5.3 of RFC 3280).
                 */
<span class="nc" id="L632">                Set&lt;String&gt; unresCritExts = entry.getCriticalExtensionOIDs();</span>
<span class="nc bnc" id="L633" title="All 4 branches missed.">                if (unresCritExts != null &amp;&amp; !unresCritExts.isEmpty()) {</span>
                    /* remove any that we will process */
<span class="nc" id="L635">                    unresCritExts.remove(ReasonCode_Id.toString());</span>
<span class="nc" id="L636">                    unresCritExts.remove(CertificateIssuer_Id.toString());</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">                    if (!unresCritExts.isEmpty()) {</span>
<span class="nc" id="L638">                        throw new CertPathValidatorException(</span>
                            &quot;Unrecognized critical extension(s) in revoked &quot; +
                            &quot;CRL entry&quot;);
                    }
                }

<span class="nc" id="L644">                reasonCode = entry.getRevocationReason();</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">                if (reasonCode == null) {</span>
<span class="nc" id="L646">                    reasonCode = CRLReason.UNSPECIFIED;</span>
                }
<span class="nc" id="L648">                Date revocationDate = entry.getRevocationDate();</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">                if (revocationDate.before(params.date())) {</span>
<span class="nc" id="L650">                    Throwable t = new CertificateRevokedException(</span>
                        revocationDate, reasonCode,
<span class="nc" id="L652">                        crl.getIssuerX500Principal(), entry.getExtensions());</span>
<span class="nc" id="L653">                    throw new CertPathValidatorException(</span>
<span class="nc" id="L654">                        t.getMessage(), t, null, -1, BasicReason.REVOKED);</span>
                }
            }
<span class="fc" id="L657">        }</span>
<span class="fc" id="L658">    }</span>

    private void checkOCSP(X509Certificate cert,
                           Collection&lt;String&gt; unresolvedCritExts)
        throws CertPathValidatorException
    {
<span class="nc" id="L664">        X509CertImpl currCert = null;</span>
        try {
<span class="nc" id="L666">            currCert = X509CertImpl.toImpl(cert);</span>
<span class="nc" id="L667">        } catch (CertificateException ce) {</span>
<span class="nc" id="L668">            throw new CertPathValidatorException(ce);</span>
<span class="nc" id="L669">        }</span>

<span class="nc bnc" id="L671" title="All 2 branches missed.">        X509Certificate respCert = (responderCert == null) ? issuerCert</span>
                                                           : responderCert;

        // The algorithm constraints of the OCSP trusted responder certificate
        // does not need to be checked in this code. The constraints will be
        // checked when the responder's certificate is validated.

<span class="nc" id="L678">        OCSPResponse response = null;</span>
<span class="nc" id="L679">        CertId certId = null;</span>
        try {
<span class="nc bnc" id="L681" title="All 2 branches missed.">            if (issuerCert != null) {</span>
<span class="nc" id="L682">                certId = new CertId(issuerCert,</span>
<span class="nc" id="L683">                                    currCert.getSerialNumberObject());</span>
            } else {
                // must be an anchor name and key
<span class="nc" id="L686">                certId = new CertId(anchor.getCA(), anchor.getCAPublicKey(),</span>
<span class="nc" id="L687">                                    currCert.getSerialNumberObject());</span>
            }

            // check if there is a cached OCSP response available
<span class="nc" id="L691">            byte[] responseBytes = ocspResponses.get(cert);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">            if (responseBytes != null) {</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L694">                    debug.println(&quot;Found cached OCSP response&quot;);</span>
                }
<span class="nc" id="L696">                response = new OCSPResponse(responseBytes);</span>

                // verify the response
<span class="nc" id="L699">                byte[] nonce = null;</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">                for (Extension ext : ocspExtensions) {</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">                    if (ext.getId().equals(&quot;1.3.6.1.5.5.7.48.1.2&quot;)) {</span>
<span class="nc" id="L702">                        nonce = ext.getValue();</span>
                    }
<span class="nc" id="L704">                }</span>
<span class="nc" id="L705">                response.verify(Collections.singletonList(certId), respCert,</span>
<span class="nc" id="L706">                                params.date(), nonce);</span>

<span class="nc" id="L708">            } else {</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">                URI responderURI = (this.responderURI != null)</span>
                                   ? this.responderURI
<span class="nc" id="L711">                                   : OCSP.getResponderURI(currCert);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                if (responderURI == null) {</span>
<span class="nc" id="L713">                    throw new CertPathValidatorException(</span>
                        &quot;Certificate does not specify OCSP responder&quot;, null,
                        null, -1);
                }

<span class="nc" id="L718">                response = OCSP.check(Collections.singletonList(certId),</span>
                                      responderURI, respCert, null,
                                      ocspExtensions);
            }
<span class="nc" id="L722">        } catch (IOException e) {</span>
<span class="nc" id="L723">            throw new CertPathValidatorException(</span>
                &quot;Unable to determine revocation status due to network error&quot;,
                e, null, -1, BasicReason.UNDETERMINED_REVOCATION_STATUS);
<span class="nc" id="L726">        }</span>

<span class="nc" id="L728">        RevocationStatus rs =</span>
<span class="nc" id="L729">            (RevocationStatus)response.getSingleResponse(certId);</span>
<span class="nc" id="L730">        RevocationStatus.CertStatus certStatus = rs.getCertStatus();</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (certStatus == RevocationStatus.CertStatus.REVOKED) {</span>
<span class="nc" id="L732">            Date revocationTime = rs.getRevocationTime();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">            if (revocationTime.before(params.date())) {</span>
<span class="nc" id="L734">                Throwable t = new CertificateRevokedException(</span>
<span class="nc" id="L735">                    revocationTime, rs.getRevocationReason(),</span>
<span class="nc" id="L736">                    respCert.getSubjectX500Principal(),</span>
<span class="nc" id="L737">                    rs.getSingleExtensions());</span>
<span class="nc" id="L738">                throw new CertPathValidatorException(t.getMessage(), t, null,</span>
                                                     -1, BasicReason.REVOKED);
            }
<span class="nc bnc" id="L741" title="All 2 branches missed.">        } else if (certStatus == RevocationStatus.CertStatus.UNKNOWN) {</span>
<span class="nc" id="L742">            throw new CertPathValidatorException(</span>
                &quot;Certificate's revocation status is unknown&quot;, null,
<span class="nc" id="L744">                params.certPath(), -1,</span>
                BasicReason.UNDETERMINED_REVOCATION_STATUS);
        }
<span class="nc" id="L747">    }</span>

    /*
     * Removes any non-hexadecimal characters from a string.
     */
    private static final String HEX_DIGITS = &quot;0123456789ABCDEFabcdef&quot;;
    private static String stripOutSeparators(String value) {
<span class="nc" id="L754">        char[] chars = value.toCharArray();</span>
<span class="nc" id="L755">        StringBuilder hexNumber = new StringBuilder();</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">        for (int i = 0; i &lt; chars.length; i++) {</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            if (HEX_DIGITS.indexOf(chars[i]) != -1) {</span>
<span class="nc" id="L758">                hexNumber.append(chars[i]);</span>
            }
        }
<span class="nc" id="L761">        return hexNumber.toString();</span>
    }

    /**
     * Checks that a cert can be used to verify a CRL.
     *
     * @param cert an X509Certificate to check
     * @return a boolean specifying if the cert is allowed to vouch for the
     *         validity of a CRL
     */
    static boolean certCanSignCrl(X509Certificate cert) {
        // if the cert doesn't include the key usage ext, or
        // the key usage ext asserts cRLSigning, return true,
        // otherwise return false.
<span class="fc" id="L775">        boolean[] keyUsage = cert.getKeyUsage();</span>
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">        if (keyUsage != null) {</span>
<span class="fc" id="L777">            return keyUsage[6];</span>
        }
<span class="nc" id="L779">        return false;</span>
    }

    /**
     * Internal method that verifies a set of possible_crls,
     * and sees if each is approved, based on the cert.
     *
     * @param crls a set of possible CRLs to test for acceptability
     * @param cert the certificate whose revocation status is being checked
     * @param signFlag &lt;code&gt;true&lt;/code&gt; if prevKey was trusted to sign CRLs
     * @param prevKey the public key of the issuer of cert
     * @param reasonsMask the reason code mask
     * @param trustAnchors a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;TrustAnchor&lt;/code&gt;s&gt;
     * @return a collection of approved crls (or an empty collection)
     */
<span class="fc" id="L794">    private static final boolean[] ALL_REASONS =</span>
        {true, true, true, true, true, true, true, true, true};
    private Collection&lt;X509CRL&gt; verifyPossibleCRLs(Set&lt;X509CRL&gt; crls,
                                                   X509Certificate cert,
                                                   PublicKey prevKey,
                                                   boolean signFlag,
                                                   boolean[] reasonsMask,
                                                   Set&lt;TrustAnchor&gt; anchors)
        throws CertPathValidatorException
    {
        try {
<span class="fc" id="L805">            X509CertImpl certImpl = X509CertImpl.toImpl(cert);</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L807">                debug.println(&quot;RevocationChecker.verifyPossibleCRLs: &quot; +</span>
                              &quot;Checking CRLDPs for &quot;
<span class="nc" id="L809">                              + certImpl.getSubjectX500Principal());</span>
            }
<span class="fc" id="L811">            CRLDistributionPointsExtension ext =</span>
<span class="fc" id="L812">                certImpl.getCRLDistributionPointsExtension();</span>
<span class="fc" id="L813">            List&lt;DistributionPoint&gt; points = null;</span>
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">            if (ext == null) {</span>
                // assume a DP with reasons and CRLIssuer fields omitted
                // and a DP name of the cert issuer.
                // TODO add issuerAltName too
<span class="fc" id="L818">                X500Name certIssuer = (X500Name)certImpl.getIssuerDN();</span>
<span class="fc" id="L819">                DistributionPoint point = new DistributionPoint(</span>
<span class="fc" id="L820">                     new GeneralNames().add(new GeneralName(certIssuer)),</span>
                     null, null);
<span class="fc" id="L822">                points = Collections.singletonList(point);</span>
<span class="fc" id="L823">            } else {</span>
<span class="nc" id="L824">                points = ext.get(CRLDistributionPointsExtension.POINTS);</span>
            }
<span class="fc" id="L826">            Set&lt;X509CRL&gt; results = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">            for (DistributionPoint point : points) {</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">                for (X509CRL crl : crls) {</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">                    if (DistributionPointFetcher.verifyCRL(</span>
                            certImpl, point, crl, reasonsMask, signFlag,
<span class="fc" id="L831">                            prevKey, params.sigProvider(), anchors,</span>
<span class="fc" id="L832">                            certStores, params.date()))</span>
                    {
<span class="fc" id="L834">                        results.add(crl);</span>
                    }
<span class="fc" id="L836">                }</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">                if (Arrays.equals(reasonsMask, ALL_REASONS))</span>
<span class="fc" id="L838">                    break;</span>
<span class="fc" id="L839">            }</span>
<span class="fc" id="L840">            return results;</span>
<span class="nc" id="L841">        } catch (CertificateException | CRLException | IOException e) {</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L843">                debug.println(&quot;Exception while verifying CRL: &quot;+e.getMessage());</span>
<span class="nc" id="L844">                e.printStackTrace();</span>
            }
<span class="nc" id="L846">            return Collections.emptySet();</span>
        }
    }

    /**
     * We have a cert whose revocation status couldn't be verified by
     * a CRL issued by the cert that issued the CRL. See if we can
     * find a valid CRL issued by a separate key that can verify the
     * revocation status of this certificate.
     * &lt;p&gt;
     * Note that this does not provide support for indirect CRLs,
     * only CRLs signed with a different key (but the same issuer
     * name) as the certificate being checked.
     *
     * @param currCert the &lt;code&gt;X509Certificate&lt;/code&gt; to be checked
     * @param prevKey the &lt;code&gt;PublicKey&lt;/code&gt; that failed
     * @param signFlag &lt;code&gt;true&lt;/code&gt; if that key was trusted to sign CRLs
     * @param stackedCerts a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;X509Certificate&lt;/code&gt;s&gt;
     *                     whose revocation status depends on the
     *                     non-revoked status of this cert. To avoid
     *                     circular dependencies, we assume they're
     *                     revoked while checking the revocation
     *                     status of this cert.
     * @throws CertPathValidatorException if the cert's revocation status
     *         cannot be verified successfully with another key
     */
    private void verifyWithSeparateSigningKey(X509Certificate cert,
                                              PublicKey prevKey,
                                              boolean signFlag,
                                              Set&lt;X509Certificate&gt; stackedCerts)
        throws CertPathValidatorException
    {
<span class="fc" id="L878">        String msg = &quot;revocation status&quot;;</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L880">            debug.println(</span>
                &quot;RevocationChecker.verifyWithSeparateSigningKey()&quot; +
                &quot; ---checking &quot; + msg + &quot;...&quot;);
        }

        // reject circular dependencies - RFC 3280 is not explicit on how
        // to handle this, so we feel it is safest to reject them until
        // the issue is resolved in the PKIX WG.
<span class="pc bpc" id="L888" title="1 of 4 branches missed.">        if ((stackedCerts != null) &amp;&amp; stackedCerts.contains(cert)) {</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L890">                debug.println(</span>
                    &quot;RevocationChecker.verifyWithSeparateSigningKey()&quot; +
                    &quot; circular dependency&quot;);
            }
<span class="nc" id="L894">            throw new CertPathValidatorException</span>
                (&quot;Could not determine revocation status&quot;, null, null, -1,
                 BasicReason.UNDETERMINED_REVOCATION_STATUS);
        }

        // Try to find another key that might be able to sign
        // CRLs vouching for this cert.
        // If prevKey wasn't trusted, maybe we just didn't have the right
        // path to it. Don't rule that key out.
<span class="fc bfc" id="L903" title="All 2 branches covered.">        if (!signFlag) {</span>
<span class="fc" id="L904">            buildToNewKey(cert, null, stackedCerts);</span>
        } else {
<span class="fc" id="L906">            buildToNewKey(cert, prevKey, stackedCerts);</span>
        }
<span class="fc" id="L908">    }</span>

    /**
     * Tries to find a CertPath that establishes a key that can be
     * used to verify the revocation status of a given certificate.
     * Ignores keys that have previously been tried. Throws a
     * CertPathValidatorException if no such key could be found.
     *
     * @param currCert the &lt;code&gt;X509Certificate&lt;/code&gt; to be checked
     * @param prevKey the &lt;code&gt;PublicKey&lt;/code&gt; of the certificate whose key
     *    cannot be used to vouch for the CRL and should be ignored
     * @param stackedCerts a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;X509Certificate&lt;/code&gt;s&gt;
     *                     whose revocation status depends on the
     *                     establishment of this path.
     * @throws CertPathValidatorException on failure
     */
<span class="fc" id="L924">    private static final boolean [] CRL_SIGN_USAGE =</span>
        { false, false, false, false, false, false, true };
    private void buildToNewKey(X509Certificate currCert,
                               PublicKey prevKey,
                               Set&lt;X509Certificate&gt; stackedCerts)
        throws CertPathValidatorException
    {

<span class="pc bpc" id="L932" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L933">            debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +</span>
                          &quot; starting work&quot;);
        }
<span class="fc" id="L936">        Set&lt;PublicKey&gt; badKeys = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">        if (prevKey != null) {</span>
<span class="fc" id="L938">            badKeys.add(prevKey);</span>
        }
<span class="fc" id="L940">        X509CertSelector certSel = new RejectKeySelector(badKeys);</span>
<span class="fc" id="L941">        certSel.setSubject(currCert.getIssuerX500Principal());</span>
<span class="fc" id="L942">        certSel.setKeyUsage(CRL_SIGN_USAGE);</span>

<span class="pc bpc" id="L944" title="1 of 2 branches missed.">        Set&lt;TrustAnchor&gt; newAnchors = anchor == null ?</span>
<span class="pc" id="L945">                                      params.trustAnchors() :</span>
<span class="fc" id="L946">                                      Collections.singleton(anchor);</span>

        PKIXBuilderParameters builderParams;
        try {
<span class="fc" id="L950">            builderParams = new PKIXBuilderParameters(newAnchors, certSel);</span>
<span class="nc" id="L951">        } catch (InvalidAlgorithmParameterException iape) {</span>
<span class="nc" id="L952">            throw new RuntimeException(iape); // should never occur</span>
<span class="fc" id="L953">        }</span>
<span class="fc" id="L954">        builderParams.setInitialPolicies(params.initialPolicies());</span>
<span class="fc" id="L955">        builderParams.setCertStores(certStores);</span>
<span class="fc" id="L956">        builderParams.setExplicitPolicyRequired</span>
<span class="fc" id="L957">            (params.explicitPolicyRequired());</span>
<span class="fc" id="L958">        builderParams.setPolicyMappingInhibited</span>
<span class="fc" id="L959">            (params.policyMappingInhibited());</span>
<span class="fc" id="L960">        builderParams.setAnyPolicyInhibited(params.anyPolicyInhibited());</span>
        // Policy qualifiers must be rejected, since we don't have
        // any way to convey them back to the application.
        // That's the default, so no need to write code.
<span class="fc" id="L964">        builderParams.setDate(params.date());</span>
        // CertPathCheckers need to be cloned to start from fresh state
<span class="fc" id="L966">        builderParams.setCertPathCheckers(</span>
<span class="fc" id="L967">            params.getPKIXParameters().getCertPathCheckers());</span>
<span class="fc" id="L968">        builderParams.setSigProvider(params.sigProvider());</span>

        // Skip revocation during this build to detect circular
        // references. But check revocation afterwards, using the
        // key (or any other that works).
<span class="fc" id="L973">        builderParams.setRevocationEnabled(false);</span>

        // check for AuthorityInformationAccess extension
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">        if (Builder.USE_AIA == true) {</span>
<span class="nc" id="L977">            X509CertImpl currCertImpl = null;</span>
            try {
<span class="nc" id="L979">                currCertImpl = X509CertImpl.toImpl(currCert);</span>
<span class="nc" id="L980">            } catch (CertificateException ce) {</span>
                // ignore but log it
<span class="nc bnc" id="L982" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L983">                    debug.println(&quot;RevocationChecker.buildToNewKey: &quot; +</span>
                                  &quot;error decoding cert: &quot; + ce);
                }
<span class="nc" id="L986">            }</span>
<span class="nc" id="L987">            AuthorityInfoAccessExtension aiaExt = null;</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">            if (currCertImpl != null) {</span>
<span class="nc" id="L989">                aiaExt = currCertImpl.getAuthorityInfoAccessExtension();</span>
            }
<span class="nc bnc" id="L991" title="All 2 branches missed.">            if (aiaExt != null) {</span>
<span class="nc" id="L992">                List&lt;AccessDescription&gt; adList = aiaExt.getAccessDescriptions();</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">                if (adList != null) {</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">                    for (AccessDescription ad : adList) {</span>
<span class="nc" id="L995">                        CertStore cs = URICertStore.getInstance(ad);</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">                        if (cs != null) {</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">                            if (debug != null) {</span>
<span class="nc" id="L998">                                debug.println(&quot;adding AIAext CertStore&quot;);</span>
                            }
<span class="nc" id="L1000">                            builderParams.addCertStore(cs);</span>
                        }
<span class="nc" id="L1002">                    }</span>
                }
            }
        }

<span class="fc" id="L1007">        CertPathBuilder builder = null;</span>
        try {
<span class="fc" id="L1009">            builder = CertPathBuilder.getInstance(&quot;PKIX&quot;);</span>
<span class="nc" id="L1010">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L1011">            throw new CertPathValidatorException(nsae);</span>
<span class="fc" id="L1012">        }</span>
        while (true) {
            try {
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L1016">                    debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +</span>
                                  &quot; about to try build ...&quot;);
                }
<span class="fc" id="L1019">                PKIXCertPathBuilderResult cpbr =</span>
<span class="fc" id="L1020">                    (PKIXCertPathBuilderResult)builder.build(builderParams);</span>

<span class="pc bpc" id="L1022" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L1023">                    debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +</span>
                                  &quot; about to check revocation ...&quot;);
                }
                // Now check revocation of all certs in path, assuming that
                // the stackedCerts are revoked.
<span class="fc bfc" id="L1028" title="All 2 branches covered.">                if (stackedCerts == null) {</span>
<span class="fc" id="L1029">                    stackedCerts = new HashSet&lt;X509Certificate&gt;();</span>
                }
<span class="fc" id="L1031">                stackedCerts.add(currCert);</span>
<span class="fc" id="L1032">                TrustAnchor ta = cpbr.getTrustAnchor();</span>
<span class="fc" id="L1033">                PublicKey prevKey2 = ta.getCAPublicKey();</span>
<span class="pc bpc" id="L1034" title="1 of 2 branches missed.">                if (prevKey2 == null) {</span>
<span class="fc" id="L1035">                    prevKey2 = ta.getTrustedCert().getPublicKey();</span>
                }
<span class="fc" id="L1037">                boolean signFlag = true;</span>
<span class="fc" id="L1038">                List&lt;? extends Certificate&gt; cpList =</span>
<span class="fc" id="L1039">                    cpbr.getCertPath().getCertificates();</span>
                try {
<span class="fc bfc" id="L1041" title="All 2 branches covered.">                    for (int i = cpList.size()-1; i &gt;= 0; i-- ) {</span>
<span class="fc" id="L1042">                        X509Certificate cert = (X509Certificate)cpList.get(i);</span>

<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">                        if (debug != null) {</span>
<span class="nc" id="L1045">                            debug.println(&quot;RevocationChecker.buildToNewKey()&quot;</span>
                                          + &quot; index &quot; + i + &quot; checking &quot;
                                          + cert);
                        }
<span class="fc" id="L1049">                        checkCRLs(cert, prevKey2, signFlag, true,</span>
                                  stackedCerts, newAnchors);
<span class="fc" id="L1051">                        signFlag = certCanSignCrl(cert);</span>
<span class="fc" id="L1052">                        prevKey2 = cert.getPublicKey();</span>
                    }
<span class="nc" id="L1054">                } catch (CertPathValidatorException cpve) {</span>
                    // ignore it and try to get another key
<span class="nc" id="L1056">                    badKeys.add(cpbr.getPublicKey());</span>
<span class="nc" id="L1057">                    continue;</span>
<span class="fc" id="L1058">                }</span>

<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L1061">                    debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +</span>
<span class="nc" id="L1062">                                  &quot; got key &quot; + cpbr.getPublicKey());</span>
                }
                // Now check revocation on the current cert using that key.
                // If it doesn't check out, try to find a different key.
                // And if we can't find a key, then return false.
<span class="fc" id="L1067">                PublicKey newKey = cpbr.getPublicKey();</span>
                try {
<span class="fc" id="L1069">                    checkCRLs(currCert, newKey, true, false, null,</span>
<span class="fc" id="L1070">                              params.trustAnchors());</span>
                    // If that passed, the cert is OK!
<span class="fc" id="L1072">                    return;</span>
<span class="nc" id="L1073">                } catch (CertPathValidatorException cpve) {</span>
                    // If it is revoked, rethrow exception
<span class="nc bnc" id="L1075" title="All 2 branches missed.">                    if (cpve.getReason() == BasicReason.REVOKED) {</span>
<span class="nc" id="L1076">                        throw cpve;</span>
                    }
                    // Otherwise, ignore the exception and
                    // try to get another key.
                }
<span class="nc" id="L1081">                badKeys.add(newKey);</span>
<span class="nc" id="L1082">            } catch (InvalidAlgorithmParameterException iape) {</span>
<span class="nc" id="L1083">                throw new CertPathValidatorException(iape);</span>
<span class="nc" id="L1084">            } catch (CertPathBuilderException cpbe) {</span>
<span class="nc" id="L1085">                throw new CertPathValidatorException</span>
                    (&quot;Could not determine revocation status&quot;, null, null,
                     -1, BasicReason.UNDETERMINED_REVOCATION_STATUS);
<span class="nc" id="L1088">            }</span>
        }
    }

    @Override
    public RevocationChecker clone() {
<span class="nc" id="L1094">        RevocationChecker copy = (RevocationChecker)super.clone();</span>
        // we don't deep-copy the exceptions, but that is ok because they
        // are never modified after they are instantiated
<span class="nc" id="L1097">        copy.softFailExceptions = new LinkedList&lt;&gt;(softFailExceptions);</span>
<span class="nc" id="L1098">        return copy;</span>
    }

    /*
     * This inner class extends the X509CertSelector to add an additional
     * check to make sure the subject public key isn't on a particular list.
     * This class is used by buildToNewKey() to make sure the builder doesn't
     * end up with a CertPath to a public key that has already been rejected.
     */
    private static class RejectKeySelector extends X509CertSelector {
        private final Set&lt;PublicKey&gt; badKeySet;

        /**
         * Creates a new &lt;code&gt;RejectKeySelector&lt;/code&gt;.
         *
         * @param badPublicKeys a &lt;code&gt;Set&lt;/code&gt; of
         *                      &lt;code&gt;PublicKey&lt;/code&gt;s that
         *                      should be rejected (or &lt;code&gt;null&lt;/code&gt;
         *                      if no such check should be done)
         */
<span class="fc" id="L1118">        RejectKeySelector(Set&lt;PublicKey&gt; badPublicKeys) {</span>
<span class="fc" id="L1119">            this.badKeySet = badPublicKeys;</span>
<span class="fc" id="L1120">        }</span>

        /**
         * Decides whether a &lt;code&gt;Certificate&lt;/code&gt; should be selected.
         *
         * @param cert the &lt;code&gt;Certificate&lt;/code&gt; to be checked
         * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Certificate&lt;/code&gt; should be
         *         selected, &lt;code&gt;false&lt;/code&gt; otherwise
         */
        @Override
        public boolean match(Certificate cert) {
<span class="fc bfc" id="L1131" title="All 2 branches covered.">            if (!super.match(cert))</span>
<span class="fc" id="L1132">                return(false);</span>

<span class="fc bfc" id="L1134" title="All 2 branches covered.">            if (badKeySet.contains(cert.getPublicKey())) {</span>
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">                if (debug != null)</span>
<span class="nc" id="L1136">                    debug.println(&quot;RejectKeySelector.match: bad key&quot;);</span>
<span class="fc" id="L1137">                return false;</span>
            }

<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">            if (debug != null)</span>
<span class="nc" id="L1141">                debug.println(&quot;RejectKeySelector.match: returning true&quot;);</span>
<span class="fc" id="L1142">            return true;</span>
        }

        /**
         * Return a printable representation of the &lt;code&gt;CertSelector&lt;/code&gt;.
         *
         * @return a &lt;code&gt;String&lt;/code&gt; describing the contents of the
         *         &lt;code&gt;CertSelector&lt;/code&gt;
         */
        @Override
        public String toString() {
<span class="nc" id="L1153">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1154">            sb.append(&quot;RejectKeySelector: [\n&quot;);</span>
<span class="nc" id="L1155">            sb.append(super.toString());</span>
<span class="nc" id="L1156">            sb.append(badKeySet);</span>
<span class="nc" id="L1157">            sb.append(&quot;]&quot;);</span>
<span class="nc" id="L1158">            return sb.toString();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>